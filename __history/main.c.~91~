/* TITLE BLOCK
  
   filename : main.c
   purpose  : main application file
   hardware : 323-01A 
   PIC      : PIC18F87K22
 
*/

#include <E:\Program Files (x86)\PICWHD\Devices\18F87K22.h>

#CASE
#device PASS_STRINGS=IN_RAM

//#define DEBUG_MODE  // comment-out for stand-alone operation

#ifdef DEBUG_MODE
   #device ICD=TRUE
#endif

#ifdef DEBUG_MODE
   #FUSES MCLR
#else
   #FUSES NOMCLR
#endif

#device adc=12

// *** Watchdog Timer *** //
// WDT resolution    = 4ms
// WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768
// WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec
#FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec.
#FUSES WDT_SW                    // WDT is s/w controlled

#FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O
#FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode)
#FUSES PUT                       // Power Up Timer
#FUSES NOBROWNOUT                // No brownout reset
#FUSES NOEXTADDRSFT

#FUSES NOPROTECT                 //Code not protected from reading
#FUSES NOCPD                     //No EE protection
#FUSES STVREN                    //Stack full/underflow will cause reset
#FUSES NOWRT                     //Program memory not write protected

#FUSES NOEBTR                    //Memory not protected from table reads
#FUSES NOWRTD                    //Data EEPROM not write protected
#FUSES NOWRTC                    //configuration not registers write protected

#FUSES BBSIZ2K                   //2K words Boot Block size
#FUSES NOCPB                     //No Boot Block code protection
#FUSES NOWRTB                    //Boot block not write protected
#FUSES NOEBTRB                   //Boot block not protected from table reads

#FUSES RTCOSC_INT

#use delay(internal=64mhz)

// check tris statements in init_hw.c
#use fast_io(A)
#use fast_io(B)
#use fast_io(C)
#use fast_io(D)
#use fast_io(E)
#use fast_io(F)
#use fast_io(G)
#use fast_io(H)
#use fast_io(J)

#use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors)
#use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors)

// --------------------------------------------------------------------//
#define VERSION         "V2.120"
// --------------------------------------------------------------------//
#include "includes.h"   
// --------------------------------------------------------------------//


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/
void resetUserInput(void)
{
   storeUserInput = FALSE;
   DISABLE_UART_RCV_TIMER;

   disable_interrupts(INT_RDA);

   delay_ms(5);

   bufferTailIndex = 0;
   bufferHeadIndex = 0;
   bufferReadIndex = 0;
   uartRcvTimeout = FALSE;
   memset ((void *)inputBuf, 0, MEX_USER_INPUT_BUFFER_SIZE);
   uart_data_rcvd = FALSE;
   rtc_alarm = FALSE;
   storeUserInput = TRUE;
   set_usart_int();
   enable_interrupts(INT_RDA);

   return;
}


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/
void changeState(state_machine_t newState)
{
   resetUserInput();
   previousSubGenState = currentSubGenState;
   currentSubGenState = newState;

   return;
}


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/
int8 getUserInputStatus(void)
{
   char *inputBufPtr = &inputBuf[bufferReadIndex];
   int8 tempTailIndex = bufferTailIndex;
   rcvd_serial_data_t result = NO_DATA;

   if (uartRcvTimeout)
   {
      result = RCV_TIMEOUT;
   }
   else
   {
      while (bufferReadIndex < tempTailIndex)
      {
         if (TRUE == com_echo)
         {
            fputc((*inputBufPtr), COM_A);
         }

         if (CARRIAGE_RET == (*inputBufPtr))
         {
            result = COMPLETE_DATA;
            break;
         }
         else
         {
            result = PARTIAL_DATA;
         }

         bufferReadIndex++;
      }
   }

   return (result);
}


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/
int8 getSerialBufferCount(void)
{
   int8 head = 0;
   int8 tail = 0;

   int8 bufferCount = 0;

   tail = bufferTailIndex;
   head = bufferHeadIndex;

   if (tail < head)
   {
      bufferCount = (MEX_USER_INPUT_BUFFER_SIZE - head) + 1;
      bufferCount += tail;
   }
   else
   {
      bufferCount = tail - head;
   }

   return (bufferCount);
}


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/
void adjustSerialBufferReadIndex(int8 adjustIndex)
{
   int8 tempIndex;
   int8 tempHeadIndex;
   int8 tempTailIndex;

   tempHeadIndex = bufferHeadIndex;
   tempTailIndex = bufferTailIndex;
   tempIndex = 0;

   if (MEX_USER_INPUT_BUFFER_SIZE < (tempHeadIndex + adjustIndex) )
   {
      tempIndex = MEX_USER_INPUT_BUFFER_SIZE - (tempHeadIndex - 1);
      tempHeadIndex = 0;
   }

   adjustIndex -= tempIndex;
   tempHeadIndex += adjustIndex;

   bufferHeadIndex = tempHeadIndex;

   if (tempHeadIndex > tempTailIndex)
   {
      bufferTailIndex = tempHeadIndex;
   }

   return;
}


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/
void processDisplayPromptOnBoot(rcvd_serial_data_t userCmndResponse)
{
   if (FALSE == nv_cmd_mode)
   {
      fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n");
      changeState(USER_INPUT_ON_BOOT_STATE);
      SET_UART_RCV_TIMER(FIVE_SEC_DELAY_TIMEOUT);
   }
   else
   {
      changeState(CMND_PROMPT_STATE);
   }

   return;
}


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/
void processUserInputOnBoot(rcvd_serial_data_t userCmndResponse)
{
   int8 index;
   char *inputBufPtr = &inputBuf[bufferHeadIndex];

   switch (userCmndResponse)
   {
      case RCV_TIMEOUT:
      {
         resetUserInput();
         if(MaxSamples == TRUE)
         {
            arg = 0;
            commandZ();
         }
         else
         {
            fprintf(COM_A, "Aligning valve and homing syringe in 5s\r\n");
            delay_ms(5000);
            recovery();
            fprintf(COM_A, "Returning to Logging Mode\r\n");
            changeState(AUTO_SAMPLE_STATE);
         }
         break;
      }

      case PARTIAL_DATA:
      case COMPLETE_DATA:
      {
         for (index = 0; index < bufferReadIndex; index++)
         {
            if (ESCAPE == (*inputBufPtr))
            {
               changeState(CMND_PROMPT_STATE);
               break;
            }
            inputBufPtr++;
         }
         break;
      }

      default:
      {
         break;
      }
   }

   return;
}


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/
void processCmndPromptDisplay(rcvd_serial_data_t userCmndResponse)
{

   nv_cmd_mode = TRUE;
   write8(ADDR_CMD_MODE, nv_cmd_mode);

   sprintf(event_str, ",command prompt\r\n");
   record_event();
   cmd_set=0; // user

   fputs("@CMD>", COM_A);
   changeState(CMND_RESPOND_STATE);

   return;
}


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/
void processUserCmndResponse(rcvd_serial_data_t userCmndResponse)
{
   // cmd_set - 0=user, 1=full
   int8 bufferSize;
   int8 rcvdByte;
   int1 validData = TRUE;
   arg = 0;
   char *inputBufPtr = &inputBuf[bufferHeadIndex];

   cmd = *inputBufPtr++;

   switch (userCmndResponse)
   {
      case PARTIAL_DATA:
      {
         if ('?' == rcvdByte)
         {
//            if (TRUE == busy_status)
//               printMsg("?@BSY\r\n");
//            else
//               printMsg("@RDY\r\n");
         }
         break;
      }

      case COMPLETE_DATA:
      {
         if (0 == cmd_set)
         {
            if (!isamong (rcvdByte, USERCMDLIST))
            {
               validData = FALSE;
            }
         }
         else
         {
            if (!isamong (rcvdByte, FULLCMDLIST))
            {
               validData = FALSE;
            }
         }

         bufferSize = bufferReadIndex - bufferHeadIndex;
         if ( (0 >= bufferSize) || (FALSE == validData) )
         {
            fputs("@INV", COM_A);
            changeState(CMND_PROMPT_STATE);
         }
         else
         {
            while (bufferSize--)
            {
               rcvdByte = *inputBufPtr++;
               if (CARRIAGE_RET != rcvdByte)
               {
                  if ( (ZERO <= rcvdByte) && (NINE >= rcvdByte) )
                  {
                     arg = (arg * 10) + (rcvdByte - ZERO);
                  }
                  else
                  {
                     fputs("@ARG ", COM_A);             // bad input
                     changeState(CMND_PROMPT_STATE);
                  }
               }
               else
               {
                  break;
               }
            }
         }

         select_cmd();
         break;
      }

      case RCV_TIMEOUT:
      default:
      {
         break;
      }
   }

   return;
}


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/
wakeup_reason_t processWakeup(rcvd_serial_data_t userCmndResponse)
{
   wakeup_reason_t wakeupReason = RTC_ALRAM_WAKE;
   int8 bufferSize;
   int8 buffer_index;
   int8 dollarSignCount = 0;
   char *inputBufPtr = &inputBuf[bufferReadIndex];

   blip();

   if (TRUE == uart_data_rcvd)
   {
      uart_data_rcvd = FALSE;
      SET_UART_RCV_TIMER(SIX_SEC_DELAY_TIMEOUT);

      while (TRUE)
      {
         userCmndResponse = getUserInputStatus();
         if ( (PARTIAL_DATA == userCmndResponse) || (COMPLETE_DATA == userCmndResponse) )
         {
            bufferSize = bufferTailIndex - bufferReadIndex;
            if (bufferSize)
            {
               for (buffer_index = 0; buffer_index <= bufferSize; buffer_index++)
               {
                  if (DOLLAR_SIGN == inputBufPtr++)
                  {
                     dollarSignCount++;
                  }

                  bufferReadIndex += 1;
               }
            }
         }
         else
         {
            if (RCV_TIMEOUT == userCmndResponse)
            {
               wakeupReason = FALSE_WAKE;
               break;
            }
         }

         if (TRUE == rtc_alarm)
         {
            break;
         }
         
         if (2 <= dollarSignCount)
         {
            wakeupReason = RCVD_CMND_WAKE;
            break;
         }

         delay_us(1);
      }
   }

   return (wakeupReason);
}


/* 
/*****************************************************************************/
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*                                                                           */ 
/*****************************************************************************/

void main()
{
   rcvd_serial_data_t userCmndResponse = NO_DATA;
   state_machine_t currentSubGenState = USER_PROMPT_ON_BOOT_STATE;
   state_machine_t previousSubGenState = USER_PROMPT_ON_BOOT_STATE;

   disable_interrupts(GLOBAL);
   
   setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 );
   setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 );
   
   setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096);
   setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0);

   // TIMER 0 is being used to service the WTD
   setup_timer_0(T0_INTERNAL|T0_DIV_256);
   /* sets the internal clock as source and prescale 256. 
      At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every
      6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used.
      Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec
      Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec
      .. pre-load with 3036 to get exact 1.0000 sec value
   */
   
   // TIMER 1 is used to extinguish the LED
   setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);
   /* sets the internal clock as source and prescale 4. 
      At 10Mhz timer0 will increment every 0.4us in this setup and overflows every
      104.8 ms. Timer1 is 16-bit.
      Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec
      Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec
      Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec
   */   
   
   setup_stepper_pwm();  // Uses TIMER 2
   
   // TIMER 3 is used for stepper motor intervals
   setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer
   
   // TIMER 4 is use for serial time-outs. 8-bit timer.
   setup_timer_4(T4_DIV_BY_4, T4_MID_VAL, 16);
   
   setup_comparator(NC_NC_NC_NC);
   
   setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz
          
   ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0
   enable_interrupts(INT_EXT);
   
   start_heartbeat();
   
   enable_interrupts(GLOBAL);

   init_hardware();
   motor_sleep_rdy();

   init_nv_vars();
   get_step_vars();
   init_aws();
   
   blink();
   
   //Add for TCP/IP interface
   //delay_ms(15000);
   
   signon();

   RTC_read();
   RTC_last_power();
   RTC_reset_HT();  
   RTC_read();    
   RTC_read_flags();

   if(nv_sd_status>0)
      fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status);
   
   init_rtc(); // This is the FAT RTC
   sd_status = init_sdcard();
   if(sd_status>0)
      printMsg("@SD_\r\n");

   reset_event();

   if(m_error[0] > 0 || m_error[1] > 0)
      msg_mer();  

   if (m_comp[0]==FALSE)
   {
      e_port[0]=0;
      write16(ADDR_E1_PORT,0);
      fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]);
   }

   if (m_comp[1]==FALSE)
   {
      m_lin_pos[1]=-1;
      write16(ADDR_M2_LIN_POS, -1);
      fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]);
   }

   resetUserInput();


   while (TRUE)
   {
      userCmndResponse = getUserInputStatus();
      switch (currentSubGenState)
      {
         case USER_PROMPT_ON_BOOT_STATE:
         {
            processDisplayPromptOnBoot(userCmndResponse);
            break;
         }

         case USER_INPUT_ON_BOOT_STATE:
         {
            processUserInputOnBoot(userCmndResponse);
            break;
         }

         case CMND_PROMPT_STATE:
         {
            processCmndPromptDisplay(userCmndResponse);
            break;
         }

         case CMND_RESPOND_STATE:
         {
            processUserCmndResponse(userCmndResponse);
            break;
         }

         case SLEEP_STATE:
         {
            clear_interrupt(INT_EXT);        // RTC
            resetUserInput();
            set_usart_int();
            kill_wd();
            sleep();
            delay_cycles(1); // pre-fetched NOP
            break;
         }
         case AUTO_SAMPLE_STATE:
         {
            user_quit = auto_sample_ready();
            reset_cpu();
            break;
         }

      }
   }

}

