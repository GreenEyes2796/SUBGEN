CCS PCH C Compiler, Version 5.071d, 1               03-Jul-17 15:15
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   113404 bytes (87%)
                           Largest free fragment is 17306
               RAM used:   2144 (56%) at main() level
                           2609 (68%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1AFB6
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0ED4
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0EFE
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   18F4
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E00
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   16D6
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   174C
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E64
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
....................              /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 3F,40
00668:  DATA 42,53
0066A:  DATA 59,0D
0066C:  DATA 0A,00
0066E:  DATA 40,52
00670:  DATA 44,59
00672:  DATA 0D,0A
00674:  DATA 00,00
00676:  DATA 40,46
00678:  DATA 53,3A
0067A:  DATA 44,69
0067C:  DATA 73,63
0067E:  DATA 6F,76
00680:  DATA 65,72
00682:  DATA 79,0D
00684:  DATA 0A,00
00686:  DATA 40,46
00688:  DATA 53,3A
0068A:  DATA 55,6E
0068C:  DATA 61,62
0068E:  DATA 6C,65
00690:  DATA 20,74
00692:  DATA 6F,20
00694:  DATA 70,75
00696:  DATA 74,20
00698:  DATA 63,61
0069A:  DATA 72,64
0069C:  DATA 20,69
0069E:  DATA 6E,20
006A0:  DATA 69,64
006A2:  DATA 6C,65
006A4:  DATA 20,73
006A6:  DATA 74,61
006A8:  DATA 74,65
006AA:  DATA 2C,20
006AC:  DATA 72,65
006AE:  DATA 73,70
006B0:  DATA 6F,6E
006B2:  DATA 73,65
006B4:  DATA 20,3D
006B6:  DATA 20,25
006B8:  DATA 30,32
006BA:  DATA 78,0D
006BC:  DATA 0A,00
006BE:  DATA 40,46
006C0:  DATA 53,3A
006C2:  DATA 43,61
006C4:  DATA 72,64
006C6:  DATA 20,69
006C8:  DATA 64,6C
006CA:  DATA 65,2C
006CC:  DATA 20,72
006CE:  DATA 65,73
006D0:  DATA 70,6F
006D2:  DATA 6E,73
006D4:  DATA 65,20
006D6:  DATA 3D,20
006D8:  DATA 25,30
006DA:  DATA 32,78
006DC:  DATA 0D,0A
006DE:  DATA 00,00
006E0:  DATA 40,46
006E2:  DATA 53,3A
006E4:  DATA 52,65
006E6:  DATA 73,70
006E8:  DATA 6F,6E
006EA:  DATA 73,65
006EC:  DATA 20,74
006EE:  DATA 6F,20
006F0:  DATA 53,44
006F2:  DATA 20,76
006F4:  DATA 65,72
006F6:  DATA 20,32
006F8:  DATA 20,74
006FA:  DATA 65,73
006FC:  DATA 74,20
006FE:  DATA 43,4D
00700:  DATA 44,38
00702:  DATA 20,3D
00704:  DATA 20,25
00706:  DATA 78,0D
00708:  DATA 0A,00
0070A:  DATA 40,46
0070C:  DATA 53,3A
0070E:  DATA 50,6F
00710:  DATA 73,73
00712:  DATA 69,62
00714:  DATA 6C,65
00716:  DATA 20,53
00718:  DATA 44,76
0071A:  DATA 32,20
0071C:  DATA 63,61
0071E:  DATA 72,64
00720:  DATA 20,64
00722:  DATA 65,74
00724:  DATA 65,63
00726:  DATA 74,65
00728:  DATA 64,0D
0072A:  DATA 0A,00
0072C:  DATA 40,46
0072E:  DATA 53,3A
00730:  DATA 56,6F
00732:  DATA 6C,74
00734:  DATA 61,67
00736:  DATA 65,20
00738:  DATA 72,61
0073A:  DATA 6E,67
0073C:  DATA 65,20
0073E:  DATA 63,68
00740:  DATA 65,63
00742:  DATA 6B,2C
00744:  DATA 20,6F
00746:  DATA 63,72
00748:  DATA 20,3D
0074A:  DATA 20,25
0074C:  DATA 30,32
0074E:  DATA 78,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,0D
0075C:  DATA 0A,00
0075E:  DATA 40,46
00760:  DATA 53,3A
00762:  DATA 43,61
00764:  DATA 72,64
00766:  DATA 20,56
00768:  DATA 64,64
0076A:  DATA 20,72
0076C:  DATA 61,6E
0076E:  DATA 67,65
00770:  DATA 20,3D
00772:  DATA 20,32
00774:  DATA 2E,37
00776:  DATA 2D,33
00778:  DATA 2E,36
0077A:  DATA 20,76
0077C:  DATA 6F,6C
0077E:  DATA 74,73
00780:  DATA 0D,0A
00782:  DATA 00,00
00784:  DATA 40,46
00786:  DATA 53,3A
00788:  DATA 53,65
0078A:  DATA 6E,64
0078C:  DATA 69,6E
0078E:  DATA 67,20
00790:  DATA 41,43
00792:  DATA 4D,44
00794:  DATA 34,31
00796:  DATA 20,63
00798:  DATA 6F,6D
0079A:  DATA 6D,61
0079C:  DATA 6E,64
0079E:  DATA 20,74
007A0:  DATA 6F,20
007A2:  DATA 53,44
007A4:  DATA 20,76
007A6:  DATA 65,72
007A8:  DATA 20,32
007AA:  DATA 20,63
007AC:  DATA 61,72
007AE:  DATA 64,0D
007B0:  DATA 0A,00
007B2:  DATA 40,46
007B4:  DATA 53,3A
007B6:  DATA 52,65
007B8:  DATA 73,70
007BA:  DATA 6F,6E
007BC:  DATA 73,65
007BE:  DATA 20,66
007C0:  DATA 72,6F
007C2:  DATA 6D,20
007C4:  DATA 73,65
007C6:  DATA 6E,64
007C8:  DATA 69,6E
007CA:  DATA 67,20
007CC:  DATA 41,43
007CE:  DATA 4D,44
007D0:  DATA 34,31
007D2:  DATA 20,3D
007D4:  DATA 20,25
007D6:  DATA 30,32
007D8:  DATA 78,2C
007DA:  DATA 20,54
007DC:  DATA 69,6D
007DE:  DATA 65,72
007E0:  DATA 20,3D
007E2:  DATA 20,25
007E4:  DATA 6C,75
007E6:  DATA 0D,0A
007E8:  DATA 00,00
007EA:  DATA 40,46
007EC:  DATA 53,3A
007EE:  DATA 52,65
007F0:  DATA 73,70
007F2:  DATA 6F,6E
007F4:  DATA 73,65
007F6:  DATA 20,74
007F8:  DATA 6F,20
007FA:  DATA 43,4D
007FC:  DATA 44,35
007FE:  DATA 38,20
00800:  DATA 3D,20
00802:  DATA 25,78
00804:  DATA 0D,0A
00806:  DATA 00,00
00808:  DATA 40,46
0080A:  DATA 53,3A
0080C:  DATA 53,65
0080E:  DATA 6E,74
00810:  DATA 20,43
00812:  DATA 4D,44
00814:  DATA 20,35
00816:  DATA 38,2C
00818:  DATA 20,54
0081A:  DATA 69,6D
0081C:  DATA 65,72
0081E:  DATA 20,76
00820:  DATA 61,6C
00822:  DATA 75,65
00824:  DATA 20,3D
00826:  DATA 20,25
00828:  DATA 6C,75
0082A:  DATA 2C,20
0082C:  DATA 6F,63
0082E:  DATA 72,20
00830:  DATA 3D,20
00832:  DATA 25,30
00834:  DATA 32,78
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 0D,0A
00844:  DATA 00,00
00846:  DATA 40,46
00848:  DATA 53,3A
0084A:  DATA 43,61
0084C:  DATA 72,64
0084E:  DATA 20,43
00850:  DATA 41,4E
00852:  DATA 4E,4F
00854:  DATA 54,20
00856:  DATA 77,6F
00858:  DATA 72,6B
0085A:  DATA 20,56
0085C:  DATA 64,64
0085E:  DATA 20,72
00860:  DATA 61,6E
00862:  DATA 67,65
00864:  DATA 20,6F
00866:  DATA 66,20
00868:  DATA 32,2E
0086A:  DATA 37,2D
0086C:  DATA 33,2E
0086E:  DATA 36,20
00870:  DATA 76,6F
00872:  DATA 6C,74
00874:  DATA 73,0D
00876:  DATA 0A,00
00878:  DATA 40,46
0087A:  DATA 53,3A
0087C:  DATA 4E,6F
0087E:  DATA 74,20
00880:  DATA 61,6E
00882:  DATA 20,53
00884:  DATA 44,53
00886:  DATA 43,20
00888:  DATA 6F,72
0088A:  DATA 20,53
0088C:  DATA 44,48
0088E:  DATA 43,20
00890:  DATA 63,61
00892:  DATA 72,64
00894:  DATA 2C,20
00896:  DATA 54,65
00898:  DATA 73,74
0089A:  DATA 69,6E
0089C:  DATA 67,20
0089E:  DATA 66,6F
008A0:  DATA 72,20
008A2:  DATA 53,44
008A4:  DATA 20,56
008A6:  DATA 65,72
008A8:  DATA 31,20
008AA:  DATA 6F,72
008AC:  DATA 20,4D
008AE:  DATA 4D,43
008B0:  DATA 20,43
008B2:  DATA 61,72
008B4:  DATA 64,0D
008B6:  DATA 0A,00
008B8:  DATA 40,46
008BA:  DATA 53,3A
008BC:  DATA 52,65
008BE:  DATA 73,70
008C0:  DATA 6F,6E
008C2:  DATA 73,65
008C4:  DATA 20,66
008C6:  DATA 72,6F
008C8:  DATA 6D,20
008CA:  DATA 47,4F
008CC:  DATA 5F,49
008CE:  DATA 44,4C
008D0:  DATA 45,20
008D2:  DATA 3D,20
008D4:  DATA 25,30
008D6:  DATA 32,78
008D8:  DATA 0D,0A
008DA:  DATA 00,00
008DC:  DATA 40,46
008DE:  DATA 53,3A
008E0:  DATA 52,65
008E2:  DATA 73,70
008E4:  DATA 6F,6E
008E6:  DATA 73,65
008E8:  DATA 20,66
008EA:  DATA 72,6F
008EC:  DATA 6D,20
008EE:  DATA 53,44
008F0:  DATA 5F,43
008F2:  DATA 4D,44
008F4:  DATA 5F,53
008F6:  DATA 45,4E
008F8:  DATA 44,5F
008FA:  DATA 4F,50
008FC:  DATA 5F,43
008FE:  DATA 4F,4E
00900:  DATA 44,20
00902:  DATA 3D,20
00904:  DATA 25,30
00906:  DATA 32,78
00908:  DATA 2C,20
0090A:  DATA 54,69
0090C:  DATA 6D,65
0090E:  DATA 72,20
00910:  DATA 3D,20
00912:  DATA 25,6C
00914:  DATA 75,0D
00916:  DATA 0A,00
00918:  DATA 40,46
0091A:  DATA 53,3A
0091C:  DATA 41,74
0091E:  DATA 74,65
00920:  DATA 6D,70
00922:  DATA 74,69
00924:  DATA 6E,67
00926:  DATA 20,53
00928:  DATA 44,76
0092A:  DATA 31,20
0092C:  DATA 76,65
0092E:  DATA 72,73
00930:  DATA 75,73
00932:  DATA 20,4D
00934:  DATA 4D,43
00936:  DATA 20,49
00938:  DATA 44,2C
0093A:  DATA 20,52
0093C:  DATA 65,73
0093E:  DATA 70,6F
00940:  DATA 6E,73
00942:  DATA 65,20
00944:  DATA 66,72
00946:  DATA 6F,6D
00948:  DATA 20,53
0094A:  DATA 44,5F
0094C:  DATA 43,4D
0094E:  DATA 44,5F
00950:  DATA 41,50
00952:  DATA 50,4C
00954:  DATA 5F,43
00956:  DATA 4D,44
00958:  DATA 20,3D
0095A:  DATA 20,25
0095C:  DATA 30,32
0095E:  DATA 78,0D
00960:  DATA 0A,00
00962:  DATA 40,46
00964:  DATA 53,3A
00966:  DATA 49,6E
00968:  DATA 76,61
0096A:  DATA 6C,69
0096C:  DATA 64,20
0096E:  DATA 72,65
00970:  DATA 73,70
00972:  DATA 6F,6E
00974:  DATA 73,65
00976:  DATA 20,74
00978:  DATA 6F,20
0097A:  DATA 53,44
0097C:  DATA 5F,41
0097E:  DATA 43,4D
00980:  DATA 44,34
00982:  DATA 31,2C
00984:  DATA 20,72
00986:  DATA 65,73
00988:  DATA 70,6F
0098A:  DATA 6E,73
0098C:  DATA 65,20
0098E:  DATA 3D,20
00990:  DATA 25,30
00992:  DATA 32,58
00994:  DATA 2C,20
00996:  DATA 72,65
00998:  DATA 69,6E
0099A:  DATA 69,74
0099C:  DATA 69,61
0099E:  DATA 6C,69
009A0:  DATA 7A,69
009A2:  DATA 6E,67
009A4:  DATA 20,61
009A6:  DATA 73,20
009A8:  DATA 4D,4D
009AA:  DATA 43,0D
009AC:  DATA 0A,00
009AE:  DATA 40,46
009B0:  DATA 53,3A
009B2:  DATA 46,61
009B4:  DATA 69,6C
009B6:  DATA 65,64
009B8:  DATA 20,74
009BA:  DATA 6F,20
009BC:  DATA 69,6E
009BE:  DATA 69,74
009C0:  DATA 69,61
009C2:  DATA 6C,69
009C4:  DATA 7A,65
009C6:  DATA 20,61
009C8:  DATA 73,20
009CA:  DATA 4D,4D
009CC:  DATA 43,2C
009CE:  DATA 20,72
009D0:  DATA 65,73
009D2:  DATA 70,6F
009D4:  DATA 6E,73
009D6:  DATA 65,20
009D8:  DATA 3D,20
009DA:  DATA 25,30
009DC:  DATA 32,58
009DE:  DATA 2C,20
009E0:  DATA 65,78
009E2:  DATA 69,74
009E4:  DATA 69,6E
009E6:  DATA 67,0D
009E8:  DATA 0A,00
009EA:  DATA 40,46
009EC:  DATA 53,3A
009EE:  DATA 43,61
009F0:  DATA 72,64
009F2:  DATA 20,66
009F4:  DATA 61,69
009F6:  DATA 6C,65
009F8:  DATA 64,20
009FA:  DATA 74,6F
009FC:  DATA 20,72
009FE:  DATA 65,73
00A00:  DATA 70,6F
00A02:  DATA 6E,64
00A04:  DATA 20,63
00A06:  DATA 6F,72
00A08:  DATA 72,65
00A0A:  DATA 63,6C
00A0C:  DATA 79,20
00A0E:  DATA 61,66
00A10:  DATA 74,65
00A12:  DATA 72,20
00A14:  DATA 53,44
00A16:  DATA 5F,43
00A18:  DATA 4D,44
00A1A:  DATA 5F,53
00A1C:  DATA 45,4E
00A1E:  DATA 44,5F
00A20:  DATA 4F,50
00A22:  DATA 5F,43
00A24:  DATA 4F,4E
00A26:  DATA 44,2C
00A28:  DATA 20,72
00A2A:  DATA 65,73
00A2C:  DATA 70,6F
00A2E:  DATA 6E,73
00A30:  DATA 65,20
00A32:  DATA 3D,20
00A34:  DATA 25,30
00A36:  DATA 32,58
00A38:  DATA 2C,20
00A3A:  DATA 54,69
00A3C:  DATA 6D,65
00A3E:  DATA 72,20
00A40:  DATA 3D,20
00A42:  DATA 25,6C
00A44:  DATA 75,0D
00A46:  DATA 0A,00
00A48:  DATA 40,46
00A4A:  DATA 53,3A
00A4C:  DATA 53,65
00A4E:  DATA 74,74
00A50:  DATA 69,6E
00A52:  DATA 67,20
00A54:  DATA 62,6C
00A56:  DATA 6F,63
00A58:  DATA 6B,20
00A5A:  DATA 6C,65
00A5C:  DATA 6E,67
00A5E:  DATA 74,68
00A60:  DATA 0D,0A
00A62:  DATA 00,00
00A64:  DATA 40,46
00A66:  DATA 53,3A
00A68:  DATA 45,72
00A6A:  DATA 72,6F
00A6C:  DATA 72,20
00A6E:  DATA 73,65
00A70:  DATA 74,74
00A72:  DATA 69,6E
00A74:  DATA 67,20
00A76:  DATA 62,6C
00A78:  DATA 6F,63
00A7A:  DATA 6B,20
00A7C:  DATA 6C,65
00A7E:  DATA 6E,67
00A80:  DATA 74,68
00A82:  DATA 2C,20
00A84:  DATA 72,65
00A86:  DATA 73,70
00A88:  DATA 6F,6E
00A8A:  DATA 73,65
00A8C:  DATA 20,3D
00A8E:  DATA 20,25
00A90:  DATA 30,32
00A92:  DATA 78,2C
00A94:  DATA 20,74
00A96:  DATA 69,6D
00A98:  DATA 65,72
00A9A:  DATA 20,3D
00A9C:  DATA 20,25
00A9E:  DATA 6C,75
00AA0:  DATA 0D,0A
00AA2:  DATA 00,00
00AA4:  DATA 40,46
00AA6:  DATA 53,3A
00AA8:  DATA 43,61
00AAA:  DATA 72,64
00AAC:  DATA 20,54
00AAE:  DATA 79,70
00AB0:  DATA 65,20
00AB2:  DATA 44,69
00AB4:  DATA 73,63
00AB6:  DATA 6F,76
00AB8:  DATA 65,72
00ABA:  DATA 79,20
00ABC:  DATA 45,72
00ABE:  DATA 72,6F
00AC0:  DATA 72,0D
00AC2:  DATA 0A,00
00AC4:  DATA 40,46
00AC6:  DATA 53,3A
00AC8:  DATA 4D,4D
00ACA:  DATA 43,20
00ACC:  DATA 43,61
00ACE:  DATA 72,64
00AD0:  DATA 20,66
00AD2:  DATA 6F,75
00AD4:  DATA 6E,64
00AD6:  DATA 0D,0A
00AD8:  DATA 00,00
00ADA:  DATA 40,46
00ADC:  DATA 53,3A
00ADE:  DATA 53,44
00AE0:  DATA 76,31
00AE2:  DATA 20,43
00AE4:  DATA 61,72
00AE6:  DATA 64,20
00AE8:  DATA 66,6F
00AEA:  DATA 75,6E
00AEC:  DATA 64,0D
00AEE:  DATA 0A,00
00AF0:  DATA 40,46
00AF2:  DATA 53,3A
00AF4:  DATA 53,44
00AF6:  DATA 53,43
00AF8:  DATA 20,43
00AFA:  DATA 61,72
00AFC:  DATA 64,20
00AFE:  DATA 66,6F
00B00:  DATA 75,6E
00B02:  DATA 64,0D
00B04:  DATA 0A,00
00B06:  DATA 40,46
00B08:  DATA 53,3A
00B0A:  DATA 53,44
00B0C:  DATA 48,43
00B0E:  DATA 20,43
00B10:  DATA 61,72
00B12:  DATA 64,20
00B14:  DATA 66,6F
00B16:  DATA 75,6E
00B18:  DATA 64,0D
00B1A:  DATA 0A,00
00B1C:  DATA 40,46
00B1E:  DATA 53,3A
00B20:  DATA 43,61
00B22:  DATA 72,64
00B24:  DATA 20,54
00B26:  DATA 79,70
00B28:  DATA 65,20
00B2A:  DATA 44,69
00B2C:  DATA 73,63
00B2E:  DATA 6F,76
00B30:  DATA 65,72
00B32:  DATA 79,20
00B34:  DATA 45,72
00B36:  DATA 72,6F
00B38:  DATA 72,2C
00B3A:  DATA 20,43
00B3C:  DATA 61,72
00B3E:  DATA 64,20
00B40:  DATA 3D,20
00B42:  DATA 25,30
00B44:  DATA 32,58
00B46:  DATA 0D,0A
00B48:  DATA 00,00
00B4A:  DATA 40,46
00B4C:  DATA 53,3A
00B4E:  DATA 43,61
00B50:  DATA 72,64
00B52:  DATA 20,72
00B54:  DATA 65,73
00B56:  DATA 65,74
00B58:  DATA 20,73
00B5A:  DATA 75,63
00B5C:  DATA 63,65
00B5E:  DATA 73,73
00B60:  DATA 20,2D
00B62:  DATA 20,43
00B64:  DATA 6D,64
00B66:  DATA 20,74
00B68:  DATA 6F,20
00B6A:  DATA 52,65
00B6C:  DATA 61,64
00B6E:  DATA 79,20
00B70:  DATA 63,6F
00B72:  DATA 75,6E
00B74:  DATA 74,20
00B76:  DATA 3D,20
00B78:  DATA 25,6C
00B7A:  DATA 75,0D
00B7C:  DATA 0A,00
00B7E:  DATA 40,46
00B80:  DATA 53,3A
00B82:  DATA 53,50
00B84:  DATA 49,20
00B86:  DATA 62,75
00B88:  DATA 73,20
00B8A:  DATA 73,70
00B8C:  DATA 65,65
00B8E:  DATA 64,20
00B90:  DATA 73,65
00B92:  DATA 74,20
00B94:  DATA 74,6F
00B96:  DATA 20,68
00B98:  DATA 69,67
00B9A:  DATA 68,0D
00B9C:  DATA 0A,00
00B9E:  DATA 40,46
00BA0:  DATA 53,3A
00BA2:  DATA 43,61
00BA4:  DATA 72,64
00BA6:  DATA 20,61
00BA8:  DATA 63,74
00BAA:  DATA 69,76
00BAC:  DATA 61,74
00BAE:  DATA 65,20
00BB0:  DATA 66,61
00BB2:  DATA 69,6C
00BB4:  DATA 75,72
00BB6:  DATA 65,2C
00BB8:  DATA 20,72
00BBA:  DATA 65,73
00BBC:  DATA 70,6F
00BBE:  DATA 6E,73
00BC0:  DATA 65,20
00BC2:  DATA 3D,20
00BC4:  DATA 25,30
00BC6:  DATA 32,58
00BC8:  DATA 2C,20
00BCA:  DATA 54,69
00BCC:  DATA 6D,65
00BCE:  DATA 72,20
00BD0:  DATA 3D,20
00BD2:  DATA 25,6C
00BD4:  DATA 75,0D
00BD6:  DATA 0A,00
00BD8:  DATA 40,46
00BDA:  DATA 53,3A
00BDC:  DATA 43,61
00BDE:  DATA 72,64
00BE0:  DATA 20,61
00BE2:  DATA 63,74
00BE4:  DATA 69,76
00BE6:  DATA 61,74
00BE8:  DATA 65,20
00BEA:  DATA 73,75
00BEC:  DATA 63,63
00BEE:  DATA 65,73
00BF0:  DATA 73,20
00BF2:  DATA 6F,6E
00BF4:  DATA 20,61
00BF6:  DATA 74,74
00BF8:  DATA 65,6D
00BFA:  DATA 70,74
00BFC:  DATA 20,25
00BFE:  DATA 6C,75
00C00:  DATA 0D,0A
00C02:  DATA 00,00
00C04:  DATA 46,41
00C06:  DATA 54,20
00C08:  DATA 61,74
00C0A:  DATA 20,73
00C0C:  DATA 65,63
00C0E:  DATA 74,6F
00C10:  DATA 72,20
00C12:  DATA 30,0D
00C14:  DATA 0A,00
00C16:  DATA 54,59
00C18:  DATA 50,45
00C1A:  DATA 20,63
00C1C:  DATA 6F,6D
00C1E:  DATA 6D,61
00C20:  DATA 6E,64
00C22:  DATA 20,45
00C24:  DATA 52,52
00C26:  DATA 4F,52
00C28:  DATA 0D,0A
00C2A:  DATA 00,00
00C2C:  DATA 40,46
00C2E:  DATA 53,3A
00C30:  DATA 20,25
00C32:  DATA 73,0D
00C34:  DATA 0A,00
00C36:  DATA 40,46
00C38:  DATA 53,3A
00C3A:  DATA 20,25
00C3C:  DATA 73,0D
00C3E:  DATA 0A,00
00C40:  DATA 2A,2A
00C42:  DATA 20,40
00C44:  DATA 46,53
00C46:  DATA 3A,20
00C48:  DATA 45,52
00C4A:  DATA 52,4F
00C4C:  DATA 52,0D
00C4E:  DATA 0A,00
00C50:  DATA 20,20
00C52:  DATA 20,4E
00C54:  DATA 6F,45
00C56:  DATA 72,72
00C58:  DATA 6F,72
00C5A:  DATA 0D,0A
00C5C:  DATA 00,00
00C5E:  DATA 20,20
00C60:  DATA 20,4D
00C62:  DATA 65,64
00C64:  DATA 69,61
00C66:  DATA 20,4E
00C68:  DATA 6F,74
00C6A:  DATA 20,52
00C6C:  DATA 65,61
00C6E:  DATA 64,79
00C70:  DATA 0D,0A
00C72:  DATA 00,00
00C74:  DATA 20,20
00C76:  DATA 20,46
00C78:  DATA 69,6C
00C7A:  DATA 65,20
00C7C:  DATA 4E,6F
00C7E:  DATA 74,20
00C80:  DATA 46,6F
00C82:  DATA 75,6E
00C84:  DATA 64,0D
00C86:  DATA 0A,00
00C88:  DATA 20,20
00C8A:  DATA 20,49
00C8C:  DATA 6E,76
00C8E:  DATA 61,6C
00C90:  DATA 69,64
00C92:  DATA 20,50
00C94:  DATA 61,74
00C96:  DATA 68,0D
00C98:  DATA 0A,00
00C9A:  DATA 20,20
00C9C:  DATA 20,49
00C9E:  DATA 6E,76
00CA0:  DATA 61,6C
00CA2:  DATA 69,64
00CA4:  DATA 20,4E
00CA6:  DATA 61,6D
00CA8:  DATA 65,0D
00CAA:  DATA 0A,00
00CAC:  DATA 20,20
00CAE:  DATA 20,41
00CB0:  DATA 63,63
00CB2:  DATA 65,73
00CB4:  DATA 73,20
00CB6:  DATA 44,65
00CB8:  DATA 6E,69
00CBA:  DATA 65,64
00CBC:  DATA 0D,0A
00CBE:  DATA 00,00
00CC0:  DATA 20,20
00CC2:  DATA 20,44
00CC4:  DATA 69,73
00CC6:  DATA 6B,20
00CC8:  DATA 46,75
00CCA:  DATA 6C,6C
00CCC:  DATA 0D,0A
00CCE:  DATA 00,00
00CD0:  DATA 20,20
00CD2:  DATA 20,52
00CD4:  DATA 65,61
00CD6:  DATA 64,2F
00CD8:  DATA 57,72
00CDA:  DATA 69,74
00CDC:  DATA 65,20
00CDE:  DATA 45,72
00CE0:  DATA 72,6F
00CE2:  DATA 72,0D
00CE4:  DATA 0A,00
00CE6:  DATA 20,20
00CE8:  DATA 20,49
00CEA:  DATA 6E,63
00CEC:  DATA 6F,72
00CEE:  DATA 72,65
00CF0:  DATA 63,74
00CF2:  DATA 20,4D
00CF4:  DATA 65,64
00CF6:  DATA 69,61
00CF8:  DATA 20,43
00CFA:  DATA 68,61
00CFC:  DATA 6E,67
00CFE:  DATA 65,0D
00D00:  DATA 0A,00
00D02:  DATA 20,20
00D04:  DATA 20,57
00D06:  DATA 72,69
00D08:  DATA 74,65
00D0A:  DATA 20,50
00D0C:  DATA 72,6F
00D0E:  DATA 74,65
00D10:  DATA 63,74
00D12:  DATA 65,64
00D14:  DATA 0D,0A
00D16:  DATA 00,00
00D18:  DATA 20,20
00D1A:  DATA 20,4E
00D1C:  DATA 6F,74
00D1E:  DATA 20,45
00D20:  DATA 6E,61
00D22:  DATA 62,6C
00D24:  DATA 65,64
00D26:  DATA 0D,0A
00D28:  DATA 00,00
00D2A:  DATA 20,20
00D2C:  DATA 20,4E
00D2E:  DATA 6F,20
00D30:  DATA 46,69
00D32:  DATA 6C,65
00D34:  DATA 20,53
00D36:  DATA 79,73
00D38:  DATA 74,65
00D3A:  DATA 6D,0D
00D3C:  DATA 0A,00
00D3E:  DATA 61,70
00D40:  DATA 70,65
00D42:  DATA 6E,64
00D44:  DATA 3A,20
00D46:  DATA 46,53
00D48:  DATA 20,45
00D4A:  DATA 52,52
00D4C:  DATA 4F,52
00D4E:  DATA 20,6F
00D50:  DATA 6E,20
00D52:  DATA 66,69
00D54:  DATA 6C,65
00D56:  DATA 5F,6F
00D58:  DATA 70,65
00D5A:  DATA 6E,0D
00D5C:  DATA 0A,00
00D5E:  DATA 40,46
00D60:  DATA 53,3A
00D62:  DATA 57,72
00D64:  DATA 69,74
00D66:  DATA 69,6E
00D68:  DATA 67,0D
00D6A:  DATA 0A,5B
00D6C:  DATA 25,73
00D6E:  DATA 5D,0D
00D70:  DATA 0A,00
00D72:  DATA 40,46
00D74:  DATA 53,3A
00D76:  DATA 45,52
00D78:  DATA 52,4F
00D7A:  DATA 52,5B
00D7C:  DATA 61,70
00D7E:  DATA 70,65
00D80:  DATA 6E,64
00D82:  DATA 5D,0D
00D84:  DATA 0A,00
00D86:  DATA 40,46
00D88:  DATA 53,3A
00D8A:  DATA 43,6C
00D8C:  DATA 6F,73
00D8E:  DATA 69,6E
00D90:  DATA 67,0D
00D92:  DATA 0A,00
00D94:  DATA 40,52
00D96:  DATA 54,43
00D98:  DATA 3A,25
00D9A:  DATA 30,32
00D9C:  DATA 75,2F
00D9E:  DATA 00,00
00DA0:  DATA 40,52
00DA2:  DATA 54,43
00DA4:  DATA 3A,25
00DA6:  DATA 30,32
00DA8:  DATA 75,2F
00DAA:  DATA 00,00
00DAC:  DATA 40,41
00DAE:  DATA 4C,4D
00DB0:  DATA 3A,25
00DB2:  DATA 30,32
00DB4:  DATA 75,2F
00DB6:  DATA 00,00
00DB8:  DATA 40,41
00DBA:  DATA 4C,4D
00DBC:  DATA 3A,25
00DBE:  DATA 30,32
00DC0:  DATA 75,2F
00DC2:  DATA 00,00
00DC4:  DATA 40,41
00DC6:  DATA 4C,4D
00DC8:  DATA 0D,0A
00DCA:  DATA 00,00
*
00E3A:  TBLRD*+
00E3C:  MOVF   FF5,F
00E3E:  BZ    0E62
00E40:  MOVFF  FF6,A10
00E44:  MOVFF  FF7,A11
00E48:  MOVFF  FF8,A12
00E4C:  MOVF   FF5,W
00E4E:  BTFSS  F9E.4
00E50:  BRA    0E4E
00E52:  MOVWF  FAD
00E54:  MOVFF  A10,FF6
00E58:  MOVFF  A11,FF7
00E5C:  MOVFF  A12,FF8
00E60:  BRA    0E3A
00E62:  RETURN 0
*
00EC4:  DATA 3F,40
00EC6:  DATA 42,53
00EC8:  DATA 59,0D
00ECA:  DATA 0A,00
00ECC:  DATA 40,52
00ECE:  DATA 44,59
00ED0:  DATA 0D,0A
00ED2:  DATA 00,00
*
00F14:  DATA 40,5B
00F16:  DATA 4F,5D
00F18:  DATA 0D,0A
00F1A:  DATA 00,00
00F1C:  DATA 40,43
00F1E:  DATA 4D,44
00F20:  DATA 20,74
00F22:  DATA 6F,6F
00F24:  DATA 20,6C
00F26:  DATA 6F,6E
00F28:  DATA 67,0D
00F2A:  DATA 0A,00
00F2C:  DATA 40,5B
00F2E:  DATA 43,5D
00F30:  DATA 0D,0A
00F32:  DATA 00,00
00F34:  DATA 40,53
00F36:  DATA 4C,45
00F38:  DATA 45,50
00F3A:  DATA 0D,0A
00F3C:  DATA 00,00
00F3E:  DATA 40,4D
00F40:  DATA 45,52
00F42:  DATA 2C,25
00F44:  DATA 4C,75
00F46:  DATA 2C,25
00F48:  DATA 4C,75
00F4A:  DATA 0D,0A
00F4C:  DATA 00,00
00F4E:  DATA 6D,3A
00F50:  DATA 25,75
00F52:  DATA 2C,25
00F54:  DATA 75,20
00F56:  DATA 63,3A
00F58:  DATA 25,4C
00F5A:  DATA 75,2C
00F5C:  DATA 25,4C
00F5E:  DATA 75,2C
00F60:  DATA 25,4C
00F62:  DATA 75,0D
00F64:  DATA 0A,00
00F66:  MOVLB  A
00F68:  MOVF   x1B,W
00F6A:  CLRF   01
00F6C:  SUBWF  x1A,W
00F6E:  BC    0F76
00F70:  MOVFF  A1A,00
00F74:  BRA    0F8E
00F76:  CLRF   00
00F78:  MOVLW  08
00F7A:  MOVWF  x1C
00F7C:  RLCF   x1A,F
00F7E:  RLCF   00,F
00F80:  MOVF   x1B,W
00F82:  SUBWF  00,W
00F84:  BTFSC  FD8.0
00F86:  MOVWF  00
00F88:  RLCF   01,F
00F8A:  DECFSZ x1C,F
00F8C:  BRA    0F7C
00F8E:  MOVLB  0
00F90:  RETURN 0
00F92:  MOVF   01,W
00F94:  MOVFF  A18,A1A
00F98:  MOVLW  64
00F9A:  MOVLB  A
00F9C:  MOVWF  x1B
00F9E:  MOVLB  0
00FA0:  RCALL  0F66
00FA2:  MOVFF  00,A18
00FA6:  MOVF   01,W
00FA8:  MOVLW  30
00FAA:  BNZ   0FBC
00FAC:  MOVLB  A
00FAE:  BTFSS  x19.1
00FB0:  BRA    0FCE
00FB2:  BTFSC  x19.3
00FB4:  BRA    0FCE
00FB6:  BTFSC  x19.4
00FB8:  MOVLW  20
00FBA:  BRA    0FC4
00FBC:  MOVLB  A
00FBE:  BCF    x19.3
00FC0:  BCF    x19.4
00FC2:  BSF    x19.0
00FC4:  ADDWF  01,F
00FC6:  MOVF   01,W
00FC8:  BTFSS  F9E.4
00FCA:  BRA    0FC8
00FCC:  MOVWF  FAD
00FCE:  MOVFF  A18,A1A
00FD2:  MOVLW  0A
00FD4:  MOVWF  x1B
00FD6:  MOVLB  0
00FD8:  RCALL  0F66
00FDA:  MOVFF  00,A18
00FDE:  MOVF   01,W
00FE0:  MOVLW  30
00FE2:  BNZ   0FF4
00FE4:  MOVLB  A
00FE6:  BTFSC  x19.3
00FE8:  BRA    1000
00FEA:  BTFSS  x19.0
00FEC:  BRA    1000
00FEE:  BTFSC  x19.4
00FF0:  MOVLW  20
00FF2:  MOVLB  0
00FF4:  ADDWF  01,F
00FF6:  MOVF   01,W
00FF8:  BTFSS  F9E.4
00FFA:  BRA    0FF8
00FFC:  MOVWF  FAD
00FFE:  MOVLB  A
01000:  MOVLW  30
01002:  ADDWF  x18,F
01004:  MOVF   x18,W
01006:  BTFSS  F9E.4
01008:  BRA    1006
0100A:  MOVWF  FAD
0100C:  MOVLB  0
0100E:  RETURN 0
01010:  TBLRD*+
01012:  MOVFF  FF6,A19
01016:  MOVFF  FF7,A1A
0101A:  MOVFF  FF8,A1B
0101E:  MOVF   FF5,W
01020:  BTFSS  F9E.4
01022:  BRA    1020
01024:  MOVWF  FAD
01026:  MOVFF  A19,FF6
0102A:  MOVFF  A1A,FF7
0102E:  MOVFF  A1B,FF8
01032:  MOVLB  A
01034:  DECFSZ x18,F
01036:  BRA    103A
01038:  BRA    103E
0103A:  MOVLB  0
0103C:  BRA    1010
0103E:  MOVLB  0
01040:  RETURN 0
01042:  BTFSC  FD8.1
01044:  BRA    104E
01046:  MOVLW  0A
01048:  MOVWF  FEA
0104A:  MOVLW  2C
0104C:  MOVWF  FE9
0104E:  CLRF   00
01050:  CLRF   01
01052:  CLRF   02
01054:  CLRF   03
01056:  MOVLB  A
01058:  CLRF   x2C
0105A:  CLRF   x2D
0105C:  CLRF   x2E
0105E:  CLRF   x2F
01060:  MOVF   x2B,W
01062:  IORWF  x2A,W
01064:  IORWF  x29,W
01066:  IORWF  x28,W
01068:  BZ    10C2
0106A:  MOVLW  20
0106C:  MOVWF  x30
0106E:  BCF    FD8.0
01070:  RLCF   x24,F
01072:  RLCF   x25,F
01074:  RLCF   x26,F
01076:  RLCF   x27,F
01078:  RLCF   x2C,F
0107A:  RLCF   x2D,F
0107C:  RLCF   x2E,F
0107E:  RLCF   x2F,F
01080:  MOVF   x2B,W
01082:  SUBWF  x2F,W
01084:  BNZ   1096
01086:  MOVF   x2A,W
01088:  SUBWF  x2E,W
0108A:  BNZ   1096
0108C:  MOVF   x29,W
0108E:  SUBWF  x2D,W
01090:  BNZ   1096
01092:  MOVF   x28,W
01094:  SUBWF  x2C,W
01096:  BNC   10B6
01098:  MOVF   x28,W
0109A:  SUBWF  x2C,F
0109C:  MOVF   x29,W
0109E:  BTFSS  FD8.0
010A0:  INCFSZ x29,W
010A2:  SUBWF  x2D,F
010A4:  MOVF   x2A,W
010A6:  BTFSS  FD8.0
010A8:  INCFSZ x2A,W
010AA:  SUBWF  x2E,F
010AC:  MOVF   x2B,W
010AE:  BTFSS  FD8.0
010B0:  INCFSZ x2B,W
010B2:  SUBWF  x2F,F
010B4:  BSF    FD8.0
010B6:  RLCF   00,F
010B8:  RLCF   01,F
010BA:  RLCF   02,F
010BC:  RLCF   03,F
010BE:  DECFSZ x30,F
010C0:  BRA    106E
010C2:  MOVFF  A2C,FEF
010C6:  MOVFF  A2D,FEC
010CA:  MOVFF  A2E,FEC
010CE:  MOVFF  A2F,FEC
010D2:  MOVLB  0
010D4:  RETURN 0
010D6:  MOVF   FE9,W
010D8:  MOVLB  A
010DA:  MOVWF  x1C
010DC:  MOVLW  3B
010DE:  MOVWF  x23
010E0:  MOVLW  9A
010E2:  MOVWF  x22
010E4:  MOVLW  CA
010E6:  MOVWF  x21
010E8:  CLRF   x20
010EA:  MOVLW  0A
010EC:  MOVWF  x1E
010EE:  BSF    FD8.1
010F0:  MOVLW  0A
010F2:  MOVWF  FEA
010F4:  MOVLW  18
010F6:  MOVWF  FE9
010F8:  MOVFF  A1B,A27
010FC:  MOVFF  A1A,A26
01100:  MOVFF  A19,A25
01104:  MOVFF  A18,A24
01108:  MOVFF  A23,A2B
0110C:  MOVFF  A22,A2A
01110:  MOVFF  A21,A29
01114:  MOVFF  A20,A28
01118:  MOVLB  0
0111A:  RCALL  1042
0111C:  MOVF   01,W
0111E:  MOVF   00,F
01120:  BNZ   1148
01122:  MOVLB  A
01124:  MOVF   x1E,W
01126:  XORLW  01
01128:  BTFSS  FD8.2
0112A:  BRA    1130
0112C:  MOVLB  0
0112E:  BRA    1148
01130:  MOVF   x1C,W
01132:  BZ    114C
01134:  ANDLW  0F
01136:  SUBWF  x1E,W
01138:  BZ    113C
0113A:  BC    1158
0113C:  BTFSC  x1C.7
0113E:  BRA    1158
01140:  BTFSC  x1C.6
01142:  BRA    114C
01144:  MOVLW  20
01146:  BRA    114E
01148:  MOVLB  A
0114A:  CLRF   x1C
0114C:  MOVLW  30
0114E:  ADDWF  00,F
01150:  MOVF   00,W
01152:  BTFSS  F9E.4
01154:  BRA    1152
01156:  MOVWF  FAD
01158:  BCF    FD8.1
0115A:  MOVFF  A23,A27
0115E:  MOVFF  A22,A26
01162:  MOVFF  A21,A25
01166:  MOVFF  A20,A24
0116A:  CLRF   x2B
0116C:  CLRF   x2A
0116E:  CLRF   x29
01170:  MOVLW  0A
01172:  MOVWF  x28
01174:  MOVLB  0
01176:  RCALL  1042
01178:  MOVFF  03,A23
0117C:  MOVFF  02,A22
01180:  MOVFF  01,A21
01184:  MOVFF  00,A20
01188:  MOVLB  A
0118A:  DECFSZ x1E,F
0118C:  BRA    10EE
0118E:  MOVLB  0
01190:  RETURN 0
01192:  MOVFF  FEA,A20
01196:  MOVFF  FE9,A1F
0119A:  MOVLB  A
0119C:  SWAPF  x19,W
0119E:  IORLW  F0
011A0:  MOVWF  x1B
011A2:  ADDWF  x1B,F
011A4:  ADDLW  E2
011A6:  MOVWF  x1C
011A8:  ADDLW  32
011AA:  MOVWF  x1E
011AC:  MOVF   x19,W
011AE:  ANDLW  0F
011B0:  ADDWF  x1C,F
011B2:  ADDWF  x1C,F
011B4:  ADDWF  x1E,F
011B6:  ADDLW  E9
011B8:  MOVWF  x1D
011BA:  ADDWF  x1D,F
011BC:  ADDWF  x1D,F
011BE:  SWAPF  x18,W
011C0:  ANDLW  0F
011C2:  ADDWF  x1D,F
011C4:  ADDWF  x1E,F
011C6:  RLCF   x1D,F
011C8:  RLCF   x1E,F
011CA:  COMF   x1E,F
011CC:  RLCF   x1E,F
011CE:  MOVF   x18,W
011D0:  ANDLW  0F
011D2:  ADDWF  x1E,F
011D4:  RLCF   x1B,F
011D6:  MOVLW  07
011D8:  MOVWF  x1A
011DA:  MOVLW  0A
011DC:  DECF   x1D,F
011DE:  ADDWF  x1E,F
011E0:  BNC   11DC
011E2:  DECF   x1C,F
011E4:  ADDWF  x1D,F
011E6:  BNC   11E2
011E8:  DECF   x1B,F
011EA:  ADDWF  x1C,F
011EC:  BNC   11E8
011EE:  DECF   x1A,F
011F0:  ADDWF  x1B,F
011F2:  BNC   11EE
011F4:  MOVLW  0A
011F6:  MOVWF  FEA
011F8:  MOVLW  1A
011FA:  MOVWF  FE9
011FC:  MOVLW  07
011FE:  ANDWF  x1F,W
01200:  BCF    x1F.6
01202:  ADDWF  FE9,F
01204:  MOVLW  00
01206:  ADDWFC FEA,F
01208:  MOVF   FE9,W
0120A:  SUBLW  1E
0120C:  BNZ   1216
0120E:  MOVF   FEA,W
01210:  SUBLW  0A
01212:  BNZ   1216
01214:  BSF    x1F.6
01216:  MOVF   FEF,W
01218:  MOVWF  00
0121A:  BNZ   122C
0121C:  BTFSC  x1F.6
0121E:  BRA    122C
01220:  BTFSC  x1F.4
01222:  BRA    123C
01224:  BTFSC  x1F.3
01226:  BRA    122C
01228:  MOVLW  20
0122A:  BRA    1232
0122C:  BSF    x1F.3
0122E:  BCF    x1F.4
01230:  MOVLW  30
01232:  ADDWF  00,F
01234:  MOVF   00,W
01236:  BTFSS  F9E.4
01238:  BRA    1236
0123A:  MOVWF  FAD
0123C:  MOVF   FEE,W
0123E:  BTFSS  x1F.6
01240:  BRA    1208
01242:  MOVLB  0
01244:  RETURN 0
*
01A4A:  DATA 40,4C
01A4C:  DATA 50,43
01A4E:  DATA 2C,25
01A50:  DATA 4C,75
01A52:  DATA 2C,25
01A54:  DATA 4C,64
01A56:  DATA 0D,0A
01A58:  DATA 00,00
01A5A:  DATA 40,4D
01A5C:  DATA 4D,45
01A5E:  DATA 2C,25
01A60:  DATA 75,2C
01A62:  DATA 25,4C
01A64:  DATA 64,2C
01A66:  DATA 25,4C
01A68:  DATA 75,2C
01A6A:  DATA 25,4C
01A6C:  DATA 75,2C
01A6E:  DATA 25,4C
01A70:  DATA 64,2C
01A72:  DATA 25,4C
01A74:  DATA 64,0D
01A76:  DATA 0A,00
01A78:  DATA 56,41
01A7A:  DATA 4C,56
01A7C:  DATA 45,20
01A7E:  DATA 53,54
01A80:  DATA 4F,50
01A82:  DATA 20,25
01A84:  DATA 4C,75
01A86:  DATA 2C,25
01A88:  DATA 4C,75
01A8A:  DATA 0D,0A
01A8C:  DATA 00,00
01A8E:  DATA 69,6E
01A90:  DATA 64,3A
01A92:  DATA 25,75
01A94:  DATA 20,2F
01A96:  DATA 20,70
01A98:  DATA 68,61
01A9A:  DATA 3A,25
01A9C:  DATA 75,0D
01A9E:  DATA 0A,00
01AA0:  DATA 40,52
01AA2:  DATA 45,43
01AA4:  DATA 20,2D
01AA6:  DATA 20,68
01AA8:  DATA 6F,6D
01AAA:  DATA 69,6E
01AAC:  DATA 67,20
01AAE:  DATA 73,79
01AB0:  DATA 72,69
01AB2:  DATA 6E,67
01AB4:  DATA 65,20
01AB6:  DATA 61,6E
01AB8:  DATA 64,20
01ABA:  DATA 61,6C
01ABC:  DATA 69,67
01ABE:  DATA 6E,69
01AC0:  DATA 6E,67
01AC2:  DATA 20,76
01AC4:  DATA 61,6C
01AC6:  DATA 76,65
01AC8:  DATA 20,74
01ACA:  DATA 6F,20
01ACC:  DATA 70,6F
01ACE:  DATA 72,74
01AD0:  DATA 20,31
01AD2:  DATA 0D,0A
01AD4:  DATA 00,00
01AD6:  DATA 2C,73
01AD8:  DATA 65,72
01ADA:  DATA 69,61
01ADC:  DATA 6C,20
01ADE:  DATA 77,61
01AE0:  DATA 6B,65
01AE2:  DATA 2D,75
01AE4:  DATA 70,2C
01AE6:  DATA 53,44
01AE8:  DATA 20,69
01AEA:  DATA 6E,69
01AEC:  DATA 74,69
01AEE:  DATA 61,6C
01AF0:  DATA 69,7A
01AF2:  DATA 65,64
01AF4:  DATA 0D,0A
01AF6:  DATA 00,00
01AF8:  DATA 40,52
01AFA:  DATA 53,54
01AFC:  DATA 0D,0A
01AFE:  DATA 00,00
01B00:  DATA 40,57
01B02:  DATA 44,54
01B04:  DATA 0D,0A
01B06:  DATA 00,00
01B08:  DATA 2C,72
01B0A:  DATA 65,73
01B0C:  DATA 74,61
01B0E:  DATA 72,74
01B10:  DATA 20,63
01B12:  DATA 61,75
01B14:  DATA 73,65
01B16:  DATA 2C,57
01B18:  DATA 44,20
01B1A:  DATA 74,69
01B1C:  DATA 6D,65
01B1E:  DATA 2D,6F
01B20:  DATA 75,74
01B22:  DATA 0D,0A
01B24:  DATA 00,00
01B26:  DATA 40,57
01B28:  DATA 44,53
01B2A:  DATA 0D,0A
01B2C:  DATA 00,00
01B2E:  DATA 2C,72
01B30:  DATA 65,73
01B32:  DATA 74,61
01B34:  DATA 72,74
01B36:  DATA 20,63
01B38:  DATA 61,75
01B3A:  DATA 73,65
01B3C:  DATA 2C,57
01B3E:  DATA 44,20
01B40:  DATA 66,72
01B42:  DATA 6F,6D
01B44:  DATA 20,73
01B46:  DATA 6C,65
01B48:  DATA 65,70
01B4A:  DATA 0D,0A
01B4C:  DATA 00,00
01B4E:  DATA 40,4E
01B50:  DATA 50,55
01B52:  DATA 0D,0A
01B54:  DATA 00,00
01B56:  DATA 2C,69
01B58:  DATA 64,23
01B5A:  DATA 5B,25
01B5C:  DATA 4C,75
01B5E:  DATA 5D,2C
01B60:  DATA 70,6F
01B62:  DATA 77,65
01B64:  DATA 72,20
01B66:  DATA 61,70
01B68:  DATA 70,6C
01B6A:  DATA 69,65
01B6C:  DATA 64,2C
01B6E:  DATA 53,44
01B70:  DATA 20,69
01B72:  DATA 6E,69
01B74:  DATA 74,69
01B76:  DATA 61,6C
01B78:  DATA 69,7A
01B7A:  DATA 65,64
01B7C:  DATA 0D,0A
01B7E:  DATA 00,00
01B80:  DATA 40,52
01B82:  DATA 53,54
01B84:  DATA 0D,0A
01B86:  DATA 00,00
01B88:  DATA 2C,72
01B8A:  DATA 65,73
01B8C:  DATA 74,61
01B8E:  DATA 72,74
01B90:  DATA 20,63
01B92:  DATA 61,75
01B94:  DATA 73,65
01B96:  DATA 2C,72
01B98:  DATA 65,73
01B9A:  DATA 65,74
01B9C:  DATA 20,69
01B9E:  DATA 6E,73
01BA0:  DATA 74,72
01BA2:  DATA 75,63
01BA4:  DATA 74,69
01BA6:  DATA 6F,6E
01BA8:  DATA 0D,0A
01BAA:  DATA 00,00
01BAC:  DATA 40,42
01BAE:  DATA 4F,52
01BB0:  DATA 0D,0A
01BB2:  DATA 00,00
01BB4:  DATA 2C,72
01BB6:  DATA 65,73
01BB8:  DATA 74,61
01BBA:  DATA 72,74
01BBC:  DATA 20,63
01BBE:  DATA 61,75
01BC0:  DATA 73,65
01BC2:  DATA 2C,62
01BC4:  DATA 72,6F
01BC6:  DATA 77,6E
01BC8:  DATA 2D,6F
01BCA:  DATA 75,74
01BCC:  DATA 0D,0A
01BCE:  DATA 00,00
01BD0:  DATA 40,4D
01BD2:  DATA 52,53
01BD4:  DATA 0D,0A
01BD6:  DATA 00,00
01BD8:  DATA 2C,72
01BDA:  DATA 65,73
01BDC:  DATA 74,61
01BDE:  DATA 72,74
01BE0:  DATA 20,63
01BE2:  DATA 61,75
01BE4:  DATA 73,65
01BE6:  DATA 2C,4D
01BE8:  DATA 43,4C
01BEA:  DATA 52,20
01BEC:  DATA 66,72
01BEE:  DATA 6F,6D
01BF0:  DATA 20,73
01BF2:  DATA 6C,65
01BF4:  DATA 65,70
01BF6:  DATA 0D,0A
01BF8:  DATA 00,00
01BFA:  DATA 40,4D
01BFC:  DATA 52,52
01BFE:  DATA 0D,0A
01C00:  DATA 00,00
01C02:  DATA 2C,72
01C04:  DATA 65,73
01C06:  DATA 74,61
01C08:  DATA 72,74
01C0A:  DATA 20,63
01C0C:  DATA 61,75
01C0E:  DATA 73,65
01C10:  DATA 2C,4D
01C12:  DATA 43,4C
01C14:  DATA 52,20
01C16:  DATA 77,68
01C18:  DATA 65,6E
01C1A:  DATA 20,72
01C1C:  DATA 75,6E
01C1E:  DATA 6E,69
01C20:  DATA 6E,67
01C22:  DATA 0D,0A
01C24:  DATA 00,00
01C26:  DATA 4E,4F
01C28:  DATA 33,00
01C2A:  DATA 4E,4F
01C2C:  DATA 32,00
01C2E:  DATA 50,4F
01C30:  DATA 34,00
01C32:  DATA 4E,48
01C34:  DATA 34,00
01C36:  DATA 53,69
01C38:  DATA 4F,00
01C3A:  DATA 00,00
01C3C:  DATA 40,44
01C3E:  DATA 45,54
01C40:  DATA 5B,2F
01C42:  DATA 25,75
01C44:  DATA 5D,5B
01C46:  DATA 25,63
01C48:  DATA 5D,41
01C4A:  DATA 52,47
01C4C:  DATA 5B,25
01C4E:  DATA 4C,75
01C50:  DATA 5D,0D
01C52:  DATA 0A,00
01C54:  DATA 20,74
01C56:  DATA 69,6D
01C58:  DATA 65,2D
01C5A:  DATA 6F,75
01C5C:  DATA 74,00
01C5E:  DATA 20,64
01C60:  DATA 61,74
01C62:  DATA 61,20
01C64:  DATA 74,6F
01C66:  DATA 6F,20
01C68:  DATA 73,68
01C6A:  DATA 6F,72
01C6C:  DATA 74,00
01C6E:  DATA 20,64
01C70:  DATA 61,74
01C72:  DATA 61,20
01C74:  DATA 74,6F
01C76:  DATA 6F,20
01C78:  DATA 6C,6F
01C7A:  DATA 6E,67
01C7C:  DATA 00,00
01C7E:  DATA 2C,64
01C80:  DATA 65,74
01C82:  DATA 65,63
01C84:  DATA 74,6F
01C86:  DATA 72,5B
01C88:  DATA 25,73
01C8A:  DATA 5D,2C
01C8C:  DATA 6C,65
01C8E:  DATA 6E,5B
01C90:  DATA 25,75
01C92:  DATA 5D,00
01C94:  DATA 40,52
01C96:  DATA 54,59
01C98:  DATA 2C,25
01C9A:  DATA 75,0D
01C9C:  DATA 0A,00
01C9E:  DATA 2C,73
01CA0:  DATA 74,61
01CA2:  DATA 72,74
01CA4:  DATA 20,68
01CA6:  DATA 65,61
01CA8:  DATA 74,69
01CAA:  DATA 6E,67
01CAC:  DATA 2C,74
01CAE:  DATA 61,72
01CB0:  DATA 67,65
01CB2:  DATA 74,5B
01CB4:  DATA 25,4C
01CB6:  DATA 75,5D
01CB8:  DATA 2C,61
01CBA:  DATA 63,74
01CBC:  DATA 75,61
01CBE:  DATA 6C,5B
01CC0:  DATA 25,4C
01CC2:  DATA 75,5D
01CC4:  DATA 2C,72
01CC6:  DATA 65,61
01CC8:  DATA 64,69
01CCA:  DATA 6E,67
01CCC:  DATA 73,5B
01CCE:  DATA 25,4C
01CD0:  DATA 75,5D
01CD2:  DATA 0D,0A
01CD4:  DATA 00,00
01CD6:  DATA 2C,65
01CD8:  DATA 6E,64
01CDA:  DATA 20,68
01CDC:  DATA 65,61
01CDE:  DATA 74,69
01CE0:  DATA 6E,67
01CE2:  DATA 2C,74
01CE4:  DATA 61,72
01CE6:  DATA 67,65
01CE8:  DATA 74,5B
01CEA:  DATA 25,4C
01CEC:  DATA 75,5D
01CEE:  DATA 2C,61
01CF0:  DATA 63,74
01CF2:  DATA 75,61
01CF4:  DATA 6C,5B
01CF6:  DATA 25,4C
01CF8:  DATA 75,5D
01CFA:  DATA 2C,72
01CFC:  DATA 65,61
01CFE:  DATA 64,69
01D00:  DATA 6E,67
01D02:  DATA 73,5B
01D04:  DATA 25,4C
01D06:  DATA 75,5D
01D08:  DATA 0D,0A
01D0A:  DATA 00,00
01D0C:  DATA 4E,4F
01D0E:  DATA 33,00
01D10:  DATA 4E,4F
01D12:  DATA 32,00
01D14:  DATA 50,4F
01D16:  DATA 34,00
01D18:  DATA 4E,48
01D1A:  DATA 34,00
01D1C:  DATA 53,69
01D1E:  DATA 4F,00
01D20:  DATA 00,00
01D22:  DATA 40,44
01D24:  DATA 41,43
01D26:  DATA 2C,25
01D28:  DATA 4C,75
01D2A:  DATA 2C,25
01D2C:  DATA 4C,75
01D2E:  DATA 2C,00
01D30:  DATA 40,53
01D32:  DATA 41,52
01D34:  DATA 2C,31
01D36:  DATA 2C,25
01D38:  DATA 4C,75
01D3A:  DATA 2C,00
01D3C:  DATA 40,56
01D3E:  DATA 41,4C
01D40:  DATA 20,00
01D42:  DATA 40,56
01D44:  DATA 41,4C
01D46:  DATA 20,00
01D48:  DATA 40,56
01D4A:  DATA 41,4C
01D4C:  DATA 20,00
01D4E:  DATA 40,56
01D50:  DATA 41,4C
01D52:  DATA 20,00
01D54:  DATA 40,53
01D56:  DATA 4F,4C
01D58:  DATA 5B,2F
01D5A:  DATA 31,5D
01D5C:  DATA 5B,73
01D5E:  DATA 5D,5B
01D60:  DATA 25,4C
01D62:  DATA 75,5D
01D64:  DATA 0D,0A
01D66:  DATA 00,00
01D68:  DATA 2F,31
01D6A:  DATA 73,25
01D6C:  DATA 4C,75
01D6E:  DATA 0D,00
01D70:  DATA 40,53
01D72:  DATA 4F,4C
01D74:  DATA 5B,2F
01D76:  DATA 31,5D
01D78:  DATA 5B,63
01D7A:  DATA 5D,5B
01D7C:  DATA 25,75
01D7E:  DATA 5D,0D
01D80:  DATA 0A,00
01D82:  DATA 2F,31
01D84:  DATA 63,25
01D86:  DATA 75,0D
01D88:  DATA 00,00
01D8A:  DATA 2F,31
01D8C:  DATA 73,32
01D8E:  DATA 35,36
01D90:  DATA 0D,00
01D92:  DATA 28,49
01D94:  DATA 30,73
01D96:  DATA 29,2C
01D98:  DATA 25,4C
01D9A:  DATA 75,2C
01D9C:  DATA 28,49
01D9E:  DATA 31,73
01DA0:  DATA 29,2C
01DA2:  DATA 25,4C
01DA4:  DATA 75,2C
01DA6:  DATA 28,41
01DA8:  DATA 62,73
01DAA:  DATA 2D,73
01DAC:  DATA 29,2C
01DAE:  DATA 25,31
01DB0:  DATA 2E,34
01DB2:  DATA 67,2C
01DB4:  DATA 28,49
01DB6:  DATA 30,74
01DB8:  DATA 29,2C
01DBA:  DATA 25,4C
01DBC:  DATA 75,2C
01DBE:  DATA 28,49
01DC0:  DATA 31,74
01DC2:  DATA 29,2C
01DC4:  DATA 25,4C
01DC6:  DATA 75,2C
01DC8:  DATA 28,41
01DCA:  DATA 62,73
01DCC:  DATA 2D,74
01DCE:  DATA 29,2C
01DD0:  DATA 25,31
01DD2:  DATA 2E,34
01DD4:  DATA 67,2C
01DD6:  DATA 28,49
01DD8:  DATA 30,72
01DDA:  DATA 29,2C
01DDC:  DATA 25,4C
01DDE:  DATA 75,2C
01DE0:  DATA 28,49
01DE2:  DATA 31,72
01DE4:  DATA 29,2C
01DE6:  DATA 25,4C
01DE8:  DATA 75,2C
01DEA:  DATA 28,41
01DEC:  DATA 62,73
01DEE:  DATA 2D,72
01DF0:  DATA 29,2C
01DF2:  DATA 25,31
01DF4:  DATA 2E,34
01DF6:  DATA 67,00
01DF8:  DATA 40,41
01DFA:  DATA 62,73
01DFC:  DATA 2C,4E
01DFE:  DATA 4F,33
01E00:  DATA 2C,25
01E02:  DATA 73,0D
01E04:  DATA 0A,00
01E06:  DATA 28,49
01E08:  DATA 30,73
01E0A:  DATA 29,2C
01E0C:  DATA 25,4C
01E0E:  DATA 75,2C
01E10:  DATA 28,49
01E12:  DATA 31,73
01E14:  DATA 29,2C
01E16:  DATA 25,4C
01E18:  DATA 75,2C
01E1A:  DATA 28,41
01E1C:  DATA 62,73
01E1E:  DATA 2D,73
01E20:  DATA 29,2C
01E22:  DATA 25,31
01E24:  DATA 2E,34
01E26:  DATA 67,2C
01E28:  DATA 28,49
01E2A:  DATA 30,74
01E2C:  DATA 29,2C
01E2E:  DATA 25,4C
01E30:  DATA 75,2C
01E32:  DATA 28,49
01E34:  DATA 31,74
01E36:  DATA 29,2C
01E38:  DATA 25,4C
01E3A:  DATA 75,2C
01E3C:  DATA 28,41
01E3E:  DATA 62,73
01E40:  DATA 2D,74
01E42:  DATA 29,2C
01E44:  DATA 25,31
01E46:  DATA 2E,34
01E48:  DATA 67,2C
01E4A:  DATA 28,49
01E4C:  DATA 30,72
01E4E:  DATA 29,2C
01E50:  DATA 25,4C
01E52:  DATA 75,2C
01E54:  DATA 28,49
01E56:  DATA 31,72
01E58:  DATA 29,2C
01E5A:  DATA 25,4C
01E5C:  DATA 75,2C
01E5E:  DATA 28,41
01E60:  DATA 62,73
01E62:  DATA 2D,72
01E64:  DATA 29,2C
01E66:  DATA 25,31
01E68:  DATA 2E,34
01E6A:  DATA 67,00
01E6C:  DATA 40,41
01E6E:  DATA 62,73
01E70:  DATA 2C,4E
01E72:  DATA 4F,32
01E74:  DATA 2C,25
01E76:  DATA 73,0D
01E78:  DATA 0A,00
01E7A:  DATA 28,49
01E7C:  DATA 30,73
01E7E:  DATA 29,2C
01E80:  DATA 25,4C
01E82:  DATA 75,2C
01E84:  DATA 28,49
01E86:  DATA 31,73
01E88:  DATA 29,2C
01E8A:  DATA 25,4C
01E8C:  DATA 75,2C
01E8E:  DATA 28,41
01E90:  DATA 62,73
01E92:  DATA 2D,73
01E94:  DATA 29,2C
01E96:  DATA 25,31
01E98:  DATA 2E,34
01E9A:  DATA 67,2C
01E9C:  DATA 28,49
01E9E:  DATA 30,74
01EA0:  DATA 29,2C
01EA2:  DATA 25,4C
01EA4:  DATA 75,2C
01EA6:  DATA 28,49
01EA8:  DATA 31,74
01EAA:  DATA 29,2C
01EAC:  DATA 25,4C
01EAE:  DATA 75,2C
01EB0:  DATA 28,41
01EB2:  DATA 62,73
01EB4:  DATA 2D,74
01EB6:  DATA 29,2C
01EB8:  DATA 25,31
01EBA:  DATA 2E,34
01EBC:  DATA 67,2C
01EBE:  DATA 28,49
01EC0:  DATA 30,72
01EC2:  DATA 29,2C
01EC4:  DATA 25,4C
01EC6:  DATA 75,2C
01EC8:  DATA 28,49
01ECA:  DATA 31,72
01ECC:  DATA 29,2C
01ECE:  DATA 25,4C
01ED0:  DATA 75,2C
01ED2:  DATA 28,41
01ED4:  DATA 62,73
01ED6:  DATA 2D,72
01ED8:  DATA 29,2C
01EDA:  DATA 25,31
01EDC:  DATA 2E,34
01EDE:  DATA 67,00
01EE0:  DATA 40,41
01EE2:  DATA 62,73
01EE4:  DATA 2C,50
01EE6:  DATA 4F,34
01EE8:  DATA 2C,25
01EEA:  DATA 73,0D
01EEC:  DATA 0A,00
01EEE:  DATA 28,49
01EF0:  DATA 30,73
01EF2:  DATA 29,2C
01EF4:  DATA 25,4C
01EF6:  DATA 75,2C
01EF8:  DATA 28,49
01EFA:  DATA 31,73
01EFC:  DATA 29,2C
01EFE:  DATA 25,4C
01F00:  DATA 75,2C
01F02:  DATA 28,41
01F04:  DATA 62,73
01F06:  DATA 2D,73
01F08:  DATA 29,2C
01F0A:  DATA 25,31
01F0C:  DATA 2E,34
01F0E:  DATA 67,2C
01F10:  DATA 28,49
01F12:  DATA 30,74
01F14:  DATA 29,2C
01F16:  DATA 25,4C
01F18:  DATA 75,2C
01F1A:  DATA 28,49
01F1C:  DATA 31,74
01F1E:  DATA 29,2C
01F20:  DATA 25,4C
01F22:  DATA 75,2C
01F24:  DATA 28,41
01F26:  DATA 62,73
01F28:  DATA 2D,74
01F2A:  DATA 29,2C
01F2C:  DATA 25,31
01F2E:  DATA 2E,34
01F30:  DATA 67,2C
01F32:  DATA 28,49
01F34:  DATA 30,72
01F36:  DATA 29,2C
01F38:  DATA 25,4C
01F3A:  DATA 75,2C
01F3C:  DATA 28,49
01F3E:  DATA 31,72
01F40:  DATA 29,2C
01F42:  DATA 25,4C
01F44:  DATA 75,2C
01F46:  DATA 28,41
01F48:  DATA 62,73
01F4A:  DATA 2D,72
01F4C:  DATA 29,2C
01F4E:  DATA 25,31
01F50:  DATA 2E,34
01F52:  DATA 67,00
01F54:  DATA 40,41
01F56:  DATA 62,73
01F58:  DATA 2C,4E
01F5A:  DATA 48,34
01F5C:  DATA 2C,25
01F5E:  DATA 73,0D
01F60:  DATA 0A,00
01F62:  DATA 28,49
01F64:  DATA 30,73
01F66:  DATA 29,2C
01F68:  DATA 25,4C
01F6A:  DATA 75,2C
01F6C:  DATA 28,49
01F6E:  DATA 31,73
01F70:  DATA 29,2C
01F72:  DATA 25,4C
01F74:  DATA 75,2C
01F76:  DATA 28,41
01F78:  DATA 62,73
01F7A:  DATA 2D,73
01F7C:  DATA 29,2C
01F7E:  DATA 25,31
01F80:  DATA 2E,34
01F82:  DATA 67,2C
01F84:  DATA 28,49
01F86:  DATA 30,74
01F88:  DATA 29,2C
01F8A:  DATA 25,4C
01F8C:  DATA 75,2C
01F8E:  DATA 28,49
01F90:  DATA 31,74
01F92:  DATA 29,2C
01F94:  DATA 25,4C
01F96:  DATA 75,2C
01F98:  DATA 28,41
01F9A:  DATA 62,73
01F9C:  DATA 2D,74
01F9E:  DATA 29,2C
01FA0:  DATA 25,31
01FA2:  DATA 2E,34
01FA4:  DATA 67,2C
01FA6:  DATA 28,49
01FA8:  DATA 30,72
01FAA:  DATA 29,2C
01FAC:  DATA 25,4C
01FAE:  DATA 75,2C
01FB0:  DATA 28,49
01FB2:  DATA 31,72
01FB4:  DATA 29,2C
01FB6:  DATA 25,4C
01FB8:  DATA 75,2C
01FBA:  DATA 28,41
01FBC:  DATA 62,73
01FBE:  DATA 2D,72
01FC0:  DATA 29,2C
01FC2:  DATA 25,31
01FC4:  DATA 2E,34
01FC6:  DATA 67,00
01FC8:  DATA 40,41
01FCA:  DATA 42,53
01FCC:  DATA 2C,53
01FCE:  DATA 69,4F
01FD0:  DATA 2C,25
01FD2:  DATA 73,0D
01FD4:  DATA 0A,00
01FD6:  DATA 4E,4F
01FD8:  DATA 33,00
01FDA:  DATA 4E,4F
01FDC:  DATA 32,00
01FDE:  DATA 50,4F
01FE0:  DATA 34,00
01FE2:  DATA 4E,48
01FE4:  DATA 34,00
01FE6:  DATA 53,69
01FE8:  DATA 4F,00
01FEA:  DATA 00,00
01FEC:  DATA 28,6D
01FEE:  DATA 29,2C
01FF0:  DATA 25,33
01FF2:  DATA 2E,33
01FF4:  DATA 67,2C
01FF6:  DATA 28,63
01FF8:  DATA 29,2C
01FFA:  DATA 25,33
01FFC:  DATA 2E,33
01FFE:  DATA 67,00
02000:  DATA 28,43
02002:  DATA 73,29
02004:  DATA 2C,25
02006:  DATA 33,2E
02008:  DATA 33,67
0200A:  DATA 0D,0A
0200C:  DATA 00,00
0200E:  DATA 40,43
02010:  DATA 4F,4E
02012:  DATA 2C,4E
02014:  DATA 4F,33
02016:  DATA 2C,25
02018:  DATA 73,0D
0201A:  DATA 0A,00
0201C:  DATA 28,6D
0201E:  DATA 29,2C
02020:  DATA 25,33
02022:  DATA 2E,33
02024:  DATA 67,2C
02026:  DATA 28,63
02028:  DATA 29,2C
0202A:  DATA 25,33
0202C:  DATA 2E,33
0202E:  DATA 67,00
02030:  DATA 28,43
02032:  DATA 73,29
02034:  DATA 2C,25
02036:  DATA 33,2E
02038:  DATA 33,67
0203A:  DATA 0D,0A
0203C:  DATA 00,00
0203E:  DATA 40,43
02040:  DATA 4F,4E
02042:  DATA 2C,50
02044:  DATA 4F,34
02046:  DATA 2C,25
02048:  DATA 73,0D
0204A:  DATA 0A,00
0204C:  DATA 28,6D
0204E:  DATA 29,2C
02050:  DATA 25,33
02052:  DATA 2E,33
02054:  DATA 67,2C
02056:  DATA 28,63
02058:  DATA 29,2C
0205A:  DATA 25,33
0205C:  DATA 2E,33
0205E:  DATA 67,00
02060:  DATA 28,43
02062:  DATA 73,29
02064:  DATA 2C,25
02066:  DATA 33,2E
02068:  DATA 33,67
0206A:  DATA 0D,0A
0206C:  DATA 00,00
0206E:  DATA 40,43
02070:  DATA 4F,4E
02072:  DATA 2C,4E
02074:  DATA 48,34
02076:  DATA 2C,25
02078:  DATA 73,0D
0207A:  DATA 0A,00
0207C:  DATA 28,6D
0207E:  DATA 29,2C
02080:  DATA 25,33
02082:  DATA 2E,33
02084:  DATA 67,2C
02086:  DATA 28,63
02088:  DATA 29,2C
0208A:  DATA 25,33
0208C:  DATA 2E,33
0208E:  DATA 67,00
02090:  DATA 28,43
02092:  DATA 73,29
02094:  DATA 2C,25
02096:  DATA 33,2E
02098:  DATA 33,67
0209A:  DATA 0D,0A
0209C:  DATA 00,00
0209E:  DATA 40,43
020A0:  DATA 4F,4E
020A2:  DATA 2C,53
020A4:  DATA 69,4F
020A6:  DATA 2C,25
020A8:  DATA 73,0D
020AA:  DATA 0A,00
020AC:  DATA 4E,4F
020AE:  DATA 33,00
020B0:  DATA 50,4F
020B2:  DATA 34,00
020B4:  DATA 4E,48
020B6:  DATA 34,00
020B8:  DATA 53,69
020BA:  DATA 4F,00
020BC:  DATA 00,00
020BE:  DATA 4D,45
020C0:  DATA 4D,4F
020C2:  DATA 52,59
020C4:  DATA 20,4F
020C6:  DATA 56,45
020C8:  DATA 52,46
020CA:  DATA 4C,4F
020CC:  DATA 57,20
020CE:  DATA 45,52
020D0:  DATA 52,4F
020D2:  DATA 52,20
020D4:  DATA 40,20
020D6:  DATA 4C,69
020D8:  DATA 6E,65
020DA:  DATA 20,3A
020DC:  DATA 25,4C
020DE:  DATA 75,0A
020E0:  DATA 0D,00
020E2:  DATA 0D,0A
020E4:  DATA 3A,00
020E6:  DATA 0D,0A
020E8:  DATA 57,41
020EA:  DATA 52,4E
020EC:  DATA 49,4E
020EE:  DATA 47,3A
020F0:  DATA 20,49
020F2:  DATA 4E,56
020F4:  DATA 41,4C
020F6:  DATA 49,44
020F8:  DATA 20,43
020FA:  DATA 4F,4D
020FC:  DATA 4D,41
020FE:  DATA 4E,44
02100:  DATA 20,49
02102:  DATA 4E,20
02104:  DATA 4D,41
02106:  DATA 43,52
02108:  DATA 4F,21
0210A:  DATA 0D,0A
0210C:  DATA 00,00
0210E:  DATA 42,61
02110:  DATA 64,20
02112:  DATA 63,6F
02114:  DATA 6D,6D
02116:  DATA 61,6E
02118:  DATA 64,20
0211A:  DATA 61,74
0211C:  DATA 20,6C
0211E:  DATA 69,6E
02120:  DATA 65,3A
02122:  DATA 20,25
02124:  DATA 4C,64
02126:  DATA 20,0D
02128:  DATA 0A,00
0212A:  DATA 50,6C
0212C:  DATA 65,61
0212E:  DATA 73,65
02130:  DATA 20,72
02132:  DATA 65,2D
02134:  DATA 75,70
02136:  DATA 6C,6F
02138:  DATA 61,64
0213A:  DATA 20,6D
0213C:  DATA 61,63
0213E:  DATA 72,6F
02140:  DATA 00,00
02142:  DATA 49,74
02144:  DATA 65,72
02146:  DATA 61,74
02148:  DATA 69,6F
0214A:  DATA 6E,73
0214C:  DATA 20,6C
0214E:  DATA 65,66
02150:  DATA 74,3A
02152:  DATA 20,25
02154:  DATA 4C,75
02156:  DATA 0D,0A
02158:  DATA 00,00
0215A:  DATA 2C,6D
0215C:  DATA 61,63
0215E:  DATA 72,6F
02160:  DATA 5B,25
02162:  DATA 75,5D
02164:  DATA 2C,73
02166:  DATA 74,61
02168:  DATA 72,74
0216A:  DATA 0D,0A
0216C:  DATA 00,00
0216E:  DATA 40,4D
02170:  DATA 43,4C
02172:  DATA 5B,25
02174:  DATA 63,5D
02176:  DATA 5B,25
02178:  DATA 4C,75
0217A:  DATA 5D,0D
0217C:  DATA 0A,00
0217E:  DATA 40,4C
02180:  DATA 4E,45
02182:  DATA 0D,0A
02184:  DATA 00,00
02186:  DATA 40,52
02188:  DATA 55,4E
0218A:  DATA 0D,0A
0218C:  DATA 00,00
0218E:  DATA 40,42
02190:  DATA 41,44
02192:  DATA 0D,0A
02194:  DATA 00,00
02196:  DATA 40,54
02198:  DATA 2F,4F
0219A:  DATA 0D,0A
0219C:  DATA 00,00
0219E:  DATA 40,45
021A0:  DATA 52,52
021A2:  DATA 0D,0A
021A4:  DATA 00,00
021A6:  DATA 40,45
021A8:  DATA 4E,44
021AA:  DATA 0D,0A
021AC:  DATA 00,00
021AE:  DATA 40,48
021B0:  DATA 4C,54
021B2:  DATA 0D,0A
021B4:  DATA 00,00
021B6:  DATA 2C,6D
021B8:  DATA 61,63
021BA:  DATA 72,6F
021BC:  DATA 5B,25
021BE:  DATA 75,5D
021C0:  DATA 2C,73
021C2:  DATA 74,61
021C4:  DATA 74,75
021C6:  DATA 73,5B
021C8:  DATA 25,63
021CA:  DATA 5D,2C
021CC:  DATA 6C,69
021CE:  DATA 6E,65
021D0:  DATA 5B,25
021D2:  DATA 4C,75
021D4:  DATA 5D,0D
021D6:  DATA 0A,00
021D8:  DATA 40,52
021DA:  DATA 75,6E
021DC:  DATA 6E,69
021DE:  DATA 6E,67
021E0:  DATA 20,25
021E2:  DATA 63,25
021E4:  DATA 4C,75
021E6:  DATA 20,0D
021E8:  DATA 0A,00
021EA:  DATA 40,4D
021EC:  DATA 61,63
021EE:  DATA 72,6F
021F0:  DATA 20,25
021F2:  DATA 30,34
021F4:  DATA 4C,75
021F6:  DATA 20,6F
021F8:  DATA 66,20
021FA:  DATA 25,30
021FC:  DATA 34,4C
021FE:  DATA 75,0D
02200:  DATA 0A,00
02202:  DATA 40,4C
02204:  DATA 4E,45
02206:  DATA 0D,0A
02208:  DATA 00,00
0220A:  DATA 40,52
0220C:  DATA 55,4E
0220E:  DATA 0D,0A
02210:  DATA 00,00
02212:  DATA 40,42
02214:  DATA 41,44
02216:  DATA 0D,0A
02218:  DATA 00,00
0221A:  DATA 40,54
0221C:  DATA 2F,4F
0221E:  DATA 0D,0A
02220:  DATA 00,00
02222:  DATA 40,45
02224:  DATA 52,52
02226:  DATA 0D,0A
02228:  DATA 00,00
0222A:  DATA 40,45
0222C:  DATA 4E,44
0222E:  DATA 0D,0A
02230:  DATA 00,00
02232:  DATA 2C,61
02234:  DATA 75,74
02236:  DATA 6F,2D
02238:  DATA 73,61
0223A:  DATA 6D,70
0223C:  DATA 6C,65
0223E:  DATA 2C,73
02240:  DATA 61,6D
02242:  DATA 70,6C
02244:  DATA 65,5B
02246:  DATA 25,4C
02248:  DATA 75,5D
0224A:  DATA 2C,73
0224C:  DATA 74,61
0224E:  DATA 72,74
02250:  DATA 0D,0A
02252:  DATA 00,00
02254:  DATA 2C,61
02256:  DATA 75,74
02258:  DATA 6F,2D
0225A:  DATA 73,61
0225C:  DATA 6D,70
0225E:  DATA 6C,65
02260:  DATA 2C,73
02262:  DATA 61,6D
02264:  DATA 70,6C
02266:  DATA 65,5B
02268:  DATA 25,4C
0226A:  DATA 75,5D
0226C:  DATA 2C,63
0226E:  DATA 6F,6D
02270:  DATA 70,6C
02272:  DATA 65,74
02274:  DATA 65,0D
02276:  DATA 0A,00
02278:  DATA 2C,61
0227A:  DATA 75,74
0227C:  DATA 6F,2D
0227E:  DATA 73,61
02280:  DATA 6D,70
02282:  DATA 6C,65
02284:  DATA 2C,73
02286:  DATA 61,6D
02288:  DATA 70,6C
0228A:  DATA 65,5B
0228C:  DATA 25,4C
0228E:  DATA 75,5D
02290:  DATA 2C,65
02292:  DATA 72,72
02294:  DATA 6F,72
02296:  DATA 0D,0A
02298:  DATA 00,00
0229A:  DATA 2C,61
0229C:  DATA 75,74
0229E:  DATA 6F,2D
022A0:  DATA 73,61
022A2:  DATA 6D,70
022A4:  DATA 6C,65
022A6:  DATA 2C,73
022A8:  DATA 61,6D
022AA:  DATA 70,6C
022AC:  DATA 65,5B
022AE:  DATA 25,4C
022B0:  DATA 75,5D
022B2:  DATA 2C,6D
022B4:  DATA 61,78
022B6:  DATA 20,73
022B8:  DATA 61,6D
022BA:  DATA 70,6C
022BC:  DATA 65,73
022BE:  DATA 0D,0A
022C0:  DATA 00,00
022C2:  DATA 2C,61
022C4:  DATA 75,74
022C6:  DATA 6F,2D
022C8:  DATA 73,61
022CA:  DATA 6D,70
022CC:  DATA 6C,65
022CE:  DATA 2C,73
022D0:  DATA 61,6D
022D2:  DATA 70,6C
022D4:  DATA 65,5B
022D6:  DATA 25,4C
022D8:  DATA 75,5D
022DA:  DATA 2C,73
022DC:  DATA 74,61
022DE:  DATA 72,74
022E0:  DATA 0D,0A
022E2:  DATA 00,00
022E4:  DATA 2C,61
022E6:  DATA 75,74
022E8:  DATA 6F,2D
022EA:  DATA 73,61
022EC:  DATA 6D,70
022EE:  DATA 6C,65
022F0:  DATA 2C,73
022F2:  DATA 61,6D
022F4:  DATA 70,6C
022F6:  DATA 65,5B
022F8:  DATA 25,4C
022FA:  DATA 75,5D
022FC:  DATA 2C,63
022FE:  DATA 6F,6D
02300:  DATA 70,6C
02302:  DATA 65,74
02304:  DATA 65,0D
02306:  DATA 0A,00
02308:  DATA 2C,61
0230A:  DATA 75,74
0230C:  DATA 6F,2D
0230E:  DATA 73,61
02310:  DATA 6D,70
02312:  DATA 6C,65
02314:  DATA 2C,73
02316:  DATA 61,6D
02318:  DATA 70,6C
0231A:  DATA 65,5B
0231C:  DATA 25,4C
0231E:  DATA 75,5D
02320:  DATA 2C,73
02322:  DATA 74,61
02324:  DATA 72,74
02326:  DATA 0D,0A
02328:  DATA 00,00
0232A:  DATA 2C,61
0232C:  DATA 75,74
0232E:  DATA 6F,2D
02330:  DATA 73,61
02332:  DATA 6D,70
02334:  DATA 6C,65
02336:  DATA 2C,73
02338:  DATA 61,6D
0233A:  DATA 70,6C
0233C:  DATA 65,5B
0233E:  DATA 25,4C
02340:  DATA 75,5D
02342:  DATA 2C,63
02344:  DATA 6F,6D
02346:  DATA 70,6C
02348:  DATA 65,74
0234A:  DATA 65,0D
0234C:  DATA 0A,00
0234E:  DATA 2C,61
02350:  DATA 75,74
02352:  DATA 6F,2D
02354:  DATA 73,61
02356:  DATA 6D,70
02358:  DATA 6C,65
0235A:  DATA 2C,73
0235C:  DATA 61,6D
0235E:  DATA 70,6C
02360:  DATA 65,5B
02362:  DATA 25,4C
02364:  DATA 75,5D
02366:  DATA 2C,6D
02368:  DATA 61,78
0236A:  DATA 20,73
0236C:  DATA 61,6D
0236E:  DATA 70,6C
02370:  DATA 65,73
02372:  DATA 0D,0A
02374:  DATA 00,00
02376:  DATA 2C,61
02378:  DATA 75,74
0237A:  DATA 6F,2D
0237C:  DATA 73,61
0237E:  DATA 6D,70
02380:  DATA 6C,65
02382:  DATA 2C,69
02384:  DATA 6E,69
02386:  DATA 74,69
02388:  DATA 61,6C
0238A:  DATA 69,7A
0238C:  DATA 65,0D
0238E:  DATA 0A,00
02390:  DATA 2C,68
02392:  DATA 65,61
02394:  DATA 64,65
02396:  DATA 72,2C
02398:  DATA 69,64
0239A:  DATA 23,5B
0239C:  DATA 25,4C
0239E:  DATA 75,5D
023A0:  DATA 2C,69
023A2:  DATA 6E,74
023A4:  DATA 5B,25
023A6:  DATA 4C,75
023A8:  DATA 5D,2C
023AA:  DATA 6D,61
023AC:  DATA 78,5B
023AE:  DATA 25,4C
023B0:  DATA 75,5D
023B2:  DATA 0D,0A
023B4:  DATA 00,00
023B6:  DATA 2C,61
023B8:  DATA 75,74
023BA:  DATA 6F,2D
023BC:  DATA 73,61
023BE:  DATA 6D,70
023C0:  DATA 6C,65
023C2:  DATA 2C,73
023C4:  DATA 61,6D
023C6:  DATA 70,6C
023C8:  DATA 65,5B
023CA:  DATA 25,4C
023CC:  DATA 75,5D
023CE:  DATA 2C,61
023D0:  DATA 6C,61
023D2:  DATA 72,6D
023D4:  DATA 5B,25
023D6:  DATA 75,5D
023D8:  DATA 0D,0A
023DA:  DATA 00,00
023DC:  DATA 2C,61
023DE:  DATA 75,74
023E0:  DATA 6F,2D
023E2:  DATA 73,61
023E4:  DATA 6D,70
023E6:  DATA 6C,65
023E8:  DATA 2C,73
023EA:  DATA 6C,65
023EC:  DATA 65,70
023EE:  DATA 0D,0A
023F0:  DATA 00,00
023F2:  DATA 74,31
023F4:  DATA 3A,25
023F6:  DATA 4C,75
023F8:  DATA 20,74
023FA:  DATA 32,3A
023FC:  DATA 25,4C
023FE:  DATA 75,0D
02400:  DATA 0A,00
02402:  DATA 40,44
02404:  DATA 45,54
02406:  DATA 2C,25
02408:  DATA 4C,75
0240A:  DATA 0D,0A
0240C:  DATA 00,00
0240E:  DATA 4E,4F
02410:  DATA 33,2C
02412:  DATA 25,31
02414:  DATA 2E,35
02416:  DATA 67,2C
02418:  DATA 25,31
0241A:  DATA 2E,35
0241C:  DATA 67,0D
0241E:  DATA 0A,00
02420:  DATA 50,4F
02422:  DATA 34,2C
02424:  DATA 25,31
02426:  DATA 2E,35
02428:  DATA 67,2C
0242A:  DATA 25,31
0242C:  DATA 2E,35
0242E:  DATA 67,0D
02430:  DATA 0A,00
02432:  DATA 4E,48
02434:  DATA 34,2C
02436:  DATA 25,31
02438:  DATA 2E,35
0243A:  DATA 67,2C
0243C:  DATA 25,31
0243E:  DATA 2E,35
02440:  DATA 67,0D
02442:  DATA 0A,00
02444:  DATA 53,69
02446:  DATA 4F,34
02448:  DATA 2C,25
0244A:  DATA 31,2E
0244C:  DATA 35,67
0244E:  DATA 2C,25
02450:  DATA 31,2E
02452:  DATA 35,67
02454:  DATA 0D,0A
02456:  DATA 00,00
02458:  DATA 4E,4F
0245A:  DATA 33,28
0245C:  DATA 6D,29
0245E:  DATA 3A,00
02460:  DATA 4E,4F
02462:  DATA 33,28
02464:  DATA 63,29
02466:  DATA 3A,00
02468:  DATA 50,4F
0246A:  DATA 34,28
0246C:  DATA 6D,29
0246E:  DATA 3A,00
02470:  DATA 50,4F
02472:  DATA 34,28
02474:  DATA 63,29
02476:  DATA 3A,00
02478:  DATA 4E,48
0247A:  DATA 34,28
0247C:  DATA 6D,29
0247E:  DATA 3A,00
02480:  DATA 4E,48
02482:  DATA 34,28
02484:  DATA 63,29
02486:  DATA 3A,00
02488:  DATA 53,69
0248A:  DATA 4F,34
0248C:  DATA 28,6D
0248E:  DATA 29,3A
02490:  DATA 00,00
02492:  DATA 53,69
02494:  DATA 4F,34
02496:  DATA 28,63
02498:  DATA 29,3A
0249A:  DATA 00,00
0249C:  DATA 41,72
0249E:  DATA 65,20
024A0:  DATA 79,6F
024A2:  DATA 75,20
024A4:  DATA 73,75
024A6:  DATA 72,65
024A8:  DATA 20,79
024AA:  DATA 6F,75
024AC:  DATA 20,77
024AE:  DATA 61,6E
024B0:  DATA 74,20
024B2:  DATA 74,6F
024B4:  DATA 20,65
024B6:  DATA 72,61
024B8:  DATA 73,65
024BA:  DATA 20,74
024BC:  DATA 68,65
024BE:  DATA 20,72
024C0:  DATA 61,77
024C2:  DATA 20,64
024C4:  DATA 61,74
024C6:  DATA 61,20
024C8:  DATA 66,69
024CA:  DATA 6C,65
024CC:  DATA 3F,20
024CE:  DATA 59,20
024D0:  DATA 6F,72
024D2:  DATA 20,4E
024D4:  DATA 21,0D
024D6:  DATA 0A,00
024D8:  DATA 46,69
024DA:  DATA 6C,65
024DC:  DATA 20,64
024DE:  DATA 65,6C
024E0:  DATA 65,74
024E2:  DATA 65,64
024E4:  DATA 21,0A
024E6:  DATA 0D,00
024E8:  DATA 4F,70
024EA:  DATA 65,72
024EC:  DATA 61,74
024EE:  DATA 69,6F
024F0:  DATA 6E,20
024F2:  DATA 63,61
024F4:  DATA 6E,63
024F6:  DATA 65,6C
024F8:  DATA 65,64
024FA:  DATA 21,0D
024FC:  DATA 0A,00
024FE:  DATA 41,72
02500:  DATA 65,20
02502:  DATA 79,6F
02504:  DATA 75,20
02506:  DATA 73,75
02508:  DATA 72,65
0250A:  DATA 20,79
0250C:  DATA 6F,75
0250E:  DATA 20,77
02510:  DATA 61,6E
02512:  DATA 74,20
02514:  DATA 74,6F
02516:  DATA 20,65
02518:  DATA 72,61
0251A:  DATA 73,65
0251C:  DATA 20,74
0251E:  DATA 68,65
02520:  DATA 20,63
02522:  DATA 61,6C
02524:  DATA 63,75
02526:  DATA 6C,61
02528:  DATA 74,65
0252A:  DATA 64,20
0252C:  DATA 64,61
0252E:  DATA 74,61
02530:  DATA 20,66
02532:  DATA 69,6C
02534:  DATA 65,3F
02536:  DATA 20,59
02538:  DATA 20,6F
0253A:  DATA 72,20
0253C:  DATA 4E,21
0253E:  DATA 0D,0A
02540:  DATA 00,00
02542:  DATA 46,69
02544:  DATA 6C,65
02546:  DATA 20,64
02548:  DATA 65,6C
0254A:  DATA 65,74
0254C:  DATA 65,64
0254E:  DATA 21,0A
02550:  DATA 0D,00
02552:  DATA 4F,70
02554:  DATA 65,72
02556:  DATA 61,74
02558:  DATA 69,6F
0255A:  DATA 6E,20
0255C:  DATA 63,61
0255E:  DATA 6E,63
02560:  DATA 65,6C
02562:  DATA 65,64
02564:  DATA 21,0D
02566:  DATA 0A,00
02568:  DATA 40,49
0256A:  DATA 44,23
0256C:  DATA 25,4C
0256E:  DATA 75,20
02570:  DATA 49,25
02572:  DATA 4C,75
02574:  DATA 20,4E
02576:  DATA 25,4C
02578:  DATA 75,2F
0257A:  DATA 25,4C
0257C:  DATA 75,20
0257E:  DATA 58,25
02580:  DATA 4C,75
02582:  DATA 20,55
02584:  DATA 25,75
02586:  DATA 20,25
02588:  DATA 34,2E
0258A:  DATA 32,77
0258C:  DATA 56,0D
0258E:  DATA 0A,00
02590:  DATA 40,4D
02592:  DATA 4F,54
02594:  DATA 3A,56
02596:  DATA 41,4C
02598:  DATA 3D,25
0259A:  DATA 4C,75
0259C:  DATA 20,53
0259E:  DATA 59,52
025A0:  DATA 3D,25
025A2:  DATA 4C,64
025A4:  DATA 0D,0A
025A6:  DATA 00,00
025A8:  DATA 40,50
025AA:  DATA 57,52
025AC:  DATA 3A,25
025AE:  DATA 30,32
025B0:  DATA 75,2F
025B2:  DATA 25,30
025B4:  DATA 32,75
025B6:  DATA 2F,25
025B8:  DATA 30,32
025BA:  DATA 75,20
025BC:  DATA 25,30
025BE:  DATA 32,75
025C0:  DATA 3A,25
025C2:  DATA 30,32
025C4:  DATA 75,3A
025C6:  DATA 25,30
025C8:  DATA 32,75
025CA:  DATA 0D,0A
025CC:  DATA 00,00
025CE:  DATA 40,50
025D0:  DATA 57,52
025D2:  DATA 3A,25
025D4:  DATA 30,32
025D6:  DATA 75,2F
025D8:  DATA 25,30
025DA:  DATA 32,75
025DC:  DATA 2F,25
025DE:  DATA 30,32
025E0:  DATA 75,20
025E2:  DATA 25,30
025E4:  DATA 32,75
025E6:  DATA 3A,25
025E8:  DATA 30,32
025EA:  DATA 75,3A
025EC:  DATA 25,30
025EE:  DATA 32,75
025F0:  DATA 0D,0A
025F2:  DATA 00,00
025F4:  DATA 41,25
025F6:  DATA 4C,75
025F8:  DATA 20,49
025FA:  DATA 25,4C
025FC:  DATA 75,20
025FE:  DATA 4C,25
02600:  DATA 4C,75
02602:  DATA 20,51
02604:  DATA 25,4C
02606:  DATA 75,20
02608:  DATA 53,25
0260A:  DATA 4C,75
0260C:  DATA 20,25
0260E:  DATA 34,2E
02610:  DATA 32,77
02612:  DATA 56,0D
02614:  DATA 0A,00
02616:  DATA 40,4D
02618:  DATA 4F,54
0261A:  DATA 3A,56
0261C:  DATA 41,4C
0261E:  DATA 3D,25
02620:  DATA 4C,75
02622:  DATA 20,53
02624:  DATA 59,52
02626:  DATA 3D,25
02628:  DATA 4C,64
0262A:  DATA 0D,0A
0262C:  DATA 00,00
0262E:  DATA 40,50
02630:  DATA 57,52
02632:  DATA 3A,25
02634:  DATA 30,32
02636:  DATA 75,2F
02638:  DATA 25,30
0263A:  DATA 32,75
0263C:  DATA 2F,25
0263E:  DATA 30,32
02640:  DATA 75,20
02642:  DATA 25,30
02644:  DATA 32,75
02646:  DATA 3A,25
02648:  DATA 30,32
0264A:  DATA 75,3A
0264C:  DATA 25,30
0264E:  DATA 32,75
02650:  DATA 0D,0A
02652:  DATA 00,00
02654:  DATA 49,25
02656:  DATA 4C,75
02658:  DATA 20,4E
0265A:  DATA 25,4C
0265C:  DATA 75,2F
0265E:  DATA 25,4C
02660:  DATA 75,20
02662:  DATA 50,25
02664:  DATA 4C,75
02666:  DATA 20,25
02668:  DATA 34,2E
0266A:  DATA 32,77
0266C:  DATA 56,0D
0266E:  DATA 0A,00
02670:  DATA 40,4D
02672:  DATA 4F,54
02674:  DATA 3A,53
02676:  DATA 59,52
02678:  DATA 3D,25
0267A:  DATA 4C,64
0267C:  DATA 0D,0A
0267E:  DATA 00,00
02680:  DATA 40,50
02682:  DATA 57,52
02684:  DATA 3A,25
02686:  DATA 30,32
02688:  DATA 75,2F
0268A:  DATA 25,30
0268C:  DATA 32,75
0268E:  DATA 2F,25
02690:  DATA 30,32
02692:  DATA 75,20
02694:  DATA 25,30
02696:  DATA 32,75
02698:  DATA 3A,25
0269A:  DATA 30,32
0269C:  DATA 75,3A
0269E:  DATA 25,30
026A0:  DATA 32,75
026A2:  DATA 0D,0A
026A4:  DATA 00,00
026A6:  DATA 40,53
026A8:  DATA 4D,50
026AA:  DATA 20,25
026AC:  DATA 30,34
026AE:  DATA 4C,75
026B0:  DATA 0D,0A
026B2:  DATA 00,00
026B4:  DATA 40,53
026B6:  DATA 4D,50
026B8:  DATA 20,25
026BA:  DATA 30,34
026BC:  DATA 4C,75
026BE:  DATA 0D,0A
026C0:  DATA 00,00
026C2:  DATA 45,6E
026C4:  DATA 74,65
026C6:  DATA 72,20
026C8:  DATA 64,61
026CA:  DATA 74,65
026CC:  DATA 20,66
026CE:  DATA 6F,72
026D0:  DATA 6D,61
026D2:  DATA 74,20
026D4:  DATA 30,3D
026D6:  DATA 4D,4D
026D8:  DATA 2F,44
026DA:  DATA 44,2F
026DC:  DATA 59,59
026DE:  DATA 20,20
026E0:  DATA 31,3D
026E2:  DATA 44,44
026E4:  DATA 2F,4D
026E6:  DATA 4D,2F
026E8:  DATA 59,59
026EA:  DATA 0D,0A
026EC:  DATA 00,00
026EE:  DATA 40,4F
026F0:  DATA 4B,21
026F2:  DATA 0D,0A
026F4:  DATA 20,00
026F6:  DATA 40,45
026F8:  DATA 52,52
026FA:  DATA 0D,0A
026FC:  DATA 00,00
026FE:  DATA 40,52
02700:  DATA 55,4E
02702:  DATA 0D,0A
02704:  DATA 00,00
02706:  DATA 5B,6D
02708:  DATA 6F,74
0270A:  DATA 6F,72
0270C:  DATA 3A,31
0270E:  DATA 5D,0D
02710:  DATA 0A,00
02712:  DATA 5B,6D
02714:  DATA 6F,74
02716:  DATA 6F,72
02718:  DATA 3A,32
0271A:  DATA 5D,0D
0271C:  DATA 0A,00
0271E:  DATA 2C,45
02720:  DATA 43,4F
02722:  DATA 20,6D
02724:  DATA 6F,64
02726:  DATA 65,20
02728:  DATA 73,65
0272A:  DATA 74,0D
0272C:  DATA 0A,00
0272E:  DATA 2C,57
02730:  DATA 4D,53
02732:  DATA 2D,34
02734:  DATA 2D,53
02736:  DATA 44,20
02738:  DATA 6D,6F
0273A:  DATA 64,65
0273C:  DATA 20,73
0273E:  DATA 65,74
02740:  DATA 0D,0A
02742:  DATA 00,00
02744:  DATA 2C,41
02746:  DATA 57,53
02748:  DATA 20,6D
0274A:  DATA 6F,64
0274C:  DATA 65,20
0274E:  DATA 73,65
02750:  DATA 74,0D
02752:  DATA 0A,00
02754:  DATA 2C,57
02756:  DATA 4D,53
02758:  DATA 2D,34
0275A:  DATA 2D,51
0275C:  DATA 45,20
0275E:  DATA 6D,6F
02760:  DATA 64,65
02762:  DATA 20,73
02764:  DATA 65,74
02766:  DATA 0D,0A
02768:  DATA 00,00
0276A:  DATA 30,33
0276C:  DATA 2D,4A
0276E:  DATA 75,6C
02770:  DATA 2D,31
02772:  DATA 37,00
02774:  DATA 31,35
02776:  DATA 3A,31
02778:  DATA 35,3A
0277A:  DATA 34,34
0277C:  DATA 00,00
0277E:  DATA 53,45
02780:  DATA 4E,44
02782:  DATA 20,48
02784:  DATA 45,58
02786:  DATA 20,46
02788:  DATA 49,4C
0278A:  DATA 45,20
0278C:  DATA 28,31
0278E:  DATA 39,32
02790:  DATA 30,30
02792:  DATA 2C,4E
02794:  DATA 38,31
02796:  DATA 2C,58
02798:  DATA 4F,4E
0279A:  DATA 2D,58
0279C:  DATA 4F,46
0279E:  DATA 46,29
027A0:  DATA 0D,0A
027A2:  DATA 00,00
027A4:  DATA 40,4F
027A6:  DATA 4B,21
027A8:  DATA 20,00
027AA:  DATA 40,41
027AC:  DATA 52,47
027AE:  DATA 20,00
027B0:  DATA 40,49
027B2:  DATA 4E,56
027B4:  DATA 00,00
027B6:  DATA 40,43
027B8:  DATA 4D,44
027BA:  DATA 00,00
027BC:  DATA 2C,63
027BE:  DATA 6F,6D
027C0:  DATA 6D,61
027C2:  DATA 6E,64
027C4:  DATA 20,70
027C6:  DATA 72,6F
027C8:  DATA 6D,70
027CA:  DATA 74,0D
027CC:  DATA 0A,00
027CE:  DATA 40,53
027D0:  DATA 44,3D
027D2:  DATA 25,4C
027D4:  DATA 75,0D
027D6:  DATA 0A,00
027D8:  DATA 40,4D
027DA:  DATA 43,31
027DC:  DATA 2C,25
027DE:  DATA 4C,75
027E0:  DATA 2C,25
027E2:  DATA 4C,64
027E4:  DATA 0D,0A
027E6:  DATA 00,00
027E8:  DATA 40,4D
027EA:  DATA 43,32
027EC:  DATA 2C,25
027EE:  DATA 4C,75
027F0:  DATA 2C,25
027F2:  DATA 4C,64
027F4:  DATA 0D,0A
027F6:  DATA 00,00
027F8:  DATA 50,72
027FA:  DATA 65,73
027FC:  DATA 73,20
027FE:  DATA 61,6E
02800:  DATA 64,20
02802:  DATA 68,6F
02804:  DATA 6C,64
02806:  DATA 20,74
02808:  DATA 68,65
0280A:  DATA 20,45
0280C:  DATA 73,63
0280E:  DATA 20,6B
02810:  DATA 65,79
02812:  DATA 20,74
02814:  DATA 6F,20
02816:  DATA 72,65
02818:  DATA 74,75
0281A:  DATA 72,6E
0281C:  DATA 20,74
0281E:  DATA 6F,20
02820:  DATA 43,6F
02822:  DATA 6D,6D
02824:  DATA 61,6E
02826:  DATA 64,20
02828:  DATA 4D,6F
0282A:  DATA 64,65
0282C:  DATA 0D,0A
0282E:  DATA 00,00
02830:  DATA 52,65
02832:  DATA 74,75
02834:  DATA 72,6E
02836:  DATA 69,6E
02838:  DATA 67,20
0283A:  DATA 74,6F
0283C:  DATA 20,4C
0283E:  DATA 6F,67
02840:  DATA 67,69
02842:  DATA 6E,67
02844:  DATA 20,4D
02846:  DATA 6F,64
02848:  DATA 65,0D
0284A:  DATA 0A,00
*
02C5C:  CLRF   01
02C5E:  CLRF   02
02C60:  CLRF   00
02C62:  CLRF   03
02C64:  MOVLB  8
02C66:  MOVF   xBB,W
02C68:  BNZ   2C6E
02C6A:  MOVF   xBA,W
02C6C:  BZ    2C9E
02C6E:  MOVLW  10
02C70:  MOVWF  xBC
02C72:  BCF    FD8.0
02C74:  RLCF   xB8,F
02C76:  RLCF   xB9,F
02C78:  RLCF   00,F
02C7A:  RLCF   03,F
02C7C:  MOVF   xBB,W
02C7E:  SUBWF  03,W
02C80:  BNZ   2C86
02C82:  MOVF   xBA,W
02C84:  SUBWF  00,W
02C86:  BNC   2C96
02C88:  MOVF   xBA,W
02C8A:  SUBWF  00,F
02C8C:  BTFSS  FD8.0
02C8E:  DECF   03,F
02C90:  MOVF   xBB,W
02C92:  SUBWF  03,F
02C94:  BSF    FD8.0
02C96:  RLCF   01,F
02C98:  RLCF   02,F
02C9A:  DECFSZ xBC,F
02C9C:  BRA    2C72
02C9E:  MOVLB  0
02CA0:  RETURN 0
*
034AE:  TSTFSZ 01
034B0:  BRA    34B8
034B2:  TSTFSZ 02
034B4:  BRA    34BA
034B6:  BRA    34C6
034B8:  INCF   02,F
034BA:  MOVFF  00,FEE
034BE:  DECFSZ 01,F
034C0:  BRA    34BA
034C2:  DECFSZ 02,F
034C4:  BRA    34BA
034C6:  RETURN 0
*
03598:  MOVLB  9
0359A:  BTFSC  xCA.7
0359C:  BRA    35BE
0359E:  MOVLW  0F
035A0:  MOVWF  00
035A2:  SWAPF  xC9,W
035A4:  ANDWF  00,F
035A6:  MOVLW  0A
035A8:  SUBWF  00,W
035AA:  BC    35B2
035AC:  MOVLW  30
035AE:  ADDWF  00,F
035B0:  BRA    35B6
035B2:  MOVF   xCA,W
035B4:  ADDWF  00,F
035B6:  MOVF   00,W
035B8:  BTFSS  F9E.4
035BA:  BRA    35B8
035BC:  MOVWF  FAD
035BE:  MOVLW  0F
035C0:  ANDWF  xC9,F
035C2:  MOVLW  0A
035C4:  SUBWF  xC9,W
035C6:  BC    35CC
035C8:  MOVLW  30
035CA:  BRA    35D0
035CC:  BCF    xCA.7
035CE:  MOVF   xCA,W
035D0:  ADDWF  xC9,F
035D2:  MOVF   xC9,W
035D4:  BTFSS  F9E.4
035D6:  BRA    35D4
035D8:  MOVWF  FAD
035DA:  MOVLB  0
035DC:  RETURN 0
*
0477C:  MOVLB  9
0477E:  CLRF   xDB
04780:  CLRF   xDC
04782:  MOVLW  01
04784:  MOVWF  xDD
04786:  CLRF   FDA
04788:  CLRF   FD9
0478A:  MOVLW  09
0478C:  MOVWF  xE0
0478E:  MOVLW  D3
04790:  MOVWF  xDF
04792:  MOVLW  09
04794:  MOVWF  FEA
04796:  MOVLW  D7
04798:  MOVWF  FE9
0479A:  MOVFF  9E0,FE2
0479E:  MOVFF  9DF,FE1
047A2:  MOVFF  9DD,9DE
047A6:  BCF    FD8.0
047A8:  MOVF   FE5,W
047AA:  MULWF  FEE
047AC:  MOVF   FF3,W
047AE:  ADDWFC xDB,F
047B0:  MOVF   FF4,W
047B2:  ADDWFC xDC,F
047B4:  DECFSZ xDE,F
047B6:  BRA    47A6
047B8:  MOVFF  9DB,FDE
047BC:  MOVFF  9DC,9DB
047C0:  CLRF   xDC
047C2:  BTFSC  FD8.0
047C4:  INCF   xDC,F
047C6:  INCF   xDF,F
047C8:  BTFSC  FD8.2
047CA:  INCF   xE0,F
047CC:  INCF   xDD,F
047CE:  MOVF   xDD,W
047D0:  SUBLW  05
047D2:  BNZ   4792
047D4:  MOVLB  0
047D6:  RETURN 0
*
05020:  MOVFF  1E,FEA
05024:  MOVFF  1D,FE9
05028:  MOVLB  8
0502A:  MOVFF  8DC,FEF
0502E:  INCF   FE9,F
05030:  BTFSC  FD8.2
05032:  INCF   FEA,F
05034:  CLRF   FEF
05036:  INCF   1D,F
05038:  BTFSC  FD8.2
0503A:  INCF   1E,F
0503C:  MOVLB  0
0503E:  RETURN 0
05040:  TBLRD*+
05042:  MOVF   FF5,F
05044:  BZ    5066
05046:  MOVFF  FF6,8C8
0504A:  MOVFF  FF7,8C9
0504E:  MOVFF  FF8,8CA
05052:  MOVFF  FF5,8DC
05056:  RCALL  5020
05058:  MOVFF  8C8,FF6
0505C:  MOVFF  8C9,FF7
05060:  MOVFF  8CA,FF8
05064:  BRA    5040
05066:  RETURN 0
*
05202:  MOVF   01,W
05204:  CLRF   1B
05206:  BTFSC  FF2.7
05208:  BSF    1B.7
0520A:  BCF    FF2.7
0520C:  MOVFF  8CA,A1A
05210:  MOVLW  64
05212:  MOVLB  A
05214:  MOVWF  x1B
05216:  MOVLB  0
05218:  CALL   0F66
0521C:  BTFSC  1B.7
0521E:  BSF    FF2.7
05220:  MOVFF  00,8CA
05224:  MOVF   01,W
05226:  MOVLW  30
05228:  BNZ   523A
0522A:  MOVLB  8
0522C:  BTFSS  xCB.1
0522E:  BRA    524E
05230:  BTFSC  xCB.3
05232:  BRA    524E
05234:  BTFSC  xCB.4
05236:  MOVLW  20
05238:  BRA    5242
0523A:  MOVLB  8
0523C:  BCF    xCB.3
0523E:  BCF    xCB.4
05240:  BSF    xCB.0
05242:  ADDWF  01,F
05244:  MOVFF  01,8DC
05248:  MOVLB  0
0524A:  RCALL  5020
0524C:  MOVLB  8
0524E:  CLRF   1B
05250:  BTFSC  FF2.7
05252:  BSF    1B.7
05254:  BCF    FF2.7
05256:  MOVFF  8CA,A1A
0525A:  MOVLW  0A
0525C:  MOVLB  A
0525E:  MOVWF  x1B
05260:  MOVLB  0
05262:  CALL   0F66
05266:  BTFSC  1B.7
05268:  BSF    FF2.7
0526A:  MOVFF  00,8CA
0526E:  MOVF   01,W
05270:  MOVLW  30
05272:  BNZ   5284
05274:  MOVLB  8
05276:  BTFSC  xCB.3
05278:  BRA    528E
0527A:  BTFSS  xCB.0
0527C:  BRA    528E
0527E:  BTFSC  xCB.4
05280:  MOVLW  20
05282:  MOVLB  0
05284:  ADDWF  01,F
05286:  MOVFF  01,8DC
0528A:  RCALL  5020
0528C:  MOVLB  8
0528E:  MOVLW  30
05290:  ADDWF  xCA,F
05292:  MOVFF  8CA,8DC
05296:  MOVLB  0
05298:  RCALL  5020
0529A:  RETURN 0
0529C:  MOVF   FE9,W
0529E:  MOVLB  8
052A0:  MOVWF  xCF
052A2:  MOVLW  3B
052A4:  MOVWF  xD6
052A6:  MOVLW  9A
052A8:  MOVWF  xD5
052AA:  MOVLW  CA
052AC:  MOVWF  xD4
052AE:  CLRF   xD3
052B0:  MOVLW  0A
052B2:  MOVWF  xD1
052B4:  MOVF   xCE,W
052B6:  BTFSS  FD8.2
052B8:  DECF   xCF,F
052BA:  BSF    FD8.1
052BC:  MOVLW  08
052BE:  MOVWF  FEA
052C0:  MOVLW  CA
052C2:  MOVWF  FE9
052C4:  CLRF   1B
052C6:  BTFSC  FF2.7
052C8:  BSF    1B.7
052CA:  BCF    FF2.7
052CC:  MOVFF  8CD,A27
052D0:  MOVFF  8CC,A26
052D4:  MOVFF  8CB,A25
052D8:  MOVFF  8CA,A24
052DC:  MOVFF  8D6,A2B
052E0:  MOVFF  8D5,A2A
052E4:  MOVFF  8D4,A29
052E8:  MOVFF  8D3,A28
052EC:  MOVLB  0
052EE:  CALL   1042
052F2:  BTFSC  1B.7
052F4:  BSF    FF2.7
052F6:  MOVF   01,W
052F8:  MOVF   00,F
052FA:  BNZ   5322
052FC:  MOVLB  8
052FE:  INCF   xCE,W
05300:  SUBWF  xD1,W
05302:  BTFSS  FD8.2
05304:  BRA    530A
05306:  MOVLB  0
05308:  BRA    5322
0530A:  MOVF   xCF,W
0530C:  BZ    5326
0530E:  ANDLW  0F
05310:  SUBWF  xD1,W
05312:  BZ    5316
05314:  BC    5352
05316:  BTFSC  xCF.7
05318:  BRA    5352
0531A:  BTFSC  xCF.6
0531C:  BRA    5326
0531E:  MOVLW  20
05320:  BRA    5346
05322:  MOVLB  8
05324:  CLRF   xCF
05326:  MOVF   xCE,W
05328:  SUBWF  xD1,W
0532A:  BNZ   5344
0532C:  MOVFF  00,8CF
05330:  MOVLW  2E
05332:  MOVWF  xDC
05334:  MOVLB  0
05336:  RCALL  5020
05338:  MOVLB  8
0533A:  MOVFF  8CF,00
0533E:  MOVLW  20
05340:  ANDWF  xCF,F
05342:  MOVLW  00
05344:  MOVLW  30
05346:  ADDWF  00,F
05348:  MOVFF  00,8DC
0534C:  MOVLB  0
0534E:  RCALL  5020
05350:  MOVLB  8
05352:  BCF    FD8.1
05354:  CLRF   1B
05356:  BTFSC  FF2.7
05358:  BSF    1B.7
0535A:  BCF    FF2.7
0535C:  MOVFF  8D6,A27
05360:  MOVFF  8D5,A26
05364:  MOVFF  8D4,A25
05368:  MOVFF  8D3,A24
0536C:  MOVLB  A
0536E:  CLRF   x2B
05370:  CLRF   x2A
05372:  CLRF   x29
05374:  MOVLW  0A
05376:  MOVWF  x28
05378:  MOVLB  0
0537A:  CALL   1042
0537E:  BTFSC  1B.7
05380:  BSF    FF2.7
05382:  MOVFF  03,8D6
05386:  MOVFF  02,8D5
0538A:  MOVFF  01,8D4
0538E:  MOVFF  00,8D3
05392:  MOVLB  8
05394:  DECFSZ xD1,F
05396:  BRA    52BA
05398:  MOVLB  0
0539A:  RETURN 0
*
05C18:  MOVLB  9
05C1A:  MOVF   xE9,W
05C1C:  MULWF  xEB
05C1E:  MOVFF  FF3,01
05C22:  MOVFF  FF4,00
05C26:  MULWF  xEC
05C28:  MOVF   FF3,W
05C2A:  ADDWF  00,F
05C2C:  MOVF   xEA,W
05C2E:  MULWF  xEB
05C30:  MOVF   FF3,W
05C32:  ADDWFC 00,W
05C34:  MOVWF  02
05C36:  MOVLB  0
05C38:  RETURN 0
*
078DC:  MOVF   FEF,F
078DE:  BZ    7900
078E0:  MOVFF  FEA,98E
078E4:  MOVFF  FE9,98D
078E8:  MOVF   FEF,W
078EA:  BTFSS  F9E.4
078EC:  BRA    78EA
078EE:  MOVWF  FAD
078F0:  MOVFF  98E,FEA
078F4:  MOVFF  98D,FE9
078F8:  INCF   FE9,F
078FA:  BTFSC  FD8.2
078FC:  INCF   FEA,F
078FE:  BRA    78DC
07900:  RETURN 0
*
08F24:  MOVFF  FEA,8D5
08F28:  MOVFF  FE9,8D4
08F2C:  MOVLB  8
08F2E:  BTFSS  xCE.7
08F30:  BRA    8F42
08F32:  BSF    xD4.7
08F34:  BTFSS  xD4.4
08F36:  INCF   xD4,F
08F38:  COMF   xCD,F
08F3A:  COMF   xCE,F
08F3C:  INCF   xCD,F
08F3E:  BTFSC  FD8.2
08F40:  INCF   xCE,F
08F42:  SWAPF  xCE,W
08F44:  IORLW  F0
08F46:  MOVWF  xD0
08F48:  ADDWF  xD0,F
08F4A:  ADDLW  E2
08F4C:  MOVWF  xD1
08F4E:  ADDLW  32
08F50:  MOVWF  xD3
08F52:  MOVF   xCE,W
08F54:  ANDLW  0F
08F56:  ADDWF  xD1,F
08F58:  ADDWF  xD1,F
08F5A:  ADDWF  xD3,F
08F5C:  ADDLW  E9
08F5E:  MOVWF  xD2
08F60:  ADDWF  xD2,F
08F62:  ADDWF  xD2,F
08F64:  SWAPF  xCD,W
08F66:  ANDLW  0F
08F68:  ADDWF  xD2,F
08F6A:  ADDWF  xD3,F
08F6C:  RLCF   xD2,F
08F6E:  RLCF   xD3,F
08F70:  COMF   xD3,F
08F72:  RLCF   xD3,F
08F74:  MOVF   xCD,W
08F76:  ANDLW  0F
08F78:  ADDWF  xD3,F
08F7A:  RLCF   xD0,F
08F7C:  MOVLW  07
08F7E:  MOVWF  xCF
08F80:  MOVLW  0A
08F82:  DECF   xD2,F
08F84:  ADDWF  xD3,F
08F86:  BNC   8F82
08F88:  DECF   xD1,F
08F8A:  ADDWF  xD2,F
08F8C:  BNC   8F88
08F8E:  DECF   xD0,F
08F90:  ADDWF  xD1,F
08F92:  BNC   8F8E
08F94:  DECF   xCF,F
08F96:  ADDWF  xD0,F
08F98:  BNC   8F94
08F9A:  MOVLW  08
08F9C:  MOVWF  FEA
08F9E:  MOVLW  CF
08FA0:  MOVWF  FE9
08FA2:  MOVLW  07
08FA4:  ANDWF  xD4,W
08FA6:  BCF    xD4.6
08FA8:  MOVF   FED,F
08FAA:  ANDWF  xD4,W
08FAC:  BNZ   8FBC
08FAE:  BTFSC  xD4.4
08FB0:  MOVF   FEE,F
08FB2:  BTFSC  xD4.4
08FB4:  BRA    8FBC
08FB6:  MOVLW  20
08FB8:  MOVWF  00
08FBA:  BRA    8FFE
08FBC:  ADDWF  FE9,F
08FBE:  MOVLW  00
08FC0:  ADDWFC FEA,F
08FC2:  MOVF   FE9,W
08FC4:  SUBLW  D3
08FC6:  BNZ   8FD0
08FC8:  MOVF   FEA,W
08FCA:  SUBLW  08
08FCC:  BNZ   8FD0
08FCE:  BSF    xD4.6
08FD0:  MOVF   FEF,W
08FD2:  MOVWF  00
08FD4:  BNZ   8FE6
08FD6:  BTFSC  xD4.6
08FD8:  BRA    8FE6
08FDA:  BTFSC  xD4.4
08FDC:  BRA    9006
08FDE:  BTFSC  xD4.3
08FE0:  BRA    8FE6
08FE2:  MOVLW  20
08FE4:  BRA    8FFC
08FE6:  BTFSS  xD4.7
08FE8:  BRA    8FF6
08FEA:  MOVLW  2D
08FEC:  MOVWF  00
08FEE:  MOVF   FED,W
08FF0:  BCF    xD4.6
08FF2:  BCF    xD4.7
08FF4:  BRA    8FFE
08FF6:  BSF    xD4.3
08FF8:  BCF    xD4.4
08FFA:  MOVLW  30
08FFC:  ADDWF  00,F
08FFE:  MOVF   00,W
09000:  BTFSS  F9E.4
09002:  BRA    9000
09004:  MOVWF  FAD
09006:  MOVF   FEE,W
09008:  BTFSS  xD4.6
0900A:  BRA    8FC2
0900C:  MOVLB  0
0900E:  RETURN 0
*
094A4:  MOVF   FE9,W
094A6:  MOVLB  8
094A8:  MOVWF  xD3
094AA:  BTFSS  xD2.7
094AC:  BRA    94C8
094AE:  DECF   xD3,F
094B0:  BSF    xD3.5
094B2:  COMF   xCF,F
094B4:  COMF   xD0,F
094B6:  COMF   xD1,F
094B8:  COMF   xD2,F
094BA:  INCF   xCF,F
094BC:  BTFSC  FD8.2
094BE:  INCF   xD0,F
094C0:  BTFSC  FD8.2
094C2:  INCF   xD1,F
094C4:  BTFSC  FD8.2
094C6:  INCF   xD2,F
094C8:  MOVLW  3B
094CA:  MOVWF  xDA
094CC:  MOVLW  9A
094CE:  MOVWF  xD9
094D0:  MOVLW  CA
094D2:  MOVWF  xD8
094D4:  CLRF   xD7
094D6:  MOVLW  0A
094D8:  MOVWF  xD5
094DA:  BSF    FD8.1
094DC:  MOVLW  08
094DE:  MOVWF  FEA
094E0:  MOVLW  CF
094E2:  MOVWF  FE9
094E4:  CLRF   1B
094E6:  BTFSC  FF2.7
094E8:  BSF    1B.7
094EA:  BCF    FF2.7
094EC:  MOVFF  8D2,A27
094F0:  MOVFF  8D1,A26
094F4:  MOVFF  8D0,A25
094F8:  MOVFF  8CF,A24
094FC:  MOVFF  8DA,A2B
09500:  MOVFF  8D9,A2A
09504:  MOVFF  8D8,A29
09508:  MOVFF  8D7,A28
0950C:  MOVLB  0
0950E:  CALL   1042
09512:  BTFSC  1B.7
09514:  BSF    FF2.7
09516:  MOVF   01,W
09518:  MOVF   00,F
0951A:  BNZ   9542
0951C:  MOVLB  8
0951E:  MOVF   xD5,W
09520:  XORLW  01
09522:  BTFSS  FD8.2
09524:  BRA    952A
09526:  MOVLB  0
09528:  BRA    9542
0952A:  MOVF   xD3,W
0952C:  BZ    9548
0952E:  ANDLW  0F
09530:  SUBWF  xD5,W
09532:  BZ    9536
09534:  BC    9586
09536:  BTFSC  xD3.7
09538:  BRA    9586
0953A:  BTFSC  xD3.6
0953C:  BRA    9548
0953E:  MOVLW  20
09540:  BRA    957C
09542:  MOVLW  20
09544:  MOVLB  8
09546:  ANDWF  xD3,F
09548:  BTFSS  xD3.5
0954A:  BRA    9560
0954C:  BCF    xD3.5
0954E:  MOVFF  00,8D3
09552:  MOVLW  2D
09554:  BTFSS  F9E.4
09556:  BRA    9554
09558:  MOVWF  FAD
0955A:  MOVFF  8D3,00
0955E:  CLRF   xD3
09560:  MOVLW  30
09562:  BTFSS  xD3.5
09564:  BRA    957C
09566:  BCF    xD3.5
09568:  MOVFF  00,8D3
0956C:  MOVLW  2D
0956E:  BTFSS  F9E.4
09570:  BRA    956E
09572:  MOVWF  FAD
09574:  MOVFF  8D3,00
09578:  CLRF   xD3
0957A:  MOVLW  30
0957C:  ADDWF  00,F
0957E:  MOVF   00,W
09580:  BTFSS  F9E.4
09582:  BRA    9580
09584:  MOVWF  FAD
09586:  BCF    FD8.1
09588:  CLRF   1B
0958A:  BTFSC  FF2.7
0958C:  BSF    1B.7
0958E:  BCF    FF2.7
09590:  MOVFF  8DA,A27
09594:  MOVFF  8D9,A26
09598:  MOVFF  8D8,A25
0959C:  MOVFF  8D7,A24
095A0:  MOVLB  A
095A2:  CLRF   x2B
095A4:  CLRF   x2A
095A6:  CLRF   x29
095A8:  MOVLW  0A
095AA:  MOVWF  x28
095AC:  MOVLB  0
095AE:  CALL   1042
095B2:  BTFSC  1B.7
095B4:  BSF    FF2.7
095B6:  MOVFF  03,8DA
095BA:  MOVFF  02,8D9
095BE:  MOVFF  01,8D8
095C2:  MOVFF  00,8D7
095C6:  MOVLB  8
095C8:  DECFSZ xD5,F
095CA:  BRA    94DA
095CC:  MOVLB  0
095CE:  RETURN 0
*
0A698:  ADDWF  FE8,W
0A69A:  CLRF   FF7
0A69C:  RLCF   FF7,F
0A69E:  ADDLW  B9
0A6A0:  MOVWF  FF6
0A6A2:  MOVLW  A6
0A6A4:  ADDWFC FF7,F
0A6A6:  MOVLW  00
0A6A8:  MOVWF  FF8
0A6AA:  MOVWF  FFB
0A6AC:  TBLRD*-
0A6AE:  MOVF   FF5,W
0A6B0:  MOVWF  FFA
0A6B2:  TBLRD*
0A6B4:  MOVF   FF5,W
0A6B6:  MOVWF  FF9
0A6B8:  DATA F4,9F
0A6BA:  DATA 14,A0
0A6BC:  DATA 3C,A0
0A6BE:  DATA 6C,A0
0A6C0:  DATA 94,A0
*
0AA04:  TBLRD*+
0AA06:  MOVFF  FF6,8C9
0AA0A:  MOVFF  FF7,8CA
0AA0E:  MOVFF  FF8,8CB
0AA12:  MOVFF  FF5,8DC
0AA16:  CALL   5020
0AA1A:  MOVFF  8C9,FF6
0AA1E:  MOVFF  8CA,FF7
0AA22:  MOVFF  8CB,FF8
0AA26:  MOVLB  8
0AA28:  DECFSZ xC8,F
0AA2A:  BRA    AA2E
0AA2C:  BRA    AA32
0AA2E:  MOVLB  0
0AA30:  BRA    AA04
0AA32:  MOVLB  0
0AA34:  RETURN 0
0AA36:  MOVFF  FEA,8DB
0AA3A:  MOVFF  FE9,8DA
0AA3E:  MOVLB  8
0AA40:  SWAPF  xD4,W
0AA42:  IORLW  F0
0AA44:  MOVWF  xD6
0AA46:  ADDWF  xD6,F
0AA48:  ADDLW  E2
0AA4A:  MOVWF  xD7
0AA4C:  ADDLW  32
0AA4E:  MOVWF  xD9
0AA50:  MOVF   xD4,W
0AA52:  ANDLW  0F
0AA54:  ADDWF  xD7,F
0AA56:  ADDWF  xD7,F
0AA58:  ADDWF  xD9,F
0AA5A:  ADDLW  E9
0AA5C:  MOVWF  xD8
0AA5E:  ADDWF  xD8,F
0AA60:  ADDWF  xD8,F
0AA62:  SWAPF  xD3,W
0AA64:  ANDLW  0F
0AA66:  ADDWF  xD8,F
0AA68:  ADDWF  xD9,F
0AA6A:  RLCF   xD8,F
0AA6C:  RLCF   xD9,F
0AA6E:  COMF   xD9,F
0AA70:  RLCF   xD9,F
0AA72:  MOVF   xD3,W
0AA74:  ANDLW  0F
0AA76:  ADDWF  xD9,F
0AA78:  RLCF   xD6,F
0AA7A:  MOVLW  07
0AA7C:  MOVWF  xD5
0AA7E:  MOVLW  0A
0AA80:  DECF   xD8,F
0AA82:  ADDWF  xD9,F
0AA84:  BNC   AA80
0AA86:  DECF   xD7,F
0AA88:  ADDWF  xD8,F
0AA8A:  BNC   AA86
0AA8C:  DECF   xD6,F
0AA8E:  ADDWF  xD7,F
0AA90:  BNC   AA8C
0AA92:  DECF   xD5,F
0AA94:  ADDWF  xD6,F
0AA96:  BNC   AA92
0AA98:  MOVLW  08
0AA9A:  MOVWF  FEA
0AA9C:  MOVLW  D5
0AA9E:  MOVWF  FE9
0AAA0:  MOVLW  07
0AAA2:  ANDWF  xDA,W
0AAA4:  BCF    xDA.6
0AAA6:  ADDWF  FE9,F
0AAA8:  MOVLW  00
0AAAA:  ADDWFC FEA,F
0AAAC:  MOVF   FE9,W
0AAAE:  SUBLW  D9
0AAB0:  BNZ   AABA
0AAB2:  MOVF   FEA,W
0AAB4:  SUBLW  08
0AAB6:  BNZ   AABA
0AAB8:  BSF    xDA.6
0AABA:  MOVF   FEF,W
0AABC:  MOVWF  00
0AABE:  BNZ   AAD0
0AAC0:  BTFSC  xDA.6
0AAC2:  BRA    AAD0
0AAC4:  BTFSC  xDA.4
0AAC6:  BRA    AAF4
0AAC8:  BTFSC  xDA.3
0AACA:  BRA    AAD0
0AACC:  MOVLW  20
0AACE:  BRA    AAD6
0AAD0:  BSF    xDA.3
0AAD2:  BCF    xDA.4
0AAD4:  MOVLW  30
0AAD6:  ADDWF  00,F
0AAD8:  MOVFF  FEA,8D4
0AADC:  MOVFF  FE9,8D3
0AAE0:  MOVFF  00,8DC
0AAE4:  MOVLB  0
0AAE6:  CALL   5020
0AAEA:  MOVFF  8D4,FEA
0AAEE:  MOVFF  8D3,FE9
0AAF2:  MOVLB  8
0AAF4:  MOVF   FEE,W
0AAF6:  BTFSS  xDA.6
0AAF8:  BRA    AAAC
0AAFA:  MOVLB  0
0AAFC:  RETURN 0
*
0ACE8:  ADDWF  FE8,W
0ACEA:  CLRF   FF7
0ACEC:  RLCF   FF7,F
0ACEE:  ADDLW  09
0ACF0:  MOVWF  FF6
0ACF2:  MOVLW  AD
0ACF4:  ADDWFC FF7,F
0ACF6:  MOVLW  00
0ACF8:  MOVWF  FF8
0ACFA:  MOVWF  FFB
0ACFC:  TBLRD*-
0ACFE:  MOVF   FF5,W
0AD00:  MOVWF  FFA
0AD02:  TBLRD*
0AD04:  MOVF   FF5,W
0AD06:  MOVWF  FF9
0AD08:  DATA F8,AB
0AD0A:  DATA E4,AC
0AD0C:  DATA E4,AC
0AD0E:  DATA 58,AB
0AD10:  DATA E4,AC
0AD12:  DATA E4,AC
0AD14:  DATA E4,AC
0AD16:  DATA 1C,AB
0AD18:  DATA E4,AC
0AD1A:  DATA E4,AC
0AD1C:  DATA E4,AC
0AD1E:  DATA 6E,AC
0AD20:  DATA 94,AB
0AD22:  DATA E4,AC
0AD24:  DATA 32,AC
0AD26:  DATA AA,AC
*
0AD82:  TBLRD*+
0AD84:  MOVF   FF5,F
0AD86:  BZ    ADAA
0AD88:  MOVFF  FF6,862
0AD8C:  MOVFF  FF7,863
0AD90:  MOVFF  FF8,864
0AD94:  MOVF   FF5,W
0AD96:  BTFSS  F9E.4
0AD98:  BRA    AD96
0AD9A:  MOVWF  FAD
0AD9C:  MOVFF  862,FF6
0ADA0:  MOVFF  863,FF7
0ADA4:  MOVFF  864,FF8
0ADA8:  BRA    AD82
0ADAA:  RETURN 0
*
0BF36:  MOVLB  8
0BF38:  MOVF   xF0,W
0BF3A:  BTFSC  FD8.2
0BF3C:  BRA    C020
0BF3E:  MOVWF  00
0BF40:  MOVF   xF4,W
0BF42:  BTFSC  FD8.2
0BF44:  BRA    C020
0BF46:  ADDWF  00,F
0BF48:  BNC   BF52
0BF4A:  MOVLW  81
0BF4C:  ADDWF  00,F
0BF4E:  BC    C020
0BF50:  BRA    BF5A
0BF52:  MOVLW  7F
0BF54:  SUBWF  00,F
0BF56:  BNC   C020
0BF58:  BZ    C020
0BF5A:  MOVFF  8F1,8F8
0BF5E:  MOVF   xF5,W
0BF60:  XORWF  xF8,F
0BF62:  BSF    xF1.7
0BF64:  BSF    xF5.7
0BF66:  MOVF   xF3,W
0BF68:  MULWF  xF7
0BF6A:  MOVFF  FF4,8FA
0BF6E:  MOVF   xF2,W
0BF70:  MULWF  xF6
0BF72:  MOVFF  FF4,03
0BF76:  MOVFF  FF3,8F9
0BF7A:  MULWF  xF7
0BF7C:  MOVF   FF3,W
0BF7E:  ADDWF  xFA,F
0BF80:  MOVF   FF4,W
0BF82:  ADDWFC xF9,F
0BF84:  MOVLW  00
0BF86:  ADDWFC 03,F
0BF88:  MOVF   xF3,W
0BF8A:  MULWF  xF6
0BF8C:  MOVF   FF3,W
0BF8E:  ADDWF  xFA,F
0BF90:  MOVF   FF4,W
0BF92:  ADDWFC xF9,F
0BF94:  MOVLW  00
0BF96:  CLRF   02
0BF98:  ADDWFC 03,F
0BF9A:  ADDWFC 02,F
0BF9C:  MOVF   xF1,W
0BF9E:  MULWF  xF7
0BFA0:  MOVF   FF3,W
0BFA2:  ADDWF  xF9,F
0BFA4:  MOVF   FF4,W
0BFA6:  ADDWFC 03,F
0BFA8:  MOVLW  00
0BFAA:  ADDWFC 02,F
0BFAC:  MOVF   xF1,W
0BFAE:  MULWF  xF6
0BFB0:  MOVF   FF3,W
0BFB2:  ADDWF  03,F
0BFB4:  MOVF   FF4,W
0BFB6:  ADDWFC 02,F
0BFB8:  MOVLW  00
0BFBA:  CLRF   01
0BFBC:  ADDWFC 01,F
0BFBE:  MOVF   xF3,W
0BFC0:  MULWF  xF5
0BFC2:  MOVF   FF3,W
0BFC4:  ADDWF  xF9,F
0BFC6:  MOVF   FF4,W
0BFC8:  ADDWFC 03,F
0BFCA:  MOVLW  00
0BFCC:  ADDWFC 02,F
0BFCE:  ADDWFC 01,F
0BFD0:  MOVF   xF2,W
0BFD2:  MULWF  xF5
0BFD4:  MOVF   FF3,W
0BFD6:  ADDWF  03,F
0BFD8:  MOVF   FF4,W
0BFDA:  ADDWFC 02,F
0BFDC:  MOVLW  00
0BFDE:  ADDWFC 01,F
0BFE0:  MOVF   xF1,W
0BFE2:  MULWF  xF5
0BFE4:  MOVF   FF3,W
0BFE6:  ADDWF  02,F
0BFE8:  MOVF   FF4,W
0BFEA:  ADDWFC 01,F
0BFEC:  INCF   00,F
0BFEE:  BTFSC  01.7
0BFF0:  BRA    BFFC
0BFF2:  RLCF   xF9,F
0BFF4:  RLCF   03,F
0BFF6:  RLCF   02,F
0BFF8:  RLCF   01,F
0BFFA:  DECF   00,F
0BFFC:  MOVLW  00
0BFFE:  BTFSS  xF9.7
0C000:  BRA    C016
0C002:  INCF   03,F
0C004:  ADDWFC 02,F
0C006:  ADDWFC 01,F
0C008:  MOVF   01,W
0C00A:  BNZ   C016
0C00C:  MOVF   02,W
0C00E:  BNZ   C016
0C010:  MOVF   03,W
0C012:  BNZ   C016
0C014:  INCF   00,F
0C016:  BTFSC  xF8.7
0C018:  BSF    01.7
0C01A:  BTFSS  xF8.7
0C01C:  BCF    01.7
0C01E:  BRA    C028
0C020:  CLRF   00
0C022:  CLRF   01
0C024:  CLRF   02
0C026:  CLRF   03
0C028:  MOVLB  0
0C02A:  RETURN 0
0C02C:  MOVLW  80
0C02E:  BTFSS  FD8.1
0C030:  BRA    C036
0C032:  MOVLB  8
0C034:  XORWF  xF9,F
0C036:  MOVLB  8
0C038:  CLRF   xFE
0C03A:  CLRF   xFF
0C03C:  MOVFF  8F5,8FD
0C040:  MOVF   xF9,W
0C042:  XORWF  xFD,F
0C044:  MOVF   xF4,W
0C046:  BTFSC  FD8.2
0C048:  BRA    C294
0C04A:  MOVWF  xFC
0C04C:  MOVWF  00
0C04E:  MOVF   xF8,W
0C050:  BTFSC  FD8.2
0C052:  BRA    C2A8
0C054:  SUBWF  xFC,F
0C056:  BTFSC  FD8.2
0C058:  BRA    C19A
0C05A:  BNC   C0F6
0C05C:  MOVFF  8F9,902
0C060:  MOVLB  9
0C062:  BSF    x02.7
0C064:  MOVFF  8FA,901
0C068:  MOVFF  8FB,900
0C06C:  MOVLB  8
0C06E:  CLRF   xFF
0C070:  BCF    FD8.0
0C072:  MOVLB  9
0C074:  RRCF   x02,F
0C076:  RRCF   x01,F
0C078:  RRCF   x00,F
0C07A:  MOVLB  8
0C07C:  RRCF   xFF,F
0C07E:  DECFSZ xFC,F
0C080:  BRA    C06E
0C082:  BTFSS  xFD.7
0C084:  BRA    C08C
0C086:  BSF    xFE.0
0C088:  BRA    C2D8
0C08A:  BCF    xFE.0
0C08C:  BCF    xFC.0
0C08E:  BSF    xFE.4
0C090:  MOVLW  08
0C092:  MOVWF  FEA
0C094:  MOVLW  F7
0C096:  MOVWF  FE9
0C098:  BRA    C312
0C09A:  BCF    xFE.4
0C09C:  BTFSC  xFD.7
0C09E:  BRA    C0B8
0C0A0:  BTFSS  xFC.0
0C0A2:  BRA    C0D8
0C0A4:  MOVLB  9
0C0A6:  RRCF   x02,F
0C0A8:  RRCF   x01,F
0C0AA:  RRCF   x00,F
0C0AC:  MOVLB  8
0C0AE:  RRCF   xFF,F
0C0B0:  INCF   00,F
0C0B2:  BTFSC  FD8.2
0C0B4:  BRA    C2CA
0C0B6:  BRA    C0D8
0C0B8:  MOVLB  9
0C0BA:  BTFSC  x02.7
0C0BC:  BRA    C0DE
0C0BE:  BCF    FD8.0
0C0C0:  MOVLB  8
0C0C2:  RLCF   xFF,F
0C0C4:  MOVLB  9
0C0C6:  RLCF   x00,F
0C0C8:  RLCF   x01,F
0C0CA:  RLCF   x02,F
0C0CC:  DECFSZ 00,F
0C0CE:  BRA    C0D4
0C0D0:  MOVLB  8
0C0D2:  BRA    C2CA
0C0D4:  BRA    C0BA
0C0D6:  MOVLB  8
0C0D8:  BSF    xFE.6
0C0DA:  BRA    C1E8
0C0DC:  BCF    xFE.6
0C0DE:  MOVFF  8F5,8FD
0C0E2:  MOVLB  8
0C0E4:  BTFSS  xF5.7
0C0E6:  BRA    C0EE
0C0E8:  MOVLB  9
0C0EA:  BSF    x02.7
0C0EC:  BRA    C2BA
0C0EE:  MOVLB  9
0C0F0:  BCF    x02.7
0C0F2:  BRA    C2BA
0C0F4:  MOVLB  8
0C0F6:  MOVFF  8F8,8FC
0C0FA:  MOVFF  8F8,00
0C0FE:  MOVF   xF4,W
0C100:  SUBWF  xFC,F
0C102:  MOVFF  8F5,902
0C106:  MOVLB  9
0C108:  BSF    x02.7
0C10A:  MOVFF  8F6,901
0C10E:  MOVFF  8F7,900
0C112:  MOVLB  8
0C114:  CLRF   xFF
0C116:  BCF    FD8.0
0C118:  MOVLB  9
0C11A:  RRCF   x02,F
0C11C:  RRCF   x01,F
0C11E:  RRCF   x00,F
0C120:  MOVLB  8
0C122:  RRCF   xFF,F
0C124:  DECFSZ xFC,F
0C126:  BRA    C114
0C128:  BTFSS  xFD.7
0C12A:  BRA    C132
0C12C:  BSF    xFE.1
0C12E:  BRA    C2D8
0C130:  BCF    xFE.1
0C132:  BCF    xFC.0
0C134:  BSF    xFE.5
0C136:  MOVLW  08
0C138:  MOVWF  FEA
0C13A:  MOVLW  FB
0C13C:  MOVWF  FE9
0C13E:  BRA    C312
0C140:  BCF    xFE.5
0C142:  BTFSC  xFD.7
0C144:  BRA    C15E
0C146:  BTFSS  xFC.0
0C148:  BRA    C17E
0C14A:  MOVLB  9
0C14C:  RRCF   x02,F
0C14E:  RRCF   x01,F
0C150:  RRCF   x00,F
0C152:  MOVLB  8
0C154:  RRCF   xFF,F
0C156:  INCF   00,F
0C158:  BTFSC  FD8.2
0C15A:  BRA    C2CA
0C15C:  BRA    C17E
0C15E:  MOVLB  9
0C160:  BTFSC  x02.7
0C162:  BRA    C184
0C164:  BCF    FD8.0
0C166:  MOVLB  8
0C168:  RLCF   xFF,F
0C16A:  MOVLB  9
0C16C:  RLCF   x00,F
0C16E:  RLCF   x01,F
0C170:  RLCF   x02,F
0C172:  DECFSZ 00,F
0C174:  BRA    C17A
0C176:  MOVLB  8
0C178:  BRA    C2CA
0C17A:  BRA    C160
0C17C:  MOVLB  8
0C17E:  BSF    xFE.7
0C180:  BRA    C1E8
0C182:  BCF    xFE.7
0C184:  MOVFF  8F9,8FD
0C188:  MOVLB  8
0C18A:  BTFSS  xF9.7
0C18C:  BRA    C194
0C18E:  MOVLB  9
0C190:  BSF    x02.7
0C192:  BRA    C2BA
0C194:  MOVLB  9
0C196:  BCF    x02.7
0C198:  BRA    C2BA
0C19A:  MOVFF  8F9,902
0C19E:  MOVLB  9
0C1A0:  BSF    x02.7
0C1A2:  MOVFF  8FA,901
0C1A6:  MOVFF  8FB,900
0C1AA:  MOVLB  8
0C1AC:  BTFSS  xFD.7
0C1AE:  BRA    C1BC
0C1B0:  MOVLB  9
0C1B2:  BCF    x02.7
0C1B4:  MOVLB  8
0C1B6:  BSF    xFE.2
0C1B8:  BRA    C2D8
0C1BA:  BCF    xFE.2
0C1BC:  CLRF   xFF
0C1BE:  BCF    xFC.0
0C1C0:  MOVLW  08
0C1C2:  MOVWF  FEA
0C1C4:  MOVLW  F7
0C1C6:  MOVWF  FE9
0C1C8:  BRA    C312
0C1CA:  BTFSC  xFD.7
0C1CC:  BRA    C228
0C1CE:  MOVFF  8F5,8FD
0C1D2:  BTFSS  xFC.0
0C1D4:  BRA    C1E8
0C1D6:  MOVLB  9
0C1D8:  RRCF   x02,F
0C1DA:  RRCF   x01,F
0C1DC:  RRCF   x00,F
0C1DE:  MOVLB  8
0C1E0:  RRCF   xFF,F
0C1E2:  INCF   00,F
0C1E4:  BTFSC  FD8.2
0C1E6:  BRA    C2CA
0C1E8:  BTFSS  xFF.7
0C1EA:  BRA    C21E
0C1EC:  MOVLB  9
0C1EE:  INCF   x00,F
0C1F0:  BTFSC  FD8.2
0C1F2:  BRA    C1F8
0C1F4:  MOVLB  8
0C1F6:  BRA    C21E
0C1F8:  INCF   x01,F
0C1FA:  BTFSC  FD8.2
0C1FC:  BRA    C202
0C1FE:  MOVLB  8
0C200:  BRA    C21E
0C202:  INCF   x02,F
0C204:  BTFSC  FD8.2
0C206:  BRA    C20C
0C208:  MOVLB  8
0C20A:  BRA    C21E
0C20C:  RRCF   x02,F
0C20E:  RRCF   x01,F
0C210:  RRCF   x00,F
0C212:  INCF   00,F
0C214:  BTFSS  FD8.2
0C216:  BRA    C21C
0C218:  MOVLB  8
0C21A:  BRA    C2CA
0C21C:  MOVLB  8
0C21E:  BTFSC  xFE.6
0C220:  BRA    C0DC
0C222:  BTFSC  xFE.7
0C224:  BRA    C182
0C226:  BRA    C284
0C228:  MOVLW  80
0C22A:  MOVLB  9
0C22C:  XORWF  x02,F
0C22E:  BTFSS  x02.7
0C230:  BRA    C23E
0C232:  MOVLB  8
0C234:  BRA    C2D8
0C236:  MOVFF  8F9,8FD
0C23A:  BRA    C264
0C23C:  MOVLB  9
0C23E:  MOVFF  8F5,8FD
0C242:  MOVF   x02,F
0C244:  BTFSC  FD8.2
0C246:  BRA    C24C
0C248:  MOVLB  8
0C24A:  BRA    C264
0C24C:  MOVF   x01,F
0C24E:  BTFSC  FD8.2
0C250:  BRA    C256
0C252:  MOVLB  8
0C254:  BRA    C264
0C256:  MOVF   x00,F
0C258:  BTFSC  FD8.2
0C25A:  BRA    C260
0C25C:  MOVLB  8
0C25E:  BRA    C264
0C260:  CLRF   00
0C262:  BRA    C2BA
0C264:  MOVLB  9
0C266:  BTFSS  x02.7
0C268:  BRA    C26E
0C26A:  MOVLB  8
0C26C:  BRA    C284
0C26E:  BCF    FD8.0
0C270:  MOVLB  8
0C272:  RLCF   xFF,F
0C274:  MOVLB  9
0C276:  RLCF   x00,F
0C278:  RLCF   x01,F
0C27A:  RLCF   x02,F
0C27C:  DECFSZ 00,F
0C27E:  BRA    C266
0C280:  MOVLB  8
0C282:  BRA    C2CA
0C284:  BTFSS  xFD.7
0C286:  BRA    C28E
0C288:  MOVLB  9
0C28A:  BSF    x02.7
0C28C:  BRA    C2BA
0C28E:  MOVLB  9
0C290:  BCF    x02.7
0C292:  BRA    C2BA
0C294:  MOVFF  8F8,00
0C298:  MOVFF  8F9,902
0C29C:  MOVFF  8FA,901
0C2A0:  MOVFF  8FB,900
0C2A4:  MOVLB  9
0C2A6:  BRA    C2BA
0C2A8:  MOVFF  8F4,00
0C2AC:  MOVFF  8F5,902
0C2B0:  MOVFF  8F6,901
0C2B4:  MOVFF  8F7,900
0C2B8:  MOVLB  9
0C2BA:  MOVFF  902,01
0C2BE:  MOVFF  901,02
0C2C2:  MOVFF  900,03
0C2C6:  BRA    C360
0C2C8:  MOVLB  8
0C2CA:  CLRF   00
0C2CC:  CLRF   01
0C2CE:  CLRF   02
0C2D0:  CLRF   03
0C2D2:  MOVLB  9
0C2D4:  BRA    C360
0C2D6:  MOVLB  8
0C2D8:  CLRF   xFF
0C2DA:  MOVLB  9
0C2DC:  COMF   x00,F
0C2DE:  COMF   x01,F
0C2E0:  COMF   x02,F
0C2E2:  MOVLB  8
0C2E4:  COMF   xFF,F
0C2E6:  INCF   xFF,F
0C2E8:  BNZ   C304
0C2EA:  MOVLB  9
0C2EC:  INCF   x00,F
0C2EE:  BTFSC  FD8.2
0C2F0:  BRA    C2F6
0C2F2:  MOVLB  8
0C2F4:  BRA    C304
0C2F6:  INCF   x01,F
0C2F8:  BTFSC  FD8.2
0C2FA:  BRA    C300
0C2FC:  MOVLB  8
0C2FE:  BRA    C304
0C300:  INCF   x02,F
0C302:  MOVLB  8
0C304:  BTFSC  xFE.0
0C306:  BRA    C08A
0C308:  BTFSC  xFE.1
0C30A:  BRA    C130
0C30C:  BTFSC  xFE.2
0C30E:  BRA    C1BA
0C310:  BRA    C236
0C312:  MOVF   FEF,W
0C314:  MOVLB  9
0C316:  ADDWF  x00,F
0C318:  BNC   C32A
0C31A:  INCF   x01,F
0C31C:  BNZ   C32A
0C31E:  INCF   x02,F
0C320:  BTFSS  FD8.2
0C322:  BRA    C32A
0C324:  MOVLB  8
0C326:  BSF    xFC.0
0C328:  MOVLB  9
0C32A:  MOVF   FED,F
0C32C:  MOVF   FEF,W
0C32E:  ADDWF  x01,F
0C330:  BNC   C33E
0C332:  INCF   x02,F
0C334:  BTFSS  FD8.2
0C336:  BRA    C33E
0C338:  MOVLB  8
0C33A:  BSF    xFC.0
0C33C:  MOVLB  9
0C33E:  MOVF   FED,F
0C340:  MOVF   FEF,W
0C342:  BTFSC  FEF.7
0C344:  BRA    C348
0C346:  XORLW  80
0C348:  ADDWF  x02,F
0C34A:  BTFSS  FD8.0
0C34C:  BRA    C352
0C34E:  MOVLB  8
0C350:  BSF    xFC.0
0C352:  MOVLB  8
0C354:  BTFSC  xFE.4
0C356:  BRA    C09A
0C358:  BTFSC  xFE.5
0C35A:  BRA    C140
0C35C:  BRA    C1CA
0C35E:  MOVLB  9
0C360:  MOVLB  0
0C362:  RETURN 0
0C364:  MOVLB  8
0C366:  MOVF   xB9,W
0C368:  SUBLW  B6
0C36A:  MOVWF  xB9
0C36C:  CLRF   03
0C36E:  MOVFF  8BA,8BD
0C372:  BSF    xBA.7
0C374:  BCF    FD8.0
0C376:  RRCF   xBA,F
0C378:  RRCF   xBB,F
0C37A:  RRCF   xBC,F
0C37C:  RRCF   03,F
0C37E:  RRCF   02,F
0C380:  RRCF   01,F
0C382:  RRCF   00,F
0C384:  DECFSZ xB9,F
0C386:  BRA    C374
0C388:  BTFSS  xBD.7
0C38A:  BRA    C3A2
0C38C:  COMF   00,F
0C38E:  COMF   01,F
0C390:  COMF   02,F
0C392:  COMF   03,F
0C394:  INCF   00,F
0C396:  BTFSC  FD8.2
0C398:  INCF   01,F
0C39A:  BTFSC  FD8.2
0C39C:  INCF   02,F
0C39E:  BTFSC  FD8.2
0C3A0:  INCF   03,F
0C3A2:  MOVLB  0
0C3A4:  RETURN 0
0C3A6:  MOVF   FE9,W
0C3A8:  MOVLB  8
0C3AA:  MOVWF  x67
0C3AC:  MOVF   x66,W
0C3AE:  MOVWF  x69
0C3B0:  BZ    C3E8
0C3B2:  MOVFF  865,8F3
0C3B6:  MOVFF  864,8F2
0C3BA:  MOVFF  863,8F1
0C3BE:  MOVFF  862,8F0
0C3C2:  CLRF   xF7
0C3C4:  CLRF   xF6
0C3C6:  MOVLW  20
0C3C8:  MOVWF  xF5
0C3CA:  MOVLW  82
0C3CC:  MOVWF  xF4
0C3CE:  MOVLB  0
0C3D0:  RCALL  BF36
0C3D2:  MOVFF  03,865
0C3D6:  MOVFF  02,864
0C3DA:  MOVFF  01,863
0C3DE:  MOVFF  00,862
0C3E2:  MOVLB  8
0C3E4:  DECFSZ x69,F
0C3E6:  BRA    C3B2
0C3E8:  MOVLW  7E
0C3EA:  MOVWF  00
0C3EC:  CLRF   01
0C3EE:  BTFSC  x63.7
0C3F0:  BSF    01.7
0C3F2:  CLRF   02
0C3F4:  CLRF   03
0C3F6:  BCF    FD8.1
0C3F8:  MOVFF  865,8F7
0C3FC:  MOVFF  864,8F6
0C400:  MOVFF  863,8F5
0C404:  MOVFF  862,8F4
0C408:  MOVFF  03,8FB
0C40C:  MOVFF  02,8FA
0C410:  MOVFF  01,8F9
0C414:  MOVWF  xF8
0C416:  MOVLB  0
0C418:  RCALL  C02C
0C41A:  MOVFF  03,865
0C41E:  MOVFF  02,864
0C422:  MOVFF  01,863
0C426:  MOVFF  00,862
0C42A:  MOVFF  865,8BC
0C42E:  MOVFF  864,8BB
0C432:  MOVFF  863,8BA
0C436:  MOVFF  862,8B9
0C43A:  RCALL  C364
0C43C:  MOVFF  03,865
0C440:  MOVFF  02,864
0C444:  MOVFF  01,863
0C448:  MOVFF  00,862
0C44C:  MOVLB  8
0C44E:  BTFSS  x65.7
0C450:  BRA    C46C
0C452:  DECF   x67,F
0C454:  BSF    x67.5
0C456:  COMF   x62,F
0C458:  COMF   x63,F
0C45A:  COMF   x64,F
0C45C:  COMF   x65,F
0C45E:  INCF   x62,F
0C460:  BTFSC  FD8.2
0C462:  INCF   x63,F
0C464:  BTFSC  FD8.2
0C466:  INCF   x64,F
0C468:  BTFSC  FD8.2
0C46A:  INCF   x65,F
0C46C:  MOVLW  3B
0C46E:  MOVWF  x6E
0C470:  MOVLW  9A
0C472:  MOVWF  x6D
0C474:  MOVLW  CA
0C476:  MOVWF  x6C
0C478:  CLRF   x6B
0C47A:  MOVLW  0A
0C47C:  MOVWF  x69
0C47E:  MOVF   x66,W
0C480:  BTFSC  FD8.2
0C482:  INCF   x67,F
0C484:  BSF    FD8.1
0C486:  MOVLW  08
0C488:  MOVWF  FEA
0C48A:  MOVLW  62
0C48C:  MOVWF  FE9
0C48E:  CLRF   1B
0C490:  BTFSC  FF2.7
0C492:  BSF    1B.7
0C494:  BCF    FF2.7
0C496:  MOVFF  865,A27
0C49A:  MOVFF  864,A26
0C49E:  MOVFF  863,A25
0C4A2:  MOVFF  862,A24
0C4A6:  MOVFF  86E,A2B
0C4AA:  MOVFF  86D,A2A
0C4AE:  MOVFF  86C,A29
0C4B2:  MOVFF  86B,A28
0C4B6:  MOVLB  0
0C4B8:  CALL   1042
0C4BC:  BTFSC  1B.7
0C4BE:  BSF    FF2.7
0C4C0:  MOVF   01,W
0C4C2:  MOVF   00,F
0C4C4:  BNZ   C4EC
0C4C6:  MOVLB  8
0C4C8:  INCF   x66,W
0C4CA:  SUBWF  x69,W
0C4CC:  BTFSS  FD8.2
0C4CE:  BRA    C4D4
0C4D0:  MOVLB  0
0C4D2:  BRA    C4EC
0C4D4:  MOVF   x67,W
0C4D6:  BZ    C4F2
0C4D8:  ANDLW  0F
0C4DA:  SUBWF  x69,W
0C4DC:  BZ    C4E0
0C4DE:  BC    C558
0C4E0:  BTFSC  x67.7
0C4E2:  BRA    C558
0C4E4:  BTFSC  x67.6
0C4E6:  BRA    C4F2
0C4E8:  MOVLW  20
0C4EA:  BRA    C54E
0C4EC:  MOVLW  20
0C4EE:  MOVLB  8
0C4F0:  ANDWF  x67,F
0C4F2:  BTFSS  x67.5
0C4F4:  BRA    C510
0C4F6:  BCF    x67.5
0C4F8:  MOVF   x66,W
0C4FA:  BTFSS  FD8.2
0C4FC:  DECF   x67,F
0C4FE:  MOVF   00,W
0C500:  MOVWF  x67
0C502:  MOVLW  2D
0C504:  BTFSS  F9E.4
0C506:  BRA    C504
0C508:  MOVWF  FAD
0C50A:  MOVF   x67,W
0C50C:  MOVWF  00
0C50E:  CLRF   x67
0C510:  MOVF   x66,W
0C512:  SUBWF  x69,W
0C514:  BNZ   C52C
0C516:  MOVF   00,W
0C518:  MOVWF  x67
0C51A:  MOVLW  2E
0C51C:  BTFSS  F9E.4
0C51E:  BRA    C51C
0C520:  MOVWF  FAD
0C522:  MOVF   x67,W
0C524:  MOVWF  00
0C526:  MOVLW  20
0C528:  ANDWF  x67,F
0C52A:  MOVLW  00
0C52C:  MOVLW  30
0C52E:  BTFSS  x67.5
0C530:  BRA    C54E
0C532:  BCF    x67.5
0C534:  MOVF   x66,W
0C536:  BTFSS  FD8.2
0C538:  DECF   x67,F
0C53A:  MOVF   00,W
0C53C:  MOVWF  x67
0C53E:  MOVLW  2D
0C540:  BTFSS  F9E.4
0C542:  BRA    C540
0C544:  MOVWF  FAD
0C546:  MOVF   x67,W
0C548:  MOVWF  00
0C54A:  CLRF   x67
0C54C:  MOVLW  30
0C54E:  ADDWF  00,F
0C550:  MOVF   00,W
0C552:  BTFSS  F9E.4
0C554:  BRA    C552
0C556:  MOVWF  FAD
0C558:  BCF    FD8.1
0C55A:  CLRF   1B
0C55C:  BTFSC  FF2.7
0C55E:  BSF    1B.7
0C560:  BCF    FF2.7
0C562:  MOVFF  86E,A27
0C566:  MOVFF  86D,A26
0C56A:  MOVFF  86C,A25
0C56E:  MOVFF  86B,A24
0C572:  MOVLB  A
0C574:  CLRF   x2B
0C576:  CLRF   x2A
0C578:  CLRF   x29
0C57A:  MOVLW  0A
0C57C:  MOVWF  x28
0C57E:  MOVLB  0
0C580:  CALL   1042
0C584:  BTFSC  1B.7
0C586:  BSF    FF2.7
0C588:  MOVFF  03,86E
0C58C:  MOVFF  02,86D
0C590:  MOVFF  01,86C
0C594:  MOVFF  00,86B
0C598:  MOVLB  8
0C59A:  DECFSZ x69,F
0C59C:  BRA    C484
0C59E:  MOVLB  0
0C5A0:  RETURN 0
*
0C624:  MOVLW  8E
0C626:  MOVWF  00
0C628:  MOVFF  8F5,01
0C62C:  MOVFF  8F4,02
0C630:  CLRF   03
0C632:  MOVF   01,F
0C634:  BNZ   C648
0C636:  MOVFF  02,01
0C63A:  CLRF   02
0C63C:  MOVLW  08
0C63E:  SUBWF  00,F
0C640:  MOVF   01,F
0C642:  BNZ   C648
0C644:  CLRF   00
0C646:  BRA    C658
0C648:  BCF    FD8.0
0C64A:  BTFSC  01.7
0C64C:  BRA    C656
0C64E:  RLCF   02,F
0C650:  RLCF   01,F
0C652:  DECF   00,F
0C654:  BRA    C648
0C656:  BCF    01.7
0C658:  RETURN 0
0C65A:  MOVLB  8
0C65C:  MOVF   xD8,W
0C65E:  BTFSC  FD8.2
0C660:  BRA    C7AC
0C662:  MOVWF  xE4
0C664:  MOVF   xDC,W
0C666:  BTFSC  FD8.2
0C668:  BRA    C7AC
0C66A:  SUBWF  xE4,F
0C66C:  BNC   C678
0C66E:  MOVLW  7F
0C670:  ADDWF  xE4,F
0C672:  BTFSC  FD8.0
0C674:  BRA    C7AC
0C676:  BRA    C684
0C678:  MOVLW  81
0C67A:  SUBWF  xE4,F
0C67C:  BTFSS  FD8.0
0C67E:  BRA    C7AC
0C680:  BTFSC  FD8.2
0C682:  BRA    C7AC
0C684:  MOVFF  8E4,00
0C688:  CLRF   01
0C68A:  CLRF   02
0C68C:  CLRF   03
0C68E:  CLRF   xE3
0C690:  MOVFF  8D9,8E2
0C694:  BSF    xE2.7
0C696:  MOVFF  8DA,8E1
0C69A:  MOVFF  8DB,8E0
0C69E:  MOVLW  19
0C6A0:  MOVWF  xE4
0C6A2:  MOVF   xDF,W
0C6A4:  SUBWF  xE0,F
0C6A6:  BC    C6C2
0C6A8:  MOVLW  01
0C6AA:  SUBWF  xE1,F
0C6AC:  BC    C6C2
0C6AE:  SUBWF  xE2,F
0C6B0:  BC    C6C2
0C6B2:  SUBWF  xE3,F
0C6B4:  BC    C6C2
0C6B6:  INCF   xE3,F
0C6B8:  INCF   xE2,F
0C6BA:  INCF   xE1,F
0C6BC:  MOVF   xDF,W
0C6BE:  ADDWF  xE0,F
0C6C0:  BRA    C712
0C6C2:  MOVF   xDE,W
0C6C4:  SUBWF  xE1,F
0C6C6:  BC    C6EC
0C6C8:  MOVLW  01
0C6CA:  SUBWF  xE2,F
0C6CC:  BC    C6EC
0C6CE:  SUBWF  xE3,F
0C6D0:  BC    C6EC
0C6D2:  INCF   xE3,F
0C6D4:  INCF   xE2,F
0C6D6:  MOVF   xDE,W
0C6D8:  ADDWF  xE1,F
0C6DA:  MOVF   xDF,W
0C6DC:  ADDWF  xE0,F
0C6DE:  BNC   C712
0C6E0:  INCF   xE1,F
0C6E2:  BNZ   C712
0C6E4:  INCF   xE2,F
0C6E6:  BNZ   C712
0C6E8:  INCF   xE3,F
0C6EA:  BRA    C712
0C6EC:  MOVF   xDD,W
0C6EE:  IORLW  80
0C6F0:  SUBWF  xE2,F
0C6F2:  BC    C710
0C6F4:  MOVLW  01
0C6F6:  SUBWF  xE3,F
0C6F8:  BC    C710
0C6FA:  INCF   xE3,F
0C6FC:  MOVF   xDD,W
0C6FE:  IORLW  80
0C700:  ADDWF  xE2,F
0C702:  MOVF   xDE,W
0C704:  ADDWF  xE1,F
0C706:  BNC   C6DA
0C708:  INCF   xE2,F
0C70A:  BNZ   C6DA
0C70C:  INCF   xE3,F
0C70E:  BRA    C6DA
0C710:  BSF    03.0
0C712:  DECFSZ xE4,F
0C714:  BRA    C718
0C716:  BRA    C72E
0C718:  BCF    FD8.0
0C71A:  RLCF   xE0,F
0C71C:  RLCF   xE1,F
0C71E:  RLCF   xE2,F
0C720:  RLCF   xE3,F
0C722:  BCF    FD8.0
0C724:  RLCF   03,F
0C726:  RLCF   02,F
0C728:  RLCF   01,F
0C72A:  RLCF   xE5,F
0C72C:  BRA    C6A2
0C72E:  BTFSS  xE5.0
0C730:  BRA    C73E
0C732:  BCF    FD8.0
0C734:  RRCF   01,F
0C736:  RRCF   02,F
0C738:  RRCF   03,F
0C73A:  RRCF   xE5,F
0C73C:  BRA    C742
0C73E:  DECF   00,F
0C740:  BZ    C7AC
0C742:  BTFSC  xE5.7
0C744:  BRA    C782
0C746:  BCF    FD8.0
0C748:  RLCF   xE0,F
0C74A:  RLCF   xE1,F
0C74C:  RLCF   xE2,F
0C74E:  RLCF   xE3,F
0C750:  MOVF   xDF,W
0C752:  SUBWF  xE0,F
0C754:  BC    C764
0C756:  MOVLW  01
0C758:  SUBWF  xE1,F
0C75A:  BC    C764
0C75C:  SUBWF  xE2,F
0C75E:  BC    C764
0C760:  SUBWF  xE3,F
0C762:  BNC   C798
0C764:  MOVF   xDE,W
0C766:  SUBWF  xE1,F
0C768:  BC    C774
0C76A:  MOVLW  01
0C76C:  SUBWF  xE2,F
0C76E:  BC    C774
0C770:  SUBWF  xE3,F
0C772:  BNC   C798
0C774:  MOVF   xDD,W
0C776:  IORLW  80
0C778:  SUBWF  xE2,F
0C77A:  BC    C782
0C77C:  MOVLW  01
0C77E:  SUBWF  xE3,F
0C780:  BNC   C798
0C782:  INCF   03,F
0C784:  BNZ   C798
0C786:  INCF   02,F
0C788:  BNZ   C798
0C78A:  INCF   01,F
0C78C:  BNZ   C798
0C78E:  INCF   00,F
0C790:  BZ    C7AC
0C792:  RRCF   01,F
0C794:  RRCF   02,F
0C796:  RRCF   03,F
0C798:  MOVFF  8D9,8E4
0C79C:  MOVF   xDD,W
0C79E:  XORWF  xE4,F
0C7A0:  BTFSS  xE4.7
0C7A2:  BRA    C7A8
0C7A4:  BSF    01.7
0C7A6:  BRA    C7B4
0C7A8:  BCF    01.7
0C7AA:  BRA    C7B4
0C7AC:  CLRF   00
0C7AE:  CLRF   01
0C7B0:  CLRF   02
0C7B2:  CLRF   03
0C7B4:  MOVLB  0
0C7B6:  RETURN 0
*
0D242:  MOVFF  FEA,8A6
0D246:  MOVFF  FE9,8A5
0D24A:  MOVLB  8
0D24C:  BTFSS  x9F.7
0D24E:  BRA    D260
0D250:  BSF    xA5.7
0D252:  BTFSS  xA5.4
0D254:  INCF   xA5,F
0D256:  COMF   x9E,F
0D258:  COMF   x9F,F
0D25A:  INCF   x9E,F
0D25C:  BTFSC  FD8.2
0D25E:  INCF   x9F,F
0D260:  SWAPF  x9F,W
0D262:  IORLW  F0
0D264:  MOVWF  xA1
0D266:  ADDWF  xA1,F
0D268:  ADDLW  E2
0D26A:  MOVWF  xA2
0D26C:  ADDLW  32
0D26E:  MOVWF  xA4
0D270:  MOVF   x9F,W
0D272:  ANDLW  0F
0D274:  ADDWF  xA2,F
0D276:  ADDWF  xA2,F
0D278:  ADDWF  xA4,F
0D27A:  ADDLW  E9
0D27C:  MOVWF  xA3
0D27E:  ADDWF  xA3,F
0D280:  ADDWF  xA3,F
0D282:  SWAPF  x9E,W
0D284:  ANDLW  0F
0D286:  ADDWF  xA3,F
0D288:  ADDWF  xA4,F
0D28A:  RLCF   xA3,F
0D28C:  RLCF   xA4,F
0D28E:  COMF   xA4,F
0D290:  RLCF   xA4,F
0D292:  MOVF   x9E,W
0D294:  ANDLW  0F
0D296:  ADDWF  xA4,F
0D298:  RLCF   xA1,F
0D29A:  MOVLW  07
0D29C:  MOVWF  xA0
0D29E:  MOVLW  0A
0D2A0:  DECF   xA3,F
0D2A2:  ADDWF  xA4,F
0D2A4:  BNC   D2A0
0D2A6:  DECF   xA2,F
0D2A8:  ADDWF  xA3,F
0D2AA:  BNC   D2A6
0D2AC:  DECF   xA1,F
0D2AE:  ADDWF  xA2,F
0D2B0:  BNC   D2AC
0D2B2:  DECF   xA0,F
0D2B4:  ADDWF  xA1,F
0D2B6:  BNC   D2B2
0D2B8:  MOVLW  08
0D2BA:  MOVWF  FEA
0D2BC:  MOVLW  A0
0D2BE:  MOVWF  FE9
0D2C0:  MOVLW  07
0D2C2:  ANDWF  xA5,W
0D2C4:  BCF    xA5.6
0D2C6:  MOVF   FED,F
0D2C8:  ANDWF  xA5,W
0D2CA:  BNZ   D2DA
0D2CC:  BTFSC  xA5.4
0D2CE:  MOVF   FEE,F
0D2D0:  BTFSC  xA5.4
0D2D2:  BRA    D2DA
0D2D4:  MOVLW  20
0D2D6:  MOVWF  00
0D2D8:  BRA    D31C
0D2DA:  ADDWF  FE9,F
0D2DC:  MOVLW  00
0D2DE:  ADDWFC FEA,F
0D2E0:  MOVF   FE9,W
0D2E2:  SUBLW  A4
0D2E4:  BNZ   D2EE
0D2E6:  MOVF   FEA,W
0D2E8:  SUBLW  08
0D2EA:  BNZ   D2EE
0D2EC:  BSF    xA5.6
0D2EE:  MOVF   FEF,W
0D2F0:  MOVWF  00
0D2F2:  BNZ   D304
0D2F4:  BTFSC  xA5.6
0D2F6:  BRA    D304
0D2F8:  BTFSC  xA5.4
0D2FA:  BRA    D338
0D2FC:  BTFSC  xA5.3
0D2FE:  BRA    D304
0D300:  MOVLW  20
0D302:  BRA    D31A
0D304:  BTFSS  xA5.7
0D306:  BRA    D314
0D308:  MOVLW  2D
0D30A:  MOVWF  00
0D30C:  MOVF   FED,W
0D30E:  BCF    xA5.6
0D310:  BCF    xA5.7
0D312:  BRA    D31C
0D314:  BSF    xA5.3
0D316:  BCF    xA5.4
0D318:  MOVLW  30
0D31A:  ADDWF  00,F
0D31C:  MOVFF  FEA,89F
0D320:  MOVFF  FE9,89E
0D324:  MOVFF  00,8DC
0D328:  MOVLB  0
0D32A:  CALL   5020
0D32E:  MOVFF  89F,FEA
0D332:  MOVFF  89E,FE9
0D336:  MOVLB  8
0D338:  MOVF   FEE,W
0D33A:  BTFSS  xA5.6
0D33C:  BRA    D2E0
0D33E:  MOVLB  0
0D340:  GOTO   D464 (RETURN)
*
0D6E8:  ADDWF  FE8,W
0D6EA:  CLRF   FF7
0D6EC:  RLCF   FF7,F
0D6EE:  ADDLW  09
0D6F0:  MOVWF  FF6
0D6F2:  MOVLW  D7
0D6F4:  ADDWFC FF7,F
0D6F6:  MOVLW  00
0D6F8:  MOVWF  FF8
0D6FA:  MOVWF  FFB
0D6FC:  TBLRD*-
0D6FE:  MOVF   FF5,W
0D700:  MOVWF  FFA
0D702:  TBLRD*
0D704:  MOVF   FF5,W
0D706:  MOVWF  FF9
0D708:  DATA 1A,D6
0D70A:  DATA 42,D6
0D70C:  DATA 62,D6
0D70E:  DATA 82,D6
0D710:  DATA A2,D6
0D712:  DATA C2,D6
*
0D792:  TBLRD*+
0D794:  MOVFF  FF6,896
0D798:  MOVFF  FF7,897
0D79C:  MOVFF  FF8,898
0D7A0:  MOVF   FF5,W
0D7A2:  BTFSS  FA4.4
0D7A4:  BRA    D7A2
0D7A6:  MOVLB  F
0D7A8:  MOVWF  x1C
0D7AA:  MOVFF  896,FF6
0D7AE:  MOVFF  897,FF7
0D7B2:  MOVFF  898,FF8
0D7B6:  MOVLB  8
0D7B8:  DECFSZ x95,F
0D7BA:  BRA    D7BE
0D7BC:  BRA    D7C2
0D7BE:  MOVLB  0
0D7C0:  BRA    D792
0D7C2:  MOVLB  0
0D7C4:  RETURN 0
0D7C6:  MOVF   01,W
0D7C8:  CLRF   1B
0D7CA:  BTFSC  FF2.7
0D7CC:  BSF    1B.7
0D7CE:  BCF    FF2.7
0D7D0:  MOVFF  8D0,A1A
0D7D4:  MOVLW  64
0D7D6:  MOVLB  A
0D7D8:  MOVWF  x1B
0D7DA:  MOVLB  0
0D7DC:  CALL   0F66
0D7E0:  BTFSC  1B.7
0D7E2:  BSF    FF2.7
0D7E4:  MOVFF  00,8D0
0D7E8:  MOVF   01,W
0D7EA:  MOVLW  30
0D7EC:  BNZ   D7FE
0D7EE:  MOVLB  8
0D7F0:  BTFSS  xD1.1
0D7F2:  BRA    D814
0D7F4:  BTFSC  xD1.3
0D7F6:  BRA    D814
0D7F8:  BTFSC  xD1.4
0D7FA:  MOVLW  20
0D7FC:  BRA    D806
0D7FE:  MOVLB  8
0D800:  BCF    xD1.3
0D802:  BCF    xD1.4
0D804:  BSF    xD1.0
0D806:  ADDWF  01,F
0D808:  MOVF   01,W
0D80A:  BTFSS  FA4.4
0D80C:  BRA    D80A
0D80E:  MOVLB  F
0D810:  MOVWF  x1C
0D812:  MOVLB  8
0D814:  CLRF   1B
0D816:  BTFSC  FF2.7
0D818:  BSF    1B.7
0D81A:  BCF    FF2.7
0D81C:  MOVFF  8D0,A1A
0D820:  MOVLW  0A
0D822:  MOVLB  A
0D824:  MOVWF  x1B
0D826:  MOVLB  0
0D828:  CALL   0F66
0D82C:  BTFSC  1B.7
0D82E:  BSF    FF2.7
0D830:  MOVFF  00,8D0
0D834:  MOVF   01,W
0D836:  MOVLW  30
0D838:  BNZ   D84A
0D83A:  MOVLB  8
0D83C:  BTFSC  xD1.3
0D83E:  BRA    D858
0D840:  BTFSS  xD1.0
0D842:  BRA    D858
0D844:  BTFSC  xD1.4
0D846:  MOVLW  20
0D848:  MOVLB  0
0D84A:  ADDWF  01,F
0D84C:  MOVF   01,W
0D84E:  BTFSS  FA4.4
0D850:  BRA    D84E
0D852:  MOVLB  F
0D854:  MOVWF  x1C
0D856:  MOVLB  8
0D858:  MOVLW  30
0D85A:  ADDWF  xD0,F
0D85C:  MOVF   xD0,W
0D85E:  BTFSS  FA4.4
0D860:  BRA    D85E
0D862:  MOVLB  F
0D864:  MOVWF  x1C
0D866:  MOVLB  0
0D868:  RETURN 0
*
0D88C:  TBLRD*+
0D88E:  MOVF   FF5,F
0D890:  BZ    D8B8
0D892:  MOVFF  FF6,894
0D896:  MOVFF  FF7,895
0D89A:  MOVFF  FF8,896
0D89E:  MOVF   FF5,W
0D8A0:  BTFSS  FA4.4
0D8A2:  BRA    D8A0
0D8A4:  MOVLB  F
0D8A6:  MOVWF  x1C
0D8A8:  MOVFF  894,FF6
0D8AC:  MOVFF  895,FF7
0D8B0:  MOVFF  896,FF8
0D8B4:  MOVLB  0
0D8B6:  BRA    D88C
0D8B8:  GOTO   D97A (RETURN)
*
0DE90:  MOVF   FE9,W
0DE92:  MOVLB  8
0DE94:  MOVWF  x69
0DE96:  MOVLW  3B
0DE98:  MOVWF  x70
0DE9A:  MOVLW  9A
0DE9C:  MOVWF  x6F
0DE9E:  MOVLW  CA
0DEA0:  MOVWF  x6E
0DEA2:  CLRF   x6D
0DEA4:  MOVLW  0A
0DEA6:  MOVWF  x6B
0DEA8:  MOVF   x68,W
0DEAA:  BTFSS  FD8.2
0DEAC:  DECF   x69,F
0DEAE:  BSF    FD8.1
0DEB0:  MOVLW  08
0DEB2:  MOVWF  FEA
0DEB4:  MOVLW  64
0DEB6:  MOVWF  FE9
0DEB8:  CLRF   1B
0DEBA:  BTFSC  FF2.7
0DEBC:  BSF    1B.7
0DEBE:  BCF    FF2.7
0DEC0:  MOVFF  867,A27
0DEC4:  MOVFF  866,A26
0DEC8:  MOVFF  865,A25
0DECC:  MOVFF  864,A24
0DED0:  MOVFF  870,A2B
0DED4:  MOVFF  86F,A2A
0DED8:  MOVFF  86E,A29
0DEDC:  MOVFF  86D,A28
0DEE0:  MOVLB  0
0DEE2:  CALL   1042
0DEE6:  BTFSC  1B.7
0DEE8:  BSF    FF2.7
0DEEA:  MOVF   01,W
0DEEC:  MOVF   00,F
0DEEE:  BNZ   DF16
0DEF0:  MOVLB  8
0DEF2:  INCF   x68,W
0DEF4:  SUBWF  x6B,W
0DEF6:  BTFSS  FD8.2
0DEF8:  BRA    DEFE
0DEFA:  MOVLB  0
0DEFC:  BRA    DF16
0DEFE:  MOVF   x69,W
0DF00:  BZ    DF1A
0DF02:  ANDLW  0F
0DF04:  SUBWF  x6B,W
0DF06:  BZ    DF0A
0DF08:  BC    DF42
0DF0A:  BTFSC  x69.7
0DF0C:  BRA    DF42
0DF0E:  BTFSC  x69.6
0DF10:  BRA    DF1A
0DF12:  MOVLW  20
0DF14:  BRA    DF38
0DF16:  MOVLB  8
0DF18:  CLRF   x69
0DF1A:  MOVF   x68,W
0DF1C:  SUBWF  x6B,W
0DF1E:  BNZ   DF36
0DF20:  MOVFF  00,869
0DF24:  MOVLW  2E
0DF26:  BTFSS  F9E.4
0DF28:  BRA    DF26
0DF2A:  MOVWF  FAD
0DF2C:  MOVFF  869,00
0DF30:  MOVLW  20
0DF32:  ANDWF  x69,F
0DF34:  MOVLW  00
0DF36:  MOVLW  30
0DF38:  ADDWF  00,F
0DF3A:  MOVF   00,W
0DF3C:  BTFSS  F9E.4
0DF3E:  BRA    DF3C
0DF40:  MOVWF  FAD
0DF42:  BCF    FD8.1
0DF44:  CLRF   1B
0DF46:  BTFSC  FF2.7
0DF48:  BSF    1B.7
0DF4A:  BCF    FF2.7
0DF4C:  MOVFF  870,A27
0DF50:  MOVFF  86F,A26
0DF54:  MOVFF  86E,A25
0DF58:  MOVFF  86D,A24
0DF5C:  MOVLB  A
0DF5E:  CLRF   x2B
0DF60:  CLRF   x2A
0DF62:  CLRF   x29
0DF64:  MOVLW  0A
0DF66:  MOVWF  x28
0DF68:  MOVLB  0
0DF6A:  CALL   1042
0DF6E:  BTFSC  1B.7
0DF70:  BSF    FF2.7
0DF72:  MOVFF  03,870
0DF76:  MOVFF  02,86F
0DF7A:  MOVFF  01,86E
0DF7E:  MOVFF  00,86D
0DF82:  MOVLB  8
0DF84:  DECFSZ x6B,F
0DF86:  BRA    DEAE
0DF88:  MOVLB  0
0DF8A:  RETURN 0
*
0F024:  MOVF   FE9,W
0F026:  MOVLB  8
0F028:  MOVWF  xD4
0F02A:  MOVLW  3B
0F02C:  MOVWF  xDB
0F02E:  MOVLW  9A
0F030:  MOVWF  xDA
0F032:  MOVLW  CA
0F034:  MOVWF  xD9
0F036:  CLRF   xD8
0F038:  MOVLW  0A
0F03A:  MOVWF  xD6
0F03C:  BSF    FD8.1
0F03E:  MOVLW  08
0F040:  MOVWF  FEA
0F042:  MOVLW  D0
0F044:  MOVWF  FE9
0F046:  CLRF   1B
0F048:  BTFSC  FF2.7
0F04A:  BSF    1B.7
0F04C:  BCF    FF2.7
0F04E:  MOVFF  8D3,A27
0F052:  MOVFF  8D2,A26
0F056:  MOVFF  8D1,A25
0F05A:  MOVFF  8D0,A24
0F05E:  MOVFF  8DB,A2B
0F062:  MOVFF  8DA,A2A
0F066:  MOVFF  8D9,A29
0F06A:  MOVFF  8D8,A28
0F06E:  MOVLB  0
0F070:  CALL   1042
0F074:  BTFSC  1B.7
0F076:  BSF    FF2.7
0F078:  MOVF   01,W
0F07A:  MOVF   00,F
0F07C:  BNZ   F0A4
0F07E:  MOVLB  8
0F080:  MOVF   xD6,W
0F082:  XORLW  01
0F084:  BTFSS  FD8.2
0F086:  BRA    F08C
0F088:  MOVLB  0
0F08A:  BRA    F0A4
0F08C:  MOVF   xD4,W
0F08E:  BZ    F0A8
0F090:  ANDLW  0F
0F092:  SUBWF  xD6,W
0F094:  BZ    F098
0F096:  BC    F0B8
0F098:  BTFSC  xD4.7
0F09A:  BRA    F0B8
0F09C:  BTFSC  xD4.6
0F09E:  BRA    F0A8
0F0A0:  MOVLW  20
0F0A2:  BRA    F0AA
0F0A4:  MOVLB  8
0F0A6:  CLRF   xD4
0F0A8:  MOVLW  30
0F0AA:  ADDWF  00,F
0F0AC:  MOVF   00,W
0F0AE:  BTFSS  FA4.4
0F0B0:  BRA    F0AE
0F0B2:  MOVLB  F
0F0B4:  MOVWF  x1C
0F0B6:  MOVLB  8
0F0B8:  BCF    FD8.1
0F0BA:  CLRF   1B
0F0BC:  BTFSC  FF2.7
0F0BE:  BSF    1B.7
0F0C0:  BCF    FF2.7
0F0C2:  MOVFF  8DB,A27
0F0C6:  MOVFF  8DA,A26
0F0CA:  MOVFF  8D9,A25
0F0CE:  MOVFF  8D8,A24
0F0D2:  MOVLB  A
0F0D4:  CLRF   x2B
0F0D6:  CLRF   x2A
0F0D8:  CLRF   x29
0F0DA:  MOVLW  0A
0F0DC:  MOVWF  x28
0F0DE:  MOVLB  0
0F0E0:  CALL   1042
0F0E4:  BTFSC  1B.7
0F0E6:  BSF    FF2.7
0F0E8:  MOVFF  03,8DB
0F0EC:  MOVFF  02,8DA
0F0F0:  MOVFF  01,8D9
0F0F4:  MOVFF  00,8D8
0F0F8:  MOVLB  8
0F0FA:  DECFSZ xD6,F
0F0FC:  BRA    F03C
0F0FE:  MOVLB  0
0F100:  GOTO   F22A (RETURN)
*
0F2FA:  ADDWF  FE8,W
0F2FC:  CLRF   FF7
0F2FE:  RLCF   FF7,F
0F300:  ADDLW  1B
0F302:  MOVWF  FF6
0F304:  MOVLW  F3
0F306:  ADDWFC FF7,F
0F308:  MOVLW  00
0F30A:  MOVWF  FF8
0F30C:  MOVWF  FFB
0F30E:  TBLRD*-
0F310:  MOVF   FF5,W
0F312:  MOVWF  FFA
0F314:  TBLRD*
0F316:  MOVF   FF5,W
0F318:  MOVWF  FF9
0F31A:  DATA BA,F2
0F31C:  DATA C2,F2
0F31E:  DATA CA,F2
0F320:  DATA D2,F2
*
0FB30:  MOVF   FEF,F
0FB32:  BZ    FB54
0FB34:  MOVFF  FEA,8C9
0FB38:  MOVFF  FE9,8C8
0FB3C:  MOVFF  FEF,8DC
0FB40:  CALL   5020
0FB44:  MOVFF  8C9,FEA
0FB48:  MOVFF  8C8,FE9
0FB4C:  INCF   FE9,F
0FB4E:  BTFSC  FD8.2
0FB50:  INCF   FEA,F
0FB52:  BRA    FB30
0FB54:  RETURN 0
0FB56:  MOVFF  FEA,FE2
0FB5A:  MOVFF  FE9,FE1
0FB5E:  CLRF   01
0FB60:  BSF    00.0
0FB62:  TBLRD*+
0FB64:  MOVF   FF5,W
0FB66:  BTFSS  00.0
0FB68:  BRA    FB74
0FB6A:  SUBWF  FEE,W
0FB6C:  BNZ   FB74
0FB6E:  MOVF   FF5,F
0FB70:  BNZ   FB62
0FB72:  BRA    FB8E
0FB74:  BCF    00.0
0FB76:  MOVF   FF5,F
0FB78:  BNZ   FB62
0FB7A:  INCF   01,F
0FB7C:  BSF    00.0
0FB7E:  MOVFF  FE2,FEA
0FB82:  MOVFF  FE1,FE9
0FB86:  TBLRD*
0FB88:  MOVF   FF5,F
0FB8A:  BNZ   FB62
0FB8C:  SETF   01
0FB8E:  RETURN 0
*
10460:  MOVFF  8F1,8F8
10464:  MOVLB  8
10466:  MOVF   xF5,W
10468:  XORWF  xF8,F
1046A:  BTFSS  xF8.7
1046C:  BRA    10478
1046E:  BCF    FD8.2
10470:  BCF    FD8.0
10472:  BTFSC  xF1.7
10474:  BSF    FD8.0
10476:  BRA    104D6
10478:  MOVFF  8F1,8F8
1047C:  MOVFF  8F4,8F9
10480:  MOVF   xF0,W
10482:  SUBWF  xF9,F
10484:  BZ    10492
10486:  BTFSS  xF8.7
10488:  BRA    104D6
1048A:  MOVF   FD8,W
1048C:  XORLW  01
1048E:  MOVWF  FD8
10490:  BRA    104D6
10492:  MOVFF  8F5,8F9
10496:  MOVF   xF1,W
10498:  SUBWF  xF9,F
1049A:  BZ    104A8
1049C:  BTFSS  xF8.7
1049E:  BRA    104D6
104A0:  MOVF   FD8,W
104A2:  XORLW  01
104A4:  MOVWF  FD8
104A6:  BRA    104D6
104A8:  MOVFF  8F6,8F9
104AC:  MOVF   xF2,W
104AE:  SUBWF  xF9,F
104B0:  BZ    104BE
104B2:  BTFSS  xF8.7
104B4:  BRA    104D6
104B6:  MOVF   FD8,W
104B8:  XORLW  01
104BA:  MOVWF  FD8
104BC:  BRA    104D6
104BE:  MOVFF  8F7,8F9
104C2:  MOVF   xF3,W
104C4:  SUBWF  xF9,F
104C6:  BZ    104D4
104C8:  BTFSS  xF8.7
104CA:  BRA    104D6
104CC:  MOVF   FD8,W
104CE:  XORLW  01
104D0:  MOVWF  FD8
104D2:  BRA    104D6
104D4:  BCF    FD8.0
104D6:  MOVLB  0
104D8:  RETURN 0
104DA:  MOVLW  8E
104DC:  MOVWF  00
104DE:  MOVFF  8CA,01
104E2:  MOVFF  8C9,02
104E6:  CLRF   03
104E8:  BTFSS  01.7
104EA:  BRA    104F6
104EC:  COMF   01,F
104EE:  COMF   02,F
104F0:  INCF   02,F
104F2:  BNZ   104F6
104F4:  INCF   01,F
104F6:  MOVF   01,F
104F8:  BNZ   1050C
104FA:  MOVFF  02,01
104FE:  CLRF   02
10500:  MOVLW  08
10502:  SUBWF  00,F
10504:  MOVF   01,F
10506:  BNZ   1050C
10508:  CLRF   00
1050A:  BRA    10528
1050C:  BCF    FD8.0
1050E:  BTFSC  01.7
10510:  BRA    1051A
10512:  RLCF   02,F
10514:  RLCF   01,F
10516:  DECF   00,F
10518:  BRA    1050C
1051A:  MOVLB  8
1051C:  BTFSS  xCA.7
1051E:  BRA    10524
10520:  MOVLB  0
10522:  BRA    10528
10524:  BCF    01.7
10526:  MOVLB  0
10528:  RETURN 0
*
10926:  MOVF   FE9,W
10928:  MOVLB  8
1092A:  MOVWF  xB1
1092C:  MOVF   xB0,W
1092E:  MOVWF  xB3
10930:  BZ    1096A
10932:  MOVFF  8AF,8F3
10936:  MOVFF  8AE,8F2
1093A:  MOVFF  8AD,8F1
1093E:  MOVFF  8AC,8F0
10942:  CLRF   xF7
10944:  CLRF   xF6
10946:  MOVLW  20
10948:  MOVWF  xF5
1094A:  MOVLW  82
1094C:  MOVWF  xF4
1094E:  MOVLB  0
10950:  CALL   BF36
10954:  MOVFF  03,8AF
10958:  MOVFF  02,8AE
1095C:  MOVFF  01,8AD
10960:  MOVFF  00,8AC
10964:  MOVLB  8
10966:  DECFSZ xB3,F
10968:  BRA    10932
1096A:  MOVLW  7E
1096C:  MOVWF  00
1096E:  CLRF   01
10970:  BTFSC  xAD.7
10972:  BSF    01.7
10974:  CLRF   02
10976:  CLRF   03
10978:  BCF    FD8.1
1097A:  MOVFF  8AF,8F7
1097E:  MOVFF  8AE,8F6
10982:  MOVFF  8AD,8F5
10986:  MOVFF  8AC,8F4
1098A:  MOVFF  03,8FB
1098E:  MOVFF  02,8FA
10992:  MOVFF  01,8F9
10996:  MOVWF  xF8
10998:  MOVLB  0
1099A:  CALL   C02C
1099E:  MOVFF  03,8AF
109A2:  MOVFF  02,8AE
109A6:  MOVFF  01,8AD
109AA:  MOVFF  00,8AC
109AE:  MOVFF  8AF,8BC
109B2:  MOVFF  8AE,8BB
109B6:  MOVFF  8AD,8BA
109BA:  MOVFF  8AC,8B9
109BE:  CALL   C364
109C2:  MOVFF  03,8AF
109C6:  MOVFF  02,8AE
109CA:  MOVFF  01,8AD
109CE:  MOVFF  00,8AC
109D2:  MOVLB  8
109D4:  BTFSS  xAF.7
109D6:  BRA    109F2
109D8:  DECF   xB1,F
109DA:  BSF    xB1.5
109DC:  COMF   xAC,F
109DE:  COMF   xAD,F
109E0:  COMF   xAE,F
109E2:  COMF   xAF,F
109E4:  INCF   xAC,F
109E6:  BTFSC  FD8.2
109E8:  INCF   xAD,F
109EA:  BTFSC  FD8.2
109EC:  INCF   xAE,F
109EE:  BTFSC  FD8.2
109F0:  INCF   xAF,F
109F2:  MOVLW  3B
109F4:  MOVWF  xB8
109F6:  MOVLW  9A
109F8:  MOVWF  xB7
109FA:  MOVLW  CA
109FC:  MOVWF  xB6
109FE:  CLRF   xB5
10A00:  MOVLW  0A
10A02:  MOVWF  xB3
10A04:  MOVF   xB0,W
10A06:  BTFSC  FD8.2
10A08:  INCF   xB1,F
10A0A:  BSF    FD8.1
10A0C:  MOVLW  08
10A0E:  MOVWF  FEA
10A10:  MOVLW  AC
10A12:  MOVWF  FE9
10A14:  CLRF   1B
10A16:  BTFSC  FF2.7
10A18:  BSF    1B.7
10A1A:  BCF    FF2.7
10A1C:  MOVFF  8AF,A27
10A20:  MOVFF  8AE,A26
10A24:  MOVFF  8AD,A25
10A28:  MOVFF  8AC,A24
10A2C:  MOVFF  8B8,A2B
10A30:  MOVFF  8B7,A2A
10A34:  MOVFF  8B6,A29
10A38:  MOVFF  8B5,A28
10A3C:  MOVLB  0
10A3E:  CALL   1042
10A42:  BTFSC  1B.7
10A44:  BSF    FF2.7
10A46:  MOVF   01,W
10A48:  MOVF   00,F
10A4A:  BNZ   10A72
10A4C:  MOVLB  8
10A4E:  INCF   xB0,W
10A50:  SUBWF  xB3,W
10A52:  BTFSS  FD8.2
10A54:  BRA    10A5A
10A56:  MOVLB  0
10A58:  BRA    10A72
10A5A:  MOVF   xB1,W
10A5C:  BZ    10A78
10A5E:  ANDLW  0F
10A60:  SUBWF  xB3,W
10A62:  BZ    10A66
10A64:  BC    10AEE
10A66:  BTFSC  xB1.7
10A68:  BRA    10AEE
10A6A:  BTFSC  xB1.6
10A6C:  BRA    10A78
10A6E:  MOVLW  20
10A70:  BRA    10AE0
10A72:  MOVLW  20
10A74:  MOVLB  8
10A76:  ANDWF  xB1,F
10A78:  BTFSS  xB1.5
10A7A:  BRA    10A9A
10A7C:  BCF    xB1.5
10A7E:  MOVF   xB0,W
10A80:  BTFSS  FD8.2
10A82:  DECF   xB1,F
10A84:  MOVF   00,W
10A86:  MOVWF  xB1
10A88:  MOVLW  2D
10A8A:  MOVWF  xDC
10A8C:  MOVLB  0
10A8E:  CALL   5020
10A92:  MOVLB  8
10A94:  MOVF   xB1,W
10A96:  MOVWF  00
10A98:  CLRF   xB1
10A9A:  MOVF   xB0,W
10A9C:  SUBWF  xB3,W
10A9E:  BNZ   10ABA
10AA0:  MOVF   00,W
10AA2:  MOVWF  xB1
10AA4:  MOVLW  2E
10AA6:  MOVWF  xDC
10AA8:  MOVLB  0
10AAA:  CALL   5020
10AAE:  MOVLB  8
10AB0:  MOVF   xB1,W
10AB2:  MOVWF  00
10AB4:  MOVLW  20
10AB6:  ANDWF  xB1,F
10AB8:  MOVLW  00
10ABA:  MOVLW  30
10ABC:  BTFSS  xB1.5
10ABE:  BRA    10AE0
10AC0:  BCF    xB1.5
10AC2:  MOVF   xB0,W
10AC4:  BTFSS  FD8.2
10AC6:  DECF   xB1,F
10AC8:  MOVF   00,W
10ACA:  MOVWF  xB1
10ACC:  MOVLW  2D
10ACE:  MOVWF  xDC
10AD0:  MOVLB  0
10AD2:  CALL   5020
10AD6:  MOVLB  8
10AD8:  MOVF   xB1,W
10ADA:  MOVWF  00
10ADC:  CLRF   xB1
10ADE:  MOVLW  30
10AE0:  ADDWF  00,F
10AE2:  MOVFF  00,8DC
10AE6:  MOVLB  0
10AE8:  CALL   5020
10AEC:  MOVLB  8
10AEE:  BCF    FD8.1
10AF0:  CLRF   1B
10AF2:  BTFSC  FF2.7
10AF4:  BSF    1B.7
10AF6:  BCF    FF2.7
10AF8:  MOVFF  8B8,A27
10AFC:  MOVFF  8B7,A26
10B00:  MOVFF  8B6,A25
10B04:  MOVFF  8B5,A24
10B08:  MOVLB  A
10B0A:  CLRF   x2B
10B0C:  CLRF   x2A
10B0E:  CLRF   x29
10B10:  MOVLW  0A
10B12:  MOVWF  x28
10B14:  MOVLB  0
10B16:  CALL   1042
10B1A:  BTFSC  1B.7
10B1C:  BSF    FF2.7
10B1E:  MOVFF  03,8B8
10B22:  MOVFF  02,8B7
10B26:  MOVFF  01,8B6
10B2A:  MOVFF  00,8B5
10B2E:  MOVLB  8
10B30:  DECFSZ xB3,F
10B32:  BRA    10A0A
10B34:  MOVLB  0
10B36:  RETURN 0
*
12438:  ADDWF  FE8,W
1243A:  CLRF   FF7
1243C:  RLCF   FF7,F
1243E:  ADDLW  59
12440:  MOVWF  FF6
12442:  MOVLW  24
12444:  ADDWFC FF7,F
12446:  MOVLW  01
12448:  MOVWF  FF8
1244A:  MOVWF  FFB
1244C:  TBLRD*-
1244E:  MOVF   FF5,W
12450:  MOVWF  FFA
12452:  TBLRD*
12454:  MOVF   FF5,W
12456:  MOVWF  FF9
12458:  DATA FC,23
1245A:  DATA 04,24
1245C:  DATA 0A,24
1245E:  DATA 10,24
*
124F0:  MOVLW  8E
124F2:  MOVWF  00
124F4:  MOVLB  8
124F6:  MOVF   xF0,W
124F8:  SUBWF  00,F
124FA:  MOVFF  8F1,02
124FE:  MOVFF  8F2,01
12502:  BSF    02.7
12504:  MOVF   00,F
12506:  BZ    1251A
12508:  BCF    FD8.0
1250A:  MOVF   02,F
1250C:  BNZ   12512
1250E:  MOVF   01,F
12510:  BZ    1251A
12512:  RRCF   02,F
12514:  RRCF   01,F
12516:  DECFSZ 00,F
12518:  BRA    12508
1251A:  BTFSS  xF1.7
1251C:  BRA    12528
1251E:  COMF   01,F
12520:  COMF   02,F
12522:  INCF   01,F
12524:  BTFSC  FD8.2
12526:  INCF   02,F
12528:  MOVLB  0
1252A:  RETURN 0
*
12FE8:  ADDWF  FE8,W
12FEA:  CLRF   FF7
12FEC:  RLCF   FF7,F
12FEE:  ADDLW  09
12FF0:  MOVWF  FF6
12FF2:  MOVLW  30
12FF4:  ADDWFC FF7,F
12FF6:  MOVLW  01
12FF8:  MOVWF  FF8
12FFA:  MOVWF  FFB
12FFC:  TBLRD*-
12FFE:  MOVF   FF5,W
13000:  MOVWF  FFA
13002:  TBLRD*
13004:  MOVF   FF5,W
13006:  MOVWF  FF9
13008:  DATA 24,2E
1300A:  DATA 2A,2E
1300C:  DATA 48,2E
1300E:  DATA 66,2E
*
13080:  MOVLB  8
13082:  MOVF   xBA,W
13084:  XORWF  xBC,W
13086:  ANDLW  80
13088:  MOVWF  xBE
1308A:  BTFSS  xBA.7
1308C:  BRA    13098
1308E:  COMF   xB9,F
13090:  COMF   xBA,F
13092:  INCF   xB9,F
13094:  BTFSC  FD8.2
13096:  INCF   xBA,F
13098:  BTFSS  xBC.7
1309A:  BRA    130A6
1309C:  COMF   xBB,F
1309E:  COMF   xBC,F
130A0:  INCF   xBB,F
130A2:  BTFSC  FD8.2
130A4:  INCF   xBC,F
130A6:  MOVF   xB9,W
130A8:  MULWF  xBB
130AA:  MOVFF  FF3,01
130AE:  MOVFF  FF4,00
130B2:  MULWF  xBC
130B4:  MOVF   FF3,W
130B6:  ADDWF  00,F
130B8:  MOVF   xBA,W
130BA:  MULWF  xBB
130BC:  MOVF   FF3,W
130BE:  ADDWFC 00,W
130C0:  MOVWF  02
130C2:  BTFSS  xBE.7
130C4:  BRA    130D0
130C6:  COMF   01,F
130C8:  COMF   02,F
130CA:  INCF   01,F
130CC:  BTFSC  FD8.2
130CE:  INCF   02,F
130D0:  MOVLB  0
130D2:  GOTO   131B0 (RETURN)
*
13DFA:  ADDWF  FE8,W
13DFC:  CLRF   FF7
13DFE:  RLCF   FF7,F
13E00:  ADDLW  1B
13E02:  MOVWF  FF6
13E04:  MOVLW  3E
13E06:  ADDWFC FF7,F
13E08:  MOVLW  01
13E0A:  MOVWF  FF8
13E0C:  MOVWF  FFB
13E0E:  TBLRD*-
13E10:  MOVF   FF5,W
13E12:  MOVWF  FFA
13E14:  TBLRD*
13E16:  MOVF   FF5,W
13E18:  MOVWF  FF9
13E1A:  DATA C6,3C
13E1C:  DATA EE,3D
13E1E:  DATA F2,3C
13E20:  DATA EE,3D
13E22:  DATA BE,3B
13E24:  DATA EE,3D
13E26:  DATA EE,3D
13E28:  DATA EE,3D
13E2A:  DATA EE,3D
13E2C:  DATA EE,3D
13E2E:  DATA EE,3D
13E30:  DATA EE,3D
13E32:  DATA EE,3D
13E34:  DATA EE,3D
13E36:  DATA EE,3D
13E38:  DATA EE,3D
13E3A:  DATA E6,3D
13E3C:  DATA EE,3D
13E3E:  DATA EE,3D
13E40:  DATA EE,3D
13E42:  DATA EE,3D
13E44:  DATA EE,3D
13E46:  DATA 5E,3B
13E48:  DATA EE,3D
13E4A:  DATA 92,3B
13E4C:  DATA 9A,3B
13E4E:  DATA EE,3D
13E50:  DATA AE,3B
13E52:  DATA 1E,3D
13E54:  DATA E2,3B
13E56:  DATA EE,3D
13E58:  DATA EE,3D
13E5A:  DATA 74,3C
13E5C:  DATA 56,3C
13E5E:  DATA EE,3D
13E60:  DATA EE,3D
13E62:  DATA EE,3D
13E64:  DATA 38,3D
13E66:  DATA 64,3D
13E68:  DATA 90,3D
13E6A:  DATA 90,3C
13E6C:  DATA BC,3C
13E6E:  DATA EE,3D
13E70:  DATA EE,3D
13E72:  DATA EE,3D
13E74:  DATA EE,3D
13E76:  DATA BC,3D
13E78:  DATA EE,3D
13E7A:  DATA EE,3D
13E7C:  DATA EE,3D
13E7E:  DATA EE,3D
13E80:  DATA EE,3D
13E82:  DATA EE,3D
13E84:  DATA EE,3D
13E86:  DATA EE,3D
13E88:  DATA EE,3D
13E8A:  DATA EE,3D
13E8C:  DATA CA,3B
13E8E:  DATA EE,3D
13E90:  DATA EE,3D
13E92:  DATA EE,3D
13E94:  DATA EE,3D
13E96:  DATA FA,3B
13E98:  DATA EE,3D
13E9A:  DATA EE,3D
13E9C:  DATA 20,3C
13E9E:  DATA EE,3D
13EA0:  DATA EE,3D
13EA2:  DATA EE,3D
13EA4:  DATA 6E,3B
*
13F5A:  MOVFF  FEA,89D
13F5E:  MOVFF  FE9,89C
13F62:  MOVLB  8
13F64:  SWAPF  x96,W
13F66:  IORLW  F0
13F68:  MOVWF  x98
13F6A:  ADDWF  x98,F
13F6C:  ADDLW  E2
13F6E:  MOVWF  x99
13F70:  ADDLW  32
13F72:  MOVWF  x9B
13F74:  MOVF   x96,W
13F76:  ANDLW  0F
13F78:  ADDWF  x99,F
13F7A:  ADDWF  x99,F
13F7C:  ADDWF  x9B,F
13F7E:  ADDLW  E9
13F80:  MOVWF  x9A
13F82:  ADDWF  x9A,F
13F84:  ADDWF  x9A,F
13F86:  SWAPF  x95,W
13F88:  ANDLW  0F
13F8A:  ADDWF  x9A,F
13F8C:  ADDWF  x9B,F
13F8E:  RLCF   x9A,F
13F90:  RLCF   x9B,F
13F92:  COMF   x9B,F
13F94:  RLCF   x9B,F
13F96:  MOVF   x95,W
13F98:  ANDLW  0F
13F9A:  ADDWF  x9B,F
13F9C:  RLCF   x98,F
13F9E:  MOVLW  07
13FA0:  MOVWF  x97
13FA2:  MOVLW  0A
13FA4:  DECF   x9A,F
13FA6:  ADDWF  x9B,F
13FA8:  BNC   13FA4
13FAA:  DECF   x99,F
13FAC:  ADDWF  x9A,F
13FAE:  BNC   13FAA
13FB0:  DECF   x98,F
13FB2:  ADDWF  x99,F
13FB4:  BNC   13FB0
13FB6:  DECF   x97,F
13FB8:  ADDWF  x98,F
13FBA:  BNC   13FB6
13FBC:  MOVLW  08
13FBE:  MOVWF  FEA
13FC0:  MOVLW  97
13FC2:  MOVWF  FE9
13FC4:  MOVLW  07
13FC6:  ANDWF  x9C,W
13FC8:  BCF    x9C.6
13FCA:  ADDWF  FE9,F
13FCC:  MOVLW  00
13FCE:  ADDWFC FEA,F
13FD0:  MOVF   FE9,W
13FD2:  SUBLW  9B
13FD4:  BNZ   13FDE
13FD6:  MOVF   FEA,W
13FD8:  SUBLW  08
13FDA:  BNZ   13FDE
13FDC:  BSF    x9C.6
13FDE:  MOVF   FEF,W
13FE0:  MOVWF  00
13FE2:  BNZ   13FF4
13FE4:  BTFSC  x9C.6
13FE6:  BRA    13FF4
13FE8:  BTFSC  x9C.4
13FEA:  BRA    14008
13FEC:  BTFSC  x9C.3
13FEE:  BRA    13FF4
13FF0:  MOVLW  20
13FF2:  BRA    13FFA
13FF4:  BSF    x9C.3
13FF6:  BCF    x9C.4
13FF8:  MOVLW  30
13FFA:  ADDWF  00,F
13FFC:  MOVF   00,W
13FFE:  BTFSS  FA4.4
14000:  BRA    13FFE
14002:  MOVLB  F
14004:  MOVWF  x1C
14006:  MOVLB  8
14008:  MOVF   FEE,W
1400A:  BTFSS  x9C.6
1400C:  BRA    13FD0
1400E:  MOVLB  0
14010:  GOTO   140AC (RETURN)
*
144F0:  ADDWF  FE8,W
144F2:  CLRF   FF7
144F4:  RLCF   FF7,F
144F6:  ADDLW  11
144F8:  MOVWF  FF6
144FA:  MOVLW  45
144FC:  ADDWFC FF7,F
144FE:  MOVLW  01
14500:  MOVWF  FF8
14502:  MOVWF  FFB
14504:  TBLRD*-
14506:  MOVF   FF5,W
14508:  MOVWF  FFA
1450A:  TBLRD*
1450C:  MOVF   FF5,W
1450E:  MOVWF  FF9
14510:  DATA DC,40
14512:  DATA 3C,41
14514:  DATA 58,41
14516:  DATA 74,41
14518:  DATA 90,41
1451A:  DATA AC,41
1451C:  DATA C8,41
1451E:  DATA E4,41
14520:  DATA 00,42
14522:  DATA 1C,42
14524:  DATA 38,42
14526:  DATA 54,42
14528:  DATA 70,42
1452A:  DATA 8C,42
1452C:  DATA A8,42
1452E:  DATA C4,42
14530:  DATA E0,42
14532:  DATA FC,42
14534:  DATA 18,43
14536:  DATA 34,43
14538:  DATA 50,43
1453A:  DATA 6C,43
1453C:  DATA 88,43
1453E:  DATA A4,43
14540:  DATA C0,43
14542:  DATA DC,43
14544:  DATA F8,43
14546:  DATA 14,44
14548:  DATA 30,44
1454A:  DATA 4C,44
1454C:  DATA 68,44
1454E:  DATA 84,44
14550:  DATA A0,44
*
14D26:  ADDWF  FE8,W
14D28:  CLRF   FF7
14D2A:  RLCF   FF7,F
14D2C:  ADDLW  47
14D2E:  MOVWF  FF6
14D30:  MOVLW  4D
14D32:  ADDWFC FF7,F
14D34:  MOVLW  01
14D36:  MOVWF  FF8
14D38:  MOVWF  FFB
14D3A:  TBLRD*-
14D3C:  MOVF   FF5,W
14D3E:  MOVWF  FFA
14D40:  TBLRD*
14D42:  MOVF   FF5,W
14D44:  MOVWF  FF9
14D46:  DATA 32,49
14D48:  DATA 5A,4A
14D4A:  DATA 5E,49
14D4C:  DATA 5A,4A
14D4E:  DATA 24,48
14D50:  DATA 5A,4A
14D52:  DATA 5A,4A
14D54:  DATA 5A,4A
14D56:  DATA 5A,4A
14D58:  DATA 5A,4A
14D5A:  DATA 5A,4A
14D5C:  DATA 5A,4A
14D5E:  DATA 5A,4A
14D60:  DATA 5A,4A
14D62:  DATA 5A,4A
14D64:  DATA 5A,4A
14D66:  DATA 52,4A
14D68:  DATA 5A,4A
14D6A:  DATA 5A,4A
14D6C:  DATA 5A,4A
14D6E:  DATA 5A,4A
14D70:  DATA 5A,4A
14D72:  DATA 2E,46
14D74:  DATA 5A,4A
14D76:  DATA 62,46
14D78:  DATA 00,48
14D7A:  DATA 5A,4A
14D7C:  DATA 14,48
14D7E:  DATA 8A,49
14D80:  DATA 48,48
14D82:  DATA 5A,4A
14D84:  DATA 5A,4A
14D86:  DATA DA,48
14D88:  DATA BC,48
14D8A:  DATA 5A,4A
14D8C:  DATA 5A,4A
14D8E:  DATA 5A,4A
14D90:  DATA A4,49
14D92:  DATA D0,49
14D94:  DATA FC,49
14D96:  DATA F6,48
14D98:  DATA 26,49
14D9A:  DATA 5A,4A
14D9C:  DATA 5A,4A
14D9E:  DATA 5A,4A
14DA0:  DATA 5A,4A
14DA2:  DATA 28,4A
14DA4:  DATA 5A,4A
14DA6:  DATA 5A,4A
14DA8:  DATA 5A,4A
14DAA:  DATA 5A,4A
14DAC:  DATA 5A,4A
14DAE:  DATA 5A,4A
14DB0:  DATA 5A,4A
14DB2:  DATA 5A,4A
14DB4:  DATA 5A,4A
14DB6:  DATA 5A,4A
14DB8:  DATA 30,48
14DBA:  DATA 5A,4A
14DBC:  DATA 5A,4A
14DBE:  DATA 5A,4A
14DC0:  DATA 5A,4A
14DC2:  DATA 60,48
14DC4:  DATA 5A,4A
14DC6:  DATA 5A,4A
14DC8:  DATA 86,48
14DCA:  DATA 5A,4A
14DCC:  DATA 5A,4A
14DCE:  DATA 5A,4A
14DD0:  DATA 3E,46
14DD2:  DATA 5A,4A
14DD4:  DATA 6A,46
*
15238:  ADDWF  FE8,W
1523A:  CLRF   FF7
1523C:  RLCF   FF7,F
1523E:  ADDLW  59
15240:  MOVWF  FF6
15242:  MOVLW  52
15244:  ADDWFC FF7,F
15246:  MOVLW  01
15248:  MOVWF  FF8
1524A:  MOVWF  FFB
1524C:  TBLRD*-
1524E:  MOVF   FF5,W
15250:  MOVWF  FFA
15252:  TBLRD*
15254:  MOVF   FF5,W
15256:  MOVWF  FF9
15258:  DATA AA,50
1525A:  DATA CA,50
1525C:  DATA EA,50
1525E:  DATA 0A,51
15260:  DATA 2A,51
15262:  DATA 4A,51
15264:  DATA 6A,51
*
1AD3E:  ADDWF  FE8,W
1AD40:  CLRF   FF7
1AD42:  RLCF   FF7,F
1AD44:  ADDLW  5F
1AD46:  MOVWF  FF6
1AD48:  MOVLW  AD
1AD4A:  ADDWFC FF7,F
1AD4C:  MOVLW  01
1AD4E:  MOVWF  FF8
1AD50:  MOVWF  FFB
1AD52:  TBLRD*-
1AD54:  MOVF   FF5,W
1AD56:  MOVWF  FFA
1AD58:  TBLRD*
1AD5A:  MOVF   FF5,W
1AD5C:  MOVWF  FF9
1AD5E:  DATA BE,AB
1AD60:  DATA 3A,AD
1AD62:  DATA C4,AB
1AD64:  DATA B8,AB
1AD66:  DATA 3A,AD
1AD68:  DATA 3A,AD
1AD6A:  DATA 3A,AD
1AD6C:  DATA CA,AB
1AD6E:  DATA 7E,AC
1AD70:  DATA 3A,AD
1AD72:  DATA 9A,AC
1AD74:  DATA 3A,AD
1AD76:  DATA D0,AB
1AD78:  DATA 3A,AD
1AD7A:  DATA 3A,AD
1AD7C:  DATA 3A,AD
1AD7E:  DATA 3A,AD
1AD80:  DATA 3A,AD
1AD82:  DATA 3A,AD
1AD84:  DATA 3A,AD
1AD86:  DATA 3A,AD
1AD88:  DATA 3A,AD
1AD8A:  DATA 3A,AD
1AD8C:  DATA 3A,AD
1AD8E:  DATA 3A,AD
1AD90:  DATA 3A,AD
1AD92:  DATA 3A,AD
1AD94:  DATA 3A,AD
1AD96:  DATA 3A,AD
1AD98:  DATA 3A,AD
1AD9A:  DATA D6,AB
1AD9C:  DATA DC,AB
1AD9E:  DATA E2,AB
1ADA0:  DATA E8,AB
1ADA2:  DATA EE,AB
1ADA4:  DATA F4,AB
1ADA6:  DATA FA,AB
1ADA8:  DATA 00,AC
1ADAA:  DATA 06,AC
1ADAC:  DATA 0C,AC
1ADAE:  DATA 12,AC
1ADB0:  DATA 18,AC
1ADB2:  DATA 1E,AC
1ADB4:  DATA 2A,AC
1ADB6:  DATA 30,AC
1ADB8:  DATA 36,AC
1ADBA:  DATA 3C,AC
1ADBC:  DATA 42,AC
1ADBE:  DATA 48,AC
1ADC0:  DATA 4E,AC
1ADC2:  DATA 54,AC
1ADC4:  DATA 5A,AC
1ADC6:  DATA 60,AC
1ADC8:  DATA 66,AC
1ADCA:  DATA 6C,AC
1ADCC:  DATA 72,AC
1ADCE:  DATA 3A,AD
1ADD0:  DATA 3A,AD
1ADD2:  DATA 3A,AD
1ADD4:  DATA 78,AC
1ADD6:  DATA 3A,AD
1ADD8:  DATA 3A,AD
1ADDA:  DATA B6,AC
1ADDC:  DATA BC,AC
1ADDE:  DATA C2,AC
1ADE0:  DATA C8,AC
1ADE2:  DATA CE,AC
1ADE4:  DATA D4,AC
1ADE6:  DATA DA,AC
1ADE8:  DATA E0,AC
1ADEA:  DATA E6,AC
1ADEC:  DATA EC,AC
1ADEE:  DATA F2,AC
1ADF0:  DATA F8,AC
1ADF2:  DATA FE,AC
1ADF4:  DATA 04,AD
1ADF6:  DATA 0A,AD
1ADF8:  DATA 10,AD
1ADFA:  DATA 16,AD
1ADFC:  DATA 1C,AD
1ADFE:  DATA 20,AD
1AE00:  DATA 24,AD
1AE02:  DATA 28,AD
1AE04:  DATA 3A,AD
1AE06:  DATA 2C,AD
1AE08:  DATA 30,AD
1AE0A:  DATA 34,AD
1AE0C:  DATA 38,AD
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8D1
1F8BA:  MOVFF  FF7,8D2
1F8BE:  MOVFF  FF8,8D3
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8D1,FF6
1F8CE:  MOVFF  8D2,FF7
1F8D2:  MOVFF  8D3,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8D2
1F8E0:  MOVFF  FF7,8D3
1F8E4:  MOVFF  FF8,8D4
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8D2,FF6
1F8F4:  MOVFF  8D3,FF7
1F8F8:  MOVFF  8D4,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xD1,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xD2.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xD1,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xD2,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xD1,F
1F936:  MOVLW  0A
1F938:  SUBWF  xD1,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xD2.7
1F942:  MOVF   xD2,W
1F944:  ADDWF  xD1,F
1F946:  MOVF   xD1,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xD4,W
1F956:  CLRF   01
1F958:  SUBWF  xD3,W
1F95A:  BC    1F962
1F95C:  MOVFF  8D3,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xD5
1F968:  RLCF   xD3,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xD4,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xD5,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8D1,8D3
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xD4
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8D1
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xD2.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xD2.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xD2.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xD2.3
1F9AC:  BCF    xD2.4
1F9AE:  BSF    xD2.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8D1,8D3
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xD4
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8D1
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xD2.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xD2.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xD2.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xD1,F
1F9F0:  MOVF   xD1,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8D1,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8D2,01
1FA60:  MOVFF  8D1,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... //#ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... //#else 
....................    //#FUSES NOMCLR 
.................... //#endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... //#FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... //#FUSES WDT_SW   
.................... //#fuses WDT//, WDT16 
.................... //#fuses WDT// WDT is s/w controlled 
.................... //#use delay(clock=2000000) 
....................  
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
02898:  MOVLW  09
0289A:  MOVWF  FEA
0289C:  MOVLW  C9
0289E:  MOVWF  FE9
028A0:  MOVF   FEF,W
028A2:  BZ    28C0
028A4:  MOVLW  14
028A6:  MOVWF  01
028A8:  CLRF   00
028AA:  DECFSZ 00,F
028AC:  BRA    28AA
028AE:  DECFSZ 01,F
028B0:  BRA    28A8
028B2:  MOVLW  BF
028B4:  MOVWF  00
028B6:  DECFSZ 00,F
028B8:  BRA    28B6
028BA:  BRA    28BC
028BC:  DECFSZ FEF,F
028BE:  BRA    28A4
028C0:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E24:  BTFSS  F9E.5
00E26:  BRA    0E24
00E28:  MOVFF  FAB,1C
00E2C:  MOVFF  FAE,01
00E30:  BTFSS  1C.1
00E32:  BRA    0E38
00E34:  BCF    FAB.4
00E36:  BSF    FAB.4
00E38:  RETURN 0
*
0ADB4:  BTFSS  F9E.4
0ADB6:  BRA    ADB4
0ADB8:  MOVWF  FAD
0ADBA:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12B16:  BTFSS  FA4.5
12B18:  BRA    12B16
12B1A:  MOVLB  F
12B1C:  MOVFF  F22,1C
12B20:  MOVFF  F1D,01
12B24:  BTFSS  1C.1
12B26:  BRA    12B2C
12B28:  BCF    x22.4
12B2A:  BSF    x22.4
12B2C:  MOVLB  0
12B2E:  RETURN 0
*
16A82:  BTFSS  FA4.4
16A84:  BRA    16A82
16A86:  MOVLB  F
16A88:  MOVWF  x1C
16A8A:  MOVLB  0
16A8C:  GOTO   16B26 (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xD7
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xD8
1F850:  MOVF   xD8,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8D6,03
1F85A:  MOVFF  8D5,FE9
1F85E:  MOVFF  8D6,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xD7,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8D9
1F870:  MOVFF  8D5,FE9
1F874:  MOVFF  8D6,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xD9,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xD7
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xD7,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8D9
1F88C:  MOVFF  8D5,FE9
1F890:  MOVFF  8D6,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xD9,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xD7
....................       }  
1F89C:  MOVF   xD8,W
1F89E:  INCF   xD8,F
1F8A0:  INCF   xD5,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xD6,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8D7,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xD5,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8D2,03
1FA84:  MOVFF  8D1,FE9
1FA88:  MOVFF  8D2,FEA
1FA8C:  MOVFF  FEF,8D6
1FA90:  MOVFF  8D4,03
1FA94:  MOVFF  8D3,FE9
1FA98:  MOVFF  8D4,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xD6,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8D2,03
1FAA6:  MOVFF  8D1,FE9
1FAAA:  MOVFF  8D2,FEA
1FAAE:  MOVFF  FEF,8D6
1FAB2:  MOVFF  8D4,03
1FAB6:  MOVFF  8D3,FE9
1FABA:  MOVFF  8D4,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xD6,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8D2,03
1FAD4:  MOVFF  8D1,FE9
1FAD8:  MOVFF  8D2,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8D2,03
1FAEA:  MOVF   xD1,W
1FAEC:  INCF   xD1,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xD2,F
1FAF2:  MOVFF  8D4,03
1FAF6:  MOVF   xD3,W
1FAF8:  INCF   xD3,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xD4,F
1FAFE:  DECF   xD5,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x62.1
1FB0E:  CLRF   x6C
1FB10:  CLRF   x6B
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xC9
1FB2A:  MOVLB  0
1FB2C:  CALL   2898
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x62.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x68
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x68,W
1FB3C:  ADDLW  91
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x68,W
1FB50:  INCF   x68,F
1FB52:  CLRF   03
1FB54:  ADDLW  91
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x68,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x62.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   x91,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xD6
1FB80:  MOVLW  92
1FB82:  MOVWF  xD5
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,867
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xD6
1FB92:  MOVLW  94
1FB94:  MOVWF  xD5
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8D1
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xD6
1FBA4:  MOVLW  96
1FBA6:  MOVWF  xD5
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8D1,86A
1FBB0:  MOVFF  01,869
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xD6
1FBBA:  MOVLW  98
1FBBC:  MOVWF  xD5
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,864
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  86B,86F
1FBCA:  MOVFF  86C,870
1FBCE:  MOVFF  869,86D
1FBD2:  MOVFF  86A,86E
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x64,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x62.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x62.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x70,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x6F,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x6E,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x70,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x6F,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x70,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x6F,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x63
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x66
1FC26:  MOVLW  03
1FC28:  SUBWF  x68,W
1FC2A:  SUBWF  x66,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x66,W
1FC32:  ADDLW  91
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8D1
1FC3E:  MOVFF  03,8D2
1FC42:  MOVFF  03,8D6
1FC46:  MOVFF  01,8D5
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x63,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x66,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x63,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x63
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x68,W
1FC68:  CLRF   03
1FC6A:  ADDLW  91
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8D1
1FC76:  MOVFF  03,8D2
1FC7A:  MOVFF  03,8D6
1FC7E:  MOVFF  01,8D5
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x63,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x62.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x64,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x66
1FCAE:  CLRF   x65
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x68,W
1FCB4:  SUBWF  x66,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x65,W
1FCBA:  INCF   x65,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  71
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8D1
1FCCA:  MOVFF  03,8D2
1FCCE:  CLRF   03
1FCD0:  MOVF   x66,W
1FCD2:  ADDLW  91
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8D3
1FCDE:  MOVFF  03,8D4
1FCE2:  MOVFF  03,8D6
1FCE6:  MOVFF  01,8D5
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8D2,FEA
1FCF2:  MOVFF  8D1,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x66,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xD1
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  870,8D1
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xD2
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  86F,8D1
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xD2
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  86E,8D1
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xD2
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  86D,8D1
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xD2
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  867,8D1
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xD2
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  86F,FF8
1FD80:  MOVFF  86E,FF7
1FD84:  MOVFF  86D,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  71
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  867,8D1
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  86F,FF8
1FD9A:  MOVFF  86E,FF7
1FD9E:  MOVFF  86D,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  91
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xD2
1FDAE:  MOVFF  867,8D1
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xD2
1FDBC:  MOVLW  71
1FDBE:  MOVWF  xD1
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xD4
1FDC4:  MOVLW  91
1FDC6:  MOVWF  xD3
1FDC8:  MOVFF  867,8D5
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x62.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x64,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xD6
1FE02:  MOVLW  9A
1FE04:  MOVWF  xD5
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8D1
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xD6
1FE14:  MOVLW  9C
1FE16:  MOVWF  xD5
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8D1,86C
1FE20:  MOVFF  01,86B
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xD1
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  86B,8D1
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xD2
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x62.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x62.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xD1
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xC9
1FE8E:  MOVLB  0
1FE90:  CALL   2898
1FE94:  MOVLB  8
1FE96:  DECFSZ xD1,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
054D2:  BCF    FF2.5
....................    restart_wdt(); 
054D4:  CLRWDT
054D6:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
054D8:  CLRF   FCF
054DA:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
054DC:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
054DE:  MOVF   2F,W
054E0:  SUBLW  02
054E2:  BNZ   54EA
054E4:  MOVF   30,F
054E6:  BNZ   54EA
054E8:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
054EA:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
054EC:  BSF    F9D.0
054EE:  GOTO   5502 (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
054F2:  MOVLW  0B
054F4:  MOVWF  FD7
054F6:  MOVLW  DC
054F8:  MOVWF  FD6
....................    restart_wdt(); 
054FA:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
054FC:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
054FE:  BSF    FF2.5
....................    setup_led_pulse(); 
05500:  BRA    54D8
05502:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
05504:  MOVLB  8
05506:  MOVF   xCA,W
05508:  XORLW  00
0550A:  MOVLB  0
0550C:  BZ    5514
0550E:  XORLW  01
05510:  BZ    5518
05512:  BRA    551A
....................       case 0 : suspend_heartbeat(); 
05514:  RCALL  54D2
....................          break; 
05516:  BRA    551A
....................       case 1 : restart_heartbeat(); 
05518:  RCALL  54F2
....................          break; 
....................    } 
0551A:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
0307E:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
03080:  BCF    FD1.0
03082:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
02888:  MOVLW  0B
0288A:  MOVWF  FD7
0288C:  MOVLW  DC
0288E:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
02890:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
02892:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
02894:  BSF    FD1.0
02896:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0784E:  MOVFF  98E,994
07852:  MOVFF  98D,993
07856:  MOVLB  9
07858:  MOVF   x91,F
0785A:  BNZ   7860
0785C:  MOVF   x92,F
0785E:  BZ    78AA
07860:  MOVFF  990,03
07864:  MOVFF  98F,FE9
07868:  MOVFF  990,FEA
0786C:  MOVF   FEF,F
0786E:  BZ    78AA
....................      *s++ = *s2++; 
07870:  MOVFF  994,996
07874:  MOVF   x93,W
07876:  INCF   x93,F
07878:  BTFSC  FD8.2
0787A:  INCF   x94,F
0787C:  MOVWF  x95
0787E:  MOVFF  990,03
07882:  MOVF   x8F,W
07884:  INCF   x8F,F
07886:  BTFSC  FD8.2
07888:  INCF   x90,F
0788A:  MOVWF  FE9
0788C:  MOVFF  03,FEA
07890:  MOVFF  FEF,997
07894:  MOVFF  996,FEA
07898:  MOVFF  995,FE9
0789C:  MOVFF  997,FEF
078A0:  MOVF   x91,W
078A2:  BTFSC  FD8.2
078A4:  DECF   x92,F
078A6:  DECF   x91,F
078A8:  BRA    7858
....................   for (; n > 0; n--) 
078AA:  MOVF   x91,F
078AC:  BNZ   78B2
078AE:  MOVF   x92,F
078B0:  BZ    78D0
....................      *s++ = '\0'; 
078B2:  MOVFF  994,03
078B6:  MOVF   x93,W
078B8:  INCF   x93,F
078BA:  BTFSC  FD8.2
078BC:  INCF   x94,F
078BE:  MOVWF  FE9
078C0:  MOVFF  03,FEA
078C4:  CLRF   FEF
078C6:  MOVF   x91,W
078C8:  BTFSC  FD8.2
078CA:  DECF   x92,F
078CC:  DECF   x91,F
078CE:  BRA    78AA
....................  
....................   return(s1); 
078D0:  MOVFF  98D,01
078D4:  MOVFF  98E,02
078D8:  MOVLB  0
078DA:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
05460:  MOVFF  8D6,8DA
05464:  MOVFF  8D5,8D9
05468:  MOVFF  8DA,03
0546C:  MOVLB  8
0546E:  MOVFF  8D9,FE9
05472:  MOVFF  8DA,FEA
05476:  MOVF   FEF,F
05478:  BZ    5486
0547A:  INCF   xD9,F
0547C:  BTFSC  FD8.2
0547E:  INCF   xDA,F
05480:  MOVLB  0
05482:  BRA    5468
05484:  MOVLB  8
....................    while(*s2 != '\0') 
05486:  MOVFF  8D8,03
0548A:  MOVFF  8D7,FE9
0548E:  MOVFF  8D8,FEA
05492:  MOVF   FEF,F
05494:  BZ    54BC
....................    { 
....................       *s = *s2; 
05496:  MOVFF  8D7,FE9
0549A:  MOVFF  8D8,FEA
0549E:  MOVFF  FEF,8DD
054A2:  MOVFF  8DA,FEA
054A6:  MOVFF  8D9,FE9
054AA:  MOVFF  8DD,FEF
....................       ++s; 
054AE:  INCF   xD9,F
054B0:  BTFSC  FD8.2
054B2:  INCF   xDA,F
....................       ++s2; 
054B4:  INCF   xD7,F
054B6:  BTFSC  FD8.2
054B8:  INCF   xD8,F
054BA:  BRA    5486
....................    } 
....................  
....................    *s = '\0'; 
054BC:  MOVFF  8D9,FE9
054C0:  MOVFF  8DA,FEA
054C4:  CLRF   FEF
....................    return(s1); 
054C6:  MOVFF  8D5,01
054CA:  MOVFF  8D6,02
054CE:  MOVLB  0
054D0:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
12A92:  MOVFF  8CB,8D1
12A96:  MOVFF  8CA,8D0
12A9A:  MOVFF  8D1,03
12A9E:  MOVLB  8
12AA0:  MOVFF  8D0,FE9
12AA4:  MOVFF  8D1,FEA
12AA8:  MOVF   FEF,F
12AAA:  BZ    12AB8
12AAC:  INCF   xD0,F
12AAE:  BTFSC  FD8.2
12AB0:  INCF   xD1,F
12AB2:  MOVLB  0
12AB4:  BRA    12A9A
12AB6:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12AB8:  MOVFF  8CD,03
12ABC:  MOVFF  8CC,FE9
12AC0:  MOVFF  8CD,FEA
12AC4:  MOVF   FEF,F
12AC6:  BZ    12B00
12AC8:  MOVF   xCF,F
12ACA:  BNZ   12AD2
12ACC:  MOVF   xCE,W
12ACE:  SUBLW  00
12AD0:  BC    12B00
....................    { 
....................       *s = *s2; 
12AD2:  MOVFF  8CC,FE9
12AD6:  MOVFF  8CD,FEA
12ADA:  MOVFF  FEF,8D4
12ADE:  MOVFF  8D1,FEA
12AE2:  MOVFF  8D0,FE9
12AE6:  MOVFF  8D4,FEF
....................       ++s; 
12AEA:  INCF   xD0,F
12AEC:  BTFSC  FD8.2
12AEE:  INCF   xD1,F
....................       ++s2; 
12AF0:  INCF   xCC,F
12AF2:  BTFSC  FD8.2
12AF4:  INCF   xCD,F
....................       --n; 
12AF6:  MOVF   xCE,W
12AF8:  BTFSC  FD8.2
12AFA:  DECF   xCF,F
12AFC:  DECF   xCE,F
12AFE:  BRA    12AB8
....................    } 
....................  
....................    *s = '\0'; 
12B00:  MOVFF  8D0,FE9
12B04:  MOVFF  8D1,FEA
12B08:  CLRF   FEF
....................    return(s1); 
12B0A:  MOVFF  8CA,01
12B0E:  MOVFF  8CB,02
12B12:  MOVLB  0
12B14:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
0459C:  MOVFF  9C7,9CD
045A0:  MOVFF  9C6,9CC
045A4:  MOVFF  9C9,9CF
045A8:  MOVFF  9C8,9CE
045AC:  MOVLB  9
045AE:  MOVF   xCB,F
045B0:  BNZ   45B8
045B2:  MOVF   xCA,W
045B4:  SUBLW  00
045B6:  BC    4618
.................... { 
....................    if(*su1!=*su2) 
045B8:  MOVFF  9CC,FE9
045BC:  MOVFF  9CD,FEA
045C0:  MOVFF  FEF,9D0
045C4:  MOVFF  9CF,03
045C8:  MOVFF  9CE,FE9
045CC:  MOVFF  9CF,FEA
045D0:  MOVF   FEF,W
045D2:  SUBWF  xD0,W
045D4:  BZ    4602
....................       return ((*su1<*su2)?-1:1); 
045D6:  MOVFF  9CD,03
045DA:  MOVFF  9CC,FE9
045DE:  MOVFF  03,FEA
045E2:  MOVFF  FEF,9D0
045E6:  MOVFF  9CF,03
045EA:  MOVFF  9CE,FE9
045EE:  MOVFF  9CF,FEA
045F2:  MOVF   FEF,W
045F4:  SUBWF  xD0,W
045F6:  BC    45FC
045F8:  MOVLW  FF
045FA:  BRA    45FE
045FC:  MOVLW  01
045FE:  MOVWF  01
04600:  BRA    461C
04602:  INCF   xCC,F
04604:  BTFSC  FD8.2
04606:  INCF   xCD,F
04608:  INCF   xCE,F
0460A:  BTFSC  FD8.2
0460C:  INCF   xCF,F
0460E:  MOVF   xCA,W
04610:  BTFSC  FD8.2
04612:  DECF   xCB,F
04614:  DECF   xCA,F
04616:  BRA    45AE
.................... } 
.................... return 0; 
04618:  MOVLW  00
0461A:  MOVWF  01
0461C:  MOVLB  0
0461E:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
12A56:  MOVFF  8C9,8CB
12A5A:  MOVFF  8C8,8CA
12A5E:  MOVFF  8CB,03
12A62:  MOVLB  8
12A64:  MOVFF  8CA,FE9
12A68:  MOVFF  8CB,FEA
12A6C:  MOVF   FEF,F
12A6E:  BZ    12A7C
12A70:  INCF   xCA,F
12A72:  BTFSC  FD8.2
12A74:  INCF   xCB,F
12A76:  MOVLB  0
12A78:  BRA    12A5E
12A7A:  MOVLB  8
....................    return(sc - s); 
12A7C:  MOVF   xC8,W
12A7E:  SUBWF  xCA,W
12A80:  MOVWF  00
12A82:  MOVF   xC9,W
12A84:  SUBWFB xCB,W
12A86:  MOVWF  03
12A88:  MOVFF  00,01
12A8C:  MOVWF  02
12A8E:  MOVLB  0
12A90:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
130D6:  MOVLB  8
130D8:  CLRF   xB7
....................    sign = 0; 
130DA:  CLRF   xB5
....................    base = 10; 
130DC:  MOVLW  0A
130DE:  MOVWF  xB6
....................    result = 0; 
130E0:  CLRF   xB4
130E2:  CLRF   xB3
....................  
....................    if (!s) 
130E4:  MOVF   xB1,W
130E6:  IORWF  xB2,W
130E8:  BNZ   130F2
....................       return 0; 
130EA:  MOVLW  00
130EC:  MOVWF  01
130EE:  MOVWF  02
130F0:  BRA    132B6
....................    c = s[index++]; 
130F2:  MOVF   xB7,W
130F4:  INCF   xB7,F
130F6:  ADDWF  xB1,W
130F8:  MOVWF  FE9
130FA:  MOVLW  00
130FC:  ADDWFC xB2,W
130FE:  MOVWF  FEA
13100:  MOVFF  FEF,8B8
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
13104:  MOVF   xB8,W
13106:  SUBLW  2D
13108:  BNZ   13122
....................    { 
....................       sign = 1;         // Set the sign to negative 
1310A:  MOVLW  01
1310C:  MOVWF  xB5
....................       c = s[index++]; 
1310E:  MOVF   xB7,W
13110:  INCF   xB7,F
13112:  ADDWF  xB1,W
13114:  MOVWF  FE9
13116:  MOVLW  00
13118:  ADDWFC xB2,W
1311A:  MOVWF  FEA
1311C:  MOVFF  FEF,8B8
....................    } 
13120:  BRA    1313A
....................    else if (c == '+') 
13122:  MOVF   xB8,W
13124:  SUBLW  2B
13126:  BNZ   1313A
....................    { 
....................       c = s[index++]; 
13128:  MOVF   xB7,W
1312A:  INCF   xB7,F
1312C:  ADDWF  xB1,W
1312E:  MOVWF  FE9
13130:  MOVLW  00
13132:  ADDWFC xB2,W
13134:  MOVWF  FEA
13136:  MOVFF  FEF,8B8
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1313A:  MOVF   xB8,W
1313C:  SUBLW  2F
1313E:  BTFSC  FD8.0
13140:  BRA    1329A
13142:  MOVF   xB8,W
13144:  SUBLW  39
13146:  BTFSS  FD8.0
13148:  BRA    1329A
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1314A:  MOVF   xB8,W
1314C:  SUBLW  30
1314E:  BNZ   1318C
13150:  MOVF   xB7,W
13152:  ADDWF  xB1,W
13154:  MOVWF  FE9
13156:  MOVLW  00
13158:  ADDWFC xB2,W
1315A:  MOVWF  FEA
1315C:  MOVF   FEF,W
1315E:  SUBLW  78
13160:  BZ    13174
13162:  MOVF   xB7,W
13164:  ADDWF  xB1,W
13166:  MOVWF  FE9
13168:  MOVLW  00
1316A:  ADDWFC xB2,W
1316C:  MOVWF  FEA
1316E:  MOVF   FEF,W
13170:  SUBLW  58
13172:  BNZ   1318C
....................       { 
....................          base = 16; 
13174:  MOVLW  10
13176:  MOVWF  xB6
....................          index++; 
13178:  INCF   xB7,F
....................          c = s[index++]; 
1317A:  MOVF   xB7,W
1317C:  INCF   xB7,F
1317E:  ADDWF  xB1,W
13180:  MOVWF  FE9
13182:  MOVLW  00
13184:  ADDWFC xB2,W
13186:  MOVWF  FEA
13188:  MOVFF  FEF,8B8
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1318C:  MOVF   xB6,W
1318E:  SUBLW  0A
13190:  BNZ   131D6
....................       { 
....................          while (c >= '0' && c <= '9') 
13192:  MOVF   xB8,W
13194:  SUBLW  2F
13196:  BC    131D4
13198:  MOVF   xB8,W
1319A:  SUBLW  39
1319C:  BNC   131D4
....................          { 
....................             result = 10*result + (c - '0'); 
1319E:  CLRF   xBA
131A0:  MOVLW  0A
131A2:  MOVWF  xB9
131A4:  MOVFF  8B4,8BC
131A8:  MOVFF  8B3,8BB
131AC:  MOVLB  0
131AE:  BRA    13080
131B0:  MOVLW  30
131B2:  MOVLB  8
131B4:  SUBWF  xB8,W
131B6:  ADDWF  01,W
131B8:  MOVWF  xB3
131BA:  MOVLW  00
131BC:  ADDWFC 02,W
131BE:  MOVWF  xB4
....................             c = s[index++]; 
131C0:  MOVF   xB7,W
131C2:  INCF   xB7,F
131C4:  ADDWF  xB1,W
131C6:  MOVWF  FE9
131C8:  MOVLW  00
131CA:  ADDWFC xB2,W
131CC:  MOVWF  FEA
131CE:  MOVFF  FEF,8B8
131D2:  BRA    13192
....................          } 
....................       } 
131D4:  BRA    1329A
....................       else if (base == 16)    // The number is a hexa number 
131D6:  MOVF   xB6,W
131D8:  SUBLW  10
131DA:  BNZ   1329A
....................       { 
....................          c = toupper(c); 
131DC:  MOVF   xB8,W
131DE:  SUBLW  60
131E0:  BC    131EE
131E2:  MOVF   xB8,W
131E4:  SUBLW  7A
131E6:  BNC   131EE
131E8:  MOVF   xB8,W
131EA:  ANDLW  DF
131EC:  BRA    131F0
131EE:  MOVF   xB8,W
131F0:  MOVWF  xB8
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
131F2:  MOVF   xB8,W
131F4:  SUBLW  2F
131F6:  BC    131FE
131F8:  MOVF   xB8,W
131FA:  SUBLW  39
131FC:  BC    1320A
131FE:  MOVF   xB8,W
13200:  SUBLW  40
13202:  BC    1329A
13204:  MOVF   xB8,W
13206:  SUBLW  46
13208:  BNC   1329A
....................          { 
....................             if (c >= '0' && c <= '9') 
1320A:  MOVF   xB8,W
1320C:  SUBLW  2F
1320E:  BC    13244
13210:  MOVF   xB8,W
13212:  SUBLW  39
13214:  BNC   13244
....................                result = (result << 4) + (c - '0'); 
13216:  RLCF   xB3,W
13218:  MOVWF  xB9
1321A:  RLCF   xB4,W
1321C:  MOVWF  xBA
1321E:  RLCF   xB9,F
13220:  RLCF   xBA,F
13222:  RLCF   xB9,F
13224:  RLCF   xBA,F
13226:  RLCF   xB9,F
13228:  RLCF   xBA,F
1322A:  MOVLW  F0
1322C:  ANDWF  xB9,F
1322E:  MOVLW  30
13230:  SUBWF  xB8,W
13232:  ADDWF  xB9,W
13234:  MOVWF  01
13236:  MOVLW  00
13238:  ADDWFC xBA,W
1323A:  MOVWF  03
1323C:  MOVFF  01,8B3
13240:  MOVWF  xB4
13242:  BRA    13270
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
13244:  RLCF   xB3,W
13246:  MOVWF  xB9
13248:  RLCF   xB4,W
1324A:  MOVWF  xBA
1324C:  RLCF   xB9,F
1324E:  RLCF   xBA,F
13250:  RLCF   xB9,F
13252:  RLCF   xBA,F
13254:  RLCF   xB9,F
13256:  RLCF   xBA,F
13258:  MOVLW  F0
1325A:  ANDWF  xB9,F
1325C:  MOVLW  41
1325E:  SUBWF  xB8,W
13260:  ADDLW  0A
13262:  ADDWF  xB9,W
13264:  MOVWF  01
13266:  MOVLW  00
13268:  ADDWFC xBA,W
1326A:  MOVFF  01,8B3
1326E:  MOVWF  xB4
....................  
....................             c = s[index++];c = toupper(c); 
13270:  MOVF   xB7,W
13272:  INCF   xB7,F
13274:  ADDWF  xB1,W
13276:  MOVWF  FE9
13278:  MOVLW  00
1327A:  ADDWFC xB2,W
1327C:  MOVWF  FEA
1327E:  MOVFF  FEF,8B8
13282:  MOVF   xB8,W
13284:  SUBLW  60
13286:  BC    13294
13288:  MOVF   xB8,W
1328A:  SUBLW  7A
1328C:  BNC   13294
1328E:  MOVF   xB8,W
13290:  ANDLW  DF
13292:  BRA    13296
13294:  MOVF   xB8,W
13296:  MOVWF  xB8
13298:  BRA    131F2
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1329A:  MOVF   xB6,W
1329C:  SUBLW  0A
1329E:  BNZ   132AE
132A0:  DECFSZ xB5,W
132A2:  BRA    132AE
....................       result = -result; 
132A4:  COMF   xB3,F
132A6:  COMF   xB4,F
132A8:  INCF   xB3,F
132AA:  BTFSC  FD8.2
132AC:  INCF   xB4,F
....................  
....................    return(result); 
132AE:  MOVFF  8B3,01
132B2:  MOVFF  8B4,02
132B6:  MOVLB  0
132B8:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0C7B8:  MOVLB  8
0C7BA:  CLRF   x81
0C7BC:  CLRF   x80
0C7BE:  CLRF   x7F
0C7C0:  MOVLW  7F
0C7C2:  MOVWF  x7E
0C7C4:  CLRF   x85
0C7C6:  CLRF   x84
0C7C8:  CLRF   x83
0C7CA:  CLRF   x82
0C7CC:  BSF    x86.0
0C7CE:  BCF    x86.1
0C7D0:  BCF    x86.2
0C7D2:  CLRF   x88
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0C7D4:  MOVF   x7A,W
0C7D6:  IORWF  x7B,W
0C7D8:  BNZ   C7E4
....................       return 0; 
0C7DA:  CLRF   00
0C7DC:  CLRF   01
0C7DE:  CLRF   02
0C7E0:  CLRF   03
0C7E2:  BRA    CA08
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0C7E4:  MOVF   x88,W
0C7E6:  INCF   x88,F
0C7E8:  ADDWF  x7A,W
0C7EA:  MOVWF  FE9
0C7EC:  MOVLW  00
0C7EE:  ADDWFC x7B,W
0C7F0:  MOVWF  FEA
0C7F2:  MOVFF  FEF,887
0C7F6:  MOVF   x87,F
0C7F8:  BTFSC  FD8.2
0C7FA:  BRA    C98C
....................    { 
....................       if (skip && !isspace(c)) 
0C7FC:  BTFSS  x86.0
0C7FE:  BRA    C81E
0C800:  MOVF   x87,W
0C802:  SUBLW  20
0C804:  BZ    C81E
....................       { 
....................          skip = 0; 
0C806:  BCF    x86.0
....................          if (c == '+') 
0C808:  MOVF   x87,W
0C80A:  SUBLW  2B
0C80C:  BNZ   C814
....................          { 
....................             sign = 0; 
0C80E:  BCF    x86.1
....................             continue; 
0C810:  BRA    C974
....................          }             
0C812:  BRA    C81E
....................          else if (c == '-') 
0C814:  MOVF   x87,W
0C816:  SUBLW  2D
0C818:  BNZ   C81E
....................          { 
....................             sign = 1; 
0C81A:  BSF    x86.1
....................             continue; 
0C81C:  BRA    C974
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0C81E:  BTFSC  x86.0
0C820:  BRA    C830
0C822:  MOVF   x87,W
0C824:  SUBLW  2E
0C826:  BNZ   C830
0C828:  BTFSC  x86.2
0C82A:  BRA    C830
....................          point = 1; 
0C82C:  BSF    x86.2
0C82E:  BRA    C974
....................       else if (!skip && isdigit(c)) 
0C830:  BTFSC  x86.0
0C832:  BRA    C96E
0C834:  MOVF   x87,W
0C836:  SUBLW  2F
0C838:  BTFSC  FD8.0
0C83A:  BRA    C96E
0C83C:  MOVF   x87,W
0C83E:  SUBLW  39
0C840:  BTFSS  FD8.0
0C842:  BRA    C96E
....................       { 
....................          c -= '0'; 
0C844:  MOVLW  30
0C846:  SUBWF  x87,F
....................          if (point) 
0C848:  BTFSS  x86.2
0C84A:  BRA    C8F6
....................          { 
....................             pow10 = pow10 * 10.0; 
0C84C:  MOVFF  881,8F3
0C850:  MOVFF  880,8F2
0C854:  MOVFF  87F,8F1
0C858:  MOVFF  87E,8F0
0C85C:  CLRF   xF7
0C85E:  CLRF   xF6
0C860:  MOVLW  20
0C862:  MOVWF  xF5
0C864:  MOVLW  82
0C866:  MOVWF  xF4
0C868:  MOVLB  0
0C86A:  CALL   BF36
0C86E:  MOVFF  03,881
0C872:  MOVFF  02,880
0C876:  MOVFF  01,87F
0C87A:  MOVFF  00,87E
....................             result += (float)c / pow10;    
0C87E:  MOVLB  8
0C880:  CLRF   xF5
0C882:  MOVFF  887,8F4
0C886:  MOVLB  0
0C888:  RCALL  C624
0C88A:  MOVFF  03,88C
0C88E:  MOVFF  02,88B
0C892:  MOVFF  01,88A
0C896:  MOVFF  00,889
0C89A:  MOVFF  03,8DB
0C89E:  MOVFF  02,8DA
0C8A2:  MOVFF  01,8D9
0C8A6:  MOVFF  00,8D8
0C8AA:  MOVFF  881,8DF
0C8AE:  MOVFF  880,8DE
0C8B2:  MOVFF  87F,8DD
0C8B6:  MOVFF  87E,8DC
0C8BA:  RCALL  C65A
0C8BC:  BCF    FD8.1
0C8BE:  MOVFF  885,8F7
0C8C2:  MOVFF  884,8F6
0C8C6:  MOVFF  883,8F5
0C8CA:  MOVFF  882,8F4
0C8CE:  MOVFF  03,8FB
0C8D2:  MOVFF  02,8FA
0C8D6:  MOVFF  01,8F9
0C8DA:  MOVFF  00,8F8
0C8DE:  CALL   C02C
0C8E2:  MOVFF  03,885
0C8E6:  MOVFF  02,884
0C8EA:  MOVFF  01,883
0C8EE:  MOVFF  00,882
....................          } 
0C8F2:  BRA    C96A
0C8F4:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0C8F6:  CLRF   xF3
0C8F8:  CLRF   xF2
0C8FA:  MOVLW  20
0C8FC:  MOVWF  xF1
0C8FE:  MOVLW  82
0C900:  MOVWF  xF0
0C902:  MOVFF  885,8F7
0C906:  MOVFF  884,8F6
0C90A:  MOVFF  883,8F5
0C90E:  MOVFF  882,8F4
0C912:  MOVLB  0
0C914:  CALL   BF36
0C918:  MOVFF  03,88C
0C91C:  MOVFF  02,88B
0C920:  MOVFF  01,88A
0C924:  MOVFF  00,889
0C928:  MOVLB  8
0C92A:  CLRF   xF5
0C92C:  MOVFF  887,8F4
0C930:  MOVLB  0
0C932:  RCALL  C624
0C934:  BCF    FD8.1
0C936:  MOVFF  88C,8F7
0C93A:  MOVFF  88B,8F6
0C93E:  MOVFF  88A,8F5
0C942:  MOVFF  889,8F4
0C946:  MOVFF  03,8FB
0C94A:  MOVFF  02,8FA
0C94E:  MOVFF  01,8F9
0C952:  MOVFF  00,8F8
0C956:  CALL   C02C
0C95A:  MOVFF  03,885
0C95E:  MOVFF  02,884
0C962:  MOVFF  01,883
0C966:  MOVFF  00,882
....................          } 
....................       } 
0C96A:  BRA    C976
0C96C:  MOVLB  8
....................       else if (!skip) 
0C96E:  BTFSC  x86.0
0C970:  BRA    C974
....................          break; 
0C972:  BRA    C98C
0C974:  MOVLB  0
0C976:  MOVLB  8
0C978:  MOVF   x88,W
0C97A:  INCF   x88,F
0C97C:  ADDWF  x7A,W
0C97E:  MOVWF  FE9
0C980:  MOVLW  00
0C982:  ADDWFC x7B,W
0C984:  MOVWF  FEA
0C986:  MOVFF  FEF,887
0C98A:  BRA    C7F6
....................    } 
....................  
....................    if (sign) 
0C98C:  BTFSS  x86.1
0C98E:  BRA    C9C4
....................       result = -1*result; 
0C990:  CLRF   xF3
0C992:  CLRF   xF2
0C994:  MOVLW  80
0C996:  MOVWF  xF1
0C998:  MOVLW  7F
0C99A:  MOVWF  xF0
0C99C:  MOVFF  885,8F7
0C9A0:  MOVFF  884,8F6
0C9A4:  MOVFF  883,8F5
0C9A8:  MOVFF  882,8F4
0C9AC:  MOVLB  0
0C9AE:  CALL   BF36
0C9B2:  MOVFF  03,885
0C9B6:  MOVFF  02,884
0C9BA:  MOVFF  01,883
0C9BE:  MOVFF  00,882
0C9C2:  MOVLB  8
....................        
....................    if(endptr) 
0C9C4:  MOVF   x7C,W
0C9C6:  IORWF  x7D,W
0C9C8:  BZ    C9F8
....................    { 
....................       if (ptr) { 
0C9CA:  MOVF   x88,F
0C9CC:  BZ    C9E6
....................          ptr--; 
0C9CE:  DECF   x88,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0C9D0:  MOVFF  87C,FE9
0C9D4:  MOVFF  87D,FEA
0C9D8:  MOVF   x88,W
0C9DA:  ADDWF  x7A,W
0C9DC:  MOVWF  FEF
0C9DE:  MOVLW  00
0C9E0:  ADDWFC x7B,W
0C9E2:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0C9E4:  BRA    C9F8
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0C9E6:  MOVFF  87C,FE9
0C9EA:  MOVFF  87D,FEA
0C9EE:  MOVFF  87B,FEC
0C9F2:  MOVF   FED,F
0C9F4:  MOVFF  87A,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0C9F8:  MOVFF  882,00
0C9FC:  MOVFF  883,01
0CA00:  MOVFF  884,02
0CA04:  MOVFF  885,03
0CA08:  MOVLB  0
0CA0A:  GOTO   CA32 (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
1252C:  MOVLB  8
1252E:  BCF    xEF.0
....................    y = x; 
12530:  MOVFF  8E3,8E8
12534:  MOVFF  8E2,8E7
12538:  MOVFF  8E1,8E6
1253C:  MOVFF  8E0,8E5
....................  
....................    if (x < 0) 
12540:  MOVFF  8E3,8F3
12544:  MOVFF  8E2,8F2
12548:  MOVFF  8E1,8F1
1254C:  MOVFF  8E0,8F0
12550:  CLRF   xF7
12552:  CLRF   xF6
12554:  CLRF   xF5
12556:  CLRF   xF4
12558:  MOVLB  0
1255A:  CALL   10460
1255E:  BNC   1256C
....................    { 
....................       s = 1; 
12560:  MOVLB  8
12562:  BSF    xEF.0
....................       y = -y; 
12564:  MOVF   xE6,W
12566:  XORLW  80
12568:  MOVWF  xE6
1256A:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
1256C:  MOVFF  8E8,8F3
12570:  MOVFF  8E7,8F2
12574:  MOVFF  8E6,8F1
12578:  MOVFF  8E5,8F0
1257C:  MOVLB  8
1257E:  CLRF   xF7
12580:  CLRF   xF6
12582:  CLRF   xF5
12584:  MOVLW  8E
12586:  MOVWF  xF4
12588:  MOVLB  0
1258A:  CALL   10460
1258E:  BC    12592
12590:  BNZ   125C2
....................       res = (float32)(unsigned int16)y; 
12592:  MOVFF  8E8,8F3
12596:  MOVFF  8E7,8F2
1259A:  MOVFF  8E6,8F1
1259E:  MOVFF  8E5,8F0
125A2:  RCALL  124F0
125A4:  MOVFF  02,8F5
125A8:  MOVFF  01,8F4
125AC:  CALL   C624
125B0:  MOVFF  03,8EC
125B4:  MOVFF  02,8EB
125B8:  MOVFF  01,8EA
125BC:  MOVFF  00,8E9
125C0:  BRA    12764
....................  
....................  else if (y < 10000000.0) 
125C2:  MOVFF  8E8,8F3
125C6:  MOVFF  8E7,8F2
125CA:  MOVFF  8E6,8F1
125CE:  MOVFF  8E5,8F0
125D2:  MOVLW  80
125D4:  MOVLB  8
125D6:  MOVWF  xF7
125D8:  MOVLW  96
125DA:  MOVWF  xF6
125DC:  MOVLW  18
125DE:  MOVWF  xF5
125E0:  MOVLW  96
125E2:  MOVWF  xF4
125E4:  MOVLB  0
125E6:  CALL   10460
125EA:  BTFSS  FD8.0
125EC:  BRA    12754
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
125EE:  MOVFF  8E8,8F3
125F2:  MOVFF  8E7,8F2
125F6:  MOVFF  8E6,8F1
125FA:  MOVFF  8E5,8F0
125FE:  MOVLB  8
12600:  CLRF   xF7
12602:  CLRF   xF6
12604:  CLRF   xF5
12606:  MOVLW  70
12608:  MOVWF  xF4
1260A:  MOVLB  0
1260C:  CALL   BF36
12610:  MOVFF  03,8F3
12614:  MOVFF  02,8F2
12618:  MOVFF  01,8F1
1261C:  MOVFF  00,8F0
12620:  RCALL  124F0
12622:  MOVFF  02,8EE
12626:  MOVFF  01,8ED
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
1262A:  MOVFF  8E8,8F3
1262E:  MOVFF  8E7,8F2
12632:  MOVFF  8E6,8F1
12636:  MOVFF  8E5,8F0
1263A:  MOVLB  8
1263C:  CLRF   xF7
1263E:  CLRF   xF6
12640:  CLRF   xF5
12642:  MOVLW  70
12644:  MOVWF  xF4
12646:  MOVLB  0
12648:  CALL   BF36
1264C:  MOVFF  03,8F3
12650:  MOVFF  02,8F2
12654:  MOVFF  01,8F1
12658:  MOVFF  00,8F0
1265C:  MOVFF  8EE,8F5
12660:  MOVFF  8ED,8F4
12664:  CALL   C624
12668:  BSF    FD8.1
1266A:  MOVFF  8F3,8F7
1266E:  MOVFF  8F2,8F6
12672:  MOVFF  8F1,8F5
12676:  MOVFF  8F0,8F4
1267A:  MOVFF  03,8FB
1267E:  MOVFF  02,8FA
12682:  MOVFF  01,8F9
12686:  MOVFF  00,8F8
1268A:  CALL   C02C
1268E:  MOVLB  8
12690:  CLRF   xF3
12692:  CLRF   xF2
12694:  CLRF   xF1
12696:  MOVLW  8E
12698:  MOVWF  xF0
1269A:  MOVFF  03,8F7
1269E:  MOVFF  02,8F6
126A2:  MOVFF  01,8F5
126A6:  MOVFF  00,8F4
126AA:  MOVLB  0
126AC:  CALL   BF36
126B0:  MOVFF  03,8E8
126B4:  MOVFF  02,8E7
126B8:  MOVFF  01,8E6
126BC:  MOVFF  00,8E5
....................       res = 32768.0*(float32)l; 
126C0:  MOVFF  8EE,8F5
126C4:  MOVFF  8ED,8F4
126C8:  CALL   C624
126CC:  MOVLB  8
126CE:  CLRF   xF3
126D0:  CLRF   xF2
126D2:  CLRF   xF1
126D4:  MOVLW  8E
126D6:  MOVWF  xF0
126D8:  MOVFF  03,8F7
126DC:  MOVFF  02,8F6
126E0:  MOVFF  01,8F5
126E4:  MOVFF  00,8F4
126E8:  MOVLB  0
126EA:  CALL   BF36
126EE:  MOVFF  03,8EC
126F2:  MOVFF  02,8EB
126F6:  MOVFF  01,8EA
126FA:  MOVFF  00,8E9
....................       res += (float32)(unsigned int16)y; 
126FE:  MOVFF  8E8,8F3
12702:  MOVFF  8E7,8F2
12706:  MOVFF  8E6,8F1
1270A:  MOVFF  8E5,8F0
1270E:  RCALL  124F0
12710:  MOVFF  02,8F5
12714:  MOVFF  01,8F4
12718:  CALL   C624
1271C:  BCF    FD8.1
1271E:  MOVFF  8EC,8F7
12722:  MOVFF  8EB,8F6
12726:  MOVFF  8EA,8F5
1272A:  MOVFF  8E9,8F4
1272E:  MOVFF  03,8FB
12732:  MOVFF  02,8FA
12736:  MOVFF  01,8F9
1273A:  MOVFF  00,8F8
1273E:  CALL   C02C
12742:  MOVFF  03,8EC
12746:  MOVFF  02,8EB
1274A:  MOVFF  01,8EA
1274E:  MOVFF  00,8E9
....................    } 
12752:  BRA    12764
....................  
....................  else 
....................   res = y; 
12754:  MOVFF  8E8,8EC
12758:  MOVFF  8E7,8EB
1275C:  MOVFF  8E6,8EA
12760:  MOVFF  8E5,8E9
....................  
....................  y = y - (float32)(unsigned int16)y; 
12764:  MOVFF  8E8,8F3
12768:  MOVFF  8E7,8F2
1276C:  MOVFF  8E6,8F1
12770:  MOVFF  8E5,8F0
12774:  RCALL  124F0
12776:  MOVFF  02,8F5
1277A:  MOVFF  01,8F4
1277E:  CALL   C624
12782:  BSF    FD8.1
12784:  MOVFF  8E8,8F7
12788:  MOVFF  8E7,8F6
1278C:  MOVFF  8E6,8F5
12790:  MOVFF  8E5,8F4
12794:  MOVFF  03,8FB
12798:  MOVFF  02,8FA
1279C:  MOVFF  01,8F9
127A0:  MOVFF  00,8F8
127A4:  CALL   C02C
127A8:  MOVFF  03,8E8
127AC:  MOVFF  02,8E7
127B0:  MOVFF  01,8E6
127B4:  MOVFF  00,8E5
....................  
....................  if (s) 
127B8:  MOVLB  8
127BA:  BTFSS  xEF.0
127BC:  BRA    127C4
....................   res = -res; 
127BE:  MOVF   xEA,W
127C0:  XORLW  80
127C2:  MOVWF  xEA
....................  
....................  if (y != 0) 
127C4:  MOVFF  8E8,8F3
127C8:  MOVFF  8E7,8F2
127CC:  MOVFF  8E6,8F1
127D0:  MOVFF  8E5,8F0
127D4:  CLRF   xF7
127D6:  CLRF   xF6
127D8:  CLRF   xF5
127DA:  CLRF   xF4
127DC:  MOVLB  0
127DE:  CALL   10460
127E2:  BZ    1285C
....................  { 
....................   if (s == 1 && n == 0) 
127E4:  MOVLB  8
127E6:  BTFSS  xEF.0
127E8:  BRA    12822
127EA:  MOVF   xE4,F
127EC:  BNZ   12822
....................    res -= 1.0; 
127EE:  BSF    FD8.1
127F0:  MOVFF  8EC,8F7
127F4:  MOVFF  8EB,8F6
127F8:  MOVFF  8EA,8F5
127FC:  MOVFF  8E9,8F4
12800:  CLRF   xFB
12802:  CLRF   xFA
12804:  CLRF   xF9
12806:  MOVLW  7F
12808:  MOVWF  xF8
1280A:  MOVLB  0
1280C:  CALL   C02C
12810:  MOVFF  03,8EC
12814:  MOVFF  02,8EB
12818:  MOVFF  01,8EA
1281C:  MOVFF  00,8E9
12820:  MOVLB  8
....................  
....................   if (s == 0 && n == 1) 
12822:  BTFSC  xEF.0
12824:  BRA    1285E
12826:  DECFSZ xE4,W
12828:  BRA    1285E
....................    res += 1.0; 
1282A:  BCF    FD8.1
1282C:  MOVFF  8EC,8F7
12830:  MOVFF  8EB,8F6
12834:  MOVFF  8EA,8F5
12838:  MOVFF  8E9,8F4
1283C:  CLRF   xFB
1283E:  CLRF   xFA
12840:  CLRF   xF9
12842:  MOVLW  7F
12844:  MOVWF  xF8
12846:  MOVLB  0
12848:  CALL   C02C
1284C:  MOVFF  03,8EC
12850:  MOVFF  02,8EB
12854:  MOVFF  01,8EA
12858:  MOVFF  00,8E9
1285C:  MOVLB  8
....................  } 
....................  if (x == 0) 
1285E:  MOVFF  8E3,8F3
12862:  MOVFF  8E2,8F2
12866:  MOVFF  8E1,8F1
1286A:  MOVFF  8E0,8F0
1286E:  CLRF   xF7
12870:  CLRF   xF6
12872:  CLRF   xF5
12874:  CLRF   xF4
12876:  MOVLB  0
12878:  CALL   10460
1287C:  BNZ   1288A
....................     res = 0; 
1287E:  MOVLB  8
12880:  CLRF   xEC
12882:  CLRF   xEB
12884:  CLRF   xEA
12886:  CLRF   xE9
12888:  MOVLB  0
....................  
....................  return (res); 
1288A:  MOVFF  8E9,00
1288E:  MOVFF  8EA,01
12892:  MOVFF  8EB,02
12896:  MOVFF  8EC,03
1289A:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
128BA:  MOVFF  8DF,8E3
128BE:  MOVFF  8DE,8E2
128C2:  MOVFF  8DD,8E1
128C6:  MOVFF  8DC,8E0
128CA:  MOVLB  8
128CC:  CLRF   xE4
128CE:  MOVLB  0
128D0:  RCALL  1252C
128D2:  GOTO   129DE (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
1289C:  MOVFF  8DF,8E3
128A0:  MOVFF  8DE,8E2
128A4:  MOVFF  8DD,8E1
128A8:  MOVFF  8DC,8E0
128AC:  MOVLW  01
128AE:  MOVLB  8
128B0:  MOVWF  xE4
128B2:  MOVLB  0
128B4:  RCALL  1252C
128B6:  GOTO   12996 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
128D6:  MOVFF  8D3,8F3
128DA:  MOVFF  8D2,8F2
128DE:  MOVFF  8D1,8F1
128E2:  MOVFF  8D0,8F0
128E6:  MOVLB  8
128E8:  CLRF   xF7
128EA:  CLRF   xF6
128EC:  CLRF   xF5
128EE:  CLRF   xF4
128F0:  MOVLB  0
128F2:  CALL   10460
128F6:  BTFSC  FD8.2
128F8:  BRA    12A3A
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
128FA:  MOVFF  8CF,8DB
128FE:  MOVFF  8CE,8DA
12902:  MOVFF  8CD,8D9
12906:  MOVFF  8CC,8D8
1290A:  MOVFF  8D3,8DF
1290E:  MOVFF  8D2,8DE
12912:  MOVFF  8D1,8DD
12916:  MOVFF  8D0,8DC
1291A:  CALL   C65A
1291E:  MOVFF  03,8DB
12922:  MOVFF  02,8DA
12926:  MOVFF  01,8D9
1292A:  MOVFF  00,8D8
1292E:  MOVFF  03,8F3
12932:  MOVFF  02,8F2
12936:  MOVFF  01,8F1
1293A:  MOVFF  00,8F0
1293E:  MOVLB  8
12940:  CLRF   xF7
12942:  CLRF   xF6
12944:  CLRF   xF5
12946:  CLRF   xF4
12948:  MOVLB  0
1294A:  CALL   10460
1294E:  BNC   12998
12950:  MOVFF  8CF,8DB
12954:  MOVFF  8CE,8DA
12958:  MOVFF  8CD,8D9
1295C:  MOVFF  8CC,8D8
12960:  MOVFF  8D3,8DF
12964:  MOVFF  8D2,8DE
12968:  MOVFF  8D1,8DD
1296C:  MOVFF  8D0,8DC
12970:  CALL   C65A
12974:  MOVFF  03,8DB
12978:  MOVFF  02,8DA
1297C:  MOVFF  01,8D9
12980:  MOVFF  00,8D8
12984:  MOVFF  03,8DF
12988:  MOVFF  02,8DE
1298C:  MOVFF  01,8DD
12990:  MOVFF  00,8DC
12994:  BRA    1289C
12996:  BRA    129DE
12998:  MOVFF  8CF,8DB
1299C:  MOVFF  8CE,8DA
129A0:  MOVFF  8CD,8D9
129A4:  MOVFF  8CC,8D8
129A8:  MOVFF  8D3,8DF
129AC:  MOVFF  8D2,8DE
129B0:  MOVFF  8D1,8DD
129B4:  MOVFF  8D0,8DC
129B8:  CALL   C65A
129BC:  MOVFF  03,8DB
129C0:  MOVFF  02,8DA
129C4:  MOVFF  01,8D9
129C8:  MOVFF  00,8D8
129CC:  MOVFF  03,8DF
129D0:  MOVFF  02,8DE
129D4:  MOVFF  01,8DD
129D8:  MOVFF  00,8DC
129DC:  BRA    128BA
129DE:  MOVFF  03,8D7
129E2:  MOVFF  02,8D6
129E6:  MOVFF  01,8D5
129EA:  MOVFF  00,8D4
....................       return(x-(i*y)); 
129EE:  MOVFF  8D7,8F3
129F2:  MOVFF  8D6,8F2
129F6:  MOVFF  8D5,8F1
129FA:  MOVFF  8D4,8F0
129FE:  MOVFF  8D3,8F7
12A02:  MOVFF  8D2,8F6
12A06:  MOVFF  8D1,8F5
12A0A:  MOVFF  8D0,8F4
12A0E:  CALL   BF36
12A12:  BSF    FD8.1
12A14:  MOVFF  8CF,8F7
12A18:  MOVFF  8CE,8F6
12A1C:  MOVFF  8CD,8F5
12A20:  MOVFF  8CC,8F4
12A24:  MOVFF  03,8FB
12A28:  MOVFF  02,8FA
12A2C:  MOVFF  01,8F9
12A30:  MOVFF  00,8F8
12A34:  CALL   C02C
12A38:  BRA    12A3A
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
12A3A:  GOTO   12CD2 (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
1052A:  MOVFF  8B7,8BB
1052E:  MOVFF  8B6,8BA
10532:  MOVFF  8B5,8B9
10536:  MOVFF  8B4,8B8
....................  
....................    if (y != 1.0) 
1053A:  MOVFF  8BB,8F3
1053E:  MOVFF  8BA,8F2
10542:  MOVFF  8B9,8F1
10546:  MOVFF  8B8,8F0
1054A:  MOVLB  8
1054C:  CLRF   xF7
1054E:  CLRF   xF6
10550:  CLRF   xF5
10552:  MOVLW  7F
10554:  MOVWF  xF4
10556:  MOVLB  0
10558:  RCALL  10460
1055A:  BTFSC  FD8.2
1055C:  BRA    1089A
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
1055E:  MOVLW  08
10560:  MOVLB  8
10562:  MOVWF  xCA
10564:  MOVLW  B8
10566:  MOVWF  FE9
10568:  MOVFF  8CA,FEA
1056C:  MOVLW  7E
1056E:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
10570:  BSF    FD8.1
10572:  MOVFF  8BB,8F7
10576:  MOVFF  8BA,8F6
1057A:  MOVFF  8B9,8F5
1057E:  MOVFF  8B8,8F4
10582:  CLRF   xFB
10584:  CLRF   xFA
10586:  CLRF   xF9
10588:  MOVLW  7F
1058A:  MOVWF  xF8
1058C:  MOVLB  0
1058E:  CALL   C02C
10592:  MOVFF  03,8CC
10596:  MOVFF  02,8CB
1059A:  MOVFF  01,8CA
1059E:  MOVFF  00,8C9
105A2:  BCF    FD8.1
105A4:  MOVFF  8BB,8F7
105A8:  MOVFF  8BA,8F6
105AC:  MOVFF  8B9,8F5
105B0:  MOVFF  8B8,8F4
105B4:  MOVLB  8
105B6:  CLRF   xFB
105B8:  CLRF   xFA
105BA:  CLRF   xF9
105BC:  MOVLW  7F
105BE:  MOVWF  xF8
105C0:  MOVLB  0
105C2:  CALL   C02C
105C6:  MOVFF  8CC,8DB
105CA:  MOVFF  8CB,8DA
105CE:  MOVFF  8CA,8D9
105D2:  MOVFF  8C9,8D8
105D6:  MOVFF  03,8DF
105DA:  MOVFF  02,8DE
105DE:  MOVFF  01,8DD
105E2:  MOVFF  00,8DC
105E6:  CALL   C65A
105EA:  MOVFF  03,8BB
105EE:  MOVFF  02,8BA
105F2:  MOVFF  01,8B9
105F6:  MOVFF  00,8B8
....................  
....................       y2=y*y; 
105FA:  MOVFF  8BB,8F3
105FE:  MOVFF  8BA,8F2
10602:  MOVFF  8B9,8F1
10606:  MOVFF  8B8,8F0
1060A:  MOVFF  8BB,8F7
1060E:  MOVFF  8BA,8F6
10612:  MOVFF  8B9,8F5
10616:  MOVFF  8B8,8F4
1061A:  CALL   BF36
1061E:  MOVFF  03,8C7
10622:  MOVFF  02,8C6
10626:  MOVFF  01,8C5
1062A:  MOVFF  00,8C4
....................  
....................       res = pl[0]*y2 + pl[1]; 
1062E:  MOVLW  99
10630:  MOVLB  8
10632:  MOVWF  xF3
10634:  MOVLW  47
10636:  MOVWF  xF2
10638:  MOVLW  8A
1063A:  MOVWF  xF1
1063C:  MOVLW  7F
1063E:  MOVWF  xF0
10640:  MOVFF  8C7,8F7
10644:  MOVFF  8C6,8F6
10648:  MOVFF  8C5,8F5
1064C:  MOVFF  8C4,8F4
10650:  MOVLB  0
10652:  CALL   BF36
10656:  MOVFF  03,8CC
1065A:  MOVFF  02,8CB
1065E:  MOVFF  01,8CA
10662:  MOVFF  00,8C9
10666:  BCF    FD8.1
10668:  MOVFF  03,8F7
1066C:  MOVFF  02,8F6
10670:  MOVFF  01,8F5
10674:  MOVFF  00,8F4
10678:  MOVLB  8
1067A:  CLRF   xFB
1067C:  CLRF   xFA
1067E:  CLRF   xF9
10680:  MOVLW  80
10682:  MOVWF  xF8
10684:  MOVLB  0
10686:  CALL   C02C
1068A:  MOVFF  03,8BF
1068E:  MOVFF  02,8BE
10692:  MOVFF  01,8BD
10696:  MOVFF  00,8BC
....................  
....................       r = ql[0]*y2 + ql[1]; 
1069A:  MOVLW  4C
1069C:  MOVLB  8
1069E:  MOVWF  xF3
106A0:  MOVLW  F3
106A2:  MOVWF  xF2
106A4:  MOVLW  3A
106A6:  MOVWF  xF1
106A8:  MOVLW  7B
106AA:  MOVWF  xF0
106AC:  MOVFF  8C7,8F7
106B0:  MOVFF  8C6,8F6
106B4:  MOVFF  8C5,8F5
106B8:  MOVFF  8C4,8F4
106BC:  MOVLB  0
106BE:  CALL   BF36
106C2:  MOVFF  03,8CC
106C6:  MOVFF  02,8CB
106CA:  MOVFF  01,8CA
106CE:  MOVFF  00,8C9
106D2:  BCF    FD8.1
106D4:  MOVFF  03,8F7
106D8:  MOVFF  02,8F6
106DC:  MOVFF  01,8F5
106E0:  MOVFF  00,8F4
106E4:  MOVLW  2B
106E6:  MOVLB  8
106E8:  MOVWF  xFB
106EA:  MOVLW  9D
106EC:  MOVWF  xFA
106EE:  MOVLW  DF
106F0:  MOVWF  xF9
106F2:  MOVLW  7E
106F4:  MOVWF  xF8
106F6:  MOVLB  0
106F8:  CALL   C02C
106FC:  MOVFF  03,8C3
10700:  MOVFF  02,8C2
10704:  MOVFF  01,8C1
10708:  MOVFF  00,8C0
....................       r = r*y2 + 1.0; 
1070C:  MOVFF  8C3,8F3
10710:  MOVFF  8C2,8F2
10714:  MOVFF  8C1,8F1
10718:  MOVFF  8C0,8F0
1071C:  MOVFF  8C7,8F7
10720:  MOVFF  8C6,8F6
10724:  MOVFF  8C5,8F5
10728:  MOVFF  8C4,8F4
1072C:  CALL   BF36
10730:  MOVFF  03,8CC
10734:  MOVFF  02,8CB
10738:  MOVFF  01,8CA
1073C:  MOVFF  00,8C9
10740:  BCF    FD8.1
10742:  MOVFF  03,8F7
10746:  MOVFF  02,8F6
1074A:  MOVFF  01,8F5
1074E:  MOVFF  00,8F4
10752:  MOVLB  8
10754:  CLRF   xFB
10756:  CLRF   xFA
10758:  CLRF   xF9
1075A:  MOVLW  7F
1075C:  MOVWF  xF8
1075E:  MOVLB  0
10760:  CALL   C02C
10764:  MOVFF  03,8C3
10768:  MOVFF  02,8C2
1076C:  MOVFF  01,8C1
10770:  MOVFF  00,8C0
....................  
....................       res = y*res/r; 
10774:  MOVFF  8BB,8F3
10778:  MOVFF  8BA,8F2
1077C:  MOVFF  8B9,8F1
10780:  MOVFF  8B8,8F0
10784:  MOVFF  8BF,8F7
10788:  MOVFF  8BE,8F6
1078C:  MOVFF  8BD,8F5
10790:  MOVFF  8BC,8F4
10794:  CALL   BF36
10798:  MOVFF  03,8CC
1079C:  MOVFF  02,8CB
107A0:  MOVFF  01,8CA
107A4:  MOVFF  00,8C9
107A8:  MOVFF  03,8DB
107AC:  MOVFF  02,8DA
107B0:  MOVFF  01,8D9
107B4:  MOVFF  00,8D8
107B8:  MOVFF  8C3,8DF
107BC:  MOVFF  8C2,8DE
107C0:  MOVFF  8C1,8DD
107C4:  MOVFF  8C0,8DC
107C8:  CALL   C65A
107CC:  MOVFF  03,8BF
107D0:  MOVFF  02,8BE
107D4:  MOVFF  01,8BD
107D8:  MOVFF  00,8BC
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
107DC:  MOVLW  08
107DE:  MOVLB  8
107E0:  MOVWF  xCA
107E2:  MOVLW  B4
107E4:  MOVWF  FE9
107E6:  MOVFF  8CA,FEA
107EA:  MOVLW  7E
107EC:  SUBWF  FEF,W
107EE:  MOVWF  xC8
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
107F0:  BTFSS  xC8.7
107F2:  BRA    1081C
....................          r = -(float32)-n; 
107F4:  MOVLW  00
107F6:  BSF    FD8.0
107F8:  SUBFWB xC8,W
107FA:  CLRF   xCA
107FC:  MOVWF  xC9
107FE:  BTFSC  xC9.7
10800:  DECF   xCA,F
10802:  MOVLB  0
10804:  RCALL  104DA
10806:  MOVFF  00,8C0
1080A:  MOVF   01,W
1080C:  XORLW  80
1080E:  MOVLB  8
10810:  MOVWF  xC1
10812:  MOVFF  02,8C2
10816:  MOVFF  03,8C3
1081A:  BRA    1083C
....................       else 
....................          r = (float32)n; 
1081C:  CLRF   xCA
1081E:  MOVFF  8C8,8C9
10822:  BTFSC  xC9.7
10824:  DECF   xCA,F
10826:  MOVLB  0
10828:  RCALL  104DA
1082A:  MOVFF  03,8C3
1082E:  MOVFF  02,8C2
10832:  MOVFF  01,8C1
10836:  MOVFF  00,8C0
1083A:  MOVLB  8
....................  
....................       res += r*LN2; 
1083C:  MOVFF  8C3,8F3
10840:  MOVFF  8C2,8F2
10844:  MOVFF  8C1,8F1
10848:  MOVFF  8C0,8F0
1084C:  MOVLW  18
1084E:  MOVWF  xF7
10850:  MOVLW  72
10852:  MOVWF  xF6
10854:  MOVLW  31
10856:  MOVWF  xF5
10858:  MOVLW  7E
1085A:  MOVWF  xF4
1085C:  MOVLB  0
1085E:  CALL   BF36
10862:  BCF    FD8.1
10864:  MOVFF  8BF,8F7
10868:  MOVFF  8BE,8F6
1086C:  MOVFF  8BD,8F5
10870:  MOVFF  8BC,8F4
10874:  MOVFF  03,8FB
10878:  MOVFF  02,8FA
1087C:  MOVFF  01,8F9
10880:  MOVFF  00,8F8
10884:  CALL   C02C
10888:  MOVFF  03,8BF
1088C:  MOVFF  02,8BE
10890:  MOVFF  01,8BD
10894:  MOVFF  00,8BC
....................    } 
10898:  BRA    108A6
....................  
....................    else 
....................       res = 0.0; 
1089A:  MOVLB  8
1089C:  CLRF   xBF
1089E:  CLRF   xBE
108A0:  CLRF   xBD
108A2:  CLRF   xBC
108A4:  MOVLB  0
....................  
....................    return(res); 
108A6:  MOVFF  8BC,00
108AA:  MOVFF  8BD,01
108AE:  MOVFF  8BE,02
108B2:  MOVFF  8BF,03
108B6:  GOTO   108CC (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
108BA:  MOVFF  8AF,8B7
108BE:  MOVFF  8AE,8B6
108C2:  MOVFF  8AD,8B5
108C6:  MOVFF  8AC,8B4
108CA:  BRA    1052A
108CC:  MOVFF  03,8B3
108D0:  MOVFF  02,8B2
108D4:  MOVFF  01,8B1
108D8:  MOVFF  00,8B0
....................    r = r*LN10_INV; 
108DC:  MOVFF  8B3,8F3
108E0:  MOVFF  8B2,8F2
108E4:  MOVFF  8B1,8F1
108E8:  MOVFF  8B0,8F0
108EC:  MOVLW  D9
108EE:  MOVLB  8
108F0:  MOVWF  xF7
108F2:  MOVLW  5B
108F4:  MOVWF  xF6
108F6:  MOVLW  5E
108F8:  MOVWF  xF5
108FA:  MOVLW  7D
108FC:  MOVWF  xF4
108FE:  MOVLB  0
10900:  CALL   BF36
10904:  MOVFF  03,8B3
10908:  MOVFF  02,8B2
1090C:  MOVFF  01,8B1
10910:  MOVFF  00,8B0
....................    return(r); 
10914:  MOVFF  8B0,00
10918:  MOVFF  8B1,01
1091C:  MOVFF  8B2,02
10920:  MOVFF  8B3,03
10924:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
0FFE6:  BCF    FC6.5
0FFE8:  MOVLW  21
0FFEA:  MOVWF  FC6
0FFEC:  MOVLW  40
0FFEE:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
0FFF0:  BSF    F91.2
....................    output_high(EEP_WP); 
0FFF2:  BSF    F91.3
0FFF4:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
*
102C8:  BCF    F91.2
....................    spi_write(0x05);  
102CA:  MOVF   FC9,W
102CC:  MOVLW  05
102CE:  MOVWF  FC9
102D0:  RRCF   FC7,W
102D2:  BNC   102D0
....................    data = spi_read(0);  
102D4:  MOVF   FC9,W
102D6:  CLRF   FC9
102D8:  RRCF   FC7,W
102DA:  BNC   102D8
102DC:  MOVFF  FC9,8AB
....................    output_high(EEP_CS);  
102E0:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
102E2:  MOVLW  00
102E4:  MOVLB  8
102E6:  BTFSS  xAB.0
102E8:  MOVLW  01
102EA:  MOVWF  01
102EC:  MOVLB  0
102EE:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
17B66:  MOVLB  8
17B68:  CLRF   xCA
17B6A:  MOVLB  0
17B6C:  CALL   5504
....................       while(!ext_eeprom_ready()); 
17B70:  CALL   102C8
17B74:  MOVF   01,F
17B76:  BZ    17B70
....................     
....................       output_low(EEP_CS);  
17B78:  BCF    F91.2
....................       spi_write(0x06);  
17B7A:  MOVF   FC9,W
17B7C:  MOVLW  06
17B7E:  MOVWF  FC9
17B80:  RRCF   FC7,W
17B82:  BNC   17B80
....................       output_high(EEP_CS);  
17B84:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
17B86:  BCF    F91.2
....................       spi_write(0x02);  
17B88:  MOVF   FC9,W
17B8A:  MOVLW  02
17B8C:  MOVWF  FC9
17B8E:  RRCF   FC7,W
17B90:  BNC   17B8E
....................       spi_write(address >> 8);  
17B92:  MOVFF  885,887
17B96:  MOVLB  8
17B98:  CLRF   x88
17B9A:  MOVF   FC9,W
17B9C:  MOVFF  885,FC9
17BA0:  RRCF   FC7,W
17BA2:  BNC   17BA0
....................       spi_write(address);  
17BA4:  MOVF   FC9,W
17BA6:  MOVFF  884,FC9
17BAA:  RRCF   FC7,W
17BAC:  BNC   17BAA
....................       spi_write(data);  
17BAE:  MOVF   FC9,W
17BB0:  MOVFF  886,FC9
17BB4:  RRCF   FC7,W
17BB6:  BNC   17BB4
....................       output_high(EEP_CS);  
17BB8:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
17BBA:  MOVLW  01
17BBC:  MOVWF  xCA
17BBE:  MOVLB  0
17BC0:  CALL   5504
17BC4:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
102F0:  MOVLB  8
102F2:  CLRF   xCA
102F4:  MOVLB  0
102F6:  CALL   5504
....................     
....................       while(!ext_eeprom_ready()); 
102FA:  RCALL  102C8
102FC:  MOVF   01,F
102FE:  BZ    102FA
....................        
....................       output_low(EEP_CS);  
10300:  BCF    F91.2
....................       spi_write(0x03);  
10302:  MOVF   FC9,W
10304:  MOVLW  03
10306:  MOVWF  FC9
10308:  RRCF   FC7,W
1030A:  BNC   10308
....................       spi_write(address >> 8);  
1030C:  MOVFF  8A9,8AB
10310:  MOVLB  8
10312:  CLRF   xAC
10314:  MOVF   FC9,W
10316:  MOVFF  8A9,FC9
1031A:  RRCF   FC7,W
1031C:  BNC   1031A
....................       spi_write(address);  
1031E:  MOVF   FC9,W
10320:  MOVFF  8A8,FC9
10324:  RRCF   FC7,W
10326:  BNC   10324
....................        
....................       data = spi_read(0);  
10328:  MOVF   FC9,W
1032A:  CLRF   FC9
1032C:  RRCF   FC7,W
1032E:  BNC   1032C
10330:  MOVFF  FC9,8AA
....................       output_high(EEP_CS);  
10334:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
10336:  MOVLW  01
10338:  MOVWF  xCA
1033A:  MOVLB  0
1033C:  CALL   5504
....................     
....................    return(data);  
10340:  MOVLB  8
10342:  MOVFF  8AA,01
10346:  MOVLB  0
10348:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
0339A:  MOVF   FF2,W
0339C:  MOVWF  00
0339E:  BCF    FF2.7
033A0:  CLRF   F63
033A2:  MOVFF  866,F62
033A6:  MOVFF  867,F61
033AA:  BCF    F7F.6
033AC:  BCF    F7F.7
033AE:  BSF    F7F.2
033B0:  MOVLB  F
033B2:  MOVLW  55
033B4:  MOVWF  F7E
033B6:  MOVLW  AA
033B8:  MOVWF  F7E
033BA:  BSF    F7F.1
033BC:  BTFSC  F7F.1
033BE:  BRA    33BC
033C0:  BCF    F7F.2
033C2:  MOVF   00,W
033C4:  IORWF  FF2,F
033C6:  MOVLB  0
033C8:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
029AC:  MOVLB  8
029AE:  CLRF   x95
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
029B0:  MOVFF  FF2,896
029B4:  BCF    FF2.7
029B6:  CLRF   F63
029B8:  MOVFF  894,F62
029BC:  BCF    F7F.6
029BE:  BCF    F7F.7
029C0:  BSF    F7F.0
029C2:  MOVF   F61,W
029C4:  BTFSC  x96.7
029C6:  BSF    FF2.7
029C8:  MOVWF  x95
....................    return(data); 
029CA:  MOVFF  895,01
029CE:  MOVLB  0
029D0:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
04F56:  MOVLB  8
04F58:  CLRF   xCE
04F5A:  MOVF   xCE,W
04F5C:  SUBLW  01
04F5E:  BNC   4FB8
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
04F60:  MOVF   xCB,W
04F62:  ADDWF  xCE,W
04F64:  MOVWF  xCF
04F66:  MOVLW  08
04F68:  MOVWF  xD1
04F6A:  MOVLW  CC
04F6C:  MOVWF  xD0
04F6E:  MOVF   xCE,W
04F70:  ADDWF  xD0,W
04F72:  MOVWF  01
04F74:  MOVLW  00
04F76:  ADDWFC xD1,W
04F78:  MOVWF  03
04F7A:  MOVF   01,W
04F7C:  MOVWF  FE9
04F7E:  MOVFF  03,FEA
04F82:  MOVFF  FEF,8D0
04F86:  MOVF   FF2,W
04F88:  MOVWF  00
04F8A:  BCF    FF2.7
04F8C:  CLRF   F63
04F8E:  MOVFF  8CF,F62
04F92:  MOVFF  8D0,F61
04F96:  BCF    F7F.6
04F98:  BCF    F7F.7
04F9A:  BSF    F7F.2
04F9C:  MOVLB  F
04F9E:  MOVLW  55
04FA0:  MOVWF  F7E
04FA2:  MOVLW  AA
04FA4:  MOVWF  F7E
04FA6:  BSF    F7F.1
04FA8:  BTFSC  F7F.1
04FAA:  BRA    4FA8
04FAC:  BCF    F7F.2
04FAE:  MOVF   00,W
04FB0:  IORWF  FF2,F
04FB2:  MOVLB  8
04FB4:  INCF   xCE,F
04FB6:  BRA    4F5A
....................     }  
04FB8:  MOVLB  0
04FBA:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
02952:  MOVLB  8
02954:  CLRF   x77
02956:  CLRF   x76
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
02958:  CLRF   x75
0295A:  MOVF   x75,W
0295C:  SUBLW  01
0295E:  BNC   29A0
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02960:  MOVLW  08
02962:  MOVWF  x79
02964:  MOVLW  76
02966:  MOVWF  x78
02968:  MOVF   x75,W
0296A:  ADDWF  x78,W
0296C:  MOVWF  01
0296E:  MOVLW  00
02970:  ADDWFC x79,W
02972:  MOVWF  03
02974:  MOVF   01,W
02976:  MOVWF  FE9
02978:  MOVFF  03,FEA
0297C:  MOVF   x74,W
0297E:  ADDWF  x75,W
02980:  MOVWF  x7A
02982:  MOVFF  FF2,87B
02986:  BCF    FF2.7
02988:  CLRF   F63
0298A:  MOVFF  87A,F62
0298E:  BCF    F7F.6
02990:  BCF    F7F.7
02992:  BSF    F7F.0
02994:  MOVF   F61,W
02996:  BTFSC  x7B.7
02998:  BSF    FF2.7
0299A:  MOVWF  FEF
0299C:  INCF   x75,F
0299E:  BRA    295A
....................    } 
....................  
....................    return(data);  
029A0:  MOVFF  876,01
029A4:  MOVFF  877,02
029A8:  MOVLB  0
029AA:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0CA54:  MOVLB  8
0CA56:  CLRF   x68
0CA58:  MOVF   x68,W
0CA5A:  SUBLW  03
0CA5C:  BNC   CABE
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0CA5E:  MOVF   x68,W
0CA60:  ADDWF  x62,W
0CA62:  MOVWF  x69
0CA64:  MOVLW  00
0CA66:  ADDWFC x63,W
0CA68:  MOVWF  x6A
0CA6A:  MOVLW  08
0CA6C:  MOVWF  x6C
0CA6E:  MOVLW  64
0CA70:  MOVWF  x6B
0CA72:  MOVF   x68,W
0CA74:  ADDWF  x6B,W
0CA76:  MOVWF  01
0CA78:  MOVLW  00
0CA7A:  ADDWFC x6C,W
0CA7C:  MOVWF  03
0CA7E:  MOVF   01,W
0CA80:  MOVWF  FE9
0CA82:  MOVFF  03,FEA
0CA86:  MOVFF  FEF,86B
0CA8A:  MOVF   FF2,W
0CA8C:  MOVWF  00
0CA8E:  BCF    FF2.7
0CA90:  MOVFF  86A,F63
0CA94:  MOVFF  869,F62
0CA98:  MOVFF  86B,F61
0CA9C:  BCF    F7F.6
0CA9E:  BCF    F7F.7
0CAA0:  BSF    F7F.2
0CAA2:  MOVLB  F
0CAA4:  MOVLW  55
0CAA6:  MOVWF  F7E
0CAA8:  MOVLW  AA
0CAAA:  MOVWF  F7E
0CAAC:  BSF    F7F.1
0CAAE:  BTFSC  F7F.1
0CAB0:  BRA    CAAE
0CAB2:  BCF    F7F.2
0CAB4:  MOVF   00,W
0CAB6:  IORWF  FF2,F
0CAB8:  MOVLB  8
0CABA:  INCF   x68,F
0CABC:  BRA    CA58
....................    } 
0CABE:  MOVLB  0
0CAC0:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
029D2:  MOVLB  8
029D4:  CLRF   x68
029D6:  CLRF   x67
029D8:  CLRF   x66
029DA:  CLRF   x65
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
029DC:  CLRF   x64
029DE:  MOVF   x64,W
029E0:  SUBLW  03
029E2:  BNC   2A2C
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
029E4:  MOVLW  08
029E6:  MOVWF  x6A
029E8:  MOVLW  65
029EA:  MOVWF  x69
029EC:  MOVF   x64,W
029EE:  ADDWF  x69,W
029F0:  MOVWF  01
029F2:  MOVLW  00
029F4:  ADDWFC x6A,W
029F6:  MOVWF  03
029F8:  MOVF   01,W
029FA:  MOVWF  FE9
029FC:  MOVFF  03,FEA
02A00:  MOVF   x64,W
02A02:  ADDWF  x62,W
02A04:  MOVWF  x6B
02A06:  MOVLW  00
02A08:  ADDWFC x63,W
02A0A:  MOVWF  x6C
02A0C:  MOVFF  FF2,86D
02A10:  BCF    FF2.7
02A12:  MOVFF  86C,F63
02A16:  MOVFF  86B,F62
02A1A:  BCF    F7F.6
02A1C:  BCF    F7F.7
02A1E:  BSF    F7F.0
02A20:  MOVF   F61,W
02A22:  BTFSC  x6D.7
02A24:  BSF    FF2.7
02A26:  MOVWF  FEF
02A28:  INCF   x64,F
02A2A:  BRA    29DE
....................    } 
....................  
....................    return(data);  
02A2C:  MOVFF  865,00
02A30:  MOVFF  866,01
02A34:  MOVFF  867,02
02A38:  MOVFF  868,03
02A3C:  MOVLB  0
02A3E:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
17DA6:  MOVLB  8
17DA8:  CLRF   x80
17DAA:  MOVF   x80,W
17DAC:  SUBLW  01
17DAE:  BNC   17DEC
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
17DB0:  MOVF   x80,W
17DB2:  ADDWF  x7C,W
17DB4:  MOVWF  x81
17DB6:  MOVLW  00
17DB8:  ADDWFC x7D,W
17DBA:  MOVWF  x82
17DBC:  MOVLW  08
17DBE:  MOVWF  x84
17DC0:  MOVLW  7E
17DC2:  MOVWF  x83
17DC4:  MOVF   x80,W
17DC6:  ADDWF  x83,W
17DC8:  MOVWF  01
17DCA:  MOVLW  00
17DCC:  ADDWFC x84,W
17DCE:  MOVWF  03
17DD0:  MOVFF  01,FE9
17DD4:  MOVWF  FEA
17DD6:  MOVFF  FEF,886
17DDA:  MOVFF  882,885
17DDE:  MOVFF  881,884
17DE2:  MOVLB  0
17DE4:  RCALL  17B66
17DE6:  MOVLB  8
17DE8:  INCF   x80,F
17DEA:  BRA    17DAA
....................     }  
17DEC:  MOVLB  0
17DEE:  GOTO   17E5E (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
10404:  MOVLB  8
10406:  CLRF   xA3
10408:  CLRF   xA2
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
1040A:  CLRF   xA1
1040C:  MOVF   xA1,W
1040E:  SUBLW  01
10410:  BNC   10454
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
10412:  MOVLW  08
10414:  MOVWF  xA5
10416:  MOVLW  A2
10418:  MOVWF  xA4
1041A:  MOVF   xA1,W
1041C:  ADDWF  xA4,W
1041E:  MOVWF  01
10420:  MOVLW  00
10422:  ADDWFC xA5,W
10424:  MOVWF  03
10426:  MOVFF  01,8A4
1042A:  MOVWF  xA5
1042C:  MOVF   xA1,W
1042E:  ADDWF  x9F,W
10430:  MOVWF  xA6
10432:  MOVLW  00
10434:  ADDWFC xA0,W
10436:  MOVWF  xA7
10438:  MOVWF  xA9
1043A:  MOVFF  8A6,8A8
1043E:  MOVLB  0
10440:  RCALL  102F0
10442:  MOVFF  8A5,FEA
10446:  MOVFF  8A4,FE9
1044A:  MOVFF  01,FEF
1044E:  MOVLB  8
10450:  INCF   xA1,F
10452:  BRA    1040C
....................    } 
....................    return(data);  
10454:  MOVFF  8A2,01
10458:  MOVFF  8A3,02
1045C:  MOVLB  0
1045E:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
15836:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
15838:  MOVF   2F,W
1583A:  SUBLW  02
1583C:  BNZ   15844
1583E:  MOVF   30,F
15840:  BNZ   15844
15842:  BSF    F90.6
....................    delay_ms(32); 
15844:  MOVLW  20
15846:  MOVLB  9
15848:  MOVWF  xC9
1584A:  MOVLB  0
1584C:  CALL   2898
....................    output_bit(BOARD_LED, OFF); 
15850:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
15852:  MOVF   2F,W
15854:  SUBLW  02
15856:  BNZ   1585E
15858:  MOVF   30,F
1585A:  BNZ   1585E
1585C:  BCF    F90.6
....................    delay_ms(32); 
1585E:  MOVLW  20
15860:  MOVLB  9
15862:  MOVWF  xC9
15864:  MOVLB  0
15866:  CALL   2898
1586A:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
030D0:  MOVF   2F,W
030D2:  MOVWF  00
030D4:  MOVF   30,W
030D6:  MOVWF  03
030D8:  BNZ   30DE
030DA:  MOVF   00,F
030DC:  BZ    3100
030DE:  MOVF   03,W
030E0:  BNZ   30E8
030E2:  MOVLW  01
030E4:  SUBWF  00,W
030E6:  BZ    3152
030E8:  MOVF   03,W
030EA:  BNZ   30F2
030EC:  MOVLW  02
030EE:  SUBWF  00,W
030F0:  BZ    31A4
030F2:  MOVF   03,W
030F4:  BNZ   30FE
030F6:  MOVLW  03
030F8:  SUBWF  00,W
030FA:  BTFSC  FD8.2
030FC:  BRA    31F6
030FE:  BRA    3248
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
03100:  MOVLW  BE
03102:  MOVWF  FF6
03104:  MOVLW  05
03106:  MOVWF  FF7
03108:  MOVLW  00
0310A:  MOVWF  FF8
0310C:  CLRF   1B
0310E:  BTFSC  FF2.7
03110:  BSF    1B.7
03112:  BCF    FF2.7
03114:  MOVLW  06
03116:  MOVLB  A
03118:  MOVWF  x18
0311A:  MOVLB  0
0311C:  CALL   1010
03120:  BTFSC  1B.7
03122:  BSF    FF2.7
03124:  MOVLW  CA
03126:  MOVWF  FF6
03128:  MOVLW  05
0312A:  MOVWF  FF7
0312C:  MOVLW  00
0312E:  MOVWF  FF8
03130:  CLRF   1B
03132:  BTFSC  FF2.7
03134:  BSF    1B.7
03136:  BCF    FF2.7
03138:  CALL   0E3A
0313C:  BTFSC  1B.7
0313E:  BSF    FF2.7
03140:  MOVLW  0D
03142:  BTFSS  F9E.4
03144:  BRA    3142
03146:  MOVWF  FAD
03148:  MOVLW  0A
0314A:  BTFSS  F9E.4
0314C:  BRA    314A
0314E:  MOVWF  FAD
....................          break; 
03150:  BRA    3298
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
03152:  MOVLW  D2
03154:  MOVWF  FF6
03156:  MOVLW  05
03158:  MOVWF  FF7
0315A:  MOVLW  00
0315C:  MOVWF  FF8
0315E:  CLRF   1B
03160:  BTFSC  FF2.7
03162:  BSF    1B.7
03164:  BCF    FF2.7
03166:  MOVLW  09
03168:  MOVLB  A
0316A:  MOVWF  x18
0316C:  MOVLB  0
0316E:  CALL   1010
03172:  BTFSC  1B.7
03174:  BSF    FF2.7
03176:  MOVLW  E0
03178:  MOVWF  FF6
0317A:  MOVLW  05
0317C:  MOVWF  FF7
0317E:  MOVLW  00
03180:  MOVWF  FF8
03182:  CLRF   1B
03184:  BTFSC  FF2.7
03186:  BSF    1B.7
03188:  BCF    FF2.7
0318A:  CALL   0E3A
0318E:  BTFSC  1B.7
03190:  BSF    FF2.7
03192:  MOVLW  0D
03194:  BTFSS  F9E.4
03196:  BRA    3194
03198:  MOVWF  FAD
0319A:  MOVLW  0A
0319C:  BTFSS  F9E.4
0319E:  BRA    319C
031A0:  MOVWF  FAD
....................          break;  
031A2:  BRA    3298
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
031A4:  MOVLW  E8
031A6:  MOVWF  FF6
031A8:  MOVLW  05
031AA:  MOVWF  FF7
031AC:  MOVLW  00
031AE:  MOVWF  FF8
031B0:  CLRF   1B
031B2:  BTFSC  FF2.7
031B4:  BSF    1B.7
031B6:  BCF    FF2.7
031B8:  MOVLW  06
031BA:  MOVLB  A
031BC:  MOVWF  x18
031BE:  MOVLB  0
031C0:  CALL   1010
031C4:  BTFSC  1B.7
031C6:  BSF    FF2.7
031C8:  MOVLW  F4
031CA:  MOVWF  FF6
031CC:  MOVLW  05
031CE:  MOVWF  FF7
031D0:  MOVLW  00
031D2:  MOVWF  FF8
031D4:  CLRF   1B
031D6:  BTFSC  FF2.7
031D8:  BSF    1B.7
031DA:  BCF    FF2.7
031DC:  CALL   0E3A
031E0:  BTFSC  1B.7
031E2:  BSF    FF2.7
031E4:  MOVLW  0D
031E6:  BTFSS  F9E.4
031E8:  BRA    31E6
031EA:  MOVWF  FAD
031EC:  MOVLW  0A
031EE:  BTFSS  F9E.4
031F0:  BRA    31EE
031F2:  MOVWF  FAD
....................          break; 
031F4:  BRA    3298
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
031F6:  MOVLW  FC
031F8:  MOVWF  FF6
031FA:  MOVLW  05
031FC:  MOVWF  FF7
031FE:  MOVLW  00
03200:  MOVWF  FF8
03202:  CLRF   1B
03204:  BTFSC  FF2.7
03206:  BSF    1B.7
03208:  BCF    FF2.7
0320A:  MOVLW  09
0320C:  MOVLB  A
0320E:  MOVWF  x18
03210:  MOVLB  0
03212:  CALL   1010
03216:  BTFSC  1B.7
03218:  BSF    FF2.7
0321A:  MOVLW  0A
0321C:  MOVWF  FF6
0321E:  MOVLW  06
03220:  MOVWF  FF7
03222:  MOVLW  00
03224:  MOVWF  FF8
03226:  CLRF   1B
03228:  BTFSC  FF2.7
0322A:  BSF    1B.7
0322C:  BCF    FF2.7
0322E:  CALL   0E3A
03232:  BTFSC  1B.7
03234:  BSF    FF2.7
03236:  MOVLW  0D
03238:  BTFSS  F9E.4
0323A:  BRA    3238
0323C:  MOVWF  FAD
0323E:  MOVLW  0A
03240:  BTFSS  F9E.4
03242:  BRA    3240
03244:  MOVWF  FAD
....................          break;           
03246:  BRA    3298
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
03248:  MOVLW  12
0324A:  MOVWF  FF6
0324C:  MOVLW  06
0324E:  MOVWF  FF7
03250:  MOVLW  00
03252:  MOVWF  FF8
03254:  CLRF   1B
03256:  BTFSC  FF2.7
03258:  BSF    1B.7
0325A:  BCF    FF2.7
0325C:  MOVLW  06
0325E:  MOVLB  A
03260:  MOVWF  x18
03262:  MOVLB  0
03264:  CALL   1010
03268:  BTFSC  1B.7
0326A:  BSF    FF2.7
0326C:  MOVLW  1E
0326E:  MOVWF  FF6
03270:  MOVLW  06
03272:  MOVWF  FF7
03274:  MOVLW  00
03276:  MOVWF  FF8
03278:  CLRF   1B
0327A:  BTFSC  FF2.7
0327C:  BSF    1B.7
0327E:  BCF    FF2.7
03280:  CALL   0E3A
03284:  BTFSC  1B.7
03286:  BSF    FF2.7
03288:  MOVLW  0D
0328A:  BTFSS  F9E.4
0328C:  BRA    328A
0328E:  MOVWF  FAD
03290:  MOVLW  0A
03292:  BTFSS  F9E.4
03294:  BRA    3292
03296:  MOVWF  FAD
....................          break; 
....................    } 
03298:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
1725C:  MOVLW  26
1725E:  MOVWF  FF6
17260:  MOVLW  06
17262:  MOVWF  FF7
17264:  MOVLW  00
17266:  MOVWF  FF8
17268:  CLRF   1B
1726A:  BTFSC  FF2.7
1726C:  BSF    1B.7
1726E:  BCF    FF2.7
17270:  CALL   0E3A
17274:  BTFSC  1B.7
17276:  BSF    FF2.7
17278:  GOTO   17622 (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0AF70:  MOVLW  2E
0AF72:  MOVWF  FF6
0AF74:  MOVLW  06
0AF76:  MOVWF  FF7
0AF78:  MOVLW  00
0AF7A:  MOVWF  FF8
0AF7C:  CLRF   1B
0AF7E:  BTFSC  FF2.7
0AF80:  BSF    1B.7
0AF82:  BCF    FF2.7
0AF84:  CALL   0E3A
0AF88:  BTFSC  1B.7
0AF8A:  BSF    FF2.7
0AF8C:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BC32:  MOVLW  36
0BC34:  MOVWF  FF6
0BC36:  MOVLW  06
0BC38:  MOVWF  FF7
0BC3A:  MOVLW  00
0BC3C:  MOVWF  FF8
0BC3E:  CLRF   1B
0BC40:  BTFSC  FF2.7
0BC42:  BSF    1B.7
0BC44:  BCF    FF2.7
0BC46:  CALL   0E3A
0BC4A:  BTFSC  1B.7
0BC4C:  BSF    FF2.7
0BC4E:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
035DE:  MOVLW  4E
035E0:  MOVWF  FF6
035E2:  MOVLW  06
035E4:  MOVWF  FF7
035E6:  MOVLW  00
035E8:  MOVWF  FF8
035EA:  CLRF   1B
035EC:  BTFSC  FF2.7
035EE:  BSF    1B.7
035F0:  BCF    FF2.7
035F2:  CALL   0E3A
035F6:  BTFSC  1B.7
035F8:  BSF    FF2.7
035FA:  GOTO   4350 (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
05002:  MOVLW  56
05004:  MOVWF  FF6
05006:  MOVLW  06
05008:  MOVWF  FF7
0500A:  MOVLW  00
0500C:  MOVWF  FF8
0500E:  CLRF   1B
05010:  BTFSC  FF2.7
05012:  BSF    1B.7
05014:  BCF    FF2.7
05016:  CALL   0E3A
0501A:  BTFSC  1B.7
0501C:  BSF    FF2.7
0501E:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
15D5E:  MOVLW  5E
15D60:  MOVWF  FF6
15D62:  MOVLW  06
15D64:  MOVWF  FF7
15D66:  MOVLW  00
15D68:  MOVWF  FF8
15D6A:  CLRF   1B
15D6C:  BTFSC  FF2.7
15D6E:  BSF    1B.7
15D70:  BCF    FF2.7
15D72:  CALL   0E3A
15D76:  BTFSC  1B.7
15D78:  BSF    FF2.7
15D7A:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
*
0ADBC:  DECFSZ 4A,W
0ADBE:  BRA    ADDE
0ADC0:  MOVLW  66
0ADC2:  MOVWF  FF6
0ADC4:  MOVLW  06
0ADC6:  MOVWF  FF7
0ADC8:  MOVLW  00
0ADCA:  MOVWF  FF8
0ADCC:  CLRF   1B
0ADCE:  BTFSC  FF2.7
0ADD0:  BSF    1B.7
0ADD2:  BCF    FF2.7
0ADD4:  CALL   0E3A
0ADD8:  BTFSC  1B.7
0ADDA:  BSF    FF2.7
0ADDC:  BRA    ADFA
....................    else fprintf(COM_A, "@RDY\r\n"); 
0ADDE:  MOVLW  6E
0ADE0:  MOVWF  FF6
0ADE2:  MOVLW  06
0ADE4:  MOVWF  FF7
0ADE6:  MOVLW  00
0ADE8:  MOVWF  FF8
0ADEA:  CLRF   1B
0ADEC:  BTFSC  FF2.7
0ADEE:  BSF    1B.7
0ADF0:  BCF    FF2.7
0ADF2:  CALL   0E3A
0ADF6:  BTFSC  1B.7
0ADF8:  BSF    FF2.7
0ADFA:  GOTO   1AFAC (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
034C8:  MOVLW  0A
034CA:  MOVLB  A
034CC:  MOVWF  x0E
034CE:  MOVLW  05
034D0:  MOVFF  A0E,A0C
034D4:  MOVWF  x0B
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
034D6:  MOVF   FC9,W
034D8:  SETF   FC9
034DA:  RRCF   FC7,W
034DC:  BNC   34DA
....................    SD_spi_read(sdcmd); 
034DE:  MOVF   FC9,W
034E0:  MOVFF  A04,FC9
034E4:  RRCF   FC7,W
034E6:  BNC   34E4
....................    SD_spi_read(value[3]); 
034E8:  MOVLW  03
034EA:  ADDWF  x0B,W
034EC:  MOVWF  FE9
034EE:  MOVLW  00
034F0:  ADDWFC x0C,W
034F2:  MOVWF  FEA
034F4:  MOVFF  FEF,A0D
034F8:  MOVF   FC9,W
034FA:  MOVFF  A0D,FC9
034FE:  RRCF   FC7,W
03500:  BNC   34FE
....................    SD_spi_read(value[2]); 
03502:  MOVLW  02
03504:  ADDWF  x0B,W
03506:  MOVWF  FE9
03508:  MOVLW  00
0350A:  ADDWFC x0C,W
0350C:  MOVWF  FEA
0350E:  MOVFF  FEF,A0D
03512:  MOVF   FC9,W
03514:  MOVFF  A0D,FC9
03518:  RRCF   FC7,W
0351A:  BNC   3518
....................    SD_spi_read(value[1]); 
0351C:  MOVLW  01
0351E:  ADDWF  x0B,W
03520:  MOVWF  FE9
03522:  MOVLW  00
03524:  ADDWFC x0C,W
03526:  MOVWF  FEA
03528:  MOVFF  FEF,A0D
0352C:  MOVF   FC9,W
0352E:  MOVFF  A0D,FC9
03532:  RRCF   FC7,W
03534:  BNC   3532
....................    SD_spi_read(value[0]); 
03536:  MOVFF  A0B,FE9
0353A:  MOVFF  A0C,FEA
0353E:  MOVFF  FEF,A0D
03542:  MOVF   FC9,W
03544:  MOVFF  A0D,FC9
03548:  RRCF   FC7,W
0354A:  BNC   3548
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
0354C:  MOVF   x04,W
0354E:  SUBLW  48
03550:  BNZ   355E
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
03552:  MOVF   FC9,W
03554:  MOVLW  87
03556:  MOVWF  FC9
03558:  RRCF   FC7,W
0355A:  BNC   3558
0355C:  BRA    3568
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
0355E:  MOVF   FC9,W
03560:  MOVLW  95
03562:  MOVWF  FC9
03564:  RRCF   FC7,W
03566:  BNC   3564
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
03568:  CLRF   x09
....................    response = SD_spi_read(0xFF); 
0356A:  MOVF   FC9,W
0356C:  SETF   FC9
0356E:  RRCF   FC7,W
03570:  BNC   356E
03572:  MOVFF  FC9,A0A
....................    while ((response == 0xFF) && (i < 100)) 
03576:  INCFSZ x0A,W
03578:  BRA    3590
0357A:  MOVF   x09,W
0357C:  SUBLW  63
0357E:  BNC   3590
....................       { 
....................       i++; 
03580:  INCF   x09,F
....................       response = SD_spi_read(0xFF); 
03582:  MOVF   FC9,W
03584:  SETF   FC9
03586:  RRCF   FC7,W
03588:  BNC   3586
0358A:  MOVFF  FC9,A0A
0358E:  BRA    3576
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
03590:  MOVFF  A0A,01
03594:  MOVLB  0
03596:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
0435C:  MOVLW  50
0435E:  MOVLB  A
04360:  MOVWF  x04
04362:  MOVFF  A03,A08
04366:  MOVFF  A02,A07
0436A:  MOVFF  A01,A06
0436E:  MOVFF  A00,A05
04372:  MOVLB  0
04374:  CALL   34C8
04378:  MOVF   01,W
0437A:  BZ    4382
0437C:  XORLW  40
0437E:  BZ    4398
04380:  BRA    439E
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
04382:  MOVFF  A03,4E8
04386:  MOVFF  A02,4E7
0438A:  MOVFF  A01,4E6
0438E:  MOVFF  A00,4E5
....................          return(TRUE); 
04392:  MOVLW  01
04394:  MOVWF  01
04396:  BRA    43A2
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
04398:  MOVLW  00
0439A:  MOVWF  01
0439C:  BRA    43A2
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
0439E:  MOVLW  00
043A0:  MOVWF  01
....................       } 
043A2:  GOTO   4488 (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
043A6:  MOVF   FC9,W
043A8:  SETF   FC9
043AA:  RRCF   FC7,W
043AC:  BNC   43AA
043AE:  MOVFF  FC9,A08
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
043B2:  MOVLB  A
043B4:  CLRF   x07
043B6:  CLRF   x06
043B8:  MOVF   x07,W
043BA:  SUBLW  27
043BC:  BNC   43E6
043BE:  BNZ   43C6
043C0:  MOVF   x06,W
043C2:  SUBLW  0F
043C4:  BNC   43E6
043C6:  INCFSZ x08,W
043C8:  BRA    43E6
....................       { 
....................       delay_us(10); 
043CA:  MOVLW  35
043CC:  MOVWF  00
043CE:  DECFSZ 00,F
043D0:  BRA    43CE
....................       response = SD_spi_read(0xFF);  
043D2:  MOVF   FC9,W
043D4:  SETF   FC9
043D6:  RRCF   FC7,W
043D8:  BNC   43D6
043DA:  MOVFF  FC9,A08
043DE:  INCF   x06,F
043E0:  BTFSC  FD8.2
043E2:  INCF   x07,F
043E4:  BRA    43B8
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
043E6:  MOVF   x08,W
043E8:  SUBLW  FE
043EA:  BZ    43FA
....................       { 
....................       if (!response) 
043EC:  MOVF   x08,F
043EE:  BNZ   43F4
....................          response = 0xFE; 
043F0:  MOVLW  FE
043F2:  MOVWF  x08
....................       return(response); 
043F4:  MOVFF  A08,01
043F8:  BRA    4450
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
043FA:  CLRF   x07
043FC:  CLRF   x06
043FE:  MOVF   x05,F
04400:  BNZ   4414
04402:  MOVF   x04,F
04404:  BNZ   4414
04406:  MOVF   x07,W
04408:  SUBWF  x03,W
0440A:  BNC   4434
0440C:  BNZ   4414
0440E:  MOVF   x02,W
04410:  SUBWF  x06,W
04412:  BC    4434
....................       ptr[i]=SD_spi_read(0xFF); 
04414:  MOVF   x00,W
04416:  ADDWF  x06,W
04418:  MOVWF  FE9
0441A:  MOVF   x01,W
0441C:  ADDWFC x07,W
0441E:  MOVWF  FEA
04420:  MOVF   FC9,W
04422:  SETF   FC9
04424:  RRCF   FC7,W
04426:  BNC   4424
04428:  MOVFF  FC9,FEF
0442C:  INCF   x06,F
0442E:  BTFSC  FD8.2
04430:  INCF   x07,F
04432:  BRA    43FE
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
04434:  MOVF   FC9,W
04436:  SETF   FC9
04438:  RRCF   FC7,W
0443A:  BNC   4438
....................    SD_spi_read(0xFF); 
0443C:  MOVF   FC9,W
0443E:  SETF   FC9
04440:  RRCF   FC7,W
04442:  BNC   4440
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
04444:  MOVF   FC9,W
04446:  SETF   FC9
04448:  RRCF   FC7,W
0444A:  BNC   4448
....................    return(0); 
0444C:  MOVLW  00
0444E:  MOVWF  01
04450:  MOVLB  0
04452:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
057C4:  MOVLW  C3
057C6:  MOVLB  A
057C8:  MOVWF  x08
057CA:  MOVLW  50
057CC:  MOVWF  x07
....................    SD_spi_read(0xFF); 
057CE:  MOVF   FC9,W
057D0:  SETF   FC9
057D2:  RRCF   FC7,W
057D4:  BNC   57D2
....................    do 
....................       { 
....................       delay_us(10); 
057D6:  MOVLW  35
057D8:  MOVWF  00
057DA:  DECFSZ 00,F
057DC:  BRA    57DA
....................       response = SD_spi_read(0xFF); 
057DE:  MOVF   FC9,W
057E0:  SETF   FC9
057E2:  RRCF   FC7,W
057E4:  BNC   57E2
057E6:  MOVFF  FC9,A06
....................       Timer--; 
057EA:  MOVF   x07,W
057EC:  BTFSC  FD8.2
057EE:  DECF   x08,F
057F0:  DECF   x07,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
057F2:  INCFSZ x06,W
057F4:  BRA    57F8
057F6:  BRA    57FE
057F8:  MOVF   x07,W
057FA:  IORWF  x08,W
057FC:  BNZ   57D6
....................       ; 
....................  
....................    return (response); 
057FE:  MOVFF  A06,01
05802:  MOVLB  0
05804:  GOTO   5814 (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
05808:  MOVLW  02
0580A:  MOVLB  A
0580C:  MOVWF  x05
0580E:  CLRF   x04
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
05810:  MOVLB  0
05812:  BRA    57C4
05814:  INCFSZ 01,W
05816:  BRA    581A
05818:  BRA    5820
....................       return (FALSE); 
0581A:  MOVLW  00
0581C:  MOVWF  01
0581E:  BRA    58BA
....................  
....................    SD_spi_write(token);               // transmit data token 
05820:  MOVF   FC9,W
05822:  MOVFF  A02,FC9
05826:  RRCF   FC7,W
05828:  BNC   5826
....................    if (token != 0xFD) 
0582A:  MOVLB  A
0582C:  MOVF   x02,W
0582E:  SUBLW  FD
05830:  BZ    58B4
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
05832:  MOVFF  A05,03
05836:  MOVF   x04,W
05838:  BTFSC  FD8.2
0583A:  DECF   x05,F
0583C:  DECF   x04,F
0583E:  IORWF  03,W
05840:  BZ    5864
....................          SD_spi_write(*ptr++); 
05842:  MOVFF  A01,03
05846:  MOVF   x00,W
05848:  INCF   x00,F
0584A:  BTFSC  FD8.2
0584C:  INCF   x01,F
0584E:  MOVWF  FE9
05850:  MOVFF  03,FEA
05854:  MOVFF  FEF,A06
05858:  MOVF   FC9,W
0585A:  MOVFF  A06,FC9
0585E:  RRCF   FC7,W
05860:  BNC   585E
05862:  BRA    5832
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
05864:  MOVF   FC9,W
05866:  SETF   FC9
05868:  RRCF   FC7,W
0586A:  BNC   5868
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
0586C:  MOVF   FC9,W
0586E:  SETF   FC9
05870:  RRCF   FC7,W
05872:  BNC   5870
....................       response = SD_spi_read(0xFF);      // Receive data response 
05874:  MOVF   FC9,W
05876:  SETF   FC9
05878:  RRCF   FC7,W
0587A:  BNC   5878
0587C:  MOVFF  FC9,A03
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
05880:  CLRF   x05
05882:  CLRF   x04
05884:  MOVF   x05,W
05886:  SUBLW  C3
05888:  BNC   58B4
0588A:  BNZ   5892
0588C:  MOVF   x04,W
0588E:  SUBLW  4F
05890:  BNC   58B4
....................          { 
....................          delay_us(10); 
05892:  MOVLW  35
05894:  MOVWF  00
05896:  DECFSZ 00,F
05898:  BRA    5896
....................          response = SD_spi_read(0xFF);   // digest prior operation 
0589A:  MOVF   FC9,W
0589C:  SETF   FC9
0589E:  RRCF   FC7,W
058A0:  BNC   589E
058A2:  MOVFF  FC9,A03
....................          if (response != 0x00) 
058A6:  MOVF   x03,F
058A8:  BZ    58AC
....................             break; 
058AA:  BRA    58B4
058AC:  INCF   x04,F
058AE:  BTFSC  FD8.2
058B0:  INCF   x05,F
058B2:  BRA    5884
....................          } 
....................  
....................       } 
....................    return(TRUE); 
058B4:  MOVLW  01
058B6:  MOVWF  01
058B8:  MOVLB  0
058BA:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
058BC:  MOVLB  4
058BE:  BTFSS  xE9.0
058C0:  BRA    58C8
....................       return (RES_NOTRDY); 
058C2:  MOVLW  03
058C4:  MOVWF  01
058C6:  BRA    59FE
....................  
....................    if (Media_Status & STA_PROTECT) 
058C8:  BTFSS  xE9.2
058CA:  BRA    58D2
....................       return (RES_WRPRT); 
058CC:  MOVLW  02
058CE:  MOVWF  01
058D0:  BRA    59FE
....................  
....................    if (!SectorCount) 
058D2:  MOVLB  9
058D4:  MOVF   xFF,F
058D6:  BNZ   58E2
....................       return (RES_PARERR); 
058D8:  MOVLW  04
058DA:  MOVWF  01
058DC:  MOVLB  4
058DE:  BRA    59FE
058E0:  MOVLB  9
....................  
....................    SelectSD; 
058E2:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
058E4:  MOVLB  4
058E6:  MOVF   xE3,W
058E8:  SUBLW  05
058EA:  BZ    5906
....................       SectorNumber *= 512; 
058EC:  BCF    FD8.0
058EE:  MOVFF  9FD,9FE
058F2:  MOVFF  9FC,9FD
058F6:  MOVFF  9FB,9FC
058FA:  MOVLB  9
058FC:  CLRF   xFB
058FE:  RLCF   xFC,F
05900:  RLCF   xFD,F
05902:  RLCF   xFE,F
05904:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
05906:  MOVLB  9
05908:  DECFSZ xFF,W
0590A:  BRA    594C
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
0590C:  MOVLW  58
0590E:  MOVLB  A
05910:  MOVWF  x04
05912:  MOVFF  9FE,A08
05916:  MOVFF  9FD,A07
0591A:  MOVFF  9FC,A06
0591E:  MOVFF  9FB,A05
05922:  MOVLB  0
05924:  CALL   34C8
05928:  MOVF   01,F
0592A:  BNZ   5948
....................          if (SD_write_data(Buffer, 0xFE)) 
0592C:  MOVFF  9FA,A01
05930:  MOVFF  9F9,A00
05934:  MOVLW  FE
05936:  MOVLB  A
05938:  MOVWF  x02
0593A:  MOVLB  0
0593C:  RCALL  5808
0593E:  MOVF   01,F
05940:  BZ    5948
....................             SectorCount = 0; 
05942:  MOVLB  9
05944:  CLRF   xFF
05946:  MOVLB  0
....................       } 
05948:  BRA    59E4
0594A:  MOVLB  9
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
0594C:  MOVLB  4
0594E:  MOVF   xE3,W
05950:  ANDLW  03
05952:  BZ    5980
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
05954:  MOVLW  77
05956:  MOVLB  A
05958:  MOVWF  x04
0595A:  CLRF   x08
0595C:  CLRF   x07
0595E:  CLRF   x06
05960:  CLRF   x05
05962:  MOVLB  0
05964:  CALL   34C8
....................          SD_cmd(SD_ACMD23, SectorCount); 
05968:  MOVLW  57
0596A:  MOVLB  A
0596C:  MOVWF  x04
0596E:  CLRF   x08
05970:  CLRF   x07
05972:  CLRF   x06
05974:  MOVFF  9FF,A05
05978:  MOVLB  0
0597A:  CALL   34C8
0597E:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
05980:  MOVLW  59
05982:  MOVLB  A
05984:  MOVWF  x04
05986:  MOVFF  9FE,A08
0598A:  MOVFF  9FD,A07
0598E:  MOVFF  9FC,A06
05992:  MOVFF  9FB,A05
05996:  MOVLB  0
05998:  CALL   34C8
0599C:  MOVF   01,F
0599E:  BNZ   59E4
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
059A0:  MOVFF  9FA,A01
059A4:  MOVFF  9F9,A00
059A8:  MOVLW  FC
059AA:  MOVLB  A
059AC:  MOVWF  x02
059AE:  MOVLB  0
059B0:  RCALL  5808
059B2:  MOVF   01,F
059B4:  BNZ   59B8
....................                break; 
059B6:  BRA    59CA
....................             Buffer += 512; 
059B8:  MOVLW  02
059BA:  MOVLB  9
059BC:  ADDWF  xFA,F
....................             } while (--SectorCount); 
059BE:  DECF   xFF,F
059C0:  BTFSC  FD8.2
059C2:  BRA    59C8
059C4:  MOVLB  0
059C6:  BRA    59A0
059C8:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
059CA:  MOVLB  A
059CC:  CLRF   x01
059CE:  CLRF   x00
059D0:  MOVLW  FD
059D2:  MOVWF  x02
059D4:  MOVLB  0
059D6:  RCALL  5808
059D8:  MOVF   01,F
059DA:  BNZ   59E4
....................             SectorCount = 1; 
059DC:  MOVLW  01
059DE:  MOVLB  9
059E0:  MOVWF  xFF
059E2:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
059E4:  BSF    F91.1
....................    SD_spi_read(0xFF); 
059E6:  MOVF   FC9,W
059E8:  SETF   FC9
059EA:  RRCF   FC7,W
059EC:  BNC   59EA
....................    return SectorCount ? RES_ERROR : RES_OK; 
059EE:  MOVLB  9
059F0:  MOVF   xFF,F
059F2:  BZ    59F8
059F4:  MOVLW  01
059F6:  BRA    59FA
059F8:  MOVLW  00
059FA:  MOVWF  01
059FC:  MOVLB  4
059FE:  MOVLB  0
05A00:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
04454:  MOVLB  4
04456:  BTFSS  xE9.0
04458:  BRA    4460
....................       return (RES_NOTRDY); 
0445A:  MOVLW  03
0445C:  MOVWF  01
0445E:  BRA    4598
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
04460:  MOVLB  9
04462:  MOVF   xFF,W
04464:  SUBLW  01
04466:  BNC   446C
04468:  MOVF   xFF,F
0446A:  BNZ   4476
....................       return(RES_PARERR); 
0446C:  MOVLW  04
0446E:  MOVWF  01
04470:  MOVLB  4
04472:  BRA    4598
04474:  MOVLB  9
....................  
....................    SelectSD; 
04476:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
04478:  MOVLB  A
0447A:  CLRF   x03
0447C:  CLRF   x02
0447E:  MOVLW  02
04480:  MOVWF  x01
04482:  CLRF   x00
04484:  MOVLB  0
04486:  BRA    435C
04488:  MOVF   01,F
0448A:  BNZ   4498
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
0448C:  BSF    F91.1
....................       return(RES_ERROR); 
0448E:  MOVLW  01
04490:  MOVWF  01
04492:  MOVLB  4
04494:  BRA    4598
04496:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
04498:  MOVLB  4
0449A:  MOVF   xE3,W
0449C:  SUBLW  05
0449E:  BZ    44BA
....................       SectorNumber *= 512; 
044A0:  BCF    FD8.0
044A2:  MOVFF  9FD,9FE
044A6:  MOVFF  9FC,9FD
044AA:  MOVFF  9FB,9FC
044AE:  MOVLB  9
044B0:  CLRF   xFB
044B2:  RLCF   xFC,F
044B4:  RLCF   xFD,F
044B6:  RLCF   xFE,F
044B8:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
044BA:  MOVLB  9
044BC:  DECFSZ xFF,W
044BE:  BRA    4518
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
044C0:  MOVLW  51
044C2:  MOVLB  A
044C4:  MOVWF  x04
044C6:  MOVFF  9FE,A08
044CA:  MOVFF  9FD,A07
044CE:  MOVFF  9FC,A06
044D2:  MOVFF  9FB,A05
044D6:  MOVLB  0
044D8:  CALL   34C8
044DC:  MOVF   01,F
044DE:  BZ    44EC
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
044E0:  BSF    F91.1
....................          return(RES_PARERR); 
044E2:  MOVLW  04
044E4:  MOVWF  01
044E6:  MOVLB  4
044E8:  BRA    4598
044EA:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
044EC:  MOVFF  9FA,A01
044F0:  MOVFF  9F9,A00
044F4:  MOVLB  A
044F6:  CLRF   x05
044F8:  CLRF   x04
044FA:  MOVLW  02
044FC:  MOVWF  x03
044FE:  CLRF   x02
04500:  MOVLB  0
04502:  RCALL  43A6
04504:  MOVF   01,F
04506:  BZ    4514
....................          { 
....................          DeselectSD; 
04508:  BSF    F91.1
....................          return(RES_ERROR); 
0450A:  MOVLW  01
0450C:  MOVWF  01
0450E:  MOVLB  4
04510:  BRA    4598
04512:  MOVLB  0
....................          } 
....................       } 
04514:  BRA    4590
04516:  MOVLB  9
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
04518:  MOVLW  52
0451A:  MOVLB  A
0451C:  MOVWF  x04
0451E:  MOVFF  9FE,A08
04522:  MOVFF  9FD,A07
04526:  MOVFF  9FC,A06
0452A:  MOVFF  9FB,A05
0452E:  MOVLB  0
04530:  CALL   34C8
04534:  MOVF   01,F
04536:  BZ    4544
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
04538:  BSF    F91.1
....................          return(RES_PARERR); 
0453A:  MOVLW  04
0453C:  MOVWF  01
0453E:  MOVLB  4
04540:  BRA    4598
04542:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
04544:  MOVFF  9FA,A01
04548:  MOVFF  9F9,A00
0454C:  MOVLB  A
0454E:  CLRF   x05
04550:  CLRF   x04
04552:  MOVLW  02
04554:  MOVWF  x03
04556:  CLRF   x02
04558:  MOVLB  0
0455A:  RCALL  43A6
0455C:  MOVF   01,F
0455E:  BZ    456C
....................             { 
....................             DeselectSD; 
04560:  BSF    F91.1
....................             return(RES_ERROR); 
04562:  MOVLW  01
04564:  MOVWF  01
04566:  MOVLB  4
04568:  BRA    4598
0456A:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
0456C:  MOVLW  02
0456E:  MOVLB  9
04570:  ADDWF  xFA,F
....................          } while (--SectorCount); 
04572:  DECF   xFF,F
04574:  BTFSC  FD8.2
04576:  BRA    457C
04578:  MOVLB  0
0457A:  BRA    4544
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
0457C:  MOVLW  4C
0457E:  MOVLB  A
04580:  MOVWF  x04
04582:  CLRF   x08
04584:  CLRF   x07
04586:  CLRF   x06
04588:  CLRF   x05
0458A:  MOVLB  0
0458C:  CALL   34C8
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
04590:  BSF    F91.1
....................    return(RES_OK); 
04592:  MOVLW  00
04594:  MOVWF  01
04596:  MOVLB  4
04598:  MOVLB  0
0459A:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
0551C:  MOVLB  4
0551E:  BCF    xE9.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
05520:  BCF    xE9.2
....................  
....................    return(Media_Status); 
05522:  MOVFF  4E9,01
05526:  MOVLB  0
05528:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
035FE:  MOVLB  9
03600:  CLRF   xC8
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
03602:  MOVLB  4
03604:  CLRF   xE3
....................  
....................    DeselectSD; 
03606:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
03608:  MOVLW  0A
0360A:  MOVLB  9
0360C:  MOVWF  xC9
0360E:  MOVLB  0
03610:  CALL   2898
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
03614:  BCF    FC6.5
03616:  MOVLW  22
03618:  MOVWF  FC6
0361A:  MOVLW  40
0361C:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
0361E:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
03620:  MOVLB  9
03622:  CLRF   xC0
03624:  MOVF   xC0,W
03626:  SUBLW  09
03628:  BNC   3636
....................       SD_spi_read(0xFF); 
0362A:  MOVF   FC9,W
0362C:  SETF   FC9
0362E:  RRCF   FC7,W
03630:  BNC   362E
03632:  INCF   xC0,F
03634:  BRA    3624
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
03636:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
03638:  MOVF   1F,W
0363A:  SUBLW  04
0363C:  BNZ   3662
0363E:  MOVF   20,F
03640:  BNZ   3662
03642:  MOVLW  76
03644:  MOVWF  FF6
03646:  MOVLW  06
03648:  MOVWF  FF7
0364A:  MOVLW  00
0364C:  MOVWF  FF8
0364E:  CLRF   1B
03650:  BTFSC  FF2.7
03652:  BSF    1B.7
03654:  BCF    FF2.7
03656:  MOVLB  0
03658:  CALL   0E3A
0365C:  BTFSC  1B.7
0365E:  BSF    FF2.7
03660:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
03662:  MOVLW  40
03664:  MOVLB  A
03666:  MOVWF  x04
03668:  CLRF   x08
0366A:  CLRF   x07
0366C:  CLRF   x06
0366E:  CLRF   x05
03670:  MOVLB  0
03672:  RCALL  34C8
03674:  MOVFF  01,9C1
....................    if (response > 1 ) 
03678:  MOVLB  9
0367A:  MOVF   xC1,W
0367C:  SUBLW  01
0367E:  BC    36D4
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
03680:  MOVF   1F,W
03682:  SUBLW  04
03684:  BNZ   36CE
03686:  MOVF   20,F
03688:  BNZ   36CE
0368A:  MOVLW  86
0368C:  MOVWF  FF6
0368E:  MOVLW  06
03690:  MOVWF  FF7
03692:  MOVLW  00
03694:  MOVWF  FF8
03696:  CLRF   1B
03698:  BTFSC  FF2.7
0369A:  BSF    1B.7
0369C:  BCF    FF2.7
0369E:  MOVLW  31
036A0:  MOVLB  A
036A2:  MOVWF  x18
036A4:  MOVLB  0
036A6:  CALL   1010
036AA:  BTFSC  1B.7
036AC:  BSF    FF2.7
036AE:  MOVFF  9C1,9C9
036B2:  MOVLW  57
036B4:  MOVLB  9
036B6:  MOVWF  xCA
036B8:  MOVLB  0
036BA:  RCALL  3598
036BC:  MOVLW  0D
036BE:  BTFSS  F9E.4
036C0:  BRA    36BE
036C2:  MOVWF  FAD
036C4:  MOVLW  0A
036C6:  BTFSS  F9E.4
036C8:  BRA    36C6
036CA:  MOVWF  FAD
036CC:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
036CE:  BSF    xC8.0
....................       goto Exit_disk_initialize; 
036D0:  GOTO   4352
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
036D4:  MOVF   1F,W
036D6:  SUBLW  04
036D8:  BNZ   3722
036DA:  MOVF   20,F
036DC:  BNZ   3722
036DE:  MOVLW  BE
036E0:  MOVWF  FF6
036E2:  MOVLW  06
036E4:  MOVWF  FF7
036E6:  MOVLW  00
036E8:  MOVWF  FF8
036EA:  CLRF   1B
036EC:  BTFSC  FF2.7
036EE:  BSF    1B.7
036F0:  BCF    FF2.7
036F2:  MOVLW  1A
036F4:  MOVLB  A
036F6:  MOVWF  x18
036F8:  MOVLB  0
036FA:  CALL   1010
036FE:  BTFSC  1B.7
03700:  BSF    FF2.7
03702:  MOVFF  9C1,9C9
03706:  MOVLW  57
03708:  MOVLB  9
0370A:  MOVWF  xCA
0370C:  MOVLB  0
0370E:  RCALL  3598
03710:  MOVLW  0D
03712:  BTFSS  F9E.4
03714:  BRA    3712
03716:  MOVWF  FAD
03718:  MOVLW  0A
0371A:  BTFSS  F9E.4
0371C:  BRA    371A
0371E:  MOVWF  FAD
03720:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
03722:  MOVLW  48
03724:  MOVLB  A
03726:  MOVWF  x04
03728:  CLRF   x08
0372A:  CLRF   x07
0372C:  MOVLW  01
0372E:  MOVWF  x06
03730:  MOVLW  AA
03732:  MOVWF  x05
03734:  MOVLB  0
03736:  RCALL  34C8
03738:  MOVFF  01,9C1
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
0373C:  MOVF   1F,W
0373E:  SUBLW  04
03740:  BNZ   3788
03742:  MOVF   20,F
03744:  BNZ   3788
03746:  MOVLW  E0
03748:  MOVWF  FF6
0374A:  MOVLW  06
0374C:  MOVWF  FF7
0374E:  MOVLW  00
03750:  MOVWF  FF8
03752:  CLRF   1B
03754:  BTFSC  FF2.7
03756:  BSF    1B.7
03758:  BCF    FF2.7
0375A:  MOVLW  25
0375C:  MOVLB  A
0375E:  MOVWF  x18
03760:  MOVLB  0
03762:  CALL   1010
03766:  BTFSC  1B.7
03768:  BSF    FF2.7
0376A:  MOVFF  9C1,9C9
0376E:  MOVLW  57
03770:  MOVLB  9
03772:  MOVWF  xCA
03774:  MOVLB  0
03776:  RCALL  3598
03778:  MOVLW  0D
0377A:  BTFSS  F9E.4
0377C:  BRA    377A
0377E:  MOVWF  FAD
03780:  MOVLW  0A
03782:  BTFSS  F9E.4
03784:  BRA    3782
03786:  MOVWF  FAD
....................    if (response == 1)  
03788:  MOVLB  9
0378A:  DECFSZ xC1,W
0378C:  BRA    3B5E
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
0378E:  MOVF   1F,W
03790:  SUBLW  04
03792:  BNZ   37B8
03794:  MOVF   20,F
03796:  BNZ   37B8
03798:  MOVLW  0A
0379A:  MOVWF  FF6
0379C:  MOVLW  07
0379E:  MOVWF  FF7
037A0:  MOVLW  00
037A2:  MOVWF  FF8
037A4:  CLRF   1B
037A6:  BTFSC  FF2.7
037A8:  BSF    1B.7
037AA:  BCF    FF2.7
037AC:  MOVLB  0
037AE:  CALL   0E3A
037B2:  BTFSC  1B.7
037B4:  BSF    FF2.7
037B6:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
037B8:  CLRF   xC0
037BA:  MOVF   xC0,W
037BC:  SUBLW  03
037BE:  BNC   37DE
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
037C0:  CLRF   03
037C2:  MOVF   xC0,W
037C4:  ADDLW  C2
037C6:  MOVWF  FE9
037C8:  MOVLW  09
037CA:  ADDWFC 03,W
037CC:  MOVWF  FEA
037CE:  MOVF   FC9,W
037D0:  SETF   FC9
037D2:  RRCF   FC7,W
037D4:  BNC   37D2
037D6:  MOVFF  FC9,FEF
037DA:  INCF   xC0,F
037DC:  BRA    37BA
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
037DE:  MOVF   1F,W
037E0:  SUBLW  04
037E2:  BNZ   3856
037E4:  MOVF   20,F
037E6:  BNZ   3856
037E8:  MOVLW  2C
037EA:  MOVWF  FF6
037EC:  MOVLW  07
037EE:  MOVWF  FF7
037F0:  MOVLW  00
037F2:  MOVWF  FF8
037F4:  CLRF   1B
037F6:  BTFSC  FF2.7
037F8:  BSF    1B.7
037FA:  BCF    FF2.7
037FC:  MOVLW  1F
037FE:  MOVLB  A
03800:  MOVWF  x18
03802:  MOVLB  0
03804:  CALL   1010
03808:  BTFSC  1B.7
0380A:  BSF    FF2.7
0380C:  MOVFF  9C2,9C9
03810:  MOVLW  57
03812:  MOVLB  9
03814:  MOVWF  xCA
03816:  MOVLB  0
03818:  RCALL  3598
0381A:  MOVFF  9C3,9C9
0381E:  MOVLW  57
03820:  MOVLB  9
03822:  MOVWF  xCA
03824:  MOVLB  0
03826:  RCALL  3598
03828:  MOVFF  9C4,9C9
0382C:  MOVLW  57
0382E:  MOVLB  9
03830:  MOVWF  xCA
03832:  MOVLB  0
03834:  RCALL  3598
03836:  MOVFF  9C5,9C9
0383A:  MOVLW  57
0383C:  MOVLB  9
0383E:  MOVWF  xCA
03840:  MOVLB  0
03842:  RCALL  3598
03844:  MOVLW  0D
03846:  BTFSS  F9E.4
03848:  BRA    3846
0384A:  MOVWF  FAD
0384C:  MOVLW  0A
0384E:  BTFSS  F9E.4
03850:  BRA    384E
03852:  MOVWF  FAD
03854:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
03856:  DECFSZ xC4,W
03858:  BRA    3B34
0385A:  MOVF   xC5,W
0385C:  SUBLW  AA
0385E:  BTFSS  FD8.2
03860:  BRA    3B34
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
03862:  MOVF   1F,W
03864:  SUBLW  04
03866:  BNZ   388C
03868:  MOVF   20,F
0386A:  BNZ   388C
0386C:  MOVLW  5E
0386E:  MOVWF  FF6
03870:  MOVLW  07
03872:  MOVWF  FF7
03874:  MOVLW  00
03876:  MOVWF  FF8
03878:  CLRF   1B
0387A:  BTFSC  FF2.7
0387C:  BSF    1B.7
0387E:  BCF    FF2.7
03880:  MOVLB  0
03882:  CALL   0E3A
03886:  BTFSC  1B.7
03888:  BSF    FF2.7
0388A:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
0388C:  MOVF   1F,W
0388E:  SUBLW  04
03890:  BNZ   38B6
03892:  MOVF   20,F
03894:  BNZ   38B6
03896:  MOVLW  84
03898:  MOVWF  FF6
0389A:  MOVLW  07
0389C:  MOVWF  FF7
0389E:  MOVLW  00
038A0:  MOVWF  FF8
038A2:  CLRF   1B
038A4:  BTFSC  FF2.7
038A6:  BSF    1B.7
038A8:  BCF    FF2.7
038AA:  MOVLB  0
038AC:  CALL   0E3A
038B0:  BTFSC  1B.7
038B2:  BSF    FF2.7
038B4:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
038B6:  CLRF   xC7
038B8:  CLRF   xC6
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
038BA:  MOVLW  77
038BC:  MOVLB  A
038BE:  MOVWF  x04
038C0:  CLRF   x08
038C2:  CLRF   x07
038C4:  CLRF   x06
038C6:  CLRF   x05
038C8:  MOVLB  0
038CA:  RCALL  34C8
038CC:  MOVFF  01,9C1
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
038D0:  MOVLW  69
038D2:  MOVLB  A
038D4:  MOVWF  x04
038D6:  MOVLW  40
038D8:  MOVWF  x08
038DA:  CLRF   x07
038DC:  CLRF   x06
038DE:  CLRF   x05
038E0:  MOVLB  0
038E2:  RCALL  34C8
038E4:  MOVFF  01,9C1
....................          while (response && (Timer < 50000)) 
038E8:  MOVLB  9
038EA:  MOVF   xC1,F
038EC:  BZ    393E
038EE:  MOVF   xC7,W
038F0:  SUBLW  C3
038F2:  BNC   393E
038F4:  BNZ   38FC
038F6:  MOVF   xC6,W
038F8:  SUBLW  4F
038FA:  BNC   393E
....................          { 
....................             delay_us(20); 
038FC:  MOVLW  6A
038FE:  MOVWF  00
03900:  DECFSZ 00,F
03902:  BRA    3900
03904:  NOP   
....................             Timer++; 
03906:  INCF   xC6,F
03908:  BTFSC  FD8.2
0390A:  INCF   xC7,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
0390C:  MOVLW  77
0390E:  MOVLB  A
03910:  MOVWF  x04
03912:  CLRF   x08
03914:  CLRF   x07
03916:  CLRF   x06
03918:  CLRF   x05
0391A:  MOVLB  0
0391C:  RCALL  34C8
0391E:  MOVFF  01,9C1
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
03922:  MOVLW  69
03924:  MOVLB  A
03926:  MOVWF  x04
03928:  MOVLW  40
0392A:  MOVWF  x08
0392C:  CLRF   x07
0392E:  CLRF   x06
03930:  CLRF   x05
03932:  MOVLB  0
03934:  RCALL  34C8
03936:  MOVFF  01,9C1
0393A:  BRA    38E8
0393C:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
0393E:  MOVF   1F,W
03940:  SUBLW  04
03942:  BNZ   39CC
03944:  MOVF   20,F
03946:  BNZ   39CC
03948:  MOVLW  B2
0394A:  MOVWF  FF6
0394C:  MOVLW  07
0394E:  MOVWF  FF7
03950:  MOVLW  00
03952:  MOVWF  FF8
03954:  CLRF   1B
03956:  BTFSC  FF2.7
03958:  BSF    1B.7
0395A:  BCF    FF2.7
0395C:  MOVLW  23
0395E:  MOVLB  A
03960:  MOVWF  x18
03962:  MOVLB  0
03964:  CALL   1010
03968:  BTFSC  1B.7
0396A:  BSF    FF2.7
0396C:  MOVFF  9C1,9C9
03970:  MOVLW  57
03972:  MOVLB  9
03974:  MOVWF  xCA
03976:  MOVLB  0
03978:  RCALL  3598
0397A:  MOVLW  D9
0397C:  MOVWF  FF6
0397E:  MOVLW  07
03980:  MOVWF  FF7
03982:  MOVLW  00
03984:  MOVWF  FF8
03986:  CLRF   1B
03988:  BTFSC  FF2.7
0398A:  BSF    1B.7
0398C:  BCF    FF2.7
0398E:  MOVLW  0A
03990:  MOVLB  A
03992:  MOVWF  x18
03994:  MOVLB  0
03996:  CALL   1010
0399A:  BTFSC  1B.7
0399C:  BSF    FF2.7
0399E:  MOVLW  10
039A0:  MOVWF  FE9
039A2:  CLRF   1B
039A4:  BTFSC  FF2.7
039A6:  BSF    1B.7
039A8:  BCF    FF2.7
039AA:  MOVFF  9C7,A19
039AE:  MOVFF  9C6,A18
039B2:  CALL   1192
039B6:  BTFSC  1B.7
039B8:  BSF    FF2.7
039BA:  MOVLW  0D
039BC:  BTFSS  F9E.4
039BE:  BRA    39BC
039C0:  MOVWF  FAD
039C2:  MOVLW  0A
039C4:  BTFSS  F9E.4
039C6:  BRA    39C4
039C8:  MOVWF  FAD
039CA:  MOVLB  9
....................          if (!response) 
039CC:  MOVF   xC1,F
039CE:  BTFSS  FD8.2
039D0:  BRA    3B32
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
039D2:  MOVLW  7A
039D4:  MOVLB  A
039D6:  MOVWF  x04
039D8:  MOVLW  40
039DA:  MOVWF  x08
039DC:  CLRF   x07
039DE:  CLRF   x06
039E0:  CLRF   x05
039E2:  MOVLB  0
039E4:  RCALL  34C8
039E6:  MOVFF  01,9C1
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
039EA:  MOVF   1F,W
039EC:  SUBLW  04
039EE:  BNZ   3A36
039F0:  MOVF   20,F
039F2:  BNZ   3A36
039F4:  MOVLW  EA
039F6:  MOVWF  FF6
039F8:  MOVLW  07
039FA:  MOVWF  FF7
039FC:  MOVLW  00
039FE:  MOVWF  FF8
03A00:  CLRF   1B
03A02:  BTFSC  FF2.7
03A04:  BSF    1B.7
03A06:  BCF    FF2.7
03A08:  MOVLW  18
03A0A:  MOVLB  A
03A0C:  MOVWF  x18
03A0E:  MOVLB  0
03A10:  CALL   1010
03A14:  BTFSC  1B.7
03A16:  BSF    FF2.7
03A18:  MOVFF  9C1,9C9
03A1C:  MOVLW  57
03A1E:  MOVLB  9
03A20:  MOVWF  xCA
03A22:  MOVLB  0
03A24:  RCALL  3598
03A26:  MOVLW  0D
03A28:  BTFSS  F9E.4
03A2A:  BRA    3A28
03A2C:  MOVWF  FAD
03A2E:  MOVLW  0A
03A30:  BTFSS  F9E.4
03A32:  BRA    3A30
03A34:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03A36:  MOVLB  9
03A38:  MOVF   xC1,F
03A3A:  BTFSS  FD8.2
03A3C:  BRA    3B32
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03A3E:  CLRF   xC0
03A40:  MOVF   xC0,W
03A42:  SUBLW  03
03A44:  BNC   3A64
....................                   ocr[i] = SD_spi_read(0xFF); 
03A46:  CLRF   03
03A48:  MOVF   xC0,W
03A4A:  ADDLW  C2
03A4C:  MOVWF  FE9
03A4E:  MOVLW  09
03A50:  ADDWFC 03,W
03A52:  MOVWF  FEA
03A54:  MOVF   FC9,W
03A56:  SETF   FC9
03A58:  RRCF   FC7,W
03A5A:  BNC   3A58
03A5C:  MOVFF  FC9,FEF
03A60:  INCF   xC0,F
03A62:  BRA    3A40
....................                if (ocr[0] & 0x40) 
03A64:  BTFSS  xC2.6
03A66:  BRA    3A72
....................                   Card = SDHC; 
03A68:  MOVLW  05
03A6A:  MOVLB  4
03A6C:  MOVWF  xE3
03A6E:  BRA    3A78
03A70:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03A72:  MOVLW  04
03A74:  MOVLB  4
03A76:  MOVWF  xE3
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03A78:  MOVF   1F,W
03A7A:  SUBLW  04
03A7C:  BNZ   3B30
03A7E:  MOVF   20,F
03A80:  BNZ   3B30
03A82:  MOVLW  08
03A84:  MOVWF  FF6
03A86:  MOVLW  08
03A88:  MOVWF  FF7
03A8A:  MOVLW  00
03A8C:  MOVWF  FF8
03A8E:  CLRF   1B
03A90:  BTFSC  FF2.7
03A92:  BSF    1B.7
03A94:  BCF    FF2.7
03A96:  MOVLW  1F
03A98:  MOVLB  A
03A9A:  MOVWF  x18
03A9C:  MOVLB  0
03A9E:  CALL   1010
03AA2:  BTFSC  1B.7
03AA4:  BSF    FF2.7
03AA6:  MOVLW  10
03AA8:  MOVWF  FE9
03AAA:  CLRF   1B
03AAC:  BTFSC  FF2.7
03AAE:  BSF    1B.7
03AB0:  BCF    FF2.7
03AB2:  MOVFF  9C7,A19
03AB6:  MOVFF  9C6,A18
03ABA:  CALL   1192
03ABE:  BTFSC  1B.7
03AC0:  BSF    FF2.7
03AC2:  MOVLW  2A
03AC4:  MOVWF  FF6
03AC6:  MOVLW  08
03AC8:  MOVWF  FF7
03ACA:  MOVLW  00
03ACC:  MOVWF  FF8
03ACE:  CLRF   1B
03AD0:  BTFSC  FF2.7
03AD2:  BSF    1B.7
03AD4:  BCF    FF2.7
03AD6:  MOVLW  08
03AD8:  MOVLB  A
03ADA:  MOVWF  x18
03ADC:  MOVLB  0
03ADE:  CALL   1010
03AE2:  BTFSC  1B.7
03AE4:  BSF    FF2.7
03AE6:  MOVFF  9C2,9C9
03AEA:  MOVLW  57
03AEC:  MOVLB  9
03AEE:  MOVWF  xCA
03AF0:  MOVLB  0
03AF2:  RCALL  3598
03AF4:  MOVFF  9C3,9C9
03AF8:  MOVLW  57
03AFA:  MOVLB  9
03AFC:  MOVWF  xCA
03AFE:  MOVLB  0
03B00:  RCALL  3598
03B02:  MOVFF  9C4,9C9
03B06:  MOVLW  57
03B08:  MOVLB  9
03B0A:  MOVWF  xCA
03B0C:  MOVLB  0
03B0E:  RCALL  3598
03B10:  MOVFF  9C5,9C9
03B14:  MOVLW  57
03B16:  MOVLB  9
03B18:  MOVWF  xCA
03B1A:  MOVLB  0
03B1C:  RCALL  3598
03B1E:  MOVLW  0D
03B20:  BTFSS  F9E.4
03B22:  BRA    3B20
03B24:  MOVWF  FAD
03B26:  MOVLW  0A
03B28:  BTFSS  F9E.4
03B2A:  BRA    3B28
03B2C:  MOVWF  FAD
03B2E:  MOVLB  4
03B30:  MOVLB  9
....................             } 
....................          } 
....................       } 
03B32:  BRA    3B5E
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03B34:  MOVF   1F,W
03B36:  SUBLW  04
03B38:  BNZ   3B5E
03B3A:  MOVF   20,F
03B3C:  BNZ   3B5E
03B3E:  MOVLW  46
03B40:  MOVWF  FF6
03B42:  MOVLW  08
03B44:  MOVWF  FF7
03B46:  MOVLW  00
03B48:  MOVWF  FF8
03B4A:  CLRF   1B
03B4C:  BTFSC  FF2.7
03B4E:  BSF    1B.7
03B50:  BCF    FF2.7
03B52:  MOVLB  0
03B54:  CALL   0E3A
03B58:  BTFSC  1B.7
03B5A:  BSF    FF2.7
03B5C:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03B5E:  MOVLB  4
03B60:  MOVF   xE3,F
03B62:  BTFSS  FD8.2
03B64:  BRA    4034
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03B66:  MOVF   1F,W
03B68:  SUBLW  04
03B6A:  BNZ   3B90
03B6C:  MOVF   20,F
03B6E:  BNZ   3B90
03B70:  MOVLW  78
03B72:  MOVWF  FF6
03B74:  MOVLW  08
03B76:  MOVWF  FF7
03B78:  MOVLW  00
03B7A:  MOVWF  FF8
03B7C:  CLRF   1B
03B7E:  BTFSC  FF2.7
03B80:  BSF    1B.7
03B82:  BCF    FF2.7
03B84:  MOVLB  0
03B86:  CALL   0E3A
03B8A:  BTFSC  1B.7
03B8C:  BSF    FF2.7
03B8E:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03B90:  MOVLW  40
03B92:  MOVLB  A
03B94:  MOVWF  x04
03B96:  CLRF   x08
03B98:  CLRF   x07
03B9A:  CLRF   x06
03B9C:  CLRF   x05
03B9E:  MOVLB  0
03BA0:  RCALL  34C8
03BA2:  MOVFF  01,9C1
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03BA6:  MOVF   1F,W
03BA8:  SUBLW  04
03BAA:  BNZ   3BF2
03BAC:  MOVF   20,F
03BAE:  BNZ   3BF2
03BB0:  MOVLW  B8
03BB2:  MOVWF  FF6
03BB4:  MOVLW  08
03BB6:  MOVWF  FF7
03BB8:  MOVLW  00
03BBA:  MOVWF  FF8
03BBC:  CLRF   1B
03BBE:  BTFSC  FF2.7
03BC0:  BSF    1B.7
03BC2:  BCF    FF2.7
03BC4:  MOVLW  1C
03BC6:  MOVLB  A
03BC8:  MOVWF  x18
03BCA:  MOVLB  0
03BCC:  CALL   1010
03BD0:  BTFSC  1B.7
03BD2:  BSF    FF2.7
03BD4:  MOVFF  9C1,9C9
03BD8:  MOVLW  57
03BDA:  MOVLB  9
03BDC:  MOVWF  xCA
03BDE:  MOVLB  0
03BE0:  RCALL  3598
03BE2:  MOVLW  0D
03BE4:  BTFSS  F9E.4
03BE6:  BRA    3BE4
03BE8:  MOVWF  FAD
03BEA:  MOVLW  0A
03BEC:  BTFSS  F9E.4
03BEE:  BRA    3BEC
03BF0:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03BF2:  MOVLB  9
03BF4:  DECFSZ xC1,W
03BF6:  BRA    3BFA
03BF8:  BRA    3C04
03BFA:  MOVF   xC1,F
03BFC:  BZ    3C04
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03BFE:  BSF    xC8.0
....................          goto Exit_disk_initialize; 
03C00:  GOTO   4352
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03C04:  CLRF   xC7
03C06:  CLRF   xC6
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03C08:  MOVLW  41
03C0A:  MOVLB  A
03C0C:  MOVWF  x04
03C0E:  CLRF   x08
03C10:  CLRF   x07
03C12:  CLRF   x06
03C14:  CLRF   x05
03C16:  MOVLB  0
03C18:  RCALL  34C8
03C1A:  MOVFF  01,9C1
....................          if (response != 0x00 ) 
03C1E:  MOVLB  9
03C20:  MOVF   xC1,F
03C22:  BZ    3C2C
....................             delay_us(10); 
03C24:  MOVLW  35
03C26:  MOVWF  00
03C28:  DECFSZ 00,F
03C2A:  BRA    3C28
....................          Timer++; 
03C2C:  INCF   xC6,F
03C2E:  BTFSC  FD8.2
03C30:  INCF   xC7,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03C32:  MOVF   xC1,F
03C34:  BZ    3C44
03C36:  MOVF   xC7,W
03C38:  SUBLW  C3
03C3A:  BNC   3C44
03C3C:  BNZ   3C08
03C3E:  MOVF   xC6,W
03C40:  SUBLW  4F
03C42:  BC    3C08
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03C44:  MOVF   1F,W
03C46:  SUBLW  04
03C48:  BNZ   3CD2
03C4A:  MOVF   20,F
03C4C:  BNZ   3CD2
03C4E:  MOVLW  DC
03C50:  MOVWF  FF6
03C52:  MOVLW  08
03C54:  MOVWF  FF7
03C56:  MOVLW  00
03C58:  MOVWF  FF8
03C5A:  CLRF   1B
03C5C:  BTFSC  FF2.7
03C5E:  BSF    1B.7
03C60:  BCF    FF2.7
03C62:  MOVLW  28
03C64:  MOVLB  A
03C66:  MOVWF  x18
03C68:  MOVLB  0
03C6A:  CALL   1010
03C6E:  BTFSC  1B.7
03C70:  BSF    FF2.7
03C72:  MOVFF  9C1,9C9
03C76:  MOVLW  57
03C78:  MOVLB  9
03C7A:  MOVWF  xCA
03C7C:  MOVLB  0
03C7E:  RCALL  3598
03C80:  MOVLW  08
03C82:  MOVWF  FF6
03C84:  MOVLW  09
03C86:  MOVWF  FF7
03C88:  MOVLW  00
03C8A:  MOVWF  FF8
03C8C:  CLRF   1B
03C8E:  BTFSC  FF2.7
03C90:  BSF    1B.7
03C92:  BCF    FF2.7
03C94:  MOVLW  0A
03C96:  MOVLB  A
03C98:  MOVWF  x18
03C9A:  MOVLB  0
03C9C:  CALL   1010
03CA0:  BTFSC  1B.7
03CA2:  BSF    FF2.7
03CA4:  MOVLW  10
03CA6:  MOVWF  FE9
03CA8:  CLRF   1B
03CAA:  BTFSC  FF2.7
03CAC:  BSF    1B.7
03CAE:  BCF    FF2.7
03CB0:  MOVFF  9C7,A19
03CB4:  MOVFF  9C6,A18
03CB8:  CALL   1192
03CBC:  BTFSC  1B.7
03CBE:  BSF    FF2.7
03CC0:  MOVLW  0D
03CC2:  BTFSS  F9E.4
03CC4:  BRA    3CC2
03CC6:  MOVWF  FAD
03CC8:  MOVLW  0A
03CCA:  BTFSS  F9E.4
03CCC:  BRA    3CCA
03CCE:  MOVWF  FAD
03CD0:  MOVLB  9
....................       if(response) 
03CD2:  MOVF   xC1,F
03CD4:  BZ    3CDA
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03CD6:  BSF    xC8.0
....................          goto Exit_disk_initialize; 
03CD8:  BRA    4352
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03CDA:  MOVLW  77
03CDC:  MOVLB  A
03CDE:  MOVWF  x04
03CE0:  CLRF   x08
03CE2:  CLRF   x07
03CE4:  CLRF   x06
03CE6:  CLRF   x05
03CE8:  MOVLB  0
03CEA:  CALL   34C8
03CEE:  MOVFF  01,9C1
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03CF2:  MOVF   1F,W
03CF4:  SUBLW  04
03CF6:  BNZ   3D3E
03CF8:  MOVF   20,F
03CFA:  BNZ   3D3E
03CFC:  MOVLW  18
03CFE:  MOVWF  FF6
03D00:  MOVLW  09
03D02:  MOVWF  FF7
03D04:  MOVLW  00
03D06:  MOVWF  FF8
03D08:  CLRF   1B
03D0A:  BTFSC  FF2.7
03D0C:  BSF    1B.7
03D0E:  BCF    FF2.7
03D10:  MOVLW  43
03D12:  MOVLB  A
03D14:  MOVWF  x18
03D16:  MOVLB  0
03D18:  CALL   1010
03D1C:  BTFSC  1B.7
03D1E:  BSF    FF2.7
03D20:  MOVFF  9C1,9C9
03D24:  MOVLW  57
03D26:  MOVLB  9
03D28:  MOVWF  xCA
03D2A:  MOVLB  0
03D2C:  RCALL  3598
03D2E:  MOVLW  0D
03D30:  BTFSS  F9E.4
03D32:  BRA    3D30
03D34:  MOVWF  FAD
03D36:  MOVLW  0A
03D38:  BTFSS  F9E.4
03D3A:  BRA    3D38
03D3C:  MOVWF  FAD
....................       if (response) 
03D3E:  MOVLB  9
03D40:  MOVF   xC1,F
03D42:  BZ    3D4E
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03D44:  MOVLW  02
03D46:  MOVLB  4
03D48:  MOVWF  xE3
....................          } 
03D4A:  BRA    3F48
03D4C:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03D4E:  MOVLW  69
03D50:  MOVLB  A
03D52:  MOVWF  x04
03D54:  CLRF   x08
03D56:  CLRF   x07
03D58:  CLRF   x06
03D5A:  CLRF   x05
03D5C:  MOVLB  0
03D5E:  CALL   34C8
03D62:  MOVFF  01,9C1
....................          if (response <= 1 ) 
03D66:  MOVLB  9
03D68:  MOVF   xC1,W
03D6A:  SUBLW  01
03D6C:  BNC   3D78
....................             Card = SDv1; 
03D6E:  MOVLW  03
03D70:  MOVLB  4
03D72:  MOVWF  xE3
03D74:  BRA    3F48
03D76:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03D78:  MOVF   1F,W
03D7A:  SUBLW  04
03D7C:  BNZ   3DDC
03D7E:  MOVF   20,F
03D80:  BNZ   3DDC
03D82:  MOVLW  62
03D84:  MOVWF  FF6
03D86:  MOVLW  09
03D88:  MOVWF  FF7
03D8A:  MOVLW  00
03D8C:  MOVWF  FF8
03D8E:  CLRF   1B
03D90:  BTFSC  FF2.7
03D92:  BSF    1B.7
03D94:  BCF    FF2.7
03D96:  MOVLW  2E
03D98:  MOVLB  A
03D9A:  MOVWF  x18
03D9C:  MOVLB  0
03D9E:  CALL   1010
03DA2:  BTFSC  1B.7
03DA4:  BSF    FF2.7
03DA6:  MOVFF  9C1,9C9
03DAA:  MOVLW  37
03DAC:  MOVLB  9
03DAE:  MOVWF  xCA
03DB0:  MOVLB  0
03DB2:  CALL   3598
03DB6:  MOVLW  94
03DB8:  MOVWF  FF6
03DBA:  MOVLW  09
03DBC:  MOVWF  FF7
03DBE:  MOVLW  00
03DC0:  MOVWF  FF8
03DC2:  CLRF   1B
03DC4:  BTFSC  FF2.7
03DC6:  BSF    1B.7
03DC8:  BCF    FF2.7
03DCA:  MOVLW  19
03DCC:  MOVLB  A
03DCE:  MOVWF  x18
03DD0:  MOVLB  0
03DD2:  CALL   1010
03DD6:  BTFSC  1B.7
03DD8:  BSF    FF2.7
03DDA:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03DDC:  MOVLW  40
03DDE:  MOVLB  A
03DE0:  MOVWF  x04
03DE2:  CLRF   x08
03DE4:  CLRF   x07
03DE6:  CLRF   x06
03DE8:  CLRF   x05
03DEA:  MOVLB  0
03DEC:  CALL   34C8
03DF0:  MOVFF  01,9C1
....................             if ((response !=0x01) && (response != 0)) 
03DF4:  MOVLB  9
03DF6:  DECFSZ xC1,W
03DF8:  BRA    3DFC
03DFA:  BRA    3E68
03DFC:  MOVF   xC1,F
03DFE:  BZ    3E68
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03E00:  MOVF   1F,W
03E02:  SUBLW  04
03E04:  BNZ   3E64
03E06:  MOVF   20,F
03E08:  BNZ   3E64
03E0A:  MOVLW  AE
03E0C:  MOVWF  FF6
03E0E:  MOVLW  09
03E10:  MOVWF  FF7
03E12:  MOVLW  00
03E14:  MOVWF  FF8
03E16:  CLRF   1B
03E18:  BTFSC  FF2.7
03E1A:  BSF    1B.7
03E1C:  BCF    FF2.7
03E1E:  MOVLW  2C
03E20:  MOVLB  A
03E22:  MOVWF  x18
03E24:  MOVLB  0
03E26:  CALL   1010
03E2A:  BTFSC  1B.7
03E2C:  BSF    FF2.7
03E2E:  MOVFF  9C1,9C9
03E32:  MOVLW  37
03E34:  MOVLB  9
03E36:  MOVWF  xCA
03E38:  MOVLB  0
03E3A:  CALL   3598
03E3E:  MOVLW  DE
03E40:  MOVWF  FF6
03E42:  MOVLW  09
03E44:  MOVWF  FF7
03E46:  MOVLW  00
03E48:  MOVWF  FF8
03E4A:  CLRF   1B
03E4C:  BTFSC  FF2.7
03E4E:  BSF    1B.7
03E50:  BCF    FF2.7
03E52:  MOVLW  0B
03E54:  MOVLB  A
03E56:  MOVWF  x18
03E58:  MOVLB  0
03E5A:  CALL   1010
03E5E:  BTFSC  1B.7
03E60:  BSF    FF2.7
03E62:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03E64:  BSF    xC8.0
....................                goto Exit_disk_initialize; 
03E66:  BRA    4352
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03E68:  CLRF   xC7
03E6A:  CLRF   xC6
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03E6C:  MOVLW  41
03E6E:  MOVLB  A
03E70:  MOVWF  x04
03E72:  CLRF   x08
03E74:  CLRF   x07
03E76:  CLRF   x06
03E78:  CLRF   x05
03E7A:  MOVLB  0
03E7C:  CALL   34C8
03E80:  MOVFF  01,9C1
....................                if (response != 0x00 ) 
03E84:  MOVLB  9
03E86:  MOVF   xC1,F
03E88:  BZ    3E92
....................                   delay_us(10); 
03E8A:  MOVLW  35
03E8C:  MOVWF  00
03E8E:  DECFSZ 00,F
03E90:  BRA    3E8E
....................                Timer++; 
03E92:  INCF   xC6,F
03E94:  BTFSC  FD8.2
03E96:  INCF   xC7,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03E98:  MOVF   xC1,F
03E9A:  BZ    3EAA
03E9C:  MOVF   xC7,W
03E9E:  SUBLW  C3
03EA0:  BNC   3EAA
03EA2:  BNZ   3E6C
03EA4:  MOVF   xC6,W
03EA6:  SUBLW  4F
03EA8:  BC    3E6C
....................     
....................             if(response) 
03EAA:  MOVF   xC1,F
03EAC:  BZ    3F42
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03EAE:  MOVF   1F,W
03EB0:  SUBLW  04
03EB2:  BNZ   3F3E
03EB4:  MOVF   20,F
03EB6:  BNZ   3F3E
03EB8:  MOVLW  EA
03EBA:  MOVWF  FF6
03EBC:  MOVLW  09
03EBE:  MOVWF  FF7
03EC0:  MOVLW  00
03EC2:  MOVWF  FF8
03EC4:  CLRF   1B
03EC6:  BTFSC  FF2.7
03EC8:  BSF    1B.7
03ECA:  BCF    FF2.7
03ECC:  MOVLW  4A
03ECE:  MOVLB  A
03ED0:  MOVWF  x18
03ED2:  MOVLB  0
03ED4:  CALL   1010
03ED8:  BTFSC  1B.7
03EDA:  BSF    FF2.7
03EDC:  MOVFF  9C1,9C9
03EE0:  MOVLW  37
03EE2:  MOVLB  9
03EE4:  MOVWF  xCA
03EE6:  MOVLB  0
03EE8:  CALL   3598
03EEC:  MOVLW  38
03EEE:  MOVWF  FF6
03EF0:  MOVLW  0A
03EF2:  MOVWF  FF7
03EF4:  MOVLW  00
03EF6:  MOVWF  FF8
03EF8:  CLRF   1B
03EFA:  BTFSC  FF2.7
03EFC:  BSF    1B.7
03EFE:  BCF    FF2.7
03F00:  MOVLW  0A
03F02:  MOVLB  A
03F04:  MOVWF  x18
03F06:  MOVLB  0
03F08:  CALL   1010
03F0C:  BTFSC  1B.7
03F0E:  BSF    FF2.7
03F10:  MOVLW  10
03F12:  MOVWF  FE9
03F14:  CLRF   1B
03F16:  BTFSC  FF2.7
03F18:  BSF    1B.7
03F1A:  BCF    FF2.7
03F1C:  MOVFF  9C7,A19
03F20:  MOVFF  9C6,A18
03F24:  CALL   1192
03F28:  BTFSC  1B.7
03F2A:  BSF    FF2.7
03F2C:  MOVLW  0D
03F2E:  BTFSS  F9E.4
03F30:  BRA    3F2E
03F32:  MOVWF  FAD
03F34:  MOVLW  0A
03F36:  BTFSS  F9E.4
03F38:  BRA    3F36
03F3A:  MOVWF  FAD
03F3C:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03F3E:  BSF    xC8.0
....................                goto Exit_disk_initialize; 
03F40:  BRA    4352
....................                } 
....................  
....................             Card = MMC; 
03F42:  MOVLW  02
03F44:  MOVLB  4
03F46:  MOVWF  xE3
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
03F48:  MOVF   1F,W
03F4A:  SUBLW  04
03F4C:  BNZ   3F72
03F4E:  MOVF   20,F
03F50:  BNZ   3F72
03F52:  MOVLW  48
03F54:  MOVWF  FF6
03F56:  MOVLW  0A
03F58:  MOVWF  FF7
03F5A:  MOVLW  00
03F5C:  MOVWF  FF8
03F5E:  CLRF   1B
03F60:  BTFSC  FF2.7
03F62:  BSF    1B.7
03F64:  BCF    FF2.7
03F66:  MOVLB  0
03F68:  CALL   0E3A
03F6C:  BTFSC  1B.7
03F6E:  BSF    FF2.7
03F70:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
03F72:  MOVLW  50
03F74:  MOVLB  A
03F76:  MOVWF  x04
03F78:  CLRF   x08
03F7A:  CLRF   x07
03F7C:  MOVLW  02
03F7E:  MOVWF  x06
03F80:  CLRF   x05
03F82:  MOVLB  0
03F84:  CALL   34C8
03F88:  MOVFF  01,9C1
....................       if ((Timer == 50000) || (response > 1))    
03F8C:  MOVLB  9
03F8E:  MOVF   xC6,W
03F90:  SUBLW  50
03F92:  BNZ   3F9A
03F94:  MOVF   xC7,W
03F96:  SUBLW  C3
03F98:  BZ    3FA0
03F9A:  MOVF   xC1,W
03F9C:  SUBLW  01
03F9E:  BC    4036
....................       { 
....................          Card = None; 
03FA0:  MOVLB  4
03FA2:  CLRF   xE3
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
03FA4:  MOVF   1F,W
03FA6:  SUBLW  04
03FA8:  BNZ   4034
03FAA:  MOVF   20,F
03FAC:  BNZ   4034
03FAE:  MOVLW  64
03FB0:  MOVWF  FF6
03FB2:  MOVLW  0A
03FB4:  MOVWF  FF7
03FB6:  MOVLW  00
03FB8:  MOVWF  FF8
03FBA:  CLRF   1B
03FBC:  BTFSC  FF2.7
03FBE:  BSF    1B.7
03FC0:  BCF    FF2.7
03FC2:  MOVLW  2B
03FC4:  MOVLB  A
03FC6:  MOVWF  x18
03FC8:  MOVLB  0
03FCA:  CALL   1010
03FCE:  BTFSC  1B.7
03FD0:  BSF    FF2.7
03FD2:  MOVFF  9C1,9C9
03FD6:  MOVLW  57
03FD8:  MOVLB  9
03FDA:  MOVWF  xCA
03FDC:  MOVLB  0
03FDE:  CALL   3598
03FE2:  MOVLW  93
03FE4:  MOVWF  FF6
03FE6:  MOVLW  0A
03FE8:  MOVWF  FF7
03FEA:  MOVLW  00
03FEC:  MOVWF  FF8
03FEE:  CLRF   1B
03FF0:  BTFSC  FF2.7
03FF2:  BSF    1B.7
03FF4:  BCF    FF2.7
03FF6:  MOVLW  0A
03FF8:  MOVLB  A
03FFA:  MOVWF  x18
03FFC:  MOVLB  0
03FFE:  CALL   1010
04002:  BTFSC  1B.7
04004:  BSF    FF2.7
04006:  MOVLW  10
04008:  MOVWF  FE9
0400A:  CLRF   1B
0400C:  BTFSC  FF2.7
0400E:  BSF    1B.7
04010:  BCF    FF2.7
04012:  MOVFF  9C7,A19
04016:  MOVFF  9C6,A18
0401A:  CALL   1192
0401E:  BTFSC  1B.7
04020:  BSF    FF2.7
04022:  MOVLW  0D
04024:  BTFSS  F9E.4
04026:  BRA    4024
04028:  MOVWF  FAD
0402A:  MOVLW  0A
0402C:  BTFSS  F9E.4
0402E:  BRA    402C
04030:  MOVWF  FAD
04032:  MOVLB  4
04034:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
04036:  MOVLB  4
04038:  MOVF   xE3,F
0403A:  BNZ   406E
....................    { 
....................       if (nv_report_mode == 4) 
0403C:  MOVF   1F,W
0403E:  SUBLW  04
04040:  BNZ   4066
04042:  MOVF   20,F
04044:  BNZ   4066
....................          printf("@FS:Card Type Discovery Error\r\n"); 
04046:  MOVLW  A4
04048:  MOVWF  FF6
0404A:  MOVLW  0A
0404C:  MOVWF  FF7
0404E:  MOVLW  00
04050:  MOVWF  FF8
04052:  CLRF   1B
04054:  BTFSC  FF2.7
04056:  BSF    1B.7
04058:  BCF    FF2.7
0405A:  MOVLB  0
0405C:  CALL   0E3A
04060:  BTFSC  1B.7
04062:  BSF    FF2.7
04064:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
04066:  MOVLB  9
04068:  BSF    xC8.0
....................       goto Exit_disk_initialize; 
0406A:  BRA    4352
0406C:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
0406E:  MOVF   xE3,W
04070:  XORLW  02
04072:  MOVLB  0
04074:  BZ    4084
04076:  XORLW  01
04078:  BZ    40AC
0407A:  XORLW  07
0407C:  BZ    40D4
0407E:  XORLW  01
04080:  BZ    40FC
04082:  BRA    4124
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
04084:  MOVF   1F,W
04086:  SUBLW  04
04088:  BNZ   40AA
0408A:  MOVF   20,F
0408C:  BNZ   40AA
0408E:  MOVLW  C4
04090:  MOVWF  FF6
04092:  MOVLW  0A
04094:  MOVWF  FF7
04096:  MOVLW  00
04098:  MOVWF  FF8
0409A:  CLRF   1B
0409C:  BTFSC  FF2.7
0409E:  BSF    1B.7
040A0:  BCF    FF2.7
040A2:  CALL   0E3A
040A6:  BTFSC  1B.7
040A8:  BSF    FF2.7
....................          break; 
040AA:  BRA    417A
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
040AC:  MOVF   1F,W
040AE:  SUBLW  04
040B0:  BNZ   40D2
040B2:  MOVF   20,F
040B4:  BNZ   40D2
040B6:  MOVLW  DA
040B8:  MOVWF  FF6
040BA:  MOVLW  0A
040BC:  MOVWF  FF7
040BE:  MOVLW  00
040C0:  MOVWF  FF8
040C2:  CLRF   1B
040C4:  BTFSC  FF2.7
040C6:  BSF    1B.7
040C8:  BCF    FF2.7
040CA:  CALL   0E3A
040CE:  BTFSC  1B.7
040D0:  BSF    FF2.7
....................          break; 
040D2:  BRA    417A
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
040D4:  MOVF   1F,W
040D6:  SUBLW  04
040D8:  BNZ   40FA
040DA:  MOVF   20,F
040DC:  BNZ   40FA
040DE:  MOVLW  F0
040E0:  MOVWF  FF6
040E2:  MOVLW  0A
040E4:  MOVWF  FF7
040E6:  MOVLW  00
040E8:  MOVWF  FF8
040EA:  CLRF   1B
040EC:  BTFSC  FF2.7
040EE:  BSF    1B.7
040F0:  BCF    FF2.7
040F2:  CALL   0E3A
040F6:  BTFSC  1B.7
040F8:  BSF    FF2.7
....................          break; 
040FA:  BRA    417A
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
040FC:  MOVF   1F,W
040FE:  SUBLW  04
04100:  BNZ   4122
04102:  MOVF   20,F
04104:  BNZ   4122
04106:  MOVLW  06
04108:  MOVWF  FF6
0410A:  MOVLW  0B
0410C:  MOVWF  FF7
0410E:  MOVLW  00
04110:  MOVWF  FF8
04112:  CLRF   1B
04114:  BTFSC  FF2.7
04116:  BSF    1B.7
04118:  BCF    FF2.7
0411A:  CALL   0E3A
0411E:  BTFSC  1B.7
04120:  BSF    FF2.7
....................          break; 
04122:  BRA    417A
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
04124:  MOVF   1F,W
04126:  SUBLW  04
04128:  BNZ   4172
0412A:  MOVF   20,F
0412C:  BNZ   4172
0412E:  MOVLW  1C
04130:  MOVWF  FF6
04132:  MOVLW  0B
04134:  MOVWF  FF7
04136:  MOVLW  00
04138:  MOVWF  FF8
0413A:  CLRF   1B
0413C:  BTFSC  FF2.7
0413E:  BSF    1B.7
04140:  BCF    FF2.7
04142:  MOVLW  26
04144:  MOVLB  A
04146:  MOVWF  x18
04148:  MOVLB  0
0414A:  CALL   1010
0414E:  BTFSC  1B.7
04150:  BSF    FF2.7
04152:  MOVFF  4E3,9C9
04156:  MOVLW  37
04158:  MOVLB  9
0415A:  MOVWF  xCA
0415C:  MOVLB  0
0415E:  CALL   3598
04162:  MOVLW  0D
04164:  BTFSS  F9E.4
04166:  BRA    4164
04168:  MOVWF  FAD
0416A:  MOVLW  0A
0416C:  BTFSS  F9E.4
0416E:  BRA    416C
04170:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
04172:  MOVLB  9
04174:  BSF    xC8.0
....................          goto Exit_disk_initialize; 
04176:  BRA    4352
04178:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
0417A:  MOVLB  9
0417C:  BCF    xC8.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
0417E:  MOVF   1F,W
04180:  SUBLW  04
04182:  BNZ   41DA
04184:  MOVF   20,F
04186:  BNZ   41DA
04188:  MOVLW  4A
0418A:  MOVWF  FF6
0418C:  MOVLW  0B
0418E:  MOVWF  FF7
04190:  MOVLW  00
04192:  MOVWF  FF8
04194:  CLRF   1B
04196:  BTFSC  FF2.7
04198:  BSF    1B.7
0419A:  BCF    FF2.7
0419C:  MOVLW  2E
0419E:  MOVLB  A
041A0:  MOVWF  x18
041A2:  MOVLB  0
041A4:  CALL   1010
041A8:  BTFSC  1B.7
041AA:  BSF    FF2.7
041AC:  MOVLW  10
041AE:  MOVWF  FE9
041B0:  CLRF   1B
041B2:  BTFSC  FF2.7
041B4:  BSF    1B.7
041B6:  BCF    FF2.7
041B8:  MOVFF  9C7,A19
041BC:  MOVFF  9C6,A18
041C0:  CALL   1192
041C4:  BTFSC  1B.7
041C6:  BSF    FF2.7
041C8:  MOVLW  0D
041CA:  BTFSS  F9E.4
041CC:  BRA    41CA
041CE:  MOVWF  FAD
041D0:  MOVLW  0A
041D2:  BTFSS  F9E.4
041D4:  BRA    41D2
041D6:  MOVWF  FAD
041D8:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
041DA:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
041DC:  BCF    FC6.5
041DE:  MOVLW  20
041E0:  MOVWF  FC6
041E2:  MOVLW  40
041E4:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
041E6:  BCF    F9E.3
....................    SelectSD; 
041E8:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
041EA:  MOVF   1F,W
041EC:  SUBLW  04
041EE:  BNZ   4214
041F0:  MOVF   20,F
041F2:  BNZ   4214
041F4:  MOVLW  7E
041F6:  MOVWF  FF6
041F8:  MOVLW  0B
041FA:  MOVWF  FF7
041FC:  MOVLW  00
041FE:  MOVWF  FF8
04200:  CLRF   1B
04202:  BTFSC  FF2.7
04204:  BSF    1B.7
04206:  BCF    FF2.7
04208:  MOVLB  0
0420A:  CALL   0E3A
0420E:  BTFSC  1B.7
04210:  BSF    FF2.7
04212:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
04214:  CLRF   xC7
04216:  CLRF   xC6
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
04218:  MOVLW  41
0421A:  MOVLB  A
0421C:  MOVWF  x04
0421E:  CLRF   x08
04220:  CLRF   x07
04222:  CLRF   x06
04224:  CLRF   x05
04226:  MOVLB  0
04228:  CALL   34C8
0422C:  MOVFF  01,9C1
....................       if (response != 0x00 ) 
04230:  MOVLB  9
04232:  MOVF   xC1,F
04234:  BZ    423E
....................          delay_us(10); 
04236:  MOVLW  35
04238:  MOVWF  00
0423A:  DECFSZ 00,F
0423C:  BRA    423A
....................  
....................       Timer++; 
0423E:  INCF   xC6,F
04240:  BTFSC  FD8.2
04242:  INCF   xC7,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
04244:  MOVF   xC1,F
04246:  BZ    4256
04248:  MOVF   xC7,W
0424A:  SUBLW  C3
0424C:  BNC   4256
0424E:  BNZ   4218
04250:  MOVF   xC6,W
04252:  SUBLW  4F
04254:  BC    4218
....................  
....................    if (response != 0x00) 
04256:  MOVF   xC1,F
04258:  BZ    42EE
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
0425A:  MOVF   1F,W
0425C:  SUBLW  04
0425E:  BNZ   42EA
04260:  MOVF   20,F
04262:  BNZ   42EA
04264:  MOVLW  9E
04266:  MOVWF  FF6
04268:  MOVLW  0B
0426A:  MOVWF  FF7
0426C:  MOVLW  00
0426E:  MOVWF  FF8
04270:  CLRF   1B
04272:  BTFSC  FF2.7
04274:  BSF    1B.7
04276:  BCF    FF2.7
04278:  MOVLW  26
0427A:  MOVLB  A
0427C:  MOVWF  x18
0427E:  MOVLB  0
04280:  CALL   1010
04284:  BTFSC  1B.7
04286:  BSF    FF2.7
04288:  MOVFF  9C1,9C9
0428C:  MOVLW  37
0428E:  MOVLB  9
04290:  MOVWF  xCA
04292:  MOVLB  0
04294:  CALL   3598
04298:  MOVLW  C8
0429A:  MOVWF  FF6
0429C:  MOVLW  0B
0429E:  MOVWF  FF7
042A0:  MOVLW  00
042A2:  MOVWF  FF8
042A4:  CLRF   1B
042A6:  BTFSC  FF2.7
042A8:  BSF    1B.7
042AA:  BCF    FF2.7
042AC:  MOVLW  0A
042AE:  MOVLB  A
042B0:  MOVWF  x18
042B2:  MOVLB  0
042B4:  CALL   1010
042B8:  BTFSC  1B.7
042BA:  BSF    FF2.7
042BC:  MOVLW  10
042BE:  MOVWF  FE9
042C0:  CLRF   1B
042C2:  BTFSC  FF2.7
042C4:  BSF    1B.7
042C6:  BCF    FF2.7
042C8:  MOVFF  9C7,A19
042CC:  MOVFF  9C6,A18
042D0:  CALL   1192
042D4:  BTFSC  1B.7
042D6:  BSF    FF2.7
042D8:  MOVLW  0D
042DA:  BTFSS  F9E.4
042DC:  BRA    42DA
042DE:  MOVWF  FAD
042E0:  MOVLW  0A
042E2:  BTFSS  F9E.4
042E4:  BRA    42E2
042E6:  MOVWF  FAD
042E8:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
042EA:  BSF    xC8.0
....................       goto Exit_disk_initialize; 
042EC:  BRA    4352
....................    } 
....................  
....................    if (nv_report_mode == 4) 
042EE:  MOVF   1F,W
042F0:  SUBLW  04
042F2:  BNZ   434A
042F4:  MOVF   20,F
042F6:  BNZ   434A
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
042F8:  MOVLW  D8
042FA:  MOVWF  FF6
042FC:  MOVLW  0B
042FE:  MOVWF  FF7
04300:  MOVLW  00
04302:  MOVWF  FF8
04304:  CLRF   1B
04306:  BTFSC  FF2.7
04308:  BSF    1B.7
0430A:  BCF    FF2.7
0430C:  MOVLW  25
0430E:  MOVLB  A
04310:  MOVWF  x18
04312:  MOVLB  0
04314:  CALL   1010
04318:  BTFSC  1B.7
0431A:  BSF    FF2.7
0431C:  MOVLW  10
0431E:  MOVWF  FE9
04320:  CLRF   1B
04322:  BTFSC  FF2.7
04324:  BSF    1B.7
04326:  BCF    FF2.7
04328:  MOVFF  9C7,A19
0432C:  MOVFF  9C6,A18
04330:  CALL   1192
04334:  BTFSC  1B.7
04336:  BSF    FF2.7
04338:  MOVLW  0D
0433A:  BTFSS  F9E.4
0433C:  BRA    433A
0433E:  MOVWF  FAD
04340:  MOVLW  0A
04342:  BTFSS  F9E.4
04344:  BRA    4342
04346:  MOVWF  FAD
04348:  MOVLB  9
....................  
....................    msg_card_ok(); 
0434A:  MOVLB  0
0434C:  GOTO   35DE
04350:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
04352:  BSF    F91.1
....................    return(SDCardStatus); 
04354:  MOVFF  9C8,01
04358:  MOVLB  0
0435A:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05A02:  MOVLW  20
05A04:  MOVLB  7
05A06:  ADDWF  x0E,W
05A08:  MOVWF  FE9
05A0A:  MOVLW  00
05A0C:  ADDWFC x0F,W
05A0E:  MOVWF  FEA
05A10:  MOVFF  FEF,9F1
05A14:  MOVFF  FEC,9F2
05A18:  MOVFF  FEC,9F3
05A1C:  MOVFF  FEC,9F4
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05A20:  MOVLB  9
05A22:  MOVF   xED,W
05A24:  SUBWF  xF1,W
05A26:  BNZ   5A3C
05A28:  MOVF   xEE,W
05A2A:  SUBWF  xF2,W
05A2C:  BNZ   5A3C
05A2E:  MOVF   xEF,W
05A30:  SUBWF  xF3,W
05A32:  BNZ   5A3C
05A34:  MOVF   xF0,W
05A36:  SUBWF  xF4,W
05A38:  BTFSC  FD8.2
05A3A:  BRA    5C10
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05A3C:  MOVLW  06
05A3E:  MOVLB  7
05A40:  ADDWF  x0E,W
05A42:  MOVWF  FE9
05A44:  MOVLW  00
05A46:  ADDWFC x0F,W
05A48:  MOVWF  FEA
05A4A:  MOVF   FEF,F
05A4C:  BTFSC  FD8.2
05A4E:  BRA    5B9A
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05A50:  MOVLW  24
05A52:  ADDWF  x0E,W
05A54:  MOVWF  01
05A56:  MOVLW  00
05A58:  ADDWFC x0F,W
05A5A:  MOVWF  03
05A5C:  MOVFF  01,9F7
05A60:  MOVLB  9
05A62:  MOVWF  xF8
05A64:  MOVWF  xFA
05A66:  MOVFF  01,9F9
05A6A:  MOVFF  9F4,9FE
05A6E:  MOVFF  9F3,9FD
05A72:  MOVFF  9F2,9FC
05A76:  MOVFF  9F1,9FB
05A7A:  MOVLW  01
05A7C:  MOVWF  xFF
05A7E:  MOVLB  0
05A80:  RCALL  58BC
05A82:  MOVFF  01,9F5
....................             if (response != RES_OK) 
05A86:  MOVLB  9
05A88:  MOVF   xF5,F
05A8A:  BZ    5A92
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05A8C:  MOVLW  00
05A8E:  MOVWF  01
05A90:  BRA    5C14
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05A92:  MOVLW  06
05A94:  MOVLB  7
05A96:  ADDWF  x0E,W
05A98:  MOVWF  FE9
05A9A:  MOVLW  00
05A9C:  ADDWFC x0F,W
05A9E:  MOVWF  FEA
05AA0:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05AA2:  MOVLW  10
05AA4:  ADDWF  x0E,W
05AA6:  MOVWF  FE9
05AA8:  MOVLW  00
05AAA:  ADDWFC x0F,W
05AAC:  MOVWF  FEA
05AAE:  MOVFF  FEF,9F7
05AB2:  MOVFF  FEC,9F8
05AB6:  MOVFF  FEC,9F9
05ABA:  MOVFF  FEC,9FA
05ABE:  MOVLW  08
05AC0:  ADDWF  x0E,W
05AC2:  MOVWF  FE9
05AC4:  MOVLW  00
05AC6:  ADDWFC x0F,W
05AC8:  MOVWF  FEA
05ACA:  MOVFF  FEF,00
05ACE:  MOVFF  FEC,01
05AD2:  MOVFF  FEC,02
05AD6:  MOVFF  FEC,03
05ADA:  MOVLB  9
05ADC:  MOVF   xF7,W
05ADE:  ADDWF  00,F
05AE0:  MOVF   xF8,W
05AE2:  ADDWFC 01,F
05AE4:  MOVF   xF9,W
05AE6:  ADDWFC 02,F
05AE8:  MOVF   xFA,W
05AEA:  ADDWFC 03,F
05AEC:  MOVF   xF4,W
05AEE:  SUBWF  03,W
05AF0:  BNC   5B98
05AF2:  BNZ   5B0A
05AF4:  MOVF   xF3,W
05AF6:  SUBWF  02,W
05AF8:  BNC   5B98
05AFA:  BNZ   5B0A
05AFC:  MOVF   xF2,W
05AFE:  SUBWF  01,W
05B00:  BNC   5B98
05B02:  BNZ   5B0A
05B04:  MOVF   00,W
05B06:  SUBWF  xF1,W
05B08:  BC    5B98
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05B0A:  MOVLW  03
05B0C:  MOVLB  7
05B0E:  ADDWF  x0E,W
05B10:  MOVWF  FE9
05B12:  MOVLW  00
05B14:  ADDWFC x0F,W
05B16:  MOVWF  FEA
05B18:  MOVFF  FEF,9F6
05B1C:  MOVLB  9
05B1E:  MOVF   xF6,W
05B20:  SUBLW  01
05B22:  BC    5B98
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05B24:  MOVLW  08
05B26:  MOVLB  7
05B28:  ADDWF  x0E,W
05B2A:  MOVWF  FE9
05B2C:  MOVLW  00
05B2E:  ADDWFC x0F,W
05B30:  MOVWF  FEA
05B32:  MOVFF  FEF,00
05B36:  MOVFF  FEC,01
05B3A:  MOVFF  FEC,02
05B3E:  MOVFF  FEC,03
05B42:  MOVF   00,W
05B44:  MOVLB  9
05B46:  ADDWF  xF1,F
05B48:  MOVF   01,W
05B4A:  ADDWFC xF2,F
05B4C:  MOVF   02,W
05B4E:  ADDWFC xF3,F
05B50:  MOVF   03,W
05B52:  ADDWFC xF4,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05B54:  MOVLW  24
05B56:  MOVLB  7
05B58:  ADDWF  x0E,W
05B5A:  MOVWF  01
05B5C:  MOVLW  00
05B5E:  ADDWFC x0F,W
05B60:  MOVWF  03
05B62:  MOVFF  01,9F7
05B66:  MOVLB  9
05B68:  MOVWF  xF8
05B6A:  MOVWF  xFA
05B6C:  MOVFF  01,9F9
05B70:  MOVFF  9F4,9FE
05B74:  MOVFF  9F3,9FD
05B78:  MOVFF  9F2,9FC
05B7C:  MOVFF  9F1,9FB
05B80:  MOVLW  01
05B82:  MOVWF  xFF
05B84:  MOVLB  0
05B86:  RCALL  58BC
05B88:  MOVF   01,F
05B8A:  BZ    5B92
....................                      break; 
05B8C:  MOVLB  9
05B8E:  BRA    5B98
05B90:  MOVLB  0
05B92:  MOVLB  9
05B94:  DECF   xF6,F
05B96:  BRA    5B1E
05B98:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05B9A:  MOVLB  9
05B9C:  MOVF   xED,F
05B9E:  BNZ   5BAC
05BA0:  MOVF   xEE,F
05BA2:  BNZ   5BAC
05BA4:  MOVF   xEF,F
05BA6:  BNZ   5BAC
05BA8:  MOVF   xF0,F
05BAA:  BZ    5C10
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05BAC:  MOVLW  24
05BAE:  MOVLB  7
05BB0:  ADDWF  x0E,W
05BB2:  MOVWF  01
05BB4:  MOVLW  00
05BB6:  ADDWFC x0F,W
05BB8:  MOVWF  03
05BBA:  MOVFF  01,9F7
05BBE:  MOVLB  9
05BC0:  MOVWF  xF8
05BC2:  MOVWF  xFA
05BC4:  MOVFF  01,9F9
05BC8:  MOVFF  9F0,9FE
05BCC:  MOVFF  9EF,9FD
05BD0:  MOVFF  9EE,9FC
05BD4:  MOVFF  9ED,9FB
05BD8:  MOVLW  01
05BDA:  MOVWF  xFF
05BDC:  MOVLB  0
05BDE:  CALL   4454
05BE2:  MOVF   01,F
05BE4:  BZ    5BF0
....................             return FALSE; 
05BE6:  MOVLW  00
05BE8:  MOVWF  01
05BEA:  MOVLB  9
05BEC:  BRA    5C14
05BEE:  MOVLB  0
....................          fs->winsect = sector; 
05BF0:  MOVLW  20
05BF2:  MOVLB  7
05BF4:  ADDWF  x0E,W
05BF6:  MOVWF  FE9
05BF8:  MOVLW  00
05BFA:  ADDWFC x0F,W
05BFC:  MOVWF  FEA
05BFE:  MOVFF  9ED,FEF
05C02:  MOVFF  9EE,FEC
05C06:  MOVFF  9EF,FEC
05C0A:  MOVFF  9F0,FEC
05C0E:  MOVLB  9
....................          } 
....................       } 
....................    return (TRUE); 
05C10:  MOVLW  01
05C12:  MOVWF  01
05C14:  MOVLB  0
05C16:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05C3A:  MOVLB  9
05C3C:  MOVF   xDC,F
05C3E:  BNZ   5C50
05C40:  MOVF   xDB,F
05C42:  BNZ   5C50
05C44:  MOVF   xDA,F
05C46:  BNZ   5C50
05C48:  MOVF   xD9,W
05C4A:  SUBLW  01
05C4C:  BTFSC  FD8.0
05C4E:  BRA    5F60
05C50:  MOVLW  0C
05C52:  MOVLB  7
05C54:  ADDWF  x0E,W
05C56:  MOVWF  FE9
05C58:  MOVLW  00
05C5A:  ADDWFC x0F,W
05C5C:  MOVWF  FEA
05C5E:  MOVFF  FEF,00
05C62:  MOVFF  FEC,01
05C66:  MOVFF  FEC,02
05C6A:  MOVFF  FEC,03
05C6E:  MOVLB  9
05C70:  MOVF   xDC,W
05C72:  SUBWF  03,W
05C74:  BTFSS  FD8.0
05C76:  BRA    5F60
05C78:  BNZ   5C96
05C7A:  MOVF   xDB,W
05C7C:  SUBWF  02,W
05C7E:  BTFSS  FD8.0
05C80:  BRA    5F60
05C82:  BNZ   5C96
05C84:  MOVF   xDA,W
05C86:  SUBWF  01,W
05C88:  BTFSS  FD8.0
05C8A:  BRA    5F60
05C8C:  BNZ   5C96
05C8E:  MOVF   00,W
05C90:  SUBWF  xD9,W
05C92:  BTFSC  FD8.0
05C94:  BRA    5F60
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05C96:  MOVLW  10
05C98:  MOVLB  7
05C9A:  ADDWF  x0E,W
05C9C:  MOVWF  FE9
05C9E:  MOVLW  00
05CA0:  ADDWFC x0F,W
05CA2:  MOVWF  FEA
05CA4:  MOVFF  FEF,9E1
05CA8:  MOVFF  FEC,9E2
05CAC:  MOVFF  FEC,9E3
05CB0:  MOVFF  FEC,9E4
....................       switch (fs->fs_type)  
05CB4:  MOVF   x0E,W
05CB6:  MOVWF  FE9
05CB8:  MOVF   x0F,W
05CBA:  MOVWF  FEA
05CBC:  MOVF   FEF,W
05CBE:  XORLW  01
05CC0:  MOVLB  0
05CC2:  BZ    5CD2
05CC4:  XORLW  03
05CC6:  BTFSC  FD8.2
05CC8:  BRA    5E18
05CCA:  XORLW  01
05CCC:  BTFSC  FD8.2
05CCE:  BRA    5E9A
05CD0:  BRA    5F62
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05CD2:  MOVFF  9DA,9EA
05CD6:  MOVFF  9D9,9E9
05CDA:  MOVLB  9
05CDC:  CLRF   xEC
05CDE:  MOVLW  03
05CE0:  MOVWF  xEB
05CE2:  MOVLB  0
05CE4:  RCALL  5C18
05CE6:  BCF    FD8.0
05CE8:  MOVLB  9
05CEA:  RRCF   02,W
05CEC:  MOVWF  xE0
05CEE:  RRCF   01,W
05CF0:  MOVWF  xDF
....................             if (!move_window(fatsect + bc / 512))  
05CF2:  BCF    FD8.0
05CF4:  CLRF   03
05CF6:  RRCF   xE0,W
05CF8:  MOVWF  02
05CFA:  ADDWF  xE1,W
05CFC:  MOVWF  xE5
05CFE:  MOVF   03,W
05D00:  ADDWFC xE2,W
05D02:  MOVWF  xE6
05D04:  MOVLW  00
05D06:  ADDWFC xE3,W
05D08:  MOVWF  xE7
05D0A:  MOVLW  00
05D0C:  ADDWFC xE4,W
05D0E:  MOVWF  xE8
05D10:  MOVWF  xF0
05D12:  MOVFF  9E7,9EF
05D16:  MOVFF  9E6,9EE
05D1A:  MOVFF  9E5,9ED
05D1E:  MOVLB  0
05D20:  RCALL  5A02
05D22:  MOVF   01,F
05D24:  BNZ   5D28
....................                break; 
05D26:  BRA    5F62
....................             wc = fs->win[bc % 512]; 
05D28:  MOVLB  9
05D2A:  MOVF   xE0,W
05D2C:  ANDLW  01
05D2E:  MOVWF  xE6
05D30:  MOVLW  24
05D32:  ADDWF  xDF,W
05D34:  MOVWF  01
05D36:  MOVLW  00
05D38:  ADDWFC xE6,W
05D3A:  MOVWF  03
05D3C:  MOVF   01,W
05D3E:  MOVLB  7
05D40:  ADDWF  x0E,W
05D42:  MOVWF  FE9
05D44:  MOVF   x0F,W
05D46:  ADDWFC 03,W
05D48:  MOVWF  FEA
05D4A:  MOVLB  9
05D4C:  CLRF   xDE
05D4E:  MOVFF  FEF,9DD
....................             bc++; 
05D52:  INCF   xDF,F
05D54:  BTFSC  FD8.2
05D56:  INCF   xE0,F
....................             if (!move_window(fatsect + bc / 512))  
05D58:  BCF    FD8.0
05D5A:  CLRF   03
05D5C:  RRCF   xE0,W
05D5E:  MOVWF  02
05D60:  ADDWF  xE1,W
05D62:  MOVWF  xE5
05D64:  MOVF   03,W
05D66:  ADDWFC xE2,W
05D68:  MOVWF  xE6
05D6A:  MOVLW  00
05D6C:  ADDWFC xE3,W
05D6E:  MOVWF  xE7
05D70:  MOVLW  00
05D72:  ADDWFC xE4,W
05D74:  MOVWF  xE8
05D76:  MOVWF  xF0
05D78:  MOVFF  9E7,9EF
05D7C:  MOVFF  9E6,9EE
05D80:  MOVFF  9E5,9ED
05D84:  MOVLB  0
05D86:  RCALL  5A02
05D88:  MOVF   01,F
05D8A:  BNZ   5D8E
....................                break; 
05D8C:  BRA    5F62
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05D8E:  MOVLB  9
05D90:  MOVF   xE0,W
05D92:  ANDLW  01
05D94:  MOVWF  xE6
05D96:  MOVLW  24
05D98:  ADDWF  xDF,W
05D9A:  MOVWF  01
05D9C:  MOVLW  00
05D9E:  ADDWFC xE6,W
05DA0:  MOVWF  03
05DA2:  MOVF   01,W
05DA4:  MOVLB  7
05DA6:  ADDWF  x0E,W
05DA8:  MOVWF  FE9
05DAA:  MOVF   x0F,W
05DAC:  ADDWFC 03,W
05DAE:  MOVWF  FEA
05DB0:  MOVF   FEF,W
05DB2:  MOVLB  9
05DB4:  MOVWF  xE7
05DB6:  MOVLW  00
05DB8:  IORWF  xDD,F
05DBA:  MOVF   xE7,W
05DBC:  IORWF  xDE,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05DBE:  MOVF   xD9,W
05DC0:  ANDLW  01
05DC2:  MOVWF  00
05DC4:  CLRF   01
05DC6:  CLRF   02
05DC8:  CLRF   03
05DCA:  MOVF   00,F
05DCC:  BNZ   5DDA
05DCE:  MOVF   01,F
05DD0:  BNZ   5DDA
05DD2:  MOVF   02,F
05DD4:  BNZ   5DDA
05DD6:  MOVF   03,F
05DD8:  BZ    5E00
05DDA:  RRCF   xDE,W
05DDC:  MOVWF  03
05DDE:  RRCF   xDD,W
05DE0:  MOVWF  02
05DE2:  RRCF   03,F
05DE4:  RRCF   02,F
05DE6:  RRCF   03,F
05DE8:  RRCF   02,F
05DEA:  RRCF   03,F
05DEC:  RRCF   02,F
05DEE:  MOVLW  0F
05DF0:  ANDWF  03,F
05DF2:  MOVFF  02,00
05DF6:  MOVFF  03,01
05DFA:  CLRF   02
05DFC:  CLRF   03
05DFE:  BRA    5E14
05E00:  MOVFF  9DD,00
05E04:  MOVF   xDE,W
05E06:  ANDLW  0F
05E08:  MOVWF  03
05E0A:  MOVF   xDD,W
05E0C:  MOVFF  03,01
05E10:  CLRF   02
05E12:  CLRF   03
05E14:  BRA    5F6E
05E16:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05E18:  MOVFF  9DA,00
05E1C:  MOVFF  9DB,01
05E20:  MOVFF  9DC,02
05E24:  CLRF   03
05E26:  MOVF   00,W
05E28:  MOVLB  9
05E2A:  ADDWF  xE1,W
05E2C:  MOVWF  xE5
05E2E:  MOVF   xDB,W
05E30:  ADDWFC xE2,W
05E32:  MOVWF  xE6
05E34:  MOVF   xDC,W
05E36:  ADDWFC xE3,W
05E38:  MOVWF  xE7
05E3A:  MOVF   03,W
05E3C:  ADDWFC xE4,W
05E3E:  MOVWF  xE8
05E40:  MOVWF  xF0
05E42:  MOVFF  9E7,9EF
05E46:  MOVFF  9E6,9EE
05E4A:  MOVFF  9E5,9ED
05E4E:  MOVLB  0
05E50:  RCALL  5A02
05E52:  MOVF   01,F
05E54:  BNZ   5E58
....................                break; 
05E56:  BRA    5F62
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05E58:  BCF    FD8.0
05E5A:  MOVLB  9
05E5C:  RLCF   xD9,W
05E5E:  MOVWF  xE5
05E60:  RLCF   xDA,W
05E62:  MOVWF  xE6
05E64:  MOVLW  01
05E66:  ANDWF  xE6,F
05E68:  MOVLW  24
05E6A:  ADDWF  xE5,W
05E6C:  MOVWF  01
05E6E:  MOVLW  00
05E70:  ADDWFC xE6,W
05E72:  MOVWF  03
05E74:  MOVF   01,W
05E76:  MOVLB  7
05E78:  ADDWF  x0E,W
05E7A:  MOVWF  01
05E7C:  MOVF   x0F,W
05E7E:  ADDWFC 03,F
05E80:  MOVFF  01,FE9
05E84:  MOVFF  03,FEA
05E88:  MOVFF  FEF,00
05E8C:  MOVFF  FEC,01
05E90:  CLRF   02
05E92:  CLRF   03
05E94:  MOVLB  9
05E96:  BRA    5F6E
05E98:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05E9A:  MOVLB  9
05E9C:  RRCF   xDC,W
05E9E:  MOVWF  03
05EA0:  RRCF   xDB,W
05EA2:  MOVWF  02
05EA4:  RRCF   xDA,W
05EA6:  MOVWF  01
05EA8:  RRCF   xD9,W
05EAA:  MOVWF  00
05EAC:  RRCF   03,F
05EAE:  RRCF   02,F
05EB0:  RRCF   01,F
05EB2:  RRCF   00,F
05EB4:  RRCF   03,F
05EB6:  RRCF   02,F
05EB8:  RRCF   01,F
05EBA:  RRCF   00,F
05EBC:  RRCF   03,F
05EBE:  RRCF   02,F
05EC0:  RRCF   01,F
05EC2:  RRCF   00,F
05EC4:  RRCF   03,F
05EC6:  RRCF   02,F
05EC8:  RRCF   01,F
05ECA:  RRCF   00,F
05ECC:  RRCF   03,F
05ECE:  RRCF   02,F
05ED0:  RRCF   01,F
05ED2:  RRCF   00,F
05ED4:  RRCF   03,F
05ED6:  RRCF   02,F
05ED8:  RRCF   01,F
05EDA:  RRCF   00,F
05EDC:  MOVLW  01
05EDE:  ANDWF  03,F
05EE0:  MOVF   00,W
05EE2:  ADDWF  xE1,W
05EE4:  MOVWF  xE5
05EE6:  MOVF   01,W
05EE8:  ADDWFC xE2,W
05EEA:  MOVWF  xE6
05EEC:  MOVF   02,W
05EEE:  ADDWFC xE3,W
05EF0:  MOVWF  xE7
05EF2:  MOVF   03,W
05EF4:  ADDWFC xE4,W
05EF6:  MOVWF  xE8
05EF8:  MOVWF  xF0
05EFA:  MOVFF  9E7,9EF
05EFE:  MOVFF  9E6,9EE
05F02:  MOVFF  9E5,9ED
05F06:  MOVLB  0
05F08:  RCALL  5A02
05F0A:  MOVF   01,F
05F0C:  BNZ   5F10
....................                break; 
05F0E:  BRA    5F62
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05F10:  MOVLB  9
05F12:  RLCF   xD9,W
05F14:  MOVWF  xE5
05F16:  RLCF   xDA,W
05F18:  MOVWF  xE6
05F1A:  RLCF   xE5,F
05F1C:  RLCF   xE6,F
05F1E:  MOVLW  FC
05F20:  ANDWF  xE5,F
05F22:  MOVLW  01
05F24:  ANDWF  xE6,F
05F26:  MOVLW  24
05F28:  ADDWF  xE5,W
05F2A:  MOVWF  01
05F2C:  MOVLW  00
05F2E:  ADDWFC xE6,W
05F30:  MOVWF  03
05F32:  MOVF   01,W
05F34:  MOVLB  7
05F36:  ADDWF  x0E,W
05F38:  MOVWF  01
05F3A:  MOVF   x0F,W
05F3C:  ADDWFC 03,F
05F3E:  MOVFF  01,FE9
05F42:  MOVFF  03,FEA
05F46:  MOVFF  FEF,00
05F4A:  MOVFF  FEC,01
05F4E:  MOVFF  FEC,02
05F52:  MOVFF  FEC,9EA
05F56:  MOVLB  9
05F58:  MOVF   xEA,W
05F5A:  ANDLW  0F
05F5C:  MOVWF  03
05F5E:  BRA    5F6E
05F60:  MOVLB  0
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
05F62:  MOVLW  01
05F64:  MOVWF  00
05F66:  CLRF   01
05F68:  CLRF   02
05F6A:  CLRF   03
05F6C:  MOVLB  9
05F6E:  MOVLB  0
05F70:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
06534:  MOVLW  10
06536:  MOVLB  7
06538:  ADDWF  x0E,W
0653A:  MOVWF  FE9
0653C:  MOVLW  00
0653E:  ADDWFC x0F,W
06540:  MOVWF  FEA
06542:  MOVFF  FEF,9E5
06546:  MOVFF  FEC,9E6
0654A:  MOVFF  FEC,9E7
0654E:  MOVFF  FEC,9E8
....................    switch (fs->fs_type)  
06552:  MOVF   x0E,W
06554:  MOVWF  FE9
06556:  MOVF   x0F,W
06558:  MOVWF  FEA
0655A:  MOVF   FEF,W
0655C:  XORLW  01
0655E:  MOVLB  0
06560:  BZ    6570
06562:  XORLW  03
06564:  BTFSC  FD8.2
06566:  BRA    6748
06568:  XORLW  01
0656A:  BTFSC  FD8.2
0656C:  BRA    67CC
0656E:  BRA    6894
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
06570:  MOVFF  9DA,9EA
06574:  MOVFF  9D9,9E9
06578:  MOVLB  9
0657A:  CLRF   xEC
0657C:  MOVLW  03
0657E:  MOVWF  xEB
06580:  MOVLB  0
06582:  CALL   5C18
06586:  BCF    FD8.0
06588:  MOVLB  9
0658A:  RRCF   02,W
0658C:  MOVWF  xE2
0658E:  RRCF   01,W
06590:  MOVWF  xE1
....................          if (!move_window(fatsect + bc / 512)) 
06592:  BCF    FD8.0
06594:  CLRF   03
06596:  RRCF   xE2,W
06598:  MOVWF  02
0659A:  ADDWF  xE5,W
0659C:  MOVWF  xE9
0659E:  MOVF   03,W
065A0:  ADDWFC xE6,W
065A2:  MOVWF  xEA
065A4:  MOVLW  00
065A6:  ADDWFC xE7,W
065A8:  MOVWF  xEB
065AA:  MOVLW  00
065AC:  ADDWFC xE8,W
065AE:  MOVWF  xEC
065B0:  MOVWF  xF0
065B2:  MOVFF  9EB,9EF
065B6:  MOVFF  9EA,9EE
065BA:  MOVFF  9E9,9ED
065BE:  MOVLB  0
065C0:  CALL   5A02
065C4:  MOVF   01,F
065C6:  BNZ   65CE
....................             return (FALSE); 
065C8:  MOVLW  00
065CA:  MOVWF  01
065CC:  BRA    68B2
....................          p = &fs->win[bc % 512]; 
065CE:  MOVLB  9
065D0:  MOVF   xE2,W
065D2:  ANDLW  01
065D4:  MOVWF  xEA
065D6:  MOVLW  24
065D8:  ADDWF  xE1,W
065DA:  MOVWF  01
065DC:  MOVLW  00
065DE:  ADDWFC xEA,W
065E0:  MOVWF  03
065E2:  MOVF   01,W
065E4:  MOVLB  7
065E6:  ADDWF  x0E,W
065E8:  MOVWF  01
065EA:  MOVF   x0F,W
065EC:  ADDWFC 03,F
065EE:  MOVFF  01,9E3
065F2:  MOVLB  9
065F4:  MOVFF  03,9E4
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
065F8:  MOVFF  9E3,9E9
065FC:  MOVFF  9E4,9EA
06600:  MOVF   xD9,W
06602:  ANDLW  01
06604:  MOVWF  00
06606:  CLRF   01
06608:  CLRF   02
0660A:  CLRF   03
0660C:  MOVF   00,F
0660E:  BNZ   661C
06610:  MOVF   01,F
06612:  BNZ   661C
06614:  MOVF   02,F
06616:  BNZ   661C
06618:  MOVF   03,F
0661A:  BZ    663C
0661C:  MOVFF  9E4,03
06620:  MOVFF  9E3,FE9
06624:  MOVFF  9E4,FEA
06628:  MOVF   FEF,W
0662A:  ANDLW  0F
0662C:  MOVWF  xEB
0662E:  SWAPF  xDD,W
06630:  MOVWF  00
06632:  MOVLW  F0
06634:  ANDWF  00,F
06636:  MOVF   00,W
06638:  IORWF  xEB,W
0663A:  BRA    663E
0663C:  MOVF   xDD,W
0663E:  MOVFF  9EA,FEA
06642:  MOVFF  9E9,FE9
06646:  MOVWF  FEF
....................          fs->winflag = 1; 
06648:  MOVLW  06
0664A:  MOVLB  7
0664C:  ADDWF  x0E,W
0664E:  MOVWF  FE9
06650:  MOVLW  00
06652:  ADDWFC x0F,W
06654:  MOVWF  FEA
06656:  MOVLW  01
06658:  MOVWF  FEF
....................          bc++; 
0665A:  MOVLB  9
0665C:  INCF   xE1,F
0665E:  BTFSC  FD8.2
06660:  INCF   xE2,F
....................          if (!move_window(fatsect + bc / 512)) 
06662:  BCF    FD8.0
06664:  CLRF   03
06666:  RRCF   xE2,W
06668:  MOVWF  02
0666A:  ADDWF  xE5,W
0666C:  MOVWF  xE9
0666E:  MOVF   03,W
06670:  ADDWFC xE6,W
06672:  MOVWF  xEA
06674:  MOVLW  00
06676:  ADDWFC xE7,W
06678:  MOVWF  xEB
0667A:  MOVLW  00
0667C:  ADDWFC xE8,W
0667E:  MOVWF  xEC
06680:  MOVWF  xF0
06682:  MOVFF  9EB,9EF
06686:  MOVFF  9EA,9EE
0668A:  MOVFF  9E9,9ED
0668E:  MOVLB  0
06690:  CALL   5A02
06694:  MOVF   01,F
06696:  BNZ   669E
....................             return (FALSE); 
06698:  MOVLW  00
0669A:  MOVWF  01
0669C:  BRA    68B2
....................          p = &fs->win[bc % 512]; 
0669E:  MOVLB  9
066A0:  MOVF   xE2,W
066A2:  ANDLW  01
066A4:  MOVWF  xEA
066A6:  MOVLW  24
066A8:  ADDWF  xE1,W
066AA:  MOVWF  01
066AC:  MOVLW  00
066AE:  ADDWFC xEA,W
066B0:  MOVWF  03
066B2:  MOVF   01,W
066B4:  MOVLB  7
066B6:  ADDWF  x0E,W
066B8:  MOVWF  01
066BA:  MOVF   x0F,W
066BC:  ADDWFC 03,F
066BE:  MOVFF  01,9E3
066C2:  MOVLB  9
066C4:  MOVFF  03,9E4
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
066C8:  MOVFF  9E3,9E9
066CC:  MOVFF  9E4,9EA
066D0:  MOVF   xD9,W
066D2:  ANDLW  01
066D4:  MOVWF  00
066D6:  CLRF   01
066D8:  CLRF   02
066DA:  CLRF   03
066DC:  MOVF   00,F
066DE:  BNZ   66EC
066E0:  MOVF   01,F
066E2:  BNZ   66EC
066E4:  MOVF   02,F
066E6:  BNZ   66EC
066E8:  MOVF   03,F
066EA:  BZ    671C
066EC:  RRCF   xE0,W
066EE:  MOVWF  03
066F0:  RRCF   xDF,W
066F2:  MOVWF  02
066F4:  RRCF   xDE,W
066F6:  MOVWF  01
066F8:  RRCF   xDD,W
066FA:  MOVWF  00
066FC:  RRCF   03,F
066FE:  RRCF   02,F
06700:  RRCF   01,F
06702:  RRCF   00,F
06704:  RRCF   03,F
06706:  RRCF   02,F
06708:  RRCF   01,F
0670A:  RRCF   00,F
0670C:  RRCF   03,F
0670E:  RRCF   02,F
06710:  RRCF   01,F
06712:  RRCF   00,F
06714:  MOVLW  0F
06716:  ANDWF  03,F
06718:  MOVF   00,W
0671A:  BRA    673C
0671C:  MOVFF  9E3,FE9
06720:  MOVFF  9E4,FEA
06724:  MOVF   FEF,W
06726:  ANDLW  F0
06728:  MOVWF  xEC
0672A:  MOVFF  9DE,00
0672E:  MOVFF  9DF,01
06732:  MOVFF  9E0,02
06736:  MOVF   xDE,W
06738:  ANDLW  0F
0673A:  IORWF  xEC,W
0673C:  MOVFF  9EA,FEA
06740:  MOVFF  9E9,FE9
06744:  MOVWF  FEF
....................          break; 
06746:  BRA    689C
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
06748:  MOVFF  9DA,00
0674C:  MOVFF  9DB,01
06750:  MOVFF  9DC,02
06754:  CLRF   03
06756:  MOVF   00,W
06758:  MOVLB  9
0675A:  ADDWF  xE5,W
0675C:  MOVWF  xE9
0675E:  MOVF   xDB,W
06760:  ADDWFC xE6,W
06762:  MOVWF  xEA
06764:  MOVF   xDC,W
06766:  ADDWFC xE7,W
06768:  MOVWF  xEB
0676A:  MOVF   03,W
0676C:  ADDWFC xE8,W
0676E:  MOVWF  xEC
06770:  MOVWF  xF0
06772:  MOVFF  9EB,9EF
06776:  MOVFF  9EA,9EE
0677A:  MOVFF  9E9,9ED
0677E:  MOVLB  0
06780:  CALL   5A02
06784:  MOVF   01,F
06786:  BNZ   678E
....................             return (FALSE); 
06788:  MOVLW  00
0678A:  MOVWF  01
0678C:  BRA    68B2
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
0678E:  BCF    FD8.0
06790:  MOVLB  9
06792:  RLCF   xD9,W
06794:  MOVWF  xE9
06796:  RLCF   xDA,W
06798:  MOVWF  xEA
0679A:  MOVLW  01
0679C:  ANDWF  xEA,F
0679E:  MOVLW  24
067A0:  ADDWF  xE9,W
067A2:  MOVWF  01
067A4:  MOVLW  00
067A6:  ADDWFC xEA,W
067A8:  MOVWF  03
067AA:  MOVF   01,W
067AC:  MOVLB  7
067AE:  ADDWF  x0E,W
067B0:  MOVWF  01
067B2:  MOVF   x0F,W
067B4:  ADDWFC 03,F
067B6:  MOVFF  01,FE9
067BA:  MOVFF  03,FEA
067BE:  MOVFF  9DE,FEC
067C2:  MOVF   FED,F
067C4:  MOVFF  9DD,FEF
....................          break; 
067C8:  MOVLB  9
067CA:  BRA    689C
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
067CC:  MOVLB  9
067CE:  RRCF   xDC,W
067D0:  MOVWF  03
067D2:  RRCF   xDB,W
067D4:  MOVWF  02
067D6:  RRCF   xDA,W
067D8:  MOVWF  01
067DA:  RRCF   xD9,W
067DC:  MOVWF  00
067DE:  RRCF   03,F
067E0:  RRCF   02,F
067E2:  RRCF   01,F
067E4:  RRCF   00,F
067E6:  RRCF   03,F
067E8:  RRCF   02,F
067EA:  RRCF   01,F
067EC:  RRCF   00,F
067EE:  RRCF   03,F
067F0:  RRCF   02,F
067F2:  RRCF   01,F
067F4:  RRCF   00,F
067F6:  RRCF   03,F
067F8:  RRCF   02,F
067FA:  RRCF   01,F
067FC:  RRCF   00,F
067FE:  RRCF   03,F
06800:  RRCF   02,F
06802:  RRCF   01,F
06804:  RRCF   00,F
06806:  RRCF   03,F
06808:  RRCF   02,F
0680A:  RRCF   01,F
0680C:  RRCF   00,F
0680E:  MOVLW  01
06810:  ANDWF  03,F
06812:  MOVF   00,W
06814:  ADDWF  xE5,W
06816:  MOVWF  xE9
06818:  MOVF   01,W
0681A:  ADDWFC xE6,W
0681C:  MOVWF  xEA
0681E:  MOVF   02,W
06820:  ADDWFC xE7,W
06822:  MOVWF  xEB
06824:  MOVF   03,W
06826:  ADDWFC xE8,W
06828:  MOVWF  xEC
0682A:  MOVWF  xF0
0682C:  MOVFF  9EB,9EF
06830:  MOVFF  9EA,9EE
06834:  MOVFF  9E9,9ED
06838:  MOVLB  0
0683A:  CALL   5A02
0683E:  MOVF   01,F
06840:  BNZ   6848
....................             return (FALSE); 
06842:  MOVLW  00
06844:  MOVWF  01
06846:  BRA    68B2
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
06848:  MOVLB  9
0684A:  RLCF   xD9,W
0684C:  MOVWF  xE9
0684E:  RLCF   xDA,W
06850:  MOVWF  xEA
06852:  RLCF   xE9,F
06854:  RLCF   xEA,F
06856:  MOVLW  FC
06858:  ANDWF  xE9,F
0685A:  MOVLW  01
0685C:  ANDWF  xEA,F
0685E:  MOVLW  24
06860:  ADDWF  xE9,W
06862:  MOVWF  01
06864:  MOVLW  00
06866:  ADDWFC xEA,W
06868:  MOVWF  03
0686A:  MOVF   01,W
0686C:  MOVLB  7
0686E:  ADDWF  x0E,W
06870:  MOVWF  01
06872:  MOVF   x0F,W
06874:  ADDWFC 03,F
06876:  MOVFF  01,FE9
0687A:  MOVFF  03,FEA
0687E:  MOVFF  9DD,FEF
06882:  MOVFF  9DE,FEC
06886:  MOVFF  9DF,FEC
0688A:  MOVFF  9E0,FEC
....................          break; 
0688E:  MOVLB  9
06890:  BRA    689C
06892:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
06894:  MOVLW  00
06896:  MOVWF  01
06898:  BRA    68B2
0689A:  MOVLB  9
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
0689C:  MOVLW  06
0689E:  MOVLB  7
068A0:  ADDWF  x0E,W
068A2:  MOVWF  FE9
068A4:  MOVLW  00
068A6:  ADDWFC x0F,W
068A8:  MOVWF  FEA
068AA:  MOVLW  01
068AC:  MOVWF  FEF
....................    return (TRUE); 
068AE:  MOVWF  01
068B0:  MOVLB  0
068B2:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06E8E:  MOVFF  9BB,9DC
06E92:  MOVFF  9BA,9DB
06E96:  MOVFF  9B9,9DA
06E9A:  MOVFF  9B8,9D9
06E9E:  CALL   5C3A
06EA2:  MOVFF  03,9BF
06EA6:  MOVFF  02,9BE
06EAA:  MOVFF  01,9BD
06EAE:  MOVFF  00,9BC
06EB2:  MOVLB  9
06EB4:  MOVF   xBF,F
06EB6:  BNZ   6EC6
06EB8:  MOVF   xBE,F
06EBA:  BNZ   6EC6
06EBC:  MOVF   xBD,F
06EBE:  BNZ   6EC6
06EC0:  MOVF   xBC,W
06EC2:  SUBLW  01
06EC4:  BC    6F26
....................       { 
....................       if (!put_cluster(clust, 0)) 
06EC6:  MOVFF  9BB,9DC
06ECA:  MOVFF  9BA,9DB
06ECE:  MOVFF  9B9,9DA
06ED2:  MOVFF  9B8,9D9
06ED6:  CLRF   xE0
06ED8:  CLRF   xDF
06EDA:  CLRF   xDE
06EDC:  CLRF   xDD
06EDE:  MOVLB  0
06EE0:  CALL   6534
06EE4:  MOVF   01,F
06EE6:  BNZ   6EEE
....................          return FALSE; 
06EE8:  MOVLW  00
06EEA:  MOVWF  01
06EEC:  BRA    6F2C
....................       clust = nxt; 
06EEE:  MOVFF  9BF,9BB
06EF2:  MOVFF  9BE,9BA
06EF6:  MOVFF  9BD,9B9
06EFA:  MOVFF  9BC,9B8
06EFE:  MOVFF  9BB,9DC
06F02:  MOVFF  9BA,9DB
06F06:  MOVFF  9B9,9DA
06F0A:  MOVFF  9B8,9D9
06F0E:  CALL   5C3A
06F12:  MOVFF  03,9BF
06F16:  MOVFF  02,9BE
06F1A:  MOVFF  01,9BD
06F1E:  MOVFF  00,9BC
06F22:  BRA    6EB2
06F24:  MOVLB  9
....................       } 
....................    return TRUE; 
06F26:  MOVLW  01
06F28:  MOVWF  01
06F2A:  MOVLB  0
06F2C:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
068B4:  MOVLW  0C
068B6:  MOVLB  7
068B8:  ADDWF  x0E,W
068BA:  MOVWF  FE9
068BC:  MOVLW  00
068BE:  ADDWFC x0F,W
068C0:  MOVWF  FEA
068C2:  MOVFF  FEF,9D5
068C6:  MOVFF  FEC,9D6
068CA:  MOVFF  FEC,9D7
068CE:  MOVFF  FEC,9D8
....................    if (clust == 0)  
068D2:  MOVLB  9
068D4:  MOVF   xC5,F
068D6:  BNZ   6940
068D8:  MOVF   xC6,F
068DA:  BNZ   6940
068DC:  MOVF   xC7,F
068DE:  BNZ   6940
068E0:  MOVF   xC8,F
068E2:  BNZ   6940
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
068E4:  MOVLW  1C
068E6:  MOVLB  7
068E8:  ADDWF  x0E,W
068EA:  MOVWF  FE9
068EC:  MOVLW  00
068EE:  ADDWFC x0F,W
068F0:  MOVWF  FEA
068F2:  MOVFF  FEF,9D1
068F6:  MOVFF  FEC,9D2
068FA:  MOVFF  FEC,9D3
068FE:  MOVFF  FEC,9D4
....................       if (scl < 2 || scl >= mcl) scl = 1; 
06902:  MOVLB  9
06904:  MOVF   xD4,F
06906:  BNZ   6916
06908:  MOVF   xD3,F
0690A:  BNZ   6916
0690C:  MOVF   xD2,F
0690E:  BNZ   6916
06910:  MOVF   xD1,W
06912:  SUBLW  01
06914:  BC    6934
06916:  MOVF   xD8,W
06918:  SUBWF  xD4,W
0691A:  BNC   693E
0691C:  BNZ   6934
0691E:  MOVF   xD7,W
06920:  SUBWF  xD3,W
06922:  BNC   693E
06924:  BNZ   6934
06926:  MOVF   xD6,W
06928:  SUBWF  xD2,W
0692A:  BNC   693E
0692C:  BNZ   6934
0692E:  MOVF   xD5,W
06930:  SUBWF  xD1,W
06932:  BNC   693E
06934:  CLRF   xD4
06936:  CLRF   xD3
06938:  CLRF   xD2
0693A:  MOVLW  01
0693C:  MOVWF  xD1
....................       } 
0693E:  BRA    69C4
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
06940:  MOVFF  9C8,9DC
06944:  MOVFF  9C7,9DB
06948:  MOVFF  9C6,9DA
0694C:  MOVFF  9C5,9D9
06950:  MOVLB  0
06952:  CALL   5C3A
06956:  MOVFF  03,9CC
0695A:  MOVFF  02,9CB
0695E:  MOVFF  01,9CA
06962:  MOVFF  00,9C9
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
06966:  MOVLB  9
06968:  MOVF   xCC,F
0696A:  BNZ   6984
0696C:  MOVF   xCB,F
0696E:  BNZ   6984
06970:  MOVF   xCA,F
06972:  BNZ   6984
06974:  MOVF   xC9,W
06976:  SUBLW  01
06978:  BNC   6984
0697A:  CLRF   00
0697C:  CLRF   01
0697E:  CLRF   02
06980:  CLRF   03
06982:  BRA    6B46
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
06984:  MOVF   xCC,W
06986:  SUBWF  xD8,W
06988:  BNC   69B4
0698A:  BNZ   69A2
0698C:  MOVF   xCB,W
0698E:  SUBWF  xD7,W
06990:  BNC   69B4
06992:  BNZ   69A2
06994:  MOVF   xCA,W
06996:  SUBWF  xD6,W
06998:  BNC   69B4
0699A:  BNZ   69A2
0699C:  MOVF   xD5,W
0699E:  SUBWF  xC9,W
069A0:  BC    69B4
069A2:  MOVFF  9C9,00
069A6:  MOVFF  9CA,01
069AA:  MOVFF  9CB,02
069AE:  MOVFF  9CC,03
069B2:  BRA    6B46
....................       scl = clust; 
069B4:  MOVFF  9C8,9D4
069B8:  MOVFF  9C7,9D3
069BC:  MOVFF  9C6,9D2
069C0:  MOVFF  9C5,9D1
....................       } 
....................       ncl = scl;                  // Scan start cluster 
069C4:  MOVFF  9D4,9D0
069C8:  MOVFF  9D3,9CF
069CC:  MOVFF  9D2,9CE
069D0:  MOVFF  9D1,9CD
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
069D4:  MOVLW  01
069D6:  ADDWF  xCD,F
069D8:  BTFSC  FD8.0
069DA:  INCF   xCE,F
069DC:  BTFSC  FD8.2
069DE:  INCF   xCF,F
069E0:  BTFSC  FD8.2
069E2:  INCF   xD0,F
....................       if (ncl >= mcl)  
069E4:  MOVF   xD8,W
069E6:  SUBWF  xD0,W
069E8:  BNC   6A26
069EA:  BNZ   6A02
069EC:  MOVF   xD7,W
069EE:  SUBWF  xCF,W
069F0:  BNC   6A26
069F2:  BNZ   6A02
069F4:  MOVF   xD6,W
069F6:  SUBWF  xCE,W
069F8:  BNC   6A26
069FA:  BNZ   6A02
069FC:  MOVF   xD5,W
069FE:  SUBWF  xCD,W
06A00:  BNC   6A26
....................          {         // Wrap around 
....................          ncl = 2; 
06A02:  CLRF   xD0
06A04:  CLRF   xCF
06A06:  CLRF   xCE
06A08:  MOVLW  02
06A0A:  MOVWF  xCD
....................          if (scl == 1) return 0;      // No free custer was found 
06A0C:  DECFSZ xD1,W
06A0E:  BRA    6A26
06A10:  MOVF   xD2,F
06A12:  BNZ   6A26
06A14:  MOVF   xD3,F
06A16:  BNZ   6A26
06A18:  MOVF   xD4,F
06A1A:  BNZ   6A26
06A1C:  CLRF   00
06A1E:  CLRF   01
06A20:  CLRF   02
06A22:  CLRF   03
06A24:  BRA    6B46
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06A26:  MOVF   xD1,W
06A28:  SUBWF  xCD,W
06A2A:  BNZ   6A48
06A2C:  MOVF   xD2,W
06A2E:  SUBWF  xCE,W
06A30:  BNZ   6A48
06A32:  MOVF   xD3,W
06A34:  SUBWF  xCF,W
06A36:  BNZ   6A48
06A38:  MOVF   xD4,W
06A3A:  SUBWF  xD0,W
06A3C:  BNZ   6A48
06A3E:  CLRF   00
06A40:  CLRF   01
06A42:  CLRF   02
06A44:  CLRF   03
06A46:  BRA    6B46
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06A48:  MOVFF  9D0,9DC
06A4C:  MOVFF  9CF,9DB
06A50:  MOVFF  9CE,9DA
06A54:  MOVFF  9CD,9D9
06A58:  MOVLB  0
06A5A:  CALL   5C3A
06A5E:  MOVFF  03,9CC
06A62:  MOVFF  02,9CB
06A66:  MOVFF  01,9CA
06A6A:  MOVFF  00,9C9
....................       if (cstat == 1) return 0;      // Any error occured 
06A6E:  MOVLB  9
06A70:  DECFSZ xC9,W
06A72:  BRA    6A8A
06A74:  MOVF   xCA,F
06A76:  BNZ   6A8A
06A78:  MOVF   xCB,F
06A7A:  BNZ   6A8A
06A7C:  MOVF   xCC,F
06A7E:  BNZ   6A8A
06A80:  CLRF   00
06A82:  CLRF   01
06A84:  CLRF   02
06A86:  CLRF   03
06A88:  BRA    6B46
....................       } while (cstat);            // Repeat until find a free cluster 
06A8A:  MOVF   xC9,F
06A8C:  BNZ   69D4
06A8E:  MOVF   xCA,F
06A90:  BNZ   69D4
06A92:  MOVF   xCB,F
06A94:  BNZ   69D4
06A96:  MOVF   xCC,F
06A98:  BNZ   69D4
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06A9A:  MOVFF  9D0,9DC
06A9E:  MOVFF  9CF,9DB
06AA2:  MOVFF  9CE,9DA
06AA6:  MOVFF  9CD,9D9
06AAA:  MOVLW  0F
06AAC:  MOVWF  xE0
06AAE:  SETF   xDF
06AB0:  SETF   xDE
06AB2:  SETF   xDD
06AB4:  MOVLB  0
06AB6:  RCALL  6534
06AB8:  MOVF   01,F
06ABA:  BNZ   6ACA
06ABC:  CLRF   00
06ABE:  CLRF   01
06AC0:  CLRF   02
06AC2:  CLRF   03
06AC4:  MOVLB  9
06AC6:  BRA    6B46
06AC8:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06ACA:  MOVLB  9
06ACC:  MOVF   xC5,F
06ACE:  BNZ   6ADC
06AD0:  MOVF   xC6,F
06AD2:  BNZ   6ADC
06AD4:  MOVF   xC7,F
06AD6:  BNZ   6ADC
06AD8:  MOVF   xC8,F
06ADA:  BZ    6B16
06ADC:  MOVFF  9C8,9DC
06AE0:  MOVFF  9C7,9DB
06AE4:  MOVFF  9C6,9DA
06AE8:  MOVFF  9C5,9D9
06AEC:  MOVFF  9D0,9E0
06AF0:  MOVFF  9CF,9DF
06AF4:  MOVFF  9CE,9DE
06AF8:  MOVFF  9CD,9DD
06AFC:  MOVLB  0
06AFE:  RCALL  6534
06B00:  MOVF   01,F
06B02:  BTFSC  FD8.2
06B04:  BRA    6B0A
06B06:  MOVLB  9
06B08:  BRA    6B16
06B0A:  CLRF   00
06B0C:  CLRF   01
06B0E:  CLRF   02
06B10:  CLRF   03
06B12:  MOVLB  9
06B14:  BRA    6B46
....................    fs->last_clust = ncl; 
06B16:  MOVLW  1C
06B18:  MOVLB  7
06B1A:  ADDWF  x0E,W
06B1C:  MOVWF  FE9
06B1E:  MOVLW  00
06B20:  ADDWFC x0F,W
06B22:  MOVWF  FEA
06B24:  MOVFF  9CD,FEF
06B28:  MOVFF  9CE,FEC
06B2C:  MOVFF  9CF,FEC
06B30:  MOVFF  9D0,FEC
....................  
....................    return ncl;      // Return new cluster number 
06B34:  MOVFF  9CD,00
06B38:  MOVFF  9CE,01
06B3C:  MOVFF  9CF,02
06B40:  MOVFF  9D0,03
06B44:  MOVLB  9
06B46:  MOVLB  0
06B48:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
0558C:  MOVLW  02
0558E:  MOVLB  9
05590:  SUBWF  xCC,F
05592:  MOVLW  00
05594:  SUBWFB xCD,F
05596:  SUBWFB xCE,F
05598:  SUBWFB xCF,F
....................    if (clust >= fs->max_clust)  
0559A:  MOVLW  0C
0559C:  MOVLB  7
0559E:  ADDWF  x0E,W
055A0:  MOVWF  FE9
055A2:  MOVLW  00
055A4:  ADDWFC x0F,W
055A6:  MOVWF  FEA
055A8:  MOVFF  FEF,00
055AC:  MOVFF  FEC,01
055B0:  MOVFF  FEC,02
055B4:  MOVFF  FEC,03
055B8:  MOVF   03,W
055BA:  MOVLB  9
055BC:  SUBWF  xCF,W
055BE:  BNC   55E2
055C0:  BNZ   55D8
055C2:  MOVF   02,W
055C4:  SUBWF  xCE,W
055C6:  BNC   55E2
055C8:  BNZ   55D8
055CA:  MOVF   01,W
055CC:  SUBWF  xCD,W
055CE:  BNC   55E2
055D0:  BNZ   55D8
055D2:  MOVF   00,W
055D4:  SUBWF  xCC,W
055D6:  BNC   55E2
....................       return 0;      // Invalid cluster#  
055D8:  CLRF   00
055DA:  CLRF   01
055DC:  CLRF   02
055DE:  CLRF   03
055E0:  BRA    5662
....................    return (clust * fs->sects_clust + fs->database); 
055E2:  MOVLW  02
055E4:  MOVLB  7
055E6:  ADDWF  x0E,W
055E8:  MOVWF  FE9
055EA:  MOVLW  00
055EC:  ADDWFC x0F,W
055EE:  MOVWF  FEA
055F0:  MOVFF  FEF,9D7
055F4:  MOVLB  9
055F6:  MOVFF  FEA,9D2
055FA:  MOVFF  FE9,9D1
055FE:  MOVFF  9CF,9D6
05602:  MOVFF  9CE,9D5
05606:  MOVFF  9CD,9D4
0560A:  MOVFF  9CC,9D3
0560E:  CLRF   xDA
05610:  CLRF   xD9
05612:  CLRF   xD8
05614:  MOVLB  0
05616:  CALL   477C
0561A:  MOVFF  9D2,FEA
0561E:  MOVFF  9D1,FE9
05622:  MOVFF  03,9D3
05626:  MOVFF  02,9D2
0562A:  MOVFF  01,9D1
0562E:  MOVFF  00,9D0
05632:  MOVLW  18
05634:  MOVLB  7
05636:  ADDWF  x0E,W
05638:  MOVWF  FE9
0563A:  MOVLW  00
0563C:  ADDWFC x0F,W
0563E:  MOVWF  FEA
05640:  MOVFF  FEF,00
05644:  MOVFF  FEC,01
05648:  MOVFF  FEC,02
0564C:  MOVFF  FEC,03
05650:  MOVLB  9
05652:  MOVF   xD0,W
05654:  ADDWF  00,F
05656:  MOVF   xD1,W
05658:  ADDWFC 01,F
0565A:  MOVF   xD2,W
0565C:  ADDWFC 02,F
0565E:  MOVF   xD3,W
05660:  ADDWFC 03,F
05662:  MOVLB  0
05664:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
04620:  MOVLW  24
04622:  MOVLB  7
04624:  ADDWF  x0E,W
04626:  MOVWF  01
04628:  MOVLW  00
0462A:  ADDWFC x0F,W
0462C:  MOVWF  03
0462E:  MOVFF  01,9C4
04632:  MOVLB  9
04634:  MOVWF  xC5
04636:  MOVWF  FEA
04638:  MOVFF  01,FE9
0463C:  CLRF   00
0463E:  MOVLW  02
04640:  MOVWF  02
04642:  CLRF   01
04644:  MOVLB  0
04646:  CALL   34AE
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
0464A:  MOVLW  24
0464C:  MOVLB  7
0464E:  ADDWF  x0E,W
04650:  MOVWF  01
04652:  MOVLW  00
04654:  ADDWFC x0F,W
04656:  MOVWF  03
04658:  MOVFF  01,9C4
0465C:  MOVLB  9
0465E:  MOVWF  xC5
04660:  MOVWF  xFA
04662:  MOVFF  01,9F9
04666:  MOVFF  9C3,9FE
0466A:  MOVFF  9C2,9FD
0466E:  MOVFF  9C1,9FC
04672:  MOVFF  9C0,9FB
04676:  MOVLW  01
04678:  MOVWF  xFF
0467A:  MOVLB  0
0467C:  RCALL  4454
0467E:  MOVF   01,F
04680:  BTFSS  FD8.2
04682:  BRA    4772
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
04684:  MOVLW  22
04686:  MOVLB  7
04688:  ADDWF  x0E,W
0468A:  MOVWF  01
0468C:  MOVLW  02
0468E:  ADDWFC x0F,W
04690:  MOVWF  03
04692:  MOVFF  01,FE9
04696:  MOVWF  FEA
04698:  MOVFF  FEC,9C5
0469C:  MOVF   FED,F
0469E:  MOVFF  FEF,9C4
046A2:  MOVLB  9
046A4:  MOVF   xC4,W
046A6:  SUBLW  55
046A8:  BNZ   4774
046AA:  MOVF   xC5,W
046AC:  SUBLW  AA
046AE:  BNZ   4774
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
046B0:  MOVLW  5A
046B2:  MOVLB  7
046B4:  ADDWF  x0E,W
046B6:  MOVWF  01
046B8:  MOVLW  00
046BA:  ADDWFC x0F,W
046BC:  MOVWF  03
046BE:  MOVFF  01,9C4
046C2:  MOVLB  9
046C4:  MOVWF  xC5
046C6:  MOVWF  xC7
046C8:  MOVFF  01,9C6
046CC:  MOVLW  07
046CE:  MOVWF  xC9
046D0:  MOVLW  10
046D2:  MOVWF  xC8
046D4:  CLRF   xCB
046D6:  MOVLW  05
046D8:  MOVWF  xCA
046DA:  MOVLB  0
046DC:  RCALL  459C
046DE:  MOVF   01,F
046E0:  BNZ   46E8
....................             return (FS_FAT12); 
046E2:  MOVLW  01
046E4:  MOVWF  01
046E6:  BRA    477A
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
046E8:  MOVLW  5A
046EA:  MOVLB  7
046EC:  ADDWF  x0E,W
046EE:  MOVWF  01
046F0:  MOVLW  00
046F2:  ADDWFC x0F,W
046F4:  MOVWF  03
046F6:  MOVFF  01,9C4
046FA:  MOVLB  9
046FC:  MOVWF  xC5
046FE:  MOVWF  xC7
04700:  MOVFF  01,9C6
04704:  MOVLW  07
04706:  MOVWF  xC9
04708:  MOVLW  15
0470A:  MOVWF  xC8
0470C:  CLRF   xCB
0470E:  MOVLW  05
04710:  MOVWF  xCA
04712:  MOVLB  0
04714:  RCALL  459C
04716:  MOVF   01,F
04718:  BNZ   4720
....................             return (FS_FAT16); 
0471A:  MOVLW  02
0471C:  MOVWF  01
0471E:  BRA    477A
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
04720:  MOVLW  76
04722:  MOVLB  7
04724:  ADDWF  x0E,W
04726:  MOVWF  01
04728:  MOVLW  00
0472A:  ADDWFC x0F,W
0472C:  MOVWF  03
0472E:  MOVFF  01,9C4
04732:  MOVLB  9
04734:  MOVWF  xC5
04736:  MOVWF  xC7
04738:  MOVFF  01,9C6
0473C:  MOVLW  07
0473E:  MOVWF  xC9
04740:  MOVLW  1A
04742:  MOVWF  xC8
04744:  CLRF   xCB
04746:  MOVLW  05
04748:  MOVWF  xCA
0474A:  MOVLB  0
0474C:  RCALL  459C
0474E:  MOVF   01,F
04750:  BNZ   4772
04752:  MOVLW  4C
04754:  MOVLB  7
04756:  ADDWF  x0E,W
04758:  MOVWF  FE9
0475A:  MOVLW  00
0475C:  ADDWFC x0F,W
0475E:  MOVWF  FEA
04760:  MOVF   FEF,F
04762:  BTFSC  FD8.2
04764:  BRA    476A
04766:  MOVLB  0
04768:  BRA    4772
....................             return (FS_FAT32); 
0476A:  MOVLW  03
0476C:  MOVWF  01
0476E:  MOVLB  0
04770:  BRA    477A
04772:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
04774:  MOVLW  00
04776:  MOVWF  01
04778:  MOVLB  0
0477A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
05F72:  MOVLW  0C
05F74:  MOVLB  9
05F76:  ADDWF  xC2,W
05F78:  MOVWF  FE9
05F7A:  MOVLW  00
05F7C:  ADDWFC xC3,W
05F7E:  MOVWF  FEA
05F80:  MOVFF  FEC,9CB
05F84:  MOVF   FED,F
05F86:  MOVFF  FEF,9CA
05F8A:  MOVLW  01
05F8C:  ADDWF  xCA,W
05F8E:  MOVWF  xC8
05F90:  MOVLW  00
05F92:  ADDWFC xCB,W
05F94:  MOVWF  xC9
....................    if ((idx & 15) == 0)  
05F96:  MOVF   xC8,W
05F98:  ANDLW  0F
05F9A:  MOVWF  xCA
05F9C:  CLRF   xCB
05F9E:  MOVF   xCA,F
05FA0:  BTFSS  FD8.2
05FA2:  BRA    612E
05FA4:  MOVF   xCB,F
05FA6:  BTFSS  FD8.2
05FA8:  BRA    612E
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
05FAA:  MOVLW  08
05FAC:  ADDWF  xC2,W
05FAE:  MOVWF  FE9
05FB0:  MOVLW  00
05FB2:  ADDWFC xC3,W
05FB4:  MOVWF  FEA
05FB6:  MOVLW  01
05FB8:  ADDWF  FEE,F
05FBA:  MOVLW  00
05FBC:  ADDWFC FEE,F
05FBE:  ADDWFC FEE,F
05FC0:  ADDWFC FED,F
....................       if (!scan->clust)  
05FC2:  MOVLW  04
05FC4:  ADDWF  xC2,W
05FC6:  MOVWF  FE9
05FC8:  MOVLW  00
05FCA:  ADDWFC xC3,W
05FCC:  MOVWF  FEA
05FCE:  MOVF   FEF,F
05FD0:  BNZ   600E
05FD2:  MOVF   FEC,F
05FD4:  BNZ   600E
05FD6:  MOVF   FEC,F
05FD8:  BNZ   600E
05FDA:  MOVF   FEC,F
05FDC:  BNZ   600E
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
05FDE:  MOVLW  04
05FE0:  MOVLB  7
05FE2:  ADDWF  x0E,W
05FE4:  MOVWF  FE9
05FE6:  MOVLW  00
05FE8:  ADDWFC x0F,W
05FEA:  MOVWF  FEA
05FEC:  MOVFF  FEC,03
05FF0:  MOVF   FED,F
05FF2:  MOVFF  FEF,01
05FF6:  MOVF   03,W
05FF8:  MOVLB  9
05FFA:  SUBWF  xC9,W
05FFC:  BNC   600C
05FFE:  BNZ   6006
06000:  MOVF   01,W
06002:  SUBWF  xC8,W
06004:  BNC   600C
....................             return (FALSE);   // Reached to end of table  
06006:  MOVLW  00
06008:  MOVWF  01
0600A:  BRA    6148
....................          }  
0600C:  BRA    612E
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
0600E:  RRCF   xC9,W
06010:  MOVWF  xCB
06012:  RRCF   xC8,W
06014:  MOVWF  xCA
06016:  RRCF   xCB,F
06018:  RRCF   xCA,F
0601A:  RRCF   xCB,F
0601C:  RRCF   xCA,F
0601E:  RRCF   xCB,F
06020:  RRCF   xCA,F
06022:  MOVLW  0F
06024:  ANDWF  xCB,F
06026:  MOVLW  02
06028:  MOVLB  7
0602A:  ADDWF  x0E,W
0602C:  MOVWF  FE9
0602E:  MOVLW  00
06030:  ADDWFC x0F,W
06032:  MOVWF  FEA
06034:  MOVLW  01
06036:  SUBWF  FEF,W
06038:  MOVLB  9
0603A:  ANDWF  xCA,F
0603C:  CLRF   xCB
0603E:  MOVF   xCA,F
06040:  BTFSS  FD8.2
06042:  BRA    612E
06044:  MOVF   xCB,F
06046:  BTFSS  FD8.2
06048:  BRA    612E
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
0604A:  MOVLW  04
0604C:  ADDWF  xC2,W
0604E:  MOVWF  FE9
06050:  MOVLW  00
06052:  ADDWFC xC3,W
06054:  MOVWF  FEA
06056:  MOVFF  FEF,9D9
0605A:  MOVFF  FEC,9DA
0605E:  MOVFF  FEC,9DB
06062:  MOVFF  FEC,9DC
06066:  MOVLB  0
06068:  RCALL  5C3A
0606A:  MOVFF  03,9C7
0606E:  MOVFF  02,9C6
06072:  MOVFF  01,9C5
06076:  MOVFF  00,9C4
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
0607A:  MOVLW  0C
0607C:  MOVLB  7
0607E:  ADDWF  x0E,W
06080:  MOVWF  FE9
06082:  MOVLW  00
06084:  ADDWFC x0F,W
06086:  MOVWF  FEA
06088:  MOVFF  FEF,00
0608C:  MOVFF  FEC,01
06090:  MOVFF  FEC,02
06094:  MOVFF  FEC,03
06098:  MOVF   03,W
0609A:  MOVLB  9
0609C:  SUBWF  xC7,W
0609E:  BNC   60B8
060A0:  BNZ   60CA
060A2:  MOVF   02,W
060A4:  SUBWF  xC6,W
060A6:  BNC   60B8
060A8:  BNZ   60CA
060AA:  MOVF   01,W
060AC:  SUBWF  xC5,W
060AE:  BNC   60B8
060B0:  BNZ   60CA
060B2:  MOVF   00,W
060B4:  SUBWF  xC4,W
060B6:  BC    60CA
060B8:  MOVF   xC7,F
060BA:  BNZ   60D0
060BC:  MOVF   xC6,F
060BE:  BNZ   60D0
060C0:  MOVF   xC5,F
060C2:  BNZ   60D0
060C4:  MOVF   xC4,W
060C6:  SUBLW  01
060C8:  BNC   60D0
....................                return (FALSE); 
060CA:  MOVLW  00
060CC:  MOVWF  01
060CE:  BRA    6148
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
060D0:  MOVLW  04
060D2:  ADDWF  xC2,W
060D4:  MOVWF  FE9
060D6:  MOVLW  00
060D8:  ADDWFC xC3,W
060DA:  MOVWF  FEA
060DC:  MOVFF  9C4,FEF
060E0:  MOVFF  9C5,FEC
060E4:  MOVFF  9C6,FEC
060E8:  MOVFF  9C7,FEC
....................             scan->sect = clust2sect(clust); 
060EC:  MOVLW  08
060EE:  ADDWF  xC2,W
060F0:  MOVWF  01
060F2:  MOVLW  00
060F4:  ADDWFC xC3,W
060F6:  MOVWF  03
060F8:  MOVFF  01,9CA
060FC:  MOVWF  xCB
060FE:  MOVFF  9C7,9CF
06102:  MOVFF  9C6,9CE
06106:  MOVFF  9C5,9CD
0610A:  MOVFF  9C4,9CC
0610E:  MOVLB  0
06110:  CALL   558C
06114:  MOVFF  9CB,FEA
06118:  MOVFF  9CA,FE9
0611C:  MOVFF  00,FEF
06120:  MOVFF  01,FEC
06124:  MOVFF  02,FEC
06128:  MOVFF  03,FEC
0612C:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
0612E:  MOVLW  0C
06130:  ADDWF  xC2,W
06132:  MOVWF  FE9
06134:  MOVLW  00
06136:  ADDWFC xC3,W
06138:  MOVWF  FEA
0613A:  MOVFF  9C9,FEC
0613E:  MOVF   FED,F
06140:  MOVFF  9C8,FEF
....................    return (TRUE); 
06144:  MOVLW  01
06146:  MOVWF  01
06148:  MOVLB  0
0614A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
05666:  MOVFF  9C5,FEA
0566A:  MOVFF  9C4,FE9
0566E:  MOVLW  20
05670:  MOVWF  00
05672:  CLRF   02
05674:  MOVLW  0B
05676:  MOVWF  01
05678:  CALL   34AE
....................    a = 0; b = 0x18;            // NT flag 
0567C:  MOVLB  9
0567E:  CLRF   xC9
05680:  MOVLW  18
05682:  MOVWF  xCA
....................    n = 0; t = 8; 
05684:  CLRF   xC6
05686:  MOVLW  08
05688:  MOVWF  xC7
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
0568A:  MOVFF  9C2,FE9
0568E:  MOVFF  9C3,FEA
05692:  MOVFF  FEC,9CC
05696:  MOVF   FED,F
05698:  MOVFF  FEF,9CB
....................       c = *ptr; 
0569C:  MOVFF  9CB,FE9
056A0:  MOVFF  9CC,FEA
056A4:  MOVFF  FEF,9C8
....................       (*path)++; 
056A8:  MOVFF  9C3,03
056AC:  MOVFF  9C2,FE9
056B0:  MOVFF  9C3,FEA
056B4:  MOVLW  01
056B6:  ADDWF  FEE,F
056B8:  BNC   56BC
056BA:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
056BC:  MOVF   xC8,W
056BE:  SUBLW  20
056C0:  BNC   56C4
....................          c = 0; 
056C2:  CLRF   xC8
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
056C4:  MOVF   xC8,F
056C6:  BZ    56D4
056C8:  MOVF   xC8,W
056CA:  SUBLW  2F
056CC:  BZ    56D4
056CE:  MOVF   xC8,W
056D0:  SUBLW  5C
056D2:  BNZ   56F2
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
056D4:  MOVF   xC6,F
056D6:  BNZ   56DA
....................             break; 
056D8:  BRA    57BA
....................          dirname[11] = a & b;  
056DA:  MOVLW  0B
056DC:  ADDWF  xC4,W
056DE:  MOVWF  FE9
056E0:  MOVLW  00
056E2:  ADDWFC xC5,W
056E4:  MOVWF  FEA
056E6:  MOVF   xC9,W
056E8:  ANDWF  xCA,W
056EA:  MOVWF  FEF
....................             return (c); 
056EC:  MOVFF  9C8,01
056F0:  BRA    57BE
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
056F2:  MOVF   xC8,W
056F4:  SUBLW  20
056F6:  BC    56FE
056F8:  MOVF   xC8,W
056FA:  SUBLW  7F
056FC:  BNZ   5700
....................          break;   // reject invisible characters 
056FE:  BRA    57BA
....................       if (c == '.')  
05700:  MOVF   xC8,W
05702:  SUBLW  2E
05704:  BNZ   5722
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
05706:  BTFSC  xC9.0
05708:  BRA    5720
0570A:  MOVF   xC6,W
0570C:  SUBLW  00
0570E:  BC    5720
05710:  MOVF   xC6,W
05712:  SUBLW  08
05714:  BNC   5720
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
05716:  MOVLW  08
05718:  MOVWF  xC6
0571A:  MOVLW  0B
0571C:  MOVWF  xC7
....................             continue; 
0571E:  BRA    57B8
....................             } 
....................          break; 
05720:  BRA    57BA
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
05722:  MOVF   xC8,W
05724:  SUBLW  22
05726:  BNZ   572A
....................          break;               // Reject "  
05728:  BRA    57BA
....................  
....................       if (c <= ')')  
0572A:  MOVF   xC8,W
0572C:  SUBLW  29
0572E:  BNC   5732
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
05730:  BRA    579C
....................  
....................       if (c <= ',') 
05732:  MOVF   xC8,W
05734:  SUBLW  2C
05736:  BNC   573A
....................          break;               // Reject * + ,  
05738:  BRA    57BA
....................  
....................       if (c <= '9')  
0573A:  MOVF   xC8,W
0573C:  SUBLW  39
0573E:  BNC   5742
....................          goto md_l1;            // Accept - 0-9  
05740:  BRA    579C
....................  
....................       if (c <= '?')  
05742:  MOVF   xC8,W
05744:  SUBLW  3F
05746:  BNC   574A
....................          break;               // Reject : ; < = > ?  
05748:  BRA    57BA
....................  
....................       if (!(a & 1))  
0574A:  BTFSC  xC9.0
0574C:  BRA    579C
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
0574E:  MOVF   xC8,W
05750:  SUBLW  7C
05752:  BNZ   5756
....................             break;            // Reject |  
05754:  BRA    57BA
....................  
....................          if ((c >= '[') && (c <= ']')) 
05756:  MOVF   xC8,W
05758:  SUBLW  5A
0575A:  BC    5764
0575C:  MOVF   xC8,W
0575E:  SUBLW  5D
05760:  BNC   5764
....................             break;// Reject [ \ ]  
05762:  BRA    57BA
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
05764:  MOVF   xC8,W
05766:  SUBLW  40
05768:  BC    577E
0576A:  MOVF   xC8,W
0576C:  SUBLW  5A
0576E:  BNC   577E
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
05770:  MOVF   xC7,W
05772:  SUBLW  08
05774:  BNZ   577C
05776:  BCF    xCA.3
05778:  MOVF   xCA,W
0577A:  BRA    577E
0577C:  BCF    xCA.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
0577E:  MOVF   xC8,W
05780:  SUBLW  60
05782:  BC    579C
05784:  MOVF   xC8,W
05786:  SUBLW  7A
05788:  BNC   579C
....................             {      // Convert to upper case  
....................             c -= 0x20; 
0578A:  MOVLW  20
0578C:  SUBWF  xC8,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
0578E:  MOVF   xC7,W
05790:  SUBLW  08
05792:  BNZ   579A
05794:  BSF    xC9.3
05796:  MOVF   xC9,W
05798:  BRA    579C
0579A:  BSF    xC9.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
0579C:  BCF    xC9.0
....................    md_l2: 
....................       if (n >= t)  
0579E:  MOVF   xC7,W
057A0:  SUBWF  xC6,W
057A2:  BNC   57A6
....................          break; 
057A4:  BRA    57BA
....................       dirname[n++] = c; 
057A6:  MOVF   xC6,W
057A8:  INCF   xC6,F
057AA:  ADDWF  xC4,W
057AC:  MOVWF  FE9
057AE:  MOVLW  00
057B0:  ADDWFC xC5,W
057B2:  MOVWF  FEA
057B4:  MOVFF  9C8,FEF
057B8:  BRA    568A
....................       } 
....................    return 1; 
057BA:  MOVLW  01
057BC:  MOVWF  01
057BE:  MOVLB  0
057C0:  GOTO   62EE (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
0614C:  MOVLB  9
0614E:  CLRF   xC1
06150:  CLRF   xC0
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
06152:  MOVLW  14
06154:  MOVLB  7
06156:  ADDWF  x0E,W
06158:  MOVWF  FE9
0615A:  MOVLW  00
0615C:  ADDWFC x0F,W
0615E:  MOVWF  FEA
06160:  MOVFF  FEF,9BB
06164:  MOVFF  FEC,9BC
06168:  MOVFF  FEC,9BD
0616C:  MOVFF  FEC,9BE
....................    if (fs->fs_type == FS_FAT32)  
06170:  MOVFF  70E,FE9
06174:  MOVFF  70F,FEA
06178:  MOVF   FEF,W
0617A:  SUBLW  03
0617C:  BNZ   6200
....................       { 
....................       scan->clust = scan->sclust = clust; 
0617E:  MOVLW  04
06180:  MOVLB  9
06182:  ADDWF  xB3,W
06184:  MOVWF  01
06186:  MOVLW  00
06188:  ADDWFC xB4,W
0618A:  MOVFF  01,9C2
0618E:  MOVFF  9B3,FE9
06192:  MOVFF  9B4,FEA
06196:  MOVFF  9BB,FEF
0619A:  MOVFF  9BC,FEC
0619E:  MOVFF  9BD,FEC
061A2:  MOVFF  9BE,FEC
061A6:  MOVWF  FEA
061A8:  MOVFF  9C2,FE9
061AC:  MOVFF  9BB,FEF
061B0:  MOVFF  9BC,FEC
061B4:  MOVFF  9BD,FEC
061B8:  MOVFF  9BE,FEC
....................       scan->sect = clust2sect(clust); 
061BC:  MOVLW  08
061BE:  ADDWF  xB3,W
061C0:  MOVWF  01
061C2:  MOVLW  00
061C4:  ADDWFC xB4,W
061C6:  MOVWF  03
061C8:  MOVFF  01,9C2
061CC:  MOVWF  xC3
061CE:  MOVFF  9BE,9CF
061D2:  MOVFF  9BD,9CE
061D6:  MOVFF  9BC,9CD
061DA:  MOVFF  9BB,9CC
061DE:  MOVLB  0
061E0:  CALL   558C
061E4:  MOVFF  9C3,FEA
061E8:  MOVFF  9C2,FE9
061EC:  MOVFF  00,FEF
061F0:  MOVFF  01,FEC
061F4:  MOVFF  02,FEC
061F8:  MOVFF  03,FEC
....................       } 
061FC:  BRA    6260
061FE:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
06200:  MOVLW  04
06202:  MOVLB  9
06204:  ADDWF  xB3,W
06206:  MOVWF  01
06208:  MOVLW  00
0620A:  ADDWFC xB4,W
0620C:  MOVWF  03
0620E:  MOVFF  9B3,FE9
06212:  MOVFF  9B4,FEA
06216:  MOVF   FEE,F
06218:  MOVF   FEE,F
0621A:  CLRF   FEC
0621C:  MOVF   FED,F
0621E:  CLRF   FEF
06220:  MOVF   FED,F
06222:  CLRF   FEF
06224:  MOVF   FED,F
06226:  CLRF   FEF
06228:  MOVLW  00
0622A:  MOVFF  03,FEA
0622E:  MOVFF  01,FE9
06232:  MOVFF  00,FEF
06236:  MOVFF  01,FEC
0623A:  MOVFF  02,FEC
0623E:  MOVFF  03,FEC
....................       scan->sect = clust; 
06242:  MOVLW  08
06244:  ADDWF  xB3,W
06246:  MOVWF  FE9
06248:  MOVLW  00
0624A:  ADDWFC xB4,W
0624C:  MOVWF  FEA
0624E:  MOVFF  9BB,FEF
06252:  MOVFF  9BC,FEC
06256:  MOVFF  9BD,FEC
0625A:  MOVFF  9BE,FEC
0625E:  MOVLB  0
....................       } 
....................    scan->index = 0; 
06260:  MOVLW  0C
06262:  MOVLB  9
06264:  ADDWF  xB3,W
06266:  MOVWF  FE9
06268:  MOVLW  00
0626A:  ADDWFC xB4,W
0626C:  MOVWF  FEA
0626E:  CLRF   FEC
06270:  MOVF   FED,F
06272:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
06274:  MOVFF  9B8,03
06278:  MOVFF  9B7,FE9
0627C:  MOVFF  9B8,FEA
06280:  MOVF   FEF,W
06282:  SUBLW  20
06284:  BZ    62AA
06286:  MOVFF  9B8,03
0628A:  MOVFF  9B7,FE9
0628E:  MOVFF  9B8,FEA
06292:  MOVF   FEF,W
06294:  SUBLW  2F
06296:  BZ    62AA
06298:  MOVFF  9B8,03
0629C:  MOVFF  9B7,FE9
062A0:  MOVFF  9B8,FEA
062A4:  MOVF   FEF,W
062A6:  SUBLW  5C
062A8:  BNZ   62B2
....................        path++; 
062AA:  INCF   xB7,F
062AC:  BTFSC  FD8.2
062AE:  INCF   xB8,F
062B0:  BRA    6274
....................  
....................    if ((BYTE)*path < ' ')  
062B2:  MOVFF  9B8,03
062B6:  MOVFF  9B7,FE9
062BA:  MOVFF  9B8,FEA
062BE:  MOVF   FEF,W
062C0:  SUBLW  1F
062C2:  BNC   62D8
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
062C4:  MOVFF  9B9,FE9
062C8:  MOVFF  9BA,FEA
062CC:  CLRF   FEC
062CE:  MOVF   FED,F
062D0:  CLRF   FEF
....................       return (FR_OK); 
062D2:  MOVLW  00
062D4:  MOVWF  01
062D6:  BRA    6530
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
062D8:  MOVLW  09
062DA:  MOVWF  xC3
062DC:  MOVLW  B7
062DE:  MOVWF  xC2
062E0:  MOVFF  9B6,9C5
062E4:  MOVFF  9B5,9C4
062E8:  MOVLB  0
062EA:  GOTO   5666
062EE:  MOVFF  01,9BF
....................       if (ds == 1)  
062F2:  MOVLB  9
062F4:  DECFSZ xBF,W
062F6:  BRA    62FE
....................          return (FR_INVALID_NAME); 
062F8:  MOVLW  04
062FA:  MOVWF  01
062FC:  BRA    6530
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
062FE:  MOVLW  08
06300:  ADDWF  xB3,W
06302:  MOVWF  FE9
06304:  MOVLW  00
06306:  ADDWFC xB4,W
06308:  MOVWF  FEA
0630A:  MOVFF  FEF,9ED
0630E:  MOVFF  FEC,9EE
06312:  MOVFF  FEC,9EF
06316:  MOVFF  FEC,9F0
0631A:  MOVLB  0
0631C:  CALL   5A02
06320:  MOVF   01,F
06322:  BNZ   632E
....................             return (FR_RW_ERROR); 
06324:  MOVLW  07
06326:  MOVWF  01
06328:  MOVLB  9
0632A:  BRA    6530
0632C:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
0632E:  MOVLW  0C
06330:  MOVLB  9
06332:  ADDWF  xB3,W
06334:  MOVWF  FE9
06336:  MOVLW  00
06338:  ADDWFC xB4,W
0633A:  MOVWF  FEA
0633C:  MOVFF  FEC,9C3
06340:  MOVF   FED,F
06342:  MOVFF  FEF,9C2
06346:  MOVLW  0F
06348:  ANDWF  xC2,F
0634A:  CLRF   xC3
0634C:  RLCF   xC2,F
0634E:  RLCF   xC3,F
06350:  RLCF   xC2,F
06352:  RLCF   xC3,F
06354:  RLCF   xC2,F
06356:  RLCF   xC3,F
06358:  RLCF   xC2,F
0635A:  RLCF   xC3,F
0635C:  RLCF   xC2,F
0635E:  RLCF   xC3,F
06360:  MOVLW  E0
06362:  ANDWF  xC2,F
06364:  MOVLW  24
06366:  ADDWF  xC2,W
06368:  MOVWF  01
0636A:  MOVLW  00
0636C:  ADDWFC xC3,W
0636E:  MOVWF  03
06370:  MOVF   01,W
06372:  MOVLB  7
06374:  ADDWF  x0E,W
06376:  MOVWF  01
06378:  MOVF   x0F,W
0637A:  ADDWFC 03,F
0637C:  MOVFF  01,9C0
06380:  MOVLB  9
06382:  MOVFF  03,9C1
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
06386:  MOVFF  9C1,03
0638A:  MOVFF  9C0,FE9
0638E:  MOVFF  9C1,FEA
06392:  MOVF   FEF,F
06394:  BNZ   63A4
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06396:  MOVF   xBF,F
06398:  BNZ   639E
0639A:  MOVLW  02
0639C:  BRA    63A0
0639E:  MOVLW  03
063A0:  MOVWF  01
063A2:  BRA    6530
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
063A4:  MOVFF  9C1,03
063A8:  MOVFF  9C0,FE9
063AC:  MOVFF  9C1,FEA
063B0:  MOVF   FEF,W
063B2:  SUBLW  E5
063B4:  BZ    63F6
063B6:  MOVLW  0B
063B8:  ADDWF  xC0,W
063BA:  MOVWF  01
063BC:  MOVLW  00
063BE:  ADDWFC xC1,W
063C0:  MOVWF  03
063C2:  MOVFF  01,FE9
063C6:  MOVWF  FEA
063C8:  BTFSC  FEF.3
063CA:  BRA    63F6
063CC:  MOVFF  9C1,9C7
063D0:  MOVFF  9C0,9C6
063D4:  MOVFF  9B6,9C9
063D8:  MOVFF  9B5,9C8
063DC:  CLRF   xCB
063DE:  MOVLW  0B
063E0:  MOVWF  xCA
063E2:  MOVLB  0
063E4:  CALL   459C
063E8:  MOVF   01,F
063EA:  BTFSC  FD8.2
063EC:  BRA    63F2
063EE:  MOVLB  9
063F0:  BRA    63F6
....................              break; 
063F2:  BRA    641E
063F4:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
063F6:  MOVFF  9B4,9C3
063FA:  MOVFF  9B3,9C2
063FE:  MOVLB  0
06400:  RCALL  5F72
06402:  MOVF   01,F
06404:  BNZ   6418
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06406:  MOVLB  9
06408:  MOVF   xBF,F
0640A:  BNZ   6410
0640C:  MOVLW  02
0640E:  BRA    6412
06410:  MOVLW  03
06412:  MOVWF  01
06414:  BRA    6530
06416:  MOVLB  0
06418:  MOVLB  9
0641A:  BRA    62FE
0641C:  MOVLB  0
....................          } 
....................       if (!ds)  
0641E:  MOVLB  9
06420:  MOVF   xBF,F
06422:  BNZ   643C
....................          {  
....................          *win_dir = dptr;  
06424:  MOVFF  9B9,FE9
06428:  MOVFF  9BA,FEA
0642C:  MOVFF  9C1,FEC
06430:  MOVF   FED,F
06432:  MOVFF  9C0,FEF
....................          return (FR_OK); 
06436:  MOVLW  00
06438:  MOVWF  01
0643A:  BRA    6530
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
0643C:  MOVLW  0B
0643E:  ADDWF  xC0,W
06440:  MOVWF  01
06442:  MOVLW  00
06444:  ADDWFC xC1,W
06446:  MOVWF  03
06448:  MOVFF  01,FE9
0644C:  MOVWF  FEA
0644E:  BTFSC  FEF.4
06450:  BRA    6458
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
06452:  MOVLW  03
06454:  MOVWF  01
06456:  BRA    6530
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
06458:  MOVLW  14
0645A:  ADDWF  xC0,W
0645C:  MOVWF  01
0645E:  MOVLW  00
06460:  ADDWFC xC1,W
06462:  MOVWF  03
06464:  MOVFF  01,FE9
06468:  MOVWF  FEA
0646A:  MOVFF  FEC,9BE
0646E:  MOVF   FED,F
06470:  MOVFF  FEF,9C2
06474:  MOVFF  9C2,9BD
06478:  CLRF   xC2
0647A:  CLRF   xC3
0647C:  MOVLW  1A
0647E:  ADDWF  xC0,W
06480:  MOVWF  01
06482:  MOVLW  00
06484:  ADDWFC xC1,W
06486:  MOVFF  01,FE9
0648A:  MOVWF  FEA
0648C:  MOVFF  FEC,03
06490:  MOVF   FED,F
06492:  MOVF   FEF,W
06494:  IORWF  xC2,W
06496:  MOVWF  xBB
06498:  MOVF   03,W
0649A:  IORWF  xC3,W
0649C:  MOVWF  xBC
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
0649E:  MOVLW  04
064A0:  ADDWF  xB3,W
064A2:  MOVWF  01
064A4:  MOVLW  00
064A6:  ADDWFC xB4,W
064A8:  MOVFF  01,9C2
064AC:  MOVFF  9B3,FE9
064B0:  MOVFF  9B4,FEA
064B4:  MOVFF  9BB,FEF
064B8:  MOVFF  9BC,FEC
064BC:  MOVFF  9BD,FEC
064C0:  MOVFF  9BE,FEC
064C4:  MOVWF  FEA
064C6:  MOVFF  9C2,FE9
064CA:  MOVFF  9BB,FEF
064CE:  MOVFF  9BC,FEC
064D2:  MOVFF  9BD,FEC
064D6:  MOVFF  9BE,FEC
....................       scan->sect = clust2sect(clust); 
064DA:  MOVLW  08
064DC:  ADDWF  xB3,W
064DE:  MOVWF  01
064E0:  MOVLW  00
064E2:  ADDWFC xB4,W
064E4:  MOVWF  03
064E6:  MOVFF  01,9C2
064EA:  MOVWF  xC3
064EC:  MOVFF  9BE,9CF
064F0:  MOVFF  9BD,9CE
064F4:  MOVFF  9BC,9CD
064F8:  MOVFF  9BB,9CC
064FC:  MOVLB  0
064FE:  CALL   558C
06502:  MOVFF  9C3,FEA
06506:  MOVFF  9C2,FE9
0650A:  MOVFF  00,FEF
0650E:  MOVFF  01,FEC
06512:  MOVFF  02,FEC
06516:  MOVFF  03,FEC
....................       scan->index = 0; 
0651A:  MOVLW  0C
0651C:  MOVLB  9
0651E:  ADDWF  xB3,W
06520:  MOVWF  FE9
06522:  MOVLW  00
06524:  ADDWFC xB4,W
06526:  MOVWF  FEA
06528:  CLRF   FEC
0652A:  MOVF   FED,F
0652C:  CLRF   FEF
0652E:  BRA    62D8
....................       } 
06530:  MOVLB  0
06532:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06B4A:  MOVLB  9
06B4C:  MOVFF  9B3,FE9
06B50:  MOVFF  9B4,FEA
06B54:  MOVFF  FEF,9B5
06B58:  MOVFF  FEC,9B6
06B5C:  MOVFF  FEC,9B7
06B60:  MOVFF  FEC,9B8
....................    if (clust) {   // Dyanmic directory table  
06B64:  MOVF   xB5,F
06B66:  BNZ   6B74
06B68:  MOVF   xB6,F
06B6A:  BNZ   6B74
06B6C:  MOVF   xB7,F
06B6E:  BNZ   6B74
06B70:  MOVF   xB8,F
06B72:  BZ    6BD4
....................       scan->clust = clust; 
06B74:  MOVLW  04
06B76:  ADDWF  xB3,W
06B78:  MOVWF  FE9
06B7A:  MOVLW  00
06B7C:  ADDWFC xB4,W
06B7E:  MOVWF  FEA
06B80:  MOVFF  9B5,FEF
06B84:  MOVFF  9B6,FEC
06B88:  MOVFF  9B7,FEC
06B8C:  MOVFF  9B8,FEC
....................       scan->sect = clust2sect(clust); 
06B90:  MOVLW  08
06B92:  ADDWF  xB3,W
06B94:  MOVWF  01
06B96:  MOVLW  00
06B98:  ADDWFC xB4,W
06B9A:  MOVWF  03
06B9C:  MOVFF  01,9C1
06BA0:  MOVWF  xC2
06BA2:  MOVFF  9B8,9CF
06BA6:  MOVFF  9B7,9CE
06BAA:  MOVFF  9B6,9CD
06BAE:  MOVFF  9B5,9CC
06BB2:  MOVLB  0
06BB4:  CALL   558C
06BB8:  MOVFF  9C2,FEA
06BBC:  MOVFF  9C1,FE9
06BC0:  MOVFF  00,FEF
06BC4:  MOVFF  01,FEC
06BC8:  MOVFF  02,FEC
06BCC:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06BD0:  BRA    6C1E
06BD2:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06BD4:  MOVLW  08
06BD6:  ADDWF  xB3,W
06BD8:  MOVWF  01
06BDA:  MOVLW  00
06BDC:  ADDWFC xB4,W
06BDE:  MOVWF  03
06BE0:  MOVFF  01,9C1
06BE4:  MOVWF  xC2
06BE6:  MOVLW  14
06BE8:  MOVLB  7
06BEA:  ADDWF  x0E,W
06BEC:  MOVWF  FE9
06BEE:  MOVLW  00
06BF0:  ADDWFC x0F,W
06BF2:  MOVWF  FEA
06BF4:  MOVFF  FEF,00
06BF8:  MOVFF  FEC,01
06BFC:  MOVFF  FEC,02
06C00:  MOVFF  FEC,03
06C04:  MOVFF  9C2,FEA
06C08:  MOVFF  9C1,FE9
06C0C:  MOVFF  00,FEF
06C10:  MOVFF  01,FEC
06C14:  MOVFF  02,FEC
06C18:  MOVFF  03,FEC
06C1C:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06C1E:  MOVLW  0C
06C20:  MOVLB  9
06C22:  ADDWF  xB3,W
06C24:  MOVWF  FE9
06C26:  MOVLW  00
06C28:  ADDWFC xB4,W
06C2A:  MOVWF  FEA
06C2C:  CLRF   FEC
06C2E:  MOVF   FED,F
06C30:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06C32:  MOVLW  08
06C34:  ADDWF  xB3,W
06C36:  MOVWF  FE9
06C38:  MOVLW  00
06C3A:  ADDWFC xB4,W
06C3C:  MOVWF  FEA
06C3E:  MOVFF  FEF,9ED
06C42:  MOVFF  FEC,9EE
06C46:  MOVFF  FEC,9EF
06C4A:  MOVFF  FEC,9F0
06C4E:  MOVLB  0
06C50:  CALL   5A02
06C54:  MOVF   01,F
06C56:  BNZ   6C60
....................          return (NULL); 
06C58:  MOVLW  00
06C5A:  MOVWF  01
06C5C:  MOVWF  02
06C5E:  BRA    6E88
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06C60:  MOVLW  0C
06C62:  MOVLB  9
06C64:  ADDWF  xB3,W
06C66:  MOVWF  FE9
06C68:  MOVLW  00
06C6A:  ADDWFC xB4,W
06C6C:  MOVWF  FEA
06C6E:  MOVFF  FEC,9C2
06C72:  MOVF   FED,F
06C74:  MOVFF  FEF,9C1
06C78:  MOVLW  0F
06C7A:  ANDWF  xC1,F
06C7C:  CLRF   xC2
06C7E:  RLCF   xC1,F
06C80:  RLCF   xC2,F
06C82:  RLCF   xC1,F
06C84:  RLCF   xC2,F
06C86:  RLCF   xC1,F
06C88:  RLCF   xC2,F
06C8A:  RLCF   xC1,F
06C8C:  RLCF   xC2,F
06C8E:  RLCF   xC1,F
06C90:  RLCF   xC2,F
06C92:  MOVLW  E0
06C94:  ANDWF  xC1,F
06C96:  MOVLW  24
06C98:  ADDWF  xC1,W
06C9A:  MOVWF  01
06C9C:  MOVLW  00
06C9E:  ADDWFC xC2,W
06CA0:  MOVWF  03
06CA2:  MOVF   01,W
06CA4:  MOVLB  7
06CA6:  ADDWF  x0E,W
06CA8:  MOVWF  01
06CAA:  MOVF   x0F,W
06CAC:  ADDWFC 03,F
06CAE:  MOVFF  01,9BF
06CB2:  MOVLB  9
06CB4:  MOVFF  03,9C0
....................       c = *dptr; 
06CB8:  MOVFF  9BF,FE9
06CBC:  MOVFF  9C0,FEA
06CC0:  MOVFF  FEF,9BD
....................       if ((c == 0) || (c == 0xE5))  
06CC4:  MOVF   xBD,F
06CC6:  BZ    6CCE
06CC8:  MOVF   xBD,W
06CCA:  SUBLW  E5
06CCC:  BNZ   6CDC
....................          return (dptr);      // Found an empty entry!  
06CCE:  MOVFF  9BF,01
06CD2:  MOVFF  9C0,02
06CD6:  MOVLB  0
06CD8:  BRA    6E88
06CDA:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06CDC:  MOVFF  9B4,9C3
06CE0:  MOVFF  9B3,9C2
06CE4:  MOVLB  0
06CE6:  CALL   5F72
06CEA:  MOVF   01,F
06CEC:  BTFSC  FD8.2
06CEE:  BRA    6CF4
06CF0:  MOVLB  9
06CF2:  BRA    6C32
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06CF4:  MOVLB  9
06CF6:  MOVF   xB5,F
06CF8:  BNZ   6D12
06CFA:  MOVF   xB6,F
06CFC:  BNZ   6D12
06CFE:  MOVF   xB7,F
06D00:  BNZ   6D12
06D02:  MOVF   xB8,F
06D04:  BNZ   6D12
....................        return (NULL); 
06D06:  MOVLW  00
06D08:  MOVWF  01
06D0A:  MOVWF  02
06D0C:  MOVLB  0
06D0E:  BRA    6E88
06D10:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06D12:  MOVLW  04
06D14:  ADDWF  xB3,W
06D16:  MOVWF  FE9
06D18:  MOVLW  00
06D1A:  ADDWFC xB4,W
06D1C:  MOVWF  FEA
06D1E:  MOVFF  FEF,9C5
06D22:  MOVFF  FEC,9C6
06D26:  MOVFF  FEC,9C7
06D2A:  MOVFF  FEC,9C8
06D2E:  MOVLB  0
06D30:  RCALL  68B4
06D32:  MOVFF  03,9B8
06D36:  MOVFF  02,9B7
06D3A:  MOVFF  01,9B6
06D3E:  MOVFF  00,9B5
....................    if (!(clust))  
06D42:  MOVLB  9
06D44:  MOVF   xB5,F
06D46:  BNZ   6D60
06D48:  MOVF   xB6,F
06D4A:  BNZ   6D60
06D4C:  MOVF   xB7,F
06D4E:  BNZ   6D60
06D50:  MOVF   xB8,F
06D52:  BNZ   6D60
....................       return (NULL); 
06D54:  MOVLW  00
06D56:  MOVWF  01
06D58:  MOVWF  02
06D5A:  MOVLB  0
06D5C:  BRA    6E88
06D5E:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06D60:  CLRF   xF0
06D62:  CLRF   xEF
06D64:  CLRF   xEE
06D66:  CLRF   xED
06D68:  MOVLB  0
06D6A:  CALL   5A02
06D6E:  MOVF   01,F
06D70:  BNZ   6D7A
....................       return (0); 
06D72:  MOVLW  00
06D74:  MOVWF  01
06D76:  MOVWF  02
06D78:  BRA    6E88
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06D7A:  MOVLW  20
06D7C:  MOVLB  7
06D7E:  ADDWF  x0E,W
06D80:  MOVWF  01
06D82:  MOVLW  00
06D84:  ADDWFC x0F,W
06D86:  MOVWF  03
06D88:  MOVFF  01,9C1
06D8C:  MOVLB  9
06D8E:  MOVWF  xC2
06D90:  MOVFF  9B8,9CF
06D94:  MOVFF  9B7,9CE
06D98:  MOVFF  9B6,9CD
06D9C:  MOVFF  9B5,9CC
06DA0:  MOVLB  0
06DA2:  CALL   558C
06DA6:  MOVFF  03,9BC
06DAA:  MOVFF  02,9BB
06DAE:  MOVFF  01,9BA
06DB2:  MOVFF  00,9B9
06DB6:  MOVFF  9C2,FEA
06DBA:  MOVFF  9C1,FE9
06DBE:  MOVFF  9B9,FEF
06DC2:  MOVFF  9BA,FEC
06DC6:  MOVFF  9BB,FEC
06DCA:  MOVFF  9BC,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06DCE:  MOVLW  24
06DD0:  MOVLB  7
06DD2:  ADDWF  x0E,W
06DD4:  MOVWF  01
06DD6:  MOVLW  00
06DD8:  ADDWFC x0F,W
06DDA:  MOVWF  03
06DDC:  MOVFF  01,9C1
06DE0:  MOVLB  9
06DE2:  MOVWF  xC2
06DE4:  MOVWF  FEA
06DE6:  MOVFF  01,FE9
06DEA:  CLRF   00
06DEC:  MOVLW  02
06DEE:  MOVWF  02
06DF0:  CLRF   01
06DF2:  MOVLB  0
06DF4:  CALL   34AE
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06DF8:  MOVLW  02
06DFA:  MOVLB  7
06DFC:  ADDWF  x0E,W
06DFE:  MOVWF  FE9
06E00:  MOVLW  00
06E02:  ADDWFC x0F,W
06E04:  MOVWF  FEA
06E06:  MOVFF  FEF,9BE
06E0A:  MOVLB  9
06E0C:  MOVF   xBE,F
06E0E:  BZ    6E68
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06E10:  MOVLW  24
06E12:  MOVLB  7
06E14:  ADDWF  x0E,W
06E16:  MOVWF  01
06E18:  MOVLW  00
06E1A:  ADDWFC x0F,W
06E1C:  MOVWF  03
06E1E:  MOVFF  01,9C1
06E22:  MOVLB  9
06E24:  MOVWF  xC2
06E26:  MOVWF  xFA
06E28:  MOVFF  01,9F9
06E2C:  MOVFF  9BC,9FE
06E30:  MOVFF  9BB,9FD
06E34:  MOVFF  9BA,9FC
06E38:  MOVFF  9B9,9FB
06E3C:  MOVLW  01
06E3E:  MOVWF  xFF
06E40:  MOVLB  0
06E42:  CALL   58BC
06E46:  MOVF   01,F
06E48:  BZ    6E52
....................          return (NULL); 
06E4A:  MOVLW  00
06E4C:  MOVWF  01
06E4E:  MOVWF  02
06E50:  BRA    6E88
....................       sector++; 
06E52:  MOVLW  01
06E54:  MOVLB  9
06E56:  ADDWF  xB9,F
06E58:  BTFSC  FD8.0
06E5A:  INCF   xBA,F
06E5C:  BTFSC  FD8.2
06E5E:  INCF   xBB,F
06E60:  BTFSC  FD8.2
06E62:  INCF   xBC,F
06E64:  DECF   xBE,F
06E66:  BRA    6E0C
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06E68:  MOVLW  06
06E6A:  MOVLB  7
06E6C:  ADDWF  x0E,W
06E6E:  MOVWF  FE9
06E70:  MOVLW  00
06E72:  ADDWFC x0F,W
06E74:  MOVWF  FEA
06E76:  MOVLW  01
06E78:  MOVWF  FEF
....................    return (fs->win); 
06E7A:  MOVLW  24
06E7C:  ADDWF  x0E,W
06E7E:  MOVWF  01
06E80:  MOVLW  00
06E82:  ADDWFC x0F,W
06E84:  MOVWF  03
06E86:  MOVWF  02
06E88:  MOVLB  0
06E8A:  GOTO   7120 (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
0552A:  MOVLB  7
0552C:  MOVF   x0E,W
0552E:  IORWF  x0F,W
05530:  BNZ   5538
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
05532:  MOVLW  0B
05534:  MOVWF  01
05536:  BRA    5588
....................  
....................    if (disk_status() & STA_NOINIT)  
05538:  MOVLB  0
0553A:  RCALL  551C
0553C:  BTFSS  01.0
0553E:  BRA    556A
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
05540:  MOVLW  01
05542:  MOVLB  7
05544:  ADDWF  x0E,W
05546:  MOVWF  FE9
05548:  MOVLW  00
0554A:  ADDWFC x0F,W
0554C:  MOVWF  FEA
0554E:  MOVF   FEF,F
05550:  BZ    555A
....................          return (FR_INCORRECT_DISK_CHANGE); 
05552:  MOVLW  09
05554:  MOVWF  01
05556:  BRA    5588
05558:  BRA    5566
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
0555A:  MOVLB  0
0555C:  CALL   47D8
05560:  MOVF   01,W
05562:  MOVLB  7
05564:  BRA    5588
....................       }  
05566:  BRA    5584
05568:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
0556A:  MOVLB  7
0556C:  MOVFF  70E,FE9
05570:  MOVFF  70F,FEA
05574:  MOVF   FEF,F
05576:  BNZ   5584
....................          return (f_mountdrv());      // Initialize file system and return resulut  
05578:  MOVLB  0
0557A:  CALL   47D8
0557E:  MOVF   01,W
05580:  MOVLB  7
05582:  BRA    5588
....................       } 
....................    return FR_OK;                  // File system is valid  
05584:  MOVLW  00
05586:  MOVWF  01
05588:  MOVLB  0
0558A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B5E8:  MOVLB  8
0B5EA:  MOVF   xA9,W
0B5EC:  XORLW  00
0B5EE:  MOVLB  0
0B5F0:  BZ    B62A
0B5F2:  XORLW  04
0B5F4:  BZ    B646
0B5F6:  XORLW  05
0B5F8:  BZ    B662
0B5FA:  XORLW  03
0B5FC:  BZ    B67E
0B5FE:  XORLW  01
0B600:  BZ    B69A
0B602:  XORLW  06
0B604:  BZ    B6B6
0B606:  XORLW  03
0B608:  BZ    B6D2
0B60A:  XORLW  01
0B60C:  BTFSC  FD8.2
0B60E:  BRA    B6EE
0B610:  XORLW  0E
0B612:  BTFSC  FD8.2
0B614:  BRA    B70A
0B616:  XORLW  03
0B618:  BTFSC  FD8.2
0B61A:  BRA    B726
0B61C:  XORLW  01
0B61E:  BTFSC  FD8.2
0B620:  BRA    B742
0B622:  XORLW  07
0B624:  BTFSC  FD8.2
0B626:  BRA    B75E
0B628:  BRA    B77A
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B62A:  MOVFF  8AB,FEA
0B62E:  MOVFF  8AA,FE9
0B632:  MOVLW  00
0B634:  CALL   0106
0B638:  TBLRD*-
0B63A:  TBLRD*+
0B63C:  MOVF   FF5,W
0B63E:  MOVWF  FEE
0B640:  IORLW  00
0B642:  BNZ   B63A
....................          break; 
0B644:  BRA    B794
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B646:  MOVFF  8AB,FEA
0B64A:  MOVFF  8AA,FE9
0B64E:  MOVLW  00
0B650:  CALL   0124
0B654:  TBLRD*-
0B656:  TBLRD*+
0B658:  MOVF   FF5,W
0B65A:  MOVWF  FEE
0B65C:  IORLW  00
0B65E:  BNZ   B656
....................          break; 
0B660:  BRA    B794
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0B662:  MOVFF  8AB,FEA
0B666:  MOVFF  8AA,FE9
0B66A:  MOVLW  00
0B66C:  CALL   014A
0B670:  TBLRD*-
0B672:  TBLRD*+
0B674:  MOVF   FF5,W
0B676:  MOVWF  FEE
0B678:  IORLW  00
0B67A:  BNZ   B672
....................          break; 
0B67C:  BRA    B794
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0B67E:  MOVFF  8AB,FEA
0B682:  MOVFF  8AA,FE9
0B686:  MOVLW  00
0B688:  CALL   016E
0B68C:  TBLRD*-
0B68E:  TBLRD*+
0B690:  MOVF   FF5,W
0B692:  MOVWF  FEE
0B694:  IORLW  00
0B696:  BNZ   B68E
....................          break; 
0B698:  BRA    B794
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0B69A:  MOVFF  8AB,FEA
0B69E:  MOVFF  8AA,FE9
0B6A2:  MOVLW  00
0B6A4:  CALL   0192
0B6A8:  TBLRD*-
0B6AA:  TBLRD*+
0B6AC:  MOVF   FF5,W
0B6AE:  MOVWF  FEE
0B6B0:  IORLW  00
0B6B2:  BNZ   B6AA
....................          break; 
0B6B4:  BRA    B794
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0B6B6:  MOVFF  8AB,FEA
0B6BA:  MOVFF  8AA,FE9
0B6BE:  MOVLW  00
0B6C0:  CALL   01B6
0B6C4:  TBLRD*-
0B6C6:  TBLRD*+
0B6C8:  MOVF   FF5,W
0B6CA:  MOVWF  FEE
0B6CC:  IORLW  00
0B6CE:  BNZ   B6C6
....................          break; 
0B6D0:  BRA    B794
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0B6D2:  MOVFF  8AB,FEA
0B6D6:  MOVFF  8AA,FE9
0B6DA:  MOVLW  00
0B6DC:  CALL   01D8
0B6E0:  TBLRD*-
0B6E2:  TBLRD*+
0B6E4:  MOVF   FF5,W
0B6E6:  MOVWF  FEE
0B6E8:  IORLW  00
0B6EA:  BNZ   B6E2
....................          break; 
0B6EC:  BRA    B794
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0B6EE:  MOVFF  8AB,FEA
0B6F2:  MOVFF  8AA,FE9
0B6F6:  MOVLW  00
0B6F8:  CALL   01F8
0B6FC:  TBLRD*-
0B6FE:  TBLRD*+
0B700:  MOVF   FF5,W
0B702:  MOVWF  FEE
0B704:  IORLW  00
0B706:  BNZ   B6FE
....................          break; 
0B708:  BRA    B794
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0B70A:  MOVFF  8AB,FEA
0B70E:  MOVFF  8AA,FE9
0B712:  MOVLW  00
0B714:  CALL   0216
0B718:  TBLRD*-
0B71A:  TBLRD*+
0B71C:  MOVF   FF5,W
0B71E:  MOVWF  FEE
0B720:  IORLW  00
0B722:  BNZ   B71A
....................          break; 
0B724:  BRA    B794
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0B726:  MOVFF  8AB,FEA
0B72A:  MOVFF  8AA,FE9
0B72E:  MOVLW  00
0B730:  CALL   0242
0B734:  TBLRD*-
0B736:  TBLRD*+
0B738:  MOVF   FF5,W
0B73A:  MOVWF  FEE
0B73C:  IORLW  00
0B73E:  BNZ   B736
....................          break; 
0B740:  BRA    B794
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0B742:  MOVFF  8AB,FEA
0B746:  MOVFF  8AA,FE9
0B74A:  MOVLW  00
0B74C:  CALL   0266
0B750:  TBLRD*-
0B752:  TBLRD*+
0B754:  MOVF   FF5,W
0B756:  MOVWF  FEE
0B758:  IORLW  00
0B75A:  BNZ   B752
....................          break; 
0B75C:  BRA    B794
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0B75E:  MOVFF  8AB,FEA
0B762:  MOVFF  8AA,FE9
0B766:  MOVLW  00
0B768:  CALL   028A
0B76C:  TBLRD*-
0B76E:  TBLRD*+
0B770:  MOVF   FF5,W
0B772:  MOVWF  FEE
0B774:  IORLW  00
0B776:  BNZ   B76E
....................          break; 
0B778:  BRA    B794
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0B77A:  MOVFF  8AB,FEA
0B77E:  MOVFF  8AA,FE9
0B782:  MOVLW  00
0B784:  CALL   02AC
0B788:  TBLRD*-
0B78A:  TBLRD*+
0B78C:  MOVF   FF5,W
0B78E:  MOVWF  FEE
0B790:  IORLW  00
0B792:  BNZ   B78A
....................       } 
0B794:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
047D8:  MOVLB  7
047DA:  MOVF   x0E,W
047DC:  IORWF  x0F,W
047DE:  BNZ   47E6
....................       return (FR_NOT_ENABLED); 
047E0:  MOVLW  0B
047E2:  MOVWF  01
047E4:  BRA    4D72
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
047E6:  MOVFF  70F,FEA
047EA:  MOVFF  70E,FE9
047EE:  CLRF   00
047F0:  MOVLW  02
047F2:  MOVWF  02
047F4:  MOVLW  24
047F6:  MOVWF  01
047F8:  MOVLB  0
047FA:  CALL   34AE
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
047FE:  CALL   35FE
04802:  MOVFF  01,4E9
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
04806:  MOVLB  4
04808:  BTFSS  xE9.0
0480A:  BRA    4818
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
0480C:  MOVLB  0
0480E:  CALL   35FE
04812:  MOVFF  01,4E9
04816:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
04818:  BTFSS  xE9.0
0481A:  BRA    4826
0481C:  MOVLW  01
0481E:  MOVWF  01
04820:  MOVLB  7
04822:  BRA    4D72
04824:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
04826:  MOVLB  9
04828:  CLRF   xB7
0482A:  CLRF   xB6
0482C:  CLRF   xB5
0482E:  CLRF   xB4
04830:  MOVFF  9B7,9C3
04834:  MOVFF  9B6,9C2
04838:  MOVFF  9B5,9C1
0483C:  MOVFF  9B4,9C0
04840:  MOVLB  0
04842:  RCALL  4620
04844:  MOVFF  01,9B3
....................    if (!fat)  
04848:  MOVLB  9
0484A:  MOVF   xB3,F
0484C:  BNZ   48BC
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
0484E:  MOVLW  E6
04850:  MOVLB  7
04852:  ADDWF  x0E,W
04854:  MOVWF  FE9
04856:  MOVLW  01
04858:  ADDWFC x0F,W
0485A:  MOVWF  FEA
0485C:  MOVF   FEF,F
0485E:  BZ    489C
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
04860:  MOVLW  EA
04862:  ADDWF  x0E,W
04864:  MOVWF  01
04866:  MOVLW  01
04868:  ADDWFC x0F,W
0486A:  MOVFF  01,FE9
0486E:  MOVWF  FEA
04870:  MOVFF  FEF,9B4
04874:  MOVFF  FEC,9B5
04878:  MOVFF  FEC,9B6
0487C:  MOVFF  FEC,9B7
....................          fat = check_fs(sect);            // Check the partition  
04880:  MOVFF  9B7,9C3
04884:  MOVFF  9B6,9C2
04888:  MOVFF  9B5,9C1
0488C:  MOVFF  9B4,9C0
04890:  MOVLB  0
04892:  RCALL  4620
04894:  MOVFF  01,9B3
....................          } 
04898:  BRA    48BA
0489A:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
0489C:  MOVLW  04
0489E:  MOVWF  FF6
048A0:  MOVLW  0C
048A2:  MOVWF  FF7
048A4:  MOVLW  00
048A6:  MOVWF  FF8
048A8:  CLRF   1B
048AA:  BTFSC  FF2.7
048AC:  BSF    1B.7
048AE:  BCF    FF2.7
048B0:  MOVLB  0
048B2:  CALL   0E3A
048B6:  BTFSC  1B.7
048B8:  BSF    FF2.7
048BA:  MOVLB  9
....................       } 
....................    if (!fat)  
048BC:  MOVF   xB3,F
048BE:  BNZ   48CA
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
048C0:  MOVLW  0C
048C2:  MOVWF  01
048C4:  MOVLB  7
048C6:  BRA    4D72
048C8:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
048CA:  MOVLB  7
048CC:  MOVFF  70E,FE9
048D0:  MOVFF  70F,FEA
048D4:  MOVFF  9B3,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
048D8:  MOVLB  9
048DA:  MOVF   xB3,W
048DC:  SUBLW  03
048DE:  BNZ   4944
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
048E0:  MOVLW  08
048E2:  MOVLB  7
048E4:  ADDWF  x0E,W
048E6:  MOVWF  01
048E8:  MOVLW  00
048EA:  ADDWFC x0F,W
048EC:  MOVWF  03
048EE:  MOVFF  01,9C0
048F2:  MOVLB  9
048F4:  MOVWF  xC1
048F6:  MOVLW  48
048F8:  MOVLB  7
048FA:  ADDWF  x0E,W
048FC:  MOVWF  01
048FE:  MOVLW  00
04900:  ADDWFC x0F,W
04902:  MOVFF  01,FE9
04906:  MOVWF  FEA
04908:  MOVFF  FEF,00
0490C:  MOVFF  FEC,01
04910:  MOVFF  FEC,02
04914:  MOVFF  FEC,03
04918:  MOVFF  03,9C5
0491C:  MOVFF  02,9C4
04920:  MOVFF  01,9C3
04924:  MOVFF  00,9C2
04928:  MOVFF  9C1,FEA
0492C:  MOVFF  9C0,FE9
04930:  MOVFF  00,FEF
04934:  MOVFF  01,FEC
04938:  MOVFF  02,FEC
0493C:  MOVFF  03,FEC
04940:  BRA    499C
04942:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
04944:  MOVLW  08
04946:  MOVLB  7
04948:  ADDWF  x0E,W
0494A:  MOVWF  01
0494C:  MOVLW  00
0494E:  ADDWFC x0F,W
04950:  MOVWF  03
04952:  MOVFF  01,9C0
04956:  MOVLB  9
04958:  MOVWF  xC1
0495A:  MOVLW  3A
0495C:  MOVLB  7
0495E:  ADDWF  x0E,W
04960:  MOVWF  01
04962:  MOVLW  00
04964:  ADDWFC x0F,W
04966:  MOVFF  01,FE9
0496A:  MOVWF  FEA
0496C:  MOVFF  FEC,03
04970:  MOVF   FED,F
04972:  MOVFF  FEF,9C2
04976:  MOVLB  9
04978:  MOVFF  03,9C3
0497C:  MOVFF  9C1,FEA
04980:  MOVFF  9C0,FE9
04984:  MOVF   FEE,F
04986:  MOVF   FEE,F
04988:  CLRF   FEC
0498A:  MOVF   FED,F
0498C:  CLRF   FEF
0498E:  MOVF   FED,F
04990:  MOVFF  03,FEF
04994:  MOVF   FED,F
04996:  MOVFF  9C2,FEF
0499A:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
0499C:  MOVLW  02
0499E:  ADDWF  x0E,W
049A0:  MOVWF  01
049A2:  MOVLW  00
049A4:  ADDWFC x0F,W
049A6:  MOVWF  03
049A8:  MOVLW  31
049AA:  MOVLB  7
049AC:  ADDWF  x0E,W
049AE:  MOVWF  FE9
049B0:  MOVLW  00
049B2:  ADDWFC x0F,W
049B4:  MOVWF  FEA
049B6:  MOVFF  FEF,9C2
049BA:  MOVLB  9
049BC:  MOVFF  03,FEA
049C0:  MOVFF  01,FE9
049C4:  MOVFF  9C2,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
049C8:  MOVLW  03
049CA:  MOVLB  7
049CC:  ADDWF  x0E,W
049CE:  MOVWF  01
049D0:  MOVLW  00
049D2:  ADDWFC x0F,W
049D4:  MOVWF  03
049D6:  MOVLW  34
049D8:  MOVLB  7
049DA:  ADDWF  x0E,W
049DC:  MOVWF  FE9
049DE:  MOVLW  00
049E0:  ADDWFC x0F,W
049E2:  MOVWF  FEA
049E4:  MOVFF  FEF,9C2
049E8:  MOVLB  9
049EA:  MOVFF  03,FEA
049EE:  MOVFF  01,FE9
049F2:  MOVFF  9C2,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
049F6:  MOVLW  10
049F8:  MOVLB  7
049FA:  ADDWF  x0E,W
049FC:  MOVWF  01
049FE:  MOVLW  00
04A00:  ADDWFC x0F,W
04A02:  MOVWF  03
04A04:  MOVFF  01,9C0
04A08:  MOVLB  9
04A0A:  MOVWF  xC1
04A0C:  MOVLW  32
04A0E:  MOVLB  7
04A10:  ADDWF  x0E,W
04A12:  MOVWF  01
04A14:  MOVLW  00
04A16:  ADDWFC x0F,W
04A18:  MOVFF  01,FE9
04A1C:  MOVWF  FEA
04A1E:  MOVFF  FEC,03
04A22:  MOVF   FED,F
04A24:  MOVF   FEF,W
04A26:  MOVLB  9
04A28:  ADDWF  xB4,W
04A2A:  MOVWF  00
04A2C:  MOVF   03,W
04A2E:  ADDWFC xB5,W
04A30:  MOVWF  01
04A32:  MOVLW  00
04A34:  ADDWFC xB6,W
04A36:  MOVWF  02
04A38:  MOVLW  00
04A3A:  ADDWFC xB7,W
04A3C:  MOVFF  9C1,FEA
04A40:  MOVFF  9C0,FE9
04A44:  MOVFF  00,FEF
04A48:  MOVFF  01,FEC
04A4C:  MOVFF  02,FEC
04A50:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04A52:  MOVLW  04
04A54:  MOVLB  7
04A56:  ADDWF  x0E,W
04A58:  MOVWF  01
04A5A:  MOVLW  00
04A5C:  ADDWFC x0F,W
04A5E:  MOVWF  03
04A60:  MOVFF  01,9C0
04A64:  MOVLB  9
04A66:  MOVWF  xC1
04A68:  MOVLW  35
04A6A:  MOVLB  7
04A6C:  ADDWF  x0E,W
04A6E:  MOVWF  01
04A70:  MOVLW  00
04A72:  ADDWFC x0F,W
04A74:  MOVFF  01,FE9
04A78:  MOVWF  FEA
04A7A:  MOVFF  FEC,03
04A7E:  MOVF   FED,F
04A80:  MOVFF  FEF,9C2
04A84:  MOVLB  9
04A86:  MOVFF  9C1,FEA
04A8A:  MOVFF  9C0,FE9
04A8E:  MOVFF  03,FEC
04A92:  MOVF   FED,F
04A94:  MOVFF  9C2,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04A98:  MOVLW  08
04A9A:  MOVLB  7
04A9C:  ADDWF  x0E,W
04A9E:  MOVWF  FE9
04AA0:  MOVLW  00
04AA2:  ADDWFC x0F,W
04AA4:  MOVWF  FEA
04AA6:  MOVFF  FEF,9D3
04AAA:  MOVFF  FEC,9D4
04AAE:  MOVFF  FEC,9D5
04AB2:  MOVFF  FEC,9D6
04AB6:  MOVLW  03
04AB8:  ADDWF  x0E,W
04ABA:  MOVWF  FE9
04ABC:  MOVLW  00
04ABE:  ADDWFC x0F,W
04AC0:  MOVWF  FEA
04AC2:  MOVFF  FEF,9D7
04AC6:  MOVLB  9
04AC8:  MOVFF  FEA,9C6
04ACC:  MOVFF  FE9,9C5
04AD0:  CLRF   xDA
04AD2:  CLRF   xD9
04AD4:  CLRF   xD8
04AD6:  MOVLB  0
04AD8:  RCALL  477C
04ADA:  MOVFF  9C6,FEA
04ADE:  MOVFF  9C5,FE9
04AE2:  MOVFF  03,9C3
04AE6:  MOVFF  02,9C2
04AEA:  MOVFF  01,9C1
04AEE:  MOVFF  00,9C0
04AF2:  MOVLW  10
04AF4:  MOVLB  7
04AF6:  ADDWF  x0E,W
04AF8:  MOVWF  FE9
04AFA:  MOVLW  00
04AFC:  ADDWFC x0F,W
04AFE:  MOVWF  FEA
04B00:  MOVFF  FEF,00
04B04:  MOVFF  FEC,01
04B08:  MOVFF  FEC,02
04B0C:  MOVFF  FEC,03
04B10:  MOVF   00,W
04B12:  MOVLB  9
04B14:  ADDWF  xC0,W
04B16:  MOVWF  xB8
04B18:  MOVF   01,W
04B1A:  ADDWFC xC1,W
04B1C:  MOVWF  xB9
04B1E:  MOVF   02,W
04B20:  ADDWFC xC2,W
04B22:  MOVWF  xBA
04B24:  MOVF   03,W
04B26:  ADDWFC xC3,W
04B28:  MOVWF  xBB
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04B2A:  MOVF   xB3,W
04B2C:  SUBLW  03
04B2E:  BNZ   4BA0
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04B30:  MOVLW  14
04B32:  MOVLB  7
04B34:  ADDWF  x0E,W
04B36:  MOVWF  01
04B38:  MOVLW  00
04B3A:  ADDWFC x0F,W
04B3C:  MOVWF  03
04B3E:  MOVFF  01,9C0
04B42:  MOVLB  9
04B44:  MOVWF  xC1
04B46:  MOVLW  50
04B48:  MOVLB  7
04B4A:  ADDWF  x0E,W
04B4C:  MOVWF  01
04B4E:  MOVLW  00
04B50:  ADDWFC x0F,W
04B52:  MOVFF  01,FE9
04B56:  MOVWF  FEA
04B58:  MOVFF  FEF,00
04B5C:  MOVFF  FEC,01
04B60:  MOVFF  FEC,02
04B64:  MOVFF  FEC,03
04B68:  MOVFF  9C1,FEA
04B6C:  MOVFF  9C0,FE9
04B70:  MOVFF  00,FEF
04B74:  MOVFF  01,FEC
04B78:  MOVFF  02,FEC
04B7C:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04B80:  MOVLW  18
04B82:  ADDWF  x0E,W
04B84:  MOVWF  FE9
04B86:  MOVLW  00
04B88:  ADDWFC x0F,W
04B8A:  MOVWF  FEA
04B8C:  MOVFF  9B8,FEF
04B90:  MOVFF  9B9,FEC
04B94:  MOVFF  9BA,FEC
04B98:  MOVFF  9BB,FEC
....................       }  
04B9C:  BRA    4C2C
04B9E:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04BA0:  MOVLW  14
04BA2:  MOVLB  7
04BA4:  ADDWF  x0E,W
04BA6:  MOVWF  FE9
04BA8:  MOVLW  00
04BAA:  ADDWFC x0F,W
04BAC:  MOVWF  FEA
04BAE:  MOVFF  9B8,FEF
04BB2:  MOVFF  9B9,FEC
04BB6:  MOVFF  9BA,FEC
04BBA:  MOVFF  9BB,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04BBE:  MOVLW  18
04BC0:  ADDWF  x0E,W
04BC2:  MOVWF  01
04BC4:  MOVLW  00
04BC6:  ADDWFC x0F,W
04BC8:  MOVFF  01,9C0
04BCC:  MOVLB  9
04BCE:  MOVWF  xC1
04BD0:  MOVLW  04
04BD2:  MOVLB  7
04BD4:  ADDWF  x0E,W
04BD6:  MOVWF  FE9
04BD8:  MOVLW  00
04BDA:  ADDWFC x0F,W
04BDC:  MOVWF  FEA
04BDE:  MOVFF  FEC,9C3
04BE2:  MOVF   FED,F
04BE4:  MOVFF  FEF,9C2
04BE8:  MOVLB  9
04BEA:  RRCF   xC3,F
04BEC:  RRCF   xC2,F
04BEE:  RRCF   xC3,F
04BF0:  RRCF   xC2,F
04BF2:  RRCF   xC3,F
04BF4:  RRCF   xC2,F
04BF6:  RRCF   xC3,F
04BF8:  RRCF   xC2,F
04BFA:  MOVLW  0F
04BFC:  ANDWF  xC3,F
04BFE:  MOVF   xC2,W
04C00:  ADDWF  xB8,W
04C02:  MOVWF  00
04C04:  MOVF   xC3,W
04C06:  ADDWFC xB9,W
04C08:  MOVWF  01
04C0A:  MOVLW  00
04C0C:  ADDWFC xBA,W
04C0E:  MOVWF  02
04C10:  MOVLW  00
04C12:  ADDWFC xBB,W
04C14:  MOVFF  9C1,FEA
04C18:  MOVFF  9C0,FE9
04C1C:  MOVFF  00,FEF
04C20:  MOVFF  01,FEC
04C24:  MOVFF  02,FEC
04C28:  MOVWF  FEC
04C2A:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04C2C:  MOVLW  44
04C2E:  ADDWF  x0E,W
04C30:  MOVWF  01
04C32:  MOVLW  00
04C34:  ADDWFC x0F,W
04C36:  MOVFF  01,FE9
04C3A:  MOVWF  FEA
04C3C:  MOVFF  FEF,9BC
04C40:  MOVFF  FEC,9BD
04C44:  MOVFF  FEC,9BE
04C48:  MOVFF  FEC,9BF
....................    if (!maxsect)  
04C4C:  MOVLB  9
04C4E:  MOVF   xBC,F
04C50:  BNZ   4C80
04C52:  MOVF   xBD,F
04C54:  BNZ   4C80
04C56:  MOVF   xBE,F
04C58:  BNZ   4C80
04C5A:  MOVF   xBF,F
04C5C:  BNZ   4C80
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04C5E:  MOVLW  37
04C60:  MOVLB  7
04C62:  ADDWF  x0E,W
04C64:  MOVWF  01
04C66:  MOVLW  00
04C68:  ADDWFC x0F,W
04C6A:  MOVFF  01,FE9
04C6E:  MOVWF  FEA
04C70:  MOVLB  9
04C72:  CLRF   xBF
04C74:  CLRF   xBE
04C76:  MOVFF  FEC,9BD
04C7A:  MOVF   FED,F
04C7C:  MOVFF  FEF,9BC
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04C80:  MOVLW  0C
04C82:  MOVLB  7
04C84:  ADDWF  x0E,W
04C86:  MOVWF  01
04C88:  MOVLW  00
04C8A:  ADDWFC x0F,W
04C8C:  MOVWF  03
04C8E:  MOVFF  01,9C0
04C92:  MOVLB  9
04C94:  MOVWF  xC1
04C96:  MOVLW  18
04C98:  MOVLB  7
04C9A:  ADDWF  x0E,W
04C9C:  MOVWF  FE9
04C9E:  MOVLW  00
04CA0:  ADDWFC x0F,W
04CA2:  MOVWF  FEA
04CA4:  MOVFF  FEF,00
04CA8:  MOVFF  FEC,01
04CAC:  MOVFF  FEC,02
04CB0:  MOVFF  FEC,03
04CB4:  MOVF   00,W
04CB6:  MOVLB  9
04CB8:  SUBWF  xBC,W
04CBA:  MOVWF  xC2
04CBC:  MOVF   01,W
04CBE:  SUBWFB xBD,W
04CC0:  MOVWF  xC3
04CC2:  MOVF   02,W
04CC4:  SUBWFB xBE,W
04CC6:  MOVWF  xC4
04CC8:  MOVF   03,W
04CCA:  SUBWFB xBF,W
04CCC:  MOVWF  xC5
04CCE:  MOVF   xB4,W
04CD0:  ADDWF  xC2,F
04CD2:  MOVF   xB5,W
04CD4:  ADDWFC xC3,F
04CD6:  MOVF   xB6,W
04CD8:  ADDWFC xC4,F
04CDA:  MOVF   xB7,W
04CDC:  ADDWFC xC5,F
04CDE:  MOVLW  02
04CE0:  MOVLB  7
04CE2:  ADDWF  x0E,W
04CE4:  MOVWF  FE9
04CE6:  MOVLW  00
04CE8:  ADDWFC x0F,W
04CEA:  MOVWF  FEA
04CEC:  MOVFF  FEF,A28
04CF0:  MOVLB  9
04CF2:  MOVFF  FEA,9C8
04CF6:  MOVFF  FE9,9C7
04CFA:  BCF    FD8.1
04CFC:  CLRF   1B
04CFE:  BTFSC  FF2.7
04D00:  BSF    1B.7
04D02:  BCF    FF2.7
04D04:  MOVFF  9C5,A27
04D08:  MOVFF  9C4,A26
04D0C:  MOVFF  9C3,A25
04D10:  MOVFF  9C2,A24
04D14:  MOVLB  A
04D16:  CLRF   x2B
04D18:  CLRF   x2A
04D1A:  CLRF   x29
04D1C:  MOVLB  0
04D1E:  CALL   1042
04D22:  BTFSC  1B.7
04D24:  BSF    FF2.7
04D26:  MOVFF  9C8,FEA
04D2A:  MOVFF  9C7,FE9
04D2E:  MOVFF  03,9C5
04D32:  MOVFF  02,9C4
04D36:  MOVFF  01,9C3
04D3A:  MOVFF  00,9C2
04D3E:  MOVLW  02
04D40:  MOVLB  9
04D42:  ADDWF  00,W
04D44:  MOVWF  00
04D46:  MOVLW  00
04D48:  ADDWFC 01,W
04D4A:  MOVWF  01
04D4C:  MOVLW  00
04D4E:  ADDWFC 02,W
04D50:  MOVWF  02
04D52:  MOVLW  00
04D54:  ADDWFC 03,W
04D56:  MOVFF  9C1,FEA
04D5A:  MOVFF  9C0,FE9
04D5E:  MOVFF  00,FEF
04D62:  MOVFF  01,FEC
04D66:  MOVFF  02,FEC
04D6A:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04D6C:  MOVLW  00
04D6E:  MOVWF  01
04D70:  MOVLB  7
04D72:  MOVLB  0
04D74:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
0709E:  CALL   552A
070A2:  MOVFF  01,9A0
....................    if (result != FR_OK)  
070A6:  MOVLB  9
070A8:  MOVF   xA0,F
070AA:  BZ    70B2
....................       return (result); 
070AC:  MOVFF  9A0,01
070B0:  BRA    74E2
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
070B2:  MOVF   x91,W
070B4:  ANDLW  0A
070B6:  BZ    70CE
070B8:  MOVLB  0
070BA:  CALL   551C
070BE:  BTFSC  01.2
070C0:  BRA    70C6
070C2:  MOVLB  9
070C4:  BRA    70CE
....................          return (FR_WRITE_PROTECTED); 
070C6:  MOVLW  0A
070C8:  MOVWF  01
070CA:  MOVLB  9
070CC:  BRA    74E2
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
070CE:  MOVLW  09
070D0:  MOVWF  xB4
070D2:  MOVLW  92
070D4:  MOVWF  xB3
070D6:  MOVLW  09
070D8:  MOVWF  xB6
070DA:  MOVLW  A3
070DC:  MOVWF  xB5
070DE:  MOVFF  990,9B8
070E2:  MOVFF  98F,9B7
070E6:  MOVLW  09
070E8:  MOVWF  xBA
070EA:  MOVLW  A1
070EC:  MOVWF  xB9
070EE:  MOVLB  0
070F0:  CALL   614C
070F4:  MOVFF  01,9A0
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
070F8:  MOVLB  9
070FA:  MOVF   x91,W
070FC:  ANDLW  18
070FE:  BTFSC  FD8.2
07100:  BRA    7324
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
07102:  MOVF   xA0,F
07104:  BZ    718C
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
07106:  BSF    x91.3
....................          if (result != FR_NO_FILE) 
07108:  MOVF   xA0,W
0710A:  SUBLW  02
0710C:  BZ    7114
....................             return (result); 
0710E:  MOVFF  9A0,01
07112:  BRA    74E2
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
07114:  MOVLW  09
07116:  MOVWF  xB4
07118:  MOVLW  92
0711A:  MOVWF  xB3
0711C:  MOVLB  0
0711E:  BRA    6B4A
07120:  MOVFF  02,9A2
07124:  MOVFF  01,9A1
....................          if (dir_ptr == NULL) 
07128:  MOVLB  9
0712A:  MOVF   xA1,F
0712C:  BNZ   7138
0712E:  MOVF   xA2,F
07130:  BNZ   7138
....................             return (FR_DENIED); 
07132:  MOVLW  05
07134:  MOVWF  01
07136:  BRA    74E2
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
07138:  MOVFF  9A2,FEA
0713C:  MOVFF  9A1,FE9
07140:  MOVLW  09
07142:  MOVWF  FE2
07144:  MOVLW  A3
07146:  MOVWF  FE1
07148:  MOVLW  0B
0714A:  MOVWF  01
0714C:  MOVFF  FE6,FEE
07150:  DECFSZ 01,F
07152:  BRA    714C
....................          *(dir_ptr+12) = fn[11]; 
07154:  MOVLW  0C
07156:  ADDWF  xA1,W
07158:  MOVWF  01
0715A:  MOVLW  00
0715C:  ADDWFC xA2,W
0715E:  MOVFF  01,FE9
07162:  MOVWF  FEA
07164:  MOVFF  9AE,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
07168:  MOVLW  0D
0716A:  ADDWF  xA1,W
0716C:  MOVWF  xB3
0716E:  MOVLW  00
07170:  ADDWFC xA2,W
07172:  MOVWF  xB4
07174:  MOVWF  FEA
07176:  MOVFF  9B3,FE9
0717A:  CLRF   00
0717C:  CLRF   02
0717E:  MOVLW  13
07180:  MOVWF  01
07182:  MOVLB  0
07184:  CALL   34AE
....................       }  
07188:  BRA    729E
0718A:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
0718C:  MOVF   xA1,F
0718E:  BNZ   7194
07190:  MOVF   xA2,F
07192:  BZ    71AC
07194:  MOVLW  0B
07196:  ADDWF  xA1,W
07198:  MOVWF  01
0719A:  MOVLW  00
0719C:  ADDWFC xA2,W
0719E:  MOVWF  03
071A0:  MOVFF  01,FE9
071A4:  MOVWF  FEA
071A6:  MOVF   FEF,W
071A8:  ANDLW  11
071AA:  BZ    71B2
....................             return (FR_DENIED); 
071AC:  MOVLW  05
071AE:  MOVWF  01
071B0:  BRA    74E2
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
071B2:  BTFSS  x91.3
071B4:  BRA    729C
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
071B6:  MOVLW  20
071B8:  MOVLB  7
071BA:  ADDWF  x0E,W
071BC:  MOVWF  FE9
071BE:  MOVLW  00
071C0:  ADDWFC x0F,W
071C2:  MOVWF  FEA
071C4:  MOVFF  FEF,9AF
071C8:  MOVFF  FEC,9B0
071CC:  MOVFF  FEC,9B1
071D0:  MOVFF  FEC,9B2
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
071D4:  MOVLW  14
071D6:  MOVLB  9
071D8:  ADDWF  xA1,W
071DA:  MOVWF  01
071DC:  MOVLW  00
071DE:  ADDWFC xA2,W
071E0:  MOVWF  03
071E2:  MOVFF  01,FE9
071E6:  MOVWF  FEA
071E8:  MOVFF  FEC,9BB
071EC:  MOVF   FED,F
071EE:  MOVFF  FEF,9B3
071F2:  CLRF   xB5
071F4:  MOVFF  9B3,9BA
071F8:  CLRF   xB3
071FA:  CLRF   xB4
071FC:  MOVLW  1A
071FE:  ADDWF  xA1,W
07200:  MOVWF  01
07202:  MOVLW  00
07204:  ADDWFC xA2,W
07206:  MOVFF  01,FE9
0720A:  MOVWF  FEA
0720C:  MOVFF  FEC,03
07210:  MOVF   FED,F
07212:  MOVF   FEF,W
07214:  IORWF  xB3,F
07216:  MOVF   03,W
07218:  IORWF  xB4,F
0721A:  MOVFF  9B4,9B9
0721E:  MOVFF  9B3,9B8
07222:  MOVLB  0
07224:  RCALL  6E8E
07226:  MOVF   01,F
07228:  BZ    7242
0722A:  MOVFF  9B2,9F0
0722E:  MOVFF  9B1,9EF
07232:  MOVFF  9B0,9EE
07236:  MOVFF  9AF,9ED
0723A:  CALL   5A02
0723E:  MOVF   01,F
07240:  BNZ   724C
....................                return (FR_RW_ERROR); 
07242:  MOVLW  07
07244:  MOVWF  01
07246:  MOVLB  9
07248:  BRA    74E2
0724A:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
0724C:  MOVLW  14
0724E:  MOVLB  9
07250:  ADDWF  xA1,W
07252:  MOVWF  01
07254:  MOVLW  00
07256:  ADDWFC xA2,W
07258:  MOVFF  01,FE9
0725C:  MOVWF  FEA
0725E:  CLRF   FEC
07260:  MOVF   FED,F
07262:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
07264:  MOVLW  1A
07266:  ADDWF  xA1,W
07268:  MOVWF  01
0726A:  MOVLW  00
0726C:  ADDWFC xA2,W
0726E:  MOVFF  01,FE9
07272:  MOVWF  FEA
07274:  CLRF   FEC
07276:  MOVF   FED,F
07278:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
0727A:  MOVLW  1C
0727C:  ADDWF  xA1,W
0727E:  MOVWF  01
07280:  MOVLW  00
07282:  ADDWFC xA2,W
07284:  MOVFF  01,FE9
07288:  MOVWF  FEA
0728A:  MOVF   FEE,F
0728C:  MOVF   FEE,F
0728E:  CLRF   FEC
07290:  MOVF   FED,F
07292:  CLRF   FEF
07294:  MOVF   FED,F
07296:  CLRF   FEF
07298:  MOVF   FED,F
0729A:  CLRF   FEF
0729C:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
0729E:  MOVLB  9
072A0:  BTFSS  x91.3
072A2:  BRA    7322
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
072A4:  MOVLW  0B
072A6:  ADDWF  xA1,W
072A8:  MOVWF  01
072AA:  MOVLW  00
072AC:  ADDWFC xA2,W
072AE:  MOVFF  01,FE9
072B2:  MOVWF  FEA
072B4:  MOVLW  20
072B6:  MOVWF  FEF
....................          dw = get_fattime(); 
072B8:  MOVLB  0
072BA:  RCALL  6F2E
072BC:  MOVFF  03,9B2
072C0:  MOVFF  02,9B1
072C4:  MOVFF  01,9B0
072C8:  MOVFF  00,9AF
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
072CC:  MOVLW  0E
072CE:  MOVLB  9
072D0:  ADDWF  xA1,W
072D2:  MOVWF  01
072D4:  MOVLW  00
072D6:  ADDWFC xA2,W
072D8:  MOVFF  01,FE9
072DC:  MOVWF  FEA
072DE:  MOVFF  9AF,FEF
072E2:  MOVFF  9B0,FEC
072E6:  MOVFF  9B1,FEC
072EA:  MOVFF  9B2,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
072EE:  MOVLW  16
072F0:  ADDWF  xA1,W
072F2:  MOVWF  01
072F4:  MOVLW  00
072F6:  ADDWFC xA2,W
072F8:  MOVFF  01,FE9
072FC:  MOVWF  FEA
072FE:  MOVFF  9AF,FEF
07302:  MOVFF  9B0,FEC
07306:  MOVFF  9B1,FEC
0730A:  MOVFF  9B2,FEC
....................          fs->winflag = 1; 
0730E:  MOVLW  06
07310:  MOVLB  7
07312:  ADDWF  x0E,W
07314:  MOVWF  FE9
07316:  MOVLW  00
07318:  ADDWFC x0F,W
0731A:  MOVWF  FEA
0731C:  MOVLW  01
0731E:  MOVWF  FEF
07320:  MOVLB  9
....................       } 
....................    } 
07322:  BRA    7372
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
07324:  MOVF   xA0,F
07326:  BZ    732E
....................          return (result);      // Trace failed  
07328:  MOVFF  9A0,01
0732C:  BRA    74E2
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
0732E:  MOVF   xA1,F
07330:  BNZ   7336
07332:  MOVF   xA2,F
07334:  BZ    734C
07336:  MOVLW  0B
07338:  ADDWF  xA1,W
0733A:  MOVWF  01
0733C:  MOVLW  00
0733E:  ADDWFC xA2,W
07340:  MOVWF  03
07342:  MOVFF  01,FE9
07346:  MOVWF  FEA
07348:  BTFSS  FEF.4
0734A:  BRA    7352
....................          return (FR_NO_FILE); 
0734C:  MOVLW  02
0734E:  MOVWF  01
07350:  BRA    74E2
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
07352:  BTFSS  x91.1
07354:  BRA    7372
07356:  MOVLW  0B
07358:  ADDWF  xA1,W
0735A:  MOVWF  01
0735C:  MOVLW  00
0735E:  ADDWFC xA2,W
07360:  MOVWF  03
07362:  MOVFF  01,FE9
07366:  MOVWF  FEA
07368:  BTFSS  FEF.0
0736A:  BRA    7372
....................          return (FR_DENIED); 
0736C:  MOVLW  05
0736E:  MOVWF  01
07370:  BRA    74E2
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
07372:  MOVLW  1A
07374:  ADDWF  x8D,W
07376:  MOVWF  FE9
07378:  MOVLW  00
0737A:  ADDWFC x8E,W
0737C:  MOVWF  FEA
0737E:  MOVF   x91,W
07380:  ANDLW  03
07382:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
07384:  MOVLW  14
07386:  ADDWF  x8D,W
07388:  MOVWF  01
0738A:  MOVLW  00
0738C:  ADDWFC x8E,W
0738E:  MOVWF  03
07390:  MOVFF  01,9B3
07394:  MOVWF  xB4
07396:  MOVLW  20
07398:  MOVLB  7
0739A:  ADDWF  x0E,W
0739C:  MOVWF  FE9
0739E:  MOVLW  00
073A0:  ADDWFC x0F,W
073A2:  MOVWF  FEA
073A4:  MOVFF  FEF,00
073A8:  MOVFF  FEC,01
073AC:  MOVFF  FEC,02
073B0:  MOVFF  FEC,03
073B4:  MOVFF  9B4,FEA
073B8:  MOVFF  9B3,FE9
073BC:  MOVFF  00,FEF
073C0:  MOVFF  01,FEC
073C4:  MOVFF  02,FEC
073C8:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
073CC:  MOVLW  18
073CE:  MOVLB  9
073D0:  ADDWF  x8D,W
073D2:  MOVWF  FE9
073D4:  MOVLW  00
073D6:  ADDWFC x8E,W
073D8:  MOVWF  FEA
073DA:  MOVFF  9A2,FEC
073DE:  MOVF   FED,F
073E0:  MOVFF  9A1,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
073E4:  MOVLW  08
073E6:  ADDWF  x8D,W
073E8:  MOVWF  01
073EA:  MOVLW  00
073EC:  ADDWFC x8E,W
073EE:  MOVWF  03
073F0:  MOVFF  01,9B3
073F4:  MOVWF  xB4
073F6:  MOVLW  14
073F8:  ADDWF  xA1,W
073FA:  MOVWF  01
073FC:  MOVLW  00
073FE:  ADDWFC xA2,W
07400:  MOVWF  03
07402:  MOVFF  01,FE9
07406:  MOVWF  FEA
07408:  MOVFF  FEC,9B8
0740C:  MOVF   FED,F
0740E:  MOVFF  FEF,9B5
07412:  CLRF   xB7
07414:  MOVFF  9B5,9B7
07418:  CLRF   xB5
0741A:  CLRF   xB6
0741C:  MOVLW  1A
0741E:  ADDWF  xA1,W
07420:  MOVWF  01
07422:  MOVLW  00
07424:  ADDWFC xA2,W
07426:  MOVFF  01,FE9
0742A:  MOVWF  FEA
0742C:  MOVFF  FEC,03
07430:  MOVF   FED,F
07432:  MOVF   FEF,W
07434:  IORWF  xB5,W
07436:  MOVWF  00
07438:  MOVF   03,W
0743A:  IORWF  xB6,W
0743C:  MOVFF  9B7,02
07440:  MOVFF  9B8,03
07444:  MOVFF  9B4,FEA
07448:  MOVFF  9B3,FE9
0744C:  MOVFF  00,FEF
07450:  MOVWF  FEC
07452:  MOVFF  9B7,FEC
07456:  MOVFF  9B8,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
0745A:  MOVLW  04
0745C:  ADDWF  x8D,W
0745E:  MOVWF  01
07460:  MOVLW  00
07462:  ADDWFC x8E,W
07464:  MOVWF  03
07466:  MOVFF  01,9B3
0746A:  MOVWF  xB4
0746C:  MOVLW  1C
0746E:  ADDWF  xA1,W
07470:  MOVWF  01
07472:  MOVLW  00
07474:  ADDWFC xA2,W
07476:  MOVFF  01,FE9
0747A:  MOVWF  FEA
0747C:  MOVFF  FEF,00
07480:  MOVFF  FEC,01
07484:  MOVFF  FEC,02
07488:  MOVFF  FEC,03
0748C:  MOVFF  9B4,FEA
07490:  MOVFF  9B3,FE9
07494:  MOVFF  00,FEF
07498:  MOVFF  01,FEC
0749C:  MOVFF  02,FEC
074A0:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
074A4:  MOVFF  98D,FE9
074A8:  MOVFF  98E,FEA
074AC:  MOVF   FEE,F
074AE:  MOVF   FEE,F
074B0:  CLRF   FEC
074B2:  MOVF   FED,F
074B4:  CLRF   FEF
074B6:  MOVF   FED,F
074B8:  CLRF   FEF
074BA:  MOVF   FED,F
074BC:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
074BE:  MOVLW  1B
074C0:  ADDWF  x8D,W
074C2:  MOVWF  FE9
074C4:  MOVLW  00
074C6:  ADDWFC x8E,W
074C8:  MOVWF  FEA
074CA:  MOVLW  01
074CC:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
074CE:  MOVLB  7
074D0:  ADDWF  x0E,W
074D2:  MOVWF  FE9
074D4:  MOVLW  00
074D6:  ADDWFC x0F,W
074D8:  MOVWF  FEA
074DA:  INCF   FEF,F
....................    return (FR_OK); 
074DC:  MOVLW  00
074DE:  MOVWF  01
074E0:  MOVLB  9
074E2:  MOVLB  0
074E4:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B0DA:  MOVFF  8AC,8C1
0B0DE:  MOVFF  8AB,8C0
....................       *br = 0; 
0B0E2:  MOVLB  8
0B0E4:  MOVFF  8AF,FE9
0B0E8:  MOVFF  8B0,FEA
0B0EC:  CLRF   FEC
0B0EE:  MOVF   FED,F
0B0F0:  CLRF   FEF
....................       if (!fs)  
0B0F2:  MOVLB  7
0B0F4:  MOVF   x0E,W
0B0F6:  IORWF  x0F,W
0B0F8:  BNZ   B100
....................          return (FR_NOT_ENABLED); 
0B0FA:  MOVLW  0B
0B0FC:  MOVWF  01
0B0FE:  BRA    B5E2
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B100:  MOVLB  0
0B102:  CALL   551C
0B106:  BTFSC  01.0
0B108:  BRA    B11A
0B10A:  MOVLB  7
0B10C:  MOVFF  70E,FE9
0B110:  MOVFF  70F,FEA
0B114:  MOVF   FEF,F
0B116:  BNZ   B122
0B118:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B11A:  MOVLW  01
0B11C:  MOVWF  01
0B11E:  MOVLB  7
0B120:  BRA    B5E2
....................     
....................       if (fp->flag & FA__ERROR) 
0B122:  MOVLW  1A
0B124:  MOVLB  8
0B126:  ADDWF  xA9,W
0B128:  MOVWF  FE9
0B12A:  MOVLW  00
0B12C:  ADDWFC xAA,W
0B12E:  MOVWF  FEA
0B130:  BTFSS  FEF.7
0B132:  BRA    B13E
....................          return (FR_RW_ERROR);   // Check error flag  
0B134:  MOVLW  07
0B136:  MOVWF  01
0B138:  MOVLB  7
0B13A:  BRA    B5E2
0B13C:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B13E:  MOVLW  1A
0B140:  ADDWF  xA9,W
0B142:  MOVWF  FE9
0B144:  MOVLW  00
0B146:  ADDWFC xAA,W
0B148:  MOVWF  FEA
0B14A:  BTFSC  FEF.0
0B14C:  BRA    B158
....................          return (FR_DENIED);      // Check access mode  
0B14E:  MOVLW  05
0B150:  MOVWF  01
0B152:  MOVLB  7
0B154:  BRA    B5E2
0B156:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B158:  MOVLW  04
0B15A:  ADDWF  xA9,W
0B15C:  MOVWF  FE9
0B15E:  MOVLW  00
0B160:  ADDWFC xAA,W
0B162:  MOVWF  FEA
0B164:  MOVFF  FEF,8C2
0B168:  MOVFF  FEC,8C3
0B16C:  MOVFF  FEC,8C4
0B170:  MOVFF  FEC,8C5
0B174:  MOVFF  8A9,FE9
0B178:  MOVFF  8AA,FEA
0B17C:  MOVFF  FEF,00
0B180:  MOVFF  FEC,01
0B184:  MOVFF  FEC,02
0B188:  MOVFF  FEC,03
0B18C:  MOVF   00,W
0B18E:  SUBWF  xC2,W
0B190:  MOVWF  xB9
0B192:  MOVF   01,W
0B194:  SUBWFB xC3,W
0B196:  MOVWF  xBA
0B198:  MOVF   02,W
0B19A:  SUBWFB xC4,W
0B19C:  MOVWF  xBB
0B19E:  MOVF   03,W
0B1A0:  SUBWFB xC5,W
0B1A2:  MOVWF  xBC
....................       if (btr > ln) 
0B1A4:  MOVF   xBC,F
0B1A6:  BNZ   B1C2
0B1A8:  MOVF   xBB,F
0B1AA:  BNZ   B1C2
0B1AC:  MOVF   xBA,W
0B1AE:  SUBWF  xAE,W
0B1B0:  BNC   B1C2
0B1B2:  BNZ   B1BA
0B1B4:  MOVF   xAD,W
0B1B6:  SUBWF  xB9,W
0B1B8:  BC    B1C2
....................          btr = ln;            // Truncate read count by number of bytes left  
0B1BA:  MOVFF  8BA,8AE
0B1BE:  MOVFF  8B9,8AD
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B1C2:  MOVF   xAD,W
0B1C4:  IORWF  xAE,W
0B1C6:  BTFSC  FD8.2
0B1C8:  BRA    B5C0
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B1CA:  MOVFF  8A9,FE9
0B1CE:  MOVFF  8AA,FEA
0B1D2:  MOVFF  FEF,8C2
0B1D6:  MOVFF  FEC,8C3
0B1DA:  MOVFF  FEC,8C4
0B1DE:  MOVFF  FEC,8C5
0B1E2:  MOVLW  01
0B1E4:  ANDWF  xC3,F
0B1E6:  CLRF   xC4
0B1E8:  CLRF   xC5
0B1EA:  MOVF   xC2,F
0B1EC:  BTFSS  FD8.2
0B1EE:  BRA    B468
0B1F0:  MOVF   xC3,F
0B1F2:  BTFSS  FD8.2
0B1F4:  BRA    B468
0B1F6:  MOVF   xC4,F
0B1F8:  BTFSS  FD8.2
0B1FA:  BRA    B468
0B1FC:  MOVF   xC5,F
0B1FE:  BTFSS  FD8.2
0B200:  BRA    B468
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B202:  MOVLW  1B
0B204:  ADDWF  xA9,W
0B206:  MOVWF  FE9
0B208:  MOVLW  00
0B20A:  ADDWFC xAA,W
0B20C:  MOVWF  FEA
0B20E:  DECF   FEF,F
0B210:  BZ    B248
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B212:  MOVLW  10
0B214:  ADDWF  xA9,W
0B216:  MOVWF  FE9
0B218:  MOVLW  00
0B21A:  ADDWFC xAA,W
0B21C:  MOVWF  FEA
0B21E:  MOVFF  FEF,8C2
0B222:  MOVFF  FEC,8C3
0B226:  MOVFF  FEC,8C4
0B22A:  MOVFF  FEC,8C5
0B22E:  MOVLW  01
0B230:  ADDWF  xC2,W
0B232:  MOVWF  xB5
0B234:  MOVLW  00
0B236:  ADDWFC xC3,W
0B238:  MOVWF  xB6
0B23A:  MOVLW  00
0B23C:  ADDWFC xC4,W
0B23E:  MOVWF  xB7
0B240:  MOVLW  00
0B242:  ADDWFC xC5,W
0B244:  MOVWF  xB8
....................                }  
0B246:  BRA    B384
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B248:  MOVFF  8A9,FE9
0B24C:  MOVFF  8AA,FEA
0B250:  MOVFF  FEF,8C2
0B254:  MOVFF  FEC,8C3
0B258:  MOVFF  FEC,8C4
0B25C:  MOVFF  FEC,8C5
0B260:  MOVF   xC2,F
0B262:  BNZ   B28E
0B264:  MOVF   xC3,F
0B266:  BNZ   B28E
0B268:  MOVF   xC4,F
0B26A:  BNZ   B28E
0B26C:  MOVF   xC5,F
0B26E:  BNZ   B28E
0B270:  MOVLW  08
0B272:  ADDWF  xA9,W
0B274:  MOVWF  FE9
0B276:  MOVLW  00
0B278:  ADDWFC xAA,W
0B27A:  MOVWF  FEA
0B27C:  MOVFF  FEF,00
0B280:  MOVFF  FEC,01
0B284:  MOVFF  FEC,02
0B288:  MOVFF  FEC,03
0B28C:  BRA    B2B2
0B28E:  MOVLW  0C
0B290:  ADDWF  xA9,W
0B292:  MOVWF  FE9
0B294:  MOVLW  00
0B296:  ADDWFC xAA,W
0B298:  MOVWF  FEA
0B29A:  MOVFF  FEF,9D9
0B29E:  MOVFF  FEC,9DA
0B2A2:  MOVFF  FEC,9DB
0B2A6:  MOVFF  FEC,9DC
0B2AA:  MOVLB  0
0B2AC:  CALL   5C3A
0B2B0:  MOVLB  8
0B2B2:  MOVFF  03,8B4
0B2B6:  MOVFF  02,8B3
0B2BA:  MOVFF  01,8B2
0B2BE:  MOVFF  00,8B1
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B2C2:  MOVF   xB4,F
0B2C4:  BNZ   B2D4
0B2C6:  MOVF   xB3,F
0B2C8:  BNZ   B2D4
0B2CA:  MOVF   xB2,F
0B2CC:  BNZ   B2D4
0B2CE:  MOVF   xB1,W
0B2D0:  SUBLW  01
0B2D2:  BC    B312
0B2D4:  MOVLW  0C
0B2D6:  MOVLB  7
0B2D8:  ADDWF  x0E,W
0B2DA:  MOVWF  FE9
0B2DC:  MOVLW  00
0B2DE:  ADDWFC x0F,W
0B2E0:  MOVWF  FEA
0B2E2:  MOVFF  FEF,00
0B2E6:  MOVFF  FEC,01
0B2EA:  MOVFF  FEC,02
0B2EE:  MOVFF  FEC,03
0B2F2:  MOVF   03,W
0B2F4:  MOVLB  8
0B2F6:  SUBWF  xB4,W
0B2F8:  BNC   B314
0B2FA:  BNZ   B312
0B2FC:  MOVF   02,W
0B2FE:  SUBWF  xB3,W
0B300:  BNC   B314
0B302:  BNZ   B312
0B304:  MOVF   01,W
0B306:  SUBWF  xB2,W
0B308:  BNC   B314
0B30A:  BNZ   B312
0B30C:  MOVF   00,W
0B30E:  SUBWF  xB1,W
0B310:  BNC   B314
....................                   goto fr_error; 
0B312:  BRA    B5CA
....................                fp->curr_clust = clust;            // Current cluster  
0B314:  MOVLW  0C
0B316:  ADDWF  xA9,W
0B318:  MOVWF  FE9
0B31A:  MOVLW  00
0B31C:  ADDWFC xAA,W
0B31E:  MOVWF  FEA
0B320:  MOVFF  8B1,FEF
0B324:  MOVFF  8B2,FEC
0B328:  MOVFF  8B3,FEC
0B32C:  MOVFF  8B4,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B330:  MOVFF  8B4,9CF
0B334:  MOVFF  8B3,9CE
0B338:  MOVFF  8B2,9CD
0B33C:  MOVFF  8B1,9CC
0B340:  MOVLB  0
0B342:  CALL   558C
0B346:  MOVFF  03,8B8
0B34A:  MOVFF  02,8B7
0B34E:  MOVFF  01,8B6
0B352:  MOVFF  00,8B5
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B356:  MOVLW  1B
0B358:  MOVLB  8
0B35A:  ADDWF  xA9,W
0B35C:  MOVWF  01
0B35E:  MOVLW  00
0B360:  ADDWFC xAA,W
0B362:  MOVWF  03
0B364:  MOVLW  02
0B366:  MOVLB  7
0B368:  ADDWF  x0E,W
0B36A:  MOVWF  FE9
0B36C:  MOVLW  00
0B36E:  ADDWFC x0F,W
0B370:  MOVWF  FEA
0B372:  MOVFF  FEF,8C4
0B376:  MOVLB  8
0B378:  MOVFF  03,FEA
0B37C:  MOVFF  01,FE9
0B380:  MOVFF  8C4,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B384:  MOVLW  10
0B386:  ADDWF  xA9,W
0B388:  MOVWF  FE9
0B38A:  MOVLW  00
0B38C:  ADDWFC xAA,W
0B38E:  MOVWF  FEA
0B390:  MOVFF  8B5,FEF
0B394:  MOVFF  8B6,FEC
0B398:  MOVFF  8B7,FEC
0B39C:  MOVFF  8B8,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B3A0:  BCF    FD8.0
0B3A2:  RRCF   xAE,W
0B3A4:  MOVWF  xBF
....................             if (cc)  
0B3A6:  MOVF   xBF,F
0B3A8:  BZ    B468
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B3AA:  MOVLW  1B
0B3AC:  ADDWF  xA9,W
0B3AE:  MOVWF  FE9
0B3B0:  MOVLW  00
0B3B2:  ADDWFC xAA,W
0B3B4:  MOVWF  FEA
0B3B6:  MOVF   FEF,W
0B3B8:  SUBWF  xBF,W
0B3BA:  BZ    B3CE
0B3BC:  BNC   B3CE
....................                   cc = fp->sect_clust; 
0B3BE:  MOVLW  1B
0B3C0:  ADDWF  xA9,W
0B3C2:  MOVWF  FE9
0B3C4:  MOVLW  00
0B3C6:  ADDWFC xAA,W
0B3C8:  MOVWF  FEA
0B3CA:  MOVFF  FEF,8BF
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B3CE:  MOVFF  8C1,9FA
0B3D2:  MOVFF  8C0,9F9
0B3D6:  MOVFF  8B8,9FE
0B3DA:  MOVFF  8B7,9FD
0B3DE:  MOVFF  8B6,9FC
0B3E2:  MOVFF  8B5,9FB
0B3E6:  MOVFF  8BF,9FF
0B3EA:  MOVLB  0
0B3EC:  CALL   4454
0B3F0:  MOVF   01,F
0B3F2:  BZ    B3FA
....................                   goto fr_error; 
0B3F4:  MOVLB  8
0B3F6:  BRA    B5CA
0B3F8:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B3FA:  MOVLW  1B
0B3FC:  MOVLB  8
0B3FE:  ADDWF  xA9,W
0B400:  MOVWF  FE9
0B402:  MOVLW  00
0B404:  ADDWFC xAA,W
0B406:  MOVWF  FEA
0B408:  MOVLW  01
0B40A:  SUBWF  xBF,W
0B40C:  SUBWF  FEF,W
0B40E:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B410:  MOVLW  10
0B412:  ADDWF  xA9,W
0B414:  MOVWF  FE9
0B416:  MOVLW  00
0B418:  ADDWFC xAA,W
0B41A:  MOVWF  FEA
0B41C:  MOVLW  01
0B41E:  SUBWF  xBF,W
0B420:  ADDWF  FEF,W
0B422:  MOVWF  00
0B424:  MOVLW  00
0B426:  ADDWFC FEC,W
0B428:  MOVWF  01
0B42A:  MOVLW  00
0B42C:  ADDWFC FEC,W
0B42E:  MOVWF  02
0B430:  MOVLW  00
0B432:  ADDWFC FEC,W
0B434:  MOVF   FED,F
0B436:  MOVF   FED,F
0B438:  MOVF   FED,F
0B43A:  MOVFF  00,FEF
0B43E:  MOVFF  01,FEC
0B442:  MOVFF  02,FEC
0B446:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B448:  MOVLB  9
0B44A:  CLRF   xEA
0B44C:  MOVFF  8BF,9E9
0B450:  MOVLW  02
0B452:  MOVWF  xEC
0B454:  CLRF   xEB
0B456:  MOVLB  0
0B458:  CALL   5C18
0B45C:  MOVFF  02,8BE
0B460:  MOVFF  01,8BD
....................                continue; 
0B464:  BRA    B55C
0B466:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B468:  MOVLW  10
0B46A:  ADDWF  xA9,W
0B46C:  MOVWF  FE9
0B46E:  MOVLW  00
0B470:  ADDWFC xAA,W
0B472:  MOVWF  FEA
0B474:  MOVFF  FEF,9ED
0B478:  MOVFF  FEC,9EE
0B47C:  MOVFF  FEC,9EF
0B480:  MOVFF  FEC,9F0
0B484:  MOVLB  0
0B486:  CALL   5A02
0B48A:  MOVF   01,F
0B48C:  BNZ   B494
....................                goto fr_error; 
0B48E:  MOVLB  8
0B490:  BRA    B5CA
0B492:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B494:  MOVLB  8
0B496:  MOVFF  8A9,FE9
0B49A:  MOVFF  8AA,FEA
0B49E:  MOVFF  FEF,8C2
0B4A2:  MOVFF  FEC,8C3
0B4A6:  MOVFF  FEC,8C4
0B4AA:  MOVFF  FEC,8C5
0B4AE:  MOVF   xC3,W
0B4B0:  ANDLW  01
0B4B2:  MOVWF  01
0B4B4:  MOVLW  00
0B4B6:  BSF    FD8.0
0B4B8:  SUBFWB xC2,W
0B4BA:  MOVWF  xBD
0B4BC:  MOVLW  02
0B4BE:  SUBFWB 01,W
0B4C0:  MOVWF  xBE
....................          if (rcnt > btr) 
0B4C2:  MOVF   xAE,W
0B4C4:  SUBWF  xBE,W
0B4C6:  BNC   B4D8
0B4C8:  BNZ   B4D0
0B4CA:  MOVF   xBD,W
0B4CC:  SUBWF  xAD,W
0B4CE:  BC    B4D8
....................             rcnt = btr; 
0B4D0:  MOVFF  8AE,8BE
0B4D4:  MOVFF  8AD,8BD
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B4D8:  MOVFF  8A9,FE9
0B4DC:  MOVFF  8AA,FEA
0B4E0:  MOVFF  FEF,8C2
0B4E4:  MOVFF  FEC,8C3
0B4E8:  MOVFF  FEC,8C4
0B4EC:  MOVFF  FEC,8C5
0B4F0:  MOVLW  01
0B4F2:  ANDWF  xC3,F
0B4F4:  CLRF   xC4
0B4F6:  CLRF   xC5
0B4F8:  MOVLW  24
0B4FA:  ADDWF  xC2,W
0B4FC:  MOVWF  00
0B4FE:  MOVLW  00
0B500:  ADDWFC xC3,W
0B502:  MOVWF  01
0B504:  MOVLW  00
0B506:  ADDWFC xC4,W
0B508:  MOVWF  02
0B50A:  MOVLW  00
0B50C:  ADDWFC xC5,W
0B50E:  MOVWF  03
0B510:  MOVFF  01,03
0B514:  MOVF   00,W
0B516:  MOVLB  7
0B518:  ADDWF  x0E,W
0B51A:  MOVWF  01
0B51C:  MOVF   x0F,W
0B51E:  ADDWFC 03,F
0B520:  MOVFF  01,8C6
0B524:  MOVLB  8
0B526:  MOVFF  03,8C7
0B52A:  MOVFF  8C1,FEA
0B52E:  MOVFF  8C0,FE9
0B532:  MOVFF  03,FE2
0B536:  MOVFF  01,FE1
0B53A:  MOVFF  8BE,02
0B53E:  MOVFF  8BD,01
0B542:  MOVF   01,F
0B544:  BZ    B54A
0B546:  INCF   02,F
0B548:  BRA    B54E
0B54A:  MOVF   02,F
0B54C:  BZ    B55A
0B54E:  MOVFF  FE6,FEE
0B552:  DECFSZ 01,F
0B554:  BRA    B54E
0B556:  DECFSZ 02,F
0B558:  BRA    B54E
0B55A:  MOVLB  0
0B55C:  MOVLB  8
0B55E:  MOVF   xBD,W
0B560:  ADDWF  xC0,F
0B562:  MOVF   xBE,W
0B564:  ADDWFC xC1,F
0B566:  MOVFF  8A9,FE9
0B56A:  MOVFF  8AA,FEA
0B56E:  MOVF   xBD,W
0B570:  ADDWF  FEF,W
0B572:  MOVWF  00
0B574:  MOVF   xBE,W
0B576:  ADDWFC FEC,W
0B578:  MOVWF  01
0B57A:  MOVLW  00
0B57C:  ADDWFC FEC,W
0B57E:  MOVWF  02
0B580:  MOVLW  00
0B582:  ADDWFC FEC,W
0B584:  MOVWF  03
0B586:  MOVF   FED,F
0B588:  MOVF   FED,F
0B58A:  MOVF   FED,F
0B58C:  MOVFF  00,FEF
0B590:  MOVFF  01,FEC
0B594:  MOVFF  02,FEC
0B598:  MOVWF  FEC
0B59A:  MOVFF  8AF,FE9
0B59E:  MOVFF  8B0,FEA
0B5A2:  MOVF   xBD,W
0B5A4:  ADDWF  FEF,W
0B5A6:  MOVWF  01
0B5A8:  MOVF   xBE,W
0B5AA:  ADDWFC FEC,W
0B5AC:  MOVWF  03
0B5AE:  MOVF   FED,F
0B5B0:  MOVFF  01,FEF
0B5B4:  MOVWF  FEC
0B5B6:  MOVF   xBD,W
0B5B8:  SUBWF  xAD,F
0B5BA:  MOVF   xBE,W
0B5BC:  SUBWFB xAE,F
0B5BE:  BRA    B1C2
....................          } 
....................       return (FR_OK); 
0B5C0:  MOVLW  00
0B5C2:  MOVWF  01
0B5C4:  MOVLB  7
0B5C6:  BRA    B5E2
0B5C8:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B5CA:  MOVLW  1A
0B5CC:  ADDWF  xA9,W
0B5CE:  MOVWF  FE9
0B5D0:  MOVLW  00
0B5D2:  ADDWFC xAA,W
0B5D4:  MOVWF  FEA
0B5D6:  MOVF   FEF,W
0B5D8:  IORLW  80
0B5DA:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B5DC:  MOVLW  07
0B5DE:  MOVWF  01
0B5E0:  MOVLB  7
0B5E2:  MOVLB  0
0B5E4:  GOTO   B7E0 (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
07940:  MOVFF  990,9A1
07944:  MOVFF  98F,9A0
....................       *bw = 0; 
07948:  MOVLB  9
0794A:  MOVFF  993,FE9
0794E:  MOVFF  994,FEA
07952:  CLRF   FEC
07954:  MOVF   FED,F
07956:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
07958:  CLRF   x9E
0795A:  CLRF   x9D
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
0795C:  MOVLB  7
0795E:  MOVF   x0E,W
07960:  IORWF  x0F,W
07962:  BNZ   796A
....................          return (FR_NOT_ENABLED); 
07964:  MOVLW  0B
07966:  MOVWF  01
07968:  BRA    8006
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
0796A:  MOVLB  0
0796C:  CALL   551C
07970:  BTFSC  01.0
07972:  BRA    7984
07974:  MOVLB  7
07976:  MOVFF  70E,FE9
0797A:  MOVFF  70F,FEA
0797E:  MOVF   FEF,F
07980:  BNZ   798C
07982:  MOVLB  0
....................          return (FR_NOT_READY); 
07984:  MOVLW  01
07986:  MOVWF  01
07988:  MOVLB  7
0798A:  BRA    8006
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
0798C:  MOVLW  1A
0798E:  MOVLB  9
07990:  ADDWF  x8D,W
07992:  MOVWF  FE9
07994:  MOVLW  00
07996:  ADDWFC x8E,W
07998:  MOVWF  FEA
0799A:  BTFSS  FEF.7
0799C:  BRA    79A8
....................          return (FR_RW_ERROR);         // Check error flag  
0799E:  MOVLW  07
079A0:  MOVWF  01
079A2:  MOVLB  7
079A4:  BRA    8006
079A6:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
079A8:  MOVLW  1A
079AA:  ADDWF  x8D,W
079AC:  MOVWF  FE9
079AE:  MOVLW  00
079B0:  ADDWFC x8E,W
079B2:  MOVWF  FEA
079B4:  BTFSC  FEF.1
079B6:  BRA    79C2
....................          return (FR_DENIED);            // Check access mode  
079B8:  MOVLW  05
079BA:  MOVWF  01
079BC:  MOVLB  7
079BE:  BRA    8006
079C0:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
079C2:  MOVLW  04
079C4:  ADDWF  x8D,W
079C6:  MOVWF  FE9
079C8:  MOVLW  00
079CA:  ADDWFC x8E,W
079CC:  MOVWF  FEA
079CE:  MOVFF  FEF,9A2
079D2:  MOVFF  FEC,9A3
079D6:  MOVFF  FEC,9A4
079DA:  MOVFF  FEC,9A5
079DE:  MOVF   x91,W
079E0:  ADDWF  xA2,F
079E2:  MOVF   x92,W
079E4:  ADDWFC xA3,F
079E6:  MOVLW  00
079E8:  ADDWFC xA4,F
079EA:  ADDWFC xA5,F
079EC:  MOVLW  04
079EE:  ADDWF  x8D,W
079F0:  MOVWF  FE9
079F2:  MOVLW  00
079F4:  ADDWFC x8E,W
079F6:  MOVWF  FEA
079F8:  MOVFF  FEF,00
079FC:  MOVFF  FEC,01
07A00:  MOVFF  FEC,02
07A04:  MOVFF  FEC,03
07A08:  MOVF   xA5,W
07A0A:  SUBWF  03,W
07A0C:  BNC   7A2A
07A0E:  BNZ   7A26
07A10:  MOVF   xA4,W
07A12:  SUBWF  02,W
07A14:  BNC   7A2A
07A16:  BNZ   7A26
07A18:  MOVF   xA3,W
07A1A:  SUBWF  01,W
07A1C:  BNC   7A2A
07A1E:  BNZ   7A26
07A20:  MOVF   00,W
07A22:  SUBWF  xA2,W
07A24:  BC    7A2A
....................          btw = 0;                  // File size cannot reach 4GB  
07A26:  CLRF   x92
07A28:  CLRF   x91
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07A2A:  MOVF   x91,W
07A2C:  IORWF  x92,W
07A2E:  BTFSC  FD8.2
07A30:  BRA    7F3A
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07A32:  MOVFF  98D,FE9
07A36:  MOVFF  98E,FEA
07A3A:  MOVFF  FEF,9A2
07A3E:  MOVFF  FEC,9A3
07A42:  MOVFF  FEC,9A4
07A46:  MOVFF  FEC,9A5
07A4A:  MOVLW  01
07A4C:  ANDWF  xA3,F
07A4E:  CLRF   xA4
07A50:  CLRF   xA5
07A52:  MOVF   xA2,F
07A54:  BTFSS  FD8.2
07A56:  BRA    7DD4
07A58:  MOVF   xA3,F
07A5A:  BTFSS  FD8.2
07A5C:  BRA    7DD4
07A5E:  MOVF   xA4,F
07A60:  BTFSS  FD8.2
07A62:  BRA    7DD4
07A64:  MOVF   xA5,F
07A66:  BTFSS  FD8.2
07A68:  BRA    7DD4
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07A6A:  MOVLW  1B
07A6C:  ADDWF  x8D,W
07A6E:  MOVWF  FE9
07A70:  MOVLW  00
07A72:  ADDWFC x8E,W
07A74:  MOVWF  FEA
07A76:  DECF   FEF,F
07A78:  BZ    7AB0
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07A7A:  MOVLW  10
07A7C:  ADDWF  x8D,W
07A7E:  MOVWF  FE9
07A80:  MOVLW  00
07A82:  ADDWFC x8E,W
07A84:  MOVWF  FEA
07A86:  MOVFF  FEF,9A2
07A8A:  MOVFF  FEC,9A3
07A8E:  MOVFF  FEC,9A4
07A92:  MOVFF  FEC,9A5
07A96:  MOVLW  01
07A98:  ADDWF  xA2,W
07A9A:  MOVWF  x99
07A9C:  MOVLW  00
07A9E:  ADDWFC xA3,W
07AA0:  MOVWF  x9A
07AA2:  MOVLW  00
07AA4:  ADDWFC xA4,W
07AA6:  MOVWF  x9B
07AA8:  MOVLW  00
07AAA:  ADDWFC xA5,W
07AAC:  MOVWF  x9C
....................                }  
07AAE:  BRA    7C46
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07AB0:  MOVFF  98D,FE9
07AB4:  MOVFF  98E,FEA
07AB8:  MOVFF  FEF,9A2
07ABC:  MOVFF  FEC,9A3
07AC0:  MOVFF  FEC,9A4
07AC4:  MOVFF  FEC,9A5
07AC8:  MOVF   xA2,F
07ACA:  BNZ   7B50
07ACC:  MOVF   xA3,F
07ACE:  BNZ   7B50
07AD0:  MOVF   xA4,F
07AD2:  BNZ   7B50
07AD4:  MOVF   xA5,F
07AD6:  BNZ   7B50
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07AD8:  MOVLW  08
07ADA:  ADDWF  x8D,W
07ADC:  MOVWF  FE9
07ADE:  MOVLW  00
07AE0:  ADDWFC x8E,W
07AE2:  MOVWF  FEA
07AE4:  MOVFF  FEF,995
07AE8:  MOVFF  FEC,996
07AEC:  MOVFF  FEC,997
07AF0:  MOVFF  FEC,998
....................                   if (clust == 0)            // No cluster is created  
07AF4:  MOVF   x95,F
07AF6:  BNZ   7B4E
07AF8:  MOVF   x96,F
07AFA:  BNZ   7B4E
07AFC:  MOVF   x97,F
07AFE:  BNZ   7B4E
07B00:  MOVF   x98,F
07B02:  BNZ   7B4E
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07B04:  MOVLW  08
07B06:  ADDWF  x8D,W
07B08:  MOVWF  01
07B0A:  MOVLW  00
07B0C:  ADDWFC x8E,W
07B0E:  MOVWF  03
07B10:  MOVFF  01,9A2
07B14:  MOVWF  xA3
07B16:  CLRF   xC8
07B18:  CLRF   xC7
07B1A:  CLRF   xC6
07B1C:  CLRF   xC5
07B1E:  MOVLB  0
07B20:  CALL   68B4
07B24:  MOVFF  03,998
07B28:  MOVFF  02,997
07B2C:  MOVFF  01,996
07B30:  MOVFF  00,995
07B34:  MOVFF  9A3,FEA
07B38:  MOVFF  9A2,FE9
07B3C:  MOVFF  995,FEF
07B40:  MOVFF  996,FEC
07B44:  MOVFF  997,FEC
07B48:  MOVFF  998,FEC
07B4C:  MOVLB  9
....................                   } 
07B4E:  BRA    7B84
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07B50:  MOVLW  0C
07B52:  ADDWF  x8D,W
07B54:  MOVWF  FE9
07B56:  MOVLW  00
07B58:  ADDWFC x8E,W
07B5A:  MOVWF  FEA
07B5C:  MOVFF  FEF,9C5
07B60:  MOVFF  FEC,9C6
07B64:  MOVFF  FEC,9C7
07B68:  MOVFF  FEC,9C8
07B6C:  MOVLB  0
07B6E:  CALL   68B4
07B72:  MOVFF  03,998
07B76:  MOVFF  02,997
07B7A:  MOVFF  01,996
07B7E:  MOVFF  00,995
07B82:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07B84:  MOVF   x98,F
07B86:  BNZ   7B96
07B88:  MOVF   x97,F
07B8A:  BNZ   7B96
07B8C:  MOVF   x96,F
07B8E:  BNZ   7B96
07B90:  MOVF   x95,W
07B92:  SUBLW  01
07B94:  BC    7BD4
07B96:  MOVLW  0C
07B98:  MOVLB  7
07B9A:  ADDWF  x0E,W
07B9C:  MOVWF  FE9
07B9E:  MOVLW  00
07BA0:  ADDWFC x0F,W
07BA2:  MOVWF  FEA
07BA4:  MOVFF  FEF,00
07BA8:  MOVFF  FEC,01
07BAC:  MOVFF  FEC,02
07BB0:  MOVFF  FEC,03
07BB4:  MOVF   03,W
07BB6:  MOVLB  9
07BB8:  SUBWF  x98,W
07BBA:  BNC   7BD6
07BBC:  BNZ   7BD4
07BBE:  MOVF   02,W
07BC0:  SUBWF  x97,W
07BC2:  BNC   7BD6
07BC4:  BNZ   7BD4
07BC6:  MOVF   01,W
07BC8:  SUBWF  x96,W
07BCA:  BNC   7BD6
07BCC:  BNZ   7BD4
07BCE:  MOVF   00,W
07BD0:  SUBWF  x95,W
07BD2:  BNC   7BD6
....................                   break; 
07BD4:  BRA    7F3A
....................                fp->curr_clust = clust;            // Current cluster  
07BD6:  MOVLW  0C
07BD8:  ADDWF  x8D,W
07BDA:  MOVWF  FE9
07BDC:  MOVLW  00
07BDE:  ADDWFC x8E,W
07BE0:  MOVWF  FEA
07BE2:  MOVFF  995,FEF
07BE6:  MOVFF  996,FEC
07BEA:  MOVFF  997,FEC
07BEE:  MOVFF  998,FEC
....................                sect = clust2sect(clust);         // Current sector  
07BF2:  MOVFF  998,9CF
07BF6:  MOVFF  997,9CE
07BFA:  MOVFF  996,9CD
07BFE:  MOVFF  995,9CC
07C02:  MOVLB  0
07C04:  CALL   558C
07C08:  MOVFF  03,99C
07C0C:  MOVFF  02,99B
07C10:  MOVFF  01,99A
07C14:  MOVFF  00,999
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07C18:  MOVLW  1B
07C1A:  MOVLB  9
07C1C:  ADDWF  x8D,W
07C1E:  MOVWF  01
07C20:  MOVLW  00
07C22:  ADDWFC x8E,W
07C24:  MOVWF  03
07C26:  MOVLW  02
07C28:  MOVLB  7
07C2A:  ADDWF  x0E,W
07C2C:  MOVWF  FE9
07C2E:  MOVLW  00
07C30:  ADDWFC x0F,W
07C32:  MOVWF  FEA
07C34:  MOVFF  FEF,9A4
07C38:  MOVLB  9
07C3A:  MOVFF  03,FEA
07C3E:  MOVFF  01,FE9
07C42:  MOVFF  9A4,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07C46:  MOVLW  10
07C48:  ADDWF  x8D,W
07C4A:  MOVWF  FE9
07C4C:  MOVLW  00
07C4E:  ADDWFC x8E,W
07C50:  MOVWF  FEA
07C52:  MOVFF  999,FEF
07C56:  MOVFF  99A,FEC
07C5A:  MOVFF  99B,FEC
07C5E:  MOVFF  99C,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07C62:  BCF    FD8.0
07C64:  RRCF   x92,W
07C66:  MOVWF  x9F
....................             if (cc)  
07C68:  MOVF   x9F,F
07C6A:  BZ    7D24
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07C6C:  MOVLW  1B
07C6E:  ADDWF  x8D,W
07C70:  MOVWF  FE9
07C72:  MOVLW  00
07C74:  ADDWFC x8E,W
07C76:  MOVWF  FEA
07C78:  MOVF   FEF,W
07C7A:  SUBWF  x9F,W
07C7C:  BZ    7C90
07C7E:  BNC   7C90
....................                   cc = fp->sect_clust; 
07C80:  MOVLW  1B
07C82:  ADDWF  x8D,W
07C84:  MOVWF  FE9
07C86:  MOVLW  00
07C88:  ADDWFC x8E,W
07C8A:  MOVWF  FEA
07C8C:  MOVFF  FEF,99F
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07C90:  MOVFF  9A1,9FA
07C94:  MOVFF  9A0,9F9
07C98:  MOVFF  99C,9FE
07C9C:  MOVFF  99B,9FD
07CA0:  MOVFF  99A,9FC
07CA4:  MOVFF  999,9FB
07CA8:  MOVFF  99F,9FF
07CAC:  MOVLB  0
07CAE:  CALL   58BC
07CB2:  MOVF   01,F
07CB4:  BZ    7CB8
....................                   goto fw_error; 
07CB6:  BRA    7FEC
....................                fp->sect_clust -= cc - 1; 
07CB8:  MOVLW  1B
07CBA:  MOVLB  9
07CBC:  ADDWF  x8D,W
07CBE:  MOVWF  FE9
07CC0:  MOVLW  00
07CC2:  ADDWFC x8E,W
07CC4:  MOVWF  FEA
07CC6:  MOVLW  01
07CC8:  SUBWF  x9F,W
07CCA:  SUBWF  FEF,W
07CCC:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07CCE:  MOVLW  10
07CD0:  ADDWF  x8D,W
07CD2:  MOVWF  FE9
07CD4:  MOVLW  00
07CD6:  ADDWFC x8E,W
07CD8:  MOVWF  FEA
07CDA:  MOVLW  01
07CDC:  SUBWF  x9F,W
07CDE:  ADDWF  FEF,W
07CE0:  MOVWF  00
07CE2:  MOVLW  00
07CE4:  ADDWFC FEC,W
07CE6:  MOVWF  01
07CE8:  MOVLW  00
07CEA:  ADDWFC FEC,W
07CEC:  MOVWF  02
07CEE:  MOVLW  00
07CF0:  ADDWFC FEC,W
07CF2:  MOVF   FED,F
07CF4:  MOVF   FED,F
07CF6:  MOVF   FED,F
07CF8:  MOVFF  00,FEF
07CFC:  MOVFF  01,FEC
07D00:  MOVFF  02,FEC
07D04:  MOVWF  FEC
....................                wcnt = cc * 512; 
07D06:  CLRF   xEA
07D08:  MOVFF  99F,9E9
07D0C:  MOVLW  02
07D0E:  MOVWF  xEC
07D10:  CLRF   xEB
07D12:  MOVLB  0
07D14:  CALL   5C18
07D18:  MOVFF  02,99E
07D1C:  MOVFF  01,99D
....................                continue; 
07D20:  BRA    7ED6
07D22:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07D24:  MOVFF  98D,FE9
07D28:  MOVFF  98E,FEA
07D2C:  MOVFF  FEF,9A2
07D30:  MOVFF  FEC,9A3
07D34:  MOVFF  FEC,9A4
07D38:  MOVFF  FEC,9A5
07D3C:  MOVLW  04
07D3E:  ADDWF  x8D,W
07D40:  MOVWF  FE9
07D42:  MOVLW  00
07D44:  ADDWFC x8E,W
07D46:  MOVWF  FEA
07D48:  MOVFF  FEF,00
07D4C:  MOVFF  FEC,01
07D50:  MOVFF  FEC,02
07D54:  MOVFF  FEC,03
07D58:  MOVF   03,W
07D5A:  SUBWF  xA5,W
07D5C:  BNC   7DD4
07D5E:  BNZ   7D76
07D60:  MOVF   02,W
07D62:  SUBWF  xA4,W
07D64:  BNC   7DD4
07D66:  BNZ   7D76
07D68:  MOVF   01,W
07D6A:  SUBWF  xA3,W
07D6C:  BNC   7DD4
07D6E:  BNZ   7D76
07D70:  MOVF   00,W
07D72:  SUBWF  xA2,W
07D74:  BNC   7DD4
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07D76:  CLRF   xF0
07D78:  CLRF   xEF
07D7A:  CLRF   xEE
07D7C:  CLRF   xED
07D7E:  MOVLB  0
07D80:  CALL   5A02
07D84:  MOVF   01,F
07D86:  BNZ   7D8A
....................                   goto fw_error; 
07D88:  BRA    7FEC
....................                fs->winsect = fp->curr_sect; 
07D8A:  MOVLW  20
07D8C:  MOVLB  7
07D8E:  ADDWF  x0E,W
07D90:  MOVWF  01
07D92:  MOVLW  00
07D94:  ADDWFC x0F,W
07D96:  MOVWF  03
07D98:  MOVFF  01,9A2
07D9C:  MOVLB  9
07D9E:  MOVWF  xA3
07DA0:  MOVLW  10
07DA2:  ADDWF  x8D,W
07DA4:  MOVWF  FE9
07DA6:  MOVLW  00
07DA8:  ADDWFC x8E,W
07DAA:  MOVWF  FEA
07DAC:  MOVFF  FEF,00
07DB0:  MOVFF  FEC,01
07DB4:  MOVFF  FEC,02
07DB8:  MOVFF  FEC,03
07DBC:  MOVFF  9A3,FEA
07DC0:  MOVFF  9A2,FE9
07DC4:  MOVFF  00,FEF
07DC8:  MOVFF  01,FEC
07DCC:  MOVFF  02,FEC
07DD0:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07DD4:  MOVLW  10
07DD6:  ADDWF  x8D,W
07DD8:  MOVWF  FE9
07DDA:  MOVLW  00
07DDC:  ADDWFC x8E,W
07DDE:  MOVWF  FEA
07DE0:  MOVFF  FEF,9ED
07DE4:  MOVFF  FEC,9EE
07DE8:  MOVFF  FEC,9EF
07DEC:  MOVFF  FEC,9F0
07DF0:  MOVLB  0
07DF2:  CALL   5A02
07DF6:  MOVF   01,F
07DF8:  BNZ   7DFC
....................             goto fw_error;               // Move sector window 
07DFA:  BRA    7FEC
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07DFC:  MOVLB  9
07DFE:  MOVFF  98D,FE9
07E02:  MOVFF  98E,FEA
07E06:  MOVFF  FEF,9A2
07E0A:  MOVFF  FEC,9A3
07E0E:  MOVFF  FEC,9A4
07E12:  MOVFF  FEC,9A5
07E16:  MOVF   xA3,W
07E18:  ANDLW  01
07E1A:  MOVWF  01
07E1C:  MOVLW  00
07E1E:  BSF    FD8.0
07E20:  SUBFWB xA2,W
07E22:  MOVWF  x9D
07E24:  MOVLW  02
07E26:  SUBFWB 01,W
07E28:  MOVWF  x9E
....................          if (wcnt > btw) 
07E2A:  MOVF   x92,W
07E2C:  SUBWF  x9E,W
07E2E:  BNC   7E40
07E30:  BNZ   7E38
07E32:  MOVF   x9D,W
07E34:  SUBWF  x91,W
07E36:  BC    7E40
....................             wcnt = btw; 
07E38:  MOVFF  992,99E
07E3C:  MOVFF  991,99D
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07E40:  MOVFF  98D,FE9
07E44:  MOVFF  98E,FEA
07E48:  MOVFF  FEF,9A2
07E4C:  MOVFF  FEC,9A3
07E50:  MOVFF  FEC,9A4
07E54:  MOVFF  FEC,9A5
07E58:  MOVLW  01
07E5A:  ANDWF  xA3,F
07E5C:  CLRF   xA4
07E5E:  CLRF   xA5
07E60:  MOVLW  24
07E62:  ADDWF  xA2,W
07E64:  MOVWF  00
07E66:  MOVLW  00
07E68:  ADDWFC xA3,W
07E6A:  MOVWF  01
07E6C:  MOVLW  00
07E6E:  ADDWFC xA4,W
07E70:  MOVWF  02
07E72:  MOVLW  00
07E74:  ADDWFC xA5,W
07E76:  MOVWF  03
07E78:  MOVFF  01,03
07E7C:  MOVF   00,W
07E7E:  MOVLB  7
07E80:  ADDWF  x0E,W
07E82:  MOVWF  01
07E84:  MOVF   x0F,W
07E86:  ADDWFC 03,F
07E88:  MOVFF  01,9A6
07E8C:  MOVLB  9
07E8E:  MOVFF  03,9A7
07E92:  MOVFF  03,FEA
07E96:  MOVFF  01,FE9
07E9A:  MOVFF  9A1,FE2
07E9E:  MOVFF  9A0,FE1
07EA2:  MOVFF  99E,02
07EA6:  MOVFF  99D,01
07EAA:  MOVF   01,F
07EAC:  BZ    7EB2
07EAE:  INCF   02,F
07EB0:  BRA    7EB6
07EB2:  MOVF   02,F
07EB4:  BZ    7EC2
07EB6:  MOVFF  FE6,FEE
07EBA:  DECFSZ 01,F
07EBC:  BRA    7EB6
07EBE:  DECFSZ 02,F
07EC0:  BRA    7EB6
....................          fs->winflag = 1; 
07EC2:  MOVLW  06
07EC4:  MOVLB  7
07EC6:  ADDWF  x0E,W
07EC8:  MOVWF  FE9
07ECA:  MOVLW  00
07ECC:  ADDWFC x0F,W
07ECE:  MOVWF  FEA
07ED0:  MOVLW  01
07ED2:  MOVWF  FEF
07ED4:  MOVLB  0
07ED6:  MOVLB  9
07ED8:  MOVF   x9D,W
07EDA:  ADDWF  xA0,F
07EDC:  MOVF   x9E,W
07EDE:  ADDWFC xA1,F
07EE0:  MOVFF  98D,FE9
07EE4:  MOVFF  98E,FEA
07EE8:  MOVF   x9D,W
07EEA:  ADDWF  FEF,W
07EEC:  MOVWF  00
07EEE:  MOVF   x9E,W
07EF0:  ADDWFC FEC,W
07EF2:  MOVWF  01
07EF4:  MOVLW  00
07EF6:  ADDWFC FEC,W
07EF8:  MOVWF  02
07EFA:  MOVLW  00
07EFC:  ADDWFC FEC,W
07EFE:  MOVWF  03
07F00:  MOVF   FED,F
07F02:  MOVF   FED,F
07F04:  MOVF   FED,F
07F06:  MOVFF  00,FEF
07F0A:  MOVFF  01,FEC
07F0E:  MOVFF  02,FEC
07F12:  MOVWF  FEC
07F14:  MOVFF  993,FE9
07F18:  MOVFF  994,FEA
07F1C:  MOVF   x9D,W
07F1E:  ADDWF  FEF,W
07F20:  MOVWF  01
07F22:  MOVF   x9E,W
07F24:  ADDWFC FEC,W
07F26:  MOVWF  03
07F28:  MOVF   FED,F
07F2A:  MOVFF  01,FEF
07F2E:  MOVWF  FEC
07F30:  MOVF   x9D,W
07F32:  SUBWF  x91,F
07F34:  MOVF   x9E,W
07F36:  SUBWFB x92,F
07F38:  BRA    7A2A
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
07F3A:  MOVFF  98D,FE9
07F3E:  MOVFF  98E,FEA
07F42:  MOVFF  FEF,9A2
07F46:  MOVFF  FEC,9A3
07F4A:  MOVFF  FEC,9A4
07F4E:  MOVFF  FEC,9A5
07F52:  MOVLW  04
07F54:  ADDWF  x8D,W
07F56:  MOVWF  FE9
07F58:  MOVLW  00
07F5A:  ADDWFC x8E,W
07F5C:  MOVWF  FEA
07F5E:  MOVFF  FEF,00
07F62:  MOVFF  FEC,01
07F66:  MOVFF  FEC,02
07F6A:  MOVFF  FEC,03
07F6E:  MOVF   03,W
07F70:  SUBWF  xA5,W
07F72:  BNC   7FD0
07F74:  BNZ   7F8C
07F76:  MOVF   02,W
07F78:  SUBWF  xA4,W
07F7A:  BNC   7FD0
07F7C:  BNZ   7F8C
07F7E:  MOVF   01,W
07F80:  SUBWF  xA3,W
07F82:  BNC   7FD0
07F84:  BNZ   7F8C
07F86:  MOVF   xA2,W
07F88:  SUBWF  00,W
07F8A:  BC    7FD0
....................          fp->fsize = fp->fptr;      // Update file size if needed  
07F8C:  MOVLW  04
07F8E:  ADDWF  x8D,W
07F90:  MOVWF  01
07F92:  MOVLW  00
07F94:  ADDWFC x8E,W
07F96:  MOVWF  03
07F98:  MOVFF  01,9A2
07F9C:  MOVFF  03,9A3
07FA0:  MOVFF  98D,FE9
07FA4:  MOVFF  98E,FEA
07FA8:  MOVFF  FEF,00
07FAC:  MOVFF  FEC,01
07FB0:  MOVFF  FEC,02
07FB4:  MOVFF  FEC,03
07FB8:  MOVFF  9A3,FEA
07FBC:  MOVFF  9A2,FE9
07FC0:  MOVFF  00,FEF
07FC4:  MOVFF  01,FEC
07FC8:  MOVFF  02,FEC
07FCC:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
07FD0:  MOVLW  1A
07FD2:  ADDWF  x8D,W
07FD4:  MOVWF  FE9
07FD6:  MOVLW  00
07FD8:  ADDWFC x8E,W
07FDA:  MOVWF  FEA
07FDC:  MOVF   FEF,W
07FDE:  IORLW  20
07FE0:  MOVWF  FEF
....................       return (FR_OK); 
07FE2:  MOVLW  00
07FE4:  MOVWF  01
07FE6:  MOVLB  7
07FE8:  BRA    8006
07FEA:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
07FEC:  MOVLW  1A
07FEE:  MOVLB  9
07FF0:  ADDWF  x8D,W
07FF2:  MOVWF  FE9
07FF4:  MOVLW  00
07FF6:  ADDWFC x8E,W
07FF8:  MOVWF  FEA
07FFA:  MOVF   FEF,W
07FFC:  IORLW  80
07FFE:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
08000:  MOVLW  07
08002:  MOVWF  01
08004:  MOVLB  7
08006:  MOVLB  0
08008:  GOTO   83AC (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
074E6:  MOVLB  7
074E8:  MOVF   x0E,W
074EA:  IORWF  x0F,W
074EC:  BNZ   74F4
....................          return (FR_NOT_ENABLED); 
074EE:  MOVLW  0B
074F0:  MOVWF  01
074F2:  BRA    7848
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
074F4:  MOVLB  0
074F6:  CALL   551C
074FA:  BTFSC  01.0
074FC:  BRA    750E
074FE:  MOVLB  7
07500:  MOVFF  70E,FE9
07504:  MOVFF  70F,FEA
07508:  MOVF   FEF,F
0750A:  BNZ   7516
0750C:  MOVLB  0
....................          return (FR_NOT_READY); 
0750E:  MOVLW  01
07510:  MOVWF  01
07512:  MOVLB  7
07514:  BRA    7848
....................     
....................       if (fp->flag & FA__ERROR) 
07516:  MOVLW  1A
07518:  MOVLB  9
0751A:  ADDWF  x8D,W
0751C:  MOVWF  FE9
0751E:  MOVLW  00
07520:  ADDWFC x8E,W
07522:  MOVWF  FEA
07524:  BTFSS  FEF.7
07526:  BRA    7532
....................          return (FR_RW_ERROR); 
07528:  MOVLW  07
0752A:  MOVWF  01
0752C:  MOVLB  7
0752E:  BRA    7848
07530:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
07532:  MOVLW  04
07534:  ADDWF  x8D,W
07536:  MOVWF  FE9
07538:  MOVLW  00
0753A:  ADDWFC x8E,W
0753C:  MOVWF  FEA
0753E:  MOVFF  FEF,00
07542:  MOVFF  FEC,01
07546:  MOVFF  FEC,02
0754A:  MOVFF  FEC,03
0754E:  MOVF   03,W
07550:  SUBWF  x92,W
07552:  BNC   7588
07554:  BNZ   756C
07556:  MOVF   02,W
07558:  SUBWF  x91,W
0755A:  BNC   7588
0755C:  BNZ   756C
0755E:  MOVF   01,W
07560:  SUBWF  x90,W
07562:  BNC   7588
07564:  BNZ   756C
07566:  MOVF   x8F,W
07568:  SUBWF  00,W
0756A:  BC    7588
....................          ofs = fp->fsize;               // Clip offset by file size  
0756C:  MOVLW  04
0756E:  ADDWF  x8D,W
07570:  MOVWF  FE9
07572:  MOVLW  00
07574:  ADDWFC x8E,W
07576:  MOVWF  FEA
07578:  MOVFF  FEF,98F
0757C:  MOVFF  FEC,990
07580:  MOVFF  FEC,991
07584:  MOVFF  FEC,992
....................       fp->fptr = ofs;  
07588:  MOVFF  98D,FE9
0758C:  MOVF   x8E,W
0758E:  MOVWF  FEA
07590:  MOVFF  98F,FEF
07594:  MOVFF  990,FEC
07598:  MOVFF  991,FEC
0759C:  MOVFF  992,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
075A0:  MOVLW  1B
075A2:  ADDWF  x8D,W
075A4:  MOVWF  FE9
075A6:  MOVLW  00
075A8:  ADDWFC x8E,W
075AA:  MOVWF  FEA
075AC:  MOVLW  01
075AE:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
075B0:  MOVF   x8F,F
075B2:  BNZ   75C2
075B4:  MOVF   x90,F
075B6:  BNZ   75C2
075B8:  MOVF   x91,F
075BA:  BNZ   75C2
075BC:  MOVF   x92,F
075BE:  BTFSC  FD8.2
075C0:  BRA    7826
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
075C2:  MOVLW  01
075C4:  SUBWF  x8F,W
075C6:  MOVLW  00
075C8:  SUBWFB x90,W
075CA:  MOVWF  x99
075CC:  MOVLW  00
075CE:  SUBWFB x91,W
075D0:  MOVWF  x9A
075D2:  MOVLW  00
075D4:  SUBWFB x92,W
075D6:  MOVWF  x9B
075D8:  BCF    FD8.0
075DA:  CLRF   x92
075DC:  RRCF   x9B,W
075DE:  MOVWF  x91
075E0:  RRCF   x9A,W
075E2:  MOVWF  x90
075E4:  RRCF   x99,W
075E6:  MOVWF  x8F
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
075E8:  MOVLW  02
075EA:  MOVLB  7
075EC:  ADDWF  x0E,W
075EE:  MOVWF  FE9
075F0:  MOVLW  00
075F2:  ADDWFC x0F,W
075F4:  MOVWF  FEA
075F6:  MOVFF  FEF,997
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
075FA:  MOVLW  1B
075FC:  MOVLB  9
075FE:  ADDWF  x8D,W
07600:  MOVWF  01
07602:  MOVLW  00
07604:  ADDWFC x8E,W
07606:  MOVWF  03
07608:  MOVFF  01,998
0760C:  MOVWF  x99
0760E:  MOVFF  FEA,99B
07612:  MOVFF  FE9,99A
07616:  BSF    FD8.1
07618:  MOVLW  09
0761A:  MOVWF  FEA
0761C:  MOVLW  9C
0761E:  MOVWF  FE9
07620:  CLRF   1B
07622:  BTFSC  FF2.7
07624:  BSF    1B.7
07626:  BCF    FF2.7
07628:  MOVFF  992,A27
0762C:  MOVFF  991,A26
07630:  MOVFF  990,A25
07634:  MOVFF  98F,A24
07638:  MOVLB  A
0763A:  CLRF   x2B
0763C:  CLRF   x2A
0763E:  CLRF   x29
07640:  MOVFF  997,A28
07644:  MOVLB  0
07646:  CALL   1042
0764A:  BTFSC  1B.7
0764C:  BSF    FF2.7
0764E:  MOVFF  99C,00
07652:  MOVFF  99D,01
07656:  MOVFF  99E,02
0765A:  MOVFF  99F,03
0765E:  MOVFF  99B,FEA
07662:  MOVFF  99A,FE9
07666:  MOVF   00,W
07668:  MOVLB  9
0766A:  SUBWF  x97,W
0766C:  MOVWF  00
0766E:  MOVLW  00
07670:  SUBFWB 01,F
07672:  SUBFWB 02,F
07674:  SUBFWB 03,F
07676:  MOVFF  999,FEA
0767A:  MOVFF  998,FE9
0767E:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
07682:  BCF    FD8.1
07684:  CLRF   1B
07686:  BTFSC  FF2.7
07688:  BSF    1B.7
0768A:  BCF    FF2.7
0768C:  MOVFF  992,A27
07690:  MOVFF  991,A26
07694:  MOVFF  990,A25
07698:  MOVFF  98F,A24
0769C:  MOVLB  A
0769E:  CLRF   x2B
076A0:  CLRF   x2A
076A2:  CLRF   x29
076A4:  MOVFF  997,A28
076A8:  MOVLB  0
076AA:  CALL   1042
076AE:  BTFSC  1B.7
076B0:  BSF    FF2.7
076B2:  MOVFF  03,992
076B6:  MOVFF  02,991
076BA:  MOVFF  01,990
076BE:  MOVFF  00,98F
....................          clust = fp->org_clust;            // Seek to current cluster  
076C2:  MOVLW  08
076C4:  MOVLB  9
076C6:  ADDWF  x8D,W
076C8:  MOVWF  FE9
076CA:  MOVLW  00
076CC:  ADDWFC x8E,W
076CE:  MOVWF  FEA
076D0:  MOVFF  FEF,993
076D4:  MOVFF  FEC,994
076D8:  MOVFF  FEC,995
076DC:  MOVFF  FEC,996
....................     
....................          while (ofs--) 
076E0:  MOVFF  992,03
076E4:  MOVFF  991,02
076E8:  MOVFF  990,01
076EC:  MOVFF  98F,00
076F0:  MOVLW  FF
076F2:  ADDWF  x8F,F
076F4:  BTFSS  FD8.0
076F6:  ADDWF  x90,F
076F8:  BTFSS  FD8.0
076FA:  ADDWF  x91,F
076FC:  BTFSS  FD8.0
076FE:  ADDWF  x92,F
07700:  MOVF   00,F
07702:  BNZ   7710
07704:  MOVF   01,F
07706:  BNZ   7710
07708:  MOVF   02,F
0770A:  BNZ   7710
0770C:  MOVF   03,F
0770E:  BZ    773A
....................             clust = get_cluster(clust); 
07710:  MOVFF  996,9DC
07714:  MOVFF  995,9DB
07718:  MOVFF  994,9DA
0771C:  MOVFF  993,9D9
07720:  MOVLB  0
07722:  CALL   5C3A
07726:  MOVFF  03,996
0772A:  MOVFF  02,995
0772E:  MOVFF  01,994
07732:  MOVFF  00,993
07736:  MOVLB  9
07738:  BRA    76E0
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
0773A:  MOVF   x96,F
0773C:  BNZ   774C
0773E:  MOVF   x95,F
07740:  BNZ   774C
07742:  MOVF   x94,F
07744:  BNZ   774C
07746:  MOVF   x93,W
07748:  SUBLW  01
0774A:  BC    778A
0774C:  MOVLW  0C
0774E:  MOVLB  7
07750:  ADDWF  x0E,W
07752:  MOVWF  FE9
07754:  MOVLW  00
07756:  ADDWFC x0F,W
07758:  MOVWF  FEA
0775A:  MOVFF  FEF,00
0775E:  MOVFF  FEC,01
07762:  MOVFF  FEC,02
07766:  MOVFF  FEC,03
0776A:  MOVF   03,W
0776C:  MOVLB  9
0776E:  SUBWF  x96,W
07770:  BNC   778C
07772:  BNZ   778A
07774:  MOVF   02,W
07776:  SUBWF  x95,W
07778:  BNC   778C
0777A:  BNZ   778A
0777C:  MOVF   01,W
0777E:  SUBWF  x94,W
07780:  BNC   778C
07782:  BNZ   778A
07784:  MOVF   00,W
07786:  SUBWF  x93,W
07788:  BNC   778C
....................             goto fk_error; 
0778A:  BRA    7830
....................     
....................          fp->curr_clust = clust; 
0778C:  MOVLW  0C
0778E:  ADDWF  x8D,W
07790:  MOVWF  FE9
07792:  MOVLW  00
07794:  ADDWFC x8E,W
07796:  MOVWF  FEA
07798:  MOVFF  993,FEF
0779C:  MOVFF  994,FEC
077A0:  MOVFF  995,FEC
077A4:  MOVFF  996,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
077A8:  MOVLW  10
077AA:  ADDWF  x8D,W
077AC:  MOVWF  01
077AE:  MOVLW  00
077B0:  ADDWFC x8E,W
077B2:  MOVWF  03
077B4:  MOVFF  01,998
077B8:  MOVWF  x99
077BA:  MOVFF  996,9CF
077BE:  MOVFF  995,9CE
077C2:  MOVFF  994,9CD
077C6:  MOVFF  993,9CC
077CA:  MOVLB  0
077CC:  CALL   558C
077D0:  MOVFF  03,99D
077D4:  MOVFF  02,99C
077D8:  MOVFF  01,99B
077DC:  MOVFF  00,99A
077E0:  MOVLB  9
077E2:  MOVF   x97,W
077E4:  ADDWF  x9A,F
077E6:  MOVLW  00
077E8:  ADDWFC x9B,F
077EA:  ADDWFC x9C,F
077EC:  ADDWFC x9D,F
077EE:  MOVLW  1B
077F0:  ADDWF  x8D,W
077F2:  MOVWF  FE9
077F4:  MOVLW  00
077F6:  ADDWFC x8E,W
077F8:  MOVWF  FEA
077FA:  MOVF   FEF,W
077FC:  SUBWF  x9A,W
077FE:  MOVWF  00
07800:  MOVLW  00
07802:  SUBWFB x9B,W
07804:  MOVWF  01
07806:  MOVLW  00
07808:  SUBWFB x9C,W
0780A:  MOVWF  02
0780C:  MOVLW  00
0780E:  SUBWFB x9D,W
07810:  MOVFF  999,FEA
07814:  MOVFF  998,FE9
07818:  MOVFF  00,FEF
0781C:  MOVFF  01,FEC
07820:  MOVFF  02,FEC
07824:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
07826:  MOVLW  00
07828:  MOVWF  01
0782A:  MOVLB  7
0782C:  BRA    7848
0782E:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
07830:  MOVLW  1A
07832:  ADDWF  x8D,W
07834:  MOVWF  FE9
07836:  MOVLW  00
07838:  ADDWFC x8E,W
0783A:  MOVWF  FEA
0783C:  MOVF   FEF,W
0783E:  IORLW  80
07840:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
07842:  MOVLW  07
07844:  MOVWF  01
07846:  MOVLB  7
07848:  MOVLB  0
0784A:  GOTO   82C4 (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
0800C:  MOVLB  7
0800E:  MOVF   x0E,W
08010:  IORWF  x0F,W
08012:  BNZ   801A
....................       return (FR_NOT_ENABLED); 
08014:  MOVLW  0B
08016:  MOVWF  01
08018:  BRA    81E6
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
0801A:  MOVLB  0
0801C:  CALL   551C
08020:  BTFSC  01.0
08022:  BRA    8034
08024:  MOVLB  7
08026:  MOVFF  70E,FE9
0802A:  MOVFF  70F,FEA
0802E:  MOVF   FEF,F
08030:  BNZ   803C
08032:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
08034:  MOVLW  09
08036:  MOVWF  01
08038:  MOVLB  7
0803A:  BRA    81E6
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
0803C:  MOVLW  1A
0803E:  MOVLB  9
08040:  ADDWF  x90,W
08042:  MOVWF  FE9
08044:  MOVLW  00
08046:  ADDWFC x91,W
08048:  MOVWF  FEA
0804A:  BTFSS  FEF.5
0804C:  BRA    81C4
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
0804E:  MOVLW  14
08050:  ADDWF  x90,W
08052:  MOVWF  FE9
08054:  MOVLW  00
08056:  ADDWFC x91,W
08058:  MOVWF  FEA
0805A:  MOVFF  FEF,9ED
0805E:  MOVFF  FEC,9EE
08062:  MOVFF  FEC,9EF
08066:  MOVFF  FEC,9F0
0806A:  MOVLB  0
0806C:  CALL   5A02
08070:  MOVF   01,F
08072:  BNZ   807E
....................          return (FR_RW_ERROR); 
08074:  MOVLW  07
08076:  MOVWF  01
08078:  MOVLB  7
0807A:  BRA    81E6
0807C:  MOVLB  0
....................       ptr = fp->dir_ptr; 
0807E:  MOVLW  18
08080:  MOVLB  9
08082:  ADDWF  x90,W
08084:  MOVWF  FE9
08086:  MOVLW  00
08088:  ADDWFC x91,W
0808A:  MOVWF  FEA
0808C:  MOVFF  FEC,993
08090:  MOVF   FED,F
08092:  MOVFF  FEF,992
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
08096:  MOVLW  0B
08098:  ADDWF  x92,W
0809A:  MOVWF  01
0809C:  MOVLW  00
0809E:  ADDWFC x93,W
080A0:  MOVFF  01,FE9
080A4:  MOVWF  FEA
080A6:  MOVF   FEF,W
080A8:  IORLW  20
080AA:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
080AC:  MOVLW  1C
080AE:  ADDWF  x92,W
080B0:  MOVWF  01
080B2:  MOVLW  00
080B4:  ADDWFC x93,W
080B6:  MOVWF  03
080B8:  MOVFF  01,994
080BC:  MOVWF  x95
080BE:  MOVLW  04
080C0:  ADDWF  x90,W
080C2:  MOVWF  FE9
080C4:  MOVLW  00
080C6:  ADDWFC x91,W
080C8:  MOVWF  FEA
080CA:  MOVFF  FEF,00
080CE:  MOVFF  FEC,01
080D2:  MOVFF  FEC,02
080D6:  MOVFF  FEC,03
080DA:  MOVFF  995,FEA
080DE:  MOVFF  994,FE9
080E2:  MOVFF  00,FEF
080E6:  MOVFF  01,FEC
080EA:  MOVFF  02,FEC
080EE:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
080F2:  MOVLW  1A
080F4:  ADDWF  x92,W
080F6:  MOVWF  01
080F8:  MOVLW  00
080FA:  ADDWFC x93,W
080FC:  MOVWF  03
080FE:  MOVFF  01,994
08102:  MOVWF  x95
08104:  MOVLW  08
08106:  ADDWF  x90,W
08108:  MOVWF  FE9
0810A:  MOVLW  00
0810C:  ADDWFC x91,W
0810E:  MOVWF  FEA
08110:  MOVFF  FEF,00
08114:  MOVFF  FEC,01
08118:  MOVFF  FEC,02
0811C:  MOVFF  FEC,03
08120:  MOVFF  995,FEA
08124:  MOVFF  994,FE9
08128:  MOVFF  00,FEF
0812C:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
08130:  MOVLW  14
08132:  ADDWF  x92,W
08134:  MOVWF  01
08136:  MOVLW  00
08138:  ADDWFC x93,W
0813A:  MOVWF  03
0813C:  MOVFF  01,994
08140:  MOVWF  x95
08142:  MOVLW  08
08144:  ADDWF  x90,W
08146:  MOVWF  FE9
08148:  MOVLW  00
0814A:  ADDWFC x91,W
0814C:  MOVWF  FEA
0814E:  MOVFF  FEF,996
08152:  MOVFF  FEC,997
08156:  MOVFF  FEC,00
0815A:  MOVFF  FEC,01
0815E:  MOVFF  995,FEA
08162:  MOVFF  994,FE9
08166:  MOVFF  00,FEF
0816A:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
0816E:  MOVLW  16
08170:  ADDWF  x92,W
08172:  MOVWF  01
08174:  MOVLW  00
08176:  ADDWFC x93,W
08178:  MOVWF  03
0817A:  MOVFF  01,994
0817E:  MOVWF  x95
08180:  MOVLB  0
08182:  CALL   6F2E
08186:  MOVFF  995,FEA
0818A:  MOVFF  994,FE9
0818E:  MOVFF  00,FEF
08192:  MOVFF  01,FEC
08196:  MOVFF  02,FEC
0819A:  MOVFF  03,FEC
....................       fs->winflag = 1; 
0819E:  MOVLW  06
081A0:  MOVLB  7
081A2:  ADDWF  x0E,W
081A4:  MOVWF  FE9
081A6:  MOVLW  00
081A8:  ADDWFC x0F,W
081AA:  MOVWF  FEA
081AC:  MOVLW  01
081AE:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
081B0:  MOVLW  1A
081B2:  MOVLB  9
081B4:  ADDWF  x90,W
081B6:  MOVWF  FE9
081B8:  MOVLW  00
081BA:  ADDWFC x91,W
081BC:  MOVWF  FEA
081BE:  MOVF   FEF,W
081C0:  ANDLW  DF
081C2:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
081C4:  CLRF   xF0
081C6:  CLRF   xEF
081C8:  CLRF   xEE
081CA:  CLRF   xED
081CC:  MOVLB  0
081CE:  CALL   5A02
081D2:  MOVF   01,F
081D4:  BNZ   81E0
....................       return (FR_RW_ERROR); 
081D6:  MOVLW  07
081D8:  MOVWF  01
081DA:  MOVLB  7
081DC:  BRA    81E6
081DE:  MOVLB  0
....................  
....................    return (FR_OK); 
081E0:  MOVLW  00
081E2:  MOVWF  01
081E4:  MOVLB  7
081E6:  MOVLB  0
081E8:  GOTO   81F6 (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
081EC:  MOVFF  98E,991
081F0:  MOVFF  98D,990
081F4:  BRA    800C
081F6:  MOVFF  01,98F
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
081FA:  MOVLB  9
081FC:  MOVF   x8F,F
081FE:  BNZ   8230
....................       { 
....................       fp->flag = 0; 
08200:  MOVLW  1A
08202:  ADDWF  x8D,W
08204:  MOVWF  FE9
08206:  MOVLW  00
08208:  ADDWFC x8E,W
0820A:  MOVWF  FEA
0820C:  CLRF   FEF
....................       if (fs->files) 
0820E:  MOVLW  01
08210:  MOVLB  7
08212:  ADDWF  x0E,W
08214:  MOVWF  FE9
08216:  MOVLW  00
08218:  ADDWFC x0F,W
0821A:  MOVWF  FEA
0821C:  MOVF   FEF,F
0821E:  BZ    822E
....................          fs->files--; 
08220:  MOVLW  01
08222:  ADDWF  x0E,W
08224:  MOVWF  FE9
08226:  MOVLW  00
08228:  ADDWFC x0F,W
0822A:  MOVWF  FEA
0822C:  DECF   FEF,F
0822E:  MOVLB  9
....................       } 
....................    return (res); 
08230:  MOVFF  98F,01
08234:  MOVLB  0
08236:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0B910:  CALL   552A
0B914:  MOVFF  01,868
....................    if (res != FR_OK)  
0B918:  MOVLB  8
0B91A:  MOVF   x68,F
0B91C:  BZ    B924
....................       return (res); 
0B91E:  MOVFF  868,01
0B922:  BRA    BBB4
....................  
....................    if (disk_status() & STA_PROTECT) 
0B924:  MOVLB  0
0B926:  CALL   551C
0B92A:  BTFSS  01.2
0B92C:  BRA    B938
....................       return (FR_WRITE_PROTECTED); 
0B92E:  MOVLW  0A
0B930:  MOVWF  01
0B932:  MOVLB  8
0B934:  BRA    BBB4
0B936:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0B938:  MOVLW  08
0B93A:  MOVLB  9
0B93C:  MOVWF  xB4
0B93E:  MOVLW  75
0B940:  MOVWF  xB3
0B942:  MOVLW  08
0B944:  MOVWF  xB6
0B946:  MOVLW  83
0B948:  MOVWF  xB5
0B94A:  MOVFF  867,9B8
0B94E:  MOVFF  866,9B7
0B952:  MOVLW  08
0B954:  MOVWF  xBA
0B956:  MOVLW  69
0B958:  MOVWF  xB9
0B95A:  MOVLB  0
0B95C:  CALL   614C
0B960:  MOVFF  01,868
....................  
....................    if (res != FR_OK)  
0B964:  MOVLB  8
0B966:  MOVF   x68,F
0B968:  BZ    B970
....................       return (res);            // Trace failed  
0B96A:  MOVFF  868,01
0B96E:  BRA    BBB4
....................  
....................    if (dir_ptr == NULL)  
0B970:  MOVF   x69,F
0B972:  BNZ   B97E
0B974:  MOVF   x6A,F
0B976:  BNZ   B97E
....................       return (FR_NO_FILE);      // It is a root directory  
0B978:  MOVLW  02
0B97A:  MOVWF  01
0B97C:  BRA    BBB4
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0B97E:  MOVLW  0B
0B980:  ADDWF  x69,W
0B982:  MOVWF  01
0B984:  MOVLW  00
0B986:  ADDWFC x6A,W
0B988:  MOVWF  03
0B98A:  MOVFF  01,FE9
0B98E:  MOVWF  FEA
0B990:  BTFSS  FEF.0
0B992:  BRA    B99A
....................       return (FR_DENIED);         // It is a R/O item  
0B994:  MOVLW  05
0B996:  MOVWF  01
0B998:  BRA    BBB4
....................  
....................    dsect = fs->winsect; 
0B99A:  MOVLW  20
0B99C:  MOVLB  7
0B99E:  ADDWF  x0E,W
0B9A0:  MOVWF  FE9
0B9A2:  MOVLW  00
0B9A4:  ADDWFC x0F,W
0B9A6:  MOVWF  FEA
0B9A8:  MOVFF  FEF,871
0B9AC:  MOVFF  FEC,872
0B9B0:  MOVFF  FEC,873
0B9B4:  MOVFF  FEC,874
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0B9B8:  MOVLW  14
0B9BA:  MOVLB  8
0B9BC:  ADDWF  x69,W
0B9BE:  MOVWF  01
0B9C0:  MOVLW  00
0B9C2:  ADDWFC x6A,W
0B9C4:  MOVWF  03
0B9C6:  MOVFF  01,FE9
0B9CA:  MOVWF  FEA
0B9CC:  MOVFF  FEC,870
0B9D0:  MOVF   FED,F
0B9D2:  MOVFF  FEF,88F
0B9D6:  MOVFF  88F,86F
0B9DA:  CLRF   x8F
0B9DC:  CLRF   x90
0B9DE:  MOVLW  1A
0B9E0:  ADDWF  x69,W
0B9E2:  MOVWF  01
0B9E4:  MOVLW  00
0B9E6:  ADDWFC x6A,W
0B9E8:  MOVFF  01,FE9
0B9EC:  MOVWF  FEA
0B9EE:  MOVFF  FEC,03
0B9F2:  MOVF   FED,F
0B9F4:  MOVF   FEF,W
0B9F6:  IORWF  x8F,W
0B9F8:  MOVWF  x6D
0B9FA:  MOVF   03,W
0B9FC:  IORWF  x90,W
0B9FE:  MOVWF  x6E
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BA00:  MOVLW  0B
0BA02:  ADDWF  x69,W
0BA04:  MOVWF  01
0BA06:  MOVLW  00
0BA08:  ADDWFC x6A,W
0BA0A:  MOVWF  03
0BA0C:  MOVFF  01,FE9
0BA10:  MOVWF  FEA
0BA12:  BTFSS  FEF.4
0BA14:  BRA    BB28
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BA16:  MOVFF  870,87C
0BA1A:  MOVFF  86F,87B
0BA1E:  MOVFF  86E,87A
0BA22:  MOVFF  86D,879
....................       dirscan.sect = clust2sect(dclust); 
0BA26:  MOVFF  870,9CF
0BA2A:  MOVFF  86F,9CE
0BA2E:  MOVFF  86E,9CD
0BA32:  MOVFF  86D,9CC
0BA36:  MOVLB  0
0BA38:  CALL   558C
0BA3C:  MOVFF  03,880
0BA40:  MOVFF  02,87F
0BA44:  MOVFF  01,87E
0BA48:  MOVFF  00,87D
....................       dirscan.index = 0; 
0BA4C:  MOVLB  8
0BA4E:  CLRF   x82
0BA50:  CLRF   x81
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BA52:  MOVFF  880,9F0
0BA56:  MOVFF  87F,9EF
0BA5A:  MOVFF  87E,9EE
0BA5E:  MOVFF  87D,9ED
0BA62:  MOVLB  0
0BA64:  CALL   5A02
0BA68:  MOVF   01,F
0BA6A:  BNZ   BA76
....................             return (FR_RW_ERROR); 
0BA6C:  MOVLW  07
0BA6E:  MOVWF  01
0BA70:  MOVLB  8
0BA72:  BRA    BBB4
0BA74:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BA76:  MOVLB  8
0BA78:  MOVF   x81,W
0BA7A:  ANDLW  0F
0BA7C:  MOVWF  x8F
0BA7E:  CLRF   x90
0BA80:  RLCF   x8F,F
0BA82:  RLCF   x90,F
0BA84:  RLCF   x8F,F
0BA86:  RLCF   x90,F
0BA88:  RLCF   x8F,F
0BA8A:  RLCF   x90,F
0BA8C:  RLCF   x8F,F
0BA8E:  RLCF   x90,F
0BA90:  RLCF   x8F,F
0BA92:  RLCF   x90,F
0BA94:  MOVLW  E0
0BA96:  ANDWF  x8F,F
0BA98:  MOVLW  24
0BA9A:  ADDWF  x8F,W
0BA9C:  MOVWF  01
0BA9E:  MOVLW  00
0BAA0:  ADDWFC x90,W
0BAA2:  MOVWF  03
0BAA4:  MOVF   01,W
0BAA6:  MOVLB  7
0BAA8:  ADDWF  x0E,W
0BAAA:  MOVWF  01
0BAAC:  MOVF   x0F,W
0BAAE:  ADDWFC 03,F
0BAB0:  MOVFF  01,86B
0BAB4:  MOVLB  8
0BAB6:  MOVFF  03,86C
....................          if (*sdir == 0) 
0BABA:  MOVFF  86C,03
0BABE:  MOVFF  86B,FE9
0BAC2:  MOVFF  86C,FEA
0BAC6:  MOVF   FEF,F
0BAC8:  BNZ   BACC
....................             break; 
0BACA:  BRA    BB28
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BACC:  MOVFF  86C,03
0BAD0:  MOVFF  86B,FE9
0BAD4:  MOVFF  86C,FEA
0BAD8:  MOVF   FEF,W
0BADA:  SUBLW  E5
0BADC:  BZ    BB0C
0BADE:  MOVFF  86C,03
0BAE2:  MOVFF  86B,FE9
0BAE6:  MOVFF  86C,FEA
0BAEA:  MOVF   FEF,W
0BAEC:  SUBLW  2E
0BAEE:  BZ    BB0C
0BAF0:  MOVLW  0B
0BAF2:  ADDWF  x6B,W
0BAF4:  MOVWF  01
0BAF6:  MOVLW  00
0BAF8:  ADDWFC x6C,W
0BAFA:  MOVWF  03
0BAFC:  MOVFF  01,FE9
0BB00:  MOVWF  FEA
0BB02:  BTFSC  FEF.3
0BB04:  BRA    BB0C
....................             return (FR_DENIED);   // The directory is not empty  
0BB06:  MOVLW  05
0BB08:  MOVWF  01
0BB0A:  BRA    BBB4
....................          } while (next_dir_ptr(&dirscan)); 
0BB0C:  MOVLW  08
0BB0E:  MOVLB  9
0BB10:  MOVWF  xC3
0BB12:  MOVLW  75
0BB14:  MOVWF  xC2
0BB16:  MOVLB  0
0BB18:  CALL   5F72
0BB1C:  MOVF   01,F
0BB1E:  BTFSC  FD8.2
0BB20:  BRA    BB26
0BB22:  MOVLB  8
0BB24:  BRA    BA52
0BB26:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BB28:  MOVFF  874,9F0
0BB2C:  MOVFF  873,9EF
0BB30:  MOVFF  872,9EE
0BB34:  MOVFF  871,9ED
0BB38:  MOVLB  0
0BB3A:  CALL   5A02
0BB3E:  MOVF   01,F
0BB40:  BNZ   BB4C
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BB42:  MOVLW  07
0BB44:  MOVWF  01
0BB46:  MOVLB  8
0BB48:  BRA    BBB4
0BB4A:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BB4C:  MOVLB  8
0BB4E:  MOVFF  869,FE9
0BB52:  MOVFF  86A,FEA
0BB56:  MOVLW  E5
0BB58:  MOVWF  FEF
....................    fs->winflag = 1; 
0BB5A:  MOVLW  06
0BB5C:  MOVLB  7
0BB5E:  ADDWF  x0E,W
0BB60:  MOVWF  FE9
0BB62:  MOVLW  00
0BB64:  ADDWFC x0F,W
0BB66:  MOVWF  FEA
0BB68:  MOVLW  01
0BB6A:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BB6C:  MOVFF  870,9BB
0BB70:  MOVFF  86F,9BA
0BB74:  MOVFF  86E,9B9
0BB78:  MOVFF  86D,9B8
0BB7C:  MOVLB  0
0BB7E:  CALL   6E8E
0BB82:  MOVF   01,F
0BB84:  BNZ   BB90
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BB86:  MOVLW  07
0BB88:  MOVWF  01
0BB8A:  MOVLB  8
0BB8C:  BRA    BBB4
0BB8E:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BB90:  MOVLB  9
0BB92:  CLRF   xF0
0BB94:  CLRF   xEF
0BB96:  CLRF   xEE
0BB98:  CLRF   xED
0BB9A:  MOVLB  0
0BB9C:  CALL   5A02
0BBA0:  MOVF   01,F
0BBA2:  BNZ   BBAE
....................       return (FR_RW_ERROR); 
0BBA4:  MOVLW  07
0BBA6:  MOVWF  01
0BBA8:  MOVLB  8
0BBAA:  BRA    BBB4
0BBAC:  MOVLB  0
....................  
....................    return (FR_OK); 
0BBAE:  MOVLW  00
0BBB0:  MOVWF  01
0BBB2:  MOVLB  8
0BBB4:  MOVLB  0
0BBB6:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
07902:  MOVFF  98E,990
07906:  MOVFF  98D,98F
0790A:  MOVFF  990,03
0790E:  MOVLB  9
07910:  MOVFF  98F,FE9
07914:  MOVFF  990,FEA
07918:  MOVF   FEF,F
0791A:  BZ    7928
0791C:  INCF   x8F,F
0791E:  BTFSC  FD8.2
07920:  INCF   x90,F
07922:  MOVLB  0
07924:  BRA    790A
07926:  MOVLB  9
....................    return(sc - s); 
07928:  MOVF   x8D,W
0792A:  SUBWF  x8F,W
0792C:  MOVWF  00
0792E:  MOVF   x8E,W
07930:  SUBWFB x90,W
07932:  MOVWF  03
07934:  MOVFF  00,01
07938:  MOVWF  02
0793A:  MOVLB  0
0793C:  GOTO   837C (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
03490:  MOVLB  4
03492:  CLRF   xE2
03494:  MOVLW  01
03496:  MOVWF  xE1
....................    rtc.year=10; 
03498:  MOVLW  0A
0349A:  MOVWF  xE0
....................    rtc.month=1; 
0349C:  MOVLW  01
0349E:  MOVWF  xDF
....................    rtc.day=1; 
034A0:  MOVWF  xDE
....................    rtc.hour=0; 
034A2:  CLRF   xDD
....................    rtc.min=0; 
034A4:  CLRF   xDC
....................    rtc.sec=0; 
034A6:  CLRF   xDB
....................    rtc.ms100=0; 
034A8:  CLRF   xDA
034AA:  MOVLB  0
034AC:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
06F2E:  MOVLB  9
06F30:  CLRF   xBA
06F32:  CLRF   xB9
06F34:  CLRF   xB8
06F36:  MOVFF  4E0,9B7
06F3A:  MOVLW  14
06F3C:  ADDWF  xB7,F
06F3E:  MOVLW  00
06F40:  ADDWFC xB8,F
06F42:  ADDWFC xB9,F
06F44:  ADDWFC xBA,F
06F46:  BCF    FD8.0
06F48:  CLRF   xB3
06F4A:  CLRF   xB4
06F4C:  CLRF   xB5
06F4E:  RLCF   xB7,W
06F50:  MOVWF  xB6
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
06F52:  CLRF   xBA
06F54:  CLRF   xB9
06F56:  CLRF   xB8
06F58:  MOVFF  4DF,9B7
06F5C:  MOVLW  0F
06F5E:  ANDWF  xB7,F
06F60:  CLRF   xB8
06F62:  CLRF   xB9
06F64:  CLRF   xBA
06F66:  CLRF   00
06F68:  CLRF   01
06F6A:  RLCF   xB7,W
06F6C:  MOVWF  02
06F6E:  RLCF   xB8,W
06F70:  MOVWF  03
06F72:  RLCF   02,F
06F74:  RLCF   03,F
06F76:  RLCF   02,F
06F78:  RLCF   03,F
06F7A:  RLCF   02,F
06F7C:  RLCF   03,F
06F7E:  RLCF   02,F
06F80:  RLCF   03,F
06F82:  MOVLW  E0
06F84:  ANDWF  02,F
06F86:  MOVF   00,W
06F88:  IORWF  xB3,F
06F8A:  MOVF   01,W
06F8C:  IORWF  xB4,F
06F8E:  MOVF   02,W
06F90:  IORWF  xB5,F
06F92:  MOVF   03,W
06F94:  IORWF  xB6,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
06F96:  CLRF   xBA
06F98:  CLRF   xB9
06F9A:  CLRF   xB8
06F9C:  MOVFF  4DE,9B7
06FA0:  MOVLW  1F
06FA2:  ANDWF  xB7,F
06FA4:  CLRF   xB8
06FA6:  CLRF   xB9
06FA8:  CLRF   xBA
06FAA:  CLRF   00
06FAC:  CLRF   01
06FAE:  MOVF   00,W
06FB0:  IORWF  xB3,F
06FB2:  MOVF   01,W
06FB4:  IORWF  xB4,F
06FB6:  MOVF   xB7,W
06FB8:  IORWF  xB5,F
06FBA:  MOVF   xB8,W
06FBC:  IORWF  xB6,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
06FBE:  CLRF   xBA
06FC0:  CLRF   xB9
06FC2:  CLRF   xB8
06FC4:  MOVFF  4DD,9B7
06FC8:  MOVLW  1F
06FCA:  ANDWF  xB7,F
06FCC:  CLRF   xB8
06FCE:  CLRF   xB9
06FD0:  CLRF   xBA
06FD2:  CLRF   00
06FD4:  RLCF   xB7,W
06FD6:  MOVWF  01
06FD8:  RLCF   xB8,W
06FDA:  MOVWF  02
06FDC:  RLCF   xB9,W
06FDE:  MOVWF  03
06FE0:  RLCF   01,F
06FE2:  RLCF   02,F
06FE4:  RLCF   03,F
06FE6:  RLCF   01,F
06FE8:  RLCF   02,F
06FEA:  RLCF   03,F
06FEC:  MOVLW  F8
06FEE:  ANDWF  01,F
06FF0:  MOVF   00,W
06FF2:  IORWF  xB3,F
06FF4:  MOVF   01,W
06FF6:  IORWF  xB4,F
06FF8:  MOVF   02,W
06FFA:  IORWF  xB5,F
06FFC:  MOVF   03,W
06FFE:  IORWF  xB6,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
07000:  CLRF   xBA
07002:  CLRF   xB9
07004:  CLRF   xB8
07006:  MOVFF  4DC,9B7
0700A:  MOVLW  3F
0700C:  ANDWF  xB7,F
0700E:  CLRF   xB8
07010:  CLRF   xB9
07012:  CLRF   xBA
07014:  RLCF   xB7,W
07016:  MOVWF  00
07018:  RLCF   xB8,W
0701A:  MOVWF  01
0701C:  RLCF   xB9,W
0701E:  MOVWF  02
07020:  RLCF   xBA,W
07022:  MOVWF  03
07024:  RLCF   00,F
07026:  RLCF   01,F
07028:  RLCF   02,F
0702A:  RLCF   03,F
0702C:  RLCF   00,F
0702E:  RLCF   01,F
07030:  RLCF   02,F
07032:  RLCF   03,F
07034:  RLCF   00,F
07036:  RLCF   01,F
07038:  RLCF   02,F
0703A:  RLCF   03,F
0703C:  RLCF   00,F
0703E:  RLCF   01,F
07040:  RLCF   02,F
07042:  RLCF   03,F
07044:  MOVLW  E0
07046:  ANDWF  00,F
07048:  MOVF   00,W
0704A:  IORWF  xB3,F
0704C:  MOVF   01,W
0704E:  IORWF  xB4,F
07050:  MOVF   02,W
07052:  IORWF  xB5,F
07054:  MOVF   03,W
07056:  IORWF  xB6,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
07058:  CLRF   xBA
0705A:  CLRF   xB9
0705C:  CLRF   xB8
0705E:  MOVFF  4DB,9B7
07062:  MOVLW  3F
07064:  ANDWF  xB7,F
07066:  CLRF   xB8
07068:  CLRF   xB9
0706A:  CLRF   xBA
0706C:  BCF    FD8.0
0706E:  RRCF   xBA,W
07070:  MOVWF  03
07072:  RRCF   xB9,W
07074:  MOVWF  02
07076:  RRCF   xB8,W
07078:  MOVWF  01
0707A:  RRCF   xB7,W
0707C:  IORWF  xB3,F
0707E:  MOVF   01,W
07080:  IORWF  xB4,F
07082:  MOVF   02,W
07084:  IORWF  xB5,F
07086:  MOVF   03,W
07088:  IORWF  xB6,F
....................    return (work); 
0708A:  MOVFF  9B3,00
0708E:  MOVFF  9B4,01
07092:  MOVFF  9B5,02
07096:  MOVFF  9B6,03
0709A:  MOVLB  0
0709C:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0B796:  MOVLW  08
0B798:  MOVLB  9
0B79A:  MOVWF  x8E
0B79C:  MOVLW  68
0B79E:  MOVWF  x8D
0B7A0:  MOVFF  867,990
0B7A4:  MOVFF  866,98F
0B7A8:  MOVLW  01
0B7AA:  MOVWF  x91
0B7AC:  MOVLB  0
0B7AE:  CALL   709E
0B7B2:  MOVFF  01,884
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0B7B6:  MOVLB  8
0B7B8:  MOVF   x84,F
0B7BA:  BTFSS  FD8.2
0B7BC:  BRA    B8BE
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0B7BE:  MOVLW  08
0B7C0:  MOVWF  xAA
0B7C2:  MOVLW  68
0B7C4:  MOVWF  xA9
0B7C6:  MOVLW  08
0B7C8:  MOVWF  xAC
0B7CA:  MOVLW  85
0B7CC:  MOVWF  xAB
0B7CE:  CLRF   xAE
0B7D0:  MOVLW  20
0B7D2:  MOVWF  xAD
0B7D4:  MOVLW  08
0B7D6:  MOVWF  xB0
0B7D8:  MOVLW  A7
0B7DA:  MOVWF  xAF
0B7DC:  MOVLB  0
0B7DE:  BRA    B0DA
0B7E0:  MOVFF  01,884
....................          for (i = 0; i < br; i++) 
0B7E4:  MOVLB  8
0B7E6:  CLRF   xA6
0B7E8:  CLRF   xA5
0B7EA:  MOVF   xA6,W
0B7EC:  SUBWF  xA8,W
0B7EE:  BNC   B81A
0B7F0:  BNZ   B7F8
0B7F2:  MOVF   xA7,W
0B7F4:  SUBWF  xA5,W
0B7F6:  BC    B81A
....................          { 
....................             putc(mesg[i]); 
0B7F8:  MOVLW  85
0B7FA:  ADDWF  xA5,W
0B7FC:  MOVWF  FE9
0B7FE:  MOVLW  08
0B800:  ADDWFC xA6,W
0B802:  MOVWF  FEA
0B804:  MOVFF  FEF,8A9
0B808:  MOVF   xA9,W
0B80A:  MOVLB  0
0B80C:  CALL   ADB4
0B810:  MOVLB  8
0B812:  INCF   xA5,F
0B814:  BTFSC  FD8.2
0B816:  INCF   xA6,F
0B818:  BRA    B7EA
....................          } 
....................       } while ((result == FR_OK) && br); 
0B81A:  MOVF   x84,F
0B81C:  BNZ   B824
0B81E:  MOVF   xA7,W
0B820:  IORWF  xA8,W
0B822:  BNZ   B7BE
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0B824:  MOVF   x84,F
0B826:  BZ    B89A
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0B828:  MOVLW  16
0B82A:  MOVWF  FF6
0B82C:  MOVLW  0C
0B82E:  MOVWF  FF7
0B830:  MOVLW  00
0B832:  MOVWF  FF8
0B834:  CLRF   1B
0B836:  BTFSC  FF2.7
0B838:  BSF    1B.7
0B83A:  BCF    FF2.7
0B83C:  MOVLB  0
0B83E:  CALL   0E3A
0B842:  BTFSC  1B.7
0B844:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0B846:  MOVFF  884,8A9
0B84A:  MOVLW  08
0B84C:  MOVLB  8
0B84E:  MOVWF  xAB
0B850:  MOVLW  85
0B852:  MOVWF  xAA
0B854:  MOVLB  0
0B856:  RCALL  B5E8
....................          printf("@FS: %s\r\n",mesg); 
0B858:  MOVLW  2C
0B85A:  MOVWF  FF6
0B85C:  MOVLW  0C
0B85E:  MOVWF  FF7
0B860:  MOVLW  00
0B862:  MOVWF  FF8
0B864:  CLRF   1B
0B866:  BTFSC  FF2.7
0B868:  BSF    1B.7
0B86A:  BCF    FF2.7
0B86C:  MOVLW  05
0B86E:  MOVLB  A
0B870:  MOVWF  x18
0B872:  MOVLB  0
0B874:  CALL   1010
0B878:  BTFSC  1B.7
0B87A:  BSF    FF2.7
0B87C:  MOVLW  08
0B87E:  MOVWF  FEA
0B880:  MOVLW  85
0B882:  MOVWF  FE9
0B884:  CALL   78DC
0B888:  MOVLW  0D
0B88A:  BTFSS  F9E.4
0B88C:  BRA    B88A
0B88E:  MOVWF  FAD
0B890:  MOVLW  0A
0B892:  BTFSS  F9E.4
0B894:  BRA    B892
0B896:  MOVWF  FAD
0B898:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0B89A:  MOVLW  08
0B89C:  MOVLB  9
0B89E:  MOVWF  x8E
0B8A0:  MOVLW  68
0B8A2:  MOVWF  x8D
0B8A4:  MOVLB  0
0B8A6:  CALL   81EC
....................       printf("\r\n");       
0B8AA:  MOVLW  0D
0B8AC:  BTFSS  F9E.4
0B8AE:  BRA    B8AC
0B8B0:  MOVWF  FAD
0B8B2:  MOVLW  0A
0B8B4:  BTFSS  F9E.4
0B8B6:  BRA    B8B4
0B8B8:  MOVWF  FAD
....................    } 
0B8BA:  BRA    B90E
0B8BC:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0B8BE:  MOVFF  884,8A9
0B8C2:  MOVLW  08
0B8C4:  MOVWF  xAB
0B8C6:  MOVLW  85
0B8C8:  MOVWF  xAA
0B8CA:  MOVLB  0
0B8CC:  RCALL  B5E8
....................       printf("@FS: %s\r\n",mesg); 
0B8CE:  MOVLW  36
0B8D0:  MOVWF  FF6
0B8D2:  MOVLW  0C
0B8D4:  MOVWF  FF7
0B8D6:  MOVLW  00
0B8D8:  MOVWF  FF8
0B8DA:  CLRF   1B
0B8DC:  BTFSC  FF2.7
0B8DE:  BSF    1B.7
0B8E0:  BCF    FF2.7
0B8E2:  MOVLW  05
0B8E4:  MOVLB  A
0B8E6:  MOVWF  x18
0B8E8:  MOVLB  0
0B8EA:  CALL   1010
0B8EE:  BTFSC  1B.7
0B8F0:  BSF    FF2.7
0B8F2:  MOVLW  08
0B8F4:  MOVWF  FEA
0B8F6:  MOVLW  85
0B8F8:  MOVWF  FE9
0B8FA:  CALL   78DC
0B8FE:  MOVLW  0D
0B900:  BTFSS  F9E.4
0B902:  BRA    B900
0B904:  MOVWF  FAD
0B906:  MOVLW  0A
0B908:  BTFSS  F9E.4
0B90A:  BRA    B908
0B90C:  MOVWF  FAD
....................    } 
0B90E:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04D76:  MOVLW  40
04D78:  MOVWF  FF6
04D7A:  MOVLW  0C
04D7C:  MOVWF  FF7
04D7E:  MOVLW  00
04D80:  MOVWF  FF8
04D82:  CLRF   1B
04D84:  BTFSC  FF2.7
04D86:  BSF    1B.7
04D88:  BCF    FF2.7
04D8A:  CALL   0E3A
04D8E:  BTFSC  1B.7
04D90:  BSF    FF2.7
....................    if (status & FR_OK) 
04D92:  ANDLW  00
04D94:  BZ    4DB2
....................       printf("   NoError\r\n"); 
04D96:  MOVLW  50
04D98:  MOVWF  FF6
04D9A:  MOVLW  0C
04D9C:  MOVWF  FF7
04D9E:  MOVLW  00
04DA0:  MOVWF  FF8
04DA2:  CLRF   1B
04DA4:  BTFSC  FF2.7
04DA6:  BSF    1B.7
04DA8:  BCF    FF2.7
04DAA:  CALL   0E3A
04DAE:  BTFSC  1B.7
04DB0:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04DB2:  MOVLB  8
04DB4:  BTFSS  x67.0
04DB6:  BRA    4DD8
....................       printf("   Media Not Ready\r\n"); 
04DB8:  MOVLW  5E
04DBA:  MOVWF  FF6
04DBC:  MOVLW  0C
04DBE:  MOVWF  FF7
04DC0:  MOVLW  00
04DC2:  MOVWF  FF8
04DC4:  CLRF   1B
04DC6:  BTFSC  FF2.7
04DC8:  BSF    1B.7
04DCA:  BCF    FF2.7
04DCC:  MOVLB  0
04DCE:  CALL   0E3A
04DD2:  BTFSC  1B.7
04DD4:  BSF    FF2.7
04DD6:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04DD8:  BTFSS  x67.1
04DDA:  BRA    4DFC
....................       printf("   File Not Found\r\n"); 
04DDC:  MOVLW  74
04DDE:  MOVWF  FF6
04DE0:  MOVLW  0C
04DE2:  MOVWF  FF7
04DE4:  MOVLW  00
04DE6:  MOVWF  FF8
04DE8:  CLRF   1B
04DEA:  BTFSC  FF2.7
04DEC:  BSF    1B.7
04DEE:  BCF    FF2.7
04DF0:  MOVLB  0
04DF2:  CALL   0E3A
04DF6:  BTFSC  1B.7
04DF8:  BSF    FF2.7
04DFA:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04DFC:  MOVF   x67,W
04DFE:  ANDLW  03
04E00:  BZ    4E22
....................       printf("   Invalid Path\r\n"); 
04E02:  MOVLW  88
04E04:  MOVWF  FF6
04E06:  MOVLW  0C
04E08:  MOVWF  FF7
04E0A:  MOVLW  00
04E0C:  MOVWF  FF8
04E0E:  CLRF   1B
04E10:  BTFSC  FF2.7
04E12:  BSF    1B.7
04E14:  BCF    FF2.7
04E16:  MOVLB  0
04E18:  CALL   0E3A
04E1C:  BTFSC  1B.7
04E1E:  BSF    FF2.7
04E20:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04E22:  BTFSS  x67.2
04E24:  BRA    4E46
....................       printf("   Invalid Name\r\n"); 
04E26:  MOVLW  9A
04E28:  MOVWF  FF6
04E2A:  MOVLW  0C
04E2C:  MOVWF  FF7
04E2E:  MOVLW  00
04E30:  MOVWF  FF8
04E32:  CLRF   1B
04E34:  BTFSC  FF2.7
04E36:  BSF    1B.7
04E38:  BCF    FF2.7
04E3A:  MOVLB  0
04E3C:  CALL   0E3A
04E40:  BTFSC  1B.7
04E42:  BSF    FF2.7
04E44:  MOVLB  8
....................    if (status & FR_DENIED) 
04E46:  MOVF   x67,W
04E48:  ANDLW  05
04E4A:  BZ    4E6C
....................       printf("   Access Denied\r\n"); 
04E4C:  MOVLW  AC
04E4E:  MOVWF  FF6
04E50:  MOVLW  0C
04E52:  MOVWF  FF7
04E54:  MOVLW  00
04E56:  MOVWF  FF8
04E58:  CLRF   1B
04E5A:  BTFSC  FF2.7
04E5C:  BSF    1B.7
04E5E:  BCF    FF2.7
04E60:  MOVLB  0
04E62:  CALL   0E3A
04E66:  BTFSC  1B.7
04E68:  BSF    FF2.7
04E6A:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04E6C:  MOVF   x67,W
04E6E:  ANDLW  06
04E70:  BZ    4E92
....................       printf("   Disk Full\r\n"); 
04E72:  MOVLW  C0
04E74:  MOVWF  FF6
04E76:  MOVLW  0C
04E78:  MOVWF  FF7
04E7A:  MOVLW  00
04E7C:  MOVWF  FF8
04E7E:  CLRF   1B
04E80:  BTFSC  FF2.7
04E82:  BSF    1B.7
04E84:  BCF    FF2.7
04E86:  MOVLB  0
04E88:  CALL   0E3A
04E8C:  BTFSC  1B.7
04E8E:  BSF    FF2.7
04E90:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04E92:  MOVF   x67,W
04E94:  ANDLW  07
04E96:  BZ    4EB8
....................       printf("   Read/Write Error\r\n"); 
04E98:  MOVLW  D0
04E9A:  MOVWF  FF6
04E9C:  MOVLW  0C
04E9E:  MOVWF  FF7
04EA0:  MOVLW  00
04EA2:  MOVWF  FF8
04EA4:  CLRF   1B
04EA6:  BTFSC  FF2.7
04EA8:  BSF    1B.7
04EAA:  BCF    FF2.7
04EAC:  MOVLB  0
04EAE:  CALL   0E3A
04EB2:  BTFSC  1B.7
04EB4:  BSF    FF2.7
04EB6:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04EB8:  MOVF   x67,W
04EBA:  ANDLW  09
04EBC:  BZ    4EDE
....................       printf("   Incorrect Media Change\r\n"); 
04EBE:  MOVLW  E6
04EC0:  MOVWF  FF6
04EC2:  MOVLW  0C
04EC4:  MOVWF  FF7
04EC6:  MOVLW  00
04EC8:  MOVWF  FF8
04ECA:  CLRF   1B
04ECC:  BTFSC  FF2.7
04ECE:  BSF    1B.7
04ED0:  BCF    FF2.7
04ED2:  MOVLB  0
04ED4:  CALL   0E3A
04ED8:  BTFSC  1B.7
04EDA:  BSF    FF2.7
04EDC:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04EDE:  MOVF   x67,W
04EE0:  ANDLW  0A
04EE2:  BZ    4F04
....................       printf("   Write Protected\r\n"); 
04EE4:  MOVLW  02
04EE6:  MOVWF  FF6
04EE8:  MOVLW  0D
04EEA:  MOVWF  FF7
04EEC:  MOVLW  00
04EEE:  MOVWF  FF8
04EF0:  CLRF   1B
04EF2:  BTFSC  FF2.7
04EF4:  BSF    1B.7
04EF6:  BCF    FF2.7
04EF8:  MOVLB  0
04EFA:  CALL   0E3A
04EFE:  BTFSC  1B.7
04F00:  BSF    FF2.7
04F02:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04F04:  MOVF   x67,W
04F06:  ANDLW  0B
04F08:  BZ    4F2A
....................       printf("   Not Enabled\r\n"); 
04F0A:  MOVLW  18
04F0C:  MOVWF  FF6
04F0E:  MOVLW  0D
04F10:  MOVWF  FF7
04F12:  MOVLW  00
04F14:  MOVWF  FF8
04F16:  CLRF   1B
04F18:  BTFSC  FF2.7
04F1A:  BSF    1B.7
04F1C:  BCF    FF2.7
04F1E:  MOVLB  0
04F20:  CALL   0E3A
04F24:  BTFSC  1B.7
04F26:  BSF    FF2.7
04F28:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04F2A:  MOVF   x67,W
04F2C:  ANDLW  0C
04F2E:  BZ    4F50
....................       printf("   No File System\r\n"); 
04F30:  MOVLW  2A
04F32:  MOVWF  FF6
04F34:  MOVLW  0D
04F36:  MOVWF  FF7
04F38:  MOVLW  00
04F3A:  MOVWF  FF8
04F3C:  CLRF   1B
04F3E:  BTFSC  FF2.7
04F40:  BSF    1B.7
04F42:  BCF    FF2.7
04F44:  MOVLB  0
04F46:  CALL   0E3A
04F4A:  BTFSC  1B.7
04F4C:  BSF    FF2.7
04F4E:  MOVLB  8
04F50:  MOVLB  0
04F52:  GOTO   4FDC (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
08238:  MOVLW  08
0823A:  MOVWF  FEA
0823C:  MOVLW  ED
0823E:  MOVWF  FE9
08240:  CLRF   00
08242:  CLRF   02
08244:  MOVLW  A0
08246:  MOVWF  01
08248:  CALL   34AE
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
0824C:  MOVLW  08
0824E:  MOVLB  9
08250:  MOVWF  x8E
08252:  MOVLW  CC
08254:  MOVWF  x8D
08256:  MOVFF  8CB,990
0825A:  MOVFF  8CA,98F
0825E:  MOVLW  12
08260:  MOVWF  x91
08262:  MOVLB  0
08264:  CALL   709E
08268:  MOVFF  01,8E8
....................    if (result) 
0826C:  MOVLB  8
0826E:  MOVF   xE8,F
08270:  BZ    8294
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
08272:  MOVLW  3E
08274:  MOVWF  FF6
08276:  MOVLW  0D
08278:  MOVWF  FF7
0827A:  MOVLW  00
0827C:  MOVWF  FF8
0827E:  CLRF   1B
08280:  BTFSC  FF2.7
08282:  BSF    1B.7
08284:  BCF    FF2.7
08286:  MOVLB  0
08288:  CALL   0E3A
0828C:  BTFSC  1B.7
0828E:  BSF    FF2.7
....................    } 
08290:  BRA    8410
08292:  MOVLB  8
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
08294:  MOVF   xD0,F
08296:  BNZ   82A4
08298:  MOVF   xD1,F
0829A:  BNZ   82A4
0829C:  MOVF   xD2,F
0829E:  BNZ   82A4
082A0:  MOVF   xD3,F
082A2:  BZ    82CA
....................          result = f_lseek(&fdst, fdst.fsize);  
082A4:  MOVLW  08
082A6:  MOVLB  9
082A8:  MOVWF  x8E
082AA:  MOVLW  CC
082AC:  MOVWF  x8D
082AE:  MOVFF  8D3,992
082B2:  MOVFF  8D2,991
082B6:  MOVFF  8D1,990
082BA:  MOVFF  8D0,98F
082BE:  MOVLB  0
082C0:  GOTO   74E6
082C4:  MOVFF  01,8E8
082C8:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
082CA:  MOVLB  0
082CC:  MOVF   x62,F
082CE:  BNZ   82EC
082D0:  MOVLW  08
082D2:  MOVLB  9
082D4:  MOVWF  x8E
082D6:  MOVLW  ED
082D8:  MOVWF  x8D
082DA:  CLRF   x90
082DC:  MOVLW  63
082DE:  MOVWF  x8F
082E0:  CLRF   x92
082E2:  MOVLW  9F
082E4:  MOVWF  x91
082E6:  MOVLB  0
082E8:  CALL   784E
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
082EC:  DECFSZ x62,W
082EE:  BRA    830E
082F0:  MOVLW  08
082F2:  MOVLB  9
082F4:  MOVWF  x8E
082F6:  MOVLW  ED
082F8:  MOVWF  x8D
082FA:  MOVLW  01
082FC:  MOVWF  x90
082FE:  MOVLW  03
08300:  MOVWF  x8F
08302:  CLRF   x92
08304:  MOVLW  9F
08306:  MOVWF  x91
08308:  MOVLB  0
0830A:  CALL   784E
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
0830E:  MOVF   20,F
08310:  BNZ   8318
08312:  MOVF   1F,W
08314:  SUBLW  04
08316:  BC    836C
08318:  MOVLW  5E
0831A:  MOVWF  FF6
0831C:  MOVLW  0D
0831E:  MOVWF  FF7
08320:  MOVLW  00
08322:  MOVWF  FF8
08324:  CLRF   1B
08326:  BTFSC  FF2.7
08328:  BSF    1B.7
0832A:  BCF    FF2.7
0832C:  MOVLW  0E
0832E:  MOVLB  A
08330:  MOVWF  x18
08332:  MOVLB  0
08334:  CALL   1010
08338:  BTFSC  1B.7
0833A:  BSF    FF2.7
0833C:  MOVLW  08
0833E:  MOVWF  FEA
08340:  MOVLW  ED
08342:  MOVWF  FE9
08344:  CALL   78DC
08348:  MOVLW  6E
0834A:  MOVWF  FF6
0834C:  MOVLW  0D
0834E:  MOVWF  FF7
08350:  MOVLW  00
08352:  MOVWF  FF8
08354:  CLRF   1B
08356:  BTFSC  FF2.7
08358:  BSF    1B.7
0835A:  BCF    FF2.7
0835C:  MOVLW  03
0835E:  MOVLB  A
08360:  MOVWF  x18
08362:  MOVLB  0
08364:  CALL   1010
08368:  BTFSC  1B.7
0836A:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
0836C:  MOVLW  08
0836E:  MOVLB  9
08370:  MOVWF  x8E
08372:  MOVLW  ED
08374:  MOVWF  x8D
08376:  MOVLB  0
08378:  GOTO   7902
0837C:  MOVFF  02,8EA
08380:  MOVFF  01,8E9
....................       result = f_write(&fdst, mesg, btw, &bw); 
08384:  MOVLW  08
08386:  MOVLB  9
08388:  MOVWF  x8E
0838A:  MOVLW  CC
0838C:  MOVWF  x8D
0838E:  MOVLW  08
08390:  MOVWF  x90
08392:  MOVLW  ED
08394:  MOVWF  x8F
08396:  MOVFF  8EA,992
0839A:  MOVFF  8E9,991
0839E:  MOVLW  08
083A0:  MOVWF  x94
083A2:  MOVLW  EB
083A4:  MOVWF  x93
083A6:  MOVLB  0
083A8:  GOTO   7940
083AC:  MOVFF  01,8E8
....................       if (result) 
083B0:  MOVLB  8
083B2:  MOVF   xE8,F
083B4:  BZ    83D8
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
083B6:  MOVLW  72
083B8:  MOVWF  FF6
083BA:  MOVLW  0D
083BC:  MOVWF  FF7
083BE:  MOVLW  00
083C0:  MOVWF  FF8
083C2:  CLRF   1B
083C4:  BTFSC  FF2.7
083C6:  BSF    1B.7
083C8:  BCF    FF2.7
083CA:  MOVLB  0
083CC:  CALL   0E3A
083D0:  BTFSC  1B.7
083D2:  BSF    FF2.7
....................       } 
083D4:  BRA    8400
083D6:  MOVLB  8
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
083D8:  MOVF   20,F
083DA:  BNZ   83E2
083DC:  MOVF   1F,W
083DE:  SUBLW  04
083E0:  BC    8402
083E2:  MOVLW  86
083E4:  MOVWF  FF6
083E6:  MOVLW  0D
083E8:  MOVWF  FF7
083EA:  MOVLW  00
083EC:  MOVWF  FF8
083EE:  CLRF   1B
083F0:  BTFSC  FF2.7
083F2:  BSF    1B.7
083F4:  BCF    FF2.7
083F6:  MOVLB  0
083F8:  CALL   0E3A
083FC:  BTFSC  1B.7
083FE:  BSF    FF2.7
08400:  MOVLB  8
....................       } 
....................  
....................       f_close(&fdst); 
08402:  MOVLW  08
08404:  MOVLB  9
08406:  MOVWF  x8E
08408:  MOVLW  CC
0840A:  MOVWF  x8D
0840C:  MOVLB  0
0840E:  RCALL  81EC
....................    } 
....................  
....................    return (result); 
08410:  MOVLB  8
08412:  MOVFF  8E8,01
08416:  MOVLB  0
08418:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
17636:  CLRF   1B
17638:  BTFSC  FF2.7
1763A:  BSF    1B.7
1763C:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
1763E:  MOVFF  864,A1A
17642:  MOVLW  0A
17644:  MOVLB  A
17646:  MOVWF  x1B
17648:  MOVLB  0
1764A:  CALL   0F66
1764E:  BTFSC  1B.7
17650:  BSF    FF2.7
17652:  MOVFF  01,865
....................    nibl=data-(nibh*10); 
17656:  MOVLB  8
17658:  MOVF   x65,W
1765A:  MULLW  0A
1765C:  MOVF   FF3,W
1765E:  SUBWF  x64,W
17660:  MOVWF  x66
....................  
....................    return((nibh<<4)|nibl); 
17662:  SWAPF  x65,W
17664:  MOVWF  00
17666:  MOVLW  F0
17668:  ANDWF  00,F
1766A:  MOVF   00,W
1766C:  IORWF  x66,W
1766E:  MOVWF  01
17670:  MOVLB  0
17672:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
0329A:  MOVFF  8CB,8CC
....................    data=(i>>4)*10; 
0329E:  MOVLB  8
032A0:  SWAPF  xCC,W
032A2:  MOVWF  00
032A4:  MOVLW  0F
032A6:  ANDWF  00,F
032A8:  MOVF   00,W
032AA:  MULLW  0A
032AC:  MOVFF  FF3,8CB
....................    data=data+(i<<4>>4); 
032B0:  SWAPF  xCC,W
032B2:  MOVWF  00
032B4:  MOVLW  F0
032B6:  ANDWF  00,F
032B8:  MOVF   00,W
032BA:  SWAPF  00,F
032BC:  MOVLW  0F
032BE:  ANDWF  00,F
032C0:  MOVF   00,W
032C2:  ADDWF  xCB,F
....................  
....................    return data; 
032C4:  MOVFF  8CB,01
032C8:  MOVLB  0
032CA:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0343A:  MOVLB  8
0343C:  CLRF   xA8
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0343E:  BCF    FC6.5
03440:  MOVLW  21
03442:  MOVWF  FC6
03444:  MOVLW  40
03446:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
03448:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
0344A:  MOVF   FC9,W
0344C:  MOVLW  0C
0344E:  MOVWF  FC9
03450:  RRCF   FC7,W
03452:  BNC   3450
03454:  MOVFF  FC9,8A8
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
03458:  MOVF   FC9,W
0345A:  MOVFF  8A8,FC9
0345E:  RRCF   FC7,W
03460:  BNC   345E
03462:  MOVFF  FC9,72C
....................    output_bit(RTC_CS, DISABLE); 
03466:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
03468:  MOVLB  7
0346A:  BCF    x2C.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
0346C:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
0346E:  MOVF   FC9,W
03470:  MOVLW  8C
03472:  MOVWF  FC9
03474:  RRCF   FC7,W
03476:  BNC   3474
03478:  MOVFF  FC9,8A8
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
0347C:  MOVF   FC9,W
0347E:  MOVFF  72C,FC9
03482:  RRCF   FC7,W
03484:  BNC   3482
03486:  MOVFF  FC9,8A8
....................    output_bit(RTC_CS, DISABLE); 
0348A:  BSF    F91.0
0348C:  MOVLB  0
0348E:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0DF8C:  MOVLW  1A
0DF8E:  MOVLB  8
0DF90:  MOVWF  x74
0DF92:  MOVLB  0
0DF94:  CALL   2952
0DF98:  MOVFF  01,4B
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0DF9C:  MOVF   4B,F
0DF9E:  BNZ   E00C
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0DFA0:  MOVLW  94
0DFA2:  MOVWF  FF6
0DFA4:  MOVLW  0D
0DFA6:  MOVWF  FF7
0DFA8:  MOVLW  00
0DFAA:  MOVWF  FF8
0DFAC:  CLRF   1B
0DFAE:  BTFSC  FF2.7
0DFB0:  BSF    1B.7
0DFB2:  BCF    FF2.7
0DFB4:  MOVLW  05
0DFB6:  MOVLB  A
0DFB8:  MOVWF  x18
0DFBA:  MOVLB  0
0DFBC:  CALL   1010
0DFC0:  BTFSC  1B.7
0DFC2:  BSF    FF2.7
0DFC4:  CLRF   1B
0DFC6:  BTFSC  FF2.7
0DFC8:  BSF    1B.7
0DFCA:  BCF    FF2.7
0DFCC:  MOVFF  726,A18
0DFD0:  MOVLW  01
0DFD2:  MOVLB  A
0DFD4:  MOVWF  x19
0DFD6:  MOVLB  0
0DFD8:  CALL   0F92
0DFDC:  BTFSC  1B.7
0DFDE:  BSF    FF2.7
0DFE0:  MOVLW  2F
0DFE2:  BTFSS  F9E.4
0DFE4:  BRA    DFE2
0DFE6:  MOVWF  FAD
0DFE8:  CLRF   1B
0DFEA:  BTFSC  FF2.7
0DFEC:  BSF    1B.7
0DFEE:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0DFF0:  MOVFF  725,A18
0DFF4:  MOVLW  01
0DFF6:  MOVLB  A
0DFF8:  MOVWF  x19
0DFFA:  MOVLB  0
0DFFC:  CALL   0F92
0E000:  BTFSC  1B.7
0E002:  BSF    FF2.7
0E004:  MOVLW  2F
0E006:  BTFSS  F9E.4
0E008:  BRA    E006
0E00A:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0E00C:  DECFSZ 4B,W
0E00E:  BRA    E07C
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0E010:  MOVLW  A0
0E012:  MOVWF  FF6
0E014:  MOVLW  0D
0E016:  MOVWF  FF7
0E018:  MOVLW  00
0E01A:  MOVWF  FF8
0E01C:  CLRF   1B
0E01E:  BTFSC  FF2.7
0E020:  BSF    1B.7
0E022:  BCF    FF2.7
0E024:  MOVLW  05
0E026:  MOVLB  A
0E028:  MOVWF  x18
0E02A:  MOVLB  0
0E02C:  CALL   1010
0E030:  BTFSC  1B.7
0E032:  BSF    FF2.7
0E034:  CLRF   1B
0E036:  BTFSC  FF2.7
0E038:  BSF    1B.7
0E03A:  BCF    FF2.7
0E03C:  MOVFF  725,A18
0E040:  MOVLW  01
0E042:  MOVLB  A
0E044:  MOVWF  x19
0E046:  MOVLB  0
0E048:  CALL   0F92
0E04C:  BTFSC  1B.7
0E04E:  BSF    FF2.7
0E050:  MOVLW  2F
0E052:  BTFSS  F9E.4
0E054:  BRA    E052
0E056:  MOVWF  FAD
0E058:  CLRF   1B
0E05A:  BTFSC  FF2.7
0E05C:  BSF    1B.7
0E05E:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0E060:  MOVFF  726,A18
0E064:  MOVLW  01
0E066:  MOVLB  A
0E068:  MOVWF  x19
0E06A:  MOVLB  0
0E06C:  CALL   0F92
0E070:  BTFSC  1B.7
0E072:  BSF    FF2.7
0E074:  MOVLW  2F
0E076:  BTFSS  F9E.4
0E078:  BRA    E076
0E07A:  MOVWF  FAD
0E07C:  CLRF   1B
0E07E:  BTFSC  FF2.7
0E080:  BSF    1B.7
0E082:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0E084:  MOVFF  727,A18
0E088:  MOVLW  01
0E08A:  MOVLB  A
0E08C:  MOVWF  x19
0E08E:  MOVLB  0
0E090:  CALL   0F92
0E094:  BTFSC  1B.7
0E096:  BSF    FF2.7
0E098:  MOVLW  20
0E09A:  BTFSS  F9E.4
0E09C:  BRA    E09A
0E09E:  MOVWF  FAD
0E0A0:  CLRF   1B
0E0A2:  BTFSC  FF2.7
0E0A4:  BSF    1B.7
0E0A6:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E0A8:  MOVFF  723,A18
0E0AC:  MOVLW  01
0E0AE:  MOVLB  A
0E0B0:  MOVWF  x19
0E0B2:  MOVLB  0
0E0B4:  CALL   0F92
0E0B8:  BTFSC  1B.7
0E0BA:  BSF    FF2.7
0E0BC:  MOVLW  3A
0E0BE:  BTFSS  F9E.4
0E0C0:  BRA    E0BE
0E0C2:  MOVWF  FAD
0E0C4:  CLRF   1B
0E0C6:  BTFSC  FF2.7
0E0C8:  BSF    1B.7
0E0CA:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E0CC:  MOVFF  722,A18
0E0D0:  MOVLW  01
0E0D2:  MOVLB  A
0E0D4:  MOVWF  x19
0E0D6:  MOVLB  0
0E0D8:  CALL   0F92
0E0DC:  BTFSC  1B.7
0E0DE:  BSF    FF2.7
0E0E0:  MOVLW  3A
0E0E2:  BTFSS  F9E.4
0E0E4:  BRA    E0E2
0E0E6:  MOVWF  FAD
0E0E8:  CLRF   1B
0E0EA:  BTFSC  FF2.7
0E0EC:  BSF    1B.7
0E0EE:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E0F0:  MOVFF  721,A18
0E0F4:  MOVLW  01
0E0F6:  MOVLB  A
0E0F8:  MOVWF  x19
0E0FA:  MOVLB  0
0E0FC:  CALL   0F92
0E100:  BTFSC  1B.7
0E102:  BSF    FF2.7
0E104:  MOVLW  0A
0E106:  BTFSS  F9E.4
0E108:  BRA    E106
0E10A:  MOVWF  FAD
0E10C:  MOVLW  0D
0E10E:  BTFSS  F9E.4
0E110:  BRA    E10E
0E112:  MOVWF  FAD
0E114:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
032CC:  MOVLB  8
032CE:  CLRF   xCA
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
032D0:  BCF    FC6.5
032D2:  MOVLW  21
032D4:  MOVWF  FC6
032D6:  MOVLW  40
032D8:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
032DA:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
032DC:  MOVF   FC9,W
032DE:  CLRF   FC9
032E0:  RRCF   FC7,W
032E2:  BNC   32E0
032E4:  MOVFF  FC9,8CA
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
032E8:  MOVF   FC9,W
032EA:  MOVFF  8CA,FC9
032EE:  RRCF   FC7,W
032F0:  BNC   32EE
032F2:  MOVFF  FC9,728
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
032F6:  MOVF   FC9,W
032F8:  MOVFF  8CA,FC9
032FC:  RRCF   FC7,W
032FE:  BNC   32FC
03300:  MOVFF  FC9,721
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
03304:  MOVF   FC9,W
03306:  MOVFF  8CA,FC9
0330A:  RRCF   FC7,W
0330C:  BNC   330A
0330E:  MOVFF  FC9,722
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
03312:  MOVF   FC9,W
03314:  MOVFF  8CA,FC9
03318:  RRCF   FC7,W
0331A:  BNC   3318
0331C:  MOVFF  FC9,723
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
03320:  MOVF   FC9,W
03322:  MOVFF  8CA,FC9
03326:  RRCF   FC7,W
03328:  BNC   3326
0332A:  MOVFF  FC9,724
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
0332E:  MOVF   FC9,W
03330:  MOVFF  8CA,FC9
03334:  RRCF   FC7,W
03336:  BNC   3334
03338:  MOVFF  FC9,725
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
0333C:  MOVF   FC9,W
0333E:  MOVFF  8CA,FC9
03342:  RRCF   FC7,W
03344:  BNC   3342
03346:  MOVFF  FC9,726
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
0334A:  MOVF   FC9,W
0334C:  MOVFF  8CA,FC9
03350:  RRCF   FC7,W
03352:  BNC   3350
03354:  MOVFF  FC9,727
....................    output_bit(RTC_CS, DISABLE); 
03358:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
0335A:  MOVFF  721,8CB
0335E:  MOVLB  0
03360:  RCALL  329A
03362:  MOVFF  01,721
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
03366:  MOVFF  722,8CB
0336A:  RCALL  329A
0336C:  MOVFF  01,722
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
03370:  MOVFF  723,8CB
03374:  RCALL  329A
03376:  MOVFF  01,723
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
0337A:  MOVFF  725,8CB
0337E:  RCALL  329A
03380:  MOVFF  01,725
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
03384:  MOVFF  726,8CB
03388:  RCALL  329A
0338A:  MOVFF  01,726
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
0338E:  MOVFF  727,8CB
03392:  RCALL  329A
03394:  MOVFF  01,727
03398:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DCC:  MOVLB  A
00DCE:  CLRF   x0F
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DD0:  BCF    FC6.5
00DD2:  MOVLW  21
00DD4:  MOVWF  FC6
00DD6:  MOVLW  40
00DD8:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00DDA:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00DDC:  MOVF   FC9,W
00DDE:  MOVLW  0F
00DE0:  MOVWF  FC9
00DE2:  RRCF   FC7,W
00DE4:  BNC   0DE2
00DE6:  MOVFF  FC9,A0F
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00DEA:  MOVF   FC9,W
00DEC:  MOVFF  A0F,FC9
00DF0:  RRCF   FC7,W
00DF2:  BNC   0DF0
00DF4:  MOVFF  FC9,72F
....................    output_bit(RTC_CS, DISABLE); 
00DF8:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00DFA:  BCF    49.2
00DFC:  MOVLB  0
00DFE:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E1EC:  MOVF   4B,F
0E1EE:  BNZ   E25C
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E1F0:  MOVLW  AC
0E1F2:  MOVWF  FF6
0E1F4:  MOVLW  0D
0E1F6:  MOVWF  FF7
0E1F8:  MOVLW  00
0E1FA:  MOVWF  FF8
0E1FC:  CLRF   1B
0E1FE:  BTFSC  FF2.7
0E200:  BSF    1B.7
0E202:  BCF    FF2.7
0E204:  MOVLW  05
0E206:  MOVLB  A
0E208:  MOVWF  x18
0E20A:  MOVLB  0
0E20C:  CALL   1010
0E210:  BTFSC  1B.7
0E212:  BSF    FF2.7
0E214:  CLRF   1B
0E216:  BTFSC  FF2.7
0E218:  BSF    1B.7
0E21A:  BCF    FF2.7
0E21C:  MOVFF  72A,A18
0E220:  MOVLW  01
0E222:  MOVLB  A
0E224:  MOVWF  x19
0E226:  MOVLB  0
0E228:  CALL   0F92
0E22C:  BTFSC  1B.7
0E22E:  BSF    FF2.7
0E230:  MOVLW  2F
0E232:  BTFSS  F9E.4
0E234:  BRA    E232
0E236:  MOVWF  FAD
0E238:  CLRF   1B
0E23A:  BTFSC  FF2.7
0E23C:  BSF    1B.7
0E23E:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E240:  MOVFF  72B,A18
0E244:  MOVLW  01
0E246:  MOVLB  A
0E248:  MOVWF  x19
0E24A:  MOVLB  0
0E24C:  CALL   0F92
0E250:  BTFSC  1B.7
0E252:  BSF    FF2.7
0E254:  MOVLW  2F
0E256:  BTFSS  F9E.4
0E258:  BRA    E256
0E25A:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E25C:  DECFSZ 4B,W
0E25E:  BRA    E2CC
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E260:  MOVLW  B8
0E262:  MOVWF  FF6
0E264:  MOVLW  0D
0E266:  MOVWF  FF7
0E268:  MOVLW  00
0E26A:  MOVWF  FF8
0E26C:  CLRF   1B
0E26E:  BTFSC  FF2.7
0E270:  BSF    1B.7
0E272:  BCF    FF2.7
0E274:  MOVLW  05
0E276:  MOVLB  A
0E278:  MOVWF  x18
0E27A:  MOVLB  0
0E27C:  CALL   1010
0E280:  BTFSC  1B.7
0E282:  BSF    FF2.7
0E284:  CLRF   1B
0E286:  BTFSC  FF2.7
0E288:  BSF    1B.7
0E28A:  BCF    FF2.7
0E28C:  MOVFF  72B,A18
0E290:  MOVLW  01
0E292:  MOVLB  A
0E294:  MOVWF  x19
0E296:  MOVLB  0
0E298:  CALL   0F92
0E29C:  BTFSC  1B.7
0E29E:  BSF    FF2.7
0E2A0:  MOVLW  2F
0E2A2:  BTFSS  F9E.4
0E2A4:  BRA    E2A2
0E2A6:  MOVWF  FAD
0E2A8:  CLRF   1B
0E2AA:  BTFSC  FF2.7
0E2AC:  BSF    1B.7
0E2AE:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E2B0:  MOVFF  72A,A18
0E2B4:  MOVLW  01
0E2B6:  MOVLB  A
0E2B8:  MOVWF  x19
0E2BA:  MOVLB  0
0E2BC:  CALL   0F92
0E2C0:  BTFSC  1B.7
0E2C2:  BSF    FF2.7
0E2C4:  MOVLW  2F
0E2C6:  BTFSS  F9E.4
0E2C8:  BRA    E2C6
0E2CA:  MOVWF  FAD
0E2CC:  CLRF   1B
0E2CE:  BTFSC  FF2.7
0E2D0:  BSF    1B.7
0E2D2:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E2D4:  MOVFF  729,A18
0E2D8:  MOVLW  01
0E2DA:  MOVLB  A
0E2DC:  MOVWF  x19
0E2DE:  MOVLB  0
0E2E0:  CALL   0F92
0E2E4:  BTFSC  1B.7
0E2E6:  BSF    FF2.7
0E2E8:  MOVLW  20
0E2EA:  BTFSS  F9E.4
0E2EC:  BRA    E2EA
0E2EE:  MOVWF  FAD
0E2F0:  CLRF   1B
0E2F2:  BTFSC  FF2.7
0E2F4:  BSF    1B.7
0E2F6:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E2F8:  MOVFF  72C,A18
0E2FC:  MOVLW  01
0E2FE:  MOVLB  A
0E300:  MOVWF  x19
0E302:  MOVLB  0
0E304:  CALL   0F92
0E308:  BTFSC  1B.7
0E30A:  BSF    FF2.7
0E30C:  MOVLW  3A
0E30E:  BTFSS  F9E.4
0E310:  BRA    E30E
0E312:  MOVWF  FAD
0E314:  CLRF   1B
0E316:  BTFSC  FF2.7
0E318:  BSF    1B.7
0E31A:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E31C:  MOVFF  72D,A18
0E320:  MOVLW  01
0E322:  MOVLB  A
0E324:  MOVWF  x19
0E326:  MOVLB  0
0E328:  CALL   0F92
0E32C:  BTFSC  1B.7
0E32E:  BSF    FF2.7
0E330:  MOVLW  3A
0E332:  BTFSS  F9E.4
0E334:  BRA    E332
0E336:  MOVWF  FAD
0E338:  CLRF   1B
0E33A:  BTFSC  FF2.7
0E33C:  BSF    1B.7
0E33E:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E340:  MOVFF  72E,A18
0E344:  MOVLW  01
0E346:  MOVLB  A
0E348:  MOVWF  x19
0E34A:  MOVLB  0
0E34C:  CALL   0F92
0E350:  BTFSC  1B.7
0E352:  BSF    FF2.7
0E354:  MOVLW  0A
0E356:  BTFSS  F9E.4
0E358:  BRA    E356
0E35A:  MOVWF  FAD
0E35C:  MOVLW  0D
0E35E:  BTFSS  F9E.4
0E360:  BRA    E35E
0E362:  MOVWF  FAD
0E364:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E116:  MOVLB  8
0E118:  CLRF   x94
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E11A:  BCF    FC6.5
0E11C:  MOVLW  21
0E11E:  MOVWF  FC6
0E120:  MOVLW  40
0E122:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E124:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E126:  MOVF   FC9,W
0E128:  MOVLW  0A
0E12A:  MOVWF  FC9
0E12C:  RRCF   FC7,W
0E12E:  BNC   E12C
0E130:  MOVFF  FC9,894
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E134:  MOVF   FC9,W
0E136:  MOVFF  894,FC9
0E13A:  RRCF   FC7,W
0E13C:  BNC   E13A
0E13E:  MOVFF  FC9,72A
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E142:  MOVF   FC9,W
0E144:  MOVFF  894,FC9
0E148:  RRCF   FC7,W
0E14A:  BNC   E148
0E14C:  MOVFF  FC9,72B
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E150:  MOVF   FC9,W
0E152:  MOVFF  894,FC9
0E156:  RRCF   FC7,W
0E158:  BNC   E156
0E15A:  MOVFF  FC9,72C
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E15E:  MOVF   FC9,W
0E160:  MOVFF  894,FC9
0E164:  RRCF   FC7,W
0E166:  BNC   E164
0E168:  MOVFF  FC9,72D
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E16C:  MOVF   FC9,W
0E16E:  MOVFF  894,FC9
0E172:  RRCF   FC7,W
0E174:  BNC   E172
0E176:  MOVFF  FC9,72E
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E17A:  MOVF   FC9,W
0E17C:  MOVFF  894,FC9
0E180:  RRCF   FC7,W
0E182:  BNC   E180
0E184:  MOVFF  FC9,72F
....................    output_bit(RTC_CS, DISABLE); 
0E188:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E18A:  MOVLW  1F
0E18C:  MOVLB  7
0E18E:  ANDWF  x2A,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E190:  MOVFF  72A,8CB
0E194:  MOVLB  0
0E196:  CALL   329A
0E19A:  MOVFF  01,72A
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E19E:  MOVLW  3F
0E1A0:  MOVLB  7
0E1A2:  ANDWF  x2B,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E1A4:  MOVFF  72B,8CB
0E1A8:  MOVLB  0
0E1AA:  CALL   329A
0E1AE:  MOVFF  01,72B
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E1B2:  MOVLW  3F
0E1B4:  MOVLB  7
0E1B6:  ANDWF  x2C,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E1B8:  MOVFF  72C,8CB
0E1BC:  MOVLB  0
0E1BE:  CALL   329A
0E1C2:  MOVFF  01,72C
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E1C6:  MOVLB  7
0E1C8:  BCF    x2D.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E1CA:  MOVFF  72D,8CB
0E1CE:  MOVLB  0
0E1D0:  CALL   329A
0E1D4:  MOVFF  01,72D
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E1D8:  MOVLB  7
0E1DA:  BCF    x2E.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E1DC:  MOVFF  72E,8CB
0E1E0:  MOVLB  0
0E1E2:  CALL   329A
0E1E6:  MOVFF  01,72E
0E1EA:  RETURN 0
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
1727C:  MOVLW  08
1727E:  MOVWF  FEA
17280:  MOVLW  66
17282:  MOVWF  FE9
17284:  CLRF   00
17286:  CLRF   02
17288:  MOVLW  0C
1728A:  MOVWF  01
1728C:  CALL   34AE
....................  
....................    time_error = 0; 
17290:  MOVLB  8
17292:  CLRF   x72
....................     
....................    fputc('[', COM_A); 
17294:  MOVLW  5B
17296:  MOVLB  0
17298:  CALL   ADB4
....................     
....................    for (n=0; n<12; ++n){ 
1729C:  MOVLB  8
1729E:  CLRF   x65
172A0:  MOVF   x65,W
172A2:  SUBLW  0B
172A4:  BNC   172EA
....................       c = fgetc(COM_A); 
172A6:  MOVLB  0
172A8:  CALL   0E24
172AC:  MOVFF  01,864
....................       if (com_echo == TRUE) 
172B0:  DECFSZ 48,W
172B2:  BRA    172BE
....................       { 
....................          fputc(c, COM_A); 
172B4:  MOVLB  8
172B6:  MOVF   x64,W
172B8:  MOVLB  0
172BA:  CALL   ADB4
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
172BE:  MOVLB  8
172C0:  MOVF   x64,W
172C2:  SUBLW  2F
172C4:  BC    172E0
172C6:  MOVF   x64,W
172C8:  SUBLW  39
172CA:  BNC   172E0
172CC:  CLRF   03
172CE:  MOVF   x65,W
172D0:  ADDLW  66
172D2:  MOVWF  FE9
172D4:  MOVLW  08
172D6:  ADDWFC 03,W
172D8:  MOVWF  FEA
172DA:  MOVFF  864,FEF
172DE:  BRA    172E6
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
172E0:  MOVLW  01
172E2:  MOVWF  x72
....................          break; 
172E4:  BRA    172EA
....................       } 
172E6:  INCF   x65,F
172E8:  BRA    172A0
....................    } 
....................     
....................    if (time_error == 0){ 
172EA:  MOVF   x72,F
172EC:  BTFSS  FD8.2
172EE:  BRA    17626
....................     
....................       fputc(']', COM_A); 
172F0:  MOVLW  5D
172F2:  MOVLB  0
172F4:  CALL   ADB4
....................        
....................       for (n=0; n<12; ++n){ 
172F8:  MOVLB  8
172FA:  CLRF   x65
172FC:  MOVF   x65,W
172FE:  SUBLW  0B
17300:  BNC   17332
....................          t_entry[n] = (t_entry[n] - 48); 
17302:  CLRF   03
17304:  MOVF   x65,W
17306:  ADDLW  66
17308:  MOVWF  01
1730A:  MOVLW  08
1730C:  ADDWFC 03,F
1730E:  MOVFF  03,874
17312:  CLRF   03
17314:  MOVF   x65,W
17316:  ADDLW  66
17318:  MOVWF  FE9
1731A:  MOVLW  08
1731C:  ADDWFC 03,W
1731E:  MOVWF  FEA
17320:  MOVLW  30
17322:  SUBWF  FEF,W
17324:  MOVFF  874,FEA
17328:  MOVFF  01,FE9
1732C:  MOVWF  FEF
1732E:  INCF   x65,F
17330:  BRA    172FC
....................       } 
....................        
....................       if (RTCfmt == 0) 
17332:  MOVF   4B,F
17334:  BNZ   17372
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
17336:  MOVF   x66,W
17338:  MULLW  0A
1733A:  MOVF   FF3,W
1733C:  ADDWF  x67,W
1733E:  MOVLB  7
17340:  MOVWF  x34
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17342:  MOVF   x34,F
17344:  BZ    1734C
17346:  MOVF   x34,W
17348:  SUBLW  0C
1734A:  BC    17354
1734C:  MOVLW  02
1734E:  MOVLB  8
17350:  MOVWF  x72
17352:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
17354:  MOVLB  8
17356:  MOVF   x68,W
17358:  MULLW  0A
1735A:  MOVF   FF3,W
1735C:  ADDWF  x69,W
1735E:  MOVLB  7
17360:  MOVWF  x33
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17362:  MOVF   x33,F
17364:  BZ    1736C
17366:  MOVF   x33,W
17368:  SUBLW  1F
1736A:  BC    17374
1736C:  MOVLW  02
1736E:  MOVLB  8
17370:  MOVWF  x72
17372:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17374:  DECFSZ 4B,W
17376:  BRA    173B8
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
17378:  MOVLB  8
1737A:  MOVF   x66,W
1737C:  MULLW  0A
1737E:  MOVF   FF3,W
17380:  ADDWF  x67,W
17382:  MOVLB  7
17384:  MOVWF  x33
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17386:  MOVF   x33,F
17388:  BZ    17390
1738A:  MOVF   x33,W
1738C:  SUBLW  1F
1738E:  BC    17398
17390:  MOVLW  02
17392:  MOVLB  8
17394:  MOVWF  x72
17396:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
17398:  MOVLB  8
1739A:  MOVF   x68,W
1739C:  MULLW  0A
1739E:  MOVF   FF3,W
173A0:  ADDWF  x69,W
173A2:  MOVLB  7
173A4:  MOVWF  x34
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
173A6:  MOVF   x34,F
173A8:  BZ    173B0
173AA:  MOVF   x34,W
173AC:  SUBLW  0C
173AE:  BC    173B8
173B0:  MOVLW  02
173B2:  MOVLB  8
173B4:  MOVWF  x72
173B6:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
173B8:  MOVLB  8
173BA:  MOVF   x6A,W
173BC:  MULLW  0A
173BE:  MOVF   FF3,W
173C0:  ADDWF  x6B,W
173C2:  MOVLB  7
173C4:  MOVWF  x35
....................       if (RTC_Yr_Data > 99) time_error = 2;  
173C6:  MOVF   x35,W
173C8:  SUBLW  63
173CA:  BC    173D4
173CC:  MOVLW  02
173CE:  MOVLB  8
173D0:  MOVWF  x72
173D2:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
173D4:  MOVLB  8
173D6:  MOVF   x6C,W
173D8:  MULLW  0A
173DA:  MOVF   FF3,W
173DC:  ADDWF  x6D,W
173DE:  MOVLB  7
173E0:  MOVWF  x32
....................       if (RTC_Hr_Data > 24) time_error = 2;  
173E2:  MOVF   x32,W
173E4:  SUBLW  18
173E6:  BC    173F0
173E8:  MOVLW  02
173EA:  MOVLB  8
173EC:  MOVWF  x72
173EE:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
173F0:  MOVLB  8
173F2:  MOVF   x6E,W
173F4:  MULLW  0A
173F6:  MOVF   FF3,W
173F8:  ADDWF  x6F,W
173FA:  MOVLB  7
173FC:  MOVWF  x31
....................       if (RTC_Min_Data > 60) time_error = 2;  
173FE:  MOVF   x31,W
17400:  SUBLW  3C
17402:  BC    1740C
17404:  MOVLW  02
17406:  MOVLB  8
17408:  MOVWF  x72
1740A:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
1740C:  MOVLB  8
1740E:  MOVF   x70,W
17410:  MULLW  0A
17412:  MOVF   FF3,W
17414:  ADDWF  x71,W
17416:  MOVLB  7
17418:  MOVWF  x30
....................       if (RTC_Sec_Data > 60) time_error = 2; 
1741A:  MOVF   x30,W
1741C:  SUBLW  3C
1741E:  BC    17428
17420:  MOVLW  02
17422:  MOVLB  8
17424:  MOVWF  x72
17426:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
17428:  MOVF   4B,F
1742A:  BTFSS  FD8.2
1742C:  BRA    17520
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
1742E:  MOVLW  0A
17430:  BTFSS  F9E.4
17432:  BRA    17430
17434:  MOVWF  FAD
17436:  MOVLW  0D
17438:  BTFSS  F9E.4
1743A:  BRA    17438
1743C:  MOVWF  FAD
1743E:  CLRF   1B
17440:  BTFSC  FF2.7
17442:  BSF    1B.7
17444:  BCF    FF2.7
17446:  MOVFF  734,A18
1744A:  MOVLW  01
1744C:  MOVLB  A
1744E:  MOVWF  x19
17450:  MOVLB  0
17452:  CALL   0F92
17456:  BTFSC  1B.7
17458:  BSF    FF2.7
1745A:  MOVLW  2F
1745C:  BTFSS  F9E.4
1745E:  BRA    1745C
17460:  MOVWF  FAD
17462:  CLRF   1B
17464:  BTFSC  FF2.7
17466:  BSF    1B.7
17468:  BCF    FF2.7
1746A:  MOVFF  733,A18
1746E:  MOVLW  01
17470:  MOVLB  A
17472:  MOVWF  x19
17474:  MOVLB  0
17476:  CALL   0F92
1747A:  BTFSC  1B.7
1747C:  BSF    FF2.7
1747E:  MOVLW  2F
17480:  BTFSS  F9E.4
17482:  BRA    17480
17484:  MOVWF  FAD
17486:  CLRF   1B
17488:  BTFSC  FF2.7
1748A:  BSF    1B.7
1748C:  BCF    FF2.7
1748E:  MOVFF  735,A18
17492:  MOVLW  01
17494:  MOVLB  A
17496:  MOVWF  x19
17498:  MOVLB  0
1749A:  CALL   0F92
1749E:  BTFSC  1B.7
174A0:  BSF    FF2.7
174A2:  MOVLW  20
174A4:  BTFSS  F9E.4
174A6:  BRA    174A4
174A8:  MOVWF  FAD
174AA:  CLRF   1B
174AC:  BTFSC  FF2.7
174AE:  BSF    1B.7
174B0:  BCF    FF2.7
174B2:  MOVFF  732,A18
174B6:  MOVLW  01
174B8:  MOVLB  A
174BA:  MOVWF  x19
174BC:  MOVLB  0
174BE:  CALL   0F92
174C2:  BTFSC  1B.7
174C4:  BSF    FF2.7
174C6:  MOVLW  3A
174C8:  BTFSS  F9E.4
174CA:  BRA    174C8
174CC:  MOVWF  FAD
174CE:  CLRF   1B
174D0:  BTFSC  FF2.7
174D2:  BSF    1B.7
174D4:  BCF    FF2.7
174D6:  MOVFF  731,A18
174DA:  MOVLW  01
174DC:  MOVLB  A
174DE:  MOVWF  x19
174E0:  MOVLB  0
174E2:  CALL   0F92
174E6:  BTFSC  1B.7
174E8:  BSF    FF2.7
174EA:  MOVLW  3A
174EC:  BTFSS  F9E.4
174EE:  BRA    174EC
174F0:  MOVWF  FAD
174F2:  CLRF   1B
174F4:  BTFSC  FF2.7
174F6:  BSF    1B.7
174F8:  BCF    FF2.7
174FA:  MOVFF  730,A18
174FE:  MOVLW  01
17500:  MOVLB  A
17502:  MOVWF  x19
17504:  MOVLB  0
17506:  CALL   0F92
1750A:  BTFSC  1B.7
1750C:  BSF    FF2.7
1750E:  MOVLW  0A
17510:  BTFSS  F9E.4
17512:  BRA    17510
17514:  MOVWF  FAD
17516:  MOVLW  0D
17518:  BTFSS  F9E.4
1751A:  BRA    17518
1751C:  MOVWF  FAD
1751E:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17520:  DECFSZ 4B,W
17522:  BRA    17616
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
17524:  MOVLW  0A
17526:  BTFSS  F9E.4
17528:  BRA    17526
1752A:  MOVWF  FAD
1752C:  MOVLW  0D
1752E:  BTFSS  F9E.4
17530:  BRA    1752E
17532:  MOVWF  FAD
17534:  CLRF   1B
17536:  BTFSC  FF2.7
17538:  BSF    1B.7
1753A:  BCF    FF2.7
1753C:  MOVFF  733,A18
17540:  MOVLW  01
17542:  MOVLB  A
17544:  MOVWF  x19
17546:  MOVLB  0
17548:  CALL   0F92
1754C:  BTFSC  1B.7
1754E:  BSF    FF2.7
17550:  MOVLW  2F
17552:  BTFSS  F9E.4
17554:  BRA    17552
17556:  MOVWF  FAD
17558:  CLRF   1B
1755A:  BTFSC  FF2.7
1755C:  BSF    1B.7
1755E:  BCF    FF2.7
17560:  MOVFF  734,A18
17564:  MOVLW  01
17566:  MOVLB  A
17568:  MOVWF  x19
1756A:  MOVLB  0
1756C:  CALL   0F92
17570:  BTFSC  1B.7
17572:  BSF    FF2.7
17574:  MOVLW  2F
17576:  BTFSS  F9E.4
17578:  BRA    17576
1757A:  MOVWF  FAD
1757C:  CLRF   1B
1757E:  BTFSC  FF2.7
17580:  BSF    1B.7
17582:  BCF    FF2.7
17584:  MOVFF  735,A18
17588:  MOVLW  01
1758A:  MOVLB  A
1758C:  MOVWF  x19
1758E:  MOVLB  0
17590:  CALL   0F92
17594:  BTFSC  1B.7
17596:  BSF    FF2.7
17598:  MOVLW  20
1759A:  BTFSS  F9E.4
1759C:  BRA    1759A
1759E:  MOVWF  FAD
175A0:  CLRF   1B
175A2:  BTFSC  FF2.7
175A4:  BSF    1B.7
175A6:  BCF    FF2.7
175A8:  MOVFF  732,A18
175AC:  MOVLW  01
175AE:  MOVLB  A
175B0:  MOVWF  x19
175B2:  MOVLB  0
175B4:  CALL   0F92
175B8:  BTFSC  1B.7
175BA:  BSF    FF2.7
175BC:  MOVLW  3A
175BE:  BTFSS  F9E.4
175C0:  BRA    175BE
175C2:  MOVWF  FAD
175C4:  CLRF   1B
175C6:  BTFSC  FF2.7
175C8:  BSF    1B.7
175CA:  BCF    FF2.7
175CC:  MOVFF  731,A18
175D0:  MOVLW  01
175D2:  MOVLB  A
175D4:  MOVWF  x19
175D6:  MOVLB  0
175D8:  CALL   0F92
175DC:  BTFSC  1B.7
175DE:  BSF    FF2.7
175E0:  MOVLW  3A
175E2:  BTFSS  F9E.4
175E4:  BRA    175E2
175E6:  MOVWF  FAD
175E8:  CLRF   1B
175EA:  BTFSC  FF2.7
175EC:  BSF    1B.7
175EE:  BCF    FF2.7
175F0:  MOVFF  730,A18
175F4:  MOVLW  01
175F6:  MOVLB  A
175F8:  MOVWF  x19
175FA:  MOVLB  0
175FC:  CALL   0F92
17600:  BTFSC  1B.7
17602:  BSF    FF2.7
17604:  MOVLW  0A
17606:  BTFSS  F9E.4
17608:  BRA    17606
1760A:  MOVWF  FAD
1760C:  MOVLW  0D
1760E:  BTFSS  F9E.4
17610:  BRA    1760E
17612:  MOVWF  FAD
17614:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
17616:  MOVLB  8
17618:  MOVF   x72,W
1761A:  SUBLW  02
1761C:  BNZ   17624
1761E:  MOVLB  0
17620:  BRA    1725C
17622:  MOVLB  8
....................  
....................    } 
17624:  BRA    1762E
....................    else cmd_arg(); 
17626:  MOVLB  0
17628:  CALL   AF70
1762C:  MOVLB  8
....................     
....................    return time_error; 
1762E:  MOVFF  872,01
17632:  MOVLB  0
17634:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
17674:  RCALL  1727C
17676:  MOVFF  01,862
....................     
....................    if (time_error ==0 ){ 
1767A:  MOVLB  8
1767C:  MOVF   x62,F
1767E:  BTFSS  FD8.2
17680:  BRA    177B8
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
17682:  BCF    FC6.5
17684:  MOVLW  21
17686:  MOVWF  FC6
17688:  MOVLW  40
1768A:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
1768C:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
1768E:  MOVF   FC9,W
17690:  MOVLW  86
17692:  MOVWF  FC9
17694:  RRCF   FC7,W
17696:  BNC   17694
17698:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
1769C:  MOVFF  734,864
176A0:  MOVLB  0
176A2:  RCALL  17636
176A4:  MOVFF  01,864
176A8:  MOVF   FC9,W
176AA:  MOVFF  01,FC9
176AE:  RRCF   FC7,W
176B0:  BNC   176AE
176B2:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
176B6:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
176B8:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
176BA:  MOVF   FC9,W
176BC:  MOVLW  85
176BE:  MOVWF  FC9
176C0:  RRCF   FC7,W
176C2:  BNC   176C0
176C4:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
176C8:  MOVFF  733,864
176CC:  RCALL  17636
176CE:  MOVFF  01,864
176D2:  MOVF   FC9,W
176D4:  MOVFF  01,FC9
176D8:  RRCF   FC7,W
176DA:  BNC   176D8
176DC:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
176E0:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
176E2:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
176E4:  MOVF   FC9,W
176E6:  MOVLW  87
176E8:  MOVWF  FC9
176EA:  RRCF   FC7,W
176EC:  BNC   176EA
176EE:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
176F2:  MOVFF  735,864
176F6:  RCALL  17636
176F8:  MOVFF  01,864
176FC:  MOVF   FC9,W
176FE:  MOVFF  01,FC9
17702:  RRCF   FC7,W
17704:  BNC   17702
17706:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
1770A:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
1770C:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
1770E:  MOVF   FC9,W
17710:  MOVLW  83
17712:  MOVWF  FC9
17714:  RRCF   FC7,W
17716:  BNC   17714
17718:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
1771C:  MOVFF  732,864
17720:  RCALL  17636
17722:  MOVFF  01,864
17726:  MOVF   FC9,W
17728:  MOVFF  01,FC9
1772C:  RRCF   FC7,W
1772E:  BNC   1772C
17730:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
17734:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17736:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
17738:  MOVF   FC9,W
1773A:  MOVLW  82
1773C:  MOVWF  FC9
1773E:  RRCF   FC7,W
17740:  BNC   1773E
17742:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
17746:  MOVFF  731,864
1774A:  RCALL  17636
1774C:  MOVFF  01,864
17750:  MOVF   FC9,W
17752:  MOVFF  01,FC9
17756:  RRCF   FC7,W
17758:  BNC   17756
1775A:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
1775E:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17760:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
17762:  MOVF   FC9,W
17764:  MOVLW  81
17766:  MOVWF  FC9
17768:  RRCF   FC7,W
1776A:  BNC   17768
1776C:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
17770:  MOVFF  730,864
17774:  RCALL  17636
17776:  MOVFF  01,864
1777A:  MOVF   FC9,W
1777C:  MOVFF  01,FC9
17780:  RRCF   FC7,W
17782:  BNC   17780
17784:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
17788:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
1778A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
1778C:  MOVF   FC9,W
1778E:  MOVLW  80
17790:  MOVWF  FC9
17792:  RRCF   FC7,W
17794:  BNC   17792
17796:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
1779A:  MOVLB  8
1779C:  CLRF   x64
1779E:  MOVLB  0
177A0:  RCALL  17636
177A2:  MOVFF  01,864
177A6:  MOVF   FC9,W
177A8:  MOVFF  01,FC9
177AC:  RRCF   FC7,W
177AE:  BNC   177AC
177B0:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
177B4:  BSF    F91.0
177B6:  MOVLB  8
....................    } 
177B8:  MOVLB  0
177BA:  GOTO   17846 (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
1833E:  CALL   E116
....................     
....................    time_error = get_time(); 
18342:  CALL   1727C
18346:  MOVFF  01,862
....................     
....................    if (time_error == 0 ){ 
1834A:  MOVLB  8
1834C:  MOVF   x62,F
1834E:  BTFSS  FD8.2
18350:  BRA    18486
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
18352:  MOVFF  735,729
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
18356:  MOVLW  04
18358:  MOVWF  x66
1835A:  MOVFF  729,867
1835E:  MOVLB  0
18360:  CALL   339A
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
18364:  MOVFF  734,864
18368:  CALL   17636
1836C:  MOVFF  01,734
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
18370:  MOVLB  7
18372:  BSF    x34.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
18374:  BCF    FC6.5
18376:  MOVLW  21
18378:  MOVWF  FC6
1837A:  MOVLW  40
1837C:  MOVWF  FC7
....................       delay_us(10); 
1837E:  MOVLW  35
18380:  MOVWF  00
18382:  DECFSZ 00,F
18384:  BRA    18382
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
18386:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
18388:  MOVF   FC9,W
1838A:  MOVLW  8E
1838C:  MOVWF  FC9
1838E:  RRCF   FC7,W
18390:  BNC   1838E
18392:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
18396:  MOVFF  730,864
1839A:  MOVLB  0
1839C:  CALL   17636
183A0:  MOVFF  01,864
183A4:  MOVF   FC9,W
183A6:  MOVFF  01,FC9
183AA:  RRCF   FC7,W
183AC:  BNC   183AA
183AE:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
183B2:  BSF    F91.0
....................       delay_us(1);            // Delays added 1.020A 
183B4:  MOVLW  05
183B6:  MOVWF  00
183B8:  DECFSZ 00,F
183BA:  BRA    183B8
....................        
....................       output_bit(RTC_CS, ENABLE); 
183BC:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
183BE:  MOVF   FC9,W
183C0:  MOVLW  8D
183C2:  MOVWF  FC9
183C4:  RRCF   FC7,W
183C6:  BNC   183C4
183C8:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
183CC:  MOVFF  731,864
183D0:  CALL   17636
183D4:  MOVFF  01,864
183D8:  MOVF   FC9,W
183DA:  MOVFF  01,FC9
183DE:  RRCF   FC7,W
183E0:  BNC   183DE
183E2:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
183E6:  BSF    F91.0
....................       delay_us(1); 
183E8:  MOVLW  05
183EA:  MOVWF  00
183EC:  DECFSZ 00,F
183EE:  BRA    183EC
....................        
....................       output_bit(RTC_CS, ENABLE); 
183F0:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
183F2:  MOVF   FC9,W
183F4:  MOVLW  8C
183F6:  MOVWF  FC9
183F8:  RRCF   FC7,W
183FA:  BNC   183F8
183FC:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
18400:  MOVFF  732,864
18404:  CALL   17636
18408:  MOVFF  01,864
1840C:  MOVF   FC9,W
1840E:  MOVFF  01,FC9
18412:  RRCF   FC7,W
18414:  BNC   18412
18416:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
1841A:  BSF    F91.0
....................       delay_us(1);    
1841C:  MOVLW  05
1841E:  MOVWF  00
18420:  DECFSZ 00,F
18422:  BRA    18420
....................        
....................       output_bit(RTC_CS, ENABLE); 
18424:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
18426:  MOVF   FC9,W
18428:  MOVLW  8B
1842A:  MOVWF  FC9
1842C:  RRCF   FC7,W
1842E:  BNC   1842C
18430:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
18434:  MOVFF  733,864
18438:  CALL   17636
1843C:  MOVFF  01,864
18440:  MOVF   FC9,W
18442:  MOVFF  01,FC9
18446:  RRCF   FC7,W
18448:  BNC   18446
1844A:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE);  
1844E:  BSF    F91.0
....................       delay_us(1); 
18450:  MOVLW  05
18452:  MOVWF  00
18454:  DECFSZ 00,F
18456:  BRA    18454
....................        
....................       output_bit(RTC_CS, ENABLE); 
18458:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8A);        // address - Month 
1845A:  MOVF   FC9,W
1845C:  MOVLW  8A
1845E:  MOVWF  FC9
18460:  RRCF   FC7,W
18462:  BNC   18460
18464:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
18468:  MOVF   FC9,W
1846A:  MOVFF  734,FC9
1846E:  RRCF   FC7,W
18470:  BNC   1846E
18472:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
18476:  BSF    F91.0
....................       delay_us(1); 
18478:  MOVLW  05
1847A:  MOVWF  00
1847C:  DECFSZ 00,F
1847E:  BRA    1847C
....................     
....................    RTC_read_alarm(); 
18480:  CALL   E116
18484:  MOVLB  8
....................    } 
18486:  MOVLB  0
18488:  GOTO   1849E (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
15A18:  BCF    FC6.5
15A1A:  MOVLW  21
15A1C:  MOVWF  FC6
15A1E:  MOVLW  40
15A20:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
15A22:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
15A24:  MOVF   FC9,W
15A26:  MOVLW  8E
15A28:  MOVWF  FC9
15A2A:  RRCF   FC7,W
15A2C:  BNC   15A2A
15A2E:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(0b00000000);  // data 
15A32:  MOVF   FC9,W
15A34:  CLRF   FC9
15A36:  RRCF   FC7,W
15A38:  BNC   15A36
15A3A:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE); 
15A3E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A40:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15A42:  MOVF   FC9,W
15A44:  MOVLW  8D
15A46:  MOVWF  FC9
15A48:  RRCF   FC7,W
15A4A:  BNC   15A48
15A4C:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(0b10000000);  // data 
15A50:  MOVF   FC9,W
15A52:  MOVLW  80
15A54:  MOVWF  FC9
15A56:  RRCF   FC7,W
15A58:  BNC   15A56
15A5A:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE); 
15A5E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A60:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15A62:  MOVF   FC9,W
15A64:  MOVLW  8C
15A66:  MOVWF  FC9
15A68:  RRCF   FC7,W
15A6A:  BNC   15A68
15A6C:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(0b10000000);  // data 
15A70:  MOVF   FC9,W
15A72:  MOVLW  80
15A74:  MOVWF  FC9
15A76:  RRCF   FC7,W
15A78:  BNC   15A76
15A7A:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE); 
15A7E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A80:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15A82:  MOVF   FC9,W
15A84:  MOVLW  8B
15A86:  MOVWF  FC9
15A88:  RRCF   FC7,W
15A8A:  BNC   15A88
15A8C:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(0b11000000);  // data 
15A90:  MOVF   FC9,W
15A92:  MOVLW  C0
15A94:  MOVWF  FC9
15A96:  RRCF   FC7,W
15A98:  BNC   15A96
15A9A:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE);    
15A9E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15AA0:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15AA2:  MOVF   FC9,W
15AA4:  MOVLW  8A
15AA6:  MOVWF  FC9
15AA8:  RRCF   FC7,W
15AAA:  BNC   15AA8
15AAC:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(0b10000000);  // data 
15AB0:  MOVF   FC9,W
15AB2:  MOVLW  80
15AB4:  MOVWF  FC9
15AB6:  RRCF   FC7,W
15AB8:  BNC   15AB6
15ABA:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE); 
15ABE:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15AC0:  CALL   E116
15AC4:  GOTO   16884 (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
15266:  MOVLB  8
15268:  CLRF   x64
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
1526A:  BCF    FC6.5
1526C:  MOVLW  21
1526E:  MOVWF  FC6
15270:  MOVLW  40
15272:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15274:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
15276:  MOVF   FC9,W
15278:  MOVLW  0A
1527A:  MOVWF  FC9
1527C:  RRCF   FC7,W
1527E:  BNC   1527C
15280:  MOVFF  FC9,864
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
15284:  MOVF   FC9,W
15286:  MOVFF  864,FC9
1528A:  RRCF   FC7,W
1528C:  BNC   1528A
1528E:  MOVFF  FC9,72A
....................    output_bit(RTC_CS, DISABLE); 
15292:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
15294:  MOVLB  7
15296:  BSF    x2A.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15298:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
1529A:  MOVF   FC9,W
1529C:  MOVLW  8A
1529E:  MOVWF  FC9
152A0:  RRCF   FC7,W
152A2:  BNC   152A0
152A4:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
152A8:  MOVF   FC9,W
152AA:  MOVFF  72A,FC9
152AE:  RRCF   FC7,W
152B0:  BNC   152AE
152B2:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE); 
152B6:  BSF    F91.0
152B8:  MOVLB  0
152BA:  GOTO   167AE (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
033CA:  MOVFF  721,73B
....................    rtc_last_min   = RTC_Min_Reg; 
033CE:  MOVFF  722,73A
....................    rtc_last_hour  = RTC_Hr_Reg; 
033D2:  MOVFF  723,739
....................    rtc_last_day   = RTC_DOM_Reg; 
033D6:  MOVFF  725,737
....................    rtc_last_month = RTC_Mon_Reg; 
033DA:  MOVFF  726,736
....................    rtc_last_year  = RTC_Yr_Reg; 
033DE:  MOVFF  727,738
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
033E2:  MOVLW  06
033E4:  MOVLB  8
033E6:  MOVWF  x66
033E8:  MOVFF  736,867
033EC:  MOVLB  0
033EE:  RCALL  339A
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
033F0:  MOVLW  08
033F2:  MOVLB  8
033F4:  MOVWF  x66
033F6:  MOVFF  737,867
033FA:  MOVLB  0
033FC:  RCALL  339A
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
033FE:  MOVLW  0A
03400:  MOVLB  8
03402:  MOVWF  x66
03404:  MOVFF  738,867
03408:  MOVLB  0
0340A:  RCALL  339A
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
0340C:  MOVLW  0C
0340E:  MOVLB  8
03410:  MOVWF  x66
03412:  MOVFF  739,867
03416:  MOVLB  0
03418:  RCALL  339A
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
0341A:  MOVLW  0E
0341C:  MOVLB  8
0341E:  MOVWF  x66
03420:  MOVFF  73A,867
03424:  MOVLB  0
03426:  RCALL  339A
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
03428:  MOVLW  10
0342A:  MOVLB  8
0342C:  MOVWF  x66
0342E:  MOVFF  73B,867
03432:  MOVLB  0
03434:  RCALL  339A
03436:  GOTO   1B202 (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
152BE:  MOVLB  8
152C0:  CLRF   x67
152C2:  CLRF   x66
152C4:  CLRF   x65
152C6:  CLRF   x64
152C8:  CLRF   x6B
152CA:  CLRF   x6A
152CC:  CLRF   x69
152CE:  CLRF   x68
152D0:  CLRF   x6F
152D2:  CLRF   x6E
152D4:  CLRF   x6D
152D6:  CLRF   x6C
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
152D8:  CLRF   x7C
152DA:  CLRF   x7D
152DC:  MOVLW  1F
152DE:  MOVWF  x7E
152E0:  CLRF   x7F
152E2:  MOVLW  3B
152E4:  MOVWF  x80
152E6:  CLRF   x81
152E8:  MOVLW  5A
152EA:  MOVWF  x82
152EC:  CLRF   x83
152EE:  MOVLW  78
152F0:  MOVWF  x84
152F2:  CLRF   x85
152F4:  MOVLW  97
152F6:  MOVWF  x86
152F8:  CLRF   x87
152FA:  MOVLW  B5
152FC:  MOVWF  x88
152FE:  CLRF   x89
15300:  MOVLW  D4
15302:  MOVWF  x8A
15304:  CLRF   x8B
15306:  MOVLW  F3
15308:  MOVWF  x8C
1530A:  CLRF   x8D
1530C:  MOVLW  11
1530E:  MOVWF  x8E
15310:  MOVLW  01
15312:  MOVWF  x8F
15314:  MOVLW  30
15316:  MOVWF  x90
15318:  MOVLW  01
1531A:  MOVWF  x91
1531C:  MOVLW  4E
1531E:  MOVWF  x92
15320:  MOVLW  01
15322:  MOVWF  x93
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
15324:  BCF    49.3
....................     
....................    RTC_read(); 
15326:  MOVLB  0
15328:  CALL   32CC
....................    RTC_read_alarm(); 
1532C:  CALL   E116
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
15330:  MOVLW  04
15332:  MOVLB  8
15334:  MOVWF  x94
15336:  MOVLB  0
15338:  CALL   29AC
1533C:  MOVFF  01,729
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
15340:  MOVLB  7
15342:  MOVF   x27,W
15344:  SUBWF  x29,W
15346:  BC    1534C
15348:  BSF    49.3
1534A:  BRA    15774
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
1534C:  MOVF   x29,W
1534E:  SUBWF  x27,W
15350:  BTFSS  FD8.2
15352:  BRA    15774
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
15354:  MOVLW  01
15356:  SUBWF  x26,W
15358:  MOVWF  00
1535A:  BCF    FD8.0
1535C:  RLCF   00,F
1535E:  MOVF   00,W
15360:  CLRF   03
15362:  ADDLW  7C
15364:  MOVWF  FE9
15366:  MOVLW  08
15368:  ADDWFC 03,W
1536A:  MOVWF  FEA
1536C:  MOVFF  FEC,03
15370:  MOVF   FED,F
15372:  MOVFF  FEF,8F4
15376:  MOVFF  03,8F5
1537A:  MOVLB  0
1537C:  CALL   C624
15380:  MOVFF  03,867
15384:  MOVFF  02,866
15388:  MOVFF  01,865
1538C:  MOVFF  00,864
....................          time_now = time_now + RTC_DOM_Reg; 
15390:  MOVLB  8
15392:  CLRF   xF5
15394:  MOVFF  725,8F4
15398:  MOVLB  0
1539A:  CALL   C624
1539E:  BCF    FD8.1
153A0:  MOVFF  867,8F7
153A4:  MOVFF  866,8F6
153A8:  MOVFF  865,8F5
153AC:  MOVFF  864,8F4
153B0:  MOVFF  03,8FB
153B4:  MOVFF  02,8FA
153B8:  MOVFF  01,8F9
153BC:  MOVFF  00,8F8
153C0:  CALL   C02C
153C4:  MOVFF  03,867
153C8:  MOVFF  02,866
153CC:  MOVFF  01,865
153D0:  MOVFF  00,864
....................           
....................          hour = RTC_Hr_Reg; 
153D4:  MOVLB  8
153D6:  CLRF   xF5
153D8:  MOVFF  723,8F4
153DC:  MOVLB  0
153DE:  CALL   C624
153E2:  MOVFF  03,873
153E6:  MOVFF  02,872
153EA:  MOVFF  01,871
153EE:  MOVFF  00,870
....................          minute = RTC_Min_Reg; 
153F2:  MOVLB  8
153F4:  CLRF   xF5
153F6:  MOVFF  722,8F4
153FA:  MOVLB  0
153FC:  CALL   C624
15400:  MOVFF  03,877
15404:  MOVFF  02,876
15408:  MOVFF  01,875
1540C:  MOVFF  00,874
....................          second = RTC_Sec_Reg; 
15410:  MOVLB  8
15412:  CLRF   xF5
15414:  MOVFF  721,8F4
15418:  MOVLB  0
1541A:  CALL   C624
1541E:  MOVFF  03,87B
15422:  MOVFF  02,87A
15426:  MOVFF  01,879
1542A:  MOVFF  00,878
....................           
....................          fraction_of_day = (hour / 24); 
1542E:  MOVFF  873,8DB
15432:  MOVFF  872,8DA
15436:  MOVFF  871,8D9
1543A:  MOVFF  870,8D8
1543E:  MOVLB  8
15440:  CLRF   xDF
15442:  CLRF   xDE
15444:  MOVLW  40
15446:  MOVWF  xDD
15448:  MOVLW  83
1544A:  MOVWF  xDC
1544C:  MOVLB  0
1544E:  CALL   C65A
15452:  MOVFF  03,86F
15456:  MOVFF  02,86E
1545A:  MOVFF  01,86D
1545E:  MOVFF  00,86C
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15462:  MOVFF  877,8DB
15466:  MOVFF  876,8DA
1546A:  MOVFF  875,8D9
1546E:  MOVFF  874,8D8
15472:  MOVLB  8
15474:  CLRF   xDF
15476:  CLRF   xDE
15478:  MOVLW  34
1547A:  MOVWF  xDD
1547C:  MOVLW  89
1547E:  MOVWF  xDC
15480:  MOVLB  0
15482:  CALL   C65A
15486:  BCF    FD8.1
15488:  MOVFF  86F,8F7
1548C:  MOVFF  86E,8F6
15490:  MOVFF  86D,8F5
15494:  MOVFF  86C,8F4
15498:  MOVFF  03,8FB
1549C:  MOVFF  02,8FA
154A0:  MOVFF  01,8F9
154A4:  MOVFF  00,8F8
154A8:  CALL   C02C
154AC:  MOVFF  03,86F
154B0:  MOVFF  02,86E
154B4:  MOVFF  01,86D
154B8:  MOVFF  00,86C
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
154BC:  MOVFF  87B,8DB
154C0:  MOVFF  87A,8DA
154C4:  MOVFF  879,8D9
154C8:  MOVFF  878,8D8
154CC:  MOVLB  8
154CE:  CLRF   xDF
154D0:  MOVLW  C0
154D2:  MOVWF  xDE
154D4:  MOVLW  28
154D6:  MOVWF  xDD
154D8:  MOVLW  8F
154DA:  MOVWF  xDC
154DC:  MOVLB  0
154DE:  CALL   C65A
154E2:  BCF    FD8.1
154E4:  MOVFF  86F,8F7
154E8:  MOVFF  86E,8F6
154EC:  MOVFF  86D,8F5
154F0:  MOVFF  86C,8F4
154F4:  MOVFF  03,8FB
154F8:  MOVFF  02,8FA
154FC:  MOVFF  01,8F9
15500:  MOVFF  00,8F8
15504:  CALL   C02C
15508:  MOVFF  03,86F
1550C:  MOVFF  02,86E
15510:  MOVFF  01,86D
15514:  MOVFF  00,86C
....................           
....................          time_now = time_now + fraction_of_day; 
15518:  BCF    FD8.1
1551A:  MOVFF  867,8F7
1551E:  MOVFF  866,8F6
15522:  MOVFF  865,8F5
15526:  MOVFF  864,8F4
1552A:  MOVFF  86F,8FB
1552E:  MOVFF  86E,8FA
15532:  MOVFF  86D,8F9
15536:  MOVFF  86C,8F8
1553A:  CALL   C02C
1553E:  MOVFF  03,867
15542:  MOVFF  02,866
15546:  MOVFF  01,865
1554A:  MOVFF  00,864
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
1554E:  MOVLB  8
15550:  CLRF   xF5
15552:  MOVFF  72C,8F4
15556:  MOVLB  0
15558:  CALL   C624
1555C:  MOVFF  03,873
15560:  MOVFF  02,872
15564:  MOVFF  01,871
15568:  MOVFF  00,870
....................          minute = RTC_Al_Min_Reg; 
1556C:  MOVLB  8
1556E:  CLRF   xF5
15570:  MOVFF  72D,8F4
15574:  MOVLB  0
15576:  CALL   C624
1557A:  MOVFF  03,877
1557E:  MOVFF  02,876
15582:  MOVFF  01,875
15586:  MOVFF  00,874
....................          second = RTC_Al_Sec_Reg; 
1558A:  MOVLB  8
1558C:  CLRF   xF5
1558E:  MOVFF  72E,8F4
15592:  MOVLB  0
15594:  CALL   C624
15598:  MOVFF  03,87B
1559C:  MOVFF  02,87A
155A0:  MOVFF  01,879
155A4:  MOVFF  00,878
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
155A8:  MOVLW  01
155AA:  MOVLB  7
155AC:  SUBWF  x2A,W
155AE:  MOVWF  00
155B0:  BCF    FD8.0
155B2:  RLCF   00,F
155B4:  MOVF   00,W
155B6:  CLRF   03
155B8:  ADDLW  7C
155BA:  MOVWF  FE9
155BC:  MOVLW  08
155BE:  ADDWFC 03,W
155C0:  MOVWF  FEA
155C2:  MOVFF  FEC,03
155C6:  MOVF   FED,F
155C8:  MOVFF  FEF,8F4
155CC:  MOVFF  03,8F5
155D0:  MOVLB  0
155D2:  CALL   C624
155D6:  MOVFF  03,86B
155DA:  MOVFF  02,86A
155DE:  MOVFF  01,869
155E2:  MOVFF  00,868
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
155E6:  MOVLB  8
155E8:  CLRF   xF5
155EA:  MOVFF  72B,8F4
155EE:  MOVLB  0
155F0:  CALL   C624
155F4:  BCF    FD8.1
155F6:  MOVFF  86B,8F7
155FA:  MOVFF  86A,8F6
155FE:  MOVFF  869,8F5
15602:  MOVFF  868,8F4
15606:  MOVFF  03,8FB
1560A:  MOVFF  02,8FA
1560E:  MOVFF  01,8F9
15612:  MOVFF  00,8F8
15616:  CALL   C02C
1561A:  MOVFF  03,86B
1561E:  MOVFF  02,86A
15622:  MOVFF  01,869
15626:  MOVFF  00,868
....................           
....................          fraction_of_day = (hour / 24); 
1562A:  MOVFF  873,8DB
1562E:  MOVFF  872,8DA
15632:  MOVFF  871,8D9
15636:  MOVFF  870,8D8
1563A:  MOVLB  8
1563C:  CLRF   xDF
1563E:  CLRF   xDE
15640:  MOVLW  40
15642:  MOVWF  xDD
15644:  MOVLW  83
15646:  MOVWF  xDC
15648:  MOVLB  0
1564A:  CALL   C65A
1564E:  MOVFF  03,86F
15652:  MOVFF  02,86E
15656:  MOVFF  01,86D
1565A:  MOVFF  00,86C
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
1565E:  MOVFF  877,8DB
15662:  MOVFF  876,8DA
15666:  MOVFF  875,8D9
1566A:  MOVFF  874,8D8
1566E:  MOVLB  8
15670:  CLRF   xDF
15672:  CLRF   xDE
15674:  MOVLW  34
15676:  MOVWF  xDD
15678:  MOVLW  89
1567A:  MOVWF  xDC
1567C:  MOVLB  0
1567E:  CALL   C65A
15682:  BCF    FD8.1
15684:  MOVFF  86F,8F7
15688:  MOVFF  86E,8F6
1568C:  MOVFF  86D,8F5
15690:  MOVFF  86C,8F4
15694:  MOVFF  03,8FB
15698:  MOVFF  02,8FA
1569C:  MOVFF  01,8F9
156A0:  MOVFF  00,8F8
156A4:  CALL   C02C
156A8:  MOVFF  03,86F
156AC:  MOVFF  02,86E
156B0:  MOVFF  01,86D
156B4:  MOVFF  00,86C
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
156B8:  MOVFF  87B,8DB
156BC:  MOVFF  87A,8DA
156C0:  MOVFF  879,8D9
156C4:  MOVFF  878,8D8
156C8:  MOVLB  8
156CA:  CLRF   xDF
156CC:  MOVLW  C0
156CE:  MOVWF  xDE
156D0:  MOVLW  28
156D2:  MOVWF  xDD
156D4:  MOVLW  8F
156D6:  MOVWF  xDC
156D8:  MOVLB  0
156DA:  CALL   C65A
156DE:  BCF    FD8.1
156E0:  MOVFF  86F,8F7
156E4:  MOVFF  86E,8F6
156E8:  MOVFF  86D,8F5
156EC:  MOVFF  86C,8F4
156F0:  MOVFF  03,8FB
156F4:  MOVFF  02,8FA
156F8:  MOVFF  01,8F9
156FC:  MOVFF  00,8F8
15700:  CALL   C02C
15704:  MOVFF  03,86F
15708:  MOVFF  02,86E
1570C:  MOVFF  01,86D
15710:  MOVFF  00,86C
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
15714:  BCF    FD8.1
15716:  MOVFF  86B,8F7
1571A:  MOVFF  86A,8F6
1571E:  MOVFF  869,8F5
15722:  MOVFF  868,8F4
15726:  MOVFF  86F,8FB
1572A:  MOVFF  86E,8FA
1572E:  MOVFF  86D,8F9
15732:  MOVFF  86C,8F8
15736:  CALL   C02C
1573A:  MOVFF  03,86B
1573E:  MOVFF  02,86A
15742:  MOVFF  01,869
15746:  MOVFF  00,868
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
1574A:  MOVFF  86B,8F3
1574E:  MOVFF  86A,8F2
15752:  MOVFF  869,8F1
15756:  MOVFF  868,8F0
1575A:  MOVFF  867,8F7
1575E:  MOVFF  866,8F6
15762:  MOVFF  865,8F5
15766:  MOVFF  864,8F4
1576A:  CALL   10460
1576E:  BNC   15772
15770:  BSF    49.3
15772:  MOVLB  7
....................       } 
....................    } 
15774:  MOVLB  0
15776:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
15778:  BTFSS  49.3
1577A:  BRA    15798
1577C:  MOVLW  C4
1577E:  MOVWF  FF6
15780:  MOVLW  0D
15782:  MOVWF  FF7
15784:  MOVLW  00
15786:  MOVWF  FF8
15788:  CLRF   1B
1578A:  BTFSC  FF2.7
1578C:  BSF    1B.7
1578E:  BCF    FF2.7
15790:  CALL   0E3A
15794:  BTFSC  1B.7
15796:  BSF    FF2.7
15798:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F27A:  BCF    F67.5
0F27C:  MOVLW  32
0F27E:  MOVWF  F67
0F280:  MOVLW  40
0F282:  MOVWF  F68
....................     
....................    data = 0; 
0F284:  MOVLB  8
0F286:  CLRF   xB4
0F288:  CLRF   xB3
....................     
....................    DAC_MS_byte = 0; 
0F28A:  CLRF   xB5
....................    DAC_LS_byte = 0; 
0F28C:  CLRF   xB6
....................     
....................    data = setting & 0b0000111100000000; 
0F28E:  CLRF   xB3
0F290:  MOVF   xB2,W
0F292:  ANDLW  0F
0F294:  MOVWF  xB4
....................    data = data >> 8; 
0F296:  MOVFF  8B4,8B3
0F29A:  CLRF   xB4
....................    DAC_MS_byte = data; 
0F29C:  MOVFF  8B3,8B5
....................     
....................    data = setting & 0b0000000011111111; 
0F2A0:  MOVFF  8B1,8B3
0F2A4:  CLRF   xB4
....................    DAC_LS_byte = data; 
0F2A6:  MOVFF  8B3,8B6
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F2AA:  MOVLW  01
0F2AC:  SUBWF  xB0,W
0F2AE:  ADDLW  FC
0F2B0:  BC    F2DC
0F2B2:  ADDLW  04
0F2B4:  MOVLB  0
0F2B6:  GOTO   F2FA
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F2BA:  MOVLW  30
0F2BC:  MOVLB  8
0F2BE:  IORWF  xB5,F
....................          break; 
0F2C0:  BRA    F2DC
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F2C2:  MOVLW  70
0F2C4:  MOVLB  8
0F2C6:  IORWF  xB5,F
....................          break; 
0F2C8:  BRA    F2DC
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F2CA:  MOVLW  B0
0F2CC:  MOVLB  8
0F2CE:  IORWF  xB5,F
....................          break; 
0F2D0:  BRA    F2DC
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F2D2:  MOVLW  F0
0F2D4:  MOVLB  8
0F2D6:  IORWF  xB5,F
....................          break; 
0F2D8:  BRA    F2DC
0F2DA:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F2DC:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F2DE:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F2E0:  MOVF   F6A,W
0F2E2:  MOVFF  8B5,F6A
0F2E6:  RRCF   F68,W
0F2E8:  BNC   F2E6
....................    spi_write2(DAC_LS_byte); 
0F2EA:  MOVF   F6A,W
0F2EC:  MOVFF  8B6,F6A
0F2F0:  RRCF   F68,W
0F2F2:  BNC   F2F0
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F2F4:  BSF    F8C.3
0F2F6:  MOVLB  0
0F2F8:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F322:  MOVLB  8
0F324:  CLRF   xB5
0F326:  CLRF   xB6
0F328:  CLRF   xB7
0F32A:  CLRF   xB8
0F32C:  CLRF   xB9
0F32E:  CLRF   xBA
0F330:  CLRF   xBB
0F332:  CLRF   xBC
0F334:  CLRF   xBD
0F336:  CLRF   xBE
0F338:  CLRF   xBF
0F33A:  CLRF   xC0
0F33C:  CLRF   xC1
0F33E:  CLRF   xC2
0F340:  CLRF   xC3
0F342:  CLRF   xC4
0F344:  CLRF   xC5
0F346:  CLRF   xC6
0F348:  CLRF   xC7
0F34A:  CLRF   xC8
0F34C:  CLRF   xC9
0F34E:  CLRF   xCA
0F350:  CLRF   xCB
0F352:  CLRF   xCC
0F354:  CLRF   xCD
0F356:  CLRF   xCE
0F358:  CLRF   xCF
0F35A:  CLRF   xD0
0F35C:  CLRF   xD1
0F35E:  CLRF   xD2
0F360:  CLRF   xD3
0F362:  CLRF   xD4
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F364:  CLRF   xD5
0F366:  CLRF   xD6
0F368:  CLRF   xD7
0F36A:  CLRF   xD8
0F36C:  CLRF   xD9
0F36E:  CLRF   xDA
0F370:  CLRF   xDB
0F372:  CLRF   xDC
0F374:  CLRF   xDD
0F376:  CLRF   xDE
0F378:  CLRF   xDF
0F37A:  CLRF   xE0
0F37C:  CLRF   xE1
0F37E:  CLRF   xE2
0F380:  CLRF   xE3
0F382:  CLRF   xE4
0F384:  CLRF   xE5
0F386:  CLRF   xE6
0F388:  CLRF   xE7
0F38A:  CLRF   xE8
0F38C:  CLRF   xE9
0F38E:  CLRF   xEA
0F390:  CLRF   xEB
0F392:  CLRF   xEC
0F394:  CLRF   xED
0F396:  CLRF   xEE
0F398:  CLRF   xEF
0F39A:  CLRF   xF0
0F39C:  CLRF   xF1
0F39E:  CLRF   xF2
0F3A0:  CLRF   xF3
0F3A2:  CLRF   xF4
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F3A4:  CLRF   xB4
0F3A6:  MOVLW  01
0F3A8:  MOVWF  xB3
0F3AA:  MOVLW  01
0F3AC:  ADDWF  xB0,W
0F3AE:  MOVWF  01
0F3B0:  MOVLW  00
0F3B2:  ADDWFC xB1,W
0F3B4:  MOVWF  03
0F3B6:  MOVF   xB4,W
0F3B8:  SUBWF  03,W
0F3BA:  BNC   F4A0
0F3BC:  BNZ   F3C4
0F3BE:  MOVF   01,W
0F3C0:  SUBWF  xB3,W
0F3C2:  BC    F4A0
....................    { 
....................       for (n=1; n<5; ++n) 
0F3C4:  MOVLW  01
0F3C6:  MOVWF  xB2
0F3C8:  MOVF   xB2,W
0F3CA:  SUBLW  04
0F3CC:  BNC   F498
....................       { 
....................          set_adc_channel(n,VSS); 
0F3CE:  RLCF   xB2,W
0F3D0:  MOVWF  00
0F3D2:  RLCF   00,F
0F3D4:  MOVLW  FC
0F3D6:  ANDWF  00,F
0F3D8:  MOVF   FC2,W
0F3DA:  ANDLW  83
0F3DC:  IORWF  00,W
0F3DE:  MOVWF  FC2
0F3E0:  MOVLW  00
0F3E2:  MOVWF  01
0F3E4:  MOVF   FC1,W
0F3E6:  ANDLW  F8
0F3E8:  IORWF  01,W
0F3EA:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F3EC:  MOVF   xB2,W
0F3EE:  MULLW  04
0F3F0:  MOVF   FF3,W
0F3F2:  CLRF   03
0F3F4:  ADDLW  D5
0F3F6:  MOVWF  FE9
0F3F8:  MOVLW  08
0F3FA:  ADDWFC 03,W
0F3FC:  MOVWF  FEA
0F3FE:  BSF    FC2.1
0F400:  BTFSC  FC2.1
0F402:  BRA    F400
0F404:  MOVFF  FC3,FEF
0F408:  MOVFF  FC4,FEC
0F40C:  CLRF   FEC
0F40E:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F410:  MOVF   xB2,W
0F412:  MULLW  04
0F414:  MOVF   FF3,W
0F416:  CLRF   03
0F418:  ADDLW  B5
0F41A:  MOVWF  01
0F41C:  MOVLW  08
0F41E:  ADDWFC 03,F
0F420:  MOVFF  01,8F5
0F424:  MOVFF  03,8F6
0F428:  MOVF   xB2,W
0F42A:  MULLW  04
0F42C:  MOVF   FF3,W
0F42E:  CLRF   03
0F430:  ADDLW  B5
0F432:  MOVWF  FE9
0F434:  MOVLW  08
0F436:  ADDWFC 03,W
0F438:  MOVWF  FEA
0F43A:  MOVFF  FEF,8F7
0F43E:  MOVFF  FEC,8F8
0F442:  MOVFF  FEC,8F9
0F446:  MOVFF  FEC,8FA
0F44A:  MOVF   xB2,W
0F44C:  MULLW  04
0F44E:  MOVF   FF3,W
0F450:  CLRF   03
0F452:  ADDLW  D5
0F454:  MOVWF  FE9
0F456:  MOVLW  08
0F458:  ADDWFC 03,W
0F45A:  MOVWF  FEA
0F45C:  MOVFF  FEF,00
0F460:  MOVFF  FEC,01
0F464:  MOVFF  FEC,02
0F468:  MOVFF  FEC,03
0F46C:  MOVF   xF7,W
0F46E:  ADDWF  00,F
0F470:  MOVF   xF8,W
0F472:  ADDWFC 01,F
0F474:  MOVF   xF9,W
0F476:  ADDWFC 02,F
0F478:  MOVF   xFA,W
0F47A:  ADDWFC 03,F
0F47C:  MOVFF  8F6,FEA
0F480:  MOVFF  8F5,FE9
0F484:  MOVFF  00,FEF
0F488:  MOVFF  01,FEC
0F48C:  MOVFF  02,FEC
0F490:  MOVFF  03,FEC
0F494:  INCF   xB2,F
0F496:  BRA    F3C8
....................       } 
0F498:  INCF   xB3,F
0F49A:  BTFSC  FD8.2
0F49C:  INCF   xB4,F
0F49E:  BRA    F3AA
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F4A0:  MOVLW  01
0F4A2:  MOVWF  xB2
0F4A4:  MOVF   xB2,W
0F4A6:  SUBLW  04
0F4A8:  BNC   F51A
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F4AA:  BCF    FD8.0
0F4AC:  RLCF   xB2,W
0F4AE:  CLRF   03
0F4B0:  ADDLW  A1
0F4B2:  MOVWF  01
0F4B4:  MOVLW  04
0F4B6:  ADDWFC 03,F
0F4B8:  MOVFF  01,8F5
0F4BC:  MOVFF  03,8F6
0F4C0:  MOVF   xB2,W
0F4C2:  MULLW  04
0F4C4:  MOVF   FF3,W
0F4C6:  CLRF   03
0F4C8:  ADDLW  B5
0F4CA:  MOVWF  FE9
0F4CC:  MOVLW  08
0F4CE:  ADDWFC 03,W
0F4D0:  MOVWF  FEA
0F4D2:  MOVFF  FEF,A24
0F4D6:  MOVFF  FEC,A25
0F4DA:  MOVFF  FEC,A26
0F4DE:  MOVFF  FEC,A27
0F4E2:  BCF    FD8.1
0F4E4:  CLRF   1B
0F4E6:  BTFSC  FF2.7
0F4E8:  BSF    1B.7
0F4EA:  BCF    FF2.7
0F4EC:  MOVLB  A
0F4EE:  CLRF   x2B
0F4F0:  CLRF   x2A
0F4F2:  MOVFF  8B1,A29
0F4F6:  MOVFF  8B0,A28
0F4FA:  MOVLB  0
0F4FC:  CALL   1042
0F500:  BTFSC  1B.7
0F502:  BSF    FF2.7
0F504:  MOVFF  8F6,FEA
0F508:  MOVFF  8F5,FE9
0F50C:  MOVFF  00,FEF
0F510:  MOVFF  01,FEC
0F514:  MOVLB  8
0F516:  INCF   xB2,F
0F518:  BRA    F4A4
....................    } 
0F51A:  MOVLB  0
0F51C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    //Service watchdog 
....................    output_bit(PIN_J7,(!input(PIN_J7))); 
*
00E00:  BTFSS  F88.7
00E02:  BRA    0E08
00E04:  BCF    F91.7
00E06:  BRA    0E0A
00E08:  BSF    F91.7
....................     
....................    rtc_alarm = TRUE; 
00E0A:  BSF    49.0
....................    sleep_mode = FALSE; 
00E0C:  BCF    49.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E0E:  BTFSS  49.2
00E10:  BRA    0E14
....................    { 
....................       ; 
00E12:  BRA    0E0E
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E14:  BSF    49.2
....................    RTC_read_flags(); 
00E16:  RCALL  0DCC
....................    ++nv_elapsed; 
00E18:  INCF   35,F
00E1A:  BTFSC  FD8.2
00E1C:  INCF   36,F
.................... } 
....................  
00E1E:  BCF    FF2.1
00E20:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E64:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E66:  BTFSC  49.1
00E68:  BRA    0EBA
....................    { 
....................       if (kbhit(COM_A)) 
00E6A:  BTFSS  F9E.5
00E6C:  BRA    0EB8
....................       { 
....................          c = getc(COM_A); 
00E6E:  RCALL  0E24
00E70:  MOVFF  01,A0F
....................          switch (c) 
00E74:  MOVLB  A
00E76:  MOVF   x0F,W
00E78:  XORLW  3F
00E7A:  MOVLB  0
00E7C:  BZ    0E88
00E7E:  XORLW  2E
00E80:  BZ    0EAC
00E82:  XORLW  0A
00E84:  BZ    0EB2
00E86:  BRA    0EB8
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00E88:  DECFSZ 4A,W
00E8A:  BRA    0E9C
00E8C:  MOVLW  C4
00E8E:  MOVWF  FF6
00E90:  MOVLW  0E
00E92:  MOVWF  FF7
00E94:  MOVLW  00
00E96:  MOVWF  FF8
00E98:  RCALL  0E3A
00E9A:  BRA    0EAA
....................                else fprintf(COM_A, "@RDY\r\n"); 
00E9C:  MOVLW  CC
00E9E:  MOVWF  FF6
00EA0:  MOVLW  0E
00EA2:  MOVWF  FF7
00EA4:  MOVLW  00
00EA6:  MOVWF  FF8
00EA8:  RCALL  0E3A
....................                break; 
00EAA:  BRA    0EB8
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EAC:  MOVLW  01
00EAE:  MOVWF  4C
....................                break;          
00EB0:  BRA    0EB8
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EB2:  CLRF   32
00EB4:  MOVLW  01
00EB6:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00EB8:  BRA    0EBE
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00EBA:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00EBC:  BCF    F9E.5
....................    } 
00EBE:  BCF    F9E.5
00EC0:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0ADAC:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0ADAE:  MOVF   FAE,W
....................    busy_status = FALSE; 
0ADB0:  CLRF   4A
0ADB2:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
02948:  MOVLW  01
0294A:  MOVWF  4A
....................    clear_interrupt(INT_RDA); 
0294C:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
0294E:  BSF    F9D.5
02950:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00ED4:  MOVLW  0B
00ED6:  MOVWF  FD7
00ED8:  MOVLW  DC
00EDA:  MOVWF  FD6
....................    restart_wdt(); 
00EDC:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00EDE:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00EE0:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00EE2:  CLRF   FCF
00EE4:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00EE6:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00EE8:  MOVF   2F,W
00EEA:  SUBLW  02
00EEC:  BNZ   0EF4
00EEE:  MOVF   30,F
00EF0:  BNZ   0EF4
00EF2:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00EF4:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00EF6:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00EF8:  BCF    FF2.2
00EFA:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00EFE:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00F00:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00F02:  MOVF   2F,W
00F04:  SUBLW  02
00F06:  BNZ   0F0E
00F08:  MOVF   30,F
00F0A:  BNZ   0F0E
00F0C:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F0E:  BCF    F9E.0
00F10:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
1586C:  MOVLB  8
1586E:  CLRF   x69
15870:  CLRF   x6D
15872:  CLRF   x6C
15874:  CLRF   x6B
15876:  CLRF   x6A
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
15878:  MOVLW  01
1587A:  ADDWF  x6A,F
1587C:  BTFSC  FD8.0
1587E:  INCF   x6B,F
15880:  BTFSC  FD8.2
15882:  INCF   x6C,F
15884:  BTFSC  FD8.2
15886:  INCF   x6D,F
15888:  MOVF   x6D,F
1588A:  BNZ   158CC
1588C:  MOVF   x6C,W
1588E:  SUBLW  04
15890:  BNC   158CC
15892:  BNZ   158A2
15894:  MOVF   x6B,W
15896:  SUBLW  93
15898:  BNC   158CC
1589A:  BNZ   158A2
1589C:  MOVF   x6A,W
1589E:  SUBLW  DF
158A0:  BNC   158CC
....................    { 
....................       if(kbhit(COM_A)) 
158A2:  BTFSS  F9E.5
158A4:  BRA    158C2
....................       { 
....................          c = fgetc(COM_A); 
158A6:  MOVLB  0
158A8:  CALL   0E24
158AC:  MOVFF  01,869
....................          if (com_echo == TRUE) 
158B0:  DECFSZ 48,W
158B2:  BRA    158BE
....................          { 
....................             fputc(c, COM_A); 
158B4:  MOVLB  8
158B6:  MOVF   x69,W
158B8:  MOVLB  0
158BA:  CALL   ADB4
....................          } 
....................          break; 
158BE:  MOVLB  8
158C0:  BRA    158CC
....................       } 
....................  
....................       delay_us(10); 
158C2:  MOVLW  35
158C4:  MOVWF  00
158C6:  DECFSZ 00,F
158C8:  BRA    158C6
158CA:  BRA    15878
....................    } 
....................  
....................    return(c); 
158CC:  MOVFF  869,01
158D0:  MOVLB  0
158D2:  GOTO   158E2 (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AD28:  MOVLW  58
0AD2A:  MOVLB  8
0AD2C:  MOVWF  x60
0AD2E:  CLRF   x64
0AD30:  CLRF   x63
0AD32:  CLRF   x62
0AD34:  CLRF   x61
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AD36:  MOVLW  01
0AD38:  ADDWF  x61,F
0AD3A:  BTFSC  FD8.0
0AD3C:  INCF   x62,F
0AD3E:  BTFSC  FD8.2
0AD40:  INCF   x63,F
0AD42:  BTFSC  FD8.2
0AD44:  INCF   x64,F
0AD46:  MOVF   x64,F
0AD48:  BNZ   AD78
0AD4A:  MOVF   x63,F
0AD4C:  BNZ   AD78
0AD4E:  MOVF   x62,W
0AD50:  SUBLW  C3
0AD52:  BNC   AD78
0AD54:  BNZ   AD5C
0AD56:  MOVF   x61,W
0AD58:  SUBLW  4F
0AD5A:  BNC   AD78
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AD5C:  MOVLW  05
0AD5E:  MOVWF  00
0AD60:  DECFSZ 00,F
0AD62:  BRA    AD60
....................  
....................       if(kbhit()) 
0AD64:  BTFSS  F9E.5
0AD66:  BRA    AD76
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AD68:  MOVLB  0
0AD6A:  CALL   0E24
0AD6E:  MOVFF  01,860
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AD72:  MOVLB  8
0AD74:  BRA    AD78
....................       } 
0AD76:  BRA    AD36
....................    } 
....................  
....................    return(EscChar); 
0AD78:  MOVFF  860,01
0AD7C:  MOVLB  0
0AD7E:  GOTO   1B3F6 (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0D77E:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0D780:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0D782:  BSF    F8F.3
....................    delay_ms(10); 
0D784:  MOVLW  0A
0D786:  MOVLB  9
0D788:  MOVWF  xC9
0D78A:  MOVLB  0
0D78C:  CALL   2898
0D790:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0D86A:  MOVLB  8
0D86C:  CLRF   xD1
0D86E:  CLRF   xD0
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0D870:  MOVLB  F
0D872:  BTFSC  x21.1
0D874:  BRA    D882
....................       ++c; 
0D876:  MOVLB  8
0D878:  INCF   xD0,F
0D87A:  BTFSC  FD8.2
0D87C:  INCF   xD1,F
0D87E:  BRA    D870
0D880:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0D882:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0D884:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0D886:  BCF    F8F.3
0D888:  MOVLB  0
0D88A:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
0FFF6:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0FFF8:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0FFFA:  BCF    F8F.3
0FFFC:  GOTO   16B7C (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
*
16A90:  MOVLB  8
16A92:  CLRF   x62
16A94:  CLRF   x63
16A96:  CLRF   xB4
16A98:  CLRF   xB5
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16A9A:  MOVLW  14
16A9C:  MOVWF  FF6
16A9E:  MOVLW  0F
16AA0:  MOVWF  FF7
16AA2:  MOVLW  00
16AA4:  MOVWF  FF8
16AA6:  CLRF   1B
16AA8:  BTFSC  FF2.7
16AAA:  BSF    1B.7
16AAC:  BCF    FF2.7
16AAE:  MOVLB  0
16AB0:  CALL   0E3A
16AB4:  BTFSC  1B.7
16AB6:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16AB8:  MOVLB  8
16ABA:  MOVF   x63,W
16ABC:  SUBLW  04
16ABE:  BZ    16B76
....................    { 
....................        if (kbhit(COM_A)) 
16AC0:  BTFSS  F9E.5
16AC2:  BRA    16B5A
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16AC4:  MOVLB  0
16AC6:  CALL   0E24
16ACA:  MOVFF  01,862
....................           if (com_echo == TRUE) 
16ACE:  DECFSZ 48,W
16AD0:  BRA    16ADC
....................           { 
....................              fputc(charFromA, COM_A); 
16AD2:  MOVLB  8
16AD4:  MOVF   x62,W
16AD6:  MOVLB  0
16AD8:  CALL   ADB4
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16ADC:  MOVLB  8
16ADE:  MOVF   xB5,W
16AE0:  SUBLW  4F
16AE2:  BNC   16B38
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
16AE4:  MOVF   xB5,W
16AE6:  INCF   xB5,F
16AE8:  CLRF   03
16AEA:  ADDLW  64
16AEC:  MOVWF  FE9
16AEE:  MOVLW  08
16AF0:  ADDWFC 03,W
16AF2:  MOVWF  FEA
16AF4:  MOVFF  862,FEF
....................              if (CARRIAGE_RET == charFromA) 
16AF8:  MOVF   x62,W
16AFA:  SUBLW  0D
16AFC:  BNZ   16B36
....................              { 
....................                 multidrop_on(); 
16AFE:  MOVLB  0
16B00:  CALL   D77E
....................                 for (index = 0 ; index < charCount; index++) 
16B04:  MOVLB  8
16B06:  CLRF   xB4
16B08:  MOVF   xB5,W
16B0A:  SUBWF  xB4,W
16B0C:  BC    16B2C
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
16B0E:  CLRF   03
16B10:  MOVF   xB4,W
16B12:  ADDLW  64
16B14:  MOVWF  FE9
16B16:  MOVLW  08
16B18:  ADDWFC 03,W
16B1A:  MOVWF  FEA
16B1C:  MOVFF  FEF,8B6
16B20:  MOVF   xB6,W
16B22:  MOVLB  0
16B24:  BRA    16A82
16B26:  MOVLB  8
16B28:  INCF   xB4,F
16B2A:  BRA    16B08
....................                 } 
....................                 charCount = 0; 
16B2C:  CLRF   xB5
....................                 multidrop_off(); 
16B2E:  MOVLB  0
16B30:  CALL   D86A
16B34:  MOVLB  8
....................              } 
....................           } 
16B36:  BRA    16B5A
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
16B38:  MOVLW  1C
16B3A:  MOVWF  FF6
16B3C:  MOVLW  0F
16B3E:  MOVWF  FF7
16B40:  MOVLW  00
16B42:  MOVWF  FF8
16B44:  CLRF   1B
16B46:  BTFSC  FF2.7
16B48:  BSF    1B.7
16B4A:  BCF    FF2.7
16B4C:  MOVLB  0
16B4E:  CALL   0E3A
16B52:  BTFSC  1B.7
16B54:  BSF    FF2.7
....................              charCount = 0; 
16B56:  MOVLB  8
16B58:  CLRF   xB5
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
16B5A:  BTFSS  FA4.5
16B5C:  BRA    16B74
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
16B5E:  MOVLB  0
16B60:  CALL   12B16
16B64:  MOVFF  01,863
....................           fputc(charFromB, COM_A);                  // send data via USART 
16B68:  MOVLB  8
16B6A:  MOVF   x63,W
16B6C:  MOVLB  0
16B6E:  CALL   ADB4
16B72:  MOVLB  8
....................        } 
16B74:  BRA    16ABA
....................    } 
....................  
....................    multidrop_shdn(); 
16B76:  MOVLB  0
16B78:  GOTO   FFF6
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
16B7C:  MOVLW  2C
16B7E:  MOVWF  FF6
16B80:  MOVLW  0F
16B82:  MOVWF  FF7
16B84:  MOVLW  00
16B86:  MOVWF  FF8
16B88:  CLRF   1B
16B8A:  BTFSC  FF2.7
16B8C:  BSF    1B.7
16B8E:  BCF    FF2.7
16B90:  CALL   0E3A
16B94:  BTFSC  1B.7
16B96:  BSF    FF2.7
16B98:  GOTO   16BB2 (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C5A2:  MOVLB  8
0C5A4:  DECF   x7C,F
....................    len=0; 
0C5A6:  CLRF   x7D
....................    do { 
....................      c=getc(); 
0C5A8:  MOVLB  0
0C5AA:  CALL   0E24
0C5AE:  MOVFF  01,87E
....................      if(c==8) {  // Backspace 
0C5B2:  MOVLB  8
0C5B4:  MOVF   x7E,W
0C5B6:  SUBLW  08
0C5B8:  BNZ   C5DC
....................         if(len>0) { 
0C5BA:  MOVF   x7D,F
0C5BC:  BZ    C5DA
....................           len--; 
0C5BE:  DECF   x7D,F
....................           putc(c); 
0C5C0:  MOVF   x7E,W
0C5C2:  MOVLB  0
0C5C4:  CALL   ADB4
....................           putc(' '); 
0C5C8:  MOVLW  20
0C5CA:  CALL   ADB4
....................           putc(c); 
0C5CE:  MOVLB  8
0C5D0:  MOVF   x7E,W
0C5D2:  MOVLB  0
0C5D4:  CALL   ADB4
0C5D8:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C5DA:  BRA    C60A
0C5DC:  MOVF   x7E,W
0C5DE:  SUBLW  1F
0C5E0:  BC    C60A
0C5E2:  MOVF   x7E,W
0C5E4:  SUBLW  7E
0C5E6:  BNC   C60A
....................        if(len<=max) { 
0C5E8:  MOVF   x7D,W
0C5EA:  SUBWF  x7C,W
0C5EC:  BNC   C60A
....................          s[len++]=c; 
0C5EE:  MOVF   x7D,W
0C5F0:  INCF   x7D,F
0C5F2:  ADDWF  x7A,W
0C5F4:  MOVWF  FE9
0C5F6:  MOVLW  00
0C5F8:  ADDWFC x7B,W
0C5FA:  MOVWF  FEA
0C5FC:  MOVFF  87E,FEF
....................          putc(c); 
0C600:  MOVF   x7E,W
0C602:  MOVLB  0
0C604:  CALL   ADB4
0C608:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C60A:  MOVF   x7E,W
0C60C:  SUBLW  0D
0C60E:  BNZ   C5A8
....................    s[len]=0; 
0C610:  MOVF   x7D,W
0C612:  ADDWF  x7A,W
0C614:  MOVWF  FE9
0C616:  MOVLW  00
0C618:  ADDWFC x7B,W
0C61A:  MOVWF  FEA
0C61C:  CLRF   FEF
0C61E:  MOVLB  0
0C620:  GOTO   CA20 (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0CA0E:  MOVLW  08
0CA10:  MOVLB  8
0CA12:  MOVWF  x7B
0CA14:  MOVLW  62
0CA16:  MOVWF  x7A
0CA18:  MOVLW  14
0CA1A:  MOVWF  x7C
0CA1C:  MOVLB  0
0CA1E:  BRA    C5A2
....................   f = atof(s); 
0CA20:  MOVLW  08
0CA22:  MOVLB  8
0CA24:  MOVWF  x7B
0CA26:  MOVLW  62
0CA28:  MOVWF  x7A
0CA2A:  CLRF   x7D
0CA2C:  CLRF   x7C
0CA2E:  MOVLB  0
0CA30:  BRA    C7B8
0CA32:  MOVFF  03,879
0CA36:  MOVFF  02,878
0CA3A:  MOVFF  01,877
0CA3E:  MOVFF  00,876
....................   return(f); 
0CA42:  MOVFF  876,00
0CA46:  MOVFF  877,01
0CA4A:  MOVFF  878,02
0CA4E:  MOVFF  879,03
0CA52:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
028C2:  MOVLW  2F
028C4:  MOVWF  F92
....................    set_tris_b(0b00110111); 
028C6:  MOVLW  37
028C8:  MOVWF  F93
....................    set_tris_c(0b10010000); 
028CA:  MOVLW  90
028CC:  MOVWF  F94
....................    set_tris_d(0b00100000); 
028CE:  MOVLW  20
028D0:  MOVWF  F95
....................    set_tris_e(0b01000000); 
028D2:  MOVLW  40
028D4:  MOVWF  F96
....................    set_tris_f(0b00000000); 
028D6:  MOVLW  00
028D8:  MOVWF  F97
....................    set_tris_g(0b11100100); 
028DA:  MOVLW  E4
028DC:  MOVWF  F98
....................    set_tris_h(0b01000000); 
028DE:  MOVLW  40
028E0:  MOVWF  F99
....................    set_tris_j(0b00000000); 
028E2:  MOVLW  00
028E4:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
028E6:  BCF    F8E.3
....................    output_low(HB_IN1); 
028E8:  BCF    F8E.4
....................    output_low(HB_IN2); 
028EA:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
028EC:  BCF    F91.3
....................    output_high(EEP_CS);        
028EE:  BSF    F91.2
....................    output_high(RTC_CS); 
028F0:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
028F2:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
028F4:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
028F6:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
028F8:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
028FA:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
028FC:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
028FE:  BCF    F8F.3
....................    delay_ms(20);   
02900:  MOVLW  14
02902:  MOVLB  9
02904:  MOVWF  xC9
02906:  MOVLB  0
02908:  RCALL  2898
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
0290A:  BCF    F8E.1
....................    output_low(VDET);     
0290C:  BCF    F90.7
....................    bus_pwr_status=0; 
0290E:  MOVLB  4
02910:  CLRF   xB2
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
02912:  BSF    F8C.2
....................    output_high(DAC_CS); 
02914:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
02916:  BCF    F8C.0
....................    output_low(HSW2); 
02918:  BCF    F8C.1
....................    heater_stat=0; 
0291A:  CLRF   xB1
0291C:  MOVLB  0
0291E:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
1579A:  BSF    F91.1
....................    output_low(EEP_WP);        
1579C:  BCF    F91.3
....................    output_high(EEP_CS);        
1579E:  BSF    F91.2
....................    output_high(RTC_CS);  
157A0:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
157A2:  BCF    F8E.3
....................    output_low(HB_IN1);        
157A4:  BCF    F8E.4
....................    output_low(HB_IN2); 
157A6:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
157A8:  BCF    F8C.2
....................    output_low(DAC_CS); 
157AA:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
157AC:  BCF    F8C.0
....................    output_low(HSW2); 
157AE:  BCF    F8C.1
....................    heater_stat=0; 
157B0:  MOVLB  4
157B2:  CLRF   xB1
....................    // Power switches 
....................    output_low(VMOT);         
157B4:  BCF    F8E.1
....................    output_low(VDET);  
157B6:  BCF    F90.7
....................    bus_pwr_status=0; 
157B8:  CLRF   xB2
....................    output_low(VENC1);         
157BA:  BCF    F8E.6
....................    output_low(VENC2);         
157BC:  BCF    F8E.7
....................    output_low(VHBRDG);  
157BE:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
157C0:  MOVLW  34
157C2:  MOVWF  FF6
157C4:  MOVLW  0F
157C6:  MOVWF  FF7
157C8:  MOVLW  00
157CA:  MOVWF  FF8
157CC:  CLRF   1B
157CE:  BTFSC  FF2.7
157D0:  BSF    1B.7
157D2:  BCF    FF2.7
157D4:  MOVLB  0
157D6:  CALL   0E3A
157DA:  BTFSC  1B.7
157DC:  BSF    FF2.7
....................    delay_ms(50); 
157DE:  MOVLW  32
157E0:  MOVLB  9
157E2:  MOVWF  xC9
157E4:  MOVLB  0
157E6:  CALL   2898
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
157EA:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
157EC:  BSF    F91.6
....................    output_low(MD1_TXEN); 
157EE:  BCF    F91.5
....................    output_low(MD2_SHDN);    
157F0:  BCF    F8F.0
....................    output_low(MD2_REN); 
157F2:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
157F4:  BCF    F8F.3
....................  
....................    delay_ms(30); 
157F6:  MOVLW  1E
157F8:  MOVLB  9
157FA:  MOVWF  xC9
157FC:  MOVLB  0
157FE:  CALL   2898
15802:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
04FBC:  MOVLB  8
04FBE:  CLRF   x66
04FC0:  MOVF   x66,W
04FC2:  SUBLW  02
04FC4:  BNC   4FEA
....................       FS_Status = f_mountdrv(); 
04FC6:  MOVLB  0
04FC8:  RCALL  47D8
04FCA:  MOVFF  01,720
....................       if (FS_Status) 
04FCE:  MOVLB  7
04FD0:  MOVF   x20,F
04FD2:  BZ    4FDE
....................          { 
....................          display_file_result(FS_Status); 
04FD4:  MOVFF  720,867
04FD8:  MOVLB  0
04FDA:  BRA    4D76
....................          } 
04FDC:  BRA    4FE4
....................       else break; 
04FDE:  MOVLB  8
04FE0:  BRA    4FEA
04FE2:  MOVLB  0
04FE4:  MOVLB  8
04FE6:  INCF   x66,F
04FE8:  BRA    4FC0
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
04FEA:  MOVLW  3E
04FEC:  MOVWF  xCB
04FEE:  CLRF   xCD
04FF0:  MOVFF  720,8CC
04FF4:  MOVLB  0
04FF6:  RCALL  4F56
....................     
....................    return(FS_Status); 
04FF8:  MOVLB  7
04FFA:  MOVFF  720,01
04FFE:  MOVLB  0
05000:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
03084:  MOVLW  01
03086:  MOVLB  8
03088:  MOVWF  x60
0308A:  MOVF   x60,W
0308C:  SUBLW  03
0308E:  BNC   30CA
....................    { 
....................       output_bit(BOARD_LED, ON); 
03090:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
03092:  MOVF   2F,W
03094:  SUBLW  02
03096:  BNZ   309E
03098:  MOVF   30,F
0309A:  BNZ   309E
0309C:  BSF    F90.6
....................       delay_ms(32); 
0309E:  MOVLW  20
030A0:  MOVLB  9
030A2:  MOVWF  xC9
030A4:  MOVLB  0
030A6:  CALL   2898
....................       output_bit(BOARD_LED, OFF); 
030AA:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
030AC:  MOVF   2F,W
030AE:  SUBLW  02
030B0:  BNZ   30B8
030B2:  MOVF   30,F
030B4:  BNZ   30B8
030B6:  BCF    F90.6
....................       delay_ms(32); 
030B8:  MOVLW  20
030BA:  MOVLB  9
030BC:  MOVWF  xC9
030BE:  MOVLB  0
030C0:  CALL   2898
030C4:  MOVLB  8
030C6:  INCF   x60,F
030C8:  BRA    308A
....................    } 
030CA:  MOVLB  0
030CC:  GOTO   1B1F6 (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
0507E:  MOVLB  8
05080:  CLRF   xD0
05082:  CLRF   xCF
05084:  CLRF   xCE
05086:  CLRF   xCD
....................    set_adc_channel(0,VSS); 
05088:  MOVLW  00
0508A:  MOVWF  01
0508C:  MOVF   FC2,W
0508E:  ANDLW  83
05090:  IORWF  01,W
05092:  MOVWF  FC2
05094:  MOVLW  00
05096:  MOVWF  01
05098:  MOVF   FC1,W
0509A:  ANDLW  F8
0509C:  IORWF  01,W
0509E:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
050A0:  MOVLW  01
050A2:  MOVWF  xCA
050A4:  MOVF   xCA,W
050A6:  SUBLW  32
050A8:  BNC   50CE
....................       reading=read_adc(); 
050AA:  BSF    FC2.1
050AC:  BTFSC  FC2.1
050AE:  BRA    50AC
050B0:  MOVFF  FC3,8D1
050B4:  MOVFF  FC4,8D2
050B8:  CLRF   xD3
050BA:  CLRF   xD4
....................       delay_ms(5); 
050BC:  MOVLW  05
050BE:  MOVLB  9
050C0:  MOVWF  xC9
050C2:  MOVLB  0
050C4:  CALL   2898
050C8:  MOVLB  8
050CA:  INCF   xCA,F
050CC:  BRA    50A4
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
050CE:  MOVLW  01
050D0:  MOVWF  xCA
050D2:  MOVF   xCA,W
050D4:  SUBLW  64
050D6:  BNC   5184
....................       reading=read_adc(); 
050D8:  BSF    FC2.1
050DA:  BTFSC  FC2.1
050DC:  BRA    50DA
050DE:  MOVFF  FC3,8D1
050E2:  MOVFF  FC4,8D2
050E6:  CLRF   xD3
050E8:  CLRF   xD4
....................       result=(((result*(i-1))+reading)/i); 
050EA:  MOVLW  01
050EC:  SUBWF  xCA,W
050EE:  MOVWF  xD5
050F0:  MOVFF  8D0,9D6
050F4:  MOVFF  8CF,9D5
050F8:  MOVFF  8CE,9D4
050FC:  MOVFF  8CD,9D3
05100:  MOVLB  9
05102:  CLRF   xDA
05104:  CLRF   xD9
05106:  CLRF   xD8
05108:  MOVWF  xD7
0510A:  MOVLB  0
0510C:  CALL   477C
05110:  MOVFF  03,8D8
05114:  MOVFF  02,8D7
05118:  MOVFF  01,8D6
0511C:  MOVFF  00,8D5
05120:  MOVLB  8
05122:  MOVF   xD1,W
05124:  ADDWF  xD5,F
05126:  MOVF   xD2,W
05128:  ADDWFC xD6,F
0512A:  MOVF   xD3,W
0512C:  ADDWFC xD7,F
0512E:  MOVF   xD4,W
05130:  ADDWFC xD8,F
05132:  BCF    FD8.1
05134:  CLRF   1B
05136:  BTFSC  FF2.7
05138:  BSF    1B.7
0513A:  BCF    FF2.7
0513C:  MOVFF  8D8,A27
05140:  MOVFF  8D7,A26
05144:  MOVFF  8D6,A25
05148:  MOVFF  8D5,A24
0514C:  MOVLB  A
0514E:  CLRF   x2B
05150:  CLRF   x2A
05152:  CLRF   x29
05154:  MOVFF  8CA,A28
05158:  MOVLB  0
0515A:  CALL   1042
0515E:  BTFSC  1B.7
05160:  BSF    FF2.7
05162:  MOVFF  03,8D0
05166:  MOVFF  02,8CF
0516A:  MOVFF  01,8CE
0516E:  MOVFF  00,8CD
....................       delay_ms(5); 
05172:  MOVLW  05
05174:  MOVLB  9
05176:  MOVWF  xC9
05178:  MOVLB  0
0517A:  CALL   2898
0517E:  MOVLB  8
05180:  INCF   xCA,F
05182:  BRA    50D2
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
05184:  MOVFF  8D0,9D6
05188:  MOVFF  8CF,9D5
0518C:  MOVFF  8CE,9D4
05190:  MOVFF  8CD,9D3
05194:  MOVLB  9
05196:  CLRF   xDA
05198:  CLRF   xD9
0519A:  CLRF   xD8
0519C:  MOVLW  64
0519E:  MOVWF  xD7
051A0:  MOVLB  0
051A2:  CALL   477C
051A6:  MOVFF  03,8D8
051AA:  MOVFF  02,8D7
051AE:  MOVFF  01,8D6
051B2:  MOVFF  00,8D5
051B6:  BCF    FD8.1
051B8:  CLRF   1B
051BA:  BTFSC  FF2.7
051BC:  BSF    1B.7
051BE:  BCF    FF2.7
051C0:  MOVFF  03,A27
051C4:  MOVFF  02,A26
051C8:  MOVFF  01,A25
051CC:  MOVFF  00,A24
051D0:  MOVLB  A
051D2:  CLRF   x2B
051D4:  CLRF   x2A
051D6:  MOVLW  01
051D8:  MOVWF  x29
051DA:  MOVLW  10
051DC:  MOVWF  x28
051DE:  MOVLB  0
051E0:  CALL   1042
051E4:  BTFSC  1B.7
051E6:  BSF    FF2.7
051E8:  MOVLW  56
051EA:  MOVLB  8
051EC:  ADDWF  00,W
051EE:  MOVWF  xCB
051F0:  MOVLW  00
051F2:  ADDWFC 01,W
051F4:  MOVWF  xCC
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
051F6:  MOVFF  8CB,01
051FA:  MOVFF  8CC,02
051FE:  MOVLB  0
05200:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
05068:  MOVLW  02
0506A:  MOVWF  FEA
0506C:  MOVLW  95
0506E:  MOVWF  FE9
05070:  CLRF   00
05072:  CLRF   02
05074:  MOVLW  1E
05076:  MOVWF  01
05078:  CALL   34AE
0507C:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
12A3E:  MOVLW  02
12A40:  MOVWF  FEA
12A42:  MOVLW  B3
12A44:  MOVWF  FE9
12A46:  CLRF   00
12A48:  CLRF   02
12A4A:  MOVLW  1E
12A4C:  MOVWF  01
12A4E:  CALL   34AE
12A52:  GOTO   12CFA (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
0539C:  RCALL  5068
....................     
....................    v_supply = read_supply(); 
0539E:  RCALL  507E
053A0:  MOVFF  02,8C9
053A4:  MOVFF  01,8C8
....................    RTC_read(); 
053A8:  CALL   32CC
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
053AC:  MOVLW  02
053AE:  MOVWF  1E
053B0:  MOVLW  95
053B2:  MOVWF  1D
053B4:  MOVFF  726,8CA
053B8:  MOVLW  01
053BA:  MOVLB  8
053BC:  MOVWF  xCB
053BE:  MOVLB  0
053C0:  RCALL  5202
053C2:  MOVLW  2F
053C4:  MOVLB  8
053C6:  MOVWF  xDC
053C8:  MOVLB  0
053CA:  RCALL  5020
053CC:  MOVFF  725,8CA
053D0:  MOVLW  01
053D2:  MOVLB  8
053D4:  MOVWF  xCB
053D6:  MOVLB  0
053D8:  RCALL  5202
053DA:  MOVLW  2F
053DC:  MOVLB  8
053DE:  MOVWF  xDC
053E0:  MOVLB  0
053E2:  RCALL  5020
053E4:  MOVFF  727,8CA
053E8:  MOVLW  01
053EA:  MOVLB  8
053EC:  MOVWF  xCB
053EE:  MOVLB  0
053F0:  RCALL  5202
053F2:  MOVLW  20
053F4:  MOVLB  8
053F6:  MOVWF  xDC
053F8:  MOVLB  0
053FA:  RCALL  5020
053FC:  MOVFF  723,8CA
05400:  MOVLW  01
05402:  MOVLB  8
05404:  MOVWF  xCB
05406:  MOVLB  0
05408:  RCALL  5202
0540A:  MOVLW  3A
0540C:  MOVLB  8
0540E:  MOVWF  xDC
05410:  MOVLB  0
05412:  RCALL  5020
05414:  MOVFF  722,8CA
05418:  MOVLW  01
0541A:  MOVLB  8
0541C:  MOVWF  xCB
0541E:  MOVLB  0
05420:  RCALL  5202
05422:  MOVLW  3A
05424:  MOVLB  8
05426:  MOVWF  xDC
05428:  MOVLB  0
0542A:  RCALL  5020
0542C:  MOVFF  721,8CA
05430:  MOVLW  01
05432:  MOVLB  8
05434:  MOVWF  xCB
05436:  MOVLB  0
05438:  RCALL  5202
0543A:  MOVLW  2C
0543C:  MOVLB  8
0543E:  MOVWF  xDC
05440:  MOVLB  0
05442:  RCALL  5020
05444:  MOVLW  44
05446:  MOVWF  FE9
05448:  MOVLB  8
0544A:  CLRF   xCD
0544C:  CLRF   xCC
0544E:  MOVFF  8C9,8CB
05452:  MOVFF  8C8,8CA
05456:  MOVLW  02
05458:  MOVWF  xCE
0545A:  MOVLB  0
0545C:  RCALL  529C
0545E:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
0841A:  MOVLB  2
0841C:  MOVF   xD8,F
0841E:  BNZ   849A
....................    { 
....................       strcopy(event_buffer,""); 
08420:  MOVLW  01
08422:  MOVWF  FEA
08424:  MOVLW  03
08426:  MOVWF  FE9
08428:  MOVLW  00
0842A:  MOVLB  0
0842C:  CALL   02CE
08430:  TBLRD*-
08432:  TBLRD*+
08434:  MOVF   FF5,W
08436:  MOVWF  FEE
08438:  IORLW  00
0843A:  BNZ   8432
....................       time_stamp(); 
0843C:  CALL   539C
....................       strcat(event_buffer, time_stmp_str); 
08440:  MOVLW  01
08442:  MOVLB  8
08444:  MOVWF  xD6
08446:  MOVLW  03
08448:  MOVWF  xD5
0844A:  MOVLW  02
0844C:  MOVWF  xD8
0844E:  MOVLW  95
08450:  MOVWF  xD7
08452:  MOVLB  0
08454:  CALL   5460
....................       strcat(event_buffer, event_str); 
08458:  MOVLW  01
0845A:  MOVLB  8
0845C:  MOVWF  xD6
0845E:  MOVLW  03
08460:  MOVWF  xD5
08462:  MOVLW  01
08464:  MOVWF  xD8
08466:  MOVLW  A3
08468:  MOVWF  xD7
0846A:  MOVLB  0
0846C:  CALL   5460
....................       buffer_select = 1; 
08470:  MOVLW  01
08472:  MOVWF  x62
....................     
....................       heartbeat(FALSE); 
08474:  MOVLB  8
08476:  CLRF   xCA
08478:  MOVLB  0
0847A:  CALL   5504
....................          append_data(file_ptr_events); 
0847E:  MOVLW  03
08480:  MOVLB  8
08482:  MOVWF  xCB
08484:  MOVLW  11
08486:  MOVWF  xCA
08488:  MOVLB  0
0848A:  RCALL  8238
....................       heartbeat(TRUE); 
0848C:  MOVLW  01
0848E:  MOVLB  8
08490:  MOVWF  xCA
08492:  MOVLB  0
08494:  CALL   5504
08498:  MOVLB  2
....................    } 
0849A:  MOVLB  0
0849C:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
0284C:  BCF    F8B.2
0284E:  MOVLW  0C
02850:  MOVWF  FBB
02852:  CLRF   FBE
02854:  CLRF   FBF
02856:  MOVLW  01
02858:  MOVWF  F9C
0285A:  MOVLW  F8
0285C:  MOVLB  F
0285E:  ANDWF  x2D,F
02860:  MOVLW  00
02862:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
02864:  BCF    F8B.1
02866:  MOVLW  0C
02868:  MOVWF  x4E
0286A:  CLRF   x51
0286C:  CLRF   x52
0286E:  MOVLW  01
02870:  MOVWF  x1B
02872:  MOVLW  C7
02874:  ANDWF  x2D,F
02876:  MOVLW  00
02878:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
0287A:  IORLW  05
0287C:  MOVWF  FCA
0287E:  MOVLW  7F
02880:  MOVWF  FCB
02882:  MOVLB  0
02884:  GOTO   1B1AC (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09C42:  MOVLW  3E
09C44:  MOVWF  FF6
09C46:  MOVLW  0F
09C48:  MOVWF  FF7
09C4A:  MOVLW  00
09C4C:  MOVWF  FF8
09C4E:  CLRF   1B
09C50:  BTFSC  FF2.7
09C52:  BSF    1B.7
09C54:  BCF    FF2.7
09C56:  MOVLW  05
09C58:  MOVLB  A
09C5A:  MOVWF  x18
09C5C:  MOVLB  0
09C5E:  CALL   1010
09C62:  BTFSC  1B.7
09C64:  BSF    FF2.7
09C66:  MOVLW  10
09C68:  MOVWF  FE9
09C6A:  CLRF   1B
09C6C:  BTFSC  FF2.7
09C6E:  BSF    1B.7
09C70:  BCF    FF2.7
09C72:  MOVFF  793,A19
09C76:  MOVFF  792,A18
09C7A:  CALL   1192
09C7E:  BTFSC  1B.7
09C80:  BSF    FF2.7
09C82:  MOVLW  2C
09C84:  BTFSS  F9E.4
09C86:  BRA    9C84
09C88:  MOVWF  FAD
09C8A:  MOVLW  10
09C8C:  MOVWF  FE9
09C8E:  CLRF   1B
09C90:  BTFSC  FF2.7
09C92:  BSF    1B.7
09C94:  BCF    FF2.7
09C96:  MOVFF  795,A19
09C9A:  MOVFF  794,A18
09C9E:  CALL   1192
09CA2:  BTFSC  1B.7
09CA4:  BSF    FF2.7
09CA6:  MOVLW  0D
09CA8:  BTFSS  F9E.4
09CAA:  BRA    9CA8
09CAC:  MOVWF  FAD
09CAE:  MOVLW  0A
09CB0:  BTFSS  F9E.4
09CB2:  BRA    9CB0
09CB4:  MOVWF  FAD
09CB6:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02CA2:  MOVLW  86
02CA4:  MOVLB  8
02CA6:  MOVWF  x74
02CA8:  MOVLB  0
02CAA:  RCALL  2952
02CAC:  MOVFF  02,73F
02CB0:  MOVFF  01,73E
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02CB4:  MOVLW  8A
02CB6:  MOVLB  8
02CB8:  MOVWF  x74
02CBA:  MOVLB  0
02CBC:  RCALL  2952
02CBE:  MOVFF  02,743
02CC2:  MOVFF  01,742
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02CC6:  MOVLW  8E
02CC8:  MOVLB  8
02CCA:  MOVWF  x74
02CCC:  MOVLB  0
02CCE:  RCALL  2952
02CD0:  MOVFF  02,747
02CD4:  MOVFF  01,746
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02CD8:  MOVLW  92
02CDA:  MOVLB  8
02CDC:  MOVWF  x74
02CDE:  MOVLB  0
02CE0:  RCALL  2952
02CE2:  MOVFF  02,74B
02CE6:  MOVFF  01,74A
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02CEA:  MOVLW  96
02CEC:  MOVLB  8
02CEE:  MOVWF  x74
02CF0:  MOVLB  0
02CF2:  RCALL  2952
02CF4:  MOVFF  02,74F
02CF8:  MOVFF  01,74E
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02CFC:  MOVLW  9A
02CFE:  MOVLB  8
02D00:  MOVWF  x74
02D02:  MOVLB  0
02D04:  RCALL  2952
02D06:  MOVFF  02,753
02D0A:  MOVFF  01,752
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02D0E:  MOVLW  9E
02D10:  MOVLB  8
02D12:  MOVWF  x74
02D14:  MOVLB  0
02D16:  RCALL  2952
02D18:  MOVFF  02,757
02D1C:  MOVFF  01,756
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02D20:  MOVLW  A2
02D22:  MOVLB  8
02D24:  MOVWF  x74
02D26:  MOVLB  0
02D28:  RCALL  2952
02D2A:  MOVFF  02,75B
02D2E:  MOVFF  01,75A
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02D32:  MOVLW  A6
02D34:  MOVLB  8
02D36:  MOVWF  x74
02D38:  MOVLB  0
02D3A:  RCALL  2952
02D3C:  MOVFF  02,75F
02D40:  MOVFF  01,75E
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02D44:  MOVLW  82
02D46:  MOVLB  8
02D48:  MOVWF  x74
02D4A:  MOVLB  0
02D4C:  RCALL  2952
02D4E:  MOVFF  02,763
02D52:  MOVFF  01,762
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02D56:  MOVLW  7E
02D58:  MOVLB  8
02D5A:  MOVWF  x74
02D5C:  MOVLB  0
02D5E:  RCALL  2952
02D60:  MOVFF  02,7BC
02D64:  MOVFF  01,7BB
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02D68:  MOVLW  AA
02D6A:  MOVLB  8
02D6C:  MOVWF  x74
02D6E:  MOVLB  0
02D70:  RCALL  2952
02D72:  MOVFF  02,7C0
02D76:  MOVFF  01,7BF
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02D7A:  MOVLW  7A
02D7C:  MOVLB  8
02D7E:  MOVWF  x74
02D80:  MOVLB  0
02D82:  RCALL  2952
02D84:  MOVFF  02,767
02D88:  MOVFF  01,766
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02D8C:  MOVLW  76
02D8E:  MOVLB  8
02D90:  MOVWF  x74
02D92:  MOVLB  0
02D94:  RCALL  2952
02D96:  MOVFF  02,76B
02D9A:  MOVFF  01,76A
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02D9E:  MOVLW  72
02DA0:  MOVLB  8
02DA2:  MOVWF  x74
02DA4:  MOVLB  0
02DA6:  RCALL  2952
02DA8:  MOVFF  02,76F
02DAC:  MOVFF  01,76E
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02DB0:  MOVLW  6E
02DB2:  MOVLB  8
02DB4:  MOVWF  x74
02DB6:  MOVLB  0
02DB8:  RCALL  2952
02DBA:  MOVFF  02,793
02DBE:  MOVFF  01,792
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02DC2:  MOVLW  AE
02DC4:  MOVLB  8
02DC6:  MOVWF  x74
02DC8:  MOVLB  0
02DCA:  RCALL  2952
02DCC:  MOVFF  02,773
02DD0:  MOVFF  01,772
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02DD4:  MOVLW  B2
02DD6:  MOVLB  8
02DD8:  MOVWF  x74
02DDA:  MOVLB  0
02DDC:  RCALL  2952
02DDE:  MOVFF  02,7AC
02DE2:  MOVFF  01,7AB
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02DE6:  MOVLW  B6
02DE8:  MOVLB  8
02DEA:  MOVWF  x74
02DEC:  MOVLB  0
02DEE:  RCALL  2952
02DF0:  MOVFF  02,7B0
02DF4:  MOVFF  01,7AF
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02DF8:  MOVLW  BA
02DFA:  MOVLB  8
02DFC:  MOVWF  x74
02DFE:  MOVLB  0
02E00:  RCALL  2952
02E02:  MOVFF  02,777
02E06:  MOVFF  01,776
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02E0A:  MOVLW  BE
02E0C:  MOVLB  8
02E0E:  MOVWF  x74
02E10:  MOVLB  0
02E12:  RCALL  2952
02E14:  MOVFF  02,77B
02E18:  MOVFF  01,77A
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02E1C:  MOVLW  C2
02E1E:  MOVLB  8
02E20:  MOVWF  x74
02E22:  MOVLB  0
02E24:  RCALL  2952
02E26:  MOVFF  02,77F
02E2A:  MOVFF  01,77E
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02E2E:  MOVLW  88
02E30:  MOVLB  8
02E32:  MOVWF  x74
02E34:  MOVLB  0
02E36:  RCALL  2952
02E38:  MOVFF  02,741
02E3C:  MOVFF  01,740
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02E40:  MOVLW  8C
02E42:  MOVLB  8
02E44:  MOVWF  x74
02E46:  MOVLB  0
02E48:  RCALL  2952
02E4A:  MOVFF  02,745
02E4E:  MOVFF  01,744
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02E52:  MOVLW  90
02E54:  MOVLB  8
02E56:  MOVWF  x74
02E58:  MOVLB  0
02E5A:  RCALL  2952
02E5C:  MOVFF  02,749
02E60:  MOVFF  01,748
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02E64:  MOVLW  94
02E66:  MOVLB  8
02E68:  MOVWF  x74
02E6A:  MOVLB  0
02E6C:  RCALL  2952
02E6E:  MOVFF  02,74D
02E72:  MOVFF  01,74C
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02E76:  MOVLW  98
02E78:  MOVLB  8
02E7A:  MOVWF  x74
02E7C:  MOVLB  0
02E7E:  RCALL  2952
02E80:  MOVFF  02,751
02E84:  MOVFF  01,750
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02E88:  MOVLW  9C
02E8A:  MOVLB  8
02E8C:  MOVWF  x74
02E8E:  MOVLB  0
02E90:  RCALL  2952
02E92:  MOVFF  02,755
02E96:  MOVFF  01,754
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02E9A:  MOVLW  A0
02E9C:  MOVLB  8
02E9E:  MOVWF  x74
02EA0:  MOVLB  0
02EA2:  RCALL  2952
02EA4:  MOVFF  02,759
02EA8:  MOVFF  01,758
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02EAC:  MOVLW  A4
02EAE:  MOVLB  8
02EB0:  MOVWF  x74
02EB2:  MOVLB  0
02EB4:  RCALL  2952
02EB6:  MOVFF  02,75D
02EBA:  MOVFF  01,75C
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02EBE:  MOVLW  A8
02EC0:  MOVLB  8
02EC2:  MOVWF  x74
02EC4:  MOVLB  0
02EC6:  RCALL  2952
02EC8:  MOVFF  02,761
02ECC:  MOVFF  01,760
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02ED0:  MOVLW  84
02ED2:  MOVLB  8
02ED4:  MOVWF  x74
02ED6:  MOVLB  0
02ED8:  RCALL  2952
02EDA:  MOVFF  02,765
02EDE:  MOVFF  01,764
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02EE2:  MOVLW  80
02EE4:  MOVLB  8
02EE6:  MOVWF  x74
02EE8:  MOVLB  0
02EEA:  RCALL  2952
02EEC:  MOVFF  02,7BE
02EF0:  MOVFF  01,7BD
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02EF4:  MOVLW  AC
02EF6:  MOVLB  8
02EF8:  MOVWF  x74
02EFA:  MOVLB  0
02EFC:  RCALL  2952
02EFE:  MOVFF  02,7C2
02F02:  MOVFF  01,7C1
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02F06:  MOVLW  7C
02F08:  MOVLB  8
02F0A:  MOVWF  x74
02F0C:  MOVLB  0
02F0E:  RCALL  2952
02F10:  MOVFF  02,769
02F14:  MOVFF  01,768
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02F18:  MOVLW  78
02F1A:  MOVLB  8
02F1C:  MOVWF  x74
02F1E:  MOVLB  0
02F20:  RCALL  2952
02F22:  MOVFF  02,76D
02F26:  MOVFF  01,76C
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02F2A:  MOVLW  74
02F2C:  MOVLB  8
02F2E:  MOVWF  x74
02F30:  MOVLB  0
02F32:  RCALL  2952
02F34:  MOVFF  02,771
02F38:  MOVFF  01,770
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
02F3C:  MOVLW  70
02F3E:  MOVLB  8
02F40:  MOVWF  x74
02F42:  MOVLB  0
02F44:  RCALL  2952
02F46:  MOVFF  02,795
02F4A:  MOVFF  01,794
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
02F4E:  MOVLW  B0
02F50:  MOVLB  8
02F52:  MOVWF  x74
02F54:  MOVLB  0
02F56:  RCALL  2952
02F58:  MOVFF  02,775
02F5C:  MOVFF  01,774
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
02F60:  MOVLW  B4
02F62:  MOVLB  8
02F64:  MOVWF  x74
02F66:  MOVLB  0
02F68:  RCALL  2952
02F6A:  MOVFF  02,7AE
02F6E:  MOVFF  01,7AD
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
02F72:  MOVLW  B8
02F74:  MOVLB  8
02F76:  MOVWF  x74
02F78:  MOVLB  0
02F7A:  RCALL  2952
02F7C:  MOVFF  02,7B2
02F80:  MOVFF  01,7B1
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
02F84:  MOVLW  BC
02F86:  MOVLB  8
02F88:  MOVWF  x74
02F8A:  MOVLB  0
02F8C:  RCALL  2952
02F8E:  MOVFF  02,779
02F92:  MOVFF  01,778
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
02F96:  MOVLW  C0
02F98:  MOVLB  8
02F9A:  MOVWF  x74
02F9C:  MOVLB  0
02F9E:  RCALL  2952
02FA0:  MOVFF  02,77D
02FA4:  MOVFF  01,77C
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
02FA8:  MOVLW  C4
02FAA:  MOVLB  8
02FAC:  MOVWF  x74
02FAE:  MOVLB  0
02FB0:  RCALL  2952
02FB2:  MOVFF  02,781
02FB6:  MOVFF  01,780
....................     
....................    motor=0; 
02FBA:  MOVLB  7
02FBC:  CLRF   x3C
....................    m_fixed=1; 
02FBE:  MOVLW  01
02FC0:  MOVWF  x3D
....................    m_step_cnt[0]=0; 
02FC2:  CLRF   xA1
02FC4:  CLRF   xA0
02FC6:  CLRF   x9F
02FC8:  CLRF   x9E
....................    m_step_cnt[1]=0; 
02FCA:  CLRF   xA5
02FCC:  CLRF   xA4
02FCE:  CLRF   xA3
02FD0:  CLRF   xA2
....................    e_cha_cnt[0]=0; 
02FD2:  CLRF   xB8
02FD4:  CLRF   xB7
....................    e_cha_cnt[1]=0;  
02FD6:  CLRF   xBA
02FD8:  CLRF   xB9
....................    m_gb_cnt[0]=0; 
02FDA:  CLRF   x97
02FDC:  CLRF   x96
....................    m_gb_cnt[1]=0; 
02FDE:  CLRF   x99
02FE0:  CLRF   x98
....................    e_mode_rst[0]=0; 
02FE2:  CLRF   x9B
02FE4:  CLRF   x9A
....................    e_mode_rst[1]=0;    
02FE6:  CLRF   x9D
02FE8:  CLRF   x9C
....................    e_port_dist[0]=0; 
02FEA:  CLRF   xB4
02FEC:  CLRF   xB3
....................    e_port_dist[1]=0; 
02FEE:  CLRF   xB6
02FF0:  CLRF   xB5
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
02FF2:  MOVFF  773,8B9
02FF6:  MOVFF  772,8B8
02FFA:  MOVFF  75F,8BB
02FFE:  MOVFF  75E,8BA
03002:  MOVLB  0
03004:  RCALL  2C5C
03006:  BCF    FD8.0
03008:  MOVLB  8
0300A:  RLCF   01,W
0300C:  MOVLB  7
0300E:  MOVWF  xA7
03010:  MOVLB  8
03012:  RLCF   02,W
03014:  MOVLB  7
03016:  MOVWF  xA8
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
03018:  MOVFF  775,8B9
0301C:  MOVFF  774,8B8
03020:  MOVFF  761,8BB
03024:  MOVFF  760,8BA
03028:  MOVLB  0
0302A:  RCALL  2C5C
0302C:  BCF    FD8.0
0302E:  MOVLB  8
03030:  RLCF   01,W
03032:  MOVLB  7
03034:  MOVWF  xA9
03036:  MOVLB  8
03038:  RLCF   02,W
0303A:  MOVLB  7
0303C:  MOVWF  xAA
0303E:  MOVLB  0
03040:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
19C14:  MOVLW  86
19C16:  MOVLB  8
19C18:  MOVWF  xCB
19C1A:  CLRF   xCD
19C1C:  MOVLW  01
19C1E:  MOVWF  xCC
19C20:  MOVLB  0
19C22:  CALL   4F56
....................    write16(ADDR_M1_MODE,FULL); 
19C26:  MOVLW  8A
19C28:  MOVLB  8
19C2A:  MOVWF  xCB
19C2C:  CLRF   xCD
19C2E:  CLRF   xCC
19C30:  MOVLB  0
19C32:  CALL   4F56
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
19C36:  MOVLW  8E
19C38:  MOVLB  8
19C3A:  MOVWF  xCB
19C3C:  CLRF   xCD
19C3E:  MOVLW  0A
19C40:  MOVWF  xCC
19C42:  MOVLB  0
19C44:  CALL   4F56
....................    write16(ADDR_M1_POS_DIR,0); 
19C48:  MOVLW  92
19C4A:  MOVLB  8
19C4C:  MOVWF  xCB
19C4E:  CLRF   xCD
19C50:  CLRF   xCC
19C52:  MOVLB  0
19C54:  CALL   4F56
....................    write16(ADDR_M1_PWM_HLD,0); 
19C58:  MOVLW  96
19C5A:  MOVLB  8
19C5C:  MOVWF  xCB
19C5E:  CLRF   xCD
19C60:  CLRF   xCC
19C62:  MOVLB  0
19C64:  CALL   4F56
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
19C68:  MOVLW  9A
19C6A:  MOVLB  8
19C6C:  MOVWF  xCB
19C6E:  CLRF   xCD
19C70:  MOVLW  7F
19C72:  MOVWF  xCC
19C74:  MOVLB  0
19C76:  CALL   4F56
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
19C7A:  MOVLW  9E
19C7C:  MOVLB  8
19C7E:  MOVWF  xCB
19C80:  MOVLW  17
19C82:  MOVWF  xCD
19C84:  MOVLW  70
19C86:  MOVWF  xCC
19C88:  MOVLB  0
19C8A:  CALL   4F56
....................    write16(ADDR_E1_CPR,16); 
19C8E:  MOVLW  A2
19C90:  MOVLB  8
19C92:  MOVWF  xCB
19C94:  CLRF   xCD
19C96:  MOVLW  10
19C98:  MOVWF  xCC
19C9A:  MOVLB  0
19C9C:  CALL   4F56
....................    write16(ADDR_E1_PPR,16); 
19CA0:  MOVLW  A6
19CA2:  MOVLB  8
19CA4:  MOVWF  xCB
19CA6:  CLRF   xCD
19CA8:  MOVLW  10
19CAA:  MOVWF  xCC
19CAC:  MOVLB  0
19CAE:  CALL   4F56
....................    write16(ADDR_E1_MODE,2); 
19CB2:  MOVLW  82
19CB4:  MOVLB  8
19CB6:  MOVWF  xCB
19CB8:  CLRF   xCD
19CBA:  MOVLW  02
19CBC:  MOVWF  xCC
19CBE:  MOVLB  0
19CC0:  CALL   4F56
....................    write16(ADDR_E1_POS,0); 
19CC4:  MOVLW  7E
19CC6:  MOVLB  8
19CC8:  MOVWF  xCB
19CCA:  CLRF   xCD
19CCC:  CLRF   xCC
19CCE:  MOVLB  0
19CD0:  CALL   4F56
....................    write16(ADDR_E1_PORT,0); 
19CD4:  MOVLW  AA
19CD6:  MOVLB  8
19CD8:  MOVWF  xCB
19CDA:  CLRF   xCD
19CDC:  CLRF   xCC
19CDE:  MOVLB  0
19CE0:  CALL   4F56
....................    write16(ADDR_E1_TYPE,2); 
19CE4:  MOVLW  7A
19CE6:  MOVLB  8
19CE8:  MOVWF  xCB
19CEA:  CLRF   xCD
19CEC:  MOVLW  02
19CEE:  MOVWF  xCC
19CF0:  MOVLB  0
19CF2:  CALL   4F56
....................    write16(ADDR_M1_RUN,270); 
19CF6:  MOVLW  76
19CF8:  MOVLB  8
19CFA:  MOVWF  xCB
19CFC:  MOVLW  01
19CFE:  MOVWF  xCD
19D00:  MOVLW  0E
19D02:  MOVWF  xCC
19D04:  MOVLB  0
19D06:  CALL   4F56
....................    write16(ADDR_M1_BKLSH,0); 
19D0A:  MOVLW  72
19D0C:  MOVLB  8
19D0E:  MOVWF  xCB
19D10:  CLRF   xCD
19D12:  CLRF   xCC
19D14:  MOVLB  0
19D16:  CALL   4F56
....................    write16(ADDR_M1_ERROR,0);   
19D1A:  MOVLW  6E
19D1C:  MOVLB  8
19D1E:  MOVWF  xCB
19D20:  CLRF   xCD
19D22:  CLRF   xCC
19D24:  MOVLB  0
19D26:  CALL   4F56
....................    write16(ADDR_M1_SPR,38400); 
19D2A:  MOVLW  AE
19D2C:  MOVLB  8
19D2E:  MOVWF  xCB
19D30:  MOVLW  96
19D32:  MOVWF  xCD
19D34:  CLRF   xCC
19D36:  MOVLB  0
19D38:  CALL   4F56
....................    write16(ADDR_M1_COMP,0); 
19D3C:  MOVLW  B2
19D3E:  MOVLB  8
19D40:  MOVWF  xCB
19D42:  CLRF   xCD
19D44:  CLRF   xCC
19D46:  MOVLB  0
19D48:  CALL   4F56
....................    write16(ADDR_M1_LIN_POS,0); 
19D4C:  MOVLW  B6
19D4E:  MOVLB  8
19D50:  MOVWF  xCB
19D52:  CLRF   xCD
19D54:  CLRF   xCC
19D56:  MOVLB  0
19D58:  CALL   4F56
....................    write16(ADDR_E1_INDEX,1); 
19D5C:  MOVLW  BA
19D5E:  MOVLB  8
19D60:  MOVWF  xCB
19D62:  CLRF   xCD
19D64:  MOVLW  01
19D66:  MOVWF  xCC
19D68:  MOVLB  0
19D6A:  CALL   4F56
....................    write16(ADDR_M1_EVN_SO,0); 
19D6E:  MOVLW  BE
19D70:  MOVLB  8
19D72:  MOVWF  xCB
19D74:  CLRF   xCD
19D76:  CLRF   xCC
19D78:  MOVLB  0
19D7A:  CALL   4F56
....................    write16(ADDR_M1_ALIGN_OS,0); 
19D7E:  MOVLW  C2
19D80:  MOVLB  8
19D82:  MOVWF  xCB
19D84:  CLRF   xCD
19D86:  CLRF   xCC
19D88:  MOVLB  0
19D8A:  CALL   4F56
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
19D8E:  MOVLW  88
19D90:  MOVLB  8
19D92:  MOVWF  xCB
19D94:  CLRF   xCD
19D96:  MOVLW  01
19D98:  MOVWF  xCC
19D9A:  MOVLB  0
19D9C:  CALL   4F56
....................    write16(ADDR_M2_MODE,HALF); 
19DA0:  MOVLW  8C
19DA2:  MOVLB  8
19DA4:  MOVWF  xCB
19DA6:  CLRF   xCD
19DA8:  MOVLW  01
19DAA:  MOVWF  xCC
19DAC:  MOVLB  0
19DAE:  CALL   4F56
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
19DB2:  MOVLW  90
19DB4:  MOVLB  8
19DB6:  MOVWF  xCB
19DB8:  CLRF   xCD
19DBA:  MOVLW  05
19DBC:  MOVWF  xCC
19DBE:  MOVLB  0
19DC0:  CALL   4F56
....................    write16(ADDR_M2_POS_DIR,0); 
19DC4:  MOVLW  94
19DC6:  MOVLB  8
19DC8:  MOVWF  xCB
19DCA:  CLRF   xCD
19DCC:  CLRF   xCC
19DCE:  MOVLB  0
19DD0:  CALL   4F56
....................    write16(ADDR_M2_PWM_HLD,0); 
19DD4:  MOVLW  98
19DD6:  MOVLB  8
19DD8:  MOVWF  xCB
19DDA:  CLRF   xCD
19DDC:  CLRF   xCC
19DDE:  MOVLB  0
19DE0:  CALL   4F56
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
19DE4:  MOVLW  9C
19DE6:  MOVLB  8
19DE8:  MOVWF  xCB
19DEA:  CLRF   xCD
19DEC:  MOVLW  7F
19DEE:  MOVWF  xCC
19DF0:  MOVLB  0
19DF2:  CALL   4F56
....................    write16(ADDR_M2_GB_ERR,0); 
19DF6:  MOVLW  A0
19DF8:  MOVLB  8
19DFA:  MOVWF  xCB
19DFC:  CLRF   xCD
19DFE:  CLRF   xCC
19E00:  MOVLB  0
19E02:  CALL   4F56
....................    write16(ADDR_E2_CPR,0); 
19E06:  MOVLW  A4
19E08:  MOVLB  8
19E0A:  MOVWF  xCB
19E0C:  CLRF   xCD
19E0E:  CLRF   xCC
19E10:  MOVLB  0
19E12:  CALL   4F56
....................    write16(ADDR_E2_PPR,0);   
19E16:  MOVLW  A8
19E18:  MOVLB  8
19E1A:  MOVWF  xCB
19E1C:  CLRF   xCD
19E1E:  CLRF   xCC
19E20:  MOVLB  0
19E22:  CALL   4F56
....................    write16(ADDR_E2_MODE,0); 
19E26:  MOVLW  84
19E28:  MOVLB  8
19E2A:  MOVWF  xCB
19E2C:  CLRF   xCD
19E2E:  CLRF   xCC
19E30:  MOVLB  0
19E32:  CALL   4F56
....................    write16(ADDR_E2_POS,0); 
19E36:  MOVLW  80
19E38:  MOVLB  8
19E3A:  MOVWF  xCB
19E3C:  CLRF   xCD
19E3E:  CLRF   xCC
19E40:  MOVLB  0
19E42:  CALL   4F56
....................    write16(ADDR_E2_PORT,0); 
19E46:  MOVLW  AC
19E48:  MOVLB  8
19E4A:  MOVWF  xCB
19E4C:  CLRF   xCD
19E4E:  CLRF   xCC
19E50:  MOVLB  0
19E52:  CALL   4F56
....................    write16(ADDR_E2_TYPE,0); 
19E56:  MOVLW  7C
19E58:  MOVLB  8
19E5A:  MOVWF  xCB
19E5C:  CLRF   xCD
19E5E:  CLRF   xCC
19E60:  MOVLB  0
19E62:  CALL   4F56
....................    write16(ADDR_M2_RUN,0); 
19E66:  MOVLW  78
19E68:  MOVLB  8
19E6A:  MOVWF  xCB
19E6C:  CLRF   xCD
19E6E:  CLRF   xCC
19E70:  MOVLB  0
19E72:  CALL   4F56
....................    write16(ADDR_M2_BKLSH,0); 
19E76:  MOVLW  74
19E78:  MOVLB  8
19E7A:  MOVWF  xCB
19E7C:  CLRF   xCD
19E7E:  CLRF   xCC
19E80:  MOVLB  0
19E82:  CALL   4F56
....................    write16(ADDR_M2_ERROR,0);   
19E86:  MOVLW  70
19E88:  MOVLB  8
19E8A:  MOVWF  xCB
19E8C:  CLRF   xCD
19E8E:  CLRF   xCC
19E90:  MOVLB  0
19E92:  CALL   4F56
....................    write16(ADDR_M2_SPR,0); 
19E96:  MOVLW  B0
19E98:  MOVLB  8
19E9A:  MOVWF  xCB
19E9C:  CLRF   xCD
19E9E:  CLRF   xCC
19EA0:  MOVLB  0
19EA2:  CALL   4F56
....................    write16(ADDR_M2_COMP,0); 
19EA6:  MOVLW  B4
19EA8:  MOVLB  8
19EAA:  MOVWF  xCB
19EAC:  CLRF   xCD
19EAE:  CLRF   xCC
19EB0:  MOVLB  0
19EB2:  CALL   4F56
....................    write16(ADDR_M2_LIN_POS,0);    
19EB6:  MOVLW  B8
19EB8:  MOVLB  8
19EBA:  MOVWF  xCB
19EBC:  CLRF   xCD
19EBE:  CLRF   xCC
19EC0:  MOVLB  0
19EC2:  CALL   4F56
....................    write16(ADDR_E2_INDEX,0); 
19EC6:  MOVLW  BC
19EC8:  MOVLB  8
19ECA:  MOVWF  xCB
19ECC:  CLRF   xCD
19ECE:  CLRF   xCC
19ED0:  MOVLB  0
19ED2:  CALL   4F56
....................    write16(ADDR_M2_EVN_SO,0); 
19ED6:  MOVLW  C0
19ED8:  MOVLB  8
19EDA:  MOVWF  xCB
19EDC:  CLRF   xCD
19EDE:  CLRF   xCC
19EE0:  MOVLB  0
19EE2:  CALL   4F56
....................    write16(ADDR_M2_ALIGN_OS,0); 
19EE6:  MOVLW  C4
19EE8:  MOVLB  8
19EEA:  MOVWF  xCB
19EEC:  CLRF   xCD
19EEE:  CLRF   xCC
19EF0:  MOVLB  0
19EF2:  CALL   4F56
....................     
....................    get_step_vars(); 
19EF6:  CALL   2CA2
19EFA:  GOTO   1A744 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
19EFE:  MOVLW  86
19F00:  MOVLB  8
19F02:  MOVWF  xCB
19F04:  CLRF   xCD
19F06:  MOVLW  01
19F08:  MOVWF  xCC
19F0A:  MOVLB  0
19F0C:  CALL   4F56
....................    write16(ADDR_M1_MODE,FULL); 
19F10:  MOVLW  8A
19F12:  MOVLB  8
19F14:  MOVWF  xCB
19F16:  CLRF   xCD
19F18:  CLRF   xCC
19F1A:  MOVLB  0
19F1C:  CALL   4F56
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
19F20:  MOVLW  8E
19F22:  MOVLB  8
19F24:  MOVWF  xCB
19F26:  CLRF   xCD
19F28:  MOVLW  14
19F2A:  MOVWF  xCC
19F2C:  MOVLB  0
19F2E:  CALL   4F56
....................    write16(ADDR_M1_POS_DIR,1); 
19F32:  MOVLW  92
19F34:  MOVLB  8
19F36:  MOVWF  xCB
19F38:  CLRF   xCD
19F3A:  MOVLW  01
19F3C:  MOVWF  xCC
19F3E:  MOVLB  0
19F40:  CALL   4F56
....................    write16(ADDR_M1_PWM_HLD,51); 
19F44:  MOVLW  96
19F46:  MOVLB  8
19F48:  MOVWF  xCB
19F4A:  CLRF   xCD
19F4C:  MOVLW  33
19F4E:  MOVWF  xCC
19F50:  MOVLB  0
19F52:  CALL   4F56
....................    write16(ADDR_M1_PWM_DRV,511); 
19F56:  MOVLW  9A
19F58:  MOVLB  8
19F5A:  MOVWF  xCB
19F5C:  MOVLW  01
19F5E:  MOVWF  xCD
19F60:  SETF   xCC
19F62:  MOVLB  0
19F64:  CALL   4F56
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
19F68:  MOVLW  9E
19F6A:  MOVLB  8
19F6C:  MOVWF  xCB
19F6E:  MOVLW  02
19F70:  MOVWF  xCD
19F72:  MOVLW  9E
19F74:  MOVWF  xCC
19F76:  MOVLB  0
19F78:  CALL   4F56
....................    write16(ADDR_E1_CPR,24); 
19F7C:  MOVLW  A2
19F7E:  MOVLB  8
19F80:  MOVWF  xCB
19F82:  CLRF   xCD
19F84:  MOVLW  18
19F86:  MOVWF  xCC
19F88:  MOVLB  0
19F8A:  CALL   4F56
....................    write16(ADDR_E1_PPR,48); 
19F8E:  MOVLW  A6
19F90:  MOVLB  8
19F92:  MOVWF  xCB
19F94:  CLRF   xCD
19F96:  MOVLW  30
19F98:  MOVWF  xCC
19F9A:  MOVLB  0
19F9C:  CALL   4F56
....................    write16(ADDR_E1_MODE,2); 
19FA0:  MOVLW  82
19FA2:  MOVLB  8
19FA4:  MOVWF  xCB
19FA6:  CLRF   xCD
19FA8:  MOVLW  02
19FAA:  MOVWF  xCC
19FAC:  MOVLB  0
19FAE:  CALL   4F56
....................    write16(ADDR_E1_POS,0); 
19FB2:  MOVLW  7E
19FB4:  MOVLB  8
19FB6:  MOVWF  xCB
19FB8:  CLRF   xCD
19FBA:  CLRF   xCC
19FBC:  MOVLB  0
19FBE:  CALL   4F56
....................    write16(ADDR_E1_PORT,0); 
19FC2:  MOVLW  AA
19FC4:  MOVLB  8
19FC6:  MOVWF  xCB
19FC8:  CLRF   xCD
19FCA:  CLRF   xCC
19FCC:  MOVLB  0
19FCE:  CALL   4F56
....................    write16(ADDR_E1_TYPE,2); 
19FD2:  MOVLW  7A
19FD4:  MOVLB  8
19FD6:  MOVWF  xCB
19FD8:  CLRF   xCD
19FDA:  MOVLW  02
19FDC:  MOVWF  xCC
19FDE:  MOVLB  0
19FE0:  CALL   4F56
....................    write16(ADDR_M1_RUN,34); 
19FE4:  MOVLW  76
19FE6:  MOVLB  8
19FE8:  MOVWF  xCB
19FEA:  CLRF   xCD
19FEC:  MOVLW  22
19FEE:  MOVWF  xCC
19FF0:  MOVLB  0
19FF2:  CALL   4F56
....................    write16(ADDR_M1_BKLSH,0); 
19FF6:  MOVLW  72
19FF8:  MOVLB  8
19FFA:  MOVWF  xCB
19FFC:  CLRF   xCD
19FFE:  CLRF   xCC
1A000:  MOVLB  0
1A002:  CALL   4F56
....................    write16(ADDR_M1_ERROR,0);   
1A006:  MOVLW  6E
1A008:  MOVLB  8
1A00A:  MOVWF  xCB
1A00C:  CLRF   xCD
1A00E:  CLRF   xCC
1A010:  MOVLB  0
1A012:  CALL   4F56
....................    write16(ADDR_M1_SPR,6400); 
1A016:  MOVLW  AE
1A018:  MOVLB  8
1A01A:  MOVWF  xCB
1A01C:  MOVLW  19
1A01E:  MOVWF  xCD
1A020:  CLRF   xCC
1A022:  MOVLB  0
1A024:  CALL   4F56
....................    write16(ADDR_M1_COMP,0); 
1A028:  MOVLW  B2
1A02A:  MOVLB  8
1A02C:  MOVWF  xCB
1A02E:  CLRF   xCD
1A030:  CLRF   xCC
1A032:  MOVLB  0
1A034:  CALL   4F56
....................    write16(ADDR_M1_LIN_POS,0); 
1A038:  MOVLW  B6
1A03A:  MOVLB  8
1A03C:  MOVWF  xCB
1A03E:  CLRF   xCD
1A040:  CLRF   xCC
1A042:  MOVLB  0
1A044:  CALL   4F56
....................    write16(ADDR_E1_INDEX,1);    
1A048:  MOVLW  BA
1A04A:  MOVLB  8
1A04C:  MOVWF  xCB
1A04E:  CLRF   xCD
1A050:  MOVLW  01
1A052:  MOVWF  xCC
1A054:  MOVLB  0
1A056:  CALL   4F56
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A05A:  MOVLW  88
1A05C:  MOVLB  8
1A05E:  MOVWF  xCB
1A060:  CLRF   xCD
1A062:  MOVLW  01
1A064:  MOVWF  xCC
1A066:  MOVLB  0
1A068:  CALL   4F56
....................    write16(ADDR_M2_MODE,HALF); 
1A06C:  MOVLW  8C
1A06E:  MOVLB  8
1A070:  MOVWF  xCB
1A072:  CLRF   xCD
1A074:  MOVLW  01
1A076:  MOVWF  xCC
1A078:  MOVLB  0
1A07A:  CALL   4F56
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A07E:  MOVLW  90
1A080:  MOVLB  8
1A082:  MOVWF  xCB
1A084:  CLRF   xCD
1A086:  MOVLW  28
1A088:  MOVWF  xCC
1A08A:  MOVLB  0
1A08C:  CALL   4F56
....................    write16(ADDR_M2_POS_DIR,0); 
1A090:  MOVLW  94
1A092:  MOVLB  8
1A094:  MOVWF  xCB
1A096:  CLRF   xCD
1A098:  CLRF   xCC
1A09A:  MOVLB  0
1A09C:  CALL   4F56
....................    write16(ADDR_M2_PWM_HLD,0); 
1A0A0:  MOVLW  98
1A0A2:  MOVLB  8
1A0A4:  MOVWF  xCB
1A0A6:  CLRF   xCD
1A0A8:  CLRF   xCC
1A0AA:  MOVLB  0
1A0AC:  CALL   4F56
....................    write16(ADDR_M2_PWM_DRV,511); 
1A0B0:  MOVLW  9C
1A0B2:  MOVLB  8
1A0B4:  MOVWF  xCB
1A0B6:  MOVLW  01
1A0B8:  MOVWF  xCD
1A0BA:  SETF   xCC
1A0BC:  MOVLB  0
1A0BE:  CALL   4F56
....................    write16(ADDR_M2_GB_ERR,0); 
1A0C2:  MOVLW  A0
1A0C4:  MOVLB  8
1A0C6:  MOVWF  xCB
1A0C8:  CLRF   xCD
1A0CA:  CLRF   xCC
1A0CC:  MOVLB  0
1A0CE:  CALL   4F56
....................    write16(ADDR_E2_CPR,0); 
1A0D2:  MOVLW  A4
1A0D4:  MOVLB  8
1A0D6:  MOVWF  xCB
1A0D8:  CLRF   xCD
1A0DA:  CLRF   xCC
1A0DC:  MOVLB  0
1A0DE:  CALL   4F56
....................    write16(ADDR_E2_PPR,0);   
1A0E2:  MOVLW  A8
1A0E4:  MOVLB  8
1A0E6:  MOVWF  xCB
1A0E8:  CLRF   xCD
1A0EA:  CLRF   xCC
1A0EC:  MOVLB  0
1A0EE:  CALL   4F56
....................    write16(ADDR_E2_MODE,0); 
1A0F2:  MOVLW  84
1A0F4:  MOVLB  8
1A0F6:  MOVWF  xCB
1A0F8:  CLRF   xCD
1A0FA:  CLRF   xCC
1A0FC:  MOVLB  0
1A0FE:  CALL   4F56
....................    write16(ADDR_E2_POS,0); 
1A102:  MOVLW  80
1A104:  MOVLB  8
1A106:  MOVWF  xCB
1A108:  CLRF   xCD
1A10A:  CLRF   xCC
1A10C:  MOVLB  0
1A10E:  CALL   4F56
....................    write16(ADDR_E2_PORT,0); 
1A112:  MOVLW  AC
1A114:  MOVLB  8
1A116:  MOVWF  xCB
1A118:  CLRF   xCD
1A11A:  CLRF   xCC
1A11C:  MOVLB  0
1A11E:  CALL   4F56
....................    write16(ADDR_E2_TYPE,0); 
1A122:  MOVLW  7C
1A124:  MOVLB  8
1A126:  MOVWF  xCB
1A128:  CLRF   xCD
1A12A:  CLRF   xCC
1A12C:  MOVLB  0
1A12E:  CALL   4F56
....................    write16(ADDR_M2_RUN,0); 
1A132:  MOVLW  78
1A134:  MOVLB  8
1A136:  MOVWF  xCB
1A138:  CLRF   xCD
1A13A:  CLRF   xCC
1A13C:  MOVLB  0
1A13E:  CALL   4F56
....................    write16(ADDR_M2_BKLSH,0); 
1A142:  MOVLW  74
1A144:  MOVLB  8
1A146:  MOVWF  xCB
1A148:  CLRF   xCD
1A14A:  CLRF   xCC
1A14C:  MOVLB  0
1A14E:  CALL   4F56
....................    write16(ADDR_M2_ERROR,0);   
1A152:  MOVLW  70
1A154:  MOVLB  8
1A156:  MOVWF  xCB
1A158:  CLRF   xCD
1A15A:  CLRF   xCC
1A15C:  MOVLB  0
1A15E:  CALL   4F56
....................    write16(ADDR_M2_SPR,0); 
1A162:  MOVLW  B0
1A164:  MOVLB  8
1A166:  MOVWF  xCB
1A168:  CLRF   xCD
1A16A:  CLRF   xCC
1A16C:  MOVLB  0
1A16E:  CALL   4F56
....................    write16(ADDR_M2_COMP,0); 
1A172:  MOVLW  B4
1A174:  MOVLB  8
1A176:  MOVWF  xCB
1A178:  CLRF   xCD
1A17A:  CLRF   xCC
1A17C:  MOVLB  0
1A17E:  CALL   4F56
....................    write16(ADDR_M2_LIN_POS,0);   
1A182:  MOVLW  B8
1A184:  MOVLB  8
1A186:  MOVWF  xCB
1A188:  CLRF   xCD
1A18A:  CLRF   xCC
1A18C:  MOVLB  0
1A18E:  CALL   4F56
....................    write16(ADDR_E2_INDEX,0);    
1A192:  MOVLW  BC
1A194:  MOVLB  8
1A196:  MOVWF  xCB
1A198:  CLRF   xCD
1A19A:  CLRF   xCC
1A19C:  MOVLB  0
1A19E:  CALL   4F56
....................     
....................    get_step_vars(); 
1A1A2:  CALL   2CA2
1A1A6:  GOTO   1A744 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A1AA:  MOVLW  86
1A1AC:  MOVLB  8
1A1AE:  MOVWF  xCB
1A1B0:  CLRF   xCD
1A1B2:  MOVLW  01
1A1B4:  MOVWF  xCC
1A1B6:  MOVLB  0
1A1B8:  CALL   4F56
....................    write16(ADDR_M1_MODE,FULL); 
1A1BC:  MOVLW  8A
1A1BE:  MOVLB  8
1A1C0:  MOVWF  xCB
1A1C2:  CLRF   xCD
1A1C4:  CLRF   xCC
1A1C6:  MOVLB  0
1A1C8:  CALL   4F56
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A1CC:  MOVLW  8E
1A1CE:  MOVLB  8
1A1D0:  MOVWF  xCB
1A1D2:  CLRF   xCD
1A1D4:  MOVLW  0A
1A1D6:  MOVWF  xCC
1A1D8:  MOVLB  0
1A1DA:  CALL   4F56
....................    write16(ADDR_M1_POS_DIR,0); 
1A1DE:  MOVLW  92
1A1E0:  MOVLB  8
1A1E2:  MOVWF  xCB
1A1E4:  CLRF   xCD
1A1E6:  CLRF   xCC
1A1E8:  MOVLB  0
1A1EA:  CALL   4F56
....................    write16(ADDR_M1_PWM_HLD,0); 
1A1EE:  MOVLW  96
1A1F0:  MOVLB  8
1A1F2:  MOVWF  xCB
1A1F4:  CLRF   xCD
1A1F6:  CLRF   xCC
1A1F8:  MOVLB  0
1A1FA:  CALL   4F56
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A1FE:  MOVLW  9A
1A200:  MOVLB  8
1A202:  MOVWF  xCB
1A204:  CLRF   xCD
1A206:  MOVLW  7F
1A208:  MOVWF  xCC
1A20A:  MOVLB  0
1A20C:  CALL   4F56
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A210:  MOVLW  9E
1A212:  MOVLB  8
1A214:  MOVWF  xCB
1A216:  MOVLW  17
1A218:  MOVWF  xCD
1A21A:  MOVLW  70
1A21C:  MOVWF  xCC
1A21E:  MOVLB  0
1A220:  CALL   4F56
....................    write16(ADDR_E1_CPR,16); 
1A224:  MOVLW  A2
1A226:  MOVLB  8
1A228:  MOVWF  xCB
1A22A:  CLRF   xCD
1A22C:  MOVLW  10
1A22E:  MOVWF  xCC
1A230:  MOVLB  0
1A232:  CALL   4F56
....................    write16(ADDR_E1_PPR,16); 
1A236:  MOVLW  A6
1A238:  MOVLB  8
1A23A:  MOVWF  xCB
1A23C:  CLRF   xCD
1A23E:  MOVLW  10
1A240:  MOVWF  xCC
1A242:  MOVLB  0
1A244:  CALL   4F56
....................    write16(ADDR_E1_MODE,2); 
1A248:  MOVLW  82
1A24A:  MOVLB  8
1A24C:  MOVWF  xCB
1A24E:  CLRF   xCD
1A250:  MOVLW  02
1A252:  MOVWF  xCC
1A254:  MOVLB  0
1A256:  CALL   4F56
....................    write16(ADDR_E1_POS,0); 
1A25A:  MOVLW  7E
1A25C:  MOVLB  8
1A25E:  MOVWF  xCB
1A260:  CLRF   xCD
1A262:  CLRF   xCC
1A264:  MOVLB  0
1A266:  CALL   4F56
....................    write16(ADDR_E1_PORT,0); 
1A26A:  MOVLW  AA
1A26C:  MOVLB  8
1A26E:  MOVWF  xCB
1A270:  CLRF   xCD
1A272:  CLRF   xCC
1A274:  MOVLB  0
1A276:  CALL   4F56
....................    write16(ADDR_E1_TYPE,2); 
1A27A:  MOVLW  7A
1A27C:  MOVLB  8
1A27E:  MOVWF  xCB
1A280:  CLRF   xCD
1A282:  MOVLW  02
1A284:  MOVWF  xCC
1A286:  MOVLB  0
1A288:  CALL   4F56
....................    write16(ADDR_M1_RUN,270); 
1A28C:  MOVLW  76
1A28E:  MOVLB  8
1A290:  MOVWF  xCB
1A292:  MOVLW  01
1A294:  MOVWF  xCD
1A296:  MOVLW  0E
1A298:  MOVWF  xCC
1A29A:  MOVLB  0
1A29C:  CALL   4F56
....................    write16(ADDR_M1_BKLSH,0); 
1A2A0:  MOVLW  72
1A2A2:  MOVLB  8
1A2A4:  MOVWF  xCB
1A2A6:  CLRF   xCD
1A2A8:  CLRF   xCC
1A2AA:  MOVLB  0
1A2AC:  CALL   4F56
....................    write16(ADDR_M1_ERROR,0);   
1A2B0:  MOVLW  6E
1A2B2:  MOVLB  8
1A2B4:  MOVWF  xCB
1A2B6:  CLRF   xCD
1A2B8:  CLRF   xCC
1A2BA:  MOVLB  0
1A2BC:  CALL   4F56
....................    write16(ADDR_M1_SPR,38400); 
1A2C0:  MOVLW  AE
1A2C2:  MOVLB  8
1A2C4:  MOVWF  xCB
1A2C6:  MOVLW  96
1A2C8:  MOVWF  xCD
1A2CA:  CLRF   xCC
1A2CC:  MOVLB  0
1A2CE:  CALL   4F56
....................    write16(ADDR_M1_COMP,0); 
1A2D2:  MOVLW  B2
1A2D4:  MOVLB  8
1A2D6:  MOVWF  xCB
1A2D8:  CLRF   xCD
1A2DA:  CLRF   xCC
1A2DC:  MOVLB  0
1A2DE:  CALL   4F56
....................    write16(ADDR_M1_LIN_POS,0); 
1A2E2:  MOVLW  B6
1A2E4:  MOVLB  8
1A2E6:  MOVWF  xCB
1A2E8:  CLRF   xCD
1A2EA:  CLRF   xCC
1A2EC:  MOVLB  0
1A2EE:  CALL   4F56
....................    write16(ADDR_E1_INDEX,1); 
1A2F2:  MOVLW  BA
1A2F4:  MOVLB  8
1A2F6:  MOVWF  xCB
1A2F8:  CLRF   xCD
1A2FA:  MOVLW  01
1A2FC:  MOVWF  xCC
1A2FE:  MOVLB  0
1A300:  CALL   4F56
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A304:  MOVLW  88
1A306:  MOVLB  8
1A308:  MOVWF  xCB
1A30A:  CLRF   xCD
1A30C:  MOVLW  01
1A30E:  MOVWF  xCC
1A310:  MOVLB  0
1A312:  CALL   4F56
....................    write16(ADDR_M2_MODE,HALF); 
1A316:  MOVLW  8C
1A318:  MOVLB  8
1A31A:  MOVWF  xCB
1A31C:  CLRF   xCD
1A31E:  MOVLW  01
1A320:  MOVWF  xCC
1A322:  MOVLB  0
1A324:  CALL   4F56
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A328:  MOVLW  90
1A32A:  MOVLB  8
1A32C:  MOVWF  xCB
1A32E:  CLRF   xCD
1A330:  MOVLW  64
1A332:  MOVWF  xCC
1A334:  MOVLB  0
1A336:  CALL   4F56
....................    write16(ADDR_M2_POS_DIR,0); 
1A33A:  MOVLW  94
1A33C:  MOVLB  8
1A33E:  MOVWF  xCB
1A340:  CLRF   xCD
1A342:  CLRF   xCC
1A344:  MOVLB  0
1A346:  CALL   4F56
....................    write16(ADDR_M2_PWM_HLD,0); 
1A34A:  MOVLW  98
1A34C:  MOVLB  8
1A34E:  MOVWF  xCB
1A350:  CLRF   xCD
1A352:  CLRF   xCC
1A354:  MOVLB  0
1A356:  CALL   4F56
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A35A:  MOVLW  9C
1A35C:  MOVLB  8
1A35E:  MOVWF  xCB
1A360:  CLRF   xCD
1A362:  MOVLW  7F
1A364:  MOVWF  xCC
1A366:  MOVLB  0
1A368:  CALL   4F56
....................    write16(ADDR_M2_GB_ERR,0); 
1A36C:  MOVLW  A0
1A36E:  MOVLB  8
1A370:  MOVWF  xCB
1A372:  CLRF   xCD
1A374:  CLRF   xCC
1A376:  MOVLB  0
1A378:  CALL   4F56
....................    write16(ADDR_E2_CPR,0); 
1A37C:  MOVLW  A4
1A37E:  MOVLB  8
1A380:  MOVWF  xCB
1A382:  CLRF   xCD
1A384:  CLRF   xCC
1A386:  MOVLB  0
1A388:  CALL   4F56
....................    write16(ADDR_E2_PPR,0);   
1A38C:  MOVLW  A8
1A38E:  MOVLB  8
1A390:  MOVWF  xCB
1A392:  CLRF   xCD
1A394:  CLRF   xCC
1A396:  MOVLB  0
1A398:  CALL   4F56
....................    write16(ADDR_E2_MODE,0); 
1A39C:  MOVLW  84
1A39E:  MOVLB  8
1A3A0:  MOVWF  xCB
1A3A2:  CLRF   xCD
1A3A4:  CLRF   xCC
1A3A6:  MOVLB  0
1A3A8:  CALL   4F56
....................    write16(ADDR_E2_POS,0); 
1A3AC:  MOVLW  80
1A3AE:  MOVLB  8
1A3B0:  MOVWF  xCB
1A3B2:  CLRF   xCD
1A3B4:  CLRF   xCC
1A3B6:  MOVLB  0
1A3B8:  CALL   4F56
....................    write16(ADDR_E2_PORT,0); 
1A3BC:  MOVLW  AC
1A3BE:  MOVLB  8
1A3C0:  MOVWF  xCB
1A3C2:  CLRF   xCD
1A3C4:  CLRF   xCC
1A3C6:  MOVLB  0
1A3C8:  CALL   4F56
....................    write16(ADDR_E2_TYPE,0); 
1A3CC:  MOVLW  7C
1A3CE:  MOVLB  8
1A3D0:  MOVWF  xCB
1A3D2:  CLRF   xCD
1A3D4:  CLRF   xCC
1A3D6:  MOVLB  0
1A3D8:  CALL   4F56
....................    write16(ADDR_M2_RUN,0); 
1A3DC:  MOVLW  78
1A3DE:  MOVLB  8
1A3E0:  MOVWF  xCB
1A3E2:  CLRF   xCD
1A3E4:  CLRF   xCC
1A3E6:  MOVLB  0
1A3E8:  CALL   4F56
....................    write16(ADDR_M2_BKLSH,0); 
1A3EC:  MOVLW  74
1A3EE:  MOVLB  8
1A3F0:  MOVWF  xCB
1A3F2:  CLRF   xCD
1A3F4:  CLRF   xCC
1A3F6:  MOVLB  0
1A3F8:  CALL   4F56
....................    write16(ADDR_M2_ERROR,0);   
1A3FC:  MOVLW  70
1A3FE:  MOVLB  8
1A400:  MOVWF  xCB
1A402:  CLRF   xCD
1A404:  CLRF   xCC
1A406:  MOVLB  0
1A408:  CALL   4F56
....................    write16(ADDR_M2_SPR,0); 
1A40C:  MOVLW  B0
1A40E:  MOVLB  8
1A410:  MOVWF  xCB
1A412:  CLRF   xCD
1A414:  CLRF   xCC
1A416:  MOVLB  0
1A418:  CALL   4F56
....................    write16(ADDR_M2_COMP,0); 
1A41C:  MOVLW  B4
1A41E:  MOVLB  8
1A420:  MOVWF  xCB
1A422:  CLRF   xCD
1A424:  CLRF   xCC
1A426:  MOVLB  0
1A428:  CALL   4F56
....................    write16(ADDR_M2_LIN_POS,0);    
1A42C:  MOVLW  B8
1A42E:  MOVLB  8
1A430:  MOVWF  xCB
1A432:  CLRF   xCD
1A434:  CLRF   xCC
1A436:  MOVLB  0
1A438:  CALL   4F56
....................     
....................    get_step_vars(); 
1A43C:  CALL   2CA2
1A440:  GOTO   1A744 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A444:  MOVLW  86
1A446:  MOVLB  8
1A448:  MOVWF  xCB
1A44A:  CLRF   xCD
1A44C:  MOVLW  01
1A44E:  MOVWF  xCC
1A450:  MOVLB  0
1A452:  CALL   4F56
....................    write16(ADDR_M1_MODE,FULL); 
1A456:  MOVLW  8A
1A458:  MOVLB  8
1A45A:  MOVWF  xCB
1A45C:  CLRF   xCD
1A45E:  CLRF   xCC
1A460:  MOVLB  0
1A462:  CALL   4F56
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1A466:  MOVLW  8E
1A468:  MOVLB  8
1A46A:  MOVWF  xCB
1A46C:  CLRF   xCD
1A46E:  MOVLW  28
1A470:  MOVWF  xCC
1A472:  MOVLB  0
1A474:  CALL   4F56
....................    write16(ADDR_M1_POS_DIR,1); 
1A478:  MOVLW  92
1A47A:  MOVLB  8
1A47C:  MOVWF  xCB
1A47E:  CLRF   xCD
1A480:  MOVLW  01
1A482:  MOVWF  xCC
1A484:  MOVLB  0
1A486:  CALL   4F56
....................    write16(ADDR_M1_PWM_HLD,0); 
1A48A:  MOVLW  96
1A48C:  MOVLB  8
1A48E:  MOVWF  xCB
1A490:  CLRF   xCD
1A492:  CLRF   xCC
1A494:  MOVLB  0
1A496:  CALL   4F56
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A49A:  MOVLW  9A
1A49C:  MOVLB  8
1A49E:  MOVWF  xCB
1A4A0:  CLRF   xCD
1A4A2:  MOVLW  7F
1A4A4:  MOVWF  xCC
1A4A6:  MOVLB  0
1A4A8:  CALL   4F56
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1A4AC:  MOVLW  9E
1A4AE:  MOVLB  8
1A4B0:  MOVWF  xCB
1A4B2:  MOVLW  02
1A4B4:  MOVWF  xCD
1A4B6:  MOVLW  9E
1A4B8:  MOVWF  xCC
1A4BA:  MOVLB  0
1A4BC:  CALL   4F56
....................    write16(ADDR_E1_CPR,500); 
1A4C0:  MOVLW  A2
1A4C2:  MOVLB  8
1A4C4:  MOVWF  xCB
1A4C6:  MOVLW  01
1A4C8:  MOVWF  xCD
1A4CA:  MOVLW  F4
1A4CC:  MOVWF  xCC
1A4CE:  MOVLB  0
1A4D0:  CALL   4F56
....................    write16(ADDR_E1_PPR,50); 
1A4D4:  MOVLW  A6
1A4D6:  MOVLB  8
1A4D8:  MOVWF  xCB
1A4DA:  CLRF   xCD
1A4DC:  MOVLW  32
1A4DE:  MOVWF  xCC
1A4E0:  MOVLB  0
1A4E2:  CALL   4F56
....................    write16(ADDR_E1_MODE,2); 
1A4E6:  MOVLW  82
1A4E8:  MOVLB  8
1A4EA:  MOVWF  xCB
1A4EC:  CLRF   xCD
1A4EE:  MOVLW  02
1A4F0:  MOVWF  xCC
1A4F2:  MOVLB  0
1A4F4:  CALL   4F56
....................    write16(ADDR_E1_POS,0); 
1A4F8:  MOVLW  7E
1A4FA:  MOVLB  8
1A4FC:  MOVWF  xCB
1A4FE:  CLRF   xCD
1A500:  CLRF   xCC
1A502:  MOVLB  0
1A504:  CALL   4F56
....................    write16(ADDR_E1_PORT,0); 
1A508:  MOVLW  AA
1A50A:  MOVLB  8
1A50C:  MOVWF  xCB
1A50E:  CLRF   xCD
1A510:  CLRF   xCC
1A512:  MOVLB  0
1A514:  CALL   4F56
....................    write16(ADDR_E1_TYPE,1); 
1A518:  MOVLW  7A
1A51A:  MOVLB  8
1A51C:  MOVWF  xCB
1A51E:  CLRF   xCD
1A520:  MOVLW  01
1A522:  MOVWF  xCC
1A524:  MOVLB  0
1A526:  CALL   4F56
....................    write16(ADDR_M1_RUN,0); 
1A52A:  MOVLW  76
1A52C:  MOVLB  8
1A52E:  MOVWF  xCB
1A530:  CLRF   xCD
1A532:  CLRF   xCC
1A534:  MOVLB  0
1A536:  CALL   4F56
....................    write16(ADDR_M1_BKLSH,1300); 
1A53A:  MOVLW  72
1A53C:  MOVLB  8
1A53E:  MOVWF  xCB
1A540:  MOVLW  05
1A542:  MOVWF  xCD
1A544:  MOVLW  14
1A546:  MOVWF  xCC
1A548:  MOVLB  0
1A54A:  CALL   4F56
....................    write16(ADDR_M1_ERROR,0);   
1A54E:  MOVLW  6E
1A550:  MOVLB  8
1A552:  MOVWF  xCB
1A554:  CLRF   xCD
1A556:  CLRF   xCC
1A558:  MOVLB  0
1A55A:  CALL   4F56
....................    write16(ADDR_M1_SPR,20000); 
1A55E:  MOVLW  AE
1A560:  MOVLB  8
1A562:  MOVWF  xCB
1A564:  MOVLW  4E
1A566:  MOVWF  xCD
1A568:  MOVLW  20
1A56A:  MOVWF  xCC
1A56C:  MOVLB  0
1A56E:  CALL   4F56
....................    write16(ADDR_M1_COMP,0); 
1A572:  MOVLW  B2
1A574:  MOVLB  8
1A576:  MOVWF  xCB
1A578:  CLRF   xCD
1A57A:  CLRF   xCC
1A57C:  MOVLB  0
1A57E:  CALL   4F56
....................    write16(ADDR_M1_LIN_POS,0); 
1A582:  MOVLW  B6
1A584:  MOVLB  8
1A586:  MOVWF  xCB
1A588:  CLRF   xCD
1A58A:  CLRF   xCC
1A58C:  MOVLB  0
1A58E:  CALL   4F56
....................    write16(ADDR_E1_INDEX,0); 
1A592:  MOVLW  BA
1A594:  MOVLB  8
1A596:  MOVWF  xCB
1A598:  CLRF   xCD
1A59A:  CLRF   xCC
1A59C:  MOVLB  0
1A59E:  CALL   4F56
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A5A2:  MOVLW  88
1A5A4:  MOVLB  8
1A5A6:  MOVWF  xCB
1A5A8:  CLRF   xCD
1A5AA:  MOVLW  01
1A5AC:  MOVWF  xCC
1A5AE:  MOVLB  0
1A5B0:  CALL   4F56
....................    write16(ADDR_M2_MODE,HALF); 
1A5B4:  MOVLW  8C
1A5B6:  MOVLB  8
1A5B8:  MOVWF  xCB
1A5BA:  CLRF   xCD
1A5BC:  MOVLW  01
1A5BE:  MOVWF  xCC
1A5C0:  MOVLB  0
1A5C2:  CALL   4F56
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A5C6:  MOVLW  90
1A5C8:  MOVLB  8
1A5CA:  MOVWF  xCB
1A5CC:  CLRF   xCD
1A5CE:  MOVLW  28
1A5D0:  MOVWF  xCC
1A5D2:  MOVLB  0
1A5D4:  CALL   4F56
....................    write16(ADDR_M2_POS_DIR,1); 
1A5D8:  MOVLW  94
1A5DA:  MOVLB  8
1A5DC:  MOVWF  xCB
1A5DE:  CLRF   xCD
1A5E0:  MOVLW  01
1A5E2:  MOVWF  xCC
1A5E4:  MOVLB  0
1A5E6:  CALL   4F56
....................    write16(ADDR_M2_PWM_HLD,0); 
1A5EA:  MOVLW  98
1A5EC:  MOVLB  8
1A5EE:  MOVWF  xCB
1A5F0:  CLRF   xCD
1A5F2:  CLRF   xCC
1A5F4:  MOVLB  0
1A5F6:  CALL   4F56
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A5FA:  MOVLW  9C
1A5FC:  MOVLB  8
1A5FE:  MOVWF  xCB
1A600:  CLRF   xCD
1A602:  MOVLW  7F
1A604:  MOVWF  xCC
1A606:  MOVLB  0
1A608:  CALL   4F56
....................    write16(ADDR_M2_GB_ERR,0); 
1A60C:  MOVLW  A0
1A60E:  MOVLB  8
1A610:  MOVWF  xCB
1A612:  CLRF   xCD
1A614:  CLRF   xCC
1A616:  MOVLB  0
1A618:  CALL   4F56
....................    write16(ADDR_E2_CPR,0); 
1A61C:  MOVLW  A4
1A61E:  MOVLB  8
1A620:  MOVWF  xCB
1A622:  CLRF   xCD
1A624:  CLRF   xCC
1A626:  MOVLB  0
1A628:  CALL   4F56
....................    write16(ADDR_E2_PPR,0);   
1A62C:  MOVLW  A8
1A62E:  MOVLB  8
1A630:  MOVWF  xCB
1A632:  CLRF   xCD
1A634:  CLRF   xCC
1A636:  MOVLB  0
1A638:  CALL   4F56
....................    write16(ADDR_E2_MODE,0); 
1A63C:  MOVLW  84
1A63E:  MOVLB  8
1A640:  MOVWF  xCB
1A642:  CLRF   xCD
1A644:  CLRF   xCC
1A646:  MOVLB  0
1A648:  CALL   4F56
....................    write16(ADDR_E2_POS,0); 
1A64C:  MOVLW  80
1A64E:  MOVLB  8
1A650:  MOVWF  xCB
1A652:  CLRF   xCD
1A654:  CLRF   xCC
1A656:  MOVLB  0
1A658:  CALL   4F56
....................    write16(ADDR_E2_PORT,0); 
1A65C:  MOVLW  AC
1A65E:  MOVLB  8
1A660:  MOVWF  xCB
1A662:  CLRF   xCD
1A664:  CLRF   xCC
1A666:  MOVLB  0
1A668:  CALL   4F56
....................    write16(ADDR_E2_TYPE,0); 
1A66C:  MOVLW  7C
1A66E:  MOVLB  8
1A670:  MOVWF  xCB
1A672:  CLRF   xCD
1A674:  CLRF   xCC
1A676:  MOVLB  0
1A678:  CALL   4F56
....................    write16(ADDR_M2_RUN,0); 
1A67C:  MOVLW  78
1A67E:  MOVLB  8
1A680:  MOVWF  xCB
1A682:  CLRF   xCD
1A684:  CLRF   xCC
1A686:  MOVLB  0
1A688:  CALL   4F56
....................    write16(ADDR_M2_BKLSH,0); 
1A68C:  MOVLW  74
1A68E:  MOVLB  8
1A690:  MOVWF  xCB
1A692:  CLRF   xCD
1A694:  CLRF   xCC
1A696:  MOVLB  0
1A698:  CALL   4F56
....................    write16(ADDR_M2_ERROR,0);   
1A69C:  MOVLW  70
1A69E:  MOVLB  8
1A6A0:  MOVWF  xCB
1A6A2:  CLRF   xCD
1A6A4:  CLRF   xCC
1A6A6:  MOVLB  0
1A6A8:  CALL   4F56
....................    write16(ADDR_M2_SPR,0); 
1A6AC:  MOVLW  B0
1A6AE:  MOVLB  8
1A6B0:  MOVWF  xCB
1A6B2:  CLRF   xCD
1A6B4:  CLRF   xCC
1A6B6:  MOVLB  0
1A6B8:  CALL   4F56
....................    write16(ADDR_M2_COMP,0); 
1A6BC:  MOVLW  B4
1A6BE:  MOVLB  8
1A6C0:  MOVWF  xCB
1A6C2:  CLRF   xCD
1A6C4:  CLRF   xCC
1A6C6:  MOVLB  0
1A6C8:  CALL   4F56
....................    write16(ADDR_M2_LIN_POS,0);    
1A6CC:  MOVLW  B8
1A6CE:  MOVLB  8
1A6D0:  MOVWF  xCB
1A6D2:  CLRF   xCD
1A6D4:  CLRF   xCC
1A6D6:  MOVLB  0
1A6D8:  CALL   4F56
....................    write16(ADDR_E2_INDEX,0); 
1A6DC:  MOVLW  BC
1A6DE:  MOVLB  8
1A6E0:  MOVWF  xCB
1A6E2:  CLRF   xCD
1A6E4:  CLRF   xCC
1A6E6:  MOVLB  0
1A6E8:  CALL   4F56
....................     
....................    get_step_vars(); 
1A6EC:  CALL   2CA2
1A6F0:  GOTO   1A744 (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
02920:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
02922:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
02924:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
02926:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
02928:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
0292A:  BCF    F90.5
....................    set_pwm1_duty(0);    
0292C:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
0292E:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
02930:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
02932:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
02934:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
02936:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
02938:  BCF    F8D.5
....................    set_pwm2_duty(0);  
0293A:  MOVLB  F
0293C:  CLRF   x4F
....................  
....................    output_low(VENC1); 
0293E:  BCF    F8E.6
....................    output_low(VENC2);         
02940:  BCF    F8E.7
....................    output_low(VHBRDG); 
02942:  BCF    F8E.2
02944:  MOVLB  0
02946:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
01246:  BCF    FD8.0
01248:  MOVLB  7
0124A:  RLCF   x3C,W
0124C:  CLRF   03
0124E:  ADDLW  4A
01250:  MOVWF  FE9
01252:  MOVLW  07
01254:  ADDWFC 03,W
01256:  MOVWF  FEA
01258:  MOVFF  FEC,A10
0125C:  MOVF   FED,F
0125E:  MOVFF  FEF,A0F
01262:  MOVLB  A
01264:  MOVF   x0F,F
01266:  BTFSS  FD8.2
01268:  BRA    13F0
0126A:  MOVF   x10,F
0126C:  BTFSS  FD8.2
0126E:  BRA    13F0
....................       if(m_way[motor]==POS) { 
01270:  BCF    FD8.0
01272:  MOVLB  7
01274:  RLCF   x3C,W
01276:  CLRF   03
01278:  ADDLW  82
0127A:  MOVWF  FE9
0127C:  MOVLW  07
0127E:  ADDWFC 03,W
01280:  MOVWF  FEA
01282:  MOVFF  FEC,A10
01286:  MOVF   FED,F
01288:  MOVFF  FEF,A0F
0128C:  MOVLB  A
0128E:  MOVF   x0F,F
01290:  BNZ   132A
01292:  MOVF   x10,F
01294:  BNZ   132A
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
01296:  BCF    FD8.0
01298:  MOVLB  7
0129A:  RLCF   x3C,W
0129C:  CLRF   03
0129E:  ADDLW  BB
012A0:  MOVWF  FE9
012A2:  MOVLW  07
012A4:  ADDWFC 03,W
012A6:  MOVWF  FEA
012A8:  MOVFF  FEC,A10
012AC:  MOVF   FED,F
012AE:  MOVFF  FEF,A0F
012B2:  BCF    FD8.0
012B4:  RLCF   x3C,W
012B6:  CLRF   03
012B8:  ADDLW  5A
012BA:  MOVWF  FE9
012BC:  MOVLW  07
012BE:  ADDWFC 03,W
012C0:  MOVWF  FEA
012C2:  MOVFF  FEC,03
012C6:  MOVF   FED,F
012C8:  MOVFF  FEF,01
012CC:  MOVF   03,W
012CE:  MOVLB  A
012D0:  SUBWF  x10,W
012D2:  BNC   12F6
012D4:  BNZ   12DC
012D6:  MOVF   01,W
012D8:  SUBWF  x0F,W
012DA:  BNC   12F6
012DC:  BCF    FD8.0
012DE:  MOVLB  7
012E0:  RLCF   x3C,W
012E2:  CLRF   03
012E4:  ADDLW  BB
012E6:  MOVWF  FE9
012E8:  MOVLW  07
012EA:  ADDWFC 03,W
012EC:  MOVWF  FEA
012EE:  CLRF   FEC
012F0:  MOVF   FED,F
012F2:  CLRF   FEF
012F4:  MOVLB  A
....................          e_pos[motor]++; 
012F6:  BCF    FD8.0
012F8:  MOVLB  7
012FA:  RLCF   x3C,W
012FC:  CLRF   03
012FE:  ADDLW  BB
01300:  MOVWF  FE9
01302:  MOVLW  07
01304:  ADDWFC 03,W
01306:  MOVWF  FEA
01308:  MOVLW  01
0130A:  ADDWF  FEE,F
0130C:  BNC   1310
0130E:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
01310:  BCF    FD8.0
01312:  RLCF   x3C,W
01314:  CLRF   03
01316:  ADDLW  96
01318:  MOVWF  FE9
0131A:  MOVLW  07
0131C:  ADDWFC 03,W
0131E:  MOVWF  FEA
01320:  CLRF   FEC
01322:  MOVF   FED,F
01324:  CLRF   FEF
....................       } 
01326:  BRA    13EE
01328:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
0132A:  BCF    FD8.0
0132C:  MOVLB  7
0132E:  RLCF   x3C,W
01330:  CLRF   03
01332:  ADDLW  82
01334:  MOVWF  FE9
01336:  MOVLW  07
01338:  ADDWFC 03,W
0133A:  MOVWF  FEA
0133C:  MOVFF  FEC,A10
01340:  MOVF   FED,F
01342:  MOVFF  FEF,A0F
01346:  MOVLB  A
01348:  DECFSZ x0F,W
0134A:  BRA    13F0
0134C:  MOVF   x10,F
0134E:  BNZ   13F0
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01350:  BCF    FD8.0
01352:  MOVLB  7
01354:  RLCF   x3C,W
01356:  CLRF   03
01358:  ADDLW  BB
0135A:  MOVWF  FE9
0135C:  MOVLW  07
0135E:  ADDWFC 03,W
01360:  MOVWF  FEA
01362:  MOVFF  FEC,A10
01366:  MOVF   FED,F
01368:  MOVFF  FEF,A0F
0136C:  MOVLB  A
0136E:  MOVF   x0F,F
01370:  BNZ   13BC
01372:  MOVF   x10,F
01374:  BNZ   13BC
01376:  BCF    FD8.0
01378:  MOVLB  7
0137A:  RLCF   x3C,W
0137C:  CLRF   03
0137E:  ADDLW  BB
01380:  MOVWF  01
01382:  MOVLW  07
01384:  ADDWFC 03,F
01386:  MOVLB  A
01388:  MOVFF  03,A10
0138C:  BCF    FD8.0
0138E:  MOVLB  7
01390:  RLCF   x3C,W
01392:  CLRF   03
01394:  ADDLW  5A
01396:  MOVWF  FE9
01398:  MOVLW  07
0139A:  ADDWFC 03,W
0139C:  MOVWF  FEA
0139E:  MOVFF  FEC,03
013A2:  MOVF   FED,F
013A4:  MOVFF  FEF,A11
013A8:  MOVLB  A
013AA:  MOVFF  A10,FEA
013AE:  MOVFF  01,FE9
013B2:  MOVFF  03,FEC
013B6:  MOVF   FED,F
013B8:  MOVFF  A11,FEF
....................          e_pos[motor]--; 
013BC:  BCF    FD8.0
013BE:  MOVLB  7
013C0:  RLCF   x3C,W
013C2:  CLRF   03
013C4:  ADDLW  BB
013C6:  MOVWF  FE9
013C8:  MOVLW  07
013CA:  ADDWFC 03,W
013CC:  MOVWF  FEA
013CE:  MOVLW  FF
013D0:  ADDWF  FEF,F
013D2:  BC    13D8
013D4:  MOVF   FEE,F
013D6:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
013D8:  BCF    FD8.0
013DA:  RLCF   x3C,W
013DC:  CLRF   03
013DE:  ADDLW  96
013E0:  MOVWF  FE9
013E2:  MOVLW  07
013E4:  ADDWFC 03,W
013E6:  MOVWF  FEA
013E8:  CLRF   FEC
013EA:  MOVF   FED,F
013EC:  CLRF   FEF
013EE:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
013F0:  BCF    FD8.0
013F2:  MOVLB  7
013F4:  RLCF   x3C,W
013F6:  CLRF   03
013F8:  ADDLW  4A
013FA:  MOVWF  FE9
013FC:  MOVLW  07
013FE:  ADDWFC 03,W
01400:  MOVWF  FEA
01402:  MOVFF  FEC,A10
01406:  MOVF   FED,F
01408:  MOVFF  FEF,A0F
0140C:  MOVLB  A
0140E:  DECFSZ x0F,W
01410:  BRA    1598
01412:  MOVF   x10,F
01414:  BTFSS  FD8.2
01416:  BRA    1598
....................       if(m_way[motor]==NEG) { 
01418:  BCF    FD8.0
0141A:  MOVLB  7
0141C:  RLCF   x3C,W
0141E:  CLRF   03
01420:  ADDLW  82
01422:  MOVWF  FE9
01424:  MOVLW  07
01426:  ADDWFC 03,W
01428:  MOVWF  FEA
0142A:  MOVFF  FEC,A10
0142E:  MOVF   FED,F
01430:  MOVFF  FEF,A0F
01434:  MOVLB  A
01436:  DECFSZ x0F,W
01438:  BRA    14D2
0143A:  MOVF   x10,F
0143C:  BNZ   14D2
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
0143E:  BCF    FD8.0
01440:  MOVLB  7
01442:  RLCF   x3C,W
01444:  CLRF   03
01446:  ADDLW  BB
01448:  MOVWF  FE9
0144A:  MOVLW  07
0144C:  ADDWFC 03,W
0144E:  MOVWF  FEA
01450:  MOVFF  FEC,A10
01454:  MOVF   FED,F
01456:  MOVFF  FEF,A0F
0145A:  BCF    FD8.0
0145C:  RLCF   x3C,W
0145E:  CLRF   03
01460:  ADDLW  5A
01462:  MOVWF  FE9
01464:  MOVLW  07
01466:  ADDWFC 03,W
01468:  MOVWF  FEA
0146A:  MOVFF  FEC,03
0146E:  MOVF   FED,F
01470:  MOVFF  FEF,01
01474:  MOVF   03,W
01476:  MOVLB  A
01478:  SUBWF  x10,W
0147A:  BNC   149E
0147C:  BNZ   1484
0147E:  MOVF   01,W
01480:  SUBWF  x0F,W
01482:  BNC   149E
01484:  BCF    FD8.0
01486:  MOVLB  7
01488:  RLCF   x3C,W
0148A:  CLRF   03
0148C:  ADDLW  BB
0148E:  MOVWF  FE9
01490:  MOVLW  07
01492:  ADDWFC 03,W
01494:  MOVWF  FEA
01496:  CLRF   FEC
01498:  MOVF   FED,F
0149A:  CLRF   FEF
0149C:  MOVLB  A
....................          e_pos[motor]++; 
0149E:  BCF    FD8.0
014A0:  MOVLB  7
014A2:  RLCF   x3C,W
014A4:  CLRF   03
014A6:  ADDLW  BB
014A8:  MOVWF  FE9
014AA:  MOVLW  07
014AC:  ADDWFC 03,W
014AE:  MOVWF  FEA
014B0:  MOVLW  01
014B2:  ADDWF  FEE,F
014B4:  BNC   14B8
014B6:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014B8:  BCF    FD8.0
014BA:  RLCF   x3C,W
014BC:  CLRF   03
014BE:  ADDLW  96
014C0:  MOVWF  FE9
014C2:  MOVLW  07
014C4:  ADDWFC 03,W
014C6:  MOVWF  FEA
014C8:  CLRF   FEC
014CA:  MOVF   FED,F
014CC:  CLRF   FEF
....................       } 
014CE:  BRA    1596
014D0:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
014D2:  BCF    FD8.0
014D4:  MOVLB  7
014D6:  RLCF   x3C,W
014D8:  CLRF   03
014DA:  ADDLW  82
014DC:  MOVWF  FE9
014DE:  MOVLW  07
014E0:  ADDWFC 03,W
014E2:  MOVWF  FEA
014E4:  MOVFF  FEC,A10
014E8:  MOVF   FED,F
014EA:  MOVFF  FEF,A0F
014EE:  MOVLB  A
014F0:  MOVF   x0F,F
014F2:  BNZ   1598
014F4:  MOVF   x10,F
014F6:  BNZ   1598
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
014F8:  BCF    FD8.0
014FA:  MOVLB  7
014FC:  RLCF   x3C,W
014FE:  CLRF   03
01500:  ADDLW  BB
01502:  MOVWF  FE9
01504:  MOVLW  07
01506:  ADDWFC 03,W
01508:  MOVWF  FEA
0150A:  MOVFF  FEC,A10
0150E:  MOVF   FED,F
01510:  MOVFF  FEF,A0F
01514:  MOVLB  A
01516:  MOVF   x0F,F
01518:  BNZ   1564
0151A:  MOVF   x10,F
0151C:  BNZ   1564
0151E:  BCF    FD8.0
01520:  MOVLB  7
01522:  RLCF   x3C,W
01524:  CLRF   03
01526:  ADDLW  BB
01528:  MOVWF  01
0152A:  MOVLW  07
0152C:  ADDWFC 03,F
0152E:  MOVLB  A
01530:  MOVFF  03,A10
01534:  BCF    FD8.0
01536:  MOVLB  7
01538:  RLCF   x3C,W
0153A:  CLRF   03
0153C:  ADDLW  5A
0153E:  MOVWF  FE9
01540:  MOVLW  07
01542:  ADDWFC 03,W
01544:  MOVWF  FEA
01546:  MOVFF  FEC,03
0154A:  MOVF   FED,F
0154C:  MOVFF  FEF,A11
01550:  MOVLB  A
01552:  MOVFF  A10,FEA
01556:  MOVFF  01,FE9
0155A:  MOVFF  03,FEC
0155E:  MOVF   FED,F
01560:  MOVFF  A11,FEF
....................          e_pos[motor]--; 
01564:  BCF    FD8.0
01566:  MOVLB  7
01568:  RLCF   x3C,W
0156A:  CLRF   03
0156C:  ADDLW  BB
0156E:  MOVWF  FE9
01570:  MOVLW  07
01572:  ADDWFC 03,W
01574:  MOVWF  FEA
01576:  MOVLW  FF
01578:  ADDWF  FEF,F
0157A:  BC    1580
0157C:  MOVF   FEE,F
0157E:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
01580:  BCF    FD8.0
01582:  RLCF   x3C,W
01584:  CLRF   03
01586:  ADDLW  96
01588:  MOVWF  FE9
0158A:  MOVLW  07
0158C:  ADDWFC 03,W
0158E:  MOVWF  FEA
01590:  CLRF   FEC
01592:  MOVF   FED,F
01594:  CLRF   FEF
01596:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
01598:  MOVF   1F,W
0159A:  SUBLW  04
0159C:  BTFSS  FD8.2
0159E:  BRA    16D2
015A0:  MOVF   20,F
015A2:  BTFSS  FD8.2
015A4:  BRA    16D2
015A6:  BCF    FD8.0
015A8:  MOVLB  7
015AA:  RLCF   x3C,W
015AC:  CLRF   03
015AE:  ADDLW  66
015B0:  MOVWF  FE9
015B2:  MOVLW  07
015B4:  ADDWFC 03,W
015B6:  MOVWF  FEA
015B8:  MOVFF  FEC,A10
015BC:  MOVF   FED,F
015BE:  MOVFF  FEF,A0F
015C2:  MOVLB  A
015C4:  MOVF   x0F,W
015C6:  SUBLW  02
015C8:  BTFSS  FD8.2
015CA:  BRA    16D2
015CC:  MOVF   x10,F
015CE:  BTFSS  FD8.2
015D0:  BRA    16D2
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
015D2:  MOVLW  01
015D4:  MOVLB  7
015D6:  ADDWF  x3C,W
015D8:  MOVLB  A
015DA:  MOVWF  x0F
015DC:  MOVLB  7
015DE:  MOVF   x3C,W
015E0:  MULLW  04
015E2:  MOVF   FF3,W
015E4:  CLRF   03
015E6:  ADDLW  9E
015E8:  MOVWF  FE9
015EA:  MOVLW  07
015EC:  ADDWFC 03,W
015EE:  MOVWF  FEA
015F0:  MOVFF  FEF,A10
015F4:  MOVFF  FEC,A11
015F8:  MOVFF  FEC,A12
015FC:  MOVFF  FEC,A13
01600:  BCF    FD8.0
01602:  RLCF   x3C,W
01604:  CLRF   03
01606:  ADDLW  B7
01608:  MOVWF  FE9
0160A:  MOVLW  07
0160C:  ADDWFC 03,W
0160E:  MOVWF  FEA
01610:  MOVFF  FEC,A15
01614:  MOVF   FED,F
01616:  MOVFF  FEF,A14
0161A:  BCF    FD8.0
0161C:  RLCF   x3C,W
0161E:  CLRF   03
01620:  ADDLW  BB
01622:  MOVWF  FE9
01624:  MOVLW  07
01626:  ADDWFC 03,W
01628:  MOVWF  FEA
0162A:  MOVFF  FEC,A17
0162E:  MOVF   FED,F
01630:  MOVFF  FEF,A16
01634:  MOVLW  6D
01636:  BTFSS  F9E.4
01638:  BRA    1636
0163A:  MOVWF  FAD
0163C:  MOVLW  3A
0163E:  BTFSS  F9E.4
01640:  BRA    163E
01642:  MOVWF  FAD
01644:  MOVFF  A0F,A18
01648:  MOVLW  1B
0164A:  MOVLB  A
0164C:  MOVWF  x19
0164E:  MOVLB  0
01650:  RCALL  0F92
01652:  MOVLW  2C
01654:  BTFSS  F9E.4
01656:  BRA    1654
01658:  MOVWF  FAD
0165A:  MOVFF  7A6,A18
0165E:  MOVLW  1B
01660:  MOVLB  A
01662:  MOVWF  x19
01664:  MOVLB  0
01666:  RCALL  0F92
01668:  MOVLW  55
0166A:  MOVWF  FF6
0166C:  MOVLW  0F
0166E:  MOVWF  FF7
01670:  MOVLW  00
01672:  MOVWF  FF8
01674:  MOVLW  03
01676:  MOVLB  A
01678:  MOVWF  x18
0167A:  MOVLB  0
0167C:  RCALL  1010
0167E:  MOVLW  41
01680:  MOVWF  FE9
01682:  MOVFF  A13,A1B
01686:  MOVFF  A12,A1A
0168A:  MOVFF  A11,A19
0168E:  MOVFF  A10,A18
01692:  RCALL  10D6
01694:  MOVLW  2C
01696:  BTFSS  F9E.4
01698:  BRA    1696
0169A:  MOVWF  FAD
0169C:  MOVLW  10
0169E:  MOVWF  FE9
016A0:  MOVFF  A15,A19
016A4:  MOVFF  A14,A18
016A8:  RCALL  1192
016AA:  MOVLW  2C
016AC:  BTFSS  F9E.4
016AE:  BRA    16AC
016B0:  MOVWF  FAD
016B2:  MOVLW  10
016B4:  MOVWF  FE9
016B6:  MOVFF  A17,A19
016BA:  MOVFF  A16,A18
016BE:  RCALL  1192
016C0:  MOVLW  0D
016C2:  BTFSS  F9E.4
016C4:  BRA    16C2
016C6:  MOVWF  FAD
016C8:  MOVLW  0A
016CA:  BTFSS  F9E.4
016CC:  BRA    16CA
016CE:  MOVWF  FAD
016D0:  MOVLB  A
....................    }    
016D2:  MOVLB  0
016D4:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A6C2:  MOVLB  7
0A6C4:  MOVF   x3C,W
0A6C6:  XORLW  00
0A6C8:  MOVLB  0
0A6CA:  BZ    A6D2
0A6CC:  XORLW  01
0A6CE:  BZ    A762
0A6D0:  BRA    A7F0
....................       case 0 : if (e_type[motor]==1) { 
0A6D2:  BCF    FD8.0
0A6D4:  MOVLB  7
0A6D6:  RLCF   x3C,W
0A6D8:  CLRF   03
0A6DA:  ADDLW  66
0A6DC:  MOVWF  FE9
0A6DE:  MOVLW  07
0A6E0:  ADDWFC 03,W
0A6E2:  MOVWF  FEA
0A6E4:  MOVFF  FEC,8A5
0A6E8:  MOVF   FED,F
0A6EA:  MOVFF  FEF,8A4
0A6EE:  MOVLB  8
0A6F0:  DECFSZ xA4,W
0A6F2:  BRA    A712
0A6F4:  MOVF   xA5,F
0A6F6:  BNZ   A712
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A6F8:  CLRF   03
0A6FA:  MOVLB  7
0A6FC:  MOVF   x3C,W
0A6FE:  ADDLW  C7
0A700:  MOVWF  FE9
0A702:  MOVLW  07
0A704:  ADDWFC 03,W
0A706:  MOVWF  FEA
0A708:  MOVLW  00
0A70A:  BTFSC  F81.4
0A70C:  MOVLW  01
0A70E:  MOVWF  FEF
0A710:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A712:  BCF    FD8.0
0A714:  MOVLB  7
0A716:  RLCF   x3C,W
0A718:  CLRF   03
0A71A:  ADDLW  66
0A71C:  MOVWF  FE9
0A71E:  MOVLW  07
0A720:  ADDWFC 03,W
0A722:  MOVWF  FEA
0A724:  MOVFF  FEC,8A5
0A728:  MOVF   FED,F
0A72A:  MOVFF  FEF,8A4
0A72E:  MOVLB  8
0A730:  MOVF   xA4,W
0A732:  SUBLW  02
0A734:  BNZ   A75E
0A736:  MOVF   xA5,F
0A738:  BNZ   A75E
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A73A:  CLRF   03
0A73C:  MOVLB  7
0A73E:  MOVF   x3C,W
0A740:  ADDLW  C7
0A742:  MOVWF  FE9
0A744:  MOVLW  07
0A746:  ADDWFC 03,W
0A748:  MOVWF  FEA
0A74A:  MOVLW  00
0A74C:  BTFSC  F81.4
0A74E:  MOVLW  01
0A750:  MOVLB  8
0A752:  MOVWF  xA6
0A754:  MOVLW  00
0A756:  BTFSC  F81.1
0A758:  MOVLW  01
0A75A:  ANDWF  xA6,W
0A75C:  MOVWF  FEF
....................                } 
....................          break; 
0A75E:  MOVLB  0
0A760:  BRA    A7F0
....................       case 1 : if (e_type[motor]==1) { 
0A762:  BCF    FD8.0
0A764:  MOVLB  7
0A766:  RLCF   x3C,W
0A768:  CLRF   03
0A76A:  ADDLW  66
0A76C:  MOVWF  FE9
0A76E:  MOVLW  07
0A770:  ADDWFC 03,W
0A772:  MOVWF  FEA
0A774:  MOVFF  FEC,8A5
0A778:  MOVF   FED,F
0A77A:  MOVFF  FEF,8A4
0A77E:  MOVLB  8
0A780:  DECFSZ xA4,W
0A782:  BRA    A7A2
0A784:  MOVF   xA5,F
0A786:  BNZ   A7A2
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A788:  CLRF   03
0A78A:  MOVLB  7
0A78C:  MOVF   x3C,W
0A78E:  ADDLW  C7
0A790:  MOVWF  FE9
0A792:  MOVLW  07
0A794:  ADDWFC 03,W
0A796:  MOVWF  FEA
0A798:  MOVLW  00
0A79A:  BTFSC  F81.5
0A79C:  MOVLW  01
0A79E:  MOVWF  FEF
0A7A0:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A7A2:  BCF    FD8.0
0A7A4:  MOVLB  7
0A7A6:  RLCF   x3C,W
0A7A8:  CLRF   03
0A7AA:  ADDLW  66
0A7AC:  MOVWF  FE9
0A7AE:  MOVLW  07
0A7B0:  ADDWFC 03,W
0A7B2:  MOVWF  FEA
0A7B4:  MOVFF  FEC,8A5
0A7B8:  MOVF   FED,F
0A7BA:  MOVFF  FEF,8A4
0A7BE:  MOVLB  8
0A7C0:  MOVF   xA4,W
0A7C2:  SUBLW  02
0A7C4:  BNZ   A7EE
0A7C6:  MOVF   xA5,F
0A7C8:  BNZ   A7EE
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A7CA:  CLRF   03
0A7CC:  MOVLB  7
0A7CE:  MOVF   x3C,W
0A7D0:  ADDLW  C7
0A7D2:  MOVWF  FE9
0A7D4:  MOVLW  07
0A7D6:  ADDWFC 03,W
0A7D8:  MOVWF  FEA
0A7DA:  MOVLW  00
0A7DC:  BTFSC  F81.5
0A7DE:  MOVLW  01
0A7E0:  MOVLB  8
0A7E2:  MOVWF  xA6
0A7E4:  MOVLW  00
0A7E6:  BTFSC  F81.2
0A7E8:  MOVLW  01
0A7EA:  ANDWF  xA6,W
0A7EC:  MOVWF  FEF
....................                } 
....................          break; 
0A7EE:  MOVLB  0
....................    } 
0A7F0:  GOTO   A8AA (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017C2:  MOVLB  7
017C4:  MOVF   x3C,W
017C6:  XORLW  00
017C8:  MOVLB  0
017CA:  BZ    17D2
017CC:  XORLW  01
017CE:  BZ    1862
017D0:  BRA    18F0
....................       case 0 : if (e_type[motor]==1) { 
017D2:  BCF    FD8.0
017D4:  MOVLB  7
017D6:  RLCF   x3C,W
017D8:  CLRF   03
017DA:  ADDLW  66
017DC:  MOVWF  FE9
017DE:  MOVLW  07
017E0:  ADDWFC 03,W
017E2:  MOVWF  FEA
017E4:  MOVFF  FEC,A10
017E8:  MOVF   FED,F
017EA:  MOVFF  FEF,A0F
017EE:  MOVLB  A
017F0:  DECFSZ x0F,W
017F2:  BRA    1812
017F4:  MOVF   x10,F
017F6:  BNZ   1812
....................                   e_ch_n[motor]=input(ENC1_IND); 
017F8:  CLRF   03
017FA:  MOVLB  7
017FC:  MOVF   x3C,W
017FE:  ADDLW  C7
01800:  MOVWF  FE9
01802:  MOVLW  07
01804:  ADDWFC 03,W
01806:  MOVWF  FEA
01808:  MOVLW  00
0180A:  BTFSC  F81.4
0180C:  MOVLW  01
0180E:  MOVWF  FEF
01810:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01812:  BCF    FD8.0
01814:  MOVLB  7
01816:  RLCF   x3C,W
01818:  CLRF   03
0181A:  ADDLW  66
0181C:  MOVWF  FE9
0181E:  MOVLW  07
01820:  ADDWFC 03,W
01822:  MOVWF  FEA
01824:  MOVFF  FEC,A10
01828:  MOVF   FED,F
0182A:  MOVFF  FEF,A0F
0182E:  MOVLB  A
01830:  MOVF   x0F,W
01832:  SUBLW  02
01834:  BNZ   185E
01836:  MOVF   x10,F
01838:  BNZ   185E
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0183A:  CLRF   03
0183C:  MOVLB  7
0183E:  MOVF   x3C,W
01840:  ADDLW  C7
01842:  MOVWF  FE9
01844:  MOVLW  07
01846:  ADDWFC 03,W
01848:  MOVWF  FEA
0184A:  MOVLW  00
0184C:  BTFSC  F81.4
0184E:  MOVLW  01
01850:  MOVLB  A
01852:  MOVWF  x11
01854:  MOVLW  00
01856:  BTFSC  F81.1
01858:  MOVLW  01
0185A:  ANDWF  x11,W
0185C:  MOVWF  FEF
....................                } 
....................          break; 
0185E:  MOVLB  0
01860:  BRA    18F0
....................       case 1 : if (e_type[motor]==1) { 
01862:  BCF    FD8.0
01864:  MOVLB  7
01866:  RLCF   x3C,W
01868:  CLRF   03
0186A:  ADDLW  66
0186C:  MOVWF  FE9
0186E:  MOVLW  07
01870:  ADDWFC 03,W
01872:  MOVWF  FEA
01874:  MOVFF  FEC,A10
01878:  MOVF   FED,F
0187A:  MOVFF  FEF,A0F
0187E:  MOVLB  A
01880:  DECFSZ x0F,W
01882:  BRA    18A2
01884:  MOVF   x10,F
01886:  BNZ   18A2
....................                   e_ch_n[motor]=input(ENC2_IND); 
01888:  CLRF   03
0188A:  MOVLB  7
0188C:  MOVF   x3C,W
0188E:  ADDLW  C7
01890:  MOVWF  FE9
01892:  MOVLW  07
01894:  ADDWFC 03,W
01896:  MOVWF  FEA
01898:  MOVLW  00
0189A:  BTFSC  F81.5
0189C:  MOVLW  01
0189E:  MOVWF  FEF
018A0:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
018A2:  BCF    FD8.0
018A4:  MOVLB  7
018A6:  RLCF   x3C,W
018A8:  CLRF   03
018AA:  ADDLW  66
018AC:  MOVWF  FE9
018AE:  MOVLW  07
018B0:  ADDWFC 03,W
018B2:  MOVWF  FEA
018B4:  MOVFF  FEC,A10
018B8:  MOVF   FED,F
018BA:  MOVFF  FEF,A0F
018BE:  MOVLB  A
018C0:  MOVF   x0F,W
018C2:  SUBLW  02
018C4:  BNZ   18EE
018C6:  MOVF   x10,F
018C8:  BNZ   18EE
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018CA:  CLRF   03
018CC:  MOVLB  7
018CE:  MOVF   x3C,W
018D0:  ADDLW  C7
018D2:  MOVWF  FE9
018D4:  MOVLW  07
018D6:  ADDWFC 03,W
018D8:  MOVWF  FEA
018DA:  MOVLW  00
018DC:  BTFSC  F81.5
018DE:  MOVLW  01
018E0:  MOVLB  A
018E2:  MOVWF  x11
018E4:  MOVLW  00
018E6:  BTFSC  F81.2
018E8:  MOVLW  01
018EA:  ANDWF  x11,W
018EC:  MOVWF  FEF
....................                } 
....................          break; 
018EE:  MOVLB  0
....................    } 
018F0:  GOTO   1A3E (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
016D6:  BCF    FD8.0
016D8:  MOVLB  7
016DA:  RLCF   x3C,W
016DC:  CLRF   03
016DE:  ADDLW  B7
016E0:  MOVWF  FE9
016E2:  MOVLW  07
016E4:  ADDWFC 03,W
016E6:  MOVWF  FEA
016E8:  MOVLW  01
016EA:  ADDWF  FEE,F
016EC:  BNC   16F0
016EE:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
016F0:  MOVF   xA6,W
016F2:  XORLW  00
016F4:  MOVLB  0
016F6:  BZ    1702
016F8:  XORLW  01
016FA:  BZ    1708
016FC:  XORLW  03
016FE:  BZ    171A
01700:  BRA    1744
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
01702:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
01704:  BCF    FF0.0
....................          break; 
01706:  BRA    1744
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01708:  MOVLW  02
0170A:  MOVLB  7
0170C:  MOVWF  xA6
....................                disable_interrupts(INT_EXT1_L2H); 
0170E:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
01710:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
01712:  BSF    FF0.3
01714:  BCF    FF1.5
....................          break; 
01716:  MOVLB  0
01718:  BRA    1744
....................       case 2 : edge_mode=1; 
0171A:  MOVLW  01
0171C:  MOVLB  7
0171E:  MOVWF  xA6
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01720:  BCF    FD8.0
01722:  RLCF   x3C,W
01724:  CLRF   03
01726:  ADDLW  B7
01728:  MOVWF  FE9
0172A:  MOVLW  07
0172C:  ADDWFC 03,W
0172E:  MOVWF  FEA
01730:  MOVLW  FF
01732:  ADDWF  FEF,F
01734:  BC    173A
01736:  MOVF   FEE,F
01738:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
0173A:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
0173C:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
0173E:  BSF    FF0.3
01740:  BSF    FF1.5
....................          break; 
01742:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
01744:  RCALL  1246
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
01746:  BCF    FF0.0
01748:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
0174C:  BCF    FD8.0
0174E:  MOVLB  7
01750:  RLCF   x3C,W
01752:  CLRF   03
01754:  ADDLW  B7
01756:  MOVWF  FE9
01758:  MOVLW  07
0175A:  ADDWFC 03,W
0175C:  MOVWF  FEA
0175E:  MOVLW  01
01760:  ADDWF  FEE,F
01762:  BNC   1766
01764:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
01766:  MOVF   xA6,W
01768:  XORLW  00
0176A:  MOVLB  0
0176C:  BZ    1778
0176E:  XORLW  01
01770:  BZ    177E
01772:  XORLW  03
01774:  BZ    1790
01776:  BRA    17BA
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
01778:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
0177A:  BCF    FF0.1
....................          break; 
0177C:  BRA    17BA
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
0177E:  MOVLW  02
01780:  MOVLB  7
01782:  MOVWF  xA6
....................                disable_interrupts(INT_EXT2_L2H); 
01784:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
01786:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
01788:  BSF    FF0.4
0178A:  BCF    FF1.4
....................          break; 
0178C:  MOVLB  0
0178E:  BRA    17BA
....................       case 2 : edge_mode=1; 
01790:  MOVLW  01
01792:  MOVLB  7
01794:  MOVWF  xA6
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01796:  BCF    FD8.0
01798:  RLCF   x3C,W
0179A:  CLRF   03
0179C:  ADDLW  B7
0179E:  MOVWF  FE9
017A0:  MOVLW  07
017A2:  ADDWFC 03,W
017A4:  MOVWF  FEA
017A6:  MOVLW  FF
017A8:  ADDWF  FEF,F
017AA:  BC    17B0
017AC:  MOVF   FEE,F
017AE:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017B0:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017B2:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017B4:  BSF    FF0.4
017B6:  BSF    FF1.4
....................          break; 
017B8:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017BA:  RCALL  1246
.................... } 
....................  
.................... // motor step timer interrupt 
017BC:  BCF    FF0.1
017BE:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
018F4:  MOVLW  F9
018F6:  MOVWF  FB3
018F8:  MOVLW  C0
018FA:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
018FC:  BCF    FD8.0
018FE:  MOVLB  7
01900:  RLCF   x3C,W
01902:  CLRF   03
01904:  ADDLW  8A
01906:  MOVWF  FE9
01908:  MOVLW  07
0190A:  ADDWFC 03,W
0190C:  MOVWF  FEA
0190E:  MOVLW  01
01910:  ADDWF  FEE,F
01912:  BNC   1916
01914:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
01916:  BCF    FD8.0
01918:  RLCF   x3C,W
0191A:  CLRF   03
0191C:  ADDLW  8A
0191E:  MOVWF  FE9
01920:  MOVLW  07
01922:  ADDWFC 03,W
01924:  MOVWF  FEA
01926:  MOVFF  FEC,A10
0192A:  MOVF   FED,F
0192C:  MOVFF  FEF,A0F
01930:  BCF    FD8.0
01932:  RLCF   x3C,W
01934:  CLRF   03
01936:  ADDLW  46
01938:  MOVWF  FE9
0193A:  MOVLW  07
0193C:  ADDWFC 03,W
0193E:  MOVWF  FEA
01940:  MOVFF  FEC,03
01944:  MOVF   FED,F
01946:  MOVFF  FEF,01
0194A:  MOVF   03,W
0194C:  MOVLB  A
0194E:  SUBWF  x10,W
01950:  BTFSS  FD8.0
01952:  BRA    1A40
01954:  BNZ   195E
01956:  MOVF   01,W
01958:  SUBWF  x0F,W
0195A:  BTFSS  FD8.0
0195C:  BRA    1A40
....................    { 
....................       m_step_cnt[motor]++; 
0195E:  MOVLB  7
01960:  MOVF   x3C,W
01962:  MULLW  04
01964:  MOVF   FF3,W
01966:  CLRF   03
01968:  ADDLW  9E
0196A:  MOVWF  FE9
0196C:  MOVLW  07
0196E:  ADDWFC 03,W
01970:  MOVWF  FEA
01972:  MOVLW  01
01974:  ADDWF  FEE,F
01976:  MOVLW  00
01978:  ADDWFC FEE,F
0197A:  ADDWFC FEE,F
0197C:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
0197E:  BCF    FD8.0
01980:  RLCF   x3C,W
01982:  CLRF   03
01984:  ADDLW  96
01986:  MOVWF  FE9
01988:  MOVLW  07
0198A:  ADDWFC 03,W
0198C:  MOVWF  FEA
0198E:  MOVLW  01
01990:  ADDWF  FEE,F
01992:  BNC   1996
01994:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
01996:  BCF    FD8.0
01998:  RLCF   x3C,W
0199A:  CLRF   03
0199C:  ADDLW  8A
0199E:  MOVWF  FE9
019A0:  MOVLW  07
019A2:  ADDWFC 03,W
019A4:  MOVWF  FEA
019A6:  CLRF   FEC
019A8:  MOVF   FED,F
019AA:  CLRF   FEF
....................  
....................       if (motor==0) 
019AC:  MOVF   x3C,F
019AE:  BNZ   19B4
....................       { 
....................          output_toggle(M1_CLOCK); 
019B0:  BTG    F90.4
....................       } 
019B2:  BRA    1A14
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019B4:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019B6:  BCF    FD8.0
019B8:  RLCF   x3C,W
019BA:  CLRF   03
019BC:  ADDLW  82
019BE:  MOVWF  FE9
019C0:  MOVLW  07
019C2:  ADDWFC 03,W
019C4:  MOVWF  FEA
019C6:  MOVFF  FEC,A10
019CA:  MOVF   FED,F
019CC:  MOVFF  FEF,A0F
019D0:  MOVLB  A
019D2:  MOVF   x0F,F
019D4:  BNZ   19FA
019D6:  MOVF   x10,F
019D8:  BNZ   19FA
019DA:  BCF    FD8.0
019DC:  MOVLB  7
019DE:  RLCF   x3C,W
019E0:  CLRF   03
019E2:  ADDLW  AF
019E4:  MOVWF  FE9
019E6:  MOVLW  07
019E8:  ADDWFC 03,W
019EA:  MOVWF  FEA
019EC:  MOVLW  FF
019EE:  ADDWF  FEF,F
019F0:  BC    19F6
019F2:  MOVF   FEE,F
019F4:  DECF   FED,F
019F6:  BRA    1A14
019F8:  MOVLB  A
....................          else m_lin_pos[motor]++;          
019FA:  BCF    FD8.0
019FC:  MOVLB  7
019FE:  RLCF   x3C,W
01A00:  CLRF   03
01A02:  ADDLW  AF
01A04:  MOVWF  FE9
01A06:  MOVLW  07
01A08:  ADDWFC 03,W
01A0A:  MOVWF  FEA
01A0C:  MOVLW  01
01A0E:  ADDWF  FEE,F
01A10:  BNC   1A14
01A12:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A14:  BCF    FD8.0
01A16:  RLCF   x3C,W
01A18:  CLRF   03
01A1A:  ADDLW  62
01A1C:  MOVWF  FE9
01A1E:  MOVLW  07
01A20:  ADDWFC 03,W
01A22:  MOVWF  FEA
01A24:  MOVFF  FEC,A10
01A28:  MOVF   FED,F
01A2A:  MOVFF  FEF,A0F
01A2E:  MOVLB  A
01A30:  MOVF   x0F,W
01A32:  SUBLW  03
01A34:  BNZ   1A40
01A36:  MOVF   x10,F
01A38:  BNZ   1A40
01A3A:  MOVLB  0
01A3C:  BRA    17C2
01A3E:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A40:  BCF    FA1.1
01A42:  BCF    FA1.1
01A44:  MOVLB  0
01A46:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
08924:  BCF    FD8.0
08926:  MOVLB  7
08928:  RLCF   x3C,W
0892A:  CLRF   03
0892C:  ADDLW  4A
0892E:  MOVWF  FE9
08930:  MOVLW  07
08932:  ADDWFC 03,W
08934:  MOVWF  FEA
08936:  MOVFF  FEC,8B6
0893A:  MOVF   FED,F
0893C:  MOVFF  FEF,8B5
08940:  MOVLB  8
08942:  DECFSZ xB5,W
08944:  BRA    8994
08946:  MOVF   xB6,F
08948:  BNZ   8994
0894A:  BCF    FD8.0
0894C:  MOVLB  7
0894E:  RLCF   x3C,W
08950:  CLRF   03
08952:  ADDLW  82
08954:  MOVWF  01
08956:  MOVLW  07
08958:  ADDWFC 03,F
0895A:  MOVFF  01,8B5
0895E:  MOVLB  8
08960:  MOVFF  03,8B6
08964:  BCF    FD8.0
08966:  MOVLB  7
08968:  RLCF   x3C,W
0896A:  CLRF   03
0896C:  ADDLW  82
0896E:  MOVWF  FE9
08970:  MOVLW  07
08972:  ADDWFC 03,W
08974:  MOVWF  FEA
08976:  MOVF   FEF,F
08978:  BNZ   897E
0897A:  MOVF   FEC,F
0897C:  BZ    8982
0897E:  MOVLW  00
08980:  BRA    8984
08982:  MOVLW  01
08984:  MOVLB  8
08986:  MOVFF  8B6,FEA
0898A:  MOVFF  8B5,FE9
0898E:  CLRF   FEC
08990:  MOVF   FED,F
08992:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
08994:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
08996:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
08998:  BCF    FD8.0
0899A:  MOVLB  7
0899C:  RLCF   x3C,W
0899E:  CLRF   03
089A0:  ADDLW  3E
089A2:  MOVWF  FE9
089A4:  MOVLW  07
089A6:  ADDWFC 03,W
089A8:  MOVWF  FEA
089AA:  MOVF   FEF,F
089AC:  BNZ   89B6
089AE:  MOVF   FEC,F
089B0:  BNZ   89B6
089B2:  BCF    F90.2
089B4:  BRA    89B8
089B6:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
089B8:  BCF    FD8.0
089BA:  RLCF   x3C,W
089BC:  CLRF   03
089BE:  ADDLW  42
089C0:  MOVWF  FE9
089C2:  MOVLW  07
089C4:  ADDWFC 03,W
089C6:  MOVWF  FEA
089C8:  MOVF   FEF,F
089CA:  BNZ   89D4
089CC:  MOVF   FEC,F
089CE:  BNZ   89D4
089D0:  BCF    F90.3
089D2:  BRA    89D6
089D4:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
089D6:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
089D8:  BCF    FD8.0
089DA:  RLCF   x3C,W
089DC:  CLRF   03
089DE:  ADDLW  82
089E0:  MOVWF  FE9
089E2:  MOVLW  07
089E4:  ADDWFC 03,W
089E6:  MOVWF  FEA
089E8:  MOVF   FEF,F
089EA:  BNZ   89F4
089EC:  MOVF   FEC,F
089EE:  BNZ   89F4
089F0:  BCF    F90.5
089F2:  BRA    89F6
089F4:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
089F6:  BCF    FD8.0
089F8:  RLCF   x3C,W
089FA:  CLRF   03
089FC:  ADDLW  52
089FE:  MOVWF  FE9
08A00:  MOVLW  07
08A02:  ADDWFC 03,W
08A04:  MOVWF  FEA
08A06:  MOVFF  FEC,8B6
08A0A:  MOVF   FED,F
08A0C:  MOVFF  FEF,8B5
08A10:  MOVLB  8
08A12:  RRCF   xB6,F
08A14:  RRCF   xB5,F
08A16:  RRCF   xB6,F
08A18:  RRCF   xB5,F
08A1A:  RRCF   xB6,F
08A1C:  MOVFF  8B5,FBC
08A20:  RRCF   xB6,F
08A22:  RRCF   xB6,W
08A24:  ANDLW  30
08A26:  MOVWF  00
08A28:  MOVF   FBB,W
08A2A:  ANDLW  CF
08A2C:  IORWF  00,W
08A2E:  MOVWF  FBB
08A30:  MOVLB  0
08A32:  GOTO   8BBC (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08A36:  BCF    FD8.0
08A38:  MOVLB  7
08A3A:  RLCF   x3C,W
08A3C:  CLRF   03
08A3E:  ADDLW  4A
08A40:  MOVWF  FE9
08A42:  MOVLW  07
08A44:  ADDWFC 03,W
08A46:  MOVWF  FEA
08A48:  MOVFF  FEC,8B6
08A4C:  MOVF   FED,F
08A4E:  MOVFF  FEF,8B5
08A52:  MOVLB  8
08A54:  DECFSZ xB5,W
08A56:  BRA    8AA6
08A58:  MOVF   xB6,F
08A5A:  BNZ   8AA6
08A5C:  BCF    FD8.0
08A5E:  MOVLB  7
08A60:  RLCF   x3C,W
08A62:  CLRF   03
08A64:  ADDLW  82
08A66:  MOVWF  01
08A68:  MOVLW  07
08A6A:  ADDWFC 03,F
08A6C:  MOVFF  01,8B5
08A70:  MOVLB  8
08A72:  MOVFF  03,8B6
08A76:  BCF    FD8.0
08A78:  MOVLB  7
08A7A:  RLCF   x3C,W
08A7C:  CLRF   03
08A7E:  ADDLW  82
08A80:  MOVWF  FE9
08A82:  MOVLW  07
08A84:  ADDWFC 03,W
08A86:  MOVWF  FEA
08A88:  MOVF   FEF,F
08A8A:  BNZ   8A90
08A8C:  MOVF   FEC,F
08A8E:  BZ    8A94
08A90:  MOVLW  00
08A92:  BRA    8A96
08A94:  MOVLW  01
08A96:  MOVLB  8
08A98:  MOVFF  8B6,FEA
08A9C:  MOVFF  8B5,FE9
08AA0:  CLRF   FEC
08AA2:  MOVF   FED,F
08AA4:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08AA6:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08AA8:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08AAA:  BCF    FD8.0
08AAC:  MOVLB  7
08AAE:  RLCF   x3C,W
08AB0:  CLRF   03
08AB2:  ADDLW  3E
08AB4:  MOVWF  FE9
08AB6:  MOVLW  07
08AB8:  ADDWFC 03,W
08ABA:  MOVWF  FEA
08ABC:  MOVF   FEF,F
08ABE:  BNZ   8AC8
08AC0:  MOVF   FEC,F
08AC2:  BNZ   8AC8
08AC4:  BCF    F8D.2
08AC6:  BRA    8ACA
08AC8:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08ACA:  BCF    FD8.0
08ACC:  RLCF   x3C,W
08ACE:  CLRF   03
08AD0:  ADDLW  42
08AD2:  MOVWF  FE9
08AD4:  MOVLW  07
08AD6:  ADDWFC 03,W
08AD8:  MOVWF  FEA
08ADA:  MOVF   FEF,F
08ADC:  BNZ   8AE6
08ADE:  MOVF   FEC,F
08AE0:  BNZ   8AE6
08AE2:  BCF    F8D.3
08AE4:  BRA    8AE8
08AE6:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08AE8:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08AEA:  BCF    FD8.0
08AEC:  RLCF   x3C,W
08AEE:  CLRF   03
08AF0:  ADDLW  82
08AF2:  MOVWF  FE9
08AF4:  MOVLW  07
08AF6:  ADDWFC 03,W
08AF8:  MOVWF  FEA
08AFA:  MOVF   FEF,F
08AFC:  BNZ   8B06
08AFE:  MOVF   FEC,F
08B00:  BNZ   8B06
08B02:  BCF    F8D.5
08B04:  BRA    8B08
08B06:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08B08:  BCF    FD8.0
08B0A:  RLCF   x3C,W
08B0C:  CLRF   03
08B0E:  ADDLW  52
08B10:  MOVWF  FE9
08B12:  MOVLW  07
08B14:  ADDWFC 03,W
08B16:  MOVWF  FEA
08B18:  MOVFF  FEC,8B6
08B1C:  MOVF   FED,F
08B1E:  MOVFF  FEF,8B5
08B22:  MOVLB  8
08B24:  RRCF   xB6,F
08B26:  RRCF   xB5,F
08B28:  RRCF   xB6,F
08B2A:  RRCF   xB5,F
08B2C:  RRCF   xB6,F
08B2E:  MOVFF  8B5,F4F
08B32:  RRCF   xB6,F
08B34:  RRCF   xB6,W
08B36:  ANDLW  30
08B38:  MOVWF  00
08B3A:  MOVLB  F
08B3C:  MOVF   x4E,W
08B3E:  ANDLW  CF
08B40:  IORWF  00,W
08B42:  MOVWF  x4E
08B44:  MOVLB  0
08B46:  GOTO   8BBC (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
08910:  MOVLB  8
08912:  MOVF   xC9,F
08914:  BZ    891C
....................       output_bit(VENC1,ON); 
08916:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
08918:  BSF    F8E.7
....................    } 
0891A:  BRA    8920
....................    else {       
....................       output_bit(VENC1,OFF); 
0891C:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
0891E:  BCF    F8E.7
....................    } 
08920:  MOVLB  0
08922:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08CAA:  MOVLB  8
08CAC:  MOVF   xCA,F
08CAE:  BNZ   8CD6
08CB0:  MOVF   xCB,F
08CB2:  BNZ   8CD6
....................       edge_mode=0; 
08CB4:  MOVLB  7
08CB6:  CLRF   xA6
....................       switch (motor){ 
08CB8:  MOVF   x3C,W
08CBA:  XORLW  00
08CBC:  MOVLB  0
08CBE:  BZ    8CC6
08CC0:  XORLW  01
08CC2:  BZ    8CCE
08CC4:  BRA    8CD4
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08CC6:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08CC8:  BSF    FF0.3
08CCA:  BCF    FF1.5
....................             break; 
08CCC:  BRA    8CD4
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08CCE:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08CD0:  BSF    FF0.4
08CD2:  BCF    FF1.4
....................             break; 
08CD4:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08CD6:  DECFSZ xCA,W
08CD8:  BRA    8D00
08CDA:  MOVF   xCB,F
08CDC:  BNZ   8D00
....................       edge_mode=0; 
08CDE:  MOVLB  7
08CE0:  CLRF   xA6
....................       switch (motor){ 
08CE2:  MOVF   x3C,W
08CE4:  XORLW  00
08CE6:  MOVLB  0
08CE8:  BZ    8CF0
08CEA:  XORLW  01
08CEC:  BZ    8CF8
08CEE:  BRA    8CFE
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08CF0:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08CF2:  BSF    FF0.3
08CF4:  BSF    FF1.5
....................             break; 
08CF6:  BRA    8CFE
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08CF8:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08CFA:  BSF    FF0.4
08CFC:  BSF    FF1.4
....................             break; 
08CFE:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08D00:  MOVF   xCA,W
08D02:  SUBLW  02
08D04:  BNZ   8D56
08D06:  MOVF   xCB,F
08D08:  BNZ   8D56
08D0A:  BCF    FD8.0
08D0C:  MOVLB  7
08D0E:  RLCF   x3C,W
08D10:  CLRF   03
08D12:  ADDLW  66
08D14:  MOVWF  FE9
08D16:  MOVLW  07
08D18:  ADDWFC 03,W
08D1A:  MOVWF  FEA
08D1C:  MOVFF  FEC,8CD
08D20:  MOVF   FED,F
08D22:  MOVFF  FEF,8CC
08D26:  MOVLB  8
08D28:  MOVF   xCC,W
08D2A:  SUBLW  02
08D2C:  BNZ   8D56
08D2E:  MOVF   xCD,F
08D30:  BNZ   8D56
....................       edge_mode=1; 
08D32:  MOVLW  01
08D34:  MOVLB  7
08D36:  MOVWF  xA6
....................       switch (motor){ 
08D38:  MOVF   x3C,W
08D3A:  XORLW  00
08D3C:  MOVLB  0
08D3E:  BZ    8D46
08D40:  XORLW  01
08D42:  BZ    8D4E
08D44:  BRA    8D54
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08D46:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08D48:  BSF    FF0.3
08D4A:  BSF    FF1.5
....................             break; 
08D4C:  BRA    8D54
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08D4E:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08D50:  BSF    FF0.4
08D52:  BSF    FF1.4
....................             break; 
08D54:  MOVLB  8
....................       }  
....................    }     
08D56:  MOVLB  0
08D58:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08EC0:  MOVLB  7
08EC2:  MOVF   x3C,W
08EC4:  XORLW  00
08EC6:  MOVLB  0
08EC8:  BZ    8ED0
08ECA:  XORLW  01
08ECC:  BZ    8EFA
08ECE:  BRA    8F22
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08ED0:  BCF    FD8.0
08ED2:  MOVLB  7
08ED4:  RLCF   x3C,W
08ED6:  CLRF   03
08ED8:  ADDLW  92
08EDA:  MOVWF  FE9
08EDC:  MOVLW  07
08EDE:  ADDWFC 03,W
08EE0:  MOVWF  FEA
08EE2:  MOVFF  FEC,8CD
08EE6:  MOVF   FED,F
08EE8:  MOVFF  FEF,8CC
08EEC:  MOVLW  6E
08EEE:  MOVLB  8
08EF0:  MOVWF  xCB
08EF2:  MOVLB  0
08EF4:  CALL   4F56
....................          break; 
08EF8:  BRA    8F22
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08EFA:  BCF    FD8.0
08EFC:  MOVLB  7
08EFE:  RLCF   x3C,W
08F00:  CLRF   03
08F02:  ADDLW  92
08F04:  MOVWF  FE9
08F06:  MOVLW  07
08F08:  ADDWFC 03,W
08F0A:  MOVWF  FEA
08F0C:  MOVFF  FEC,8CD
08F10:  MOVF   FED,F
08F12:  MOVFF  FEF,8CC
08F16:  MOVLW  70
08F18:  MOVLB  8
08F1A:  MOVWF  xCB
08F1C:  MOVLB  0
08F1E:  CALL   4F56
....................          break;          
....................    } 
08F22:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08D5A:  MOVLB  8
08D5C:  MOVF   xC9,F
08D5E:  BNZ   8D7C
....................    { 
....................       switch (motor) 
08D60:  MOVLB  7
08D62:  MOVF   x3C,W
08D64:  XORLW  00
08D66:  MOVLB  0
08D68:  BZ    8D70
08D6A:  XORLW  01
08D6C:  BZ    8D76
08D6E:  BRA    8D7A
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08D70:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08D72:  BCF    FF0.3
....................             break; 
08D74:  BRA    8D7A
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08D76:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08D78:  BCF    FF0.4
....................             break; 
08D7A:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08D7C:  DECFSZ xC9,W
08D7E:  BRA    8DE4
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08D80:  BCF    FD8.0
08D82:  MOVLB  7
08D84:  RLCF   x3C,W
08D86:  CLRF   03
08D88:  ADDLW  66
08D8A:  MOVWF  FE9
08D8C:  MOVLW  07
08D8E:  ADDWFC 03,W
08D90:  MOVWF  FEA
08D92:  MOVFF  FEC,8CB
08D96:  MOVF   FED,F
08D98:  MOVFF  FEF,8CA
08D9C:  MOVLB  8
08D9E:  DECFSZ xCA,W
08DA0:  BRA    8DB0
08DA2:  MOVF   xCB,F
08DA4:  BNZ   8DB0
08DA6:  CLRF   xCB
08DA8:  CLRF   xCA
08DAA:  MOVLB  0
08DAC:  RCALL  8CAA
08DAE:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08DB0:  BCF    FD8.0
08DB2:  MOVLB  7
08DB4:  RLCF   x3C,W
08DB6:  CLRF   03
08DB8:  ADDLW  66
08DBA:  MOVWF  FE9
08DBC:  MOVLW  07
08DBE:  ADDWFC 03,W
08DC0:  MOVWF  FEA
08DC2:  MOVFF  FEC,8CB
08DC6:  MOVF   FED,F
08DC8:  MOVFF  FEF,8CA
08DCC:  MOVLB  8
08DCE:  MOVF   xCA,W
08DD0:  SUBLW  02
08DD2:  BNZ   8DE4
08DD4:  MOVF   xCB,F
08DD6:  BNZ   8DE4
08DD8:  CLRF   xCB
08DDA:  MOVLW  01
08DDC:  MOVWF  xCA
08DDE:  MOVLB  0
08DE0:  RCALL  8CAA
08DE2:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08DE4:  MOVF   xC9,W
08DE6:  SUBLW  02
08DE8:  BNZ   8E1E
08DEA:  BCF    FD8.0
08DEC:  MOVLB  7
08DEE:  RLCF   x3C,W
08DF0:  CLRF   03
08DF2:  ADDLW  66
08DF4:  MOVWF  FE9
08DF6:  MOVLW  07
08DF8:  ADDWFC 03,W
08DFA:  MOVWF  FEA
08DFC:  MOVFF  FEC,8CB
08E00:  MOVF   FED,F
08E02:  MOVFF  FEF,8CA
08E06:  MOVLB  8
08E08:  MOVF   xCA,W
08E0A:  SUBLW  02
08E0C:  BNZ   8E1E
08E0E:  MOVF   xCB,F
08E10:  BNZ   8E1E
....................    { 
....................       enable_enc_isr(2);   
08E12:  CLRF   xCB
08E14:  MOVLW  02
08E16:  MOVWF  xCA
08E18:  MOVLB  0
08E1A:  RCALL  8CAA
08E1C:  MOVLB  8
....................    } 
08E1E:  MOVLB  0
08E20:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08B4A:  BCF    FD8.0
08B4C:  MOVLB  7
08B4E:  RLCF   x3C,W
08B50:  CLRF   03
08B52:  ADDLW  8A
08B54:  MOVWF  FE9
08B56:  MOVLW  07
08B58:  ADDWFC 03,W
08B5A:  MOVWF  FEA
08B5C:  CLRF   FEC
08B5E:  MOVF   FED,F
08B60:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08B62:  BCF    FD8.0
08B64:  RLCF   x3C,W
08B66:  CLRF   03
08B68:  ADDLW  B7
08B6A:  MOVWF  FE9
08B6C:  MOVLW  07
08B6E:  ADDWFC 03,W
08B70:  MOVWF  FEA
08B72:  CLRF   FEC
08B74:  MOVF   FED,F
08B76:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08B78:  BCF    FD8.0
08B7A:  RLCF   x3C,W
08B7C:  CLRF   03
08B7E:  ADDLW  96
08B80:  MOVWF  FE9
08B82:  MOVLW  07
08B84:  ADDWFC 03,W
08B86:  MOVWF  FEA
08B88:  CLRF   FEC
08B8A:  MOVF   FED,F
08B8C:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08B8E:  BSF    F8E.1
....................    enc_pwr(ON); 
08B90:  MOVLW  01
08B92:  MOVLB  8
08B94:  MOVWF  xC9
08B96:  MOVLB  0
08B98:  RCALL  8910
....................    delay_ms(100); 
08B9A:  MOVLW  64
08B9C:  MOVLB  9
08B9E:  MOVWF  xC9
08BA0:  MOVLB  0
08BA2:  CALL   2898
....................     
....................    switch (motor){ 
08BA6:  MOVLB  7
08BA8:  MOVF   x3C,W
08BAA:  XORLW  00
08BAC:  MOVLB  0
08BAE:  BZ    8BB6
08BB0:  XORLW  01
08BB2:  BZ    8BBA
08BB4:  BRA    8BBC
....................       case 0 : motor_setup1(); 
08BB6:  BRA    8924
....................          break; 
08BB8:  BRA    8BBC
....................       case 1 : motor_setup2(); 
08BBA:  BRA    8A36
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08BBC:  BCF    FD8.0
08BBE:  MOVLB  7
08BC0:  RLCF   x3C,W
08BC2:  CLRF   03
08BC4:  ADDLW  86
08BC6:  MOVWF  FE9
08BC8:  MOVLW  07
08BCA:  ADDWFC 03,W
08BCC:  MOVWF  FEA
08BCE:  MOVFF  FEC,8B6
08BD2:  MOVF   FED,F
08BD4:  MOVFF  FEF,8B5
08BD8:  BCF    FD8.0
08BDA:  RLCF   x3C,W
08BDC:  CLRF   03
08BDE:  ADDLW  82
08BE0:  MOVWF  FE9
08BE2:  MOVLW  07
08BE4:  ADDWFC 03,W
08BE6:  MOVWF  FEA
08BE8:  MOVFF  FEC,03
08BEC:  MOVF   FED,F
08BEE:  MOVF   FEF,W
08BF0:  MOVLB  8
08BF2:  SUBWF  xB5,W
08BF4:  BNZ   8BFC
08BF6:  MOVF   03,W
08BF8:  SUBWF  xB6,W
08BFA:  BZ    8CA4
....................       m_way_rst[motor]=m_way[motor]; 
08BFC:  BCF    FD8.0
08BFE:  MOVLB  7
08C00:  RLCF   x3C,W
08C02:  CLRF   03
08C04:  ADDLW  86
08C06:  MOVWF  01
08C08:  MOVLW  07
08C0A:  ADDWFC 03,F
08C0C:  MOVLB  8
08C0E:  MOVFF  03,8B6
08C12:  BCF    FD8.0
08C14:  MOVLB  7
08C16:  RLCF   x3C,W
08C18:  CLRF   03
08C1A:  ADDLW  82
08C1C:  MOVWF  FE9
08C1E:  MOVLW  07
08C20:  ADDWFC 03,W
08C22:  MOVWF  FEA
08C24:  MOVFF  FEC,03
08C28:  MOVF   FED,F
08C2A:  MOVFF  FEF,8B7
08C2E:  MOVLB  8
08C30:  MOVFF  8B6,FEA
08C34:  MOVFF  01,FE9
08C38:  MOVFF  03,FEC
08C3C:  MOVF   FED,F
08C3E:  MOVFF  8B7,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08C42:  BCF    FD8.0
08C44:  MOVLB  7
08C46:  RLCF   x3C,W
08C48:  CLRF   03
08C4A:  ADDLW  9A
08C4C:  MOVWF  01
08C4E:  MOVLW  07
08C50:  ADDWFC 03,F
08C52:  MOVLB  8
08C54:  MOVFF  03,8B6
08C58:  BCF    FD8.0
08C5A:  MOVLB  7
08C5C:  RLCF   x3C,W
08C5E:  CLRF   03
08C60:  ADDLW  62
08C62:  MOVWF  FE9
08C64:  MOVLW  07
08C66:  ADDWFC 03,W
08C68:  MOVWF  FEA
08C6A:  MOVFF  FEC,03
08C6E:  MOVF   FED,F
08C70:  MOVFF  FEF,8B7
08C74:  MOVLB  8
08C76:  MOVFF  8B6,FEA
08C7A:  MOVFF  01,FE9
08C7E:  MOVFF  03,FEC
08C82:  MOVF   FED,F
08C84:  MOVFF  8B7,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08C88:  BCF    FD8.0
08C8A:  MOVLB  7
08C8C:  RLCF   x3C,W
08C8E:  CLRF   03
08C90:  ADDLW  62
08C92:  MOVWF  FE9
08C94:  MOVLW  07
08C96:  ADDWFC 03,W
08C98:  MOVWF  FEA
08C9A:  CLRF   FEC
08C9C:  MOVF   FED,F
08C9E:  MOVLW  05
08CA0:  MOVWF  FEF
08CA2:  MOVLB  8
....................    } 
08CA4:  MOVLB  0
08CA6:  GOTO   8E24 (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08E22:  BRA    8B4A
....................     
....................    m_comp[motor]=FALSE; 
08E24:  BCF    FD8.0
08E26:  MOVLB  7
08E28:  RLCF   x3C,W
08E2A:  CLRF   03
08E2C:  ADDLW  AB
08E2E:  MOVWF  FE9
08E30:  MOVLW  07
08E32:  ADDWFC 03,W
08E34:  MOVWF  FEA
08E36:  CLRF   FEC
08E38:  MOVF   FED,F
08E3A:  CLRF   FEF
....................     
....................    switch (motor){ 
08E3C:  MOVF   x3C,W
08E3E:  XORLW  00
08E40:  MOVLB  0
08E42:  BZ    8E4A
08E44:  XORLW  01
08E46:  BZ    8E5C
08E48:  BRA    8E6C
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08E4A:  MOVLW  B2
08E4C:  MOVLB  8
08E4E:  MOVWF  xCB
08E50:  CLRF   xCD
08E52:  CLRF   xCC
08E54:  MOVLB  0
08E56:  CALL   4F56
....................          break; 
08E5A:  BRA    8E6C
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08E5C:  MOVLW  B4
08E5E:  MOVLB  8
08E60:  MOVWF  xCB
08E62:  CLRF   xCD
08E64:  CLRF   xCC
08E66:  MOVLB  0
08E68:  CALL   4F56
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08E6C:  MOVLB  7
08E6E:  MOVF   x3C,W
08E70:  XORLW  00
08E72:  MOVLB  0
08E74:  BZ    8E7C
08E76:  XORLW  01
08E78:  BZ    8E80
08E7A:  BRA    8E82
....................       case 0 : output_bit(M1_ENABLE, ON); 
08E7C:  BSF    F90.1
....................          break; 
08E7E:  BRA    8E82
....................       case 1 : output_bit(M2_ENABLE, ON); 
08E80:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08E82:  MOVLW  32
08E84:  MOVLB  9
08E86:  MOVWF  xC9
08E88:  MOVLB  0
08E8A:  CALL   2898
....................     
....................    set_timer3(STEP_INTERVAL); 
08E8E:  MOVLW  F9
08E90:  MOVWF  FB3
08E92:  MOVLW  C0
08E94:  MOVWF  FB2
....................    enc_isr(int_mode); 
08E96:  MOVFF  8B4,8C9
08E9A:  RCALL  8D5A
....................    clear_interrupt(INT_TIMER3); 
08E9C:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08E9E:  BCF    FD8.0
08EA0:  MOVLB  7
08EA2:  RLCF   x3C,W
08EA4:  CLRF   03
08EA6:  ADDLW  8E
08EA8:  MOVWF  FE9
08EAA:  MOVLW  07
08EAC:  ADDWFC 03,W
08EAE:  MOVWF  FEA
08EB0:  CLRF   FEC
08EB2:  MOVF   FED,F
08EB4:  MOVLW  01
08EB6:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08EB8:  BSF    FA0.1
08EBA:  MOVLB  0
08EBC:  GOTO   A134 (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
08546:  MOVFF  8B7,8BF
0854A:  MOVFF  8B6,8BE
0854E:  MOVFF  8B5,8BD
08552:  MOVFF  8B4,8BC
....................    enc_res    = e_cpr[motor]; 
08556:  BCF    FD8.0
08558:  MOVLB  7
0855A:  RLCF   x3C,W
0855C:  CLRF   03
0855E:  ADDLW  5A
08560:  MOVWF  FE9
08562:  MOVLW  07
08564:  ADDWFC 03,W
08566:  MOVWF  FEA
08568:  MOVLB  8
0856A:  CLRF   xC3
0856C:  CLRF   xC2
0856E:  MOVFF  FEC,8C1
08572:  MOVF   FED,F
08574:  MOVFF  FEF,8C0
....................    ports      = e_ppr[motor]; 
08578:  BCF    FD8.0
0857A:  MOVLB  7
0857C:  RLCF   x3C,W
0857E:  CLRF   03
08580:  ADDLW  5E
08582:  MOVWF  FE9
08584:  MOVLW  07
08586:  ADDWFC 03,W
08588:  MOVWF  FEA
0858A:  MOVLB  8
0858C:  CLRF   xCB
0858E:  CLRF   xCA
08590:  MOVFF  FEC,8C9
08594:  MOVF   FED,F
08596:  MOVFF  FEF,8C8
....................     
....................    enc_res = enc_res * 1000; 
0859A:  MOVFF  8C3,9D6
0859E:  MOVFF  8C2,9D5
085A2:  MOVFF  8C1,9D4
085A6:  MOVFF  8C0,9D3
085AA:  MOVLB  9
085AC:  CLRF   xDA
085AE:  CLRF   xD9
085B0:  MOVLW  03
085B2:  MOVWF  xD8
085B4:  MOVLW  E8
085B6:  MOVWF  xD7
085B8:  MOVLB  0
085BA:  CALL   477C
085BE:  MOVFF  03,8C3
085C2:  MOVFF  02,8C2
085C6:  MOVFF  01,8C1
085CA:  MOVFF  00,8C0
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
085CE:  BCF    FD8.1
085D0:  CLRF   1B
085D2:  BTFSC  FF2.7
085D4:  BSF    1B.7
085D6:  BCF    FF2.7
085D8:  MOVFF  8C3,A27
085DC:  MOVFF  8C2,A26
085E0:  MOVFF  8C1,A25
085E4:  MOVFF  8C0,A24
085E8:  MOVFF  8CB,A2B
085EC:  MOVFF  8CA,A2A
085F0:  MOVFF  8C9,A29
085F4:  MOVFF  8C8,A28
085F8:  CALL   1042
085FC:  BTFSC  1B.7
085FE:  BSF    FF2.7
08600:  MOVFF  03,8BB
08604:  MOVFF  02,8BA
08608:  MOVFF  01,8B9
0860C:  MOVFF  00,8B8
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
08610:  MOVFF  8B7,9D6
08614:  MOVFF  8B6,9D5
08618:  MOVFF  8B5,9D4
0861C:  MOVFF  8B4,9D3
08620:  MOVFF  8BB,9DA
08624:  MOVFF  8BA,9D9
08628:  MOVFF  8B9,9D8
0862C:  MOVFF  8B8,9D7
08630:  CALL   477C
08634:  MOVLB  8
08636:  MOVF   xB8,W
08638:  SUBWF  00,W
0863A:  MOVWF  xBC
0863C:  MOVF   xB9,W
0863E:  SUBWFB 01,W
08640:  MOVWF  xBD
08642:  MOVF   xBA,W
08644:  SUBWFB 02,W
08646:  MOVWF  xBE
08648:  MOVF   xBB,W
0864A:  SUBWFB 03,W
0864C:  MOVWF  xBF
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
0864E:  BCF    FD8.1
08650:  CLRF   1B
08652:  BTFSC  FF2.7
08654:  BSF    1B.7
08656:  BCF    FF2.7
08658:  MOVFF  8BF,A27
0865C:  MOVFF  8BE,A26
08660:  MOVFF  8BD,A25
08664:  MOVFF  8BC,A24
08668:  MOVLB  A
0866A:  CLRF   x2B
0866C:  CLRF   x2A
0866E:  MOVLW  03
08670:  MOVWF  x29
08672:  MOVLW  E8
08674:  MOVWF  x28
08676:  MOVLB  0
08678:  CALL   1042
0867C:  BTFSC  1B.7
0867E:  BSF    FF2.7
08680:  MOVFF  03,8C7
08684:  MOVFF  02,8C6
08688:  MOVFF  01,8C5
0868C:  MOVFF  00,8C4
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
08690:  MOVFF  8C7,9D6
08694:  MOVFF  8C6,9D5
08698:  MOVFF  8C5,9D4
0869C:  MOVFF  8C4,9D3
086A0:  MOVLB  9
086A2:  CLRF   xDA
086A4:  CLRF   xD9
086A6:  MOVLW  03
086A8:  MOVWF  xD8
086AA:  MOVLW  E8
086AC:  MOVWF  xD7
086AE:  MOVLB  0
086B0:  CALL   477C
086B4:  MOVFF  03,8C7
086B8:  MOVFF  02,8C6
086BC:  MOVFF  01,8C5
086C0:  MOVFF  00,8C4
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
086C4:  MOVLB  8
086C6:  MOVF   xC4,W
086C8:  SUBWF  xBC,F
086CA:  MOVF   xC5,W
086CC:  SUBWFB xBD,F
086CE:  MOVF   xC6,W
086D0:  SUBWFB xBE,F
086D2:  MOVF   xC7,W
086D4:  SUBWFB xBF,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
086D6:  BCF    FD8.1
086D8:  CLRF   1B
086DA:  BTFSC  FF2.7
086DC:  BSF    1B.7
086DE:  BCF    FF2.7
086E0:  MOVFF  8C7,A27
086E4:  MOVFF  8C6,A26
086E8:  MOVFF  8C5,A25
086EC:  MOVFF  8C4,A24
086F0:  MOVLB  A
086F2:  CLRF   x2B
086F4:  CLRF   x2A
086F6:  MOVLW  03
086F8:  MOVWF  x29
086FA:  MOVLW  E8
086FC:  MOVWF  x28
086FE:  MOVLB  0
08700:  CALL   1042
08704:  BTFSC  1B.7
08706:  BSF    FF2.7
08708:  MOVFF  03,8C7
0870C:  MOVFF  02,8C6
08710:  MOVFF  01,8C5
08714:  MOVFF  00,8C4
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
08718:  MOVLB  8
0871A:  MOVF   xBF,F
0871C:  BNZ   8732
0871E:  MOVF   xBE,F
08720:  BNZ   8732
08722:  MOVF   xBD,W
08724:  SUBLW  00
08726:  BC    8742
08728:  XORLW  FF
0872A:  BNZ   8732
0872C:  MOVF   xBC,W
0872E:  SUBLW  F3
08730:  BC    8742
08732:  MOVLW  01
08734:  ADDWF  xC4,F
08736:  BTFSC  FD8.0
08738:  INCF   xC5,F
0873A:  BTFSC  FD8.2
0873C:  INCF   xC6,F
0873E:  BTFSC  FD8.2
08740:  INCF   xC7,F
....................    return(enc_pos); 
08742:  MOVFF  8C4,00
08746:  MOVFF  8C5,01
0874A:  MOVFF  8C6,02
0874E:  MOVFF  8C7,03
08752:  MOVLB  0
08754:  GOTO   A0BC (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
08758:  BCF    FD8.0
0875A:  MOVLB  7
0875C:  RLCF   x3C,W
0875E:  CLRF   03
08760:  ADDLW  BB
08762:  MOVWF  FE9
08764:  MOVLW  07
08766:  ADDWFC 03,W
08768:  MOVWF  FEA
0876A:  MOVFF  FEC,03
0876E:  MOVF   FED,F
08770:  MOVFF  FEF,01
08774:  MOVF   03,W
08776:  MOVLB  8
08778:  SUBWF  xB7,W
0877A:  BNC   8842
0877C:  BNZ   8784
0877E:  MOVF   xB6,W
08780:  SUBWF  01,W
08782:  BC    8842
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
08784:  BCF    FD8.0
08786:  MOVLB  7
08788:  RLCF   x3C,W
0878A:  CLRF   03
0878C:  ADDLW  BB
0878E:  MOVWF  FE9
08790:  MOVLW  07
08792:  ADDWFC 03,W
08794:  MOVWF  FEA
08796:  MOVFF  FEC,03
0879A:  MOVF   FED,F
0879C:  MOVF   FEF,W
0879E:  MOVLB  8
087A0:  SUBWF  xB6,W
087A2:  MOVWF  xB8
087A4:  MOVF   03,W
087A6:  SUBWFB xB7,W
087A8:  MOVWF  xB9
....................       if (e_pos_r > (e_cpr[motor]/2)) 
087AA:  BCF    FD8.0
087AC:  MOVLB  7
087AE:  RLCF   x3C,W
087B0:  CLRF   03
087B2:  ADDLW  5A
087B4:  MOVWF  FE9
087B6:  MOVLW  07
087B8:  ADDWFC 03,W
087BA:  MOVWF  FEA
087BC:  MOVFF  FEC,8BB
087C0:  MOVF   FED,F
087C2:  MOVFF  FEF,8BA
087C6:  BCF    FD8.0
087C8:  MOVLB  8
087CA:  RRCF   xBB,W
087CC:  MOVWF  03
087CE:  RRCF   xBA,W
087D0:  MOVWF  02
087D2:  MOVWF  01
087D4:  MOVF   03,W
087D6:  SUBWF  xB9,W
087D8:  BNC   8826
087DA:  BNZ   87E2
087DC:  MOVF   xB8,W
087DE:  SUBWF  01,W
087E0:  BC    8826
....................       { 
....................          m_way[motor] = NEG; 
087E2:  BCF    FD8.0
087E4:  MOVLB  7
087E6:  RLCF   x3C,W
087E8:  CLRF   03
087EA:  ADDLW  82
087EC:  MOVWF  FE9
087EE:  MOVLW  07
087F0:  ADDWFC 03,W
087F2:  MOVWF  FEA
087F4:  CLRF   FEC
087F6:  MOVF   FED,F
087F8:  MOVLW  01
087FA:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
087FC:  BCF    FD8.0
087FE:  RLCF   x3C,W
08800:  CLRF   03
08802:  ADDLW  5A
08804:  MOVWF  FE9
08806:  MOVLW  07
08808:  ADDWFC 03,W
0880A:  MOVWF  FEA
0880C:  MOVFF  FEC,8BB
08810:  MOVF   FED,F
08812:  MOVFF  FEF,8BA
08816:  MOVLB  8
08818:  MOVF   xB8,W
0881A:  SUBWF  xBA,W
0881C:  MOVWF  xB8
0881E:  MOVF   xB9,W
08820:  SUBWFB xBB,W
08822:  MOVWF  xB9
....................       } 
08824:  BRA    8840
....................       else 
....................       { 
....................          m_way[motor] = POS; 
08826:  BCF    FD8.0
08828:  MOVLB  7
0882A:  RLCF   x3C,W
0882C:  CLRF   03
0882E:  ADDLW  82
08830:  MOVWF  FE9
08832:  MOVLW  07
08834:  ADDWFC 03,W
08836:  MOVWF  FEA
08838:  CLRF   FEC
0883A:  MOVF   FED,F
0883C:  CLRF   FEF
0883E:  MOVLB  8
....................       } 
....................    } 
08840:  BRA    8902
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
08842:  BCF    FD8.0
08844:  MOVLB  7
08846:  RLCF   x3C,W
08848:  CLRF   03
0884A:  ADDLW  BB
0884C:  MOVWF  FE9
0884E:  MOVLW  07
08850:  ADDWFC 03,W
08852:  MOVWF  FEA
08854:  MOVFF  FEC,8BB
08858:  MOVF   FED,F
0885A:  MOVFF  FEF,8BA
0885E:  MOVLB  8
08860:  MOVF   xB6,W
08862:  SUBWF  xBA,W
08864:  MOVWF  xB8
08866:  MOVF   xB7,W
08868:  SUBWFB xBB,W
0886A:  MOVWF  xB9
....................       if (e_pos_r > (e_cpr[motor]/2)) 
0886C:  BCF    FD8.0
0886E:  MOVLB  7
08870:  RLCF   x3C,W
08872:  CLRF   03
08874:  ADDLW  5A
08876:  MOVWF  FE9
08878:  MOVLW  07
0887A:  ADDWFC 03,W
0887C:  MOVWF  FEA
0887E:  MOVFF  FEC,8BB
08882:  MOVF   FED,F
08884:  MOVFF  FEF,8BA
08888:  BCF    FD8.0
0888A:  MOVLB  8
0888C:  RRCF   xBB,W
0888E:  MOVWF  03
08890:  RRCF   xBA,W
08892:  MOVWF  02
08894:  MOVWF  01
08896:  MOVF   03,W
08898:  SUBWF  xB9,W
0889A:  BNC   88E6
0889C:  BNZ   88A4
0889E:  MOVF   xB8,W
088A0:  SUBWF  01,W
088A2:  BC    88E6
....................       { 
....................          m_way[motor] = POS; 
088A4:  BCF    FD8.0
088A6:  MOVLB  7
088A8:  RLCF   x3C,W
088AA:  CLRF   03
088AC:  ADDLW  82
088AE:  MOVWF  FE9
088B0:  MOVLW  07
088B2:  ADDWFC 03,W
088B4:  MOVWF  FEA
088B6:  CLRF   FEC
088B8:  MOVF   FED,F
088BA:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088BC:  BCF    FD8.0
088BE:  RLCF   x3C,W
088C0:  CLRF   03
088C2:  ADDLW  5A
088C4:  MOVWF  FE9
088C6:  MOVLW  07
088C8:  ADDWFC 03,W
088CA:  MOVWF  FEA
088CC:  MOVFF  FEC,8BB
088D0:  MOVF   FED,F
088D2:  MOVFF  FEF,8BA
088D6:  MOVLB  8
088D8:  MOVF   xB8,W
088DA:  SUBWF  xBA,W
088DC:  MOVWF  xB8
088DE:  MOVF   xB9,W
088E0:  SUBWFB xBB,W
088E2:  MOVWF  xB9
....................       } 
088E4:  BRA    8902
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
088E6:  BCF    FD8.0
088E8:  MOVLB  7
088EA:  RLCF   x3C,W
088EC:  CLRF   03
088EE:  ADDLW  82
088F0:  MOVWF  FE9
088F2:  MOVLW  07
088F4:  ADDWFC 03,W
088F6:  MOVWF  FEA
088F8:  CLRF   FEC
088FA:  MOVF   FED,F
088FC:  MOVLW  01
088FE:  MOVWF  FEF
08900:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
08902:  MOVFF  8B8,01
08906:  MOVFF  8B9,02
0890A:  MOVLB  0
0890C:  GOTO   A0E8 (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
09010:  BCF    FD8.0
09012:  MOVLB  7
09014:  RLCF   x3C,W
09016:  CLRF   03
09018:  ADDLW  8E
0901A:  MOVWF  FE9
0901C:  MOVLW  07
0901E:  ADDWFC 03,W
09020:  MOVWF  FEA
09022:  CLRF   FEC
09024:  MOVF   FED,F
09026:  CLRF   FEF
....................           
....................    switch (motor){ 
09028:  MOVF   x3C,W
0902A:  XORLW  00
0902C:  MOVLB  0
0902E:  BZ    9036
09030:  XORLW  01
09032:  BZ    90A0
09034:  BRA    910E
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
09036:  BCF    FD8.0
09038:  MOVLB  7
0903A:  RLCF   x3C,W
0903C:  CLRF   03
0903E:  ADDLW  4E
09040:  MOVWF  FE9
09042:  MOVLW  07
09044:  ADDWFC 03,W
09046:  MOVWF  FEA
09048:  MOVFF  FEC,8CA
0904C:  MOVF   FED,F
0904E:  MOVFF  FEF,8C9
09052:  MOVLB  8
09054:  MOVF   xC9,F
09056:  BNZ   905C
09058:  MOVF   xCA,F
0905A:  BZ    909A
0905C:  BCF    FD8.0
0905E:  MOVLB  7
09060:  RLCF   x3C,W
09062:  CLRF   03
09064:  ADDLW  4E
09066:  MOVWF  FE9
09068:  MOVLW  07
0906A:  ADDWFC 03,W
0906C:  MOVWF  FEA
0906E:  MOVFF  FEC,8CA
09072:  MOVF   FED,F
09074:  MOVFF  FEF,8C9
09078:  MOVLB  8
0907A:  RRCF   xCA,F
0907C:  RRCF   xC9,F
0907E:  RRCF   xCA,F
09080:  RRCF   xC9,F
09082:  RRCF   xCA,F
09084:  MOVFF  8C9,FBC
09088:  RRCF   xCA,F
0908A:  RRCF   xCA,W
0908C:  ANDLW  30
0908E:  MOVWF  00
09090:  MOVF   FBB,W
09092:  ANDLW  CF
09094:  IORWF  00,W
09096:  MOVWF  FBB
09098:  BRA    909C
....................                else output_bit(M1_ENABLE, OFF); 
0909A:  BCF    F90.1
....................          break;   
0909C:  MOVLB  0
0909E:  BRA    910E
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
090A0:  BCF    FD8.0
090A2:  MOVLB  7
090A4:  RLCF   x3C,W
090A6:  CLRF   03
090A8:  ADDLW  4E
090AA:  MOVWF  FE9
090AC:  MOVLW  07
090AE:  ADDWFC 03,W
090B0:  MOVWF  FEA
090B2:  MOVFF  FEC,8CA
090B6:  MOVF   FED,F
090B8:  MOVFF  FEF,8C9
090BC:  MOVLB  8
090BE:  MOVF   xC9,F
090C0:  BNZ   90C6
090C2:  MOVF   xCA,F
090C4:  BZ    9108
090C6:  BCF    FD8.0
090C8:  MOVLB  7
090CA:  RLCF   x3C,W
090CC:  CLRF   03
090CE:  ADDLW  4E
090D0:  MOVWF  FE9
090D2:  MOVLW  07
090D4:  ADDWFC 03,W
090D6:  MOVWF  FEA
090D8:  MOVFF  FEC,8CA
090DC:  MOVF   FED,F
090DE:  MOVFF  FEF,8C9
090E2:  MOVLB  8
090E4:  RRCF   xCA,F
090E6:  RRCF   xC9,F
090E8:  RRCF   xCA,F
090EA:  RRCF   xC9,F
090EC:  RRCF   xCA,F
090EE:  MOVFF  8C9,F4F
090F2:  RRCF   xCA,F
090F4:  RRCF   xCA,W
090F6:  ANDLW  30
090F8:  MOVWF  00
090FA:  MOVLB  F
090FC:  MOVF   x4E,W
090FE:  ANDLW  CF
09100:  IORWF  00,W
09102:  MOVWF  x4E
09104:  BRA    910C
09106:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
09108:  BCF    F8D.1
0910A:  MOVLB  F
....................          break; 
0910C:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
0910E:  BCF    FA0.1
....................    enc_isr(OFF); 
09110:  MOVLB  8
09112:  CLRF   xC9
09114:  MOVLB  0
09116:  RCALL  8D5A
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
09118:  MOVLB  7
0911A:  MOVF   x4E,F
0911C:  BNZ   912C
0911E:  MOVF   x4F,F
09120:  BNZ   912C
09122:  MOVF   x50,F
09124:  BNZ   912C
09126:  MOVF   x51,F
09128:  BNZ   912C
....................    { 
....................       output_bit(VMOT,OFF); 
0912A:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
0912C:  MOVLB  8
0912E:  CLRF   xC9
09130:  MOVLB  0
09132:  CALL   8910
....................  
....................    if(success==TRUE) 
09136:  MOVLB  8
09138:  DECFSZ xC8,W
0913A:  BRA    92D6
....................    { 
....................       m_error[motor]=FALSE; 
0913C:  BCF    FD8.0
0913E:  MOVLB  7
09140:  RLCF   x3C,W
09142:  CLRF   03
09144:  ADDLW  92
09146:  MOVWF  FE9
09148:  MOVLW  07
0914A:  ADDWFC 03,W
0914C:  MOVWF  FEA
0914E:  CLRF   FEC
09150:  MOVF   FED,F
09152:  CLRF   FEF
....................       wrt_m_error(); 
09154:  MOVLB  0
09156:  RCALL  8EC0
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
09158:  BCF    FD8.0
0915A:  MOVLB  7
0915C:  RLCF   x3C,W
0915E:  CLRF   03
09160:  ADDLW  62
09162:  MOVWF  FE9
09164:  MOVLW  07
09166:  ADDWFC 03,W
09168:  MOVWF  FEA
0916A:  MOVFF  FEC,8CA
0916E:  MOVF   FED,F
09170:  MOVFF  FEF,8C9
09174:  MOVLB  8
09176:  MOVF   xC9,W
09178:  SUBLW  03
0917A:  BNZ   91B2
0917C:  MOVF   xCA,F
0917E:  BNZ   91B2
....................       { 
....................          e_pos[motor] = 0; 
09180:  BCF    FD8.0
09182:  MOVLB  7
09184:  RLCF   x3C,W
09186:  CLRF   03
09188:  ADDLW  BB
0918A:  MOVWF  FE9
0918C:  MOVLW  07
0918E:  ADDWFC 03,W
09190:  MOVWF  FEA
09192:  CLRF   FEC
09194:  MOVF   FED,F
09196:  CLRF   FEF
....................          e_port[motor] = 1; 
09198:  BCF    FD8.0
0919A:  RLCF   x3C,W
0919C:  CLRF   03
0919E:  ADDLW  BF
091A0:  MOVWF  FE9
091A2:  MOVLW  07
091A4:  ADDWFC 03,W
091A6:  MOVWF  FEA
091A8:  CLRF   FEC
091AA:  MOVF   FED,F
091AC:  MOVLW  01
091AE:  MOVWF  FEF
091B0:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
091B2:  BCF    FD8.0
091B4:  MOVLB  7
091B6:  RLCF   x3C,W
091B8:  CLRF   03
091BA:  ADDLW  62
091BC:  MOVWF  FE9
091BE:  MOVLW  07
091C0:  ADDWFC 03,W
091C2:  MOVWF  FEA
091C4:  MOVFF  FEC,8CA
091C8:  MOVF   FED,F
091CA:  MOVFF  FEF,8C9
091CE:  MOVLB  8
091D0:  MOVF   xC9,W
091D2:  SUBLW  02
091D4:  BNZ   9220
091D6:  MOVF   xCA,F
091D8:  BNZ   9220
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
091DA:  BCF    FD8.0
091DC:  MOVLB  7
091DE:  RLCF   x3C,W
091E0:  CLRF   03
091E2:  ADDLW  BF
091E4:  MOVWF  01
091E6:  MOVLW  07
091E8:  ADDWFC 03,F
091EA:  MOVLB  8
091EC:  MOVFF  03,8CA
091F0:  BCF    FD8.0
091F2:  MOVLB  7
091F4:  RLCF   x3C,W
091F6:  CLRF   03
091F8:  ADDLW  C3
091FA:  MOVWF  FE9
091FC:  MOVLW  07
091FE:  ADDWFC 03,W
09200:  MOVWF  FEA
09202:  MOVFF  FEC,03
09206:  MOVF   FED,F
09208:  MOVFF  FEF,8CB
0920C:  MOVLB  8
0920E:  MOVFF  8CA,FEA
09212:  MOVFF  01,FE9
09216:  MOVFF  03,FEC
0921A:  MOVF   FED,F
0921C:  MOVFF  8CB,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
09220:  BCF    FD8.0
09222:  MOVLB  7
09224:  RLCF   x3C,W
09226:  CLRF   03
09228:  ADDLW  62
0922A:  MOVWF  FE9
0922C:  MOVLW  07
0922E:  ADDWFC 03,W
09230:  MOVWF  FEA
09232:  MOVFF  FEC,8CA
09236:  MOVF   FED,F
09238:  MOVFF  FEF,8C9
0923C:  MOVLB  8
0923E:  MOVF   xC9,W
09240:  SUBLW  02
09242:  BNZ   9248
09244:  MOVF   xCA,F
09246:  BZ    9270
09248:  BCF    FD8.0
0924A:  MOVLB  7
0924C:  RLCF   x3C,W
0924E:  CLRF   03
09250:  ADDLW  62
09252:  MOVWF  FE9
09254:  MOVLW  07
09256:  ADDWFC 03,W
09258:  MOVWF  FEA
0925A:  MOVFF  FEC,8CA
0925E:  MOVF   FED,F
09260:  MOVFF  FEF,8C9
09264:  MOVLB  8
09266:  MOVF   xC9,W
09268:  SUBLW  03
0926A:  BNZ   92D4
0926C:  MOVF   xCA,F
0926E:  BNZ   92D4
....................       { 
....................          switch(motor) 
09270:  MOVLB  7
09272:  MOVF   x3C,W
09274:  XORLW  00
09276:  MOVLB  0
09278:  BZ    9280
0927A:  XORLW  01
0927C:  BZ    92AA
0927E:  BRA    92D2
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09280:  MOVLW  7E
09282:  MOVLB  8
09284:  MOVWF  xCB
09286:  MOVFF  7BC,8CD
0928A:  MOVFF  7BB,8CC
0928E:  MOVLB  0
09290:  CALL   4F56
....................                      write16(ADDR_E1_PORT,e_port[0]); 
09294:  MOVLW  AA
09296:  MOVLB  8
09298:  MOVWF  xCB
0929A:  MOVFF  7C0,8CD
0929E:  MOVFF  7BF,8CC
092A2:  MOVLB  0
092A4:  CALL   4F56
....................                break; 
092A8:  BRA    92D2
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
092AA:  MOVLW  80
092AC:  MOVLB  8
092AE:  MOVWF  xCB
092B0:  MOVFF  7BE,8CD
092B4:  MOVFF  7BD,8CC
092B8:  MOVLB  0
092BA:  CALL   4F56
....................                      write16(ADDR_E2_PORT,e_port[1]); 
092BE:  MOVLW  AC
092C0:  MOVLB  8
092C2:  MOVWF  xCB
092C4:  MOVFF  7C2,8CD
092C8:  MOVFF  7C1,8CC
092CC:  MOVLB  0
092CE:  CALL   4F56
....................                break;             
092D2:  MOVLB  8
....................          } 
....................       } 
....................    } 
092D4:  BRA    937E
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
092D6:  BCF    FD8.0
092D8:  MOVLB  7
092DA:  RLCF   x3C,W
092DC:  CLRF   03
092DE:  ADDLW  92
092E0:  MOVWF  FE9
092E2:  MOVLW  07
092E4:  ADDWFC 03,W
092E6:  MOVWF  FEA
092E8:  CLRF   FEC
092EA:  MOVF   FED,F
092EC:  MOVLW  01
092EE:  MOVWF  FEF
....................       e_pos[motor] = 0; 
092F0:  BCF    FD8.0
092F2:  RLCF   x3C,W
092F4:  CLRF   03
092F6:  ADDLW  BB
092F8:  MOVWF  FE9
092FA:  MOVLW  07
092FC:  ADDWFC 03,W
092FE:  MOVWF  FEA
09300:  CLRF   FEC
09302:  MOVF   FED,F
09304:  CLRF   FEF
....................       e_port[motor] = 0; 
09306:  BCF    FD8.0
09308:  RLCF   x3C,W
0930A:  CLRF   03
0930C:  ADDLW  BF
0930E:  MOVWF  FE9
09310:  MOVLW  07
09312:  ADDWFC 03,W
09314:  MOVWF  FEA
09316:  CLRF   FEC
09318:  MOVF   FED,F
0931A:  CLRF   FEF
....................       switch(motor) 
0931C:  MOVF   x3C,W
0931E:  XORLW  00
09320:  MOVLB  0
09322:  BZ    932A
09324:  XORLW  01
09326:  BZ    9354
09328:  BRA    937C
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
0932A:  MOVLW  7E
0932C:  MOVLB  8
0932E:  MOVWF  xCB
09330:  MOVFF  7BC,8CD
09334:  MOVFF  7BB,8CC
09338:  MOVLB  0
0933A:  CALL   4F56
....................                   write16(ADDR_E1_PORT,e_port[0]); 
0933E:  MOVLW  AA
09340:  MOVLB  8
09342:  MOVWF  xCB
09344:  MOVFF  7C0,8CD
09348:  MOVFF  7BF,8CC
0934C:  MOVLB  0
0934E:  CALL   4F56
....................             break; 
09352:  BRA    937C
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
09354:  MOVLW  80
09356:  MOVLB  8
09358:  MOVWF  xCB
0935A:  MOVFF  7BE,8CD
0935E:  MOVFF  7BD,8CC
09362:  MOVLB  0
09364:  CALL   4F56
....................                   write16(ADDR_E2_PORT,e_port[1]); 
09368:  MOVLW  AC
0936A:  MOVLB  8
0936C:  MOVWF  xCB
0936E:  MOVFF  7C2,8CD
09372:  MOVFF  7C1,8CC
09376:  MOVLB  0
09378:  CALL   4F56
....................             break;             
0937C:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
0937E:  BCF    FD8.0
09380:  MOVLB  7
09382:  RLCF   x3C,W
09384:  CLRF   03
09386:  ADDLW  AB
09388:  MOVWF  FE9
0938A:  MOVLW  07
0938C:  ADDWFC 03,W
0938E:  MOVWF  FEA
09390:  CLRF   FEC
09392:  MOVF   FED,F
09394:  MOVLW  01
09396:  MOVWF  FEF
....................     
....................    switch (motor) 
09398:  MOVF   x3C,W
0939A:  XORLW  00
0939C:  MOVLB  0
0939E:  BZ    93A6
093A0:  XORLW  01
093A2:  BZ    93CE
093A4:  BRA    93F4
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
093A6:  MOVLW  B2
093A8:  MOVLB  8
093AA:  MOVWF  xCB
093AC:  CLRF   xCD
093AE:  MOVLW  01
093B0:  MOVWF  xCC
093B2:  MOVLB  0
093B4:  CALL   4F56
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
093B8:  MOVLW  B6
093BA:  MOVLB  8
093BC:  MOVWF  xCB
093BE:  MOVFF  7B0,8CD
093C2:  MOVFF  7AF,8CC
093C6:  MOVLB  0
093C8:  CALL   4F56
....................          break; 
093CC:  BRA    93F4
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
093CE:  MOVLW  B4
093D0:  MOVLB  8
093D2:  MOVWF  xCB
093D4:  CLRF   xCD
093D6:  MOVLW  01
093D8:  MOVWF  xCC
093DA:  MOVLB  0
093DC:  CALL   4F56
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
093E0:  MOVLW  B8
093E2:  MOVLB  8
093E4:  MOVWF  xCB
093E6:  MOVFF  7B2,8CD
093EA:  MOVFF  7B1,8CC
093EE:  MOVLB  0
093F0:  CALL   4F56
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
093F4:  MOVF   1F,W
093F6:  SUBLW  04
093F8:  BNZ   949E
093FA:  MOVF   20,F
093FC:  BNZ   949E
....................    { 
....................       if(motor==1) 
093FE:  MOVLB  7
09400:  DECFSZ x3C,W
09402:  BRA    94A0
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
09404:  BCF    FD8.0
09406:  RLCF   x3C,W
09408:  CLRF   03
0940A:  ADDLW  AB
0940C:  MOVWF  FE9
0940E:  MOVLW  07
09410:  ADDWFC 03,W
09412:  MOVWF  FEA
09414:  MOVFF  FEC,8CA
09418:  MOVF   FED,F
0941A:  MOVFF  FEF,8C9
0941E:  BCF    FD8.0
09420:  RLCF   x3C,W
09422:  CLRF   03
09424:  ADDLW  AF
09426:  MOVWF  FE9
09428:  MOVLW  07
0942A:  ADDWFC 03,W
0942C:  MOVWF  FEA
0942E:  MOVFF  FEC,8CC
09432:  MOVF   FED,F
09434:  MOVFF  FEF,8CB
09438:  MOVLW  4A
0943A:  MOVWF  FF6
0943C:  MOVLW  1A
0943E:  MOVWF  FF7
09440:  MOVLW  00
09442:  MOVWF  FF8
09444:  CLRF   1B
09446:  BTFSC  FF2.7
09448:  BSF    1B.7
0944A:  BCF    FF2.7
0944C:  MOVLW  05
0944E:  MOVLB  A
09450:  MOVWF  x18
09452:  MOVLB  0
09454:  CALL   1010
09458:  BTFSC  1B.7
0945A:  BSF    FF2.7
0945C:  MOVLW  10
0945E:  MOVWF  FE9
09460:  CLRF   1B
09462:  BTFSC  FF2.7
09464:  BSF    1B.7
09466:  BCF    FF2.7
09468:  MOVFF  8CA,A19
0946C:  MOVFF  8C9,A18
09470:  CALL   1192
09474:  BTFSC  1B.7
09476:  BSF    FF2.7
09478:  MOVLW  2C
0947A:  BTFSS  F9E.4
0947C:  BRA    947A
0947E:  MOVWF  FAD
09480:  MOVLW  10
09482:  MOVWF  FE9
09484:  MOVFF  8CC,8CE
09488:  MOVFF  8CB,8CD
0948C:  RCALL  8F24
0948E:  MOVLW  0D
09490:  BTFSS  F9E.4
09492:  BRA    9490
09494:  MOVWF  FAD
09496:  MOVLW  0A
09498:  BTFSS  F9E.4
0949A:  BRA    9498
0949C:  MOVWF  FAD
0949E:  MOVLB  7
....................       } 
....................    } 
094A0:  MOVLB  0
094A2:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
095D0:  BCF    FD8.0
095D2:  MOVLB  7
095D4:  RLCF   x3C,W
095D6:  CLRF   03
095D8:  ADDLW  66
095DA:  MOVWF  FE9
095DC:  MOVLW  07
095DE:  ADDWFC 03,W
095E0:  MOVWF  FEA
095E2:  MOVFF  FEC,8C9
095E6:  MOVF   FED,F
095E8:  MOVFF  FEF,8C8
095EC:  MOVLB  8
095EE:  DECFSZ xC8,W
095F0:  BRA    9600
095F2:  MOVF   xC9,F
095F4:  BNZ   9600
095F6:  MOVLW  01
095F8:  MOVWF  xC8
095FA:  MOVLB  0
095FC:  RCALL  9010
095FE:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
09600:  BCF    FD8.0
09602:  MOVLB  7
09604:  RLCF   x3C,W
09606:  CLRF   03
09608:  ADDLW  66
0960A:  MOVWF  FE9
0960C:  MOVLW  07
0960E:  ADDWFC 03,W
09610:  MOVWF  FEA
09612:  MOVFF  FEC,8C9
09616:  MOVF   FED,F
09618:  MOVFF  FEF,8C8
0961C:  MOVLB  8
0961E:  MOVF   xC8,W
09620:  SUBLW  02
09622:  BTFSS  FD8.2
09624:  BRA    9C2E
09626:  MOVF   xC9,F
09628:  BTFSS  FD8.2
0962A:  BRA    9C2E
....................       if (e_mode[motor]==2){ 
0962C:  BCF    FD8.0
0962E:  MOVLB  7
09630:  RLCF   x3C,W
09632:  CLRF   03
09634:  ADDLW  62
09636:  MOVWF  FE9
09638:  MOVLW  07
0963A:  ADDWFC 03,W
0963C:  MOVWF  FEA
0963E:  MOVFF  FEC,8C9
09642:  MOVF   FED,F
09644:  MOVFF  FEF,8C8
09648:  MOVLB  8
0964A:  MOVF   xC8,W
0964C:  SUBLW  02
0964E:  BTFSS  FD8.2
09650:  BRA    9BAA
09652:  MOVF   xC9,F
09654:  BTFSS  FD8.2
09656:  BRA    9BAA
....................          if(nv_product==ECO || nv_product==WMS2){ 
09658:  MOVF   2F,F
0965A:  BNZ   9660
0965C:  MOVF   30,F
0965E:  BZ    966E
09660:  MOVF   2F,W
09662:  SUBLW  03
09664:  BTFSS  FD8.2
09666:  BRA    97B2
09668:  MOVF   30,F
0966A:  BTFSS  FD8.2
0966C:  BRA    97B2
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
0966E:  BCF    FD8.0
09670:  MOVLB  7
09672:  RLCF   x3C,W
09674:  CLRF   03
09676:  ADDLW  A7
09678:  MOVWF  FE9
0967A:  MOVLW  07
0967C:  ADDWFC 03,W
0967E:  MOVWF  FEA
09680:  MOVFF  FEC,9D4
09684:  MOVF   FED,F
09686:  MOVFF  FEF,9D3
0968A:  MOVFF  FEA,8CB
0968E:  MOVFF  FE9,8CA
09692:  MOVLB  9
09694:  CLRF   xD6
09696:  CLRF   xD5
09698:  MOVFF  8B9,9DA
0969C:  MOVFF  8B8,9D9
096A0:  MOVFF  8B7,9D8
096A4:  MOVFF  8B6,9D7
096A8:  MOVLB  0
096AA:  CALL   477C
096AE:  MOVFF  8CB,FEA
096B2:  MOVFF  8CA,FE9
096B6:  MOVFF  03,8CB
096BA:  MOVFF  02,8CA
096BE:  MOVFF  01,8C9
096C2:  MOVFF  00,8C8
096C6:  BCF    FD8.0
096C8:  MOVLB  7
096CA:  RLCF   x3C,W
096CC:  CLRF   03
096CE:  ADDLW  A7
096D0:  MOVWF  FE9
096D2:  MOVLW  07
096D4:  ADDWFC 03,W
096D6:  MOVWF  FEA
096D8:  MOVFF  FEC,8CD
096DC:  MOVF   FED,F
096DE:  MOVFF  FEF,8CC
096E2:  BCF    FD8.0
096E4:  MOVLB  8
096E6:  RRCF   xCD,W
096E8:  MOVWF  03
096EA:  RRCF   xCC,W
096EC:  MOVWF  02
096EE:  ADDWF  00,W
096F0:  MOVWF  00
096F2:  MOVF   03,W
096F4:  ADDWFC 01,W
096F6:  MOVWF  01
096F8:  MOVLW  00
096FA:  ADDWFC xCA,W
096FC:  MOVWF  02
096FE:  MOVLW  00
09700:  ADDWFC xCB,W
09702:  MOVWF  xC3
09704:  MOVFF  02,8C2
09708:  MOVFF  01,8C1
0970C:  MOVFF  00,8C0
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
09710:  BCF    FD8.0
09712:  MOVLB  7
09714:  RLCF   x3C,W
09716:  CLRF   03
09718:  ADDLW  A7
0971A:  MOVWF  FE9
0971C:  MOVLW  07
0971E:  ADDWFC 03,W
09720:  MOVWF  FEA
09722:  MOVFF  FEC,9D4
09726:  MOVF   FED,F
09728:  MOVFF  FEF,9D3
0972C:  MOVFF  FEA,8CB
09730:  MOVFF  FE9,8CA
09734:  MOVLB  9
09736:  CLRF   xD6
09738:  CLRF   xD5
0973A:  MOVFF  8B9,9DA
0973E:  MOVFF  8B8,9D9
09742:  MOVFF  8B7,9D8
09746:  MOVFF  8B6,9D7
0974A:  MOVLB  0
0974C:  CALL   477C
09750:  MOVFF  8CB,FEA
09754:  MOVFF  8CA,FE9
09758:  MOVFF  03,8CB
0975C:  MOVFF  02,8CA
09760:  MOVFF  01,8C9
09764:  MOVFF  00,8C8
09768:  BCF    FD8.0
0976A:  MOVLB  7
0976C:  RLCF   x3C,W
0976E:  CLRF   03
09770:  ADDLW  A7
09772:  MOVWF  FE9
09774:  MOVLW  07
09776:  ADDWFC 03,W
09778:  MOVWF  FEA
0977A:  MOVFF  FEC,8CD
0977E:  MOVF   FED,F
09780:  MOVFF  FEF,8CC
09784:  BCF    FD8.0
09786:  MOVLB  8
09788:  RRCF   xCD,W
0978A:  MOVWF  03
0978C:  RRCF   xCC,W
0978E:  MOVWF  02
09790:  SUBWF  00,W
09792:  MOVWF  00
09794:  MOVF   03,W
09796:  SUBWFB 01,W
09798:  MOVWF  01
0979A:  MOVLW  00
0979C:  SUBWFB xCA,W
0979E:  MOVWF  02
097A0:  MOVLW  00
097A2:  SUBWFB xCB,W
097A4:  MOVWF  xC7
097A6:  MOVFF  02,8C6
097AA:  MOVFF  01,8C5
097AE:  MOVFF  00,8C4
....................          } 
....................          if (nv_product==WMS4){ 
097B2:  DECFSZ 2F,W
097B4:  BRA    99CC
097B6:  MOVF   30,F
097B8:  BTFSS  FD8.2
097BA:  BRA    99CC
....................             if (end_even_port==FALSE){ 
097BC:  MOVLB  2
097BE:  MOVF   xD7,F
097C0:  BNZ   98B6
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
097C2:  BCF    FD8.0
097C4:  MOVLB  7
097C6:  RLCF   x3C,W
097C8:  CLRF   03
097CA:  ADDLW  A7
097CC:  MOVWF  FE9
097CE:  MOVLW  07
097D0:  ADDWFC 03,W
097D2:  MOVWF  FEA
097D4:  MOVFF  FEC,9EA
097D8:  MOVF   FED,F
097DA:  MOVFF  FEF,9E9
097DE:  MOVFF  8BB,9EC
097E2:  MOVFF  8BA,9EB
097E6:  MOVLB  0
097E8:  CALL   5C18
097EC:  MOVFF  02,8C9
097F0:  MOVFF  01,8C8
097F4:  BCF    FD8.0
097F6:  MOVLB  7
097F8:  RLCF   x3C,W
097FA:  CLRF   03
097FC:  ADDLW  A7
097FE:  MOVWF  FE9
09800:  MOVLW  07
09802:  ADDWFC 03,W
09804:  MOVWF  FEA
09806:  MOVFF  FEC,8CB
0980A:  MOVF   FED,F
0980C:  MOVFF  FEF,8CA
09810:  BCF    FD8.0
09812:  MOVLB  8
09814:  RRCF   xCB,W
09816:  MOVWF  03
09818:  RRCF   xCA,W
0981A:  MOVWF  02
0981C:  ADDWF  01,W
0981E:  MOVWF  01
09820:  MOVF   xC9,W
09822:  ADDWFC 03,F
09824:  MOVFF  01,8C0
09828:  MOVFF  03,8C1
0982C:  CLRF   02
0982E:  CLRF   03
09830:  MOVFF  03,8C3
09834:  MOVFF  02,8C2
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
09838:  BCF    FD8.0
0983A:  MOVLB  7
0983C:  RLCF   x3C,W
0983E:  CLRF   03
09840:  ADDLW  A7
09842:  MOVWF  FE9
09844:  MOVLW  07
09846:  ADDWFC 03,W
09848:  MOVWF  FEA
0984A:  MOVFF  FEC,9EA
0984E:  MOVF   FED,F
09850:  MOVFF  FEF,9E9
09854:  MOVFF  8BB,9EC
09858:  MOVFF  8BA,9EB
0985C:  MOVLB  0
0985E:  CALL   5C18
09862:  MOVFF  02,8C9
09866:  MOVFF  01,8C8
0986A:  BCF    FD8.0
0986C:  MOVLB  7
0986E:  RLCF   x3C,W
09870:  CLRF   03
09872:  ADDLW  A7
09874:  MOVWF  FE9
09876:  MOVLW  07
09878:  ADDWFC 03,W
0987A:  MOVWF  FEA
0987C:  MOVFF  FEC,8CB
09880:  MOVF   FED,F
09882:  MOVFF  FEF,8CA
09886:  BCF    FD8.0
09888:  MOVLB  8
0988A:  RRCF   xCB,W
0988C:  MOVWF  03
0988E:  RRCF   xCA,W
09890:  MOVWF  02
09892:  SUBWF  01,W
09894:  MOVWF  00
09896:  MOVF   03,W
09898:  SUBWFB xC9,W
0989A:  MOVWF  03
0989C:  MOVF   00,W
0989E:  MOVFF  03,8C5
098A2:  CLRF   02
098A4:  CLRF   03
098A6:  MOVFF  03,8C7
098AA:  MOVFF  02,8C6
098AE:  MOVFF  00,8C4
....................             } 
098B2:  BRA    99CC
098B4:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
098B6:  DECFSZ xD7,W
098B8:  BRA    99CE
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
098BA:  BCF    FD8.0
098BC:  MOVLB  7
098BE:  RLCF   x3C,W
098C0:  CLRF   03
098C2:  ADDLW  A7
098C4:  MOVWF  FE9
098C6:  MOVLW  07
098C8:  ADDWFC 03,W
098CA:  MOVWF  FEA
098CC:  MOVFF  FEC,9EA
098D0:  MOVF   FED,F
098D2:  MOVFF  FEF,9E9
098D6:  MOVLW  01
098D8:  MOVLB  8
098DA:  SUBWF  xBA,W
098DC:  MOVWF  00
098DE:  MOVLW  00
098E0:  SUBWFB xBB,W
098E2:  MOVWF  03
098E4:  MOVFF  00,8CA
098E8:  MOVWF  xCB
098EA:  MOVFF  FE8,9EC
098EE:  MOVFF  00,9EB
098F2:  MOVLB  0
098F4:  CALL   5C18
098F8:  MOVFF  02,8C9
098FC:  MOVFF  01,8C8
09900:  BCF    FD8.0
09902:  MOVLB  7
09904:  RLCF   x3C,W
09906:  CLRF   03
09908:  ADDLW  A7
0990A:  MOVWF  FE9
0990C:  MOVLW  07
0990E:  ADDWFC 03,W
09910:  MOVWF  FEA
09912:  MOVFF  FEC,8CB
09916:  MOVF   FED,F
09918:  MOVFF  FEF,8CA
0991C:  BCF    FD8.0
0991E:  MOVLB  8
09920:  RRCF   xCB,W
09922:  MOVWF  03
09924:  RRCF   xCA,W
09926:  MOVWF  02
09928:  ADDWF  01,W
0992A:  MOVWF  01
0992C:  MOVF   xC9,W
0992E:  ADDWFC 03,F
09930:  MOVFF  01,8C0
09934:  MOVFF  03,8C1
09938:  CLRF   02
0993A:  CLRF   03
0993C:  MOVFF  03,8C3
09940:  MOVFF  02,8C2
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
09944:  BCF    FD8.0
09946:  MOVLB  7
09948:  RLCF   x3C,W
0994A:  CLRF   03
0994C:  ADDLW  A7
0994E:  MOVWF  FE9
09950:  MOVLW  07
09952:  ADDWFC 03,W
09954:  MOVWF  FEA
09956:  MOVFF  FEC,9EA
0995A:  MOVF   FED,F
0995C:  MOVFF  FEF,9E9
09960:  MOVLW  01
09962:  MOVLB  8
09964:  SUBWF  xBA,W
09966:  MOVWF  00
09968:  MOVLW  00
0996A:  SUBWFB xBB,W
0996C:  MOVWF  03
0996E:  MOVFF  00,8CA
09972:  MOVWF  xCB
09974:  MOVFF  FE8,9EC
09978:  MOVFF  00,9EB
0997C:  MOVLB  0
0997E:  CALL   5C18
09982:  MOVFF  02,03
09986:  MOVFF  01,8C4
0998A:  MOVFF  02,8C5
0998E:  CLRF   02
09990:  CLRF   03
09992:  MOVFF  03,8C7
09996:  MOVFF  02,8C6
....................                m_pll = m_pll -(m_ppp[motor]/2); 
0999A:  BCF    FD8.0
0999C:  MOVLB  7
0999E:  RLCF   x3C,W
099A0:  CLRF   03
099A2:  ADDLW  A7
099A4:  MOVWF  FE9
099A6:  MOVLW  07
099A8:  ADDWFC 03,W
099AA:  MOVWF  FEA
099AC:  MOVFF  FEC,8C9
099B0:  MOVF   FED,F
099B2:  MOVFF  FEF,8C8
099B6:  BCF    FD8.0
099B8:  MOVLB  8
099BA:  RRCF   xC9,W
099BC:  MOVWF  03
099BE:  RRCF   xC8,W
099C0:  SUBWF  xC4,F
099C2:  MOVF   03,W
099C4:  SUBWFB xC5,F
099C6:  MOVLW  00
099C8:  SUBWFB xC6,F
099CA:  SUBWFB xC7,F
099CC:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
099CE:  MOVLB  7
099D0:  MOVF   x3C,W
099D2:  MULLW  04
099D4:  MOVF   FF3,W
099D6:  CLRF   03
099D8:  ADDLW  9E
099DA:  MOVWF  FE9
099DC:  MOVLW  07
099DE:  ADDWFC 03,W
099E0:  MOVWF  FEA
099E2:  MOVFF  FEF,8C8
099E6:  MOVFF  FEC,8C9
099EA:  MOVFF  FEC,8CA
099EE:  MOVFF  FEC,8CB
099F2:  MOVLB  8
099F4:  BTFSC  xC3.7
099F6:  BRA    9A66
099F8:  MOVF   xC3,W
099FA:  SUBWF  xCB,W
099FC:  BNC   9A16
099FE:  BNZ   9A66
09A00:  MOVF   xC2,W
09A02:  SUBWF  xCA,W
09A04:  BNC   9A16
09A06:  BNZ   9A66
09A08:  MOVF   xC1,W
09A0A:  SUBWF  xC9,W
09A0C:  BNC   9A16
09A0E:  BNZ   9A66
09A10:  MOVF   xC8,W
09A12:  SUBWF  xC0,W
09A14:  BNC   9A66
09A16:  MOVLB  7
09A18:  MOVF   x3C,W
09A1A:  MULLW  04
09A1C:  MOVF   FF3,W
09A1E:  CLRF   03
09A20:  ADDLW  9E
09A22:  MOVWF  FE9
09A24:  MOVLW  07
09A26:  ADDWFC 03,W
09A28:  MOVWF  FEA
09A2A:  MOVFF  FEF,8C8
09A2E:  MOVFF  FEC,8C9
09A32:  MOVFF  FEC,8CA
09A36:  MOVFF  FEC,8CB
09A3A:  MOVLB  8
09A3C:  BTFSC  xC7.7
09A3E:  BRA    9BAA
09A40:  MOVF   xCB,W
09A42:  SUBWF  xC7,W
09A44:  BTFSS  FD8.0
09A46:  BRA    9BAA
09A48:  BNZ   9A66
09A4A:  MOVF   xCA,W
09A4C:  SUBWF  xC6,W
09A4E:  BTFSS  FD8.0
09A50:  BRA    9BAA
09A52:  BNZ   9A66
09A54:  MOVF   xC9,W
09A56:  SUBWF  xC5,W
09A58:  BTFSS  FD8.0
09A5A:  BRA    9BAA
09A5C:  BNZ   9A66
09A5E:  MOVF   xC4,W
09A60:  SUBWF  xC8,W
09A62:  BTFSC  FD8.0
09A64:  BRA    9BAA
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09A66:  MOVLW  01
09A68:  MOVLB  7
09A6A:  ADDWF  x3C,W
09A6C:  MOVLB  8
09A6E:  MOVWF  xC8
09A70:  BCF    FD8.0
09A72:  MOVLB  7
09A74:  RLCF   x3C,W
09A76:  CLRF   03
09A78:  ADDLW  A7
09A7A:  MOVWF  FE9
09A7C:  MOVLW  07
09A7E:  ADDWFC 03,W
09A80:  MOVWF  FEA
09A82:  MOVFF  FEC,8CA
09A86:  MOVF   FED,F
09A88:  MOVFF  FEF,8C9
09A8C:  MOVF   x3C,W
09A8E:  MULLW  04
09A90:  MOVF   FF3,W
09A92:  CLRF   03
09A94:  ADDLW  9E
09A96:  MOVWF  FE9
09A98:  MOVLW  07
09A9A:  ADDWFC 03,W
09A9C:  MOVWF  FEA
09A9E:  MOVFF  FEF,8CB
09AA2:  MOVFF  FEC,8CC
09AA6:  MOVFF  FEC,8CD
09AAA:  MOVFF  FEC,8CE
09AAE:  MOVLW  5A
09AB0:  MOVWF  FF6
09AB2:  MOVLW  1A
09AB4:  MOVWF  FF7
09AB6:  MOVLW  00
09AB8:  MOVWF  FF8
09ABA:  CLRF   1B
09ABC:  BTFSC  FF2.7
09ABE:  BSF    1B.7
09AC0:  BCF    FF2.7
09AC2:  MOVLW  05
09AC4:  MOVLB  A
09AC6:  MOVWF  x18
09AC8:  MOVLB  0
09ACA:  CALL   1010
09ACE:  BTFSC  1B.7
09AD0:  BSF    FF2.7
09AD2:  CLRF   1B
09AD4:  BTFSC  FF2.7
09AD6:  BSF    1B.7
09AD8:  BCF    FF2.7
09ADA:  MOVFF  8C8,A18
09ADE:  MOVLW  1B
09AE0:  MOVLB  A
09AE2:  MOVWF  x19
09AE4:  MOVLB  0
09AE6:  CALL   0F92
09AEA:  BTFSC  1B.7
09AEC:  BSF    FF2.7
09AEE:  MOVLW  2C
09AF0:  BTFSS  F9E.4
09AF2:  BRA    9AF0
09AF4:  MOVWF  FAD
09AF6:  MOVLW  41
09AF8:  MOVWF  FE9
09AFA:  MOVFF  8B9,8D2
09AFE:  MOVFF  8B8,8D1
09B02:  MOVFF  8B7,8D0
09B06:  MOVFF  8B6,8CF
09B0A:  RCALL  94A4
09B0C:  MOVLW  2C
09B0E:  BTFSS  F9E.4
09B10:  BRA    9B0E
09B12:  MOVWF  FAD
09B14:  MOVLW  10
09B16:  MOVWF  FE9
09B18:  CLRF   1B
09B1A:  BTFSC  FF2.7
09B1C:  BSF    1B.7
09B1E:  BCF    FF2.7
09B20:  MOVFF  8CA,A19
09B24:  MOVFF  8C9,A18
09B28:  CALL   1192
09B2C:  BTFSC  1B.7
09B2E:  BSF    FF2.7
09B30:  MOVLW  2C
09B32:  BTFSS  F9E.4
09B34:  BRA    9B32
09B36:  MOVWF  FAD
09B38:  MOVLW  41
09B3A:  MOVWF  FE9
09B3C:  CLRF   1B
09B3E:  BTFSC  FF2.7
09B40:  BSF    1B.7
09B42:  BCF    FF2.7
09B44:  MOVFF  8CE,A1B
09B48:  MOVFF  8CD,A1A
09B4C:  MOVFF  8CC,A19
09B50:  MOVFF  8CB,A18
09B54:  CALL   10D6
09B58:  BTFSC  1B.7
09B5A:  BSF    FF2.7
09B5C:  MOVLW  2C
09B5E:  BTFSS  F9E.4
09B60:  BRA    9B5E
09B62:  MOVWF  FAD
09B64:  MOVLW  41
09B66:  MOVWF  FE9
09B68:  MOVFF  8C3,8D2
09B6C:  MOVFF  8C2,8D1
09B70:  MOVFF  8C1,8D0
09B74:  MOVFF  8C0,8CF
09B78:  RCALL  94A4
09B7A:  MOVLW  2C
09B7C:  BTFSS  F9E.4
09B7E:  BRA    9B7C
09B80:  MOVWF  FAD
09B82:  MOVLW  41
09B84:  MOVWF  FE9
09B86:  MOVFF  8C7,8D2
09B8A:  MOVFF  8C6,8D1
09B8E:  MOVFF  8C5,8D0
09B92:  MOVFF  8C4,8CF
09B96:  RCALL  94A4
09B98:  MOVLW  0D
09B9A:  BTFSS  F9E.4
09B9C:  BRA    9B9A
09B9E:  MOVWF  FAD
09BA0:  MOVLW  0A
09BA2:  BTFSS  F9E.4
09BA4:  BRA    9BA2
09BA6:  MOVWF  FAD
09BA8:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09BAA:  BCF    FD8.0
09BAC:  MOVLB  7
09BAE:  RLCF   x3C,W
09BB0:  CLRF   03
09BB2:  ADDLW  9A
09BB4:  MOVWF  01
09BB6:  MOVLW  07
09BB8:  ADDWFC 03,F
09BBA:  MOVLB  8
09BBC:  MOVFF  03,8C9
09BC0:  BCF    FD8.0
09BC2:  MOVLB  7
09BC4:  RLCF   x3C,W
09BC6:  CLRF   03
09BC8:  ADDLW  62
09BCA:  MOVWF  FE9
09BCC:  MOVLW  07
09BCE:  ADDWFC 03,W
09BD0:  MOVWF  FEA
09BD2:  MOVFF  FEC,03
09BD6:  MOVF   FED,F
09BD8:  MOVFF  FEF,8CA
09BDC:  MOVLB  8
09BDE:  MOVFF  8C9,FEA
09BE2:  MOVFF  01,FE9
09BE6:  MOVFF  03,FEC
09BEA:  MOVF   FED,F
09BEC:  MOVFF  8CA,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09BF0:  BCF    FD8.0
09BF2:  MOVLB  7
09BF4:  RLCF   x3C,W
09BF6:  CLRF   03
09BF8:  ADDLW  62
09BFA:  MOVWF  FE9
09BFC:  MOVLW  07
09BFE:  ADDWFC 03,W
09C00:  MOVWF  FEA
09C02:  CLRF   FEC
09C04:  MOVF   FED,F
09C06:  MOVLW  04
09C08:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09C0A:  MOVF   x3C,W
09C0C:  MULLW  04
09C0E:  MOVF   FF3,W
09C10:  CLRF   03
09C12:  ADDLW  9E
09C14:  MOVWF  FE9
09C16:  MOVLW  07
09C18:  ADDWFC 03,W
09C1A:  MOVWF  FEA
09C1C:  MOVFF  FEF,8BC
09C20:  MOVFF  FEC,8BD
09C24:  MOVFF  FEC,8BE
09C28:  MOVFF  FEC,8BF
09C2C:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09C2E:  MOVFF  8BC,00
09C32:  MOVFF  8BD,01
09C36:  MOVFF  8BE,02
09C3A:  MOVFF  8BF,03
09C3E:  MOVLB  0
09C40:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
0849E:  MOVLB  2
084A0:  CLRF   xD7
....................    start_even_port = FALSE; 
084A2:  CLRF   xD6
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
084A4:  BCF    FD8.0
084A6:  MOVLB  7
084A8:  RLCF   x3C,W
084AA:  CLRF   03
084AC:  ADDLW  C3
084AE:  MOVWF  FE9
084B0:  MOVLW  07
084B2:  ADDWFC 03,W
084B4:  MOVWF  FEA
084B6:  MOVFF  FEC,8B6
084BA:  MOVF   FED,F
084BC:  MOVFF  FEF,8B5
084C0:  MOVLW  01
084C2:  MOVLB  8
084C4:  ANDWF  xB5,F
084C6:  CLRF   xB6
084C8:  MOVF   xB5,F
084CA:  BNZ   84D8
084CC:  MOVF   xB6,F
084CE:  BNZ   84D8
....................    { 
....................       end_even_port = TRUE; 
084D0:  MOVLW  01
084D2:  MOVLB  2
084D4:  MOVWF  xD7
084D6:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
084D8:  BCF    FD8.0
084DA:  MOVLB  7
084DC:  RLCF   x3C,W
084DE:  CLRF   03
084E0:  ADDLW  BF
084E2:  MOVWF  FE9
084E4:  MOVLW  07
084E6:  ADDWFC 03,W
084E8:  MOVWF  FEA
084EA:  MOVFF  FEC,8B6
084EE:  MOVF   FED,F
084F0:  MOVFF  FEF,8B5
084F4:  MOVLW  01
084F6:  MOVLB  8
084F8:  ANDWF  xB5,F
084FA:  CLRF   xB6
084FC:  MOVF   xB5,F
084FE:  BNZ   850C
08500:  MOVF   xB6,F
08502:  BNZ   850C
....................    { 
....................       start_even_port = TRUE; 
08504:  MOVLW  01
08506:  MOVLB  2
08508:  MOVWF  xD6
0850A:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
0850C:  MOVLB  2
0850E:  MOVF   xD6,F
08510:  BNZ   8526
....................    { 
....................       evenOdd = 0; 
08512:  MOVLB  8
08514:  CLRF   xB4
....................       if (TRUE == end_even_port) 
08516:  MOVLB  2
08518:  DECFSZ xD7,W
0851A:  BRA    8524
....................       { 
....................          evenOdd = 1; 
0851C:  MOVLW  01
0851E:  MOVLB  8
08520:  MOVWF  xB4
08522:  MOVLB  2
....................       } 
....................    } 
08524:  BRA    853A
....................    else 
....................    { 
....................       evenOdd = 2; 
08526:  MOVLW  02
08528:  MOVLB  8
0852A:  MOVWF  xB4
....................       if (TRUE == end_even_port) 
0852C:  MOVLB  2
0852E:  DECFSZ xD7,W
08530:  BRA    853A
....................       { 
....................          evenOdd = 3; 
08532:  MOVLW  03
08534:  MOVLB  8
08536:  MOVWF  xB4
08538:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
0853A:  MOVLB  8
0853C:  MOVFF  8B4,01
08540:  MOVLB  0
08542:  GOTO   9F90 (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09CB8:  BCF    FD8.0
09CBA:  MOVLB  7
09CBC:  RLCF   x3C,W
09CBE:  CLRF   03
09CC0:  ADDLW  82
09CC2:  MOVWF  FE9
09CC4:  MOVLW  07
09CC6:  ADDWFC 03,W
09CC8:  MOVWF  FEA
09CCA:  CLRF   FEC
09CCC:  MOVF   FED,F
09CCE:  MOVFF  8A5,FEF
....................    m_step_cnt[motor] = 0; 
09CD2:  MOVF   x3C,W
09CD4:  MULLW  04
09CD6:  MOVF   FF3,W
09CD8:  CLRF   03
09CDA:  ADDLW  9E
09CDC:  MOVWF  FE9
09CDE:  MOVLW  07
09CE0:  ADDWFC 03,W
09CE2:  MOVWF  FEA
09CE4:  MOVF   FEE,F
09CE6:  MOVF   FEE,F
09CE8:  CLRF   FEC
09CEA:  MOVF   FED,F
09CEC:  CLRF   FEF
09CEE:  MOVF   FED,F
09CF0:  CLRF   FEF
09CF2:  MOVF   FED,F
09CF4:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09CF6:  BCF    FD8.0
09CF8:  RLCF   x3C,W
09CFA:  CLRF   03
09CFC:  ADDLW  6A
09CFE:  MOVWF  FE9
09D00:  MOVLW  07
09D02:  ADDWFC 03,W
09D04:  MOVWF  FEA
09D06:  MOVFF  FEC,8B2
09D0A:  MOVF   FED,F
09D0C:  MOVFF  FEF,8B1
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09D10:  BCF    FD8.0
09D12:  RLCF   x3C,W
09D14:  CLRF   03
09D16:  ADDLW  72
09D18:  MOVWF  FE9
09D1A:  MOVLW  07
09D1C:  ADDWFC 03,W
09D1E:  MOVWF  FEA
09D20:  MOVFF  FEC,8B9
09D24:  MOVF   FED,F
09D26:  MOVFF  FEF,8B8
09D2A:  BCF    FD8.0
09D2C:  RLCF   x3C,W
09D2E:  CLRF   03
09D30:  ADDLW  5A
09D32:  MOVWF  FE9
09D34:  MOVLW  07
09D36:  ADDWFC 03,W
09D38:  MOVWF  FEA
09D3A:  MOVFF  FEC,03
09D3E:  MOVF   FED,F
09D40:  MOVFF  FEF,8BA
09D44:  MOVFF  03,8B7
09D48:  MOVFF  03,8BB
09D4C:  MOVLB  0
09D4E:  CALL   2C5C
09D52:  MOVFF  02,8B0
09D56:  MOVFF  01,8AF
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09D5A:  BCF    FD8.0
09D5C:  MOVLB  7
09D5E:  RLCF   x3C,W
09D60:  CLRF   03
09D62:  ADDLW  62
09D64:  MOVWF  FE9
09D66:  MOVLW  07
09D68:  ADDWFC 03,W
09D6A:  MOVWF  FEA
09D6C:  MOVFF  FEC,8B5
09D70:  MOVF   FED,F
09D72:  MOVFF  FEF,8B4
09D76:  MOVLB  8
09D78:  MOVF   xB4,W
09D7A:  SUBLW  02
09D7C:  BNZ   9DAC
09D7E:  MOVF   xB5,F
09D80:  BNZ   9DAC
09D82:  BCF    FD8.0
09D84:  MOVLB  7
09D86:  RLCF   x3C,W
09D88:  CLRF   03
09D8A:  ADDLW  BF
09D8C:  MOVWF  FE9
09D8E:  MOVLW  07
09D90:  ADDWFC 03,W
09D92:  MOVWF  FEA
09D94:  MOVFF  FEC,8B5
09D98:  MOVF   FED,F
09D9A:  MOVFF  FEF,8B4
09D9E:  MOVLB  8
09DA0:  MOVF   xB4,F
09DA2:  BNZ   9DAC
09DA4:  MOVF   xB5,F
09DA6:  BTFSC  FD8.2
09DA8:  GOTO   A64A
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09DAC:  BCF    FD8.0
09DAE:  MOVLB  7
09DB0:  RLCF   x3C,W
09DB2:  CLRF   03
09DB4:  ADDLW  62
09DB6:  MOVWF  FE9
09DB8:  MOVLW  07
09DBA:  ADDWFC 03,W
09DBC:  MOVWF  FEA
09DBE:  MOVFF  FEC,8B5
09DC2:  MOVF   FED,F
09DC4:  MOVFF  FEF,8B4
09DC8:  MOVLB  8
09DCA:  MOVF   xB4,W
09DCC:  SUBLW  02
09DCE:  BTFSS  FD8.2
09DD0:  BRA    A12A
09DD2:  MOVF   xB5,F
09DD4:  BTFSS  FD8.2
09DD6:  BRA    A12A
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09DD8:  BCF    FD8.0
09DDA:  MOVLB  7
09DDC:  RLCF   x3C,W
09DDE:  CLRF   03
09DE0:  ADDLW  C3
09DE2:  MOVWF  FE9
09DE4:  MOVLW  07
09DE6:  ADDWFC 03,W
09DE8:  MOVWF  FEA
09DEA:  MOVFF  8A6,FEF
09DEE:  MOVFF  8A7,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09DF2:  DECFSZ 2F,W
09DF4:  BRA    A0A6
09DF6:  MOVF   30,F
09DF8:  BTFSS  FD8.2
09DFA:  BRA    A0A6
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09DFC:  BCF    FD8.0
09DFE:  RLCF   x3C,W
09E00:  CLRF   03
09E02:  ADDLW  C3
09E04:  MOVWF  FE9
09E06:  MOVLW  07
09E08:  ADDWFC 03,W
09E0A:  MOVWF  FEA
09E0C:  MOVFF  FEC,8B5
09E10:  MOVF   FED,F
09E12:  MOVFF  FEF,8B4
09E16:  BCF    FD8.0
09E18:  RLCF   x3C,W
09E1A:  CLRF   03
09E1C:  ADDLW  BF
09E1E:  MOVWF  FE9
09E20:  MOVLW  07
09E22:  ADDWFC 03,W
09E24:  MOVWF  FEA
09E26:  MOVFF  FEC,03
09E2A:  MOVF   FED,F
09E2C:  MOVFF  FEF,01
09E30:  MOVF   03,W
09E32:  MOVLB  8
09E34:  SUBWF  xB5,W
09E36:  BNC   9ED2
09E38:  BNZ   9E40
09E3A:  MOVF   xB4,W
09E3C:  SUBWF  01,W
09E3E:  BC    9ED2
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09E40:  BCF    FD8.0
09E42:  MOVLB  7
09E44:  RLCF   x3C,W
09E46:  CLRF   03
09E48:  ADDLW  B3
09E4A:  MOVWF  01
09E4C:  MOVLW  07
09E4E:  ADDWFC 03,F
09E50:  MOVLB  8
09E52:  MOVFF  03,8B5
09E56:  BCF    FD8.0
09E58:  MOVLB  7
09E5A:  RLCF   x3C,W
09E5C:  CLRF   03
09E5E:  ADDLW  C3
09E60:  MOVWF  FE9
09E62:  MOVLW  07
09E64:  ADDWFC 03,W
09E66:  MOVWF  FEA
09E68:  MOVFF  FEC,8B7
09E6C:  MOVF   FED,F
09E6E:  MOVFF  FEF,8B6
09E72:  BCF    FD8.0
09E74:  RLCF   x3C,W
09E76:  CLRF   03
09E78:  ADDLW  BF
09E7A:  MOVWF  FE9
09E7C:  MOVLW  07
09E7E:  ADDWFC 03,W
09E80:  MOVWF  FEA
09E82:  MOVFF  FEC,03
09E86:  MOVF   FED,F
09E88:  MOVF   FEF,W
09E8A:  MOVLB  8
09E8C:  SUBWF  xB6,W
09E8E:  MOVWF  00
09E90:  MOVF   03,W
09E92:  SUBWFB xB7,W
09E94:  MOVFF  8B5,FEA
09E98:  MOVFF  01,FE9
09E9C:  MOVWF  FEC
09E9E:  MOVF   FED,F
09EA0:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09EA4:  BCF    FD8.0
09EA6:  MOVLB  7
09EA8:  RLCF   x3C,W
09EAA:  CLRF   03
09EAC:  ADDLW  B3
09EAE:  MOVWF  FE9
09EB0:  MOVLW  07
09EB2:  ADDWFC 03,W
09EB4:  MOVWF  FEA
09EB6:  MOVFF  FEC,8B5
09EBA:  MOVF   FED,F
09EBC:  MOVFF  FEF,8B4
09EC0:  BCF    FD8.0
09EC2:  MOVLB  8
09EC4:  CLRF   xA9
09EC6:  CLRF   xA8
09EC8:  RRCF   xB5,W
09ECA:  MOVWF  xA7
09ECC:  RRCF   xB4,W
09ECE:  MOVWF  xA6
....................             } 
09ED0:  BRA    9F8A
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09ED2:  BCF    FD8.0
09ED4:  MOVLB  7
09ED6:  RLCF   x3C,W
09ED8:  CLRF   03
09EDA:  ADDLW  B3
09EDC:  MOVWF  01
09EDE:  MOVLW  07
09EE0:  ADDWFC 03,F
09EE2:  MOVFF  01,8B4
09EE6:  MOVLB  8
09EE8:  MOVFF  03,8B5
09EEC:  BCF    FD8.0
09EEE:  MOVLB  7
09EF0:  RLCF   x3C,W
09EF2:  CLRF   03
09EF4:  ADDLW  5E
09EF6:  MOVWF  FE9
09EF8:  MOVLW  07
09EFA:  ADDWFC 03,W
09EFC:  MOVWF  FEA
09EFE:  MOVFF  FEC,8B7
09F02:  MOVF   FED,F
09F04:  MOVFF  FEF,8B6
09F08:  BCF    FD8.0
09F0A:  RLCF   x3C,W
09F0C:  CLRF   03
09F0E:  ADDLW  BF
09F10:  MOVWF  FE9
09F12:  MOVLW  07
09F14:  ADDWFC 03,W
09F16:  MOVWF  FEA
09F18:  MOVFF  FEC,03
09F1C:  MOVF   FED,F
09F1E:  MOVF   FEF,W
09F20:  MOVLB  8
09F22:  SUBWF  xB6,F
09F24:  MOVF   03,W
09F26:  SUBWFB xB7,F
09F28:  BCF    FD8.0
09F2A:  MOVLB  7
09F2C:  RLCF   x3C,W
09F2E:  CLRF   03
09F30:  ADDLW  C3
09F32:  MOVWF  FE9
09F34:  MOVLW  07
09F36:  ADDWFC 03,W
09F38:  MOVWF  FEA
09F3A:  MOVFF  FEC,03
09F3E:  MOVF   FED,F
09F40:  MOVF   FEF,W
09F42:  MOVLB  8
09F44:  ADDWF  xB6,W
09F46:  MOVWF  01
09F48:  MOVF   xB7,W
09F4A:  ADDWFC 03,F
09F4C:  MOVFF  8B5,FEA
09F50:  MOVFF  8B4,FE9
09F54:  MOVFF  03,FEC
09F58:  MOVF   FED,F
09F5A:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F5E:  BCF    FD8.0
09F60:  MOVLB  7
09F62:  RLCF   x3C,W
09F64:  CLRF   03
09F66:  ADDLW  B3
09F68:  MOVWF  FE9
09F6A:  MOVLW  07
09F6C:  ADDWFC 03,W
09F6E:  MOVWF  FEA
09F70:  MOVFF  FEC,8B5
09F74:  MOVF   FED,F
09F76:  MOVFF  FEF,8B4
09F7A:  BCF    FD8.0
09F7C:  MOVLB  8
09F7E:  CLRF   xA9
09F80:  CLRF   xA8
09F82:  RRCF   xB5,W
09F84:  MOVWF  xA7
09F86:  RRCF   xB4,W
09F88:  MOVWF  xA6
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
09F8A:  MOVLB  0
09F8C:  GOTO   849E
09F90:  MOVFF  01,8B3
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
09F94:  BCF    FD8.0
09F96:  MOVLB  7
09F98:  RLCF   x3C,W
09F9A:  CLRF   03
09F9C:  ADDLW  C3
09F9E:  MOVWF  FE9
09FA0:  MOVLW  07
09FA2:  ADDWFC 03,W
09FA4:  MOVWF  FEA
09FA6:  MOVFF  FEC,8B5
09FAA:  MOVF   FED,F
09FAC:  MOVFF  FEF,8B4
09FB0:  MOVLB  8
09FB2:  MOVF   xB4,W
09FB4:  SUBLW  02
09FB6:  BNZ   9FE6
09FB8:  MOVF   xB5,F
09FBA:  BNZ   9FE6
09FBC:  BCF    FD8.0
09FBE:  MOVLB  7
09FC0:  RLCF   x3C,W
09FC2:  CLRF   03
09FC4:  ADDLW  BF
09FC6:  MOVWF  FE9
09FC8:  MOVLW  07
09FCA:  ADDWFC 03,W
09FCC:  MOVWF  FEA
09FCE:  MOVFF  FEC,8B5
09FD2:  MOVF   FED,F
09FD4:  MOVFF  FEF,8B4
09FD8:  MOVLB  8
09FDA:  DECFSZ xB4,W
09FDC:  BRA    9FE6
09FDE:  MOVF   xB5,F
09FE0:  BNZ   9FE6
....................             { 
....................                port_port=4; 
09FE2:  MOVLW  04
09FE4:  MOVWF  xB3
....................             } 
....................              
....................             switch(port_port){ 
09FE6:  MOVF   xB3,W
09FE8:  ADDLW  FB
09FEA:  BC    A0A2
09FEC:  ADDLW  05
09FEE:  MOVLB  0
09FF0:  GOTO   A698
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
09FF4:  BCF    FD8.0
09FF6:  MOVLB  7
09FF8:  RLCF   x3C,W
09FFA:  CLRF   03
09FFC:  ADDLW  6A
09FFE:  MOVWF  FE9
0A000:  MOVLW  07
0A002:  ADDWFC 03,W
0A004:  MOVWF  FEA
0A006:  MOVFF  FEC,8B2
0A00A:  MOVF   FED,F
0A00C:  MOVFF  FEF,8B1
....................                   break; 
0A010:  MOVLB  8
0A012:  BRA    A0A2
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A014:  BCF    FD8.0
0A016:  MOVLB  7
0A018:  RLCF   x3C,W
0A01A:  CLRF   03
0A01C:  ADDLW  7A
0A01E:  MOVWF  FE9
0A020:  MOVLW  07
0A022:  ADDWFC 03,W
0A024:  MOVWF  FEA
0A026:  MOVFF  FEC,03
0A02A:  MOVF   FED,F
0A02C:  MOVF   FEF,W
0A02E:  MOVLB  8
0A030:  ADDWF  xAF,W
0A032:  MOVWF  xB1
0A034:  MOVF   03,W
0A036:  ADDWFC xB0,W
0A038:  MOVWF  xB2
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A03A:  BRA    A0A2
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A03C:  BCF    FD8.0
0A03E:  MOVLB  7
0A040:  RLCF   x3C,W
0A042:  CLRF   03
0A044:  ADDLW  6A
0A046:  MOVWF  FE9
0A048:  MOVLW  07
0A04A:  ADDWFC 03,W
0A04C:  MOVWF  FEA
0A04E:  MOVFF  FEC,8B2
0A052:  MOVF   FED,F
0A054:  MOVFF  FEF,8B1
....................                         ++m_steps; 
0A058:  MOVLW  01
0A05A:  MOVLB  8
0A05C:  ADDWF  xA6,F
0A05E:  BTFSC  FD8.0
0A060:  INCF   xA7,F
0A062:  BTFSC  FD8.2
0A064:  INCF   xA8,F
0A066:  BTFSC  FD8.2
0A068:  INCF   xA9,F
....................                   break; 
0A06A:  BRA    A0A2
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A06C:  BCF    FD8.0
0A06E:  MOVLB  7
0A070:  RLCF   x3C,W
0A072:  CLRF   03
0A074:  ADDLW  7A
0A076:  MOVWF  FE9
0A078:  MOVLW  07
0A07A:  ADDWFC 03,W
0A07C:  MOVWF  FEA
0A07E:  MOVFF  FEC,03
0A082:  MOVF   FED,F
0A084:  MOVF   FEF,W
0A086:  MOVLB  8
0A088:  ADDWF  xAF,W
0A08A:  MOVWF  xB1
0A08C:  MOVF   03,W
0A08E:  ADDWFC xB0,W
0A090:  MOVWF  xB2
....................  
....................                   break; 
0A092:  BRA    A0A2
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A094:  MOVFF  8B0,8B2
0A098:  MOVFF  8AF,8B1
....................                   break;     
0A09C:  MOVLB  8
0A09E:  BRA    A0A2
0A0A0:  MOVLB  8
....................             } 
....................          } 
0A0A2:  BRA    A0CE
0A0A4:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A0A6:  MOVFF  8A9,8B7
0A0AA:  MOVFF  8A8,8B6
0A0AE:  MOVFF  8A7,8B5
0A0B2:  MOVFF  8A6,8B4
0A0B6:  MOVLB  0
0A0B8:  GOTO   8546
0A0BC:  MOVFF  03,8A9
0A0C0:  MOVFF  02,8A8
0A0C4:  MOVFF  01,8A7
0A0C8:  MOVFF  00,8A6
0A0CC:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A0CE:  DECFSZ xA4,W
0A0D0:  BRA    A0F8
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A0D2:  MOVFF  8A7,8B5
0A0D6:  MOVFF  8A6,8B4
0A0DA:  MOVFF  8A7,8B7
0A0DE:  MOVFF  8A6,8B6
0A0E2:  MOVLB  0
0A0E4:  GOTO   8758
0A0E8:  MOVLB  8
0A0EA:  CLRF   xA9
0A0EC:  CLRF   xA8
0A0EE:  MOVFF  02,8A7
0A0F2:  MOVFF  01,8A6
....................          } 
0A0F6:  BRA    A12A
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A0F8:  MOVF   2F,W
0A0FA:  SUBLW  03
0A0FC:  BNZ   A12A
0A0FE:  MOVF   30,F
0A100:  BNZ   A12A
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A102:  BCF    FD8.0
0A104:  MOVLB  7
0A106:  RLCF   x3C,W
0A108:  CLRF   03
0A10A:  ADDLW  BB
0A10C:  MOVWF  FE9
0A10E:  MOVLW  07
0A110:  ADDWFC 03,W
0A112:  MOVWF  FEA
0A114:  MOVFF  FEC,03
0A118:  MOVF   FED,F
0A11A:  MOVF   FEF,W
0A11C:  MOVLB  8
0A11E:  SUBWF  xA6,F
0A120:  MOVF   03,W
0A122:  SUBWFB xA7,F
0A124:  MOVLW  00
0A126:  SUBWFB xA8,F
0A128:  SUBWFB xA9,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A12A:  MOVFF  8AA,8B4
0A12E:  MOVLB  0
0A130:  GOTO   8E22
....................  
....................       while (m_running[motor]) 
0A134:  BCF    FD8.0
0A136:  MOVLB  7
0A138:  RLCF   x3C,W
0A13A:  CLRF   03
0A13C:  ADDLW  8E
0A13E:  MOVWF  FE9
0A140:  MOVLW  07
0A142:  ADDWFC 03,W
0A144:  MOVWF  FEA
0A146:  MOVF   FEF,F
0A148:  BNZ   A150
0A14A:  MOVF   FEC,F
0A14C:  BTFSC  FD8.2
0A14E:  BRA    A646
....................       { 
....................          switch(e_mode[motor]) 
0A150:  BCF    FD8.0
0A152:  RLCF   x3C,W
0A154:  CLRF   03
0A156:  ADDLW  62
0A158:  MOVWF  FE9
0A15A:  MOVLW  07
0A15C:  ADDWFC 03,W
0A15E:  MOVWF  FEA
0A160:  MOVF   FEF,W
0A162:  MOVWF  00
0A164:  MOVF   FEE,F
0A166:  MOVF   FED,W
0A168:  MOVWF  03
0A16A:  MOVF   03,W
0A16C:  BNZ   A176
0A16E:  MOVF   00,F
0A170:  MOVLB  0
0A172:  BZ    A1C4
0A174:  MOVLB  7
0A176:  MOVF   03,W
0A178:  BNZ   A184
0A17A:  MOVLW  01
0A17C:  SUBWF  00,W
0A17E:  MOVLB  0
0A180:  BZ    A21A
0A182:  MOVLB  7
0A184:  MOVF   03,W
0A186:  BNZ   A192
0A188:  MOVLW  02
0A18A:  SUBWF  00,W
0A18C:  MOVLB  0
0A18E:  BZ    A21A
0A190:  MOVLB  7
0A192:  MOVF   03,W
0A194:  BNZ   A1A2
0A196:  MOVLW  03
0A198:  SUBWF  00,W
0A19A:  MOVLB  0
0A19C:  BTFSC  FD8.2
0A19E:  BRA    A2E8
0A1A0:  MOVLB  7
0A1A2:  MOVF   03,W
0A1A4:  BNZ   A1B2
0A1A6:  MOVLW  04
0A1A8:  SUBWF  00,W
0A1AA:  MOVLB  0
0A1AC:  BTFSC  FD8.2
0A1AE:  BRA    A438
0A1B0:  MOVLB  7
0A1B2:  MOVF   03,W
0A1B4:  BNZ   A1C2
0A1B6:  MOVLW  05
0A1B8:  SUBWF  00,W
0A1BA:  MOVLB  0
0A1BC:  BTFSC  FD8.2
0A1BE:  BRA    A588
0A1C0:  MOVLB  7
0A1C2:  BRA    A640
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A1C4:  MOVLB  7
0A1C6:  MOVF   x3C,W
0A1C8:  MULLW  04
0A1CA:  MOVF   FF3,W
0A1CC:  CLRF   03
0A1CE:  ADDLW  9E
0A1D0:  MOVWF  FE9
0A1D2:  MOVLW  07
0A1D4:  ADDWFC 03,W
0A1D6:  MOVWF  FEA
0A1D8:  MOVFF  FEF,8B4
0A1DC:  MOVFF  FEC,8B5
0A1E0:  MOVFF  FEC,8B6
0A1E4:  MOVFF  FEC,8B7
0A1E8:  MOVLB  8
0A1EA:  MOVF   xA9,W
0A1EC:  SUBWF  xB7,W
0A1EE:  BNC   A214
0A1F0:  BNZ   A208
0A1F2:  MOVF   xA8,W
0A1F4:  SUBWF  xB6,W
0A1F6:  BNC   A214
0A1F8:  BNZ   A208
0A1FA:  MOVF   xA7,W
0A1FC:  SUBWF  xB5,W
0A1FE:  BNC   A214
0A200:  BNZ   A208
0A202:  MOVF   xA6,W
0A204:  SUBWF  xB4,W
0A206:  BNC   A214
....................                { 
....................                   terminate(1); 
0A208:  MOVLW  01
0A20A:  MOVWF  xC8
0A20C:  MOVLB  0
0A20E:  CALL   9010
0A212:  MOVLB  8
....................                } 
....................                break; 
0A214:  MOVLB  7
0A216:  BRA    A640
0A218:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A21A:  BCF    FD8.0
0A21C:  MOVLB  7
0A21E:  RLCF   x3C,W
0A220:  CLRF   03
0A222:  ADDLW  96
0A224:  MOVWF  FE9
0A226:  MOVLW  07
0A228:  ADDWFC 03,W
0A22A:  MOVWF  FEA
0A22C:  MOVFF  FEC,8B5
0A230:  MOVF   FED,F
0A232:  MOVFF  FEF,8B4
0A236:  BCF    FD8.0
0A238:  RLCF   x3C,W
0A23A:  CLRF   03
0A23C:  ADDLW  56
0A23E:  MOVWF  FE9
0A240:  MOVLW  07
0A242:  ADDWFC 03,W
0A244:  MOVWF  FEA
0A246:  MOVFF  FEC,03
0A24A:  MOVF   FED,F
0A24C:  MOVFF  FEF,01
0A250:  MOVF   03,W
0A252:  MOVLB  8
0A254:  SUBWF  xB5,W
0A256:  BNC   A26A
0A258:  BNZ   A260
0A25A:  MOVF   01,W
0A25C:  SUBWF  xB4,W
0A25E:  BNC   A26A
....................                { 
....................                   terminate(0); 
0A260:  CLRF   xC8
0A262:  MOVLB  0
0A264:  CALL   9010
0A268:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A26A:  BCF    FD8.0
0A26C:  MOVLB  7
0A26E:  RLCF   x3C,W
0A270:  CLRF   03
0A272:  ADDLW  B7
0A274:  MOVWF  FE9
0A276:  MOVLW  07
0A278:  ADDWFC 03,W
0A27A:  MOVWF  FEA
0A27C:  MOVFF  FEC,8B5
0A280:  MOVF   FED,F
0A282:  MOVFF  FEF,8B4
0A286:  MOVLB  8
0A288:  MOVF   xA9,F
0A28A:  BNZ   A2E2
0A28C:  MOVF   xA8,F
0A28E:  BNZ   A2E2
0A290:  MOVF   xA7,W
0A292:  SUBWF  xB5,W
0A294:  BNC   A2E2
0A296:  BNZ   A29E
0A298:  MOVF   xA6,W
0A29A:  SUBWF  xB4,W
0A29C:  BNC   A2E2
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A29E:  BCF    FD8.0
0A2A0:  MOVLB  7
0A2A2:  RLCF   x3C,W
0A2A4:  CLRF   03
0A2A6:  ADDLW  B3
0A2A8:  MOVWF  FE9
0A2AA:  MOVLW  07
0A2AC:  ADDWFC 03,W
0A2AE:  MOVWF  FEA
0A2B0:  MOVFF  FEC,8BB
0A2B4:  MOVF   FED,F
0A2B6:  MOVFF  FEF,8BA
0A2BA:  MOVFF  8A9,8B9
0A2BE:  MOVFF  8A8,8B8
0A2C2:  MOVFF  8A7,8B7
0A2C6:  MOVFF  8A6,8B6
0A2CA:  MOVLB  0
0A2CC:  CALL   95D0
0A2D0:  MOVFF  03,8AE
0A2D4:  MOVFF  02,8AD
0A2D8:  MOVFF  01,8AC
0A2DC:  MOVFF  00,8AB
0A2E0:  MOVLB  8
....................                } 
....................                break; 
0A2E2:  MOVLB  7
0A2E4:  BRA    A640
0A2E6:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A2E8:  BCF    FD8.0
0A2EA:  MOVLB  7
0A2EC:  RLCF   x3C,W
0A2EE:  CLRF   03
0A2F0:  ADDLW  B7
0A2F2:  MOVWF  FE9
0A2F4:  MOVLW  07
0A2F6:  ADDWFC 03,W
0A2F8:  MOVWF  FEA
0A2FA:  MOVFF  FEC,8B5
0A2FE:  MOVF   FED,F
0A300:  MOVFF  FEF,8B4
0A304:  MOVLB  8
0A306:  MOVF   xA9,F
0A308:  BNZ   A326
0A30A:  MOVF   xA8,F
0A30C:  BNZ   A326
0A30E:  MOVF   xA7,W
0A310:  SUBWF  xB5,W
0A312:  BNC   A326
0A314:  BNZ   A31C
0A316:  MOVF   xA6,W
0A318:  SUBWF  xB4,W
0A31A:  BNC   A326
....................                { 
....................                   terminate(0); 
0A31C:  CLRF   xC8
0A31E:  MOVLB  0
0A320:  CALL   9010
0A324:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A326:  BCF    FD8.0
0A328:  MOVLB  7
0A32A:  RLCF   x3C,W
0A32C:  CLRF   03
0A32E:  ADDLW  76
0A330:  MOVWF  FE9
0A332:  MOVLW  07
0A334:  ADDWFC 03,W
0A336:  MOVWF  FEA
0A338:  MOVFF  FEC,8B5
0A33C:  MOVF   FED,F
0A33E:  MOVFF  FEF,8B4
0A342:  MOVLB  8
0A344:  MOVF   xB4,F
0A346:  BNZ   A3AC
0A348:  MOVF   xB5,F
0A34A:  BNZ   A3AC
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A34C:  CLRF   03
0A34E:  MOVLB  7
0A350:  MOVF   x3C,W
0A352:  ADDLW  C7
0A354:  MOVWF  FE9
0A356:  MOVLW  07
0A358:  ADDWFC 03,W
0A35A:  MOVWF  FEA
0A35C:  MOVF   FEF,F
0A35E:  BNZ   A3AA
....................                   { 
....................                      wrt_m_error(); 
0A360:  MOVLB  0
0A362:  CALL   8EC0
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A366:  BCF    FD8.0
0A368:  MOVLB  7
0A36A:  RLCF   x3C,W
0A36C:  CLRF   03
0A36E:  ADDLW  B3
0A370:  MOVWF  FE9
0A372:  MOVLW  07
0A374:  ADDWFC 03,W
0A376:  MOVWF  FEA
0A378:  MOVFF  FEC,8BB
0A37C:  MOVF   FED,F
0A37E:  MOVFF  FEF,8BA
0A382:  MOVFF  8A9,8B9
0A386:  MOVFF  8A8,8B8
0A38A:  MOVFF  8A7,8B7
0A38E:  MOVFF  8A6,8B6
0A392:  MOVLB  0
0A394:  CALL   95D0
0A398:  MOVFF  03,8AE
0A39C:  MOVFF  02,8AD
0A3A0:  MOVFF  01,8AC
0A3A4:  MOVFF  00,8AB
0A3A8:  MOVLB  7
0A3AA:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A3AC:  BCF    FD8.0
0A3AE:  MOVLB  7
0A3B0:  RLCF   x3C,W
0A3B2:  CLRF   03
0A3B4:  ADDLW  76
0A3B6:  MOVWF  FE9
0A3B8:  MOVLW  07
0A3BA:  ADDWFC 03,W
0A3BC:  MOVWF  FEA
0A3BE:  MOVFF  FEC,8B5
0A3C2:  MOVF   FED,F
0A3C4:  MOVFF  FEF,8B4
0A3C8:  MOVLB  8
0A3CA:  DECFSZ xB4,W
0A3CC:  BRA    A432
0A3CE:  MOVF   xB5,F
0A3D0:  BNZ   A432
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A3D2:  CLRF   03
0A3D4:  MOVLB  7
0A3D6:  MOVF   x3C,W
0A3D8:  ADDLW  C7
0A3DA:  MOVWF  FE9
0A3DC:  MOVLW  07
0A3DE:  ADDWFC 03,W
0A3E0:  MOVWF  FEA
0A3E2:  DECFSZ FEF,W
0A3E4:  BRA    A430
....................                   { 
....................                      wrt_m_error(); 
0A3E6:  MOVLB  0
0A3E8:  CALL   8EC0
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A3EC:  BCF    FD8.0
0A3EE:  MOVLB  7
0A3F0:  RLCF   x3C,W
0A3F2:  CLRF   03
0A3F4:  ADDLW  B3
0A3F6:  MOVWF  FE9
0A3F8:  MOVLW  07
0A3FA:  ADDWFC 03,W
0A3FC:  MOVWF  FEA
0A3FE:  MOVFF  FEC,8BB
0A402:  MOVF   FED,F
0A404:  MOVFF  FEF,8BA
0A408:  MOVFF  8A9,8B9
0A40C:  MOVFF  8A8,8B8
0A410:  MOVFF  8A7,8B7
0A414:  MOVFF  8A6,8B6
0A418:  MOVLB  0
0A41A:  CALL   95D0
0A41E:  MOVFF  03,8AE
0A422:  MOVFF  02,8AD
0A426:  MOVFF  01,8AC
0A42A:  MOVFF  00,8AB
0A42E:  MOVLB  7
0A430:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A432:  MOVLB  7
0A434:  BRA    A640
0A436:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A438:  MOVLB  7
0A43A:  MOVF   x3C,W
0A43C:  MULLW  04
0A43E:  MOVF   FF3,W
0A440:  CLRF   03
0A442:  ADDLW  9E
0A444:  MOVWF  FE9
0A446:  MOVLW  07
0A448:  ADDWFC 03,W
0A44A:  MOVWF  FEA
0A44C:  MOVFF  FEF,8B4
0A450:  MOVFF  FEC,8B5
0A454:  MOVFF  FEC,8B6
0A458:  MOVFF  FEC,8B7
0A45C:  MOVLB  8
0A45E:  MOVF   xAB,W
0A460:  SUBWF  xB4,F
0A462:  MOVF   xAC,W
0A464:  SUBWFB xB5,F
0A466:  MOVF   xAD,W
0A468:  SUBWFB xB6,F
0A46A:  MOVF   xAE,W
0A46C:  SUBWFB xB7,F
0A46E:  BNZ   A486
0A470:  MOVF   xB6,F
0A472:  BNZ   A486
0A474:  MOVF   xB2,W
0A476:  SUBWF  xB5,W
0A478:  BTFSS  FD8.0
0A47A:  BRA    A582
0A47C:  BNZ   A486
0A47E:  MOVF   xB1,W
0A480:  SUBWF  xB4,W
0A482:  BTFSS  FD8.0
0A484:  BRA    A582
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A486:  BCF    FD8.0
0A488:  MOVLB  7
0A48A:  RLCF   x3C,W
0A48C:  CLRF   03
0A48E:  ADDLW  62
0A490:  MOVWF  01
0A492:  MOVLW  07
0A494:  ADDWFC 03,F
0A496:  MOVLB  8
0A498:  MOVFF  03,8B5
0A49C:  BCF    FD8.0
0A49E:  MOVLB  7
0A4A0:  RLCF   x3C,W
0A4A2:  CLRF   03
0A4A4:  ADDLW  9A
0A4A6:  MOVWF  FE9
0A4A8:  MOVLW  07
0A4AA:  ADDWFC 03,W
0A4AC:  MOVWF  FEA
0A4AE:  MOVFF  FEC,03
0A4B2:  MOVF   FED,F
0A4B4:  MOVFF  FEF,8B6
0A4B8:  MOVLB  8
0A4BA:  MOVFF  8B5,FEA
0A4BE:  MOVFF  01,FE9
0A4C2:  MOVFF  03,FEC
0A4C6:  MOVF   FED,F
0A4C8:  MOVFF  8B6,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A4CC:  MOVLB  7
0A4CE:  MOVF   x3C,W
0A4D0:  MULLW  04
0A4D2:  MOVF   FF3,W
0A4D4:  CLRF   03
0A4D6:  ADDLW  9E
0A4D8:  MOVWF  FE9
0A4DA:  MOVLW  07
0A4DC:  ADDWFC 03,W
0A4DE:  MOVWF  FEA
0A4E0:  MOVFF  FEF,8B4
0A4E4:  MOVFF  FEC,8B5
0A4E8:  MOVFF  FEC,8B6
0A4EC:  MOVFF  FEC,8B7
0A4F0:  MOVLW  78
0A4F2:  MOVWF  FF6
0A4F4:  MOVLW  1A
0A4F6:  MOVWF  FF7
0A4F8:  MOVLW  00
0A4FA:  MOVWF  FF8
0A4FC:  CLRF   1B
0A4FE:  BTFSC  FF2.7
0A500:  BSF    1B.7
0A502:  BCF    FF2.7
0A504:  MOVLW  0B
0A506:  MOVLB  A
0A508:  MOVWF  x18
0A50A:  MOVLB  0
0A50C:  CALL   1010
0A510:  BTFSC  1B.7
0A512:  BSF    FF2.7
0A514:  MOVLW  41
0A516:  MOVWF  FE9
0A518:  CLRF   1B
0A51A:  BTFSC  FF2.7
0A51C:  BSF    1B.7
0A51E:  BCF    FF2.7
0A520:  MOVFF  8B7,A1B
0A524:  MOVFF  8B6,A1A
0A528:  MOVFF  8B5,A19
0A52C:  MOVFF  8B4,A18
0A530:  CALL   10D6
0A534:  BTFSC  1B.7
0A536:  BSF    FF2.7
0A538:  MOVLW  2C
0A53A:  BTFSS  F9E.4
0A53C:  BRA    A53A
0A53E:  MOVWF  FAD
0A540:  MOVLW  41
0A542:  MOVWF  FE9
0A544:  CLRF   1B
0A546:  BTFSC  FF2.7
0A548:  BSF    1B.7
0A54A:  BCF    FF2.7
0A54C:  MOVFF  8AE,A1B
0A550:  MOVFF  8AD,A1A
0A554:  MOVFF  8AC,A19
0A558:  MOVFF  8AB,A18
0A55C:  CALL   10D6
0A560:  BTFSC  1B.7
0A562:  BSF    FF2.7
0A564:  MOVLW  0D
0A566:  BTFSS  F9E.4
0A568:  BRA    A566
0A56A:  MOVWF  FAD
0A56C:  MOVLW  0A
0A56E:  BTFSS  F9E.4
0A570:  BRA    A56E
0A572:  MOVWF  FAD
....................                   terminate(1); 
0A574:  MOVLW  01
0A576:  MOVLB  8
0A578:  MOVWF  xC8
0A57A:  MOVLB  0
0A57C:  CALL   9010
0A580:  MOVLB  8
....................                } 
....................                break; 
0A582:  MOVLB  7
0A584:  BRA    A640
0A586:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A588:  MOVLB  7
0A58A:  MOVF   x3C,W
0A58C:  MULLW  04
0A58E:  MOVF   FF3,W
0A590:  CLRF   03
0A592:  ADDLW  9E
0A594:  MOVWF  FE9
0A596:  MOVLW  07
0A598:  ADDWFC 03,W
0A59A:  MOVWF  FEA
0A59C:  MOVFF  FEF,8B4
0A5A0:  MOVFF  FEC,8B5
0A5A4:  MOVFF  FEC,8B6
0A5A8:  MOVFF  FEC,8B7
0A5AC:  BCF    FD8.0
0A5AE:  RLCF   x3C,W
0A5B0:  CLRF   03
0A5B2:  ADDLW  6E
0A5B4:  MOVWF  FE9
0A5B6:  MOVLW  07
0A5B8:  ADDWFC 03,W
0A5BA:  MOVWF  FEA
0A5BC:  MOVFF  FEC,03
0A5C0:  MOVF   FED,F
0A5C2:  MOVFF  FEF,01
0A5C6:  MOVLB  8
0A5C8:  MOVF   xB7,F
0A5CA:  BNZ   A5DE
0A5CC:  MOVF   xB6,F
0A5CE:  BNZ   A5DE
0A5D0:  MOVF   03,W
0A5D2:  SUBWF  xB5,W
0A5D4:  BNC   A63E
0A5D6:  BNZ   A5DE
0A5D8:  MOVF   01,W
0A5DA:  SUBWF  xB4,W
0A5DC:  BNC   A63E
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A5DE:  BCF    FD8.0
0A5E0:  MOVLB  7
0A5E2:  RLCF   x3C,W
0A5E4:  CLRF   03
0A5E6:  ADDLW  62
0A5E8:  MOVWF  01
0A5EA:  MOVLW  07
0A5EC:  ADDWFC 03,F
0A5EE:  MOVLB  8
0A5F0:  MOVFF  03,8B5
0A5F4:  BCF    FD8.0
0A5F6:  MOVLB  7
0A5F8:  RLCF   x3C,W
0A5FA:  CLRF   03
0A5FC:  ADDLW  9A
0A5FE:  MOVWF  FE9
0A600:  MOVLW  07
0A602:  ADDWFC 03,W
0A604:  MOVWF  FEA
0A606:  MOVFF  FEC,03
0A60A:  MOVF   FED,F
0A60C:  MOVFF  FEF,8B6
0A610:  MOVLB  8
0A612:  MOVFF  8B5,FEA
0A616:  MOVFF  01,FE9
0A61A:  MOVFF  03,FEC
0A61E:  MOVF   FED,F
0A620:  MOVFF  8B6,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A624:  BCF    FD8.0
0A626:  MOVLB  7
0A628:  RLCF   x3C,W
0A62A:  CLRF   03
0A62C:  ADDLW  B7
0A62E:  MOVWF  FE9
0A630:  MOVLW  07
0A632:  ADDWFC 03,W
0A634:  MOVWF  FEA
0A636:  CLRF   FEC
0A638:  MOVF   FED,F
0A63A:  CLRF   FEF
0A63C:  MOVLB  8
....................                } 
....................                break; 
0A63E:  MOVLB  7
....................             } 
....................          } 
0A640:  MOVLB  0
0A642:  BRA    A134
0A644:  MOVLB  7
....................       } 
....................    } 
0A646:  BRA    A664
0A648:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A64A:  BCF    FD8.0
0A64C:  MOVLB  7
0A64E:  RLCF   x3C,W
0A650:  CLRF   03
0A652:  ADDLW  92
0A654:  MOVWF  FE9
0A656:  MOVLW  07
0A658:  ADDWFC 03,W
0A65A:  MOVWF  FEA
0A65C:  CLRF   FEC
0A65E:  MOVF   FED,F
0A660:  MOVLW  01
0A662:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A664:  BCF    FD8.0
0A666:  RLCF   x3C,W
0A668:  CLRF   03
0A66A:  ADDLW  92
0A66C:  MOVWF  FE9
0A66E:  MOVLW  07
0A670:  ADDWFC 03,W
0A672:  MOVWF  FEA
0A674:  MOVFF  FEC,8B5
0A678:  MOVF   FED,F
0A67A:  MOVFF  FEF,8B4
0A67E:  MOVLB  8
0A680:  DECFSZ xB4,W
0A682:  BRA    A694
0A684:  MOVF   xB5,F
0A686:  BNZ   A694
....................       wrt_m_error(); 
0A688:  MOVLB  0
0A68A:  CALL   8EC0
....................       msg_mer(); 
0A68E:  CALL   9C42
0A692:  MOVLB  8
....................    } 
0A694:  MOVLB  0
0A696:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
16BC0:  MOVF   44,F
16BC2:  BNZ   16BD0
16BC4:  MOVF   45,F
16BC6:  BNZ   16BD0
16BC8:  MOVF   46,F
16BCA:  BNZ   16BD0
16BCC:  MOVF   47,F
16BCE:  BZ    16BFC
16BD0:  MOVF   47,F
16BD2:  BNZ   16BFC
16BD4:  MOVF   46,W
16BD6:  SUBLW  00
16BD8:  BNC   16BFC
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
16BDA:  MOVFF  862,8A4
16BDE:  MOVFF  863,8A5
16BE2:  MOVFF  47,8A9
16BE6:  MOVFF  46,8A8
16BEA:  MOVFF  45,8A7
16BEE:  MOVFF  44,8A6
16BF2:  MOVFF  864,8AA
16BF6:  CALL   9CB8
....................    } 
16BFA:  BRA    16C78
....................    else if(arg==0) 
16BFC:  MOVF   44,F
16BFE:  BNZ   16C74
16C00:  MOVF   45,F
16C02:  BNZ   16C74
16C04:  MOVF   46,F
16C06:  BNZ   16C74
16C08:  MOVF   47,F
16C0A:  BNZ   16C74
....................    { 
....................       m_lin_pos[motor]=0; 
16C0C:  BCF    FD8.0
16C0E:  MOVLB  7
16C10:  RLCF   x3C,W
16C12:  CLRF   03
16C14:  ADDLW  AF
16C16:  MOVWF  FE9
16C18:  MOVLW  07
16C1A:  ADDWFC 03,W
16C1C:  MOVWF  FEA
16C1E:  CLRF   FEC
16C20:  MOVF   FED,F
16C22:  CLRF   FEF
....................       switch (motor){ 
16C24:  MOVF   x3C,W
16C26:  XORLW  00
16C28:  MOVLB  0
16C2A:  BZ    16C32
16C2C:  XORLW  01
16C2E:  BZ    16C44
16C30:  BRA    16C54
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
16C32:  MOVLW  B6
16C34:  MOVLB  8
16C36:  MOVWF  xCB
16C38:  CLRF   xCD
16C3A:  CLRF   xCC
16C3C:  MOVLB  0
16C3E:  CALL   4F56
....................             break; 
16C42:  BRA    16C54
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
16C44:  MOVLW  B8
16C46:  MOVLB  8
16C48:  MOVWF  xCB
16C4A:  CLRF   xCD
16C4C:  CLRF   xCC
16C4E:  MOVLB  0
16C50:  CALL   4F56
....................             break; 
....................       }  
....................       m_error[motor]=0; 
16C54:  BCF    FD8.0
16C56:  MOVLB  7
16C58:  RLCF   x3C,W
16C5A:  CLRF   03
16C5C:  ADDLW  92
16C5E:  MOVWF  FE9
16C60:  MOVLW  07
16C62:  ADDWFC 03,W
16C64:  MOVWF  FEA
16C66:  CLRF   FEC
16C68:  MOVF   FED,F
16C6A:  CLRF   FEF
....................       wrt_m_error(); 
16C6C:  MOVLB  0
16C6E:  CALL   8EC0
....................    } 
16C72:  BRA    16C78
....................    else cmd_arg(); 
16C74:  CALL   AF70
16C78:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
1866A:  MOVLW  01
1866C:  MOVLB  8
1866E:  MOVWF  xC9
18670:  MOVLB  0
18672:  CALL   8910
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
18676:  MOVLW  FA
18678:  MOVLB  9
1867A:  MOVWF  xC9
1867C:  MOVLB  0
1867E:  CALL   2898
....................       switch(motor) 
18682:  MOVLB  7
18684:  MOVF   x3C,W
18686:  XORLW  00
18688:  MOVLB  0
1868A:  BZ    18692
1868C:  XORLW  01
1868E:  BZ    186A4
18690:  BRA    186B4
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18692:  MOVLB  8
18694:  CLRF   x62
18696:  BTFSC  F81.4
18698:  INCF   x62,F
....................             chanA = input(ENC1_PHA); 
1869A:  CLRF   x63
1869C:  BTFSC  F81.1
1869E:  INCF   x63,F
....................             break; 
186A0:  MOVLB  0
186A2:  BRA    186B4
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
186A4:  MOVLB  8
186A6:  CLRF   x62
186A8:  BTFSC  F81.5
186AA:  INCF   x62,F
....................             chanA = input(ENC2_PHA); 
186AC:  CLRF   x63
186AE:  BTFSC  F81.2
186B0:  INCF   x63,F
....................             break; 
186B2:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
186B4:  MOVLW  8E
186B6:  MOVWF  FF6
186B8:  MOVLW  1A
186BA:  MOVWF  FF7
186BC:  MOVLW  00
186BE:  MOVWF  FF8
186C0:  CLRF   1B
186C2:  BTFSC  FF2.7
186C4:  BSF    1B.7
186C6:  BCF    FF2.7
186C8:  MOVLW  04
186CA:  MOVLB  A
186CC:  MOVWF  x18
186CE:  MOVLB  0
186D0:  CALL   1010
186D4:  BTFSC  1B.7
186D6:  BSF    FF2.7
186D8:  CLRF   1B
186DA:  BTFSC  FF2.7
186DC:  BSF    1B.7
186DE:  BCF    FF2.7
186E0:  MOVFF  862,A18
186E4:  MOVLW  1B
186E6:  MOVLB  A
186E8:  MOVWF  x19
186EA:  MOVLB  0
186EC:  CALL   0F92
186F0:  BTFSC  1B.7
186F2:  BSF    FF2.7
186F4:  MOVLW  94
186F6:  MOVWF  FF6
186F8:  MOVLW  1A
186FA:  MOVWF  FF7
186FC:  MOVLW  00
186FE:  MOVWF  FF8
18700:  CLRF   1B
18702:  BTFSC  FF2.7
18704:  BSF    1B.7
18706:  BCF    FF2.7
18708:  MOVLW  07
1870A:  MOVLB  A
1870C:  MOVWF  x18
1870E:  MOVLB  0
18710:  CALL   1010
18714:  BTFSC  1B.7
18716:  BSF    FF2.7
18718:  CLRF   1B
1871A:  BTFSC  FF2.7
1871C:  BSF    1B.7
1871E:  BCF    FF2.7
18720:  MOVFF  863,A18
18724:  MOVLW  1B
18726:  MOVLB  A
18728:  MOVWF  x19
1872A:  MOVLB  0
1872C:  CALL   0F92
18730:  BTFSC  1B.7
18732:  BSF    FF2.7
18734:  MOVLW  0D
18736:  BTFSS  F9E.4
18738:  BRA    18736
1873A:  MOVWF  FAD
1873C:  MOVLW  0A
1873E:  BTFSS  F9E.4
18740:  BRA    1873E
18742:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
18744:  BTFSS  F9E.5
18746:  BRA    18754
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
18748:  CALL   0E24
1874C:  MOVF   01,W
1874E:  SUBLW  1B
18750:  BNZ   18754
....................          { 
....................             break; 
18752:  BRA    18756
....................          } 
....................       } 
18754:  BRA    18676
....................    } 
....................  
....................    delay_ms(100); 
18756:  MOVLW  64
18758:  MOVLB  9
1875A:  MOVWF  xC9
1875C:  MOVLB  0
1875E:  CALL   2898
....................    enc_pwr(OFF); 
18762:  MOVLB  8
18764:  CLRF   xC9
18766:  MOVLB  0
18768:  CALL   8910
1876C:  GOTO   18788 (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A7F4:  BCF    FD8.0
0A7F6:  MOVLB  7
0A7F8:  RLCF   x3C,W
0A7FA:  CLRF   03
0A7FC:  ADDLW  62
0A7FE:  MOVWF  FE9
0A800:  MOVLW  07
0A802:  ADDWFC 03,W
0A804:  MOVWF  FEA
0A806:  MOVFF  FEC,8A3
0A80A:  MOVF   FED,F
0A80C:  MOVFF  FEF,8A2
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A810:  BCF    FD8.0
0A812:  RLCF   x3C,W
0A814:  CLRF   03
0A816:  ADDLW  72
0A818:  MOVWF  FE9
0A81A:  MOVLW  07
0A81C:  ADDWFC 03,W
0A81E:  MOVWF  FEA
0A820:  MOVFF  FEC,8B9
0A824:  MOVF   FED,F
0A826:  MOVFF  FEF,8B8
0A82A:  BCF    FD8.0
0A82C:  RLCF   x3C,W
0A82E:  CLRF   03
0A830:  ADDLW  5E
0A832:  MOVWF  FE9
0A834:  MOVLW  07
0A836:  ADDWFC 03,W
0A838:  MOVWF  FEA
0A83A:  MOVFF  FEC,03
0A83E:  MOVF   FED,F
0A840:  MOVFF  FEF,8BA
0A844:  MOVFF  03,8A7
0A848:  MOVFF  03,8BB
0A84C:  MOVLB  0
0A84E:  CALL   2C5C
0A852:  MOVFF  02,8A1
0A856:  MOVFF  01,8A0
....................    e_mode[motor] = 0;                          // motor steps 
0A85A:  BCF    FD8.0
0A85C:  MOVLB  7
0A85E:  RLCF   x3C,W
0A860:  CLRF   03
0A862:  ADDLW  62
0A864:  MOVWF  FE9
0A866:  MOVLW  07
0A868:  ADDWFC 03,W
0A86A:  MOVWF  FEA
0A86C:  CLRF   FEC
0A86E:  MOVF   FED,F
0A870:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A872:  MOVLB  8
0A874:  CLRF   xA4
0A876:  MOVFF  89F,8A5
0A87A:  CLRF   xA9
0A87C:  CLRF   xA8
0A87E:  MOVFF  8A1,8A7
0A882:  MOVFF  8A0,8A6
0A886:  MOVLW  01
0A888:  MOVWF  xAA
0A88A:  MOVLB  0
0A88C:  CALL   9CB8
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A890:  MOVLW  01
0A892:  MOVLB  8
0A894:  MOVWF  xC9
0A896:  MOVLB  0
0A898:  CALL   8910
....................    delay_ms(100); 
0A89C:  MOVLW  64
0A89E:  MOVLB  9
0A8A0:  MOVWF  xC9
0A8A2:  MOVLB  0
0A8A4:  CALL   2898
....................    poll_index(); 
0A8A8:  BRA    A6C2
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A8AA:  BCF    FD8.0
0A8AC:  MOVLB  7
0A8AE:  RLCF   x3C,W
0A8B0:  CLRF   03
0A8B2:  ADDLW  5A
0A8B4:  MOVWF  FE9
0A8B6:  MOVLW  07
0A8B8:  ADDWFC 03,W
0A8BA:  MOVWF  FEA
0A8BC:  MOVFF  FEC,8A5
0A8C0:  MOVF   FED,F
0A8C2:  MOVFF  FEF,8A4
0A8C6:  MOVLW  02
0A8C8:  MOVLB  8
0A8CA:  ADDWF  xA4,W
0A8CC:  MOVWF  xA0
0A8CE:  MOVLW  00
0A8D0:  ADDWFC xA5,W
0A8D2:  MOVWF  xA1
....................    e_mode[motor] = 3; 
0A8D4:  BCF    FD8.0
0A8D6:  MOVLB  7
0A8D8:  RLCF   x3C,W
0A8DA:  CLRF   03
0A8DC:  ADDLW  62
0A8DE:  MOVWF  FE9
0A8E0:  MOVLW  07
0A8E2:  ADDWFC 03,W
0A8E4:  MOVWF  FEA
0A8E6:  CLRF   FEC
0A8E8:  MOVF   FED,F
0A8EA:  MOVLW  03
0A8EC:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A8EE:  MOVLB  8
0A8F0:  CLRF   xA4
0A8F2:  MOVFF  89F,8A5
0A8F6:  CLRF   xA9
0A8F8:  CLRF   xA8
0A8FA:  MOVFF  8A1,8A7
0A8FE:  MOVFF  8A0,8A6
0A902:  MOVLW  01
0A904:  MOVWF  xAA
0A906:  MOVLB  0
0A908:  CALL   9CB8
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A90C:  MOVFF  77F,8A1
0A910:  MOVFF  77E,8A0
....................    e_mode[motor] = 0;                          // motor steps 
0A914:  BCF    FD8.0
0A916:  MOVLB  7
0A918:  RLCF   x3C,W
0A91A:  CLRF   03
0A91C:  ADDLW  62
0A91E:  MOVWF  FE9
0A920:  MOVLW  07
0A922:  ADDWFC 03,W
0A924:  MOVWF  FEA
0A926:  CLRF   FEC
0A928:  MOVF   FED,F
0A92A:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0A92C:  MOVLB  8
0A92E:  CLRF   xA4
0A930:  MOVFF  89F,8A5
0A934:  CLRF   xA9
0A936:  CLRF   xA8
0A938:  MOVFF  8A1,8A7
0A93C:  MOVFF  8A0,8A6
0A940:  MOVLW  01
0A942:  MOVWF  xAA
0A944:  MOVLB  0
0A946:  CALL   9CB8
....................  
....................    e_pos[motor] = 0; 
0A94A:  BCF    FD8.0
0A94C:  MOVLB  7
0A94E:  RLCF   x3C,W
0A950:  CLRF   03
0A952:  ADDLW  BB
0A954:  MOVWF  FE9
0A956:  MOVLW  07
0A958:  ADDWFC 03,W
0A95A:  MOVWF  FEA
0A95C:  CLRF   FEC
0A95E:  MOVF   FED,F
0A960:  CLRF   FEF
....................    e_port[motor] = 1; 
0A962:  BCF    FD8.0
0A964:  RLCF   x3C,W
0A966:  CLRF   03
0A968:  ADDLW  BF
0A96A:  MOVWF  FE9
0A96C:  MOVLW  07
0A96E:  ADDWFC 03,W
0A970:  MOVWF  FEA
0A972:  CLRF   FEC
0A974:  MOVF   FED,F
0A976:  MOVLW  01
0A978:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0A97A:  BCF    FD8.0
0A97C:  RLCF   x3C,W
0A97E:  CLRF   03
0A980:  ADDLW  62
0A982:  MOVWF  FE9
0A984:  MOVLW  07
0A986:  ADDWFC 03,W
0A988:  MOVWF  FEA
0A98A:  MOVFF  8A3,FEC
0A98E:  MOVF   FED,F
0A990:  MOVFF  8A2,FEF
0A994:  MOVLB  0
0A996:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0DDB6:  BCF    FD8.0
0DDB8:  MOVLB  7
0DDBA:  RLCF   x3C,W
0DDBC:  CLRF   03
0DDBE:  ADDLW  5A
0DDC0:  MOVWF  FE9
0DDC2:  MOVLW  07
0DDC4:  ADDWFC 03,W
0DDC6:  MOVWF  FEA
0DDC8:  MOVFF  FEC,866
0DDCC:  MOVF   FED,F
0DDCE:  MOVFF  FEF,865
0DDD2:  MOVLW  02
0DDD4:  MOVLB  8
0DDD6:  ADDWF  x65,W
0DDD8:  MOVWF  x63
0DDDA:  MOVLW  00
0DDDC:  ADDWFC x66,W
0DDDE:  MOVWF  x64
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0DDE0:  CLRF   xA4
0DDE2:  MOVFF  862,8A5
0DDE6:  CLRF   xA9
0DDE8:  CLRF   xA8
0DDEA:  MOVFF  864,8A7
0DDEE:  MOVFF  863,8A6
0DDF2:  MOVLW  02
0DDF4:  MOVWF  xAA
0DDF6:  MOVLB  0
0DDF8:  CALL   9CB8
0DDFC:  GOTO   DE7C (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0A998:  MOVF   2F,W
0A99A:  SUBLW  02
0A99C:  BNZ   A9A2
0A99E:  MOVF   30,F
0A9A0:  BZ    AA02
....................    { 
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0A9A2:  MOVLW  A0
0A9A4:  MOVWF  FF6
0A9A6:  MOVLW  1A
0A9A8:  MOVWF  FF7
0A9AA:  MOVLW  00
0A9AC:  MOVWF  FF8
0A9AE:  CLRF   1B
0A9B0:  BTFSC  FF2.7
0A9B2:  BSF    1B.7
0A9B4:  BCF    FF2.7
0A9B6:  CALL   0E3A
0A9BA:  BTFSC  1B.7
0A9BC:  BSF    FF2.7
....................       motor=0; 
0A9BE:  MOVLB  7
0A9C0:  CLRF   x3C
....................       align(0); 
0A9C2:  MOVLB  8
0A9C4:  CLRF   x9F
0A9C6:  MOVLB  0
0A9C8:  RCALL  A7F4
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0A9CA:  MOVLW  01
0A9CC:  MOVLB  7
0A9CE:  MOVWF  x3C
....................       move_motor(0,0,22000,1); 
0A9D0:  MOVLB  8
0A9D2:  CLRF   xA4
0A9D4:  CLRF   xA5
0A9D6:  CLRF   xA9
0A9D8:  CLRF   xA8
0A9DA:  MOVLW  55
0A9DC:  MOVWF  xA7
0A9DE:  MOVLW  F0
0A9E0:  MOVWF  xA6
0A9E2:  MOVLW  01
0A9E4:  MOVWF  xAA
0A9E6:  MOVLB  0
0A9E8:  CALL   9CB8
....................        
....................       m_lin_pos[1]=0; 
0A9EC:  MOVLB  7
0A9EE:  CLRF   xB2
0A9F0:  CLRF   xB1
....................       write16(ADDR_M2_LIN_POS,0); 
0A9F2:  MOVLW  B8
0A9F4:  MOVLB  8
0A9F6:  MOVWF  xCB
0A9F8:  CLRF   xCD
0A9FA:  CLRF   xCC
0A9FC:  MOVLB  0
0A9FE:  CALL   4F56
....................    } 
0AA02:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0BE74:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BE76:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0BE78:  BCF    F8E.3
....................   delay_ms(20); 
0BE7A:  MOVLW  14
0BE7C:  MOVLB  9
0BE7E:  MOVWF  xC9
0BE80:  MOVLB  0
0BE82:  CALL   2898
....................   output_bit(VMOT,  OFF); 
0BE86:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0BE88:  BCF    F8E.2
0BE8A:  GOTO   BEE0 (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BE8E:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BE90:  BSF    F8E.1
....................   delay_ms(50); 
0BE92:  MOVLW  32
0BE94:  MOVLB  9
0BE96:  MOVWF  xC9
0BE98:  MOVLB  0
0BE9A:  CALL   2898
....................   output_bit(HB_IN1,ON);           
0BE9E:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BEA0:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0BEA2:  BSF    F8E.3
0BEA4:  GOTO   BEE0 (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BEA8:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BEAA:  BSF    F8E.1
....................   delay_ms(50); 
0BEAC:  MOVLW  32
0BEAE:  MOVLB  9
0BEB0:  MOVWF  xC9
0BEB2:  MOVLB  0
0BEB4:  CALL   2898
....................   output_bit(HB_IN1,OFF);           
0BEB8:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0BEBA:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0BEBC:  BSF    F8E.3
0BEBE:  GOTO   BEE0 (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0BEC2:  MOVLB  8
0BEC4:  MOVF   x92,W
0BEC6:  XORLW  00
0BEC8:  MOVLB  0
0BECA:  BZ    BED6
0BECC:  XORLW  01
0BECE:  BZ    BEDA
0BED0:  XORLW  03
0BED2:  BZ    BEDE
0BED4:  BRA    BEE0
....................       case 0:  HB_all_OFF(); 
0BED6:  BRA    BE74
....................          break; 
0BED8:  BRA    BEE0
....................       case 1:  HB_m1_ON(); 
0BEDA:  BRA    BE8E
....................          break; 
0BEDC:  BRA    BEE0
....................       case 2:  HB_m2_ON(); 
0BEDE:  BRA    BEA8
....................          break; 
....................    } 
0BEE0:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
158D6:  MOVLB  8
158D8:  CLRF   x66
158DA:  CLRF   x67
158DC:  CLRF   x68
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
158DE:  MOVLB  0
158E0:  BRA    1586C
158E2:  MOVFF  01,867
....................       if (serChar) 
158E6:  MOVLB  8
158E8:  MOVF   x67,F
158EA:  BZ    15914
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
158EC:  MOVF   x67,W
158EE:  SUBLW  24
158F0:  BNZ   158FA
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
158F2:  MOVLW  02
158F4:  MOVWF  x68
....................             break; 
158F6:  BRA    15920
....................          }else if (serChar == 'D'){ 
158F8:  BRA    15914
158FA:  MOVF   x67,W
158FC:  SUBLW  44
158FE:  BNZ   15910
....................             wakeup_char_is_D = 1; 
15900:  MOVLW  01
15902:  MOVLB  7
15904:  MOVWF  xC9
....................             wakeUpReason = WAKE_UP_GOOD; 
15906:  MOVLW  02
15908:  MOVLB  8
1590A:  MOVWF  x68
....................             break; 
1590C:  BRA    15920
....................          }else 
1590E:  BRA    15914
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
15910:  MOVLW  01
15912:  MOVWF  x68
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
15914:  INCF   x66,F
15916:  MOVF   x66,W
15918:  SUBLW  02
1591A:  BC    1591E
....................       { 
....................          break; 
1591C:  BRA    15920
....................       } 
1591E:  BRA    158DE
....................    } 
....................  
....................    return (wakeUpReason); 
15920:  MOVFF  868,01
15924:  MOVLB  0
15926:  GOTO   1593A (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
15804:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
15806:  BSF    49.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
15808:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
1580A:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
1580C:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
1580E:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
15810:  BSF    FF2.6
15812:  GOTO   1581E (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
15816:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
15818:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
1581A:  BCF    49.0
....................    set_usart_int(); 
1581C:  BRA    15804
....................    kill_wd(); 
1581E:  CALL   307E
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
15822:  BSF    FF2.4
....................    sleep();  
15824:  MOVFF  FD3,00
15828:  BCF    FD1.7
1582A:  BCF    FD3.7
1582C:  SLEEP 
1582E:  MOVFF  00,FD3
....................    delay_cycles(1); 
15832:  NOP   
15834:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
1592A:  MOVLB  8
1592C:  CLRF   x65
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
1592E:  MOVLB  0
15930:  RCALL  15836
....................  
....................    if (TRUE != rtc_alarm) 
15932:  BTFSC  49.0
15934:  BRA    159F2
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
15936:  RCALL  15836
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
15938:  BRA    158D6
1593A:  MOVFF  01,865
....................       if (WAKE_UP_GOOD == serWakeupReason) 
1593E:  MOVLB  8
15940:  MOVF   x65,W
15942:  SUBLW  02
15944:  BNZ   159EA
....................       { 
....................          sleep_mode = FALSE; 
15946:  BCF    49.1
....................          start_heartbeat(); 
15948:  MOVLB  0
1594A:  CALL   2888
....................          init_hardware(); 
1594E:  CALL   28C2
....................          init_rtc();                      // This is the FAT RTC 
15952:  CALL   3490
....................          sd_status = init_sdcard(); 
15956:  CALL   4FBC
1595A:  MOVFF  01,2D8
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
1595E:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
15960:  MOVLW  01
15962:  MOVWF  1E
15964:  MOVLW  A3
15966:  MOVWF  1D
15968:  MOVLW  D6
1596A:  MOVWF  FF6
1596C:  MOVLW  1A
1596E:  MOVWF  FF7
15970:  MOVLW  00
15972:  MOVWF  FF8
15974:  CALL   5040
....................          record_event(); 
15978:  CALL   841A
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
1597C:  CLRF   32
1597E:  MOVLW  01
15980:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
15982:  MOVLW  02
15984:  MOVLB  8
15986:  MOVWF  x66
15988:  MOVFF  31,867
1598C:  MOVLB  0
1598E:  CALL   339A
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
15992:  MOVLB  7
15994:  MOVF   xC9,F
15996:  BZ    159B8
....................             file_list(file_ptr_rel_new); 
15998:  MOVLW  03
1599A:  MOVLB  8
1599C:  MOVWF  x67
1599E:  MOVWF  x66
159A0:  MOVLB  0
159A2:  CALL   B796
....................             f_unlink(file_ptr_rel_new); 
159A6:  MOVLW  03
159A8:  MOVLB  8
159AA:  MOVWF  x67
159AC:  MOVWF  x66
159AE:  MOVLB  0
159B0:  CALL   B910
....................              
....................             wakeup_char_is_D = 0; 
159B4:  MOVLB  7
159B6:  CLRF   xC9
....................          } 
....................          if(sd_status>0) 
159B8:  MOVLB  2
159BA:  MOVF   xD8,F
159BC:  BZ    159C6
....................          { 
....................             msg_card_fail(); 
159BE:  MOVLB  0
159C0:  CALL   5002
159C4:  MOVLB  2
....................          } 
....................  
....................          fprintf(COM_A, "@RST\r\n"); 
159C6:  MOVLW  F8
159C8:  MOVWF  FF6
159CA:  MOVLW  1A
159CC:  MOVWF  FF7
159CE:  MOVLW  00
159D0:  MOVWF  FF8
159D2:  CLRF   1B
159D4:  BTFSC  FF2.7
159D6:  BSF    1B.7
159D8:  BCF    FF2.7
159DA:  MOVLB  0
159DC:  CALL   0E3A
159E0:  BTFSC  1B.7
159E2:  BSF    FF2.7
....................          reset_cpu(); 
159E4:  RESET
....................       } 
159E6:  BRA    159F2
159E8:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
159EA:  DECFSZ x65,W
159EC:  BRA    159F4
....................          { 
....................             initilizeSleepState(); 
159EE:  MOVLB  0
159F0:  RCALL  15816
159F2:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
159F4:  MOVLW  00
159F6:  BTFSC  49.0
159F8:  MOVLW  01
159FA:  MOVWF  01
159FC:  MOVLB  0
159FE:  GOTO   15A08 (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
15A02:  RCALL  1579A
....................    initilizeSleepState(); 
15A04:  RCALL  15816
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
15A06:  BRA    1592A
15A08:  DECFSZ 01,W
15A0A:  BRA    15A10
....................       { 
....................          rtc_alarm = FALSE; 
15A0C:  BCF    49.0
....................          break; 
15A0E:  BRA    15A16
....................       } 
....................  
....................       blip(); 
15A10:  RCALL  15836
....................       blip(); 
15A12:  RCALL  15836
15A14:  BRA    15A06
....................    } 
15A16:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0AAFE:  MOVF   FD0,W
0AB00:  ANDLW  0F
0AB02:  BTFSS  FD0.4
0AB04:  MOVLW  00
0AB06:  BSF    FD0.0
0AB08:  BSF    FD0.1
0AB0A:  BSF    FD0.4
0AB0C:  BSF    FD8.3
0AB0E:  BSF    FD8.4
0AB10:  ADDLW  F0
0AB12:  BTFSC  FD8.0
0AB14:  BRA    ACE4
0AB16:  ADDLW  10
0AB18:  GOTO   ACE8
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0AB1C:  MOVLW  00
0AB1E:  MOVWF  FF6
0AB20:  MOVLW  1B
0AB22:  MOVWF  FF7
0AB24:  MOVLW  00
0AB26:  MOVWF  FF8
0AB28:  CLRF   1B
0AB2A:  BTFSC  FF2.7
0AB2C:  BSF    1B.7
0AB2E:  BCF    FF2.7
0AB30:  CALL   0E3A
0AB34:  BTFSC  1B.7
0AB36:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0AB38:  MOVLW  01
0AB3A:  MOVWF  1E
0AB3C:  MOVLW  A3
0AB3E:  MOVWF  1D
0AB40:  MOVLW  08
0AB42:  MOVWF  FF6
0AB44:  MOVLW  1B
0AB46:  MOVWF  FF7
0AB48:  MOVLW  00
0AB4A:  MOVWF  FF8
0AB4C:  CALL   5040
....................          record_event(); 
0AB50:  CALL   841A
....................          recovery(); 
0AB54:  RCALL  A998
....................          break; 
0AB56:  BRA    ACE4
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AB58:  MOVLW  26
0AB5A:  MOVWF  FF6
0AB5C:  MOVLW  1B
0AB5E:  MOVWF  FF7
0AB60:  MOVLW  00
0AB62:  MOVWF  FF8
0AB64:  CLRF   1B
0AB66:  BTFSC  FF2.7
0AB68:  BSF    1B.7
0AB6A:  BCF    FF2.7
0AB6C:  CALL   0E3A
0AB70:  BTFSC  1B.7
0AB72:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AB74:  MOVLW  01
0AB76:  MOVWF  1E
0AB78:  MOVLW  A3
0AB7A:  MOVWF  1D
0AB7C:  MOVLW  2E
0AB7E:  MOVWF  FF6
0AB80:  MOVLW  1B
0AB82:  MOVWF  FF7
0AB84:  MOVLW  00
0AB86:  MOVWF  FF8
0AB88:  CALL   5040
....................          record_event(); 
0AB8C:  CALL   841A
....................          recovery(); 
0AB90:  RCALL  A998
....................          break; 
0AB92:  BRA    ACE4
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0AB94:  MOVLW  4E
0AB96:  MOVWF  FF6
0AB98:  MOVLW  1B
0AB9A:  MOVWF  FF7
0AB9C:  MOVLW  00
0AB9E:  MOVWF  FF8
0ABA0:  CLRF   1B
0ABA2:  BTFSC  FF2.7
0ABA4:  BSF    1B.7
0ABA6:  BCF    FF2.7
0ABA8:  CALL   0E3A
0ABAC:  BTFSC  1B.7
0ABAE:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0ABB0:  MOVLW  01
0ABB2:  MOVWF  1E
0ABB4:  MOVLW  A3
0ABB6:  MOVWF  1D
0ABB8:  MOVLW  56
0ABBA:  MOVWF  FF6
0ABBC:  MOVLW  1B
0ABBE:  MOVWF  FF7
0ABC0:  MOVLW  00
0ABC2:  MOVWF  FF8
0ABC4:  MOVLW  05
0ABC6:  MOVLB  8
0ABC8:  MOVWF  xC8
0ABCA:  MOVLB  0
0ABCC:  RCALL  AA04
0ABCE:  MOVLW  10
0ABD0:  MOVWF  FE9
0ABD2:  MOVFF  26,8D4
0ABD6:  MOVFF  25,8D3
0ABDA:  RCALL  AA36
0ABDC:  MOVLW  5E
0ABDE:  MOVWF  FF6
0ABE0:  MOVLW  1B
0ABE2:  MOVWF  FF7
0ABE4:  MOVLW  00
0ABE6:  MOVWF  FF8
0ABE8:  MOVLW  20
0ABEA:  MOVLB  8
0ABEC:  MOVWF  xC8
0ABEE:  MOVLB  0
0ABF0:  RCALL  AA04
....................          record_event(); 
0ABF2:  CALL   841A
....................          break; 
0ABF6:  BRA    ACE4
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0ABF8:  MOVLW  80
0ABFA:  MOVWF  FF6
0ABFC:  MOVLW  1B
0ABFE:  MOVWF  FF7
0AC00:  MOVLW  00
0AC02:  MOVWF  FF8
0AC04:  CLRF   1B
0AC06:  BTFSC  FF2.7
0AC08:  BSF    1B.7
0AC0A:  BCF    FF2.7
0AC0C:  CALL   0E3A
0AC10:  BTFSC  1B.7
0AC12:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0AC14:  MOVLW  01
0AC16:  MOVWF  1E
0AC18:  MOVLW  A3
0AC1A:  MOVWF  1D
0AC1C:  MOVLW  88
0AC1E:  MOVWF  FF6
0AC20:  MOVLW  1B
0AC22:  MOVWF  FF7
0AC24:  MOVLW  00
0AC26:  MOVWF  FF8
0AC28:  CALL   5040
....................          record_event(); 
0AC2C:  CALL   841A
....................          break; 
0AC30:  BRA    ACE4
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0AC32:  MOVLW  AC
0AC34:  MOVWF  FF6
0AC36:  MOVLW  1B
0AC38:  MOVWF  FF7
0AC3A:  MOVLW  00
0AC3C:  MOVWF  FF8
0AC3E:  CLRF   1B
0AC40:  BTFSC  FF2.7
0AC42:  BSF    1B.7
0AC44:  BCF    FF2.7
0AC46:  CALL   0E3A
0AC4A:  BTFSC  1B.7
0AC4C:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AC4E:  MOVLW  01
0AC50:  MOVWF  1E
0AC52:  MOVLW  A3
0AC54:  MOVWF  1D
0AC56:  MOVLW  B4
0AC58:  MOVWF  FF6
0AC5A:  MOVLW  1B
0AC5C:  MOVWF  FF7
0AC5E:  MOVLW  00
0AC60:  MOVWF  FF8
0AC62:  CALL   5040
....................          record_event(); 
0AC66:  CALL   841A
....................          recovery(); 
0AC6A:  RCALL  A998
....................          break; 
0AC6C:  BRA    ACE4
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AC6E:  MOVLW  D0
0AC70:  MOVWF  FF6
0AC72:  MOVLW  1B
0AC74:  MOVWF  FF7
0AC76:  MOVLW  00
0AC78:  MOVWF  FF8
0AC7A:  CLRF   1B
0AC7C:  BTFSC  FF2.7
0AC7E:  BSF    1B.7
0AC80:  BCF    FF2.7
0AC82:  CALL   0E3A
0AC86:  BTFSC  1B.7
0AC88:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0AC8A:  MOVLW  01
0AC8C:  MOVWF  1E
0AC8E:  MOVLW  A3
0AC90:  MOVWF  1D
0AC92:  MOVLW  D8
0AC94:  MOVWF  FF6
0AC96:  MOVLW  1B
0AC98:  MOVWF  FF7
0AC9A:  MOVLW  00
0AC9C:  MOVWF  FF8
0AC9E:  CALL   5040
....................          record_event(); 
0ACA2:  CALL   841A
....................          recovery(); 
0ACA6:  RCALL  A998
....................          break; 
0ACA8:  BRA    ACE4
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0ACAA:  MOVLW  FA
0ACAC:  MOVWF  FF6
0ACAE:  MOVLW  1B
0ACB0:  MOVWF  FF7
0ACB2:  MOVLW  00
0ACB4:  MOVWF  FF8
0ACB6:  CLRF   1B
0ACB8:  BTFSC  FF2.7
0ACBA:  BSF    1B.7
0ACBC:  BCF    FF2.7
0ACBE:  CALL   0E3A
0ACC2:  BTFSC  1B.7
0ACC4:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0ACC6:  MOVLW  01
0ACC8:  MOVWF  1E
0ACCA:  MOVLW  A3
0ACCC:  MOVWF  1D
0ACCE:  MOVLW  02
0ACD0:  MOVWF  FF6
0ACD2:  MOVLW  1C
0ACD4:  MOVWF  FF7
0ACD6:  MOVLW  00
0ACD8:  MOVWF  FF8
0ACDA:  CALL   5040
....................          record_event(); 
0ACDE:  CALL   841A
....................          recovery(); 
0ACE2:  RCALL  A998
....................          break; 
....................       }         
....................    } 
0ACE4:  GOTO   1B292 (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02A40:  MOVLW  1E
02A42:  MOVLB  8
02A44:  MOVWF  x74
02A46:  MOVLB  0
02A48:  RCALL  2952
02A4A:  MOVFF  02,30
02A4E:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02A52:  MOVLW  1C
02A54:  MOVLB  8
02A56:  MOVWF  x74
02A58:  MOVLB  0
02A5A:  RCALL  2952
02A5C:  MOVFF  02,20
02A60:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02A64:  MOVLW  16
02A66:  MOVLB  8
02A68:  MOVWF  x74
02A6A:  MOVLB  0
02A6C:  RCALL  2952
02A6E:  MOVFF  02,22
02A72:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02A76:  MOVLW  14
02A78:  MOVLB  8
02A7A:  MOVWF  x74
02A7C:  MOVLB  0
02A7E:  RCALL  2952
02A80:  MOVFF  02,24
02A84:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02A88:  MOVLB  8
02A8A:  CLRF   x74
02A8C:  MOVLB  0
02A8E:  RCALL  2952
02A90:  MOVFF  02,26
02A94:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02A98:  MOVLW  18
02A9A:  MOVLB  8
02A9C:  MOVWF  x74
02A9E:  MOVLB  0
02AA0:  RCALL  2952
02AA2:  MOVFF  02,28
02AA6:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02AAA:  MOVLW  02
02AAC:  MOVLB  8
02AAE:  MOVWF  x94
02AB0:  MOVLB  0
02AB2:  RCALL  29AC
02AB4:  CLRF   32
02AB6:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02ABA:  MOVLW  28
02ABC:  MOVLB  8
02ABE:  MOVWF  x94
02AC0:  MOVLB  0
02AC2:  RCALL  29AC
02AC4:  CLRF   34
02AC6:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02ACA:  MOVLW  12
02ACC:  MOVLB  8
02ACE:  MOVWF  x74
02AD0:  MOVLB  0
02AD2:  RCALL  2952
02AD4:  MOVFF  02,36
02AD8:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02ADC:  MOVLW  3A
02ADE:  MOVLB  8
02AE0:  MOVWF  x74
02AE2:  MOVLB  0
02AE4:  RCALL  2952
02AE6:  MOVFF  02,38
02AEA:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02AEE:  MOVLW  3C
02AF0:  MOVLB  8
02AF2:  MOVWF  x74
02AF4:  MOVLB  0
02AF6:  RCALL  2952
02AF8:  MOVFF  02,3A
02AFC:  MOVFF  01,39
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02B00:  MOVLW  3E
02B02:  MOVLB  8
02B04:  MOVWF  x74
02B06:  MOVLB  0
02B08:  RCALL  2952
02B0A:  MOVFF  02,3C
02B0E:  MOVFF  01,3B
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02B12:  MOVLW  40
02B14:  MOVLB  8
02B16:  MOVWF  x74
02B18:  MOVLB  0
02B1A:  RCALL  2952
02B1C:  MOVFF  02,3E
02B20:  MOVFF  01,3D
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02B24:  MOVLW  42
02B26:  MOVLB  8
02B28:  MOVWF  x74
02B2A:  MOVLB  0
02B2C:  RCALL  2952
02B2E:  MOVFF  02,40
02B32:  MOVFF  01,3F
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02B36:  MOVLW  04
02B38:  MOVLB  8
02B3A:  MOVWF  x94
02B3C:  MOVLB  0
02B3E:  RCALL  29AC
02B40:  MOVFF  01,729
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02B44:  MOVLB  8
02B46:  CLRF   x63
02B48:  MOVLW  44
02B4A:  MOVWF  x62
02B4C:  MOVLB  0
02B4E:  RCALL  29D2
02B50:  MOVFF  03,3F4
02B54:  MOVFF  02,3F3
02B58:  MOVFF  01,3F2
02B5C:  MOVFF  00,3F1
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02B60:  MOVLB  8
02B62:  CLRF   x63
02B64:  MOVLW  48
02B66:  MOVWF  x62
02B68:  MOVLB  0
02B6A:  RCALL  29D2
02B6C:  MOVFF  03,3F8
02B70:  MOVFF  02,3F7
02B74:  MOVFF  01,3F6
02B78:  MOVFF  00,3F5
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02B7C:  MOVLB  8
02B7E:  CLRF   x63
02B80:  MOVLW  4C
02B82:  MOVWF  x62
02B84:  MOVLB  0
02B86:  RCALL  29D2
02B88:  MOVFF  03,3FC
02B8C:  MOVFF  02,3FB
02B90:  MOVFF  01,3FA
02B94:  MOVFF  00,3F9
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02B98:  MOVLB  8
02B9A:  CLRF   x63
02B9C:  MOVLW  52
02B9E:  MOVWF  x62
02BA0:  MOVLB  0
02BA2:  RCALL  29D2
02BA4:  MOVFF  03,400
02BA8:  MOVFF  02,3FF
02BAC:  MOVFF  01,3FE
02BB0:  MOVFF  00,3FD
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02BB4:  MOVLB  8
02BB6:  CLRF   x63
02BB8:  MOVLW  56
02BBA:  MOVWF  x62
02BBC:  MOVLB  0
02BBE:  RCALL  29D2
02BC0:  MOVFF  03,404
02BC4:  MOVFF  02,403
02BC8:  MOVFF  01,402
02BCC:  MOVFF  00,401
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02BD0:  MOVLB  8
02BD2:  CLRF   x63
02BD4:  MOVLW  5A
02BD6:  MOVWF  x62
02BD8:  MOVLB  0
02BDA:  RCALL  29D2
02BDC:  MOVFF  03,408
02BE0:  MOVFF  02,407
02BE4:  MOVFF  01,406
02BE8:  MOVFF  00,405
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02BEC:  MOVLB  8
02BEE:  CLRF   x63
02BF0:  MOVLW  5E
02BF2:  MOVWF  x62
02BF4:  MOVLB  0
02BF6:  RCALL  29D2
02BF8:  MOVFF  03,40C
02BFC:  MOVFF  02,40B
02C00:  MOVFF  01,40A
02C04:  MOVFF  00,409
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02C08:  MOVLB  8
02C0A:  CLRF   x63
02C0C:  MOVLW  62
02C0E:  MOVWF  x62
02C10:  MOVLB  0
02C12:  RCALL  29D2
02C14:  MOVFF  03,410
02C18:  MOVFF  02,40F
02C1C:  MOVFF  01,40E
02C20:  MOVFF  00,40D
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02C24:  MOVLW  20
02C26:  MOVLB  8
02C28:  MOVWF  x74
02C2A:  MOVLB  0
02C2C:  RCALL  2952
02C2E:  MOVFF  02,2A
02C32:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02C36:  MOVLW  22
02C38:  MOVLB  8
02C3A:  MOVWF  x74
02C3C:  MOVLB  0
02C3E:  RCALL  2952
02C40:  MOVFF  02,2C
02C44:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02C48:  MOVLW  24
02C4A:  MOVLB  8
02C4C:  MOVWF  x74
02C4E:  MOVLB  0
02C50:  RCALL  2952
02C52:  MOVFF  02,2E
02C56:  MOVFF  01,2D
02C5A:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DBAE:  MOVLW  1C
0DBB0:  MOVLB  8
0DBB2:  MOVWF  xCB
0DBB4:  CLRF   xCD
0DBB6:  CLRF   xCC
0DBB8:  MOVLB  0
0DBBA:  CALL   4F56
....................    write16(ADDR_SAMPLE,0); 
0DBBE:  MOVLW  16
0DBC0:  MOVLB  8
0DBC2:  MOVWF  xCB
0DBC4:  CLRF   xCD
0DBC6:  CLRF   xCC
0DBC8:  MOVLB  0
0DBCA:  CALL   4F56
....................    write16(ADDR_INTERVAL,60); 
0DBCE:  MOVLW  14
0DBD0:  MOVLB  8
0DBD2:  MOVWF  xCB
0DBD4:  CLRF   xCD
0DBD6:  MOVLW  3C
0DBD8:  MOVWF  xCC
0DBDA:  MOVLB  0
0DBDC:  CALL   4F56
....................    write16(ADDR_SERIALNO,9999); 
0DBE0:  MOVLB  8
0DBE2:  CLRF   xCB
0DBE4:  MOVLW  27
0DBE6:  MOVWF  xCD
0DBE8:  MOVLW  0F
0DBEA:  MOVWF  xCC
0DBEC:  MOVLB  0
0DBEE:  CALL   4F56
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DBF2:  MOVLW  18
0DBF4:  MOVLB  8
0DBF6:  MOVWF  xCB
0DBF8:  MOVLW  0D
0DBFA:  MOVWF  xCD
0DBFC:  MOVLW  20
0DBFE:  MOVWF  xCC
0DC00:  MOVLB  0
0DC02:  CALL   4F56
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DC06:  MOVLW  02
0DC08:  MOVLB  8
0DC0A:  MOVWF  x66
0DC0C:  MOVLW  01
0DC0E:  MOVWF  x67
0DC10:  MOVLB  0
0DC12:  CALL   339A
....................    write16(ADDR_MACRO_STEP, 0); 
0DC16:  MOVLW  3A
0DC18:  MOVLB  8
0DC1A:  MOVWF  xCB
0DC1C:  CLRF   xCD
0DC1E:  CLRF   xCC
0DC20:  MOVLB  0
0DC22:  CALL   4F56
....................    write16(ADDR_COM_ERR,3); 
0DC26:  MOVLW  3C
0DC28:  MOVLB  8
0DC2A:  MOVWF  xCB
0DC2C:  CLRF   xCD
0DC2E:  MOVLW  03
0DC30:  MOVWF  xCC
0DC32:  MOVLB  0
0DC34:  CALL   4F56
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DC38:  MOVLW  04
0DC3A:  MOVLB  8
0DC3C:  MOVWF  x66
0DC3E:  MOVLW  0A
0DC40:  MOVWF  x67
0DC42:  MOVLB  0
0DC44:  CALL   339A
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DC48:  MOVLB  8
0DC4A:  CLRF   x63
0DC4C:  MOVLW  44
0DC4E:  MOVWF  x62
0DC50:  CLRF   x67
0DC52:  CLRF   x66
0DC54:  CLRF   x65
0DC56:  MOVLW  7F
0DC58:  MOVWF  x64
0DC5A:  MOVLB  0
0DC5C:  CALL   CA54
....................    write_float(ADDR_CAL_C1,0); 
0DC60:  MOVLB  8
0DC62:  CLRF   x63
0DC64:  MOVLW  48
0DC66:  MOVWF  x62
0DC68:  CLRF   x67
0DC6A:  CLRF   x66
0DC6C:  CLRF   x65
0DC6E:  CLRF   x64
0DC70:  MOVLB  0
0DC72:  CALL   CA54
....................    write_float(ADDR_CAL_M2,1); 
0DC76:  MOVLB  8
0DC78:  CLRF   x63
0DC7A:  MOVLW  4C
0DC7C:  MOVWF  x62
0DC7E:  CLRF   x67
0DC80:  CLRF   x66
0DC82:  CLRF   x65
0DC84:  MOVLW  7F
0DC86:  MOVWF  x64
0DC88:  MOVLB  0
0DC8A:  CALL   CA54
....................    write_float(ADDR_CAL_C2,0); 
0DC8E:  MOVLB  8
0DC90:  CLRF   x63
0DC92:  MOVLW  52
0DC94:  MOVWF  x62
0DC96:  CLRF   x67
0DC98:  CLRF   x66
0DC9A:  CLRF   x65
0DC9C:  CLRF   x64
0DC9E:  MOVLB  0
0DCA0:  CALL   CA54
....................    write_float(ADDR_CAL_M3,1); 
0DCA4:  MOVLB  8
0DCA6:  CLRF   x63
0DCA8:  MOVLW  56
0DCAA:  MOVWF  x62
0DCAC:  CLRF   x67
0DCAE:  CLRF   x66
0DCB0:  CLRF   x65
0DCB2:  MOVLW  7F
0DCB4:  MOVWF  x64
0DCB6:  MOVLB  0
0DCB8:  CALL   CA54
....................    write_float(ADDR_CAL_C3,0); 
0DCBC:  MOVLB  8
0DCBE:  CLRF   x63
0DCC0:  MOVLW  5A
0DCC2:  MOVWF  x62
0DCC4:  CLRF   x67
0DCC6:  CLRF   x66
0DCC8:  CLRF   x65
0DCCA:  CLRF   x64
0DCCC:  MOVLB  0
0DCCE:  CALL   CA54
....................    write_float(ADDR_CAL_M4,1); 
0DCD2:  MOVLB  8
0DCD4:  CLRF   x63
0DCD6:  MOVLW  5E
0DCD8:  MOVWF  x62
0DCDA:  CLRF   x67
0DCDC:  CLRF   x66
0DCDE:  CLRF   x65
0DCE0:  MOVLW  7F
0DCE2:  MOVWF  x64
0DCE4:  MOVLB  0
0DCE6:  CALL   CA54
....................    write_float(ADDR_CAL_C4,0);  
0DCEA:  MOVLB  8
0DCEC:  CLRF   x63
0DCEE:  MOVLW  62
0DCF0:  MOVWF  x62
0DCF2:  CLRF   x67
0DCF4:  CLRF   x66
0DCF6:  CLRF   x65
0DCF8:  CLRF   x64
0DCFA:  MOVLB  0
0DCFC:  CALL   CA54
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0DD00:  MOVLW  40
0DD02:  MOVLB  8
0DD04:  MOVWF  xCB
0DD06:  MOVLW  4E
0DD08:  MOVWF  xCD
0DD0A:  MOVLW  20
0DD0C:  MOVWF  xCC
0DD0E:  MOVLB  0
0DD10:  CALL   4F56
....................    write16(ADDR_D2_TEMP,20000); 
0DD14:  MOVLW  42
0DD16:  MOVLB  8
0DD18:  MOVWF  xCB
0DD1A:  MOVLW  4E
0DD1C:  MOVWF  xCD
0DD1E:  MOVLW  20
0DD20:  MOVWF  xCC
0DD22:  MOVLB  0
0DD24:  CALL   4F56
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0DD28:  MOVLW  20
0DD2A:  MOVLB  8
0DD2C:  MOVWF  xCB
0DD2E:  CLRF   xCD
0DD30:  CLRF   xCC
0DD32:  MOVLB  0
0DD34:  CALL   4F56
....................    write16(ADDR_VOLUME,22500);  
0DD38:  MOVLW  22
0DD3A:  MOVLB  8
0DD3C:  MOVWF  xCB
0DD3E:  MOVLW  57
0DD40:  MOVWF  xCD
0DD42:  MOVLW  E4
0DD44:  MOVWF  xCC
0DD46:  MOVLB  0
0DD48:  CALL   4F56
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0DD4C:  MOVF   2F,W
0DD4E:  SUBLW  02
0DD50:  BNZ   DD56
0DD52:  MOVF   30,F
0DD54:  BZ    DD6A
0DD56:  MOVLW  24
0DD58:  MOVLB  8
0DD5A:  MOVWF  xCB
0DD5C:  CLRF   xCD
0DD5E:  MOVLW  02
0DD60:  MOVWF  xCC
0DD62:  MOVLB  0
0DD64:  CALL   4F56
0DD68:  BRA    DD7C
....................    else write16(ADDR_PORT,1); 
0DD6A:  MOVLW  24
0DD6C:  MOVLB  8
0DD6E:  MOVWF  xCB
0DD70:  CLRF   xCD
0DD72:  MOVLW  01
0DD74:  MOVWF  xCC
0DD76:  MOVLB  0
0DD78:  CALL   4F56
....................     
....................    write16(ADDR_DET_TYPE,1); 
0DD7C:  MOVLW  26
0DD7E:  MOVLB  8
0DD80:  MOVWF  xCB
0DD82:  CLRF   xCD
0DD84:  MOVLW  01
0DD86:  MOVWF  xCC
0DD88:  MOVLB  0
0DD8A:  CALL   4F56
....................     
....................    init_nv_vars(); 
0DD8E:  CALL   2A40
0DD92:  GOTO   DDAC (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
124DA:  MOVLW  02
124DC:  MOVWF  FEA
124DE:  MOVLW  43
124E0:  MOVWF  FE9
124E2:  CLRF   00
124E4:  CLRF   02
124E6:  MOVLW  51
124E8:  MOVWF  01
124EA:  CALL   34AE
124EE:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F610:  MOVLW  03
0F612:  MOVWF  FEA
0F614:  MOVLW  21
0F616:  MOVWF  FE9
0F618:  CLRF   00
0F61A:  CLRF   02
0F61C:  MOVLW  14
0F61E:  MOVWF  01
0F620:  CALL   34AE
0F624:  GOTO   F644 (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
13010:  MOVLB  8
13012:  CLRF   xB1
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
13014:  CLRF   FEA
13016:  MOVLW  4E
13018:  MOVWF  FE9
1301A:  CLRF   00
1301C:  CLRF   02
1301E:  MOVLW  14
13020:  MOVWF  01
13022:  MOVLB  0
13024:  CALL   34AE
....................  
....................    for(n=0; n<20; n++) { 
13028:  MOVLB  8
1302A:  CLRF   xB2
1302C:  MOVF   xB2,W
1302E:  SUBLW  13
13030:  BNC   13076
....................         c = data_buffer[string_pos];  
13032:  CLRF   03
13034:  MOVLB  2
13036:  MOVF   x94,W
13038:  ADDLW  63
1303A:  MOVWF  FE9
1303C:  MOVLW  00
1303E:  ADDWFC 03,W
13040:  MOVWF  FEA
13042:  MOVFF  FEF,8B1
....................         ++string_pos; 
13046:  INCF   x94,F
....................         if (c == '\0') return(1); // found end 
13048:  MOVLB  8
1304A:  MOVF   xB1,F
1304C:  BNZ   13054
1304E:  MOVLW  01
13050:  MOVWF  01
13052:  BRA    1307A
....................         if (c == ',')  return(0); // found seperator  
13054:  MOVF   xB1,W
13056:  SUBLW  2C
13058:  BNZ   13060
1305A:  MOVLW  00
1305C:  MOVWF  01
1305E:  BRA    1307A
....................         sub_string[n] = c; 
13060:  CLRF   03
13062:  MOVF   xB2,W
13064:  ADDLW  4E
13066:  MOVWF  FE9
13068:  MOVLW  00
1306A:  ADDWFC 03,W
1306C:  MOVWF  FEA
1306E:  MOVFF  8B1,FEF
13072:  INCF   xB2,F
13074:  BRA    1302C
....................    } 
....................     
....................    return(2); // failed = bad string 
13076:  MOVLW  02
13078:  MOVWF  01
1307A:  MOVLB  0
1307C:  GOTO   133A6 (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
132BA:  MOVLW  26
132BC:  MOVWF  FF6
132BE:  MOVLW  1C
132C0:  MOVWF  FF7
132C2:  MOVLW  00
132C4:  MOVWF  FF8
132C6:  MOVLW  03
132C8:  MOVWF  FEA
132CA:  MOVLW  39
132CC:  MOVWF  FE9
132CE:  CALL   FB56
132D2:  MOVF   01,W
132D4:  BZ    132E8
132D6:  XORLW  01
132D8:  BZ    13308
132DA:  XORLW  03
132DC:  BZ    13328
132DE:  XORLW  01
132E0:  BZ    13348
132E2:  XORLW  07
132E4:  BZ    13368
132E6:  BRA    13386
....................       case "NO3" : NO3_array[read_i] = result; 
132E8:  BCF    FD8.0
132EA:  MOVLB  3
132EC:  RLCF   x46,W
132EE:  CLRF   03
132F0:  ADDLW  47
132F2:  MOVWF  FE9
132F4:  MOVLW  03
132F6:  ADDWFC 03,W
132F8:  MOVWF  FEA
132FA:  MOVFF  8B2,FEC
132FE:  MOVF   FED,F
13300:  MOVFF  8B1,FEF
....................          break; 
13304:  MOVLB  0
13306:  BRA    13386
....................       case "NO2" : NO2_array[read_i] = result; 
13308:  BCF    FD8.0
1330A:  MOVLB  3
1330C:  RLCF   x46,W
1330E:  CLRF   03
13310:  ADDLW  59
13312:  MOVWF  FE9
13314:  MOVLW  03
13316:  ADDWFC 03,W
13318:  MOVWF  FEA
1331A:  MOVFF  8B2,FEC
1331E:  MOVF   FED,F
13320:  MOVFF  8B1,FEF
....................          break;    
13324:  MOVLB  0
13326:  BRA    13386
....................       case "PO4" : PO4_array[read_i] = result; 
13328:  BCF    FD8.0
1332A:  MOVLB  3
1332C:  RLCF   x46,W
1332E:  CLRF   03
13330:  ADDLW  6B
13332:  MOVWF  FE9
13334:  MOVLW  03
13336:  ADDWFC 03,W
13338:  MOVWF  FEA
1333A:  MOVFF  8B2,FEC
1333E:  MOVF   FED,F
13340:  MOVFF  8B1,FEF
....................          break; 
13344:  MOVLB  0
13346:  BRA    13386
....................       case "NH4" : NH4_array[read_i] = result; 
13348:  BCF    FD8.0
1334A:  MOVLB  3
1334C:  RLCF   x46,W
1334E:  CLRF   03
13350:  ADDLW  7D
13352:  MOVWF  FE9
13354:  MOVLW  03
13356:  ADDWFC 03,W
13358:  MOVWF  FEA
1335A:  MOVFF  8B2,FEC
1335E:  MOVF   FED,F
13360:  MOVFF  8B1,FEF
....................          break; 
13364:  MOVLB  0
13366:  BRA    13386
....................       case "SiO" : SiO_array[read_i] = result; 
13368:  BCF    FD8.0
1336A:  MOVLB  3
1336C:  RLCF   x46,W
1336E:  CLRF   03
13370:  ADDLW  8F
13372:  MOVWF  FE9
13374:  MOVLW  03
13376:  ADDWFC 03,W
13378:  MOVWF  FEA
1337A:  MOVFF  8B2,FEC
1337E:  MOVF   FED,F
13380:  MOVFF  8B1,FEF
....................          break; 
13384:  MOVLB  0
....................    } 
13386:  GOTO   133FE (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
1338A:  MOVLB  8
1338C:  CLRF   xAC
1338E:  CLRF   xAB
13390:  CLRF   xAE
13392:  CLRF   xAD
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
13394:  MOVLB  2
13396:  CLRF   x94
....................     
....................    for (n=0; n<11; ++n){ 
13398:  MOVLB  8
1339A:  CLRF   xAF
1339C:  MOVF   xAF,W
1339E:  SUBLW  0A
133A0:  BNC   133F2
....................       parsed = parse_string(); 
133A2:  MOVLB  0
133A4:  BRA    13010
133A6:  MOVFF  01,8B0
....................       if (parsed == 2) return(0); 
133AA:  MOVLB  8
133AC:  MOVF   xB0,W
133AE:  SUBLW  02
133B0:  BNZ   133BA
133B2:  MOVLW  00
133B4:  MOVWF  01
133B6:  MOVWF  02
133B8:  BRA    13408
....................       if (n==8) result = atol(sub_string); 
133BA:  MOVF   xAF,W
133BC:  SUBLW  08
133BE:  BNZ   133D4
133C0:  CLRF   xB2
133C2:  MOVLW  4E
133C4:  MOVWF  xB1
133C6:  MOVLB  0
133C8:  RCALL  130D6
133CA:  MOVFF  02,8AC
133CE:  MOVFF  01,8AB
133D2:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
133D4:  MOVF   xAF,W
133D6:  SUBLW  0A
133D8:  BNZ   133EE
133DA:  CLRF   xB2
133DC:  MOVLW  4E
133DE:  MOVWF  xB1
133E0:  MOVLB  0
133E2:  RCALL  130D6
133E4:  MOVFF  02,8AE
133E8:  MOVFF  01,8AD
133EC:  MOVLB  8
133EE:  INCF   xAF,F
133F0:  BRA    1339C
....................    } 
....................    load_parsed_data(result); 
133F2:  MOVFF  8AC,8B2
133F6:  MOVFF  8AB,8B1
133FA:  MOVLB  0
133FC:  BRA    132BA
....................    return (temp); 
133FE:  MOVLB  8
13400:  MOVFF  8AD,01
13404:  MOVFF  8AE,02
13408:  MOVLB  0
1340A:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D22E:  CLRF   FEA
0D230:  MOVLW  63
0D232:  MOVWF  FE9
0D234:  CLRF   00
0D236:  CLRF   02
0D238:  MOVLW  A0
0D23A:  MOVWF  01
0D23C:  CALL   34AE
0D240:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F628:  MOVLW  03
0F62A:  MOVWF  FEA
0F62C:  MOVLW  39
0F62E:  MOVWF  FE9
0F630:  MOVLW  00
0F632:  CALL   02E4
0F636:  TBLRD*-
0F638:  TBLRD*+
0F63A:  MOVF   FF5,W
0F63C:  MOVWF  FEE
0F63E:  IORLW  00
0F640:  BNZ   F638
....................  
....................    clear_flag_str(); 
0F642:  BRA    F610
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F644:  MOVLW  08
0F646:  MOVWF  1E
0F648:  MOVLW  CA
0F64A:  MOVWF  1D
0F64C:  MOVLW  10
0F64E:  MOVWF  FE9
0F650:  MOVFF  320,8D4
0F654:  MOVFF  31F,8D3
0F658:  CALL   AA36
....................  
....................    if (macro_flag < 100) { 
0F65C:  MOVLB  3
0F65E:  MOVF   x20,F
0F660:  BNZ   F67A
0F662:  MOVF   x1F,W
0F664:  SUBLW  63
0F666:  BNC   F67A
....................       temp_str[3] = '\0'; 
0F668:  MOVLB  8
0F66A:  CLRF   xCD
....................       temp_str[2] = temp_str[1]; 
0F66C:  MOVFF  8CB,8CC
....................       temp_str[1] = temp_str[0]; 
0F670:  MOVFF  8CA,8CB
....................       temp_str[0] = '0'; 
0F674:  MOVLW  30
0F676:  MOVWF  xCA
0F678:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F67A:  MOVLB  8
0F67C:  MOVF   xCA,W
0F67E:  XORLW  30
0F680:  MOVLB  0
0F682:  BZ    F6A6
0F684:  XORLW  01
0F686:  BZ    F6CC
0F688:  XORLW  03
0F68A:  BZ    F6F2
0F68C:  XORLW  01
0F68E:  BZ    F718
0F690:  XORLW  07
0F692:  BZ    F73E
0F694:  XORLW  01
0F696:  BZ    F764
0F698:  XORLW  03
0F69A:  BTFSC  FD8.2
0F69C:  BRA    F78A
0F69E:  XORLW  01
0F6A0:  BTFSC  FD8.2
0F6A2:  BRA    F7B0
0F6A4:  BRA    F7D8
....................       case '0' : strcopy(chem,"NO3"); 
0F6A6:  MOVLW  03
0F6A8:  MOVWF  FEA
0F6AA:  MOVLW  39
0F6AC:  MOVWF  FE9
0F6AE:  MOVLW  00
0F6B0:  CALL   02FC
0F6B4:  TBLRD*-
0F6B6:  TBLRD*+
0F6B8:  MOVF   FF5,W
0F6BA:  MOVWF  FEE
0F6BC:  IORLW  00
0F6BE:  BNZ   F6B6
....................                  wave_l=543; 
0F6C0:  MOVLW  02
0F6C2:  MOVLB  8
0F6C4:  MOVWF  xC9
0F6C6:  MOVLW  1F
0F6C8:  MOVWF  xC8
....................          break; 
0F6CA:  BRA    F7FC
....................       case '1' : strcopy(chem,"PO4"); 
0F6CC:  MOVLW  03
0F6CE:  MOVWF  FEA
0F6D0:  MOVLW  39
0F6D2:  MOVWF  FE9
0F6D4:  MOVLW  00
0F6D6:  CALL   0314
0F6DA:  TBLRD*-
0F6DC:  TBLRD*+
0F6DE:  MOVF   FF5,W
0F6E0:  MOVWF  FEE
0F6E2:  IORLW  00
0F6E4:  BNZ   F6DC
....................                  wave_l=880;       
0F6E6:  MOVLW  03
0F6E8:  MOVLB  8
0F6EA:  MOVWF  xC9
0F6EC:  MOVLW  70
0F6EE:  MOVWF  xC8
....................          break; 
0F6F0:  BRA    F7FC
....................       case '2' : strcopy(chem,"NH4"); 
0F6F2:  MOVLW  03
0F6F4:  MOVWF  FEA
0F6F6:  MOVLW  39
0F6F8:  MOVWF  FE9
0F6FA:  MOVLW  00
0F6FC:  CALL   032C
0F700:  TBLRD*-
0F702:  TBLRD*+
0F704:  MOVF   FF5,W
0F706:  MOVWF  FEE
0F708:  IORLW  00
0F70A:  BNZ   F702
....................                  wave_l=660;       
0F70C:  MOVLW  02
0F70E:  MOVLB  8
0F710:  MOVWF  xC9
0F712:  MOVLW  94
0F714:  MOVWF  xC8
....................          break; 
0F716:  BRA    F7FC
....................       case '3' : strcopy(chem,"SiO"); 
0F718:  MOVLW  03
0F71A:  MOVWF  FEA
0F71C:  MOVLW  39
0F71E:  MOVWF  FE9
0F720:  MOVLW  00
0F722:  CALL   0344
0F726:  TBLRD*-
0F728:  TBLRD*+
0F72A:  MOVF   FF5,W
0F72C:  MOVWF  FEE
0F72E:  IORLW  00
0F730:  BNZ   F728
....................                  wave_l=810;       
0F732:  MOVLW  03
0F734:  MOVLB  8
0F736:  MOVWF  xC9
0F738:  MOVLW  2A
0F73A:  MOVWF  xC8
....................          break; 
0F73C:  BRA    F7FC
....................       case '4' : strcopy(chem,"Ure"); 
0F73E:  MOVLW  03
0F740:  MOVWF  FEA
0F742:  MOVLW  39
0F744:  MOVWF  FE9
0F746:  MOVLW  00
0F748:  CALL   035C
0F74C:  TBLRD*-
0F74E:  TBLRD*+
0F750:  MOVF   FF5,W
0F752:  MOVWF  FEE
0F754:  IORLW  00
0F756:  BNZ   F74E
....................                  wave_l=525;       
0F758:  MOVLW  02
0F75A:  MOVLB  8
0F75C:  MOVWF  xC9
0F75E:  MOVLW  0D
0F760:  MOVWF  xC8
....................          break; 
0F762:  BRA    F7FC
....................       case '5' : strcopy(chem,"NO2"); 
0F764:  MOVLW  03
0F766:  MOVWF  FEA
0F768:  MOVLW  39
0F76A:  MOVWF  FE9
0F76C:  MOVLW  00
0F76E:  CALL   0374
0F772:  TBLRD*-
0F774:  TBLRD*+
0F776:  MOVF   FF5,W
0F778:  MOVWF  FEE
0F77A:  IORLW  00
0F77C:  BNZ   F774
....................                  wave_l=543;       
0F77E:  MOVLW  02
0F780:  MOVLB  8
0F782:  MOVWF  xC9
0F784:  MOVLW  1F
0F786:  MOVWF  xC8
....................          break; 
0F788:  BRA    F7FC
....................       case '6' : strcopy(chem,"Fe_"); 
0F78A:  MOVLW  03
0F78C:  MOVWF  FEA
0F78E:  MOVLW  39
0F790:  MOVWF  FE9
0F792:  MOVLW  00
0F794:  CALL   038C
0F798:  TBLRD*-
0F79A:  TBLRD*+
0F79C:  MOVF   FF5,W
0F79E:  MOVWF  FEE
0F7A0:  IORLW  00
0F7A2:  BNZ   F79A
....................                  wave_l=543;       
0F7A4:  MOVLW  02
0F7A6:  MOVLB  8
0F7A8:  MOVWF  xC9
0F7AA:  MOVLW  1F
0F7AC:  MOVWF  xC8
....................          break; 
0F7AE:  BRA    F7FC
....................       case '7' : strcopy(chem,"Cl_"); 
0F7B0:  MOVLW  03
0F7B2:  MOVWF  FEA
0F7B4:  MOVLW  39
0F7B6:  MOVWF  FE9
0F7B8:  MOVLW  00
0F7BA:  CALL   03A4
0F7BE:  TBLRD*-
0F7C0:  TBLRD*+
0F7C2:  MOVF   FF5,W
0F7C4:  MOVWF  FEE
0F7C6:  IORLW  00
0F7C8:  BNZ   F7C0
....................                  wave_l=560;       
0F7CA:  MOVLW  02
0F7CC:  MOVLB  8
0F7CE:  MOVWF  xC9
0F7D0:  MOVLW  30
0F7D2:  MOVWF  xC8
....................          break; 
0F7D4:  BRA    F7FC
0F7D6:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0F7D8:  MOVLW  03
0F7DA:  MOVWF  FEA
0F7DC:  MOVLW  39
0F7DE:  MOVWF  FE9
0F7E0:  MOVLW  00
0F7E2:  CALL   02E4
0F7E6:  TBLRD*-
0F7E8:  TBLRD*+
0F7EA:  MOVF   FF5,W
0F7EC:  MOVWF  FEE
0F7EE:  IORLW  00
0F7F0:  BNZ   F7E8
....................                  wave_l=999;       
0F7F2:  MOVLW  03
0F7F4:  MOVLB  8
0F7F6:  MOVWF  xC9
0F7F8:  MOVLW  E7
0F7FA:  MOVWF  xC8
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0F7FC:  MOVF   xCB,W
0F7FE:  XORLW  31
0F800:  MOVLB  0
0F802:  BZ    F822
0F804:  XORLW  03
0F806:  BZ    F83E
0F808:  XORLW  01
0F80A:  BZ    F85A
0F80C:  XORLW  07
0F80E:  BZ    F876
0F810:  XORLW  01
0F812:  BZ    F892
0F814:  XORLW  03
0F816:  BZ    F8AE
0F818:  XORLW  01
0F81A:  BZ    F8CA
0F81C:  XORLW  0F
0F81E:  BZ    F8E6
0F820:  BRA    F902
....................       case '1' : strcopy(anal,"Smp"); 
0F822:  MOVLW  03
0F824:  MOVWF  FEA
0F826:  MOVLW  3E
0F828:  MOVWF  FE9
0F82A:  MOVLW  00
0F82C:  CALL   03BC
0F830:  TBLRD*-
0F832:  TBLRD*+
0F834:  MOVF   FF5,W
0F836:  MOVWF  FEE
0F838:  IORLW  00
0F83A:  BNZ   F832
....................          break; 
0F83C:  BRA    F91C
....................       case '2' : strcopy(anal,"Std"); 
0F83E:  MOVLW  03
0F840:  MOVWF  FEA
0F842:  MOVLW  3E
0F844:  MOVWF  FE9
0F846:  MOVLW  00
0F848:  CALL   03D4
0F84C:  TBLRD*-
0F84E:  TBLRD*+
0F850:  MOVF   FF5,W
0F852:  MOVWF  FEE
0F854:  IORLW  00
0F856:  BNZ   F84E
....................          break; 
0F858:  BRA    F91C
....................       case '3' : strcopy(anal,"Cmb"); 
0F85A:  MOVLW  03
0F85C:  MOVWF  FEA
0F85E:  MOVLW  3E
0F860:  MOVWF  FE9
0F862:  MOVLW  00
0F864:  CALL   03EC
0F868:  TBLRD*-
0F86A:  TBLRD*+
0F86C:  MOVF   FF5,W
0F86E:  MOVWF  FEE
0F870:  IORLW  00
0F872:  BNZ   F86A
....................          break; 
0F874:  BRA    F91C
....................       case '4' : strcopy(anal,"Tst"); 
0F876:  MOVLW  03
0F878:  MOVWF  FEA
0F87A:  MOVLW  3E
0F87C:  MOVWF  FE9
0F87E:  MOVLW  00
0F880:  CALL   0404
0F884:  TBLRD*-
0F886:  TBLRD*+
0F888:  MOVF   FF5,W
0F88A:  MOVWF  FEE
0F88C:  IORLW  00
0F88E:  BNZ   F886
....................          break; 
0F890:  BRA    F91C
....................       case '5' : strcopy(anal,"Rbl"); 
0F892:  MOVLW  03
0F894:  MOVWF  FEA
0F896:  MOVLW  3E
0F898:  MOVWF  FE9
0F89A:  MOVLW  00
0F89C:  CALL   041C
0F8A0:  TBLRD*-
0F8A2:  TBLRD*+
0F8A4:  MOVF   FF5,W
0F8A6:  MOVWF  FEE
0F8A8:  IORLW  00
0F8AA:  BNZ   F8A2
....................          break; 
0F8AC:  BRA    F91C
....................       case '6' : strcopy(anal,"Cal"); 
0F8AE:  MOVLW  03
0F8B0:  MOVWF  FEA
0F8B2:  MOVLW  3E
0F8B4:  MOVWF  FE9
0F8B6:  MOVLW  00
0F8B8:  CALL   0434
0F8BC:  TBLRD*-
0F8BE:  TBLRD*+
0F8C0:  MOVF   FF5,W
0F8C2:  MOVWF  FEE
0F8C4:  IORLW  00
0F8C6:  BNZ   F8BE
....................          break; 
0F8C8:  BRA    F91C
....................       case '7' : strcopy(anal,"Fls"); 
0F8CA:  MOVLW  03
0F8CC:  MOVWF  FEA
0F8CE:  MOVLW  3E
0F8D0:  MOVWF  FE9
0F8D2:  MOVLW  00
0F8D4:  CALL   044C
0F8D8:  TBLRD*-
0F8DA:  TBLRD*+
0F8DC:  MOVF   FF5,W
0F8DE:  MOVWF  FEE
0F8E0:  IORLW  00
0F8E2:  BNZ   F8DA
....................          break; 
0F8E4:  BRA    F91C
....................       case '8' : strcopy(anal,"Utl"); 
0F8E6:  MOVLW  03
0F8E8:  MOVWF  FEA
0F8EA:  MOVLW  3E
0F8EC:  MOVWF  FE9
0F8EE:  MOVLW  00
0F8F0:  CALL   0464
0F8F4:  TBLRD*-
0F8F6:  TBLRD*+
0F8F8:  MOVF   FF5,W
0F8FA:  MOVWF  FEE
0F8FC:  IORLW  00
0F8FE:  BNZ   F8F6
....................          break;     
0F900:  BRA    F91C
....................       default  : strcopy(anal,"XXX"); 
0F902:  MOVLW  03
0F904:  MOVWF  FEA
0F906:  MOVLW  3E
0F908:  MOVWF  FE9
0F90A:  MOVLW  00
0F90C:  CALL   02E4
0F910:  TBLRD*-
0F912:  TBLRD*+
0F914:  MOVF   FF5,W
0F916:  MOVWF  FEE
0F918:  IORLW  00
0F91A:  BNZ   F912
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0F91C:  MOVLB  8
0F91E:  MOVF   xCC,W
0F920:  XORLW  31
0F922:  MOVLB  0
0F924:  BZ    F94E
0F926:  XORLW  03
0F928:  BZ    F96E
0F92A:  XORLW  01
0F92C:  BZ    F990
0F92E:  XORLW  07
0F930:  BZ    F9B2
0F932:  XORLW  01
0F934:  BZ    F9D4
0F936:  XORLW  03
0F938:  BZ    F9F6
0F93A:  XORLW  01
0F93C:  BTFSC  FD8.2
0F93E:  BRA    FA18
0F940:  XORLW  0F
0F942:  BTFSC  FD8.2
0F944:  BRA    FA3A
0F946:  XORLW  01
0F948:  BTFSC  FD8.2
0F94A:  BRA    FA5C
0F94C:  BRA    FA80
....................       case '1' : strcopy(read_t,"I0s"); 
0F94E:  MOVLW  03
0F950:  MOVWF  FEA
0F952:  MOVLW  42
0F954:  MOVWF  FE9
0F956:  MOVLW  00
0F958:  CALL   047C
0F95C:  TBLRD*-
0F95E:  TBLRD*+
0F960:  MOVF   FF5,W
0F962:  MOVWF  FEE
0F964:  IORLW  00
0F966:  BNZ   F95E
....................                  read_i = 0; 
0F968:  MOVLB  3
0F96A:  CLRF   x46
....................          break; 
0F96C:  BRA    FA9E
....................       case '2' : strcopy(read_t,"I1s"); 
0F96E:  MOVLW  03
0F970:  MOVWF  FEA
0F972:  MOVLW  42
0F974:  MOVWF  FE9
0F976:  MOVLW  00
0F978:  CALL   0494
0F97C:  TBLRD*-
0F97E:  TBLRD*+
0F980:  MOVF   FF5,W
0F982:  MOVWF  FEE
0F984:  IORLW  00
0F986:  BNZ   F97E
....................                  read_i = 1;       
0F988:  MOVLW  01
0F98A:  MOVLB  3
0F98C:  MOVWF  x46
....................          break; 
0F98E:  BRA    FA9E
....................       case '3' : strcopy(read_t,"I0t"); 
0F990:  MOVLW  03
0F992:  MOVWF  FEA
0F994:  MOVLW  42
0F996:  MOVWF  FE9
0F998:  MOVLW  00
0F99A:  CALL   04AC
0F99E:  TBLRD*-
0F9A0:  TBLRD*+
0F9A2:  MOVF   FF5,W
0F9A4:  MOVWF  FEE
0F9A6:  IORLW  00
0F9A8:  BNZ   F9A0
....................                  read_i = 2;       
0F9AA:  MOVLW  02
0F9AC:  MOVLB  3
0F9AE:  MOVWF  x46
....................          break; 
0F9B0:  BRA    FA9E
....................       case '4' : strcopy(read_t,"I1t"); 
0F9B2:  MOVLW  03
0F9B4:  MOVWF  FEA
0F9B6:  MOVLW  42
0F9B8:  MOVWF  FE9
0F9BA:  MOVLW  00
0F9BC:  CALL   04C4
0F9C0:  TBLRD*-
0F9C2:  TBLRD*+
0F9C4:  MOVF   FF5,W
0F9C6:  MOVWF  FEE
0F9C8:  IORLW  00
0F9CA:  BNZ   F9C2
....................                  read_i = 3;       
0F9CC:  MOVLW  03
0F9CE:  MOVLB  3
0F9D0:  MOVWF  x46
....................          break; 
0F9D2:  BRA    FA9E
....................       case '5' : strcopy(read_t,"I0r"); 
0F9D4:  MOVLW  03
0F9D6:  MOVWF  FEA
0F9D8:  MOVLW  42
0F9DA:  MOVWF  FE9
0F9DC:  MOVLW  00
0F9DE:  CALL   04DC
0F9E2:  TBLRD*-
0F9E4:  TBLRD*+
0F9E6:  MOVF   FF5,W
0F9E8:  MOVWF  FEE
0F9EA:  IORLW  00
0F9EC:  BNZ   F9E4
....................                  read_i = 4;       
0F9EE:  MOVLW  04
0F9F0:  MOVLB  3
0F9F2:  MOVWF  x46
....................          break; 
0F9F4:  BRA    FA9E
....................       case '6' : strcopy(read_t,"I1r"); 
0F9F6:  MOVLW  03
0F9F8:  MOVWF  FEA
0F9FA:  MOVLW  42
0F9FC:  MOVWF  FE9
0F9FE:  MOVLW  00
0FA00:  CALL   04F4
0FA04:  TBLRD*-
0FA06:  TBLRD*+
0FA08:  MOVF   FF5,W
0FA0A:  MOVWF  FEE
0FA0C:  IORLW  00
0FA0E:  BNZ   FA06
....................                  read_i = 5;       
0FA10:  MOVLW  05
0FA12:  MOVLB  3
0FA14:  MOVWF  x46
....................          break; 
0FA16:  BRA    FA9E
....................       case '7' : strcopy(read_t,"I0u"); 
0FA18:  MOVLW  03
0FA1A:  MOVWF  FEA
0FA1C:  MOVLW  42
0FA1E:  MOVWF  FE9
0FA20:  MOVLW  00
0FA22:  CALL   050C
0FA26:  TBLRD*-
0FA28:  TBLRD*+
0FA2A:  MOVF   FF5,W
0FA2C:  MOVWF  FEE
0FA2E:  IORLW  00
0FA30:  BNZ   FA28
....................                  read_i = 6;       
0FA32:  MOVLW  06
0FA34:  MOVLB  3
0FA36:  MOVWF  x46
....................          break; 
0FA38:  BRA    FA9E
....................       case '8' : strcopy(read_t,"I1u"); 
0FA3A:  MOVLW  03
0FA3C:  MOVWF  FEA
0FA3E:  MOVLW  42
0FA40:  MOVWF  FE9
0FA42:  MOVLW  00
0FA44:  CALL   0524
0FA48:  TBLRD*-
0FA4A:  TBLRD*+
0FA4C:  MOVF   FF5,W
0FA4E:  MOVWF  FEE
0FA50:  IORLW  00
0FA52:  BNZ   FA4A
....................                  read_i = 7;       
0FA54:  MOVLW  07
0FA56:  MOVLB  3
0FA58:  MOVWF  x46
....................          break; 
0FA5A:  BRA    FA9E
....................       case '9' : strcopy(read_t,"Chk"); 
0FA5C:  MOVLW  03
0FA5E:  MOVWF  FEA
0FA60:  MOVLW  42
0FA62:  MOVWF  FE9
0FA64:  MOVLW  00
0FA66:  CALL   053C
0FA6A:  TBLRD*-
0FA6C:  TBLRD*+
0FA6E:  MOVF   FF5,W
0FA70:  MOVWF  FEE
0FA72:  IORLW  00
0FA74:  BNZ   FA6C
....................                  read_i = 8;       
0FA76:  MOVLW  08
0FA78:  MOVLB  3
0FA7A:  MOVWF  x46
....................          break;        
0FA7C:  BRA    FA9E
0FA7E:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0FA80:  MOVLW  03
0FA82:  MOVWF  FEA
0FA84:  MOVLW  42
0FA86:  MOVWF  FE9
0FA88:  MOVLW  00
0FA8A:  CALL   0554
0FA8E:  TBLRD*-
0FA90:  TBLRD*+
0FA92:  MOVF   FF5,W
0FA94:  MOVWF  FEE
0FA96:  IORLW  00
0FA98:  BNZ   FA90
....................                  read_i = 0;       
0FA9A:  MOVLB  3
0FA9C:  CLRF   x46
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FA9E:  MOVLW  03
0FAA0:  MOVLB  8
0FAA2:  MOVWF  xD6
0FAA4:  MOVLW  21
0FAA6:  MOVWF  xD5
0FAA8:  MOVLW  03
0FAAA:  MOVWF  xD8
0FAAC:  MOVLW  39
0FAAE:  MOVWF  xD7
0FAB0:  MOVLB  0
0FAB2:  CALL   5460
....................    strcat(flag_str, (char *)","); 
0FAB6:  MOVLW  2C
0FAB8:  MOVLB  8
0FABA:  MOVWF  xD1
0FABC:  CLRF   xD2
0FABE:  MOVLW  03
0FAC0:  MOVWF  xD6
0FAC2:  MOVLW  21
0FAC4:  MOVWF  xD5
0FAC6:  MOVLW  08
0FAC8:  MOVWF  xD8
0FACA:  MOVLW  D1
0FACC:  MOVWF  xD7
0FACE:  MOVLB  0
0FAD0:  CALL   5460
....................    strcat(flag_str, anal); 
0FAD4:  MOVLW  03
0FAD6:  MOVLB  8
0FAD8:  MOVWF  xD6
0FADA:  MOVLW  21
0FADC:  MOVWF  xD5
0FADE:  MOVLW  03
0FAE0:  MOVWF  xD8
0FAE2:  MOVLW  3E
0FAE4:  MOVWF  xD7
0FAE6:  MOVLB  0
0FAE8:  CALL   5460
....................    strcat(flag_str, (char *)","); 
0FAEC:  MOVLW  2C
0FAEE:  MOVLB  8
0FAF0:  MOVWF  xD1
0FAF2:  CLRF   xD2
0FAF4:  MOVLW  03
0FAF6:  MOVWF  xD6
0FAF8:  MOVLW  21
0FAFA:  MOVWF  xD5
0FAFC:  MOVLW  08
0FAFE:  MOVWF  xD8
0FB00:  MOVLW  D1
0FB02:  MOVWF  xD7
0FB04:  MOVLB  0
0FB06:  CALL   5460
....................    strcat(flag_str, read_t);   
0FB0A:  MOVLW  03
0FB0C:  MOVLB  8
0FB0E:  MOVWF  xD6
0FB10:  MOVLW  21
0FB12:  MOVWF  xD5
0FB14:  MOVLW  03
0FB16:  MOVWF  xD8
0FB18:  MOVLW  42
0FB1A:  MOVWF  xD7
0FB1C:  MOVLB  0
0FB1E:  CALL   5460
....................     
....................    return wave_l; 
0FB22:  MOVLB  8
0FB24:  MOVFF  8C8,01
0FB28:  MOVFF  8C9,02
0FB2C:  MOVLB  0
0FB2E:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F104:  MOVF   43,W
0F106:  SUBLW  4B
0F108:  BTFSC  FD8.2
0F10A:  MOVFF  44,2D2
....................    if (cmd=='L') detector_li = arg; 
0F10E:  MOVF   43,W
0F110:  SUBLW  4C
0F112:  BNZ   F11C
0F114:  MOVFF  45,2D4
0F118:  MOVFF  44,2D3
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F11C:  MOVF   1F,W
0F11E:  SUBLW  04
0F120:  BNZ   F1EA
0F122:  MOVF   20,F
0F124:  BNZ   F1EA
0F126:  MOVLW  3C
0F128:  MOVWF  FF6
0F12A:  MOVLW  1C
0F12C:  MOVWF  FF7
0F12E:  MOVLW  00
0F130:  MOVWF  FF8
0F132:  CLRF   1B
0F134:  BTFSC  FF2.7
0F136:  BSF    1B.7
0F138:  BCF    FF2.7
0F13A:  MOVLW  06
0F13C:  MOVLB  A
0F13E:  MOVWF  x18
0F140:  MOVLB  0
0F142:  CALL   1010
0F146:  BTFSC  1B.7
0F148:  BSF    FF2.7
0F14A:  CLRF   1B
0F14C:  BTFSC  FF2.7
0F14E:  BSF    1B.7
0F150:  BCF    FF2.7
0F152:  MOVFF  2D1,A18
0F156:  MOVLW  1B
0F158:  MOVLB  A
0F15A:  MOVWF  x19
0F15C:  MOVLB  0
0F15E:  CALL   0F92
0F162:  BTFSC  1B.7
0F164:  BSF    FF2.7
0F166:  MOVLW  5D
0F168:  BTFSS  F9E.4
0F16A:  BRA    F168
0F16C:  MOVWF  FAD
0F16E:  MOVLW  5B
0F170:  BTFSS  F9E.4
0F172:  BRA    F170
0F174:  MOVWF  FAD
0F176:  MOVF   43,W
0F178:  BTFSS  F9E.4
0F17A:  BRA    F178
0F17C:  MOVWF  FAD
0F17E:  MOVLW  48
0F180:  MOVWF  FF6
0F182:  MOVLW  1C
0F184:  MOVWF  FF7
0F186:  MOVLW  00
0F188:  MOVWF  FF8
0F18A:  CLRF   1B
0F18C:  BTFSC  FF2.7
0F18E:  BSF    1B.7
0F190:  BCF    FF2.7
0F192:  MOVLW  05
0F194:  MOVLB  A
0F196:  MOVWF  x18
0F198:  MOVLB  0
0F19A:  CALL   1010
0F19E:  BTFSC  1B.7
0F1A0:  BSF    FF2.7
0F1A2:  MOVLW  41
0F1A4:  MOVWF  FE9
0F1A6:  CLRF   1B
0F1A8:  BTFSC  FF2.7
0F1AA:  BSF    1B.7
0F1AC:  BCF    FF2.7
0F1AE:  MOVFF  47,A1B
0F1B2:  MOVFF  46,A1A
0F1B6:  MOVFF  45,A19
0F1BA:  MOVFF  44,A18
0F1BE:  CALL   10D6
0F1C2:  BTFSC  1B.7
0F1C4:  BSF    FF2.7
0F1C6:  MOVLW  50
0F1C8:  MOVWF  FF6
0F1CA:  MOVLW  1C
0F1CC:  MOVWF  FF7
0F1CE:  MOVLW  00
0F1D0:  MOVWF  FF8
0F1D2:  CLRF   1B
0F1D4:  BTFSC  FF2.7
0F1D6:  BSF    1B.7
0F1D8:  BCF    FF2.7
0F1DA:  MOVLW  03
0F1DC:  MOVLB  A
0F1DE:  MOVWF  x18
0F1E0:  MOVLB  0
0F1E2:  CALL   1010
0F1E6:  BTFSC  1B.7
0F1E8:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F1EA:  CALL   D77E
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F1EE:  MOVLW  2F
0F1F0:  BTFSS  FA4.4
0F1F2:  BRA    F1F0
0F1F4:  MOVLB  F
0F1F6:  MOVWF  x1C
0F1F8:  MOVFF  2D1,8D0
0F1FC:  MOVLW  1B
0F1FE:  MOVLB  8
0F200:  MOVWF  xD1
0F202:  MOVLB  0
0F204:  CALL   D7C6
0F208:  MOVF   43,W
0F20A:  BTFSS  FA4.4
0F20C:  BRA    F20A
0F20E:  MOVLB  F
0F210:  MOVWF  x1C
0F212:  MOVLW  41
0F214:  MOVWF  FE9
0F216:  MOVFF  47,8D3
0F21A:  MOVFF  46,8D2
0F21E:  MOVFF  45,8D1
0F222:  MOVFF  44,8D0
0F226:  MOVLB  0
0F228:  BRA    F024
0F22A:  MOVLW  0D
0F22C:  BTFSS  FA4.4
0F22E:  BRA    F22C
0F230:  MOVLB  F
0F232:  MOVWF  x1C
0F234:  MOVLW  0A
0F236:  BTFSS  FA4.4
0F238:  BRA    F236
0F23A:  MOVWF  x1C
....................    multidrop_off(); 
0F23C:  MOVLB  0
0F23E:  CALL   D86A
0F242:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12B30:  MOVLB  8
12B32:  CLRF   xC9
12B34:  BCF    xCA.0
12B36:  CLRF   xCB
12B38:  CLRF   xCF
12B3A:  CLRF   xCE
12B3C:  CLRF   xCD
12B3E:  CLRF   xCC
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12B40:  MOVLW  02
12B42:  MOVWF  FEA
12B44:  MOVLW  43
12B46:  MOVWF  FE9
12B48:  CLRF   00
12B4A:  CLRF   02
12B4C:  MOVLW  51
12B4E:  MOVWF  01
12B50:  MOVLB  0
12B52:  CALL   34AE
....................  
....................    det_cmd(); 
12B56:  CALL   F104
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12B5A:  CALL   54D2
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12B5E:  MOVLB  8
12B60:  MOVF   xCB,W
12B62:  SUBLW  02
12B64:  BZ    12BF8
12B66:  MOVF   xCB,W
12B68:  SUBLW  03
12B6A:  BZ    12BF8
12B6C:  MOVF   xC9,W
12B6E:  SUBLW  50
12B70:  BNC   12BF8
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12B72:  BTFSS  FA4.5
12B74:  BRA    12BAC
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12B76:  MOVLB  0
12B78:  RCALL  12B16
12B7A:  MOVFF  01,8C8
....................  
....................          if(startCharacterRcvd) 
12B7E:  MOVLB  8
12B80:  BTFSS  xCA.0
12B82:  BRA    12BA4
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12B84:  MOVF   xC9,W
12B86:  INCF   xC9,F
12B88:  CLRF   03
12B8A:  ADDLW  43
12B8C:  MOVWF  FE9
12B8E:  MOVLW  02
12B90:  ADDWFC 03,W
12B92:  MOVWF  FEA
12B94:  MOVFF  8C8,FEF
....................             if (CARRIAGE_RET == c) 
12B98:  MOVF   xC8,W
12B9A:  SUBLW  0D
12B9C:  BNZ   12BA2
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12B9E:  MOVLW  02
12BA0:  MOVWF  xCB
....................             } 
....................          } 
12BA2:  BRA    12BAC
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12BA4:  MOVF   xC8,W
12BA6:  SUBLW  40
12BA8:  BNZ   12BAC
....................             { 
....................                startCharacterRcvd = TRUE; 
12BAA:  BSF    xCA.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12BAC:  MOVLW  35
12BAE:  MOVWF  00
12BB0:  DECFSZ 00,F
12BB2:  BRA    12BB0
....................       if (tenMicroSecDelayCounter++ > 500000) 
12BB4:  MOVFF  8CF,8D3
12BB8:  MOVFF  8CE,8D2
12BBC:  MOVFF  8CD,8D1
12BC0:  MOVFF  8CC,8D0
12BC4:  MOVLW  01
12BC6:  ADDWF  xCC,F
12BC8:  BTFSC  FD8.0
12BCA:  INCF   xCD,F
12BCC:  BTFSC  FD8.2
12BCE:  INCF   xCE,F
12BD0:  BTFSC  FD8.2
12BD2:  INCF   xCF,F
12BD4:  MOVF   xD3,F
12BD6:  BNZ   12BF2
12BD8:  MOVF   xD2,W
12BDA:  SUBLW  06
12BDC:  BC    12BF6
12BDE:  XORLW  FF
12BE0:  BNZ   12BF2
12BE2:  MOVF   xD1,W
12BE4:  SUBLW  A0
12BE6:  BC    12BF6
12BE8:  XORLW  FF
12BEA:  BNZ   12BF2
12BEC:  MOVF   xD0,W
12BEE:  SUBLW  20
12BF0:  BC    12BF6
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12BF2:  MOVLW  03
12BF4:  MOVWF  xCB
....................       } 
12BF6:  BRA    12B60
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12BF8:  MOVF   xC9,W
12BFA:  SUBLW  50
12BFC:  BC    12C0E
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12BFE:  MOVF   xCB,W
12C00:  SUBLW  03
12C02:  BZ    12C0E
12C04:  MOVF   xCB,W
12C06:  SUBLW  02
12C08:  BZ    12C0E
....................       { 
....................          rcvDataType = SOME_DATA; 
12C0A:  MOVLW  01
12C0C:  MOVWF  xCB
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12C0E:  MOVLB  0
12C10:  CALL   54F2
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12C14:  MOVLB  8
12C16:  MOVFF  8CB,01
12C1A:  MOVLB  0
12C1C:  GOTO   12D94 (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
0FC5E:  MOVF   1F,F
0FC60:  BNZ   FC80
0FC62:  MOVF   20,F
0FC64:  BNZ   FC80
0FC66:  MOVLB  8
0FC68:  DECFSZ xC9,W
0FC6A:  BRA    FC6E
0FC6C:  BRA    FC72
0FC6E:  MOVLB  0
0FC70:  BRA    FC80
0FC72:  CLRF   FEA
0FC74:  MOVLW  63
0FC76:  MOVWF  FE9
0FC78:  MOVLB  0
0FC7A:  CALL   78DC
0FC7E:  BRA    FC94
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
0FC80:  MOVF   20,F
0FC82:  BNZ   FC8A
0FC84:  MOVF   1F,W
0FC86:  SUBLW  03
0FC88:  BC    FC94
0FC8A:  CLRF   FEA
0FC8C:  MOVLW  63
0FC8E:  MOVWF  FE9
0FC90:  CALL   78DC
....................  
....................    if (store==TRUE && sd_status==0) { 
0FC94:  MOVLB  8
0FC96:  DECFSZ xC8,W
0FC98:  BRA    FCF8
0FC9A:  MOVLB  2
0FC9C:  MOVF   xD8,F
0FC9E:  BTFSC  FD8.2
0FCA0:  BRA    FCA6
0FCA2:  MOVLB  8
0FCA4:  BRA    FCF8
....................        
....................       buffer_select = 0; 
0FCA6:  MOVLB  0
0FCA8:  CLRF   x62
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FCAA:  MOVLB  8
0FCAC:  CLRF   xCA
0FCAE:  MOVLB  0
0FCB0:  CALL   5504
....................          append_data(file_ptr_raw_all); 
0FCB4:  MOVLW  02
0FCB6:  MOVLB  8
0FCB8:  MOVWF  xCB
0FCBA:  MOVLW  D9
0FCBC:  MOVWF  xCA
0FCBE:  MOVLB  0
0FCC0:  CALL   8238
....................       heartbeat(TRUE); 
0FCC4:  MOVLW  01
0FCC6:  MOVLB  8
0FCC8:  MOVWF  xCA
0FCCA:  MOVLB  0
0FCCC:  CALL   5504
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FCD0:  MOVLB  8
0FCD2:  CLRF   xCA
0FCD4:  MOVLB  0
0FCD6:  CALL   5504
....................          append_data(file_ptr_raw_new); 
0FCDA:  MOVLW  02
0FCDC:  MOVLB  8
0FCDE:  MOVWF  xCB
0FCE0:  MOVLW  E7
0FCE2:  MOVWF  xCA
0FCE4:  MOVLB  0
0FCE6:  CALL   8238
....................       heartbeat(TRUE); 
0FCEA:  MOVLW  01
0FCEC:  MOVLB  8
0FCEE:  MOVWF  xCA
0FCF0:  MOVLB  0
0FCF2:  CALL   5504
0FCF6:  MOVLB  8
....................    } 
0FCF8:  MOVLB  0
0FCFA:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12C2C:  CLRF   xC2
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12C20:  MOVLW  0D
12C22:  MOVLB  8
12C24:  MOVWF  xAB
12C26:  MOVLW  0A
12C28:  MOVWF  xAC
12C2A:  CLRF   xAD
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12C2E:  MOVLB  0
12C30:  RCALL  124DA
....................    clear_data_buffer(); 
12C32:  CALL   D22E
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12C36:  MOVLW  08
12C38:  MOVWF  FEA
12C3A:  MOVLW  AE
12C3C:  MOVWF  FE9
12C3E:  CLRF   00
12C40:  CLRF   02
12C42:  MOVLW  14
12C44:  MOVWF  01
12C46:  CALL   34AE
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12C4A:  MOVLW  01
12C4C:  MOVWF  FEA
12C4E:  MOVLW  A3
12C50:  MOVWF  FE9
12C52:  CLRF   00
12C54:  CLRF   02
12C56:  MOVLW  A0
12C58:  MOVWF  01
12C5A:  CALL   34AE
....................  
....................    time_stamp(); 
12C5E:  CALL   539C
....................    strcpy(data_buffer, time_stmp_str); 
12C62:  CLRF   FEA
12C64:  MOVLW  63
12C66:  MOVWF  FE9
12C68:  MOVLW  02
12C6A:  MOVWF  FE2
12C6C:  MOVLW  95
12C6E:  MOVWF  FE1
12C70:  MOVF   FE7,F
12C72:  MOVFF  FE6,FEE
12C76:  BNZ   12C70
....................    strcat(data_buffer, (char *)","); 
12C78:  MOVLW  2C
12C7A:  MOVLB  8
12C7C:  MOVWF  xC6
12C7E:  CLRF   xC7
12C80:  CLRF   xD6
12C82:  MOVLW  63
12C84:  MOVWF  xD5
12C86:  MOVLW  08
12C88:  MOVWF  xD8
12C8A:  MOVLW  C6
12C8C:  MOVWF  xD7
12C8E:  MOVLB  0
12C90:  CALL   5460
....................  
....................    flag_mod=fmod(macro_flag,10); 
12C94:  MOVFF  320,8F5
12C98:  MOVFF  31F,8F4
12C9C:  CALL   C624
12CA0:  MOVFF  03,8CB
12CA4:  MOVFF  02,8CA
12CA8:  MOVFF  01,8C9
12CAC:  MOVFF  00,8C8
12CB0:  MOVFF  03,8CF
12CB4:  MOVFF  02,8CE
12CB8:  MOVFF  01,8CD
12CBC:  MOVFF  00,8CC
12CC0:  MOVLB  8
12CC2:  CLRF   xD3
12CC4:  CLRF   xD2
12CC6:  MOVLW  20
12CC8:  MOVWF  xD1
12CCA:  MOVLW  82
12CCC:  MOVWF  xD0
12CCE:  MOVLB  0
12CD0:  BRA    128D6
12CD2:  MOVFF  03,8F3
12CD6:  MOVFF  02,8F2
12CDA:  MOVFF  01,8F1
12CDE:  MOVFF  00,8F0
12CE2:  RCALL  124F0
12CE4:  MOVFF  01,8C5
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
12CE8:  MOVLB  8
12CEA:  DECFSZ xC5,W
12CEC:  BRA    12CF0
12CEE:  BRA    12CF6
12CF0:  MOVF   xC5,W
12CF2:  SUBLW  03
12CF4:  BNZ   12D14
....................    { 
....................       clear_proc_time_stmp_str(); 
12CF6:  MOVLB  0
12CF8:  BRA    12A3E
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
12CFA:  MOVLW  02
12CFC:  MOVWF  FEA
12CFE:  MOVLW  B3
12D00:  MOVWF  FE9
12D02:  MOVLW  02
12D04:  MOVWF  FE2
12D06:  MOVLW  95
12D08:  MOVWF  FE1
12D0A:  MOVF   FE7,F
12D0C:  MOVFF  FE6,FEE
12D10:  BNZ   12D0A
12D12:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
12D14:  MOVLB  0
12D16:  CALL   F628
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12D1A:  MOVLB  8
12D1C:  CLRF   xC9
12D1E:  MOVLW  63
12D20:  MOVWF  xC8
12D22:  MOVLB  0
12D24:  RCALL  12A56
12D26:  MOVFF  02,03
12D2A:  MOVF   01,W
12D2C:  XORLW  FF
12D2E:  ADDLW  A1
12D30:  MOVLB  8
12D32:  MOVWF  xC8
12D34:  MOVLW  00
12D36:  SUBFWB 02,W
12D38:  MOVWF  xC9
12D3A:  MOVLW  01
12D3C:  SUBWF  xC8,F
12D3E:  MOVLW  00
12D40:  SUBWFB xC9,F
12D42:  CLRF   xCB
12D44:  MOVLW  63
12D46:  MOVWF  xCA
12D48:  MOVLW  03
12D4A:  MOVWF  xCD
12D4C:  MOVLW  21
12D4E:  MOVWF  xCC
12D50:  MOVFF  8C9,8CF
12D54:  MOVFF  8C8,8CE
12D58:  MOVLB  0
12D5A:  RCALL  12A92
....................    strcat(data_buffer, (char *)","); 
12D5C:  MOVLW  2C
12D5E:  MOVLB  8
12D60:  MOVWF  xC6
12D62:  CLRF   xC7
12D64:  CLRF   xD6
12D66:  MOVLW  63
12D68:  MOVWF  xD5
12D6A:  MOVLW  08
12D6C:  MOVWF  xD8
12D6E:  MOVLW  C6
12D70:  MOVWF  xD7
12D72:  MOVLB  0
12D74:  CALL   5460
....................     
....................    cmd = 'S'; 
12D78:  MOVLW  53
12D7A:  MOVWF  43
....................    arg = 1; 
12D7C:  CLRF   47
12D7E:  CLRF   46
12D80:  CLRF   45
12D82:  MOVLW  01
12D84:  MOVWF  44
....................  
....................    for(i = 0; i < 6; i++) 
12D86:  MOVLB  8
12D88:  CLRF   xC3
12D8A:  MOVF   xC3,W
12D8C:  SUBLW  05
12D8E:  BNC   12DA6
....................    { 
....................       rcvdData = get_slave_data(); 
12D90:  MOVLB  0
12D92:  BRA    12B30
12D94:  MOVFF  01,8C2
....................       if (DATA_COMPLETE == rcvdData) 
12D98:  MOVLB  8
12D9A:  MOVF   xC2,W
12D9C:  SUBLW  02
12D9E:  BNZ   12DA2
....................       { 
....................          break; 
12DA0:  BRA    12DA6
....................       } 
12DA2:  INCF   xC3,F
12DA4:  BRA    12D8A
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12DA6:  CLRF   xC9
12DA8:  MOVLW  63
12DAA:  MOVWF  xC8
12DAC:  MOVLB  0
12DAE:  RCALL  12A56
12DB0:  MOVFF  02,03
12DB4:  MOVF   01,W
12DB6:  XORLW  FF
12DB8:  ADDLW  A1
12DBA:  MOVLB  8
12DBC:  MOVWF  xC8
12DBE:  MOVLW  00
12DC0:  SUBFWB 02,W
12DC2:  MOVWF  xC9
12DC4:  MOVLW  01
12DC6:  SUBWF  xC8,F
12DC8:  MOVLW  00
12DCA:  SUBWFB xC9,F
12DCC:  CLRF   xCB
12DCE:  MOVLW  63
12DD0:  MOVWF  xCA
12DD2:  MOVLW  02
12DD4:  MOVWF  xCD
12DD6:  MOVLW  43
12DD8:  MOVWF  xCC
12DDA:  MOVFF  8C9,8CF
12DDE:  MOVFF  8C8,8CE
12DE2:  MOVLB  0
12DE4:  RCALL  12A92
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
12DE6:  MOVLW  02
12DE8:  MOVLB  8
12DEA:  MOVWF  xC9
12DEC:  MOVLW  43
12DEE:  MOVWF  xC8
12DF0:  MOVLB  0
12DF2:  RCALL  12A56
12DF4:  MOVFF  01,8C4
....................    if (rec_len > 0 && rec_len < 12) 
12DF8:  MOVLB  8
12DFA:  MOVF   xC4,F
12DFC:  BZ    12E0A
12DFE:  MOVF   xC4,W
12E00:  SUBLW  0B
12E02:  BNC   12E0A
....................    { 
....................       rcvdData = SHORT_DATA; 
12E04:  MOVLW  04
12E06:  MOVWF  xC2
....................    } 
12E08:  BRA    12E14
....................    else 
....................    { 
....................       if (rec_len > 30) 
12E0A:  MOVF   xC4,W
12E0C:  SUBLW  1E
12E0E:  BC    12E14
....................       { 
....................          rcvdData = LONG_DATA; 
12E10:  MOVLW  05
12E12:  MOVWF  xC2
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
12E14:  MOVLW  02
12E16:  SUBWF  xC2,W
12E18:  ADDLW  FC
12E1A:  BC    12E86
12E1C:  ADDLW  04
12E1E:  MOVLB  0
12E20:  GOTO   12FE8
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
12E24:  MOVLB  8
12E26:  BRA    12E86
12E28:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
12E2A:  MOVLW  08
12E2C:  MOVWF  1E
12E2E:  MOVLW  AE
12E30:  MOVWF  1D
12E32:  MOVLW  54
12E34:  MOVWF  FF6
12E36:  MOVLW  1C
12E38:  MOVWF  FF7
12E3A:  MOVLW  00
12E3C:  MOVWF  FF8
12E3E:  CALL   5040
....................          break; 
12E42:  MOVLB  8
12E44:  BRA    12E86
12E46:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
12E48:  MOVLW  08
12E4A:  MOVWF  1E
12E4C:  MOVLW  AE
12E4E:  MOVWF  1D
12E50:  MOVLW  5E
12E52:  MOVWF  FF6
12E54:  MOVLW  1C
12E56:  MOVWF  FF7
12E58:  MOVLW  00
12E5A:  MOVWF  FF8
12E5C:  CALL   5040
....................          break; 
12E60:  MOVLB  8
12E62:  BRA    12E86
12E64:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
12E66:  MOVLW  08
12E68:  MOVWF  1E
12E6A:  MOVLW  AE
12E6C:  MOVWF  1D
12E6E:  MOVLW  6E
12E70:  MOVWF  FF6
12E72:  MOVLW  1C
12E74:  MOVWF  FF7
12E76:  MOVLW  00
12E78:  MOVWF  FF8
12E7A:  CALL   5040
....................          break; 
12E7E:  MOVLB  8
12E80:  BRA    12E86
12E82:  MOVLB  0
12E84:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12E86:  CLRF   xC9
12E88:  MOVLW  63
12E8A:  MOVWF  xC8
12E8C:  MOVLB  0
12E8E:  RCALL  12A56
12E90:  MOVFF  02,03
12E94:  MOVF   01,W
12E96:  XORLW  FF
12E98:  ADDLW  A1
12E9A:  MOVLB  8
12E9C:  MOVWF  xC8
12E9E:  MOVLW  00
12EA0:  SUBFWB 02,W
12EA2:  MOVWF  xC9
12EA4:  MOVLW  01
12EA6:  SUBWF  xC8,F
12EA8:  MOVLW  00
12EAA:  SUBWFB xC9,F
12EAC:  CLRF   xCB
12EAE:  MOVLW  63
12EB0:  MOVWF  xCA
12EB2:  MOVLW  08
12EB4:  MOVWF  xCD
12EB6:  MOVLW  AE
12EB8:  MOVWF  xCC
12EBA:  MOVFF  8C9,8CF
12EBE:  MOVFF  8C8,8CE
12EC2:  MOVLB  0
12EC4:  RCALL  12A92
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12EC6:  MOVLB  8
12EC8:  CLRF   xC9
12ECA:  MOVLW  63
12ECC:  MOVWF  xC8
12ECE:  MOVLB  0
12ED0:  RCALL  12A56
12ED2:  MOVFF  02,03
12ED6:  MOVF   01,W
12ED8:  XORLW  FF
12EDA:  ADDLW  A1
12EDC:  MOVLB  8
12EDE:  MOVWF  xC8
12EE0:  MOVLW  00
12EE2:  SUBFWB 02,W
12EE4:  MOVWF  xC9
12EE6:  MOVLW  01
12EE8:  SUBWF  xC8,F
12EEA:  MOVLW  00
12EEC:  SUBWFB xC9,F
12EEE:  CLRF   xCB
12EF0:  MOVLW  63
12EF2:  MOVWF  xCA
12EF4:  MOVLW  08
12EF6:  MOVWF  xCD
12EF8:  MOVLW  AB
12EFA:  MOVWF  xCC
12EFC:  MOVFF  8C9,8CF
12F00:  MOVFF  8C8,8CE
12F04:  MOVLB  0
12F06:  RCALL  12A92
....................  
....................    if(DATA_COMPLETE != rcvdData) 
12F08:  MOVLB  8
12F0A:  MOVF   xC2,W
12F0C:  SUBLW  02
12F0E:  BZ    12FCA
....................    {    //housekeeping 
....................       time_stamp(); 
12F10:  MOVLB  0
12F12:  CALL   539C
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
12F16:  MOVLW  01
12F18:  MOVWF  1E
12F1A:  MOVLW  A3
12F1C:  MOVWF  1D
12F1E:  MOVLW  7E
12F20:  MOVWF  FF6
12F22:  MOVLW  1C
12F24:  MOVWF  FF7
12F26:  MOVLW  00
12F28:  MOVWF  FF8
12F2A:  MOVLW  0A
12F2C:  MOVLB  8
12F2E:  MOVWF  xC8
12F30:  MOVLB  0
12F32:  CALL   AA04
12F36:  MOVFF  1E,FEA
12F3A:  MOVFF  1D,FE9
12F3E:  CLRF   FEF
12F40:  MOVLW  08
12F42:  MOVWF  FEA
12F44:  MOVLW  AE
12F46:  MOVWF  FE9
12F48:  CALL   FB30
12F4C:  MOVLW  8A
12F4E:  MOVWF  FF6
12F50:  MOVLW  1C
12F52:  MOVWF  FF7
12F54:  MOVLW  00
12F56:  MOVWF  FF8
12F58:  MOVLW  06
12F5A:  MOVLB  8
12F5C:  MOVWF  xC8
12F5E:  MOVLB  0
12F60:  CALL   AA04
12F64:  MOVFF  8C4,8CA
12F68:  MOVLW  1B
12F6A:  MOVLB  8
12F6C:  MOVWF  xCB
12F6E:  MOVLB  0
12F70:  CALL   5202
12F74:  MOVLW  5D
12F76:  MOVLB  8
12F78:  MOVWF  xDC
12F7A:  MOVLB  0
12F7C:  CALL   5020
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
12F80:  MOVLW  01
12F82:  MOVLB  8
12F84:  MOVWF  xC9
12F86:  MOVLW  A3
12F88:  MOVWF  xC8
12F8A:  MOVLB  0
12F8C:  RCALL  12A56
12F8E:  MOVFF  02,03
12F92:  MOVF   01,W
12F94:  XORLW  FF
12F96:  ADDLW  A1
12F98:  MOVLB  8
12F9A:  MOVWF  xC8
12F9C:  MOVLW  00
12F9E:  SUBFWB 02,W
12FA0:  MOVWF  xC9
12FA2:  MOVLW  01
12FA4:  SUBWF  xC8,F
12FA6:  MOVLW  00
12FA8:  SUBWFB xC9,F
12FAA:  MOVLW  01
12FAC:  MOVWF  xCB
12FAE:  MOVLW  A3
12FB0:  MOVWF  xCA
12FB2:  CLRF   xCD
12FB4:  MOVLW  63
12FB6:  MOVWF  xCC
12FB8:  MOVFF  8C9,8CF
12FBC:  MOVFF  8C8,8CE
12FC0:  MOVLB  0
12FC2:  RCALL  12A92
....................       record_event(); 
12FC4:  CALL   841A
12FC8:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
12FCA:  MOVFF  8A9,8C8
12FCE:  MOVFF  8AA,8C9
12FD2:  MOVLB  0
12FD4:  CALL   FC5E
....................  
....................    return (rcvdData); 
12FD8:  CLRF   03
12FDA:  MOVLB  8
12FDC:  MOVFF  8C2,01
12FE0:  MOVFF  03,02
12FE4:  MOVLB  0
12FE6:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
1340C:  MOVLB  8
1340E:  CLRF   xA1
13410:  MOVF   xA1,W
13412:  SUBLW  02
13414:  BTFSS  FD8.0
13416:  BRA    1352C
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
13418:  MOVFF  89F,8A9
1341C:  MOVFF  8A0,8AA
13420:  MOVLB  0
13422:  CALL   12C20
13426:  MOVFF  02,03
1342A:  MOVF   01,W
1342C:  SUBLW  02
1342E:  BNZ   1343C
13430:  MOVF   03,F
13432:  BNZ   1343C
....................       { 
....................          break; 
13434:  MOVLB  8
13436:  BRA    1352C
....................       } 
13438:  BRA    13528
1343A:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
1343C:  MOVLW  01
1343E:  MOVLB  8
13440:  ADDWF  xA1,W
13442:  MOVWF  xA2
13444:  MOVLW  94
13446:  MOVWF  FF6
13448:  MOVLW  1C
1344A:  MOVWF  FF7
1344C:  MOVLW  00
1344E:  MOVWF  FF8
13450:  CLRF   1B
13452:  BTFSC  FF2.7
13454:  BSF    1B.7
13456:  BCF    FF2.7
13458:  MOVLW  05
1345A:  MOVLB  A
1345C:  MOVWF  x18
1345E:  MOVLB  0
13460:  CALL   1010
13464:  BTFSC  1B.7
13466:  BSF    FF2.7
13468:  CLRF   1B
1346A:  BTFSC  FF2.7
1346C:  BSF    1B.7
1346E:  BCF    FF2.7
13470:  MOVFF  8A2,A18
13474:  MOVLW  1B
13476:  MOVLB  A
13478:  MOVWF  x19
1347A:  MOVLB  0
1347C:  CALL   0F92
13480:  BTFSC  1B.7
13482:  BSF    FF2.7
13484:  MOVLW  0D
13486:  BTFSS  F9E.4
13488:  BRA    13486
1348A:  MOVWF  FAD
1348C:  MOVLW  0A
1348E:  BTFSS  F9E.4
13490:  BRA    1348E
13492:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
13494:  BCF    F90.7
....................          delay_ms(1000); 
13496:  MOVLW  04
13498:  MOVLB  8
1349A:  MOVWF  xA2
1349C:  MOVLW  FA
1349E:  MOVLB  9
134A0:  MOVWF  xC9
134A2:  MOVLB  0
134A4:  CALL   2898
134A8:  MOVLB  8
134AA:  DECFSZ xA2,F
134AC:  BRA    1349C
....................          output_bit(VDET,ON); 
134AE:  BSF    F90.7
....................          delay_ms(1000); 
134B0:  MOVLW  04
134B2:  MOVWF  xA2
134B4:  MOVLW  FA
134B6:  MOVLB  9
134B8:  MOVWF  xC9
134BA:  MOVLB  0
134BC:  CALL   2898
134C0:  MOVLB  8
134C2:  DECFSZ xA2,F
134C4:  BRA    134B4
....................          if (LightTargetFlag==0) 
134C6:  MOVLB  2
134C8:  MOVF   xD5,F
134CA:  BNZ   13512
....................          { 
....................           cmd='K'; 
134CC:  MOVLW  4B
134CE:  MOVWF  43
....................           arg=detector_ch; 
134D0:  CLRF   47
134D2:  CLRF   46
134D4:  CLRF   45
134D6:  MOVFF  2D2,44
....................           det_cmd(); 
134DA:  MOVLB  0
134DC:  CALL   F104
....................           delay_ms(1000); 
134E0:  MOVLW  04
134E2:  MOVLB  8
134E4:  MOVWF  xA2
134E6:  MOVLW  FA
134E8:  MOVLB  9
134EA:  MOVWF  xC9
134EC:  MOVLB  0
134EE:  CALL   2898
134F2:  MOVLB  8
134F4:  DECFSZ xA2,F
134F6:  BRA    134E6
....................           cmd='L'; 
134F8:  MOVLW  4C
134FA:  MOVWF  43
....................           arg=detector_li; 
134FC:  CLRF   47
134FE:  CLRF   46
13500:  MOVFF  2D4,45
13504:  MOVFF  2D3,44
....................           det_cmd(); 
13508:  MOVLB  0
1350A:  CALL   F104
....................          }  
1350E:  BRA    13526
13510:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
13512:  MOVLW  6C
13514:  MOVWF  43
....................           arg=1; 
13516:  CLRF   47
13518:  CLRF   46
1351A:  CLRF   45
1351C:  MOVLW  01
1351E:  MOVWF  44
....................           det_cmd(); 
13520:  MOVLB  0
13522:  CALL   F104
13526:  MOVLB  8
....................          }  
....................       } 
13528:  INCF   xA1,F
1352A:  BRA    13410
....................    } 
....................  
....................    parse_data(); 
1352C:  MOVLB  0
1352E:  RCALL  1338A
....................    data_available = TRUE; 
13530:  MOVLW  01
13532:  MOVLB  3
13534:  MOVWF  x37
....................    macro_flag = 900; 
13536:  MOVLW  03
13538:  MOVWF  x20
1353A:  MOVLW  84
1353C:  MOVWF  x1F
....................  
....................    return; 
1353E:  MOVLB  0
13540:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
138AC:  MOVLB  8
138AE:  CLRF   xAA
138B0:  CLRF   xA9
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
138B2:  MOVLB  0
138B4:  RCALL  1338A
138B6:  MOVFF  02,8AA
138BA:  MOVFF  01,8A9
....................    return (temp); 
138BE:  MOVLB  8
138C0:  MOVFF  8A9,01
138C4:  MOVFF  8AA,02
138C8:  MOVLB  0
138CA:  GOTO   139DC (RETURN)
.................... } 
....................  
.................... void det_temp() 
138CE:  MOVLB  8
138D0:  CLRF   xA6
138D2:  CLRF   xA5
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
138D4:  MOVLB  2
138D6:  MOVF   xD1,W
138D8:  XORLW  01
138DA:  MOVLB  0
138DC:  BZ    138E4
138DE:  XORLW  03
138E0:  BZ    138EE
138E2:  BRA    138F8
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
138E4:  MOVFF  3E,8A8
138E8:  MOVFF  3D,8A7
....................          break; 
138EC:  BRA    13904
....................       case 2 : target_temp = nv_d2_temp; 
138EE:  MOVFF  40,8A8
138F2:  MOVFF  3F,8A7
....................          break; 
138F6:  BRA    13904
....................       default : target_temp = 20000; 
138F8:  MOVLW  4E
138FA:  MOVLB  8
138FC:  MOVWF  xA8
138FE:  MOVLW  20
13900:  MOVWF  xA7
....................          break; 
13902:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
13904:  MOVLB  8
13906:  CLRF   xA4
13908:  MOVLW  3C
1390A:  MOVWF  xA3
....................    n = 0; 
1390C:  CLRF   xA2
1390E:  CLRF   xA1
....................    store=FALSE; 
13910:  CLRF   x9F
....................    display=FALSE; 
13912:  CLRF   xA0
....................  
....................    time_stamp(); 
13914:  MOVLB  0
13916:  CALL   539C
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
1391A:  MOVLW  01
1391C:  MOVWF  1E
1391E:  MOVLW  A3
13920:  MOVWF  1D
13922:  MOVLW  9E
13924:  MOVWF  FF6
13926:  MOVLW  1C
13928:  MOVWF  FF7
1392A:  MOVLW  00
1392C:  MOVWF  FF8
1392E:  MOVLW  16
13930:  MOVLB  8
13932:  MOVWF  xC8
13934:  MOVLB  0
13936:  CALL   AA04
1393A:  MOVLW  10
1393C:  MOVWF  FE9
1393E:  MOVFF  8A8,8D4
13942:  MOVFF  8A7,8D3
13946:  CALL   AA36
1394A:  MOVLW  B7
1394C:  MOVWF  FF6
1394E:  MOVLW  1C
13950:  MOVWF  FF7
13952:  MOVLW  00
13954:  MOVWF  FF8
13956:  MOVLW  09
13958:  MOVLB  8
1395A:  MOVWF  xC8
1395C:  MOVLB  0
1395E:  CALL   AA04
13962:  MOVLW  10
13964:  MOVWF  FE9
13966:  MOVFF  8A6,8D4
1396A:  MOVFF  8A5,8D3
1396E:  CALL   AA36
13972:  MOVLW  C3
13974:  MOVWF  FF6
13976:  MOVLW  1C
13978:  MOVWF  FF7
1397A:  MOVLW  00
1397C:  MOVWF  FF8
1397E:  MOVLW  0B
13980:  MOVLB  8
13982:  MOVWF  xC8
13984:  MOVLB  0
13986:  CALL   AA04
1398A:  MOVLW  10
1398C:  MOVWF  FE9
1398E:  MOVFF  8A2,8D4
13992:  MOVFF  8A1,8D3
13996:  CALL   AA36
1399A:  MOVLW  D1
1399C:  MOVWF  FF6
1399E:  MOVLW  1C
139A0:  MOVWF  FF7
139A2:  MOVLW  00
139A4:  MOVWF  FF8
139A6:  MOVLW  03
139A8:  MOVLB  8
139AA:  MOVWF  xC8
139AC:  MOVLB  0
139AE:  CALL   AA04
....................    record_event(); 
139B2:  CALL   841A
....................  
....................    for (n=1; n<t; ++n) 
139B6:  MOVLB  8
139B8:  CLRF   xA2
139BA:  MOVLW  01
139BC:  MOVWF  xA1
139BE:  MOVF   xA2,W
139C0:  SUBWF  xA4,W
139C2:  BNC   13A1E
139C4:  BNZ   139CC
139C6:  MOVF   xA3,W
139C8:  SUBWF  xA1,W
139CA:  BC    13A1E
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
139CC:  MOVFF  89F,8A9
139D0:  MOVFF  8A0,8AA
139D4:  MOVLB  0
139D6:  CALL   12C20
....................       current_temp=parse_temp(); 
139DA:  BRA    138AC
139DC:  MOVFF  02,8A6
139E0:  MOVFF  01,8A5
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
139E4:  MOVLB  8
139E6:  MOVF   xA8,W
139E8:  SUBWF  xA6,W
139EA:  BNC   139F4
139EC:  BNZ   139FC
139EE:  MOVF   xA7,W
139F0:  SUBWF  xA5,W
139F2:  BC    139FC
139F4:  MOVF   xA5,F
139F6:  BNZ   13A00
139F8:  MOVF   xA6,F
139FA:  BNZ   13A00
139FC:  BRA    13A1E
139FE:  BRA    13A16
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13A00:  MOVLW  0A
13A02:  MOVWF  xA9
13A04:  MOVLW  FA
13A06:  MOVLB  9
13A08:  MOVWF  xC9
13A0A:  MOVLB  0
13A0C:  CALL   2898
13A10:  MOVLB  8
13A12:  DECFSZ xA9,F
13A14:  BRA    13A04
13A16:  INCF   xA1,F
13A18:  BTFSC  FD8.2
13A1A:  INCF   xA2,F
13A1C:  BRA    139BE
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13A1E:  MOVLW  01
13A20:  MOVWF  1E
13A22:  MOVLW  A3
13A24:  MOVWF  1D
13A26:  MOVLW  D6
13A28:  MOVWF  FF6
13A2A:  MOVLW  1C
13A2C:  MOVWF  FF7
13A2E:  MOVLW  00
13A30:  MOVWF  FF8
13A32:  MOVLW  14
13A34:  MOVWF  xC8
13A36:  MOVLB  0
13A38:  CALL   AA04
13A3C:  MOVLW  10
13A3E:  MOVWF  FE9
13A40:  MOVFF  8A8,8D4
13A44:  MOVFF  8A7,8D3
13A48:  CALL   AA36
13A4C:  MOVLW  ED
13A4E:  MOVWF  FF6
13A50:  MOVLW  1C
13A52:  MOVWF  FF7
13A54:  MOVLW  00
13A56:  MOVWF  FF8
13A58:  MOVLW  09
13A5A:  MOVLB  8
13A5C:  MOVWF  xC8
13A5E:  MOVLB  0
13A60:  CALL   AA04
13A64:  MOVLW  10
13A66:  MOVWF  FE9
13A68:  MOVFF  8A6,8D4
13A6C:  MOVFF  8A5,8D3
13A70:  CALL   AA36
13A74:  MOVLW  F9
13A76:  MOVWF  FF6
13A78:  MOVLW  1C
13A7A:  MOVWF  FF7
13A7C:  MOVLW  00
13A7E:  MOVWF  FF8
13A80:  MOVLW  0B
13A82:  MOVLB  8
13A84:  MOVWF  xC8
13A86:  MOVLB  0
13A88:  CALL   AA04
13A8C:  MOVLW  10
13A8E:  MOVWF  FE9
13A90:  MOVFF  8A2,8D4
13A94:  MOVFF  8A1,8D3
13A98:  CALL   AA36
13A9C:  MOVLW  07
13A9E:  MOVWF  FF6
13AA0:  MOVLW  1D
13AA2:  MOVWF  FF7
13AA4:  MOVLW  00
13AA6:  MOVWF  FF8
13AA8:  MOVLW  03
13AAA:  MOVLB  8
13AAC:  MOVWF  xC8
13AAE:  MOVLB  0
13AB0:  CALL   AA04
....................    record_event();    
13AB4:  CALL   841A
13AB8:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
13584:  MOVLB  8
13586:  CLRF   xB2
13588:  CLRF   xB1
1358A:  CLRF   xB0
1358C:  CLRF   xAF
....................    set_adc_channel(1,VSS); 
1358E:  MOVLW  04
13590:  MOVWF  01
13592:  MOVF   FC2,W
13594:  ANDLW  83
13596:  IORWF  01,W
13598:  MOVWF  FC2
1359A:  MOVLW  00
1359C:  MOVWF  01
1359E:  MOVF   FC1,W
135A0:  ANDLW  F8
135A2:  IORWF  01,W
135A4:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
135A6:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
135A8:  MOVLW  01
135AA:  MOVWF  xAC
135AC:  MOVF   xAC,W
135AE:  SUBLW  32
135B0:  BNC   135D6
....................       reading=read_adc(); 
135B2:  BSF    FC2.1
135B4:  BTFSC  FC2.1
135B6:  BRA    135B4
135B8:  MOVFF  FC3,8B3
135BC:  MOVFF  FC4,8B4
135C0:  CLRF   xB5
135C2:  CLRF   xB6
....................       delay_ms(5); 
135C4:  MOVLW  05
135C6:  MOVLB  9
135C8:  MOVWF  xC9
135CA:  MOVLB  0
135CC:  CALL   2898
135D0:  MOVLB  8
135D2:  INCF   xAC,F
135D4:  BRA    135AC
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
135D6:  MOVLW  01
135D8:  MOVWF  xAC
135DA:  MOVF   xAC,W
135DC:  SUBLW  64
135DE:  BNC   1368C
....................       reading=read_adc(); 
135E0:  BSF    FC2.1
135E2:  BTFSC  FC2.1
135E4:  BRA    135E2
135E6:  MOVFF  FC3,8B3
135EA:  MOVFF  FC4,8B4
135EE:  CLRF   xB5
135F0:  CLRF   xB6
....................       result=(((result*(i-1))+reading)/i); 
135F2:  MOVLW  01
135F4:  SUBWF  xAC,W
135F6:  MOVWF  xB7
135F8:  MOVFF  8B2,9D6
135FC:  MOVFF  8B1,9D5
13600:  MOVFF  8B0,9D4
13604:  MOVFF  8AF,9D3
13608:  MOVLB  9
1360A:  CLRF   xDA
1360C:  CLRF   xD9
1360E:  CLRF   xD8
13610:  MOVWF  xD7
13612:  MOVLB  0
13614:  CALL   477C
13618:  MOVFF  03,8BA
1361C:  MOVFF  02,8B9
13620:  MOVFF  01,8B8
13624:  MOVFF  00,8B7
13628:  MOVLB  8
1362A:  MOVF   xB3,W
1362C:  ADDWF  xB7,F
1362E:  MOVF   xB4,W
13630:  ADDWFC xB8,F
13632:  MOVF   xB5,W
13634:  ADDWFC xB9,F
13636:  MOVF   xB6,W
13638:  ADDWFC xBA,F
1363A:  BCF    FD8.1
1363C:  CLRF   1B
1363E:  BTFSC  FF2.7
13640:  BSF    1B.7
13642:  BCF    FF2.7
13644:  MOVFF  8BA,A27
13648:  MOVFF  8B9,A26
1364C:  MOVFF  8B8,A25
13650:  MOVFF  8B7,A24
13654:  MOVLB  A
13656:  CLRF   x2B
13658:  CLRF   x2A
1365A:  CLRF   x29
1365C:  MOVFF  8AC,A28
13660:  MOVLB  0
13662:  CALL   1042
13666:  BTFSC  1B.7
13668:  BSF    FF2.7
1366A:  MOVFF  03,8B2
1366E:  MOVFF  02,8B1
13672:  MOVFF  01,8B0
13676:  MOVFF  00,8AF
....................       delay_ms(5); 
1367A:  MOVLW  05
1367C:  MOVLB  9
1367E:  MOVWF  xC9
13680:  MOVLB  0
13682:  CALL   2898
13686:  MOVLB  8
13688:  INCF   xAC,F
1368A:  BRA    135DA
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
1368C:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
1368E:  MOVFF  8B2,9D6
13692:  MOVFF  8B1,9D5
13696:  MOVFF  8B0,9D4
1369A:  MOVFF  8AF,9D3
1369E:  MOVLB  9
136A0:  CLRF   xDA
136A2:  CLRF   xD9
136A4:  MOVLW  10
136A6:  MOVWF  xD8
136A8:  MOVLW  25
136AA:  MOVWF  xD7
136AC:  MOVLB  0
136AE:  CALL   477C
136B2:  MOVFF  03,8BA
136B6:  MOVFF  02,8B9
136BA:  MOVFF  01,8B8
136BE:  MOVFF  00,8B7
136C2:  BCF    FD8.1
136C4:  CLRF   1B
136C6:  BTFSC  FF2.7
136C8:  BSF    1B.7
136CA:  BCF    FF2.7
136CC:  MOVFF  03,A27
136D0:  MOVFF  02,A26
136D4:  MOVFF  01,A25
136D8:  MOVFF  00,A24
136DC:  MOVLB  A
136DE:  CLRF   x2B
136E0:  CLRF   x2A
136E2:  CLRF   x29
136E4:  MOVLW  64
136E6:  MOVWF  x28
136E8:  MOVLB  0
136EA:  CALL   1042
136EE:  BTFSC  1B.7
136F0:  BSF    FF2.7
136F2:  MOVLW  21
136F4:  MOVLB  8
136F6:  SUBWF  00,W
136F8:  MOVWF  xAD
136FA:  MOVLW  50
136FC:  SUBWFB 01,W
136FE:  MOVWF  xAE
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
13700:  MOVFF  8AD,01
13704:  MOVFF  8AE,02
13708:  MOVLB  0
1370A:  GOTO   13770 (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
1371A:  CLRF   xA5
1371C:  CLRF   xA4
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
1370E:  MOVLW  0D
13710:  MOVLB  8
13712:  MOVWF  xA1
13714:  MOVLW  0A
13716:  MOVWF  xA2
13718:  CLRF   xA3
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
1371E:  MOVLB  0
13720:  CALL   124DA
....................    clear_data_buffer(); 
13724:  CALL   D22E
....................  
....................    time_stamp(); 
13728:  CALL   539C
....................    strcpy(data_buffer, time_stmp_str); 
1372C:  CLRF   FEA
1372E:  MOVLW  63
13730:  MOVWF  FE9
13732:  MOVLW  02
13734:  MOVWF  FE2
13736:  MOVLW  95
13738:  MOVWF  FE1
1373A:  MOVF   FE7,F
1373C:  MOVFF  FE6,FEE
13740:  BNZ   1373A
....................    strcat(data_buffer, (char *)",Tmp,"); 
13742:  MOVLW  2C
13744:  MOVLB  8
13746:  MOVWF  xA6
13748:  MOVLW  54
1374A:  MOVWF  xA7
1374C:  MOVLW  6D
1374E:  MOVWF  xA8
13750:  MOVLW  70
13752:  MOVWF  xA9
13754:  MOVLW  2C
13756:  MOVWF  xAA
13758:  CLRF   xAB
1375A:  CLRF   xD6
1375C:  MOVLW  63
1375E:  MOVWF  xD5
13760:  MOVLW  08
13762:  MOVWF  xD8
13764:  MOVLW  A6
13766:  MOVWF  xD7
13768:  MOVLB  0
1376A:  CALL   5460
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
1376E:  BRA    13584
13770:  MOVFF  02,8A5
13774:  MOVFF  01,8A4
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
13778:  MOVLW  02
1377A:  MOVWF  1E
1377C:  MOVLW  43
1377E:  MOVWF  1D
13780:  MOVLW  45
13782:  MOVWF  FE9
13784:  MOVLB  8
13786:  CLRF   xCD
13788:  CLRF   xCC
1378A:  MOVFF  8A5,8CB
1378E:  MOVFF  8A4,8CA
13792:  MOVLW  03
13794:  MOVWF  xCE
13796:  MOVLB  0
13798:  CALL   529C
....................  
....................    strcat(slave_reply, endofline); 
1379C:  MOVLW  02
1379E:  MOVLB  8
137A0:  MOVWF  xD6
137A2:  MOVLW  43
137A4:  MOVWF  xD5
137A6:  MOVLW  08
137A8:  MOVWF  xD8
137AA:  MOVLW  A1
137AC:  MOVWF  xD7
137AE:  MOVLB  0
137B0:  CALL   5460
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
137B4:  MOVLB  8
137B6:  CLRF   xC9
137B8:  MOVLW  63
137BA:  MOVWF  xC8
137BC:  MOVLB  0
137BE:  CALL   12A56
137C2:  MOVFF  02,03
137C6:  MOVF   01,W
137C8:  XORLW  FF
137CA:  ADDLW  A1
137CC:  MOVLB  8
137CE:  MOVWF  xAC
137D0:  MOVLW  00
137D2:  SUBFWB 02,W
137D4:  MOVWF  xAD
137D6:  MOVLW  01
137D8:  SUBWF  xAC,F
137DA:  MOVLW  00
137DC:  SUBWFB xAD,F
137DE:  CLRF   xCB
137E0:  MOVLW  63
137E2:  MOVWF  xCA
137E4:  MOVLW  02
137E6:  MOVWF  xCD
137E8:  MOVLW  43
137EA:  MOVWF  xCC
137EC:  MOVFF  8AD,8CF
137F0:  MOVFF  8AC,8CE
137F4:  MOVLB  0
137F6:  CALL   12A92
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
137FA:  MOVF   1F,F
137FC:  BNZ   1381C
137FE:  MOVF   20,F
13800:  BNZ   1381C
13802:  MOVLB  8
13804:  DECFSZ xA0,W
13806:  BRA    1380A
13808:  BRA    1380E
1380A:  MOVLB  0
1380C:  BRA    1381C
1380E:  CLRF   FEA
13810:  MOVLW  63
13812:  MOVWF  FE9
13814:  MOVLB  0
13816:  CALL   78DC
1381A:  BRA    13830
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
1381C:  MOVF   20,F
1381E:  BNZ   13826
13820:  MOVF   1F,W
13822:  SUBLW  03
13824:  BC    13830
13826:  CLRF   FEA
13828:  MOVLW  63
1382A:  MOVWF  FE9
1382C:  CALL   78DC
....................  
....................    if (store == TRUE && sd_status==0) { 
13830:  MOVLB  8
13832:  DECFSZ x9F,W
13834:  BRA    13894
13836:  MOVLB  2
13838:  MOVF   xD8,F
1383A:  BTFSC  FD8.2
1383C:  BRA    13842
1383E:  MOVLB  8
13840:  BRA    13894
....................       buffer_select = 0; 
13842:  MOVLB  0
13844:  CLRF   x62
....................       
....................       heartbeat(FALSE); 
13846:  MOVLB  8
13848:  CLRF   xCA
1384A:  MOVLB  0
1384C:  CALL   5504
....................          append_data(file_ptr_raw_all); 
13850:  MOVLW  02
13852:  MOVLB  8
13854:  MOVWF  xCB
13856:  MOVLW  D9
13858:  MOVWF  xCA
1385A:  MOVLB  0
1385C:  CALL   8238
....................       heartbeat(TRUE); 
13860:  MOVLW  01
13862:  MOVLB  8
13864:  MOVWF  xCA
13866:  MOVLB  0
13868:  CALL   5504
....................        
....................       heartbeat(FALSE); 
1386C:  MOVLB  8
1386E:  CLRF   xCA
13870:  MOVLB  0
13872:  CALL   5504
....................          append_data(file_ptr_raw_new); 
13876:  MOVLW  02
13878:  MOVLB  8
1387A:  MOVWF  xCB
1387C:  MOVLW  E7
1387E:  MOVWF  xCA
13880:  MOVLB  0
13882:  CALL   8238
....................       heartbeat(TRUE); 
13886:  MOVLW  01
13888:  MOVLB  8
1388A:  MOVWF  xCA
1388C:  MOVLB  0
1388E:  CALL   5504
13892:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
13894:  MOVLW  03
13896:  MOVLB  3
13898:  MOVWF  x20
1389A:  MOVLW  84
1389C:  MOVWF  x1F
....................     
....................    return (temp); 
1389E:  MOVLB  8
138A0:  MOVFF  8A4,01
138A4:  MOVFF  8A5,02
138A8:  MOVLB  0
138AA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
123EC:  MOVLB  8
123EE:  MOVF   xA2,W
123F0:  ADDLW  FC
123F2:  BC    12430
123F4:  ADDLW  04
123F6:  MOVLB  0
123F8:  GOTO   12438
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
123FC:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
123FE:  BCF    F8C.1
....................          break; 
12400:  MOVLB  8
12402:  BRA    12430
....................       case 1 :  
....................             output_bit(HSW1, ON); 
12404:  BSF    F8C.0
....................          break; 
12406:  MOVLB  8
12408:  BRA    12430
....................       case 2 :  
....................             output_bit(HSW2, ON); 
1240A:  BSF    F8C.1
....................          break;  
1240C:  MOVLB  8
1240E:  BRA    12430
....................       case 3 :  
....................             output_bit(HSW1, ON); 
12410:  BSF    F8C.0
....................             delay_ms(500); 
12412:  MOVLW  02
12414:  MOVLB  8
12416:  MOVWF  xA3
12418:  MOVLW  FA
1241A:  MOVLB  9
1241C:  MOVWF  xC9
1241E:  MOVLB  0
12420:  CALL   2898
12424:  MOVLB  8
12426:  DECFSZ xA3,F
12428:  BRA    12418
....................             output_bit(HSW2, ON); 
1242A:  BSF    F8C.1
....................          break;             
1242C:  BRA    12430
1242E:  MOVLB  8
....................    } 
....................    heater_stat=set; 
12430:  MOVFF  8A2,4B1
12434:  MOVLB  0
12436:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F51E:  MOVLW  08
0F520:  MOVLB  8
0F522:  MOVWF  xA9
0F524:  CLRF   xA8
....................    LED_level_change=2048; 
0F526:  MOVWF  xAB
0F528:  CLRF   xAA
....................     
....................    for (i=0; i<12; i++){ 
0F52A:  CLRF   xA7
0F52C:  MOVF   xA7,W
0F52E:  SUBLW  0B
0F530:  BNC   F5A8
....................       DAC_set(1,LED_level); 
0F532:  MOVLW  01
0F534:  MOVWF  xB0
0F536:  MOVFF  8A9,8B2
0F53A:  MOVFF  8A8,8B1
0F53E:  MOVLB  0
0F540:  RCALL  F27A
....................       LED_level_change = LED_level_change/2; 
0F542:  BCF    FD8.0
0F544:  MOVLB  8
0F546:  RRCF   xAB,F
0F548:  RRCF   xAA,F
....................       ADC_average(200); 
0F54A:  CLRF   xB1
0F54C:  MOVLW  C8
0F54E:  MOVWF  xB0
0F550:  MOVLB  0
0F552:  RCALL  F322
....................       output = ADC_val[2]; 
0F554:  MOVFF  4A6,8AD
0F558:  MOVFF  4A5,8AC
....................       temp = ADC_val[3]; 
0F55C:  MOVFF  4A8,8AF
0F560:  MOVFF  4A7,8AE
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F564:  MOVLB  8
0F566:  MOVF   xA6,W
0F568:  SUBWF  xAD,W
0F56A:  BNC   F57E
0F56C:  BNZ   F574
0F56E:  MOVF   xAC,W
0F570:  SUBWF  xA5,W
0F572:  BC    F57E
....................          LED_level=LED_level-LED_level_change; 
0F574:  MOVF   xAA,W
0F576:  SUBWF  xA8,F
0F578:  MOVF   xAB,W
0F57A:  SUBWFB xA9,F
....................       } 
0F57C:  BRA    F5A4
....................       else if(output<intensity){ 
0F57E:  MOVF   xAD,W
0F580:  SUBWF  xA6,W
0F582:  BNC   F596
0F584:  BNZ   F58C
0F586:  MOVF   xA5,W
0F588:  SUBWF  xAC,W
0F58A:  BC    F596
....................          LED_level=LED_level+LED_level_change; 
0F58C:  MOVF   xAA,W
0F58E:  ADDWF  xA8,F
0F590:  MOVF   xAB,W
0F592:  ADDWFC xA9,F
....................       } 
0F594:  BRA    F5A4
....................       else if(output==intensity) break; 
0F596:  MOVF   xA5,W
0F598:  SUBWF  xAC,W
0F59A:  BNZ   F5A4
0F59C:  MOVF   xA6,W
0F59E:  SUBWF  xAD,W
0F5A0:  BTFSC  FD8.2
0F5A2:  BRA    F5A8
0F5A4:  INCF   xA7,F
0F5A6:  BRA    F52C
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F5A8:  MOVLW  01
0F5AA:  MOVWF  xB0
0F5AC:  MOVFF  8A9,8B2
0F5B0:  MOVFF  8A8,8B1
0F5B4:  MOVLB  0
0F5B6:  RCALL  F27A
0F5B8:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F5BA:  MOVLW  01
0F5BC:  MOVLB  8
0F5BE:  MOVWF  xA4
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F5C0:  MOVF   xA2,F
0F5C2:  BNZ   F5C8
0F5C4:  MOVF   xA3,F
0F5C6:  BZ    F5DC
0F5C8:  MOVF   xA3,W
0F5CA:  SUBLW  0F
0F5CC:  BNC   F5DC
0F5CE:  MOVFF  8A3,8A6
0F5D2:  MOVFF  8A2,8A5
0F5D6:  MOVLB  0
0F5D8:  RCALL  F51E
0F5DA:  MOVLB  8
....................   if(intensity == 0) { 
0F5DC:  MOVF   xA2,F
0F5DE:  BNZ   F602
0F5E0:  MOVF   xA3,F
0F5E2:  BNZ   F602
....................       DAC_set(1, 0); 
0F5E4:  MOVLW  01
0F5E6:  MOVWF  xB0
0F5E8:  CLRF   xB2
0F5EA:  CLRF   xB1
0F5EC:  MOVLB  0
0F5EE:  RCALL  F27A
....................       DAC_set(2, 0); 
0F5F0:  MOVLW  02
0F5F2:  MOVLB  8
0F5F4:  MOVWF  xB0
0F5F6:  CLRF   xB2
0F5F8:  CLRF   xB1
0F5FA:  MOVLB  0
0F5FC:  RCALL  F27A
....................    } 
0F5FE:  BRA    F606
0F600:  MOVLB  8
....................    else valid=FALSE; 
0F602:  CLRF   xA4
0F604:  MOVLB  0
....................    return(valid); 
0F606:  MOVLB  8
0F608:  MOVFF  8A4,01
0F60C:  MOVLB  0
0F60E:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FB90:  MOVLW  0C
0FB92:  MOVWF  FF6
0FB94:  MOVLW  1D
0FB96:  MOVWF  FF7
0FB98:  MOVLW  00
0FB9A:  MOVWF  FF8
0FB9C:  MOVLW  03
0FB9E:  MOVWF  FEA
0FBA0:  MOVLW  39
0FBA2:  MOVWF  FE9
0FBA4:  RCALL  FB56
0FBA6:  MOVF   01,W
0FBA8:  BZ    FBBC
0FBAA:  XORLW  01
0FBAC:  BZ    FBDC
0FBAE:  XORLW  03
0FBB0:  BZ    FBFC
0FBB2:  XORLW  01
0FBB4:  BZ    FC1C
0FBB6:  XORLW  07
0FBB8:  BZ    FC3C
0FBBA:  BRA    FC5A
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FBBC:  BCF    FD8.0
0FBBE:  MOVLB  3
0FBC0:  RLCF   x46,W
0FBC2:  CLRF   03
0FBC4:  ADDLW  47
0FBC6:  MOVWF  FE9
0FBC8:  MOVLW  03
0FBCA:  ADDWFC 03,W
0FBCC:  MOVWF  FEA
0FBCE:  MOVFF  4A4,FEC
0FBD2:  MOVF   FED,F
0FBD4:  MOVFF  4A3,FEF
....................          break; 
0FBD8:  MOVLB  0
0FBDA:  BRA    FC5A
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FBDC:  BCF    FD8.0
0FBDE:  MOVLB  3
0FBE0:  RLCF   x46,W
0FBE2:  CLRF   03
0FBE4:  ADDLW  59
0FBE6:  MOVWF  FE9
0FBE8:  MOVLW  03
0FBEA:  ADDWFC 03,W
0FBEC:  MOVWF  FEA
0FBEE:  MOVFF  4A4,FEC
0FBF2:  MOVF   FED,F
0FBF4:  MOVFF  4A3,FEF
....................          break;    
0FBF8:  MOVLB  0
0FBFA:  BRA    FC5A
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FBFC:  BCF    FD8.0
0FBFE:  MOVLB  3
0FC00:  RLCF   x46,W
0FC02:  CLRF   03
0FC04:  ADDLW  6B
0FC06:  MOVWF  FE9
0FC08:  MOVLW  03
0FC0A:  ADDWFC 03,W
0FC0C:  MOVWF  FEA
0FC0E:  MOVFF  4A4,FEC
0FC12:  MOVF   FED,F
0FC14:  MOVFF  4A3,FEF
....................          break; 
0FC18:  MOVLB  0
0FC1A:  BRA    FC5A
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FC1C:  BCF    FD8.0
0FC1E:  MOVLB  3
0FC20:  RLCF   x46,W
0FC22:  CLRF   03
0FC24:  ADDLW  7D
0FC26:  MOVWF  FE9
0FC28:  MOVLW  03
0FC2A:  ADDWFC 03,W
0FC2C:  MOVWF  FEA
0FC2E:  MOVFF  4A4,FEC
0FC32:  MOVF   FED,F
0FC34:  MOVFF  4A3,FEF
....................          break; 
0FC38:  MOVLB  0
0FC3A:  BRA    FC5A
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FC3C:  BCF    FD8.0
0FC3E:  MOVLB  3
0FC40:  RLCF   x46,W
0FC42:  CLRF   03
0FC44:  ADDLW  8F
0FC46:  MOVWF  FE9
0FC48:  MOVLW  03
0FC4A:  ADDWFC 03,W
0FC4C:  MOVWF  FEA
0FC4E:  MOVFF  4A4,FEC
0FC52:  MOVF   FED,F
0FC54:  MOVFF  4A3,FEF
....................          break; 
0FC58:  MOVLB  0
....................    } 
0FC5A:  GOTO   FF3E (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
0FCFC:  MOVFF  8A0,8B1
0FD00:  MOVFF  89F,8B0
0FD04:  CALL   F322
....................     
....................    v_supply = read_supply(); 
0FD08:  CALL   507E
0FD0C:  MOVFF  02,8A5
0FD10:  MOVFF  01,8A4
....................        
....................    RTC_reset_HT(); 
0FD14:  CALL   343A
....................    RTC_read(); 
0FD18:  CALL   32CC
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
0FD1C:  RCALL  F628
0FD1E:  MOVFF  02,8A7
0FD22:  MOVFF  01,8A6
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
0FD26:  MOVLB  8
0FD28:  DECFSZ xA3,W
0FD2A:  BRA    FD54
0FD2C:  MOVLW  10
0FD2E:  MOVWF  FE9
0FD30:  CLRF   1B
0FD32:  BTFSC  FF2.7
0FD34:  BSF    1B.7
0FD36:  BCF    FF2.7
0FD38:  MOVFF  4A6,A19
0FD3C:  MOVFF  4A5,A18
0FD40:  MOVLB  0
0FD42:  CALL   1192
0FD46:  BTFSC  1B.7
0FD48:  BSF    FF2.7
0FD4A:  MOVLW  2C
0FD4C:  BTFSS  F9E.4
0FD4E:  BRA    FD4C
0FD50:  MOVWF  FAD
0FD52:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
0FD54:  CLRF   1E
0FD56:  MOVLW  63
0FD58:  MOVWF  1D
0FD5A:  MOVFF  726,8CA
0FD5E:  MOVLW  01
0FD60:  MOVWF  xCB
0FD62:  MOVLB  0
0FD64:  CALL   5202
0FD68:  MOVLW  2F
0FD6A:  MOVLB  8
0FD6C:  MOVWF  xDC
0FD6E:  MOVLB  0
0FD70:  CALL   5020
0FD74:  MOVFF  725,8CA
0FD78:  MOVLW  01
0FD7A:  MOVLB  8
0FD7C:  MOVWF  xCB
0FD7E:  MOVLB  0
0FD80:  CALL   5202
0FD84:  MOVLW  2F
0FD86:  MOVLB  8
0FD88:  MOVWF  xDC
0FD8A:  MOVLB  0
0FD8C:  CALL   5020
0FD90:  MOVFF  727,8CA
0FD94:  MOVLW  01
0FD96:  MOVLB  8
0FD98:  MOVWF  xCB
0FD9A:  MOVLB  0
0FD9C:  CALL   5202
0FDA0:  MOVLW  20
0FDA2:  MOVLB  8
0FDA4:  MOVWF  xDC
0FDA6:  MOVLB  0
0FDA8:  CALL   5020
0FDAC:  MOVFF  723,8CA
0FDB0:  MOVLW  01
0FDB2:  MOVLB  8
0FDB4:  MOVWF  xCB
0FDB6:  MOVLB  0
0FDB8:  CALL   5202
0FDBC:  MOVLW  3A
0FDBE:  MOVLB  8
0FDC0:  MOVWF  xDC
0FDC2:  MOVLB  0
0FDC4:  CALL   5020
0FDC8:  MOVFF  722,8CA
0FDCC:  MOVLW  01
0FDCE:  MOVLB  8
0FDD0:  MOVWF  xCB
0FDD2:  MOVLB  0
0FDD4:  CALL   5202
0FDD8:  MOVLW  3A
0FDDA:  MOVLB  8
0FDDC:  MOVWF  xDC
0FDDE:  MOVLB  0
0FDE0:  CALL   5020
0FDE4:  MOVFF  721,8CA
0FDE8:  MOVLW  01
0FDEA:  MOVLB  8
0FDEC:  MOVWF  xCB
0FDEE:  MOVLB  0
0FDF0:  CALL   5202
0FDF4:  MOVLW  2C
0FDF6:  MOVLB  8
0FDF8:  MOVWF  xDC
0FDFA:  MOVLB  0
0FDFC:  CALL   5020
0FE00:  MOVLW  04
0FE02:  MOVWF  FE9
0FE04:  MOVLB  8
0FE06:  CLRF   xCD
0FE08:  CLRF   xCC
0FE0A:  MOVFF  8A5,8CB
0FE0E:  MOVFF  8A4,8CA
0FE12:  MOVLW  02
0FE14:  MOVWF  xCE
0FE16:  MOVLB  0
0FE18:  CALL   529C
0FE1C:  MOVLW  2C
0FE1E:  MOVLB  8
0FE20:  MOVWF  xDC
0FE22:  MOVLB  0
0FE24:  CALL   5020
0FE28:  MOVFF  1E,FEA
0FE2C:  MOVFF  1D,FE9
0FE30:  CLRF   FEF
0FE32:  MOVLW  03
0FE34:  MOVWF  FEA
0FE36:  MOVLW  39
0FE38:  MOVWF  FE9
0FE3A:  RCALL  FB30
0FE3C:  MOVLW  2C
0FE3E:  MOVLB  8
0FE40:  MOVWF  xDC
0FE42:  MOVLB  0
0FE44:  CALL   5020
0FE48:  MOVFF  1E,FEA
0FE4C:  MOVFF  1D,FE9
0FE50:  CLRF   FEF
0FE52:  MOVLW  03
0FE54:  MOVWF  FEA
0FE56:  MOVLW  3E
0FE58:  MOVWF  FE9
0FE5A:  RCALL  FB30
0FE5C:  MOVLW  2C
0FE5E:  MOVLB  8
0FE60:  MOVWF  xDC
0FE62:  MOVLB  0
0FE64:  CALL   5020
0FE68:  MOVFF  1E,FEA
0FE6C:  MOVFF  1D,FE9
0FE70:  CLRF   FEF
0FE72:  MOVLW  03
0FE74:  MOVWF  FEA
0FE76:  MOVLW  42
0FE78:  MOVWF  FE9
0FE7A:  RCALL  FB30
0FE7C:  MOVLW  2C
0FE7E:  MOVLB  8
0FE80:  MOVWF  xDC
0FE82:  MOVLB  0
0FE84:  CALL   5020
0FE88:  MOVLW  10
0FE8A:  MOVWF  FE9
0FE8C:  MOVFF  26,8D4
0FE90:  MOVFF  25,8D3
0FE94:  CALL   AA36
0FE98:  MOVLW  2C
0FE9A:  MOVLB  8
0FE9C:  MOVWF  xDC
0FE9E:  MOVLB  0
0FEA0:  CALL   5020
0FEA4:  MOVLW  10
0FEA6:  MOVWF  FE9
0FEA8:  MOVFF  8A7,8D4
0FEAC:  MOVFF  8A6,8D3
0FEB0:  CALL   AA36
0FEB4:  MOVLW  2C
0FEB6:  MOVLB  8
0FEB8:  MOVWF  xDC
0FEBA:  MOVLB  0
0FEBC:  CALL   5020
0FEC0:  MOVFF  4B1,8CA
0FEC4:  MOVLW  1B
0FEC6:  MOVLB  8
0FEC8:  MOVWF  xCB
0FECA:  MOVLB  0
0FECC:  CALL   5202
0FED0:  MOVLW  2C
0FED2:  MOVLB  8
0FED4:  MOVWF  xDC
0FED6:  MOVLB  0
0FED8:  CALL   5020
0FEDC:  MOVLW  10
0FEDE:  MOVWF  FE9
0FEE0:  MOVFF  4A4,8D4
0FEE4:  MOVFF  4A3,8D3
0FEE8:  CALL   AA36
0FEEC:  MOVLW  2C
0FEEE:  MOVLB  8
0FEF0:  MOVWF  xDC
0FEF2:  MOVLB  0
0FEF4:  CALL   5020
0FEF8:  MOVLW  10
0FEFA:  MOVWF  FE9
0FEFC:  MOVFF  4AA,8D4
0FF00:  MOVFF  4A9,8D3
0FF04:  CALL   AA36
0FF08:  MOVLW  2C
0FF0A:  MOVLB  8
0FF0C:  MOVWF  xDC
0FF0E:  MOVLB  0
0FF10:  CALL   5020
0FF14:  MOVLW  10
0FF16:  MOVWF  FE9
0FF18:  MOVFF  4A8,8D4
0FF1C:  MOVFF  4A7,8D3
0FF20:  CALL   AA36
0FF24:  MOVLW  0D
0FF26:  MOVLB  8
0FF28:  MOVWF  xDC
0FF2A:  MOVLB  0
0FF2C:  CALL   5020
0FF30:  MOVLW  0A
0FF32:  MOVLB  8
0FF34:  MOVWF  xDC
0FF36:  MOVLB  0
0FF38:  CALL   5020
....................  
....................    load_scanned_data();  
0FF3C:  BRA    FB90
....................  
....................    display_rec(store, display); 
0FF3E:  MOVFF  8A1,8C8
0FF42:  MOVFF  8A2,8C9
0FF46:  RCALL  FC5E
....................     
....................    data_available = TRUE; 
0FF48:  MOVLW  01
0FF4A:  MOVLB  3
0FF4C:  MOVWF  x37
....................    macro_flag = 900; 
0FF4E:  MOVLW  03
0FF50:  MOVWF  x20
0FF52:  MOVLW  84
0FF54:  MOVWF  x1F
0FF56:  MOVLB  0
0FF58:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
*
10000:  MOVLB  8
10002:  CLRF   x68
10004:  CLRF   x67
....................    channel=channel-20000; 
10006:  MOVLW  20
10008:  SUBWF  x64,F
1000A:  MOVLW  4E
1000C:  SUBWFB x65,F
....................     
....................    for (i=0; i<9; i++){ 
1000E:  CLRF   x66
10010:  MOVF   x66,W
10012:  SUBLW  08
10014:  BTFSS  FD8.0
10016:  GOTO   100C2
....................       DAC_set(channel, setting); 
1001A:  MOVFF  864,8B0
1001E:  MOVFF  868,8B2
10022:  MOVFF  867,8B1
10026:  MOVLB  0
10028:  CALL   F27A
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
1002C:  MOVLW  22
1002E:  MOVWF  FF6
10030:  MOVLW  1D
10032:  MOVWF  FF7
10034:  MOVLW  00
10036:  MOVWF  FF8
10038:  CLRF   1B
1003A:  BTFSC  FF2.7
1003C:  BSF    1B.7
1003E:  BCF    FF2.7
10040:  MOVLW  05
10042:  MOVLB  A
10044:  MOVWF  x18
10046:  MOVLB  0
10048:  CALL   1010
1004C:  BTFSC  1B.7
1004E:  BSF    FF2.7
10050:  MOVLW  10
10052:  MOVWF  FE9
10054:  CLRF   1B
10056:  BTFSC  FF2.7
10058:  BSF    1B.7
1005A:  BCF    FF2.7
1005C:  MOVFF  865,A19
10060:  MOVFF  864,A18
10064:  CALL   1192
10068:  BTFSC  1B.7
1006A:  BSF    FF2.7
1006C:  MOVLW  2C
1006E:  BTFSS  F9E.4
10070:  GOTO   1006E
10074:  MOVWF  FAD
10076:  MOVLW  10
10078:  MOVWF  FE9
1007A:  CLRF   1B
1007C:  BTFSC  FF2.7
1007E:  BSF    1B.7
10080:  BCF    FF2.7
10082:  MOVFF  868,A19
10086:  MOVFF  867,A18
1008A:  CALL   1192
1008E:  BTFSC  1B.7
10090:  BSF    FF2.7
10092:  MOVLW  2C
10094:  BTFSS  F9E.4
10096:  GOTO   10094
1009A:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
1009C:  MOVLB  8
1009E:  CLRF   xA0
100A0:  MOVLW  C8
100A2:  MOVWF  x9F
100A4:  CLRF   xA1
100A6:  MOVLW  01
100A8:  MOVWF  xA2
100AA:  MOVWF  xA3
100AC:  MOVLB  0
100AE:  CALL   FCFC
....................       setting = setting+500; 
100B2:  MOVLW  F4
100B4:  MOVLB  8
100B6:  ADDWF  x67,F
100B8:  MOVLW  01
100BA:  ADDWFC x68,F
100BC:  INCF   x66,F
100BE:  GOTO   10010
....................    } 
100C2:  MOVLB  0
100C4:  GOTO   10194 (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
*
0FF5A:  MOVLB  8
0FF5C:  CLRF   x64
0FF5E:  CLRF   x63
....................     
....................    for (i=0; i<9; i++){ 
0FF60:  CLRF   x62
0FF62:  MOVF   x62,W
0FF64:  SUBLW  08
0FF66:  BNC   FFE0
....................       LED_SAR(intensity); 
0FF68:  MOVFF  864,8A6
0FF6C:  MOVFF  863,8A5
0FF70:  MOVLB  0
0FF72:  CALL   F51E
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
0FF76:  MOVLW  30
0FF78:  MOVWF  FF6
0FF7A:  MOVLW  1D
0FF7C:  MOVWF  FF7
0FF7E:  MOVLW  00
0FF80:  MOVWF  FF8
0FF82:  CLRF   1B
0FF84:  BTFSC  FF2.7
0FF86:  BSF    1B.7
0FF88:  BCF    FF2.7
0FF8A:  MOVLW  07
0FF8C:  MOVLB  A
0FF8E:  MOVWF  x18
0FF90:  MOVLB  0
0FF92:  CALL   1010
0FF96:  BTFSC  1B.7
0FF98:  BSF    FF2.7
0FF9A:  MOVLW  10
0FF9C:  MOVWF  FE9
0FF9E:  CLRF   1B
0FFA0:  BTFSC  FF2.7
0FFA2:  BSF    1B.7
0FFA4:  BCF    FF2.7
0FFA6:  MOVFF  864,A19
0FFAA:  MOVFF  863,A18
0FFAE:  CALL   1192
0FFB2:  BTFSC  1B.7
0FFB4:  BSF    FF2.7
0FFB6:  MOVLW  2C
0FFB8:  BTFSS  F9E.4
0FFBA:  BRA    FFB8
0FFBC:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
0FFBE:  MOVLB  8
0FFC0:  CLRF   xA0
0FFC2:  MOVLW  C8
0FFC4:  MOVWF  x9F
0FFC6:  CLRF   xA1
0FFC8:  MOVLW  01
0FFCA:  MOVWF  xA2
0FFCC:  MOVWF  xA3
0FFCE:  MOVLB  0
0FFD0:  RCALL  FCFC
....................       intensity = intensity+500; 
0FFD2:  MOVLW  F4
0FFD4:  MOVLB  8
0FFD6:  ADDWF  x63,F
0FFD8:  MOVLW  01
0FFDA:  ADDWFC x64,F
0FFDC:  INCF   x62,F
0FFDE:  BRA    FF62
....................    } 
0FFE0:  MOVLB  0
0FFE2:  GOTO   10194 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
03042:  MOVLB  8
03044:  CLRF   x93
03046:  MOVF   x93,W
03048:  SUBLW  20
0304A:  BNC   3060
0304C:  CLRF   03
0304E:  MOVF   x93,W
03050:  ADDLW  B3
03052:  MOVWF  FE9
03054:  MOVLW  04
03056:  ADDWFC 03,W
03058:  MOVWF  FEA
0305A:  CLRF   FEF
0305C:  INCF   x93,F
0305E:  BRA    3046
03060:  MOVLB  0
03062:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
03064:  MOVF   2F,W
03066:  SUBLW  02
03068:  BNZ   3072
0306A:  MOVF   30,F
0306C:  BNZ   3072
0306E:  MOVLW  00
03070:  MOVWF  F99
....................    init_valve_status(); 
03072:  RCALL  3042
....................    bus_pwr_status=0; 
03074:  MOVLB  4
03076:  CLRF   xB2
03078:  MOVLB  0
0307A:  GOTO   1B1EE (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0EA68:  MOVLW  3C
0EA6A:  MOVWF  FF6
0EA6C:  MOVLW  1D
0EA6E:  MOVWF  FF7
0EA70:  MOVLW  00
0EA72:  MOVWF  FF8
0EA74:  CLRF   1B
0EA76:  BTFSC  FF2.7
0EA78:  BSF    1B.7
0EA7A:  BCF    FF2.7
0EA7C:  CALL   0E3A
0EA80:  BTFSC  1B.7
0EA82:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EA84:  MOVLW  01
0EA86:  MOVLB  8
0EA88:  MOVWF  x93
0EA8A:  MOVF   x93,W
0EA8C:  SUBLW  08
0EA8E:  BNC   EAF8
0EA90:  CLRF   03
0EA92:  MOVF   x93,W
0EA94:  ADDLW  B3
0EA96:  MOVWF  FE9
0EA98:  MOVLW  04
0EA9A:  ADDWFC 03,W
0EA9C:  MOVWF  FEA
0EA9E:  MOVFF  FEF,894
0EAA2:  CLRF   1B
0EAA4:  BTFSC  FF2.7
0EAA6:  BSF    1B.7
0EAA8:  BCF    FF2.7
0EAAA:  MOVFF  893,A18
0EAAE:  MOVLW  01
0EAB0:  MOVLB  A
0EAB2:  MOVWF  x19
0EAB4:  MOVLB  0
0EAB6:  CALL   0F92
0EABA:  BTFSC  1B.7
0EABC:  BSF    FF2.7
0EABE:  MOVLW  5B
0EAC0:  BTFSS  F9E.4
0EAC2:  BRA    EAC0
0EAC4:  MOVWF  FAD
0EAC6:  CLRF   1B
0EAC8:  BTFSC  FF2.7
0EACA:  BSF    1B.7
0EACC:  BCF    FF2.7
0EACE:  MOVFF  894,A18
0EAD2:  MOVLW  1B
0EAD4:  MOVLB  A
0EAD6:  MOVWF  x19
0EAD8:  MOVLB  0
0EADA:  CALL   0F92
0EADE:  BTFSC  1B.7
0EAE0:  BSF    FF2.7
0EAE2:  MOVLW  5D
0EAE4:  BTFSS  F9E.4
0EAE6:  BRA    EAE4
0EAE8:  MOVWF  FAD
0EAEA:  MOVLW  20
0EAEC:  BTFSS  F9E.4
0EAEE:  BRA    EAEC
0EAF0:  MOVWF  FAD
0EAF2:  MOVLB  8
0EAF4:  INCF   x93,F
0EAF6:  BRA    EA8A
....................    fprintf(COM_A, "\r\n"); 
0EAF8:  MOVLW  0D
0EAFA:  BTFSS  F9E.4
0EAFC:  BRA    EAFA
0EAFE:  MOVWF  FAD
0EB00:  MOVLW  0A
0EB02:  BTFSS  F9E.4
0EB04:  BRA    EB02
0EB06:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EB08:  MOVLW  42
0EB0A:  MOVWF  FF6
0EB0C:  MOVLW  1D
0EB0E:  MOVWF  FF7
0EB10:  MOVLW  00
0EB12:  MOVWF  FF8
0EB14:  CLRF   1B
0EB16:  BTFSC  FF2.7
0EB18:  BSF    1B.7
0EB1A:  BCF    FF2.7
0EB1C:  MOVLB  0
0EB1E:  CALL   0E3A
0EB22:  BTFSC  1B.7
0EB24:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EB26:  MOVLW  09
0EB28:  MOVLB  8
0EB2A:  MOVWF  x93
0EB2C:  MOVF   x93,W
0EB2E:  SUBLW  10
0EB30:  BNC   EB9A
0EB32:  CLRF   03
0EB34:  MOVF   x93,W
0EB36:  ADDLW  B3
0EB38:  MOVWF  FE9
0EB3A:  MOVLW  04
0EB3C:  ADDWFC 03,W
0EB3E:  MOVWF  FEA
0EB40:  MOVFF  FEF,894
0EB44:  CLRF   1B
0EB46:  BTFSC  FF2.7
0EB48:  BSF    1B.7
0EB4A:  BCF    FF2.7
0EB4C:  MOVFF  893,A18
0EB50:  MOVLW  01
0EB52:  MOVLB  A
0EB54:  MOVWF  x19
0EB56:  MOVLB  0
0EB58:  CALL   0F92
0EB5C:  BTFSC  1B.7
0EB5E:  BSF    FF2.7
0EB60:  MOVLW  5B
0EB62:  BTFSS  F9E.4
0EB64:  BRA    EB62
0EB66:  MOVWF  FAD
0EB68:  CLRF   1B
0EB6A:  BTFSC  FF2.7
0EB6C:  BSF    1B.7
0EB6E:  BCF    FF2.7
0EB70:  MOVFF  894,A18
0EB74:  MOVLW  1B
0EB76:  MOVLB  A
0EB78:  MOVWF  x19
0EB7A:  MOVLB  0
0EB7C:  CALL   0F92
0EB80:  BTFSC  1B.7
0EB82:  BSF    FF2.7
0EB84:  MOVLW  5D
0EB86:  BTFSS  F9E.4
0EB88:  BRA    EB86
0EB8A:  MOVWF  FAD
0EB8C:  MOVLW  20
0EB8E:  BTFSS  F9E.4
0EB90:  BRA    EB8E
0EB92:  MOVWF  FAD
0EB94:  MOVLB  8
0EB96:  INCF   x93,F
0EB98:  BRA    EB2C
....................    fprintf(COM_A, "\r\n"); 
0EB9A:  MOVLW  0D
0EB9C:  BTFSS  F9E.4
0EB9E:  BRA    EB9C
0EBA0:  MOVWF  FAD
0EBA2:  MOVLW  0A
0EBA4:  BTFSS  F9E.4
0EBA6:  BRA    EBA4
0EBA8:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EBAA:  MOVLW  48
0EBAC:  MOVWF  FF6
0EBAE:  MOVLW  1D
0EBB0:  MOVWF  FF7
0EBB2:  MOVLW  00
0EBB4:  MOVWF  FF8
0EBB6:  CLRF   1B
0EBB8:  BTFSC  FF2.7
0EBBA:  BSF    1B.7
0EBBC:  BCF    FF2.7
0EBBE:  MOVLB  0
0EBC0:  CALL   0E3A
0EBC4:  BTFSC  1B.7
0EBC6:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EBC8:  MOVLW  11
0EBCA:  MOVLB  8
0EBCC:  MOVWF  x93
0EBCE:  MOVF   x93,W
0EBD0:  SUBLW  18
0EBD2:  BNC   EC3C
0EBD4:  CLRF   03
0EBD6:  MOVF   x93,W
0EBD8:  ADDLW  B3
0EBDA:  MOVWF  FE9
0EBDC:  MOVLW  04
0EBDE:  ADDWFC 03,W
0EBE0:  MOVWF  FEA
0EBE2:  MOVFF  FEF,894
0EBE6:  CLRF   1B
0EBE8:  BTFSC  FF2.7
0EBEA:  BSF    1B.7
0EBEC:  BCF    FF2.7
0EBEE:  MOVFF  893,A18
0EBF2:  MOVLW  01
0EBF4:  MOVLB  A
0EBF6:  MOVWF  x19
0EBF8:  MOVLB  0
0EBFA:  CALL   0F92
0EBFE:  BTFSC  1B.7
0EC00:  BSF    FF2.7
0EC02:  MOVLW  5B
0EC04:  BTFSS  F9E.4
0EC06:  BRA    EC04
0EC08:  MOVWF  FAD
0EC0A:  CLRF   1B
0EC0C:  BTFSC  FF2.7
0EC0E:  BSF    1B.7
0EC10:  BCF    FF2.7
0EC12:  MOVFF  894,A18
0EC16:  MOVLW  1B
0EC18:  MOVLB  A
0EC1A:  MOVWF  x19
0EC1C:  MOVLB  0
0EC1E:  CALL   0F92
0EC22:  BTFSC  1B.7
0EC24:  BSF    FF2.7
0EC26:  MOVLW  5D
0EC28:  BTFSS  F9E.4
0EC2A:  BRA    EC28
0EC2C:  MOVWF  FAD
0EC2E:  MOVLW  20
0EC30:  BTFSS  F9E.4
0EC32:  BRA    EC30
0EC34:  MOVWF  FAD
0EC36:  MOVLB  8
0EC38:  INCF   x93,F
0EC3A:  BRA    EBCE
....................    fprintf(COM_A, "\r\n"); 
0EC3C:  MOVLW  0D
0EC3E:  BTFSS  F9E.4
0EC40:  BRA    EC3E
0EC42:  MOVWF  FAD
0EC44:  MOVLW  0A
0EC46:  BTFSS  F9E.4
0EC48:  BRA    EC46
0EC4A:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EC4C:  MOVLW  4E
0EC4E:  MOVWF  FF6
0EC50:  MOVLW  1D
0EC52:  MOVWF  FF7
0EC54:  MOVLW  00
0EC56:  MOVWF  FF8
0EC58:  CLRF   1B
0EC5A:  BTFSC  FF2.7
0EC5C:  BSF    1B.7
0EC5E:  BCF    FF2.7
0EC60:  MOVLB  0
0EC62:  CALL   0E3A
0EC66:  BTFSC  1B.7
0EC68:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EC6A:  MOVLW  19
0EC6C:  MOVLB  8
0EC6E:  MOVWF  x93
0EC70:  MOVF   x93,W
0EC72:  SUBLW  20
0EC74:  BNC   ECDE
0EC76:  CLRF   03
0EC78:  MOVF   x93,W
0EC7A:  ADDLW  B3
0EC7C:  MOVWF  FE9
0EC7E:  MOVLW  04
0EC80:  ADDWFC 03,W
0EC82:  MOVWF  FEA
0EC84:  MOVFF  FEF,894
0EC88:  CLRF   1B
0EC8A:  BTFSC  FF2.7
0EC8C:  BSF    1B.7
0EC8E:  BCF    FF2.7
0EC90:  MOVFF  893,A18
0EC94:  MOVLW  01
0EC96:  MOVLB  A
0EC98:  MOVWF  x19
0EC9A:  MOVLB  0
0EC9C:  CALL   0F92
0ECA0:  BTFSC  1B.7
0ECA2:  BSF    FF2.7
0ECA4:  MOVLW  5B
0ECA6:  BTFSS  F9E.4
0ECA8:  BRA    ECA6
0ECAA:  MOVWF  FAD
0ECAC:  CLRF   1B
0ECAE:  BTFSC  FF2.7
0ECB0:  BSF    1B.7
0ECB2:  BCF    FF2.7
0ECB4:  MOVFF  894,A18
0ECB8:  MOVLW  1B
0ECBA:  MOVLB  A
0ECBC:  MOVWF  x19
0ECBE:  MOVLB  0
0ECC0:  CALL   0F92
0ECC4:  BTFSC  1B.7
0ECC6:  BSF    FF2.7
0ECC8:  MOVLW  5D
0ECCA:  BTFSS  F9E.4
0ECCC:  BRA    ECCA
0ECCE:  MOVWF  FAD
0ECD0:  MOVLW  20
0ECD2:  BTFSS  F9E.4
0ECD4:  BRA    ECD2
0ECD6:  MOVWF  FAD
0ECD8:  MOVLB  8
0ECDA:  INCF   x93,F
0ECDC:  BRA    EC70
....................    fprintf(COM_A, "\r\n");    
0ECDE:  MOVLW  0D
0ECE0:  BTFSS  F9E.4
0ECE2:  BRA    ECE0
0ECE4:  MOVWF  FAD
0ECE6:  MOVLW  0A
0ECE8:  BTFSS  F9E.4
0ECEA:  BRA    ECE8
0ECEC:  MOVWF  FAD
0ECEE:  MOVLB  0
0ECF0:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
14014:  MOVF   1F,W
14016:  SUBLW  04
14018:  BNZ   14082
1401A:  MOVF   20,F
1401C:  BNZ   14082
1401E:  MOVLW  54
14020:  MOVWF  FF6
14022:  MOVLW  1D
14024:  MOVWF  FF7
14026:  MOVLW  00
14028:  MOVWF  FF8
1402A:  CLRF   1B
1402C:  BTFSC  FF2.7
1402E:  BSF    1B.7
14030:  BCF    FF2.7
14032:  MOVLW  0C
14034:  MOVLB  A
14036:  MOVWF  x18
14038:  MOVLB  0
1403A:  CALL   1010
1403E:  BTFSC  1B.7
14040:  BSF    FF2.7
14042:  MOVLW  10
14044:  MOVWF  FE9
14046:  CLRF   1B
14048:  BTFSC  FF2.7
1404A:  BSF    1B.7
1404C:  BCF    FF2.7
1404E:  MOVFF  894,A19
14052:  MOVFF  893,A18
14056:  CALL   1192
1405A:  BTFSC  1B.7
1405C:  BSF    FF2.7
1405E:  MOVLW  63
14060:  MOVWF  FF6
14062:  MOVLW  1D
14064:  MOVWF  FF7
14066:  MOVLW  00
14068:  MOVWF  FF8
1406A:  CLRF   1B
1406C:  BTFSC  FF2.7
1406E:  BSF    1B.7
14070:  BCF    FF2.7
14072:  MOVLW  03
14074:  MOVLB  A
14076:  MOVWF  x18
14078:  MOVLB  0
1407A:  CALL   1010
1407E:  BTFSC  1B.7
14080:  BSF    FF2.7
....................  
....................    multidrop_on(); 
14082:  CALL   D77E
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
14086:  MOVLW  68
14088:  MOVWF  FF6
1408A:  MOVLW  1D
1408C:  MOVWF  FF7
1408E:  MOVLW  00
14090:  MOVWF  FF8
14092:  MOVLW  03
14094:  MOVLB  8
14096:  MOVWF  x95
14098:  MOVLB  0
1409A:  CALL   D792
1409E:  MOVLW  10
140A0:  MOVWF  FE9
140A2:  MOVFF  894,896
140A6:  MOVFF  893,895
140AA:  BRA    13F5A
140AC:  MOVLW  0D
140AE:  BTFSS  FA4.4
140B0:  BRA    140AE
140B2:  MOVLB  F
140B4:  MOVWF  x1C
....................    multidrop_off(); 
140B6:  MOVLB  0
140B8:  CALL   D86A
....................  
....................    delay_ms(100); 
140BC:  MOVLW  64
140BE:  MOVLB  9
140C0:  MOVWF  xC9
140C2:  MOVLB  0
140C4:  CALL   2898
140C8:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0D8BC:  MOVF   1F,W
0D8BE:  SUBLW  04
0D8C0:  BNZ   D92A
0D8C2:  MOVF   20,F
0D8C4:  BNZ   D92A
0D8C6:  MOVLW  70
0D8C8:  MOVWF  FF6
0D8CA:  MOVLW  1D
0D8CC:  MOVWF  FF7
0D8CE:  MOVLW  00
0D8D0:  MOVWF  FF8
0D8D2:  CLRF   1B
0D8D4:  BTFSC  FF2.7
0D8D6:  BSF    1B.7
0D8D8:  BCF    FF2.7
0D8DA:  MOVLW  0C
0D8DC:  MOVLB  A
0D8DE:  MOVWF  x18
0D8E0:  MOVLB  0
0D8E2:  CALL   1010
0D8E6:  BTFSC  1B.7
0D8E8:  BSF    FF2.7
0D8EA:  CLRF   1B
0D8EC:  BTFSC  FF2.7
0D8EE:  BSF    1B.7
0D8F0:  BCF    FF2.7
0D8F2:  MOVFF  893,A18
0D8F6:  MOVLW  1B
0D8F8:  MOVLB  A
0D8FA:  MOVWF  x19
0D8FC:  MOVLB  0
0D8FE:  CALL   0F92
0D902:  BTFSC  1B.7
0D904:  BSF    FF2.7
0D906:  MOVLW  7E
0D908:  MOVWF  FF6
0D90A:  MOVLW  1D
0D90C:  MOVWF  FF7
0D90E:  MOVLW  00
0D910:  MOVWF  FF8
0D912:  CLRF   1B
0D914:  BTFSC  FF2.7
0D916:  BSF    1B.7
0D918:  BCF    FF2.7
0D91A:  MOVLW  03
0D91C:  MOVLB  A
0D91E:  MOVWF  x18
0D920:  MOVLB  0
0D922:  CALL   1010
0D926:  BTFSC  1B.7
0D928:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0D92A:  RCALL  D77E
....................       fprintf(COM_B, "/1c%u\r",chip); 
0D92C:  MOVLW  82
0D92E:  MOVWF  FF6
0D930:  MOVLW  1D
0D932:  MOVWF  FF7
0D934:  MOVLW  00
0D936:  MOVWF  FF8
0D938:  MOVLW  03
0D93A:  MOVLB  8
0D93C:  MOVWF  x95
0D93E:  MOVLB  0
0D940:  RCALL  D792
0D942:  MOVFF  893,8D0
0D946:  MOVLW  1B
0D948:  MOVLB  8
0D94A:  MOVWF  xD1
0D94C:  MOVLB  0
0D94E:  RCALL  D7C6
0D950:  MOVLW  0D
0D952:  BTFSS  FA4.4
0D954:  BRA    D952
0D956:  MOVLB  F
0D958:  MOVWF  x1C
....................    multidrop_off(); 
0D95A:  MOVLB  0
0D95C:  RCALL  D86A
....................    delay_ms(100); 
0D95E:  MOVLW  64
0D960:  MOVLB  9
0D962:  MOVWF  xC9
0D964:  MOVLB  0
0D966:  CALL   2898
....................  
....................    multidrop_on(); 
0D96A:  RCALL  D77E
....................      fprintf(COM_B, "/1s256\r"); 
0D96C:  MOVLW  8A
0D96E:  MOVWF  FF6
0D970:  MOVLW  1D
0D972:  MOVWF  FF7
0D974:  MOVLW  00
0D976:  MOVWF  FF8
0D978:  BRA    D88C
....................    multidrop_off();  
0D97A:  RCALL  D86A
....................    delay_ms(100); 
0D97C:  MOVLW  64
0D97E:  MOVLB  9
0D980:  MOVWF  xC9
0D982:  MOVLB  0
0D984:  CALL   2898
0D988:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
140CA:  MOVLB  8
140CC:  MOVF   x92,W
140CE:  ADDLW  DF
140D0:  BTFSC  FD8.0
140D2:  BRA    144BE
140D4:  ADDLW  21
140D6:  MOVLB  0
140D8:  GOTO   144F0
....................       case 0 : sol_chip_cmd(1); 
140DC:  MOVLW  01
140DE:  MOVLB  8
140E0:  MOVWF  x93
140E2:  MOVLB  0
140E4:  CALL   D8BC
....................                sol_switch_cmd(0); 
140E8:  MOVLB  8
140EA:  CLRF   x94
140EC:  CLRF   x93
140EE:  MOVLB  0
140F0:  RCALL  14014
....................                sol_chip_cmd(2); 
140F2:  MOVLW  02
140F4:  MOVLB  8
140F6:  MOVWF  x93
140F8:  MOVLB  0
140FA:  CALL   D8BC
....................                sol_switch_cmd(0); 
140FE:  MOVLB  8
14100:  CLRF   x94
14102:  CLRF   x93
14104:  MOVLB  0
14106:  RCALL  14014
....................                sol_chip_cmd(3); 
14108:  MOVLW  03
1410A:  MOVLB  8
1410C:  MOVWF  x93
1410E:  MOVLB  0
14110:  CALL   D8BC
....................                sol_switch_cmd(0); 
14114:  MOVLB  8
14116:  CLRF   x94
14118:  CLRF   x93
1411A:  MOVLB  0
1411C:  RCALL  14014
....................                sol_chip_cmd(4); 
1411E:  MOVLW  04
14120:  MOVLB  8
14122:  MOVWF  x93
14124:  MOVLB  0
14126:  CALL   D8BC
....................                sol_switch_cmd(0); 
1412A:  MOVLB  8
1412C:  CLRF   x94
1412E:  CLRF   x93
14130:  MOVLB  0
14132:  RCALL  14014
....................                init_valve_status(); 
14134:  CALL   3042
....................          break; 
14138:  MOVLB  8
1413A:  BRA    144BE
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
1413C:  MOVLW  01
1413E:  MOVLB  8
14140:  MOVWF  x93
14142:  MOVLB  0
14144:  CALL   D8BC
....................                sol_switch_cmd(1); 
14148:  MOVLB  8
1414A:  CLRF   x94
1414C:  MOVLW  01
1414E:  MOVWF  x93
14150:  MOVLB  0
14152:  RCALL  14014
....................          break;     
14154:  MOVLB  8
14156:  BRA    144BE
....................       case 2 : sol_chip_cmd(1); 
14158:  MOVLW  01
1415A:  MOVLB  8
1415C:  MOVWF  x93
1415E:  MOVLB  0
14160:  CALL   D8BC
....................                sol_switch_cmd(2); 
14164:  MOVLB  8
14166:  CLRF   x94
14168:  MOVLW  02
1416A:  MOVWF  x93
1416C:  MOVLB  0
1416E:  RCALL  14014
....................          break;           
14170:  MOVLB  8
14172:  BRA    144BE
....................       case 3 : sol_chip_cmd(1); 
14174:  MOVLW  01
14176:  MOVLB  8
14178:  MOVWF  x93
1417A:  MOVLB  0
1417C:  CALL   D8BC
....................                sol_switch_cmd(4); 
14180:  MOVLB  8
14182:  CLRF   x94
14184:  MOVLW  04
14186:  MOVWF  x93
14188:  MOVLB  0
1418A:  RCALL  14014
....................          break;  
1418C:  MOVLB  8
1418E:  BRA    144BE
....................       case 4 : sol_chip_cmd(1); 
14190:  MOVLW  01
14192:  MOVLB  8
14194:  MOVWF  x93
14196:  MOVLB  0
14198:  CALL   D8BC
....................                sol_switch_cmd(8); 
1419C:  MOVLB  8
1419E:  CLRF   x94
141A0:  MOVLW  08
141A2:  MOVWF  x93
141A4:  MOVLB  0
141A6:  RCALL  14014
....................          break;  
141A8:  MOVLB  8
141AA:  BRA    144BE
....................       case 5 : sol_chip_cmd(1); 
141AC:  MOVLW  01
141AE:  MOVLB  8
141B0:  MOVWF  x93
141B2:  MOVLB  0
141B4:  CALL   D8BC
....................                sol_switch_cmd(16); 
141B8:  MOVLB  8
141BA:  CLRF   x94
141BC:  MOVLW  10
141BE:  MOVWF  x93
141C0:  MOVLB  0
141C2:  RCALL  14014
....................          break;  
141C4:  MOVLB  8
141C6:  BRA    144BE
....................       case 6 : sol_chip_cmd(1); 
141C8:  MOVLW  01
141CA:  MOVLB  8
141CC:  MOVWF  x93
141CE:  MOVLB  0
141D0:  CALL   D8BC
....................                sol_switch_cmd(32); 
141D4:  MOVLB  8
141D6:  CLRF   x94
141D8:  MOVLW  20
141DA:  MOVWF  x93
141DC:  MOVLB  0
141DE:  RCALL  14014
....................          break;  
141E0:  MOVLB  8
141E2:  BRA    144BE
....................       case 7 : sol_chip_cmd(1); 
141E4:  MOVLW  01
141E6:  MOVLB  8
141E8:  MOVWF  x93
141EA:  MOVLB  0
141EC:  CALL   D8BC
....................                sol_switch_cmd(64); 
141F0:  MOVLB  8
141F2:  CLRF   x94
141F4:  MOVLW  40
141F6:  MOVWF  x93
141F8:  MOVLB  0
141FA:  RCALL  14014
....................          break;  
141FC:  MOVLB  8
141FE:  BRA    144BE
....................       case 8 : sol_chip_cmd(1); 
14200:  MOVLW  01
14202:  MOVLB  8
14204:  MOVWF  x93
14206:  MOVLB  0
14208:  CALL   D8BC
....................                sol_switch_cmd(128); 
1420C:  MOVLB  8
1420E:  CLRF   x94
14210:  MOVLW  80
14212:  MOVWF  x93
14214:  MOVLB  0
14216:  RCALL  14014
....................          break;   
14218:  MOVLB  8
1421A:  BRA    144BE
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
1421C:  MOVLW  02
1421E:  MOVLB  8
14220:  MOVWF  x93
14222:  MOVLB  0
14224:  CALL   D8BC
....................                sol_switch_cmd(1); 
14228:  MOVLB  8
1422A:  CLRF   x94
1422C:  MOVLW  01
1422E:  MOVWF  x93
14230:  MOVLB  0
14232:  RCALL  14014
....................          break;     
14234:  MOVLB  8
14236:  BRA    144BE
....................       case 10 : sol_chip_cmd(2); 
14238:  MOVLW  02
1423A:  MOVLB  8
1423C:  MOVWF  x93
1423E:  MOVLB  0
14240:  CALL   D8BC
....................                sol_switch_cmd(2); 
14244:  MOVLB  8
14246:  CLRF   x94
14248:  MOVLW  02
1424A:  MOVWF  x93
1424C:  MOVLB  0
1424E:  RCALL  14014
....................          break;           
14250:  MOVLB  8
14252:  BRA    144BE
....................       case 11 : sol_chip_cmd(2); 
14254:  MOVLW  02
14256:  MOVLB  8
14258:  MOVWF  x93
1425A:  MOVLB  0
1425C:  CALL   D8BC
....................                sol_switch_cmd(4); 
14260:  MOVLB  8
14262:  CLRF   x94
14264:  MOVLW  04
14266:  MOVWF  x93
14268:  MOVLB  0
1426A:  RCALL  14014
....................          break;  
1426C:  MOVLB  8
1426E:  BRA    144BE
....................       case 12 : sol_chip_cmd(2); 
14270:  MOVLW  02
14272:  MOVLB  8
14274:  MOVWF  x93
14276:  MOVLB  0
14278:  CALL   D8BC
....................                sol_switch_cmd(8); 
1427C:  MOVLB  8
1427E:  CLRF   x94
14280:  MOVLW  08
14282:  MOVWF  x93
14284:  MOVLB  0
14286:  RCALL  14014
....................          break;  
14288:  MOVLB  8
1428A:  BRA    144BE
....................       case 13 : sol_chip_cmd(2); 
1428C:  MOVLW  02
1428E:  MOVLB  8
14290:  MOVWF  x93
14292:  MOVLB  0
14294:  CALL   D8BC
....................                sol_switch_cmd(16); 
14298:  MOVLB  8
1429A:  CLRF   x94
1429C:  MOVLW  10
1429E:  MOVWF  x93
142A0:  MOVLB  0
142A2:  RCALL  14014
....................          break;  
142A4:  MOVLB  8
142A6:  BRA    144BE
....................       case 14 : sol_chip_cmd(2); 
142A8:  MOVLW  02
142AA:  MOVLB  8
142AC:  MOVWF  x93
142AE:  MOVLB  0
142B0:  CALL   D8BC
....................                sol_switch_cmd(32); 
142B4:  MOVLB  8
142B6:  CLRF   x94
142B8:  MOVLW  20
142BA:  MOVWF  x93
142BC:  MOVLB  0
142BE:  RCALL  14014
....................          break;  
142C0:  MOVLB  8
142C2:  BRA    144BE
....................       case 15 : sol_chip_cmd(2); 
142C4:  MOVLW  02
142C6:  MOVLB  8
142C8:  MOVWF  x93
142CA:  MOVLB  0
142CC:  CALL   D8BC
....................                sol_switch_cmd(64); 
142D0:  MOVLB  8
142D2:  CLRF   x94
142D4:  MOVLW  40
142D6:  MOVWF  x93
142D8:  MOVLB  0
142DA:  RCALL  14014
....................          break;  
142DC:  MOVLB  8
142DE:  BRA    144BE
....................       case 16 : sol_chip_cmd(2); 
142E0:  MOVLW  02
142E2:  MOVLB  8
142E4:  MOVWF  x93
142E6:  MOVLB  0
142E8:  CALL   D8BC
....................                sol_switch_cmd(128); 
142EC:  MOVLB  8
142EE:  CLRF   x94
142F0:  MOVLW  80
142F2:  MOVWF  x93
142F4:  MOVLB  0
142F6:  RCALL  14014
....................          break;   
142F8:  MOVLB  8
142FA:  BRA    144BE
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
142FC:  MOVLW  03
142FE:  MOVLB  8
14300:  MOVWF  x93
14302:  MOVLB  0
14304:  CALL   D8BC
....................                sol_switch_cmd(1); 
14308:  MOVLB  8
1430A:  CLRF   x94
1430C:  MOVLW  01
1430E:  MOVWF  x93
14310:  MOVLB  0
14312:  RCALL  14014
....................          break;     
14314:  MOVLB  8
14316:  BRA    144BE
....................       case 18 : sol_chip_cmd(3); 
14318:  MOVLW  03
1431A:  MOVLB  8
1431C:  MOVWF  x93
1431E:  MOVLB  0
14320:  CALL   D8BC
....................                sol_switch_cmd(2); 
14324:  MOVLB  8
14326:  CLRF   x94
14328:  MOVLW  02
1432A:  MOVWF  x93
1432C:  MOVLB  0
1432E:  RCALL  14014
....................          break;           
14330:  MOVLB  8
14332:  BRA    144BE
....................       case 19 : sol_chip_cmd(3); 
14334:  MOVLW  03
14336:  MOVLB  8
14338:  MOVWF  x93
1433A:  MOVLB  0
1433C:  CALL   D8BC
....................                sol_switch_cmd(4); 
14340:  MOVLB  8
14342:  CLRF   x94
14344:  MOVLW  04
14346:  MOVWF  x93
14348:  MOVLB  0
1434A:  RCALL  14014
....................          break;  
1434C:  MOVLB  8
1434E:  BRA    144BE
....................       case 20 : sol_chip_cmd(3); 
14350:  MOVLW  03
14352:  MOVLB  8
14354:  MOVWF  x93
14356:  MOVLB  0
14358:  CALL   D8BC
....................                sol_switch_cmd(8); 
1435C:  MOVLB  8
1435E:  CLRF   x94
14360:  MOVLW  08
14362:  MOVWF  x93
14364:  MOVLB  0
14366:  RCALL  14014
....................          break;  
14368:  MOVLB  8
1436A:  BRA    144BE
....................       case 21 : sol_chip_cmd(3); 
1436C:  MOVLW  03
1436E:  MOVLB  8
14370:  MOVWF  x93
14372:  MOVLB  0
14374:  CALL   D8BC
....................                sol_switch_cmd(16); 
14378:  MOVLB  8
1437A:  CLRF   x94
1437C:  MOVLW  10
1437E:  MOVWF  x93
14380:  MOVLB  0
14382:  RCALL  14014
....................          break;  
14384:  MOVLB  8
14386:  BRA    144BE
....................       case 22 : sol_chip_cmd(3); 
14388:  MOVLW  03
1438A:  MOVLB  8
1438C:  MOVWF  x93
1438E:  MOVLB  0
14390:  CALL   D8BC
....................                sol_switch_cmd(32); 
14394:  MOVLB  8
14396:  CLRF   x94
14398:  MOVLW  20
1439A:  MOVWF  x93
1439C:  MOVLB  0
1439E:  RCALL  14014
....................          break;  
143A0:  MOVLB  8
143A2:  BRA    144BE
....................       case 23 : sol_chip_cmd(3); 
143A4:  MOVLW  03
143A6:  MOVLB  8
143A8:  MOVWF  x93
143AA:  MOVLB  0
143AC:  CALL   D8BC
....................                sol_switch_cmd(64); 
143B0:  MOVLB  8
143B2:  CLRF   x94
143B4:  MOVLW  40
143B6:  MOVWF  x93
143B8:  MOVLB  0
143BA:  RCALL  14014
....................          break;  
143BC:  MOVLB  8
143BE:  BRA    144BE
....................       case 24 : sol_chip_cmd(3); 
143C0:  MOVLW  03
143C2:  MOVLB  8
143C4:  MOVWF  x93
143C6:  MOVLB  0
143C8:  CALL   D8BC
....................                sol_switch_cmd(128); 
143CC:  MOVLB  8
143CE:  CLRF   x94
143D0:  MOVLW  80
143D2:  MOVWF  x93
143D4:  MOVLB  0
143D6:  RCALL  14014
....................          break;      
143D8:  MOVLB  8
143DA:  BRA    144BE
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
143DC:  MOVLW  04
143DE:  MOVLB  8
143E0:  MOVWF  x93
143E2:  MOVLB  0
143E4:  CALL   D8BC
....................                sol_switch_cmd(1); 
143E8:  MOVLB  8
143EA:  CLRF   x94
143EC:  MOVLW  01
143EE:  MOVWF  x93
143F0:  MOVLB  0
143F2:  RCALL  14014
....................          break;     
143F4:  MOVLB  8
143F6:  BRA    144BE
....................       case 26 : sol_chip_cmd(4); 
143F8:  MOVLW  04
143FA:  MOVLB  8
143FC:  MOVWF  x93
143FE:  MOVLB  0
14400:  CALL   D8BC
....................                sol_switch_cmd(2); 
14404:  MOVLB  8
14406:  CLRF   x94
14408:  MOVLW  02
1440A:  MOVWF  x93
1440C:  MOVLB  0
1440E:  RCALL  14014
....................          break;           
14410:  MOVLB  8
14412:  BRA    144BE
....................       case 27 : sol_chip_cmd(4); 
14414:  MOVLW  04
14416:  MOVLB  8
14418:  MOVWF  x93
1441A:  MOVLB  0
1441C:  CALL   D8BC
....................                sol_switch_cmd(4); 
14420:  MOVLB  8
14422:  CLRF   x94
14424:  MOVLW  04
14426:  MOVWF  x93
14428:  MOVLB  0
1442A:  RCALL  14014
....................          break;  
1442C:  MOVLB  8
1442E:  BRA    144BE
....................       case 28 : sol_chip_cmd(4); 
14430:  MOVLW  04
14432:  MOVLB  8
14434:  MOVWF  x93
14436:  MOVLB  0
14438:  CALL   D8BC
....................                sol_switch_cmd(8); 
1443C:  MOVLB  8
1443E:  CLRF   x94
14440:  MOVLW  08
14442:  MOVWF  x93
14444:  MOVLB  0
14446:  RCALL  14014
....................          break;  
14448:  MOVLB  8
1444A:  BRA    144BE
....................       case 29 : sol_chip_cmd(4); 
1444C:  MOVLW  04
1444E:  MOVLB  8
14450:  MOVWF  x93
14452:  MOVLB  0
14454:  CALL   D8BC
....................                sol_switch_cmd(16); 
14458:  MOVLB  8
1445A:  CLRF   x94
1445C:  MOVLW  10
1445E:  MOVWF  x93
14460:  MOVLB  0
14462:  RCALL  14014
....................          break;  
14464:  MOVLB  8
14466:  BRA    144BE
....................       case 30 : sol_chip_cmd(4); 
14468:  MOVLW  04
1446A:  MOVLB  8
1446C:  MOVWF  x93
1446E:  MOVLB  0
14470:  CALL   D8BC
....................                sol_switch_cmd(32); 
14474:  MOVLB  8
14476:  CLRF   x94
14478:  MOVLW  20
1447A:  MOVWF  x93
1447C:  MOVLB  0
1447E:  RCALL  14014
....................          break;  
14480:  MOVLB  8
14482:  BRA    144BE
....................       case 31 : sol_chip_cmd(4); 
14484:  MOVLW  04
14486:  MOVLB  8
14488:  MOVWF  x93
1448A:  MOVLB  0
1448C:  CALL   D8BC
....................                sol_switch_cmd(64); 
14490:  MOVLB  8
14492:  CLRF   x94
14494:  MOVLW  40
14496:  MOVWF  x93
14498:  MOVLB  0
1449A:  RCALL  14014
....................          break;  
1449C:  MOVLB  8
1449E:  BRA    144BE
....................       case 32 : sol_chip_cmd(4); 
144A0:  MOVLW  04
144A2:  MOVLB  8
144A4:  MOVWF  x93
144A6:  MOVLB  0
144A8:  CALL   D8BC
....................                sol_switch_cmd(128); 
144AC:  MOVLB  8
144AE:  CLRF   x94
144B0:  MOVLW  80
144B2:  MOVWF  x93
144B4:  MOVLB  0
144B6:  RCALL  14014
....................          break; 
144B8:  MOVLB  8
144BA:  BRA    144BE
144BC:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
144BE:  MOVF   x92,F
144C0:  BZ    144DA
144C2:  MOVF   x92,W
144C4:  SUBLW  20
144C6:  BNC   144DA
144C8:  CLRF   03
144CA:  MOVF   x92,W
144CC:  ADDLW  B3
144CE:  MOVWF  FE9
144D0:  MOVLW  04
144D2:  ADDWFC 03,W
144D4:  MOVWF  FEA
144D6:  MOVLW  01
144D8:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
144DA:  MOVF   1F,W
144DC:  SUBLW  04
144DE:  BNZ   144EC
144E0:  MOVF   20,F
144E2:  BNZ   144EC
144E4:  MOVLB  0
144E6:  CALL   EA68
144EA:  MOVLB  8
144EC:  MOVLB  0
144EE:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
10202:  MOVLB  8
10204:  CLRF   x7A
10206:  MOVF   x7A,W
10208:  SUBLW  07
1020A:  BNC   10226
1020C:  BCF    FD8.0
1020E:  RLCF   x7A,W
10210:  CLRF   03
10212:  ADDLW  47
10214:  MOVWF  FE9
10216:  MOVLW  03
10218:  ADDWFC 03,W
1021A:  MOVWF  FEA
1021C:  CLRF   FEC
1021E:  MOVF   FED,F
10220:  CLRF   FEF
10222:  INCF   x7A,F
10224:  BRA    10206
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
10226:  CLRF   x7A
10228:  MOVF   x7A,W
1022A:  SUBLW  07
1022C:  BNC   10248
1022E:  BCF    FD8.0
10230:  RLCF   x7A,W
10232:  CLRF   03
10234:  ADDLW  59
10236:  MOVWF  FE9
10238:  MOVLW  03
1023A:  ADDWFC 03,W
1023C:  MOVWF  FEA
1023E:  CLRF   FEC
10240:  MOVF   FED,F
10242:  CLRF   FEF
10244:  INCF   x7A,F
10246:  BRA    10228
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
10248:  CLRF   x7A
1024A:  MOVF   x7A,W
1024C:  SUBLW  07
1024E:  BNC   1026A
10250:  BCF    FD8.0
10252:  RLCF   x7A,W
10254:  CLRF   03
10256:  ADDLW  6B
10258:  MOVWF  FE9
1025A:  MOVLW  03
1025C:  ADDWFC 03,W
1025E:  MOVWF  FEA
10260:  CLRF   FEC
10262:  MOVF   FED,F
10264:  CLRF   FEF
10266:  INCF   x7A,F
10268:  BRA    1024A
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
1026A:  CLRF   x7A
1026C:  MOVF   x7A,W
1026E:  SUBLW  07
10270:  BNC   1028C
10272:  BCF    FD8.0
10274:  RLCF   x7A,W
10276:  CLRF   03
10278:  ADDLW  7D
1027A:  MOVWF  FE9
1027C:  MOVLW  03
1027E:  ADDWFC 03,W
10280:  MOVWF  FEA
10282:  CLRF   FEC
10284:  MOVF   FED,F
10286:  CLRF   FEF
10288:  INCF   x7A,F
1028A:  BRA    1026C
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
1028C:  CLRF   x7A
1028E:  MOVF   x7A,W
10290:  SUBLW  07
10292:  BNC   102AE
10294:  BCF    FD8.0
10296:  RLCF   x7A,W
10298:  CLRF   03
1029A:  ADDLW  8F
1029C:  MOVWF  FE9
1029E:  MOVLW  03
102A0:  ADDWFC 03,W
102A2:  MOVWF  FEA
102A4:  CLRF   FEC
102A6:  MOVF   FED,F
102A8:  CLRF   FEF
102AA:  INCF   x7A,F
102AC:  BRA    1028E
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
102AE:  MOVLW  04
102B0:  MOVWF  FEA
102B2:  MOVLW  21
102B4:  MOVWF  FE9
102B6:  CLRF   00
102B8:  CLRF   02
102BA:  MOVLW  44
102BC:  MOVWF  01
102BE:  MOVLB  0
102C0:  CALL   34AE
102C4:  GOTO   14F10 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10B38:  MOVLB  8
10B3A:  CLRF   x9F
10B3C:  MOVF   x9F,W
10B3E:  SUBLW  03
10B40:  BNC   10B60
10B42:  MOVF   x9F,W
10B44:  MULLW  04
10B46:  MOVF   FF3,W
10B48:  CLRF   03
10B4A:  ADDLW  A1
10B4C:  MOVWF  FE9
10B4E:  MOVLW  03
10B50:  ADDWFC 03,W
10B52:  MOVWF  FEA
10B54:  CLRF   FEF
10B56:  CLRF   FEC
10B58:  CLRF   FEC
10B5A:  CLRF   FEC
10B5C:  INCF   x9F,F
10B5E:  BRA    10B3C
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10B60:  MOVLB  3
10B62:  MOVF   x47,F
10B64:  BTFSS  FD8.2
10B66:  BRA    10B6C
10B68:  MOVF   x48,F
10B6A:  BZ    10C06
10B6C:  MOVF   x49,F
10B6E:  BNZ   10B74
10B70:  MOVF   x4A,F
10B72:  BZ    10C06
....................       blank = NO3_array[0]; 
10B74:  MOVFF  348,8F5
10B78:  MOVFF  347,8F4
10B7C:  MOVLB  0
10B7E:  CALL   C624
10B82:  MOVFF  03,8A3
10B86:  MOVFF  02,8A2
10B8A:  MOVFF  01,8A1
10B8E:  MOVFF  00,8A0
....................       react = NO3_array[1]; 
10B92:  MOVFF  34A,8F5
10B96:  MOVFF  349,8F4
10B9A:  CALL   C624
10B9E:  MOVFF  03,8A7
10BA2:  MOVFF  02,8A6
10BA6:  MOVFF  01,8A5
10BAA:  MOVFF  00,8A4
....................       ratio = blank / react; 
10BAE:  MOVFF  8A3,8DB
10BB2:  MOVFF  8A2,8DA
10BB6:  MOVFF  8A1,8D9
10BBA:  MOVFF  8A0,8D8
10BBE:  MOVFF  8A7,8DF
10BC2:  MOVFF  8A6,8DE
10BC6:  MOVFF  8A5,8DD
10BCA:  MOVFF  8A4,8DC
10BCE:  CALL   C65A
10BD2:  MOVFF  03,8AB
10BD6:  MOVFF  02,8AA
10BDA:  MOVFF  01,8A9
10BDE:  MOVFF  00,8A8
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10BE2:  MOVFF  8AB,8AF
10BE6:  MOVFF  8AA,8AE
10BEA:  MOVFF  8A9,8AD
10BEE:  MOVFF  8A8,8AC
10BF2:  RCALL  108BA
10BF4:  MOVFF  03,3A4
10BF8:  MOVFF  02,3A3
10BFC:  MOVFF  01,3A2
10C00:  MOVFF  00,3A1
10C04:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10C06:  MOVF   x4B,F
10C08:  BNZ   10C0E
10C0A:  MOVF   x4C,F
10C0C:  BZ    10CA8
10C0E:  MOVF   x4D,F
10C10:  BNZ   10C16
10C12:  MOVF   x4E,F
10C14:  BZ    10CA8
....................       blank = NO3_array[2]; 
10C16:  MOVFF  34C,8F5
10C1A:  MOVFF  34B,8F4
10C1E:  MOVLB  0
10C20:  CALL   C624
10C24:  MOVFF  03,8A3
10C28:  MOVFF  02,8A2
10C2C:  MOVFF  01,8A1
10C30:  MOVFF  00,8A0
....................       react = NO3_array[3]; 
10C34:  MOVFF  34E,8F5
10C38:  MOVFF  34D,8F4
10C3C:  CALL   C624
10C40:  MOVFF  03,8A7
10C44:  MOVFF  02,8A6
10C48:  MOVFF  01,8A5
10C4C:  MOVFF  00,8A4
....................       ratio = blank / react;    
10C50:  MOVFF  8A3,8DB
10C54:  MOVFF  8A2,8DA
10C58:  MOVFF  8A1,8D9
10C5C:  MOVFF  8A0,8D8
10C60:  MOVFF  8A7,8DF
10C64:  MOVFF  8A6,8DE
10C68:  MOVFF  8A5,8DD
10C6C:  MOVFF  8A4,8DC
10C70:  CALL   C65A
10C74:  MOVFF  03,8AB
10C78:  MOVFF  02,8AA
10C7C:  MOVFF  01,8A9
10C80:  MOVFF  00,8A8
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10C84:  MOVFF  8AB,8AF
10C88:  MOVFF  8AA,8AE
10C8C:  MOVFF  8A9,8AD
10C90:  MOVFF  8A8,8AC
10C94:  RCALL  108BA
10C96:  MOVFF  03,3A8
10C9A:  MOVFF  02,3A7
10C9E:  MOVFF  01,3A6
10CA2:  MOVFF  00,3A5
10CA6:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
10CA8:  MOVF   x4F,F
10CAA:  BNZ   10CB0
10CAC:  MOVF   x50,F
10CAE:  BZ    10D4A
10CB0:  MOVF   x51,F
10CB2:  BNZ   10CB8
10CB4:  MOVF   x52,F
10CB6:  BZ    10D4A
....................       blank = NO3_array[4]; 
10CB8:  MOVFF  350,8F5
10CBC:  MOVFF  34F,8F4
10CC0:  MOVLB  0
10CC2:  CALL   C624
10CC6:  MOVFF  03,8A3
10CCA:  MOVFF  02,8A2
10CCE:  MOVFF  01,8A1
10CD2:  MOVFF  00,8A0
....................       react = NO3_array[5]; 
10CD6:  MOVFF  352,8F5
10CDA:  MOVFF  351,8F4
10CDE:  CALL   C624
10CE2:  MOVFF  03,8A7
10CE6:  MOVFF  02,8A6
10CEA:  MOVFF  01,8A5
10CEE:  MOVFF  00,8A4
....................       ratio = blank / react; 
10CF2:  MOVFF  8A3,8DB
10CF6:  MOVFF  8A2,8DA
10CFA:  MOVFF  8A1,8D9
10CFE:  MOVFF  8A0,8D8
10D02:  MOVFF  8A7,8DF
10D06:  MOVFF  8A6,8DE
10D0A:  MOVFF  8A5,8DD
10D0E:  MOVFF  8A4,8DC
10D12:  CALL   C65A
10D16:  MOVFF  03,8AB
10D1A:  MOVFF  02,8AA
10D1E:  MOVFF  01,8A9
10D22:  MOVFF  00,8A8
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
10D26:  MOVFF  8AB,8AF
10D2A:  MOVFF  8AA,8AE
10D2E:  MOVFF  8A9,8AD
10D32:  MOVFF  8A8,8AC
10D36:  RCALL  108BA
10D38:  MOVFF  03,3AC
10D3C:  MOVFF  02,3AB
10D40:  MOVFF  01,3AA
10D44:  MOVFF  00,3A9
10D48:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
10D4A:  MOVF   x53,F
10D4C:  BNZ   10D52
10D4E:  MOVF   x54,F
10D50:  BZ    10DEC
10D52:  MOVF   x55,F
10D54:  BNZ   10D5A
10D56:  MOVF   x56,F
10D58:  BZ    10DEC
....................       blank = NO3_array[6]; 
10D5A:  MOVFF  354,8F5
10D5E:  MOVFF  353,8F4
10D62:  MOVLB  0
10D64:  CALL   C624
10D68:  MOVFF  03,8A3
10D6C:  MOVFF  02,8A2
10D70:  MOVFF  01,8A1
10D74:  MOVFF  00,8A0
....................       react = NO3_array[7]; 
10D78:  MOVFF  356,8F5
10D7C:  MOVFF  355,8F4
10D80:  CALL   C624
10D84:  MOVFF  03,8A7
10D88:  MOVFF  02,8A6
10D8C:  MOVFF  01,8A5
10D90:  MOVFF  00,8A4
....................       ratio = blank / react; 
10D94:  MOVFF  8A3,8DB
10D98:  MOVFF  8A2,8DA
10D9C:  MOVFF  8A1,8D9
10DA0:  MOVFF  8A0,8D8
10DA4:  MOVFF  8A7,8DF
10DA8:  MOVFF  8A6,8DE
10DAC:  MOVFF  8A5,8DD
10DB0:  MOVFF  8A4,8DC
10DB4:  CALL   C65A
10DB8:  MOVFF  03,8AB
10DBC:  MOVFF  02,8AA
10DC0:  MOVFF  01,8A9
10DC4:  MOVFF  00,8A8
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
10DC8:  MOVFF  8AB,8AF
10DCC:  MOVFF  8AA,8AE
10DD0:  MOVFF  8A9,8AD
10DD4:  MOVFF  8A8,8AC
10DD8:  RCALL  108BA
10DDA:  MOVFF  03,3B0
10DDE:  MOVFF  02,3AF
10DE2:  MOVFF  01,3AE
10DE6:  MOVFF  00,3AD
10DEA:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
10DEC:  MOVLW  04
10DEE:  MOVWF  1E
10DF0:  MOVLW  21
10DF2:  MOVWF  1D
10DF4:  MOVLW  92
10DF6:  MOVWF  FF6
10DF8:  MOVLW  1D
10DFA:  MOVWF  FF7
10DFC:  MOVLW  00
10DFE:  MOVWF  FF8
10E00:  MOVLW  06
10E02:  MOVLB  8
10E04:  MOVWF  xC8
10E06:  MOVLB  0
10E08:  CALL   AA04
10E0C:  MOVLW  10
10E0E:  MOVWF  FE9
10E10:  MOVFF  348,8D4
10E14:  MOVFF  347,8D3
10E18:  CALL   AA36
10E1C:  MOVLW  9B
10E1E:  MOVWF  FF6
10E20:  MOVLW  1D
10E22:  MOVWF  FF7
10E24:  MOVLW  00
10E26:  MOVWF  FF8
10E28:  MOVLW  07
10E2A:  MOVLB  8
10E2C:  MOVWF  xC8
10E2E:  MOVLB  0
10E30:  CALL   AA04
10E34:  MOVLW  10
10E36:  MOVWF  FE9
10E38:  MOVFF  34A,8D4
10E3C:  MOVFF  349,8D3
10E40:  CALL   AA36
10E44:  MOVLW  A5
10E46:  MOVWF  FF6
10E48:  MOVLW  1D
10E4A:  MOVWF  FF7
10E4C:  MOVLW  00
10E4E:  MOVWF  FF8
10E50:  MOVLW  09
10E52:  MOVLB  8
10E54:  MOVWF  xC8
10E56:  MOVLB  0
10E58:  CALL   AA04
10E5C:  MOVLW  89
10E5E:  MOVWF  FE9
10E60:  MOVFF  3A4,8AF
10E64:  MOVFF  3A3,8AE
10E68:  MOVFF  3A2,8AD
10E6C:  MOVFF  3A1,8AC
10E70:  MOVLW  04
10E72:  MOVLB  8
10E74:  MOVWF  xB0
10E76:  MOVLB  0
10E78:  RCALL  10926
10E7A:  MOVLW  B3
10E7C:  MOVWF  FF6
10E7E:  MOVLW  1D
10E80:  MOVWF  FF7
10E82:  MOVLW  00
10E84:  MOVWF  FF8
10E86:  MOVLW  07
10E88:  MOVLB  8
10E8A:  MOVWF  xC8
10E8C:  MOVLB  0
10E8E:  CALL   AA04
10E92:  MOVLW  10
10E94:  MOVWF  FE9
10E96:  MOVFF  34C,8D4
10E9A:  MOVFF  34B,8D3
10E9E:  CALL   AA36
10EA2:  MOVLW  BD
10EA4:  MOVWF  FF6
10EA6:  MOVLW  1D
10EA8:  MOVWF  FF7
10EAA:  MOVLW  00
10EAC:  MOVWF  FF8
10EAE:  MOVLW  07
10EB0:  MOVLB  8
10EB2:  MOVWF  xC8
10EB4:  MOVLB  0
10EB6:  CALL   AA04
10EBA:  MOVLW  10
10EBC:  MOVWF  FE9
10EBE:  MOVFF  34E,8D4
10EC2:  MOVFF  34D,8D3
10EC6:  CALL   AA36
10ECA:  MOVLW  C7
10ECC:  MOVWF  FF6
10ECE:  MOVLW  1D
10ED0:  MOVWF  FF7
10ED2:  MOVLW  00
10ED4:  MOVWF  FF8
10ED6:  MOVLW  09
10ED8:  MOVLB  8
10EDA:  MOVWF  xC8
10EDC:  MOVLB  0
10EDE:  CALL   AA04
10EE2:  MOVLW  89
10EE4:  MOVWF  FE9
10EE6:  MOVFF  3A8,8AF
10EEA:  MOVFF  3A7,8AE
10EEE:  MOVFF  3A6,8AD
10EF2:  MOVFF  3A5,8AC
10EF6:  MOVLW  04
10EF8:  MOVLB  8
10EFA:  MOVWF  xB0
10EFC:  MOVLB  0
10EFE:  RCALL  10926
10F00:  MOVLW  D5
10F02:  MOVWF  FF6
10F04:  MOVLW  1D
10F06:  MOVWF  FF7
10F08:  MOVLW  00
10F0A:  MOVWF  FF8
10F0C:  MOVLW  07
10F0E:  MOVLB  8
10F10:  MOVWF  xC8
10F12:  MOVLB  0
10F14:  CALL   AA04
10F18:  MOVLW  10
10F1A:  MOVWF  FE9
10F1C:  MOVFF  350,8D4
10F20:  MOVFF  34F,8D3
10F24:  CALL   AA36
10F28:  MOVLW  DF
10F2A:  MOVWF  FF6
10F2C:  MOVLW  1D
10F2E:  MOVWF  FF7
10F30:  MOVLW  00
10F32:  MOVWF  FF8
10F34:  MOVLW  07
10F36:  MOVLB  8
10F38:  MOVWF  xC8
10F3A:  MOVLB  0
10F3C:  CALL   AA04
10F40:  MOVLW  10
10F42:  MOVWF  FE9
10F44:  MOVFF  352,8D4
10F48:  MOVFF  351,8D3
10F4C:  CALL   AA36
10F50:  MOVLW  E9
10F52:  MOVWF  FF6
10F54:  MOVLW  1D
10F56:  MOVWF  FF7
10F58:  MOVLW  00
10F5A:  MOVWF  FF8
10F5C:  MOVLW  09
10F5E:  MOVLB  8
10F60:  MOVWF  xC8
10F62:  MOVLB  0
10F64:  CALL   AA04
10F68:  MOVLW  89
10F6A:  MOVWF  FE9
10F6C:  MOVFF  3AC,8AF
10F70:  MOVFF  3AB,8AE
10F74:  MOVFF  3AA,8AD
10F78:  MOVFF  3A9,8AC
10F7C:  MOVLW  04
10F7E:  MOVLB  8
10F80:  MOVWF  xB0
10F82:  MOVLB  0
10F84:  RCALL  10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
10F86:  MOVF   1F,W
10F88:  SUBLW  02
10F8A:  BNZ   10F90
10F8C:  MOVF   20,F
10F8E:  BZ    10FD0
10F90:  MOVLW  F8
10F92:  MOVWF  FF6
10F94:  MOVLW  1D
10F96:  MOVWF  FF7
10F98:  MOVLW  00
10F9A:  MOVWF  FF8
10F9C:  CLRF   1B
10F9E:  BTFSC  FF2.7
10FA0:  BSF    1B.7
10FA2:  BCF    FF2.7
10FA4:  MOVLW  09
10FA6:  MOVLB  A
10FA8:  MOVWF  x18
10FAA:  MOVLB  0
10FAC:  CALL   1010
10FB0:  BTFSC  1B.7
10FB2:  BSF    FF2.7
10FB4:  MOVLW  04
10FB6:  MOVWF  FEA
10FB8:  MOVLW  21
10FBA:  MOVWF  FE9
10FBC:  CALL   78DC
10FC0:  MOVLW  0D
10FC2:  BTFSS  F9E.4
10FC4:  BRA    10FC2
10FC6:  MOVWF  FAD
10FC8:  MOVLW  0A
10FCA:  BTFSS  F9E.4
10FCC:  BRA    10FCA
10FCE:  MOVWF  FAD
10FD0:  GOTO   122DC (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
10FD4:  MOVLB  8
10FD6:  CLRF   x9F
10FD8:  MOVF   x9F,W
10FDA:  SUBLW  03
10FDC:  BNC   10FFC
10FDE:  MOVF   x9F,W
10FE0:  MULLW  04
10FE2:  MOVF   FF3,W
10FE4:  CLRF   03
10FE6:  ADDLW  B1
10FE8:  MOVWF  FE9
10FEA:  MOVLW  03
10FEC:  ADDWFC 03,W
10FEE:  MOVWF  FEA
10FF0:  CLRF   FEF
10FF2:  CLRF   FEC
10FF4:  CLRF   FEC
10FF6:  CLRF   FEC
10FF8:  INCF   x9F,F
10FFA:  BRA    10FD8
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
10FFC:  MOVLB  3
10FFE:  MOVF   x59,F
11000:  BTFSS  FD8.2
11002:  BRA    11008
11004:  MOVF   x5A,F
11006:  BZ    110A2
11008:  MOVF   x5B,F
1100A:  BNZ   11010
1100C:  MOVF   x5C,F
1100E:  BZ    110A2
....................       blank = NO2_array[0]; 
11010:  MOVFF  35A,8F5
11014:  MOVFF  359,8F4
11018:  MOVLB  0
1101A:  CALL   C624
1101E:  MOVFF  03,8A3
11022:  MOVFF  02,8A2
11026:  MOVFF  01,8A1
1102A:  MOVFF  00,8A0
....................       react = NO2_array[1]; 
1102E:  MOVFF  35C,8F5
11032:  MOVFF  35B,8F4
11036:  CALL   C624
1103A:  MOVFF  03,8A7
1103E:  MOVFF  02,8A6
11042:  MOVFF  01,8A5
11046:  MOVFF  00,8A4
....................       ratio = blank / react; 
1104A:  MOVFF  8A3,8DB
1104E:  MOVFF  8A2,8DA
11052:  MOVFF  8A1,8D9
11056:  MOVFF  8A0,8D8
1105A:  MOVFF  8A7,8DF
1105E:  MOVFF  8A6,8DE
11062:  MOVFF  8A5,8DD
11066:  MOVFF  8A4,8DC
1106A:  CALL   C65A
1106E:  MOVFF  03,8AB
11072:  MOVFF  02,8AA
11076:  MOVFF  01,8A9
1107A:  MOVFF  00,8A8
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
1107E:  MOVFF  8AB,8AF
11082:  MOVFF  8AA,8AE
11086:  MOVFF  8A9,8AD
1108A:  MOVFF  8A8,8AC
1108E:  RCALL  108BA
11090:  MOVFF  03,3B4
11094:  MOVFF  02,3B3
11098:  MOVFF  01,3B2
1109C:  MOVFF  00,3B1
110A0:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
110A2:  MOVF   x5D,F
110A4:  BNZ   110AA
110A6:  MOVF   x5E,F
110A8:  BZ    11146
110AA:  MOVF   x5F,F
110AC:  BNZ   110B2
110AE:  MOVF   x60,F
110B0:  BZ    11146
....................       blank = NO2_array[2]; 
110B2:  MOVFF  35E,8F5
110B6:  MOVFF  35D,8F4
110BA:  MOVLB  0
110BC:  CALL   C624
110C0:  MOVFF  03,8A3
110C4:  MOVFF  02,8A2
110C8:  MOVFF  01,8A1
110CC:  MOVFF  00,8A0
....................       react = NO2_array[3]; 
110D0:  MOVFF  360,8F5
110D4:  MOVFF  35F,8F4
110D8:  CALL   C624
110DC:  MOVFF  03,8A7
110E0:  MOVFF  02,8A6
110E4:  MOVFF  01,8A5
110E8:  MOVFF  00,8A4
....................       ratio = blank / react;    
110EC:  MOVFF  8A3,8DB
110F0:  MOVFF  8A2,8DA
110F4:  MOVFF  8A1,8D9
110F8:  MOVFF  8A0,8D8
110FC:  MOVFF  8A7,8DF
11100:  MOVFF  8A6,8DE
11104:  MOVFF  8A5,8DD
11108:  MOVFF  8A4,8DC
1110C:  CALL   C65A
11110:  MOVFF  03,8AB
11114:  MOVFF  02,8AA
11118:  MOVFF  01,8A9
1111C:  MOVFF  00,8A8
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
11120:  MOVFF  8AB,8AF
11124:  MOVFF  8AA,8AE
11128:  MOVFF  8A9,8AD
1112C:  MOVFF  8A8,8AC
11130:  CALL   108BA
11134:  MOVFF  03,3B8
11138:  MOVFF  02,3B7
1113C:  MOVFF  01,3B6
11140:  MOVFF  00,3B5
11144:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
11146:  MOVF   x61,F
11148:  BNZ   1114E
1114A:  MOVF   x62,F
1114C:  BZ    111EA
1114E:  MOVF   x63,F
11150:  BNZ   11156
11152:  MOVF   x64,F
11154:  BZ    111EA
....................       blank = NO2_array[4]; 
11156:  MOVFF  362,8F5
1115A:  MOVFF  361,8F4
1115E:  MOVLB  0
11160:  CALL   C624
11164:  MOVFF  03,8A3
11168:  MOVFF  02,8A2
1116C:  MOVFF  01,8A1
11170:  MOVFF  00,8A0
....................       react = NO2_array[5]; 
11174:  MOVFF  364,8F5
11178:  MOVFF  363,8F4
1117C:  CALL   C624
11180:  MOVFF  03,8A7
11184:  MOVFF  02,8A6
11188:  MOVFF  01,8A5
1118C:  MOVFF  00,8A4
....................       ratio = blank / react; 
11190:  MOVFF  8A3,8DB
11194:  MOVFF  8A2,8DA
11198:  MOVFF  8A1,8D9
1119C:  MOVFF  8A0,8D8
111A0:  MOVFF  8A7,8DF
111A4:  MOVFF  8A6,8DE
111A8:  MOVFF  8A5,8DD
111AC:  MOVFF  8A4,8DC
111B0:  CALL   C65A
111B4:  MOVFF  03,8AB
111B8:  MOVFF  02,8AA
111BC:  MOVFF  01,8A9
111C0:  MOVFF  00,8A8
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
111C4:  MOVFF  8AB,8AF
111C8:  MOVFF  8AA,8AE
111CC:  MOVFF  8A9,8AD
111D0:  MOVFF  8A8,8AC
111D4:  CALL   108BA
111D8:  MOVFF  03,3BC
111DC:  MOVFF  02,3BB
111E0:  MOVFF  01,3BA
111E4:  MOVFF  00,3B9
111E8:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
111EA:  MOVF   x65,F
111EC:  BNZ   111F2
111EE:  MOVF   x66,F
111F0:  BZ    1128E
111F2:  MOVF   x67,F
111F4:  BNZ   111FA
111F6:  MOVF   x68,F
111F8:  BZ    1128E
....................       blank = NO2_array[6]; 
111FA:  MOVFF  366,8F5
111FE:  MOVFF  365,8F4
11202:  MOVLB  0
11204:  CALL   C624
11208:  MOVFF  03,8A3
1120C:  MOVFF  02,8A2
11210:  MOVFF  01,8A1
11214:  MOVFF  00,8A0
....................       react = NO2_array[7]; 
11218:  MOVFF  368,8F5
1121C:  MOVFF  367,8F4
11220:  CALL   C624
11224:  MOVFF  03,8A7
11228:  MOVFF  02,8A6
1122C:  MOVFF  01,8A5
11230:  MOVFF  00,8A4
....................       ratio = blank / react; 
11234:  MOVFF  8A3,8DB
11238:  MOVFF  8A2,8DA
1123C:  MOVFF  8A1,8D9
11240:  MOVFF  8A0,8D8
11244:  MOVFF  8A7,8DF
11248:  MOVFF  8A6,8DE
1124C:  MOVFF  8A5,8DD
11250:  MOVFF  8A4,8DC
11254:  CALL   C65A
11258:  MOVFF  03,8AB
1125C:  MOVFF  02,8AA
11260:  MOVFF  01,8A9
11264:  MOVFF  00,8A8
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
11268:  MOVFF  8AB,8AF
1126C:  MOVFF  8AA,8AE
11270:  MOVFF  8A9,8AD
11274:  MOVFF  8A8,8AC
11278:  CALL   108BA
1127C:  MOVFF  03,3C0
11280:  MOVFF  02,3BF
11284:  MOVFF  01,3BE
11288:  MOVFF  00,3BD
1128C:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
1128E:  MOVLW  04
11290:  MOVWF  1E
11292:  MOVLW  21
11294:  MOVWF  1D
11296:  MOVLW  06
11298:  MOVWF  FF6
1129A:  MOVLW  1E
1129C:  MOVWF  FF7
1129E:  MOVLW  00
112A0:  MOVWF  FF8
112A2:  MOVLW  06
112A4:  MOVLB  8
112A6:  MOVWF  xC8
112A8:  MOVLB  0
112AA:  CALL   AA04
112AE:  MOVLW  10
112B0:  MOVWF  FE9
112B2:  MOVFF  35A,8D4
112B6:  MOVFF  359,8D3
112BA:  CALL   AA36
112BE:  MOVLW  0F
112C0:  MOVWF  FF6
112C2:  MOVLW  1E
112C4:  MOVWF  FF7
112C6:  MOVLW  00
112C8:  MOVWF  FF8
112CA:  MOVLW  07
112CC:  MOVLB  8
112CE:  MOVWF  xC8
112D0:  MOVLB  0
112D2:  CALL   AA04
112D6:  MOVLW  10
112D8:  MOVWF  FE9
112DA:  MOVFF  35C,8D4
112DE:  MOVFF  35B,8D3
112E2:  CALL   AA36
112E6:  MOVLW  19
112E8:  MOVWF  FF6
112EA:  MOVLW  1E
112EC:  MOVWF  FF7
112EE:  MOVLW  00
112F0:  MOVWF  FF8
112F2:  MOVLW  09
112F4:  MOVLB  8
112F6:  MOVWF  xC8
112F8:  MOVLB  0
112FA:  CALL   AA04
112FE:  MOVLW  89
11300:  MOVWF  FE9
11302:  MOVFF  3B4,8AF
11306:  MOVFF  3B3,8AE
1130A:  MOVFF  3B2,8AD
1130E:  MOVFF  3B1,8AC
11312:  MOVLW  04
11314:  MOVLB  8
11316:  MOVWF  xB0
11318:  MOVLB  0
1131A:  CALL   10926
1131E:  MOVLW  27
11320:  MOVWF  FF6
11322:  MOVLW  1E
11324:  MOVWF  FF7
11326:  MOVLW  00
11328:  MOVWF  FF8
1132A:  MOVLW  07
1132C:  MOVLB  8
1132E:  MOVWF  xC8
11330:  MOVLB  0
11332:  CALL   AA04
11336:  MOVLW  10
11338:  MOVWF  FE9
1133A:  MOVFF  35E,8D4
1133E:  MOVFF  35D,8D3
11342:  CALL   AA36
11346:  MOVLW  31
11348:  MOVWF  FF6
1134A:  MOVLW  1E
1134C:  MOVWF  FF7
1134E:  MOVLW  00
11350:  MOVWF  FF8
11352:  MOVLW  07
11354:  MOVLB  8
11356:  MOVWF  xC8
11358:  MOVLB  0
1135A:  CALL   AA04
1135E:  MOVLW  10
11360:  MOVWF  FE9
11362:  MOVFF  360,8D4
11366:  MOVFF  35F,8D3
1136A:  CALL   AA36
1136E:  MOVLW  3B
11370:  MOVWF  FF6
11372:  MOVLW  1E
11374:  MOVWF  FF7
11376:  MOVLW  00
11378:  MOVWF  FF8
1137A:  MOVLW  09
1137C:  MOVLB  8
1137E:  MOVWF  xC8
11380:  MOVLB  0
11382:  CALL   AA04
11386:  MOVLW  89
11388:  MOVWF  FE9
1138A:  MOVFF  3B8,8AF
1138E:  MOVFF  3B7,8AE
11392:  MOVFF  3B6,8AD
11396:  MOVFF  3B5,8AC
1139A:  MOVLW  04
1139C:  MOVLB  8
1139E:  MOVWF  xB0
113A0:  MOVLB  0
113A2:  CALL   10926
113A6:  MOVLW  49
113A8:  MOVWF  FF6
113AA:  MOVLW  1E
113AC:  MOVWF  FF7
113AE:  MOVLW  00
113B0:  MOVWF  FF8
113B2:  MOVLW  07
113B4:  MOVLB  8
113B6:  MOVWF  xC8
113B8:  MOVLB  0
113BA:  CALL   AA04
113BE:  MOVLW  10
113C0:  MOVWF  FE9
113C2:  MOVFF  362,8D4
113C6:  MOVFF  361,8D3
113CA:  CALL   AA36
113CE:  MOVLW  53
113D0:  MOVWF  FF6
113D2:  MOVLW  1E
113D4:  MOVWF  FF7
113D6:  MOVLW  00
113D8:  MOVWF  FF8
113DA:  MOVLW  07
113DC:  MOVLB  8
113DE:  MOVWF  xC8
113E0:  MOVLB  0
113E2:  CALL   AA04
113E6:  MOVLW  10
113E8:  MOVWF  FE9
113EA:  MOVFF  364,8D4
113EE:  MOVFF  363,8D3
113F2:  CALL   AA36
113F6:  MOVLW  5D
113F8:  MOVWF  FF6
113FA:  MOVLW  1E
113FC:  MOVWF  FF7
113FE:  MOVLW  00
11400:  MOVWF  FF8
11402:  MOVLW  09
11404:  MOVLB  8
11406:  MOVWF  xC8
11408:  MOVLB  0
1140A:  CALL   AA04
1140E:  MOVLW  89
11410:  MOVWF  FE9
11412:  MOVFF  3BC,8AF
11416:  MOVFF  3BB,8AE
1141A:  MOVFF  3BA,8AD
1141E:  MOVFF  3B9,8AC
11422:  MOVLW  04
11424:  MOVLB  8
11426:  MOVWF  xB0
11428:  MOVLB  0
1142A:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
1142E:  MOVF   1F,W
11430:  SUBLW  02
11432:  BNZ   11438
11434:  MOVF   20,F
11436:  BZ    11478
11438:  MOVLW  6C
1143A:  MOVWF  FF6
1143C:  MOVLW  1E
1143E:  MOVWF  FF7
11440:  MOVLW  00
11442:  MOVWF  FF8
11444:  CLRF   1B
11446:  BTFSC  FF2.7
11448:  BSF    1B.7
1144A:  BCF    FF2.7
1144C:  MOVLW  09
1144E:  MOVLB  A
11450:  MOVWF  x18
11452:  MOVLB  0
11454:  CALL   1010
11458:  BTFSC  1B.7
1145A:  BSF    FF2.7
1145C:  MOVLW  04
1145E:  MOVWF  FEA
11460:  MOVLW  21
11462:  MOVWF  FE9
11464:  CALL   78DC
11468:  MOVLW  0D
1146A:  BTFSS  F9E.4
1146C:  BRA    1146A
1146E:  MOVWF  FAD
11470:  MOVLW  0A
11472:  BTFSS  F9E.4
11474:  BRA    11472
11476:  MOVWF  FAD
11478:  GOTO   122DC (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
1147C:  MOVLB  8
1147E:  CLRF   x9F
11480:  MOVF   x9F,W
11482:  SUBLW  03
11484:  BNC   114A4
11486:  MOVF   x9F,W
11488:  MULLW  04
1148A:  MOVF   FF3,W
1148C:  CLRF   03
1148E:  ADDLW  C1
11490:  MOVWF  FE9
11492:  MOVLW  03
11494:  ADDWFC 03,W
11496:  MOVWF  FEA
11498:  CLRF   FEF
1149A:  CLRF   FEC
1149C:  CLRF   FEC
1149E:  CLRF   FEC
114A0:  INCF   x9F,F
114A2:  BRA    11480
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
114A4:  MOVLB  3
114A6:  MOVF   x6B,F
114A8:  BTFSS  FD8.2
114AA:  BRA    114B0
114AC:  MOVF   x6C,F
114AE:  BZ    1154C
114B0:  MOVF   x6D,F
114B2:  BNZ   114B8
114B4:  MOVF   x6E,F
114B6:  BZ    1154C
....................       blank = PO4_array[0]; 
114B8:  MOVFF  36C,8F5
114BC:  MOVFF  36B,8F4
114C0:  MOVLB  0
114C2:  CALL   C624
114C6:  MOVFF  03,8A3
114CA:  MOVFF  02,8A2
114CE:  MOVFF  01,8A1
114D2:  MOVFF  00,8A0
....................       react = PO4_array[1]; 
114D6:  MOVFF  36E,8F5
114DA:  MOVFF  36D,8F4
114DE:  CALL   C624
114E2:  MOVFF  03,8A7
114E6:  MOVFF  02,8A6
114EA:  MOVFF  01,8A5
114EE:  MOVFF  00,8A4
....................       ratio = blank / react; 
114F2:  MOVFF  8A3,8DB
114F6:  MOVFF  8A2,8DA
114FA:  MOVFF  8A1,8D9
114FE:  MOVFF  8A0,8D8
11502:  MOVFF  8A7,8DF
11506:  MOVFF  8A6,8DE
1150A:  MOVFF  8A5,8DD
1150E:  MOVFF  8A4,8DC
11512:  CALL   C65A
11516:  MOVFF  03,8AB
1151A:  MOVFF  02,8AA
1151E:  MOVFF  01,8A9
11522:  MOVFF  00,8A8
....................       PO4_abs_array[0] = log10(ratio); 
11526:  MOVFF  8AB,8AF
1152A:  MOVFF  8AA,8AE
1152E:  MOVFF  8A9,8AD
11532:  MOVFF  8A8,8AC
11536:  CALL   108BA
1153A:  MOVFF  03,3C4
1153E:  MOVFF  02,3C3
11542:  MOVFF  01,3C2
11546:  MOVFF  00,3C1
1154A:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
1154C:  MOVF   x6F,F
1154E:  BNZ   11554
11550:  MOVF   x70,F
11552:  BZ    115F0
11554:  MOVF   x71,F
11556:  BNZ   1155C
11558:  MOVF   x72,F
1155A:  BZ    115F0
....................       blank = PO4_array[2]; 
1155C:  MOVFF  370,8F5
11560:  MOVFF  36F,8F4
11564:  MOVLB  0
11566:  CALL   C624
1156A:  MOVFF  03,8A3
1156E:  MOVFF  02,8A2
11572:  MOVFF  01,8A1
11576:  MOVFF  00,8A0
....................       react = PO4_array[3]; 
1157A:  MOVFF  372,8F5
1157E:  MOVFF  371,8F4
11582:  CALL   C624
11586:  MOVFF  03,8A7
1158A:  MOVFF  02,8A6
1158E:  MOVFF  01,8A5
11592:  MOVFF  00,8A4
....................       ratio = blank / react;    
11596:  MOVFF  8A3,8DB
1159A:  MOVFF  8A2,8DA
1159E:  MOVFF  8A1,8D9
115A2:  MOVFF  8A0,8D8
115A6:  MOVFF  8A7,8DF
115AA:  MOVFF  8A6,8DE
115AE:  MOVFF  8A5,8DD
115B2:  MOVFF  8A4,8DC
115B6:  CALL   C65A
115BA:  MOVFF  03,8AB
115BE:  MOVFF  02,8AA
115C2:  MOVFF  01,8A9
115C6:  MOVFF  00,8A8
....................       PO4_abs_array[1] = log10(ratio); 
115CA:  MOVFF  8AB,8AF
115CE:  MOVFF  8AA,8AE
115D2:  MOVFF  8A9,8AD
115D6:  MOVFF  8A8,8AC
115DA:  CALL   108BA
115DE:  MOVFF  03,3C8
115E2:  MOVFF  02,3C7
115E6:  MOVFF  01,3C6
115EA:  MOVFF  00,3C5
115EE:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
115F0:  MOVF   x73,F
115F2:  BNZ   115F8
115F4:  MOVF   x74,F
115F6:  BZ    11694
115F8:  MOVF   x75,F
115FA:  BNZ   11600
115FC:  MOVF   x76,F
115FE:  BZ    11694
....................       blank = PO4_array[4]; 
11600:  MOVFF  374,8F5
11604:  MOVFF  373,8F4
11608:  MOVLB  0
1160A:  CALL   C624
1160E:  MOVFF  03,8A3
11612:  MOVFF  02,8A2
11616:  MOVFF  01,8A1
1161A:  MOVFF  00,8A0
....................       react = PO4_array[5]; 
1161E:  MOVFF  376,8F5
11622:  MOVFF  375,8F4
11626:  CALL   C624
1162A:  MOVFF  03,8A7
1162E:  MOVFF  02,8A6
11632:  MOVFF  01,8A5
11636:  MOVFF  00,8A4
....................       ratio = blank / react; 
1163A:  MOVFF  8A3,8DB
1163E:  MOVFF  8A2,8DA
11642:  MOVFF  8A1,8D9
11646:  MOVFF  8A0,8D8
1164A:  MOVFF  8A7,8DF
1164E:  MOVFF  8A6,8DE
11652:  MOVFF  8A5,8DD
11656:  MOVFF  8A4,8DC
1165A:  CALL   C65A
1165E:  MOVFF  03,8AB
11662:  MOVFF  02,8AA
11666:  MOVFF  01,8A9
1166A:  MOVFF  00,8A8
....................       PO4_abs_array[2] = log10(ratio); 
1166E:  MOVFF  8AB,8AF
11672:  MOVFF  8AA,8AE
11676:  MOVFF  8A9,8AD
1167A:  MOVFF  8A8,8AC
1167E:  CALL   108BA
11682:  MOVFF  03,3CC
11686:  MOVFF  02,3CB
1168A:  MOVFF  01,3CA
1168E:  MOVFF  00,3C9
11692:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
11694:  MOVF   x77,F
11696:  BNZ   1169C
11698:  MOVF   x78,F
1169A:  BZ    11738
1169C:  MOVF   x79,F
1169E:  BNZ   116A4
116A0:  MOVF   x7A,F
116A2:  BZ    11738
....................       blank = PO4_array[6]; 
116A4:  MOVFF  378,8F5
116A8:  MOVFF  377,8F4
116AC:  MOVLB  0
116AE:  CALL   C624
116B2:  MOVFF  03,8A3
116B6:  MOVFF  02,8A2
116BA:  MOVFF  01,8A1
116BE:  MOVFF  00,8A0
....................       react = PO4_array[7]; 
116C2:  MOVFF  37A,8F5
116C6:  MOVFF  379,8F4
116CA:  CALL   C624
116CE:  MOVFF  03,8A7
116D2:  MOVFF  02,8A6
116D6:  MOVFF  01,8A5
116DA:  MOVFF  00,8A4
....................       ratio = blank / react; 
116DE:  MOVFF  8A3,8DB
116E2:  MOVFF  8A2,8DA
116E6:  MOVFF  8A1,8D9
116EA:  MOVFF  8A0,8D8
116EE:  MOVFF  8A7,8DF
116F2:  MOVFF  8A6,8DE
116F6:  MOVFF  8A5,8DD
116FA:  MOVFF  8A4,8DC
116FE:  CALL   C65A
11702:  MOVFF  03,8AB
11706:  MOVFF  02,8AA
1170A:  MOVFF  01,8A9
1170E:  MOVFF  00,8A8
....................       PO4_abs_array[3] = log10(ratio); 
11712:  MOVFF  8AB,8AF
11716:  MOVFF  8AA,8AE
1171A:  MOVFF  8A9,8AD
1171E:  MOVFF  8A8,8AC
11722:  CALL   108BA
11726:  MOVFF  03,3D0
1172A:  MOVFF  02,3CF
1172E:  MOVFF  01,3CE
11732:  MOVFF  00,3CD
11736:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
11738:  MOVLW  04
1173A:  MOVWF  1E
1173C:  MOVLW  21
1173E:  MOVWF  1D
11740:  MOVLW  7A
11742:  MOVWF  FF6
11744:  MOVLW  1E
11746:  MOVWF  FF7
11748:  MOVLW  00
1174A:  MOVWF  FF8
1174C:  MOVLW  06
1174E:  MOVLB  8
11750:  MOVWF  xC8
11752:  MOVLB  0
11754:  CALL   AA04
11758:  MOVLW  10
1175A:  MOVWF  FE9
1175C:  MOVFF  36C,8D4
11760:  MOVFF  36B,8D3
11764:  CALL   AA36
11768:  MOVLW  83
1176A:  MOVWF  FF6
1176C:  MOVLW  1E
1176E:  MOVWF  FF7
11770:  MOVLW  00
11772:  MOVWF  FF8
11774:  MOVLW  07
11776:  MOVLB  8
11778:  MOVWF  xC8
1177A:  MOVLB  0
1177C:  CALL   AA04
11780:  MOVLW  10
11782:  MOVWF  FE9
11784:  MOVFF  36E,8D4
11788:  MOVFF  36D,8D3
1178C:  CALL   AA36
11790:  MOVLW  8D
11792:  MOVWF  FF6
11794:  MOVLW  1E
11796:  MOVWF  FF7
11798:  MOVLW  00
1179A:  MOVWF  FF8
1179C:  MOVLW  09
1179E:  MOVLB  8
117A0:  MOVWF  xC8
117A2:  MOVLB  0
117A4:  CALL   AA04
117A8:  MOVLW  89
117AA:  MOVWF  FE9
117AC:  MOVFF  3C4,8AF
117B0:  MOVFF  3C3,8AE
117B4:  MOVFF  3C2,8AD
117B8:  MOVFF  3C1,8AC
117BC:  MOVLW  04
117BE:  MOVLB  8
117C0:  MOVWF  xB0
117C2:  MOVLB  0
117C4:  CALL   10926
117C8:  MOVLW  9B
117CA:  MOVWF  FF6
117CC:  MOVLW  1E
117CE:  MOVWF  FF7
117D0:  MOVLW  00
117D2:  MOVWF  FF8
117D4:  MOVLW  07
117D6:  MOVLB  8
117D8:  MOVWF  xC8
117DA:  MOVLB  0
117DC:  CALL   AA04
117E0:  MOVLW  10
117E2:  MOVWF  FE9
117E4:  MOVFF  370,8D4
117E8:  MOVFF  36F,8D3
117EC:  CALL   AA36
117F0:  MOVLW  A5
117F2:  MOVWF  FF6
117F4:  MOVLW  1E
117F6:  MOVWF  FF7
117F8:  MOVLW  00
117FA:  MOVWF  FF8
117FC:  MOVLW  07
117FE:  MOVLB  8
11800:  MOVWF  xC8
11802:  MOVLB  0
11804:  CALL   AA04
11808:  MOVLW  10
1180A:  MOVWF  FE9
1180C:  MOVFF  372,8D4
11810:  MOVFF  371,8D3
11814:  CALL   AA36
11818:  MOVLW  AF
1181A:  MOVWF  FF6
1181C:  MOVLW  1E
1181E:  MOVWF  FF7
11820:  MOVLW  00
11822:  MOVWF  FF8
11824:  MOVLW  09
11826:  MOVLB  8
11828:  MOVWF  xC8
1182A:  MOVLB  0
1182C:  CALL   AA04
11830:  MOVLW  89
11832:  MOVWF  FE9
11834:  MOVFF  3C8,8AF
11838:  MOVFF  3C7,8AE
1183C:  MOVFF  3C6,8AD
11840:  MOVFF  3C5,8AC
11844:  MOVLW  04
11846:  MOVLB  8
11848:  MOVWF  xB0
1184A:  MOVLB  0
1184C:  CALL   10926
11850:  MOVLW  BD
11852:  MOVWF  FF6
11854:  MOVLW  1E
11856:  MOVWF  FF7
11858:  MOVLW  00
1185A:  MOVWF  FF8
1185C:  MOVLW  07
1185E:  MOVLB  8
11860:  MOVWF  xC8
11862:  MOVLB  0
11864:  CALL   AA04
11868:  MOVLW  10
1186A:  MOVWF  FE9
1186C:  MOVFF  374,8D4
11870:  MOVFF  373,8D3
11874:  CALL   AA36
11878:  MOVLW  C7
1187A:  MOVWF  FF6
1187C:  MOVLW  1E
1187E:  MOVWF  FF7
11880:  MOVLW  00
11882:  MOVWF  FF8
11884:  MOVLW  07
11886:  MOVLB  8
11888:  MOVWF  xC8
1188A:  MOVLB  0
1188C:  CALL   AA04
11890:  MOVLW  10
11892:  MOVWF  FE9
11894:  MOVFF  376,8D4
11898:  MOVFF  375,8D3
1189C:  CALL   AA36
118A0:  MOVLW  D1
118A2:  MOVWF  FF6
118A4:  MOVLW  1E
118A6:  MOVWF  FF7
118A8:  MOVLW  00
118AA:  MOVWF  FF8
118AC:  MOVLW  09
118AE:  MOVLB  8
118B0:  MOVWF  xC8
118B2:  MOVLB  0
118B4:  CALL   AA04
118B8:  MOVLW  89
118BA:  MOVWF  FE9
118BC:  MOVFF  3CC,8AF
118C0:  MOVFF  3CB,8AE
118C4:  MOVFF  3CA,8AD
118C8:  MOVFF  3C9,8AC
118CC:  MOVLW  04
118CE:  MOVLB  8
118D0:  MOVWF  xB0
118D2:  MOVLB  0
118D4:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
118D8:  MOVF   1F,W
118DA:  SUBLW  02
118DC:  BNZ   118E2
118DE:  MOVF   20,F
118E0:  BZ    11922
118E2:  MOVLW  E0
118E4:  MOVWF  FF6
118E6:  MOVLW  1E
118E8:  MOVWF  FF7
118EA:  MOVLW  00
118EC:  MOVWF  FF8
118EE:  CLRF   1B
118F0:  BTFSC  FF2.7
118F2:  BSF    1B.7
118F4:  BCF    FF2.7
118F6:  MOVLW  09
118F8:  MOVLB  A
118FA:  MOVWF  x18
118FC:  MOVLB  0
118FE:  CALL   1010
11902:  BTFSC  1B.7
11904:  BSF    FF2.7
11906:  MOVLW  04
11908:  MOVWF  FEA
1190A:  MOVLW  21
1190C:  MOVWF  FE9
1190E:  CALL   78DC
11912:  MOVLW  0D
11914:  BTFSS  F9E.4
11916:  BRA    11914
11918:  MOVWF  FAD
1191A:  MOVLW  0A
1191C:  BTFSS  F9E.4
1191E:  BRA    1191C
11920:  MOVWF  FAD
11922:  GOTO   122DC (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
11926:  MOVLB  8
11928:  CLRF   x9F
1192A:  MOVF   x9F,W
1192C:  SUBLW  03
1192E:  BNC   1194E
11930:  MOVF   x9F,W
11932:  MULLW  04
11934:  MOVF   FF3,W
11936:  CLRF   03
11938:  ADDLW  D1
1193A:  MOVWF  FE9
1193C:  MOVLW  03
1193E:  ADDWFC 03,W
11940:  MOVWF  FEA
11942:  CLRF   FEF
11944:  CLRF   FEC
11946:  CLRF   FEC
11948:  CLRF   FEC
1194A:  INCF   x9F,F
1194C:  BRA    1192A
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
1194E:  MOVLB  3
11950:  MOVF   x7D,F
11952:  BTFSS  FD8.2
11954:  BRA    1195A
11956:  MOVF   x7E,F
11958:  BZ    119F6
1195A:  MOVF   x7F,F
1195C:  BNZ   11962
1195E:  MOVF   x80,F
11960:  BZ    119F6
....................       blank = NH4_array[0]; 
11962:  MOVFF  37E,8F5
11966:  MOVFF  37D,8F4
1196A:  MOVLB  0
1196C:  CALL   C624
11970:  MOVFF  03,8A3
11974:  MOVFF  02,8A2
11978:  MOVFF  01,8A1
1197C:  MOVFF  00,8A0
....................       react = NH4_array[1]; 
11980:  MOVFF  380,8F5
11984:  MOVFF  37F,8F4
11988:  CALL   C624
1198C:  MOVFF  03,8A7
11990:  MOVFF  02,8A6
11994:  MOVFF  01,8A5
11998:  MOVFF  00,8A4
....................       ratio = blank / react; 
1199C:  MOVFF  8A3,8DB
119A0:  MOVFF  8A2,8DA
119A4:  MOVFF  8A1,8D9
119A8:  MOVFF  8A0,8D8
119AC:  MOVFF  8A7,8DF
119B0:  MOVFF  8A6,8DE
119B4:  MOVFF  8A5,8DD
119B8:  MOVFF  8A4,8DC
119BC:  CALL   C65A
119C0:  MOVFF  03,8AB
119C4:  MOVFF  02,8AA
119C8:  MOVFF  01,8A9
119CC:  MOVFF  00,8A8
....................       NH4_abs_array[0] = log10(ratio); 
119D0:  MOVFF  8AB,8AF
119D4:  MOVFF  8AA,8AE
119D8:  MOVFF  8A9,8AD
119DC:  MOVFF  8A8,8AC
119E0:  CALL   108BA
119E4:  MOVFF  03,3D4
119E8:  MOVFF  02,3D3
119EC:  MOVFF  01,3D2
119F0:  MOVFF  00,3D1
119F4:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
119F6:  MOVF   x81,F
119F8:  BNZ   119FE
119FA:  MOVF   x82,F
119FC:  BZ    11A9A
119FE:  MOVF   x83,F
11A00:  BNZ   11A06
11A02:  MOVF   x84,F
11A04:  BZ    11A9A
....................       blank = NH4_array[2]; 
11A06:  MOVFF  382,8F5
11A0A:  MOVFF  381,8F4
11A0E:  MOVLB  0
11A10:  CALL   C624
11A14:  MOVFF  03,8A3
11A18:  MOVFF  02,8A2
11A1C:  MOVFF  01,8A1
11A20:  MOVFF  00,8A0
....................       react = NH4_array[3]; 
11A24:  MOVFF  384,8F5
11A28:  MOVFF  383,8F4
11A2C:  CALL   C624
11A30:  MOVFF  03,8A7
11A34:  MOVFF  02,8A6
11A38:  MOVFF  01,8A5
11A3C:  MOVFF  00,8A4
....................       ratio = blank / react;    
11A40:  MOVFF  8A3,8DB
11A44:  MOVFF  8A2,8DA
11A48:  MOVFF  8A1,8D9
11A4C:  MOVFF  8A0,8D8
11A50:  MOVFF  8A7,8DF
11A54:  MOVFF  8A6,8DE
11A58:  MOVFF  8A5,8DD
11A5C:  MOVFF  8A4,8DC
11A60:  CALL   C65A
11A64:  MOVFF  03,8AB
11A68:  MOVFF  02,8AA
11A6C:  MOVFF  01,8A9
11A70:  MOVFF  00,8A8
....................       NH4_abs_array[1] = log10(ratio); 
11A74:  MOVFF  8AB,8AF
11A78:  MOVFF  8AA,8AE
11A7C:  MOVFF  8A9,8AD
11A80:  MOVFF  8A8,8AC
11A84:  CALL   108BA
11A88:  MOVFF  03,3D8
11A8C:  MOVFF  02,3D7
11A90:  MOVFF  01,3D6
11A94:  MOVFF  00,3D5
11A98:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
11A9A:  MOVF   x85,F
11A9C:  BNZ   11AA2
11A9E:  MOVF   x86,F
11AA0:  BZ    11B3E
11AA2:  MOVF   x87,F
11AA4:  BNZ   11AAA
11AA6:  MOVF   x88,F
11AA8:  BZ    11B3E
....................       blank = NH4_array[4]; 
11AAA:  MOVFF  386,8F5
11AAE:  MOVFF  385,8F4
11AB2:  MOVLB  0
11AB4:  CALL   C624
11AB8:  MOVFF  03,8A3
11ABC:  MOVFF  02,8A2
11AC0:  MOVFF  01,8A1
11AC4:  MOVFF  00,8A0
....................       react = NH4_array[5]; 
11AC8:  MOVFF  388,8F5
11ACC:  MOVFF  387,8F4
11AD0:  CALL   C624
11AD4:  MOVFF  03,8A7
11AD8:  MOVFF  02,8A6
11ADC:  MOVFF  01,8A5
11AE0:  MOVFF  00,8A4
....................       ratio = blank / react; 
11AE4:  MOVFF  8A3,8DB
11AE8:  MOVFF  8A2,8DA
11AEC:  MOVFF  8A1,8D9
11AF0:  MOVFF  8A0,8D8
11AF4:  MOVFF  8A7,8DF
11AF8:  MOVFF  8A6,8DE
11AFC:  MOVFF  8A5,8DD
11B00:  MOVFF  8A4,8DC
11B04:  CALL   C65A
11B08:  MOVFF  03,8AB
11B0C:  MOVFF  02,8AA
11B10:  MOVFF  01,8A9
11B14:  MOVFF  00,8A8
....................       NH4_abs_array[2] = log10(ratio); 
11B18:  MOVFF  8AB,8AF
11B1C:  MOVFF  8AA,8AE
11B20:  MOVFF  8A9,8AD
11B24:  MOVFF  8A8,8AC
11B28:  CALL   108BA
11B2C:  MOVFF  03,3DC
11B30:  MOVFF  02,3DB
11B34:  MOVFF  01,3DA
11B38:  MOVFF  00,3D9
11B3C:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11B3E:  MOVF   x89,F
11B40:  BNZ   11B46
11B42:  MOVF   x8A,F
11B44:  BZ    11BE2
11B46:  MOVF   x8B,F
11B48:  BNZ   11B4E
11B4A:  MOVF   x8C,F
11B4C:  BZ    11BE2
....................       blank = NH4_array[6]; 
11B4E:  MOVFF  38A,8F5
11B52:  MOVFF  389,8F4
11B56:  MOVLB  0
11B58:  CALL   C624
11B5C:  MOVFF  03,8A3
11B60:  MOVFF  02,8A2
11B64:  MOVFF  01,8A1
11B68:  MOVFF  00,8A0
....................       react = NH4_array[7]; 
11B6C:  MOVFF  38C,8F5
11B70:  MOVFF  38B,8F4
11B74:  CALL   C624
11B78:  MOVFF  03,8A7
11B7C:  MOVFF  02,8A6
11B80:  MOVFF  01,8A5
11B84:  MOVFF  00,8A4
....................       ratio = blank / react; 
11B88:  MOVFF  8A3,8DB
11B8C:  MOVFF  8A2,8DA
11B90:  MOVFF  8A1,8D9
11B94:  MOVFF  8A0,8D8
11B98:  MOVFF  8A7,8DF
11B9C:  MOVFF  8A6,8DE
11BA0:  MOVFF  8A5,8DD
11BA4:  MOVFF  8A4,8DC
11BA8:  CALL   C65A
11BAC:  MOVFF  03,8AB
11BB0:  MOVFF  02,8AA
11BB4:  MOVFF  01,8A9
11BB8:  MOVFF  00,8A8
....................       NH4_abs_array[3] = log10(ratio); 
11BBC:  MOVFF  8AB,8AF
11BC0:  MOVFF  8AA,8AE
11BC4:  MOVFF  8A9,8AD
11BC8:  MOVFF  8A8,8AC
11BCC:  CALL   108BA
11BD0:  MOVFF  03,3E0
11BD4:  MOVFF  02,3DF
11BD8:  MOVFF  01,3DE
11BDC:  MOVFF  00,3DD
11BE0:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11BE2:  MOVLW  04
11BE4:  MOVWF  1E
11BE6:  MOVLW  21
11BE8:  MOVWF  1D
11BEA:  MOVLW  EE
11BEC:  MOVWF  FF6
11BEE:  MOVLW  1E
11BF0:  MOVWF  FF7
11BF2:  MOVLW  00
11BF4:  MOVWF  FF8
11BF6:  MOVLW  06
11BF8:  MOVLB  8
11BFA:  MOVWF  xC8
11BFC:  MOVLB  0
11BFE:  CALL   AA04
11C02:  MOVLW  10
11C04:  MOVWF  FE9
11C06:  MOVFF  37E,8D4
11C0A:  MOVFF  37D,8D3
11C0E:  CALL   AA36
11C12:  MOVLW  F7
11C14:  MOVWF  FF6
11C16:  MOVLW  1E
11C18:  MOVWF  FF7
11C1A:  MOVLW  00
11C1C:  MOVWF  FF8
11C1E:  MOVLW  07
11C20:  MOVLB  8
11C22:  MOVWF  xC8
11C24:  MOVLB  0
11C26:  CALL   AA04
11C2A:  MOVLW  10
11C2C:  MOVWF  FE9
11C2E:  MOVFF  380,8D4
11C32:  MOVFF  37F,8D3
11C36:  CALL   AA36
11C3A:  MOVLW  01
11C3C:  MOVWF  FF6
11C3E:  MOVLW  1F
11C40:  MOVWF  FF7
11C42:  MOVLW  00
11C44:  MOVWF  FF8
11C46:  MOVLW  09
11C48:  MOVLB  8
11C4A:  MOVWF  xC8
11C4C:  MOVLB  0
11C4E:  CALL   AA04
11C52:  MOVLW  89
11C54:  MOVWF  FE9
11C56:  MOVFF  3D4,8AF
11C5A:  MOVFF  3D3,8AE
11C5E:  MOVFF  3D2,8AD
11C62:  MOVFF  3D1,8AC
11C66:  MOVLW  04
11C68:  MOVLB  8
11C6A:  MOVWF  xB0
11C6C:  MOVLB  0
11C6E:  CALL   10926
11C72:  MOVLW  0F
11C74:  MOVWF  FF6
11C76:  MOVLW  1F
11C78:  MOVWF  FF7
11C7A:  MOVLW  00
11C7C:  MOVWF  FF8
11C7E:  MOVLW  07
11C80:  MOVLB  8
11C82:  MOVWF  xC8
11C84:  MOVLB  0
11C86:  CALL   AA04
11C8A:  MOVLW  10
11C8C:  MOVWF  FE9
11C8E:  MOVFF  382,8D4
11C92:  MOVFF  381,8D3
11C96:  CALL   AA36
11C9A:  MOVLW  19
11C9C:  MOVWF  FF6
11C9E:  MOVLW  1F
11CA0:  MOVWF  FF7
11CA2:  MOVLW  00
11CA4:  MOVWF  FF8
11CA6:  MOVLW  07
11CA8:  MOVLB  8
11CAA:  MOVWF  xC8
11CAC:  MOVLB  0
11CAE:  CALL   AA04
11CB2:  MOVLW  10
11CB4:  MOVWF  FE9
11CB6:  MOVFF  384,8D4
11CBA:  MOVFF  383,8D3
11CBE:  CALL   AA36
11CC2:  MOVLW  23
11CC4:  MOVWF  FF6
11CC6:  MOVLW  1F
11CC8:  MOVWF  FF7
11CCA:  MOVLW  00
11CCC:  MOVWF  FF8
11CCE:  MOVLW  09
11CD0:  MOVLB  8
11CD2:  MOVWF  xC8
11CD4:  MOVLB  0
11CD6:  CALL   AA04
11CDA:  MOVLW  89
11CDC:  MOVWF  FE9
11CDE:  MOVFF  3D8,8AF
11CE2:  MOVFF  3D7,8AE
11CE6:  MOVFF  3D6,8AD
11CEA:  MOVFF  3D5,8AC
11CEE:  MOVLW  04
11CF0:  MOVLB  8
11CF2:  MOVWF  xB0
11CF4:  MOVLB  0
11CF6:  CALL   10926
11CFA:  MOVLW  31
11CFC:  MOVWF  FF6
11CFE:  MOVLW  1F
11D00:  MOVWF  FF7
11D02:  MOVLW  00
11D04:  MOVWF  FF8
11D06:  MOVLW  07
11D08:  MOVLB  8
11D0A:  MOVWF  xC8
11D0C:  MOVLB  0
11D0E:  CALL   AA04
11D12:  MOVLW  10
11D14:  MOVWF  FE9
11D16:  MOVFF  386,8D4
11D1A:  MOVFF  385,8D3
11D1E:  CALL   AA36
11D22:  MOVLW  3B
11D24:  MOVWF  FF6
11D26:  MOVLW  1F
11D28:  MOVWF  FF7
11D2A:  MOVLW  00
11D2C:  MOVWF  FF8
11D2E:  MOVLW  07
11D30:  MOVLB  8
11D32:  MOVWF  xC8
11D34:  MOVLB  0
11D36:  CALL   AA04
11D3A:  MOVLW  10
11D3C:  MOVWF  FE9
11D3E:  MOVFF  388,8D4
11D42:  MOVFF  387,8D3
11D46:  CALL   AA36
11D4A:  MOVLW  45
11D4C:  MOVWF  FF6
11D4E:  MOVLW  1F
11D50:  MOVWF  FF7
11D52:  MOVLW  00
11D54:  MOVWF  FF8
11D56:  MOVLW  09
11D58:  MOVLB  8
11D5A:  MOVWF  xC8
11D5C:  MOVLB  0
11D5E:  CALL   AA04
11D62:  MOVLW  89
11D64:  MOVWF  FE9
11D66:  MOVFF  3DC,8AF
11D6A:  MOVFF  3DB,8AE
11D6E:  MOVFF  3DA,8AD
11D72:  MOVFF  3D9,8AC
11D76:  MOVLW  04
11D78:  MOVLB  8
11D7A:  MOVWF  xB0
11D7C:  MOVLB  0
11D7E:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
11D82:  MOVF   1F,W
11D84:  SUBLW  02
11D86:  BNZ   11D8C
11D88:  MOVF   20,F
11D8A:  BZ    11DCC
11D8C:  MOVLW  54
11D8E:  MOVWF  FF6
11D90:  MOVLW  1F
11D92:  MOVWF  FF7
11D94:  MOVLW  00
11D96:  MOVWF  FF8
11D98:  CLRF   1B
11D9A:  BTFSC  FF2.7
11D9C:  BSF    1B.7
11D9E:  BCF    FF2.7
11DA0:  MOVLW  09
11DA2:  MOVLB  A
11DA4:  MOVWF  x18
11DA6:  MOVLB  0
11DA8:  CALL   1010
11DAC:  BTFSC  1B.7
11DAE:  BSF    FF2.7
11DB0:  MOVLW  04
11DB2:  MOVWF  FEA
11DB4:  MOVLW  21
11DB6:  MOVWF  FE9
11DB8:  CALL   78DC
11DBC:  MOVLW  0D
11DBE:  BTFSS  F9E.4
11DC0:  BRA    11DBE
11DC2:  MOVWF  FAD
11DC4:  MOVLW  0A
11DC6:  BTFSS  F9E.4
11DC8:  BRA    11DC6
11DCA:  MOVWF  FAD
11DCC:  GOTO   122DC (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
11DD0:  MOVLB  8
11DD2:  CLRF   x9F
11DD4:  MOVF   x9F,W
11DD6:  SUBLW  03
11DD8:  BNC   11DF8
11DDA:  MOVF   x9F,W
11DDC:  MULLW  04
11DDE:  MOVF   FF3,W
11DE0:  CLRF   03
11DE2:  ADDLW  E1
11DE4:  MOVWF  FE9
11DE6:  MOVLW  03
11DE8:  ADDWFC 03,W
11DEA:  MOVWF  FEA
11DEC:  CLRF   FEF
11DEE:  CLRF   FEC
11DF0:  CLRF   FEC
11DF2:  CLRF   FEC
11DF4:  INCF   x9F,F
11DF6:  BRA    11DD4
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
11DF8:  MOVLB  3
11DFA:  MOVF   x8F,F
11DFC:  BTFSS  FD8.2
11DFE:  BRA    11E04
11E00:  MOVF   x90,F
11E02:  BZ    11EA0
11E04:  MOVF   x91,F
11E06:  BNZ   11E0C
11E08:  MOVF   x92,F
11E0A:  BZ    11EA0
....................       blank = SiO_array[0]; 
11E0C:  MOVFF  390,8F5
11E10:  MOVFF  38F,8F4
11E14:  MOVLB  0
11E16:  CALL   C624
11E1A:  MOVFF  03,8A3
11E1E:  MOVFF  02,8A2
11E22:  MOVFF  01,8A1
11E26:  MOVFF  00,8A0
....................       react = SiO_array[1]; 
11E2A:  MOVFF  392,8F5
11E2E:  MOVFF  391,8F4
11E32:  CALL   C624
11E36:  MOVFF  03,8A7
11E3A:  MOVFF  02,8A6
11E3E:  MOVFF  01,8A5
11E42:  MOVFF  00,8A4
....................       ratio = blank / react; 
11E46:  MOVFF  8A3,8DB
11E4A:  MOVFF  8A2,8DA
11E4E:  MOVFF  8A1,8D9
11E52:  MOVFF  8A0,8D8
11E56:  MOVFF  8A7,8DF
11E5A:  MOVFF  8A6,8DE
11E5E:  MOVFF  8A5,8DD
11E62:  MOVFF  8A4,8DC
11E66:  CALL   C65A
11E6A:  MOVFF  03,8AB
11E6E:  MOVFF  02,8AA
11E72:  MOVFF  01,8A9
11E76:  MOVFF  00,8A8
....................       SiO_abs_array[0] = log10(ratio); 
11E7A:  MOVFF  8AB,8AF
11E7E:  MOVFF  8AA,8AE
11E82:  MOVFF  8A9,8AD
11E86:  MOVFF  8A8,8AC
11E8A:  CALL   108BA
11E8E:  MOVFF  03,3E4
11E92:  MOVFF  02,3E3
11E96:  MOVFF  01,3E2
11E9A:  MOVFF  00,3E1
11E9E:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
11EA0:  MOVF   x93,F
11EA2:  BNZ   11EA8
11EA4:  MOVF   x94,F
11EA6:  BZ    11F44
11EA8:  MOVF   x95,F
11EAA:  BNZ   11EB0
11EAC:  MOVF   x96,F
11EAE:  BZ    11F44
....................       blank = SiO_array[2]; 
11EB0:  MOVFF  394,8F5
11EB4:  MOVFF  393,8F4
11EB8:  MOVLB  0
11EBA:  CALL   C624
11EBE:  MOVFF  03,8A3
11EC2:  MOVFF  02,8A2
11EC6:  MOVFF  01,8A1
11ECA:  MOVFF  00,8A0
....................       react = SiO_array[3]; 
11ECE:  MOVFF  396,8F5
11ED2:  MOVFF  395,8F4
11ED6:  CALL   C624
11EDA:  MOVFF  03,8A7
11EDE:  MOVFF  02,8A6
11EE2:  MOVFF  01,8A5
11EE6:  MOVFF  00,8A4
....................       ratio = blank / react;    
11EEA:  MOVFF  8A3,8DB
11EEE:  MOVFF  8A2,8DA
11EF2:  MOVFF  8A1,8D9
11EF6:  MOVFF  8A0,8D8
11EFA:  MOVFF  8A7,8DF
11EFE:  MOVFF  8A6,8DE
11F02:  MOVFF  8A5,8DD
11F06:  MOVFF  8A4,8DC
11F0A:  CALL   C65A
11F0E:  MOVFF  03,8AB
11F12:  MOVFF  02,8AA
11F16:  MOVFF  01,8A9
11F1A:  MOVFF  00,8A8
....................       SiO_abs_array[1] = log10(ratio); 
11F1E:  MOVFF  8AB,8AF
11F22:  MOVFF  8AA,8AE
11F26:  MOVFF  8A9,8AD
11F2A:  MOVFF  8A8,8AC
11F2E:  CALL   108BA
11F32:  MOVFF  03,3E8
11F36:  MOVFF  02,3E7
11F3A:  MOVFF  01,3E6
11F3E:  MOVFF  00,3E5
11F42:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
11F44:  MOVF   x97,F
11F46:  BNZ   11F4C
11F48:  MOVF   x98,F
11F4A:  BZ    11FE8
11F4C:  MOVF   x99,F
11F4E:  BNZ   11F54
11F50:  MOVF   x9A,F
11F52:  BZ    11FE8
....................       blank = SiO_array[4]; 
11F54:  MOVFF  398,8F5
11F58:  MOVFF  397,8F4
11F5C:  MOVLB  0
11F5E:  CALL   C624
11F62:  MOVFF  03,8A3
11F66:  MOVFF  02,8A2
11F6A:  MOVFF  01,8A1
11F6E:  MOVFF  00,8A0
....................       react = SiO_array[5]; 
11F72:  MOVFF  39A,8F5
11F76:  MOVFF  399,8F4
11F7A:  CALL   C624
11F7E:  MOVFF  03,8A7
11F82:  MOVFF  02,8A6
11F86:  MOVFF  01,8A5
11F8A:  MOVFF  00,8A4
....................       ratio = blank / react; 
11F8E:  MOVFF  8A3,8DB
11F92:  MOVFF  8A2,8DA
11F96:  MOVFF  8A1,8D9
11F9A:  MOVFF  8A0,8D8
11F9E:  MOVFF  8A7,8DF
11FA2:  MOVFF  8A6,8DE
11FA6:  MOVFF  8A5,8DD
11FAA:  MOVFF  8A4,8DC
11FAE:  CALL   C65A
11FB2:  MOVFF  03,8AB
11FB6:  MOVFF  02,8AA
11FBA:  MOVFF  01,8A9
11FBE:  MOVFF  00,8A8
....................       SiO_abs_array[2] = log10(ratio); 
11FC2:  MOVFF  8AB,8AF
11FC6:  MOVFF  8AA,8AE
11FCA:  MOVFF  8A9,8AD
11FCE:  MOVFF  8A8,8AC
11FD2:  CALL   108BA
11FD6:  MOVFF  03,3EC
11FDA:  MOVFF  02,3EB
11FDE:  MOVFF  01,3EA
11FE2:  MOVFF  00,3E9
11FE6:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
11FE8:  MOVF   x9B,F
11FEA:  BNZ   11FF0
11FEC:  MOVF   x9C,F
11FEE:  BZ    1208C
11FF0:  MOVF   x9D,F
11FF2:  BNZ   11FF8
11FF4:  MOVF   x9E,F
11FF6:  BZ    1208C
....................       blank = SiO_array[6]; 
11FF8:  MOVFF  39C,8F5
11FFC:  MOVFF  39B,8F4
12000:  MOVLB  0
12002:  CALL   C624
12006:  MOVFF  03,8A3
1200A:  MOVFF  02,8A2
1200E:  MOVFF  01,8A1
12012:  MOVFF  00,8A0
....................       react = SiO_array[7]; 
12016:  MOVFF  39E,8F5
1201A:  MOVFF  39D,8F4
1201E:  CALL   C624
12022:  MOVFF  03,8A7
12026:  MOVFF  02,8A6
1202A:  MOVFF  01,8A5
1202E:  MOVFF  00,8A4
....................       ratio = blank / react; 
12032:  MOVFF  8A3,8DB
12036:  MOVFF  8A2,8DA
1203A:  MOVFF  8A1,8D9
1203E:  MOVFF  8A0,8D8
12042:  MOVFF  8A7,8DF
12046:  MOVFF  8A6,8DE
1204A:  MOVFF  8A5,8DD
1204E:  MOVFF  8A4,8DC
12052:  CALL   C65A
12056:  MOVFF  03,8AB
1205A:  MOVFF  02,8AA
1205E:  MOVFF  01,8A9
12062:  MOVFF  00,8A8
....................       SiO_abs_array[3] = log10(ratio); 
12066:  MOVFF  8AB,8AF
1206A:  MOVFF  8AA,8AE
1206E:  MOVFF  8A9,8AD
12072:  MOVFF  8A8,8AC
12076:  CALL   108BA
1207A:  MOVFF  03,3F0
1207E:  MOVFF  02,3EF
12082:  MOVFF  01,3EE
12086:  MOVFF  00,3ED
1208A:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
1208C:  MOVLW  04
1208E:  MOVWF  1E
12090:  MOVLW  21
12092:  MOVWF  1D
12094:  MOVLW  62
12096:  MOVWF  FF6
12098:  MOVLW  1F
1209A:  MOVWF  FF7
1209C:  MOVLW  00
1209E:  MOVWF  FF8
120A0:  MOVLW  06
120A2:  MOVLB  8
120A4:  MOVWF  xC8
120A6:  MOVLB  0
120A8:  CALL   AA04
120AC:  MOVLW  10
120AE:  MOVWF  FE9
120B0:  MOVFF  390,8D4
120B4:  MOVFF  38F,8D3
120B8:  CALL   AA36
120BC:  MOVLW  6B
120BE:  MOVWF  FF6
120C0:  MOVLW  1F
120C2:  MOVWF  FF7
120C4:  MOVLW  00
120C6:  MOVWF  FF8
120C8:  MOVLW  07
120CA:  MOVLB  8
120CC:  MOVWF  xC8
120CE:  MOVLB  0
120D0:  CALL   AA04
120D4:  MOVLW  10
120D6:  MOVWF  FE9
120D8:  MOVFF  392,8D4
120DC:  MOVFF  391,8D3
120E0:  CALL   AA36
120E4:  MOVLW  75
120E6:  MOVWF  FF6
120E8:  MOVLW  1F
120EA:  MOVWF  FF7
120EC:  MOVLW  00
120EE:  MOVWF  FF8
120F0:  MOVLW  09
120F2:  MOVLB  8
120F4:  MOVWF  xC8
120F6:  MOVLB  0
120F8:  CALL   AA04
120FC:  MOVLW  89
120FE:  MOVWF  FE9
12100:  MOVFF  3E4,8AF
12104:  MOVFF  3E3,8AE
12108:  MOVFF  3E2,8AD
1210C:  MOVFF  3E1,8AC
12110:  MOVLW  04
12112:  MOVLB  8
12114:  MOVWF  xB0
12116:  MOVLB  0
12118:  CALL   10926
1211C:  MOVLW  83
1211E:  MOVWF  FF6
12120:  MOVLW  1F
12122:  MOVWF  FF7
12124:  MOVLW  00
12126:  MOVWF  FF8
12128:  MOVLW  07
1212A:  MOVLB  8
1212C:  MOVWF  xC8
1212E:  MOVLB  0
12130:  CALL   AA04
12134:  MOVLW  10
12136:  MOVWF  FE9
12138:  MOVFF  394,8D4
1213C:  MOVFF  393,8D3
12140:  CALL   AA36
12144:  MOVLW  8D
12146:  MOVWF  FF6
12148:  MOVLW  1F
1214A:  MOVWF  FF7
1214C:  MOVLW  00
1214E:  MOVWF  FF8
12150:  MOVLW  07
12152:  MOVLB  8
12154:  MOVWF  xC8
12156:  MOVLB  0
12158:  CALL   AA04
1215C:  MOVLW  10
1215E:  MOVWF  FE9
12160:  MOVFF  396,8D4
12164:  MOVFF  395,8D3
12168:  CALL   AA36
1216C:  MOVLW  97
1216E:  MOVWF  FF6
12170:  MOVLW  1F
12172:  MOVWF  FF7
12174:  MOVLW  00
12176:  MOVWF  FF8
12178:  MOVLW  09
1217A:  MOVLB  8
1217C:  MOVWF  xC8
1217E:  MOVLB  0
12180:  CALL   AA04
12184:  MOVLW  89
12186:  MOVWF  FE9
12188:  MOVFF  3E8,8AF
1218C:  MOVFF  3E7,8AE
12190:  MOVFF  3E6,8AD
12194:  MOVFF  3E5,8AC
12198:  MOVLW  04
1219A:  MOVLB  8
1219C:  MOVWF  xB0
1219E:  MOVLB  0
121A0:  CALL   10926
121A4:  MOVLW  A5
121A6:  MOVWF  FF6
121A8:  MOVLW  1F
121AA:  MOVWF  FF7
121AC:  MOVLW  00
121AE:  MOVWF  FF8
121B0:  MOVLW  07
121B2:  MOVLB  8
121B4:  MOVWF  xC8
121B6:  MOVLB  0
121B8:  CALL   AA04
121BC:  MOVLW  10
121BE:  MOVWF  FE9
121C0:  MOVFF  398,8D4
121C4:  MOVFF  397,8D3
121C8:  CALL   AA36
121CC:  MOVLW  AF
121CE:  MOVWF  FF6
121D0:  MOVLW  1F
121D2:  MOVWF  FF7
121D4:  MOVLW  00
121D6:  MOVWF  FF8
121D8:  MOVLW  07
121DA:  MOVLB  8
121DC:  MOVWF  xC8
121DE:  MOVLB  0
121E0:  CALL   AA04
121E4:  MOVLW  10
121E6:  MOVWF  FE9
121E8:  MOVFF  39A,8D4
121EC:  MOVFF  399,8D3
121F0:  CALL   AA36
121F4:  MOVLW  B9
121F6:  MOVWF  FF6
121F8:  MOVLW  1F
121FA:  MOVWF  FF7
121FC:  MOVLW  00
121FE:  MOVWF  FF8
12200:  MOVLW  09
12202:  MOVLB  8
12204:  MOVWF  xC8
12206:  MOVLB  0
12208:  CALL   AA04
1220C:  MOVLW  89
1220E:  MOVWF  FE9
12210:  MOVFF  3EC,8AF
12214:  MOVFF  3EB,8AE
12218:  MOVFF  3EA,8AD
1221C:  MOVFF  3E9,8AC
12220:  MOVLW  04
12222:  MOVLB  8
12224:  MOVWF  xB0
12226:  MOVLB  0
12228:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
1222C:  MOVF   1F,W
1222E:  SUBLW  02
12230:  BNZ   12236
12232:  MOVF   20,F
12234:  BZ    12276
12236:  MOVLW  C8
12238:  MOVWF  FF6
1223A:  MOVLW  1F
1223C:  MOVWF  FF7
1223E:  MOVLW  00
12240:  MOVWF  FF8
12242:  CLRF   1B
12244:  BTFSC  FF2.7
12246:  BSF    1B.7
12248:  BCF    FF2.7
1224A:  MOVLW  09
1224C:  MOVLB  A
1224E:  MOVWF  x18
12250:  MOVLB  0
12252:  CALL   1010
12256:  BTFSC  1B.7
12258:  BSF    FF2.7
1225A:  MOVLW  04
1225C:  MOVWF  FEA
1225E:  MOVLW  21
12260:  MOVWF  FE9
12262:  CALL   78DC
12266:  MOVLW  0D
12268:  BTFSS  F9E.4
1226A:  BRA    12268
1226C:  MOVWF  FAD
1226E:  MOVLW  0A
12270:  BTFSS  F9E.4
12272:  BRA    12270
12274:  MOVWF  FAD
12276:  GOTO   122DC (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
1227A:  MOVLW  04
1227C:  MOVWF  FEA
1227E:  MOVLW  21
12280:  MOVWF  FE9
12282:  MOVLW  00
12284:  CALL   056C
12288:  TBLRD*-
1228A:  TBLRD*+
1228C:  MOVF   FF5,W
1228E:  MOVWF  FEE
12290:  IORLW  00
12292:  BNZ   1228A
....................     
....................    switch (chem){ 
12294:  MOVLW  D6
12296:  MOVWF  FF6
12298:  MOVLW  1F
1229A:  MOVWF  FF7
1229C:  MOVLW  00
1229E:  MOVWF  FF8
122A0:  MOVLW  03
122A2:  MOVWF  FEA
122A4:  MOVLW  39
122A6:  MOVWF  FE9
122A8:  CALL   FB56
122AC:  MOVF   01,W
122AE:  BZ    122C2
122B0:  XORLW  01
122B2:  BZ    122C8
122B4:  XORLW  03
122B6:  BZ    122CE
122B8:  XORLW  01
122BA:  BZ    122D4
122BC:  XORLW  07
122BE:  BZ    122DA
122C0:  BRA    122DC
....................       case "NO3" : calc_abs_NO3(); 
122C2:  GOTO   10B38
....................          break; 
122C6:  BRA    122DC
....................       case "NO2" : calc_abs_NO2 (); 
122C8:  GOTO   10FD4
....................          break;    
122CC:  BRA    122DC
....................       case "PO4" : calc_abs_PO4(); 
122CE:  GOTO   1147C
....................          break; 
122D2:  BRA    122DC
....................       case "NH4" : calc_abs_NH4(); 
122D4:  GOTO   11926
....................          break; 
122D8:  BRA    122DC
....................       case "SiO" : calc_abs_SiO(); 
122DA:  BRA    11DD0
....................          break; 
....................    } 
122DC:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
122DE:  CALL   D22E
....................     
....................    if (data_available == TRUE) { 
122E2:  MOVLB  3
122E4:  DECFSZ x37,W
122E6:  BRA    123E8
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
122E8:  MOVLB  8
122EA:  CLRF   xD6
122EC:  MOVLW  63
122EE:  MOVWF  xD5
122F0:  MOVLW  02
122F2:  MOVWF  xD8
122F4:  MOVLW  B3
122F6:  MOVWF  xD7
122F8:  MOVLB  0
122FA:  CALL   5460
....................       strcat(data_buffer, comma); 
122FE:  MOVLB  8
12300:  CLRF   xD6
12302:  MOVLW  63
12304:  MOVWF  xD5
12306:  MOVLW  03
12308:  MOVWF  xD8
1230A:  MOVLW  35
1230C:  MOVWF  xD7
1230E:  MOVLB  0
12310:  CALL   5460
....................       strcat(data_buffer, chem); 
12314:  MOVLB  8
12316:  CLRF   xD6
12318:  MOVLW  63
1231A:  MOVWF  xD5
1231C:  MOVLW  03
1231E:  MOVWF  xD8
12320:  MOVLW  39
12322:  MOVWF  xD7
12324:  MOVLB  0
12326:  CALL   5460
....................       strcat(data_buffer, comma); 
1232A:  MOVLB  8
1232C:  CLRF   xD6
1232E:  MOVLW  63
12330:  MOVWF  xD5
12332:  MOVLW  03
12334:  MOVWF  xD8
12336:  MOVLW  35
12338:  MOVWF  xD7
1233A:  MOVLB  0
1233C:  CALL   5460
....................       strcat(data_buffer, abs_str); 
12340:  MOVLB  8
12342:  CLRF   xD6
12344:  MOVLW  63
12346:  MOVWF  xD5
12348:  MOVLW  04
1234A:  MOVWF  xD8
1234C:  MOVLW  21
1234E:  MOVWF  xD7
12350:  MOVLB  0
12352:  CALL   5460
....................       strcat(data_buffer, endofline); 
12356:  MOVLB  8
12358:  CLRF   xD6
1235A:  MOVLW  63
1235C:  MOVWF  xD5
1235E:  MOVLW  07
12360:  MOVWF  xD8
12362:  MOVLW  CA
12364:  MOVWF  xD7
12366:  MOVLB  0
12368:  CALL   5460
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
1236C:  MOVF   1F,W
1236E:  SUBLW  04
12370:  BNZ   12390
12372:  MOVF   20,F
12374:  BNZ   12390
12376:  CLRF   FEA
12378:  MOVLW  63
1237A:  MOVWF  FE9
1237C:  CALL   78DC
12380:  MOVLW  0D
12382:  BTFSS  F9E.4
12384:  BRA    12382
12386:  MOVWF  FAD
12388:  MOVLW  0A
1238A:  BTFSS  F9E.4
1238C:  BRA    1238A
1238E:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
12390:  MOVLB  2
12392:  MOVF   xD8,F
12394:  BNZ   123E6
....................        
....................          buffer_select = 0; 
12396:  MOVLB  0
12398:  CLRF   x62
....................           
....................          heartbeat(FALSE); 
1239A:  MOVLB  8
1239C:  CLRF   xCA
1239E:  MOVLB  0
123A0:  CALL   5504
....................             append_data(file_ptr_rel_all); 
123A4:  MOVLW  02
123A6:  MOVLB  8
123A8:  MOVWF  xCB
123AA:  MOVLW  F5
123AC:  MOVWF  xCA
123AE:  MOVLB  0
123B0:  CALL   8238
....................          heartbeat(TRUE);          
123B4:  MOVLW  01
123B6:  MOVLB  8
123B8:  MOVWF  xCA
123BA:  MOVLB  0
123BC:  CALL   5504
....................           
....................          heartbeat(FALSE); 
123C0:  MOVLB  8
123C2:  CLRF   xCA
123C4:  MOVLB  0
123C6:  CALL   5504
....................             append_data(file_ptr_rel_new);    
123CA:  MOVLW  03
123CC:  MOVLB  8
123CE:  MOVWF  xCB
123D0:  MOVWF  xCA
123D2:  MOVLB  0
123D4:  CALL   8238
....................          heartbeat(TRUE); 
123D8:  MOVLW  01
123DA:  MOVLB  8
123DC:  MOVWF  xCA
123DE:  MOVLB  0
123E0:  CALL   5504
123E4:  MOVLB  2
123E6:  MOVLB  3
....................       } 
....................    } 
123E8:  MOVLB  0
123EA:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D344:  MOVLW  2C
0D346:  MOVLB  8
0D348:  MOVWF  x7B
0D34A:  CLRF   x7C
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D34C:  MOVLW  0D
0D34E:  MOVWF  x7D
0D350:  MOVLW  0A
0D352:  MOVWF  x7E
0D354:  CLRF   x7F
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D356:  MOVLB  0
0D358:  RCALL  D22E
....................    time_stamp(); 
0D35A:  CALL   539C
....................    strcat(data_buffer, time_stmp_str); 
0D35E:  MOVLB  8
0D360:  CLRF   xD6
0D362:  MOVLW  63
0D364:  MOVWF  xD5
0D366:  MOVLW  02
0D368:  MOVWF  xD8
0D36A:  MOVLW  95
0D36C:  MOVWF  xD7
0D36E:  MOVLB  0
0D370:  CALL   5460
....................    strcat(data_buffer, comma); 
0D374:  MOVLB  8
0D376:  CLRF   xD6
0D378:  MOVLW  63
0D37A:  MOVWF  xD5
0D37C:  MOVLW  08
0D37E:  MOVWF  xD8
0D380:  MOVLW  7B
0D382:  MOVWF  xD7
0D384:  MOVLB  0
0D386:  CALL   5460
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D38A:  MOVLW  08
0D38C:  MOVWF  1E
0D38E:  MOVLW  80
0D390:  MOVWF  1D
0D392:  MOVFF  87A,8CA
0D396:  MOVLW  1B
0D398:  MOVLB  8
0D39A:  MOVWF  xCB
0D39C:  MOVLB  0
0D39E:  CALL   5202
0D3A2:  MOVLW  2C
0D3A4:  MOVLB  8
0D3A6:  MOVWF  xDC
0D3A8:  MOVLB  0
0D3AA:  CALL   5020
0D3AE:  MOVLW  10
0D3B0:  MOVWF  FE9
0D3B2:  MOVFF  2A,8D4
0D3B6:  MOVFF  29,8D3
0D3BA:  CALL   AA36
0D3BE:  MOVLW  2C
0D3C0:  MOVLB  8
0D3C2:  MOVWF  xDC
0D3C4:  MOVLB  0
0D3C6:  CALL   5020
0D3CA:  MOVLW  10
0D3CC:  MOVWF  FE9
0D3CE:  MOVFF  24,8D4
0D3D2:  MOVFF  23,8D3
0D3D6:  CALL   AA36
0D3DA:  MOVLW  2C
0D3DC:  MOVLB  8
0D3DE:  MOVWF  xDC
0D3E0:  MOVLB  0
0D3E2:  CALL   5020
0D3E6:  MOVLW  10
0D3E8:  MOVWF  FE9
0D3EA:  MOVFF  2C,8D4
0D3EE:  MOVFF  2B,8D3
0D3F2:  CALL   AA36
0D3F6:  MOVLW  2C
0D3F8:  MOVLB  8
0D3FA:  MOVWF  xDC
0D3FC:  MOVLB  0
0D3FE:  CALL   5020
0D402:  MOVLW  10
0D404:  MOVWF  FE9
0D406:  MOVFF  2E,8D4
0D40A:  MOVFF  2D,8D3
0D40E:  CALL   AA36
0D412:  MOVLW  2C
0D414:  MOVLB  8
0D416:  MOVWF  xDC
0D418:  MOVLB  0
0D41A:  CALL   5020
0D41E:  MOVLW  10
0D420:  MOVWF  FE9
0D422:  MOVFF  22,8D4
0D426:  MOVFF  21,8D3
0D42A:  CALL   AA36
0D42E:  MOVLW  2C
0D430:  MOVLB  8
0D432:  MOVWF  xDC
0D434:  MOVLB  0
0D436:  CALL   5020
0D43A:  MOVLW  10
0D43C:  MOVWF  FE9
0D43E:  MOVFF  7C4,8D4
0D442:  MOVFF  7C3,8D3
0D446:  CALL   AA36
0D44A:  MOVLW  2C
0D44C:  MOVLB  8
0D44E:  MOVWF  xDC
0D450:  MOVLB  0
0D452:  CALL   5020
0D456:  MOVLW  10
0D458:  MOVWF  FE9
0D45A:  MOVFF  7B2,89F
0D45E:  MOVFF  7B1,89E
0D462:  BRA    D242
....................    strcat(data_buffer, config_str); 
0D464:  MOVLB  8
0D466:  CLRF   xD6
0D468:  MOVLW  63
0D46A:  MOVWF  xD5
0D46C:  MOVLW  08
0D46E:  MOVWF  xD8
0D470:  MOVLW  80
0D472:  MOVWF  xD7
0D474:  MOVLB  0
0D476:  CALL   5460
....................    strcat(data_buffer, endofline); 
0D47A:  MOVLB  8
0D47C:  CLRF   xD6
0D47E:  MOVLW  63
0D480:  MOVWF  xD5
0D482:  MOVLW  08
0D484:  MOVWF  xD8
0D486:  MOVLW  7D
0D488:  MOVWF  xD7
0D48A:  MOVLB  0
0D48C:  CALL   5460
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D490:  CLRF   FEA
0D492:  MOVLW  63
0D494:  MOVWF  FE9
0D496:  CALL   78DC
0D49A:  MOVLW  0D
0D49C:  BTFSS  F9E.4
0D49E:  BRA    D49C
0D4A0:  MOVWF  FAD
0D4A2:  MOVLW  0A
0D4A4:  BTFSS  F9E.4
0D4A6:  BRA    D4A4
0D4A8:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D4AA:  MOVLB  2
0D4AC:  MOVF   xD8,F
0D4AE:  BNZ   D502
....................     
....................       buffer_select = 0; 
0D4B0:  MOVLB  0
0D4B2:  CLRF   x62
....................        
....................       heartbeat(FALSE); 
0D4B4:  MOVLB  8
0D4B6:  CLRF   xCA
0D4B8:  MOVLB  0
0D4BA:  CALL   5504
....................          append_data(file_ptr_raw_all); 
0D4BE:  MOVLW  02
0D4C0:  MOVLB  8
0D4C2:  MOVWF  xCB
0D4C4:  MOVLW  D9
0D4C6:  MOVWF  xCA
0D4C8:  MOVLB  0
0D4CA:  CALL   8238
....................       heartbeat(TRUE);          
0D4CE:  MOVLW  01
0D4D0:  MOVLB  8
0D4D2:  MOVWF  xCA
0D4D4:  MOVLB  0
0D4D6:  CALL   5504
....................        
....................       heartbeat(FALSE); 
0D4DA:  MOVLB  8
0D4DC:  CLRF   xCA
0D4DE:  MOVLB  0
0D4E0:  CALL   5504
....................          append_data(file_ptr_raw_new);    
0D4E4:  MOVLW  02
0D4E6:  MOVLB  8
0D4E8:  MOVWF  xCB
0D4EA:  MOVLW  E7
0D4EC:  MOVWF  xCA
0D4EE:  MOVLB  0
0D4F0:  CALL   8238
....................       heartbeat(TRUE); 
0D4F4:  MOVLW  01
0D4F6:  MOVLB  8
0D4F8:  MOVWF  xCA
0D4FA:  MOVLB  0
0D4FC:  CALL   5504
0D500:  MOVLB  2
....................    } 
0D502:  MOVLB  0
0D504:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
14DD6:  MOVLW  2C
14DD8:  MOVLB  8
14DDA:  MOVWF  x7D
14DDC:  CLRF   x7E
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
14DDE:  MOVLW  0D
14DE0:  MOVWF  x7F
14DE2:  MOVLW  0A
14DE4:  MOVWF  x80
14DE6:  CLRF   x81
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
14DE8:  MOVLB  0
14DEA:  CALL   D22E
....................    time_stamp(); 
14DEE:  CALL   539C
....................    strcat(data_buffer, time_stmp_str); 
14DF2:  MOVLB  8
14DF4:  CLRF   xD6
14DF6:  MOVLW  63
14DF8:  MOVWF  xD5
14DFA:  MOVLW  02
14DFC:  MOVWF  xD8
14DFE:  MOVLW  95
14E00:  MOVWF  xD7
14E02:  MOVLB  0
14E04:  CALL   5460
....................    strcat(data_buffer, comma); 
14E08:  MOVLB  8
14E0A:  CLRF   xD6
14E0C:  MOVLW  63
14E0E:  MOVWF  xD5
14E10:  MOVLW  08
14E12:  MOVWF  xD8
14E14:  MOVLW  7D
14E16:  MOVWF  xD7
14E18:  MOVLB  0
14E1A:  CALL   5460
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
14E1E:  MOVLW  08
14E20:  MOVWF  1E
14E22:  MOVLW  82
14E24:  MOVWF  1D
14E26:  MOVFF  87A,8CA
14E2A:  MOVLW  1B
14E2C:  MOVLB  8
14E2E:  MOVWF  xCB
14E30:  MOVLB  0
14E32:  CALL   5202
14E36:  MOVLW  2C
14E38:  MOVLB  8
14E3A:  MOVWF  xDC
14E3C:  MOVLB  0
14E3E:  CALL   5020
14E42:  MOVLW  10
14E44:  MOVWF  FE9
14E46:  MOVFF  87C,8D4
14E4A:  MOVFF  87B,8D3
14E4E:  CALL   AA36
....................    strcat(data_buffer, config_str); 
14E52:  MOVLB  8
14E54:  CLRF   xD6
14E56:  MOVLW  63
14E58:  MOVWF  xD5
14E5A:  MOVLW  08
14E5C:  MOVWF  xD8
14E5E:  MOVLW  82
14E60:  MOVWF  xD7
14E62:  MOVLB  0
14E64:  CALL   5460
....................    strcat(data_buffer, endofline); 
14E68:  MOVLB  8
14E6A:  CLRF   xD6
14E6C:  MOVLW  63
14E6E:  MOVWF  xD5
14E70:  MOVLW  08
14E72:  MOVWF  xD8
14E74:  MOVLW  7F
14E76:  MOVWF  xD7
14E78:  MOVLB  0
14E7A:  CALL   5460
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
14E7E:  MOVF   1F,W
14E80:  SUBLW  04
14E82:  BNZ   14EA2
14E84:  MOVF   20,F
14E86:  BNZ   14EA2
14E88:  CLRF   FEA
14E8A:  MOVLW  63
14E8C:  MOVWF  FE9
14E8E:  CALL   78DC
14E92:  MOVLW  0D
14E94:  BTFSS  F9E.4
14E96:  BRA    14E94
14E98:  MOVWF  FAD
14E9A:  MOVLW  0A
14E9C:  BTFSS  F9E.4
14E9E:  BRA    14E9C
14EA0:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
14EA2:  MOVLB  2
14EA4:  MOVF   xD8,F
14EA6:  BNZ   14EFA
....................     
....................       buffer_select = 0; 
14EA8:  MOVLB  0
14EAA:  CLRF   x62
....................        
....................       heartbeat(FALSE); 
14EAC:  MOVLB  8
14EAE:  CLRF   xCA
14EB0:  MOVLB  0
14EB2:  CALL   5504
....................          append_data(file_ptr_raw_all); 
14EB6:  MOVLW  02
14EB8:  MOVLB  8
14EBA:  MOVWF  xCB
14EBC:  MOVLW  D9
14EBE:  MOVWF  xCA
14EC0:  MOVLB  0
14EC2:  CALL   8238
....................       heartbeat(TRUE);          
14EC6:  MOVLW  01
14EC8:  MOVLB  8
14ECA:  MOVWF  xCA
14ECC:  MOVLB  0
14ECE:  CALL   5504
....................        
....................       heartbeat(FALSE); 
14ED2:  MOVLB  8
14ED4:  CLRF   xCA
14ED6:  MOVLB  0
14ED8:  CALL   5504
....................          append_data(file_ptr_raw_new);    
14EDC:  MOVLW  02
14EDE:  MOVLB  8
14EE0:  MOVWF  xCB
14EE2:  MOVLW  E7
14EE4:  MOVWF  xCA
14EE6:  MOVLB  0
14EE8:  CALL   8238
....................       heartbeat(TRUE); 
14EEC:  MOVLW  01
14EEE:  MOVLB  8
14EF0:  MOVWF  xCA
14EF2:  MOVLB  0
14EF4:  CALL   5504
14EF8:  MOVLB  2
....................    } 
14EFA:  MOVLB  0
14EFC:  GOTO   15098 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0D076:  BSF    F90.7
....................    delay_ms(500); 
0D078:  MOVLW  02
0D07A:  MOVLB  8
0D07C:  MOVWF  x9F
0D07E:  MOVLW  FA
0D080:  MOVLB  9
0D082:  MOVWF  xC9
0D084:  MOVLB  0
0D086:  CALL   2898
0D08A:  MOVLB  8
0D08C:  DECFSZ x9F,F
0D08E:  BRA    D07E
....................    bus_pwr_status=1; 
0D090:  MOVLW  01
0D092:  MOVLB  4
0D094:  MOVWF  xB2
0D096:  MOVLB  0
0D098:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D09A:  BCF    F90.7
....................    delay_ms(100); 
0D09C:  MOVLW  64
0D09E:  MOVLB  9
0D0A0:  MOVWF  xC9
0D0A2:  MOVLB  0
0D0A4:  CALL   2898
....................    bus_pwr_status=0; 
0D0A8:  MOVLB  4
0D0AA:  CLRF   xB2
0D0AC:  MOVLB  0
0D0AE:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
17AC0:  MOVLB  8
17AC2:  CLRF   x74
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
17AC4:  CLRF   x74
17AC6:  MOVF   x74,W
17AC8:  SUBLW  31
17ACA:  BNC   17AE0
....................       string_arg[i] = 0; 
17ACC:  CLRF   03
17ACE:  MOVF   x74,W
17AD0:  ADDLW  21
17AD2:  MOVWF  FE9
17AD4:  MOVLW  08
17AD6:  ADDWFC 03,W
17AD8:  MOVWF  FEA
17ADA:  CLRF   FEF
17ADC:  INCF   x74,F
17ADE:  BRA    17AC6
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
17AE0:  CLRF   x74
17AE2:  MOVF   x74,W
17AE4:  SUBLW  31
17AE6:  BNC   17B60
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
17AE8:  CLRF   03
17AEA:  MOVF   x74,W
17AEC:  ADDLW  21
17AEE:  MOVWF  FE9
17AF0:  MOVLW  08
17AF2:  ADDWFC 03,W
17AF4:  MOVWF  FEA
17AF6:  MOVFF  FEA,878
17AFA:  MOVFF  FE9,877
17AFE:  MOVLB  0
17B00:  CALL   0E24
17B04:  MOVFF  878,FEA
17B08:  MOVFF  877,FE9
17B0C:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
17B10:  DECFSZ 48,W
17B12:  BRA    17B30
....................       { 
....................          fputc(string_arg[i],COM_A); 
17B14:  CLRF   03
17B16:  MOVLB  8
17B18:  MOVF   x74,W
17B1A:  ADDLW  21
17B1C:  MOVWF  FE9
17B1E:  MOVLW  08
17B20:  ADDWFC 03,W
17B22:  MOVWF  FEA
17B24:  MOVFF  FEF,875
17B28:  MOVF   x75,W
17B2A:  MOVLB  0
17B2C:  CALL   ADB4
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
17B30:  CLRF   03
17B32:  MOVLB  8
17B34:  MOVF   x74,W
17B36:  ADDLW  21
17B38:  MOVWF  FE9
17B3A:  MOVLW  08
17B3C:  ADDWFC 03,W
17B3E:  MOVWF  FEA
17B40:  MOVF   FEF,W
17B42:  SUBLW  0D
17B44:  BZ    17B5A
17B46:  CLRF   03
17B48:  MOVF   x74,W
17B4A:  ADDLW  21
17B4C:  MOVWF  FE9
17B4E:  MOVLW  08
17B50:  ADDWFC 03,W
17B52:  MOVWF  FEA
17B54:  MOVF   FEF,W
17B56:  SUBLW  0A
17B58:  BNZ   17B5C
....................       { 
....................          break; 
17B5A:  BRA    17B60
....................       } 
17B5C:  INCF   x74,F
17B5E:  BRA    17AE2
....................    } 
17B60:  MOVLB  0
17B62:  GOTO   17E8A (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
17D08:  MOVLB  8
17D0A:  CLRF   x74
....................    macro_arg = 0; 
17D0C:  CLRF   x76
17D0E:  CLRF   x75
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
17D10:  MOVF   x74,W
17D12:  SUBLW  0D
17D14:  BZ    17DA0
....................       number = fgetc(COM_A); 
17D16:  MOVLB  0
17D18:  CALL   0E24
17D1C:  MOVFF  01,874
....................       if (com_echo == TRUE) 
17D20:  DECFSZ 48,W
17D22:  BRA    17D34
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
17D24:  MOVLB  8
17D26:  MOVF   x74,W
17D28:  SUBLW  0D
17D2A:  BZ    17D36
17D2C:  MOVF   x74,W
17D2E:  MOVLB  0
17D30:  CALL   ADB4
17D34:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
17D36:  MOVF   x74,W
17D38:  SUBLW  2F
17D3A:  BC    17D70
17D3C:  MOVF   x74,W
17D3E:  SUBLW  39
17D40:  BNC   17D70
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
17D42:  MOVLW  30
17D44:  SUBWF  x74,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
17D46:  MOVFF  876,9EA
17D4A:  MOVFF  875,9E9
17D4E:  MOVLB  9
17D50:  CLRF   xEC
17D52:  MOVLW  0A
17D54:  MOVWF  xEB
17D56:  MOVLB  0
17D58:  CALL   5C18
17D5C:  MOVFF  02,876
17D60:  MOVFF  01,875
....................          macro_arg = macro_arg + number;                // for each number 
17D64:  MOVLB  8
17D66:  MOVF   x74,W
17D68:  ADDWF  x75,F
17D6A:  MOVLW  00
17D6C:  ADDWFC x76,F
....................       } 
17D6E:  BRA    17D9E
....................       else if (number == CARRIAGE_RET) 
17D70:  MOVF   x74,W
17D72:  SUBLW  0D
17D74:  BNZ   17D96
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
17D76:  INCFSZ x75,W
17D78:  BRA    17D80
17D7A:  INCFSZ x76,W
17D7C:  BRA    17D80
17D7E:  BRA    17D8C
17D80:  MOVFF  875,01
17D84:  MOVFF  876,02
17D88:  BRA    17DA0
17D8A:  BRA    17D94
....................          else return(65535); 
17D8C:  MOVLW  FF
17D8E:  MOVWF  01
17D90:  MOVWF  02
17D92:  BRA    17DA0
....................       } 
17D94:  BRA    17D9E
....................       else 
....................       { 
....................          return(65535); 
17D96:  MOVLW  FF
17D98:  MOVWF  01
17D9A:  MOVWF  02
17D9C:  BRA    17DA0
....................       } 
17D9E:  BRA    17D10
....................    } 
17DA0:  MOVLB  0
17DA2:  GOTO   17EB4 (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
17850:  MOVF   2F,W
17852:  MOVWF  00
17854:  MOVF   30,W
17856:  MOVWF  03
17858:  BNZ   1785E
1785A:  MOVF   00,F
1785C:  BZ    17884
1785E:  MOVF   03,W
17860:  BNZ   1786A
17862:  MOVLW  03
17864:  SUBWF  00,W
17866:  BTFSC  FD8.2
17868:  BRA    17942
1786A:  MOVF   03,W
1786C:  BNZ   17876
1786E:  MOVLW  01
17870:  SUBWF  00,W
17872:  BTFSC  FD8.2
17874:  BRA    17942
17876:  MOVF   03,W
17878:  BNZ   17882
1787A:  MOVLW  02
1787C:  SUBWF  00,W
1787E:  BTFSC  FD8.2
17880:  BRA    179B8
17882:  BRA    17A26
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
17884:  MOVLB  8
17886:  MOVF   x78,F
17888:  BNZ   178B8
1788A:  MOVF   x77,W
1788C:  SUBLW  23
1788E:  BZ    178B2
17890:  MOVF   x77,W
17892:  SUBLW  25
17894:  BZ    178B2
17896:  MOVF   x77,W
17898:  SUBLW  3B
1789A:  BZ    178B2
1789C:  MOVF   x77,W
1789E:  SUBLW  4D
178A0:  BZ    178B2
178A2:  MOVF   x77,W
178A4:  SUBLW  5A
178A6:  BZ    178B2
178A8:  MOVF   x77,W
178AA:  SUBLW  72
178AC:  BZ    178B2
178AE:  MOVLW  00
178B0:  BRA    178B4
178B2:  MOVLW  01
178B4:  MOVWF  x79
178B6:  BRA    1793E
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
178B8:  MOVF   x77,W
178BA:  SUBLW  23
178BC:  BZ    1793A
178BE:  MOVF   x77,W
178C0:  SUBLW  25
178C2:  BZ    1793A
178C4:  MOVF   x77,W
178C6:  SUBLW  2B
178C8:  BZ    1793A
178CA:  MOVF   x77,W
178CC:  SUBLW  2D
178CE:  BZ    1793A
178D0:  MOVF   x77,W
178D2:  SUBLW  2F
178D4:  BZ    1793A
178D6:  MOVF   x77,W
178D8:  SUBLW  3B
178DA:  BZ    1793A
178DC:  MOVF   x77,W
178DE:  SUBLW  41
178E0:  BZ    1793A
178E2:  MOVF   x77,W
178E4:  SUBLW  42
178E6:  BC    178EE
178E8:  MOVF   x77,W
178EA:  SUBLW  44
178EC:  BC    1793A
178EE:  MOVF   x77,W
178F0:  SUBLW  45
178F2:  BC    178FA
178F4:  MOVF   x77,W
178F6:  SUBLW  48
178F8:  BC    1793A
178FA:  MOVF   x77,W
178FC:  SUBLW  4A
178FE:  BC    17906
17900:  MOVF   x77,W
17902:  SUBLW  4C
17904:  BC    1793A
17906:  MOVF   x77,W
17908:  SUBLW  4F
1790A:  BC    17912
1790C:  MOVF   x77,W
1790E:  SUBLW  55
17910:  BC    1793A
17912:  MOVF   x77,W
17914:  SUBLW  59
17916:  BZ    1793A
17918:  MOVF   x77,W
1791A:  SUBLW  64
1791C:  BZ    1793A
1791E:  MOVF   x77,W
17920:  SUBLW  69
17922:  BZ    1793A
17924:  MOVF   x77,W
17926:  SUBLW  6C
17928:  BZ    1793A
1792A:  MOVF   x77,W
1792C:  SUBLW  70
1792E:  BZ    1793A
17930:  MOVF   x77,W
17932:  SUBLW  72
17934:  BZ    1793A
17936:  MOVLW  00
17938:  BRA    1793C
1793A:  MOVLW  01
1793C:  MOVWF  x79
....................          break; 
1793E:  MOVLB  0
17940:  BRA    17A26
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
17942:  MOVLB  8
17944:  MOVF   x78,F
17946:  BNZ   17970
17948:  MOVF   x77,W
1794A:  SUBLW  23
1794C:  BZ    1796A
1794E:  MOVF   x77,W
17950:  SUBLW  3B
17952:  BZ    1796A
17954:  MOVF   x77,W
17956:  SUBLW  4A
17958:  BZ    1796A
1795A:  MOVF   x77,W
1795C:  SUBLW  4D
1795E:  BZ    1796A
17960:  MOVF   x77,W
17962:  SUBLW  50
17964:  BZ    1796A
17966:  MOVLW  00
17968:  BRA    1796C
1796A:  MOVLW  01
1796C:  MOVWF  x79
1796E:  BRA    179B4
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
17970:  MOVF   x77,W
17972:  SUBLW  23
17974:  BZ    179B0
17976:  MOVF   x77,W
17978:  SUBLW  2B
1797A:  BZ    179B0
1797C:  MOVF   x77,W
1797E:  SUBLW  2D
17980:  BZ    179B0
17982:  MOVF   x77,W
17984:  SUBLW  3B
17986:  BZ    179B0
17988:  MOVF   x77,W
1798A:  SUBLW  42
1798C:  BZ    179B0
1798E:  MOVF   x77,W
17990:  SUBLW  47
17992:  BZ    179B0
17994:  MOVF   x77,W
17996:  SUBLW  4F
17998:  BC    179A0
1799A:  MOVF   x77,W
1799C:  SUBLW  52
1799E:  BC    179B0
179A0:  MOVF   x77,W
179A2:  SUBLW  54
179A4:  BZ    179B0
179A6:  MOVF   x77,W
179A8:  SUBLW  59
179AA:  BZ    179B0
179AC:  MOVLW  00
179AE:  BRA    179B2
179B0:  MOVLW  01
179B2:  MOVWF  x79
....................          break;   
179B4:  MOVLB  0
179B6:  BRA    17A26
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
179B8:  MOVLB  8
179BA:  MOVF   x78,F
179BC:  BNZ   179E0
179BE:  MOVF   x77,W
179C0:  SUBLW  23
179C2:  BZ    179DA
179C4:  MOVF   x77,W
179C6:  SUBLW  3B
179C8:  BZ    179DA
179CA:  MOVF   x77,W
179CC:  SUBLW  4D
179CE:  BZ    179DA
179D0:  MOVF   x77,W
179D2:  SUBLW  50
179D4:  BZ    179DA
179D6:  MOVLW  00
179D8:  BRA    179DC
179DA:  MOVLW  01
179DC:  MOVWF  x79
179DE:  BRA    17A24
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
179E0:  MOVF   x77,W
179E2:  SUBLW  23
179E4:  BZ    17A20
179E6:  MOVF   x77,W
179E8:  SUBLW  2B
179EA:  BZ    17A20
179EC:  MOVF   x77,W
179EE:  SUBLW  2D
179F0:  BZ    17A20
179F2:  MOVF   x77,W
179F4:  SUBLW  3B
179F6:  BZ    17A20
179F8:  MOVF   x77,W
179FA:  SUBLW  42
179FC:  BC    17A04
179FE:  MOVF   x77,W
17A00:  SUBLW  44
17A02:  BC    17A20
17A04:  MOVF   x77,W
17A06:  SUBLW  4F
17A08:  BC    17A10
17A0A:  MOVF   x77,W
17A0C:  SUBLW  51
17A0E:  BC    17A20
17A10:  MOVF   x77,W
17A12:  SUBLW  53
17A14:  BZ    17A20
17A16:  MOVF   x77,W
17A18:  SUBLW  59
17A1A:  BZ    17A20
17A1C:  MOVLW  00
17A1E:  BRA    17A22
17A20:  MOVLW  01
17A22:  MOVWF  x79
....................          break;   
17A24:  MOVLB  0
....................    } 
....................    return(valid_macro); 
17A26:  MOVLB  8
17A28:  MOVFF  879,01
17A2C:  MOVLB  0
17A2E:  GOTO   17A5A (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
17A32:  MOVLW  01
17A34:  MOVLB  8
17A36:  MOVWF  x76
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
17A38:  MOVLB  0
17A3A:  CALL   0E24
17A3E:  MOVFF  01,875
....................       if (com_echo == TRUE) fputc(e,COM_A); 
17A42:  DECFSZ 48,W
17A44:  BRA    17A50
17A46:  MOVLB  8
17A48:  MOVF   x75,W
17A4A:  MOVLB  0
17A4C:  CALL   ADB4
....................          valid_macro = check_macro(e, macro); 
17A50:  MOVFF  875,877
17A54:  MOVFF  874,878
17A58:  BRA    17850
17A5A:  MOVFF  01,876
....................       if (valid_macro == TRUE) { 
17A5E:  MOVLB  8
17A60:  DECFSZ x76,W
17A62:  BRA    17A6C
....................          return(e); 
17A64:  MOVFF  875,01
17A68:  BRA    17A78
....................       } 
17A6A:  BRA    17A72
....................       else return(0); 
17A6C:  MOVLW  00
17A6E:  MOVWF  01
17A70:  BRA    17A78
....................    } while (valid_macro == TRUE); 
17A72:  DECFSZ x76,W
17A74:  BRA    17A78
17A76:  BRA    17A38
17A78:  MOVLB  0
17A7A:  GOTO   17E6C (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
17DF2:  BCF    FD8.0
17DF4:  MOVLB  8
17DF6:  RLCF   x77,W
17DF8:  CLRF   03
17DFA:  ADDLW  CD
17DFC:  MOVWF  FE9
17DFE:  MOVLW  07
17E00:  ADDWFC 03,W
17E02:  MOVWF  FEA
17E04:  MOVFF  FEC,87D
17E08:  MOVF   FED,F
17E0A:  MOVFF  FEF,87C
17E0E:  MOVFF  879,9EA
17E12:  MOVFF  878,9E9
17E16:  MOVLB  9
17E18:  CLRF   xEC
17E1A:  MOVLW  03
17E1C:  MOVWF  xEB
17E1E:  MOVLB  0
17E20:  CALL   5C18
17E24:  MOVF   01,W
17E26:  MOVLB  8
17E28:  ADDWF  x7C,W
17E2A:  MOVWF  x7A
17E2C:  MOVF   02,W
17E2E:  ADDWFC x7D,W
17E30:  MOVWF  x7B
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
17E32:  MOVFF  87B,885
17E36:  MOVFF  87A,884
17E3A:  MOVFF  874,886
17E3E:  MOVLB  0
17E40:  RCALL  17B66
....................     
....................    ++addr; 
17E42:  MOVLB  8
17E44:  INCF   x7A,F
17E46:  BTFSC  FD8.2
17E48:  INCF   x7B,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
17E4A:  MOVFF  87B,87D
17E4E:  MOVFF  87A,87C
17E52:  MOVFF  876,87F
17E56:  MOVFF  875,87E
17E5A:  MOVLB  0
17E5C:  BRA    17DA6
17E5E:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
17BC6:  BCF    FD8.0
17BC8:  MOVLB  8
17BCA:  RLCF   x75,W
17BCC:  CLRF   03
17BCE:  ADDLW  CD
17BD0:  MOVWF  FE9
17BD2:  MOVLW  07
17BD4:  ADDWFC 03,W
17BD6:  MOVWF  FEA
17BD8:  MOVFF  FEC,87E
17BDC:  MOVF   FED,F
17BDE:  MOVFF  FEF,87D
17BE2:  MOVFF  877,9EA
17BE6:  MOVFF  876,9E9
17BEA:  MOVLB  9
17BEC:  CLRF   xEC
17BEE:  MOVLW  03
17BF0:  MOVWF  xEB
17BF2:  MOVLB  0
17BF4:  CALL   5C18
17BF8:  MOVF   01,W
17BFA:  MOVLB  8
17BFC:  ADDWF  x7D,W
17BFE:  MOVWF  x7A
17C00:  MOVF   02,W
17C02:  ADDWFC x7E,W
17C04:  MOVWF  x7B
....................    write_ext_eeprom(addr, macro_cmd); 
17C06:  MOVFF  87B,885
17C0A:  MOVFF  87A,884
17C0E:  MOVFF  874,886
17C12:  MOVLB  0
17C14:  RCALL  17B66
....................     
....................    int i = 0; 
17C16:  MOVLB  8
17C18:  CLRF   x7C
....................    addr = string_address[macro] + (count*50); 
17C1A:  BCF    FD8.0
17C1C:  RLCF   x75,W
17C1E:  CLRF   03
17C20:  ADDLW  F7
17C22:  MOVWF  FE9
17C24:  MOVLW  07
17C26:  ADDWFC 03,W
17C28:  MOVWF  FEA
17C2A:  MOVFF  FEC,87E
17C2E:  MOVF   FED,F
17C30:  MOVFF  FEF,87D
17C34:  MOVFF  879,9EA
17C38:  MOVFF  878,9E9
17C3C:  MOVLB  9
17C3E:  CLRF   xEC
17C40:  MOVLW  32
17C42:  MOVWF  xEB
17C44:  MOVLB  0
17C46:  CALL   5C18
17C4A:  MOVF   01,W
17C4C:  MOVLB  8
17C4E:  ADDWF  x7D,W
17C50:  MOVWF  x7A
17C52:  MOVF   02,W
17C54:  ADDWFC x7E,W
17C56:  MOVWF  x7B
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
17C58:  MOVF   x79,F
17C5A:  BNZ   17CB0
17C5C:  MOVF   x78,W
17C5E:  SUBLW  14
17C60:  BNC   17CB0
....................       for(i = 0; i<50; i++) { 
17C62:  CLRF   x7C
17C64:  MOVF   x7C,W
17C66:  SUBLW  31
17C68:  BNC   17CAE
....................          write_ext_eeprom(addr + i, string_arg[i]); 
17C6A:  MOVF   x7C,W
17C6C:  ADDWF  x7A,W
17C6E:  MOVWF  x7D
17C70:  MOVLW  00
17C72:  ADDWFC x7B,W
17C74:  MOVWF  x7E
17C76:  CLRF   03
17C78:  MOVF   x7C,W
17C7A:  ADDLW  21
17C7C:  MOVWF  FE9
17C7E:  MOVLW  08
17C80:  ADDWFC 03,W
17C82:  MOVWF  FEA
17C84:  MOVFF  FEF,886
17C88:  MOVFF  87E,885
17C8C:  MOVFF  87D,884
17C90:  MOVLB  0
17C92:  RCALL  17B66
....................          if(string_arg[i] == 0){ 
17C94:  CLRF   03
17C96:  MOVLB  8
17C98:  MOVF   x7C,W
17C9A:  ADDLW  21
17C9C:  MOVWF  FE9
17C9E:  MOVLW  08
17CA0:  ADDWFC 03,W
17CA2:  MOVWF  FEA
17CA4:  MOVF   FEF,F
17CA6:  BNZ   17CAA
....................             break; 
17CA8:  BRA    17CAE
....................          } 
17CAA:  INCF   x7C,F
17CAC:  BRA    17C64
....................       
....................       } 
....................    }else{ 
17CAE:  BRA    17D02
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
17CB0:  MOVLW  BE
17CB2:  MOVWF  FF6
17CB4:  MOVLW  20
17CB6:  MOVWF  FF7
17CB8:  MOVLW  00
17CBA:  MOVWF  FF8
17CBC:  CLRF   1B
17CBE:  BTFSC  FF2.7
17CC0:  BSF    1B.7
17CC2:  BCF    FF2.7
17CC4:  MOVLW  1E
17CC6:  MOVLB  A
17CC8:  MOVWF  x18
17CCA:  MOVLB  0
17CCC:  CALL   1010
17CD0:  BTFSC  1B.7
17CD2:  BSF    FF2.7
17CD4:  MOVLW  10
17CD6:  MOVWF  FE9
17CD8:  CLRF   1B
17CDA:  BTFSC  FF2.7
17CDC:  BSF    1B.7
17CDE:  BCF    FF2.7
17CE0:  MOVFF  877,A19
17CE4:  MOVFF  876,A18
17CE8:  CALL   1192
17CEC:  BTFSC  1B.7
17CEE:  BSF    FF2.7
17CF0:  MOVLW  0A
17CF2:  BTFSS  F9E.4
17CF4:  BRA    17CF2
17CF6:  MOVWF  FAD
17CF8:  MOVLW  0D
17CFA:  BTFSS  F9E.4
17CFC:  BRA    17CFA
17CFE:  MOVWF  FAD
17D00:  MOVLB  8
....................    } 
17D02:  MOVLB  0
17D04:  GOTO   17EA4 (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
18044:  CALL   FFE6
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
18048:  MOVLW  3B
1804A:  MOVLB  8
1804C:  MOVWF  x74
1804E:  CLRF   x76
18050:  CLRF   x75
18052:  CLRF   x77
18054:  CLRF   x79
18056:  CLRF   x78
18058:  MOVLB  0
1805A:  RCALL  17DF2
....................     
....................    write_macro_line(59, 0, 1, 0); 
1805C:  MOVLW  3B
1805E:  MOVLB  8
18060:  MOVWF  x74
18062:  CLRF   x76
18064:  CLRF   x75
18066:  MOVLW  01
18068:  MOVWF  x77
1806A:  CLRF   x79
1806C:  CLRF   x78
1806E:  MOVLB  0
18070:  RCALL  17DF2
....................    write_macro_line(59, 0, 2, 0); 
18072:  MOVLW  3B
18074:  MOVLB  8
18076:  MOVWF  x74
18078:  CLRF   x76
1807A:  CLRF   x75
1807C:  MOVLW  02
1807E:  MOVWF  x77
18080:  CLRF   x79
18082:  CLRF   x78
18084:  MOVLB  0
18086:  RCALL  17DF2
....................    write_macro_line(59, 0, 3, 0); 
18088:  MOVLW  3B
1808A:  MOVLB  8
1808C:  MOVWF  x74
1808E:  CLRF   x76
18090:  CLRF   x75
18092:  MOVLW  03
18094:  MOVWF  x77
18096:  CLRF   x79
18098:  CLRF   x78
1809A:  MOVLB  0
1809C:  RCALL  17DF2
....................    write_macro_line(59, 0, 4, 0); 
1809E:  MOVLW  3B
180A0:  MOVLB  8
180A2:  MOVWF  x74
180A4:  CLRF   x76
180A6:  CLRF   x75
180A8:  MOVLW  04
180AA:  MOVWF  x77
180AC:  CLRF   x79
180AE:  CLRF   x78
180B0:  MOVLB  0
180B2:  RCALL  17DF2
....................    write_macro_line(59, 0, 5, 0); 
180B4:  MOVLW  3B
180B6:  MOVLB  8
180B8:  MOVWF  x74
180BA:  CLRF   x76
180BC:  CLRF   x75
180BE:  MOVLW  05
180C0:  MOVWF  x77
180C2:  CLRF   x79
180C4:  CLRF   x78
180C6:  MOVLB  0
180C8:  RCALL  17DF2
....................    write_macro_line(59, 0, 6, 0); 
180CA:  MOVLW  3B
180CC:  MOVLB  8
180CE:  MOVWF  x74
180D0:  CLRF   x76
180D2:  CLRF   x75
180D4:  MOVLW  06
180D6:  MOVWF  x77
180D8:  CLRF   x79
180DA:  CLRF   x78
180DC:  MOVLB  0
180DE:  RCALL  17DF2
....................    write_macro_line(59, 0, 7, 0); 
180E0:  MOVLW  3B
180E2:  MOVLB  8
180E4:  MOVWF  x74
180E6:  CLRF   x76
180E8:  CLRF   x75
180EA:  MOVLW  07
180EC:  MOVWF  x77
180EE:  CLRF   x79
180F0:  CLRF   x78
180F2:  MOVLB  0
180F4:  RCALL  17DF2
....................    write_macro_line(59, 0, 8, 0); 
180F6:  MOVLW  3B
180F8:  MOVLB  8
180FA:  MOVWF  x74
180FC:  CLRF   x76
180FE:  CLRF   x75
18100:  MOVLW  08
18102:  MOVWF  x77
18104:  CLRF   x79
18106:  CLRF   x78
18108:  MOVLB  0
1810A:  RCALL  17DF2
....................     
....................    write_macro_line(59, 0, 9, 0); 
1810C:  MOVLW  3B
1810E:  MOVLB  8
18110:  MOVWF  x74
18112:  CLRF   x76
18114:  CLRF   x75
18116:  MOVLW  09
18118:  MOVWF  x77
1811A:  CLRF   x79
1811C:  CLRF   x78
1811E:  MOVLB  0
18120:  RCALL  17DF2
....................    write_macro_line(59, 0, 10, 0); 
18122:  MOVLW  3B
18124:  MOVLB  8
18126:  MOVWF  x74
18128:  CLRF   x76
1812A:  CLRF   x75
1812C:  MOVLW  0A
1812E:  MOVWF  x77
18130:  CLRF   x79
18132:  CLRF   x78
18134:  MOVLB  0
18136:  RCALL  17DF2
....................    write_macro_line(59, 0, 11, 0); 
18138:  MOVLW  3B
1813A:  MOVLB  8
1813C:  MOVWF  x74
1813E:  CLRF   x76
18140:  CLRF   x75
18142:  MOVLW  0B
18144:  MOVWF  x77
18146:  CLRF   x79
18148:  CLRF   x78
1814A:  MOVLB  0
1814C:  RCALL  17DF2
....................    write_macro_line(59, 0, 12, 0); 
1814E:  MOVLW  3B
18150:  MOVLB  8
18152:  MOVWF  x74
18154:  CLRF   x76
18156:  CLRF   x75
18158:  MOVLW  0C
1815A:  MOVWF  x77
1815C:  CLRF   x79
1815E:  CLRF   x78
18160:  MOVLB  0
18162:  RCALL  17DF2
....................    write_macro_line(59, 0, 13, 0); 
18164:  MOVLW  3B
18166:  MOVLB  8
18168:  MOVWF  x74
1816A:  CLRF   x76
1816C:  CLRF   x75
1816E:  MOVLW  0D
18170:  MOVWF  x77
18172:  CLRF   x79
18174:  CLRF   x78
18176:  MOVLB  0
18178:  RCALL  17DF2
....................    write_macro_line(59, 0, 14, 0); 
1817A:  MOVLW  3B
1817C:  MOVLB  8
1817E:  MOVWF  x74
18180:  CLRF   x76
18182:  CLRF   x75
18184:  MOVLW  0E
18186:  MOVWF  x77
18188:  CLRF   x79
1818A:  CLRF   x78
1818C:  MOVLB  0
1818E:  RCALL  17DF2
....................    write_macro_line(59, 0, 15, 0); 
18190:  MOVLW  3B
18192:  MOVLB  8
18194:  MOVWF  x74
18196:  CLRF   x76
18198:  CLRF   x75
1819A:  MOVLW  0F
1819C:  MOVWF  x77
1819E:  CLRF   x79
181A0:  CLRF   x78
181A2:  MOVLB  0
181A4:  RCALL  17DF2
....................    write_macro_line(59, 0, 16, 0); 
181A6:  MOVLW  3B
181A8:  MOVLB  8
181AA:  MOVWF  x74
181AC:  CLRF   x76
181AE:  CLRF   x75
181B0:  MOVLW  10
181B2:  MOVWF  x77
181B4:  CLRF   x79
181B6:  CLRF   x78
181B8:  MOVLB  0
181BA:  RCALL  17DF2
181BC:  GOTO   181F4 (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
17A7E:  MOVLB  8
17A80:  CLRF   x74
....................     
....................    heartbeat(FALSE); 
17A82:  CLRF   xCA
17A84:  MOVLB  0
17A86:  CALL   5504
....................     
....................    while(mcc != CARRIAGE_RET){ 
17A8A:  MOVLB  8
17A8C:  MOVF   x74,W
17A8E:  SUBLW  0D
17A90:  BZ    17AB2
....................       if (kbhit(COM_A)) { 
17A92:  BTFSS  F9E.5
17A94:  BRA    17AB0
....................          mcc=fgetc(COM_A); 
17A96:  MOVLB  0
17A98:  CALL   0E24
17A9C:  MOVFF  01,874
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
17AA0:  DECFSZ 48,W
17AA2:  BRA    17AAE
17AA4:  MOVLB  8
17AA6:  MOVF   x74,W
17AA8:  MOVLB  0
17AAA:  CALL   ADB4
17AAE:  MOVLB  8
....................       } 
17AB0:  BRA    17A8C
....................    } 
....................     
....................    heartbeat(TRUE); 
17AB2:  MOVLW  01
17AB4:  MOVWF  xCA
17AB6:  MOVLB  0
17AB8:  CALL   5504
17ABC:  GOTO   17E7C (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
17E60:  MOVLB  8
17E62:  CLRF   x73
....................     
....................    macro_cmd = get_cmd(macro); 
17E64:  MOVFF  86B,874
17E68:  MOVLB  0
17E6A:  BRA    17A32
17E6C:  MOVFF  01,870
....................    if (macro_cmd == 35){  
17E70:  MOVLB  8
17E72:  MOVF   x70,W
17E74:  SUBLW  23
17E76:  BNZ   17E80
....................       macro_comment();        // # = 35 
17E78:  MOVLB  0
17E7A:  BRA    17A7E
....................    }else if(macro_cmd == 112){// 112 is p 
17E7C:  BRA    17F02
17E7E:  MOVLB  8
17E80:  MOVF   x70,W
17E82:  SUBLW  70
17E84:  BNZ   17EAC
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
17E86:  MOVLB  0
17E88:  BRA    17AC0
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
17E8A:  MOVFF  870,874
17E8E:  MOVFF  86B,875
17E92:  MOVFF  86D,877
17E96:  MOVFF  86C,876
17E9A:  MOVFF  86F,879
17E9E:  MOVFF  86E,878
17EA2:  BRA    17BC6
....................       valid_macro = TRUE; 
17EA4:  MOVLW  01
17EA6:  MOVLB  8
17EA8:  MOVWF  x73
....................    }else{ 
17EAA:  BRA    17F00
....................       if (macro_cmd != 0) { 
17EAC:  MOVF   x70,F
17EAE:  BZ    17ED6
....................          macro_arg = get_arg(); 
17EB0:  MOVLB  0
17EB2:  BRA    17D08
17EB4:  MOVFF  02,872
17EB8:  MOVFF  01,871
....................          if (macro_arg != 65535) valid_macro = TRUE; 
17EBC:  MOVLB  8
17EBE:  INCFSZ x71,W
17EC0:  BRA    17EC8
17EC2:  INCFSZ x72,W
17EC4:  BRA    17EC8
17EC6:  BRA    17ECE
17EC8:  MOVLW  01
17ECA:  MOVWF  x73
17ECC:  BRA    17ED4
....................          else return(macro_cmd); 
17ECE:  MOVFF  870,01
17ED2:  BRA    17F08
....................       }else return(macro_cmd); 
17ED4:  BRA    17EDC
17ED6:  MOVFF  870,01
17EDA:  BRA    17F08
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
17EDC:  MOVFF  870,874
17EE0:  MOVFF  872,876
17EE4:  MOVFF  871,875
17EE8:  MOVFF  86B,877
17EEC:  MOVFF  86D,879
17EF0:  MOVFF  86C,878
17EF4:  MOVLB  0
17EF6:  RCALL  17DF2
....................       return(macro_cmd); 
17EF8:  MOVLB  8
17EFA:  MOVFF  870,01
17EFE:  BRA    17F08
17F00:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
17F02:  MOVLB  8
17F04:  MOVFF  870,01
17F08:  MOVLB  0
17F0A:  GOTO   17F50 (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
17F0E:  MOVLB  8
17F10:  CLRF   x6A
17F12:  CLRF   x69
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
17F14:  CLRF   x65
17F16:  CLRF   x64
....................    valid_macro = TRUE; 
17F18:  MOVLW  01
17F1A:  MOVWF  x66
....................    macro_cmd = 1; 
17F1C:  MOVWF  x67
....................     
....................    init_ext_eeprom(); 
17F1E:  MOVLB  0
17F20:  CALL   FFE6
....................     
....................    fprintf(COM_A, ":"); 
17F24:  MOVLW  3A
17F26:  BTFSS  F9E.4
17F28:  BRA    17F26
17F2A:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
17F2C:  MOVLB  8
17F2E:  MOVF   x67,W
17F30:  SUBLW  3B
17F32:  BZ    17F96
17F34:  MOVF   x67,F
17F36:  BZ    17F96
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
17F38:  MOVFF  863,86B
17F3C:  MOVFF  865,86D
17F40:  MOVFF  864,86C
17F44:  MOVFF  86A,86F
17F48:  MOVFF  869,86E
17F4C:  MOVLB  0
17F4E:  BRA    17E60
17F50:  MOVFF  01,867
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
17F54:  MOVLB  8
17F56:  MOVF   x67,W
17F58:  SUBLW  70
17F5A:  BNZ   17F62
....................          count++; 
17F5C:  INCF   x69,F
17F5E:  BTFSC  FD8.2
17F60:  INCF   x6A,F
....................       } 
....................       if (macro_cmd != 35) ++line; 
17F62:  MOVF   x67,W
17F64:  SUBLW  23
17F66:  BZ    17F6E
17F68:  INCF   x64,F
17F6A:  BTFSC  FD8.2
17F6C:  INCF   x65,F
....................       if (macro_cmd != 59) printf("\r\n:"); 
17F6E:  MOVF   x67,W
17F70:  SUBLW  3B
17F72:  BZ    17F94
17F74:  MOVLW  E2
17F76:  MOVWF  FF6
17F78:  MOVLW  20
17F7A:  MOVWF  FF7
17F7C:  MOVLW  00
17F7E:  MOVWF  FF8
17F80:  CLRF   1B
17F82:  BTFSC  FF2.7
17F84:  BSF    1B.7
17F86:  BCF    FF2.7
17F88:  MOVLB  0
17F8A:  CALL   0E3A
17F8E:  BTFSC  1B.7
17F90:  BSF    FF2.7
17F92:  MOVLB  8
17F94:  BRA    17F2E
....................    }       
....................    if (macro_cmd == 0){ 
17F96:  MOVF   x67,F
17F98:  BNZ   1802E
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
17F9A:  MOVLW  E6
17F9C:  MOVWF  FF6
17F9E:  MOVLW  20
17FA0:  MOVWF  FF7
17FA2:  MOVLW  00
17FA4:  MOVWF  FF8
17FA6:  CLRF   1B
17FA8:  BTFSC  FF2.7
17FAA:  BSF    1B.7
17FAC:  BCF    FF2.7
17FAE:  MOVLB  0
17FB0:  CALL   0E3A
17FB4:  BTFSC  1B.7
17FB6:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
17FB8:  MOVLW  0E
17FBA:  MOVWF  FF6
17FBC:  MOVLW  21
17FBE:  MOVWF  FF7
17FC0:  MOVLW  00
17FC2:  MOVWF  FF8
17FC4:  CLRF   1B
17FC6:  BTFSC  FF2.7
17FC8:  BSF    1B.7
17FCA:  BCF    FF2.7
17FCC:  MOVLW  15
17FCE:  MOVLB  A
17FD0:  MOVWF  x18
17FD2:  MOVLB  0
17FD4:  CALL   1010
17FD8:  BTFSC  1B.7
17FDA:  BSF    FF2.7
17FDC:  MOVLW  10
17FDE:  MOVWF  FE9
17FE0:  MOVFF  865,8CE
17FE4:  MOVFF  864,8CD
17FE8:  CALL   8F24
17FEC:  MOVLW  26
17FEE:  MOVWF  FF6
17FF0:  MOVLW  21
17FF2:  MOVWF  FF7
17FF4:  MOVLW  00
17FF6:  MOVWF  FF8
17FF8:  CLRF   1B
17FFA:  BTFSC  FF2.7
17FFC:  BSF    1B.7
17FFE:  BCF    FF2.7
18000:  MOVLW  03
18002:  MOVLB  A
18004:  MOVWF  x18
18006:  MOVLB  0
18008:  CALL   1010
1800C:  BTFSC  1B.7
1800E:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
18010:  MOVLW  2A
18012:  MOVWF  FF6
18014:  MOVLW  21
18016:  MOVWF  FF7
18018:  MOVLW  00
1801A:  MOVWF  FF8
1801C:  CLRF   1B
1801E:  BTFSC  FF2.7
18020:  BSF    1B.7
18022:  BCF    FF2.7
18024:  CALL   0E3A
18028:  BTFSC  1B.7
1802A:  BSF    FF2.7
1802C:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
1802E:  MOVLW  0D
18030:  BTFSS  F9E.4
18032:  BRA    18030
18034:  MOVWF  FAD
18036:  MOVLW  0A
18038:  BTFSS  F9E.4
1803A:  BRA    18038
1803C:  MOVWF  FAD
1803E:  MOVLB  0
18040:  GOTO   181DC (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
181FE:  BCF    FD8.0
18200:  MOVLB  8
18202:  RLCF   x68,W
18204:  CLRF   03
18206:  ADDLW  CD
18208:  MOVWF  FE9
1820A:  MOVLW  07
1820C:  ADDWFC 03,W
1820E:  MOVWF  FEA
18210:  MOVFF  FEC,871
18214:  MOVF   FED,F
18216:  MOVFF  FEF,870
1821A:  MOVFF  86A,9EA
1821E:  MOVFF  869,9E9
18222:  MOVLB  9
18224:  CLRF   xEC
18226:  MOVLW  03
18228:  MOVWF  xEB
1822A:  MOVLB  0
1822C:  CALL   5C18
18230:  MOVF   01,W
18232:  MOVLB  8
18234:  ADDWF  x70,W
18236:  MOVWF  x6B
18238:  MOVF   02,W
1823A:  ADDWFC x71,W
1823C:  MOVWF  x6C
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
1823E:  MOVFF  86C,8A9
18242:  MOVFF  86B,8A8
18246:  MOVLB  0
18248:  CALL   102F0
1824C:  MOVFF  01,86D
....................    ++addr; 
18250:  MOVLB  8
18252:  INCF   x6B,F
18254:  BTFSC  FD8.2
18256:  INCF   x6C,F
....................    macro_arg = read16_ext_eeprom(addr); 
18258:  MOVFF  86C,8A0
1825C:  MOVFF  86B,89F
18260:  MOVLB  0
18262:  CALL   10404
18266:  MOVFF  02,86F
1826A:  MOVFF  01,86E
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
1826E:  MOVLB  8
18270:  MOVF   x6D,W
18272:  BTFSS  F9E.4
18274:  BRA    18272
18276:  MOVWF  FAD
18278:  MOVLW  10
1827A:  MOVWF  FE9
1827C:  CLRF   1B
1827E:  BTFSC  FF2.7
18280:  BSF    1B.7
18282:  BCF    FF2.7
18284:  MOVFF  86F,A19
18288:  MOVFF  86E,A18
1828C:  MOVLB  0
1828E:  CALL   1192
18292:  BTFSC  1B.7
18294:  BSF    FF2.7
18296:  MOVLW  0D
18298:  BTFSS  F9E.4
1829A:  BRA    18298
1829C:  MOVWF  FAD
1829E:  MOVLW  0A
182A0:  BTFSS  F9E.4
182A2:  BRA    182A0
182A4:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
182A6:  MOVLB  8
182A8:  MOVFF  86D,01
182AC:  MOVLB  0
182AE:  GOTO   182E2 (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
13EA6:  BCF    FD8.0
13EA8:  MOVLB  8
13EAA:  RLCF   x94,W
13EAC:  CLRF   03
13EAE:  ADDLW  CD
13EB0:  MOVWF  FE9
13EB2:  MOVLW  07
13EB4:  ADDWFC 03,W
13EB6:  MOVWF  FEA
13EB8:  MOVFF  FEC,89D
13EBC:  MOVF   FED,F
13EBE:  MOVFF  FEF,89C
13EC2:  MOVFF  896,9EA
13EC6:  MOVFF  895,9E9
13ECA:  MOVLB  9
13ECC:  CLRF   xEC
13ECE:  MOVLW  03
13ED0:  MOVWF  xEB
13ED2:  MOVLB  0
13ED4:  CALL   5C18
13ED8:  MOVF   01,W
13EDA:  MOVLB  8
13EDC:  ADDWF  x9C,W
13EDE:  MOVWF  x97
13EE0:  MOVF   02,W
13EE2:  ADDWFC x9D,W
13EE4:  MOVWF  x98
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
13EE6:  MOVFF  898,8A9
13EEA:  MOVFF  897,8A8
13EEE:  MOVLB  0
13EF0:  CALL   102F0
13EF4:  MOVFF  01,899
....................    ++addr; 
13EF8:  MOVLB  8
13EFA:  INCF   x97,F
13EFC:  BTFSC  FD8.2
13EFE:  INCF   x98,F
....................    macro_arg = read16_ext_eeprom(addr); 
13F00:  MOVFF  898,8A0
13F04:  MOVFF  897,89F
13F08:  MOVLB  0
13F0A:  CALL   10404
13F0E:  MOVFF  02,89B
13F12:  MOVFF  01,89A
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
13F16:  MOVLB  8
13F18:  MOVF   x99,W
13F1A:  BTFSS  F9E.4
13F1C:  BRA    13F1A
13F1E:  MOVWF  FAD
13F20:  MOVLW  10
13F22:  MOVWF  FE9
13F24:  CLRF   1B
13F26:  BTFSC  FF2.7
13F28:  BSF    1B.7
13F2A:  BCF    FF2.7
13F2C:  MOVFF  89B,A19
13F30:  MOVFF  89A,A18
13F34:  MOVLB  0
13F36:  CALL   1192
13F3A:  BTFSC  1B.7
13F3C:  BSF    FF2.7
13F3E:  MOVLW  0D
13F40:  BTFSS  F9E.4
13F42:  BRA    13F40
13F44:  MOVWF  FAD
13F46:  MOVLW  0A
13F48:  BTFSS  F9E.4
13F4A:  BRA    13F48
13F4C:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
13F4E:  MOVLB  8
13F50:  MOVFF  899,01
13F54:  MOVLB  0
13F56:  GOTO   1472E (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
1034A:  BCF    FD8.0
1034C:  MOVLB  8
1034E:  RLCF   x92,W
10350:  CLRF   03
10352:  ADDLW  F7
10354:  MOVWF  FE9
10356:  MOVLW  07
10358:  ADDWFC 03,W
1035A:  MOVWF  FEA
1035C:  MOVFF  FEC,89B
10360:  MOVF   FED,F
10362:  MOVFF  FEF,89A
10366:  MOVFF  896,9EA
1036A:  MOVFF  895,9E9
1036E:  MOVLB  9
10370:  CLRF   xEC
10372:  MOVLW  32
10374:  MOVWF  xEB
10376:  MOVLB  0
10378:  CALL   5C18
1037C:  MOVF   01,W
1037E:  MOVLB  8
10380:  ADDWF  x9A,W
10382:  MOVWF  x97
10384:  MOVF   02,W
10386:  ADDWFC x9B,W
10388:  MOVWF  x98
....................     
....................    int i = 0; 
1038A:  CLRF   x99
....................    for(i = 0; i < 50; i++){ 
1038C:  CLRF   x99
1038E:  MOVF   x99,W
10390:  SUBLW  31
10392:  BNC   103A8
....................       string_arg[i] = 0; 
10394:  CLRF   03
10396:  MOVF   x99,W
10398:  ADDLW  21
1039A:  MOVWF  FE9
1039C:  MOVLW  08
1039E:  ADDWFC 03,W
103A0:  MOVWF  FEA
103A2:  CLRF   FEF
103A4:  INCF   x99,F
103A6:  BRA    1038E
....................    }  
....................    for(i = 0; i < 50; i++){ 
103A8:  CLRF   x99
103AA:  MOVF   x99,W
103AC:  SUBLW  31
103AE:  BNC   10400
....................       string_arg[i] = read_ext_eeprom(addr + i); 
103B0:  CLRF   03
103B2:  MOVF   x99,W
103B4:  ADDLW  21
103B6:  MOVWF  01
103B8:  MOVLW  08
103BA:  ADDWFC 03,F
103BC:  MOVFF  01,89A
103C0:  MOVFF  03,89B
103C4:  MOVF   x99,W
103C6:  ADDWF  x97,W
103C8:  MOVWF  x9C
103CA:  MOVLW  00
103CC:  ADDWFC x98,W
103CE:  MOVWF  x9D
103D0:  MOVWF  xA9
103D2:  MOVFF  89C,8A8
103D6:  MOVLB  0
103D8:  RCALL  102F0
103DA:  MOVFF  89B,FEA
103DE:  MOVFF  89A,FE9
103E2:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
103E6:  CLRF   03
103E8:  MOVLB  8
103EA:  MOVF   x99,W
103EC:  ADDLW  21
103EE:  MOVWF  FE9
103F0:  MOVLW  08
103F2:  ADDWFC 03,W
103F4:  MOVWF  FEA
103F6:  MOVF   FEF,F
103F8:  BNZ   103FC
....................          break; 
103FA:  BRA    10400
....................       } 
103FC:  INCF   x99,F
103FE:  BRA    103AA
....................    }   
10400:  MOVLB  0
10402:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
182B2:  MOVLB  8
182B4:  CLRF   x67
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
182B6:  CLRF   x65
182B8:  CLRF   x64
....................    macro_cmd = 1; 
182BA:  MOVLW  01
182BC:  MOVWF  x66
....................     
....................    init_ext_eeprom(); 
182BE:  MOVLB  0
182C0:  CALL   FFE6
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
182C4:  MOVLB  8
182C6:  MOVF   x65,W
182C8:  SUBLW  03
182CA:  BNC   18312
182CC:  MOVF   x66,W
182CE:  SUBLW  3B
182D0:  BZ    18312
....................       macro_cmd = read_macro_line(macro, line); 
182D2:  MOVFF  863,868
182D6:  MOVFF  865,86A
182DA:  MOVFF  864,869
182DE:  MOVLB  0
182E0:  BRA    181FE
182E2:  MOVFF  01,866
....................       if(macro_cmd == 'p'){ 
182E6:  MOVLB  8
182E8:  MOVF   x66,W
182EA:  SUBLW  70
182EC:  BNZ   1830A
....................          read_macro_line_string(macro,line,count); 
182EE:  MOVFF  863,892
182F2:  MOVFF  865,894
182F6:  MOVFF  864,893
182FA:  CLRF   x96
182FC:  MOVFF  867,895
18300:  MOVLB  0
18302:  CALL   1034A
....................          count++; 
18306:  MOVLB  8
18308:  INCF   x67,F
....................       } 
....................       ++line; 
1830A:  INCF   x64,F
1830C:  BTFSC  FD8.2
1830E:  INCF   x65,F
18310:  BRA    182C6
....................    } 
18312:  MOVLB  0
18314:  GOTO   18334 (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0D040:  MOVLB  8
0D042:  CLRF   xA2
0D044:  CLRF   xA1
0D046:  MOVF   xA2,W
0D048:  SUBWF  xA0,W
0D04A:  BNC   D072
0D04C:  BNZ   D054
0D04E:  MOVF   x9F,W
0D050:  SUBWF  xA1,W
0D052:  BC    D072
....................       delay_ms(1000); 
0D054:  MOVLW  04
0D056:  MOVWF  xA3
0D058:  MOVLW  FA
0D05A:  MOVLB  9
0D05C:  MOVWF  xC9
0D05E:  MOVLB  0
0D060:  CALL   2898
0D064:  MOVLB  8
0D066:  DECFSZ xA3,F
0D068:  BRA    D058
0D06A:  INCF   xA1,F
0D06C:  BTFSC  FD8.2
0D06E:  INCF   xA2,F
0D070:  BRA    D046
....................    }  
0D072:  MOVLB  0
0D074:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0D008:  BCF    FD8.0
0D00A:  MOVLB  7
0D00C:  RLCF   x3C,W
0D00E:  CLRF   03
0D010:  ADDLW  92
0D012:  MOVWF  FE9
0D014:  MOVLW  07
0D016:  ADDWFC 03,W
0D018:  MOVWF  FEA
0D01A:  MOVFF  FEC,8A1
0D01E:  MOVF   FED,F
0D020:  MOVFF  FEF,8A0
0D024:  MOVLB  8
0D026:  DECFSZ xA0,W
0D028:  BRA    D034
0D02A:  MOVF   xA1,F
0D02C:  BNZ   D034
....................    { 
....................       macro_status = 'e'; 
0D02E:  MOVLW  65
0D030:  MOVWF  x9F
....................    } 
0D032:  BRA    D038
....................    else 
....................    { 
....................       macro_status = 'a'; 
0D034:  MOVLW  61
0D036:  MOVWF  x9F
....................    } 
....................    return(macro_status); 
0D038:  MOVFF  89F,01
0D03C:  MOVLB  0
0D03E:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
13542:  DECFSZ 41,W
13544:  BRA    13558
13546:  MOVF   42,F
13548:  BNZ   13558
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
1354A:  MOVLW  01
1354C:  MOVLB  8
1354E:  MOVWF  x9F
13550:  MOVWF  xA0
13552:  MOVLB  0
13554:  RCALL  1340C
....................    } 
13556:  BRA    13582
....................    else if(nv_det_type==2 || nv_det_type==3) 
13558:  MOVF   41,W
1355A:  SUBLW  02
1355C:  BNZ   13562
1355E:  MOVF   42,F
13560:  BZ    1356C
13562:  MOVF   41,W
13564:  SUBLW  03
13566:  BNZ   13582
13568:  MOVF   42,F
1356A:  BNZ   13582
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
1356C:  MOVLB  8
1356E:  CLRF   xA0
13570:  MOVLW  C8
13572:  MOVWF  x9F
13574:  MOVLW  01
13576:  MOVWF  xA1
13578:  MOVWF  xA2
1357A:  CLRF   xA3
1357C:  MOVLB  0
1357E:  CALL   FCFC
....................    } 
13582:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
12460:  DECFSZ 41,W
12462:  BRA    1247E
12464:  MOVF   42,F
12466:  BNZ   1247E
....................       cmd = macro_cmd; 
12468:  MOVFF  89F,43
....................       arg = macro_arg; 
1246C:  CLRF   47
1246E:  CLRF   46
12470:  MOVFF  8A1,45
12474:  MOVFF  8A0,44
....................       det_cmd(); 
12478:  CALL   F104
....................    } 
1247C:  BRA    12498
....................    else if(nv_det_type==2 || nv_det_type==3) { 
1247E:  MOVF   41,W
12480:  SUBLW  02
12482:  BNZ   12488
12484:  MOVF   42,F
12486:  BZ    12492
12488:  MOVF   41,W
1248A:  SUBLW  03
1248C:  BNZ   12498
1248E:  MOVF   42,F
12490:  BNZ   12498
....................       set_heaters(macro_arg); 
12492:  MOVFF  8A0,8A2
12496:  RCALL  123EC
....................    } 
12498:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
1249A:  DECFSZ 41,W
1249C:  BRA    124B8
1249E:  MOVF   42,F
124A0:  BNZ   124B8
....................       cmd = macro_cmd; 
124A2:  MOVFF  89F,43
....................       arg = macro_arg; 
124A6:  CLRF   47
124A8:  CLRF   46
124AA:  MOVFF  8A1,45
124AE:  MOVFF  8A0,44
....................       det_cmd(); 
124B2:  CALL   F104
....................    } 
124B6:  BRA    124D8
....................    else if(nv_det_type==2 || nv_det_type==3) { 
124B8:  MOVF   41,W
124BA:  SUBLW  02
124BC:  BNZ   124C2
124BE:  MOVF   42,F
124C0:  BZ    124CC
124C2:  MOVF   41,W
124C4:  SUBLW  03
124C6:  BNZ   124D8
124C8:  MOVF   42,F
124CA:  BNZ   124D8
....................       set_LED(macro_arg); 
124CC:  MOVFF  8A1,8A3
124D0:  MOVFF  8A0,8A2
124D4:  CALL   F5BA
....................    } 
124D8:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13ABA:  MOVLW  65
13ABC:  MOVLB  8
13ABE:  MOVWF  x9E
....................     
....................    addr = macro_address[macro] + (line*3); 
13AC0:  BCF    FD8.0
13AC2:  RLCF   x94,W
13AC4:  CLRF   03
13AC6:  ADDLW  CD
13AC8:  MOVWF  FE9
13ACA:  MOVLW  07
13ACC:  ADDWFC 03,W
13ACE:  MOVWF  FEA
13AD0:  MOVFF  FEC,8A0
13AD4:  MOVF   FED,F
13AD6:  MOVFF  FEF,89F
13ADA:  MOVFF  896,9EA
13ADE:  MOVFF  895,9E9
13AE2:  MOVLB  9
13AE4:  CLRF   xEC
13AE6:  MOVLW  03
13AE8:  MOVWF  xEB
13AEA:  MOVLB  0
13AEC:  CALL   5C18
13AF0:  MOVF   01,W
13AF2:  MOVLB  8
13AF4:  ADDWF  x9F,W
13AF6:  MOVWF  x99
13AF8:  MOVF   02,W
13AFA:  ADDWFC xA0,W
13AFC:  MOVWF  x9A
....................  
....................    init_ext_eeprom(); 
13AFE:  MOVLB  0
13B00:  CALL   FFE6
....................    macro_cmd = read_ext_eeprom(addr); 
13B04:  MOVFF  89A,8A9
13B08:  MOVFF  899,8A8
13B0C:  CALL   102F0
13B10:  MOVFF  01,89B
....................    ++addr; 
13B14:  MOVLB  8
13B16:  INCF   x99,F
13B18:  BTFSC  FD8.2
13B1A:  INCF   x9A,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13B1C:  MOVFF  89A,8A0
13B20:  MOVFF  899,89F
13B24:  MOVLB  0
13B26:  CALL   10404
13B2A:  MOVFF  02,89D
13B2E:  MOVFF  01,89C
....................    //} 
....................    heartbeat(TRUE); 
13B32:  MOVLW  01
13B34:  MOVLB  8
13B36:  MOVWF  xCA
13B38:  MOVLB  0
13B3A:  CALL   5504
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13B3E:  MOVF   2F,F
13B40:  BTFSS  FD8.2
13B42:  BRA    13DEE
13B44:  MOVF   30,F
13B46:  BTFSS  FD8.2
13B48:  BRA    13DEE
....................       switch(macro_cmd) 
13B4A:  MOVLW  2B
13B4C:  MOVLB  8
13B4E:  SUBWF  x9B,W
13B50:  ADDLW  BA
13B52:  BTFSC  FD8.0
13B54:  BRA    13DF0
13B56:  ADDLW  46
13B58:  MOVLB  0
13B5A:  GOTO   13DFA
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
13B5E:  CALL   1227A
....................             store_rel_data(); 
13B62:  CALL   122DE
....................             macro_status = 'a'; 
13B66:  MOVLW  61
13B68:  MOVLB  8
13B6A:  MOVWF  x9E
....................             break; 
13B6C:  BRA    13DF0
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
13B6E:  MOVLW  08
13B70:  MOVWF  FEA
13B72:  MOVLW  21
13B74:  MOVWF  FE9
13B76:  CALL   78DC
13B7A:  MOVLW  0D
13B7C:  BTFSS  F9E.4
13B7E:  BRA    13B7C
13B80:  MOVWF  FAD
13B82:  MOVLW  0A
13B84:  BTFSS  F9E.4
13B86:  BRA    13B84
13B88:  MOVWF  FAD
....................             macro_status = 'a'; 
13B8A:  MOVLW  61
13B8C:  MOVLB  8
13B8E:  MOVWF  x9E
....................             break; 
13B90:  BRA    13DF0
....................          case 'C' : 
....................             calc_abs_data(); 
13B92:  CALL   1227A
....................             break; 
13B96:  MOVLB  8
13B98:  BRA    13DF0
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
13B9A:  MOVFF  89D,8A0
13B9E:  MOVFF  89C,89F
13BA2:  CALL   D040
....................             macro_status = 'a'; 
13BA6:  MOVLW  61
13BA8:  MOVLB  8
13BAA:  MOVWF  x9E
....................             break; 
13BAC:  BRA    13DF0
....................          case 'F' : macro_flag = macro_arg; 
13BAE:  MOVFF  89D,320
13BB2:  MOVFF  89C,31F
....................                     macro_status = 'a'; 
13BB6:  MOVLW  61
13BB8:  MOVLB  8
13BBA:  MOVWF  x9E
....................             break ; 
13BBC:  BRA    13DF0
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
13BBE:  MOVFF  89C,2D1
....................                     macro_status = 'a'; 
13BC2:  MOVLW  61
13BC4:  MOVLB  8
13BC6:  MOVWF  x9E
....................             break ; 
13BC8:  BRA    13DF0
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
13BCA:  MOVFF  89B,89F
13BCE:  MOVFF  89D,8A1
13BD2:  MOVFF  89C,8A0
13BD6:  CALL   12460
....................                     macro_status = 'a'; 
13BDA:  MOVLW  61
13BDC:  MOVLB  8
13BDE:  MOVWF  x9E
....................             break; 
13BE0:  BRA    13DF0
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
13BE2:  MOVFF  89B,89F
13BE6:  MOVFF  89D,8A1
13BEA:  MOVFF  89C,8A0
13BEE:  CALL   12460
....................                     macro_status = 'a'; 
13BF2:  MOVLW  61
13BF4:  MOVLB  8
13BF6:  MOVWF  x9E
....................             break; 
13BF8:  BRA    13DF0
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
13BFA:  MOVFF  89D,8B9
13BFE:  MOVFF  89C,8B8
13C02:  MOVLB  8
13C04:  CLRF   xBB
13C06:  MOVLW  64
13C08:  MOVWF  xBA
13C0A:  MOVLB  0
13C0C:  CALL   2C5C
13C10:  MOVFF  02,749
13C14:  MOVFF  01,748
....................                     macro_status = 'a'; 
13C18:  MOVLW  61
13C1A:  MOVLB  8
13C1C:  MOVWF  x9E
....................             break;    
13C1E:  BRA    13DF0
....................          case 'l' : LightTargetFlag = 1; 
13C20:  MOVLW  01
13C22:  MOVLB  2
13C24:  MOVWF  xD5
....................                     set_light(macro_cmd,macro_arg); 
13C26:  MOVFF  89B,89F
13C2A:  MOVFF  89D,8A1
13C2E:  MOVFF  89C,8A0
13C32:  MOVLB  0
13C34:  CALL   1249A
....................                     delay_ms(10000); 
13C38:  MOVLW  28
13C3A:  MOVLB  8
13C3C:  MOVWF  x9F
13C3E:  MOVLW  FA
13C40:  MOVLB  9
13C42:  MOVWF  xC9
13C44:  MOVLB  0
13C46:  CALL   2898
13C4A:  MOVLB  8
13C4C:  DECFSZ x9F,F
13C4E:  BRA    13C3E
....................                     macro_status = 'a'; 
13C50:  MOVLW  61
13C52:  MOVWF  x9E
....................             break;        
13C54:  BRA    13DF0
....................          case 'L' : LightTargetFlag = 0; 
13C56:  MOVLB  2
13C58:  CLRF   xD5
....................                     set_light(macro_cmd,macro_arg); 
13C5A:  MOVFF  89B,89F
13C5E:  MOVFF  89D,8A1
13C62:  MOVFF  89C,8A0
13C66:  MOVLB  0
13C68:  CALL   1249A
....................                     macro_status = 'a'; 
13C6C:  MOVLW  61
13C6E:  MOVLB  8
13C70:  MOVWF  x9E
....................             break; 
13C72:  BRA    13DF0
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
13C74:  MOVFF  89B,43
....................                     arg = macro_arg; 
13C78:  CLRF   47
13C7A:  CLRF   46
13C7C:  MOVFF  89D,45
13C80:  MOVFF  89C,44
....................                     det_cmd(); 
13C84:  CALL   F104
....................                     macro_status = 'a'; 
13C88:  MOVLW  61
13C8A:  MOVLB  8
13C8C:  MOVWF  x9E
....................             break ; 
13C8E:  BRA    13DF0
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
13C90:  MOVLB  8
13C92:  DECFSZ x9C,W
13C94:  BRA    13CA0
13C96:  MOVF   x9D,F
13C98:  BNZ   13CA0
13C9A:  MOVLB  0
13C9C:  RCALL  13542
13C9E:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
13CA0:  MOVF   x9C,W
13CA2:  SUBLW  02
13CA4:  BNZ   13CB6
13CA6:  MOVF   x9D,F
13CA8:  BNZ   13CB6
13CAA:  MOVLW  01
13CAC:  MOVWF  x9F
13CAE:  MOVWF  xA0
13CB0:  MOVLB  0
13CB2:  RCALL  1370E
13CB4:  MOVLB  8
....................                     macro_status = 'a'; 
13CB6:  MOVLW  61
13CB8:  MOVWF  x9E
....................             break ;  
13CBA:  BRA    13DF0
....................          case 'T' : det_temp(); 
13CBC:  RCALL  138CE
....................                     macro_status = 'a'; 
13CBE:  MOVLW  61
13CC0:  MOVLB  8
13CC2:  MOVWF  x9E
....................             break; 
13CC4:  BRA    13DF0
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
13CC6:  MOVLW  01
13CC8:  MOVLB  7
13CCA:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
13CCC:  MOVLB  8
13CCE:  CLRF   xA4
13CD0:  CLRF   xA5
13CD2:  CLRF   xA9
13CD4:  CLRF   xA8
13CD6:  MOVFF  89D,8A7
13CDA:  MOVFF  89C,8A6
13CDE:  MOVWF  xAA
13CE0:  MOVLB  0
13CE2:  CALL   9CB8
....................                     macro_status=step_err_status(); 
13CE6:  CALL   D008
13CEA:  MOVFF  01,89E
....................             break; 
13CEE:  MOVLB  8
13CF0:  BRA    13DF0
....................          case '-' : motor=1; 
13CF2:  MOVLW  01
13CF4:  MOVLB  7
13CF6:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
13CF8:  MOVLB  8
13CFA:  CLRF   xA4
13CFC:  MOVWF  xA5
13CFE:  CLRF   xA9
13D00:  CLRF   xA8
13D02:  MOVFF  89D,8A7
13D06:  MOVFF  89C,8A6
13D0A:  MOVWF  xAA
13D0C:  MOVLB  0
13D0E:  CALL   9CB8
....................                     macro_status=step_err_status(); 
13D12:  CALL   D008
13D16:  MOVFF  01,89E
....................             break; 
13D1A:  MOVLB  8
13D1C:  BRA    13DF0
....................          case 'G' : motor=0; 
13D1E:  MOVLB  7
13D20:  CLRF   x3C
....................                     align(0); 
13D22:  MOVLB  8
13D24:  CLRF   x9F
13D26:  MOVLB  0
13D28:  CALL   A7F4
....................                     macro_status=step_err_status(); 
13D2C:  CALL   D008
13D30:  MOVFF  01,89E
....................             break ;           
13D34:  MOVLB  8
13D36:  BRA    13DF0
....................          case 'P' : motor=0; 
13D38:  MOVLB  7
13D3A:  CLRF   x3C
....................                     move_motor(1,0,macro_arg,1);   
13D3C:  MOVLW  01
13D3E:  MOVLB  8
13D40:  MOVWF  xA4
13D42:  CLRF   xA5
13D44:  CLRF   xA9
13D46:  CLRF   xA8
13D48:  MOVFF  89D,8A7
13D4C:  MOVFF  89C,8A6
13D50:  MOVWF  xAA
13D52:  MOVLB  0
13D54:  CALL   9CB8
....................                     macro_status=step_err_status(); 
13D58:  CALL   D008
13D5C:  MOVFF  01,89E
....................             break; 
13D60:  MOVLB  8
13D62:  BRA    13DF0
....................          case 'Q' : motor=0; 
13D64:  MOVLB  7
13D66:  CLRF   x3C
....................                     move_motor(0,0,macro_arg,1); 
13D68:  MOVLB  8
13D6A:  CLRF   xA4
13D6C:  CLRF   xA5
13D6E:  CLRF   xA9
13D70:  CLRF   xA8
13D72:  MOVFF  89D,8A7
13D76:  MOVFF  89C,8A6
13D7A:  MOVLW  01
13D7C:  MOVWF  xAA
13D7E:  MOVLB  0
13D80:  CALL   9CB8
....................                     macro_status=step_err_status(); 
13D84:  CALL   D008
13D88:  MOVFF  01,89E
....................             break; 
13D8C:  MOVLB  8
13D8E:  BRA    13DF0
....................          case 'R' : motor=0; 
13D90:  MOVLB  7
13D92:  CLRF   x3C
....................                     move_motor(0,1,macro_arg,1); 
13D94:  MOVLB  8
13D96:  CLRF   xA4
13D98:  MOVLW  01
13D9A:  MOVWF  xA5
13D9C:  CLRF   xA9
13D9E:  CLRF   xA8
13DA0:  MOVFF  89D,8A7
13DA4:  MOVFF  89C,8A6
13DA8:  MOVWF  xAA
13DAA:  MOVLB  0
13DAC:  CALL   9CB8
....................                     macro_status=step_err_status(); 
13DB0:  CALL   D008
13DB4:  MOVFF  01,89E
....................             break; 
13DB8:  MOVLB  8
13DBA:  BRA    13DF0
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
13DBC:  MOVLB  8
13DBE:  DECFSZ x9C,W
13DC0:  BRA    13DD0
13DC2:  MOVF   x9D,F
13DC4:  BNZ   13DD0
13DC6:  MOVLB  0
13DC8:  CALL   D076
13DCC:  BRA    13DDE
13DCE:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
13DD0:  MOVF   x9C,F
13DD2:  BNZ   13DE0
13DD4:  MOVF   x9D,F
13DD6:  BNZ   13DE0
13DD8:  MOVLB  0
13DDA:  CALL   D09A
13DDE:  MOVLB  8
....................                     macro_status = 'a'; 
13DE0:  MOVLW  61
13DE2:  MOVWF  x9E
....................             break; 
13DE4:  BRA    13DF0
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
13DE6:  MOVLW  66
13DE8:  MOVLB  8
13DEA:  MOVWF  x9E
....................             break ; 
13DEC:  BRA    13DF0
13DEE:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
13DF0:  MOVFF  89E,01
13DF4:  MOVLB  0
13DF6:  GOTO   146F6 (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
14552:  MOVLW  65
14554:  MOVLB  8
14556:  MOVWF  x84
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
14558:  BCF    FD8.0
1455A:  RLCF   x7A,W
1455C:  CLRF   03
1455E:  ADDLW  CD
14560:  MOVWF  FE9
14562:  MOVLW  07
14564:  ADDWFC 03,W
14566:  MOVWF  FEA
14568:  MOVFF  FEC,893
1456C:  MOVF   FED,F
1456E:  MOVFF  FEF,892
14572:  MOVFF  87C,03
14576:  MOVFF  87B,FE9
1457A:  MOVFF  87C,FEA
1457E:  MOVFF  FEC,9EA
14582:  MOVF   FED,F
14584:  MOVFF  FEF,9E9
14588:  MOVLB  9
1458A:  CLRF   xEC
1458C:  MOVLW  03
1458E:  MOVWF  xEB
14590:  MOVLB  0
14592:  CALL   5C18
14596:  MOVF   01,W
14598:  MOVLB  8
1459A:  ADDWF  x92,W
1459C:  MOVWF  x7F
1459E:  MOVF   02,W
145A0:  ADDWFC x93,W
145A2:  MOVWF  x80
....................  
....................    init_ext_eeprom(); 
145A4:  MOVLB  0
145A6:  CALL   FFE6
....................    macro_cmd = read_ext_eeprom(addr); 
145AA:  MOVFF  880,8A9
145AE:  MOVFF  87F,8A8
145B2:  CALL   102F0
145B6:  MOVFF  01,881
....................    ++addr; 
145BA:  MOVLB  8
145BC:  INCF   x7F,F
145BE:  BTFSC  FD8.2
145C0:  INCF   x80,F
....................    if(macro_cmd == 'p'){ 
145C2:  MOVF   x81,W
145C4:  SUBLW  70
145C6:  BNZ   145EC
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
145C8:  MOVFF  87A,892
145CC:  MOVFF  87C,894
145D0:  MOVFF  87B,893
145D4:  MOVFF  854,896
145D8:  MOVFF  853,895
145DC:  MOVLB  0
145DE:  CALL   1034A
....................       count1++; 
145E2:  MOVLB  8
145E4:  INCF   x53,F
145E6:  BTFSC  FD8.2
145E8:  INCF   x54,F
....................    }else{ 
145EA:  BRA    14604
....................    macro_arg = read16_ext_eeprom(addr); 
145EC:  MOVFF  880,8A0
145F0:  MOVFF  87F,89F
145F4:  MOVLB  0
145F6:  CALL   10404
145FA:  MOVFF  02,883
145FE:  MOVFF  01,882
14602:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
14604:  MOVLW  01
14606:  MOVWF  xCA
14608:  MOVLB  0
1460A:  CALL   5504
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
1460E:  MOVF   2F,F
14610:  BTFSS  FD8.2
14612:  BRA    14A60
14614:  MOVF   30,F
14616:  BTFSS  FD8.2
14618:  BRA    14A60
....................       switch(macro_cmd){ 
1461A:  MOVLW  2B
1461C:  MOVLB  8
1461E:  SUBWF  x81,W
14620:  ADDLW  B8
14622:  BTFSC  FD8.0
14624:  BRA    14A5C
14626:  ADDLW  48
14628:  MOVLB  0
1462A:  GOTO   14D26
....................          case 'A' : 
....................             calc_abs_data(); 
1462E:  CALL   1227A
....................             store_rel_data(); 
14632:  CALL   122DE
....................             macro_status = 'a'; 
14636:  MOVLW  61
14638:  MOVLB  8
1463A:  MOVWF  x84
....................             break; 
1463C:  BRA    14A5C
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
1463E:  MOVLW  08
14640:  MOVWF  FEA
14642:  MOVLW  21
14644:  MOVWF  FE9
14646:  CALL   78DC
1464A:  MOVLW  0D
1464C:  BTFSS  F9E.4
1464E:  BRA    1464C
14650:  MOVWF  FAD
14652:  MOVLW  0A
14654:  BTFSS  F9E.4
14656:  BRA    14654
14658:  MOVWF  FAD
....................             macro_status = 'a'; 
1465A:  MOVLW  61
1465C:  MOVLB  8
1465E:  MOVWF  x84
....................             break; 
14660:  BRA    14A5C
....................          case 'C' : 
....................             calc_abs_data(); 
14662:  CALL   1227A
....................             break; 
14666:  MOVLB  8
14668:  BRA    14A5C
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
1466A:  MOVLB  8
1466C:  CLRF   x88
1466E:  CLRF   x87
14670:  CLRF   x86
14672:  CLRF   x85
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
14674:  MOVFF  87C,03
14678:  MOVFF  87B,FE9
1467C:  MOVFF  87C,FEA
14680:  MOVLW  01
14682:  ADDWF  FEE,F
14684:  BNC   14688
14686:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
14688:  MOVFF  87B,FE9
1468C:  MOVFF  87C,FEA
14690:  CLRF   x8C
14692:  CLRF   x8B
14694:  MOVFF  FEC,88A
14698:  MOVF   FED,F
1469A:  MOVFF  FEF,889
1469E:  CLRF   x90
146A0:  CLRF   x8F
146A2:  CLRF   x8E
146A4:  CLRF   x8D
....................                    
....................                   while(count < macro_arg){ 
146A6:  MOVF   x88,F
146A8:  BTFSS  FD8.2
146AA:  BRA    147E6
146AC:  MOVF   x87,F
146AE:  BTFSS  FD8.2
146B0:  BRA    147E6
146B2:  MOVF   x86,W
146B4:  SUBWF  x83,W
146B6:  BTFSS  FD8.0
146B8:  BRA    147E6
146BA:  BNZ   146C4
146BC:  MOVF   x82,W
146BE:  SUBWF  x85,W
146C0:  BTFSC  FD8.0
146C2:  BRA    147E6
....................                      char curr = 'A'; 
146C4:  MOVLW  41
146C6:  MOVWF  x91
....................                      while(curr != '%'){ 
146C8:  MOVF   x91,W
146CA:  SUBLW  25
146CC:  BZ    14738
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
146CE:  MOVFF  87C,03
146D2:  MOVFF  87B,FE9
146D6:  MOVFF  87C,FEA
146DA:  MOVFF  FEC,896
146DE:  MOVF   FED,F
146E0:  MOVFF  FEF,895
146E4:  MOVFF  87A,894
146E8:  MOVFF  87E,898
146EC:  MOVFF  87D,897
146F0:  MOVLB  0
146F2:  GOTO   13ABA
....................                         (*line)++; 
146F6:  MOVFF  87C,03
146FA:  MOVLB  8
146FC:  MOVF   x7B,W
146FE:  MOVWF  FE9
14700:  MOVFF  03,FEA
14704:  MOVLW  01
14706:  ADDWF  FEE,F
14708:  BNC   1470C
1470A:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
1470C:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
1470E:  MOVFF  87C,03
14712:  MOVFF  87B,FE9
14716:  MOVFF  87C,FEA
1471A:  MOVFF  FEC,896
1471E:  MOVF   FED,F
14720:  MOVFF  FEF,895
14724:  MOVFF  87A,894
14728:  MOVLB  0
1472A:  GOTO   13EA6
1472E:  MOVFF  01,891
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
14732:  BSF    F91.5
14734:  MOVLB  8
14736:  BRA    146C8
....................                      } 
....................                      end_line = (*line); 
14738:  MOVFF  87B,FE9
1473C:  MOVFF  87C,FEA
14740:  CLRF   x90
14742:  CLRF   x8F
14744:  MOVFF  FEC,88E
14748:  MOVF   FED,F
1474A:  MOVFF  FEF,88D
....................                      count++; 
1474E:  MOVLW  01
14750:  ADDWF  x85,F
14752:  BTFSC  FD8.0
14754:  INCF   x86,F
14756:  BTFSC  FD8.2
14758:  INCF   x87,F
1475A:  BTFSC  FD8.2
1475C:  INCF   x88,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
1475E:  MOVF   x85,W
14760:  SUBWF  x82,W
14762:  MOVWF  x92
14764:  MOVF   x86,W
14766:  SUBWFB x83,W
14768:  MOVWF  x93
1476A:  MOVLW  00
1476C:  SUBFWB x87,W
1476E:  MOVWF  x94
14770:  MOVLW  00
14772:  SUBFWB x88,W
14774:  MOVWF  x95
14776:  MOVLW  42
14778:  MOVWF  FF6
1477A:  MOVLW  21
1477C:  MOVWF  FF7
1477E:  MOVLW  00
14780:  MOVWF  FF8
14782:  CLRF   1B
14784:  BTFSC  FF2.7
14786:  BSF    1B.7
14788:  BCF    FF2.7
1478A:  MOVLW  11
1478C:  MOVLB  A
1478E:  MOVWF  x18
14790:  MOVLB  0
14792:  CALL   1010
14796:  BTFSC  1B.7
14798:  BSF    FF2.7
1479A:  MOVLW  41
1479C:  MOVWF  FE9
1479E:  CLRF   1B
147A0:  BTFSC  FF2.7
147A2:  BSF    1B.7
147A4:  BCF    FF2.7
147A6:  MOVFF  895,A1B
147AA:  MOVFF  894,A1A
147AE:  MOVFF  893,A19
147B2:  MOVFF  892,A18
147B6:  CALL   10D6
147BA:  BTFSC  1B.7
147BC:  BSF    FF2.7
147BE:  MOVLW  0D
147C0:  BTFSS  F9E.4
147C2:  BRA    147C0
147C4:  MOVWF  FAD
147C6:  MOVLW  0A
147C8:  BTFSS  F9E.4
147CA:  BRA    147C8
147CC:  MOVWF  FAD
....................                      (*line) = start_line; 
147CE:  MOVFF  87C,03
147D2:  MOVLB  8
147D4:  MOVFF  87B,FE9
147D8:  MOVFF  87C,FEA
147DC:  MOVFF  889,FEF
147E0:  MOVFF  88A,FEC
147E4:  BRA    146A6
....................                   } 
....................                   (*line) = end_line + 1; 
147E6:  MOVFF  87B,FE9
147EA:  MOVFF  87C,FEA
147EE:  MOVLW  01
147F0:  ADDWF  x8D,W
147F2:  MOVWF  FEF
147F4:  MOVLW  00
147F6:  ADDWFC x8E,W
147F8:  MOVWF  FEC
....................                   macro_status = 'a'; 
147FA:  MOVLW  61
147FC:  MOVWF  x84
....................             break; 
147FE:  BRA    14A5C
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
14800:  MOVFF  883,8A0
14804:  MOVFF  882,89F
14808:  CALL   D040
....................                     macro_status = 'a'; 
1480C:  MOVLW  61
1480E:  MOVLB  8
14810:  MOVWF  x84
....................             break; 
14812:  BRA    14A5C
....................          case 'F' : macro_flag = macro_arg; 
14814:  MOVFF  883,320
14818:  MOVFF  882,31F
....................                     macro_status = 'a'; 
1481C:  MOVLW  61
1481E:  MOVLB  8
14820:  MOVWF  x84
....................             break ; 
14822:  BRA    14A5C
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14824:  MOVFF  882,2D1
....................                     macro_status = 'a'; 
14828:  MOVLW  61
1482A:  MOVLB  8
1482C:  MOVWF  x84
....................             break ; 
1482E:  BRA    14A5C
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14830:  MOVFF  881,89F
14834:  MOVFF  883,8A1
14838:  MOVFF  882,8A0
1483C:  CALL   12460
....................                     macro_status = 'a'; 
14840:  MOVLW  61
14842:  MOVLB  8
14844:  MOVWF  x84
....................             break; 
14846:  BRA    14A5C
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14848:  MOVFF  881,89F
1484C:  MOVFF  883,8A1
14850:  MOVFF  882,8A0
14854:  CALL   12460
....................                     macro_status = 'a'; 
14858:  MOVLW  61
1485A:  MOVLB  8
1485C:  MOVWF  x84
....................             break; 
1485E:  BRA    14A5C
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14860:  MOVFF  883,8B9
14864:  MOVFF  882,8B8
14868:  MOVLB  8
1486A:  CLRF   xBB
1486C:  MOVLW  64
1486E:  MOVWF  xBA
14870:  MOVLB  0
14872:  CALL   2C5C
14876:  MOVFF  02,749
1487A:  MOVFF  01,748
....................                     macro_status = 'a'; 
1487E:  MOVLW  61
14880:  MOVLB  8
14882:  MOVWF  x84
....................             break;    
14884:  BRA    14A5C
....................          case 'l' : LightTargetFlag = 1; 
14886:  MOVLW  01
14888:  MOVLB  2
1488A:  MOVWF  xD5
....................                     set_light(macro_cmd,macro_arg); 
1488C:  MOVFF  881,89F
14890:  MOVFF  883,8A1
14894:  MOVFF  882,8A0
14898:  MOVLB  0
1489A:  CALL   1249A
....................                     delay_ms(10000); 
1489E:  MOVLW  28
148A0:  MOVLB  8
148A2:  MOVWF  x92
148A4:  MOVLW  FA
148A6:  MOVLB  9
148A8:  MOVWF  xC9
148AA:  MOVLB  0
148AC:  CALL   2898
148B0:  MOVLB  8
148B2:  DECFSZ x92,F
148B4:  BRA    148A4
....................                     macro_status = 'a'; 
148B6:  MOVLW  61
148B8:  MOVWF  x84
....................             break;        
148BA:  BRA    14A5C
....................          case 'L' : LightTargetFlag = 0; 
148BC:  MOVLB  2
148BE:  CLRF   xD5
....................                     set_light(macro_cmd,macro_arg); 
148C0:  MOVFF  881,89F
148C4:  MOVFF  883,8A1
148C8:  MOVFF  882,8A0
148CC:  MOVLB  0
148CE:  CALL   1249A
....................                     macro_status = 'a'; 
148D2:  MOVLW  61
148D4:  MOVLB  8
148D6:  MOVWF  x84
....................             break; 
148D8:  BRA    14A5C
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
148DA:  MOVFF  881,43
....................                     arg = macro_arg; 
148DE:  CLRF   47
148E0:  CLRF   46
148E2:  MOVFF  883,45
148E6:  MOVFF  882,44
....................                     det_cmd(); 
148EA:  CALL   F104
....................                     macro_status = 'a'; 
148EE:  MOVLW  61
148F0:  MOVLB  8
148F2:  MOVWF  x84
....................             break ; 
148F4:  BRA    14A5C
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
148F6:  MOVLB  8
148F8:  DECFSZ x82,W
148FA:  BRA    14908
148FC:  MOVF   x83,F
148FE:  BNZ   14908
14900:  MOVLB  0
14902:  CALL   13542
14906:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14908:  MOVF   x82,W
1490A:  SUBLW  02
1490C:  BNZ   14920
1490E:  MOVF   x83,F
14910:  BNZ   14920
14912:  MOVLW  01
14914:  MOVWF  x9F
14916:  MOVWF  xA0
14918:  MOVLB  0
1491A:  CALL   1370E
1491E:  MOVLB  8
....................                     macro_status = 'a'; 
14920:  MOVLW  61
14922:  MOVWF  x84
....................             break ;  
14924:  BRA    14A5C
....................          case 'T' : det_temp(); 
14926:  CALL   138CE
....................                     macro_status = 'a'; 
1492A:  MOVLW  61
1492C:  MOVLB  8
1492E:  MOVWF  x84
....................             break; 
14930:  BRA    14A5C
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14932:  MOVLW  01
14934:  MOVLB  7
14936:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14938:  MOVLB  8
1493A:  CLRF   xA4
1493C:  CLRF   xA5
1493E:  CLRF   xA9
14940:  CLRF   xA8
14942:  MOVFF  883,8A7
14946:  MOVFF  882,8A6
1494A:  MOVWF  xAA
1494C:  MOVLB  0
1494E:  CALL   9CB8
....................                     macro_status=step_err_status(); 
14952:  CALL   D008
14956:  MOVFF  01,884
....................             break; 
1495A:  MOVLB  8
1495C:  BRA    14A5C
....................          case '-' : motor=1; 
1495E:  MOVLW  01
14960:  MOVLB  7
14962:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14964:  MOVLB  8
14966:  CLRF   xA4
14968:  MOVWF  xA5
1496A:  CLRF   xA9
1496C:  CLRF   xA8
1496E:  MOVFF  883,8A7
14972:  MOVFF  882,8A6
14976:  MOVWF  xAA
14978:  MOVLB  0
1497A:  CALL   9CB8
....................                     macro_status=step_err_status(); 
1497E:  CALL   D008
14982:  MOVFF  01,884
....................             break; 
14986:  MOVLB  8
14988:  BRA    14A5C
....................          case 'G' : motor=0; 
1498A:  MOVLB  7
1498C:  CLRF   x3C
....................                     align(0); 
1498E:  MOVLB  8
14990:  CLRF   x9F
14992:  MOVLB  0
14994:  CALL   A7F4
....................                     macro_status=step_err_status(); 
14998:  CALL   D008
1499C:  MOVFF  01,884
....................             break ;           
149A0:  MOVLB  8
149A2:  BRA    14A5C
....................          case 'P' : motor=0; 
149A4:  MOVLB  7
149A6:  CLRF   x3C
....................                     move_motor(1,0,macro_arg,1);   
149A8:  MOVLW  01
149AA:  MOVLB  8
149AC:  MOVWF  xA4
149AE:  CLRF   xA5
149B0:  CLRF   xA9
149B2:  CLRF   xA8
149B4:  MOVFF  883,8A7
149B8:  MOVFF  882,8A6
149BC:  MOVWF  xAA
149BE:  MOVLB  0
149C0:  CALL   9CB8
....................                     macro_status=step_err_status(); 
149C4:  CALL   D008
149C8:  MOVFF  01,884
....................             break; 
149CC:  MOVLB  8
149CE:  BRA    14A5C
....................          case 'Q' : motor=0; 
149D0:  MOVLB  7
149D2:  CLRF   x3C
....................                     move_motor(0,0,macro_arg,1); 
149D4:  MOVLB  8
149D6:  CLRF   xA4
149D8:  CLRF   xA5
149DA:  CLRF   xA9
149DC:  CLRF   xA8
149DE:  MOVFF  883,8A7
149E2:  MOVFF  882,8A6
149E6:  MOVLW  01
149E8:  MOVWF  xAA
149EA:  MOVLB  0
149EC:  CALL   9CB8
....................                     macro_status=step_err_status(); 
149F0:  CALL   D008
149F4:  MOVFF  01,884
....................             break; 
149F8:  MOVLB  8
149FA:  BRA    14A5C
....................          case 'R' : motor=0; 
149FC:  MOVLB  7
149FE:  CLRF   x3C
....................                     move_motor(0,1,macro_arg,1); 
14A00:  MOVLB  8
14A02:  CLRF   xA4
14A04:  MOVLW  01
14A06:  MOVWF  xA5
14A08:  CLRF   xA9
14A0A:  CLRF   xA8
14A0C:  MOVFF  883,8A7
14A10:  MOVFF  882,8A6
14A14:  MOVWF  xAA
14A16:  MOVLB  0
14A18:  CALL   9CB8
....................                     macro_status=step_err_status(); 
14A1C:  CALL   D008
14A20:  MOVFF  01,884
....................             break; 
14A24:  MOVLB  8
14A26:  BRA    14A5C
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14A28:  MOVLB  8
14A2A:  DECFSZ x82,W
14A2C:  BRA    14A3C
14A2E:  MOVF   x83,F
14A30:  BNZ   14A3C
14A32:  MOVLB  0
14A34:  CALL   D076
14A38:  BRA    14A4A
14A3A:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14A3C:  MOVF   x82,F
14A3E:  BNZ   14A4C
14A40:  MOVF   x83,F
14A42:  BNZ   14A4C
14A44:  MOVLB  0
14A46:  CALL   D09A
14A4A:  MOVLB  8
....................                     macro_status = 'a'; 
14A4C:  MOVLW  61
14A4E:  MOVWF  x84
....................             break; 
14A50:  BRA    14A5C
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14A52:  MOVLW  66
14A54:  MOVLB  8
14A56:  MOVWF  x84
....................             break ; 
14A58:  BRA    14A5C
14A5A:  MOVLB  8
....................       } 
....................    } 
14A5C:  BRA    14D1C
14A5E:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14A60:  DECFSZ 2F,W
14A62:  BRA    14A68
14A64:  MOVF   30,F
14A66:  BZ    14A76
14A68:  MOVF   2F,W
14A6A:  SUBLW  03
14A6C:  BTFSS  FD8.2
14A6E:  BRA    14BF4
14A70:  MOVF   30,F
14A72:  BTFSS  FD8.2
14A74:  BRA    14BF4
....................       switch(macro_cmd){ 
14A76:  MOVLB  8
14A78:  MOVF   x81,W
14A7A:  XORLW  2B
14A7C:  MOVLB  0
14A7E:  BZ    14AAC
14A80:  XORLW  06
14A82:  BZ    14AD6
14A84:  XORLW  6F
14A86:  BZ    14B00
14A88:  XORLW  05
14A8A:  BZ    14B12
14A8C:  XORLW  17
14A8E:  BZ    14B2A
14A90:  XORLW  01
14A92:  BZ    14B54
14A94:  XORLW  03
14A96:  BZ    14B7E
14A98:  XORLW  06
14A9A:  BTFSC  FD8.2
14A9C:  BRA    14BA8
14A9E:  XORLW  0D
14AA0:  BTFSC  FD8.2
14AA2:  BRA    14BBE
14AA4:  XORLW  62
14AA6:  BTFSC  FD8.2
14AA8:  BRA    14BEA
14AAA:  BRA    14BF2
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14AAC:  MOVLW  01
14AAE:  MOVLB  7
14AB0:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14AB2:  MOVLB  8
14AB4:  CLRF   xA4
14AB6:  CLRF   xA5
14AB8:  CLRF   xA9
14ABA:  CLRF   xA8
14ABC:  MOVFF  883,8A7
14AC0:  MOVFF  882,8A6
14AC4:  MOVWF  xAA
14AC6:  MOVLB  0
14AC8:  CALL   9CB8
....................                     macro_status=step_err_status(); 
14ACC:  CALL   D008
14AD0:  MOVFF  01,884
....................             break; 
14AD4:  BRA    14BF2
....................          case '-' : motor=1; 
14AD6:  MOVLW  01
14AD8:  MOVLB  7
14ADA:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14ADC:  MOVLB  8
14ADE:  CLRF   xA4
14AE0:  MOVWF  xA5
14AE2:  CLRF   xA9
14AE4:  CLRF   xA8
14AE6:  MOVFF  883,8A7
14AEA:  MOVFF  882,8A6
14AEE:  MOVWF  xAA
14AF0:  MOVLB  0
14AF2:  CALL   9CB8
....................                     macro_status=step_err_status(); 
14AF6:  CALL   D008
14AFA:  MOVFF  01,884
....................             break; 
14AFE:  BRA    14BF2
....................          case 'B' : h_bridge(macro_arg); 
14B00:  MOVFF  882,892
14B04:  CALL   BEC2
....................                     macro_status = 'a'; 
14B08:  MOVLW  61
14B0A:  MOVLB  8
14B0C:  MOVWF  x84
....................             break;             
14B0E:  MOVLB  0
14B10:  BRA    14BF2
....................          case 'G' : motor=0; 
14B12:  MOVLB  7
14B14:  CLRF   x3C
....................                     align(0); 
14B16:  MOVLB  8
14B18:  CLRF   x9F
14B1A:  MOVLB  0
14B1C:  CALL   A7F4
....................                     macro_status=step_err_status(); 
14B20:  CALL   D008
14B24:  MOVFF  01,884
....................             break ;           
14B28:  BRA    14BF2
....................          case 'P' : motor=0; 
14B2A:  MOVLB  7
14B2C:  CLRF   x3C
....................                     move_motor(0,0,mmacro_var,1);   
14B2E:  MOVLB  8
14B30:  CLRF   xA4
14B32:  CLRF   xA5
14B34:  CLRF   xA9
14B36:  CLRF   xA8
14B38:  MOVFF  87E,8A7
14B3C:  MOVFF  87D,8A6
14B40:  MOVLW  01
14B42:  MOVWF  xAA
14B44:  MOVLB  0
14B46:  CALL   9CB8
....................                     macro_status=step_err_status(); 
14B4A:  CALL   D008
14B4E:  MOVFF  01,884
....................             break; 
14B52:  BRA    14BF2
....................          case 'Q' : motor=0; 
14B54:  MOVLB  7
14B56:  CLRF   x3C
....................                     move_motor(0,0,mmacro_var,1); 
14B58:  MOVLB  8
14B5A:  CLRF   xA4
14B5C:  CLRF   xA5
14B5E:  CLRF   xA9
14B60:  CLRF   xA8
14B62:  MOVFF  87E,8A7
14B66:  MOVFF  87D,8A6
14B6A:  MOVLW  01
14B6C:  MOVWF  xAA
14B6E:  MOVLB  0
14B70:  CALL   9CB8
....................                     macro_status=step_err_status(); 
14B74:  CALL   D008
14B78:  MOVFF  01,884
....................             break; 
14B7C:  BRA    14BF2
....................          case 'R' : motor=0; 
14B7E:  MOVLB  7
14B80:  CLRF   x3C
....................                     move_motor(0,1,mmacro_var,1); 
14B82:  MOVLB  8
14B84:  CLRF   xA4
14B86:  MOVLW  01
14B88:  MOVWF  xA5
14B8A:  CLRF   xA9
14B8C:  CLRF   xA8
14B8E:  MOVFF  87E,8A7
14B92:  MOVFF  87D,8A6
14B96:  MOVWF  xAA
14B98:  MOVLB  0
14B9A:  CALL   9CB8
....................                     macro_status=step_err_status(); 
14B9E:  CALL   D008
14BA2:  MOVFF  01,884
....................             break; 
14BA6:  BRA    14BF2
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
14BA8:  MOVFF  883,8A0
14BAC:  MOVFF  882,89F
14BB0:  CALL   D040
....................                     macro_status = 'a'; 
14BB4:  MOVLW  61
14BB6:  MOVLB  8
14BB8:  MOVWF  x84
....................             break; 
14BBA:  MOVLB  0
14BBC:  BRA    14BF2
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
14BBE:  MOVLB  8
14BC0:  DECFSZ x82,W
14BC2:  BRA    14BD2
14BC4:  MOVF   x83,F
14BC6:  BNZ   14BD2
14BC8:  MOVLB  0
14BCA:  CALL   D076
14BCE:  BRA    14BE0
14BD0:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14BD2:  MOVF   x82,F
14BD4:  BNZ   14BE2
14BD6:  MOVF   x83,F
14BD8:  BNZ   14BE2
14BDA:  MOVLB  0
14BDC:  CALL   D09A
14BE0:  MOVLB  8
....................                     macro_status = 'a'; 
14BE2:  MOVLW  61
14BE4:  MOVWF  x84
....................             break; 
14BE6:  MOVLB  0
14BE8:  BRA    14BF2
....................          case ';' : macro_status = 'f'; 
14BEA:  MOVLW  66
14BEC:  MOVLB  8
14BEE:  MOVWF  x84
....................             break;            
14BF0:  MOVLB  0
....................       } 
....................    } 
14BF2:  BRA    14D1A
....................    else if (nv_product==AWS){ 
14BF4:  MOVF   2F,W
14BF6:  SUBLW  02
14BF8:  BTFSS  FD8.2
14BFA:  BRA    14D1A
14BFC:  MOVF   30,F
14BFE:  BTFSS  FD8.2
14C00:  BRA    14D1A
....................       switch(macro_cmd){ 
14C02:  MOVLB  8
14C04:  MOVF   x81,W
14C06:  XORLW  2B
14C08:  MOVLB  0
14C0A:  BZ    14C30
14C0C:  XORLW  06
14C0E:  BZ    14C5A
14C10:  XORLW  6E
14C12:  BZ    14C84
14C14:  XORLW  07
14C16:  BZ    14C96
14C18:  XORLW  14
14C1A:  BZ    14CAC
14C1C:  XORLW  01
14C1E:  BZ    14CBE
14C20:  XORLW  02
14C22:  BZ    14CD0
14C24:  XORLW  0A
14C26:  BZ    14CE6
14C28:  XORLW  62
14C2A:  BTFSC  FD8.2
14C2C:  BRA    14D12
14C2E:  BRA    14D1A
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14C30:  MOVLW  01
14C32:  MOVLB  7
14C34:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14C36:  MOVLB  8
14C38:  CLRF   xA4
14C3A:  CLRF   xA5
14C3C:  CLRF   xA9
14C3E:  CLRF   xA8
14C40:  MOVFF  883,8A7
14C44:  MOVFF  882,8A6
14C48:  MOVWF  xAA
14C4A:  MOVLB  0
14C4C:  CALL   9CB8
....................                     macro_status=step_err_status(); 
14C50:  CALL   D008
14C54:  MOVFF  01,884
....................             break; 
14C58:  BRA    14D1A
....................          case '-' : motor=1; 
14C5A:  MOVLW  01
14C5C:  MOVLB  7
14C5E:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14C60:  MOVLB  8
14C62:  CLRF   xA4
14C64:  MOVWF  xA5
14C66:  CLRF   xA9
14C68:  CLRF   xA8
14C6A:  MOVFF  883,8A7
14C6E:  MOVFF  882,8A6
14C72:  MOVWF  xAA
14C74:  MOVLB  0
14C76:  CALL   9CB8
....................                     macro_status=step_err_status(); 
14C7A:  CALL   D008
14C7E:  MOVFF  01,884
....................             break; 
14C82:  BRA    14D1A
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
14C84:  MOVFF  882,893
14C88:  CALL   D8BC
....................                     macro_status = 'a';  
14C8C:  MOVLW  61
14C8E:  MOVLB  8
14C90:  MOVWF  x84
....................             break;          
14C92:  MOVLB  0
14C94:  BRA    14D1A
....................          case 'D' : delay_sec(macro_arg); 
14C96:  MOVFF  883,8A0
14C9A:  MOVFF  882,89F
14C9E:  CALL   D040
....................                     macro_status = 'a'; 
14CA2:  MOVLW  61
14CA4:  MOVLB  8
14CA6:  MOVWF  x84
....................             break; 
14CA8:  MOVLB  0
14CAA:  BRA    14D1A
....................          case 'P' : sol_switch(mmacro_var); 
14CAC:  MOVFF  87D,892
14CB0:  CALL   140CA
....................                     macro_status = 'a'; 
14CB4:  MOVLW  61
14CB6:  MOVLB  8
14CB8:  MOVWF  x84
....................             break;              
14CBA:  MOVLB  0
14CBC:  BRA    14D1A
....................          case 'Q' : sol_switch(macro_arg); 
14CBE:  MOVFF  882,892
14CC2:  CALL   140CA
....................                     macro_status = 'a'; 
14CC6:  MOVLW  61
14CC8:  MOVLB  8
14CCA:  MOVWF  x84
....................             break;             
14CCC:  MOVLB  0
14CCE:  BRA    14D1A
....................          case 'S' : sol_switch_cmd(macro_arg); 
14CD0:  MOVFF  883,894
14CD4:  MOVFF  882,893
14CD8:  CALL   14014
....................                     macro_status = 'a'; 
14CDC:  MOVLW  61
14CDE:  MOVLB  8
14CE0:  MOVWF  x84
....................             break; 
14CE2:  MOVLB  0
14CE4:  BRA    14D1A
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14CE6:  MOVLB  8
14CE8:  DECFSZ x82,W
14CEA:  BRA    14CFA
14CEC:  MOVF   x83,F
14CEE:  BNZ   14CFA
14CF0:  MOVLB  0
14CF2:  CALL   D076
14CF6:  BRA    14D08
14CF8:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14CFA:  MOVF   x82,F
14CFC:  BNZ   14D0A
14CFE:  MOVF   x83,F
14D00:  BNZ   14D0A
14D02:  MOVLB  0
14D04:  CALL   D09A
14D08:  MOVLB  8
....................                     macro_status = 'a'; 
14D0A:  MOVLW  61
14D0C:  MOVWF  x84
....................             break;               
14D0E:  MOVLB  0
14D10:  BRA    14D1A
....................          case ';' : macro_status = 'f'; 
14D12:  MOVLW  66
14D14:  MOVLB  8
14D16:  MOVWF  x84
....................             break;            
14D18:  MOVLB  0
14D1A:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
14D1C:  MOVFF  884,01
14D20:  MOVLB  0
14D22:  GOTO   15032 (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
14F00:  MOVLB  8
14F02:  CLRF   x54
14F04:  CLRF   x53
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
14F06:  MOVLB  0
14F08:  CALL   5068
....................    clear_data_arrays(); 
14F0C:  GOTO   10202
....................     
....................    line = 0;  
14F10:  MOVLB  8
14F12:  CLRF   x78
14F14:  CLRF   x77
....................    macro_status = 'a'; 
14F16:  MOVLW  61
14F18:  MOVWF  x79
....................    data_available = FALSE; 
14F1A:  MOVLB  3
14F1C:  CLRF   x37
....................    macro_flag = 900; 
14F1E:  MOVLW  03
14F20:  MOVWF  x20
14F22:  MOVLW  84
14F24:  MOVWF  x1F
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
14F26:  MOVLW  01
14F28:  MOVWF  1E
14F2A:  MOVLW  A3
14F2C:  MOVWF  1D
14F2E:  MOVLW  5A
14F30:  MOVWF  FF6
14F32:  MOVLW  21
14F34:  MOVWF  FF7
14F36:  MOVLW  00
14F38:  MOVWF  FF8
14F3A:  MOVLW  07
14F3C:  MOVLB  8
14F3E:  MOVWF  xC8
14F40:  MOVLB  0
14F42:  CALL   AA04
14F46:  MOVFF  874,8CA
14F4A:  MOVLW  1B
14F4C:  MOVLB  8
14F4E:  MOVWF  xCB
14F50:  MOVLB  0
14F52:  CALL   5202
14F56:  MOVLW  63
14F58:  MOVWF  FF6
14F5A:  MOVLW  21
14F5C:  MOVWF  FF7
14F5E:  MOVLW  00
14F60:  MOVWF  FF8
14F62:  MOVLW  09
14F64:  MOVLB  8
14F66:  MOVWF  xC8
14F68:  MOVLB  0
14F6A:  CALL   AA04
....................    record_event();    
14F6E:  CALL   841A
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
14F72:  MOVLB  8
14F74:  MOVF   x78,W
14F76:  SUBLW  03
14F78:  BNC   1504A
14F7A:  MOVF   x79,W
14F7C:  SUBLW  61
14F7E:  BNZ   1504A
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
14F80:  MOVF   1F,W
14F82:  SUBLW  04
14F84:  BNZ   15018
14F86:  MOVF   20,F
14F88:  BNZ   15018
....................                                                macro_status, (line + 1)); 
14F8A:  MOVLW  01
14F8C:  ADDWF  x77,W
14F8E:  MOVWF  x7A
14F90:  MOVLW  00
14F92:  ADDWFC x78,W
14F94:  MOVWF  x7B
14F96:  MOVLW  6E
14F98:  MOVWF  FF6
14F9A:  MOVLW  21
14F9C:  MOVWF  FF7
14F9E:  MOVLW  00
14FA0:  MOVWF  FF8
14FA2:  CLRF   1B
14FA4:  BTFSC  FF2.7
14FA6:  BSF    1B.7
14FA8:  BCF    FF2.7
14FAA:  MOVLW  05
14FAC:  MOVLB  A
14FAE:  MOVWF  x18
14FB0:  MOVLB  0
14FB2:  CALL   1010
14FB6:  BTFSC  1B.7
14FB8:  BSF    FF2.7
14FBA:  MOVLB  8
14FBC:  MOVF   x79,W
14FBE:  BTFSS  F9E.4
14FC0:  BRA    14FBE
14FC2:  MOVWF  FAD
14FC4:  MOVLW  5D
14FC6:  BTFSS  F9E.4
14FC8:  BRA    14FC6
14FCA:  MOVWF  FAD
14FCC:  MOVLW  5B
14FCE:  BTFSS  F9E.4
14FD0:  BRA    14FCE
14FD2:  MOVWF  FAD
14FD4:  MOVLW  10
14FD6:  MOVWF  FE9
14FD8:  CLRF   1B
14FDA:  BTFSC  FF2.7
14FDC:  BSF    1B.7
14FDE:  BCF    FF2.7
14FE0:  MOVFF  87B,A19
14FE4:  MOVFF  87A,A18
14FE8:  MOVLB  0
14FEA:  CALL   1192
14FEE:  BTFSC  1B.7
14FF0:  BSF    FF2.7
14FF2:  MOVLW  7A
14FF4:  MOVWF  FF6
14FF6:  MOVLW  21
14FF8:  MOVWF  FF7
14FFA:  MOVLW  00
14FFC:  MOVWF  FF8
14FFE:  CLRF   1B
15000:  BTFSC  FF2.7
15002:  BSF    1B.7
15004:  BCF    FF2.7
15006:  MOVLW  03
15008:  MOVLB  A
1500A:  MOVWF  x18
1500C:  MOVLB  0
1500E:  CALL   1010
15012:  BTFSC  1B.7
15014:  BSF    FF2.7
15016:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
15018:  MOVFF  874,87A
1501C:  MOVLW  08
1501E:  MOVWF  x7C
15020:  MOVLW  77
15022:  MOVWF  x7B
15024:  MOVFF  876,87E
15028:  MOVFF  875,87D
1502C:  MOVLB  0
1502E:  GOTO   14552
15032:  MOVFF  01,879
....................       ++line; 
15036:  MOVLB  8
15038:  INCF   x77,F
1503A:  BTFSC  FD8.2
1503C:  INCF   x78,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
1503E:  DECFSZ 4C,W
15040:  BRA    15048
....................          macro_status = 'g'; 
15042:  MOVLW  67
15044:  MOVWF  x79
....................          break;    
15046:  BRA    1504A
....................       } 
15048:  BRA    14F74
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
1504A:  MOVF   2F,W
1504C:  MOVWF  00
1504E:  MOVF   30,W
15050:  MOVWF  03
15052:  MOVF   03,W
15054:  BNZ   15060
15056:  MOVLW  01
15058:  SUBWF  00,W
1505A:  MOVLB  0
1505C:  BZ    1507E
1505E:  MOVLB  8
15060:  MOVF   03,W
15062:  BNZ   1506E
15064:  MOVLW  03
15066:  SUBWF  00,W
15068:  MOVLB  0
1506A:  BZ    1507E
1506C:  MOVLB  8
1506E:  MOVF   03,W
15070:  BNZ   1507C
15072:  MOVLW  02
15074:  SUBWF  00,W
15076:  MOVLB  0
15078:  BZ    1508A
1507A:  MOVLB  8
1507C:  BRA    1509A
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
1507E:  MOVFF  874,87A
15082:  CALL   D344
....................          break; 
15086:  MOVLB  8
15088:  BRA    1509A
....................       case AWS : store_aws_data(macro,mmacro_var); 
1508A:  MOVFF  874,87A
1508E:  MOVFF  876,87C
15092:  MOVFF  875,87B
15096:  BRA    14DD6
....................          break; 
15098:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
1509A:  MOVLW  61
1509C:  SUBWF  x79,W
1509E:  ADDLW  F9
150A0:  BC    1518C
150A2:  ADDLW  07
150A4:  MOVLB  0
150A6:  GOTO   15238
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
150AA:  MOVLW  7E
150AC:  MOVWF  FF6
150AE:  MOVLW  21
150B0:  MOVWF  FF7
150B2:  MOVLW  00
150B4:  MOVWF  FF8
150B6:  CLRF   1B
150B8:  BTFSC  FF2.7
150BA:  BSF    1B.7
150BC:  BCF    FF2.7
150BE:  CALL   0E3A
150C2:  BTFSC  1B.7
150C4:  BSF    FF2.7
....................          break; 
150C6:  MOVLB  8
150C8:  BRA    1518C
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
150CA:  MOVLW  86
150CC:  MOVWF  FF6
150CE:  MOVLW  21
150D0:  MOVWF  FF7
150D2:  MOVLW  00
150D4:  MOVWF  FF8
150D6:  CLRF   1B
150D8:  BTFSC  FF2.7
150DA:  BSF    1B.7
150DC:  BCF    FF2.7
150DE:  CALL   0E3A
150E2:  BTFSC  1B.7
150E4:  BSF    FF2.7
....................          break; 
150E6:  MOVLB  8
150E8:  BRA    1518C
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
150EA:  MOVLW  8E
150EC:  MOVWF  FF6
150EE:  MOVLW  21
150F0:  MOVWF  FF7
150F2:  MOVLW  00
150F4:  MOVWF  FF8
150F6:  CLRF   1B
150F8:  BTFSC  FF2.7
150FA:  BSF    1B.7
150FC:  BCF    FF2.7
150FE:  CALL   0E3A
15102:  BTFSC  1B.7
15104:  BSF    FF2.7
....................          break; 
15106:  MOVLB  8
15108:  BRA    1518C
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
1510A:  MOVLW  96
1510C:  MOVWF  FF6
1510E:  MOVLW  21
15110:  MOVWF  FF7
15112:  MOVLW  00
15114:  MOVWF  FF8
15116:  CLRF   1B
15118:  BTFSC  FF2.7
1511A:  BSF    1B.7
1511C:  BCF    FF2.7
1511E:  CALL   0E3A
15122:  BTFSC  1B.7
15124:  BSF    FF2.7
....................          break; 
15126:  MOVLB  8
15128:  BRA    1518C
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
1512A:  MOVLW  9E
1512C:  MOVWF  FF6
1512E:  MOVLW  21
15130:  MOVWF  FF7
15132:  MOVLW  00
15134:  MOVWF  FF8
15136:  CLRF   1B
15138:  BTFSC  FF2.7
1513A:  BSF    1B.7
1513C:  BCF    FF2.7
1513E:  CALL   0E3A
15142:  BTFSC  1B.7
15144:  BSF    FF2.7
....................          break;    
15146:  MOVLB  8
15148:  BRA    1518C
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
1514A:  MOVLW  A6
1514C:  MOVWF  FF6
1514E:  MOVLW  21
15150:  MOVWF  FF7
15152:  MOVLW  00
15154:  MOVWF  FF8
15156:  CLRF   1B
15158:  BTFSC  FF2.7
1515A:  BSF    1B.7
1515C:  BCF    FF2.7
1515E:  CALL   0E3A
15162:  BTFSC  1B.7
15164:  BSF    FF2.7
....................          break;    
15166:  MOVLB  8
15168:  BRA    1518C
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
1516A:  MOVLW  AE
1516C:  MOVWF  FF6
1516E:  MOVLW  21
15170:  MOVWF  FF7
15172:  MOVLW  00
15174:  MOVWF  FF8
15176:  CLRF   1B
15178:  BTFSC  FF2.7
1517A:  BSF    1B.7
1517C:  BCF    FF2.7
1517E:  CALL   0E3A
15182:  BTFSC  1B.7
15184:  BSF    FF2.7
....................          break;           
15186:  MOVLB  8
15188:  BRA    1518C
1518A:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
1518C:  MOVLW  01
1518E:  MOVWF  1E
15190:  MOVLW  A3
15192:  MOVWF  1D
15194:  MOVLW  B6
15196:  MOVWF  FF6
15198:  MOVLW  21
1519A:  MOVWF  FF7
1519C:  MOVLW  00
1519E:  MOVWF  FF8
151A0:  MOVLW  07
151A2:  MOVWF  xC8
151A4:  MOVLB  0
151A6:  CALL   AA04
151AA:  MOVFF  874,8CA
151AE:  MOVLW  1B
151B0:  MOVLB  8
151B2:  MOVWF  xCB
151B4:  MOVLB  0
151B6:  CALL   5202
151BA:  MOVLW  BF
151BC:  MOVWF  FF6
151BE:  MOVLW  21
151C0:  MOVWF  FF7
151C2:  MOVLW  00
151C4:  MOVWF  FF8
151C6:  MOVLW  09
151C8:  MOVLB  8
151CA:  MOVWF  xC8
151CC:  MOVLB  0
151CE:  CALL   AA04
151D2:  MOVFF  879,8DC
151D6:  CALL   5020
151DA:  MOVLW  CA
151DC:  MOVWF  FF6
151DE:  MOVLW  21
151E0:  MOVWF  FF7
151E2:  MOVLW  00
151E4:  MOVWF  FF8
151E6:  MOVLW  07
151E8:  MOVLB  8
151EA:  MOVWF  xC8
151EC:  MOVLB  0
151EE:  CALL   AA04
151F2:  MOVLW  10
151F4:  MOVWF  FE9
151F6:  MOVFF  878,8D4
151FA:  MOVFF  877,8D3
151FE:  CALL   AA36
15202:  MOVLW  D4
15204:  MOVWF  FF6
15206:  MOVLW  21
15208:  MOVWF  FF7
1520A:  MOVLW  00
1520C:  MOVWF  FF8
1520E:  MOVLW  03
15210:  MOVLB  8
15212:  MOVWF  xC8
15214:  MOVLB  0
15216:  CALL   AA04
....................    record_event(); 
1521A:  CALL   841A
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
1521E:  MOVLB  8
15220:  MOVF   x79,W
15222:  SUBLW  66
15224:  BZ    15234
15226:  MOVF   x79,W
15228:  SUBLW  67
1522A:  BZ    15234
1522C:  MOVLB  0
1522E:  CALL   A998
15232:  MOVLB  8
15234:  MOVLB  0
15236:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15AC8:  MOVLW  01
15ACA:  MOVLB  8
15ACC:  MOVWF  x6C
....................    while (macro_batch == TRUE){ 
15ACE:  DECFSZ x6C,W
15AD0:  BRA    15D56
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15AD2:  MOVFF  38,9EA
15AD6:  MOVFF  37,9E9
15ADA:  MOVLB  9
15ADC:  CLRF   xEC
15ADE:  MOVLW  03
15AE0:  MOVWF  xEB
15AE2:  MOVLB  0
15AE4:  CALL   5C18
15AE8:  MOVF   01,W
15AEA:  MOVLB  7
15AEC:  ADDWF  xCD,W
15AEE:  MOVLB  8
15AF0:  MOVWF  x67
15AF2:  MOVF   02,W
15AF4:  MOVLB  7
15AF6:  ADDWFC xCE,W
15AF8:  MOVLB  8
15AFA:  MOVWF  x68
....................       init_ext_eeprom(); 
15AFC:  MOVLB  0
15AFE:  CALL   FFE6
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
15B02:  MOVFF  868,8A9
15B06:  MOVFF  867,8A8
15B0A:  CALL   102F0
15B0E:  MOVFF  01,869
....................       ++addr; 
15B12:  MOVLB  8
15B14:  INCF   x67,F
15B16:  BTFSC  FD8.2
15B18:  INCF   x68,F
....................       macro_arg = read16_ext_eeprom(addr); 
15B1A:  MOVFF  868,8A0
15B1E:  MOVFF  867,89F
15B22:  MOVLB  0
15B24:  CALL   10404
15B28:  MOVFF  02,86B
15B2C:  MOVFF  01,86A
....................       ++addr; 
15B30:  MOVLB  8
15B32:  INCF   x67,F
15B34:  BTFSC  FD8.2
15B36:  INCF   x68,F
....................       ++addr;      
15B38:  INCF   x67,F
15B3A:  BTFSC  FD8.2
15B3C:  INCF   x68,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
15B3E:  MOVF   x69,W
15B40:  SUBLW  4D
15B42:  BTFSS  FD8.2
15B44:  BRA    15C6E
15B46:  MOVF   x6A,F
15B48:  BNZ   15B50
15B4A:  MOVF   x6B,F
15B4C:  BTFSC  FD8.2
15B4E:  BRA    15C6E
....................          { 
....................          RTC_reset_HT(); 
15B50:  MOVLB  0
15B52:  CALL   343A
....................          RTC_read(); 
15B56:  CALL   32CC
....................          RTC_display(); 
15B5A:  CALL   DF8C
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
15B5E:  MOVLW  D8
15B60:  MOVWF  FF6
15B62:  MOVLW  21
15B64:  MOVWF  FF7
15B66:  MOVLW  00
15B68:  MOVWF  FF8
15B6A:  CLRF   1B
15B6C:  BTFSC  FF2.7
15B6E:  BSF    1B.7
15B70:  BCF    FF2.7
15B72:  MOVLW  09
15B74:  MOVLB  A
15B76:  MOVWF  x18
15B78:  MOVLB  0
15B7A:  CALL   1010
15B7E:  BTFSC  1B.7
15B80:  BSF    FF2.7
15B82:  MOVLB  8
15B84:  MOVF   x69,W
15B86:  BTFSS  F9E.4
15B88:  BRA    15B86
15B8A:  MOVWF  FAD
15B8C:  MOVLW  10
15B8E:  MOVWF  FE9
15B90:  CLRF   1B
15B92:  BTFSC  FF2.7
15B94:  BSF    1B.7
15B96:  BCF    FF2.7
15B98:  MOVFF  86B,A19
15B9C:  MOVFF  86A,A18
15BA0:  MOVLB  0
15BA2:  CALL   1192
15BA6:  BTFSC  1B.7
15BA8:  BSF    FF2.7
15BAA:  MOVLW  E6
15BAC:  MOVWF  FF6
15BAE:  MOVLW  21
15BB0:  MOVWF  FF7
15BB2:  MOVLW  00
15BB4:  MOVWF  FF8
15BB6:  CLRF   1B
15BB8:  BTFSC  FF2.7
15BBA:  BSF    1B.7
15BBC:  BCF    FF2.7
15BBE:  MOVLW  03
15BC0:  MOVLB  A
15BC2:  MOVWF  x18
15BC4:  MOVLB  0
15BC6:  CALL   1010
15BCA:  BTFSC  1B.7
15BCC:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
15BCE:  MOVLW  01
15BD0:  ADDWF  21,W
15BD2:  MOVLB  8
15BD4:  MOVWF  x6D
15BD6:  MOVLW  00
15BD8:  ADDWFC 22,W
15BDA:  MOVWF  x6E
15BDC:  MOVLW  EA
15BDE:  MOVWF  FF6
15BE0:  MOVLW  21
15BE2:  MOVWF  FF7
15BE4:  MOVLW  00
15BE6:  MOVWF  FF8
15BE8:  CLRF   1B
15BEA:  BTFSC  FF2.7
15BEC:  BSF    1B.7
15BEE:  BCF    FF2.7
15BF0:  MOVLW  07
15BF2:  MOVLB  A
15BF4:  MOVWF  x18
15BF6:  MOVLB  0
15BF8:  CALL   1010
15BFC:  BTFSC  1B.7
15BFE:  BSF    FF2.7
15C00:  MOVLW  09
15C02:  MOVWF  FE9
15C04:  CLRF   1B
15C06:  BTFSC  FF2.7
15C08:  BSF    1B.7
15C0A:  BCF    FF2.7
15C0C:  MOVFF  86E,A19
15C10:  MOVFF  86D,A18
15C14:  CALL   1192
15C18:  BTFSC  1B.7
15C1A:  BSF    FF2.7
15C1C:  MOVLW  F6
15C1E:  MOVWF  FF6
15C20:  MOVLW  21
15C22:  MOVWF  FF7
15C24:  MOVLW  00
15C26:  MOVWF  FF8
15C28:  CLRF   1B
15C2A:  BTFSC  FF2.7
15C2C:  BSF    1B.7
15C2E:  BCF    FF2.7
15C30:  MOVLW  04
15C32:  MOVLB  A
15C34:  MOVWF  x18
15C36:  MOVLB  0
15C38:  CALL   1010
15C3C:  BTFSC  1B.7
15C3E:  BSF    FF2.7
15C40:  MOVLW  09
15C42:  MOVWF  FE9
15C44:  CLRF   1B
15C46:  BTFSC  FF2.7
15C48:  BSF    1B.7
15C4A:  BCF    FF2.7
15C4C:  MOVFF  28,A19
15C50:  MOVFF  27,A18
15C54:  CALL   1192
15C58:  BTFSC  1B.7
15C5A:  BSF    FF2.7
15C5C:  MOVLW  0D
15C5E:  BTFSS  F9E.4
15C60:  BRA    15C5E
15C62:  MOVWF  FAD
15C64:  MOVLW  0A
15C66:  BTFSS  F9E.4
15C68:  BRA    15C66
15C6A:  MOVWF  FAD
15C6C:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
15C6E:  MOVF   28,W
15C70:  SUBWF  22,W
15C72:  BNC   15C80
15C74:  BNZ   15C7C
15C76:  MOVF   27,W
15C78:  SUBWF  21,W
15C7A:  BNC   15C80
....................          {macro_cmd = 'Z';} 
15C7C:  MOVLW  5A
15C7E:  MOVWF  x69
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
15C80:  MOVF   x69,W
15C82:  XORLW  72
15C84:  MOVLB  0
15C86:  BZ    15C9A
15C88:  XORLW  57
15C8A:  BZ    15CBC
15C8C:  XORLW  68
15C8E:  BZ    15CF2
15C90:  XORLW  17
15C92:  BZ    15D28
15C94:  XORLW  61
15C96:  BZ    15D34
15C98:  BRA    15D3E
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
15C9A:  INCF   37,F
15C9C:  BTFSC  FD8.2
15C9E:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
15CA0:  MOVLB  8
15CA2:  CLRF   x5C
15CA4:  CLRF   x5B
15CA6:  MOVFF  38,85A
15CAA:  MOVFF  37,859
....................                master_macro_loop_count = macro_arg; 
15CAE:  CLRF   x58
15CB0:  CLRF   x57
15CB2:  MOVFF  86B,856
15CB6:  MOVFF  86A,855
....................             break; 
15CBA:  BRA    15D4A
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
15CBC:  MOVLB  8
15CBE:  MOVF   x58,F
15CC0:  BNZ   15CD0
15CC2:  MOVF   x57,F
15CC4:  BNZ   15CD0
15CC6:  MOVF   x56,F
15CC8:  BNZ   15CD0
15CCA:  MOVF   x55,W
15CCC:  SUBLW  01
15CCE:  BC    15CEA
....................                   nv_macro_step = master_macro_loop_start; 
15CD0:  MOVFF  85A,38
15CD4:  MOVFF  859,37
....................                   master_macro_loop_count--; 
15CD8:  MOVLW  FF
15CDA:  ADDWF  x55,F
15CDC:  BTFSS  FD8.0
15CDE:  ADDWF  x56,F
15CE0:  BTFSS  FD8.0
15CE2:  ADDWF  x57,F
15CE4:  BTFSS  FD8.0
15CE6:  ADDWF  x58,F
....................                }else{ 
15CE8:  BRA    15CF0
....................                   nv_macro_step++; 
15CEA:  INCF   37,F
15CEC:  BTFSC  FD8.2
15CEE:  INCF   38,F
....................                } 
....................             break; 
15CF0:  BRA    15D4A
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
15CF2:  MOVLB  8
15CF4:  MOVF   x6B,F
15CF6:  BNZ   15D26
15CF8:  MOVF   x6A,W
15CFA:  SUBLW  14
15CFC:  BNC   15D26
....................                   play_macro(macro_arg,0);     // casts to int8 
15CFE:  MOVFF  86A,874
15D02:  CLRF   x76
15D04:  CLRF   x75
15D06:  MOVLB  0
15D08:  CALL   14F00
....................                   delay_ms(100); 
15D0C:  MOVLW  64
15D0E:  MOVLB  9
15D10:  MOVWF  xC9
15D12:  MOVLB  0
15D14:  CALL   2898
....................                   ++nv_sample; 
15D18:  INCF   21,F
15D1A:  BTFSC  FD8.2
15D1C:  INCF   22,F
....................                   ++nv_macro_step; 
15D1E:  INCF   37,F
15D20:  BTFSC  FD8.2
15D22:  INCF   38,F
15D24:  MOVLB  8
....................                } 
....................                break; 
15D26:  BRA    15D4A
....................             case 'Z' : ++nv_macro_step; 
15D28:  INCF   37,F
15D2A:  BTFSC  FD8.2
15D2C:  INCF   38,F
....................                        macro_batch = FALSE; 
15D2E:  MOVLB  8
15D30:  CLRF   x6C
....................                break; 
15D32:  BRA    15D4A
....................             case ';' : nv_macro_step = 0; 
15D34:  CLRF   38
15D36:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
15D38:  MOVLB  8
15D3A:  BRA    15D4A
15D3C:  MOVLB  0
....................             default  : cmd_err(); 
15D3E:  CALL   BC32
....................                        macro_cmd = 'e'; 
15D42:  MOVLW  65
15D44:  MOVLB  8
15D46:  MOVWF  x69
....................                        macro_batch = FALSE; 
15D48:  CLRF   x6C
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
15D4A:  DECFSZ 4C,W
15D4C:  BRA    15D54
....................             macro_cmd = ';'; 
15D4E:  MOVLW  3B
15D50:  MOVWF  x69
....................             break;         // 17 = CTRL-Q (quit) 
15D52:  BRA    15D56
....................          } 
15D54:  BRA    15ACE
....................    } 
....................    return (macro_cmd); 
15D56:  MOVFF  869,01
15D5A:  MOVLB  0
15D5C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D0B0:  MOVLB  8
0D0B2:  MOVF   x69,W
0D0B4:  XORLW  2B
0D0B6:  MOVLB  0
0D0B8:  BZ    D0E8
0D0BA:  XORLW  06
0D0BC:  BZ    D110
0D0BE:  XORLW  6F
0D0C0:  BZ    D138
0D0C2:  XORLW  05
0D0C4:  BZ    D14A
0D0C6:  XORLW  17
0D0C8:  BZ    D160
0D0CA:  XORLW  01
0D0CC:  BZ    D190
0D0CE:  XORLW  03
0D0D0:  BTFSC  FD8.2
0D0D2:  BRA    D1B8
0D0D4:  XORLW  06
0D0D6:  BTFSC  FD8.2
0D0D8:  BRA    D1E0
0D0DA:  XORLW  0D
0D0DC:  BTFSC  FD8.2
0D0DE:  BRA    D1F4
0D0E0:  XORLW  62
0D0E2:  BTFSC  FD8.2
0D0E4:  BRA    D21C
0D0E6:  BRA    D224
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D0E8:  MOVLW  01
0D0EA:  MOVLB  7
0D0EC:  MOVWF  x3C
....................                  move_motor(0,0,macro_arg,1); 
0D0EE:  MOVLB  8
0D0F0:  CLRF   xA4
0D0F2:  CLRF   xA5
0D0F4:  CLRF   xA9
0D0F6:  CLRF   xA8
0D0F8:  MOVFF  86B,8A7
0D0FC:  MOVFF  86A,8A6
0D100:  MOVWF  xAA
0D102:  MOVLB  0
0D104:  CALL   9CB8
....................                  macro_status=step_err_status(); 
0D108:  RCALL  D008
0D10A:  MOVFF  01,86C
....................          break; 
0D10E:  BRA    D224
....................       case '-' : motor=1; 
0D110:  MOVLW  01
0D112:  MOVLB  7
0D114:  MOVWF  x3C
....................                  move_motor(0,1,macro_arg,1); 
0D116:  MOVLB  8
0D118:  CLRF   xA4
0D11A:  MOVWF  xA5
0D11C:  CLRF   xA9
0D11E:  CLRF   xA8
0D120:  MOVFF  86B,8A7
0D124:  MOVFF  86A,8A6
0D128:  MOVWF  xAA
0D12A:  MOVLB  0
0D12C:  CALL   9CB8
....................                  macro_status=step_err_status(); 
0D130:  RCALL  D008
0D132:  MOVFF  01,86C
....................          break; 
0D136:  BRA    D224
....................       case 'B' : h_bridge(macro_arg); 
0D138:  MOVFF  86A,892
0D13C:  CALL   BEC2
....................                  macro_status = 'a'; 
0D140:  MOVLW  61
0D142:  MOVLB  8
0D144:  MOVWF  x6C
....................          break; 
0D146:  MOVLB  0
0D148:  BRA    D224
....................       case 'G' : motor=0; 
0D14A:  MOVLB  7
0D14C:  CLRF   x3C
....................                  align(0); 
0D14E:  MOVLB  8
0D150:  CLRF   x9F
0D152:  MOVLB  0
0D154:  CALL   A7F4
....................                  macro_status=step_err_status(); 
0D158:  RCALL  D008
0D15A:  MOVFF  01,86C
....................          break ;           
0D15E:  BRA    D224
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D160:  MOVFF  86B,2E
0D164:  MOVFF  86A,2D
....................                  motor=0; 
0D168:  MOVLB  7
0D16A:  CLRF   x3C
....................                  move_motor(0,0,macro_arg,1);   
0D16C:  MOVLB  8
0D16E:  CLRF   xA4
0D170:  CLRF   xA5
0D172:  CLRF   xA9
0D174:  CLRF   xA8
0D176:  MOVFF  86B,8A7
0D17A:  MOVFF  86A,8A6
0D17E:  MOVLW  01
0D180:  MOVWF  xAA
0D182:  MOVLB  0
0D184:  CALL   9CB8
....................                  macro_status=step_err_status(); 
0D188:  RCALL  D008
0D18A:  MOVFF  01,86C
....................          break; 
0D18E:  BRA    D224
....................       case 'Q' : motor=0; 
0D190:  MOVLB  7
0D192:  CLRF   x3C
....................                  move_motor(0,0,macro_arg,1); 
0D194:  MOVLB  8
0D196:  CLRF   xA4
0D198:  CLRF   xA5
0D19A:  CLRF   xA9
0D19C:  CLRF   xA8
0D19E:  MOVFF  86B,8A7
0D1A2:  MOVFF  86A,8A6
0D1A6:  MOVLW  01
0D1A8:  MOVWF  xAA
0D1AA:  MOVLB  0
0D1AC:  CALL   9CB8
....................                  macro_status=step_err_status(); 
0D1B0:  RCALL  D008
0D1B2:  MOVFF  01,86C
....................          break; 
0D1B6:  BRA    D224
....................       case 'R' : motor=0; 
0D1B8:  MOVLB  7
0D1BA:  CLRF   x3C
....................                  move_motor(0,1,macro_arg,1); 
0D1BC:  MOVLB  8
0D1BE:  CLRF   xA4
0D1C0:  MOVLW  01
0D1C2:  MOVWF  xA5
0D1C4:  CLRF   xA9
0D1C6:  CLRF   xA8
0D1C8:  MOVFF  86B,8A7
0D1CC:  MOVFF  86A,8A6
0D1D0:  MOVWF  xAA
0D1D2:  MOVLB  0
0D1D4:  CALL   9CB8
....................                  macro_status=step_err_status(); 
0D1D8:  RCALL  D008
0D1DA:  MOVFF  01,86C
....................          break; 
0D1DE:  BRA    D224
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D1E0:  MOVFF  86B,8A0
0D1E4:  MOVFF  86A,89F
0D1E8:  RCALL  D040
....................                  macro_status = 'a'; 
0D1EA:  MOVLW  61
0D1EC:  MOVLB  8
0D1EE:  MOVWF  x6C
....................          break; 
0D1F0:  MOVLB  0
0D1F2:  BRA    D224
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D1F4:  MOVLB  8
0D1F6:  DECFSZ x6A,W
0D1F8:  BRA    D206
0D1FA:  MOVF   x6B,F
0D1FC:  BNZ   D206
0D1FE:  MOVLB  0
0D200:  RCALL  D076
0D202:  BRA    D212
0D204:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D206:  MOVF   x6A,F
0D208:  BNZ   D214
0D20A:  MOVF   x6B,F
0D20C:  BNZ   D214
0D20E:  MOVLB  0
0D210:  RCALL  D09A
0D212:  MOVLB  8
....................                  macro_status = 'a'; 
0D214:  MOVLW  61
0D216:  MOVWF  x6C
....................          break;           
0D218:  MOVLB  0
0D21A:  BRA    D224
....................       case ';' : macro_status = 'f'; 
0D21C:  MOVLW  66
0D21E:  MOVLB  8
0D220:  MOVWF  x6C
....................          break;            
0D222:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D224:  MOVLB  8
0D226:  MOVFF  86C,01
0D22A:  MOVLB  0
0D22C:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D506:  MOVF   2E,F
0D508:  BNZ   D510
0D50A:  MOVF   2D,W
0D50C:  SUBLW  01
0D50E:  BC    D522
0D510:  MOVF   2E,F
0D512:  BNZ   D522
0D514:  MOVF   2D,W
0D516:  SUBLW  30
0D518:  BNC   D522
0D51A:  DECFSZ 2F,W
0D51C:  BRA    D522
0D51E:  MOVF   30,F
0D520:  BZ    D540
0D522:  MOVF   2E,F
0D524:  BNZ   D52C
0D526:  MOVF   2D,W
0D528:  SUBLW  01
0D52A:  BC    D54A
0D52C:  MOVF   2E,F
0D52E:  BNZ   D54A
0D530:  MOVF   2D,W
0D532:  SUBLW  32
0D534:  BNC   D54A
0D536:  MOVF   2F,W
0D538:  SUBLW  03
0D53A:  BNZ   D54A
0D53C:  MOVF   30,F
0D53E:  BNZ   D54A
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D540:  MOVLW  61
0D542:  MOVLB  8
0D544:  MOVWF  x68
....................    } 
0D546:  BRA    D552
0D548:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D54A:  MOVLW  65
0D54C:  MOVLB  8
0D54E:  MOVWF  x68
....................       goto end_macro;       
0D550:  BRA    D602
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D552:  MOVLW  59
0D554:  MOVWF  x69
0D556:  CLRF   x6B
0D558:  MOVLW  01
0D55A:  MOVWF  x6A
0D55C:  MOVLB  0
0D55E:  RCALL  D0B0
0D560:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro; 
0D564:  MOVLB  8
0D566:  MOVF   x68,W
0D568:  SUBLW  61
0D56A:  BTFSS  FD8.2
0D56C:  BRA    D602
....................    macro_status = play_wms_macro_cmd('G',1); 
0D56E:  MOVLW  47
0D570:  MOVWF  x69
0D572:  CLRF   x6B
0D574:  MOVLW  01
0D576:  MOVWF  x6A
0D578:  MOVLB  0
0D57A:  RCALL  D0B0
0D57C:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro; 
0D580:  MOVLB  8
0D582:  MOVF   x68,W
0D584:  SUBLW  61
0D586:  BTFSS  FD8.2
0D588:  BRA    D602
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D58A:  MOVLW  2D
0D58C:  MOVWF  x69
0D58E:  MOVFF  2C,86B
0D592:  MOVFF  2B,86A
0D596:  MOVLB  0
0D598:  RCALL  D0B0
0D59A:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro; 
0D59E:  MOVLB  8
0D5A0:  MOVF   x68,W
0D5A2:  SUBLW  61
0D5A4:  BTFSS  FD8.2
0D5A6:  BRA    D602
....................    macro_status = play_wms_macro_cmd('P',port); 
0D5A8:  MOVLW  50
0D5AA:  MOVWF  x69
0D5AC:  MOVFF  867,86B
0D5B0:  MOVFF  866,86A
0D5B4:  MOVLB  0
0D5B6:  RCALL  D0B0
0D5B8:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro;    
0D5BC:  MOVLB  8
0D5BE:  MOVF   x68,W
0D5C0:  SUBLW  61
0D5C2:  BTFSS  FD8.2
0D5C4:  BRA    D602
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D5C6:  MOVLW  2B
0D5C8:  MOVWF  x69
0D5CA:  MOVFF  2C,86B
0D5CE:  MOVFF  2B,86A
0D5D2:  MOVLB  0
0D5D4:  RCALL  D0B0
0D5D6:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro; 
0D5DA:  MOVLB  8
0D5DC:  MOVF   x68,W
0D5DE:  SUBLW  61
0D5E0:  BTFSS  FD8.2
0D5E2:  BRA    D602
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D5E4:  MOVLW  59
0D5E6:  MOVWF  x69
0D5E8:  CLRF   x6B
0D5EA:  CLRF   x6A
0D5EC:  MOVLB  0
0D5EE:  RCALL  D0B0
0D5F0:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro; 
0D5F4:  MOVLB  8
0D5F6:  MOVF   x68,W
0D5F8:  SUBLW  61
0D5FA:  BTFSS  FD8.2
0D5FC:  BRA    D602
....................    macro_status='f';  
0D5FE:  MOVLW  66
0D600:  MOVWF  x68
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D602:  CLRF   x7A
0D604:  MOVLB  0
0D606:  RCALL  D344
....................    
....................    switch(macro_status){ 
0D608:  MOVLW  61
0D60A:  MOVLB  8
0D60C:  SUBWF  x68,W
0D60E:  ADDLW  FA
0D610:  BC    D6E4
0D612:  ADDLW  06
0D614:  MOVLB  0
0D616:  GOTO   D6E8
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D61A:  MOVF   1F,F
0D61C:  BNZ   D622
0D61E:  MOVF   20,F
0D620:  BZ    D63E
0D622:  MOVLW  02
0D624:  MOVWF  FF6
0D626:  MOVLW  22
0D628:  MOVWF  FF7
0D62A:  MOVLW  00
0D62C:  MOVWF  FF8
0D62E:  CLRF   1B
0D630:  BTFSC  FF2.7
0D632:  BSF    1B.7
0D634:  BCF    FF2.7
0D636:  CALL   0E3A
0D63A:  BTFSC  1B.7
0D63C:  BSF    FF2.7
....................          break; 
0D63E:  MOVLB  8
0D640:  BRA    D6E4
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D642:  MOVLW  0A
0D644:  MOVWF  FF6
0D646:  MOVLW  22
0D648:  MOVWF  FF7
0D64A:  MOVLW  00
0D64C:  MOVWF  FF8
0D64E:  CLRF   1B
0D650:  BTFSC  FF2.7
0D652:  BSF    1B.7
0D654:  BCF    FF2.7
0D656:  CALL   0E3A
0D65A:  BTFSC  1B.7
0D65C:  BSF    FF2.7
....................          break; 
0D65E:  MOVLB  8
0D660:  BRA    D6E4
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D662:  MOVLW  12
0D664:  MOVWF  FF6
0D666:  MOVLW  22
0D668:  MOVWF  FF7
0D66A:  MOVLW  00
0D66C:  MOVWF  FF8
0D66E:  CLRF   1B
0D670:  BTFSC  FF2.7
0D672:  BSF    1B.7
0D674:  BCF    FF2.7
0D676:  CALL   0E3A
0D67A:  BTFSC  1B.7
0D67C:  BSF    FF2.7
....................          break; 
0D67E:  MOVLB  8
0D680:  BRA    D6E4
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D682:  MOVLW  1A
0D684:  MOVWF  FF6
0D686:  MOVLW  22
0D688:  MOVWF  FF7
0D68A:  MOVLW  00
0D68C:  MOVWF  FF8
0D68E:  CLRF   1B
0D690:  BTFSC  FF2.7
0D692:  BSF    1B.7
0D694:  BCF    FF2.7
0D696:  CALL   0E3A
0D69A:  BTFSC  1B.7
0D69C:  BSF    FF2.7
....................          break; 
0D69E:  MOVLB  8
0D6A0:  BRA    D6E4
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D6A2:  MOVLW  22
0D6A4:  MOVWF  FF6
0D6A6:  MOVLW  22
0D6A8:  MOVWF  FF7
0D6AA:  MOVLW  00
0D6AC:  MOVWF  FF8
0D6AE:  CLRF   1B
0D6B0:  BTFSC  FF2.7
0D6B2:  BSF    1B.7
0D6B4:  BCF    FF2.7
0D6B6:  CALL   0E3A
0D6BA:  BTFSC  1B.7
0D6BC:  BSF    FF2.7
....................          break;    
0D6BE:  MOVLB  8
0D6C0:  BRA    D6E4
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D6C2:  MOVLW  2A
0D6C4:  MOVWF  FF6
0D6C6:  MOVLW  22
0D6C8:  MOVWF  FF7
0D6CA:  MOVLW  00
0D6CC:  MOVWF  FF8
0D6CE:  CLRF   1B
0D6D0:  BTFSC  FF2.7
0D6D2:  BSF    1B.7
0D6D4:  BCF    FF2.7
0D6D6:  CALL   0E3A
0D6DA:  BTFSC  1B.7
0D6DC:  BSF    FF2.7
....................          break;           
0D6DE:  MOVLB  8
0D6E0:  BRA    D6E4
0D6E2:  MOVLB  8
....................    } 
0D6E4:  MOVLB  0
0D6E6:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
15F9E:  MOVLB  8
15FA0:  MOVF   x65,W
15FA2:  BTFSC  FD8.2
15FA4:  DECF   x66,F
15FA6:  DECF   x65,F
....................    addr = macro_address[0] + (step*9); 
15FA8:  MOVFF  866,9EA
15FAC:  MOVFF  865,9E9
15FB0:  MOVLB  9
15FB2:  CLRF   xEC
15FB4:  MOVLW  09
15FB6:  MOVWF  xEB
15FB8:  MOVLB  0
15FBA:  CALL   5C18
15FBE:  MOVF   01,W
15FC0:  MOVLB  7
15FC2:  ADDWF  xCD,W
15FC4:  MOVLB  8
15FC6:  MOVWF  x67
15FC8:  MOVF   02,W
15FCA:  MOVLB  7
15FCC:  ADDWFC xCE,W
15FCE:  MOVLB  8
15FD0:  MOVWF  x68
....................     
....................    init_ext_eeprom(); 
15FD2:  MOVLB  0
15FD4:  CALL   FFE6
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
15FD8:  MOVFF  868,8A9
15FDC:  MOVFF  867,8A8
15FE0:  CALL   102F0
15FE4:  MOVFF  01,869
....................    ++addr; 
15FE8:  MOVLB  8
15FEA:  INCF   x67,F
15FEC:  BTFSC  FD8.2
15FEE:  INCF   x68,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
15FF0:  MOVFF  868,8A0
15FF4:  MOVFF  867,89F
15FF8:  MOVLB  0
15FFA:  CALL   10404
15FFE:  MOVFF  02,86D
16002:  MOVFF  01,86C
....................    ++addr; 
16006:  MOVLB  8
16008:  INCF   x67,F
1600A:  BTFSC  FD8.2
1600C:  INCF   x68,F
....................    ++addr; 
1600E:  INCF   x67,F
16010:  BTFSC  FD8.2
16012:  INCF   x68,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
16014:  MOVFF  868,8A9
16018:  MOVFF  867,8A8
1601C:  MOVLB  0
1601E:  CALL   102F0
16022:  MOVFF  01,86A
....................    ++addr; 
16026:  MOVLB  8
16028:  INCF   x67,F
1602A:  BTFSC  FD8.2
1602C:  INCF   x68,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
1602E:  MOVFF  868,8A0
16032:  MOVFF  867,89F
16036:  MOVLB  0
16038:  CALL   10404
1603C:  MOVFF  02,86F
16040:  MOVFF  01,86E
....................    ++addr; 
16044:  MOVLB  8
16046:  INCF   x67,F
16048:  BTFSC  FD8.2
1604A:  INCF   x68,F
....................    ++addr; 
1604C:  INCF   x67,F
1604E:  BTFSC  FD8.2
16050:  INCF   x68,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
16052:  MOVFF  868,8A9
16056:  MOVFF  867,8A8
1605A:  MOVLB  0
1605C:  CALL   102F0
16060:  MOVFF  01,86B
....................    ++addr; 
16064:  MOVLB  8
16066:  INCF   x67,F
16068:  BTFSC  FD8.2
1606A:  INCF   x68,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
1606C:  MOVFF  868,8A0
16070:  MOVFF  867,89F
16074:  MOVLB  0
16076:  CALL   10404
1607A:  MOVFF  02,871
1607E:  MOVFF  01,870
....................    ++addr; 
16082:  MOVLB  8
16084:  INCF   x67,F
16086:  BTFSC  FD8.2
16088:  INCF   x68,F
....................    ++addr; 
1608A:  INCF   x67,F
1608C:  BTFSC  FD8.2
1608E:  INCF   x68,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16090:  MOVFF  868,8A9
16094:  MOVFF  867,8A8
16098:  MOVLB  0
1609A:  CALL   102F0
1609E:  MOVFF  01,872
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
160A2:  MOVLB  8
160A4:  MOVF   x69,W
160A6:  SUBLW  4A
160A8:  BTFSS  FD8.2
160AA:  BRA    16180
160AC:  MOVF   x6A,W
160AE:  SUBLW  50
160B0:  BNZ   16180
160B2:  MOVF   x6B,W
160B4:  SUBLW  4D
160B6:  BNZ   16180
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
160B8:  MOVF   x69,W
160BA:  BTFSS  F9E.4
160BC:  BRA    160BA
160BE:  MOVWF  FAD
160C0:  MOVLW  10
160C2:  MOVWF  FE9
160C4:  CLRF   1B
160C6:  BTFSC  FF2.7
160C8:  BSF    1B.7
160CA:  BCF    FF2.7
160CC:  MOVFF  86D,A19
160D0:  MOVFF  86C,A18
160D4:  MOVLB  0
160D6:  CALL   1192
160DA:  BTFSC  1B.7
160DC:  BSF    FF2.7
160DE:  MOVLW  2C
160E0:  BTFSS  F9E.4
160E2:  BRA    160E0
160E4:  MOVWF  FAD
160E6:  MOVLB  8
160E8:  MOVF   x6A,W
160EA:  BTFSS  F9E.4
160EC:  BRA    160EA
160EE:  MOVWF  FAD
160F0:  MOVLW  10
160F2:  MOVWF  FE9
160F4:  CLRF   1B
160F6:  BTFSC  FF2.7
160F8:  BSF    1B.7
160FA:  BCF    FF2.7
160FC:  MOVFF  86F,A19
16100:  MOVFF  86E,A18
16104:  MOVLB  0
16106:  CALL   1192
1610A:  BTFSC  1B.7
1610C:  BSF    FF2.7
1610E:  MOVLW  2C
16110:  BTFSS  F9E.4
16112:  BRA    16110
16114:  MOVWF  FAD
16116:  MOVLB  8
16118:  MOVF   x6B,W
1611A:  BTFSS  F9E.4
1611C:  BRA    1611A
1611E:  MOVWF  FAD
16120:  MOVLW  10
16122:  MOVWF  FE9
16124:  CLRF   1B
16126:  BTFSC  FF2.7
16128:  BSF    1B.7
1612A:  BCF    FF2.7
1612C:  MOVFF  871,A19
16130:  MOVFF  870,A18
16134:  MOVLB  0
16136:  CALL   1192
1613A:  BTFSC  1B.7
1613C:  BSF    FF2.7
1613E:  MOVLW  0D
16140:  BTFSS  F9E.4
16142:  BRA    16140
16144:  MOVWF  FAD
16146:  MOVLW  0A
16148:  BTFSS  F9E.4
1614A:  BRA    16148
1614C:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
1614E:  MOVFF  86D,24
16152:  MOVFF  86C,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
16156:  MOVLB  8
16158:  MOVF   x70,F
1615A:  BNZ   16160
1615C:  MOVF   x71,F
1615E:  BZ    1617E
16160:  MOVF   x71,F
16162:  BNZ   1617E
16164:  MOVF   x70,W
16166:  SUBLW  10
16168:  BNC   1617E
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
1616A:  MOVFF  870,874
1616E:  MOVFF  86F,876
16172:  MOVFF  86E,875
16176:  MOVLB  0
16178:  CALL   14F00
1617C:  MOVLB  8
....................       } 
....................    } 
1617E:  BRA    1618C
....................    else { 
....................       cmd_err(); 
16180:  MOVLB  0
16182:  CALL   BC32
....................       macro_end = 59; 
16186:  MOVLW  3B
16188:  MOVLB  8
1618A:  MOVWF  x72
....................    } 
....................     
....................    return (macro_end); 
1618C:  MOVFF  872,01
16190:  MOVLB  0
16192:  GOTO   1627C (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
1637E:  MOVLB  8
16380:  MOVF   x69,W
16382:  BTFSC  FD8.2
16384:  DECF   x6A,F
16386:  DECF   x69,F
....................    addr = macro_address[0] + (step*6); 
16388:  MOVFF  86A,9EA
1638C:  MOVFF  869,9E9
16390:  MOVLB  9
16392:  CLRF   xEC
16394:  MOVLW  06
16396:  MOVWF  xEB
16398:  MOVLB  0
1639A:  CALL   5C18
1639E:  MOVF   01,W
163A0:  MOVLB  7
163A2:  ADDWF  xCD,W
163A4:  MOVLB  8
163A6:  MOVWF  x6B
163A8:  MOVF   02,W
163AA:  MOVLB  7
163AC:  ADDWFC xCE,W
163AE:  MOVLB  8
163B0:  MOVWF  x6C
....................     
....................    init_ext_eeprom(); 
163B2:  MOVLB  0
163B4:  CALL   FFE6
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
163B8:  MOVFF  86C,8A9
163BC:  MOVFF  86B,8A8
163C0:  CALL   102F0
163C4:  MOVFF  01,86D
....................    ++addr; 
163C8:  MOVLB  8
163CA:  INCF   x6B,F
163CC:  BTFSC  FD8.2
163CE:  INCF   x6C,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
163D0:  MOVFF  86C,8A0
163D4:  MOVFF  86B,89F
163D8:  MOVLB  0
163DA:  CALL   10404
163DE:  MOVFF  02,870
163E2:  MOVFF  01,86F
....................    ++addr; 
163E6:  MOVLB  8
163E8:  INCF   x6B,F
163EA:  BTFSC  FD8.2
163EC:  INCF   x6C,F
....................    ++addr; 
163EE:  INCF   x6B,F
163F0:  BTFSC  FD8.2
163F2:  INCF   x6C,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
163F4:  MOVFF  86C,8A9
163F8:  MOVFF  86B,8A8
163FC:  MOVLB  0
163FE:  CALL   102F0
16402:  MOVFF  01,86E
....................    ++addr; 
16406:  MOVLB  8
16408:  INCF   x6B,F
1640A:  BTFSC  FD8.2
1640C:  INCF   x6C,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
1640E:  MOVFF  86C,8A0
16412:  MOVFF  86B,89F
16416:  MOVLB  0
16418:  CALL   10404
1641C:  MOVFF  02,872
16420:  MOVFF  01,871
....................    ++addr; 
16424:  MOVLB  8
16426:  INCF   x6B,F
16428:  BTFSC  FD8.2
1642A:  INCF   x6C,F
....................    ++addr; 
1642C:  INCF   x6B,F
1642E:  BTFSC  FD8.2
16430:  INCF   x6C,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16432:  MOVFF  86C,8A9
16436:  MOVFF  86B,8A8
1643A:  MOVLB  0
1643C:  CALL   102F0
16440:  MOVFF  01,873
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
16444:  MOVLB  8
16446:  MOVF   x6D,W
16448:  SUBLW  50
1644A:  BNZ   164EE
1644C:  MOVF   x6E,W
1644E:  SUBLW  4D
16450:  BNZ   164EE
....................        
....................       RTC_read(); 
16452:  MOVLB  0
16454:  CALL   32CC
....................       RTC_display(); 
16458:  CALL   DF8C
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
1645C:  MOVLB  8
1645E:  MOVF   x6D,W
16460:  BTFSS  F9E.4
16462:  BRA    16460
16464:  MOVWF  FAD
16466:  MOVLW  10
16468:  MOVWF  FE9
1646A:  CLRF   1B
1646C:  BTFSC  FF2.7
1646E:  BSF    1B.7
16470:  BCF    FF2.7
16472:  MOVFF  870,A19
16476:  MOVFF  86F,A18
1647A:  MOVLB  0
1647C:  CALL   1192
16480:  BTFSC  1B.7
16482:  BSF    FF2.7
16484:  MOVLW  2C
16486:  BTFSS  F9E.4
16488:  BRA    16486
1648A:  MOVWF  FAD
1648C:  MOVLB  8
1648E:  MOVF   x6E,W
16490:  BTFSS  F9E.4
16492:  BRA    16490
16494:  MOVWF  FAD
16496:  MOVLW  10
16498:  MOVWF  FE9
1649A:  CLRF   1B
1649C:  BTFSC  FF2.7
1649E:  BSF    1B.7
164A0:  BCF    FF2.7
164A2:  MOVFF  872,A19
164A6:  MOVFF  871,A18
164AA:  MOVLB  0
164AC:  CALL   1192
164B0:  BTFSC  1B.7
164B2:  BSF    FF2.7
164B4:  MOVLW  0D
164B6:  BTFSS  F9E.4
164B8:  BRA    164B6
164BA:  MOVWF  FAD
164BC:  MOVLW  0A
164BE:  BTFSS  F9E.4
164C0:  BRA    164BE
164C2:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
164C4:  MOVLB  8
164C6:  MOVF   x71,F
164C8:  BNZ   164CE
164CA:  MOVF   x72,F
164CC:  BZ    164EC
164CE:  MOVF   x72,F
164D0:  BNZ   164EC
164D2:  MOVF   x71,W
164D4:  SUBLW  10
164D6:  BNC   164EC
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
164D8:  MOVFF  871,874
164DC:  MOVFF  870,876
164E0:  MOVFF  86F,875
164E4:  MOVLB  0
164E6:  CALL   14F00
164EA:  MOVLB  8
....................       } 
....................    } 
164EC:  BRA    164FA
....................    else { 
....................       cmd_err(); 
164EE:  MOVLB  0
164F0:  CALL   BC32
....................       macro_end = 59; 
164F4:  MOVLW  3B
164F6:  MOVLB  8
164F8:  MOVWF  x73
....................    } 
....................     
....................    return (macro_end); 
164FA:  MOVFF  873,01
164FE:  MOVLB  0
16500:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
15D7C:  MOVF   24,W
15D7E:  SUBWF  36,W
15D80:  BTFSS  FD8.0
15D82:  BRA    15F8A
15D84:  BNZ   15D8E
15D86:  MOVF   23,W
15D88:  SUBWF  35,W
15D8A:  BTFSS  FD8.0
15D8C:  BRA    15F8A
15D8E:  MOVF   33,F
15D90:  BTFSS  FD8.2
15D92:  BRA    15F8A
15D94:  MOVF   34,F
15D96:  BTFSS  FD8.2
15D98:  BRA    15F8A
....................       { 
....................          nv_elapsed = 0; 
15D9A:  CLRF   36
15D9C:  CLRF   35
....................  
....................          init_hardware(); 
15D9E:  CALL   28C2
....................          sd_status = init_sdcard(); 
15DA2:  CALL   4FBC
15DA6:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
15DAA:  MOVLB  2
15DAC:  MOVF   xD8,F
15DAE:  BZ    15DB8
15DB0:  MOVLB  0
15DB2:  CALL   5002
15DB6:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
15DB8:  MOVLW  01
15DBA:  MOVWF  1E
15DBC:  MOVLW  A3
15DBE:  MOVWF  1D
15DC0:  MOVLW  32
15DC2:  MOVWF  FF6
15DC4:  MOVLW  22
15DC6:  MOVWF  FF7
15DC8:  MOVLW  00
15DCA:  MOVWF  FF8
15DCC:  MOVLW  14
15DCE:  MOVLB  8
15DD0:  MOVWF  xC8
15DD2:  MOVLB  0
15DD4:  CALL   AA04
15DD8:  MOVLW  10
15DDA:  MOVWF  FE9
15DDC:  MOVFF  22,8D4
15DE0:  MOVFF  21,8D3
15DE4:  CALL   AA36
15DE8:  MOVLW  49
15DEA:  MOVWF  FF6
15DEC:  MOVLW  22
15DEE:  MOVWF  FF7
15DF0:  MOVLW  00
15DF2:  MOVWF  FF8
15DF4:  MOVLW  09
15DF6:  MOVLB  8
15DF8:  MOVWF  xC8
15DFA:  MOVLB  0
15DFC:  CALL   AA04
....................          record_event();          
15E00:  CALL   841A
....................              
....................          macro_cmd = master_macro_eco(); 
15E04:  RCALL  15AC8
15E06:  MOVFF  01,864
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
15E0A:  MOVLW  16
15E0C:  MOVLB  8
15E0E:  MOVWF  xCB
15E10:  MOVFF  22,8CD
15E14:  MOVFF  21,8CC
15E18:  MOVLB  0
15E1A:  CALL   4F56
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
15E1E:  MOVLW  3A
15E20:  MOVLB  8
15E22:  MOVWF  xCB
15E24:  MOVFF  38,8CD
15E28:  MOVFF  37,8CC
15E2C:  MOVLB  0
15E2E:  CALL   4F56
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
15E32:  DECFSZ 4C,W
15E34:  BRA    15E58
....................          { 
....................             disable_interrupts (INT_EXT); 
15E36:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
15E38:  CLRF   32
15E3A:  MOVLW  01
15E3C:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
15E3E:  MOVLW  02
15E40:  MOVLB  8
15E42:  MOVWF  x66
15E44:  MOVFF  31,867
15E48:  MOVLB  0
15E4A:  CALL   339A
....................             busy_clear(); 
15E4E:  CALL   ADAC
....................             return (user_quit); 
15E52:  MOVFF  4C,01
15E56:  BRA    15F9A
....................          } 
....................  
....................          motor_sleep_rdy(); 
15E58:  CALL   2920
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
15E5C:  MOVLW  01
15E5E:  MOVWF  1E
15E60:  MOVLW  A3
15E62:  MOVWF  1D
15E64:  MOVLW  54
15E66:  MOVWF  FF6
15E68:  MOVLW  22
15E6A:  MOVWF  FF7
15E6C:  MOVLW  00
15E6E:  MOVWF  FF8
15E70:  MOVLW  14
15E72:  MOVLB  8
15E74:  MOVWF  xC8
15E76:  MOVLB  0
15E78:  CALL   AA04
15E7C:  MOVLW  10
15E7E:  MOVWF  FE9
15E80:  MOVFF  22,8D4
15E84:  MOVFF  21,8D3
15E88:  CALL   AA36
15E8C:  MOVLW  6B
15E8E:  MOVWF  FF6
15E90:  MOVLW  22
15E92:  MOVWF  FF7
15E94:  MOVLW  00
15E96:  MOVWF  FF8
15E98:  MOVLW  0C
15E9A:  MOVLB  8
15E9C:  MOVWF  xC8
15E9E:  MOVLB  0
15EA0:  CALL   AA04
....................          record_event();  
15EA4:  CALL   841A
....................           
....................          if (macro_cmd == 'e') 
15EA8:  MOVLB  8
15EAA:  MOVF   x64,W
15EAC:  SUBLW  65
15EAE:  BNZ   15F02
....................          { 
....................             disable_interrupts (INT_EXT); 
15EB0:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
15EB2:  MOVLW  01
15EB4:  MOVWF  1E
15EB6:  MOVLW  A3
15EB8:  MOVWF  1D
15EBA:  MOVLW  78
15EBC:  MOVWF  FF6
15EBE:  MOVLW  22
15EC0:  MOVWF  FF7
15EC2:  MOVLW  00
15EC4:  MOVWF  FF8
15EC6:  MOVLW  14
15EC8:  MOVWF  xC8
15ECA:  MOVLB  0
15ECC:  CALL   AA04
15ED0:  MOVLW  10
15ED2:  MOVWF  FE9
15ED4:  MOVFF  22,8D4
15ED8:  MOVFF  21,8D3
15EDC:  CALL   AA36
15EE0:  MOVLW  8F
15EE2:  MOVWF  FF6
15EE4:  MOVLW  22
15EE6:  MOVWF  FF7
15EE8:  MOVLW  00
15EEA:  MOVWF  FF8
15EEC:  MOVLW  09
15EEE:  MOVLB  8
15EF0:  MOVWF  xC8
15EF2:  MOVLB  0
15EF4:  CALL   AA04
....................             record_event();  
15EF8:  CALL   841A
....................             cmd_err(); 
15EFC:  CALL   BC32
15F00:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
15F02:  MOVF   28,W
15F04:  SUBWF  22,W
15F06:  BNC   15F8C
15F08:  BNZ   15F10
15F0A:  MOVF   27,W
15F0C:  SUBWF  21,W
15F0E:  BNC   15F8C
....................          { 
....................             disable_interrupts (INT_EXT); 
15F10:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
15F12:  MOVLW  01
15F14:  MOVWF  1E
15F16:  MOVLW  A3
15F18:  MOVWF  1D
15F1A:  MOVLW  9A
15F1C:  MOVWF  FF6
15F1E:  MOVLW  22
15F20:  MOVWF  FF7
15F22:  MOVLW  00
15F24:  MOVWF  FF8
15F26:  MOVLW  14
15F28:  MOVWF  xC8
15F2A:  MOVLB  0
15F2C:  CALL   AA04
15F30:  MOVLW  10
15F32:  MOVWF  FE9
15F34:  MOVFF  22,8D4
15F38:  MOVFF  21,8D3
15F3C:  CALL   AA36
15F40:  MOVLW  B1
15F42:  MOVWF  FF6
15F44:  MOVLW  22
15F46:  MOVWF  FF7
15F48:  MOVLW  00
15F4A:  MOVWF  FF8
15F4C:  MOVLW  0F
15F4E:  MOVLB  8
15F50:  MOVWF  xC8
15F52:  MOVLB  0
15F54:  CALL   AA04
....................             record_event();   
15F58:  CALL   841A
....................             msg_max(); 
15F5C:  RCALL  15D5E
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
15F5E:  CLRF   34
15F60:  MOVLW  01
15F62:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
15F64:  MOVLW  28
15F66:  MOVLB  8
15F68:  MOVWF  x66
15F6A:  MOVFF  33,867
15F6E:  MOVLB  0
15F70:  CALL   339A
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15F74:  CLRF   32
15F76:  MOVLW  01
15F78:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
15F7A:  MOVLW  02
15F7C:  MOVLB  8
15F7E:  MOVWF  x66
15F80:  MOVFF  31,867
15F84:  MOVLB  0
15F86:  CALL   339A
15F8A:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
15F8C:  MOVLB  0
15F8E:  RCALL  15A02
15F90:  BRA    15D7C
....................    } 
....................     
....................    busy_clear(); 
15F92:  CALL   ADAC
....................    return (user_quit); 
15F96:  MOVFF  4C,01
15F9A:  GOTO   168BE (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
16196:  MOVF   24,W
16198:  SUBWF  36,W
1619A:  BTFSS  FD8.0
1619C:  BRA    1636C
1619E:  BNZ   161A8
161A0:  MOVF   23,W
161A2:  SUBWF  35,W
161A4:  BTFSS  FD8.0
161A6:  BRA    1636C
....................       { 
....................          nv_elapsed = 0; 
161A8:  CLRF   36
161AA:  CLRF   35
....................  
....................          init_hardware(); 
161AC:  CALL   28C2
....................          sd_status = init_sdcard(); 
161B0:  CALL   4FBC
161B4:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
161B8:  MOVLB  2
161BA:  MOVF   xD8,F
161BC:  BZ    161C6
161BE:  MOVLB  0
161C0:  CALL   5002
161C4:  MOVLB  2
....................  
....................          ++nv_sample; 
161C6:  INCF   21,F
161C8:  BTFSC  FD8.2
161CA:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
161CC:  MOVLW  40
161CE:  BTFSS  F9E.4
161D0:  BRA    161CE
161D2:  MOVWF  FAD
161D4:  MOVLW  53
161D6:  BTFSS  F9E.4
161D8:  BRA    161D6
161DA:  MOVWF  FAD
161DC:  MOVLW  09
161DE:  MOVWF  FE9
161E0:  CLRF   1B
161E2:  BTFSC  FF2.7
161E4:  BSF    1B.7
161E6:  BCF    FF2.7
161E8:  MOVFF  22,A19
161EC:  MOVFF  21,A18
161F0:  MOVLB  0
161F2:  CALL   1192
161F6:  BTFSC  1B.7
161F8:  BSF    FF2.7
161FA:  MOVLW  0D
161FC:  BTFSS  F9E.4
161FE:  BRA    161FC
16200:  MOVWF  FAD
16202:  MOVLW  0A
16204:  BTFSS  F9E.4
16206:  BRA    16204
16208:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
1620A:  MOVLW  01
1620C:  MOVWF  1E
1620E:  MOVLW  A3
16210:  MOVWF  1D
16212:  MOVLW  C2
16214:  MOVWF  FF6
16216:  MOVLW  22
16218:  MOVWF  FF7
1621A:  MOVLW  00
1621C:  MOVWF  FF8
1621E:  MOVLW  14
16220:  MOVLB  8
16222:  MOVWF  xC8
16224:  MOVLB  0
16226:  CALL   AA04
1622A:  MOVLW  10
1622C:  MOVWF  FE9
1622E:  MOVFF  22,8D4
16232:  MOVFF  21,8D3
16236:  CALL   AA36
1623A:  MOVLW  D9
1623C:  MOVWF  FF6
1623E:  MOVLW  22
16240:  MOVWF  FF7
16242:  MOVLW  00
16244:  MOVWF  FF8
16246:  MOVLW  09
16248:  MOVLB  8
1624A:  MOVWF  xC8
1624C:  MOVLB  0
1624E:  CALL   AA04
....................          record_event();   
16252:  CALL   841A
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16256:  MOVLW  16
16258:  MOVLB  8
1625A:  MOVWF  xCB
1625C:  MOVFF  22,8CD
16260:  MOVFF  21,8CC
16264:  MOVLB  0
16266:  CALL   4F56
....................  
....................          if (nv_macro_mode==TRUE) 
1626A:  DECFSZ 29,W
1626C:  BRA    16282
1626E:  MOVF   2A,F
16270:  BNZ   16282
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
16272:  MOVFF  22,866
16276:  MOVFF  21,865
1627A:  BRA    15F9E
1627C:  MOVFF  01,864
....................          } 
16280:  BRA    162EA
....................          else 
....................          { 
....................             time_stamp(); 
16282:  CALL   539C
....................             play_wms_hard_macro(nv_port); 
16286:  MOVFF  2E,867
1628A:  MOVFF  2D,866
1628E:  CALL   D506
....................             ++nv_port; 
16292:  INCF   2D,F
16294:  BTFSC  FD8.2
16296:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
16298:  MOVF   2E,F
1629A:  BNZ   162A2
1629C:  MOVF   2D,W
1629E:  SUBLW  01
162A0:  BC    162B4
162A2:  MOVF   2E,F
162A4:  BNZ   162B4
162A6:  MOVF   2D,W
162A8:  SUBLW  30
162AA:  BNC   162B4
162AC:  DECFSZ 2F,W
162AE:  BRA    162B4
162B0:  MOVF   30,F
162B2:  BZ    162D2
162B4:  MOVF   2E,F
162B6:  BNZ   162BE
162B8:  MOVF   2D,W
162BA:  SUBLW  01
162BC:  BC    162E8
162BE:  MOVF   2E,F
162C0:  BNZ   162E8
162C2:  MOVF   2D,W
162C4:  SUBLW  32
162C6:  BNC   162E8
162C8:  MOVF   2F,W
162CA:  SUBLW  03
162CC:  BNZ   162E8
162CE:  MOVF   30,F
162D0:  BNZ   162E8
....................             { 
....................                write16(ADDR_PORT, nv_port);             
162D2:  MOVLW  24
162D4:  MOVLB  8
162D6:  MOVWF  xCB
162D8:  MOVFF  2E,8CD
162DC:  MOVFF  2D,8CC
162E0:  MOVLB  0
162E2:  CALL   4F56
....................             } 
162E6:  BRA    162EA
....................             else disable_interrupts (INT_EXT); 
162E8:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
162EA:  DECFSZ 4C,W
162EC:  BRA    16310
....................          { 
....................             disable_interrupts (INT_EXT); 
162EE:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
162F0:  CLRF   32
162F2:  MOVLW  01
162F4:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
162F6:  MOVLW  02
162F8:  MOVLB  8
162FA:  MOVWF  x66
162FC:  MOVFF  31,867
16300:  MOVLB  0
16302:  CALL   339A
....................             busy_clear(); 
16306:  CALL   ADAC
....................             return (user_quit); 
1630A:  MOVFF  4C,01
1630E:  BRA    1637A
....................          } 
....................           
....................          motor_sleep_rdy(); 
16310:  CALL   2920
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16314:  MOVLW  01
16316:  MOVWF  1E
16318:  MOVLW  A3
1631A:  MOVWF  1D
1631C:  MOVLW  E4
1631E:  MOVWF  FF6
16320:  MOVLW  22
16322:  MOVWF  FF7
16324:  MOVLW  00
16326:  MOVWF  FF8
16328:  MOVLW  14
1632A:  MOVLB  8
1632C:  MOVWF  xC8
1632E:  MOVLB  0
16330:  CALL   AA04
16334:  MOVLW  10
16336:  MOVWF  FE9
16338:  MOVFF  22,8D4
1633C:  MOVFF  21,8D3
16340:  CALL   AA36
16344:  MOVLW  FB
16346:  MOVWF  FF6
16348:  MOVLW  22
1634A:  MOVWF  FF7
1634C:  MOVLW  00
1634E:  MOVWF  FF8
16350:  MOVLW  0C
16352:  MOVLB  8
16354:  MOVWF  xC8
16356:  MOVLB  0
16358:  CALL   AA04
....................          record_event();  
1635C:  CALL   841A
....................           
....................          if (macro_end == ';') 
16360:  MOVLB  8
16362:  MOVF   x64,W
16364:  SUBLW  3B
16366:  BNZ   1636A
....................          { 
....................             disable_interrupts (INT_EXT); 
16368:  BCF    FF2.4
1636A:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
1636C:  CALL   15A02
16370:  BRA    16196
....................    } 
....................    busy_clear(); 
16372:  CALL   ADAC
....................    return (user_quit); 
16376:  MOVFF  4C,01
1637A:  GOTO   168C6 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
16502:  MOVF   24,W
16504:  SUBWF  36,W
16506:  BTFSS  FD8.0
16508:  BRA    166C2
1650A:  BNZ   16514
1650C:  MOVF   23,W
1650E:  SUBWF  35,W
16510:  BTFSS  FD8.0
16512:  BRA    166C2
....................       { 
....................          nv_elapsed = 0; 
16514:  CLRF   36
16516:  CLRF   35
....................  
....................          init_hardware(); 
16518:  CALL   28C2
....................          sd_status = init_sdcard(); 
1651C:  CALL   4FBC
16520:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
16524:  MOVLB  2
16526:  MOVF   xD8,F
16528:  BZ    16532
1652A:  MOVLB  0
1652C:  CALL   5002
16530:  MOVLB  2
....................  
....................          ++nv_sample; 
16532:  INCF   21,F
16534:  BTFSC  FD8.2
16536:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
16538:  MOVLW  40
1653A:  BTFSS  F9E.4
1653C:  BRA    1653A
1653E:  MOVWF  FAD
16540:  MOVLW  53
16542:  BTFSS  F9E.4
16544:  BRA    16542
16546:  MOVWF  FAD
16548:  MOVLW  09
1654A:  MOVWF  FE9
1654C:  CLRF   1B
1654E:  BTFSC  FF2.7
16550:  BSF    1B.7
16552:  BCF    FF2.7
16554:  MOVFF  22,A19
16558:  MOVFF  21,A18
1655C:  MOVLB  0
1655E:  CALL   1192
16562:  BTFSC  1B.7
16564:  BSF    FF2.7
16566:  MOVLW  0D
16568:  BTFSS  F9E.4
1656A:  BRA    16568
1656C:  MOVWF  FAD
1656E:  MOVLW  0A
16570:  BTFSS  F9E.4
16572:  BRA    16570
16574:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16576:  MOVLW  01
16578:  MOVWF  1E
1657A:  MOVLW  A3
1657C:  MOVWF  1D
1657E:  MOVLW  08
16580:  MOVWF  FF6
16582:  MOVLW  23
16584:  MOVWF  FF7
16586:  MOVLW  00
16588:  MOVWF  FF8
1658A:  MOVLW  14
1658C:  MOVLB  8
1658E:  MOVWF  xC8
16590:  MOVLB  0
16592:  CALL   AA04
16596:  MOVLW  10
16598:  MOVWF  FE9
1659A:  MOVFF  22,8D4
1659E:  MOVFF  21,8D3
165A2:  CALL   AA36
165A6:  MOVLW  1F
165A8:  MOVWF  FF6
165AA:  MOVLW  23
165AC:  MOVWF  FF7
165AE:  MOVLW  00
165B0:  MOVWF  FF8
165B2:  MOVLW  09
165B4:  MOVLB  8
165B6:  MOVWF  xC8
165B8:  MOVLB  0
165BA:  CALL   AA04
....................          record_event();   
165BE:  CALL   841A
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
165C2:  MOVLW  16
165C4:  MOVLB  8
165C6:  MOVWF  xCB
165C8:  MOVFF  22,8CD
165CC:  MOVFF  21,8CC
165D0:  MOVLB  0
165D2:  CALL   4F56
....................  
....................          macro_end = master_macro_aws(nv_sample); 
165D6:  MOVFF  22,86A
165DA:  MOVFF  21,869
165DE:  RCALL  1637E
165E0:  MOVFF  01,864
....................           
....................          if (user_quit == TRUE) 
165E4:  DECFSZ 4C,W
165E6:  BRA    1660A
....................          { 
....................             disable_interrupts (INT_EXT); 
165E8:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
165EA:  CLRF   32
165EC:  MOVLW  01
165EE:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
165F0:  MOVLW  02
165F2:  MOVLB  8
165F4:  MOVWF  x66
165F6:  MOVFF  31,867
165FA:  MOVLB  0
165FC:  CALL   339A
....................             busy_clear(); 
16600:  CALL   ADAC
....................             return (user_quit); 
16604:  MOVFF  4C,01
16608:  BRA    166D4
....................          } 
....................           
....................          motor_sleep_rdy(); 
1660A:  CALL   2920
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
1660E:  MOVLW  01
16610:  MOVWF  1E
16612:  MOVLW  A3
16614:  MOVWF  1D
16616:  MOVLW  2A
16618:  MOVWF  FF6
1661A:  MOVLW  23
1661C:  MOVWF  FF7
1661E:  MOVLW  00
16620:  MOVWF  FF8
16622:  MOVLW  14
16624:  MOVLB  8
16626:  MOVWF  xC8
16628:  MOVLB  0
1662A:  CALL   AA04
1662E:  MOVLW  10
16630:  MOVWF  FE9
16632:  MOVFF  22,8D4
16636:  MOVFF  21,8D3
1663A:  CALL   AA36
1663E:  MOVLW  41
16640:  MOVWF  FF6
16642:  MOVLW  23
16644:  MOVWF  FF7
16646:  MOVLW  00
16648:  MOVWF  FF8
1664A:  MOVLW  0C
1664C:  MOVLB  8
1664E:  MOVWF  xC8
16650:  MOVLB  0
16652:  CALL   AA04
....................          record_event();  
16656:  CALL   841A
....................           
....................          if (macro_end == ';') 
1665A:  MOVLB  8
1665C:  MOVF   x64,W
1665E:  SUBLW  3B
16660:  BNZ   16664
....................          { 
....................             disable_interrupts (INT_EXT); 
16662:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16664:  MOVF   28,W
16666:  SUBWF  22,W
16668:  BNC   166C4
1666A:  BNZ   16672
1666C:  MOVF   27,W
1666E:  SUBWF  21,W
16670:  BNC   166C4
....................          { 
....................             disable_interrupts (INT_EXT); 
16672:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16674:  MOVLW  01
16676:  MOVWF  1E
16678:  MOVLW  A3
1667A:  MOVWF  1D
1667C:  MOVLW  4E
1667E:  MOVWF  FF6
16680:  MOVLW  23
16682:  MOVWF  FF7
16684:  MOVLW  00
16686:  MOVWF  FF8
16688:  MOVLW  14
1668A:  MOVWF  xC8
1668C:  MOVLB  0
1668E:  CALL   AA04
16692:  MOVLW  10
16694:  MOVWF  FE9
16696:  MOVFF  22,8D4
1669A:  MOVFF  21,8D3
1669E:  CALL   AA36
166A2:  MOVLW  65
166A4:  MOVWF  FF6
166A6:  MOVLW  23
166A8:  MOVWF  FF7
166AA:  MOVLW  00
166AC:  MOVWF  FF8
166AE:  MOVLW  0F
166B0:  MOVLB  8
166B2:  MOVWF  xC8
166B4:  MOVLB  0
166B6:  CALL   AA04
....................             record_event();   
166BA:  CALL   841A
....................             msg_max(); 
166BE:  CALL   15D5E
166C2:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
166C4:  MOVLB  0
166C6:  CALL   15A02
166CA:  BRA    16502
....................    } 
....................    busy_clear(); 
166CC:  CALL   ADAC
....................    return (user_quit); 
166D0:  MOVFF  4C,01
166D4:  GOTO   168CE (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
166D8:  CALL   2948
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
166DC:  MOVLW  01
166DE:  MOVWF  1E
166E0:  MOVLW  A3
166E2:  MOVWF  1D
166E4:  MOVLW  76
166E6:  MOVWF  FF6
166E8:  MOVLW  23
166EA:  MOVWF  FF7
166EC:  MOVLW  00
166EE:  MOVWF  FF8
166F0:  CALL   5040
....................    record_event(); 
166F4:  CALL   841A
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
166F8:  MOVLW  01
166FA:  MOVWF  1E
166FC:  MOVLW  A3
166FE:  MOVWF  1D
16700:  MOVLW  90
16702:  MOVWF  FF6
16704:  MOVLW  23
16706:  MOVWF  FF7
16708:  MOVLW  00
1670A:  MOVWF  FF8
1670C:  MOVLW  0C
1670E:  MOVLB  8
16710:  MOVWF  xC8
16712:  MOVLB  0
16714:  CALL   AA04
16718:  MOVLW  10
1671A:  MOVWF  FE9
1671C:  MOVFF  26,8D4
16720:  MOVFF  25,8D3
16724:  CALL   AA36
16728:  MOVLW  9F
1672A:  MOVWF  FF6
1672C:  MOVLW  23
1672E:  MOVWF  FF7
16730:  MOVLW  00
16732:  MOVWF  FF8
16734:  MOVLW  06
16736:  MOVLB  8
16738:  MOVWF  xC8
1673A:  MOVLB  0
1673C:  CALL   AA04
16740:  MOVLW  10
16742:  MOVWF  FE9
16744:  MOVFF  24,8D4
16748:  MOVFF  23,8D3
1674C:  CALL   AA36
16750:  MOVLW  A8
16752:  MOVWF  FF6
16754:  MOVLW  23
16756:  MOVWF  FF7
16758:  MOVLW  00
1675A:  MOVWF  FF8
1675C:  MOVLW  06
1675E:  MOVLB  8
16760:  MOVWF  xC8
16762:  MOVLB  0
16764:  CALL   AA04
16768:  MOVLW  10
1676A:  MOVWF  FE9
1676C:  MOVFF  28,8D4
16770:  MOVFF  27,8D3
16774:  CALL   AA36
16778:  MOVLW  B1
1677A:  MOVWF  FF6
1677C:  MOVLW  23
1677E:  MOVWF  FF7
16780:  MOVLW  00
16782:  MOVWF  FF8
16784:  MOVLW  03
16786:  MOVLB  8
16788:  MOVWF  xC8
1678A:  MOVLB  0
1678C:  CALL   AA04
....................    record_event(); 
16790:  CALL   841A
....................     
....................    user_quit = FALSE; 
16794:  CLRF   4C
....................     
....................    nv_cmd_mode = FALSE; 
16796:  CLRF   32
16798:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1679A:  MOVLW  02
1679C:  MOVLB  8
1679E:  MOVWF  x66
167A0:  MOVFF  31,867
167A4:  MOVLB  0
167A6:  CALL   339A
....................  
....................    RTC_set_AFE(); 
167AA:  GOTO   15266
....................    // check if start is earlier than now 
....................    RTC_late(); 
167AE:  CALL   152BE
....................    // show clock 
....................    RTC_display(); 
167B2:  CALL   DF8C
....................    // show alarm 
....................    RTC_display_alarm(); 
167B6:  CALL   E1EC
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
167BA:  CALL   15778
....................  
....................    if (alarm_passed == FALSE){ 
167BE:  BTFSC  49.3
167C0:  BRA    167C2
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
167C2:  MOVLW  00
167C4:  BTFSC  49.3
167C6:  MOVLW  01
167C8:  MOVLB  8
167CA:  MOVWF  x64
167CC:  MOVLW  01
167CE:  MOVWF  1E
167D0:  MOVLW  A3
167D2:  MOVWF  1D
167D4:  MOVLW  B6
167D6:  MOVWF  FF6
167D8:  MOVLW  23
167DA:  MOVWF  FF7
167DC:  MOVLW  00
167DE:  MOVWF  FF8
167E0:  MOVLW  14
167E2:  MOVWF  xC8
167E4:  MOVLB  0
167E6:  CALL   AA04
167EA:  MOVLW  10
167EC:  MOVWF  FE9
167EE:  MOVFF  22,8D4
167F2:  MOVFF  21,8D3
167F6:  CALL   AA36
167FA:  MOVLW  CD
167FC:  MOVWF  FF6
167FE:  MOVLW  23
16800:  MOVWF  FF7
16802:  MOVLW  00
16804:  MOVWF  FF8
16806:  MOVLW  08
16808:  MOVLB  8
1680A:  MOVWF  xC8
1680C:  MOVLB  0
1680E:  CALL   AA04
16812:  MOVFF  864,8CA
16816:  MOVLW  1B
16818:  MOVLB  8
1681A:  MOVWF  xCB
1681C:  MOVLB  0
1681E:  CALL   5202
16822:  MOVLW  D7
16824:  MOVWF  FF6
16826:  MOVLW  23
16828:  MOVWF  FF7
1682A:  MOVLW  00
1682C:  MOVWF  FF8
1682E:  MOVLW  03
16830:  MOVLB  8
16832:  MOVWF  xC8
16834:  MOVLB  0
16836:  CALL   AA04
....................    record_event();  
1683A:  CALL   841A
....................  
....................    while (TRUE == RTC_read_flags_running) 
1683E:  BTFSS  49.2
16840:  BRA    16844
....................    { 
....................       ; 
16842:  BRA    1683E
....................    } 
....................    RTC_read_flags_running = TRUE; 
16844:  BSF    49.2
16846:  CLRF   1B
16848:  BTFSC  FF2.7
1684A:  BSF    1B.7
1684C:  BCF    FF2.7
....................    RTC_read_flags(); 
1684E:  CALL   0DCC
16852:  BTFSC  1B.7
16854:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
16856:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
16858:  CALL   2920
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
1685C:  BTFSC  49.3
1685E:  BRA    16880
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
16860:  MOVLW  01
16862:  MOVWF  1E
16864:  MOVLW  A3
16866:  MOVWF  1D
16868:  MOVLW  DC
1686A:  MOVWF  FF6
1686C:  MOVLW  23
1686E:  MOVWF  FF7
16870:  MOVLW  00
16872:  MOVWF  FF8
16874:  CALL   5040
....................       record_event(); 
16878:  CALL   841A
....................       go_to_sleep(); 
1687C:  CALL   15A02
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
16880:  GOTO   15A18
....................    nv_elapsed = nv_interval; 
16884:  MOVFF  24,36
16888:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
1688C:  MOVFF  2F,00
16890:  MOVF   30,W
16892:  MOVWF  03
16894:  BNZ   1689A
16896:  MOVF   00,F
16898:  BZ    168BA
1689A:  MOVF   03,W
1689C:  BNZ   168A4
1689E:  MOVLW  01
168A0:  SUBWF  00,W
168A2:  BZ    168C4
168A4:  MOVF   03,W
168A6:  BNZ   168AE
168A8:  MOVLW  03
168AA:  SUBWF  00,W
168AC:  BZ    168C4
168AE:  MOVF   03,W
168B0:  BNZ   168B8
168B2:  MOVLW  02
168B4:  SUBWF  00,W
168B6:  BZ    168CC
168B8:  BRA    168D2
....................       case ECO: user_quit = auto_sample_eco(); 
168BA:  GOTO   15D7C
168BE:  MOVFF  01,4C
....................          break; 
168C2:  BRA    168D2
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
168C4:  BRA    16196
168C6:  MOVFF  01,4C
....................          break; 
168CA:  BRA    168D2
....................       case AWS: user_quit = auto_sample_aws(); 
168CC:  BRA    16502
168CE:  MOVFF  01,4C
....................          break;          
....................    } 
....................    return(user_quit); 
168D2:  MOVFF  4C,01
168D6:  GOTO   169E4 (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BC02:  MOVF   44,F
0BC04:  BNZ   BC12
0BC06:  MOVF   45,F
0BC08:  BNZ   BC12
0BC0A:  MOVF   46,F
0BC0C:  BNZ   BC12
0BC0E:  MOVF   47,F
0BC10:  BZ    BC2A
0BC12:  MOVF   47,F
0BC14:  BNZ   BC2A
0BC16:  MOVF   46,F
0BC18:  BNZ   BC2A
0BC1A:  MOVF   45,F
0BC1C:  BNZ   BC2A
0BC1E:  MOVF   44,W
0BC20:  SUBLW  02
0BC22:  BNC   BC2A
....................       detector = arg; 
0BC24:  MOVFF  44,2D1
....................    } 
0BC28:  BRA    BC2E
....................    else cmd_arg(); 
0BC2A:  CALL   AF70
0BC2E:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0BC50:  MOVF   44,F
0BC52:  BNZ   BC60
0BC54:  MOVF   45,F
0BC56:  BNZ   BC60
0BC58:  MOVF   46,F
0BC5A:  BNZ   BC60
0BC5C:  MOVF   47,F
0BC5E:  BZ    BCBA
0BC60:  MOVF   47,F
0BC62:  BNZ   BCBA
0BC64:  MOVF   46,W
0BC66:  SUBLW  00
0BC68:  BNC   BCBA
....................       switch (detector){ 
0BC6A:  MOVLB  2
0BC6C:  MOVF   xD1,W
0BC6E:  XORLW  01
0BC70:  MOVLB  0
0BC72:  BZ    BC7A
0BC74:  XORLW  03
0BC76:  BZ    BC98
0BC78:  BRA    BCB6
....................          case 1 : nv_d1_temp = arg; 
0BC7A:  MOVFF  45,3E
0BC7E:  MOVFF  44,3D
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0BC82:  MOVLW  40
0BC84:  MOVLB  8
0BC86:  MOVWF  xCB
0BC88:  MOVFF  3E,8CD
0BC8C:  MOVFF  3D,8CC
0BC90:  MOVLB  0
0BC92:  CALL   4F56
....................             break; 
0BC96:  BRA    BCB8
....................          case 2 : nv_d2_temp = arg; 
0BC98:  MOVFF  45,40
0BC9C:  MOVFF  44,3F
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0BCA0:  MOVLW  42
0BCA2:  MOVLB  8
0BCA4:  MOVWF  xCB
0BCA6:  MOVFF  40,8CD
0BCAA:  MOVFF  3F,8CC
0BCAE:  MOVLB  0
0BCB0:  CALL   4F56
....................             break; 
0BCB4:  BRA    BCB8
....................          default : cmd_err(); 
0BCB6:  RCALL  BC32
....................             break; 
....................       } 
....................    } 
0BCB8:  BRA    BD60
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0BCBA:  MOVF   44,F
0BCBC:  BNZ   BD5C
0BCBE:  MOVF   45,F
0BCC0:  BNZ   BD5C
0BCC2:  MOVF   46,F
0BCC4:  BNZ   BD5C
0BCC6:  MOVF   47,F
0BCC8:  BNZ   BD5C
0BCCA:  MOVLW  F2
0BCCC:  MOVWF  FF6
0BCCE:  MOVLW  23
0BCD0:  MOVWF  FF7
0BCD2:  MOVLW  00
0BCD4:  MOVWF  FF8
0BCD6:  CLRF   1B
0BCD8:  BTFSC  FF2.7
0BCDA:  BSF    1B.7
0BCDC:  BCF    FF2.7
0BCDE:  MOVLW  03
0BCE0:  MOVLB  A
0BCE2:  MOVWF  x18
0BCE4:  MOVLB  0
0BCE6:  CALL   1010
0BCEA:  BTFSC  1B.7
0BCEC:  BSF    FF2.7
0BCEE:  MOVLW  10
0BCF0:  MOVWF  FE9
0BCF2:  CLRF   1B
0BCF4:  BTFSC  FF2.7
0BCF6:  BSF    1B.7
0BCF8:  BCF    FF2.7
0BCFA:  MOVFF  3E,A19
0BCFE:  MOVFF  3D,A18
0BD02:  CALL   1192
0BD06:  BTFSC  1B.7
0BD08:  BSF    FF2.7
0BD0A:  MOVLW  F8
0BD0C:  MOVWF  FF6
0BD0E:  MOVLW  23
0BD10:  MOVWF  FF7
0BD12:  MOVLW  00
0BD14:  MOVWF  FF8
0BD16:  CLRF   1B
0BD18:  BTFSC  FF2.7
0BD1A:  BSF    1B.7
0BD1C:  BCF    FF2.7
0BD1E:  MOVLW  04
0BD20:  MOVLB  A
0BD22:  MOVWF  x18
0BD24:  MOVLB  0
0BD26:  CALL   1010
0BD2A:  BTFSC  1B.7
0BD2C:  BSF    FF2.7
0BD2E:  MOVLW  10
0BD30:  MOVWF  FE9
0BD32:  CLRF   1B
0BD34:  BTFSC  FF2.7
0BD36:  BSF    1B.7
0BD38:  BCF    FF2.7
0BD3A:  MOVFF  40,A19
0BD3E:  MOVFF  3F,A18
0BD42:  CALL   1192
0BD46:  BTFSC  1B.7
0BD48:  BSF    FF2.7
0BD4A:  MOVLW  0D
0BD4C:  BTFSS  F9E.4
0BD4E:  BRA    BD4C
0BD50:  MOVWF  FAD
0BD52:  MOVLW  0A
0BD54:  BTFSS  F9E.4
0BD56:  BRA    BD54
0BD58:  MOVWF  FAD
0BD5A:  BRA    BD60
....................    else cmd_arg(); 
0BD5C:  CALL   AF70
0BD60:  GOTO   BDC6 (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0BD64:  MOVF   47,F
0BD66:  BNZ   BD94
0BD68:  MOVF   46,F
0BD6A:  BNZ   BD94
0BD6C:  MOVF   45,F
0BD6E:  BNZ   BD94
0BD70:  MOVF   44,W
0BD72:  SUBLW  01
0BD74:  BNC   BD94
....................       nv_macro_mode = arg; 
0BD76:  MOVFF  45,2A
0BD7A:  MOVFF  44,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0BD7E:  MOVLW  20
0BD80:  MOVLB  8
0BD82:  MOVWF  xCB
0BD84:  MOVFF  2A,8CD
0BD88:  MOVFF  29,8CC
0BD8C:  MOVLB  0
0BD8E:  CALL   4F56
....................    } 
0BD92:  BRA    BD98
....................    else cmd_arg(); 
0BD94:  CALL   AF70
0BD98:  GOTO   BDC6 (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0BD9C:  MOVF   2F,W
0BD9E:  MOVWF  00
0BDA0:  MOVF   30,W
0BDA2:  MOVWF  03
0BDA4:  BNZ   BDAA
0BDA6:  MOVF   00,F
0BDA8:  BZ    BDC0
0BDAA:  MOVF   03,W
0BDAC:  BNZ   BDB4
0BDAE:  MOVLW  01
0BDB0:  SUBWF  00,W
0BDB2:  BZ    BDC4
0BDB4:  MOVF   03,W
0BDB6:  BNZ   BDBE
0BDB8:  MOVLW  03
0BDBA:  SUBWF  00,W
0BDBC:  BZ    BDC4
0BDBE:  BRA    BDC6
....................       case ECO : commandAe(); 
0BDC0:  BRA    BC50
....................          break; 
0BDC2:  BRA    BDC6
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0BDC4:  BRA    BD64
....................          break; 
....................    } 
0BDC6:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0BDCA:  MOVF   44,F
0BDCC:  BNZ   BDDA
0BDCE:  MOVF   45,F
0BDD0:  BNZ   BDDA
0BDD2:  MOVF   46,F
0BDD4:  BNZ   BDDA
0BDD6:  MOVF   47,F
0BDD8:  BZ    BE0A
0BDDA:  MOVF   47,F
0BDDC:  BNZ   BE0A
0BDDE:  MOVF   46,F
0BDE0:  BNZ   BE0A
0BDE2:  MOVF   45,F
0BDE4:  BNZ   BE0A
0BDE6:  MOVF   44,W
0BDE8:  SUBLW  03
0BDEA:  BNC   BE0A
....................       nv_det_type = arg; 
0BDEC:  MOVFF  45,42
0BDF0:  MOVFF  44,41
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0BDF4:  MOVLW  26
0BDF6:  MOVLB  8
0BDF8:  MOVWF  xCB
0BDFA:  MOVFF  42,8CD
0BDFE:  MOVFF  41,8CC
0BE02:  MOVLB  0
0BE04:  CALL   4F56
....................    } 
0BE08:  BRA    BE70
....................    else if(arg==0) { 
0BE0A:  MOVF   44,F
0BE0C:  BNZ   BE6C
0BE0E:  MOVF   45,F
0BE10:  BNZ   BE6C
0BE12:  MOVF   46,F
0BE14:  BNZ   BE6C
0BE16:  MOVF   47,F
0BE18:  BNZ   BE6C
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0BE1A:  MOVLW  02
0BE1C:  MOVWF  FF6
0BE1E:  MOVLW  24
0BE20:  MOVWF  FF7
0BE22:  MOVLW  00
0BE24:  MOVWF  FF8
0BE26:  CLRF   1B
0BE28:  BTFSC  FF2.7
0BE2A:  BSF    1B.7
0BE2C:  BCF    FF2.7
0BE2E:  MOVLW  05
0BE30:  MOVLB  A
0BE32:  MOVWF  x18
0BE34:  MOVLB  0
0BE36:  CALL   1010
0BE3A:  BTFSC  1B.7
0BE3C:  BSF    FF2.7
0BE3E:  MOVLW  10
0BE40:  MOVWF  FE9
0BE42:  CLRF   1B
0BE44:  BTFSC  FF2.7
0BE46:  BSF    1B.7
0BE48:  BCF    FF2.7
0BE4A:  MOVFF  42,A19
0BE4E:  MOVFF  41,A18
0BE52:  CALL   1192
0BE56:  BTFSC  1B.7
0BE58:  BSF    FF2.7
0BE5A:  MOVLW  0D
0BE5C:  BTFSS  F9E.4
0BE5E:  BRA    BE5C
0BE60:  MOVWF  FAD
0BE62:  MOVLW  0A
0BE64:  BTFSS  F9E.4
0BE66:  BRA    BE64
0BE68:  MOVWF  FAD
....................    } 
0BE6A:  BRA    BE70
....................    else cmd_arg(); 
0BE6C:  CALL   AF70
0BE70:  GOTO   BF32 (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0BEE2:  MOVF   47,F
0BEE4:  BNZ   BF00
0BEE6:  MOVF   46,F
0BEE8:  BNZ   BF00
0BEEA:  MOVF   45,F
0BEEC:  BNZ   BF00
0BEEE:  MOVF   44,W
0BEF0:  SUBLW  03
0BEF2:  BNC   BF00
....................       hb_cmd=arg; 
0BEF4:  MOVFF  44,862
....................       h_bridge(hb_cmd); 
0BEF8:  MOVFF  862,892
0BEFC:  RCALL  BEC2
....................    } 
0BEFE:  BRA    BF04
....................    else cmd_arg(); 
0BF00:  CALL   AF70
0BF04:  GOTO   BF32 (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0BF08:  MOVF   2F,W
0BF0A:  MOVWF  00
0BF0C:  MOVF   30,W
0BF0E:  MOVWF  03
0BF10:  BNZ   BF16
0BF12:  MOVF   00,F
0BF14:  BZ    BF2C
0BF16:  MOVF   03,W
0BF18:  BNZ   BF20
0BF1A:  MOVLW  01
0BF1C:  SUBWF  00,W
0BF1E:  BZ    BF30
0BF20:  MOVF   03,W
0BF22:  BNZ   BF2A
0BF24:  MOVLW  03
0BF26:  SUBWF  00,W
0BF28:  BZ    BF30
0BF2A:  BRA    BF32
....................       case ECO : commandBe(); 
0BF2C:  BRA    BDCA
....................          break; 
0BF2E:  BRA    BF32
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0BF30:  BRA    BEE2
....................          break; 
....................    } 
0BF32:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CAC2:  MOVF   44,W
0CAC4:  MOVWF  00
0CAC6:  MOVF   45,W
0CAC8:  MOVWF  03
0CACA:  BNZ   CAD0
0CACC:  MOVF   00,F
0CACE:  BZ    CB32
0CAD0:  MOVF   03,W
0CAD2:  BNZ   CADC
0CAD4:  MOVLW  01
0CAD6:  SUBWF  00,W
0CAD8:  BTFSC  FD8.2
0CADA:  BRA    CD20
0CADC:  MOVF   03,W
0CADE:  BNZ   CAE8
0CAE0:  MOVLW  02
0CAE2:  SUBWF  00,W
0CAE4:  BTFSC  FD8.2
0CAE6:  BRA    CD7C
0CAE8:  MOVF   03,W
0CAEA:  BNZ   CAF4
0CAEC:  MOVLW  03
0CAEE:  SUBWF  00,W
0CAF0:  BTFSC  FD8.2
0CAF2:  BRA    CDD8
0CAF4:  MOVF   03,W
0CAF6:  BNZ   CB00
0CAF8:  MOVLW  04
0CAFA:  SUBWF  00,W
0CAFC:  BTFSC  FD8.2
0CAFE:  BRA    CE34
0CB00:  MOVF   03,W
0CB02:  BNZ   CB0C
0CB04:  MOVLW  05
0CB06:  SUBWF  00,W
0CB08:  BTFSC  FD8.2
0CB0A:  BRA    CE90
0CB0C:  MOVF   03,W
0CB0E:  BNZ   CB18
0CB10:  MOVLW  06
0CB12:  SUBWF  00,W
0CB14:  BTFSC  FD8.2
0CB16:  BRA    CEEC
0CB18:  MOVF   03,W
0CB1A:  BNZ   CB24
0CB1C:  MOVLW  07
0CB1E:  SUBWF  00,W
0CB20:  BTFSC  FD8.2
0CB22:  BRA    CF48
0CB24:  MOVF   03,W
0CB26:  BNZ   CB30
0CB28:  MOVLW  08
0CB2A:  SUBWF  00,W
0CB2C:  BTFSC  FD8.2
0CB2E:  BRA    CFA4
0CB30:  BRA    D000
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CB32:  MOVLW  0E
0CB34:  MOVWF  FF6
0CB36:  MOVLW  24
0CB38:  MOVWF  FF7
0CB3A:  MOVLW  00
0CB3C:  MOVWF  FF8
0CB3E:  CLRF   1B
0CB40:  BTFSC  FF2.7
0CB42:  BSF    1B.7
0CB44:  BCF    FF2.7
0CB46:  MOVLW  04
0CB48:  MOVLB  A
0CB4A:  MOVWF  x18
0CB4C:  MOVLB  0
0CB4E:  CALL   1010
0CB52:  BTFSC  1B.7
0CB54:  BSF    FF2.7
0CB56:  MOVLW  89
0CB58:  MOVWF  FE9
0CB5A:  MOVFF  3F4,865
0CB5E:  MOVFF  3F3,864
0CB62:  MOVFF  3F2,863
0CB66:  MOVFF  3F1,862
0CB6A:  MOVLW  05
0CB6C:  MOVLB  8
0CB6E:  MOVWF  x66
0CB70:  MOVLB  0
0CB72:  RCALL  C3A6
0CB74:  MOVLW  2C
0CB76:  BTFSS  F9E.4
0CB78:  BRA    CB76
0CB7A:  MOVWF  FAD
0CB7C:  MOVLW  89
0CB7E:  MOVWF  FE9
0CB80:  MOVFF  3F8,865
0CB84:  MOVFF  3F7,864
0CB88:  MOVFF  3F6,863
0CB8C:  MOVFF  3F5,862
0CB90:  MOVLW  05
0CB92:  MOVLB  8
0CB94:  MOVWF  x66
0CB96:  MOVLB  0
0CB98:  RCALL  C3A6
0CB9A:  MOVLW  0D
0CB9C:  BTFSS  F9E.4
0CB9E:  BRA    CB9C
0CBA0:  MOVWF  FAD
0CBA2:  MOVLW  0A
0CBA4:  BTFSS  F9E.4
0CBA6:  BRA    CBA4
0CBA8:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CBAA:  MOVLW  20
0CBAC:  MOVWF  FF6
0CBAE:  MOVLW  24
0CBB0:  MOVWF  FF7
0CBB2:  MOVLW  00
0CBB4:  MOVWF  FF8
0CBB6:  CLRF   1B
0CBB8:  BTFSC  FF2.7
0CBBA:  BSF    1B.7
0CBBC:  BCF    FF2.7
0CBBE:  MOVLW  04
0CBC0:  MOVLB  A
0CBC2:  MOVWF  x18
0CBC4:  MOVLB  0
0CBC6:  CALL   1010
0CBCA:  BTFSC  1B.7
0CBCC:  BSF    FF2.7
0CBCE:  MOVLW  89
0CBD0:  MOVWF  FE9
0CBD2:  MOVFF  3FC,865
0CBD6:  MOVFF  3FB,864
0CBDA:  MOVFF  3FA,863
0CBDE:  MOVFF  3F9,862
0CBE2:  MOVLW  05
0CBE4:  MOVLB  8
0CBE6:  MOVWF  x66
0CBE8:  MOVLB  0
0CBEA:  CALL   C3A6
0CBEE:  MOVLW  2C
0CBF0:  BTFSS  F9E.4
0CBF2:  BRA    CBF0
0CBF4:  MOVWF  FAD
0CBF6:  MOVLW  89
0CBF8:  MOVWF  FE9
0CBFA:  MOVFF  400,865
0CBFE:  MOVFF  3FF,864
0CC02:  MOVFF  3FE,863
0CC06:  MOVFF  3FD,862
0CC0A:  MOVLW  05
0CC0C:  MOVLB  8
0CC0E:  MOVWF  x66
0CC10:  MOVLB  0
0CC12:  CALL   C3A6
0CC16:  MOVLW  0D
0CC18:  BTFSS  F9E.4
0CC1A:  BRA    CC18
0CC1C:  MOVWF  FAD
0CC1E:  MOVLW  0A
0CC20:  BTFSS  F9E.4
0CC22:  BRA    CC20
0CC24:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CC26:  MOVLW  32
0CC28:  MOVWF  FF6
0CC2A:  MOVLW  24
0CC2C:  MOVWF  FF7
0CC2E:  MOVLW  00
0CC30:  MOVWF  FF8
0CC32:  CLRF   1B
0CC34:  BTFSC  FF2.7
0CC36:  BSF    1B.7
0CC38:  BCF    FF2.7
0CC3A:  MOVLW  04
0CC3C:  MOVLB  A
0CC3E:  MOVWF  x18
0CC40:  MOVLB  0
0CC42:  CALL   1010
0CC46:  BTFSC  1B.7
0CC48:  BSF    FF2.7
0CC4A:  MOVLW  89
0CC4C:  MOVWF  FE9
0CC4E:  MOVFF  404,865
0CC52:  MOVFF  403,864
0CC56:  MOVFF  402,863
0CC5A:  MOVFF  401,862
0CC5E:  MOVLW  05
0CC60:  MOVLB  8
0CC62:  MOVWF  x66
0CC64:  MOVLB  0
0CC66:  CALL   C3A6
0CC6A:  MOVLW  2C
0CC6C:  BTFSS  F9E.4
0CC6E:  BRA    CC6C
0CC70:  MOVWF  FAD
0CC72:  MOVLW  89
0CC74:  MOVWF  FE9
0CC76:  MOVFF  408,865
0CC7A:  MOVFF  407,864
0CC7E:  MOVFF  406,863
0CC82:  MOVFF  405,862
0CC86:  MOVLW  05
0CC88:  MOVLB  8
0CC8A:  MOVWF  x66
0CC8C:  MOVLB  0
0CC8E:  CALL   C3A6
0CC92:  MOVLW  0D
0CC94:  BTFSS  F9E.4
0CC96:  BRA    CC94
0CC98:  MOVWF  FAD
0CC9A:  MOVLW  0A
0CC9C:  BTFSS  F9E.4
0CC9E:  BRA    CC9C
0CCA0:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CCA2:  MOVLW  44
0CCA4:  MOVWF  FF6
0CCA6:  MOVLW  24
0CCA8:  MOVWF  FF7
0CCAA:  MOVLW  00
0CCAC:  MOVWF  FF8
0CCAE:  CLRF   1B
0CCB0:  BTFSC  FF2.7
0CCB2:  BSF    1B.7
0CCB4:  BCF    FF2.7
0CCB6:  MOVLW  05
0CCB8:  MOVLB  A
0CCBA:  MOVWF  x18
0CCBC:  MOVLB  0
0CCBE:  CALL   1010
0CCC2:  BTFSC  1B.7
0CCC4:  BSF    FF2.7
0CCC6:  MOVLW  89
0CCC8:  MOVWF  FE9
0CCCA:  MOVFF  40C,865
0CCCE:  MOVFF  40B,864
0CCD2:  MOVFF  40A,863
0CCD6:  MOVFF  409,862
0CCDA:  MOVLW  05
0CCDC:  MOVLB  8
0CCDE:  MOVWF  x66
0CCE0:  MOVLB  0
0CCE2:  CALL   C3A6
0CCE6:  MOVLW  2C
0CCE8:  BTFSS  F9E.4
0CCEA:  BRA    CCE8
0CCEC:  MOVWF  FAD
0CCEE:  MOVLW  89
0CCF0:  MOVWF  FE9
0CCF2:  MOVFF  410,865
0CCF6:  MOVFF  40F,864
0CCFA:  MOVFF  40E,863
0CCFE:  MOVFF  40D,862
0CD02:  MOVLW  05
0CD04:  MOVLB  8
0CD06:  MOVWF  x66
0CD08:  MOVLB  0
0CD0A:  CALL   C3A6
0CD0E:  MOVLW  0D
0CD10:  BTFSS  F9E.4
0CD12:  BRA    CD10
0CD14:  MOVWF  FAD
0CD16:  MOVLW  0A
0CD18:  BTFSS  F9E.4
0CD1A:  BRA    CD18
0CD1C:  MOVWF  FAD
....................                   break; 
0CD1E:  BRA    D004
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0CD20:  MOVLW  58
0CD22:  MOVWF  FF6
0CD24:  MOVLW  24
0CD26:  MOVWF  FF7
0CD28:  MOVLW  00
0CD2A:  MOVWF  FF8
0CD2C:  CLRF   1B
0CD2E:  BTFSC  FF2.7
0CD30:  BSF    1B.7
0CD32:  BCF    FF2.7
0CD34:  CALL   0E3A
0CD38:  BTFSC  1B.7
0CD3A:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0CD3C:  RCALL  CA0E
0CD3E:  MOVFF  03,3F4
0CD42:  MOVFF  02,3F3
0CD46:  MOVFF  01,3F2
0CD4A:  MOVFF  00,3F1
....................                fprintf(COM_A,"\r\n");   
0CD4E:  MOVLW  0D
0CD50:  BTFSS  F9E.4
0CD52:  BRA    CD50
0CD54:  MOVWF  FAD
0CD56:  MOVLW  0A
0CD58:  BTFSS  F9E.4
0CD5A:  BRA    CD58
0CD5C:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0CD5E:  MOVLB  8
0CD60:  CLRF   x63
0CD62:  MOVLW  44
0CD64:  MOVWF  x62
0CD66:  MOVFF  3F4,867
0CD6A:  MOVFF  3F3,866
0CD6E:  MOVFF  3F2,865
0CD72:  MOVFF  3F1,864
0CD76:  MOVLB  0
0CD78:  RCALL  CA54
....................          break; 
0CD7A:  BRA    D004
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0CD7C:  MOVLW  60
0CD7E:  MOVWF  FF6
0CD80:  MOVLW  24
0CD82:  MOVWF  FF7
0CD84:  MOVLW  00
0CD86:  MOVWF  FF8
0CD88:  CLRF   1B
0CD8A:  BTFSC  FF2.7
0CD8C:  BSF    1B.7
0CD8E:  BCF    FF2.7
0CD90:  CALL   0E3A
0CD94:  BTFSC  1B.7
0CD96:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0CD98:  RCALL  CA0E
0CD9A:  MOVFF  03,3F8
0CD9E:  MOVFF  02,3F7
0CDA2:  MOVFF  01,3F6
0CDA6:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");  
0CDAA:  MOVLW  0D
0CDAC:  BTFSS  F9E.4
0CDAE:  BRA    CDAC
0CDB0:  MOVWF  FAD
0CDB2:  MOVLW  0A
0CDB4:  BTFSS  F9E.4
0CDB6:  BRA    CDB4
0CDB8:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0CDBA:  MOVLB  8
0CDBC:  CLRF   x63
0CDBE:  MOVLW  48
0CDC0:  MOVWF  x62
0CDC2:  MOVFF  3F8,867
0CDC6:  MOVFF  3F7,866
0CDCA:  MOVFF  3F6,865
0CDCE:  MOVFF  3F5,864
0CDD2:  MOVLB  0
0CDD4:  RCALL  CA54
....................          break; 
0CDD6:  BRA    D004
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0CDD8:  MOVLW  68
0CDDA:  MOVWF  FF6
0CDDC:  MOVLW  24
0CDDE:  MOVWF  FF7
0CDE0:  MOVLW  00
0CDE2:  MOVWF  FF8
0CDE4:  CLRF   1B
0CDE6:  BTFSC  FF2.7
0CDE8:  BSF    1B.7
0CDEA:  BCF    FF2.7
0CDEC:  CALL   0E3A
0CDF0:  BTFSC  1B.7
0CDF2:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0CDF4:  RCALL  CA0E
0CDF6:  MOVFF  03,3FC
0CDFA:  MOVFF  02,3FB
0CDFE:  MOVFF  01,3FA
0CE02:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n"); 
0CE06:  MOVLW  0D
0CE08:  BTFSS  F9E.4
0CE0A:  BRA    CE08
0CE0C:  MOVWF  FAD
0CE0E:  MOVLW  0A
0CE10:  BTFSS  F9E.4
0CE12:  BRA    CE10
0CE14:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0CE16:  MOVLB  8
0CE18:  CLRF   x63
0CE1A:  MOVLW  4C
0CE1C:  MOVWF  x62
0CE1E:  MOVFF  3FC,867
0CE22:  MOVFF  3FB,866
0CE26:  MOVFF  3FA,865
0CE2A:  MOVFF  3F9,864
0CE2E:  MOVLB  0
0CE30:  RCALL  CA54
....................          break; 
0CE32:  BRA    D004
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0CE34:  MOVLW  70
0CE36:  MOVWF  FF6
0CE38:  MOVLW  24
0CE3A:  MOVWF  FF7
0CE3C:  MOVLW  00
0CE3E:  MOVWF  FF8
0CE40:  CLRF   1B
0CE42:  BTFSC  FF2.7
0CE44:  BSF    1B.7
0CE46:  BCF    FF2.7
0CE48:  CALL   0E3A
0CE4C:  BTFSC  1B.7
0CE4E:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0CE50:  RCALL  CA0E
0CE52:  MOVFF  03,400
0CE56:  MOVFF  02,3FF
0CE5A:  MOVFF  01,3FE
0CE5E:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n");  
0CE62:  MOVLW  0D
0CE64:  BTFSS  F9E.4
0CE66:  BRA    CE64
0CE68:  MOVWF  FAD
0CE6A:  MOVLW  0A
0CE6C:  BTFSS  F9E.4
0CE6E:  BRA    CE6C
0CE70:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0CE72:  MOVLB  8
0CE74:  CLRF   x63
0CE76:  MOVLW  52
0CE78:  MOVWF  x62
0CE7A:  MOVFF  3F8,867
0CE7E:  MOVFF  3F7,866
0CE82:  MOVFF  3F6,865
0CE86:  MOVFF  3F5,864
0CE8A:  MOVLB  0
0CE8C:  RCALL  CA54
....................          break; 
0CE8E:  BRA    D004
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0CE90:  MOVLW  78
0CE92:  MOVWF  FF6
0CE94:  MOVLW  24
0CE96:  MOVWF  FF7
0CE98:  MOVLW  00
0CE9A:  MOVWF  FF8
0CE9C:  CLRF   1B
0CE9E:  BTFSC  FF2.7
0CEA0:  BSF    1B.7
0CEA2:  BCF    FF2.7
0CEA4:  CALL   0E3A
0CEA8:  BTFSC  1B.7
0CEAA:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0CEAC:  RCALL  CA0E
0CEAE:  MOVFF  03,404
0CEB2:  MOVFF  02,403
0CEB6:  MOVFF  01,402
0CEBA:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");   
0CEBE:  MOVLW  0D
0CEC0:  BTFSS  F9E.4
0CEC2:  BRA    CEC0
0CEC4:  MOVWF  FAD
0CEC6:  MOVLW  0A
0CEC8:  BTFSS  F9E.4
0CECA:  BRA    CEC8
0CECC:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0CECE:  MOVLB  8
0CED0:  CLRF   x63
0CED2:  MOVLW  56
0CED4:  MOVWF  x62
0CED6:  MOVFF  404,867
0CEDA:  MOVFF  403,866
0CEDE:  MOVFF  402,865
0CEE2:  MOVFF  401,864
0CEE6:  MOVLB  0
0CEE8:  RCALL  CA54
....................          break; 
0CEEA:  BRA    D004
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0CEEC:  MOVLW  80
0CEEE:  MOVWF  FF6
0CEF0:  MOVLW  24
0CEF2:  MOVWF  FF7
0CEF4:  MOVLW  00
0CEF6:  MOVWF  FF8
0CEF8:  CLRF   1B
0CEFA:  BTFSC  FF2.7
0CEFC:  BSF    1B.7
0CEFE:  BCF    FF2.7
0CF00:  CALL   0E3A
0CF04:  BTFSC  1B.7
0CF06:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0CF08:  RCALL  CA0E
0CF0A:  MOVFF  03,408
0CF0E:  MOVFF  02,407
0CF12:  MOVFF  01,406
0CF16:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");  
0CF1A:  MOVLW  0D
0CF1C:  BTFSS  F9E.4
0CF1E:  BRA    CF1C
0CF20:  MOVWF  FAD
0CF22:  MOVLW  0A
0CF24:  BTFSS  F9E.4
0CF26:  BRA    CF24
0CF28:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0CF2A:  MOVLB  8
0CF2C:  CLRF   x63
0CF2E:  MOVLW  5A
0CF30:  MOVWF  x62
0CF32:  MOVFF  408,867
0CF36:  MOVFF  407,866
0CF3A:  MOVFF  406,865
0CF3E:  MOVFF  405,864
0CF42:  MOVLB  0
0CF44:  RCALL  CA54
....................          break; 
0CF46:  BRA    D004
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0CF48:  MOVLW  88
0CF4A:  MOVWF  FF6
0CF4C:  MOVLW  24
0CF4E:  MOVWF  FF7
0CF50:  MOVLW  00
0CF52:  MOVWF  FF8
0CF54:  CLRF   1B
0CF56:  BTFSC  FF2.7
0CF58:  BSF    1B.7
0CF5A:  BCF    FF2.7
0CF5C:  CALL   0E3A
0CF60:  BTFSC  1B.7
0CF62:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0CF64:  RCALL  CA0E
0CF66:  MOVFF  03,40C
0CF6A:  MOVFF  02,40B
0CF6E:  MOVFF  01,40A
0CF72:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");   
0CF76:  MOVLW  0D
0CF78:  BTFSS  F9E.4
0CF7A:  BRA    CF78
0CF7C:  MOVWF  FAD
0CF7E:  MOVLW  0A
0CF80:  BTFSS  F9E.4
0CF82:  BRA    CF80
0CF84:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0CF86:  MOVLB  8
0CF88:  CLRF   x63
0CF8A:  MOVLW  5E
0CF8C:  MOVWF  x62
0CF8E:  MOVFF  40C,867
0CF92:  MOVFF  40B,866
0CF96:  MOVFF  40A,865
0CF9A:  MOVFF  409,864
0CF9E:  MOVLB  0
0CFA0:  RCALL  CA54
....................          break; 
0CFA2:  BRA    D004
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0CFA4:  MOVLW  92
0CFA6:  MOVWF  FF6
0CFA8:  MOVLW  24
0CFAA:  MOVWF  FF7
0CFAC:  MOVLW  00
0CFAE:  MOVWF  FF8
0CFB0:  CLRF   1B
0CFB2:  BTFSC  FF2.7
0CFB4:  BSF    1B.7
0CFB6:  BCF    FF2.7
0CFB8:  CALL   0E3A
0CFBC:  BTFSC  1B.7
0CFBE:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0CFC0:  RCALL  CA0E
0CFC2:  MOVFF  03,410
0CFC6:  MOVFF  02,40F
0CFCA:  MOVFF  01,40E
0CFCE:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");  
0CFD2:  MOVLW  0D
0CFD4:  BTFSS  F9E.4
0CFD6:  BRA    CFD4
0CFD8:  MOVWF  FAD
0CFDA:  MOVLW  0A
0CFDC:  BTFSS  F9E.4
0CFDE:  BRA    CFDC
0CFE0:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0CFE2:  MOVLB  8
0CFE4:  CLRF   x63
0CFE6:  MOVLW  62
0CFE8:  MOVWF  x62
0CFEA:  MOVFF  410,867
0CFEE:  MOVFF  40F,866
0CFF2:  MOVFF  40E,865
0CFF6:  MOVFF  40D,864
0CFFA:  MOVLB  0
0CFFC:  RCALL  CA54
....................          break;         
0CFFE:  BRA    D004
....................       default: cmd_arg(); 
0D000:  CALL   AF70
....................          break; 
....................    } 
0D004:  GOTO   D9FA (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0D714:  MOVF   47,F
0D716:  BNZ   D726
0D718:  MOVF   46,F
0D71A:  BNZ   D726
0D71C:  MOVF   45,F
0D71E:  BNZ   D726
0D720:  MOVF   44,W
0D722:  SUBLW  01
0D724:  BC    D776
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0D726:  MOVF   47,F
0D728:  BNZ   D740
0D72A:  MOVF   46,F
0D72C:  BNZ   D740
0D72E:  MOVF   45,F
0D730:  BNZ   D740
0D732:  MOVF   44,W
0D734:  SUBLW  30
0D736:  BNC   D740
0D738:  DECFSZ 2F,W
0D73A:  BRA    D740
0D73C:  MOVF   30,F
0D73E:  BZ    D75C
0D740:  MOVF   47,F
0D742:  BNZ   D770
0D744:  MOVF   46,F
0D746:  BNZ   D770
0D748:  MOVF   45,F
0D74A:  BNZ   D770
0D74C:  MOVF   44,W
0D74E:  SUBLW  32
0D750:  BNC   D770
0D752:  MOVF   2F,W
0D754:  SUBLW  03
0D756:  BNZ   D770
0D758:  MOVF   30,F
0D75A:  BNZ   D770
....................          port=arg; 
0D75C:  MOVFF  45,863
0D760:  MOVFF  44,862
....................          play_wms_hard_macro(port);    
0D764:  MOVFF  863,867
0D768:  MOVFF  862,866
0D76C:  RCALL  D506
....................       } 
0D76E:  BRA    D774
....................       else cmd_arg(); 
0D770:  CALL   AF70
....................    } 
0D774:  BRA    D77A
....................    else cmd_arg(); 
0D776:  CALL   AF70
0D77A:  GOTO   D9FA (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0D98A:  MOVF   44,F
0D98C:  BNZ   D99A
0D98E:  MOVF   45,F
0D990:  BNZ   D99A
0D992:  MOVF   46,F
0D994:  BNZ   D99A
0D996:  MOVF   47,F
0D998:  BZ    D9B8
0D99A:  MOVF   47,F
0D99C:  BNZ   D9B8
0D99E:  MOVF   46,F
0D9A0:  BNZ   D9B8
0D9A2:  MOVF   45,F
0D9A4:  BNZ   D9B8
0D9A6:  MOVF   44,W
0D9A8:  SUBLW  04
0D9AA:  BNC   D9B8
....................       chip=arg; 
0D9AC:  MOVFF  44,862
....................       sol_chip_cmd(chip); 
0D9B0:  MOVFF  862,893
0D9B4:  RCALL  D8BC
....................    } 
0D9B6:  BRA    D9BC
....................    else cmd_arg();    
0D9B8:  CALL   AF70
0D9BC:  GOTO   D9FA (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0D9C0:  MOVF   2F,W
0D9C2:  MOVWF  00
0D9C4:  MOVF   30,W
0D9C6:  MOVWF  03
0D9C8:  BNZ   D9CE
0D9CA:  MOVF   00,F
0D9CC:  BZ    D9EE
0D9CE:  MOVF   03,W
0D9D0:  BNZ   D9D8
0D9D2:  MOVLW  01
0D9D4:  SUBWF  00,W
0D9D6:  BZ    D9F4
0D9D8:  MOVF   03,W
0D9DA:  BNZ   D9E2
0D9DC:  MOVLW  03
0D9DE:  SUBWF  00,W
0D9E0:  BZ    D9F4
0D9E2:  MOVF   03,W
0D9E4:  BNZ   D9EC
0D9E6:  MOVLW  02
0D9E8:  SUBWF  00,W
0D9EA:  BZ    D9F8
0D9EC:  BRA    D9FA
....................       case ECO : commandCe(); 
0D9EE:  GOTO   CAC2
....................          break; 
0D9F2:  BRA    D9FA
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0D9F4:  BRA    D714
....................          break; 
0D9F6:  BRA    D9FA
....................       case AWS : commandCa(); 
0D9F8:  BRA    D98A
....................          break;          
....................    } 
0D9FA:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0D9FE:  MOVF   44,W
0DA00:  MOVWF  00
0DA02:  MOVF   45,W
0DA04:  MOVWF  03
0DA06:  BNZ   DA0C
0DA08:  MOVF   00,F
0DA0A:  BZ    DA2C
0DA0C:  MOVF   03,W
0DA0E:  BNZ   DA16
0DA10:  MOVLW  01
0DA12:  SUBWF  00,W
0DA14:  BZ    DA3E
0DA16:  MOVF   03,W
0DA18:  BNZ   DA20
0DA1A:  MOVLW  02
0DA1C:  SUBWF  00,W
0DA1E:  BZ    DA60
0DA20:  MOVF   03,W
0DA22:  BNZ   DA2A
0DA24:  MOVLW  03
0DA26:  SUBWF  00,W
0DA28:  BZ    DA72
0DA2A:  BRA    DA90
....................       case 0 : file_list(file_ptr_raw_all); 
0DA2C:  MOVLW  02
0DA2E:  MOVLB  8
0DA30:  MOVWF  x67
0DA32:  MOVLW  D9
0DA34:  MOVWF  x66
0DA36:  MOVLB  0
0DA38:  CALL   B796
....................          break; 
0DA3C:  BRA    DA94
....................       case 1 : file_list(file_ptr_raw_new); 
0DA3E:  MOVLW  02
0DA40:  MOVLB  8
0DA42:  MOVWF  x67
0DA44:  MOVLW  E7
0DA46:  MOVWF  x66
0DA48:  MOVLB  0
0DA4A:  CALL   B796
....................                f_unlink(file_ptr_raw_new); 
0DA4E:  MOVLW  02
0DA50:  MOVLB  8
0DA52:  MOVWF  x67
0DA54:  MOVLW  E7
0DA56:  MOVWF  x66
0DA58:  MOVLB  0
0DA5A:  CALL   B910
....................          break; 
0DA5E:  BRA    DA94
....................       case 2 : file_list(file_ptr_rel_all); 
0DA60:  MOVLW  02
0DA62:  MOVLB  8
0DA64:  MOVWF  x67
0DA66:  MOVLW  F5
0DA68:  MOVWF  x66
0DA6A:  MOVLB  0
0DA6C:  CALL   B796
....................          break; 
0DA70:  BRA    DA94
....................       case 3 : file_list(file_ptr_rel_new); 
0DA72:  MOVLW  03
0DA74:  MOVLB  8
0DA76:  MOVWF  x67
0DA78:  MOVWF  x66
0DA7A:  MOVLB  0
0DA7C:  CALL   B796
....................                f_unlink(file_ptr_rel_new); 
0DA80:  MOVLW  03
0DA82:  MOVLB  8
0DA84:  MOVWF  x67
0DA86:  MOVWF  x66
0DA88:  MOVLB  0
0DA8A:  CALL   B910
....................          break;  
0DA8E:  BRA    DA94
....................       default : cmd_arg(); 
0DA90:  CALL   AF70
....................          break; 
....................    } 
0DA94:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DA98:  MOVF   44,W
0DA9A:  MOVWF  00
0DA9C:  MOVF   45,W
0DA9E:  MOVWF  03
0DAA0:  BNZ   DAA6
0DAA2:  MOVF   00,F
0DAA4:  BZ    DAB2
0DAA6:  MOVF   03,W
0DAA8:  BNZ   DAB0
0DAAA:  MOVLW  02
0DAAC:  SUBWF  00,W
0DAAE:  BZ    DB2C
0DAB0:  BRA    DBA6
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DAB2:  MOVLW  9C
0DAB4:  MOVWF  FF6
0DAB6:  MOVLW  24
0DAB8:  MOVWF  FF7
0DABA:  MOVLW  00
0DABC:  MOVWF  FF8
0DABE:  CLRF   1B
0DAC0:  BTFSC  FF2.7
0DAC2:  BSF    1B.7
0DAC4:  BCF    FF2.7
0DAC6:  CALL   0E3A
0DACA:  BTFSC  1B.7
0DACC:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DACE:  CALL   0E24
0DAD2:  MOVFF  01,862
....................       if(result == 'Y'){ 
0DAD6:  MOVLB  8
0DAD8:  MOVF   x62,W
0DADA:  SUBLW  59
0DADC:  BNZ   DB0C
....................       f_unlink(file_ptr_raw_all); 
0DADE:  MOVLW  02
0DAE0:  MOVWF  x67
0DAE2:  MOVLW  D9
0DAE4:  MOVWF  x66
0DAE6:  MOVLB  0
0DAE8:  CALL   B910
....................       printf("File deleted!\n\r"); 
0DAEC:  MOVLW  D8
0DAEE:  MOVWF  FF6
0DAF0:  MOVLW  24
0DAF2:  MOVWF  FF7
0DAF4:  MOVLW  00
0DAF6:  MOVWF  FF8
0DAF8:  CLRF   1B
0DAFA:  BTFSC  FF2.7
0DAFC:  BSF    1B.7
0DAFE:  BCF    FF2.7
0DB00:  CALL   0E3A
0DB04:  BTFSC  1B.7
0DB06:  BSF    FF2.7
....................       }else{ 
0DB08:  BRA    DB2A
0DB0A:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DB0C:  MOVLW  E8
0DB0E:  MOVWF  FF6
0DB10:  MOVLW  24
0DB12:  MOVWF  FF7
0DB14:  MOVLW  00
0DB16:  MOVWF  FF8
0DB18:  CLRF   1B
0DB1A:  BTFSC  FF2.7
0DB1C:  BSF    1B.7
0DB1E:  BCF    FF2.7
0DB20:  MOVLB  0
0DB22:  CALL   0E3A
0DB26:  BTFSC  1B.7
0DB28:  BSF    FF2.7
....................       } 
....................          break; 
0DB2A:  BRA    DBAA
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DB2C:  MOVLW  FE
0DB2E:  MOVWF  FF6
0DB30:  MOVLW  24
0DB32:  MOVWF  FF7
0DB34:  MOVLW  00
0DB36:  MOVWF  FF8
0DB38:  CLRF   1B
0DB3A:  BTFSC  FF2.7
0DB3C:  BSF    1B.7
0DB3E:  BCF    FF2.7
0DB40:  CALL   0E3A
0DB44:  BTFSC  1B.7
0DB46:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DB48:  CALL   0E24
0DB4C:  MOVFF  01,862
....................          if(result == 'Y'){ 
0DB50:  MOVLB  8
0DB52:  MOVF   x62,W
0DB54:  SUBLW  59
0DB56:  BNZ   DB86
....................             f_unlink(file_ptr_rel_all); 
0DB58:  MOVLW  02
0DB5A:  MOVWF  x67
0DB5C:  MOVLW  F5
0DB5E:  MOVWF  x66
0DB60:  MOVLB  0
0DB62:  CALL   B910
....................             printf("File deleted!\n\r"); 
0DB66:  MOVLW  42
0DB68:  MOVWF  FF6
0DB6A:  MOVLW  25
0DB6C:  MOVWF  FF7
0DB6E:  MOVLW  00
0DB70:  MOVWF  FF8
0DB72:  CLRF   1B
0DB74:  BTFSC  FF2.7
0DB76:  BSF    1B.7
0DB78:  BCF    FF2.7
0DB7A:  CALL   0E3A
0DB7E:  BTFSC  1B.7
0DB80:  BSF    FF2.7
....................          }else{ 
0DB82:  BRA    DBA4
0DB84:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DB86:  MOVLW  52
0DB88:  MOVWF  FF6
0DB8A:  MOVLW  25
0DB8C:  MOVWF  FF7
0DB8E:  MOVLW  00
0DB90:  MOVWF  FF8
0DB92:  CLRF   1B
0DB94:  BTFSC  FF2.7
0DB96:  BSF    1B.7
0DB98:  BCF    FF2.7
0DB9A:  MOVLB  0
0DB9C:  CALL   0E3A
0DBA0:  BTFSC  1B.7
0DBA2:  BSF    FF2.7
....................          } 
....................          break; 
0DBA4:  BRA    DBAA
....................       default : cmd_arg(); 
0DBA6:  CALL   AF70
....................          break;          
....................    } 
0DBAA:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0DD96:  MOVF   44,W
0DD98:  SUBLW  95
0DD9A:  BNZ   DDAE
0DD9C:  MOVF   45,W
0DD9E:  SUBLW  15
0DDA0:  BNZ   DDAE
0DDA2:  MOVF   46,F
0DDA4:  BNZ   DDAE
0DDA6:  MOVF   47,F
0DDA8:  BNZ   DDAE
....................       reset_nv_vars(); 
0DDAA:  BRA    DBAE
....................    } 
0DDAC:  BRA    DDB2
....................    else cmd_arg(); 
0DDAE:  CALL   AF70
0DDB2:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0DE00:  MOVF   2F,F
0DE02:  BNZ   DE08
0DE04:  MOVF   30,F
0DE06:  BZ    DE1A
0DE08:  DECFSZ 2F,W
0DE0A:  BRA    DE10
0DE0C:  MOVF   30,F
0DE0E:  BZ    DE1A
0DE10:  MOVF   2F,W
0DE12:  SUBLW  03
0DE14:  BNZ   DE8C
0DE16:  MOVF   30,F
0DE18:  BNZ   DE8C
....................    { 
....................       busy_set(); 
0DE1A:  CALL   2948
....................  
....................       switch(arg) 
0DE1E:  MOVFF  44,00
0DE22:  MOVF   45,W
0DE24:  MOVWF  03
0DE26:  BNZ   DE2E
0DE28:  MOVLW  01
0DE2A:  SUBWF  00,W
0DE2C:  BZ    DE44
0DE2E:  MOVF   03,W
0DE30:  BNZ   DE38
0DE32:  MOVLW  02
0DE34:  SUBWF  00,W
0DE36:  BZ    DE54
0DE38:  MOVF   03,W
0DE3A:  BNZ   DE42
0DE3C:  MOVLW  03
0DE3E:  SUBWF  00,W
0DE40:  BZ    DE7E
0DE42:  BRA    DE84
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0DE44:  MOVLB  7
0DE46:  CLRF   x3C
....................             align(0); 
0DE48:  MOVLB  8
0DE4A:  CLRF   x9F
0DE4C:  MOVLB  0
0DE4E:  CALL   A7F4
....................             break; 
0DE52:  BRA    DE88
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0DE54:  MOVF   44,W
0DE56:  SUBLW  02
0DE58:  BNZ   DE7C
0DE5A:  MOVF   45,F
0DE5C:  BNZ   DE7C
0DE5E:  MOVF   46,F
0DE60:  BNZ   DE7C
0DE62:  MOVF   47,F
0DE64:  BNZ   DE7C
0DE66:  MOVF   1F,W
0DE68:  SUBLW  04
0DE6A:  BNZ   DE7C
0DE6C:  MOVF   20,F
0DE6E:  BNZ   DE7C
....................             { 
....................                motor=0; 
0DE70:  MOVLB  7
0DE72:  CLRF   x3C
....................                cal_disk(0); 
0DE74:  MOVLB  8
0DE76:  CLRF   x62
0DE78:  MOVLB  0
0DE7A:  BRA    DDB6
....................             } 
....................             break; 
0DE7C:  BRA    DE88
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0DE7E:  CALL   A998
....................             break; 
0DE82:  BRA    DE88
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0DE84:  CALL   AF70
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0DE88:  CALL   ADAC
....................    } 
0DE8C:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E366:  DECFSZ 44,W
0E368:  BRA    E786
0E36A:  MOVF   45,F
0E36C:  BTFSS  FD8.2
0E36E:  BRA    E786
0E370:  MOVF   46,F
0E372:  BTFSS  FD8.2
0E374:  BRA    E786
0E376:  MOVF   47,F
0E378:  BTFSS  FD8.2
0E37A:  BRA    E786
....................       v_supply = read_supply(); 
0E37C:  CALL   507E
0E380:  MOVFF  02,863
0E384:  MOVFF  01,862
....................        
....................       RTC_reset_HT(); 
0E388:  CALL   343A
....................       RTC_read(); 
0E38C:  CALL   32CC
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E390:  MOVLW  68
0E392:  MOVWF  FF6
0E394:  MOVLW  25
0E396:  MOVWF  FF7
0E398:  MOVLW  00
0E39A:  MOVWF  FF8
0E39C:  CLRF   1B
0E39E:  BTFSC  FF2.7
0E3A0:  BSF    1B.7
0E3A2:  BCF    FF2.7
0E3A4:  MOVLW  04
0E3A6:  MOVLB  A
0E3A8:  MOVWF  x18
0E3AA:  MOVLB  0
0E3AC:  CALL   1010
0E3B0:  BTFSC  1B.7
0E3B2:  BSF    FF2.7
0E3B4:  MOVLW  10
0E3B6:  MOVWF  FE9
0E3B8:  CLRF   1B
0E3BA:  BTFSC  FF2.7
0E3BC:  BSF    1B.7
0E3BE:  BCF    FF2.7
0E3C0:  MOVFF  26,A19
0E3C4:  MOVFF  25,A18
0E3C8:  CALL   1192
0E3CC:  BTFSC  1B.7
0E3CE:  BSF    FF2.7
0E3D0:  MOVLW  20
0E3D2:  BTFSS  F9E.4
0E3D4:  BRA    E3D2
0E3D6:  MOVWF  FAD
0E3D8:  MOVLW  49
0E3DA:  BTFSS  F9E.4
0E3DC:  BRA    E3DA
0E3DE:  MOVWF  FAD
0E3E0:  MOVLW  10
0E3E2:  MOVWF  FE9
0E3E4:  CLRF   1B
0E3E6:  BTFSC  FF2.7
0E3E8:  BSF    1B.7
0E3EA:  BCF    FF2.7
0E3EC:  MOVFF  24,A19
0E3F0:  MOVFF  23,A18
0E3F4:  CALL   1192
0E3F8:  BTFSC  1B.7
0E3FA:  BSF    FF2.7
0E3FC:  MOVLW  20
0E3FE:  BTFSS  F9E.4
0E400:  BRA    E3FE
0E402:  MOVWF  FAD
0E404:  MOVLW  4E
0E406:  BTFSS  F9E.4
0E408:  BRA    E406
0E40A:  MOVWF  FAD
0E40C:  MOVLW  10
0E40E:  MOVWF  FE9
0E410:  CLRF   1B
0E412:  BTFSC  FF2.7
0E414:  BSF    1B.7
0E416:  BCF    FF2.7
0E418:  MOVFF  22,A19
0E41C:  MOVFF  21,A18
0E420:  CALL   1192
0E424:  BTFSC  1B.7
0E426:  BSF    FF2.7
0E428:  MOVLW  2F
0E42A:  BTFSS  F9E.4
0E42C:  BRA    E42A
0E42E:  MOVWF  FAD
0E430:  MOVLW  10
0E432:  MOVWF  FE9
0E434:  CLRF   1B
0E436:  BTFSC  FF2.7
0E438:  BSF    1B.7
0E43A:  BCF    FF2.7
0E43C:  MOVFF  28,A19
0E440:  MOVFF  27,A18
0E444:  CALL   1192
0E448:  BTFSC  1B.7
0E44A:  BSF    FF2.7
0E44C:  MOVLW  20
0E44E:  BTFSS  F9E.4
0E450:  BRA    E44E
0E452:  MOVWF  FAD
0E454:  MOVLW  58
0E456:  BTFSS  F9E.4
0E458:  BRA    E456
0E45A:  MOVWF  FAD
0E45C:  MOVLW  10
0E45E:  MOVWF  FE9
0E460:  CLRF   1B
0E462:  BTFSC  FF2.7
0E464:  BSF    1B.7
0E466:  BCF    FF2.7
0E468:  MOVFF  20,A19
0E46C:  MOVFF  1F,A18
0E470:  CALL   1192
0E474:  BTFSC  1B.7
0E476:  BSF    FF2.7
0E478:  MOVLW  20
0E47A:  BTFSS  F9E.4
0E47C:  BRA    E47A
0E47E:  MOVWF  FAD
0E480:  MOVLW  55
0E482:  BTFSS  F9E.4
0E484:  BRA    E482
0E486:  MOVWF  FAD
0E488:  CLRF   1B
0E48A:  BTFSC  FF2.7
0E48C:  BSF    1B.7
0E48E:  BCF    FF2.7
0E490:  MOVFF  73C,A18
0E494:  MOVLW  1B
0E496:  MOVLB  A
0E498:  MOVWF  x19
0E49A:  MOVLB  0
0E49C:  CALL   0F92
0E4A0:  BTFSC  1B.7
0E4A2:  BSF    FF2.7
0E4A4:  MOVLW  20
0E4A6:  BTFSS  F9E.4
0E4A8:  BRA    E4A6
0E4AA:  MOVWF  FAD
0E4AC:  MOVLW  04
0E4AE:  MOVWF  FE9
0E4B0:  MOVLB  8
0E4B2:  CLRF   x67
0E4B4:  CLRF   x66
0E4B6:  MOVFF  863,865
0E4BA:  MOVFF  862,864
0E4BE:  MOVLW  02
0E4C0:  MOVWF  x68
0E4C2:  MOVLB  0
0E4C4:  RCALL  DE90
0E4C6:  MOVLW  8C
0E4C8:  MOVWF  FF6
0E4CA:  MOVLW  25
0E4CC:  MOVWF  FF7
0E4CE:  MOVLW  00
0E4D0:  MOVWF  FF8
0E4D2:  CLRF   1B
0E4D4:  BTFSC  FF2.7
0E4D6:  BSF    1B.7
0E4D8:  BCF    FF2.7
0E4DA:  MOVLW  03
0E4DC:  MOVLB  A
0E4DE:  MOVWF  x18
0E4E0:  MOVLB  0
0E4E2:  CALL   1010
0E4E6:  BTFSC  1B.7
0E4E8:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E4EA:  MOVLW  90
0E4EC:  MOVWF  FF6
0E4EE:  MOVLW  25
0E4F0:  MOVWF  FF7
0E4F2:  MOVLW  00
0E4F4:  MOVWF  FF8
0E4F6:  CLRF   1B
0E4F8:  BTFSC  FF2.7
0E4FA:  BSF    1B.7
0E4FC:  BCF    FF2.7
0E4FE:  MOVLW  09
0E500:  MOVLB  A
0E502:  MOVWF  x18
0E504:  MOVLB  0
0E506:  CALL   1010
0E50A:  BTFSC  1B.7
0E50C:  BSF    FF2.7
0E50E:  MOVLW  10
0E510:  MOVWF  FE9
0E512:  CLRF   1B
0E514:  BTFSC  FF2.7
0E516:  BSF    1B.7
0E518:  BCF    FF2.7
0E51A:  MOVFF  7C0,A19
0E51E:  MOVFF  7BF,A18
0E522:  CALL   1192
0E526:  BTFSC  1B.7
0E528:  BSF    FF2.7
0E52A:  MOVLW  9C
0E52C:  MOVWF  FF6
0E52E:  MOVLW  25
0E530:  MOVWF  FF7
0E532:  MOVLW  00
0E534:  MOVWF  FF8
0E536:  CLRF   1B
0E538:  BTFSC  FF2.7
0E53A:  BSF    1B.7
0E53C:  BCF    FF2.7
0E53E:  MOVLW  05
0E540:  MOVLB  A
0E542:  MOVWF  x18
0E544:  MOVLB  0
0E546:  CALL   1010
0E54A:  BTFSC  1B.7
0E54C:  BSF    FF2.7
0E54E:  MOVLW  10
0E550:  MOVWF  FE9
0E552:  MOVFF  7B2,8CE
0E556:  MOVFF  7B1,8CD
0E55A:  CALL   8F24
0E55E:  MOVLW  0D
0E560:  BTFSS  F9E.4
0E562:  BRA    E560
0E564:  MOVWF  FAD
0E566:  MOVLW  0A
0E568:  BTFSS  F9E.4
0E56A:  BRA    E568
0E56C:  MOVWF  FAD
....................       RTC_display(); 
0E56E:  RCALL  DF8C
....................       if (RTCfmt == 0) 
0E570:  MOVF   4B,F
0E572:  BTFSS  FD8.2
0E574:  BRA    E67A
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E576:  MOVLW  A8
0E578:  MOVWF  FF6
0E57A:  MOVLW  25
0E57C:  MOVWF  FF7
0E57E:  MOVLW  00
0E580:  MOVWF  FF8
0E582:  CLRF   1B
0E584:  BTFSC  FF2.7
0E586:  BSF    1B.7
0E588:  BCF    FF2.7
0E58A:  MOVLW  05
0E58C:  MOVLB  A
0E58E:  MOVWF  x18
0E590:  MOVLB  0
0E592:  CALL   1010
0E596:  BTFSC  1B.7
0E598:  BSF    FF2.7
0E59A:  CLRF   1B
0E59C:  BTFSC  FF2.7
0E59E:  BSF    1B.7
0E5A0:  BCF    FF2.7
0E5A2:  MOVFF  736,A18
0E5A6:  MOVLW  01
0E5A8:  MOVLB  A
0E5AA:  MOVWF  x19
0E5AC:  MOVLB  0
0E5AE:  CALL   0F92
0E5B2:  BTFSC  1B.7
0E5B4:  BSF    FF2.7
0E5B6:  MOVLW  2F
0E5B8:  BTFSS  F9E.4
0E5BA:  BRA    E5B8
0E5BC:  MOVWF  FAD
0E5BE:  CLRF   1B
0E5C0:  BTFSC  FF2.7
0E5C2:  BSF    1B.7
0E5C4:  BCF    FF2.7
0E5C6:  MOVFF  737,A18
0E5CA:  MOVLW  01
0E5CC:  MOVLB  A
0E5CE:  MOVWF  x19
0E5D0:  MOVLB  0
0E5D2:  CALL   0F92
0E5D6:  BTFSC  1B.7
0E5D8:  BSF    FF2.7
0E5DA:  MOVLW  2F
0E5DC:  BTFSS  F9E.4
0E5DE:  BRA    E5DC
0E5E0:  MOVWF  FAD
0E5E2:  CLRF   1B
0E5E4:  BTFSC  FF2.7
0E5E6:  BSF    1B.7
0E5E8:  BCF    FF2.7
0E5EA:  MOVFF  738,A18
0E5EE:  MOVLW  01
0E5F0:  MOVLB  A
0E5F2:  MOVWF  x19
0E5F4:  MOVLB  0
0E5F6:  CALL   0F92
0E5FA:  BTFSC  1B.7
0E5FC:  BSF    FF2.7
0E5FE:  MOVLW  20
0E600:  BTFSS  F9E.4
0E602:  BRA    E600
0E604:  MOVWF  FAD
0E606:  CLRF   1B
0E608:  BTFSC  FF2.7
0E60A:  BSF    1B.7
0E60C:  BCF    FF2.7
0E60E:  MOVFF  739,A18
0E612:  MOVLW  01
0E614:  MOVLB  A
0E616:  MOVWF  x19
0E618:  MOVLB  0
0E61A:  CALL   0F92
0E61E:  BTFSC  1B.7
0E620:  BSF    FF2.7
0E622:  MOVLW  3A
0E624:  BTFSS  F9E.4
0E626:  BRA    E624
0E628:  MOVWF  FAD
0E62A:  CLRF   1B
0E62C:  BTFSC  FF2.7
0E62E:  BSF    1B.7
0E630:  BCF    FF2.7
0E632:  MOVFF  73A,A18
0E636:  MOVLW  01
0E638:  MOVLB  A
0E63A:  MOVWF  x19
0E63C:  MOVLB  0
0E63E:  CALL   0F92
0E642:  BTFSC  1B.7
0E644:  BSF    FF2.7
0E646:  MOVLW  3A
0E648:  BTFSS  F9E.4
0E64A:  BRA    E648
0E64C:  MOVWF  FAD
0E64E:  CLRF   1B
0E650:  BTFSC  FF2.7
0E652:  BSF    1B.7
0E654:  BCF    FF2.7
0E656:  MOVFF  73B,A18
0E65A:  MOVLW  01
0E65C:  MOVLB  A
0E65E:  MOVWF  x19
0E660:  MOVLB  0
0E662:  CALL   0F92
0E666:  BTFSC  1B.7
0E668:  BSF    FF2.7
0E66A:  MOVLW  0D
0E66C:  BTFSS  F9E.4
0E66E:  BRA    E66C
0E670:  MOVWF  FAD
0E672:  MOVLW  0A
0E674:  BTFSS  F9E.4
0E676:  BRA    E674
0E678:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E67A:  DECFSZ 4B,W
0E67C:  BRA    E782
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E67E:  MOVLW  CE
0E680:  MOVWF  FF6
0E682:  MOVLW  25
0E684:  MOVWF  FF7
0E686:  MOVLW  00
0E688:  MOVWF  FF8
0E68A:  CLRF   1B
0E68C:  BTFSC  FF2.7
0E68E:  BSF    1B.7
0E690:  BCF    FF2.7
0E692:  MOVLW  05
0E694:  MOVLB  A
0E696:  MOVWF  x18
0E698:  MOVLB  0
0E69A:  CALL   1010
0E69E:  BTFSC  1B.7
0E6A0:  BSF    FF2.7
0E6A2:  CLRF   1B
0E6A4:  BTFSC  FF2.7
0E6A6:  BSF    1B.7
0E6A8:  BCF    FF2.7
0E6AA:  MOVFF  737,A18
0E6AE:  MOVLW  01
0E6B0:  MOVLB  A
0E6B2:  MOVWF  x19
0E6B4:  MOVLB  0
0E6B6:  CALL   0F92
0E6BA:  BTFSC  1B.7
0E6BC:  BSF    FF2.7
0E6BE:  MOVLW  2F
0E6C0:  BTFSS  F9E.4
0E6C2:  BRA    E6C0
0E6C4:  MOVWF  FAD
0E6C6:  CLRF   1B
0E6C8:  BTFSC  FF2.7
0E6CA:  BSF    1B.7
0E6CC:  BCF    FF2.7
0E6CE:  MOVFF  736,A18
0E6D2:  MOVLW  01
0E6D4:  MOVLB  A
0E6D6:  MOVWF  x19
0E6D8:  MOVLB  0
0E6DA:  CALL   0F92
0E6DE:  BTFSC  1B.7
0E6E0:  BSF    FF2.7
0E6E2:  MOVLW  2F
0E6E4:  BTFSS  F9E.4
0E6E6:  BRA    E6E4
0E6E8:  MOVWF  FAD
0E6EA:  CLRF   1B
0E6EC:  BTFSC  FF2.7
0E6EE:  BSF    1B.7
0E6F0:  BCF    FF2.7
0E6F2:  MOVFF  738,A18
0E6F6:  MOVLW  01
0E6F8:  MOVLB  A
0E6FA:  MOVWF  x19
0E6FC:  MOVLB  0
0E6FE:  CALL   0F92
0E702:  BTFSC  1B.7
0E704:  BSF    FF2.7
0E706:  MOVLW  20
0E708:  BTFSS  F9E.4
0E70A:  BRA    E708
0E70C:  MOVWF  FAD
0E70E:  CLRF   1B
0E710:  BTFSC  FF2.7
0E712:  BSF    1B.7
0E714:  BCF    FF2.7
0E716:  MOVFF  739,A18
0E71A:  MOVLW  01
0E71C:  MOVLB  A
0E71E:  MOVWF  x19
0E720:  MOVLB  0
0E722:  CALL   0F92
0E726:  BTFSC  1B.7
0E728:  BSF    FF2.7
0E72A:  MOVLW  3A
0E72C:  BTFSS  F9E.4
0E72E:  BRA    E72C
0E730:  MOVWF  FAD
0E732:  CLRF   1B
0E734:  BTFSC  FF2.7
0E736:  BSF    1B.7
0E738:  BCF    FF2.7
0E73A:  MOVFF  73A,A18
0E73E:  MOVLW  01
0E740:  MOVLB  A
0E742:  MOVWF  x19
0E744:  MOVLB  0
0E746:  CALL   0F92
0E74A:  BTFSC  1B.7
0E74C:  BSF    FF2.7
0E74E:  MOVLW  3A
0E750:  BTFSS  F9E.4
0E752:  BRA    E750
0E754:  MOVWF  FAD
0E756:  CLRF   1B
0E758:  BTFSC  FF2.7
0E75A:  BSF    1B.7
0E75C:  BCF    FF2.7
0E75E:  MOVFF  73B,A18
0E762:  MOVLW  01
0E764:  MOVLB  A
0E766:  MOVWF  x19
0E768:  MOVLB  0
0E76A:  CALL   0F92
0E76E:  BTFSC  1B.7
0E770:  BSF    FF2.7
0E772:  MOVLW  0D
0E774:  BTFSS  F9E.4
0E776:  BRA    E774
0E778:  MOVWF  FAD
0E77A:  MOVLW  0A
0E77C:  BTFSS  F9E.4
0E77E:  BRA    E77C
0E780:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0E782:  RCALL  E116
....................       RTC_display_alarm(); 
0E784:  RCALL  E1EC
....................    } 
0E786:  GOTO   EF9A (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0E78A:  DECFSZ 44,W
0E78C:  BRA    EA64
0E78E:  MOVF   45,F
0E790:  BTFSS  FD8.2
0E792:  BRA    EA64
0E794:  MOVF   46,F
0E796:  BTFSS  FD8.2
0E798:  BRA    EA64
0E79A:  MOVF   47,F
0E79C:  BTFSS  FD8.2
0E79E:  BRA    EA64
....................       v_supply = read_supply(); 
0E7A0:  CALL   507E
0E7A4:  MOVFF  02,863
0E7A8:  MOVFF  01,862
....................        
....................       RTC_reset_HT(); 
0E7AC:  CALL   343A
....................       RTC_read(); 
0E7B0:  CALL   32CC
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0E7B4:  MOVLW  41
0E7B6:  BTFSS  F9E.4
0E7B8:  BRA    E7B6
0E7BA:  MOVWF  FAD
0E7BC:  MOVLW  10
0E7BE:  MOVWF  FE9
0E7C0:  CLRF   1B
0E7C2:  BTFSC  FF2.7
0E7C4:  BSF    1B.7
0E7C6:  BCF    FF2.7
0E7C8:  MOVFF  2A,A19
0E7CC:  MOVFF  29,A18
0E7D0:  CALL   1192
0E7D4:  BTFSC  1B.7
0E7D6:  BSF    FF2.7
0E7D8:  MOVLW  20
0E7DA:  BTFSS  F9E.4
0E7DC:  BRA    E7DA
0E7DE:  MOVWF  FAD
0E7E0:  MOVLW  49
0E7E2:  BTFSS  F9E.4
0E7E4:  BRA    E7E2
0E7E6:  MOVWF  FAD
0E7E8:  MOVLW  10
0E7EA:  MOVWF  FE9
0E7EC:  CLRF   1B
0E7EE:  BTFSC  FF2.7
0E7F0:  BSF    1B.7
0E7F2:  BCF    FF2.7
0E7F4:  MOVFF  24,A19
0E7F8:  MOVFF  23,A18
0E7FC:  CALL   1192
0E800:  BTFSC  1B.7
0E802:  BSF    FF2.7
0E804:  MOVLW  20
0E806:  BTFSS  F9E.4
0E808:  BRA    E806
0E80A:  MOVWF  FAD
0E80C:  MOVLW  4C
0E80E:  BTFSS  F9E.4
0E810:  BRA    E80E
0E812:  MOVWF  FAD
0E814:  MOVLW  10
0E816:  MOVWF  FE9
0E818:  CLRF   1B
0E81A:  BTFSC  FF2.7
0E81C:  BSF    1B.7
0E81E:  BCF    FF2.7
0E820:  MOVFF  2C,A19
0E824:  MOVFF  2B,A18
0E828:  CALL   1192
0E82C:  BTFSC  1B.7
0E82E:  BSF    FF2.7
0E830:  MOVLW  20
0E832:  BTFSS  F9E.4
0E834:  BRA    E832
0E836:  MOVWF  FAD
0E838:  MOVLW  51
0E83A:  BTFSS  F9E.4
0E83C:  BRA    E83A
0E83E:  MOVWF  FAD
0E840:  MOVLW  10
0E842:  MOVWF  FE9
0E844:  CLRF   1B
0E846:  BTFSC  FF2.7
0E848:  BSF    1B.7
0E84A:  BCF    FF2.7
0E84C:  MOVFF  2E,A19
0E850:  MOVFF  2D,A18
0E854:  CALL   1192
0E858:  BTFSC  1B.7
0E85A:  BSF    FF2.7
0E85C:  MOVLW  20
0E85E:  BTFSS  F9E.4
0E860:  BRA    E85E
0E862:  MOVWF  FAD
0E864:  MOVLW  53
0E866:  BTFSS  F9E.4
0E868:  BRA    E866
0E86A:  MOVWF  FAD
0E86C:  MOVLW  10
0E86E:  MOVWF  FE9
0E870:  CLRF   1B
0E872:  BTFSC  FF2.7
0E874:  BSF    1B.7
0E876:  BCF    FF2.7
0E878:  MOVFF  22,A19
0E87C:  MOVFF  21,A18
0E880:  CALL   1192
0E884:  BTFSC  1B.7
0E886:  BSF    FF2.7
0E888:  MOVLW  20
0E88A:  BTFSS  F9E.4
0E88C:  BRA    E88A
0E88E:  MOVWF  FAD
0E890:  MOVLW  04
0E892:  MOVWF  FE9
0E894:  MOVLB  8
0E896:  CLRF   x67
0E898:  CLRF   x66
0E89A:  MOVFF  863,865
0E89E:  MOVFF  862,864
0E8A2:  MOVLW  02
0E8A4:  MOVWF  x68
0E8A6:  MOVLB  0
0E8A8:  CALL   DE90
0E8AC:  MOVLW  12
0E8AE:  MOVWF  FF6
0E8B0:  MOVLW  26
0E8B2:  MOVWF  FF7
0E8B4:  MOVLW  00
0E8B6:  MOVWF  FF8
0E8B8:  CLRF   1B
0E8BA:  BTFSC  FF2.7
0E8BC:  BSF    1B.7
0E8BE:  BCF    FF2.7
0E8C0:  MOVLW  03
0E8C2:  MOVLB  A
0E8C4:  MOVWF  x18
0E8C6:  MOVLB  0
0E8C8:  CALL   1010
0E8CC:  BTFSC  1B.7
0E8CE:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E8D0:  MOVLW  16
0E8D2:  MOVWF  FF6
0E8D4:  MOVLW  26
0E8D6:  MOVWF  FF7
0E8D8:  MOVLW  00
0E8DA:  MOVWF  FF8
0E8DC:  CLRF   1B
0E8DE:  BTFSC  FF2.7
0E8E0:  BSF    1B.7
0E8E2:  BCF    FF2.7
0E8E4:  MOVLW  09
0E8E6:  MOVLB  A
0E8E8:  MOVWF  x18
0E8EA:  MOVLB  0
0E8EC:  CALL   1010
0E8F0:  BTFSC  1B.7
0E8F2:  BSF    FF2.7
0E8F4:  MOVLW  10
0E8F6:  MOVWF  FE9
0E8F8:  CLRF   1B
0E8FA:  BTFSC  FF2.7
0E8FC:  BSF    1B.7
0E8FE:  BCF    FF2.7
0E900:  MOVFF  7C0,A19
0E904:  MOVFF  7BF,A18
0E908:  CALL   1192
0E90C:  BTFSC  1B.7
0E90E:  BSF    FF2.7
0E910:  MOVLW  22
0E912:  MOVWF  FF6
0E914:  MOVLW  26
0E916:  MOVWF  FF7
0E918:  MOVLW  00
0E91A:  MOVWF  FF8
0E91C:  CLRF   1B
0E91E:  BTFSC  FF2.7
0E920:  BSF    1B.7
0E922:  BCF    FF2.7
0E924:  MOVLW  05
0E926:  MOVLB  A
0E928:  MOVWF  x18
0E92A:  MOVLB  0
0E92C:  CALL   1010
0E930:  BTFSC  1B.7
0E932:  BSF    FF2.7
0E934:  MOVLW  10
0E936:  MOVWF  FE9
0E938:  MOVFF  7B2,8CE
0E93C:  MOVFF  7B1,8CD
0E940:  CALL   8F24
0E944:  MOVLW  0D
0E946:  BTFSS  F9E.4
0E948:  BRA    E946
0E94A:  MOVWF  FAD
0E94C:  MOVLW  0A
0E94E:  BTFSS  F9E.4
0E950:  BRA    E94E
0E952:  MOVWF  FAD
....................       RTC_display(); 
0E954:  CALL   DF8C
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E958:  MOVLW  2E
0E95A:  MOVWF  FF6
0E95C:  MOVLW  26
0E95E:  MOVWF  FF7
0E960:  MOVLW  00
0E962:  MOVWF  FF8
0E964:  CLRF   1B
0E966:  BTFSC  FF2.7
0E968:  BSF    1B.7
0E96A:  BCF    FF2.7
0E96C:  MOVLW  05
0E96E:  MOVLB  A
0E970:  MOVWF  x18
0E972:  MOVLB  0
0E974:  CALL   1010
0E978:  BTFSC  1B.7
0E97A:  BSF    FF2.7
0E97C:  CLRF   1B
0E97E:  BTFSC  FF2.7
0E980:  BSF    1B.7
0E982:  BCF    FF2.7
0E984:  MOVFF  736,A18
0E988:  MOVLW  01
0E98A:  MOVLB  A
0E98C:  MOVWF  x19
0E98E:  MOVLB  0
0E990:  CALL   0F92
0E994:  BTFSC  1B.7
0E996:  BSF    FF2.7
0E998:  MOVLW  2F
0E99A:  BTFSS  F9E.4
0E99C:  BRA    E99A
0E99E:  MOVWF  FAD
0E9A0:  CLRF   1B
0E9A2:  BTFSC  FF2.7
0E9A4:  BSF    1B.7
0E9A6:  BCF    FF2.7
0E9A8:  MOVFF  737,A18
0E9AC:  MOVLW  01
0E9AE:  MOVLB  A
0E9B0:  MOVWF  x19
0E9B2:  MOVLB  0
0E9B4:  CALL   0F92
0E9B8:  BTFSC  1B.7
0E9BA:  BSF    FF2.7
0E9BC:  MOVLW  2F
0E9BE:  BTFSS  F9E.4
0E9C0:  BRA    E9BE
0E9C2:  MOVWF  FAD
0E9C4:  CLRF   1B
0E9C6:  BTFSC  FF2.7
0E9C8:  BSF    1B.7
0E9CA:  BCF    FF2.7
0E9CC:  MOVFF  738,A18
0E9D0:  MOVLW  01
0E9D2:  MOVLB  A
0E9D4:  MOVWF  x19
0E9D6:  MOVLB  0
0E9D8:  CALL   0F92
0E9DC:  BTFSC  1B.7
0E9DE:  BSF    FF2.7
0E9E0:  MOVLW  20
0E9E2:  BTFSS  F9E.4
0E9E4:  BRA    E9E2
0E9E6:  MOVWF  FAD
0E9E8:  CLRF   1B
0E9EA:  BTFSC  FF2.7
0E9EC:  BSF    1B.7
0E9EE:  BCF    FF2.7
0E9F0:  MOVFF  739,A18
0E9F4:  MOVLW  01
0E9F6:  MOVLB  A
0E9F8:  MOVWF  x19
0E9FA:  MOVLB  0
0E9FC:  CALL   0F92
0EA00:  BTFSC  1B.7
0EA02:  BSF    FF2.7
0EA04:  MOVLW  3A
0EA06:  BTFSS  F9E.4
0EA08:  BRA    EA06
0EA0A:  MOVWF  FAD
0EA0C:  CLRF   1B
0EA0E:  BTFSC  FF2.7
0EA10:  BSF    1B.7
0EA12:  BCF    FF2.7
0EA14:  MOVFF  73A,A18
0EA18:  MOVLW  01
0EA1A:  MOVLB  A
0EA1C:  MOVWF  x19
0EA1E:  MOVLB  0
0EA20:  CALL   0F92
0EA24:  BTFSC  1B.7
0EA26:  BSF    FF2.7
0EA28:  MOVLW  3A
0EA2A:  BTFSS  F9E.4
0EA2C:  BRA    EA2A
0EA2E:  MOVWF  FAD
0EA30:  CLRF   1B
0EA32:  BTFSC  FF2.7
0EA34:  BSF    1B.7
0EA36:  BCF    FF2.7
0EA38:  MOVFF  73B,A18
0EA3C:  MOVLW  01
0EA3E:  MOVLB  A
0EA40:  MOVWF  x19
0EA42:  MOVLB  0
0EA44:  CALL   0F92
0EA48:  BTFSC  1B.7
0EA4A:  BSF    FF2.7
0EA4C:  MOVLW  0D
0EA4E:  BTFSS  F9E.4
0EA50:  BRA    EA4E
0EA52:  MOVWF  FAD
0EA54:  MOVLW  0A
0EA56:  BTFSS  F9E.4
0EA58:  BRA    EA56
0EA5A:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EA5C:  CALL   E116
....................       RTC_display_alarm(); 
0EA60:  CALL   E1EC
....................    } 
0EA64:  GOTO   EF9A (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0ECF2:  DECFSZ 44,W
0ECF4:  BRA    EF5A
0ECF6:  MOVF   45,F
0ECF8:  BTFSS  FD8.2
0ECFA:  BRA    EF5A
0ECFC:  MOVF   46,F
0ECFE:  BTFSS  FD8.2
0ED00:  BRA    EF5A
0ED02:  MOVF   47,F
0ED04:  BTFSS  FD8.2
0ED06:  BRA    EF5A
....................       v_supply = read_supply(); 
0ED08:  CALL   507E
0ED0C:  MOVFF  02,863
0ED10:  MOVFF  01,862
....................        
....................       RTC_reset_HT(); 
0ED14:  CALL   343A
....................       RTC_read(); 
0ED18:  CALL   32CC
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0ED1C:  MOVLW  49
0ED1E:  BTFSS  F9E.4
0ED20:  BRA    ED1E
0ED22:  MOVWF  FAD
0ED24:  MOVLW  10
0ED26:  MOVWF  FE9
0ED28:  CLRF   1B
0ED2A:  BTFSC  FF2.7
0ED2C:  BSF    1B.7
0ED2E:  BCF    FF2.7
0ED30:  MOVFF  24,A19
0ED34:  MOVFF  23,A18
0ED38:  CALL   1192
0ED3C:  BTFSC  1B.7
0ED3E:  BSF    FF2.7
0ED40:  MOVLW  20
0ED42:  BTFSS  F9E.4
0ED44:  BRA    ED42
0ED46:  MOVWF  FAD
0ED48:  MOVLW  4E
0ED4A:  BTFSS  F9E.4
0ED4C:  BRA    ED4A
0ED4E:  MOVWF  FAD
0ED50:  MOVLW  10
0ED52:  MOVWF  FE9
0ED54:  CLRF   1B
0ED56:  BTFSC  FF2.7
0ED58:  BSF    1B.7
0ED5A:  BCF    FF2.7
0ED5C:  MOVFF  22,A19
0ED60:  MOVFF  21,A18
0ED64:  CALL   1192
0ED68:  BTFSC  1B.7
0ED6A:  BSF    FF2.7
0ED6C:  MOVLW  2F
0ED6E:  BTFSS  F9E.4
0ED70:  BRA    ED6E
0ED72:  MOVWF  FAD
0ED74:  MOVLW  10
0ED76:  MOVWF  FE9
0ED78:  CLRF   1B
0ED7A:  BTFSC  FF2.7
0ED7C:  BSF    1B.7
0ED7E:  BCF    FF2.7
0ED80:  MOVFF  28,A19
0ED84:  MOVFF  27,A18
0ED88:  CALL   1192
0ED8C:  BTFSC  1B.7
0ED8E:  BSF    FF2.7
0ED90:  MOVLW  20
0ED92:  BTFSS  F9E.4
0ED94:  BRA    ED92
0ED96:  MOVWF  FAD
0ED98:  MOVLW  50
0ED9A:  BTFSS  F9E.4
0ED9C:  BRA    ED9A
0ED9E:  MOVWF  FAD
0EDA0:  MOVLW  10
0EDA2:  MOVWF  FE9
0EDA4:  CLRF   1B
0EDA6:  BTFSC  FF2.7
0EDA8:  BSF    1B.7
0EDAA:  BCF    FF2.7
0EDAC:  MOVFF  2E,A19
0EDB0:  MOVFF  2D,A18
0EDB4:  CALL   1192
0EDB8:  BTFSC  1B.7
0EDBA:  BSF    FF2.7
0EDBC:  MOVLW  20
0EDBE:  BTFSS  F9E.4
0EDC0:  BRA    EDBE
0EDC2:  MOVWF  FAD
0EDC4:  MOVLW  04
0EDC6:  MOVWF  FE9
0EDC8:  MOVLB  8
0EDCA:  CLRF   x67
0EDCC:  CLRF   x66
0EDCE:  MOVFF  863,865
0EDD2:  MOVFF  862,864
0EDD6:  MOVLW  02
0EDD8:  MOVWF  x68
0EDDA:  MOVLB  0
0EDDC:  CALL   DE90
0EDE0:  MOVLW  6C
0EDE2:  MOVWF  FF6
0EDE4:  MOVLW  26
0EDE6:  MOVWF  FF7
0EDE8:  MOVLW  00
0EDEA:  MOVWF  FF8
0EDEC:  CLRF   1B
0EDEE:  BTFSC  FF2.7
0EDF0:  BSF    1B.7
0EDF2:  BCF    FF2.7
0EDF4:  MOVLW  03
0EDF6:  MOVLB  A
0EDF8:  MOVWF  x18
0EDFA:  MOVLB  0
0EDFC:  CALL   1010
0EE00:  BTFSC  1B.7
0EE02:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0EE04:  MOVLW  70
0EE06:  MOVWF  FF6
0EE08:  MOVLW  26
0EE0A:  MOVWF  FF7
0EE0C:  MOVLW  00
0EE0E:  MOVWF  FF8
0EE10:  CLRF   1B
0EE12:  BTFSC  FF2.7
0EE14:  BSF    1B.7
0EE16:  BCF    FF2.7
0EE18:  MOVLW  09
0EE1A:  MOVLB  A
0EE1C:  MOVWF  x18
0EE1E:  MOVLB  0
0EE20:  CALL   1010
0EE24:  BTFSC  1B.7
0EE26:  BSF    FF2.7
0EE28:  MOVLW  10
0EE2A:  MOVWF  FE9
0EE2C:  MOVFF  7B2,8CE
0EE30:  MOVFF  7B1,8CD
0EE34:  CALL   8F24
0EE38:  MOVLW  0D
0EE3A:  BTFSS  F9E.4
0EE3C:  BRA    EE3A
0EE3E:  MOVWF  FAD
0EE40:  MOVLW  0A
0EE42:  BTFSS  F9E.4
0EE44:  BRA    EE42
0EE46:  MOVWF  FAD
....................       display_valve_status(); 
0EE48:  RCALL  EA68
....................       RTC_display(); 
0EE4A:  CALL   DF8C
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EE4E:  MOVLW  80
0EE50:  MOVWF  FF6
0EE52:  MOVLW  26
0EE54:  MOVWF  FF7
0EE56:  MOVLW  00
0EE58:  MOVWF  FF8
0EE5A:  CLRF   1B
0EE5C:  BTFSC  FF2.7
0EE5E:  BSF    1B.7
0EE60:  BCF    FF2.7
0EE62:  MOVLW  05
0EE64:  MOVLB  A
0EE66:  MOVWF  x18
0EE68:  MOVLB  0
0EE6A:  CALL   1010
0EE6E:  BTFSC  1B.7
0EE70:  BSF    FF2.7
0EE72:  CLRF   1B
0EE74:  BTFSC  FF2.7
0EE76:  BSF    1B.7
0EE78:  BCF    FF2.7
0EE7A:  MOVFF  736,A18
0EE7E:  MOVLW  01
0EE80:  MOVLB  A
0EE82:  MOVWF  x19
0EE84:  MOVLB  0
0EE86:  CALL   0F92
0EE8A:  BTFSC  1B.7
0EE8C:  BSF    FF2.7
0EE8E:  MOVLW  2F
0EE90:  BTFSS  F9E.4
0EE92:  BRA    EE90
0EE94:  MOVWF  FAD
0EE96:  CLRF   1B
0EE98:  BTFSC  FF2.7
0EE9A:  BSF    1B.7
0EE9C:  BCF    FF2.7
0EE9E:  MOVFF  737,A18
0EEA2:  MOVLW  01
0EEA4:  MOVLB  A
0EEA6:  MOVWF  x19
0EEA8:  MOVLB  0
0EEAA:  CALL   0F92
0EEAE:  BTFSC  1B.7
0EEB0:  BSF    FF2.7
0EEB2:  MOVLW  2F
0EEB4:  BTFSS  F9E.4
0EEB6:  BRA    EEB4
0EEB8:  MOVWF  FAD
0EEBA:  CLRF   1B
0EEBC:  BTFSC  FF2.7
0EEBE:  BSF    1B.7
0EEC0:  BCF    FF2.7
0EEC2:  MOVFF  738,A18
0EEC6:  MOVLW  01
0EEC8:  MOVLB  A
0EECA:  MOVWF  x19
0EECC:  MOVLB  0
0EECE:  CALL   0F92
0EED2:  BTFSC  1B.7
0EED4:  BSF    FF2.7
0EED6:  MOVLW  20
0EED8:  BTFSS  F9E.4
0EEDA:  BRA    EED8
0EEDC:  MOVWF  FAD
0EEDE:  CLRF   1B
0EEE0:  BTFSC  FF2.7
0EEE2:  BSF    1B.7
0EEE4:  BCF    FF2.7
0EEE6:  MOVFF  739,A18
0EEEA:  MOVLW  01
0EEEC:  MOVLB  A
0EEEE:  MOVWF  x19
0EEF0:  MOVLB  0
0EEF2:  CALL   0F92
0EEF6:  BTFSC  1B.7
0EEF8:  BSF    FF2.7
0EEFA:  MOVLW  3A
0EEFC:  BTFSS  F9E.4
0EEFE:  BRA    EEFC
0EF00:  MOVWF  FAD
0EF02:  CLRF   1B
0EF04:  BTFSC  FF2.7
0EF06:  BSF    1B.7
0EF08:  BCF    FF2.7
0EF0A:  MOVFF  73A,A18
0EF0E:  MOVLW  01
0EF10:  MOVLB  A
0EF12:  MOVWF  x19
0EF14:  MOVLB  0
0EF16:  CALL   0F92
0EF1A:  BTFSC  1B.7
0EF1C:  BSF    FF2.7
0EF1E:  MOVLW  3A
0EF20:  BTFSS  F9E.4
0EF22:  BRA    EF20
0EF24:  MOVWF  FAD
0EF26:  CLRF   1B
0EF28:  BTFSC  FF2.7
0EF2A:  BSF    1B.7
0EF2C:  BCF    FF2.7
0EF2E:  MOVFF  73B,A18
0EF32:  MOVLW  01
0EF34:  MOVLB  A
0EF36:  MOVWF  x19
0EF38:  MOVLB  0
0EF3A:  CALL   0F92
0EF3E:  BTFSC  1B.7
0EF40:  BSF    FF2.7
0EF42:  MOVLW  0D
0EF44:  BTFSS  F9E.4
0EF46:  BRA    EF44
0EF48:  MOVWF  FAD
0EF4A:  MOVLW  0A
0EF4C:  BTFSS  F9E.4
0EF4E:  BRA    EF4C
0EF50:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EF52:  CALL   E116
....................       RTC_display_alarm(); 
0EF56:  CALL   E1EC
....................    } 
0EF5A:  GOTO   EF9A (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0EF5E:  MOVF   2F,W
0EF60:  MOVWF  00
0EF62:  MOVF   30,W
0EF64:  MOVWF  03
0EF66:  BNZ   EF6C
0EF68:  MOVF   00,F
0EF6A:  BZ    EF8C
0EF6C:  MOVF   03,W
0EF6E:  BNZ   EF76
0EF70:  MOVLW  01
0EF72:  SUBWF  00,W
0EF74:  BZ    EF92
0EF76:  MOVF   03,W
0EF78:  BNZ   EF80
0EF7A:  MOVLW  03
0EF7C:  SUBWF  00,W
0EF7E:  BZ    EF92
0EF80:  MOVF   03,W
0EF82:  BNZ   EF8A
0EF84:  MOVLW  02
0EF86:  SUBWF  00,W
0EF88:  BZ    EF98
0EF8A:  BRA    EF9A
....................       case ECO : commandHe(); 
0EF8C:  GOTO   E366
....................          break; 
0EF90:  BRA    EF9A
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0EF92:  GOTO   E78A
....................          break; 
0EF96:  BRA    EF9A
....................       case AWS : commandHa(); 
0EF98:  BRA    ECF2
....................          break;          
....................    } 
0EF9A:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0EF9E:  MOVF   44,F
0EFA0:  BNZ   EFAE
0EFA2:  MOVF   45,F
0EFA4:  BNZ   EFAE
0EFA6:  MOVF   46,F
0EFA8:  BNZ   EFAE
0EFAA:  MOVF   47,F
0EFAC:  BZ    EFE2
0EFAE:  MOVF   47,F
0EFB0:  BNZ   EFE2
0EFB2:  MOVF   46,F
0EFB4:  BNZ   EFE2
0EFB6:  MOVF   45,W
0EFB8:  SUBLW  FD
0EFBA:  BNC   EFE2
0EFBC:  BNZ   EFC4
0EFBE:  MOVF   44,W
0EFC0:  SUBLW  20
0EFC2:  BNC   EFE2
....................       nv_interval = arg; 
0EFC4:  MOVFF  45,24
0EFC8:  MOVFF  44,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0EFCC:  MOVLW  14
0EFCE:  MOVLB  8
0EFD0:  MOVWF  xCB
0EFD2:  MOVFF  24,8CD
0EFD6:  MOVFF  23,8CC
0EFDA:  MOVLB  0
0EFDC:  CALL   4F56
....................    } 
0EFE0:  BRA    EFE6
....................    else cmd_arg(); 
0EFE2:  CALL   AF70
0EFE6:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0EFEA:  MOVF   47,F
0EFEC:  BNZ   F01C
0EFEE:  MOVF   46,F
0EFF0:  BNZ   F01C
0EFF2:  MOVF   45,W
0EFF4:  SUBLW  27
0EFF6:  BNC   F01C
0EFF8:  BNZ   F000
0EFFA:  MOVF   44,W
0EFFC:  SUBLW  0F
0EFFE:  BNC   F01C
....................       nv_serial = arg; 
0F000:  MOVFF  45,26
0F004:  MOVFF  44,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0F008:  MOVLB  8
0F00A:  CLRF   xCB
0F00C:  MOVFF  26,8CD
0F010:  MOVFF  25,8CC
0F014:  MOVLB  0
0F016:  CALL   4F56
....................    } 
0F01A:  BRA    F020
....................    else cmd_arg(); 
0F01C:  CALL   AF70
0F020:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F244:  MOVF   2F,F
0F246:  BNZ   F276
0F248:  MOVF   30,F
0F24A:  BNZ   F276
....................        
....................       if (arg > 0 && arg < 3){ 
0F24C:  MOVF   44,F
0F24E:  BNZ   F25C
0F250:  MOVF   45,F
0F252:  BNZ   F25C
0F254:  MOVF   46,F
0F256:  BNZ   F25C
0F258:  MOVF   47,F
0F25A:  BZ    F272
0F25C:  MOVF   47,F
0F25E:  BNZ   F272
0F260:  MOVF   46,F
0F262:  BNZ   F272
0F264:  MOVF   45,F
0F266:  BNZ   F272
0F268:  MOVF   44,W
0F26A:  SUBLW  02
0F26C:  BNC   F272
....................          det_cmd(); 
0F26E:  RCALL  F104
....................       } 
0F270:  BRA    F276
....................       else cmd_arg(); 
0F272:  CALL   AF70
....................        
....................    } 
0F276:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
100C8:  MOVF   47,F
100CA:  BNZ   10136
100CC:  MOVF   46,F
100CE:  BNZ   10136
100D0:  MOVF   45,W
100D2:  SUBLW  0F
100D4:  BNC   10136
....................       switch (nv_det_type){ 
100D6:  MOVFF  41,00
100DA:  MOVF   42,W
100DC:  MOVWF  03
100DE:  BNZ   100E6
100E0:  MOVLW  01
100E2:  SUBWF  00,W
100E4:  BZ    100FC
100E6:  MOVF   03,W
100E8:  BNZ   100F0
100EA:  MOVLW  02
100EC:  SUBWF  00,W
100EE:  BZ    10102
100F0:  MOVF   03,W
100F2:  BNZ   100FA
100F4:  MOVLW  03
100F6:  SUBWF  00,W
100F8:  BZ    10120
100FA:  BRA    10134
....................          case 1 : det_cmd(); 
100FC:  CALL   F104
....................             break; 
10100:  BRA    10134
....................          case 2 : DAC_set(1,arg); 
10102:  MOVFF  45,863
10106:  MOVFF  44,862
1010A:  MOVLW  01
1010C:  MOVLB  8
1010E:  MOVWF  xB0
10110:  MOVFF  863,8B2
10114:  MOVFF  862,8B1
10118:  MOVLB  0
1011A:  CALL   F27A
....................             break; 
1011E:  BRA    10134
....................          case 3 : set_LED(arg); 
10120:  MOVFF  45,863
10124:  MOVFF  44,862
10128:  MOVFF  863,8A3
1012C:  MOVFF  862,8A2
10130:  CALL   F5BA
....................             break; 
....................       } 
....................    } 
10134:  BRA    10194
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
10136:  MOVF   47,F
10138:  BNZ   1014E
1013A:  MOVF   46,F
1013C:  BNZ   1014E
1013E:  MOVF   45,W
10140:  SUBLW  4D
10142:  BC    10178
10144:  XORLW  FF
10146:  BNZ   1014E
10148:  MOVF   44,W
1014A:  SUBLW  20
1014C:  BC    10178
1014E:  MOVF   47,F
10150:  BNZ   10178
10152:  MOVF   46,F
10154:  BNZ   10178
10156:  MOVF   45,W
10158:  SUBLW  4E
1015A:  BNC   10178
1015C:  BNZ   10164
1015E:  MOVF   44,W
10160:  SUBLW  22
10162:  BNC   10178
10164:  MOVFF  45,863
10168:  MOVFF  44,862
1016C:  MOVFF  863,865
10170:  MOVFF  862,864
10174:  BRA    10000
10176:  BRA    10194
....................    else if(arg==30001)set_LED_test(); 
10178:  MOVF   44,W
1017A:  SUBLW  31
1017C:  BNZ   10190
1017E:  MOVF   45,W
10180:  SUBLW  75
10182:  BNZ   10190
10184:  MOVF   46,F
10186:  BNZ   10190
10188:  MOVF   47,F
1018A:  BNZ   10190
1018C:  BRA    FF5A
1018E:  BRA    10194
....................    else cmd_arg(); 
10190:  CALL   AF70
10194:  GOTO   101FE (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
10198:  MOVF   47,F
1019A:  BNZ   101CC
1019C:  MOVF   46,F
1019E:  BNZ   101CC
101A0:  MOVF   45,W
101A2:  SUBLW  57
101A4:  BNC   101CC
101A6:  BNZ   101AE
101A8:  MOVF   44,W
101AA:  SUBLW  E4
101AC:  BNC   101CC
....................       nv_volume = arg; 
101AE:  MOVFF  45,2C
101B2:  MOVFF  44,2B
....................       write16(ADDR_VOLUME, nv_volume); 
101B6:  MOVLW  22
101B8:  MOVLB  8
101BA:  MOVWF  xCB
101BC:  MOVFF  2C,8CD
101C0:  MOVFF  2B,8CC
101C4:  MOVLB  0
101C6:  CALL   4F56
....................    } 
101CA:  BRA    101D0
....................    else cmd_arg(); 
101CC:  CALL   AF70
101D0:  GOTO   101FE (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
101D4:  MOVF   2F,W
101D6:  MOVWF  00
101D8:  MOVF   30,W
101DA:  MOVWF  03
101DC:  BNZ   101E2
101DE:  MOVF   00,F
101E0:  BZ    101F8
101E2:  MOVF   03,W
101E4:  BNZ   101EC
101E6:  MOVLW  01
101E8:  SUBWF  00,W
101EA:  BZ    101FC
101EC:  MOVF   03,W
101EE:  BNZ   101F6
101F0:  MOVLW  03
101F2:  SUBWF  00,W
101F4:  BZ    101FC
101F6:  BRA    101FE
....................       case ECO : commandLe(); 
101F8:  BRA    100C8
....................          break; 
101FA:  BRA    101FE
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
101FC:  BRA    10198
....................          break; 
....................    } 
101FE:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
168DA:  CALL   2948
....................     
....................    user_quit = FALSE; 
168DE:  CLRF   4C
....................     
....................    if(arg > 0 && arg < 21) 
168E0:  MOVF   44,F
168E2:  BNZ   168F0
168E4:  MOVF   45,F
168E6:  BNZ   168F0
168E8:  MOVF   46,F
168EA:  BNZ   168F0
168EC:  MOVF   47,F
168EE:  BZ    1696C
168F0:  MOVF   47,F
168F2:  BNZ   1696C
168F4:  MOVF   46,F
168F6:  BNZ   1696C
168F8:  MOVF   45,F
168FA:  BNZ   1696C
168FC:  MOVF   44,W
168FE:  SUBLW  14
16900:  BNC   1696C
....................    { 
....................       macro = arg; 
16902:  MOVFF  44,863
....................       switch(nv_product){ 
16906:  MOVFF  2F,00
1690A:  MOVF   30,W
1690C:  MOVWF  03
1690E:  BNZ   16914
16910:  MOVF   00,F
16912:  BZ    16934
16914:  MOVF   03,W
16916:  BNZ   1691E
16918:  MOVLW  01
1691A:  SUBWF  00,W
1691C:  BZ    16934
1691E:  MOVF   03,W
16920:  BNZ   16928
16922:  MOVLW  03
16924:  SUBWF  00,W
16926:  BZ    16934
16928:  MOVF   03,W
1692A:  BNZ   16932
1692C:  MOVLW  02
1692E:  SUBWF  00,W
16930:  BZ    1695A
16932:  BRA    1696A
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
16934:  MOVLW  01
16936:  MOVLB  7
16938:  ADDWF  xBF,W
1693A:  MOVLB  8
1693C:  MOVWF  x64
1693E:  MOVLW  00
16940:  MOVLB  7
16942:  ADDWFC xC0,W
16944:  MOVLB  8
16946:  MOVWF  x65
16948:  MOVFF  863,874
1694C:  MOVWF  x76
1694E:  MOVFF  864,875
16952:  MOVLB  0
16954:  CALL   14F00
....................             break; 
16958:  BRA    1696A
....................          case AWS : play_macro(macro,nv_port); 
1695A:  MOVFF  863,874
1695E:  MOVFF  2E,876
16962:  MOVFF  2D,875
16966:  CALL   14F00
....................             break; 
....................       } 
....................    }    
1696A:  BRA    169EE
....................    else if (arg == 0) 
1696C:  MOVF   44,F
1696E:  BNZ   169EA
16970:  MOVF   45,F
16972:  BNZ   169EA
16974:  MOVF   46,F
16976:  BNZ   169EA
16978:  MOVF   47,F
1697A:  BNZ   169EA
....................    { 
....................       //start watchdog at beginning of logging mode 
....................       RTC_reset_HT(); 
1697C:  CALL   343A
....................       output_bit(RTC_CS, ENABLE); 
16980:  BCF    F91.0
....................       spi_write(0x89); 
16982:  MOVF   FC9,W
16984:  MOVLW  89
16986:  MOVWF  FC9
16988:  RRCF   FC7,W
1698A:  BNC   16988
....................       spi_write(0b11111111); 
1698C:  MOVF   FC9,W
1698E:  SETF   FC9
16990:  RRCF   FC7,W
16992:  BNC   16990
....................       output_bit(RTC_CS, DISABLE); 
16994:  BSF    F91.0
....................        
....................       MaxSamples=FALSE; 
16996:  CLRF   34
16998:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
1699A:  MOVLW  28
1699C:  MOVLB  8
1699E:  MOVWF  x66
169A0:  MOVFF  33,867
169A4:  MOVLB  0
169A6:  CALL   339A
....................       if (LoggingReentry != TRUE) 
169AA:  MOVLB  8
169AC:  DECFSZ x62,W
169AE:  BRA    169B2
169B0:  BRA    169CA
....................       { 
....................          nv_sample = 0; 
169B2:  CLRF   22
169B4:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
169B6:  MOVLW  16
169B8:  MOVWF  xCB
169BA:  MOVFF  22,8CD
169BE:  MOVFF  21,8CC
169C2:  MOVLB  0
169C4:  CALL   4F56
169C8:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
169CA:  CLRF   x62
....................       nv_macro_step = 0; 
169CC:  CLRF   38
169CE:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
169D0:  MOVLW  3A
169D2:  MOVWF  xCB
169D4:  MOVFF  38,8CD
169D8:  MOVFF  37,8CC
169DC:  MOVLB  0
169DE:  CALL   4F56
....................       user_quit = auto_sample_ready(); 
169E2:  BRA    166D8
169E4:  MOVFF  01,4C
....................    } 
169E8:  BRA    169EE
....................    else cmd_arg(); 
169EA:  CALL   AF70
....................     
....................    busy_clear(); 
169EE:  CALL   ADAC
169F2:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
169F4:  MOVF   44,F
169F6:  BNZ   16A04
169F8:  MOVF   45,F
169FA:  BNZ   16A04
169FC:  MOVF   46,F
169FE:  BNZ   16A04
16A00:  MOVF   47,F
16A02:  BZ    16A38
16A04:  MOVF   47,F
16A06:  BNZ   16A38
16A08:  MOVF   46,F
16A0A:  BNZ   16A38
16A0C:  MOVF   45,W
16A0E:  SUBLW  0D
16A10:  BNC   16A38
16A12:  BNZ   16A1A
16A14:  MOVF   44,W
16A16:  SUBLW  AC
16A18:  BNC   16A38
....................       nv_max_samples = arg; 
16A1A:  MOVFF  45,28
16A1E:  MOVFF  44,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
16A22:  MOVLW  18
16A24:  MOVLB  8
16A26:  MOVWF  xCB
16A28:  MOVFF  28,8CD
16A2C:  MOVFF  27,8CC
16A30:  MOVLB  0
16A32:  CALL   4F56
....................    } 
16A36:  BRA    16A7E
....................    else if(arg == 0) { 
16A38:  MOVF   44,F
16A3A:  BNZ   16A7A
16A3C:  MOVF   45,F
16A3E:  BNZ   16A7A
16A40:  MOVF   46,F
16A42:  BNZ   16A7A
16A44:  MOVF   47,F
16A46:  BNZ   16A7A
....................       nv_sample = 0; 
16A48:  CLRF   22
16A4A:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
16A4C:  MOVLW  16
16A4E:  MOVLB  8
16A50:  MOVWF  xCB
16A52:  MOVFF  22,8CD
16A56:  MOVFF  21,8CC
16A5A:  MOVLB  0
16A5C:  CALL   4F56
....................       nv_macro_step = 0; 
16A60:  CLRF   38
16A62:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16A64:  MOVLW  3A
16A66:  MOVLB  8
16A68:  MOVWF  xCB
16A6A:  MOVFF  38,8CD
16A6E:  MOVFF  37,8CC
16A72:  MOVLB  0
16A74:  CALL   4F56
....................    } 
16A78:  BRA    16A7E
....................    else cmd_arg(); 
16A7A:  CALL   AF70
16A7E:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
16B9C:  DECFSZ 44,W
16B9E:  BRA    16BB8
16BA0:  MOVF   45,F
16BA2:  BNZ   16BB8
16BA4:  MOVF   46,F
16BA6:  BNZ   16BB8
16BA8:  MOVF   47,F
16BAA:  BNZ   16BB8
....................    { 
....................       bus_on(); 
16BAC:  CALL   D076
....................       open_pipe(); 
16BB0:  BRA    16A90
....................       bus_off(); 
16BB2:  CALL   D09A
....................    } 
16BB6:  BRA    16BBC
....................    else cmd_arg(); 
16BB8:  CALL   AF70
16BBC:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
16C7A:  MOVLB  7
16C7C:  DECFSZ x3D,W
16C7E:  BRA    16C82
16C80:  CLRF   x3C
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
16C82:  MOVF   44,F
16C84:  BNZ   16C94
16C86:  MOVF   45,F
16C88:  BNZ   16C94
16C8A:  MOVF   46,F
16C8C:  BNZ   16C94
16C8E:  MOVF   47,F
16C90:  BTFSC  FD8.2
16C92:  BRA    16D5C
16C94:  BCF    FD8.0
16C96:  RLCF   x3C,W
16C98:  CLRF   03
16C9A:  ADDLW  5E
16C9C:  MOVWF  FE9
16C9E:  MOVLW  07
16CA0:  ADDWFC 03,W
16CA2:  MOVWF  FEA
16CA4:  MOVFF  FEC,03
16CA8:  MOVF   FED,F
16CAA:  MOVFF  FEF,01
16CAE:  MOVF   47,F
16CB0:  BNZ   16D5C
16CB2:  MOVF   46,F
16CB4:  BNZ   16D5C
16CB6:  MOVF   45,W
16CB8:  SUBWF  03,W
16CBA:  BNC   16D5C
16CBC:  BNZ   16CC4
16CBE:  MOVF   44,W
16CC0:  SUBWF  01,W
16CC2:  BNC   16D5C
....................       if(e_mode[motor]==2){     // if port mode then move 
16CC4:  BCF    FD8.0
16CC6:  RLCF   x3C,W
16CC8:  CLRF   03
16CCA:  ADDLW  62
16CCC:  MOVWF  FE9
16CCE:  MOVLW  07
16CD0:  ADDWFC 03,W
16CD2:  MOVWF  FEA
16CD4:  MOVFF  FEC,863
16CD8:  MOVF   FED,F
16CDA:  MOVFF  FEF,862
16CDE:  MOVLB  8
16CE0:  MOVF   x62,W
16CE2:  SUBLW  02
16CE4:  BNZ   16D52
16CE6:  MOVF   x63,F
16CE8:  BNZ   16D52
....................          switch (nv_product){ 
16CEA:  MOVF   2F,W
16CEC:  MOVWF  00
16CEE:  MOVF   30,W
16CF0:  MOVWF  03
16CF2:  MOVF   03,W
16CF4:  BNZ   16CFE
16CF6:  MOVF   00,F
16CF8:  MOVLB  0
16CFA:  BZ    16D1C
16CFC:  MOVLB  8
16CFE:  MOVF   03,W
16D00:  BNZ   16D0C
16D02:  MOVLW  01
16D04:  SUBWF  00,W
16D06:  MOVLB  0
16D08:  BZ    16D2E
16D0A:  MOVLB  8
16D0C:  MOVF   03,W
16D0E:  BNZ   16D1A
16D10:  MOVLW  03
16D12:  SUBWF  00,W
16D14:  MOVLB  0
16D16:  BZ    16D40
16D18:  MOVLB  8
16D1A:  BRA    16D50
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
16D1C:  MOVLW  01
16D1E:  MOVLB  8
16D20:  MOVWF  x62
16D22:  CLRF   x63
16D24:  MOVWF  x64
16D26:  MOVLB  0
16D28:  RCALL  16BC0
....................                break;             
16D2A:  MOVLB  8
16D2C:  BRA    16D50
....................             case WMS4: command_move(0,0,1); 
16D2E:  MOVLB  8
16D30:  CLRF   x62
16D32:  CLRF   x63
16D34:  MOVLW  01
16D36:  MOVWF  x64
16D38:  MOVLB  0
16D3A:  RCALL  16BC0
....................                break; 
16D3C:  MOVLB  8
16D3E:  BRA    16D50
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
16D40:  MOVLB  8
16D42:  CLRF   x62
16D44:  CLRF   x63
16D46:  MOVLW  01
16D48:  MOVWF  x64
16D4A:  MOVLB  0
16D4C:  RCALL  16BC0
....................                break; 
16D4E:  MOVLB  8
....................          } 
....................       } 
16D50:  BRA    16D5A
....................       else cmd_err();                           // else error 
16D52:  MOVLB  0
16D54:  CALL   BC32
16D58:  MOVLB  8
....................    } 
16D5A:  BRA    16D64
....................    else cmd_arg(); 
16D5C:  MOVLB  0
16D5E:  CALL   AF70
16D62:  MOVLB  8
16D64:  MOVLB  0
16D66:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
16D68:  MOVF   47,F
16D6A:  BNZ   16D98
16D6C:  MOVF   46,F
16D6E:  BNZ   16D98
16D70:  MOVF   45,F
16D72:  BNZ   16D98
16D74:  MOVF   44,W
16D76:  SUBLW  30
16D78:  BNC   16D98
....................       nv_port = arg; 
16D7A:  MOVFF  45,2E
16D7E:  MOVFF  44,2D
....................       write16(ADDR_PORT, nv_port); 
16D82:  MOVLW  24
16D84:  MOVLB  8
16D86:  MOVWF  xCB
16D88:  MOVFF  2E,8CD
16D8C:  MOVFF  2D,8CC
16D90:  MOVLB  0
16D92:  CALL   4F56
....................    } 
16D96:  BRA    16D9C
....................    else cmd_arg(); 
16D98:  CALL   AF70
16D9C:  GOTO   16DD8 (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
16DA0:  MOVF   2F,W
16DA2:  MOVWF  00
16DA4:  MOVF   30,W
16DA6:  MOVWF  03
16DA8:  BNZ   16DAE
16DAA:  MOVF   00,F
16DAC:  BZ    16DCE
16DAE:  MOVF   03,W
16DB0:  BNZ   16DB8
16DB2:  MOVLW  01
16DB4:  SUBWF  00,W
16DB6:  BZ    16DD2
16DB8:  MOVF   03,W
16DBA:  BNZ   16DC2
16DBC:  MOVLW  03
16DBE:  SUBWF  00,W
16DC0:  BZ    16DD2
16DC2:  MOVF   03,W
16DC4:  BNZ   16DCC
16DC6:  MOVLW  02
16DC8:  SUBWF  00,W
16DCA:  BZ    16DD6
16DCC:  BRA    16DD8
....................       case ECO : commandPe(); 
16DCE:  RCALL  16C7A
....................          break; 
16DD0:  BRA    16DD8
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
16DD2:  RCALL  16C7A
....................          break; 
16DD4:  BRA    16DD8
....................       case AWS : commandPa(); 
16DD6:  BRA    16D68
....................          break;          
....................    } 
16DD8:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
16E24:  MOVLB  4
16E26:  DECFSZ xB2,W
16E28:  BRA    16E54
....................     
....................       if(arg<33){ 
16E2A:  MOVF   47,F
16E2C:  BNZ   16E4C
16E2E:  MOVF   46,F
16E30:  BNZ   16E4C
16E32:  MOVF   45,F
16E34:  BNZ   16E4C
16E36:  MOVF   44,W
16E38:  SUBLW  20
16E3A:  BNC   16E4C
....................          valve=arg;    
16E3C:  MOVFF  44,862
....................          sol_switch(valve); 
16E40:  MOVFF  862,892
16E44:  MOVLB  0
16E46:  CALL   140CA
....................       }  
16E4A:  BRA    16E52
....................       else cmd_arg(); 
16E4C:  MOVLB  0
16E4E:  CALL   AF70
....................    } 
16E52:  BRA    16E5A
....................    else cmd_err(); 
16E54:  MOVLB  0
16E56:  CALL   BC32
16E5A:  GOTO   16E8A (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
16DDC:  MOVF   44,F
16DDE:  BNZ   16DEC
16DE0:  MOVF   45,F
16DE2:  BNZ   16DEC
16DE4:  MOVF   46,F
16DE6:  BNZ   16DEC
16DE8:  MOVF   47,F
16DEA:  BZ    16E1C
16DEC:  MOVF   47,F
16DEE:  BNZ   16E1C
16DF0:  MOVF   46,F
16DF2:  BNZ   16E1C
16DF4:  MOVF   45,F
16DF6:  BNZ   16E1C
16DF8:  MOVF   44,W
16DFA:  SUBLW  32
16DFC:  BNC   16E1C
....................       nv_port = arg; 
16DFE:  MOVFF  45,2E
16E02:  MOVFF  44,2D
....................       write16(ADDR_SAMPLE, nv_port); 
16E06:  MOVLW  16
16E08:  MOVLB  8
16E0A:  MOVWF  xCB
16E0C:  MOVFF  2E,8CD
16E10:  MOVFF  2D,8CC
16E14:  MOVLB  0
16E16:  CALL   4F56
....................    } 
16E1A:  BRA    16E20
....................    else cmd_arg(); 
16E1C:  CALL   AF70
16E20:  GOTO   16E8A (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
16E5E:  MOVF   2F,W
16E60:  MOVWF  00
16E62:  MOVF   30,W
16E64:  MOVWF  03
16E66:  BNZ   16E6E
16E68:  MOVLW  01
16E6A:  SUBWF  00,W
16E6C:  BZ    16E84
16E6E:  MOVF   03,W
16E70:  BNZ   16E78
16E72:  MOVLW  03
16E74:  SUBWF  00,W
16E76:  BZ    16E84
16E78:  MOVF   03,W
16E7A:  BNZ   16E82
16E7C:  MOVLW  02
16E7E:  SUBWF  00,W
16E80:  BZ    16E88
16E82:  BRA    16E8A
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
16E84:  BRA    16DDC
....................          break; 
16E86:  BRA    16E8A
....................       case AWS : commandQa(); 
16E88:  BRA    16E24
....................          break;          
....................    } 
16E8A:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
16E8E:  CALL   2948
....................     
....................    nv_macro_step = 0; 
16E92:  CLRF   38
16E94:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
16E96:  MOVLW  3A
16E98:  MOVLB  8
16E9A:  MOVWF  xCB
16E9C:  MOVFF  38,8CD
16EA0:  MOVFF  37,8CC
16EA4:  MOVLB  0
16EA6:  CALL   4F56
....................     
....................    user_quit = FALSE; 
16EAA:  CLRF   4C
....................     
....................    if (arg > 0 && arg < 3501){ 
16EAC:  MOVF   44,F
16EAE:  BNZ   16EBC
16EB0:  MOVF   45,F
16EB2:  BNZ   16EBC
16EB4:  MOVF   46,F
16EB6:  BNZ   16EBC
16EB8:  MOVF   47,F
16EBA:  BZ    16F68
16EBC:  MOVF   47,F
16EBE:  BNZ   16F68
16EC0:  MOVF   46,F
16EC2:  BNZ   16F68
16EC4:  MOVF   45,W
16EC6:  SUBLW  0D
16EC8:  BNC   16F68
16ECA:  BNZ   16ED2
16ECC:  MOVF   44,W
16ECE:  SUBLW  AC
16ED0:  BNC   16F68
....................       samples = arg; 
16ED2:  MOVFF  45,864
16ED6:  MOVFF  44,863
....................       user_quit = FALSE; 
16EDA:  CLRF   4C
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
16EDC:  MOVLB  8
16EDE:  CLRF   x66
16EE0:  CLRF   x65
16EE2:  MOVF   x66,W
16EE4:  SUBWF  x64,W
16EE6:  BNC   16F66
16EE8:  BNZ   16EF0
16EEA:  MOVF   x63,W
16EEC:  SUBWF  x65,W
16EEE:  BC    16F66
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
16EF0:  MOVLW  01
16EF2:  ADDWF  x65,W
16EF4:  MOVWF  x67
16EF6:  MOVLW  00
16EF8:  ADDWFC x66,W
16EFA:  MOVWF  x68
16EFC:  MOVLW  A6
16EFE:  MOVWF  FF6
16F00:  MOVLW  26
16F02:  MOVWF  FF7
16F04:  MOVLW  00
16F06:  MOVWF  FF8
16F08:  CLRF   1B
16F0A:  BTFSC  FF2.7
16F0C:  BSF    1B.7
16F0E:  BCF    FF2.7
16F10:  MOVLW  05
16F12:  MOVLB  A
16F14:  MOVWF  x18
16F16:  MOVLB  0
16F18:  CALL   1010
16F1C:  BTFSC  1B.7
16F1E:  BSF    FF2.7
16F20:  MOVLW  09
16F22:  MOVWF  FE9
16F24:  CLRF   1B
16F26:  BTFSC  FF2.7
16F28:  BSF    1B.7
16F2A:  BCF    FF2.7
16F2C:  MOVFF  868,A19
16F30:  MOVFF  867,A18
16F34:  CALL   1192
16F38:  BTFSC  1B.7
16F3A:  BSF    FF2.7
16F3C:  MOVLW  0D
16F3E:  BTFSS  F9E.4
16F40:  BRA    16F3E
16F42:  MOVWF  FAD
16F44:  MOVLW  0A
16F46:  BTFSS  F9E.4
16F48:  BRA    16F46
16F4A:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
16F4C:  CALL   15AC8
16F50:  MOVFF  01,862
....................          if (macro_cmd == ';') break; 
16F54:  MOVLB  8
16F56:  MOVF   x62,W
16F58:  SUBLW  3B
16F5A:  BTFSC  FD8.2
16F5C:  BRA    16F66
16F5E:  INCF   x65,F
16F60:  BTFSC  FD8.2
16F62:  INCF   x66,F
16F64:  BRA    16EE2
16F66:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
16F68:  CALL   ADAC
16F6C:  GOTO   1712C (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
16F70:  MOVF   44,F
16F72:  BNZ   16F80
16F74:  MOVF   45,F
16F76:  BNZ   16F80
16F78:  MOVF   46,F
16F7A:  BNZ   16F80
16F7C:  MOVF   47,F
16F7E:  BZ    16FC4
16F80:  MOVF   47,F
16F82:  BNZ   16FC4
16F84:  MOVF   46,F
16F86:  BNZ   16FC4
16F88:  MOVF   45,F
16F8A:  BNZ   16FC4
16F8C:  MOVF   44,W
16F8E:  SUBLW  2F
16F90:  BNC   16FC4
....................       n=arg; 
16F92:  MOVFF  44,865
....................       port=2; 
16F96:  MOVLB  8
16F98:  CLRF   x63
16F9A:  MOVLW  02
16F9C:  MOVWF  x62
....................       for(i=0;i<n;++i){ 
16F9E:  CLRF   x64
16FA0:  MOVF   x65,W
16FA2:  SUBWF  x64,W
16FA4:  BC    16FC0
....................          play_wms_hard_macro(port); 
16FA6:  MOVFF  863,867
16FAA:  MOVFF  862,866
16FAE:  MOVLB  0
16FB0:  CALL   D506
....................          ++port; 
16FB4:  MOVLB  8
16FB6:  INCF   x62,F
16FB8:  BTFSC  FD8.2
16FBA:  INCF   x63,F
16FBC:  INCF   x64,F
16FBE:  BRA    16FA0
....................       } 
....................    } 
16FC0:  BRA    16FCA
16FC2:  MOVLB  0
....................    else cmd_arg(); 
16FC4:  CALL   AF70
16FC8:  MOVLB  8
16FCA:  MOVLB  0
16FCC:  GOTO   1712C (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
16FD0:  CALL   2948
....................     
....................    nv_macro_step = 0; 
16FD4:  CLRF   38
16FD6:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
16FD8:  MOVLW  3A
16FDA:  MOVLB  8
16FDC:  MOVWF  xCB
16FDE:  MOVFF  38,8CD
16FE2:  MOVFF  37,8CC
16FE6:  MOVLB  0
16FE8:  CALL   4F56
....................     
....................    user_quit = FALSE; 
16FEC:  CLRF   4C
....................     
....................    if (arg > 0 && arg < 241){ 
16FEE:  MOVF   44,F
16FF0:  BNZ   17000
16FF2:  MOVF   45,F
16FF4:  BNZ   17000
16FF6:  MOVF   46,F
16FF8:  BNZ   17000
16FFA:  MOVF   47,F
16FFC:  BTFSC  FD8.2
16FFE:  BRA    170EC
17000:  MOVF   47,F
17002:  BTFSS  FD8.2
17004:  BRA    170EC
17006:  MOVF   46,F
17008:  BTFSS  FD8.2
1700A:  BRA    170EC
1700C:  MOVF   45,F
1700E:  BTFSS  FD8.2
17010:  BRA    170EC
17012:  MOVF   44,W
17014:  SUBLW  F0
17016:  BNC   170EC
....................       samples = arg; 
17018:  MOVFF  45,864
1701C:  MOVFF  44,863
....................       user_quit = FALSE; 
17020:  CLRF   4C
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
17022:  MOVLB  8
17024:  CLRF   x66
17026:  CLRF   x65
17028:  MOVF   x66,W
1702A:  SUBWF  x64,W
1702C:  BNC   170EA
1702E:  BNZ   17036
17030:  MOVF   x63,W
17032:  SUBWF  x65,W
17034:  BC    170EA
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
17036:  MOVLW  01
17038:  ADDWF  x65,W
1703A:  MOVWF  x67
1703C:  MOVLW  00
1703E:  ADDWFC x66,W
17040:  MOVWF  x68
17042:  MOVLW  B4
17044:  MOVWF  FF6
17046:  MOVLW  26
17048:  MOVWF  FF7
1704A:  MOVLW  00
1704C:  MOVWF  FF8
1704E:  CLRF   1B
17050:  BTFSC  FF2.7
17052:  BSF    1B.7
17054:  BCF    FF2.7
17056:  MOVLW  05
17058:  MOVLB  A
1705A:  MOVWF  x18
1705C:  MOVLB  0
1705E:  CALL   1010
17062:  BTFSC  1B.7
17064:  BSF    FF2.7
17066:  MOVLW  09
17068:  MOVWF  FE9
1706A:  CLRF   1B
1706C:  BTFSC  FF2.7
1706E:  BSF    1B.7
17070:  BCF    FF2.7
17072:  MOVFF  868,A19
17076:  MOVFF  867,A18
1707A:  CALL   1192
1707E:  BTFSC  1B.7
17080:  BSF    FF2.7
17082:  MOVLW  0D
17084:  BTFSS  F9E.4
17086:  BRA    17084
17088:  MOVWF  FAD
1708A:  MOVLW  0A
1708C:  BTFSS  F9E.4
1708E:  BRA    1708C
17090:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
17092:  MOVLW  01
17094:  MOVLB  8
17096:  ADDWF  x65,W
17098:  MOVWF  x67
1709A:  MOVLW  00
1709C:  ADDWFC x66,W
1709E:  MOVWF  x68
170A0:  MOVWF  x6A
170A2:  MOVFF  867,869
170A6:  MOVLB  0
170A8:  CALL   1637E
170AC:  MOVFF  01,862
....................          ++nv_sample;                     // increment sample number 
170B0:  INCF   21,F
170B2:  BTFSC  FD8.2
170B4:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
170B6:  MOVLW  16
170B8:  MOVLB  8
170BA:  MOVWF  xCB
170BC:  MOVFF  22,8CD
170C0:  MOVFF  21,8CC
170C4:  MOVLB  0
170C6:  CALL   4F56
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
170CA:  MOVF   27,W
170CC:  SUBWF  21,W
170CE:  BNZ   170D6
170D0:  MOVF   28,W
170D2:  SUBWF  22,W
170D4:  BZ    170DE
170D6:  MOVLB  8
170D8:  MOVF   x62,W
170DA:  SUBLW  3B
170DC:  BNZ   170E2
170DE:  MOVLB  8
170E0:  BRA    170EA
170E2:  INCF   x65,F
170E4:  BTFSC  FD8.2
170E6:  INCF   x66,F
170E8:  BRA    17028
170EA:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
170EC:  CALL   ADAC
170F0:  GOTO   1712C (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
170F4:  MOVF   2F,W
170F6:  MOVWF  00
170F8:  MOVF   30,W
170FA:  MOVWF  03
170FC:  BNZ   17102
170FE:  MOVF   00,F
17100:  BZ    17122
17102:  MOVF   03,W
17104:  BNZ   1710C
17106:  MOVLW  01
17108:  SUBWF  00,W
1710A:  BZ    17126
1710C:  MOVF   03,W
1710E:  BNZ   17116
17110:  MOVLW  03
17112:  SUBWF  00,W
17114:  BZ    17126
17116:  MOVF   03,W
17118:  BNZ   17120
1711A:  MOVLW  02
1711C:  SUBWF  00,W
1711E:  BZ    1712A
17120:  BRA    1712C
....................       case ECO : commandRe(); 
17122:  BRA    16E8E
....................          break; 
17124:  BRA    1712C
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
17126:  BRA    16F70
....................          break; 
17128:  BRA    1712C
....................       case AWS : commandRa(); 
1712A:  BRA    16FD0
....................          break;          
....................    } 
1712C:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
17130:  CALL   2948
....................     
....................    switch(arg){ 
17134:  MOVFF  44,00
17138:  MOVF   45,W
1713A:  MOVWF  03
1713C:  BNZ   17144
1713E:  MOVLW  01
17140:  SUBWF  00,W
17142:  BZ    17150
17144:  MOVF   03,W
17146:  BNZ   1714E
17148:  MOVLW  02
1714A:  SUBWF  00,W
1714C:  BZ    17194
1714E:  BRA    171A4
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
17150:  DECFSZ 41,W
17152:  BRA    17168
17154:  MOVF   42,F
17156:  BNZ   17168
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
17158:  MOVLB  8
1715A:  CLRF   x9F
1715C:  MOVLW  01
1715E:  MOVWF  xA0
17160:  MOVLB  0
17162:  CALL   1340C
....................       } 
17166:  BRA    17192
....................       else if(nv_det_type==2 || nv_det_type==3) 
17168:  MOVF   41,W
1716A:  SUBLW  02
1716C:  BNZ   17172
1716E:  MOVF   42,F
17170:  BZ    1717C
17172:  MOVF   41,W
17174:  SUBLW  03
17176:  BNZ   17192
17178:  MOVF   42,F
1717A:  BNZ   17192
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
1717C:  MOVLB  8
1717E:  CLRF   xA0
17180:  MOVLW  C8
17182:  MOVWF  x9F
17184:  CLRF   xA1
17186:  MOVLW  01
17188:  MOVWF  xA2
1718A:  CLRF   xA3
1718C:  MOVLB  0
1718E:  CALL   FCFC
....................       } 
....................       break;                                                        //200 scans,don't store,display 
17192:  BRA    171A8
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
17194:  MOVLB  8
17196:  CLRF   x9F
17198:  MOVLW  01
1719A:  MOVWF  xA0
1719C:  MOVLB  0
1719E:  CALL   1370E
....................       break; 
171A2:  BRA    171A8
....................    default: cmd_arg(); 
171A4:  CALL   AF70
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
171A8:  CALL   ADAC
171AC:  GOTO   17258 (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
171B0:  MOVF   47,F
171B2:  BNZ   171E4
171B4:  MOVF   46,F
171B6:  BNZ   171E4
171B8:  MOVF   45,W
171BA:  SUBLW  04
171BC:  BNC   171E4
171BE:  BNZ   171C6
171C0:  MOVF   44,W
171C2:  SUBLW  00
171C4:  BNC   171E4
....................       nv_sample = arg; 
171C6:  MOVFF  45,22
171CA:  MOVFF  44,21
....................       write16(ADDR_SAMPLE, nv_sample); 
171CE:  MOVLW  16
171D0:  MOVLB  8
171D2:  MOVWF  xCB
171D4:  MOVFF  22,8CD
171D8:  MOVFF  21,8CC
171DC:  MOVLB  0
171DE:  CALL   4F56
....................    } 
171E2:  BRA    171E8
....................    else cmd_arg(); 
171E4:  CALL   AF70
171E8:  GOTO   17258 (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
171EC:  MOVF   47,F
171EE:  BNZ   17218
171F0:  MOVF   46,F
171F2:  BNZ   17218
171F4:  MOVF   45,W
171F6:  SUBLW  01
171F8:  BNC   17218
171FA:  BNZ   17202
171FC:  MOVF   44,W
171FE:  SUBLW  02
17200:  BNC   17218
....................       setting = arg; 
17202:  MOVFF  45,863
17206:  MOVFF  44,862
....................       sol_switch_cmd(setting); 
1720A:  MOVFF  863,894
1720E:  MOVFF  862,893
17212:  CALL   14014
....................    } 
17216:  BRA    1721C
....................    else cmd_arg(); 
17218:  CALL   AF70
1721C:  GOTO   17258 (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
17220:  MOVF   2F,W
17222:  MOVWF  00
17224:  MOVF   30,W
17226:  MOVWF  03
17228:  BNZ   1722E
1722A:  MOVF   00,F
1722C:  BZ    1724E
1722E:  MOVF   03,W
17230:  BNZ   17238
17232:  MOVLW  01
17234:  SUBWF  00,W
17236:  BZ    17252
17238:  MOVF   03,W
1723A:  BNZ   17242
1723C:  MOVLW  03
1723E:  SUBWF  00,W
17240:  BZ    17252
17242:  MOVF   03,W
17244:  BNZ   1724C
17246:  MOVLW  02
17248:  SUBWF  00,W
1724A:  BZ    17256
1724C:  BRA    17258
....................       case ECO : commandSe(); 
1724E:  BRA    17130
....................          break; 
17250:  BRA    17258
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
17252:  BRA    171B0
....................          break; 
17254:  BRA    17258
....................       case AWS : commandSa(); 
17256:  BRA    171EC
....................          break;          
....................    } 
17258:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
177BE:  MOVLW  C2
177C0:  MOVWF  FF6
177C2:  MOVLW  26
177C4:  MOVWF  FF7
177C6:  MOVLW  00
177C8:  MOVWF  FF8
177CA:  CLRF   1B
177CC:  BTFSC  FF2.7
177CE:  BSF    1B.7
177D0:  BCF    FF2.7
177D2:  CALL   0E3A
177D6:  BTFSC  1B.7
177D8:  BSF    FF2.7
....................    fputc('>',COM_A); 
177DA:  MOVLW  3E
177DC:  CALL   ADB4
....................    RTCfmt=fgetc(COM_A); 
177E0:  CALL   0E24
177E4:  MOVFF  01,4B
....................    if (com_echo == TRUE) 
177E8:  DECFSZ 48,W
177EA:  BRA    177F2
....................       { 
....................       fputc(RTCfmt,COM_A); 
177EC:  MOVF   4B,W
177EE:  CALL   ADB4
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
177F2:  MOVLW  30
177F4:  SUBWF  4B,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
177F6:  MOVF   4B,W
177F8:  SUBLW  01
177FA:  BNC   17830
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
177FC:  MOVLW  EE
177FE:  MOVWF  FF6
17800:  MOVLW  26
17802:  MOVWF  FF7
17804:  MOVLW  00
17806:  MOVWF  FF8
17808:  CALL   AD82
1780C:  MOVLW  0D
1780E:  BTFSS  F9E.4
17810:  BRA    1780E
17812:  MOVWF  FAD
17814:  MOVLW  0A
17816:  BTFSS  F9E.4
17818:  BRA    17816
1781A:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
1781C:  MOVLW  1A
1781E:  MOVLB  8
17820:  MOVWF  xCB
17822:  CLRF   xCD
17824:  MOVFF  4B,8CC
17828:  MOVLB  0
1782A:  CALL   4F56
....................       }  
1782E:  BRA    17834
....................    else cmd_arg(); 
17830:  CALL   AF70
....................     
....................    if(arg == 1) 
17834:  DECFSZ 44,W
17836:  BRA    17848
17838:  MOVF   45,F
1783A:  BNZ   17848
1783C:  MOVF   46,F
1783E:  BNZ   17848
17840:  MOVF   47,F
17842:  BNZ   17848
....................    { 
....................       RTC_Set(); 
17844:  BRA    17674
....................    } 
17846:  BRA    1784C
....................    else cmd_arg(); 
17848:  CALL   AF70
1784C:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
181C0:  MOVF   47,F
181C2:  BNZ   181DE
181C4:  MOVF   46,F
181C6:  BNZ   181DE
181C8:  MOVF   45,F
181CA:  BNZ   181DE
181CC:  MOVF   44,W
181CE:  SUBLW  14
181D0:  BNC   181DE
....................       macro = arg; 
181D2:  MOVFF  44,862
....................       upload_macro(macro);    
181D6:  MOVFF  862,863
181DA:  BRA    17F0E
....................    }    
181DC:  BRA    181FA
....................    else if (arg == 5525){ 
181DE:  MOVF   44,W
181E0:  SUBLW  95
181E2:  BNZ   181F6
181E4:  MOVF   45,W
181E6:  SUBLW  15
181E8:  BNZ   181F6
181EA:  MOVF   46,F
181EC:  BNZ   181F6
181EE:  MOVF   47,F
181F0:  BNZ   181F6
....................       write_blank_macros(); 
181F2:  BRA    18044
....................    } 
181F4:  BRA    181FA
....................    else cmd_arg(); 
181F6:  CALL   AF70
181FA:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
18318:  MOVF   47,F
1831A:  BNZ   18336
1831C:  MOVF   46,F
1831E:  BNZ   18336
18320:  MOVF   45,F
18322:  BNZ   18336
18324:  MOVF   44,W
18326:  SUBLW  14
18328:  BNC   18336
....................       macro = arg;  
1832A:  MOVFF  44,862
....................       read_macro(macro); 
1832E:  MOVFF  862,863
18332:  BRA    182B2
....................    }    
18334:  BRA    1833A
....................    else cmd_arg(); 
18336:  CALL   AF70
1833A:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
1848C:  DECFSZ 44,W
1848E:  BRA    184A8
18490:  MOVF   45,F
18492:  BNZ   184A8
18494:  MOVF   46,F
18496:  BNZ   184A8
18498:  MOVF   47,F
1849A:  BNZ   184A8
....................       RTC_alarm(); 
1849C:  BRA    1833E
....................       RTC_late(); 
1849E:  CALL   152BE
....................       RTC_alarm_status(); 
184A2:  CALL   15778
....................    } 
184A6:  BRA    184AC
....................    else cmd_arg(); 
184A8:  CALL   AF70
184AC:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
184B0:  MOVF   44,W
184B2:  MOVWF  00
184B4:  MOVF   45,W
184B6:  MOVWF  03
184B8:  BNZ   184BE
184BA:  MOVF   00,F
184BC:  BZ    184F2
184BE:  MOVF   03,W
184C0:  BNZ   184C8
184C2:  MOVLW  02
184C4:  SUBWF  00,W
184C6:  BZ    184F2
184C8:  MOVF   03,W
184CA:  BNZ   184D2
184CC:  MOVLW  03
184CE:  SUBWF  00,W
184D0:  BZ    184F2
184D2:  MOVF   03,W
184D4:  BNZ   184DC
184D6:  MOVLW  04
184D8:  SUBWF  00,W
184DA:  BZ    184F2
184DC:  MOVF   03,W
184DE:  BNZ   184E6
184E0:  MOVLW  05
184E2:  SUBWF  00,W
184E4:  BZ    184F2
184E6:  MOVF   03,W
184E8:  BNZ   184F0
184EA:  MOVLW  06
184EC:  SUBWF  00,W
184EE:  BZ    184F2
184F0:  BRA    18510
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
184F2:  MOVFF  45,20
184F6:  MOVFF  44,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
184FA:  MOVLW  1C
184FC:  MOVLB  8
184FE:  MOVWF  xCB
18500:  MOVFF  20,8CD
18504:  MOVFF  1F,8CC
18508:  MOVLB  0
1850A:  CALL   4F56
....................          break; 
1850E:  BRA    18514
....................       default: cmd_arg(); 
18510:  CALL   AF70
....................          break; 
....................    } 
18514:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
18518:  CALL   2948
....................     
....................    switch(arg){ 
1851C:  MOVFF  44,00
18520:  MOVF   45,W
18522:  MOVWF  03
18524:  BNZ   1852A
18526:  MOVF   00,F
18528:  BZ    185AE
1852A:  MOVF   03,W
1852C:  BNZ   18534
1852E:  MOVLW  0A
18530:  SUBWF  00,W
18532:  BZ    185AE
18534:  MOVF   03,W
18536:  BNZ   1853E
18538:  MOVLW  01
1853A:  SUBWF  00,W
1853C:  BZ    185B6
1853E:  MOVF   03,W
18540:  BNZ   18548
18542:  MOVLW  0B
18544:  SUBWF  00,W
18546:  BZ    185B6
18548:  MOVF   03,W
1854A:  BNZ   18552
1854C:  MOVLW  14
1854E:  SUBWF  00,W
18550:  BZ    185C0
18552:  MOVF   03,W
18554:  BNZ   1855C
18556:  MOVLW  15
18558:  SUBWF  00,W
1855A:  BZ    185C6
1855C:  MOVF   03,W
1855E:  BNZ   18566
18560:  MOVLW  1E
18562:  SUBWF  00,W
18564:  BZ    185CC
18566:  MOVF   03,W
18568:  BNZ   18570
1856A:  MOVLW  1F
1856C:  SUBWF  00,W
1856E:  BZ    185D2
18570:  MOVF   03,W
18572:  BNZ   1857A
18574:  MOVLW  28
18576:  SUBWF  00,W
18578:  BZ    185D8
1857A:  MOVF   03,W
1857C:  BNZ   18584
1857E:  MOVLW  29
18580:  SUBWF  00,W
18582:  BZ    185DE
18584:  MOVF   03,W
18586:  BNZ   1858E
18588:  MOVLW  32
1858A:  SUBWF  00,W
1858C:  BZ    185E4
1858E:  MOVF   03,W
18590:  BNZ   18598
18592:  MOVLW  33
18594:  SUBWF  00,W
18596:  BZ    185EA
18598:  MOVF   03,W
1859A:  BNZ   185A2
1859C:  MOVLW  3C
1859E:  SUBWF  00,W
185A0:  BZ    185F0
185A2:  MOVF   03,W
185A4:  BNZ   185AC
185A6:  MOVLW  3D
185A8:  SUBWF  00,W
185AA:  BZ    185FE
185AC:  BRA    18610
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
185AE:  BCF    F90.7
....................                bus_pwr_status=0; 
185B0:  MOVLB  4
185B2:  CLRF   xB2
....................          break; 
185B4:  BRA    18616
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
185B6:  BSF    F90.7
....................                bus_pwr_status=1; 
185B8:  MOVLW  01
185BA:  MOVLB  4
185BC:  MOVWF  xB2
....................          break; 
185BE:  BRA    18616
....................       case 20: output_bit(VMOT,OFF); 
185C0:  BCF    F8E.1
....................          break; 
185C2:  MOVLB  4
185C4:  BRA    18616
....................       case 21: output_bit(VMOT,ON); 
185C6:  BSF    F8E.1
....................          break; 
185C8:  MOVLB  4
185CA:  BRA    18616
....................       case 30: output_bit(VENC1,OFF); 
185CC:  BCF    F8E.6
....................          break; 
185CE:  MOVLB  4
185D0:  BRA    18616
....................       case 31: output_bit(VENC1,ON); 
185D2:  BSF    F8E.6
....................          break; 
185D4:  MOVLB  4
185D6:  BRA    18616
....................       case 40: output_bit(VENC2,OFF); 
185D8:  BCF    F8E.7
....................          break; 
185DA:  MOVLB  4
185DC:  BRA    18616
....................       case 41: output_bit(VENC2,ON); 
185DE:  BSF    F8E.7
....................          break; 
185E0:  MOVLB  4
185E2:  BRA    18616
....................       case 50: output_bit(VHBRDG,OFF); 
185E4:  BCF    F8E.2
....................          break; 
185E6:  MOVLB  4
185E8:  BRA    18616
....................       case 51: output_bit(VHBRDG,ON); 
185EA:  BSF    F8E.2
....................          break;          
185EC:  MOVLB  4
185EE:  BRA    18616
....................       case 60: set_heaters(0); 
185F0:  MOVLB  8
185F2:  CLRF   xA2
185F4:  MOVLB  0
185F6:  CALL   123EC
....................          break; 
185FA:  MOVLB  4
185FC:  BRA    18616
....................       case 61: set_heaters(3); 
185FE:  MOVLW  03
18600:  MOVLB  8
18602:  MOVWF  xA2
18604:  MOVLB  0
18606:  CALL   123EC
....................          break; 
1860A:  MOVLB  4
1860C:  BRA    18616
1860E:  MOVLB  0
....................       default : cmd_arg(); 
18610:  CALL   AF70
....................          break;          
18614:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
18616:  MOVLB  0
18618:  CALL   ADAC
1861C:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
18620:  MOVF   44,F
18622:  BNZ   1863E
18624:  MOVF   45,F
18626:  BNZ   1863E
18628:  MOVF   46,F
1862A:  BNZ   1863E
1862C:  MOVF   47,F
1862E:  BNZ   1863E
....................       motor_sleep_rdy(); 
18630:  CALL   2920
....................       shutdown(); 
18634:  CALL   1579A
....................       go_to_sleep(); 
18638:  CALL   15A02
....................    } 
1863C:  BRA    18642
....................    else cmd_arg(); 
1863E:  CALL   AF70
18642:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
18770:  DECFSZ 44,W
18772:  BRA    18784
18774:  MOVF   45,F
18776:  BNZ   18784
18778:  MOVF   46,F
1877A:  BNZ   18784
1877C:  MOVF   47,F
1877E:  BNZ   18784
18780:  BRA    1866A
18782:  BRA    18788
....................    else cmd_arg(); 
18784:  CALL   AF70
18788:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
1878C:  MOVF   47,F
1878E:  BNZ   1881E
18790:  MOVF   46,F
18792:  BNZ   1881E
18794:  MOVF   45,W
18796:  SUBLW  27
18798:  BNC   1881E
1879A:  BNZ   187A2
1879C:  MOVF   44,W
1879E:  SUBLW  10
187A0:  BNC   1881E
....................       m_bklsh[motor] = arg; 
187A2:  BCF    FD8.0
187A4:  MOVLB  7
187A6:  RLCF   x3C,W
187A8:  CLRF   03
187AA:  ADDLW  6E
187AC:  MOVWF  FE9
187AE:  MOVLW  07
187B0:  ADDWFC 03,W
187B2:  MOVWF  FEA
187B4:  MOVFF  44,FEF
187B8:  MOVFF  45,FEC
....................       switch(motor){ 
187BC:  MOVF   x3C,W
187BE:  XORLW  00
187C0:  MOVLB  0
187C2:  BZ    187CA
187C4:  XORLW  01
187C6:  BZ    187F4
187C8:  BRA    1881C
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
187CA:  BCF    FD8.0
187CC:  MOVLB  7
187CE:  RLCF   x3C,W
187D0:  CLRF   03
187D2:  ADDLW  6E
187D4:  MOVWF  FE9
187D6:  MOVLW  07
187D8:  ADDWFC 03,W
187DA:  MOVWF  FEA
187DC:  MOVFF  FEC,8CD
187E0:  MOVF   FED,F
187E2:  MOVFF  FEF,8CC
187E6:  MOVLW  72
187E8:  MOVLB  8
187EA:  MOVWF  xCB
187EC:  MOVLB  0
187EE:  CALL   4F56
....................             break; 
187F2:  BRA    1881C
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
187F4:  BCF    FD8.0
187F6:  MOVLB  7
187F8:  RLCF   x3C,W
187FA:  CLRF   03
187FC:  ADDLW  6E
187FE:  MOVWF  FE9
18800:  MOVLW  07
18802:  ADDWFC 03,W
18804:  MOVWF  FEA
18806:  MOVFF  FEC,8CD
1880A:  MOVF   FED,F
1880C:  MOVFF  FEF,8CC
18810:  MOVLW  74
18812:  MOVLB  8
18814:  MOVWF  xCB
18816:  MOVLB  0
18818:  CALL   4F56
....................             break;             
....................       } 
....................    } 
1881C:  BRA    18822
....................    else cmd_arg();    
1881E:  CALL   AF70
18822:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_c(){ 
....................    if(arg == 0){ 
18826:  MOVF   44,F
18828:  BNZ   1883A
1882A:  MOVF   45,F
1882C:  BNZ   1883A
1882E:  MOVF   46,F
18830:  BNZ   1883A
18832:  MOVF   47,F
18834:  BNZ   1883A
....................       output_bit(PIN_J7,0); 
18836:  BCF    F91.7
....................    }else if(arg == 1){ 
18838:  BRA    1886A
1883A:  DECFSZ 44,W
1883C:  BRA    1884E
1883E:  MOVF   45,F
18840:  BNZ   1884E
18842:  MOVF   46,F
18844:  BNZ   1884E
18846:  MOVF   47,F
18848:  BNZ   1884E
....................       output_bit(PIN_J7,1); 
1884A:  BSF    F91.7
....................    }else{ 
1884C:  BRA    1886A
....................       RTC_reset_HT(); 
1884E:  CALL   343A
....................       output_bit(RTC_CS, ENABLE); 
18852:  BCF    F91.0
....................       spi_write(0x89); 
18854:  MOVF   FC9,W
18856:  MOVLW  89
18858:  MOVWF  FC9
1885A:  RRCF   FC7,W
1885C:  BNC   1885A
....................       spi_write(arg); 
1885E:  MOVF   FC9,W
18860:  MOVFF  44,FC9
18864:  RRCF   FC7,W
18866:  BNC   18864
....................       output_bit(RTC_CS, DISABLE); 
18868:  BSF    F91.0
....................    } 
1886A:  GOTO   1AD3A (RETURN)
.................... } 
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
1886E:  MOVF   47,F
18870:  BNZ   188FC
18872:  MOVF   46,F
18874:  BNZ   188FC
18876:  MOVF   45,F
18878:  BNZ   188FC
1887A:  MOVF   44,W
1887C:  SUBLW  01
1887E:  BNC   188FC
....................       m_pos_dir[motor] = arg; 
18880:  BCF    FD8.0
18882:  MOVLB  7
18884:  RLCF   x3C,W
18886:  CLRF   03
18888:  ADDLW  4A
1888A:  MOVWF  FE9
1888C:  MOVLW  07
1888E:  ADDWFC 03,W
18890:  MOVWF  FEA
18892:  MOVFF  44,FEF
18896:  MOVFF  45,FEC
....................       switch(motor){ 
1889A:  MOVF   x3C,W
1889C:  XORLW  00
1889E:  MOVLB  0
188A0:  BZ    188A8
188A2:  XORLW  01
188A4:  BZ    188D2
188A6:  BRA    188FA
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
188A8:  BCF    FD8.0
188AA:  MOVLB  7
188AC:  RLCF   x3C,W
188AE:  CLRF   03
188B0:  ADDLW  4A
188B2:  MOVWF  FE9
188B4:  MOVLW  07
188B6:  ADDWFC 03,W
188B8:  MOVWF  FEA
188BA:  MOVFF  FEC,8CD
188BE:  MOVF   FED,F
188C0:  MOVFF  FEF,8CC
188C4:  MOVLW  92
188C6:  MOVLB  8
188C8:  MOVWF  xCB
188CA:  MOVLB  0
188CC:  CALL   4F56
....................             break; 
188D0:  BRA    188FA
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
188D2:  BCF    FD8.0
188D4:  MOVLB  7
188D6:  RLCF   x3C,W
188D8:  CLRF   03
188DA:  ADDLW  4A
188DC:  MOVWF  FE9
188DE:  MOVLW  07
188E0:  ADDWFC 03,W
188E2:  MOVWF  FEA
188E4:  MOVFF  FEC,8CD
188E8:  MOVF   FED,F
188EA:  MOVFF  FEF,8CC
188EE:  MOVLW  94
188F0:  MOVLB  8
188F2:  MOVWF  xCB
188F4:  MOVLB  0
188F6:  CALL   4F56
....................             break;             
....................       } 
....................    } 
188FA:  BRA    18900
....................    else cmd_arg();    
188FC:  CALL   AF70
18900:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
18904:  MOVF   47,F
18906:  BNZ   18996
18908:  MOVF   46,F
1890A:  BNZ   18996
1890C:  MOVF   45,W
1890E:  SUBLW  27
18910:  BNC   18996
18912:  BNZ   1891A
18914:  MOVF   44,W
18916:  SUBLW  10
18918:  BNC   18996
....................       e_cpr[motor] = arg; 
1891A:  BCF    FD8.0
1891C:  MOVLB  7
1891E:  RLCF   x3C,W
18920:  CLRF   03
18922:  ADDLW  5A
18924:  MOVWF  FE9
18926:  MOVLW  07
18928:  ADDWFC 03,W
1892A:  MOVWF  FEA
1892C:  MOVFF  44,FEF
18930:  MOVFF  45,FEC
....................       switch(motor){ 
18934:  MOVF   x3C,W
18936:  XORLW  00
18938:  MOVLB  0
1893A:  BZ    18942
1893C:  XORLW  01
1893E:  BZ    1896C
18940:  BRA    18994
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
18942:  BCF    FD8.0
18944:  MOVLB  7
18946:  RLCF   x3C,W
18948:  CLRF   03
1894A:  ADDLW  5A
1894C:  MOVWF  FE9
1894E:  MOVLW  07
18950:  ADDWFC 03,W
18952:  MOVWF  FEA
18954:  MOVFF  FEC,8CD
18958:  MOVF   FED,F
1895A:  MOVFF  FEF,8CC
1895E:  MOVLW  A2
18960:  MOVLB  8
18962:  MOVWF  xCB
18964:  MOVLB  0
18966:  CALL   4F56
....................             break; 
1896A:  BRA    18994
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
1896C:  BCF    FD8.0
1896E:  MOVLB  7
18970:  RLCF   x3C,W
18972:  CLRF   03
18974:  ADDLW  5A
18976:  MOVWF  FE9
18978:  MOVLW  07
1897A:  ADDWFC 03,W
1897C:  MOVWF  FEA
1897E:  MOVFF  FEC,8CD
18982:  MOVF   FED,F
18984:  MOVFF  FEF,8CC
18988:  MOVLW  A4
1898A:  MOVLB  8
1898C:  MOVWF  xCB
1898E:  MOVLB  0
18990:  CALL   4F56
....................             break;             
....................       } 
....................    } 
18994:  BRA    1899A
....................    else cmd_arg();    
18996:  CALL   AF70
1899A:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
1899E:  MOVF   47,F
189A0:  BNZ   189B6
189A2:  MOVF   46,F
189A4:  BNZ   189B6
189A6:  MOVF   45,F
189A8:  BNZ   189B6
189AA:  MOVF   44,W
189AC:  SUBLW  01
189AE:  BNC   189B6
189B0:  MOVFF  44,73D
189B4:  BRA    189BA
....................    else cmd_arg();    
189B6:  CALL   AF70
189BA:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
189BE:  MOVF   47,F
189C0:  BNZ   18A50
189C2:  MOVF   46,F
189C4:  BNZ   18A50
189C6:  MOVF   45,W
189C8:  SUBLW  EA
189CA:  BNC   18A50
189CC:  BNZ   189D4
189CE:  MOVF   44,W
189D0:  SUBLW  60
189D2:  BNC   18A50
....................       m_gb_err[motor] = arg; 
189D4:  BCF    FD8.0
189D6:  MOVLB  7
189D8:  RLCF   x3C,W
189DA:  CLRF   03
189DC:  ADDLW  56
189DE:  MOVWF  FE9
189E0:  MOVLW  07
189E2:  ADDWFC 03,W
189E4:  MOVWF  FEA
189E6:  MOVFF  44,FEF
189EA:  MOVFF  45,FEC
....................       switch(motor){ 
189EE:  MOVF   x3C,W
189F0:  XORLW  00
189F2:  MOVLB  0
189F4:  BZ    189FC
189F6:  XORLW  01
189F8:  BZ    18A26
189FA:  BRA    18A4E
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
189FC:  BCF    FD8.0
189FE:  MOVLB  7
18A00:  RLCF   x3C,W
18A02:  CLRF   03
18A04:  ADDLW  56
18A06:  MOVWF  FE9
18A08:  MOVLW  07
18A0A:  ADDWFC 03,W
18A0C:  MOVWF  FEA
18A0E:  MOVFF  FEC,8CD
18A12:  MOVF   FED,F
18A14:  MOVFF  FEF,8CC
18A18:  MOVLW  9E
18A1A:  MOVLB  8
18A1C:  MOVWF  xCB
18A1E:  MOVLB  0
18A20:  CALL   4F56
....................             break; 
18A24:  BRA    18A4E
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
18A26:  BCF    FD8.0
18A28:  MOVLB  7
18A2A:  RLCF   x3C,W
18A2C:  CLRF   03
18A2E:  ADDLW  56
18A30:  MOVWF  FE9
18A32:  MOVLW  07
18A34:  ADDWFC 03,W
18A36:  MOVWF  FEA
18A38:  MOVFF  FEC,8CD
18A3C:  MOVF   FED,F
18A3E:  MOVFF  FEF,8CC
18A42:  MOVLW  A0
18A44:  MOVLB  8
18A46:  MOVWF  xCB
18A48:  MOVLB  0
18A4A:  CALL   4F56
....................             break;             
....................       } 
....................    } 
18A4E:  BRA    18A54
....................    else cmd_arg();    
18A50:  CALL   AF70
18A54:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
18A58:  MOVF   47,F
18A5A:  BNZ   18B24
18A5C:  MOVF   46,F
18A5E:  BNZ   18B24
18A60:  MOVF   45,F
18A62:  BNZ   18B24
18A64:  MOVF   44,W
18A66:  SUBLW  64
18A68:  BNC   18B24
....................       hold_pc=arg; 
18A6A:  MOVFF  45,863
18A6E:  MOVFF  44,862
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
18A72:  BCF    FD8.0
18A74:  MOVLB  7
18A76:  RLCF   x3C,W
18A78:  CLRF   03
18A7A:  ADDLW  4E
18A7C:  MOVWF  FE9
18A7E:  MOVLW  07
18A80:  ADDWFC 03,W
18A82:  MOVWF  FEA
18A84:  MOVFF  863,9EA
18A88:  MOVFF  862,9E9
18A8C:  MOVLW  01
18A8E:  MOVLB  9
18A90:  MOVWF  xEC
18A92:  SETF   xEB
18A94:  MOVLB  0
18A96:  CALL   5C18
18A9A:  MOVFF  02,867
18A9E:  MOVFF  01,866
18AA2:  MOVFF  02,8B9
18AA6:  MOVFF  01,8B8
18AAA:  MOVLB  8
18AAC:  CLRF   xBB
18AAE:  MOVLW  64
18AB0:  MOVWF  xBA
18AB2:  MOVLB  0
18AB4:  CALL   2C5C
18AB8:  MOVFF  01,FEF
18ABC:  MOVFF  02,FEC
....................       switch(motor){ 
18AC0:  MOVLB  7
18AC2:  MOVF   x3C,W
18AC4:  XORLW  00
18AC6:  MOVLB  0
18AC8:  BZ    18AD0
18ACA:  XORLW  01
18ACC:  BZ    18AFA
18ACE:  BRA    18B22
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
18AD0:  BCF    FD8.0
18AD2:  MOVLB  7
18AD4:  RLCF   x3C,W
18AD6:  CLRF   03
18AD8:  ADDLW  4E
18ADA:  MOVWF  FE9
18ADC:  MOVLW  07
18ADE:  ADDWFC 03,W
18AE0:  MOVWF  FEA
18AE2:  MOVFF  FEC,8CD
18AE6:  MOVF   FED,F
18AE8:  MOVFF  FEF,8CC
18AEC:  MOVLW  96
18AEE:  MOVLB  8
18AF0:  MOVWF  xCB
18AF2:  MOVLB  0
18AF4:  CALL   4F56
....................             break; 
18AF8:  BRA    18B22
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
18AFA:  BCF    FD8.0
18AFC:  MOVLB  7
18AFE:  RLCF   x3C,W
18B00:  CLRF   03
18B02:  ADDLW  4E
18B04:  MOVWF  FE9
18B06:  MOVLW  07
18B08:  ADDWFC 03,W
18B0A:  MOVWF  FEA
18B0C:  MOVFF  FEC,8CD
18B10:  MOVF   FED,F
18B12:  MOVFF  FEF,8CC
18B16:  MOVLW  98
18B18:  MOVLB  8
18B1A:  MOVWF  xCB
18B1C:  MOVLB  0
18B1E:  CALL   4F56
....................             break;             
....................       } 
....................    } 
18B22:  BRA    18B28
....................    else cmd_arg();    
18B24:  CALL   AF70
18B28:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
18B2C:  MOVF   47,F
18B2E:  BNZ   18C00
18B30:  MOVF   46,F
18B32:  BNZ   18C00
18B34:  MOVF   45,W
18B36:  SUBLW  EA
18B38:  BNC   18C00
18B3A:  BNZ   18B42
18B3C:  MOVF   44,W
18B3E:  SUBLW  60
18B40:  BNC   18C00
....................       m_stp_int[motor] = (arg/100); 
18B42:  BCF    FD8.0
18B44:  MOVLB  7
18B46:  RLCF   x3C,W
18B48:  CLRF   03
18B4A:  ADDLW  46
18B4C:  MOVWF  FE9
18B4E:  MOVLW  07
18B50:  ADDWFC 03,W
18B52:  MOVWF  FEA
18B54:  MOVFF  FEA,865
18B58:  MOVFF  FE9,864
18B5C:  BCF    FD8.1
18B5E:  CLRF   1B
18B60:  BTFSC  FF2.7
18B62:  BSF    1B.7
18B64:  BCF    FF2.7
18B66:  MOVFF  47,A27
18B6A:  MOVFF  46,A26
18B6E:  MOVFF  45,A25
18B72:  MOVFF  44,A24
18B76:  MOVLB  A
18B78:  CLRF   x2B
18B7A:  CLRF   x2A
18B7C:  CLRF   x29
18B7E:  MOVLW  64
18B80:  MOVWF  x28
18B82:  MOVLB  0
18B84:  CALL   1042
18B88:  BTFSC  1B.7
18B8A:  BSF    FF2.7
18B8C:  MOVFF  865,FEA
18B90:  MOVFF  864,FE9
18B94:  MOVFF  00,FEF
18B98:  MOVFF  01,FEC
....................       switch(motor){ 
18B9C:  MOVLB  7
18B9E:  MOVF   x3C,W
18BA0:  XORLW  00
18BA2:  MOVLB  0
18BA4:  BZ    18BAC
18BA6:  XORLW  01
18BA8:  BZ    18BD6
18BAA:  BRA    18BFE
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
18BAC:  BCF    FD8.0
18BAE:  MOVLB  7
18BB0:  RLCF   x3C,W
18BB2:  CLRF   03
18BB4:  ADDLW  46
18BB6:  MOVWF  FE9
18BB8:  MOVLW  07
18BBA:  ADDWFC 03,W
18BBC:  MOVWF  FEA
18BBE:  MOVFF  FEC,8CD
18BC2:  MOVF   FED,F
18BC4:  MOVFF  FEF,8CC
18BC8:  MOVLW  8E
18BCA:  MOVLB  8
18BCC:  MOVWF  xCB
18BCE:  MOVLB  0
18BD0:  CALL   4F56
....................             break; 
18BD4:  BRA    18BFE
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
18BD6:  BCF    FD8.0
18BD8:  MOVLB  7
18BDA:  RLCF   x3C,W
18BDC:  CLRF   03
18BDE:  ADDLW  46
18BE0:  MOVWF  FE9
18BE2:  MOVLW  07
18BE4:  ADDWFC 03,W
18BE6:  MOVWF  FEA
18BE8:  MOVFF  FEC,8CD
18BEC:  MOVF   FED,F
18BEE:  MOVFF  FEF,8CC
18BF2:  MOVLW  90
18BF4:  MOVLB  8
18BF6:  MOVWF  xCB
18BF8:  MOVLB  0
18BFA:  CALL   4F56
....................             break;             
....................       } 
....................    } 
18BFE:  BRA    18C04
....................    else cmd_arg();    
18C00:  CALL   AF70
18C04:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
18C08:  MOVF   47,F
18C0A:  BNZ   18C9A
18C0C:  MOVF   46,F
18C0E:  BNZ   18C9A
18C10:  MOVF   45,W
18C12:  SUBLW  27
18C14:  BNC   18C9A
18C16:  BNZ   18C1E
18C18:  MOVF   44,W
18C1A:  SUBLW  10
18C1C:  BNC   18C9A
....................       m_run[motor] = arg; 
18C1E:  BCF    FD8.0
18C20:  MOVLB  7
18C22:  RLCF   x3C,W
18C24:  CLRF   03
18C26:  ADDLW  6A
18C28:  MOVWF  FE9
18C2A:  MOVLW  07
18C2C:  ADDWFC 03,W
18C2E:  MOVWF  FEA
18C30:  MOVFF  44,FEF
18C34:  MOVFF  45,FEC
....................       switch(motor){ 
18C38:  MOVF   x3C,W
18C3A:  XORLW  00
18C3C:  MOVLB  0
18C3E:  BZ    18C46
18C40:  XORLW  01
18C42:  BZ    18C70
18C44:  BRA    18C98
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
18C46:  BCF    FD8.0
18C48:  MOVLB  7
18C4A:  RLCF   x3C,W
18C4C:  CLRF   03
18C4E:  ADDLW  6A
18C50:  MOVWF  FE9
18C52:  MOVLW  07
18C54:  ADDWFC 03,W
18C56:  MOVWF  FEA
18C58:  MOVFF  FEC,8CD
18C5C:  MOVF   FED,F
18C5E:  MOVFF  FEF,8CC
18C62:  MOVLW  76
18C64:  MOVLB  8
18C66:  MOVWF  xCB
18C68:  MOVLB  0
18C6A:  CALL   4F56
....................             break; 
18C6E:  BRA    18C98
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
18C70:  BCF    FD8.0
18C72:  MOVLB  7
18C74:  RLCF   x3C,W
18C76:  CLRF   03
18C78:  ADDLW  6A
18C7A:  MOVWF  FE9
18C7C:  MOVLW  07
18C7E:  ADDWFC 03,W
18C80:  MOVWF  FEA
18C82:  MOVFF  FEC,8CD
18C86:  MOVF   FED,F
18C88:  MOVFF  FEF,8CC
18C8C:  MOVLW  78
18C8E:  MOVLB  8
18C90:  MOVWF  xCB
18C92:  MOVLB  0
18C94:  CALL   4F56
....................             break;             
....................       } 
....................    } 
18C98:  BRA    18C9E
....................    else cmd_arg();    
18C9A:  CALL   AF70
18C9E:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
18CA2:  MOVF   47,F
18CA4:  BNZ   18D30
18CA6:  MOVF   46,F
18CA8:  BNZ   18D30
18CAA:  MOVF   45,F
18CAC:  BNZ   18D30
18CAE:  MOVF   44,W
18CB0:  SUBLW  03
18CB2:  BNC   18D30
....................       e_mode[motor] = arg; 
18CB4:  BCF    FD8.0
18CB6:  MOVLB  7
18CB8:  RLCF   x3C,W
18CBA:  CLRF   03
18CBC:  ADDLW  62
18CBE:  MOVWF  FE9
18CC0:  MOVLW  07
18CC2:  ADDWFC 03,W
18CC4:  MOVWF  FEA
18CC6:  MOVFF  44,FEF
18CCA:  MOVFF  45,FEC
....................       switch(motor){ 
18CCE:  MOVF   x3C,W
18CD0:  XORLW  00
18CD2:  MOVLB  0
18CD4:  BZ    18CDC
18CD6:  XORLW  01
18CD8:  BZ    18D06
18CDA:  BRA    18D2E
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
18CDC:  BCF    FD8.0
18CDE:  MOVLB  7
18CE0:  RLCF   x3C,W
18CE2:  CLRF   03
18CE4:  ADDLW  62
18CE6:  MOVWF  FE9
18CE8:  MOVLW  07
18CEA:  ADDWFC 03,W
18CEC:  MOVWF  FEA
18CEE:  MOVFF  FEC,8CD
18CF2:  MOVF   FED,F
18CF4:  MOVFF  FEF,8CC
18CF8:  MOVLW  82
18CFA:  MOVLB  8
18CFC:  MOVWF  xCB
18CFE:  MOVLB  0
18D00:  CALL   4F56
....................             break; 
18D04:  BRA    18D2E
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
18D06:  BCF    FD8.0
18D08:  MOVLB  7
18D0A:  RLCF   x3C,W
18D0C:  CLRF   03
18D0E:  ADDLW  62
18D10:  MOVWF  FE9
18D12:  MOVLW  07
18D14:  ADDWFC 03,W
18D16:  MOVWF  FEA
18D18:  MOVFF  FEC,8CD
18D1C:  MOVF   FED,F
18D1E:  MOVFF  FEF,8CC
18D22:  MOVLW  84
18D24:  MOVLB  8
18D26:  MOVWF  xCB
18D28:  MOVLB  0
18D2A:  CALL   4F56
....................             break;             
....................       } 
....................    } 
18D2E:  BRA    18D34
....................    else cmd_arg();    
18D30:  CALL   AF70
18D34:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
19998:  MOVF   47,F
1999A:  BNZ   19A26
1999C:  MOVF   46,F
1999E:  BNZ   19A26
199A0:  MOVF   45,F
199A2:  BNZ   19A26
199A4:  MOVF   44,W
199A6:  SUBLW  01
199A8:  BNC   19A26
....................       m_mode[motor] = arg; 
199AA:  BCF    FD8.0
199AC:  MOVLB  7
199AE:  RLCF   x3C,W
199B0:  CLRF   03
199B2:  ADDLW  42
199B4:  MOVWF  FE9
199B6:  MOVLW  07
199B8:  ADDWFC 03,W
199BA:  MOVWF  FEA
199BC:  MOVFF  44,FEF
199C0:  MOVFF  45,FEC
....................       switch(motor){ 
199C4:  MOVF   x3C,W
199C6:  XORLW  00
199C8:  MOVLB  0
199CA:  BZ    199D2
199CC:  XORLW  01
199CE:  BZ    199FC
199D0:  BRA    19A24
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
199D2:  BCF    FD8.0
199D4:  MOVLB  7
199D6:  RLCF   x3C,W
199D8:  CLRF   03
199DA:  ADDLW  42
199DC:  MOVWF  FE9
199DE:  MOVLW  07
199E0:  ADDWFC 03,W
199E2:  MOVWF  FEA
199E4:  MOVFF  FEC,8CD
199E8:  MOVF   FED,F
199EA:  MOVFF  FEF,8CC
199EE:  MOVLW  8A
199F0:  MOVLB  8
199F2:  MOVWF  xCB
199F4:  MOVLB  0
199F6:  CALL   4F56
....................             break; 
199FA:  BRA    19A24
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
199FC:  BCF    FD8.0
199FE:  MOVLB  7
19A00:  RLCF   x3C,W
19A02:  CLRF   03
19A04:  ADDLW  42
19A06:  MOVWF  FE9
19A08:  MOVLW  07
19A0A:  ADDWFC 03,W
19A0C:  MOVWF  FEA
19A0E:  MOVFF  FEC,8CD
19A12:  MOVF   FED,F
19A14:  MOVFF  FEF,8CC
19A18:  MOVLW  8C
19A1A:  MOVLB  8
19A1C:  MOVWF  xCB
19A1E:  MOVLB  0
19A20:  CALL   4F56
....................             break;             
....................       } 
....................    } 
19A24:  BRA    19A2A
....................    else cmd_arg();    
19A26:  CALL   AF70
19A2A:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
19A2E:  MOVF   47,F
19A30:  BNZ   19ABC
19A32:  MOVF   46,F
19A34:  BNZ   19ABC
19A36:  MOVF   45,F
19A38:  BNZ   19ABC
19A3A:  MOVF   44,W
19A3C:  SUBLW  01
19A3E:  BNC   19ABC
....................       e_index[motor] = arg; 
19A40:  BCF    FD8.0
19A42:  MOVLB  7
19A44:  RLCF   x3C,W
19A46:  CLRF   03
19A48:  ADDLW  76
19A4A:  MOVWF  FE9
19A4C:  MOVLW  07
19A4E:  ADDWFC 03,W
19A50:  MOVWF  FEA
19A52:  MOVFF  44,FEF
19A56:  MOVFF  45,FEC
....................       switch(motor){ 
19A5A:  MOVF   x3C,W
19A5C:  XORLW  00
19A5E:  MOVLB  0
19A60:  BZ    19A68
19A62:  XORLW  01
19A64:  BZ    19A92
19A66:  BRA    19ABA
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
19A68:  BCF    FD8.0
19A6A:  MOVLB  7
19A6C:  RLCF   x3C,W
19A6E:  CLRF   03
19A70:  ADDLW  76
19A72:  MOVWF  FE9
19A74:  MOVLW  07
19A76:  ADDWFC 03,W
19A78:  MOVWF  FEA
19A7A:  MOVFF  FEC,8CD
19A7E:  MOVF   FED,F
19A80:  MOVFF  FEF,8CC
19A84:  MOVLW  BA
19A86:  MOVLB  8
19A88:  MOVWF  xCB
19A8A:  MOVLB  0
19A8C:  CALL   4F56
....................             break; 
19A90:  BRA    19ABA
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
19A92:  BCF    FD8.0
19A94:  MOVLB  7
19A96:  RLCF   x3C,W
19A98:  CLRF   03
19A9A:  ADDLW  76
19A9C:  MOVWF  FE9
19A9E:  MOVLW  07
19AA0:  ADDWFC 03,W
19AA2:  MOVWF  FEA
19AA4:  MOVFF  FEC,8CD
19AA8:  MOVF   FED,F
19AAA:  MOVFF  FEF,8CC
19AAE:  MOVLW  BC
19AB0:  MOVLB  8
19AB2:  MOVWF  xCB
19AB4:  MOVLB  0
19AB6:  CALL   4F56
....................             break;             
....................       } 
....................    } 
19ABA:  BRA    19AC0
....................    else cmd_arg();    
19ABC:  CALL   AF70
19AC0:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
19AC4:  MOVF   47,F
19AC6:  BNZ   19B56
19AC8:  MOVF   46,F
19ACA:  BNZ   19B56
19ACC:  MOVF   45,W
19ACE:  SUBLW  01
19AD0:  BNC   19B56
19AD2:  BNZ   19ADA
19AD4:  MOVF   44,W
19AD6:  SUBLW  0A
19AD8:  BNC   19B56
....................        evn_so[motor] = arg; 
19ADA:  BCF    FD8.0
19ADC:  MOVLB  7
19ADE:  RLCF   x3C,W
19AE0:  CLRF   03
19AE2:  ADDLW  7A
19AE4:  MOVWF  FE9
19AE6:  MOVLW  07
19AE8:  ADDWFC 03,W
19AEA:  MOVWF  FEA
19AEC:  MOVFF  44,FEF
19AF0:  MOVFF  45,FEC
....................        switch(motor){ 
19AF4:  MOVF   x3C,W
19AF6:  XORLW  00
19AF8:  MOVLB  0
19AFA:  BZ    19B02
19AFC:  XORLW  01
19AFE:  BZ    19B2C
19B00:  BRA    19B54
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
19B02:  BCF    FD8.0
19B04:  MOVLB  7
19B06:  RLCF   x3C,W
19B08:  CLRF   03
19B0A:  ADDLW  7A
19B0C:  MOVWF  FE9
19B0E:  MOVLW  07
19B10:  ADDWFC 03,W
19B12:  MOVWF  FEA
19B14:  MOVFF  FEC,8CD
19B18:  MOVF   FED,F
19B1A:  MOVFF  FEF,8CC
19B1E:  MOVLW  BE
19B20:  MOVLB  8
19B22:  MOVWF  xCB
19B24:  MOVLB  0
19B26:  CALL   4F56
....................             break; 
19B2A:  BRA    19B54
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
19B2C:  BCF    FD8.0
19B2E:  MOVLB  7
19B30:  RLCF   x3C,W
19B32:  CLRF   03
19B34:  ADDLW  7A
19B36:  MOVWF  FE9
19B38:  MOVLW  07
19B3A:  ADDWFC 03,W
19B3C:  MOVWF  FEA
19B3E:  MOVFF  FEC,8CD
19B42:  MOVF   FED,F
19B44:  MOVFF  FEF,8CC
19B48:  MOVLW  C0
19B4A:  MOVLB  8
19B4C:  MOVWF  xCB
19B4E:  MOVLB  0
19B50:  CALL   4F56
....................             break;             
....................       } 
....................    } 
19B54:  BRA    19B5A
....................    else cmd_arg();    
19B56:  CALL   AF70
19B5A:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
19B5E:  MOVF   47,F
19B60:  BNZ   19BF0
19B62:  MOVF   46,F
19B64:  BNZ   19BF0
19B66:  MOVF   45,W
19B68:  SUBLW  03
19B6A:  BNC   19BF0
19B6C:  BNZ   19B74
19B6E:  MOVF   44,W
19B70:  SUBLW  E8
19B72:  BNC   19BF0
....................       e_ppr[motor] = arg; 
19B74:  BCF    FD8.0
19B76:  MOVLB  7
19B78:  RLCF   x3C,W
19B7A:  CLRF   03
19B7C:  ADDLW  5E
19B7E:  MOVWF  FE9
19B80:  MOVLW  07
19B82:  ADDWFC 03,W
19B84:  MOVWF  FEA
19B86:  MOVFF  44,FEF
19B8A:  MOVFF  45,FEC
....................       switch(motor){ 
19B8E:  MOVF   x3C,W
19B90:  XORLW  00
19B92:  MOVLB  0
19B94:  BZ    19B9C
19B96:  XORLW  01
19B98:  BZ    19BC6
19B9A:  BRA    19BEE
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
19B9C:  BCF    FD8.0
19B9E:  MOVLB  7
19BA0:  RLCF   x3C,W
19BA2:  CLRF   03
19BA4:  ADDLW  5E
19BA6:  MOVWF  FE9
19BA8:  MOVLW  07
19BAA:  ADDWFC 03,W
19BAC:  MOVWF  FEA
19BAE:  MOVFF  FEC,8CD
19BB2:  MOVF   FED,F
19BB4:  MOVFF  FEF,8CC
19BB8:  MOVLW  A6
19BBA:  MOVLB  8
19BBC:  MOVWF  xCB
19BBE:  MOVLB  0
19BC0:  CALL   4F56
....................             break; 
19BC4:  BRA    19BEE
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
19BC6:  BCF    FD8.0
19BC8:  MOVLB  7
19BCA:  RLCF   x3C,W
19BCC:  CLRF   03
19BCE:  ADDLW  5E
19BD0:  MOVWF  FE9
19BD2:  MOVLW  07
19BD4:  ADDWFC 03,W
19BD6:  MOVWF  FEA
19BD8:  MOVFF  FEC,8CD
19BDC:  MOVF   FED,F
19BDE:  MOVFF  FEF,8CC
19BE2:  MOVLW  A8
19BE4:  MOVLB  8
19BE6:  MOVWF  xCB
19BE8:  MOVLB  0
19BEA:  CALL   4F56
....................             break;             
....................       } 
....................    } 
19BEE:  BRA    19BF4
....................    else cmd_arg();    
19BF0:  CALL   AF70
19BF4:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
19BF8:  MOVF   44,F
19BFA:  BNZ   19C0C
19BFC:  MOVF   45,F
19BFE:  BNZ   19C0C
19C00:  MOVF   46,F
19C02:  BNZ   19C0C
19C04:  MOVF   47,F
19C06:  BNZ   19C0C
19C08:  BCF    F8E.1
19C0A:  BRA    19C10
....................    else cmd_arg();    
19C0C:  CALL   AF70
19C10:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1A6F4:  MOVF   44,F
1A6F6:  BNZ   1A746
1A6F8:  MOVF   45,F
1A6FA:  BNZ   1A746
1A6FC:  MOVF   46,F
1A6FE:  BNZ   1A746
1A700:  MOVF   47,F
1A702:  BNZ   1A746
....................       switch (nv_product) { 
1A704:  MOVFF  2F,00
1A708:  MOVF   30,W
1A70A:  MOVWF  03
1A70C:  BNZ   1A712
1A70E:  MOVF   00,F
1A710:  BZ    1A732
1A712:  MOVF   03,W
1A714:  BNZ   1A71C
1A716:  MOVLW  01
1A718:  SUBWF  00,W
1A71A:  BZ    1A738
1A71C:  MOVF   03,W
1A71E:  BNZ   1A726
1A720:  MOVLW  02
1A722:  SUBWF  00,W
1A724:  BZ    1A73E
1A726:  MOVF   03,W
1A728:  BNZ   1A730
1A72A:  MOVLW  03
1A72C:  SUBWF  00,W
1A72E:  BZ    1A742
1A730:  BRA    1A744
....................          case ECO : rst_step_vars_eco(); 
1A732:  GOTO   19C14
....................             break; 
1A736:  BRA    1A744
....................          case WMS4 : rst_step_vars_wms4(); 
1A738:  GOTO   19EFE
....................             break; 
1A73C:  BRA    1A744
....................          case AWS : rst_step_vars_aws(); 
1A73E:  BRA    1A1AA
....................             break;             
1A740:  BRA    1A744
....................          case WMS2 : rst_step_vars_wms2(); 
1A742:  BRA    1A444
....................             break; 
....................       } 
....................    }  
1A744:  BRA    1A74A
....................    else cmd_arg(); 
1A746:  CALL   AF70
1A74A:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1A74E:  MOVF   47,F
1A750:  BTFSS  FD8.2
1A752:  BRA    1A854
1A754:  MOVF   46,W
1A756:  SUBLW  00
1A758:  BTFSS  FD8.0
1A75A:  BRA    1A854
....................       m_spr[motor] = arg; 
1A75C:  BCF    FD8.0
1A75E:  MOVLB  7
1A760:  RLCF   x3C,W
1A762:  CLRF   03
1A764:  ADDLW  72
1A766:  MOVWF  FE9
1A768:  MOVLW  07
1A76A:  ADDWFC 03,W
1A76C:  MOVWF  FEA
1A76E:  MOVFF  44,FEF
1A772:  MOVFF  45,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1A776:  BCF    FD8.0
1A778:  RLCF   x3C,W
1A77A:  CLRF   03
1A77C:  ADDLW  A7
1A77E:  MOVWF  01
1A780:  MOVLW  07
1A782:  ADDWFC 03,F
1A784:  MOVFF  01,862
1A788:  MOVLB  8
1A78A:  MOVFF  03,863
1A78E:  BCF    FD8.0
1A790:  MOVLB  7
1A792:  RLCF   x3C,W
1A794:  CLRF   03
1A796:  ADDLW  72
1A798:  MOVWF  FE9
1A79A:  MOVLW  07
1A79C:  ADDWFC 03,W
1A79E:  MOVWF  FEA
1A7A0:  MOVFF  FEC,8B9
1A7A4:  MOVF   FED,F
1A7A6:  MOVFF  FEF,8B8
1A7AA:  BCF    FD8.0
1A7AC:  RLCF   x3C,W
1A7AE:  CLRF   03
1A7B0:  ADDLW  5E
1A7B2:  MOVWF  FE9
1A7B4:  MOVLW  07
1A7B6:  ADDWFC 03,W
1A7B8:  MOVWF  FEA
1A7BA:  MOVFF  FEC,03
1A7BE:  MOVF   FED,F
1A7C0:  MOVFF  FEF,8BA
1A7C4:  MOVFF  03,867
1A7C8:  MOVFF  03,8BB
1A7CC:  MOVLB  0
1A7CE:  CALL   2C5C
1A7D2:  MOVFF  02,865
1A7D6:  BCF    FD8.0
1A7D8:  MOVLB  8
1A7DA:  RLCF   01,W
1A7DC:  MOVWF  02
1A7DE:  RLCF   x65,W
1A7E0:  MOVFF  863,FEA
1A7E4:  MOVFF  862,FE9
1A7E8:  MOVWF  FEC
1A7EA:  MOVF   FED,F
1A7EC:  MOVFF  02,FEF
....................       switch(motor){ 
1A7F0:  MOVLB  7
1A7F2:  MOVF   x3C,W
1A7F4:  XORLW  00
1A7F6:  MOVLB  0
1A7F8:  BZ    1A800
1A7FA:  XORLW  01
1A7FC:  BZ    1A82A
1A7FE:  BRA    1A852
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1A800:  BCF    FD8.0
1A802:  MOVLB  7
1A804:  RLCF   x3C,W
1A806:  CLRF   03
1A808:  ADDLW  72
1A80A:  MOVWF  FE9
1A80C:  MOVLW  07
1A80E:  ADDWFC 03,W
1A810:  MOVWF  FEA
1A812:  MOVFF  FEC,8CD
1A816:  MOVF   FED,F
1A818:  MOVFF  FEF,8CC
1A81C:  MOVLW  AE
1A81E:  MOVLB  8
1A820:  MOVWF  xCB
1A822:  MOVLB  0
1A824:  CALL   4F56
....................             break; 
1A828:  BRA    1A852
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1A82A:  BCF    FD8.0
1A82C:  MOVLB  7
1A82E:  RLCF   x3C,W
1A830:  CLRF   03
1A832:  ADDLW  72
1A834:  MOVWF  FE9
1A836:  MOVLW  07
1A838:  ADDWFC 03,W
1A83A:  MOVWF  FEA
1A83C:  MOVFF  FEC,8CD
1A840:  MOVF   FED,F
1A842:  MOVFF  FEF,8CC
1A846:  MOVLW  B0
1A848:  MOVLB  8
1A84A:  MOVWF  xCB
1A84C:  MOVLB  0
1A84E:  CALL   4F56
....................             break;             
....................       } 
....................    } 
1A852:  BRA    1A858
....................    else cmd_arg();    
1A854:  CALL   AF70
1A858:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1A85C:  MOVF   47,F
1A85E:  BNZ   1A8EA
1A860:  MOVF   46,F
1A862:  BNZ   1A8EA
1A864:  MOVF   45,F
1A866:  BNZ   1A8EA
1A868:  MOVF   44,W
1A86A:  SUBLW  02
1A86C:  BNC   1A8EA
....................       e_type[motor] = arg; 
1A86E:  BCF    FD8.0
1A870:  MOVLB  7
1A872:  RLCF   x3C,W
1A874:  CLRF   03
1A876:  ADDLW  66
1A878:  MOVWF  FE9
1A87A:  MOVLW  07
1A87C:  ADDWFC 03,W
1A87E:  MOVWF  FEA
1A880:  MOVFF  44,FEF
1A884:  MOVFF  45,FEC
....................       switch(motor){ 
1A888:  MOVF   x3C,W
1A88A:  XORLW  00
1A88C:  MOVLB  0
1A88E:  BZ    1A896
1A890:  XORLW  01
1A892:  BZ    1A8C0
1A894:  BRA    1A8E8
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1A896:  BCF    FD8.0
1A898:  MOVLB  7
1A89A:  RLCF   x3C,W
1A89C:  CLRF   03
1A89E:  ADDLW  66
1A8A0:  MOVWF  FE9
1A8A2:  MOVLW  07
1A8A4:  ADDWFC 03,W
1A8A6:  MOVWF  FEA
1A8A8:  MOVFF  FEC,8CD
1A8AC:  MOVF   FED,F
1A8AE:  MOVFF  FEF,8CC
1A8B2:  MOVLW  7A
1A8B4:  MOVLB  8
1A8B6:  MOVWF  xCB
1A8B8:  MOVLB  0
1A8BA:  CALL   4F56
....................             break; 
1A8BE:  BRA    1A8E8
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1A8C0:  BCF    FD8.0
1A8C2:  MOVLB  7
1A8C4:  RLCF   x3C,W
1A8C6:  CLRF   03
1A8C8:  ADDLW  66
1A8CA:  MOVWF  FE9
1A8CC:  MOVLW  07
1A8CE:  ADDWFC 03,W
1A8D0:  MOVWF  FEA
1A8D2:  MOVFF  FEC,8CD
1A8D6:  MOVF   FED,F
1A8D8:  MOVFF  FEF,8CC
1A8DC:  MOVLW  7C
1A8DE:  MOVLB  8
1A8E0:  MOVWF  xCB
1A8E2:  MOVLB  0
1A8E4:  CALL   4F56
....................             break;             
....................       } 
....................    } 
1A8E8:  BRA    1A8EE
....................    else cmd_arg();    
1A8EA:  CALL   AF70
1A8EE:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
*
1A92A:  MOVF   47,F
1A92C:  BNZ   1A9F6
1A92E:  MOVF   46,F
1A930:  BNZ   1A9F6
1A932:  MOVF   45,F
1A934:  BNZ   1A9F6
1A936:  MOVF   44,W
1A938:  SUBLW  64
1A93A:  BNC   1A9F6
....................       drive_pc=arg; 
1A93C:  MOVFF  45,863
1A940:  MOVFF  44,862
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1A944:  BCF    FD8.0
1A946:  MOVLB  7
1A948:  RLCF   x3C,W
1A94A:  CLRF   03
1A94C:  ADDLW  52
1A94E:  MOVWF  FE9
1A950:  MOVLW  07
1A952:  ADDWFC 03,W
1A954:  MOVWF  FEA
1A956:  MOVFF  863,9EA
1A95A:  MOVFF  862,9E9
1A95E:  MOVLW  01
1A960:  MOVLB  9
1A962:  MOVWF  xEC
1A964:  SETF   xEB
1A966:  MOVLB  0
1A968:  CALL   5C18
1A96C:  MOVFF  02,867
1A970:  MOVFF  01,866
1A974:  MOVFF  02,8B9
1A978:  MOVFF  01,8B8
1A97C:  MOVLB  8
1A97E:  CLRF   xBB
1A980:  MOVLW  64
1A982:  MOVWF  xBA
1A984:  MOVLB  0
1A986:  CALL   2C5C
1A98A:  MOVFF  01,FEF
1A98E:  MOVFF  02,FEC
....................       switch(motor){ 
1A992:  MOVLB  7
1A994:  MOVF   x3C,W
1A996:  XORLW  00
1A998:  MOVLB  0
1A99A:  BZ    1A9A2
1A99C:  XORLW  01
1A99E:  BZ    1A9CC
1A9A0:  BRA    1A9F4
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1A9A2:  BCF    FD8.0
1A9A4:  MOVLB  7
1A9A6:  RLCF   x3C,W
1A9A8:  CLRF   03
1A9AA:  ADDLW  52
1A9AC:  MOVWF  FE9
1A9AE:  MOVLW  07
1A9B0:  ADDWFC 03,W
1A9B2:  MOVWF  FEA
1A9B4:  MOVFF  FEC,8CD
1A9B8:  MOVF   FED,F
1A9BA:  MOVFF  FEF,8CC
1A9BE:  MOVLW  9A
1A9C0:  MOVLB  8
1A9C2:  MOVWF  xCB
1A9C4:  MOVLB  0
1A9C6:  CALL   4F56
....................             break; 
1A9CA:  BRA    1A9F4
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1A9CC:  BCF    FD8.0
1A9CE:  MOVLB  7
1A9D0:  RLCF   x3C,W
1A9D2:  CLRF   03
1A9D4:  ADDLW  52
1A9D6:  MOVWF  FE9
1A9D8:  MOVLW  07
1A9DA:  ADDWFC 03,W
1A9DC:  MOVWF  FEA
1A9DE:  MOVFF  FEC,8CD
1A9E2:  MOVF   FED,F
1A9E4:  MOVFF  FEF,8CC
1A9E8:  MOVLW  9C
1A9EA:  MOVLB  8
1A9EC:  MOVWF  xCB
1A9EE:  MOVLB  0
1A9F0:  CALL   4F56
....................             break;             
....................       } 
....................    } 
1A9F4:  BRA    1A9FA
....................    else cmd_arg();    
1A9F6:  CALL   AF70
1A9FA:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1A9FE:  MOVF   47,F
1AA00:  BNZ   1AA90
1AA02:  MOVF   46,F
1AA04:  BNZ   1AA90
1AA06:  MOVF   45,W
1AA08:  SUBLW  27
1AA0A:  BNC   1AA90
1AA0C:  BNZ   1AA14
1AA0E:  MOVF   44,W
1AA10:  SUBLW  0F
1AA12:  BNC   1AA90
....................        align_os[motor] = arg; 
1AA14:  BCF    FD8.0
1AA16:  MOVLB  7
1AA18:  RLCF   x3C,W
1AA1A:  CLRF   03
1AA1C:  ADDLW  7E
1AA1E:  MOVWF  FE9
1AA20:  MOVLW  07
1AA22:  ADDWFC 03,W
1AA24:  MOVWF  FEA
1AA26:  MOVFF  44,FEF
1AA2A:  MOVFF  45,FEC
....................        switch(motor){ 
1AA2E:  MOVF   x3C,W
1AA30:  XORLW  00
1AA32:  MOVLB  0
1AA34:  BZ    1AA3C
1AA36:  XORLW  01
1AA38:  BZ    1AA66
1AA3A:  BRA    1AA8E
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1AA3C:  BCF    FD8.0
1AA3E:  MOVLB  7
1AA40:  RLCF   x3C,W
1AA42:  CLRF   03
1AA44:  ADDLW  7E
1AA46:  MOVWF  FE9
1AA48:  MOVLW  07
1AA4A:  ADDWFC 03,W
1AA4C:  MOVWF  FEA
1AA4E:  MOVFF  FEC,8CD
1AA52:  MOVF   FED,F
1AA54:  MOVFF  FEF,8CC
1AA58:  MOVLW  C2
1AA5A:  MOVLB  8
1AA5C:  MOVWF  xCB
1AA5E:  MOVLB  0
1AA60:  CALL   4F56
....................             break; 
1AA64:  BRA    1AA8E
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1AA66:  BCF    FD8.0
1AA68:  MOVLB  7
1AA6A:  RLCF   x3C,W
1AA6C:  CLRF   03
1AA6E:  ADDLW  7E
1AA70:  MOVWF  FE9
1AA72:  MOVLW  07
1AA74:  ADDWFC 03,W
1AA76:  MOVWF  FEA
1AA78:  MOVFF  FEC,8CD
1AA7C:  MOVF   FED,F
1AA7E:  MOVFF  FEF,8CC
1AA82:  MOVLW  C4
1AA84:  MOVLB  8
1AA86:  MOVWF  xCB
1AA88:  MOVLB  0
1AA8A:  CALL   4F56
....................             break;             
....................       } 
....................    } 
1AA8E:  BRA    1AA94
....................    else cmd_arg();    
1AA90:  CALL   AF70
1AA94:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1AA98:  MOVF   47,F
1AA9A:  BNZ   1AB26
1AA9C:  MOVF   46,F
1AA9E:  BNZ   1AB26
1AAA0:  MOVF   45,F
1AAA2:  BNZ   1AB26
1AAA4:  MOVF   44,W
1AAA6:  SUBLW  01
1AAA8:  BNC   1AB26
....................       m_ctrl[motor] = arg; 
1AAAA:  BCF    FD8.0
1AAAC:  MOVLB  7
1AAAE:  RLCF   x3C,W
1AAB0:  CLRF   03
1AAB2:  ADDLW  3E
1AAB4:  MOVWF  FE9
1AAB6:  MOVLW  07
1AAB8:  ADDWFC 03,W
1AABA:  MOVWF  FEA
1AABC:  MOVFF  44,FEF
1AAC0:  MOVFF  45,FEC
....................       switch(motor){ 
1AAC4:  MOVF   x3C,W
1AAC6:  XORLW  00
1AAC8:  MOVLB  0
1AACA:  BZ    1AAD2
1AACC:  XORLW  01
1AACE:  BZ    1AAFC
1AAD0:  BRA    1AB24
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1AAD2:  BCF    FD8.0
1AAD4:  MOVLB  7
1AAD6:  RLCF   x3C,W
1AAD8:  CLRF   03
1AADA:  ADDLW  3E
1AADC:  MOVWF  FE9
1AADE:  MOVLW  07
1AAE0:  ADDWFC 03,W
1AAE2:  MOVWF  FEA
1AAE4:  MOVFF  FEC,8CD
1AAE8:  MOVF   FED,F
1AAEA:  MOVFF  FEF,8CC
1AAEE:  MOVLW  86
1AAF0:  MOVLB  8
1AAF2:  MOVWF  xCB
1AAF4:  MOVLB  0
1AAF6:  CALL   4F56
....................             break; 
1AAFA:  BRA    1AB24
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1AAFC:  BCF    FD8.0
1AAFE:  MOVLB  7
1AB00:  RLCF   x3C,W
1AB02:  CLRF   03
1AB04:  ADDLW  3E
1AB06:  MOVWF  FE9
1AB08:  MOVLW  07
1AB0A:  ADDWFC 03,W
1AB0C:  MOVWF  FEA
1AB0E:  MOVFF  FEC,8CD
1AB12:  MOVF   FED,F
1AB14:  MOVFF  FEF,8CC
1AB18:  MOVLW  88
1AB1A:  MOVLB  8
1AB1C:  MOVWF  xCB
1AB1E:  MOVLB  0
1AB20:  CALL   4F56
....................             break;             
....................       } 
....................    } 
1AB24:  BRA    1AB2A
....................    else cmd_arg();    
1AB26:  CALL   AF70
1AB2A:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1A8F2:  MOVF   44,W
1A8F4:  MOVWF  00
1A8F6:  MOVF   45,W
1A8F8:  MOVWF  03
1A8FA:  BNZ   1A902
1A8FC:  MOVLW  01
1A8FE:  SUBWF  00,W
1A900:  BZ    1A90E
1A902:  MOVF   03,W
1A904:  BNZ   1A90C
1A906:  MOVLW  02
1A908:  SUBWF  00,W
1A90A:  BZ    1A914
1A90C:  BRA    1A91E
....................       case 1: motor = 0; 
1A90E:  MOVLB  7
1A910:  CLRF   x3C
....................          break; 
1A912:  BRA    1A924
....................       case 2: motor = 1; 
1A914:  MOVLW  01
1A916:  MOVLB  7
1A918:  MOVWF  x3C
....................          break; 
1A91A:  BRA    1A924
1A91C:  MOVLB  0
....................       default : cmd_arg(); 
1A91E:  CALL   AF70
....................          break; 
1A922:  MOVLB  7
....................    } 
1A924:  MOVLB  0
1A926:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1AB2E:  MOVF   44,F
1AB30:  BNZ   1AB3E
1AB32:  MOVF   45,F
1AB34:  BNZ   1AB3E
1AB36:  MOVF   46,F
1AB38:  BNZ   1AB3E
1AB3A:  MOVF   47,F
1AB3C:  BZ    1AB9C
1AB3E:  MOVF   47,F
1AB40:  BNZ   1AB9C
1AB42:  MOVF   46,F
1AB44:  BNZ   1AB9C
1AB46:  MOVF   45,F
1AB48:  BNZ   1AB9C
1AB4A:  MOVF   44,W
1AB4C:  SUBLW  02
1AB4E:  BNC   1AB9C
....................       switch(arg){ 
1AB50:  MOVFF  44,00
1AB54:  MOVF   45,W
1AB56:  MOVWF  03
1AB58:  BNZ   1AB60
1AB5A:  MOVLW  01
1AB5C:  SUBWF  00,W
1AB5E:  BZ    1AB6C
1AB60:  MOVF   03,W
1AB62:  BNZ   1AB6A
1AB64:  MOVLW  02
1AB66:  SUBWF  00,W
1AB68:  BZ    1AB84
1AB6A:  BRA    1AB9A
....................          case 1 : e_pos[0] = 0; 
1AB6C:  MOVLB  7
1AB6E:  CLRF   xBC
1AB70:  CLRF   xBB
....................                   write16(ADDR_E1_POS, 0); 
1AB72:  MOVLW  7E
1AB74:  MOVLB  8
1AB76:  MOVWF  xCB
1AB78:  CLRF   xCD
1AB7A:  CLRF   xCC
1AB7C:  MOVLB  0
1AB7E:  CALL   4F56
....................             break; 
1AB82:  BRA    1AB9A
....................          case 2 : e_pos[1] = 0; 
1AB84:  MOVLB  7
1AB86:  CLRF   xBE
1AB88:  CLRF   xBD
....................                   write16(ADDR_E2_POS, 0); 
1AB8A:  MOVLW  80
1AB8C:  MOVLB  8
1AB8E:  MOVWF  xCB
1AB90:  CLRF   xCD
1AB92:  CLRF   xCC
1AB94:  MOVLB  0
1AB96:  CALL   4F56
....................             break;             
....................       } 
....................    } 
1AB9A:  BRA    1ABA0
....................    else cmd_arg();  
1AB9C:  CALL   AF70
1ABA0:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
18D38:  DECFSZ 44,W
18D3A:  GOTO   19990
18D3E:  MOVF   45,F
18D40:  BTFSS  FD8.2
18D42:  GOTO   19990
18D46:  MOVF   46,F
18D48:  BTFSS  FD8.2
18D4A:  GOTO   19990
18D4E:  MOVF   47,F
18D50:  BTFSS  FD8.2
18D52:  GOTO   19990
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18D56:  MOVFF  74F,9EA
18D5A:  MOVFF  74E,9E9
18D5E:  MOVLB  9
18D60:  CLRF   xEC
18D62:  MOVLW  64
18D64:  MOVWF  xEB
18D66:  MOVLB  0
18D68:  CALL   5C18
18D6C:  MOVFF  02,869
18D70:  MOVFF  01,868
18D74:  MOVFF  02,8B9
18D78:  MOVFF  01,8B8
18D7C:  MOVLW  01
18D7E:  MOVLB  8
18D80:  MOVWF  xBB
18D82:  SETF   xBA
18D84:  MOVLB  0
18D86:  CALL   2C5C
18D8A:  MOVFF  02,863
18D8E:  MOVFF  01,862
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18D92:  MOVFF  753,9EA
18D96:  MOVFF  752,9E9
18D9A:  MOVLB  9
18D9C:  CLRF   xEC
18D9E:  MOVLW  64
18DA0:  MOVWF  xEB
18DA2:  MOVLB  0
18DA4:  CALL   5C18
18DA8:  MOVFF  02,869
18DAC:  MOVFF  01,868
18DB0:  MOVFF  02,8B9
18DB4:  MOVFF  01,8B8
18DB8:  MOVLW  01
18DBA:  MOVLB  8
18DBC:  MOVWF  xBB
18DBE:  SETF   xBA
18DC0:  MOVLB  0
18DC2:  CALL   2C5C
18DC6:  MOVFF  02,865
18DCA:  MOVFF  01,864
....................       step_us  =   m_stp_int[0]*100; 
18DCE:  MOVFF  747,9EA
18DD2:  MOVFF  746,9E9
18DD6:  MOVLB  9
18DD8:  CLRF   xEC
18DDA:  MOVLW  64
18DDC:  MOVWF  xEB
18DDE:  MOVLB  0
18DE0:  CALL   5C18
18DE4:  MOVFF  02,867
18DE8:  MOVFF  01,866
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
18DEC:  MOVLW  06
18DEE:  MOVWF  FF6
18DF0:  MOVLW  27
18DF2:  MOVWF  FF7
18DF4:  MOVLW  00
18DF6:  MOVWF  FF8
18DF8:  CLRF   1B
18DFA:  BTFSC  FF2.7
18DFC:  BSF    1B.7
18DFE:  BCF    FF2.7
18E00:  CALL   0E3A
18E04:  BTFSC  1B.7
18E06:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
18E08:  MOVLW  62
18E0A:  BTFSS  F9E.4
18E0C:  BRA    18E0A
18E0E:  MOVWF  FAD
18E10:  MOVLW  3A
18E12:  BTFSS  F9E.4
18E14:  BRA    18E12
18E16:  MOVWF  FAD
18E18:  MOVLW  10
18E1A:  MOVWF  FE9
18E1C:  CLRF   1B
18E1E:  BTFSC  FF2.7
18E20:  BSF    1B.7
18E22:  BCF    FF2.7
18E24:  MOVFF  76F,A19
18E28:  MOVFF  76E,A18
18E2C:  CALL   1192
18E30:  BTFSC  1B.7
18E32:  BSF    FF2.7
18E34:  MOVLW  0D
18E36:  BTFSS  F9E.4
18E38:  BRA    18E36
18E3A:  MOVWF  FAD
18E3C:  MOVLW  0A
18E3E:  BTFSS  F9E.4
18E40:  BRA    18E3E
18E42:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
18E44:  MOVLW  63
18E46:  BTFSS  F9E.4
18E48:  BRA    18E46
18E4A:  MOVWF  FAD
18E4C:  MOVLW  3A
18E4E:  BTFSS  F9E.4
18E50:  BRA    18E4E
18E52:  MOVWF  FAD
18E54:  MOVLW  41
18E56:  MOVWF  FE9
18E58:  CLRF   1B
18E5A:  BTFSC  FF2.7
18E5C:  BSF    1B.7
18E5E:  BCF    FF2.7
18E60:  MOVFF  7A1,A1B
18E64:  MOVFF  7A0,A1A
18E68:  MOVFF  79F,A19
18E6C:  MOVFF  79E,A18
18E70:  CALL   10D6
18E74:  BTFSC  1B.7
18E76:  BSF    FF2.7
18E78:  MOVLW  2F
18E7A:  BTFSS  F9E.4
18E7C:  BRA    18E7A
18E7E:  MOVWF  FAD
18E80:  MOVLW  10
18E82:  MOVWF  FE9
18E84:  CLRF   1B
18E86:  BTFSC  FF2.7
18E88:  BSF    1B.7
18E8A:  BCF    FF2.7
18E8C:  MOVFF  7B8,A19
18E90:  MOVFF  7B7,A18
18E94:  CALL   1192
18E98:  BTFSC  1B.7
18E9A:  BSF    FF2.7
18E9C:  MOVLW  2F
18E9E:  BTFSS  F9E.4
18EA0:  BRA    18E9E
18EA2:  MOVWF  FAD
18EA4:  MOVLW  10
18EA6:  MOVWF  FE9
18EA8:  CLRF   1B
18EAA:  BTFSC  FF2.7
18EAC:  BSF    1B.7
18EAE:  BCF    FF2.7
18EB0:  MOVFF  7BC,A19
18EB4:  MOVFF  7BB,A18
18EB8:  CALL   1192
18EBC:  BTFSC  1B.7
18EBE:  BSF    FF2.7
18EC0:  MOVLW  0D
18EC2:  BTFSS  F9E.4
18EC4:  BRA    18EC2
18EC6:  MOVWF  FAD
18EC8:  MOVLW  0A
18ECA:  BTFSS  F9E.4
18ECC:  BRA    18ECA
18ECE:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
18ED0:  MOVLW  64
18ED2:  BTFSS  F9E.4
18ED4:  BRA    18ED2
18ED6:  MOVWF  FAD
18ED8:  MOVLW  3A
18EDA:  BTFSS  F9E.4
18EDC:  BRA    18EDA
18EDE:  MOVWF  FAD
18EE0:  MOVLW  10
18EE2:  MOVWF  FE9
18EE4:  CLRF   1B
18EE6:  BTFSC  FF2.7
18EE8:  BSF    1B.7
18EEA:  BCF    FF2.7
18EEC:  MOVFF  74B,A19
18EF0:  MOVFF  74A,A18
18EF4:  CALL   1192
18EF8:  BTFSC  1B.7
18EFA:  BSF    FF2.7
18EFC:  MOVLW  0D
18EFE:  BTFSS  F9E.4
18F00:  BRA    18EFE
18F02:  MOVWF  FAD
18F04:  MOVLW  0A
18F06:  BTFSS  F9E.4
18F08:  BRA    18F06
18F0A:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
18F0C:  MOVLW  65
18F0E:  BTFSS  F9E.4
18F10:  BRA    18F0E
18F12:  MOVWF  FAD
18F14:  MOVLW  3A
18F16:  BTFSS  F9E.4
18F18:  BRA    18F16
18F1A:  MOVWF  FAD
18F1C:  MOVLW  10
18F1E:  MOVWF  FE9
18F20:  CLRF   1B
18F22:  BTFSC  FF2.7
18F24:  BSF    1B.7
18F26:  BCF    FF2.7
18F28:  MOVFF  75B,A19
18F2C:  MOVFF  75A,A18
18F30:  CALL   1192
18F34:  BTFSC  1B.7
18F36:  BSF    FF2.7
18F38:  MOVLW  0D
18F3A:  BTFSS  F9E.4
18F3C:  BRA    18F3A
18F3E:  MOVWF  FAD
18F40:  MOVLW  0A
18F42:  BTFSS  F9E.4
18F44:  BRA    18F42
18F46:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
18F48:  MOVLW  66
18F4A:  BTFSS  F9E.4
18F4C:  BRA    18F4A
18F4E:  MOVWF  FAD
18F50:  MOVLW  3A
18F52:  BTFSS  F9E.4
18F54:  BRA    18F52
18F56:  MOVWF  FAD
18F58:  CLRF   1B
18F5A:  BTFSC  FF2.7
18F5C:  BSF    1B.7
18F5E:  BCF    FF2.7
18F60:  MOVFF  73D,A18
18F64:  MOVLW  1B
18F66:  MOVLB  A
18F68:  MOVWF  x19
18F6A:  MOVLB  0
18F6C:  CALL   0F92
18F70:  BTFSC  1B.7
18F72:  BSF    FF2.7
18F74:  MOVLW  0D
18F76:  BTFSS  F9E.4
18F78:  BRA    18F76
18F7A:  MOVWF  FAD
18F7C:  MOVLW  0A
18F7E:  BTFSS  F9E.4
18F80:  BRA    18F7E
18F82:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
18F84:  MOVLW  67
18F86:  BTFSS  F9E.4
18F88:  BRA    18F86
18F8A:  MOVWF  FAD
18F8C:  MOVLW  3A
18F8E:  BTFSS  F9E.4
18F90:  BRA    18F8E
18F92:  MOVWF  FAD
18F94:  MOVLW  10
18F96:  MOVWF  FE9
18F98:  CLRF   1B
18F9A:  BTFSC  FF2.7
18F9C:  BSF    1B.7
18F9E:  BCF    FF2.7
18FA0:  MOVFF  757,A19
18FA4:  MOVFF  756,A18
18FA8:  CALL   1192
18FAC:  BTFSC  1B.7
18FAE:  BSF    FF2.7
18FB0:  MOVLW  0D
18FB2:  BTFSS  F9E.4
18FB4:  BRA    18FB2
18FB6:  MOVWF  FAD
18FB8:  MOVLW  0A
18FBA:  BTFSS  F9E.4
18FBC:  BRA    18FBA
18FBE:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
18FC0:  MOVLW  68
18FC2:  BTFSS  F9E.4
18FC4:  BRA    18FC2
18FC6:  MOVWF  FAD
18FC8:  MOVLW  3A
18FCA:  BTFSS  F9E.4
18FCC:  BRA    18FCA
18FCE:  MOVWF  FAD
18FD0:  MOVLW  10
18FD2:  MOVWF  FE9
18FD4:  CLRF   1B
18FD6:  BTFSC  FF2.7
18FD8:  BSF    1B.7
18FDA:  BCF    FF2.7
18FDC:  MOVFF  863,A19
18FE0:  MOVFF  862,A18
18FE4:  CALL   1192
18FE8:  BTFSC  1B.7
18FEA:  BSF    FF2.7
18FEC:  MOVLW  0D
18FEE:  BTFSS  F9E.4
18FF0:  BRA    18FEE
18FF2:  MOVWF  FAD
18FF4:  MOVLW  0A
18FF6:  BTFSS  F9E.4
18FF8:  BRA    18FF6
18FFA:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
18FFC:  MOVLW  69
18FFE:  BTFSS  F9E.4
19000:  BRA    18FFE
19002:  MOVWF  FAD
19004:  MOVLW  3A
19006:  BTFSS  F9E.4
19008:  BRA    19006
1900A:  MOVWF  FAD
1900C:  MOVLW  10
1900E:  MOVWF  FE9
19010:  CLRF   1B
19012:  BTFSC  FF2.7
19014:  BSF    1B.7
19016:  BCF    FF2.7
19018:  MOVFF  867,A19
1901C:  MOVFF  866,A18
19020:  CALL   1192
19024:  BTFSC  1B.7
19026:  BSF    FF2.7
19028:  MOVLW  0D
1902A:  BTFSS  F9E.4
1902C:  BRA    1902A
1902E:  MOVWF  FAD
19030:  MOVLW  0A
19032:  BTFSS  F9E.4
19034:  BRA    19032
19036:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
19038:  MOVLW  6A
1903A:  BTFSS  F9E.4
1903C:  BRA    1903A
1903E:  MOVWF  FAD
19040:  MOVLW  3A
19042:  BTFSS  F9E.4
19044:  BRA    19042
19046:  MOVWF  FAD
19048:  MOVLW  10
1904A:  MOVWF  FE9
1904C:  CLRF   1B
1904E:  BTFSC  FF2.7
19050:  BSF    1B.7
19052:  BCF    FF2.7
19054:  MOVFF  76B,A19
19058:  MOVFF  76A,A18
1905C:  CALL   1192
19060:  BTFSC  1B.7
19062:  BSF    FF2.7
19064:  MOVLW  0D
19066:  BTFSS  F9E.4
19068:  BRA    19066
1906A:  MOVWF  FAD
1906C:  MOVLW  0A
1906E:  BTFSS  F9E.4
19070:  BRA    1906E
19072:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
19074:  MOVLW  6B
19076:  BTFSS  F9E.4
19078:  BRA    19076
1907A:  MOVWF  FAD
1907C:  MOVLW  3A
1907E:  BTFSS  F9E.4
19080:  BRA    1907E
19082:  MOVWF  FAD
19084:  MOVLW  10
19086:  MOVWF  FE9
19088:  CLRF   1B
1908A:  BTFSC  FF2.7
1908C:  BSF    1B.7
1908E:  BCF    FF2.7
19090:  MOVFF  763,A19
19094:  MOVFF  762,A18
19098:  CALL   1192
1909C:  BTFSC  1B.7
1909E:  BSF    FF2.7
190A0:  MOVLW  0D
190A2:  BTFSS  F9E.4
190A4:  BRA    190A2
190A6:  MOVWF  FAD
190A8:  MOVLW  0A
190AA:  BTFSS  F9E.4
190AC:  BRA    190AA
190AE:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
190B0:  MOVLW  6D
190B2:  BTFSS  F9E.4
190B4:  BRA    190B2
190B6:  MOVWF  FAD
190B8:  MOVLW  3A
190BA:  BTFSS  F9E.4
190BC:  BRA    190BA
190BE:  MOVWF  FAD
190C0:  MOVLW  10
190C2:  MOVWF  FE9
190C4:  CLRF   1B
190C6:  BTFSC  FF2.7
190C8:  BSF    1B.7
190CA:  BCF    FF2.7
190CC:  MOVFF  743,A19
190D0:  MOVFF  742,A18
190D4:  CALL   1192
190D8:  BTFSC  1B.7
190DA:  BSF    FF2.7
190DC:  MOVLW  0D
190DE:  BTFSS  F9E.4
190E0:  BRA    190DE
190E2:  MOVWF  FAD
190E4:  MOVLW  0A
190E6:  BTFSS  F9E.4
190E8:  BRA    190E6
190EA:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
190EC:  MOVLW  6E
190EE:  BTFSS  F9E.4
190F0:  BRA    190EE
190F2:  MOVWF  FAD
190F4:  MOVLW  3A
190F6:  BTFSS  F9E.4
190F8:  BRA    190F6
190FA:  MOVWF  FAD
190FC:  MOVLW  10
190FE:  MOVWF  FE9
19100:  CLRF   1B
19102:  BTFSC  FF2.7
19104:  BSF    1B.7
19106:  BCF    FF2.7
19108:  MOVFF  777,A19
1910C:  MOVFF  776,A18
19110:  CALL   1192
19114:  BTFSC  1B.7
19116:  BSF    FF2.7
19118:  MOVLW  0D
1911A:  BTFSS  F9E.4
1911C:  BRA    1911A
1911E:  MOVWF  FAD
19120:  MOVLW  0A
19122:  BTFSS  F9E.4
19124:  BRA    19122
19126:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
19128:  MOVLW  6F
1912A:  BTFSS  F9E.4
1912C:  BRA    1912A
1912E:  MOVWF  FAD
19130:  MOVLW  3A
19132:  BTFSS  F9E.4
19134:  BRA    19132
19136:  MOVWF  FAD
19138:  MOVLW  10
1913A:  MOVWF  FE9
1913C:  CLRF   1B
1913E:  BTFSC  FF2.7
19140:  BSF    1B.7
19142:  BCF    FF2.7
19144:  MOVFF  77B,A19
19148:  MOVFF  77A,A18
1914C:  CALL   1192
19150:  BTFSC  1B.7
19152:  BSF    FF2.7
19154:  MOVLW  0D
19156:  BTFSS  F9E.4
19158:  BRA    19156
1915A:  MOVWF  FAD
1915C:  MOVLW  0A
1915E:  BTFSS  F9E.4
19160:  BRA    1915E
19162:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
19164:  MOVLW  70
19166:  BTFSS  F9E.4
19168:  BRA    19166
1916A:  MOVWF  FAD
1916C:  MOVLW  3A
1916E:  BTFSS  F9E.4
19170:  BRA    1916E
19172:  MOVWF  FAD
19174:  MOVLW  10
19176:  MOVWF  FE9
19178:  CLRF   1B
1917A:  BTFSC  FF2.7
1917C:  BSF    1B.7
1917E:  BCF    FF2.7
19180:  MOVFF  7C0,A19
19184:  MOVFF  7BF,A18
19188:  CALL   1192
1918C:  BTFSC  1B.7
1918E:  BSF    FF2.7
19190:  MOVLW  2F
19192:  BTFSS  F9E.4
19194:  BRA    19192
19196:  MOVWF  FAD
19198:  MOVLW  10
1919A:  MOVWF  FE9
1919C:  CLRF   1B
1919E:  BTFSC  FF2.7
191A0:  BSF    1B.7
191A2:  BCF    FF2.7
191A4:  MOVFF  75F,A19
191A8:  MOVFF  75E,A18
191AC:  CALL   1192
191B0:  BTFSC  1B.7
191B2:  BSF    FF2.7
191B4:  MOVLW  0D
191B6:  BTFSS  F9E.4
191B8:  BRA    191B6
191BA:  MOVWF  FAD
191BC:  MOVLW  0A
191BE:  BTFSS  F9E.4
191C0:  BRA    191BE
191C2:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
191C4:  MOVLW  71
191C6:  BTFSS  F9E.4
191C8:  BRA    191C6
191CA:  MOVWF  FAD
191CC:  MOVLW  3A
191CE:  BTFSS  F9E.4
191D0:  BRA    191CE
191D2:  MOVWF  FAD
191D4:  MOVLW  10
191D6:  MOVWF  FE9
191D8:  CLRF   1B
191DA:  BTFSC  FF2.7
191DC:  BSF    1B.7
191DE:  BCF    FF2.7
191E0:  MOVFF  793,A19
191E4:  MOVFF  792,A18
191E8:  CALL   1192
191EC:  BTFSC  1B.7
191EE:  BSF    FF2.7
191F0:  MOVLW  0D
191F2:  BTFSS  F9E.4
191F4:  BRA    191F2
191F6:  MOVWF  FAD
191F8:  MOVLW  0A
191FA:  BTFSS  F9E.4
191FC:  BRA    191FA
191FE:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
19200:  MOVLW  73
19202:  BTFSS  F9E.4
19204:  BRA    19202
19206:  MOVWF  FAD
19208:  MOVLW  3A
1920A:  BTFSS  F9E.4
1920C:  BRA    1920A
1920E:  MOVWF  FAD
19210:  MOVLW  10
19212:  MOVWF  FE9
19214:  CLRF   1B
19216:  BTFSC  FF2.7
19218:  BSF    1B.7
1921A:  BCF    FF2.7
1921C:  MOVFF  773,A19
19220:  MOVFF  772,A18
19224:  CALL   1192
19228:  BTFSC  1B.7
1922A:  BSF    FF2.7
1922C:  MOVLW  0D
1922E:  BTFSS  F9E.4
19230:  BRA    1922E
19232:  MOVWF  FAD
19234:  MOVLW  0A
19236:  BTFSS  F9E.4
19238:  BRA    19236
1923A:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
1923C:  MOVLW  74
1923E:  BTFSS  F9E.4
19240:  BRA    1923E
19242:  MOVWF  FAD
19244:  MOVLW  3A
19246:  BTFSS  F9E.4
19248:  BRA    19246
1924A:  MOVWF  FAD
1924C:  MOVLW  10
1924E:  MOVWF  FE9
19250:  CLRF   1B
19252:  BTFSC  FF2.7
19254:  BSF    1B.7
19256:  BCF    FF2.7
19258:  MOVFF  767,A19
1925C:  MOVFF  766,A18
19260:  CALL   1192
19264:  BTFSC  1B.7
19266:  BSF    FF2.7
19268:  MOVLW  0D
1926A:  BTFSS  F9E.4
1926C:  BRA    1926A
1926E:  MOVWF  FAD
19270:  MOVLW  0A
19272:  BTFSS  F9E.4
19274:  BRA    19272
19276:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19278:  MOVLW  01
1927A:  MOVLB  7
1927C:  ADDWF  x3C,W
1927E:  MOVLB  8
19280:  MOVWF  x68
19282:  MOVLW  75
19284:  BTFSS  F9E.4
19286:  BRA    19284
19288:  MOVWF  FAD
1928A:  MOVLW  3A
1928C:  BTFSS  F9E.4
1928E:  BRA    1928C
19290:  MOVWF  FAD
19292:  CLRF   1B
19294:  BTFSC  FF2.7
19296:  BSF    1B.7
19298:  BCF    FF2.7
1929A:  MOVFF  868,A18
1929E:  MOVLW  1B
192A0:  MOVLB  A
192A2:  MOVWF  x19
192A4:  MOVLB  0
192A6:  CALL   0F92
192AA:  BTFSC  1B.7
192AC:  BSF    FF2.7
192AE:  MOVLW  0D
192B0:  BTFSS  F9E.4
192B2:  BRA    192B0
192B4:  MOVWF  FAD
192B6:  MOVLW  0A
192B8:  BTFSS  F9E.4
192BA:  BRA    192B8
192BC:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
192BE:  MOVLW  77
192C0:  BTFSS  F9E.4
192C2:  BRA    192C0
192C4:  MOVWF  FAD
192C6:  MOVLW  3A
192C8:  BTFSS  F9E.4
192CA:  BRA    192C8
192CC:  MOVWF  FAD
192CE:  MOVLW  10
192D0:  MOVWF  FE9
192D2:  CLRF   1B
192D4:  BTFSC  FF2.7
192D6:  BSF    1B.7
192D8:  BCF    FF2.7
192DA:  MOVFF  865,A19
192DE:  MOVFF  864,A18
192E2:  CALL   1192
192E6:  BTFSC  1B.7
192E8:  BSF    FF2.7
192EA:  MOVLW  0D
192EC:  BTFSS  F9E.4
192EE:  BRA    192EC
192F0:  MOVWF  FAD
192F2:  MOVLW  0A
192F4:  BTFSS  F9E.4
192F6:  BRA    192F4
192F8:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
192FA:  MOVLW  78
192FC:  BTFSS  F9E.4
192FE:  BRA    192FC
19300:  MOVWF  FAD
19302:  MOVLW  3A
19304:  BTFSS  F9E.4
19306:  BRA    19304
19308:  MOVWF  FAD
1930A:  MOVLW  10
1930C:  MOVWF  FE9
1930E:  CLRF   1B
19310:  BTFSC  FF2.7
19312:  BSF    1B.7
19314:  BCF    FF2.7
19316:  MOVFF  77F,A19
1931A:  MOVFF  77E,A18
1931E:  CALL   1192
19322:  BTFSC  1B.7
19324:  BSF    FF2.7
19326:  MOVLW  0D
19328:  BTFSS  F9E.4
1932A:  BRA    19328
1932C:  MOVWF  FAD
1932E:  MOVLW  0A
19330:  BTFSS  F9E.4
19332:  BRA    19330
19334:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
19336:  MOVLW  79
19338:  BTFSS  F9E.4
1933A:  BRA    19338
1933C:  MOVWF  FAD
1933E:  MOVLW  3A
19340:  BTFSS  F9E.4
19342:  BRA    19340
19344:  MOVWF  FAD
19346:  MOVLW  10
19348:  MOVWF  FE9
1934A:  CLRF   1B
1934C:  BTFSC  FF2.7
1934E:  BSF    1B.7
19350:  BCF    FF2.7
19352:  MOVFF  73F,A19
19356:  MOVFF  73E,A18
1935A:  CALL   1192
1935E:  BTFSC  1B.7
19360:  BSF    FF2.7
19362:  MOVLW  0D
19364:  BTFSS  F9E.4
19366:  BRA    19364
19368:  MOVWF  FAD
1936A:  MOVLW  0A
1936C:  BTFSS  F9E.4
1936E:  BRA    1936C
19370:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19372:  MOVFF  751,9EA
19376:  MOVFF  750,9E9
1937A:  MOVLB  9
1937C:  CLRF   xEC
1937E:  MOVLW  64
19380:  MOVWF  xEB
19382:  MOVLB  0
19384:  CALL   5C18
19388:  MOVFF  02,869
1938C:  MOVFF  01,868
19390:  MOVFF  02,8B9
19394:  MOVFF  01,8B8
19398:  MOVLW  01
1939A:  MOVLB  8
1939C:  MOVWF  xBB
1939E:  SETF   xBA
193A0:  MOVLB  0
193A2:  CALL   2C5C
193A6:  MOVFF  02,863
193AA:  MOVFF  01,862
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
193AE:  MOVFF  755,9EA
193B2:  MOVFF  754,9E9
193B6:  MOVLB  9
193B8:  CLRF   xEC
193BA:  MOVLW  64
193BC:  MOVWF  xEB
193BE:  MOVLB  0
193C0:  CALL   5C18
193C4:  MOVFF  02,869
193C8:  MOVFF  01,868
193CC:  MOVFF  02,8B9
193D0:  MOVFF  01,8B8
193D4:  MOVLW  01
193D6:  MOVLB  8
193D8:  MOVWF  xBB
193DA:  SETF   xBA
193DC:  MOVLB  0
193DE:  CALL   2C5C
193E2:  MOVFF  02,865
193E6:  MOVFF  01,864
....................       step_us  =   m_stp_int[1]*100; 
193EA:  MOVFF  749,9EA
193EE:  MOVFF  748,9E9
193F2:  MOVLB  9
193F4:  CLRF   xEC
193F6:  MOVLW  64
193F8:  MOVWF  xEB
193FA:  MOVLB  0
193FC:  CALL   5C18
19400:  MOVFF  02,867
19404:  MOVFF  01,866
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
19408:  MOVLW  12
1940A:  MOVWF  FF6
1940C:  MOVLW  27
1940E:  MOVWF  FF7
19410:  MOVLW  00
19412:  MOVWF  FF8
19414:  CLRF   1B
19416:  BTFSC  FF2.7
19418:  BSF    1B.7
1941A:  BCF    FF2.7
1941C:  CALL   0E3A
19420:  BTFSC  1B.7
19422:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
19424:  MOVLW  62
19426:  BTFSS  F9E.4
19428:  BRA    19426
1942A:  MOVWF  FAD
1942C:  MOVLW  3A
1942E:  BTFSS  F9E.4
19430:  BRA    1942E
19432:  MOVWF  FAD
19434:  MOVLW  10
19436:  MOVWF  FE9
19438:  CLRF   1B
1943A:  BTFSC  FF2.7
1943C:  BSF    1B.7
1943E:  BCF    FF2.7
19440:  MOVFF  771,A19
19444:  MOVFF  770,A18
19448:  CALL   1192
1944C:  BTFSC  1B.7
1944E:  BSF    FF2.7
19450:  MOVLW  0D
19452:  BTFSS  F9E.4
19454:  BRA    19452
19456:  MOVWF  FAD
19458:  MOVLW  0A
1945A:  BTFSS  F9E.4
1945C:  BRA    1945A
1945E:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
19460:  MOVLW  63
19462:  BTFSS  F9E.4
19464:  BRA    19462
19466:  MOVWF  FAD
19468:  MOVLW  3A
1946A:  BTFSS  F9E.4
1946C:  BRA    1946A
1946E:  MOVWF  FAD
19470:  MOVLW  41
19472:  MOVWF  FE9
19474:  CLRF   1B
19476:  BTFSC  FF2.7
19478:  BSF    1B.7
1947A:  BCF    FF2.7
1947C:  MOVFF  7A5,A1B
19480:  MOVFF  7A4,A1A
19484:  MOVFF  7A3,A19
19488:  MOVFF  7A2,A18
1948C:  CALL   10D6
19490:  BTFSC  1B.7
19492:  BSF    FF2.7
19494:  MOVLW  2F
19496:  BTFSS  F9E.4
19498:  BRA    19496
1949A:  MOVWF  FAD
1949C:  MOVLW  10
1949E:  MOVWF  FE9
194A0:  CLRF   1B
194A2:  BTFSC  FF2.7
194A4:  BSF    1B.7
194A6:  BCF    FF2.7
194A8:  MOVFF  7BA,A19
194AC:  MOVFF  7B9,A18
194B0:  CALL   1192
194B4:  BTFSC  1B.7
194B6:  BSF    FF2.7
194B8:  MOVLW  2F
194BA:  BTFSS  F9E.4
194BC:  BRA    194BA
194BE:  MOVWF  FAD
194C0:  MOVLW  10
194C2:  MOVWF  FE9
194C4:  CLRF   1B
194C6:  BTFSC  FF2.7
194C8:  BSF    1B.7
194CA:  BCF    FF2.7
194CC:  MOVFF  7BE,A19
194D0:  MOVFF  7BD,A18
194D4:  CALL   1192
194D8:  BTFSC  1B.7
194DA:  BSF    FF2.7
194DC:  MOVLW  0D
194DE:  BTFSS  F9E.4
194E0:  BRA    194DE
194E2:  MOVWF  FAD
194E4:  MOVLW  0A
194E6:  BTFSS  F9E.4
194E8:  BRA    194E6
194EA:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
194EC:  MOVLW  64
194EE:  BTFSS  F9E.4
194F0:  BRA    194EE
194F2:  MOVWF  FAD
194F4:  MOVLW  3A
194F6:  BTFSS  F9E.4
194F8:  BRA    194F6
194FA:  MOVWF  FAD
194FC:  MOVLW  10
194FE:  MOVWF  FE9
19500:  CLRF   1B
19502:  BTFSC  FF2.7
19504:  BSF    1B.7
19506:  BCF    FF2.7
19508:  MOVFF  74D,A19
1950C:  MOVFF  74C,A18
19510:  CALL   1192
19514:  BTFSC  1B.7
19516:  BSF    FF2.7
19518:  MOVLW  0D
1951A:  BTFSS  F9E.4
1951C:  BRA    1951A
1951E:  MOVWF  FAD
19520:  MOVLW  0A
19522:  BTFSS  F9E.4
19524:  BRA    19522
19526:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
19528:  MOVLW  65
1952A:  BTFSS  F9E.4
1952C:  BRA    1952A
1952E:  MOVWF  FAD
19530:  MOVLW  3A
19532:  BTFSS  F9E.4
19534:  BRA    19532
19536:  MOVWF  FAD
19538:  MOVLW  10
1953A:  MOVWF  FE9
1953C:  CLRF   1B
1953E:  BTFSC  FF2.7
19540:  BSF    1B.7
19542:  BCF    FF2.7
19544:  MOVFF  75D,A19
19548:  MOVFF  75C,A18
1954C:  CALL   1192
19550:  BTFSC  1B.7
19552:  BSF    FF2.7
19554:  MOVLW  0D
19556:  BTFSS  F9E.4
19558:  BRA    19556
1955A:  MOVWF  FAD
1955C:  MOVLW  0A
1955E:  BTFSS  F9E.4
19560:  BRA    1955E
19562:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19564:  MOVLW  66
19566:  BTFSS  F9E.4
19568:  BRA    19566
1956A:  MOVWF  FAD
1956C:  MOVLW  3A
1956E:  BTFSS  F9E.4
19570:  BRA    1956E
19572:  MOVWF  FAD
19574:  CLRF   1B
19576:  BTFSC  FF2.7
19578:  BSF    1B.7
1957A:  BCF    FF2.7
1957C:  MOVFF  73D,A18
19580:  MOVLW  1B
19582:  MOVLB  A
19584:  MOVWF  x19
19586:  MOVLB  0
19588:  CALL   0F92
1958C:  BTFSC  1B.7
1958E:  BSF    FF2.7
19590:  MOVLW  0D
19592:  BTFSS  F9E.4
19594:  BRA    19592
19596:  MOVWF  FAD
19598:  MOVLW  0A
1959A:  BTFSS  F9E.4
1959C:  BRA    1959A
1959E:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
195A0:  MOVLW  67
195A2:  BTFSS  F9E.4
195A4:  BRA    195A2
195A6:  MOVWF  FAD
195A8:  MOVLW  3A
195AA:  BTFSS  F9E.4
195AC:  BRA    195AA
195AE:  MOVWF  FAD
195B0:  MOVLW  10
195B2:  MOVWF  FE9
195B4:  CLRF   1B
195B6:  BTFSC  FF2.7
195B8:  BSF    1B.7
195BA:  BCF    FF2.7
195BC:  MOVFF  759,A19
195C0:  MOVFF  758,A18
195C4:  CALL   1192
195C8:  BTFSC  1B.7
195CA:  BSF    FF2.7
195CC:  MOVLW  0D
195CE:  BTFSS  F9E.4
195D0:  BRA    195CE
195D2:  MOVWF  FAD
195D4:  MOVLW  0A
195D6:  BTFSS  F9E.4
195D8:  BRA    195D6
195DA:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
195DC:  MOVLW  68
195DE:  BTFSS  F9E.4
195E0:  BRA    195DE
195E2:  MOVWF  FAD
195E4:  MOVLW  3A
195E6:  BTFSS  F9E.4
195E8:  BRA    195E6
195EA:  MOVWF  FAD
195EC:  MOVLW  10
195EE:  MOVWF  FE9
195F0:  CLRF   1B
195F2:  BTFSC  FF2.7
195F4:  BSF    1B.7
195F6:  BCF    FF2.7
195F8:  MOVFF  863,A19
195FC:  MOVFF  862,A18
19600:  CALL   1192
19604:  BTFSC  1B.7
19606:  BSF    FF2.7
19608:  MOVLW  0D
1960A:  BTFSS  F9E.4
1960C:  BRA    1960A
1960E:  MOVWF  FAD
19610:  MOVLW  0A
19612:  BTFSS  F9E.4
19614:  BRA    19612
19616:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
19618:  MOVLW  69
1961A:  BTFSS  F9E.4
1961C:  BRA    1961A
1961E:  MOVWF  FAD
19620:  MOVLW  3A
19622:  BTFSS  F9E.4
19624:  BRA    19622
19626:  MOVWF  FAD
19628:  MOVLW  10
1962A:  MOVWF  FE9
1962C:  CLRF   1B
1962E:  BTFSC  FF2.7
19630:  BSF    1B.7
19632:  BCF    FF2.7
19634:  MOVFF  867,A19
19638:  MOVFF  866,A18
1963C:  CALL   1192
19640:  BTFSC  1B.7
19642:  BSF    FF2.7
19644:  MOVLW  0D
19646:  BTFSS  F9E.4
19648:  BRA    19646
1964A:  MOVWF  FAD
1964C:  MOVLW  0A
1964E:  BTFSS  F9E.4
19650:  BRA    1964E
19652:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
19654:  MOVLW  6A
19656:  BTFSS  F9E.4
19658:  BRA    19656
1965A:  MOVWF  FAD
1965C:  MOVLW  3A
1965E:  BTFSS  F9E.4
19660:  BRA    1965E
19662:  MOVWF  FAD
19664:  MOVLW  10
19666:  MOVWF  FE9
19668:  CLRF   1B
1966A:  BTFSC  FF2.7
1966C:  BSF    1B.7
1966E:  BCF    FF2.7
19670:  MOVFF  76D,A19
19674:  MOVFF  76C,A18
19678:  CALL   1192
1967C:  BTFSC  1B.7
1967E:  BSF    FF2.7
19680:  MOVLW  0D
19682:  BTFSS  F9E.4
19684:  BRA    19682
19686:  MOVWF  FAD
19688:  MOVLW  0A
1968A:  BTFSS  F9E.4
1968C:  BRA    1968A
1968E:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
19690:  MOVLW  6B
19692:  BTFSS  F9E.4
19694:  BRA    19692
19696:  MOVWF  FAD
19698:  MOVLW  3A
1969A:  BTFSS  F9E.4
1969C:  BRA    1969A
1969E:  MOVWF  FAD
196A0:  MOVLW  10
196A2:  MOVWF  FE9
196A4:  CLRF   1B
196A6:  BTFSC  FF2.7
196A8:  BSF    1B.7
196AA:  BCF    FF2.7
196AC:  MOVFF  765,A19
196B0:  MOVFF  764,A18
196B4:  CALL   1192
196B8:  BTFSC  1B.7
196BA:  BSF    FF2.7
196BC:  MOVLW  0D
196BE:  BTFSS  F9E.4
196C0:  BRA    196BE
196C2:  MOVWF  FAD
196C4:  MOVLW  0A
196C6:  BTFSS  F9E.4
196C8:  BRA    196C6
196CA:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
196CC:  MOVLW  6D
196CE:  BTFSS  F9E.4
196D0:  BRA    196CE
196D2:  MOVWF  FAD
196D4:  MOVLW  3A
196D6:  BTFSS  F9E.4
196D8:  BRA    196D6
196DA:  MOVWF  FAD
196DC:  MOVLW  10
196DE:  MOVWF  FE9
196E0:  CLRF   1B
196E2:  BTFSC  FF2.7
196E4:  BSF    1B.7
196E6:  BCF    FF2.7
196E8:  MOVFF  745,A19
196EC:  MOVFF  744,A18
196F0:  CALL   1192
196F4:  BTFSC  1B.7
196F6:  BSF    FF2.7
196F8:  MOVLW  0D
196FA:  BTFSS  F9E.4
196FC:  BRA    196FA
196FE:  MOVWF  FAD
19700:  MOVLW  0A
19702:  BTFSS  F9E.4
19704:  BRA    19702
19706:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
19708:  MOVLW  6E
1970A:  BTFSS  F9E.4
1970C:  BRA    1970A
1970E:  MOVWF  FAD
19710:  MOVLW  3A
19712:  BTFSS  F9E.4
19714:  BRA    19712
19716:  MOVWF  FAD
19718:  MOVLW  10
1971A:  MOVWF  FE9
1971C:  CLRF   1B
1971E:  BTFSC  FF2.7
19720:  BSF    1B.7
19722:  BCF    FF2.7
19724:  MOVFF  779,A19
19728:  MOVFF  778,A18
1972C:  CALL   1192
19730:  BTFSC  1B.7
19732:  BSF    FF2.7
19734:  MOVLW  0D
19736:  BTFSS  F9E.4
19738:  BRA    19736
1973A:  MOVWF  FAD
1973C:  MOVLW  0A
1973E:  BTFSS  F9E.4
19740:  BRA    1973E
19742:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
19744:  MOVLW  6F
19746:  BTFSS  F9E.4
19748:  BRA    19746
1974A:  MOVWF  FAD
1974C:  MOVLW  3A
1974E:  BTFSS  F9E.4
19750:  BRA    1974E
19752:  MOVWF  FAD
19754:  MOVLW  10
19756:  MOVWF  FE9
19758:  CLRF   1B
1975A:  BTFSC  FF2.7
1975C:  BSF    1B.7
1975E:  BCF    FF2.7
19760:  MOVFF  77D,A19
19764:  MOVFF  77C,A18
19768:  CALL   1192
1976C:  BTFSC  1B.7
1976E:  BSF    FF2.7
19770:  MOVLW  0D
19772:  BTFSS  F9E.4
19774:  BRA    19772
19776:  MOVWF  FAD
19778:  MOVLW  0A
1977A:  BTFSS  F9E.4
1977C:  BRA    1977A
1977E:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
19780:  MOVLW  70
19782:  BTFSS  F9E.4
19784:  BRA    19782
19786:  MOVWF  FAD
19788:  MOVLW  3A
1978A:  BTFSS  F9E.4
1978C:  BRA    1978A
1978E:  MOVWF  FAD
19790:  MOVLW  10
19792:  MOVWF  FE9
19794:  CLRF   1B
19796:  BTFSC  FF2.7
19798:  BSF    1B.7
1979A:  BCF    FF2.7
1979C:  MOVFF  7C2,A19
197A0:  MOVFF  7C1,A18
197A4:  CALL   1192
197A8:  BTFSC  1B.7
197AA:  BSF    FF2.7
197AC:  MOVLW  2F
197AE:  BTFSS  F9E.4
197B0:  BRA    197AE
197B2:  MOVWF  FAD
197B4:  MOVLW  10
197B6:  MOVWF  FE9
197B8:  CLRF   1B
197BA:  BTFSC  FF2.7
197BC:  BSF    1B.7
197BE:  BCF    FF2.7
197C0:  MOVFF  761,A19
197C4:  MOVFF  760,A18
197C8:  CALL   1192
197CC:  BTFSC  1B.7
197CE:  BSF    FF2.7
197D0:  MOVLW  0D
197D2:  BTFSS  F9E.4
197D4:  BRA    197D2
197D6:  MOVWF  FAD
197D8:  MOVLW  0A
197DA:  BTFSS  F9E.4
197DC:  BRA    197DA
197DE:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
197E0:  MOVLW  71
197E2:  BTFSS  F9E.4
197E4:  BRA    197E2
197E6:  MOVWF  FAD
197E8:  MOVLW  3A
197EA:  BTFSS  F9E.4
197EC:  BRA    197EA
197EE:  MOVWF  FAD
197F0:  MOVLW  10
197F2:  MOVWF  FE9
197F4:  CLRF   1B
197F6:  BTFSC  FF2.7
197F8:  BSF    1B.7
197FA:  BCF    FF2.7
197FC:  MOVFF  795,A19
19800:  MOVFF  794,A18
19804:  CALL   1192
19808:  BTFSC  1B.7
1980A:  BSF    FF2.7
1980C:  MOVLW  0D
1980E:  BTFSS  F9E.4
19810:  BRA    1980E
19812:  MOVWF  FAD
19814:  MOVLW  0A
19816:  BTFSS  F9E.4
19818:  BRA    19816
1981A:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
1981C:  MOVLW  73
1981E:  BTFSS  F9E.4
19820:  BRA    1981E
19822:  MOVWF  FAD
19824:  MOVLW  3A
19826:  BTFSS  F9E.4
19828:  BRA    19826
1982A:  MOVWF  FAD
1982C:  MOVLW  10
1982E:  MOVWF  FE9
19830:  CLRF   1B
19832:  BTFSC  FF2.7
19834:  BSF    1B.7
19836:  BCF    FF2.7
19838:  MOVFF  775,A19
1983C:  MOVFF  774,A18
19840:  CALL   1192
19844:  BTFSC  1B.7
19846:  BSF    FF2.7
19848:  MOVLW  0D
1984A:  BTFSS  F9E.4
1984C:  BRA    1984A
1984E:  MOVWF  FAD
19850:  MOVLW  0A
19852:  BTFSS  F9E.4
19854:  BRA    19852
19856:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
19858:  MOVLW  74
1985A:  BTFSS  F9E.4
1985C:  BRA    1985A
1985E:  MOVWF  FAD
19860:  MOVLW  3A
19862:  BTFSS  F9E.4
19864:  BRA    19862
19866:  MOVWF  FAD
19868:  MOVLW  10
1986A:  MOVWF  FE9
1986C:  CLRF   1B
1986E:  BTFSC  FF2.7
19870:  BSF    1B.7
19872:  BCF    FF2.7
19874:  MOVFF  769,A19
19878:  MOVFF  768,A18
1987C:  CALL   1192
19880:  BTFSC  1B.7
19882:  BSF    FF2.7
19884:  MOVLW  0D
19886:  BTFSS  F9E.4
19888:  BRA    19886
1988A:  MOVWF  FAD
1988C:  MOVLW  0A
1988E:  BTFSS  F9E.4
19890:  BRA    1988E
19892:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19894:  MOVLW  01
19896:  MOVLB  7
19898:  ADDWF  x3C,W
1989A:  MOVLB  8
1989C:  MOVWF  x68
1989E:  MOVLW  75
198A0:  BTFSS  F9E.4
198A2:  BRA    198A0
198A4:  MOVWF  FAD
198A6:  MOVLW  3A
198A8:  BTFSS  F9E.4
198AA:  BRA    198A8
198AC:  MOVWF  FAD
198AE:  CLRF   1B
198B0:  BTFSC  FF2.7
198B2:  BSF    1B.7
198B4:  BCF    FF2.7
198B6:  MOVFF  868,A18
198BA:  MOVLW  1B
198BC:  MOVLB  A
198BE:  MOVWF  x19
198C0:  MOVLB  0
198C2:  CALL   0F92
198C6:  BTFSC  1B.7
198C8:  BSF    FF2.7
198CA:  MOVLW  0D
198CC:  BTFSS  F9E.4
198CE:  BRA    198CC
198D0:  MOVWF  FAD
198D2:  MOVLW  0A
198D4:  BTFSS  F9E.4
198D6:  BRA    198D4
198D8:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
198DA:  MOVLW  77
198DC:  BTFSS  F9E.4
198DE:  BRA    198DC
198E0:  MOVWF  FAD
198E2:  MOVLW  3A
198E4:  BTFSS  F9E.4
198E6:  BRA    198E4
198E8:  MOVWF  FAD
198EA:  MOVLW  10
198EC:  MOVWF  FE9
198EE:  CLRF   1B
198F0:  BTFSC  FF2.7
198F2:  BSF    1B.7
198F4:  BCF    FF2.7
198F6:  MOVFF  865,A19
198FA:  MOVFF  864,A18
198FE:  CALL   1192
19902:  BTFSC  1B.7
19904:  BSF    FF2.7
19906:  MOVLW  0D
19908:  BTFSS  F9E.4
1990A:  BRA    19908
1990C:  MOVWF  FAD
1990E:  MOVLW  0A
19910:  BTFSS  F9E.4
19912:  BRA    19910
19914:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
19916:  MOVLW  78
19918:  BTFSS  F9E.4
1991A:  BRA    19918
1991C:  MOVWF  FAD
1991E:  MOVLW  3A
19920:  BTFSS  F9E.4
19922:  BRA    19920
19924:  MOVWF  FAD
19926:  MOVLW  10
19928:  MOVWF  FE9
1992A:  CLRF   1B
1992C:  BTFSC  FF2.7
1992E:  BSF    1B.7
19930:  BCF    FF2.7
19932:  MOVFF  781,A19
19936:  MOVFF  780,A18
1993A:  CALL   1192
1993E:  BTFSC  1B.7
19940:  BSF    FF2.7
19942:  MOVLW  0D
19944:  BTFSS  F9E.4
19946:  BRA    19944
19948:  MOVWF  FAD
1994A:  MOVLW  0A
1994C:  BTFSS  F9E.4
1994E:  BRA    1994C
19950:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
19952:  MOVLW  79
19954:  BTFSS  F9E.4
19956:  BRA    19954
19958:  MOVWF  FAD
1995A:  MOVLW  3A
1995C:  BTFSS  F9E.4
1995E:  BRA    1995C
19960:  MOVWF  FAD
19962:  MOVLW  10
19964:  MOVWF  FE9
19966:  CLRF   1B
19968:  BTFSC  FF2.7
1996A:  BSF    1B.7
1996C:  BCF    FF2.7
1996E:  MOVFF  741,A19
19972:  MOVFF  740,A18
19976:  CALL   1192
1997A:  BTFSC  1B.7
1997C:  BSF    FF2.7
1997E:  MOVLW  0D
19980:  BTFSS  F9E.4
19982:  BRA    19980
19984:  MOVWF  FAD
19986:  MOVLW  0A
19988:  BTFSS  F9E.4
1998A:  BRA    19988
1998C:  MOVWF  FAD
....................    } 
1998E:  BRA    19994
....................    else cmd_arg(); 
19990:  CALL   AF70
19994:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BBB8:  MOVF   44,W
0BBBA:  SUBLW  0D
0BBBC:  BNZ   BBDC
0BBBE:  MOVF   45,W
0BBC0:  SUBLW  07
0BBC2:  BNZ   BBDC
0BBC4:  MOVF   46,F
0BBC6:  BNZ   BBDC
0BBC8:  MOVF   47,F
0BBCA:  BNZ   BBDC
0BBCC:  MOVLW  03
0BBCE:  MOVLB  8
0BBD0:  MOVWF  x67
0BBD2:  MOVLW  11
0BBD4:  MOVWF  x66
0BBD6:  MOVLB  0
0BBD8:  RCALL  B796
0BBDA:  BRA    BBFE
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BBDC:  MOVF   44,W
0BBDE:  SUBLW  98
0BBE0:  BNZ   BBFE
0BBE2:  MOVF   45,W
0BBE4:  SUBLW  07
0BBE6:  BNZ   BBFE
0BBE8:  MOVF   46,F
0BBEA:  BNZ   BBFE
0BBEC:  MOVF   47,F
0BBEE:  BNZ   BBFE
0BBF0:  MOVLW  03
0BBF2:  MOVLB  8
0BBF4:  MOVWF  x67
0BBF6:  MOVLW  11
0BBF8:  MOVWF  x66
0BBFA:  MOVLB  0
0BBFC:  RCALL  B910
0BBFE:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0AFCA:  MOVF   44,W
0AFCC:  MOVWF  00
0AFCE:  MOVFF  45,03
0AFD2:  MOVLW  15
0AFD4:  SUBWF  45,W
0AFD6:  BNZ   AFDE
0AFD8:  MOVLW  95
0AFDA:  SUBWF  00,W
0AFDC:  BZ    B004
0AFDE:  MOVLW  15
0AFE0:  SUBWF  03,W
0AFE2:  BNZ   AFEA
0AFE4:  MOVLW  96
0AFE6:  SUBWF  00,W
0AFE8:  BZ    B036
0AFEA:  MOVLW  15
0AFEC:  SUBWF  03,W
0AFEE:  BNZ   AFF6
0AFF0:  MOVLW  97
0AFF2:  SUBWF  00,W
0AFF4:  BZ    B06C
0AFF6:  MOVLW  15
0AFF8:  SUBWF  03,W
0AFFA:  BNZ   B002
0AFFC:  MOVLW  98
0AFFE:  SUBWF  00,W
0B000:  BZ    B0A2
0B002:  BRA    B0D6
....................       case 5525 : nv_product = ECO; 
0B004:  CLRF   30
0B006:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0B008:  MOVLW  1E
0B00A:  MOVLB  8
0B00C:  MOVWF  xCB
0B00E:  CLRF   xCD
0B010:  CLRF   xCC
0B012:  MOVLB  0
0B014:  CALL   4F56
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B018:  MOVLW  01
0B01A:  MOVWF  1E
0B01C:  MOVLW  A3
0B01E:  MOVWF  1D
0B020:  MOVLW  1E
0B022:  MOVWF  FF6
0B024:  MOVLW  27
0B026:  MOVWF  FF7
0B028:  MOVLW  00
0B02A:  MOVWF  FF8
0B02C:  CALL   5040
....................                   record_event(); 
0B030:  CALL   841A
....................          break; 
0B034:  BRA    B0D6
....................       case 5526 : nv_product = WMS4; 
0B036:  CLRF   30
0B038:  MOVLW  01
0B03A:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B03C:  MOVLW  1E
0B03E:  MOVLB  8
0B040:  MOVWF  xCB
0B042:  CLRF   xCD
0B044:  MOVLW  01
0B046:  MOVWF  xCC
0B048:  MOVLB  0
0B04A:  CALL   4F56
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B04E:  MOVLW  01
0B050:  MOVWF  1E
0B052:  MOVLW  A3
0B054:  MOVWF  1D
0B056:  MOVLW  2E
0B058:  MOVWF  FF6
0B05A:  MOVLW  27
0B05C:  MOVWF  FF7
0B05E:  MOVLW  00
0B060:  MOVWF  FF8
0B062:  CALL   5040
....................                   record_event();                   
0B066:  CALL   841A
....................          break;    
0B06A:  BRA    B0D6
....................       case 5527 : nv_product = AWS; 
0B06C:  CLRF   30
0B06E:  MOVLW  02
0B070:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B072:  MOVLW  1E
0B074:  MOVLB  8
0B076:  MOVWF  xCB
0B078:  CLRF   xCD
0B07A:  MOVLW  02
0B07C:  MOVWF  xCC
0B07E:  MOVLB  0
0B080:  CALL   4F56
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B084:  MOVLW  01
0B086:  MOVWF  1E
0B088:  MOVLW  A3
0B08A:  MOVWF  1D
0B08C:  MOVLW  44
0B08E:  MOVWF  FF6
0B090:  MOVLW  27
0B092:  MOVWF  FF7
0B094:  MOVLW  00
0B096:  MOVWF  FF8
0B098:  CALL   5040
....................                   record_event();                   
0B09C:  CALL   841A
....................          break;   
0B0A0:  BRA    B0D6
....................       case 5528 : nv_product = WMS2; 
0B0A2:  CLRF   30
0B0A4:  MOVLW  03
0B0A6:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B0A8:  MOVLW  1E
0B0AA:  MOVLB  8
0B0AC:  MOVWF  xCB
0B0AE:  CLRF   xCD
0B0B0:  MOVLW  03
0B0B2:  MOVWF  xCC
0B0B4:  MOVLB  0
0B0B6:  CALL   4F56
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B0BA:  MOVLW  01
0B0BC:  MOVWF  1E
0B0BE:  MOVLW  A3
0B0C0:  MOVWF  1D
0B0C2:  MOVLW  54
0B0C4:  MOVWF  FF6
0B0C6:  MOVLW  27
0B0C8:  MOVWF  FF7
0B0CA:  MOVLW  00
0B0CC:  MOVWF  FF8
0B0CE:  CALL   5040
....................                   record_event();                   
0B0D2:  CALL   841A
....................          break;            
....................    } 
0B0D6:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0AF8E:  MOVF   44,W
0AF90:  MOVWF  00
0AF92:  MOVF   45,W
0AF94:  MOVWF  03
0AF96:  BNZ   AF9C
0AF98:  MOVF   00,F
0AF9A:  BZ    AFB2
0AF9C:  MOVF   03,W
0AF9E:  BNZ   AFA6
0AFA0:  MOVLW  01
0AFA2:  SUBWF  00,W
0AFA4:  BZ    AFB8
0AFA6:  MOVF   03,W
0AFA8:  BNZ   AFB0
0AFAA:  MOVLW  02
0AFAC:  SUBWF  00,W
0AFAE:  BZ    AFBE
0AFB0:  BRA    AFC4
....................       case 0 : kill_wd(); 
0AFB2:  CALL   307E
....................          break; 
0AFB6:  BRA    AFC6
....................       case 1 : start_heartbeat(); 
0AFB8:  CALL   2888
....................          break; 
0AFBC:  BRA    AFC6
....................       case 2 : suspend_heartbeat(); 
0AFBE:  CALL   54D2
....................          break; 
0AFC2:  BRA    AFC6
....................       default : cmd_arg(); 
0AFC4:  RCALL  AF70
....................          break; 
....................    } 
0AFC6:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0AECE:  MOVF   44,W
0AED0:  MOVWF  00
0AED2:  MOVF   45,W
0AED4:  MOVWF  03
0AED6:  BNZ   AEDC
0AED8:  MOVF   00,F
0AEDA:  BZ    AEEA
0AEDC:  MOVLW  15
0AEDE:  SUBWF  03,W
0AEE0:  BNZ   AEE8
0AEE2:  MOVLW  95
0AEE4:  SUBWF  00,W
0AEE6:  BZ    AF48
0AEE8:  BRA    AF6C
....................       case 0:     signon(); 
0AEEA:  CALL   30D0
....................                   fprintf(COM_A, __DATE__); 
0AEEE:  MOVLW  6A
0AEF0:  MOVWF  FF6
0AEF2:  MOVLW  27
0AEF4:  MOVWF  FF7
0AEF6:  MOVLW  00
0AEF8:  MOVWF  FF8
0AEFA:  CLRF   1B
0AEFC:  BTFSC  FF2.7
0AEFE:  BSF    1B.7
0AF00:  BCF    FF2.7
0AF02:  CALL   0E3A
0AF06:  BTFSC  1B.7
0AF08:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0AF0A:  MOVLW  0D
0AF0C:  BTFSS  F9E.4
0AF0E:  BRA    AF0C
0AF10:  MOVWF  FAD
0AF12:  MOVLW  0A
0AF14:  BTFSS  F9E.4
0AF16:  BRA    AF14
0AF18:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0AF1A:  MOVLW  74
0AF1C:  MOVWF  FF6
0AF1E:  MOVLW  27
0AF20:  MOVWF  FF7
0AF22:  MOVLW  00
0AF24:  MOVWF  FF8
0AF26:  CLRF   1B
0AF28:  BTFSC  FF2.7
0AF2A:  BSF    1B.7
0AF2C:  BCF    FF2.7
0AF2E:  CALL   0E3A
0AF32:  BTFSC  1B.7
0AF34:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0AF36:  MOVLW  0D
0AF38:  BTFSS  F9E.4
0AF3A:  BRA    AF38
0AF3C:  MOVWF  FAD
0AF3E:  MOVLW  0A
0AF40:  BTFSS  F9E.4
0AF42:  BRA    AF40
0AF44:  MOVWF  FAD
....................          break; 
0AF46:  BRA    AF6C
....................       case 5525 : kill_wd(); 
0AF48:  CALL   307E
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0AF4C:  MOVLW  7E
0AF4E:  MOVWF  FF6
0AF50:  MOVLW  27
0AF52:  MOVWF  FF7
0AF54:  MOVLW  00
0AF56:  MOVWF  FF8
0AF58:  CLRF   1B
0AF5A:  BTFSC  FF2.7
0AF5C:  BSF    1B.7
0AF5E:  BCF    FF2.7
0AF60:  CALL   0E3A
0AF64:  BTFSC  1B.7
0AF66:  BSF    FF2.7
....................                   load_program(); 
0AF68:  CALL   1F800
....................          break; 
....................    } 
0AF6C:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
18644:  MOVF   44,W
18646:  MOVWF  00
18648:  MOVF   45,W
1864A:  MOVWF  03
1864C:  BNZ   18652
1864E:  MOVF   00,F
18650:  BZ    1865E
18652:  MOVF   03,W
18654:  BNZ   1865C
18656:  MOVLW  01
18658:  SUBWF  00,W
1865A:  BZ    18662
1865C:  BRA    18666
....................       case 0 : cmd_set=0;  // user 
1865E:  CLRF   4D
....................          break; 
18660:  BRA    18666
....................       case 1 : cmd_set=1;  // full 
18662:  MOVLW  01
18664:  MOVWF  4D
....................          break; 
....................    } 
18666:  GOTO   1AD3A (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1ABA4:  CALL   ADAC
....................     
....................    switch (cmd) 
1ABA8:  MOVLW  23
1ABAA:  SUBWF  43,W
1ABAC:  ADDLW  A8
1ABAE:  BTFSC  FD8.0
1ABB0:  BRA    1AD3A
1ABB2:  ADDLW  58
1ABB4:  GOTO   1AD3E
....................    { 
....................       case '&': commandFW(); 
1ABB8:  GOTO   AECE
....................          break; 
1ABBC:  BRA    1AD3A
....................       case '#': command_hash(); 
1ABBE:  GOTO   AF8E
....................          break;          
1ABC2:  BRA    1AD3A
....................       case '%': command_prod(); 
1ABC4:  GOTO   AFCA
....................          break; 
1ABC8:  BRA    1AD3A
....................       case '*': command_star(); 
1ABCA:  GOTO   BBB8
....................          break;       
1ABCE:  BRA    1AD3A
....................       // standard commands 
....................       case '/': command_addr(); 
1ABD0:  GOTO   BC02
....................          break; 
1ABD4:  BRA    1AD3A
....................       case 'A': commandA(); 
1ABD6:  GOTO   BD9C
....................          break; 
1ABDA:  BRA    1AD3A
....................       case 'B': commandB(); 
1ABDC:  GOTO   BF08
....................          break; 
1ABE0:  BRA    1AD3A
....................       case 'C': commandC(); 
1ABE2:  GOTO   D9C0
....................          break; 
1ABE6:  BRA    1AD3A
....................       case 'D': commandD(); 
1ABE8:  GOTO   D9FE
....................          break; 
1ABEC:  BRA    1AD3A
....................       case 'E': commandE(); 
1ABEE:  GOTO   DA98
....................          break;          
1ABF2:  BRA    1AD3A
....................       case 'F': commandF(); 
1ABF4:  GOTO   DD96
....................          break;          
1ABF8:  BRA    1AD3A
....................       case 'G': commandG(); 
1ABFA:  GOTO   DE00
....................          break; 
1ABFE:  BRA    1AD3A
....................       case 'H': commandH(); 
1AC00:  GOTO   EF5E
....................          break; 
1AC04:  BRA    1AD3A
....................       case 'I': commandI(); 
1AC06:  GOTO   EF9E
....................          break;    
1AC0A:  BRA    1AD3A
....................       case 'J': commandJ(); 
1AC0C:  GOTO   EFEA
....................          break;      
1AC10:  BRA    1AD3A
....................       case 'K': commandK(); 
1AC12:  GOTO   F244
....................          break;    
1AC16:  BRA    1AD3A
....................       case 'L': commandL(); 
1AC18:  GOTO   101D4
....................          break;             
1AC1C:  BRA    1AD3A
....................       case 'M': commandM(FALSE); 
1AC1E:  MOVLB  8
1AC20:  CLRF   x62
1AC22:  MOVLB  0
1AC24:  CALL   168DA
....................          break;   
1AC28:  BRA    1AD3A
....................       case 'N': commandN(); 
1AC2A:  GOTO   169F4
....................          break;          
1AC2E:  BRA    1AD3A
....................       case 'O': commandO(); 
1AC30:  GOTO   16B9C
....................          break;    
1AC34:  BRA    1AD3A
....................       case 'P': commandP(); 
1AC36:  GOTO   16DA0
....................          break;  
1AC3A:  BRA    1AD3A
....................       case 'Q': commandQ(); 
1AC3C:  GOTO   16E5E
....................          break;              
1AC40:  BRA    1AD3A
....................       case 'R': commandR(); 
1AC42:  GOTO   170F4
....................          break;    
1AC46:  BRA    1AD3A
....................       case 'S': commandS(); 
1AC48:  GOTO   17220
....................          break;  
1AC4C:  BRA    1AD3A
....................       case 'T': commandT(); 
1AC4E:  GOTO   177BE
....................          break;            
1AC52:  BRA    1AD3A
....................       case 'U': commandU(); 
1AC54:  GOTO   181C0
....................          break;           
1AC58:  BRA    1AD3A
....................       case 'V': commandV(); 
1AC5A:  GOTO   18318
....................          break; 
1AC5E:  BRA    1AD3A
....................       case 'W': commandW(); 
1AC60:  GOTO   1848C
....................          break; 
1AC64:  BRA    1AD3A
....................       case 'X': commandX(); 
1AC66:  GOTO   184B0
....................          break; 
1AC6A:  BRA    1AD3A
....................       case 'Y': commandY(); 
1AC6C:  GOTO   18518
....................          break;  
1AC70:  BRA    1AD3A
....................       case 'Z': commandZ(); 
1AC72:  CALL   18620
....................          break;    
1AC76:  BRA    1AD3A
....................       // stepper 
....................       case '^': command_set(); 
1AC78:  GOTO   18644
....................          break;       
1AC7C:  BRA    1AD3A
....................       case '+': if(m_fixed==1) motor=1; 
1AC7E:  MOVLB  7
1AC80:  DECFSZ x3D,W
1AC82:  BRA    1AC88
1AC84:  MOVLW  01
1AC86:  MOVWF  x3C
....................                 command_move(0,0,1); 
1AC88:  MOVLB  8
1AC8A:  CLRF   x62
1AC8C:  CLRF   x63
1AC8E:  MOVLW  01
1AC90:  MOVWF  x64
1AC92:  MOVLB  0
1AC94:  CALL   16BC0
....................          break; 
1AC98:  BRA    1AD3A
....................       case '-': if(m_fixed==1) motor=1; 
1AC9A:  MOVLB  7
1AC9C:  DECFSZ x3D,W
1AC9E:  BRA    1ACA4
1ACA0:  MOVLW  01
1ACA2:  MOVWF  x3C
....................                 command_move(0,1,1); 
1ACA4:  MOVLB  8
1ACA6:  CLRF   x62
1ACA8:  MOVLW  01
1ACAA:  MOVWF  x63
1ACAC:  MOVWF  x64
1ACAE:  MOVLB  0
1ACB0:  CALL   16BC0
....................          break; 
1ACB4:  BRA    1AD3A
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1ACB6:  GOTO   18770
....................          break;     
1ACBA:  BRA    1AD3A
....................       case 'b': command_b(); 
1ACBC:  GOTO   1878C
....................          break; 
1ACC0:  BRA    1AD3A
....................       case 'c': command_c(); 
1ACC2:  GOTO   18826
....................          break; 
1ACC6:  BRA    1AD3A
....................       case 'd': command_d(); 
1ACC8:  GOTO   1886E
....................          break;          
1ACCC:  BRA    1AD3A
....................       case 'e': command_e(); 
1ACCE:  GOTO   18904
....................          break;       
1ACD2:  BRA    1AD3A
....................       case 'f': command_f(); 
1ACD4:  GOTO   1899E
....................          break; 
1ACD8:  BRA    1AD3A
....................       case 'g': command_g(); 
1ACDA:  GOTO   189BE
....................          break;          
1ACDE:  BRA    1AD3A
....................       case 'h': command_h(); 
1ACE0:  GOTO   18A58
....................          break; 
1ACE4:  BRA    1AD3A
....................       case 'i': command_i(); 
1ACE6:  GOTO   18B2C
....................          break;   
1ACEA:  BRA    1AD3A
....................       case 'j': command_j(); 
1ACEC:  GOTO   18C08
....................          break;           
1ACF0:  BRA    1AD3A
....................       case 'k': command_k(); 
1ACF2:  GOTO   18CA2
....................          break;          
1ACF6:  BRA    1AD3A
....................       case 'l': step_var_list(); 
1ACF8:  GOTO   18D38
....................          break;          
1ACFC:  BRA    1AD3A
....................       case 'm': command_m(); 
1ACFE:  GOTO   19998
....................          break;    
1AD02:  BRA    1AD3A
....................       case 'n': command_n(); 
1AD04:  GOTO   19A2E
....................          break; 
1AD08:  BRA    1AD3A
....................       case 'o': command_o(); 
1AD0A:  GOTO   19AC4
....................          break;    
1AD0E:  BRA    1AD3A
....................       case 'p': command_p(); 
1AD10:  GOTO   19B5E
....................          break;   
1AD14:  BRA    1AD3A
....................       case 'q': command_q(); 
1AD16:  GOTO   19BF8
....................          break; 
1AD1A:  BRA    1AD3A
....................       case 'r': command_r(); 
1AD1C:  BRA    1A6F4
....................          break;    
1AD1E:  BRA    1AD3A
....................       case 's': command_s(); 
1AD20:  BRA    1A74E
....................          break;           
1AD22:  BRA    1AD3A
....................       case 't': command_t(); 
1AD24:  BRA    1A85C
....................          break;          
1AD26:  BRA    1AD3A
....................       case 'u': command_u(); 
1AD28:  BRA    1A8F2
....................          break;           
1AD2A:  BRA    1AD3A
....................       case 'w': command_w(); 
1AD2C:  BRA    1A92A
....................          break; 
1AD2E:  BRA    1AD3A
....................       case 'x': command_x(); 
1AD30:  BRA    1A9FE
....................          break;    
1AD32:  BRA    1AD3A
....................       case 'y': command_y(); 
1AD34:  BRA    1AA98
....................          break;  
1AD36:  BRA    1AD3A
....................       case 'z': command_z(); 
1AD38:  BRA    1AB2E
....................          break;           
....................    } 
1AD3A:  GOTO   1AEC2 (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... #define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c" 
.................... #define BYTE_TO_BINARY(byte)  \ 
....................   (byte & 0x80 ? '1' : '0'), \ 
....................   (byte & 0x40 ? '1' : '0'), \ 
....................   (byte & 0x20 ? '1' : '0'), \ 
....................   (byte & 0x10 ? '1' : '0'), \ 
....................   (byte & 0x08 ? '1' : '0'), \ 
....................   (byte & 0x04 ? '1' : '0'), \ 
....................   (byte & 0x02 ? '1' : '0'), \ 
....................   (byte & 0x01 ? '1' : '0')  
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................  
....................   number = 0; 
*
1AE0E:  MOVLB  8
1AE10:  CLRF   x60
....................   arg = 0; 
1AE12:  CLRF   47
1AE14:  CLRF   46
1AE16:  CLRF   45
1AE18:  CLRF   44
....................   good_arg = FALSE; 
1AE1A:  CLRF   x61
....................    
....................   while (number != CARRIAGE_RET) 
1AE1C:  MOVF   x60,W
1AE1E:  SUBLW  0D
1AE20:  BZ    1AEF4
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
1AE22:  MOVLB  0
1AE24:  CALL   0E24
1AE28:  MOVFF  01,860
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
1AE2C:  MOVLB  8
1AE2E:  MOVF   x60,W
1AE30:  SUBLW  0D
1AE32:  BZ    1AE3E
1AE34:  MOVF   x60,W
1AE36:  MOVLB  0
1AE38:  CALL   ADB4
1AE3C:  MOVLB  8
....................      if (number > 47 && number < 58) 
1AE3E:  MOVF   x60,W
1AE40:  SUBLW  2F
1AE42:  BC    1AE94
1AE44:  MOVF   x60,W
1AE46:  SUBLW  39
1AE48:  BNC   1AE94
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
1AE4A:  MOVLW  30
1AE4C:  SUBWF  x60,F
....................         arg = arg * 10;                    // increase significance 
1AE4E:  MOVFF  47,9D6
1AE52:  MOVFF  46,9D5
1AE56:  MOVFF  45,9D4
1AE5A:  MOVFF  44,9D3
1AE5E:  MOVLB  9
1AE60:  CLRF   xDA
1AE62:  CLRF   xD9
1AE64:  CLRF   xD8
1AE66:  MOVLW  0A
1AE68:  MOVWF  xD7
1AE6A:  MOVLB  0
1AE6C:  CALL   477C
1AE70:  MOVFF  03,47
1AE74:  MOVFF  02,46
1AE78:  MOVFF  01,45
1AE7C:  MOVFF  00,44
....................         arg = arg + number;                // for each number 
1AE80:  MOVLB  8
1AE82:  MOVF   x60,W
1AE84:  ADDWF  44,F
1AE86:  MOVLW  00
1AE88:  ADDWFC 45,F
1AE8A:  ADDWFC 46,F
1AE8C:  ADDWFC 47,F
....................         good_arg = TRUE; 
1AE8E:  MOVLW  01
1AE90:  MOVWF  x61
....................      } 
1AE92:  BRA    1AEEC
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
1AE94:  MOVF   x60,W
1AE96:  SUBLW  0D
1AE98:  BNZ   1AEC6
1AE9A:  DECFSZ x61,W
1AE9C:  BRA    1AEC6
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
1AE9E:  MOVLW  A4
1AEA0:  MOVWF  FF6
1AEA2:  MOVLW  27
1AEA4:  MOVWF  FF7
1AEA6:  MOVLW  00
1AEA8:  MOVWF  FF8
1AEAA:  MOVLB  0
1AEAC:  CALL   AD82
1AEB0:  MOVLW  0D
1AEB2:  BTFSS  F9E.4
1AEB4:  BRA    1AEB2
1AEB6:  MOVWF  FAD
1AEB8:  MOVLW  0A
1AEBA:  BTFSS  F9E.4
1AEBC:  BRA    1AEBA
1AEBE:  MOVWF  FAD
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
1AEC0:  BRA    1ABA4
....................      } 
1AEC2:  BRA    1AEEA
1AEC4:  MOVLB  8
....................      else 
....................      { 
....................         good_arg = FALSE; 
1AEC6:  CLRF   x61
....................         fputs("@ARG ", COM_A);             // bad input 
1AEC8:  MOVLW  AA
1AECA:  MOVWF  FF6
1AECC:  MOVLW  27
1AECE:  MOVWF  FF7
1AED0:  MOVLW  00
1AED2:  MOVWF  FF8
1AED4:  MOVLB  0
1AED6:  CALL   AD82
1AEDA:  MOVLW  0D
1AEDC:  BTFSS  F9E.4
1AEDE:  BRA    1AEDC
1AEE0:  MOVWF  FAD
1AEE2:  MOVLW  0A
1AEE4:  BTFSS  F9E.4
1AEE6:  BRA    1AEE4
1AEE8:  MOVWF  FAD
1AEEA:  MOVLB  8
....................      } 
....................      if (good_arg == FALSE) break; 
1AEEC:  MOVF   x61,F
1AEEE:  BTFSC  FD8.2
1AEF0:  BRA    1AEF4
1AEF2:  BRA    1AE1C
....................   } 
1AEF4:  MOVLB  0
1AEF6:  GOTO   1AF2A (RETURN)
.................... } 
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0ADFE:  MOVF   4D,F
0AE00:  BNZ   AE52
0AE02:  MOVLB  8
0AE04:  MOVF   x60,W
0AE06:  SUBLW  24
0AE08:  BC    AE10
0AE0A:  MOVF   x60,W
0AE0C:  SUBLW  26
0AE0E:  BC    AE4A
0AE10:  MOVF   x60,W
0AE12:  SUBLW  29
0AE14:  BC    AE1C
0AE16:  MOVF   x60,W
0AE18:  SUBLW  2B
0AE1A:  BC    AE4A
0AE1C:  MOVF   x60,W
0AE1E:  SUBLW  2D
0AE20:  BZ    AE4A
0AE22:  MOVF   x60,W
0AE24:  SUBLW  2F
0AE26:  BZ    AE4A
0AE28:  MOVF   x60,W
0AE2A:  SUBLW  40
0AE2C:  BC    AE34
0AE2E:  MOVF   x60,W
0AE30:  SUBLW  42
0AE32:  BC    AE4A
0AE34:  MOVF   x60,W
0AE36:  SUBLW  43
0AE38:  BC    AE40
0AE3A:  MOVF   x60,W
0AE3C:  SUBLW  5A
0AE3E:  BC    AE4A
0AE40:  MOVF   x60,W
0AE42:  SUBLW  5E
0AE44:  BZ    AE4A
0AE46:  MOVLW  00
0AE48:  BRA    AE4C
0AE4A:  MOVLW  01
0AE4C:  MOVWF  x61
0AE4E:  BRA    AEC0
0AE50:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0AE52:  DECFSZ 4D,W
0AE54:  BRA    AEC2
0AE56:  MOVLB  8
0AE58:  MOVF   x60,W
0AE5A:  SUBLW  23
0AE5C:  BZ    AEBC
0AE5E:  MOVF   x60,W
0AE60:  SUBLW  24
0AE62:  BC    AE6A
0AE64:  MOVF   x60,W
0AE66:  SUBLW  26
0AE68:  BC    AEBC
0AE6A:  MOVF   x60,W
0AE6C:  SUBLW  29
0AE6E:  BC    AE76
0AE70:  MOVF   x60,W
0AE72:  SUBLW  2B
0AE74:  BC    AEBC
0AE76:  MOVF   x60,W
0AE78:  SUBLW  2D
0AE7A:  BZ    AEBC
0AE7C:  MOVF   x60,W
0AE7E:  SUBLW  2F
0AE80:  BZ    AEBC
0AE82:  MOVF   x60,W
0AE84:  SUBLW  40
0AE86:  BC    AE8E
0AE88:  MOVF   x60,W
0AE8A:  SUBLW  42
0AE8C:  BC    AEBC
0AE8E:  MOVF   x60,W
0AE90:  SUBLW  43
0AE92:  BC    AE9A
0AE94:  MOVF   x60,W
0AE96:  SUBLW  5A
0AE98:  BC    AEBC
0AE9A:  MOVF   x60,W
0AE9C:  SUBLW  5E
0AE9E:  BZ    AEBC
0AEA0:  MOVF   x60,W
0AEA2:  SUBLW  60
0AEA4:  BC    AEAC
0AEA6:  MOVF   x60,W
0AEA8:  SUBLW  75
0AEAA:  BC    AEBC
0AEAC:  MOVF   x60,W
0AEAE:  SUBLW  76
0AEB0:  BC    AEB8
0AEB2:  MOVF   x60,W
0AEB4:  SUBLW  7A
0AEB6:  BC    AEBC
0AEB8:  MOVLW  00
0AEBA:  BRA    AEBE
0AEBC:  MOVLW  01
0AEBE:  MOVWF  x61
0AEC0:  MOVLB  0
....................    return(valid); 
0AEC2:  MOVLB  8
0AEC4:  MOVFF  861,01
0AEC8:  MOVLB  0
0AECA:  GOTO   1AF02 (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
*
1AEFA:  MOVFF  43,860
1AEFE:  GOTO   ADFE
1AF02:  MOVF   01,F
1AF04:  BZ    1AF0A
1AF06:  BRA    1AE0E
1AF08:  BRA    1AF2A
....................    else fputs("@INV", COM_A); 
1AF0A:  MOVLW  B0
1AF0C:  MOVWF  FF6
1AF0E:  MOVLW  27
1AF10:  MOVWF  FF7
1AF12:  MOVLW  00
1AF14:  MOVWF  FF8
1AF16:  CALL   AD82
1AF1A:  MOVLW  0D
1AF1C:  BTFSS  F9E.4
1AF1E:  BRA    1AF1C
1AF20:  MOVWF  FAD
1AF22:  MOVLW  0A
1AF24:  BTFSS  F9E.4
1AF26:  BRA    1AF24
1AF28:  MOVWF  FAD
1AF2A:  GOTO   1AFAC (RETURN)
.................... } 
....................  
.................... void command_prompt() 
.................... { 
....................    //disable_interrupts(INT_EXT); 
....................     
....................    nv_cmd_mode = TRUE; 
1AF2E:  CLRF   32
1AF30:  MOVLW  01
1AF32:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1AF34:  MOVLW  02
1AF36:  MOVLB  8
1AF38:  MOVWF  x66
1AF3A:  MOVFF  31,867
1AF3E:  MOVLB  0
1AF40:  CALL   339A
....................     
....................    fputs("@CMD", COM_A); 
1AF44:  MOVLW  B6
1AF46:  MOVWF  FF6
1AF48:  MOVLW  27
1AF4A:  MOVWF  FF7
1AF4C:  MOVLW  00
1AF4E:  MOVWF  FF8
1AF50:  CALL   AD82
1AF54:  MOVLW  0D
1AF56:  BTFSS  F9E.4
1AF58:  BRA    1AF56
1AF5A:  MOVWF  FAD
1AF5C:  MOVLW  0A
1AF5E:  BTFSS  F9E.4
1AF60:  BRA    1AF5E
1AF62:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1AF64:  MOVLW  01
1AF66:  MOVWF  1E
1AF68:  MOVLW  A3
1AF6A:  MOVWF  1D
1AF6C:  MOVLW  BC
1AF6E:  MOVWF  FF6
1AF70:  MOVLW  27
1AF72:  MOVWF  FF7
1AF74:  MOVLW  00
1AF76:  MOVWF  FF8
1AF78:  CALL   5040
....................    record_event(); 
1AF7C:  CALL   841A
....................     
....................    busy_clear(); 
1AF80:  CALL   ADAC
....................     
....................    cmd_set=0; // user 
1AF84:  CLRF   4D
....................     
....................    do { 
....................       fputc('>',COM_A); 
1AF86:  MOVLW  3E
1AF88:  CALL   ADB4
....................       cmd=fgetc(COM_A); 
1AF8C:  CALL   0E24
1AF90:  MOVFF  01,43
....................       if (com_echo == TRUE) 
1AF94:  DECFSZ 48,W
1AF96:  BRA    1AF9E
....................       { 
....................          fputc(cmd,COM_A); 
1AF98:  MOVF   43,W
1AF9A:  CALL   ADB4
....................       } 
....................       if (cmd == '?') msg_busy(); 
1AF9E:  MOVF   43,W
1AFA0:  SUBLW  3F
1AFA2:  BNZ   1AFAA
1AFA4:  GOTO   ADBC
1AFA8:  BRA    1AFAC
....................       else proc_cmd(); 
1AFAA:  BRA    1AEFA
....................       //restart_wdt(); 
....................    } while(nv_cmd_mode == TRUE); 
1AFAC:  DECFSZ 31,W
1AFAE:  BRA    1AFB4
1AFB0:  MOVF   32,F
1AFB2:  BZ    1AF86
1AFB4:  RETURN 0
.................... } 
....................  
....................  
.................... void main() 
1AFB6:  CLRF   FF8
1AFB8:  BCF    FD0.7
1AFBA:  BSF    07.7
1AFBC:  MOVLW  70
1AFBE:  MOVWF  FD3
1AFC0:  MOVLW  40
1AFC2:  MOVWF  F9B
1AFC4:  CLRF   F64
1AFC6:  CLRF   1C
1AFC8:  BSF    F65.3
1AFCA:  MOVWF  FAF
1AFCC:  MOVLW  03
1AFCE:  MOVWF  FD4
1AFD0:  MOVLW  A6
1AFD2:  MOVWF  FAC
1AFD4:  MOVLW  90
1AFD6:  MOVWF  FAB
1AFD8:  MOVLB  F
1AFDA:  BSF    x20.3
1AFDC:  MOVLW  82
1AFDE:  MOVWF  x1E
1AFE0:  MOVLW  06
1AFE2:  MOVWF  x1F
1AFE4:  MOVLW  A6
1AFE6:  MOVWF  x21
1AFE8:  MOVLW  90
1AFEA:  MOVWF  x22
1AFEC:  BSF    F65.3
1AFEE:  MOVLW  40
1AFF0:  MOVWF  FAF
1AFF2:  MOVLW  03
1AFF4:  MOVWF  FD4
1AFF6:  MOVLW  A6
1AFF8:  MOVWF  FAC
1AFFA:  MOVLW  90
1AFFC:  MOVWF  FAB
1AFFE:  CLRF   1E
1B000:  CLRF   1D
1B002:  CLRF   42
1B004:  MOVLW  01
1B006:  MOVWF  41
1B008:  MOVWF  48
1B00A:  BCF    49.0
1B00C:  BCF    49.1
1B00E:  BCF    49.2
1B010:  MOVLB  0
1B012:  CLRF   x62
1B014:  MOVLB  2
1B016:  MOVWF  xD5
1B018:  MOVLB  3
1B01A:  CLRF   x37
1B01C:  MOVLB  4
1B01E:  CLRF   xE3
1B020:  MOVWF  xE9
1B022:  MOVLW  04
1B024:  MOVLB  7
1B026:  MOVWF  x0F
1B028:  MOVLW  EA
1B02A:  MOVWF  x0E
1B02C:  CLRF   xC9
1B02E:  MOVLB  8
1B030:  CLRF   x54
1B032:  CLRF   x53
1B034:  CLRF   x58
1B036:  CLRF   x57
1B038:  CLRF   x56
1B03A:  CLRF   x55
1B03C:  CLRF   x5C
1B03E:  CLRF   x5B
1B040:  CLRF   x5A
1B042:  CLRF   x59
1B044:  MOVLW  00
1B046:  MOVLB  F
1B048:  MOVWF  x23
1B04A:  MOVWF  x24
1B04C:  MOVWF  x25
1B04E:  BCF    FC1.3
1B050:  BCF    FC1.4
1B052:  BCF    FC1.5
1B054:  CLRF   x2E
1B056:  CLRF   x2F
1B058:  CLRF   x54
1B05A:  BRA    1B11C
1B05C:  DATA 44,02
1B05E:  DATA D9,20
1B060:  DATA 64,72
1B062:  DATA 61,77
1B064:  DATA 5F,61
1B066:  DATA 6C,6C
1B068:  DATA 2E,63
1B06A:  DATA 73,76
1B06C:  DATA 00,20
1B06E:  DATA 64,72
1B070:  DATA 61,77
1B072:  DATA 5F,6E
1B074:  DATA 65,77
1B076:  DATA 2E,63
1B078:  DATA 73,76
1B07A:  DATA 00,20
1B07C:  DATA 64,72
1B07E:  DATA 65,6C
1B080:  DATA 5F,61
1B082:  DATA 6C,6C
1B084:  DATA 2E,63
1B086:  DATA 73,76
1B088:  DATA 00,20
1B08A:  DATA 64,72
1B08C:  DATA 65,6C
1B08E:  DATA 5F,6E
1B090:  DATA 65,77
1B092:  DATA 2E,63
1B094:  DATA 73,76
1B096:  DATA 00,20
1B098:  DATA 65,76
1B09A:  DATA 65,6E
1B09C:  DATA 74,73
1B09E:  DATA 2E,74
1B0A0:  DATA 78,74
1B0A2:  DATA 00,02
1B0A4:  DATA 03,35
1B0A6:  DATA 2C,00
1B0A8:  DATA 02,04
1B0AA:  DATA D4,00
1B0AC:  DATA 00,10
1B0AE:  DATA 07,10
1B0B0:  DATA 46,41
1B0B2:  DATA 54,31
1B0B4:  DATA 32,46
1B0B6:  DATA 41,54
1B0B8:  DATA 31,36
1B0BA:  DATA 46,41
1B0BC:  DATA 54,33
1B0BE:  DATA 32,00
1B0C0:  DATA 57,07
1B0C2:  DATA CA,0D
1B0C4:  DATA 0A,00
1B0C6:  DATA 00,03
1B0C8:  DATA 00,0F
1B0CA:  DATA 00,1B
1B0CC:  DATA 00,27
1B0CE:  DATA 00,33
1B0D0:  DATA 00,3F
1B0D2:  DATA 00,4B
1B0D4:  DATA 00,57
1B0D6:  DATA 00,63
1B0D8:  DATA 00,6F
1B0DA:  DATA 00,7B
1B0DC:  DATA 00,87
1B0DE:  DATA 00,93
1B0E0:  DATA 00,9F
1B0E2:  DATA 00,AB
1B0E4:  DATA 00,B7
1B0E6:  DATA 00,C3
1B0E8:  DATA 48,B1
1B0EA:  DATA 70,D4
1B0EC:  DATA 98,F7
1B0EE:  DATA C0,1A
1B0F0:  DATA 00,CF
1B0F2:  DATA 28,F2
1B0F4:  DATA 50,15
1B0F6:  DATA 78,38
1B0F8:  DATA A0,5B
1B0FA:  DATA C8,7E
1B0FC:  DATA F0,A1
1B0FE:  DATA 18,C5
1B100:  DATA 40,E8
1B102:  DATA 68,0B
1B104:  DATA 90,2E
1B106:  DATA B8,51
1B108:  DATA E0,74
1B10A:  DATA 08,98
1B10C:  DATA 30,BB
1B10E:  DATA 58,DE
1B110:  DATA 80,01
1B112:  DATA A8,24
1B114:  DATA D0,47
1B116:  DATA F8,6A
1B118:  DATA 20,8E
1B11A:  DATA 00,00
1B11C:  MOVLW  01
1B11E:  MOVWF  FF8
1B120:  MOVLW  B0
1B122:  MOVWF  FF7
1B124:  MOVLW  5C
1B126:  MOVWF  FF6
1B128:  TBLRD*+
1B12A:  MOVF   FF5,W
1B12C:  MOVWF  00
1B12E:  XORLW  00
1B130:  BZ    1B158
1B132:  TBLRD*+
1B134:  MOVF   FF5,W
1B136:  MOVWF  01
1B138:  BTFSC  FE8.7
1B13A:  BRA    1B146
1B13C:  ANDLW  0F
1B13E:  MOVWF  FEA
1B140:  TBLRD*+
1B142:  MOVFF  FF5,FE9
1B146:  BTFSC  01.6
1B148:  TBLRD*+
1B14A:  BTFSS  01.6
1B14C:  TBLRD*+
1B14E:  MOVFF  FF5,FEE
1B152:  DCFSNZ 00,F
1B154:  BRA    1B128
1B156:  BRA    1B14A
1B158:  CLRF   FF8
1B15A:  MOVLB  8
1B15C:  CLRF   x5D
1B15E:  CLRF   x5F
1B160:  CLRF   x5E
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B162:  BCF    FF2.6
1B164:  BCF    FF2.7
1B166:  BTFSC  FF2.7
1B168:  BRA    1B164
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B16A:  BCF    FC6.5
1B16C:  MOVLW  21
1B16E:  MOVWF  FC6
1B170:  MOVLW  40
1B172:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B174:  BCF    F67.5
1B176:  MOVLW  21
1B178:  MOVWF  F67
1B17A:  MOVLW  40
1B17C:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B17E:  MOVLW  00
1B180:  MOVLB  F
1B182:  MOVWF  x23
1B184:  MOVWF  x24
1B186:  MOVLW  1F
1B188:  MOVWF  x25
1B18A:  BCF    FC1.3
1B18C:  BSF    FC1.4
1B18E:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B190:  MOVF   FC0,W
1B192:  ANDLW  C0
1B194:  IORLW  07
1B196:  MOVWF  FC0
1B198:  BSF    FC0.7
1B19A:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B19C:  MOVLW  87
1B19E:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B1A0:  MOVLW  37
1B1A2:  MOVWF  FCD
1B1A4:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B1A6:  MOVLB  0
1B1A8:  GOTO   284C
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B1AC:  CLRF   FB0
1B1AE:  MOVLW  07
1B1B0:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B1B2:  MOVLW  04
1B1B4:  MOVLB  F
1B1B6:  MOVWF  x2E
1B1B8:  MOVWF  x2F
1B1BA:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B1BC:  MOVLW  70
1B1BE:  MOVWF  FD3
1B1C0:  MOVLW  40
1B1C2:  MOVWF  F9B
1B1C4:  CLRF   F64
....................     
....................    //setup_wdt(WDT_4S); 
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B1C6:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B1C8:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B1CA:  MOVLB  0
1B1CC:  CALL   2888
....................  
....................    enable_interrupts(GLOBAL); 
1B1D0:  MOVLW  C0
1B1D2:  IORWF  FF2,F
....................     
....................     
....................  
....................    init_hardware(); 
1B1D4:  CALL   28C2
....................    motor_sleep_rdy(); 
1B1D8:  CALL   2920
....................  
....................    sleep_mode = FALSE;    
1B1DC:  BCF    49.1
....................    busy_set(); 
1B1DE:  CALL   2948
....................     
....................    init_nv_vars(); 
1B1E2:  CALL   2A40
....................    get_step_vars(); 
1B1E6:  CALL   2CA2
....................    init_aws(); 
1B1EA:  GOTO   3064
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B1EE:  CALL   307E
....................    blink(); 
1B1F2:  GOTO   3084
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B1F6:  CALL   30D0
....................     
....................    RTC_read(); 
1B1FA:  CALL   32CC
....................    RTC_last_power(); 
1B1FE:  GOTO   33CA
....................    RTC_reset_HT();   
1B202:  CALL   343A
....................    RTC_read(); 
1B206:  CALL   32CC
1B20A:  CLRF   1B
1B20C:  BTFSC  FF2.7
1B20E:  BSF    1B.7
1B210:  BCF    FF2.7
....................    RTC_read_flags(); 
1B212:  CALL   0DCC
1B216:  BTFSC  1B.7
1B218:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B21A:  MOVF   3B,F
1B21C:  BNZ   1B222
1B21E:  MOVF   3C,F
1B220:  BZ    1B272
1B222:  MOVLW  CE
1B224:  MOVWF  FF6
1B226:  MOVLW  27
1B228:  MOVWF  FF7
1B22A:  MOVLW  00
1B22C:  MOVWF  FF8
1B22E:  CLRF   1B
1B230:  BTFSC  FF2.7
1B232:  BSF    1B.7
1B234:  BCF    FF2.7
1B236:  MOVLW  04
1B238:  MOVLB  A
1B23A:  MOVWF  x18
1B23C:  MOVLB  0
1B23E:  CALL   1010
1B242:  BTFSC  1B.7
1B244:  BSF    FF2.7
1B246:  MOVLW  10
1B248:  MOVWF  FE9
1B24A:  CLRF   1B
1B24C:  BTFSC  FF2.7
1B24E:  BSF    1B.7
1B250:  BCF    FF2.7
1B252:  MOVFF  3C,A19
1B256:  MOVFF  3B,A18
1B25A:  CALL   1192
1B25E:  BTFSC  1B.7
1B260:  BSF    FF2.7
1B262:  MOVLW  0D
1B264:  BTFSS  F9E.4
1B266:  BRA    1B264
1B268:  MOVWF  FAD
1B26A:  MOVLW  0A
1B26C:  BTFSS  F9E.4
1B26E:  BRA    1B26C
1B270:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B272:  CALL   3490
....................    sd_status = init_sdcard(); 
1B276:  CALL   4FBC
1B27A:  MOVFF  01,2D8
....................    if(sd_status>0) msg_card_fail(); 
1B27E:  MOVLB  2
1B280:  MOVF   xD8,F
1B282:  BZ    1B28C
1B284:  MOVLB  0
1B286:  CALL   5002
1B28A:  MOVLB  2
....................    
....................     
....................     
....................    reset_event(); 
1B28C:  MOVLB  0
1B28E:  GOTO   AAFE
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B292:  MOVLB  7
1B294:  MOVF   x92,F
1B296:  BNZ   1B2A4
1B298:  MOVF   x93,F
1B29A:  BNZ   1B2A4
1B29C:  MOVF   x94,F
1B29E:  BNZ   1B2A4
1B2A0:  MOVF   x95,F
1B2A2:  BZ    1B2AC
1B2A4:  MOVLB  0
1B2A6:  CALL   9C42
1B2AA:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B2AC:  MOVF   xAB,F
1B2AE:  BNZ   1B332
1B2B0:  MOVF   xAC,F
1B2B2:  BNZ   1B332
....................       e_port[0]=0; 
1B2B4:  CLRF   xC0
1B2B6:  CLRF   xBF
....................       write16(ADDR_E1_PORT,0); 
1B2B8:  MOVLW  AA
1B2BA:  MOVLB  8
1B2BC:  MOVWF  xCB
1B2BE:  CLRF   xCD
1B2C0:  CLRF   xCC
1B2C2:  MOVLB  0
1B2C4:  CALL   4F56
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B2C8:  MOVLW  D8
1B2CA:  MOVWF  FF6
1B2CC:  MOVLW  27
1B2CE:  MOVWF  FF7
1B2D0:  MOVLW  00
1B2D2:  MOVWF  FF8
1B2D4:  CLRF   1B
1B2D6:  BTFSC  FF2.7
1B2D8:  BSF    1B.7
1B2DA:  BCF    FF2.7
1B2DC:  MOVLW  05
1B2DE:  MOVLB  A
1B2E0:  MOVWF  x18
1B2E2:  MOVLB  0
1B2E4:  CALL   1010
1B2E8:  BTFSC  1B.7
1B2EA:  BSF    FF2.7
1B2EC:  MOVLW  10
1B2EE:  MOVWF  FE9
1B2F0:  CLRF   1B
1B2F2:  BTFSC  FF2.7
1B2F4:  BSF    1B.7
1B2F6:  BCF    FF2.7
1B2F8:  MOVFF  7AC,A19
1B2FC:  MOVFF  7AB,A18
1B300:  CALL   1192
1B304:  BTFSC  1B.7
1B306:  BSF    FF2.7
1B308:  MOVLW  2C
1B30A:  BTFSS  F9E.4
1B30C:  BRA    1B30A
1B30E:  MOVWF  FAD
1B310:  MOVLW  10
1B312:  MOVWF  FE9
1B314:  MOVFF  7C0,8CE
1B318:  MOVFF  7BF,8CD
1B31C:  CALL   8F24
1B320:  MOVLW  0D
1B322:  BTFSS  F9E.4
1B324:  BRA    1B322
1B326:  MOVWF  FAD
1B328:  MOVLW  0A
1B32A:  BTFSS  F9E.4
1B32C:  BRA    1B32A
1B32E:  MOVWF  FAD
1B330:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B332:  MOVF   xAD,F
1B334:  BNZ   1B3B8
1B336:  MOVF   xAE,F
1B338:  BNZ   1B3B8
....................       m_lin_pos[1]=-1; 
1B33A:  SETF   xB2
1B33C:  SETF   xB1
....................       write16(ADDR_M2_LIN_POS, -1); 
1B33E:  MOVLW  B8
1B340:  MOVLB  8
1B342:  MOVWF  xCB
1B344:  SETF   xCD
1B346:  SETF   xCC
1B348:  MOVLB  0
1B34A:  CALL   4F56
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B34E:  MOVLW  E8
1B350:  MOVWF  FF6
1B352:  MOVLW  27
1B354:  MOVWF  FF7
1B356:  MOVLW  00
1B358:  MOVWF  FF8
1B35A:  CLRF   1B
1B35C:  BTFSC  FF2.7
1B35E:  BSF    1B.7
1B360:  BCF    FF2.7
1B362:  MOVLW  05
1B364:  MOVLB  A
1B366:  MOVWF  x18
1B368:  MOVLB  0
1B36A:  CALL   1010
1B36E:  BTFSC  1B.7
1B370:  BSF    FF2.7
1B372:  MOVLW  10
1B374:  MOVWF  FE9
1B376:  CLRF   1B
1B378:  BTFSC  FF2.7
1B37A:  BSF    1B.7
1B37C:  BCF    FF2.7
1B37E:  MOVFF  7AE,A19
1B382:  MOVFF  7AD,A18
1B386:  CALL   1192
1B38A:  BTFSC  1B.7
1B38C:  BSF    FF2.7
1B38E:  MOVLW  2C
1B390:  BTFSS  F9E.4
1B392:  BRA    1B390
1B394:  MOVWF  FAD
1B396:  MOVLW  10
1B398:  MOVWF  FE9
1B39A:  MOVFF  7B2,8CE
1B39E:  MOVFF  7B1,8CD
1B3A2:  CALL   8F24
1B3A6:  MOVLW  0D
1B3A8:  BTFSS  F9E.4
1B3AA:  BRA    1B3A8
1B3AC:  MOVWF  FAD
1B3AE:  MOVLW  0A
1B3B0:  BTFSS  F9E.4
1B3B2:  BRA    1B3B0
1B3B4:  MOVWF  FAD
1B3B6:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1B3B8:  MOVF   31,F
1B3BA:  BNZ   1B45E
1B3BC:  MOVF   32,F
1B3BE:  BNZ   1B45E
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1B3C0:  MOVLW  F8
1B3C2:  MOVWF  FF6
1B3C4:  MOVLW  27
1B3C6:  MOVWF  FF7
1B3C8:  MOVLW  00
1B3CA:  MOVWF  FF8
1B3CC:  CLRF   1B
1B3CE:  BTFSC  FF2.7
1B3D0:  BSF    1B.7
1B3D2:  BCF    FF2.7
1B3D4:  MOVLB  0
1B3D6:  CALL   0E3A
1B3DA:  BTFSC  1B.7
1B3DC:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1B3DE:  MOVLB  8
1B3E0:  MOVF   x5F,F
1B3E2:  BNZ   1B410
1B3E4:  MOVF   x5E,W
1B3E6:  SUBLW  63
1B3E8:  BNC   1B410
1B3EA:  MOVF   x5D,W
1B3EC:  SUBLW  1B
1B3EE:  BZ    1B410
....................       { 
....................          EscNum=TestForEsc(); 
1B3F0:  MOVLB  0
1B3F2:  GOTO   AD28
1B3F6:  MOVFF  01,85D
....................          if(EscNum == ESCAPE) command_prompt(); 
1B3FA:  MOVLB  8
1B3FC:  MOVF   x5D,W
1B3FE:  SUBLW  1B
1B400:  BNZ   1B408
1B402:  MOVLB  0
1B404:  RCALL  1AF2E
1B406:  MOVLB  8
....................          EscCount++; 
1B408:  INCF   x5E,F
1B40A:  BTFSC  FD8.2
1B40C:  INCF   x5F,F
1B40E:  BRA    1B3E0
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1B410:  DECFSZ 33,W
1B412:  BRA    1B428
1B414:  MOVF   34,F
1B416:  BNZ   1B428
....................       { 
....................          arg=0; 
1B418:  CLRF   47
1B41A:  CLRF   46
1B41C:  CLRF   45
1B41E:  CLRF   44
....................          commandZ(); 
1B420:  MOVLB  0
1B422:  CALL   18620
1B426:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1B428:  MOVLW  30
1B42A:  MOVWF  FF6
1B42C:  MOVLW  28
1B42E:  MOVWF  FF7
1B430:  MOVLW  00
1B432:  MOVWF  FF8
1B434:  CLRF   1B
1B436:  BTFSC  FF2.7
1B438:  BSF    1B.7
1B43A:  BCF    FF2.7
1B43C:  MOVLB  0
1B43E:  CALL   0E3A
1B442:  BTFSC  1B.7
1B444:  BSF    FF2.7
....................       arg = 0; 
1B446:  CLRF   47
1B448:  CLRF   46
1B44A:  CLRF   45
1B44C:  CLRF   44
....................       commandM(TRUE); 
1B44E:  MOVLW  01
1B450:  MOVLB  8
1B452:  MOVWF  x62
1B454:  MOVLB  0
1B456:  CALL   168DA
....................    } 
1B45A:  BRA    1B462
1B45C:  MOVLB  7
....................    else 
....................    { 
....................       /*int8 RTC_buffer = 0; 
....................       unsigned int8 a0 = 0; 
....................       unsigned int8 a1 = 0; 
....................       unsigned int8 a2 = 0; 
....................       unsigned int8 a3 = 0; 
....................       unsigned int8 a4 = 0; 
....................       unsigned int8 a5 = 0; 
....................       unsigned int8 a6 = 0; 
....................       unsigned int8 a7 = 0; 
....................       unsigned int8 a8 = 0; 
....................       unsigned int8 a9 = 0; 
....................       unsigned int8 a10 = 0; 
....................       unsigned int8 a11 = 0; 
....................        
....................       RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
....................       spi_write(0x89); 
....................       spi_write(0b11000011); 
....................       output_bit(RTC_CS, DISABLE); 
....................        
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x00); 
....................       a0 = RTC_buffer; 
....................       fprintf(COM_A,"crap: %u\r\n",RTC_buffer); 
....................       a1 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg0: %u\r\n",a1); 
....................       a2 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg1: %u\r\n",a2); 
....................       a3 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg2: %u\r\n",a3); 
....................       a4 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg3: %u\r\n",a4); 
....................       a5 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg4: %u\r\n",a5); 
....................       a6 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg5: %u\r\n",a6); 
....................       a7 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg6: %u\r\n",a7); 
....................       a8 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg7: %u\r\n",a8); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg8: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg9: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regA: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regB: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regC: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regD: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regE: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regF: %u\r\n",a9); 
....................        
....................       output_bit(RTC_CS, DISABLE);*/ 
....................     
....................       command_prompt(); 
1B45E:  MOVLB  0
1B460:  RCALL  1AF2E
....................    } 
....................  
....................    reset_cpu(); 
1B462:  RESET
.................... } 
....................  
1B464:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 7F78   PUT NOBROWNOUT BORV18 ZPBORM WDT WDT1048576
   Word  3: 8BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
