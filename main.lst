CCS PCH C Compiler, Version 5.071d, 1               06-Jul-17 13:39
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   114150 bytes (87%)
                           Largest free fragment is 16558
               RAM used:   2148 (56%) at main() level
                           2613 (68%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1B29A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0EE8
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0F12
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   1908
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E14
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   16EA
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   1760
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E78
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
....................              /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 3F,40
00668:  DATA 42,53
0066A:  DATA 59,0D
0066C:  DATA 0A,00
0066E:  DATA 40,52
00670:  DATA 44,59
00672:  DATA 0D,0A
00674:  DATA 00,00
00676:  DATA 40,46
00678:  DATA 53,3A
0067A:  DATA 44,69
0067C:  DATA 73,63
0067E:  DATA 6F,76
00680:  DATA 65,72
00682:  DATA 79,0D
00684:  DATA 0A,00
00686:  DATA 40,46
00688:  DATA 53,3A
0068A:  DATA 55,6E
0068C:  DATA 61,62
0068E:  DATA 6C,65
00690:  DATA 20,74
00692:  DATA 6F,20
00694:  DATA 70,75
00696:  DATA 74,20
00698:  DATA 63,61
0069A:  DATA 72,64
0069C:  DATA 20,69
0069E:  DATA 6E,20
006A0:  DATA 69,64
006A2:  DATA 6C,65
006A4:  DATA 20,73
006A6:  DATA 74,61
006A8:  DATA 74,65
006AA:  DATA 2C,20
006AC:  DATA 72,65
006AE:  DATA 73,70
006B0:  DATA 6F,6E
006B2:  DATA 73,65
006B4:  DATA 20,3D
006B6:  DATA 20,25
006B8:  DATA 30,32
006BA:  DATA 78,0D
006BC:  DATA 0A,00
006BE:  DATA 40,46
006C0:  DATA 53,3A
006C2:  DATA 43,61
006C4:  DATA 72,64
006C6:  DATA 20,69
006C8:  DATA 64,6C
006CA:  DATA 65,2C
006CC:  DATA 20,72
006CE:  DATA 65,73
006D0:  DATA 70,6F
006D2:  DATA 6E,73
006D4:  DATA 65,20
006D6:  DATA 3D,20
006D8:  DATA 25,30
006DA:  DATA 32,78
006DC:  DATA 0D,0A
006DE:  DATA 00,00
006E0:  DATA 40,46
006E2:  DATA 53,3A
006E4:  DATA 52,65
006E6:  DATA 73,70
006E8:  DATA 6F,6E
006EA:  DATA 73,65
006EC:  DATA 20,74
006EE:  DATA 6F,20
006F0:  DATA 53,44
006F2:  DATA 20,76
006F4:  DATA 65,72
006F6:  DATA 20,32
006F8:  DATA 20,74
006FA:  DATA 65,73
006FC:  DATA 74,20
006FE:  DATA 43,4D
00700:  DATA 44,38
00702:  DATA 20,3D
00704:  DATA 20,25
00706:  DATA 78,0D
00708:  DATA 0A,00
0070A:  DATA 40,46
0070C:  DATA 53,3A
0070E:  DATA 50,6F
00710:  DATA 73,73
00712:  DATA 69,62
00714:  DATA 6C,65
00716:  DATA 20,53
00718:  DATA 44,76
0071A:  DATA 32,20
0071C:  DATA 63,61
0071E:  DATA 72,64
00720:  DATA 20,64
00722:  DATA 65,74
00724:  DATA 65,63
00726:  DATA 74,65
00728:  DATA 64,0D
0072A:  DATA 0A,00
0072C:  DATA 40,46
0072E:  DATA 53,3A
00730:  DATA 56,6F
00732:  DATA 6C,74
00734:  DATA 61,67
00736:  DATA 65,20
00738:  DATA 72,61
0073A:  DATA 6E,67
0073C:  DATA 65,20
0073E:  DATA 63,68
00740:  DATA 65,63
00742:  DATA 6B,2C
00744:  DATA 20,6F
00746:  DATA 63,72
00748:  DATA 20,3D
0074A:  DATA 20,25
0074C:  DATA 30,32
0074E:  DATA 78,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,0D
0075C:  DATA 0A,00
0075E:  DATA 40,46
00760:  DATA 53,3A
00762:  DATA 43,61
00764:  DATA 72,64
00766:  DATA 20,56
00768:  DATA 64,64
0076A:  DATA 20,72
0076C:  DATA 61,6E
0076E:  DATA 67,65
00770:  DATA 20,3D
00772:  DATA 20,32
00774:  DATA 2E,37
00776:  DATA 2D,33
00778:  DATA 2E,36
0077A:  DATA 20,76
0077C:  DATA 6F,6C
0077E:  DATA 74,73
00780:  DATA 0D,0A
00782:  DATA 00,00
00784:  DATA 40,46
00786:  DATA 53,3A
00788:  DATA 53,65
0078A:  DATA 6E,64
0078C:  DATA 69,6E
0078E:  DATA 67,20
00790:  DATA 41,43
00792:  DATA 4D,44
00794:  DATA 34,31
00796:  DATA 20,63
00798:  DATA 6F,6D
0079A:  DATA 6D,61
0079C:  DATA 6E,64
0079E:  DATA 20,74
007A0:  DATA 6F,20
007A2:  DATA 53,44
007A4:  DATA 20,76
007A6:  DATA 65,72
007A8:  DATA 20,32
007AA:  DATA 20,63
007AC:  DATA 61,72
007AE:  DATA 64,0D
007B0:  DATA 0A,00
007B2:  DATA 40,46
007B4:  DATA 53,3A
007B6:  DATA 52,65
007B8:  DATA 73,70
007BA:  DATA 6F,6E
007BC:  DATA 73,65
007BE:  DATA 20,66
007C0:  DATA 72,6F
007C2:  DATA 6D,20
007C4:  DATA 73,65
007C6:  DATA 6E,64
007C8:  DATA 69,6E
007CA:  DATA 67,20
007CC:  DATA 41,43
007CE:  DATA 4D,44
007D0:  DATA 34,31
007D2:  DATA 20,3D
007D4:  DATA 20,25
007D6:  DATA 30,32
007D8:  DATA 78,2C
007DA:  DATA 20,54
007DC:  DATA 69,6D
007DE:  DATA 65,72
007E0:  DATA 20,3D
007E2:  DATA 20,25
007E4:  DATA 6C,75
007E6:  DATA 0D,0A
007E8:  DATA 00,00
007EA:  DATA 40,46
007EC:  DATA 53,3A
007EE:  DATA 52,65
007F0:  DATA 73,70
007F2:  DATA 6F,6E
007F4:  DATA 73,65
007F6:  DATA 20,74
007F8:  DATA 6F,20
007FA:  DATA 43,4D
007FC:  DATA 44,35
007FE:  DATA 38,20
00800:  DATA 3D,20
00802:  DATA 25,78
00804:  DATA 0D,0A
00806:  DATA 00,00
00808:  DATA 40,46
0080A:  DATA 53,3A
0080C:  DATA 53,65
0080E:  DATA 6E,74
00810:  DATA 20,43
00812:  DATA 4D,44
00814:  DATA 20,35
00816:  DATA 38,2C
00818:  DATA 20,54
0081A:  DATA 69,6D
0081C:  DATA 65,72
0081E:  DATA 20,76
00820:  DATA 61,6C
00822:  DATA 75,65
00824:  DATA 20,3D
00826:  DATA 20,25
00828:  DATA 6C,75
0082A:  DATA 2C,20
0082C:  DATA 6F,63
0082E:  DATA 72,20
00830:  DATA 3D,20
00832:  DATA 25,30
00834:  DATA 32,78
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 0D,0A
00844:  DATA 00,00
00846:  DATA 40,46
00848:  DATA 53,3A
0084A:  DATA 43,61
0084C:  DATA 72,64
0084E:  DATA 20,43
00850:  DATA 41,4E
00852:  DATA 4E,4F
00854:  DATA 54,20
00856:  DATA 77,6F
00858:  DATA 72,6B
0085A:  DATA 20,56
0085C:  DATA 64,64
0085E:  DATA 20,72
00860:  DATA 61,6E
00862:  DATA 67,65
00864:  DATA 20,6F
00866:  DATA 66,20
00868:  DATA 32,2E
0086A:  DATA 37,2D
0086C:  DATA 33,2E
0086E:  DATA 36,20
00870:  DATA 76,6F
00872:  DATA 6C,74
00874:  DATA 73,0D
00876:  DATA 0A,00
00878:  DATA 40,46
0087A:  DATA 53,3A
0087C:  DATA 4E,6F
0087E:  DATA 74,20
00880:  DATA 61,6E
00882:  DATA 20,53
00884:  DATA 44,53
00886:  DATA 43,20
00888:  DATA 6F,72
0088A:  DATA 20,53
0088C:  DATA 44,48
0088E:  DATA 43,20
00890:  DATA 63,61
00892:  DATA 72,64
00894:  DATA 2C,20
00896:  DATA 54,65
00898:  DATA 73,74
0089A:  DATA 69,6E
0089C:  DATA 67,20
0089E:  DATA 66,6F
008A0:  DATA 72,20
008A2:  DATA 53,44
008A4:  DATA 20,56
008A6:  DATA 65,72
008A8:  DATA 31,20
008AA:  DATA 6F,72
008AC:  DATA 20,4D
008AE:  DATA 4D,43
008B0:  DATA 20,43
008B2:  DATA 61,72
008B4:  DATA 64,0D
008B6:  DATA 0A,00
008B8:  DATA 40,46
008BA:  DATA 53,3A
008BC:  DATA 52,65
008BE:  DATA 73,70
008C0:  DATA 6F,6E
008C2:  DATA 73,65
008C4:  DATA 20,66
008C6:  DATA 72,6F
008C8:  DATA 6D,20
008CA:  DATA 47,4F
008CC:  DATA 5F,49
008CE:  DATA 44,4C
008D0:  DATA 45,20
008D2:  DATA 3D,20
008D4:  DATA 25,30
008D6:  DATA 32,78
008D8:  DATA 0D,0A
008DA:  DATA 00,00
008DC:  DATA 40,46
008DE:  DATA 53,3A
008E0:  DATA 52,65
008E2:  DATA 73,70
008E4:  DATA 6F,6E
008E6:  DATA 73,65
008E8:  DATA 20,66
008EA:  DATA 72,6F
008EC:  DATA 6D,20
008EE:  DATA 53,44
008F0:  DATA 5F,43
008F2:  DATA 4D,44
008F4:  DATA 5F,53
008F6:  DATA 45,4E
008F8:  DATA 44,5F
008FA:  DATA 4F,50
008FC:  DATA 5F,43
008FE:  DATA 4F,4E
00900:  DATA 44,20
00902:  DATA 3D,20
00904:  DATA 25,30
00906:  DATA 32,78
00908:  DATA 2C,20
0090A:  DATA 54,69
0090C:  DATA 6D,65
0090E:  DATA 72,20
00910:  DATA 3D,20
00912:  DATA 25,6C
00914:  DATA 75,0D
00916:  DATA 0A,00
00918:  DATA 40,46
0091A:  DATA 53,3A
0091C:  DATA 41,74
0091E:  DATA 74,65
00920:  DATA 6D,70
00922:  DATA 74,69
00924:  DATA 6E,67
00926:  DATA 20,53
00928:  DATA 44,76
0092A:  DATA 31,20
0092C:  DATA 76,65
0092E:  DATA 72,73
00930:  DATA 75,73
00932:  DATA 20,4D
00934:  DATA 4D,43
00936:  DATA 20,49
00938:  DATA 44,2C
0093A:  DATA 20,52
0093C:  DATA 65,73
0093E:  DATA 70,6F
00940:  DATA 6E,73
00942:  DATA 65,20
00944:  DATA 66,72
00946:  DATA 6F,6D
00948:  DATA 20,53
0094A:  DATA 44,5F
0094C:  DATA 43,4D
0094E:  DATA 44,5F
00950:  DATA 41,50
00952:  DATA 50,4C
00954:  DATA 5F,43
00956:  DATA 4D,44
00958:  DATA 20,3D
0095A:  DATA 20,25
0095C:  DATA 30,32
0095E:  DATA 78,0D
00960:  DATA 0A,00
00962:  DATA 40,46
00964:  DATA 53,3A
00966:  DATA 49,6E
00968:  DATA 76,61
0096A:  DATA 6C,69
0096C:  DATA 64,20
0096E:  DATA 72,65
00970:  DATA 73,70
00972:  DATA 6F,6E
00974:  DATA 73,65
00976:  DATA 20,74
00978:  DATA 6F,20
0097A:  DATA 53,44
0097C:  DATA 5F,41
0097E:  DATA 43,4D
00980:  DATA 44,34
00982:  DATA 31,2C
00984:  DATA 20,72
00986:  DATA 65,73
00988:  DATA 70,6F
0098A:  DATA 6E,73
0098C:  DATA 65,20
0098E:  DATA 3D,20
00990:  DATA 25,30
00992:  DATA 32,58
00994:  DATA 2C,20
00996:  DATA 72,65
00998:  DATA 69,6E
0099A:  DATA 69,74
0099C:  DATA 69,61
0099E:  DATA 6C,69
009A0:  DATA 7A,69
009A2:  DATA 6E,67
009A4:  DATA 20,61
009A6:  DATA 73,20
009A8:  DATA 4D,4D
009AA:  DATA 43,0D
009AC:  DATA 0A,00
009AE:  DATA 40,46
009B0:  DATA 53,3A
009B2:  DATA 46,61
009B4:  DATA 69,6C
009B6:  DATA 65,64
009B8:  DATA 20,74
009BA:  DATA 6F,20
009BC:  DATA 69,6E
009BE:  DATA 69,74
009C0:  DATA 69,61
009C2:  DATA 6C,69
009C4:  DATA 7A,65
009C6:  DATA 20,61
009C8:  DATA 73,20
009CA:  DATA 4D,4D
009CC:  DATA 43,2C
009CE:  DATA 20,72
009D0:  DATA 65,73
009D2:  DATA 70,6F
009D4:  DATA 6E,73
009D6:  DATA 65,20
009D8:  DATA 3D,20
009DA:  DATA 25,30
009DC:  DATA 32,58
009DE:  DATA 2C,20
009E0:  DATA 65,78
009E2:  DATA 69,74
009E4:  DATA 69,6E
009E6:  DATA 67,0D
009E8:  DATA 0A,00
009EA:  DATA 40,46
009EC:  DATA 53,3A
009EE:  DATA 43,61
009F0:  DATA 72,64
009F2:  DATA 20,66
009F4:  DATA 61,69
009F6:  DATA 6C,65
009F8:  DATA 64,20
009FA:  DATA 74,6F
009FC:  DATA 20,72
009FE:  DATA 65,73
00A00:  DATA 70,6F
00A02:  DATA 6E,64
00A04:  DATA 20,63
00A06:  DATA 6F,72
00A08:  DATA 72,65
00A0A:  DATA 63,6C
00A0C:  DATA 79,20
00A0E:  DATA 61,66
00A10:  DATA 74,65
00A12:  DATA 72,20
00A14:  DATA 53,44
00A16:  DATA 5F,43
00A18:  DATA 4D,44
00A1A:  DATA 5F,53
00A1C:  DATA 45,4E
00A1E:  DATA 44,5F
00A20:  DATA 4F,50
00A22:  DATA 5F,43
00A24:  DATA 4F,4E
00A26:  DATA 44,2C
00A28:  DATA 20,72
00A2A:  DATA 65,73
00A2C:  DATA 70,6F
00A2E:  DATA 6E,73
00A30:  DATA 65,20
00A32:  DATA 3D,20
00A34:  DATA 25,30
00A36:  DATA 32,58
00A38:  DATA 2C,20
00A3A:  DATA 54,69
00A3C:  DATA 6D,65
00A3E:  DATA 72,20
00A40:  DATA 3D,20
00A42:  DATA 25,6C
00A44:  DATA 75,0D
00A46:  DATA 0A,00
00A48:  DATA 40,46
00A4A:  DATA 53,3A
00A4C:  DATA 53,65
00A4E:  DATA 74,74
00A50:  DATA 69,6E
00A52:  DATA 67,20
00A54:  DATA 62,6C
00A56:  DATA 6F,63
00A58:  DATA 6B,20
00A5A:  DATA 6C,65
00A5C:  DATA 6E,67
00A5E:  DATA 74,68
00A60:  DATA 0D,0A
00A62:  DATA 00,00
00A64:  DATA 40,46
00A66:  DATA 53,3A
00A68:  DATA 45,72
00A6A:  DATA 72,6F
00A6C:  DATA 72,20
00A6E:  DATA 73,65
00A70:  DATA 74,74
00A72:  DATA 69,6E
00A74:  DATA 67,20
00A76:  DATA 62,6C
00A78:  DATA 6F,63
00A7A:  DATA 6B,20
00A7C:  DATA 6C,65
00A7E:  DATA 6E,67
00A80:  DATA 74,68
00A82:  DATA 2C,20
00A84:  DATA 72,65
00A86:  DATA 73,70
00A88:  DATA 6F,6E
00A8A:  DATA 73,65
00A8C:  DATA 20,3D
00A8E:  DATA 20,25
00A90:  DATA 30,32
00A92:  DATA 78,2C
00A94:  DATA 20,74
00A96:  DATA 69,6D
00A98:  DATA 65,72
00A9A:  DATA 20,3D
00A9C:  DATA 20,25
00A9E:  DATA 6C,75
00AA0:  DATA 0D,0A
00AA2:  DATA 00,00
00AA4:  DATA 40,46
00AA6:  DATA 53,3A
00AA8:  DATA 43,61
00AAA:  DATA 72,64
00AAC:  DATA 20,54
00AAE:  DATA 79,70
00AB0:  DATA 65,20
00AB2:  DATA 44,69
00AB4:  DATA 73,63
00AB6:  DATA 6F,76
00AB8:  DATA 65,72
00ABA:  DATA 79,20
00ABC:  DATA 45,72
00ABE:  DATA 72,6F
00AC0:  DATA 72,0D
00AC2:  DATA 0A,00
00AC4:  DATA 40,46
00AC6:  DATA 53,3A
00AC8:  DATA 4D,4D
00ACA:  DATA 43,20
00ACC:  DATA 43,61
00ACE:  DATA 72,64
00AD0:  DATA 20,66
00AD2:  DATA 6F,75
00AD4:  DATA 6E,64
00AD6:  DATA 0D,0A
00AD8:  DATA 00,00
00ADA:  DATA 40,46
00ADC:  DATA 53,3A
00ADE:  DATA 53,44
00AE0:  DATA 76,31
00AE2:  DATA 20,43
00AE4:  DATA 61,72
00AE6:  DATA 64,20
00AE8:  DATA 66,6F
00AEA:  DATA 75,6E
00AEC:  DATA 64,0D
00AEE:  DATA 0A,00
00AF0:  DATA 40,46
00AF2:  DATA 53,3A
00AF4:  DATA 53,44
00AF6:  DATA 53,43
00AF8:  DATA 20,43
00AFA:  DATA 61,72
00AFC:  DATA 64,20
00AFE:  DATA 66,6F
00B00:  DATA 75,6E
00B02:  DATA 64,0D
00B04:  DATA 0A,00
00B06:  DATA 40,46
00B08:  DATA 53,3A
00B0A:  DATA 53,44
00B0C:  DATA 48,43
00B0E:  DATA 20,43
00B10:  DATA 61,72
00B12:  DATA 64,20
00B14:  DATA 66,6F
00B16:  DATA 75,6E
00B18:  DATA 64,0D
00B1A:  DATA 0A,00
00B1C:  DATA 40,46
00B1E:  DATA 53,3A
00B20:  DATA 43,61
00B22:  DATA 72,64
00B24:  DATA 20,54
00B26:  DATA 79,70
00B28:  DATA 65,20
00B2A:  DATA 44,69
00B2C:  DATA 73,63
00B2E:  DATA 6F,76
00B30:  DATA 65,72
00B32:  DATA 79,20
00B34:  DATA 45,72
00B36:  DATA 72,6F
00B38:  DATA 72,2C
00B3A:  DATA 20,43
00B3C:  DATA 61,72
00B3E:  DATA 64,20
00B40:  DATA 3D,20
00B42:  DATA 25,30
00B44:  DATA 32,58
00B46:  DATA 0D,0A
00B48:  DATA 00,00
00B4A:  DATA 40,46
00B4C:  DATA 53,3A
00B4E:  DATA 43,61
00B50:  DATA 72,64
00B52:  DATA 20,72
00B54:  DATA 65,73
00B56:  DATA 65,74
00B58:  DATA 20,73
00B5A:  DATA 75,63
00B5C:  DATA 63,65
00B5E:  DATA 73,73
00B60:  DATA 20,2D
00B62:  DATA 20,43
00B64:  DATA 6D,64
00B66:  DATA 20,74
00B68:  DATA 6F,20
00B6A:  DATA 52,65
00B6C:  DATA 61,64
00B6E:  DATA 79,20
00B70:  DATA 63,6F
00B72:  DATA 75,6E
00B74:  DATA 74,20
00B76:  DATA 3D,20
00B78:  DATA 25,6C
00B7A:  DATA 75,0D
00B7C:  DATA 0A,00
00B7E:  DATA 40,46
00B80:  DATA 53,3A
00B82:  DATA 53,50
00B84:  DATA 49,20
00B86:  DATA 62,75
00B88:  DATA 73,20
00B8A:  DATA 73,70
00B8C:  DATA 65,65
00B8E:  DATA 64,20
00B90:  DATA 73,65
00B92:  DATA 74,20
00B94:  DATA 74,6F
00B96:  DATA 20,68
00B98:  DATA 69,67
00B9A:  DATA 68,0D
00B9C:  DATA 0A,00
00B9E:  DATA 40,46
00BA0:  DATA 53,3A
00BA2:  DATA 43,61
00BA4:  DATA 72,64
00BA6:  DATA 20,61
00BA8:  DATA 63,74
00BAA:  DATA 69,76
00BAC:  DATA 61,74
00BAE:  DATA 65,20
00BB0:  DATA 66,61
00BB2:  DATA 69,6C
00BB4:  DATA 75,72
00BB6:  DATA 65,2C
00BB8:  DATA 20,72
00BBA:  DATA 65,73
00BBC:  DATA 70,6F
00BBE:  DATA 6E,73
00BC0:  DATA 65,20
00BC2:  DATA 3D,20
00BC4:  DATA 25,30
00BC6:  DATA 32,58
00BC8:  DATA 2C,20
00BCA:  DATA 54,69
00BCC:  DATA 6D,65
00BCE:  DATA 72,20
00BD0:  DATA 3D,20
00BD2:  DATA 25,6C
00BD4:  DATA 75,0D
00BD6:  DATA 0A,00
00BD8:  DATA 40,46
00BDA:  DATA 53,3A
00BDC:  DATA 43,61
00BDE:  DATA 72,64
00BE0:  DATA 20,61
00BE2:  DATA 63,74
00BE4:  DATA 69,76
00BE6:  DATA 61,74
00BE8:  DATA 65,20
00BEA:  DATA 73,75
00BEC:  DATA 63,63
00BEE:  DATA 65,73
00BF0:  DATA 73,20
00BF2:  DATA 6F,6E
00BF4:  DATA 20,61
00BF6:  DATA 74,74
00BF8:  DATA 65,6D
00BFA:  DATA 70,74
00BFC:  DATA 20,25
00BFE:  DATA 6C,75
00C00:  DATA 0D,0A
00C02:  DATA 00,00
00C04:  DATA 46,41
00C06:  DATA 54,20
00C08:  DATA 61,74
00C0A:  DATA 20,73
00C0C:  DATA 65,63
00C0E:  DATA 74,6F
00C10:  DATA 72,20
00C12:  DATA 30,0D
00C14:  DATA 0A,00
00C16:  DATA 54,59
00C18:  DATA 50,45
00C1A:  DATA 20,63
00C1C:  DATA 6F,6D
00C1E:  DATA 6D,61
00C20:  DATA 6E,64
00C22:  DATA 20,45
00C24:  DATA 52,52
00C26:  DATA 4F,52
00C28:  DATA 0D,0A
00C2A:  DATA 00,00
00C2C:  DATA 40,46
00C2E:  DATA 53,3A
00C30:  DATA 20,25
00C32:  DATA 73,0D
00C34:  DATA 0A,00
00C36:  DATA 40,46
00C38:  DATA 53,3A
00C3A:  DATA 20,25
00C3C:  DATA 73,0D
00C3E:  DATA 0A,00
00C40:  DATA 2A,2A
00C42:  DATA 20,40
00C44:  DATA 46,53
00C46:  DATA 3A,20
00C48:  DATA 45,52
00C4A:  DATA 52,4F
00C4C:  DATA 52,0D
00C4E:  DATA 0A,00
00C50:  DATA 20,20
00C52:  DATA 20,4E
00C54:  DATA 6F,45
00C56:  DATA 72,72
00C58:  DATA 6F,72
00C5A:  DATA 0D,0A
00C5C:  DATA 00,00
00C5E:  DATA 20,20
00C60:  DATA 20,4D
00C62:  DATA 65,64
00C64:  DATA 69,61
00C66:  DATA 20,4E
00C68:  DATA 6F,74
00C6A:  DATA 20,52
00C6C:  DATA 65,61
00C6E:  DATA 64,79
00C70:  DATA 0D,0A
00C72:  DATA 00,00
00C74:  DATA 20,20
00C76:  DATA 20,46
00C78:  DATA 69,6C
00C7A:  DATA 65,20
00C7C:  DATA 4E,6F
00C7E:  DATA 74,20
00C80:  DATA 46,6F
00C82:  DATA 75,6E
00C84:  DATA 64,0D
00C86:  DATA 0A,00
00C88:  DATA 20,20
00C8A:  DATA 20,49
00C8C:  DATA 6E,76
00C8E:  DATA 61,6C
00C90:  DATA 69,64
00C92:  DATA 20,50
00C94:  DATA 61,74
00C96:  DATA 68,0D
00C98:  DATA 0A,00
00C9A:  DATA 20,20
00C9C:  DATA 20,49
00C9E:  DATA 6E,76
00CA0:  DATA 61,6C
00CA2:  DATA 69,64
00CA4:  DATA 20,4E
00CA6:  DATA 61,6D
00CA8:  DATA 65,0D
00CAA:  DATA 0A,00
00CAC:  DATA 20,20
00CAE:  DATA 20,41
00CB0:  DATA 63,63
00CB2:  DATA 65,73
00CB4:  DATA 73,20
00CB6:  DATA 44,65
00CB8:  DATA 6E,69
00CBA:  DATA 65,64
00CBC:  DATA 0D,0A
00CBE:  DATA 00,00
00CC0:  DATA 20,20
00CC2:  DATA 20,44
00CC4:  DATA 69,73
00CC6:  DATA 6B,20
00CC8:  DATA 46,75
00CCA:  DATA 6C,6C
00CCC:  DATA 0D,0A
00CCE:  DATA 00,00
00CD0:  DATA 20,20
00CD2:  DATA 20,52
00CD4:  DATA 65,61
00CD6:  DATA 64,2F
00CD8:  DATA 57,72
00CDA:  DATA 69,74
00CDC:  DATA 65,20
00CDE:  DATA 45,72
00CE0:  DATA 72,6F
00CE2:  DATA 72,0D
00CE4:  DATA 0A,00
00CE6:  DATA 20,20
00CE8:  DATA 20,49
00CEA:  DATA 6E,63
00CEC:  DATA 6F,72
00CEE:  DATA 72,65
00CF0:  DATA 63,74
00CF2:  DATA 20,4D
00CF4:  DATA 65,64
00CF6:  DATA 69,61
00CF8:  DATA 20,43
00CFA:  DATA 68,61
00CFC:  DATA 6E,67
00CFE:  DATA 65,0D
00D00:  DATA 0A,00
00D02:  DATA 20,20
00D04:  DATA 20,57
00D06:  DATA 72,69
00D08:  DATA 74,65
00D0A:  DATA 20,50
00D0C:  DATA 72,6F
00D0E:  DATA 74,65
00D10:  DATA 63,74
00D12:  DATA 65,64
00D14:  DATA 0D,0A
00D16:  DATA 00,00
00D18:  DATA 20,20
00D1A:  DATA 20,4E
00D1C:  DATA 6F,74
00D1E:  DATA 20,45
00D20:  DATA 6E,61
00D22:  DATA 62,6C
00D24:  DATA 65,64
00D26:  DATA 0D,0A
00D28:  DATA 00,00
00D2A:  DATA 20,20
00D2C:  DATA 20,4E
00D2E:  DATA 6F,20
00D30:  DATA 46,69
00D32:  DATA 6C,65
00D34:  DATA 20,53
00D36:  DATA 79,73
00D38:  DATA 74,65
00D3A:  DATA 6D,0D
00D3C:  DATA 0A,00
00D3E:  DATA 61,70
00D40:  DATA 70,65
00D42:  DATA 6E,64
00D44:  DATA 3A,20
00D46:  DATA 46,53
00D48:  DATA 20,45
00D4A:  DATA 52,52
00D4C:  DATA 4F,52
00D4E:  DATA 20,6F
00D50:  DATA 6E,20
00D52:  DATA 66,69
00D54:  DATA 6C,65
00D56:  DATA 5F,6F
00D58:  DATA 70,65
00D5A:  DATA 6E,0D
00D5C:  DATA 0A,00
00D5E:  DATA 40,46
00D60:  DATA 53,3A
00D62:  DATA 57,72
00D64:  DATA 69,74
00D66:  DATA 69,6E
00D68:  DATA 67,0D
00D6A:  DATA 0A,5B
00D6C:  DATA 25,73
00D6E:  DATA 5D,0D
00D70:  DATA 0A,00
00D72:  DATA 40,46
00D74:  DATA 53,3A
00D76:  DATA 45,52
00D78:  DATA 52,4F
00D7A:  DATA 52,5B
00D7C:  DATA 61,70
00D7E:  DATA 70,65
00D80:  DATA 6E,64
00D82:  DATA 5D,0D
00D84:  DATA 0A,00
00D86:  DATA 40,46
00D88:  DATA 53,3A
00D8A:  DATA 43,6C
00D8C:  DATA 6F,73
00D8E:  DATA 69,6E
00D90:  DATA 67,0D
00D92:  DATA 0A,00
00D94:  DATA 40,52
00D96:  DATA 54,43
00D98:  DATA 3A,25
00D9A:  DATA 30,32
00D9C:  DATA 75,2F
00D9E:  DATA 00,00
00DA0:  DATA 40,52
00DA2:  DATA 54,43
00DA4:  DATA 3A,25
00DA6:  DATA 30,32
00DA8:  DATA 75,2F
00DAA:  DATA 00,00
00DAC:  DATA 40,41
00DAE:  DATA 4C,4D
00DB0:  DATA 3A,25
00DB2:  DATA 30,32
00DB4:  DATA 75,2F
00DB6:  DATA 00,00
00DB8:  DATA 40,41
00DBA:  DATA 4C,4D
00DBC:  DATA 3A,25
00DBE:  DATA 30,32
00DC0:  DATA 75,2F
00DC2:  DATA 00,00
00DC4:  DATA 74,65
00DC6:  DATA 73,74
00DC8:  DATA 36,3A
00DCA:  DATA 20,25
00DCC:  DATA 64,0D
00DCE:  DATA 0A,00
00DD0:  DATA 40,41
00DD2:  DATA 4C,4D
00DD4:  DATA 0D,0A
00DD6:  DATA 00,00
*
00E4E:  TBLRD*+
00E50:  MOVF   FF5,F
00E52:  BZ    0E76
00E54:  MOVFF  FF6,A14
00E58:  MOVFF  FF7,A15
00E5C:  MOVFF  FF8,A16
00E60:  MOVF   FF5,W
00E62:  BTFSS  F9E.4
00E64:  BRA    0E62
00E66:  MOVWF  FAD
00E68:  MOVFF  A14,FF6
00E6C:  MOVFF  A15,FF7
00E70:  MOVFF  A16,FF8
00E74:  BRA    0E4E
00E76:  RETURN 0
*
00ED8:  DATA 3F,40
00EDA:  DATA 42,53
00EDC:  DATA 59,0D
00EDE:  DATA 0A,00
00EE0:  DATA 40,52
00EE2:  DATA 44,59
00EE4:  DATA 0D,0A
00EE6:  DATA 00,00
*
00F28:  DATA 40,5B
00F2A:  DATA 4F,5D
00F2C:  DATA 0D,0A
00F2E:  DATA 00,00
00F30:  DATA 40,43
00F32:  DATA 4D,44
00F34:  DATA 20,74
00F36:  DATA 6F,6F
00F38:  DATA 20,6C
00F3A:  DATA 6F,6E
00F3C:  DATA 67,0D
00F3E:  DATA 0A,00
00F40:  DATA 40,5B
00F42:  DATA 43,5D
00F44:  DATA 0D,0A
00F46:  DATA 00,00
00F48:  DATA 40,53
00F4A:  DATA 4C,45
00F4C:  DATA 45,50
00F4E:  DATA 0D,0A
00F50:  DATA 00,00
00F52:  DATA 40,4D
00F54:  DATA 45,52
00F56:  DATA 2C,25
00F58:  DATA 4C,75
00F5A:  DATA 2C,25
00F5C:  DATA 4C,75
00F5E:  DATA 0D,0A
00F60:  DATA 00,00
00F62:  DATA 6D,3A
00F64:  DATA 25,75
00F66:  DATA 2C,25
00F68:  DATA 75,20
00F6A:  DATA 63,3A
00F6C:  DATA 25,4C
00F6E:  DATA 75,2C
00F70:  DATA 25,4C
00F72:  DATA 75,2C
00F74:  DATA 25,4C
00F76:  DATA 75,0D
00F78:  DATA 0A,00
00F7A:  MOVLB  A
00F7C:  MOVF   x1F,W
00F7E:  CLRF   01
00F80:  SUBWF  x1E,W
00F82:  BC    0F8A
00F84:  MOVFF  A1E,00
00F88:  BRA    0FA2
00F8A:  CLRF   00
00F8C:  MOVLW  08
00F8E:  MOVWF  x20
00F90:  RLCF   x1E,F
00F92:  RLCF   00,F
00F94:  MOVF   x1F,W
00F96:  SUBWF  00,W
00F98:  BTFSC  FD8.0
00F9A:  MOVWF  00
00F9C:  RLCF   01,F
00F9E:  DECFSZ x20,F
00FA0:  BRA    0F90
00FA2:  MOVLB  0
00FA4:  RETURN 0
00FA6:  MOVF   01,W
00FA8:  MOVFF  A1C,A1E
00FAC:  MOVLW  64
00FAE:  MOVLB  A
00FB0:  MOVWF  x1F
00FB2:  MOVLB  0
00FB4:  RCALL  0F7A
00FB6:  MOVFF  00,A1C
00FBA:  MOVF   01,W
00FBC:  MOVLW  30
00FBE:  BNZ   0FD0
00FC0:  MOVLB  A
00FC2:  BTFSS  x1D.1
00FC4:  BRA    0FE2
00FC6:  BTFSC  x1D.3
00FC8:  BRA    0FE2
00FCA:  BTFSC  x1D.4
00FCC:  MOVLW  20
00FCE:  BRA    0FD8
00FD0:  MOVLB  A
00FD2:  BCF    x1D.3
00FD4:  BCF    x1D.4
00FD6:  BSF    x1D.0
00FD8:  ADDWF  01,F
00FDA:  MOVF   01,W
00FDC:  BTFSS  F9E.4
00FDE:  BRA    0FDC
00FE0:  MOVWF  FAD
00FE2:  MOVFF  A1C,A1E
00FE6:  MOVLW  0A
00FE8:  MOVWF  x1F
00FEA:  MOVLB  0
00FEC:  RCALL  0F7A
00FEE:  MOVFF  00,A1C
00FF2:  MOVF   01,W
00FF4:  MOVLW  30
00FF6:  BNZ   1008
00FF8:  MOVLB  A
00FFA:  BTFSC  x1D.3
00FFC:  BRA    1014
00FFE:  BTFSS  x1D.0
01000:  BRA    1014
01002:  BTFSC  x1D.4
01004:  MOVLW  20
01006:  MOVLB  0
01008:  ADDWF  01,F
0100A:  MOVF   01,W
0100C:  BTFSS  F9E.4
0100E:  BRA    100C
01010:  MOVWF  FAD
01012:  MOVLB  A
01014:  MOVLW  30
01016:  ADDWF  x1C,F
01018:  MOVF   x1C,W
0101A:  BTFSS  F9E.4
0101C:  BRA    101A
0101E:  MOVWF  FAD
01020:  MOVLB  0
01022:  RETURN 0
01024:  TBLRD*+
01026:  MOVFF  FF6,A1D
0102A:  MOVFF  FF7,A1E
0102E:  MOVFF  FF8,A1F
01032:  MOVF   FF5,W
01034:  BTFSS  F9E.4
01036:  BRA    1034
01038:  MOVWF  FAD
0103A:  MOVFF  A1D,FF6
0103E:  MOVFF  A1E,FF7
01042:  MOVFF  A1F,FF8
01046:  MOVLB  A
01048:  DECFSZ x1C,F
0104A:  BRA    104E
0104C:  BRA    1052
0104E:  MOVLB  0
01050:  BRA    1024
01052:  MOVLB  0
01054:  RETURN 0
01056:  BTFSC  FD8.1
01058:  BRA    1062
0105A:  MOVLW  0A
0105C:  MOVWF  FEA
0105E:  MOVLW  30
01060:  MOVWF  FE9
01062:  CLRF   00
01064:  CLRF   01
01066:  CLRF   02
01068:  CLRF   03
0106A:  MOVLB  A
0106C:  CLRF   x30
0106E:  CLRF   x31
01070:  CLRF   x32
01072:  CLRF   x33
01074:  MOVF   x2F,W
01076:  IORWF  x2E,W
01078:  IORWF  x2D,W
0107A:  IORWF  x2C,W
0107C:  BZ    10D6
0107E:  MOVLW  20
01080:  MOVWF  x34
01082:  BCF    FD8.0
01084:  RLCF   x28,F
01086:  RLCF   x29,F
01088:  RLCF   x2A,F
0108A:  RLCF   x2B,F
0108C:  RLCF   x30,F
0108E:  RLCF   x31,F
01090:  RLCF   x32,F
01092:  RLCF   x33,F
01094:  MOVF   x2F,W
01096:  SUBWF  x33,W
01098:  BNZ   10AA
0109A:  MOVF   x2E,W
0109C:  SUBWF  x32,W
0109E:  BNZ   10AA
010A0:  MOVF   x2D,W
010A2:  SUBWF  x31,W
010A4:  BNZ   10AA
010A6:  MOVF   x2C,W
010A8:  SUBWF  x30,W
010AA:  BNC   10CA
010AC:  MOVF   x2C,W
010AE:  SUBWF  x30,F
010B0:  MOVF   x2D,W
010B2:  BTFSS  FD8.0
010B4:  INCFSZ x2D,W
010B6:  SUBWF  x31,F
010B8:  MOVF   x2E,W
010BA:  BTFSS  FD8.0
010BC:  INCFSZ x2E,W
010BE:  SUBWF  x32,F
010C0:  MOVF   x2F,W
010C2:  BTFSS  FD8.0
010C4:  INCFSZ x2F,W
010C6:  SUBWF  x33,F
010C8:  BSF    FD8.0
010CA:  RLCF   00,F
010CC:  RLCF   01,F
010CE:  RLCF   02,F
010D0:  RLCF   03,F
010D2:  DECFSZ x34,F
010D4:  BRA    1082
010D6:  MOVFF  A30,FEF
010DA:  MOVFF  A31,FEC
010DE:  MOVFF  A32,FEC
010E2:  MOVFF  A33,FEC
010E6:  MOVLB  0
010E8:  RETURN 0
010EA:  MOVF   FE9,W
010EC:  MOVLB  A
010EE:  MOVWF  x20
010F0:  MOVLW  3B
010F2:  MOVWF  x27
010F4:  MOVLW  9A
010F6:  MOVWF  x26
010F8:  MOVLW  CA
010FA:  MOVWF  x25
010FC:  CLRF   x24
010FE:  MOVLW  0A
01100:  MOVWF  x22
01102:  BSF    FD8.1
01104:  MOVLW  0A
01106:  MOVWF  FEA
01108:  MOVLW  1C
0110A:  MOVWF  FE9
0110C:  MOVFF  A1F,A2B
01110:  MOVFF  A1E,A2A
01114:  MOVFF  A1D,A29
01118:  MOVFF  A1C,A28
0111C:  MOVFF  A27,A2F
01120:  MOVFF  A26,A2E
01124:  MOVFF  A25,A2D
01128:  MOVFF  A24,A2C
0112C:  MOVLB  0
0112E:  RCALL  1056
01130:  MOVF   01,W
01132:  MOVF   00,F
01134:  BNZ   115C
01136:  MOVLB  A
01138:  MOVF   x22,W
0113A:  XORLW  01
0113C:  BTFSS  FD8.2
0113E:  BRA    1144
01140:  MOVLB  0
01142:  BRA    115C
01144:  MOVF   x20,W
01146:  BZ    1160
01148:  ANDLW  0F
0114A:  SUBWF  x22,W
0114C:  BZ    1150
0114E:  BC    116C
01150:  BTFSC  x20.7
01152:  BRA    116C
01154:  BTFSC  x20.6
01156:  BRA    1160
01158:  MOVLW  20
0115A:  BRA    1162
0115C:  MOVLB  A
0115E:  CLRF   x20
01160:  MOVLW  30
01162:  ADDWF  00,F
01164:  MOVF   00,W
01166:  BTFSS  F9E.4
01168:  BRA    1166
0116A:  MOVWF  FAD
0116C:  BCF    FD8.1
0116E:  MOVFF  A27,A2B
01172:  MOVFF  A26,A2A
01176:  MOVFF  A25,A29
0117A:  MOVFF  A24,A28
0117E:  CLRF   x2F
01180:  CLRF   x2E
01182:  CLRF   x2D
01184:  MOVLW  0A
01186:  MOVWF  x2C
01188:  MOVLB  0
0118A:  RCALL  1056
0118C:  MOVFF  03,A27
01190:  MOVFF  02,A26
01194:  MOVFF  01,A25
01198:  MOVFF  00,A24
0119C:  MOVLB  A
0119E:  DECFSZ x22,F
011A0:  BRA    1102
011A2:  MOVLB  0
011A4:  RETURN 0
011A6:  MOVFF  FEA,A24
011AA:  MOVFF  FE9,A23
011AE:  MOVLB  A
011B0:  SWAPF  x1D,W
011B2:  IORLW  F0
011B4:  MOVWF  x1F
011B6:  ADDWF  x1F,F
011B8:  ADDLW  E2
011BA:  MOVWF  x20
011BC:  ADDLW  32
011BE:  MOVWF  x22
011C0:  MOVF   x1D,W
011C2:  ANDLW  0F
011C4:  ADDWF  x20,F
011C6:  ADDWF  x20,F
011C8:  ADDWF  x22,F
011CA:  ADDLW  E9
011CC:  MOVWF  x21
011CE:  ADDWF  x21,F
011D0:  ADDWF  x21,F
011D2:  SWAPF  x1C,W
011D4:  ANDLW  0F
011D6:  ADDWF  x21,F
011D8:  ADDWF  x22,F
011DA:  RLCF   x21,F
011DC:  RLCF   x22,F
011DE:  COMF   x22,F
011E0:  RLCF   x22,F
011E2:  MOVF   x1C,W
011E4:  ANDLW  0F
011E6:  ADDWF  x22,F
011E8:  RLCF   x1F,F
011EA:  MOVLW  07
011EC:  MOVWF  x1E
011EE:  MOVLW  0A
011F0:  DECF   x21,F
011F2:  ADDWF  x22,F
011F4:  BNC   11F0
011F6:  DECF   x20,F
011F8:  ADDWF  x21,F
011FA:  BNC   11F6
011FC:  DECF   x1F,F
011FE:  ADDWF  x20,F
01200:  BNC   11FC
01202:  DECF   x1E,F
01204:  ADDWF  x1F,F
01206:  BNC   1202
01208:  MOVLW  0A
0120A:  MOVWF  FEA
0120C:  MOVLW  1E
0120E:  MOVWF  FE9
01210:  MOVLW  07
01212:  ANDWF  x23,W
01214:  BCF    x23.6
01216:  ADDWF  FE9,F
01218:  MOVLW  00
0121A:  ADDWFC FEA,F
0121C:  MOVF   FE9,W
0121E:  SUBLW  22
01220:  BNZ   122A
01222:  MOVF   FEA,W
01224:  SUBLW  0A
01226:  BNZ   122A
01228:  BSF    x23.6
0122A:  MOVF   FEF,W
0122C:  MOVWF  00
0122E:  BNZ   1240
01230:  BTFSC  x23.6
01232:  BRA    1240
01234:  BTFSC  x23.4
01236:  BRA    1250
01238:  BTFSC  x23.3
0123A:  BRA    1240
0123C:  MOVLW  20
0123E:  BRA    1246
01240:  BSF    x23.3
01242:  BCF    x23.4
01244:  MOVLW  30
01246:  ADDWF  00,F
01248:  MOVF   00,W
0124A:  BTFSS  F9E.4
0124C:  BRA    124A
0124E:  MOVWF  FAD
01250:  MOVF   FEE,W
01252:  BTFSS  x23.6
01254:  BRA    121C
01256:  MOVLB  0
01258:  RETURN 0
*
01A5E:  DATA 40,4C
01A60:  DATA 50,43
01A62:  DATA 2C,25
01A64:  DATA 4C,75
01A66:  DATA 2C,25
01A68:  DATA 4C,64
01A6A:  DATA 0D,0A
01A6C:  DATA 00,00
01A6E:  DATA 40,4D
01A70:  DATA 4D,45
01A72:  DATA 2C,25
01A74:  DATA 75,2C
01A76:  DATA 25,4C
01A78:  DATA 64,2C
01A7A:  DATA 25,4C
01A7C:  DATA 75,2C
01A7E:  DATA 25,4C
01A80:  DATA 75,2C
01A82:  DATA 25,4C
01A84:  DATA 64,2C
01A86:  DATA 25,4C
01A88:  DATA 64,0D
01A8A:  DATA 0A,00
01A8C:  DATA 56,41
01A8E:  DATA 4C,56
01A90:  DATA 45,20
01A92:  DATA 53,54
01A94:  DATA 4F,50
01A96:  DATA 20,25
01A98:  DATA 4C,75
01A9A:  DATA 2C,25
01A9C:  DATA 4C,75
01A9E:  DATA 0D,0A
01AA0:  DATA 00,00
01AA2:  DATA 69,6E
01AA4:  DATA 64,3A
01AA6:  DATA 25,75
01AA8:  DATA 20,2F
01AAA:  DATA 20,70
01AAC:  DATA 68,61
01AAE:  DATA 3A,25
01AB0:  DATA 75,0D
01AB2:  DATA 0A,00
01AB4:  DATA 40,52
01AB6:  DATA 45,43
01AB8:  DATA 20,2D
01ABA:  DATA 20,68
01ABC:  DATA 6F,6D
01ABE:  DATA 69,6E
01AC0:  DATA 67,20
01AC2:  DATA 73,79
01AC4:  DATA 72,69
01AC6:  DATA 6E,67
01AC8:  DATA 65,20
01ACA:  DATA 61,6E
01ACC:  DATA 64,20
01ACE:  DATA 61,6C
01AD0:  DATA 69,67
01AD2:  DATA 6E,69
01AD4:  DATA 6E,67
01AD6:  DATA 20,76
01AD8:  DATA 61,6C
01ADA:  DATA 76,65
01ADC:  DATA 20,74
01ADE:  DATA 6F,20
01AE0:  DATA 70,6F
01AE2:  DATA 72,74
01AE4:  DATA 20,31
01AE6:  DATA 0D,0A
01AE8:  DATA 00,00
01AEA:  DATA 2C,73
01AEC:  DATA 65,72
01AEE:  DATA 69,61
01AF0:  DATA 6C,20
01AF2:  DATA 77,61
01AF4:  DATA 6B,65
01AF6:  DATA 2D,75
01AF8:  DATA 70,2C
01AFA:  DATA 53,44
01AFC:  DATA 20,69
01AFE:  DATA 6E,69
01B00:  DATA 74,69
01B02:  DATA 61,6C
01B04:  DATA 69,7A
01B06:  DATA 65,64
01B08:  DATA 0D,0A
01B0A:  DATA 00,00
01B0C:  DATA 40,52
01B0E:  DATA 53,54
01B10:  DATA 0D,0A
01B12:  DATA 00,00
01B14:  DATA 40,57
01B16:  DATA 44,54
01B18:  DATA 0D,0A
01B1A:  DATA 00,00
01B1C:  DATA 2C,72
01B1E:  DATA 65,73
01B20:  DATA 74,61
01B22:  DATA 72,74
01B24:  DATA 20,63
01B26:  DATA 61,75
01B28:  DATA 73,65
01B2A:  DATA 2C,57
01B2C:  DATA 44,20
01B2E:  DATA 74,69
01B30:  DATA 6D,65
01B32:  DATA 2D,6F
01B34:  DATA 75,74
01B36:  DATA 0D,0A
01B38:  DATA 00,00
01B3A:  DATA 40,57
01B3C:  DATA 44,53
01B3E:  DATA 0D,0A
01B40:  DATA 00,00
01B42:  DATA 2C,72
01B44:  DATA 65,73
01B46:  DATA 74,61
01B48:  DATA 72,74
01B4A:  DATA 20,63
01B4C:  DATA 61,75
01B4E:  DATA 73,65
01B50:  DATA 2C,57
01B52:  DATA 44,20
01B54:  DATA 66,72
01B56:  DATA 6F,6D
01B58:  DATA 20,73
01B5A:  DATA 6C,65
01B5C:  DATA 65,70
01B5E:  DATA 0D,0A
01B60:  DATA 00,00
01B62:  DATA 40,4E
01B64:  DATA 50,55
01B66:  DATA 0D,0A
01B68:  DATA 00,00
01B6A:  DATA 2C,69
01B6C:  DATA 64,23
01B6E:  DATA 5B,25
01B70:  DATA 4C,75
01B72:  DATA 5D,2C
01B74:  DATA 70,6F
01B76:  DATA 77,65
01B78:  DATA 72,20
01B7A:  DATA 61,70
01B7C:  DATA 70,6C
01B7E:  DATA 69,65
01B80:  DATA 64,2C
01B82:  DATA 53,44
01B84:  DATA 20,69
01B86:  DATA 6E,69
01B88:  DATA 74,69
01B8A:  DATA 61,6C
01B8C:  DATA 69,7A
01B8E:  DATA 65,64
01B90:  DATA 0D,0A
01B92:  DATA 00,00
01B94:  DATA 40,52
01B96:  DATA 53,54
01B98:  DATA 0D,0A
01B9A:  DATA 00,00
01B9C:  DATA 2C,72
01B9E:  DATA 65,73
01BA0:  DATA 74,61
01BA2:  DATA 72,74
01BA4:  DATA 20,63
01BA6:  DATA 61,75
01BA8:  DATA 73,65
01BAA:  DATA 2C,72
01BAC:  DATA 65,73
01BAE:  DATA 65,74
01BB0:  DATA 20,69
01BB2:  DATA 6E,73
01BB4:  DATA 74,72
01BB6:  DATA 75,63
01BB8:  DATA 74,69
01BBA:  DATA 6F,6E
01BBC:  DATA 0D,0A
01BBE:  DATA 00,00
01BC0:  DATA 40,42
01BC2:  DATA 4F,52
01BC4:  DATA 0D,0A
01BC6:  DATA 00,00
01BC8:  DATA 2C,72
01BCA:  DATA 65,73
01BCC:  DATA 74,61
01BCE:  DATA 72,74
01BD0:  DATA 20,63
01BD2:  DATA 61,75
01BD4:  DATA 73,65
01BD6:  DATA 2C,62
01BD8:  DATA 72,6F
01BDA:  DATA 77,6E
01BDC:  DATA 2D,6F
01BDE:  DATA 75,74
01BE0:  DATA 0D,0A
01BE2:  DATA 00,00
01BE4:  DATA 40,4D
01BE6:  DATA 52,53
01BE8:  DATA 0D,0A
01BEA:  DATA 00,00
01BEC:  DATA 2C,72
01BEE:  DATA 65,73
01BF0:  DATA 74,61
01BF2:  DATA 72,74
01BF4:  DATA 20,63
01BF6:  DATA 61,75
01BF8:  DATA 73,65
01BFA:  DATA 2C,4D
01BFC:  DATA 43,4C
01BFE:  DATA 52,20
01C00:  DATA 66,72
01C02:  DATA 6F,6D
01C04:  DATA 20,73
01C06:  DATA 6C,65
01C08:  DATA 65,70
01C0A:  DATA 0D,0A
01C0C:  DATA 00,00
01C0E:  DATA 40,4D
01C10:  DATA 52,52
01C12:  DATA 0D,0A
01C14:  DATA 00,00
01C16:  DATA 2C,72
01C18:  DATA 65,73
01C1A:  DATA 74,61
01C1C:  DATA 72,74
01C1E:  DATA 20,63
01C20:  DATA 61,75
01C22:  DATA 73,65
01C24:  DATA 2C,4D
01C26:  DATA 43,4C
01C28:  DATA 52,20
01C2A:  DATA 77,68
01C2C:  DATA 65,6E
01C2E:  DATA 20,72
01C30:  DATA 75,6E
01C32:  DATA 6E,69
01C34:  DATA 6E,67
01C36:  DATA 0D,0A
01C38:  DATA 00,00
01C3A:  DATA 4E,4F
01C3C:  DATA 33,00
01C3E:  DATA 4E,4F
01C40:  DATA 32,00
01C42:  DATA 50,4F
01C44:  DATA 34,00
01C46:  DATA 4E,48
01C48:  DATA 34,00
01C4A:  DATA 53,69
01C4C:  DATA 4F,00
01C4E:  DATA 00,00
01C50:  DATA 40,44
01C52:  DATA 45,54
01C54:  DATA 5B,2F
01C56:  DATA 25,75
01C58:  DATA 5D,5B
01C5A:  DATA 25,63
01C5C:  DATA 5D,41
01C5E:  DATA 52,47
01C60:  DATA 5B,25
01C62:  DATA 4C,75
01C64:  DATA 5D,0D
01C66:  DATA 0A,00
01C68:  DATA 20,74
01C6A:  DATA 69,6D
01C6C:  DATA 65,2D
01C6E:  DATA 6F,75
01C70:  DATA 74,00
01C72:  DATA 20,64
01C74:  DATA 61,74
01C76:  DATA 61,20
01C78:  DATA 74,6F
01C7A:  DATA 6F,20
01C7C:  DATA 73,68
01C7E:  DATA 6F,72
01C80:  DATA 74,00
01C82:  DATA 20,64
01C84:  DATA 61,74
01C86:  DATA 61,20
01C88:  DATA 74,6F
01C8A:  DATA 6F,20
01C8C:  DATA 6C,6F
01C8E:  DATA 6E,67
01C90:  DATA 00,00
01C92:  DATA 2C,64
01C94:  DATA 65,74
01C96:  DATA 65,63
01C98:  DATA 74,6F
01C9A:  DATA 72,5B
01C9C:  DATA 25,73
01C9E:  DATA 5D,2C
01CA0:  DATA 6C,65
01CA2:  DATA 6E,5B
01CA4:  DATA 25,75
01CA6:  DATA 5D,00
01CA8:  DATA 40,52
01CAA:  DATA 54,59
01CAC:  DATA 2C,25
01CAE:  DATA 75,0D
01CB0:  DATA 0A,00
01CB2:  DATA 2C,73
01CB4:  DATA 74,61
01CB6:  DATA 72,74
01CB8:  DATA 20,68
01CBA:  DATA 65,61
01CBC:  DATA 74,69
01CBE:  DATA 6E,67
01CC0:  DATA 2C,74
01CC2:  DATA 61,72
01CC4:  DATA 67,65
01CC6:  DATA 74,5B
01CC8:  DATA 25,4C
01CCA:  DATA 75,5D
01CCC:  DATA 2C,61
01CCE:  DATA 63,74
01CD0:  DATA 75,61
01CD2:  DATA 6C,5B
01CD4:  DATA 25,4C
01CD6:  DATA 75,5D
01CD8:  DATA 2C,72
01CDA:  DATA 65,61
01CDC:  DATA 64,69
01CDE:  DATA 6E,67
01CE0:  DATA 73,5B
01CE2:  DATA 25,4C
01CE4:  DATA 75,5D
01CE6:  DATA 0D,0A
01CE8:  DATA 00,00
01CEA:  DATA 2C,65
01CEC:  DATA 6E,64
01CEE:  DATA 20,68
01CF0:  DATA 65,61
01CF2:  DATA 74,69
01CF4:  DATA 6E,67
01CF6:  DATA 2C,74
01CF8:  DATA 61,72
01CFA:  DATA 67,65
01CFC:  DATA 74,5B
01CFE:  DATA 25,4C
01D00:  DATA 75,5D
01D02:  DATA 2C,61
01D04:  DATA 63,74
01D06:  DATA 75,61
01D08:  DATA 6C,5B
01D0A:  DATA 25,4C
01D0C:  DATA 75,5D
01D0E:  DATA 2C,72
01D10:  DATA 65,61
01D12:  DATA 64,69
01D14:  DATA 6E,67
01D16:  DATA 73,5B
01D18:  DATA 25,4C
01D1A:  DATA 75,5D
01D1C:  DATA 0D,0A
01D1E:  DATA 00,00
01D20:  DATA 4E,4F
01D22:  DATA 33,00
01D24:  DATA 4E,4F
01D26:  DATA 32,00
01D28:  DATA 50,4F
01D2A:  DATA 34,00
01D2C:  DATA 4E,48
01D2E:  DATA 34,00
01D30:  DATA 53,69
01D32:  DATA 4F,00
01D34:  DATA 00,00
01D36:  DATA 40,44
01D38:  DATA 41,43
01D3A:  DATA 2C,25
01D3C:  DATA 4C,75
01D3E:  DATA 2C,25
01D40:  DATA 4C,75
01D42:  DATA 2C,00
01D44:  DATA 40,53
01D46:  DATA 41,52
01D48:  DATA 2C,31
01D4A:  DATA 2C,25
01D4C:  DATA 4C,75
01D4E:  DATA 2C,00
01D50:  DATA 40,56
01D52:  DATA 41,4C
01D54:  DATA 20,00
01D56:  DATA 40,56
01D58:  DATA 41,4C
01D5A:  DATA 20,00
01D5C:  DATA 40,56
01D5E:  DATA 41,4C
01D60:  DATA 20,00
01D62:  DATA 40,56
01D64:  DATA 41,4C
01D66:  DATA 20,00
01D68:  DATA 40,53
01D6A:  DATA 4F,4C
01D6C:  DATA 5B,2F
01D6E:  DATA 31,5D
01D70:  DATA 5B,73
01D72:  DATA 5D,5B
01D74:  DATA 25,4C
01D76:  DATA 75,5D
01D78:  DATA 0D,0A
01D7A:  DATA 00,00
01D7C:  DATA 2F,31
01D7E:  DATA 73,25
01D80:  DATA 4C,75
01D82:  DATA 0D,00
01D84:  DATA 40,53
01D86:  DATA 4F,4C
01D88:  DATA 5B,2F
01D8A:  DATA 31,5D
01D8C:  DATA 5B,63
01D8E:  DATA 5D,5B
01D90:  DATA 25,75
01D92:  DATA 5D,0D
01D94:  DATA 0A,00
01D96:  DATA 2F,31
01D98:  DATA 63,25
01D9A:  DATA 75,0D
01D9C:  DATA 00,00
01D9E:  DATA 2F,31
01DA0:  DATA 73,32
01DA2:  DATA 35,36
01DA4:  DATA 0D,00
01DA6:  DATA 28,49
01DA8:  DATA 30,73
01DAA:  DATA 29,2C
01DAC:  DATA 25,4C
01DAE:  DATA 75,2C
01DB0:  DATA 28,49
01DB2:  DATA 31,73
01DB4:  DATA 29,2C
01DB6:  DATA 25,4C
01DB8:  DATA 75,2C
01DBA:  DATA 28,41
01DBC:  DATA 62,73
01DBE:  DATA 2D,73
01DC0:  DATA 29,2C
01DC2:  DATA 25,31
01DC4:  DATA 2E,34
01DC6:  DATA 67,2C
01DC8:  DATA 28,49
01DCA:  DATA 30,74
01DCC:  DATA 29,2C
01DCE:  DATA 25,4C
01DD0:  DATA 75,2C
01DD2:  DATA 28,49
01DD4:  DATA 31,74
01DD6:  DATA 29,2C
01DD8:  DATA 25,4C
01DDA:  DATA 75,2C
01DDC:  DATA 28,41
01DDE:  DATA 62,73
01DE0:  DATA 2D,74
01DE2:  DATA 29,2C
01DE4:  DATA 25,31
01DE6:  DATA 2E,34
01DE8:  DATA 67,2C
01DEA:  DATA 28,49
01DEC:  DATA 30,72
01DEE:  DATA 29,2C
01DF0:  DATA 25,4C
01DF2:  DATA 75,2C
01DF4:  DATA 28,49
01DF6:  DATA 31,72
01DF8:  DATA 29,2C
01DFA:  DATA 25,4C
01DFC:  DATA 75,2C
01DFE:  DATA 28,41
01E00:  DATA 62,73
01E02:  DATA 2D,72
01E04:  DATA 29,2C
01E06:  DATA 25,31
01E08:  DATA 2E,34
01E0A:  DATA 67,00
01E0C:  DATA 40,41
01E0E:  DATA 62,73
01E10:  DATA 2C,4E
01E12:  DATA 4F,33
01E14:  DATA 2C,25
01E16:  DATA 73,0D
01E18:  DATA 0A,00
01E1A:  DATA 28,49
01E1C:  DATA 30,73
01E1E:  DATA 29,2C
01E20:  DATA 25,4C
01E22:  DATA 75,2C
01E24:  DATA 28,49
01E26:  DATA 31,73
01E28:  DATA 29,2C
01E2A:  DATA 25,4C
01E2C:  DATA 75,2C
01E2E:  DATA 28,41
01E30:  DATA 62,73
01E32:  DATA 2D,73
01E34:  DATA 29,2C
01E36:  DATA 25,31
01E38:  DATA 2E,34
01E3A:  DATA 67,2C
01E3C:  DATA 28,49
01E3E:  DATA 30,74
01E40:  DATA 29,2C
01E42:  DATA 25,4C
01E44:  DATA 75,2C
01E46:  DATA 28,49
01E48:  DATA 31,74
01E4A:  DATA 29,2C
01E4C:  DATA 25,4C
01E4E:  DATA 75,2C
01E50:  DATA 28,41
01E52:  DATA 62,73
01E54:  DATA 2D,74
01E56:  DATA 29,2C
01E58:  DATA 25,31
01E5A:  DATA 2E,34
01E5C:  DATA 67,2C
01E5E:  DATA 28,49
01E60:  DATA 30,72
01E62:  DATA 29,2C
01E64:  DATA 25,4C
01E66:  DATA 75,2C
01E68:  DATA 28,49
01E6A:  DATA 31,72
01E6C:  DATA 29,2C
01E6E:  DATA 25,4C
01E70:  DATA 75,2C
01E72:  DATA 28,41
01E74:  DATA 62,73
01E76:  DATA 2D,72
01E78:  DATA 29,2C
01E7A:  DATA 25,31
01E7C:  DATA 2E,34
01E7E:  DATA 67,00
01E80:  DATA 40,41
01E82:  DATA 62,73
01E84:  DATA 2C,4E
01E86:  DATA 4F,32
01E88:  DATA 2C,25
01E8A:  DATA 73,0D
01E8C:  DATA 0A,00
01E8E:  DATA 28,49
01E90:  DATA 30,73
01E92:  DATA 29,2C
01E94:  DATA 25,4C
01E96:  DATA 75,2C
01E98:  DATA 28,49
01E9A:  DATA 31,73
01E9C:  DATA 29,2C
01E9E:  DATA 25,4C
01EA0:  DATA 75,2C
01EA2:  DATA 28,41
01EA4:  DATA 62,73
01EA6:  DATA 2D,73
01EA8:  DATA 29,2C
01EAA:  DATA 25,31
01EAC:  DATA 2E,34
01EAE:  DATA 67,2C
01EB0:  DATA 28,49
01EB2:  DATA 30,74
01EB4:  DATA 29,2C
01EB6:  DATA 25,4C
01EB8:  DATA 75,2C
01EBA:  DATA 28,49
01EBC:  DATA 31,74
01EBE:  DATA 29,2C
01EC0:  DATA 25,4C
01EC2:  DATA 75,2C
01EC4:  DATA 28,41
01EC6:  DATA 62,73
01EC8:  DATA 2D,74
01ECA:  DATA 29,2C
01ECC:  DATA 25,31
01ECE:  DATA 2E,34
01ED0:  DATA 67,2C
01ED2:  DATA 28,49
01ED4:  DATA 30,72
01ED6:  DATA 29,2C
01ED8:  DATA 25,4C
01EDA:  DATA 75,2C
01EDC:  DATA 28,49
01EDE:  DATA 31,72
01EE0:  DATA 29,2C
01EE2:  DATA 25,4C
01EE4:  DATA 75,2C
01EE6:  DATA 28,41
01EE8:  DATA 62,73
01EEA:  DATA 2D,72
01EEC:  DATA 29,2C
01EEE:  DATA 25,31
01EF0:  DATA 2E,34
01EF2:  DATA 67,00
01EF4:  DATA 40,41
01EF6:  DATA 62,73
01EF8:  DATA 2C,50
01EFA:  DATA 4F,34
01EFC:  DATA 2C,25
01EFE:  DATA 73,0D
01F00:  DATA 0A,00
01F02:  DATA 28,49
01F04:  DATA 30,73
01F06:  DATA 29,2C
01F08:  DATA 25,4C
01F0A:  DATA 75,2C
01F0C:  DATA 28,49
01F0E:  DATA 31,73
01F10:  DATA 29,2C
01F12:  DATA 25,4C
01F14:  DATA 75,2C
01F16:  DATA 28,41
01F18:  DATA 62,73
01F1A:  DATA 2D,73
01F1C:  DATA 29,2C
01F1E:  DATA 25,31
01F20:  DATA 2E,34
01F22:  DATA 67,2C
01F24:  DATA 28,49
01F26:  DATA 30,74
01F28:  DATA 29,2C
01F2A:  DATA 25,4C
01F2C:  DATA 75,2C
01F2E:  DATA 28,49
01F30:  DATA 31,74
01F32:  DATA 29,2C
01F34:  DATA 25,4C
01F36:  DATA 75,2C
01F38:  DATA 28,41
01F3A:  DATA 62,73
01F3C:  DATA 2D,74
01F3E:  DATA 29,2C
01F40:  DATA 25,31
01F42:  DATA 2E,34
01F44:  DATA 67,2C
01F46:  DATA 28,49
01F48:  DATA 30,72
01F4A:  DATA 29,2C
01F4C:  DATA 25,4C
01F4E:  DATA 75,2C
01F50:  DATA 28,49
01F52:  DATA 31,72
01F54:  DATA 29,2C
01F56:  DATA 25,4C
01F58:  DATA 75,2C
01F5A:  DATA 28,41
01F5C:  DATA 62,73
01F5E:  DATA 2D,72
01F60:  DATA 29,2C
01F62:  DATA 25,31
01F64:  DATA 2E,34
01F66:  DATA 67,00
01F68:  DATA 40,41
01F6A:  DATA 62,73
01F6C:  DATA 2C,4E
01F6E:  DATA 48,34
01F70:  DATA 2C,25
01F72:  DATA 73,0D
01F74:  DATA 0A,00
01F76:  DATA 28,49
01F78:  DATA 30,73
01F7A:  DATA 29,2C
01F7C:  DATA 25,4C
01F7E:  DATA 75,2C
01F80:  DATA 28,49
01F82:  DATA 31,73
01F84:  DATA 29,2C
01F86:  DATA 25,4C
01F88:  DATA 75,2C
01F8A:  DATA 28,41
01F8C:  DATA 62,73
01F8E:  DATA 2D,73
01F90:  DATA 29,2C
01F92:  DATA 25,31
01F94:  DATA 2E,34
01F96:  DATA 67,2C
01F98:  DATA 28,49
01F9A:  DATA 30,74
01F9C:  DATA 29,2C
01F9E:  DATA 25,4C
01FA0:  DATA 75,2C
01FA2:  DATA 28,49
01FA4:  DATA 31,74
01FA6:  DATA 29,2C
01FA8:  DATA 25,4C
01FAA:  DATA 75,2C
01FAC:  DATA 28,41
01FAE:  DATA 62,73
01FB0:  DATA 2D,74
01FB2:  DATA 29,2C
01FB4:  DATA 25,31
01FB6:  DATA 2E,34
01FB8:  DATA 67,2C
01FBA:  DATA 28,49
01FBC:  DATA 30,72
01FBE:  DATA 29,2C
01FC0:  DATA 25,4C
01FC2:  DATA 75,2C
01FC4:  DATA 28,49
01FC6:  DATA 31,72
01FC8:  DATA 29,2C
01FCA:  DATA 25,4C
01FCC:  DATA 75,2C
01FCE:  DATA 28,41
01FD0:  DATA 62,73
01FD2:  DATA 2D,72
01FD4:  DATA 29,2C
01FD6:  DATA 25,31
01FD8:  DATA 2E,34
01FDA:  DATA 67,00
01FDC:  DATA 40,41
01FDE:  DATA 42,53
01FE0:  DATA 2C,53
01FE2:  DATA 69,4F
01FE4:  DATA 2C,25
01FE6:  DATA 73,0D
01FE8:  DATA 0A,00
01FEA:  DATA 4E,4F
01FEC:  DATA 33,00
01FEE:  DATA 4E,4F
01FF0:  DATA 32,00
01FF2:  DATA 50,4F
01FF4:  DATA 34,00
01FF6:  DATA 4E,48
01FF8:  DATA 34,00
01FFA:  DATA 53,69
01FFC:  DATA 4F,00
01FFE:  DATA 00,00
02000:  DATA 28,6D
02002:  DATA 29,2C
02004:  DATA 25,33
02006:  DATA 2E,33
02008:  DATA 67,2C
0200A:  DATA 28,63
0200C:  DATA 29,2C
0200E:  DATA 25,33
02010:  DATA 2E,33
02012:  DATA 67,00
02014:  DATA 28,43
02016:  DATA 73,29
02018:  DATA 2C,25
0201A:  DATA 33,2E
0201C:  DATA 33,67
0201E:  DATA 0D,0A
02020:  DATA 00,00
02022:  DATA 40,43
02024:  DATA 4F,4E
02026:  DATA 2C,4E
02028:  DATA 4F,33
0202A:  DATA 2C,25
0202C:  DATA 73,0D
0202E:  DATA 0A,00
02030:  DATA 28,6D
02032:  DATA 29,2C
02034:  DATA 25,33
02036:  DATA 2E,33
02038:  DATA 67,2C
0203A:  DATA 28,63
0203C:  DATA 29,2C
0203E:  DATA 25,33
02040:  DATA 2E,33
02042:  DATA 67,00
02044:  DATA 28,43
02046:  DATA 73,29
02048:  DATA 2C,25
0204A:  DATA 33,2E
0204C:  DATA 33,67
0204E:  DATA 0D,0A
02050:  DATA 00,00
02052:  DATA 40,43
02054:  DATA 4F,4E
02056:  DATA 2C,50
02058:  DATA 4F,34
0205A:  DATA 2C,25
0205C:  DATA 73,0D
0205E:  DATA 0A,00
02060:  DATA 28,6D
02062:  DATA 29,2C
02064:  DATA 25,33
02066:  DATA 2E,33
02068:  DATA 67,2C
0206A:  DATA 28,63
0206C:  DATA 29,2C
0206E:  DATA 25,33
02070:  DATA 2E,33
02072:  DATA 67,00
02074:  DATA 28,43
02076:  DATA 73,29
02078:  DATA 2C,25
0207A:  DATA 33,2E
0207C:  DATA 33,67
0207E:  DATA 0D,0A
02080:  DATA 00,00
02082:  DATA 40,43
02084:  DATA 4F,4E
02086:  DATA 2C,4E
02088:  DATA 48,34
0208A:  DATA 2C,25
0208C:  DATA 73,0D
0208E:  DATA 0A,00
02090:  DATA 28,6D
02092:  DATA 29,2C
02094:  DATA 25,33
02096:  DATA 2E,33
02098:  DATA 67,2C
0209A:  DATA 28,63
0209C:  DATA 29,2C
0209E:  DATA 25,33
020A0:  DATA 2E,33
020A2:  DATA 67,00
020A4:  DATA 28,43
020A6:  DATA 73,29
020A8:  DATA 2C,25
020AA:  DATA 33,2E
020AC:  DATA 33,67
020AE:  DATA 0D,0A
020B0:  DATA 00,00
020B2:  DATA 40,43
020B4:  DATA 4F,4E
020B6:  DATA 2C,53
020B8:  DATA 69,4F
020BA:  DATA 2C,25
020BC:  DATA 73,0D
020BE:  DATA 0A,00
020C0:  DATA 4E,4F
020C2:  DATA 33,00
020C4:  DATA 50,4F
020C6:  DATA 34,00
020C8:  DATA 4E,48
020CA:  DATA 34,00
020CC:  DATA 53,69
020CE:  DATA 4F,00
020D0:  DATA 00,00
020D2:  DATA 4D,45
020D4:  DATA 4D,4F
020D6:  DATA 52,59
020D8:  DATA 20,4F
020DA:  DATA 56,45
020DC:  DATA 52,46
020DE:  DATA 4C,4F
020E0:  DATA 57,20
020E2:  DATA 45,52
020E4:  DATA 52,4F
020E6:  DATA 52,20
020E8:  DATA 40,20
020EA:  DATA 4C,69
020EC:  DATA 6E,65
020EE:  DATA 20,3A
020F0:  DATA 25,4C
020F2:  DATA 75,0A
020F4:  DATA 0D,00
020F6:  DATA 0D,0A
020F8:  DATA 3A,00
020FA:  DATA 0D,0A
020FC:  DATA 57,41
020FE:  DATA 52,4E
02100:  DATA 49,4E
02102:  DATA 47,3A
02104:  DATA 20,49
02106:  DATA 4E,56
02108:  DATA 41,4C
0210A:  DATA 49,44
0210C:  DATA 20,43
0210E:  DATA 4F,4D
02110:  DATA 4D,41
02112:  DATA 4E,44
02114:  DATA 20,49
02116:  DATA 4E,20
02118:  DATA 4D,41
0211A:  DATA 43,52
0211C:  DATA 4F,21
0211E:  DATA 0D,0A
02120:  DATA 00,00
02122:  DATA 42,61
02124:  DATA 64,20
02126:  DATA 63,6F
02128:  DATA 6D,6D
0212A:  DATA 61,6E
0212C:  DATA 64,20
0212E:  DATA 61,74
02130:  DATA 20,6C
02132:  DATA 69,6E
02134:  DATA 65,3A
02136:  DATA 20,25
02138:  DATA 4C,64
0213A:  DATA 20,0D
0213C:  DATA 0A,00
0213E:  DATA 50,6C
02140:  DATA 65,61
02142:  DATA 73,65
02144:  DATA 20,72
02146:  DATA 65,2D
02148:  DATA 75,70
0214A:  DATA 6C,6F
0214C:  DATA 61,64
0214E:  DATA 20,6D
02150:  DATA 61,63
02152:  DATA 72,6F
02154:  DATA 00,00
02156:  DATA 49,74
02158:  DATA 65,72
0215A:  DATA 61,74
0215C:  DATA 69,6F
0215E:  DATA 6E,73
02160:  DATA 20,6C
02162:  DATA 65,66
02164:  DATA 74,3A
02166:  DATA 20,25
02168:  DATA 4C,75
0216A:  DATA 0D,0A
0216C:  DATA 00,00
0216E:  DATA 2C,6D
02170:  DATA 61,63
02172:  DATA 72,6F
02174:  DATA 5B,25
02176:  DATA 75,5D
02178:  DATA 2C,73
0217A:  DATA 74,61
0217C:  DATA 72,74
0217E:  DATA 0D,0A
02180:  DATA 00,00
02182:  DATA 40,4D
02184:  DATA 43,4C
02186:  DATA 5B,25
02188:  DATA 63,5D
0218A:  DATA 5B,25
0218C:  DATA 4C,75
0218E:  DATA 5D,0D
02190:  DATA 0A,00
02192:  DATA 40,4C
02194:  DATA 4E,45
02196:  DATA 0D,0A
02198:  DATA 00,00
0219A:  DATA 40,52
0219C:  DATA 55,4E
0219E:  DATA 0D,0A
021A0:  DATA 00,00
021A2:  DATA 40,42
021A4:  DATA 41,44
021A6:  DATA 0D,0A
021A8:  DATA 00,00
021AA:  DATA 40,54
021AC:  DATA 2F,4F
021AE:  DATA 0D,0A
021B0:  DATA 00,00
021B2:  DATA 40,45
021B4:  DATA 52,52
021B6:  DATA 0D,0A
021B8:  DATA 00,00
021BA:  DATA 40,45
021BC:  DATA 4E,44
021BE:  DATA 0D,0A
021C0:  DATA 00,00
021C2:  DATA 40,48
021C4:  DATA 4C,54
021C6:  DATA 0D,0A
021C8:  DATA 00,00
021CA:  DATA 2C,6D
021CC:  DATA 61,63
021CE:  DATA 72,6F
021D0:  DATA 5B,25
021D2:  DATA 75,5D
021D4:  DATA 2C,73
021D6:  DATA 74,61
021D8:  DATA 74,75
021DA:  DATA 73,5B
021DC:  DATA 25,63
021DE:  DATA 5D,2C
021E0:  DATA 6C,69
021E2:  DATA 6E,65
021E4:  DATA 5B,25
021E6:  DATA 4C,75
021E8:  DATA 5D,0D
021EA:  DATA 0A,00
021EC:  DATA 40,52
021EE:  DATA 75,6E
021F0:  DATA 6E,69
021F2:  DATA 6E,67
021F4:  DATA 20,25
021F6:  DATA 63,25
021F8:  DATA 4C,75
021FA:  DATA 20,0D
021FC:  DATA 0A,00
021FE:  DATA 40,4D
02200:  DATA 61,63
02202:  DATA 72,6F
02204:  DATA 20,25
02206:  DATA 30,34
02208:  DATA 4C,75
0220A:  DATA 20,6F
0220C:  DATA 66,20
0220E:  DATA 25,30
02210:  DATA 34,4C
02212:  DATA 75,0D
02214:  DATA 0A,00
02216:  DATA 40,4C
02218:  DATA 4E,45
0221A:  DATA 0D,0A
0221C:  DATA 00,00
0221E:  DATA 40,52
02220:  DATA 55,4E
02222:  DATA 0D,0A
02224:  DATA 00,00
02226:  DATA 40,42
02228:  DATA 41,44
0222A:  DATA 0D,0A
0222C:  DATA 00,00
0222E:  DATA 40,54
02230:  DATA 2F,4F
02232:  DATA 0D,0A
02234:  DATA 00,00
02236:  DATA 40,45
02238:  DATA 52,52
0223A:  DATA 0D,0A
0223C:  DATA 00,00
0223E:  DATA 40,45
02240:  DATA 4E,44
02242:  DATA 0D,0A
02244:  DATA 00,00
02246:  DATA 2C,61
02248:  DATA 75,74
0224A:  DATA 6F,2D
0224C:  DATA 73,61
0224E:  DATA 6D,70
02250:  DATA 6C,65
02252:  DATA 2C,73
02254:  DATA 61,6D
02256:  DATA 70,6C
02258:  DATA 65,5B
0225A:  DATA 25,4C
0225C:  DATA 75,5D
0225E:  DATA 2C,73
02260:  DATA 74,61
02262:  DATA 72,74
02264:  DATA 0D,0A
02266:  DATA 00,00
02268:  DATA 2C,61
0226A:  DATA 75,74
0226C:  DATA 6F,2D
0226E:  DATA 73,61
02270:  DATA 6D,70
02272:  DATA 6C,65
02274:  DATA 2C,73
02276:  DATA 61,6D
02278:  DATA 70,6C
0227A:  DATA 65,5B
0227C:  DATA 25,4C
0227E:  DATA 75,5D
02280:  DATA 2C,63
02282:  DATA 6F,6D
02284:  DATA 70,6C
02286:  DATA 65,74
02288:  DATA 65,0D
0228A:  DATA 0A,00
0228C:  DATA 2C,61
0228E:  DATA 75,74
02290:  DATA 6F,2D
02292:  DATA 73,61
02294:  DATA 6D,70
02296:  DATA 6C,65
02298:  DATA 2C,73
0229A:  DATA 61,6D
0229C:  DATA 70,6C
0229E:  DATA 65,5B
022A0:  DATA 25,4C
022A2:  DATA 75,5D
022A4:  DATA 2C,65
022A6:  DATA 72,72
022A8:  DATA 6F,72
022AA:  DATA 0D,0A
022AC:  DATA 00,00
022AE:  DATA 2C,61
022B0:  DATA 75,74
022B2:  DATA 6F,2D
022B4:  DATA 73,61
022B6:  DATA 6D,70
022B8:  DATA 6C,65
022BA:  DATA 2C,73
022BC:  DATA 61,6D
022BE:  DATA 70,6C
022C0:  DATA 65,5B
022C2:  DATA 25,4C
022C4:  DATA 75,5D
022C6:  DATA 2C,6D
022C8:  DATA 61,78
022CA:  DATA 20,73
022CC:  DATA 61,6D
022CE:  DATA 70,6C
022D0:  DATA 65,73
022D2:  DATA 0D,0A
022D4:  DATA 00,00
022D6:  DATA 2C,61
022D8:  DATA 75,74
022DA:  DATA 6F,2D
022DC:  DATA 73,61
022DE:  DATA 6D,70
022E0:  DATA 6C,65
022E2:  DATA 2C,73
022E4:  DATA 61,6D
022E6:  DATA 70,6C
022E8:  DATA 65,5B
022EA:  DATA 25,4C
022EC:  DATA 75,5D
022EE:  DATA 2C,73
022F0:  DATA 74,61
022F2:  DATA 72,74
022F4:  DATA 0D,0A
022F6:  DATA 00,00
022F8:  DATA 2C,61
022FA:  DATA 75,74
022FC:  DATA 6F,2D
022FE:  DATA 73,61
02300:  DATA 6D,70
02302:  DATA 6C,65
02304:  DATA 2C,73
02306:  DATA 61,6D
02308:  DATA 70,6C
0230A:  DATA 65,5B
0230C:  DATA 25,4C
0230E:  DATA 75,5D
02310:  DATA 2C,63
02312:  DATA 6F,6D
02314:  DATA 70,6C
02316:  DATA 65,74
02318:  DATA 65,0D
0231A:  DATA 0A,00
0231C:  DATA 2C,61
0231E:  DATA 75,74
02320:  DATA 6F,2D
02322:  DATA 73,61
02324:  DATA 6D,70
02326:  DATA 6C,65
02328:  DATA 2C,73
0232A:  DATA 61,6D
0232C:  DATA 70,6C
0232E:  DATA 65,5B
02330:  DATA 25,4C
02332:  DATA 75,5D
02334:  DATA 2C,73
02336:  DATA 74,61
02338:  DATA 72,74
0233A:  DATA 0D,0A
0233C:  DATA 00,00
0233E:  DATA 2C,61
02340:  DATA 75,74
02342:  DATA 6F,2D
02344:  DATA 73,61
02346:  DATA 6D,70
02348:  DATA 6C,65
0234A:  DATA 2C,73
0234C:  DATA 61,6D
0234E:  DATA 70,6C
02350:  DATA 65,5B
02352:  DATA 25,4C
02354:  DATA 75,5D
02356:  DATA 2C,63
02358:  DATA 6F,6D
0235A:  DATA 70,6C
0235C:  DATA 65,74
0235E:  DATA 65,0D
02360:  DATA 0A,00
02362:  DATA 2C,61
02364:  DATA 75,74
02366:  DATA 6F,2D
02368:  DATA 73,61
0236A:  DATA 6D,70
0236C:  DATA 6C,65
0236E:  DATA 2C,73
02370:  DATA 61,6D
02372:  DATA 70,6C
02374:  DATA 65,5B
02376:  DATA 25,4C
02378:  DATA 75,5D
0237A:  DATA 2C,6D
0237C:  DATA 61,78
0237E:  DATA 20,73
02380:  DATA 61,6D
02382:  DATA 70,6C
02384:  DATA 65,73
02386:  DATA 0D,0A
02388:  DATA 00,00
0238A:  DATA 2C,61
0238C:  DATA 75,74
0238E:  DATA 6F,2D
02390:  DATA 73,61
02392:  DATA 6D,70
02394:  DATA 6C,65
02396:  DATA 2C,69
02398:  DATA 6E,69
0239A:  DATA 74,69
0239C:  DATA 61,6C
0239E:  DATA 69,7A
023A0:  DATA 65,0D
023A2:  DATA 0A,00
023A4:  DATA 2C,68
023A6:  DATA 65,61
023A8:  DATA 64,65
023AA:  DATA 72,2C
023AC:  DATA 69,64
023AE:  DATA 23,5B
023B0:  DATA 25,4C
023B2:  DATA 75,5D
023B4:  DATA 2C,69
023B6:  DATA 6E,74
023B8:  DATA 5B,25
023BA:  DATA 4C,75
023BC:  DATA 5D,2C
023BE:  DATA 6D,61
023C0:  DATA 78,5B
023C2:  DATA 25,4C
023C4:  DATA 75,5D
023C6:  DATA 0D,0A
023C8:  DATA 00,00
023CA:  DATA 2C,61
023CC:  DATA 75,74
023CE:  DATA 6F,2D
023D0:  DATA 73,61
023D2:  DATA 6D,70
023D4:  DATA 6C,65
023D6:  DATA 2C,73
023D8:  DATA 61,6D
023DA:  DATA 70,6C
023DC:  DATA 65,5B
023DE:  DATA 25,4C
023E0:  DATA 75,5D
023E2:  DATA 2C,61
023E4:  DATA 6C,61
023E6:  DATA 72,6D
023E8:  DATA 5B,25
023EA:  DATA 75,5D
023EC:  DATA 0D,0A
023EE:  DATA 00,00
023F0:  DATA 2C,61
023F2:  DATA 75,74
023F4:  DATA 6F,2D
023F6:  DATA 73,61
023F8:  DATA 6D,70
023FA:  DATA 6C,65
023FC:  DATA 2C,73
023FE:  DATA 6C,65
02400:  DATA 65,70
02402:  DATA 0D,0A
02404:  DATA 00,00
02406:  DATA 74,31
02408:  DATA 3A,25
0240A:  DATA 4C,75
0240C:  DATA 20,74
0240E:  DATA 32,3A
02410:  DATA 25,4C
02412:  DATA 75,0D
02414:  DATA 0A,00
02416:  DATA 40,44
02418:  DATA 45,54
0241A:  DATA 2C,25
0241C:  DATA 4C,75
0241E:  DATA 0D,0A
02420:  DATA 00,00
02422:  DATA 4E,4F
02424:  DATA 33,2C
02426:  DATA 25,31
02428:  DATA 2E,35
0242A:  DATA 67,2C
0242C:  DATA 25,31
0242E:  DATA 2E,35
02430:  DATA 67,0D
02432:  DATA 0A,00
02434:  DATA 50,4F
02436:  DATA 34,2C
02438:  DATA 25,31
0243A:  DATA 2E,35
0243C:  DATA 67,2C
0243E:  DATA 25,31
02440:  DATA 2E,35
02442:  DATA 67,0D
02444:  DATA 0A,00
02446:  DATA 4E,48
02448:  DATA 34,2C
0244A:  DATA 25,31
0244C:  DATA 2E,35
0244E:  DATA 67,2C
02450:  DATA 25,31
02452:  DATA 2E,35
02454:  DATA 67,0D
02456:  DATA 0A,00
02458:  DATA 53,69
0245A:  DATA 4F,34
0245C:  DATA 2C,25
0245E:  DATA 31,2E
02460:  DATA 35,67
02462:  DATA 2C,25
02464:  DATA 31,2E
02466:  DATA 35,67
02468:  DATA 0D,0A
0246A:  DATA 00,00
0246C:  DATA 4E,4F
0246E:  DATA 33,28
02470:  DATA 6D,29
02472:  DATA 3A,00
02474:  DATA 4E,4F
02476:  DATA 33,28
02478:  DATA 63,29
0247A:  DATA 3A,00
0247C:  DATA 50,4F
0247E:  DATA 34,28
02480:  DATA 6D,29
02482:  DATA 3A,00
02484:  DATA 50,4F
02486:  DATA 34,28
02488:  DATA 63,29
0248A:  DATA 3A,00
0248C:  DATA 4E,48
0248E:  DATA 34,28
02490:  DATA 6D,29
02492:  DATA 3A,00
02494:  DATA 4E,48
02496:  DATA 34,28
02498:  DATA 63,29
0249A:  DATA 3A,00
0249C:  DATA 53,69
0249E:  DATA 4F,34
024A0:  DATA 28,6D
024A2:  DATA 29,3A
024A4:  DATA 00,00
024A6:  DATA 53,69
024A8:  DATA 4F,34
024AA:  DATA 28,63
024AC:  DATA 29,3A
024AE:  DATA 00,00
024B0:  DATA 41,72
024B2:  DATA 65,20
024B4:  DATA 79,6F
024B6:  DATA 75,20
024B8:  DATA 73,75
024BA:  DATA 72,65
024BC:  DATA 20,79
024BE:  DATA 6F,75
024C0:  DATA 20,77
024C2:  DATA 61,6E
024C4:  DATA 74,20
024C6:  DATA 74,6F
024C8:  DATA 20,65
024CA:  DATA 72,61
024CC:  DATA 73,65
024CE:  DATA 20,74
024D0:  DATA 68,65
024D2:  DATA 20,72
024D4:  DATA 61,77
024D6:  DATA 20,64
024D8:  DATA 61,74
024DA:  DATA 61,20
024DC:  DATA 66,69
024DE:  DATA 6C,65
024E0:  DATA 3F,20
024E2:  DATA 59,20
024E4:  DATA 6F,72
024E6:  DATA 20,4E
024E8:  DATA 21,0D
024EA:  DATA 0A,00
024EC:  DATA 46,69
024EE:  DATA 6C,65
024F0:  DATA 20,64
024F2:  DATA 65,6C
024F4:  DATA 65,74
024F6:  DATA 65,64
024F8:  DATA 21,0A
024FA:  DATA 0D,00
024FC:  DATA 4F,70
024FE:  DATA 65,72
02500:  DATA 61,74
02502:  DATA 69,6F
02504:  DATA 6E,20
02506:  DATA 63,61
02508:  DATA 6E,63
0250A:  DATA 65,6C
0250C:  DATA 65,64
0250E:  DATA 21,0D
02510:  DATA 0A,00
02512:  DATA 41,72
02514:  DATA 65,20
02516:  DATA 79,6F
02518:  DATA 75,20
0251A:  DATA 73,75
0251C:  DATA 72,65
0251E:  DATA 20,79
02520:  DATA 6F,75
02522:  DATA 20,77
02524:  DATA 61,6E
02526:  DATA 74,20
02528:  DATA 74,6F
0252A:  DATA 20,65
0252C:  DATA 72,61
0252E:  DATA 73,65
02530:  DATA 20,74
02532:  DATA 68,65
02534:  DATA 20,63
02536:  DATA 61,6C
02538:  DATA 63,75
0253A:  DATA 6C,61
0253C:  DATA 74,65
0253E:  DATA 64,20
02540:  DATA 64,61
02542:  DATA 74,61
02544:  DATA 20,66
02546:  DATA 69,6C
02548:  DATA 65,3F
0254A:  DATA 20,59
0254C:  DATA 20,6F
0254E:  DATA 72,20
02550:  DATA 4E,21
02552:  DATA 0D,0A
02554:  DATA 00,00
02556:  DATA 46,69
02558:  DATA 6C,65
0255A:  DATA 20,64
0255C:  DATA 65,6C
0255E:  DATA 65,74
02560:  DATA 65,64
02562:  DATA 21,0A
02564:  DATA 0D,00
02566:  DATA 4F,70
02568:  DATA 65,72
0256A:  DATA 61,74
0256C:  DATA 69,6F
0256E:  DATA 6E,20
02570:  DATA 63,61
02572:  DATA 6E,63
02574:  DATA 65,6C
02576:  DATA 65,64
02578:  DATA 21,0D
0257A:  DATA 0A,00
0257C:  DATA 40,49
0257E:  DATA 44,23
02580:  DATA 25,4C
02582:  DATA 75,20
02584:  DATA 49,25
02586:  DATA 4C,75
02588:  DATA 20,4E
0258A:  DATA 25,4C
0258C:  DATA 75,2F
0258E:  DATA 25,4C
02590:  DATA 75,20
02592:  DATA 58,25
02594:  DATA 4C,75
02596:  DATA 20,55
02598:  DATA 25,75
0259A:  DATA 20,25
0259C:  DATA 34,2E
0259E:  DATA 32,77
025A0:  DATA 56,0D
025A2:  DATA 0A,00
025A4:  DATA 40,4D
025A6:  DATA 4F,54
025A8:  DATA 3A,56
025AA:  DATA 41,4C
025AC:  DATA 3D,25
025AE:  DATA 4C,75
025B0:  DATA 20,53
025B2:  DATA 59,52
025B4:  DATA 3D,25
025B6:  DATA 4C,64
025B8:  DATA 0D,0A
025BA:  DATA 00,00
025BC:  DATA 40,50
025BE:  DATA 57,52
025C0:  DATA 3A,25
025C2:  DATA 30,32
025C4:  DATA 75,2F
025C6:  DATA 25,30
025C8:  DATA 32,75
025CA:  DATA 2F,25
025CC:  DATA 30,32
025CE:  DATA 75,20
025D0:  DATA 25,30
025D2:  DATA 32,75
025D4:  DATA 3A,25
025D6:  DATA 30,32
025D8:  DATA 75,3A
025DA:  DATA 25,30
025DC:  DATA 32,75
025DE:  DATA 0D,0A
025E0:  DATA 00,00
025E2:  DATA 40,50
025E4:  DATA 57,52
025E6:  DATA 3A,25
025E8:  DATA 30,32
025EA:  DATA 75,2F
025EC:  DATA 25,30
025EE:  DATA 32,75
025F0:  DATA 2F,25
025F2:  DATA 30,32
025F4:  DATA 75,20
025F6:  DATA 25,30
025F8:  DATA 32,75
025FA:  DATA 3A,25
025FC:  DATA 30,32
025FE:  DATA 75,3A
02600:  DATA 25,30
02602:  DATA 32,75
02604:  DATA 0D,0A
02606:  DATA 00,00
02608:  DATA 41,25
0260A:  DATA 4C,75
0260C:  DATA 20,49
0260E:  DATA 25,4C
02610:  DATA 75,20
02612:  DATA 4C,25
02614:  DATA 4C,75
02616:  DATA 20,51
02618:  DATA 25,4C
0261A:  DATA 75,20
0261C:  DATA 53,25
0261E:  DATA 4C,75
02620:  DATA 20,25
02622:  DATA 34,2E
02624:  DATA 32,77
02626:  DATA 56,0D
02628:  DATA 0A,00
0262A:  DATA 40,4D
0262C:  DATA 4F,54
0262E:  DATA 3A,56
02630:  DATA 41,4C
02632:  DATA 3D,25
02634:  DATA 4C,75
02636:  DATA 20,53
02638:  DATA 59,52
0263A:  DATA 3D,25
0263C:  DATA 4C,64
0263E:  DATA 0D,0A
02640:  DATA 00,00
02642:  DATA 40,50
02644:  DATA 57,52
02646:  DATA 3A,25
02648:  DATA 30,32
0264A:  DATA 75,2F
0264C:  DATA 25,30
0264E:  DATA 32,75
02650:  DATA 2F,25
02652:  DATA 30,32
02654:  DATA 75,20
02656:  DATA 25,30
02658:  DATA 32,75
0265A:  DATA 3A,25
0265C:  DATA 30,32
0265E:  DATA 75,3A
02660:  DATA 25,30
02662:  DATA 32,75
02664:  DATA 0D,0A
02666:  DATA 00,00
02668:  DATA 49,25
0266A:  DATA 4C,75
0266C:  DATA 20,4E
0266E:  DATA 25,4C
02670:  DATA 75,2F
02672:  DATA 25,4C
02674:  DATA 75,20
02676:  DATA 50,25
02678:  DATA 4C,75
0267A:  DATA 20,25
0267C:  DATA 34,2E
0267E:  DATA 32,77
02680:  DATA 56,0D
02682:  DATA 0A,00
02684:  DATA 40,4D
02686:  DATA 4F,54
02688:  DATA 3A,53
0268A:  DATA 59,52
0268C:  DATA 3D,25
0268E:  DATA 4C,64
02690:  DATA 0D,0A
02692:  DATA 00,00
02694:  DATA 40,50
02696:  DATA 57,52
02698:  DATA 3A,25
0269A:  DATA 30,32
0269C:  DATA 75,2F
0269E:  DATA 25,30
026A0:  DATA 32,75
026A2:  DATA 2F,25
026A4:  DATA 30,32
026A6:  DATA 75,20
026A8:  DATA 25,30
026AA:  DATA 32,75
026AC:  DATA 3A,25
026AE:  DATA 30,32
026B0:  DATA 75,3A
026B2:  DATA 25,30
026B4:  DATA 32,75
026B6:  DATA 0D,0A
026B8:  DATA 00,00
026BA:  DATA 40,53
026BC:  DATA 4D,50
026BE:  DATA 20,25
026C0:  DATA 30,34
026C2:  DATA 4C,75
026C4:  DATA 0D,0A
026C6:  DATA 00,00
026C8:  DATA 40,53
026CA:  DATA 4D,50
026CC:  DATA 20,25
026CE:  DATA 30,34
026D0:  DATA 4C,75
026D2:  DATA 0D,0A
026D4:  DATA 00,00
026D6:  DATA 45,6E
026D8:  DATA 74,65
026DA:  DATA 72,20
026DC:  DATA 64,61
026DE:  DATA 74,65
026E0:  DATA 20,66
026E2:  DATA 6F,72
026E4:  DATA 6D,61
026E6:  DATA 74,20
026E8:  DATA 30,3D
026EA:  DATA 4D,4D
026EC:  DATA 2F,44
026EE:  DATA 44,2F
026F0:  DATA 59,59
026F2:  DATA 20,20
026F4:  DATA 31,3D
026F6:  DATA 44,44
026F8:  DATA 2F,4D
026FA:  DATA 4D,2F
026FC:  DATA 59,59
026FE:  DATA 0D,0A
02700:  DATA 00,00
02702:  DATA 40,4F
02704:  DATA 4B,21
02706:  DATA 0D,0A
02708:  DATA 20,00
0270A:  DATA 40,45
0270C:  DATA 52,52
0270E:  DATA 0D,0A
02710:  DATA 00,00
02712:  DATA 40,52
02714:  DATA 55,4E
02716:  DATA 0D,0A
02718:  DATA 00,00
0271A:  DATA 5B,6D
0271C:  DATA 6F,74
0271E:  DATA 6F,72
02720:  DATA 3A,31
02722:  DATA 5D,0D
02724:  DATA 0A,00
02726:  DATA 5B,6D
02728:  DATA 6F,74
0272A:  DATA 6F,72
0272C:  DATA 3A,32
0272E:  DATA 5D,0D
02730:  DATA 0A,00
02732:  DATA 2C,45
02734:  DATA 43,4F
02736:  DATA 20,6D
02738:  DATA 6F,64
0273A:  DATA 65,20
0273C:  DATA 73,65
0273E:  DATA 74,0D
02740:  DATA 0A,00
02742:  DATA 2C,57
02744:  DATA 4D,53
02746:  DATA 2D,34
02748:  DATA 2D,53
0274A:  DATA 44,20
0274C:  DATA 6D,6F
0274E:  DATA 64,65
02750:  DATA 20,73
02752:  DATA 65,74
02754:  DATA 0D,0A
02756:  DATA 00,00
02758:  DATA 2C,41
0275A:  DATA 57,53
0275C:  DATA 20,6D
0275E:  DATA 6F,64
02760:  DATA 65,20
02762:  DATA 73,65
02764:  DATA 74,0D
02766:  DATA 0A,00
02768:  DATA 2C,57
0276A:  DATA 4D,53
0276C:  DATA 2D,34
0276E:  DATA 2D,51
02770:  DATA 45,20
02772:  DATA 6D,6F
02774:  DATA 64,65
02776:  DATA 20,73
02778:  DATA 65,74
0277A:  DATA 0D,0A
0277C:  DATA 00,00
0277E:  DATA 30,36
02780:  DATA 2D,4A
02782:  DATA 75,6C
02784:  DATA 2D,31
02786:  DATA 37,00
02788:  DATA 31,33
0278A:  DATA 3A,33
0278C:  DATA 39,3A
0278E:  DATA 33,34
02790:  DATA 00,00
02792:  DATA 53,45
02794:  DATA 4E,44
02796:  DATA 20,48
02798:  DATA 45,58
0279A:  DATA 20,46
0279C:  DATA 49,4C
0279E:  DATA 45,20
027A0:  DATA 28,31
027A2:  DATA 39,32
027A4:  DATA 30,30
027A6:  DATA 2C,4E
027A8:  DATA 38,31
027AA:  DATA 2C,58
027AC:  DATA 4F,4E
027AE:  DATA 2D,58
027B0:  DATA 4F,46
027B2:  DATA 46,29
027B4:  DATA 0D,0A
027B6:  DATA 00,00
027B8:  DATA 40,4F
027BA:  DATA 4B,21
027BC:  DATA 20,00
027BE:  DATA 40,41
027C0:  DATA 52,47
027C2:  DATA 20,00
027C4:  DATA 40,49
027C6:  DATA 4E,56
027C8:  DATA 00,00
027CA:  DATA 40,43
027CC:  DATA 4D,44
027CE:  DATA 00,00
027D0:  DATA 2C,63
027D2:  DATA 6F,6D
027D4:  DATA 6D,61
027D6:  DATA 6E,64
027D8:  DATA 20,70
027DA:  DATA 72,6F
027DC:  DATA 6D,70
027DE:  DATA 74,0D
027E0:  DATA 0A,00
027E2:  DATA 40,53
027E4:  DATA 44,3D
027E6:  DATA 25,4C
027E8:  DATA 75,0D
027EA:  DATA 0A,00
027EC:  DATA 40,4D
027EE:  DATA 43,31
027F0:  DATA 2C,25
027F2:  DATA 4C,75
027F4:  DATA 2C,25
027F6:  DATA 4C,64
027F8:  DATA 0D,0A
027FA:  DATA 00,00
027FC:  DATA 40,4D
027FE:  DATA 43,32
02800:  DATA 2C,25
02802:  DATA 4C,75
02804:  DATA 2C,25
02806:  DATA 4C,64
02808:  DATA 0D,0A
0280A:  DATA 00,00
0280C:  DATA 50,72
0280E:  DATA 65,73
02810:  DATA 73,20
02812:  DATA 61,6E
02814:  DATA 64,20
02816:  DATA 68,6F
02818:  DATA 6C,64
0281A:  DATA 20,74
0281C:  DATA 68,65
0281E:  DATA 20,45
02820:  DATA 73,63
02822:  DATA 20,6B
02824:  DATA 65,79
02826:  DATA 20,74
02828:  DATA 6F,20
0282A:  DATA 72,65
0282C:  DATA 74,75
0282E:  DATA 72,6E
02830:  DATA 20,74
02832:  DATA 6F,20
02834:  DATA 43,6F
02836:  DATA 6D,6D
02838:  DATA 61,6E
0283A:  DATA 64,20
0283C:  DATA 4D,6F
0283E:  DATA 64,65
02840:  DATA 0D,0A
02842:  DATA 00,00
02844:  DATA 52,65
02846:  DATA 74,75
02848:  DATA 72,6E
0284A:  DATA 69,6E
0284C:  DATA 67,20
0284E:  DATA 74,6F
02850:  DATA 20,4C
02852:  DATA 6F,67
02854:  DATA 67,69
02856:  DATA 6E,67
02858:  DATA 20,4D
0285A:  DATA 6F,64
0285C:  DATA 65,0D
0285E:  DATA 0A,00
*
02C70:  CLRF   01
02C72:  CLRF   02
02C74:  CLRF   00
02C76:  CLRF   03
02C78:  MOVLB  8
02C7A:  MOVF   xBF,W
02C7C:  BNZ   2C82
02C7E:  MOVF   xBE,W
02C80:  BZ    2CB2
02C82:  MOVLW  10
02C84:  MOVWF  xC0
02C86:  BCF    FD8.0
02C88:  RLCF   xBC,F
02C8A:  RLCF   xBD,F
02C8C:  RLCF   00,F
02C8E:  RLCF   03,F
02C90:  MOVF   xBF,W
02C92:  SUBWF  03,W
02C94:  BNZ   2C9A
02C96:  MOVF   xBE,W
02C98:  SUBWF  00,W
02C9A:  BNC   2CAA
02C9C:  MOVF   xBE,W
02C9E:  SUBWF  00,F
02CA0:  BTFSS  FD8.0
02CA2:  DECF   03,F
02CA4:  MOVF   xBF,W
02CA6:  SUBWF  03,F
02CA8:  BSF    FD8.0
02CAA:  RLCF   01,F
02CAC:  RLCF   02,F
02CAE:  DECFSZ xC0,F
02CB0:  BRA    2C86
02CB2:  MOVLB  0
02CB4:  RETURN 0
*
034C2:  TSTFSZ 01
034C4:  BRA    34CC
034C6:  TSTFSZ 02
034C8:  BRA    34CE
034CA:  BRA    34DA
034CC:  INCF   02,F
034CE:  MOVFF  00,FEE
034D2:  DECFSZ 01,F
034D4:  BRA    34CE
034D6:  DECFSZ 02,F
034D8:  BRA    34CE
034DA:  RETURN 0
*
035AC:  MOVLB  9
035AE:  BTFSC  xCE.7
035B0:  BRA    35D2
035B2:  MOVLW  0F
035B4:  MOVWF  00
035B6:  SWAPF  xCD,W
035B8:  ANDWF  00,F
035BA:  MOVLW  0A
035BC:  SUBWF  00,W
035BE:  BC    35C6
035C0:  MOVLW  30
035C2:  ADDWF  00,F
035C4:  BRA    35CA
035C6:  MOVF   xCE,W
035C8:  ADDWF  00,F
035CA:  MOVF   00,W
035CC:  BTFSS  F9E.4
035CE:  BRA    35CC
035D0:  MOVWF  FAD
035D2:  MOVLW  0F
035D4:  ANDWF  xCD,F
035D6:  MOVLW  0A
035D8:  SUBWF  xCD,W
035DA:  BC    35E0
035DC:  MOVLW  30
035DE:  BRA    35E4
035E0:  BCF    xCE.7
035E2:  MOVF   xCE,W
035E4:  ADDWF  xCD,F
035E6:  MOVF   xCD,W
035E8:  BTFSS  F9E.4
035EA:  BRA    35E8
035EC:  MOVWF  FAD
035EE:  MOVLB  0
035F0:  RETURN 0
*
0478E:  MOVLB  9
04790:  CLRF   xDF
04792:  CLRF   xE0
04794:  MOVLW  01
04796:  MOVWF  xE1
04798:  CLRF   FDA
0479A:  CLRF   FD9
0479C:  MOVLW  09
0479E:  MOVWF  xE4
047A0:  MOVLW  D7
047A2:  MOVWF  xE3
047A4:  MOVLW  09
047A6:  MOVWF  FEA
047A8:  MOVLW  DB
047AA:  MOVWF  FE9
047AC:  MOVFF  9E4,FE2
047B0:  MOVFF  9E3,FE1
047B4:  MOVFF  9E1,9E2
047B8:  BCF    FD8.0
047BA:  MOVF   FE5,W
047BC:  MULWF  FEE
047BE:  MOVF   FF3,W
047C0:  ADDWFC xDF,F
047C2:  MOVF   FF4,W
047C4:  ADDWFC xE0,F
047C6:  DECFSZ xE2,F
047C8:  BRA    47B8
047CA:  MOVFF  9DF,FDE
047CE:  MOVFF  9E0,9DF
047D2:  CLRF   xE0
047D4:  BTFSC  FD8.0
047D6:  INCF   xE0,F
047D8:  INCF   xE3,F
047DA:  BTFSC  FD8.2
047DC:  INCF   xE4,F
047DE:  INCF   xE1,F
047E0:  MOVF   xE1,W
047E2:  SUBLW  05
047E4:  BNZ   47A4
047E6:  MOVLB  0
047E8:  RETURN 0
*
05032:  MOVFF  1E,FEA
05036:  MOVFF  1D,FE9
0503A:  MOVLB  8
0503C:  MOVFF  8E0,FEF
05040:  INCF   FE9,F
05042:  BTFSC  FD8.2
05044:  INCF   FEA,F
05046:  CLRF   FEF
05048:  INCF   1D,F
0504A:  BTFSC  FD8.2
0504C:  INCF   1E,F
0504E:  MOVLB  0
05050:  RETURN 0
05052:  TBLRD*+
05054:  MOVF   FF5,F
05056:  BZ    5078
05058:  MOVFF  FF6,8CC
0505C:  MOVFF  FF7,8CD
05060:  MOVFF  FF8,8CE
05064:  MOVFF  FF5,8E0
05068:  RCALL  5032
0506A:  MOVFF  8CC,FF6
0506E:  MOVFF  8CD,FF7
05072:  MOVFF  8CE,FF8
05076:  BRA    5052
05078:  RETURN 0
*
05214:  MOVF   01,W
05216:  CLRF   1B
05218:  BTFSC  FF2.7
0521A:  BSF    1B.7
0521C:  BCF    FF2.7
0521E:  MOVFF  8CE,A1E
05222:  MOVLW  64
05224:  MOVLB  A
05226:  MOVWF  x1F
05228:  MOVLB  0
0522A:  CALL   0F7A
0522E:  BTFSC  1B.7
05230:  BSF    FF2.7
05232:  MOVFF  00,8CE
05236:  MOVF   01,W
05238:  MOVLW  30
0523A:  BNZ   524C
0523C:  MOVLB  8
0523E:  BTFSS  xCF.1
05240:  BRA    5260
05242:  BTFSC  xCF.3
05244:  BRA    5260
05246:  BTFSC  xCF.4
05248:  MOVLW  20
0524A:  BRA    5254
0524C:  MOVLB  8
0524E:  BCF    xCF.3
05250:  BCF    xCF.4
05252:  BSF    xCF.0
05254:  ADDWF  01,F
05256:  MOVFF  01,8E0
0525A:  MOVLB  0
0525C:  RCALL  5032
0525E:  MOVLB  8
05260:  CLRF   1B
05262:  BTFSC  FF2.7
05264:  BSF    1B.7
05266:  BCF    FF2.7
05268:  MOVFF  8CE,A1E
0526C:  MOVLW  0A
0526E:  MOVLB  A
05270:  MOVWF  x1F
05272:  MOVLB  0
05274:  CALL   0F7A
05278:  BTFSC  1B.7
0527A:  BSF    FF2.7
0527C:  MOVFF  00,8CE
05280:  MOVF   01,W
05282:  MOVLW  30
05284:  BNZ   5296
05286:  MOVLB  8
05288:  BTFSC  xCF.3
0528A:  BRA    52A0
0528C:  BTFSS  xCF.0
0528E:  BRA    52A0
05290:  BTFSC  xCF.4
05292:  MOVLW  20
05294:  MOVLB  0
05296:  ADDWF  01,F
05298:  MOVFF  01,8E0
0529C:  RCALL  5032
0529E:  MOVLB  8
052A0:  MOVLW  30
052A2:  ADDWF  xCE,F
052A4:  MOVFF  8CE,8E0
052A8:  MOVLB  0
052AA:  RCALL  5032
052AC:  RETURN 0
052AE:  MOVF   FE9,W
052B0:  MOVLB  8
052B2:  MOVWF  xD3
052B4:  MOVLW  3B
052B6:  MOVWF  xDA
052B8:  MOVLW  9A
052BA:  MOVWF  xD9
052BC:  MOVLW  CA
052BE:  MOVWF  xD8
052C0:  CLRF   xD7
052C2:  MOVLW  0A
052C4:  MOVWF  xD5
052C6:  MOVF   xD2,W
052C8:  BTFSS  FD8.2
052CA:  DECF   xD3,F
052CC:  BSF    FD8.1
052CE:  MOVLW  08
052D0:  MOVWF  FEA
052D2:  MOVLW  CE
052D4:  MOVWF  FE9
052D6:  CLRF   1B
052D8:  BTFSC  FF2.7
052DA:  BSF    1B.7
052DC:  BCF    FF2.7
052DE:  MOVFF  8D1,A2B
052E2:  MOVFF  8D0,A2A
052E6:  MOVFF  8CF,A29
052EA:  MOVFF  8CE,A28
052EE:  MOVFF  8DA,A2F
052F2:  MOVFF  8D9,A2E
052F6:  MOVFF  8D8,A2D
052FA:  MOVFF  8D7,A2C
052FE:  MOVLB  0
05300:  CALL   1056
05304:  BTFSC  1B.7
05306:  BSF    FF2.7
05308:  MOVF   01,W
0530A:  MOVF   00,F
0530C:  BNZ   5334
0530E:  MOVLB  8
05310:  INCF   xD2,W
05312:  SUBWF  xD5,W
05314:  BTFSS  FD8.2
05316:  BRA    531C
05318:  MOVLB  0
0531A:  BRA    5334
0531C:  MOVF   xD3,W
0531E:  BZ    5338
05320:  ANDLW  0F
05322:  SUBWF  xD5,W
05324:  BZ    5328
05326:  BC    5364
05328:  BTFSC  xD3.7
0532A:  BRA    5364
0532C:  BTFSC  xD3.6
0532E:  BRA    5338
05330:  MOVLW  20
05332:  BRA    5358
05334:  MOVLB  8
05336:  CLRF   xD3
05338:  MOVF   xD2,W
0533A:  SUBWF  xD5,W
0533C:  BNZ   5356
0533E:  MOVFF  00,8D3
05342:  MOVLW  2E
05344:  MOVWF  xE0
05346:  MOVLB  0
05348:  RCALL  5032
0534A:  MOVLB  8
0534C:  MOVFF  8D3,00
05350:  MOVLW  20
05352:  ANDWF  xD3,F
05354:  MOVLW  00
05356:  MOVLW  30
05358:  ADDWF  00,F
0535A:  MOVFF  00,8E0
0535E:  MOVLB  0
05360:  RCALL  5032
05362:  MOVLB  8
05364:  BCF    FD8.1
05366:  CLRF   1B
05368:  BTFSC  FF2.7
0536A:  BSF    1B.7
0536C:  BCF    FF2.7
0536E:  MOVFF  8DA,A2B
05372:  MOVFF  8D9,A2A
05376:  MOVFF  8D8,A29
0537A:  MOVFF  8D7,A28
0537E:  MOVLB  A
05380:  CLRF   x2F
05382:  CLRF   x2E
05384:  CLRF   x2D
05386:  MOVLW  0A
05388:  MOVWF  x2C
0538A:  MOVLB  0
0538C:  CALL   1056
05390:  BTFSC  1B.7
05392:  BSF    FF2.7
05394:  MOVFF  03,8DA
05398:  MOVFF  02,8D9
0539C:  MOVFF  01,8D8
053A0:  MOVFF  00,8D7
053A4:  MOVLB  8
053A6:  DECFSZ xD5,F
053A8:  BRA    52CC
053AA:  MOVLB  0
053AC:  RETURN 0
*
05C32:  MOVLB  9
05C34:  MOVF   xED,W
05C36:  MULWF  xEF
05C38:  MOVFF  FF3,01
05C3C:  MOVFF  FF4,00
05C40:  MULWF  xF0
05C42:  MOVF   FF3,W
05C44:  ADDWF  00,F
05C46:  MOVF   xEE,W
05C48:  MULWF  xEF
05C4A:  MOVF   FF3,W
05C4C:  ADDWFC 00,W
05C4E:  MOVWF  02
05C50:  MOVLB  0
05C52:  RETURN 0
*
078F8:  MOVF   FEF,F
078FA:  BZ    791C
078FC:  MOVFF  FEA,992
07900:  MOVFF  FE9,991
07904:  MOVF   FEF,W
07906:  BTFSS  F9E.4
07908:  BRA    7906
0790A:  MOVWF  FAD
0790C:  MOVFF  992,FEA
07910:  MOVFF  991,FE9
07914:  INCF   FE9,F
07916:  BTFSC  FD8.2
07918:  INCF   FEA,F
0791A:  BRA    78F8
0791C:  RETURN 0
*
08F40:  MOVFF  FEA,8D9
08F44:  MOVFF  FE9,8D8
08F48:  MOVLB  8
08F4A:  BTFSS  xD2.7
08F4C:  BRA    8F5E
08F4E:  BSF    xD8.7
08F50:  BTFSS  xD8.4
08F52:  INCF   xD8,F
08F54:  COMF   xD1,F
08F56:  COMF   xD2,F
08F58:  INCF   xD1,F
08F5A:  BTFSC  FD8.2
08F5C:  INCF   xD2,F
08F5E:  SWAPF  xD2,W
08F60:  IORLW  F0
08F62:  MOVWF  xD4
08F64:  ADDWF  xD4,F
08F66:  ADDLW  E2
08F68:  MOVWF  xD5
08F6A:  ADDLW  32
08F6C:  MOVWF  xD7
08F6E:  MOVF   xD2,W
08F70:  ANDLW  0F
08F72:  ADDWF  xD5,F
08F74:  ADDWF  xD5,F
08F76:  ADDWF  xD7,F
08F78:  ADDLW  E9
08F7A:  MOVWF  xD6
08F7C:  ADDWF  xD6,F
08F7E:  ADDWF  xD6,F
08F80:  SWAPF  xD1,W
08F82:  ANDLW  0F
08F84:  ADDWF  xD6,F
08F86:  ADDWF  xD7,F
08F88:  RLCF   xD6,F
08F8A:  RLCF   xD7,F
08F8C:  COMF   xD7,F
08F8E:  RLCF   xD7,F
08F90:  MOVF   xD1,W
08F92:  ANDLW  0F
08F94:  ADDWF  xD7,F
08F96:  RLCF   xD4,F
08F98:  MOVLW  07
08F9A:  MOVWF  xD3
08F9C:  MOVLW  0A
08F9E:  DECF   xD6,F
08FA0:  ADDWF  xD7,F
08FA2:  BNC   8F9E
08FA4:  DECF   xD5,F
08FA6:  ADDWF  xD6,F
08FA8:  BNC   8FA4
08FAA:  DECF   xD4,F
08FAC:  ADDWF  xD5,F
08FAE:  BNC   8FAA
08FB0:  DECF   xD3,F
08FB2:  ADDWF  xD4,F
08FB4:  BNC   8FB0
08FB6:  MOVLW  08
08FB8:  MOVWF  FEA
08FBA:  MOVLW  D3
08FBC:  MOVWF  FE9
08FBE:  MOVLW  07
08FC0:  ANDWF  xD8,W
08FC2:  BCF    xD8.6
08FC4:  MOVF   FED,F
08FC6:  ANDWF  xD8,W
08FC8:  BNZ   8FD8
08FCA:  BTFSC  xD8.4
08FCC:  MOVF   FEE,F
08FCE:  BTFSC  xD8.4
08FD0:  BRA    8FD8
08FD2:  MOVLW  20
08FD4:  MOVWF  00
08FD6:  BRA    901A
08FD8:  ADDWF  FE9,F
08FDA:  MOVLW  00
08FDC:  ADDWFC FEA,F
08FDE:  MOVF   FE9,W
08FE0:  SUBLW  D7
08FE2:  BNZ   8FEC
08FE4:  MOVF   FEA,W
08FE6:  SUBLW  08
08FE8:  BNZ   8FEC
08FEA:  BSF    xD8.6
08FEC:  MOVF   FEF,W
08FEE:  MOVWF  00
08FF0:  BNZ   9002
08FF2:  BTFSC  xD8.6
08FF4:  BRA    9002
08FF6:  BTFSC  xD8.4
08FF8:  BRA    9022
08FFA:  BTFSC  xD8.3
08FFC:  BRA    9002
08FFE:  MOVLW  20
09000:  BRA    9018
09002:  BTFSS  xD8.7
09004:  BRA    9012
09006:  MOVLW  2D
09008:  MOVWF  00
0900A:  MOVF   FED,W
0900C:  BCF    xD8.6
0900E:  BCF    xD8.7
09010:  BRA    901A
09012:  BSF    xD8.3
09014:  BCF    xD8.4
09016:  MOVLW  30
09018:  ADDWF  00,F
0901A:  MOVF   00,W
0901C:  BTFSS  F9E.4
0901E:  BRA    901C
09020:  MOVWF  FAD
09022:  MOVF   FEE,W
09024:  BTFSS  xD8.6
09026:  BRA    8FDE
09028:  MOVLB  0
0902A:  RETURN 0
*
094C0:  MOVF   FE9,W
094C2:  MOVLB  8
094C4:  MOVWF  xD7
094C6:  BTFSS  xD6.7
094C8:  BRA    94E4
094CA:  DECF   xD7,F
094CC:  BSF    xD7.5
094CE:  COMF   xD3,F
094D0:  COMF   xD4,F
094D2:  COMF   xD5,F
094D4:  COMF   xD6,F
094D6:  INCF   xD3,F
094D8:  BTFSC  FD8.2
094DA:  INCF   xD4,F
094DC:  BTFSC  FD8.2
094DE:  INCF   xD5,F
094E0:  BTFSC  FD8.2
094E2:  INCF   xD6,F
094E4:  MOVLW  3B
094E6:  MOVWF  xDE
094E8:  MOVLW  9A
094EA:  MOVWF  xDD
094EC:  MOVLW  CA
094EE:  MOVWF  xDC
094F0:  CLRF   xDB
094F2:  MOVLW  0A
094F4:  MOVWF  xD9
094F6:  BSF    FD8.1
094F8:  MOVLW  08
094FA:  MOVWF  FEA
094FC:  MOVLW  D3
094FE:  MOVWF  FE9
09500:  CLRF   1B
09502:  BTFSC  FF2.7
09504:  BSF    1B.7
09506:  BCF    FF2.7
09508:  MOVFF  8D6,A2B
0950C:  MOVFF  8D5,A2A
09510:  MOVFF  8D4,A29
09514:  MOVFF  8D3,A28
09518:  MOVFF  8DE,A2F
0951C:  MOVFF  8DD,A2E
09520:  MOVFF  8DC,A2D
09524:  MOVFF  8DB,A2C
09528:  MOVLB  0
0952A:  CALL   1056
0952E:  BTFSC  1B.7
09530:  BSF    FF2.7
09532:  MOVF   01,W
09534:  MOVF   00,F
09536:  BNZ   955E
09538:  MOVLB  8
0953A:  MOVF   xD9,W
0953C:  XORLW  01
0953E:  BTFSS  FD8.2
09540:  BRA    9546
09542:  MOVLB  0
09544:  BRA    955E
09546:  MOVF   xD7,W
09548:  BZ    9564
0954A:  ANDLW  0F
0954C:  SUBWF  xD9,W
0954E:  BZ    9552
09550:  BC    95A2
09552:  BTFSC  xD7.7
09554:  BRA    95A2
09556:  BTFSC  xD7.6
09558:  BRA    9564
0955A:  MOVLW  20
0955C:  BRA    9598
0955E:  MOVLW  20
09560:  MOVLB  8
09562:  ANDWF  xD7,F
09564:  BTFSS  xD7.5
09566:  BRA    957C
09568:  BCF    xD7.5
0956A:  MOVFF  00,8D7
0956E:  MOVLW  2D
09570:  BTFSS  F9E.4
09572:  BRA    9570
09574:  MOVWF  FAD
09576:  MOVFF  8D7,00
0957A:  CLRF   xD7
0957C:  MOVLW  30
0957E:  BTFSS  xD7.5
09580:  BRA    9598
09582:  BCF    xD7.5
09584:  MOVFF  00,8D7
09588:  MOVLW  2D
0958A:  BTFSS  F9E.4
0958C:  BRA    958A
0958E:  MOVWF  FAD
09590:  MOVFF  8D7,00
09594:  CLRF   xD7
09596:  MOVLW  30
09598:  ADDWF  00,F
0959A:  MOVF   00,W
0959C:  BTFSS  F9E.4
0959E:  BRA    959C
095A0:  MOVWF  FAD
095A2:  BCF    FD8.1
095A4:  CLRF   1B
095A6:  BTFSC  FF2.7
095A8:  BSF    1B.7
095AA:  BCF    FF2.7
095AC:  MOVFF  8DE,A2B
095B0:  MOVFF  8DD,A2A
095B4:  MOVFF  8DC,A29
095B8:  MOVFF  8DB,A28
095BC:  MOVLB  A
095BE:  CLRF   x2F
095C0:  CLRF   x2E
095C2:  CLRF   x2D
095C4:  MOVLW  0A
095C6:  MOVWF  x2C
095C8:  MOVLB  0
095CA:  CALL   1056
095CE:  BTFSC  1B.7
095D0:  BSF    FF2.7
095D2:  MOVFF  03,8DE
095D6:  MOVFF  02,8DD
095DA:  MOVFF  01,8DC
095DE:  MOVFF  00,8DB
095E2:  MOVLB  8
095E4:  DECFSZ xD9,F
095E6:  BRA    94F6
095E8:  MOVLB  0
095EA:  RETURN 0
*
0A6B4:  ADDWF  FE8,W
0A6B6:  CLRF   FF7
0A6B8:  RLCF   FF7,F
0A6BA:  ADDLW  D5
0A6BC:  MOVWF  FF6
0A6BE:  MOVLW  A6
0A6C0:  ADDWFC FF7,F
0A6C2:  MOVLW  00
0A6C4:  MOVWF  FF8
0A6C6:  MOVWF  FFB
0A6C8:  TBLRD*-
0A6CA:  MOVF   FF5,W
0A6CC:  MOVWF  FFA
0A6CE:  TBLRD*
0A6D0:  MOVF   FF5,W
0A6D2:  MOVWF  FF9
0A6D4:  DATA 10,A0
0A6D6:  DATA 30,A0
0A6D8:  DATA 58,A0
0A6DA:  DATA 88,A0
0A6DC:  DATA B0,A0
*
0AA28:  TBLRD*+
0AA2A:  MOVFF  FF6,8CD
0AA2E:  MOVFF  FF7,8CE
0AA32:  MOVFF  FF8,8CF
0AA36:  MOVFF  FF5,8E0
0AA3A:  CALL   5032
0AA3E:  MOVFF  8CD,FF6
0AA42:  MOVFF  8CE,FF7
0AA46:  MOVFF  8CF,FF8
0AA4A:  MOVLB  8
0AA4C:  DECFSZ xCC,F
0AA4E:  BRA    AA52
0AA50:  BRA    AA56
0AA52:  MOVLB  0
0AA54:  BRA    AA28
0AA56:  MOVLB  0
0AA58:  RETURN 0
0AA5A:  MOVFF  FEA,8DF
0AA5E:  MOVFF  FE9,8DE
0AA62:  MOVLB  8
0AA64:  SWAPF  xD8,W
0AA66:  IORLW  F0
0AA68:  MOVWF  xDA
0AA6A:  ADDWF  xDA,F
0AA6C:  ADDLW  E2
0AA6E:  MOVWF  xDB
0AA70:  ADDLW  32
0AA72:  MOVWF  xDD
0AA74:  MOVF   xD8,W
0AA76:  ANDLW  0F
0AA78:  ADDWF  xDB,F
0AA7A:  ADDWF  xDB,F
0AA7C:  ADDWF  xDD,F
0AA7E:  ADDLW  E9
0AA80:  MOVWF  xDC
0AA82:  ADDWF  xDC,F
0AA84:  ADDWF  xDC,F
0AA86:  SWAPF  xD7,W
0AA88:  ANDLW  0F
0AA8A:  ADDWF  xDC,F
0AA8C:  ADDWF  xDD,F
0AA8E:  RLCF   xDC,F
0AA90:  RLCF   xDD,F
0AA92:  COMF   xDD,F
0AA94:  RLCF   xDD,F
0AA96:  MOVF   xD7,W
0AA98:  ANDLW  0F
0AA9A:  ADDWF  xDD,F
0AA9C:  RLCF   xDA,F
0AA9E:  MOVLW  07
0AAA0:  MOVWF  xD9
0AAA2:  MOVLW  0A
0AAA4:  DECF   xDC,F
0AAA6:  ADDWF  xDD,F
0AAA8:  BNC   AAA4
0AAAA:  DECF   xDB,F
0AAAC:  ADDWF  xDC,F
0AAAE:  BNC   AAAA
0AAB0:  DECF   xDA,F
0AAB2:  ADDWF  xDB,F
0AAB4:  BNC   AAB0
0AAB6:  DECF   xD9,F
0AAB8:  ADDWF  xDA,F
0AABA:  BNC   AAB6
0AABC:  MOVLW  08
0AABE:  MOVWF  FEA
0AAC0:  MOVLW  D9
0AAC2:  MOVWF  FE9
0AAC4:  MOVLW  07
0AAC6:  ANDWF  xDE,W
0AAC8:  BCF    xDE.6
0AACA:  ADDWF  FE9,F
0AACC:  MOVLW  00
0AACE:  ADDWFC FEA,F
0AAD0:  MOVF   FE9,W
0AAD2:  SUBLW  DD
0AAD4:  BNZ   AADE
0AAD6:  MOVF   FEA,W
0AAD8:  SUBLW  08
0AADA:  BNZ   AADE
0AADC:  BSF    xDE.6
0AADE:  MOVF   FEF,W
0AAE0:  MOVWF  00
0AAE2:  BNZ   AAF4
0AAE4:  BTFSC  xDE.6
0AAE6:  BRA    AAF4
0AAE8:  BTFSC  xDE.4
0AAEA:  BRA    AB18
0AAEC:  BTFSC  xDE.3
0AAEE:  BRA    AAF4
0AAF0:  MOVLW  20
0AAF2:  BRA    AAFA
0AAF4:  BSF    xDE.3
0AAF6:  BCF    xDE.4
0AAF8:  MOVLW  30
0AAFA:  ADDWF  00,F
0AAFC:  MOVFF  FEA,8D8
0AB00:  MOVFF  FE9,8D7
0AB04:  MOVFF  00,8E0
0AB08:  MOVLB  0
0AB0A:  CALL   5032
0AB0E:  MOVFF  8D8,FEA
0AB12:  MOVFF  8D7,FE9
0AB16:  MOVLB  8
0AB18:  MOVF   FEE,W
0AB1A:  BTFSS  xDE.6
0AB1C:  BRA    AAD0
0AB1E:  MOVLB  0
0AB20:  RETURN 0
*
0AD0C:  ADDWF  FE8,W
0AD0E:  CLRF   FF7
0AD10:  RLCF   FF7,F
0AD12:  ADDLW  2D
0AD14:  MOVWF  FF6
0AD16:  MOVLW  AD
0AD18:  ADDWFC FF7,F
0AD1A:  MOVLW  00
0AD1C:  MOVWF  FF8
0AD1E:  MOVWF  FFB
0AD20:  TBLRD*-
0AD22:  MOVF   FF5,W
0AD24:  MOVWF  FFA
0AD26:  TBLRD*
0AD28:  MOVF   FF5,W
0AD2A:  MOVWF  FF9
0AD2C:  DATA 1C,AC
0AD2E:  DATA 08,AD
0AD30:  DATA 08,AD
0AD32:  DATA 7C,AB
0AD34:  DATA 08,AD
0AD36:  DATA 08,AD
0AD38:  DATA 08,AD
0AD3A:  DATA 40,AB
0AD3C:  DATA 08,AD
0AD3E:  DATA 08,AD
0AD40:  DATA 08,AD
0AD42:  DATA 92,AC
0AD44:  DATA B8,AB
0AD46:  DATA 08,AD
0AD48:  DATA 56,AC
0AD4A:  DATA CE,AC
*
0ADA6:  TBLRD*+
0ADA8:  MOVF   FF5,F
0ADAA:  BZ    ADCE
0ADAC:  MOVFF  FF6,866
0ADB0:  MOVFF  FF7,867
0ADB4:  MOVFF  FF8,868
0ADB8:  MOVF   FF5,W
0ADBA:  BTFSS  F9E.4
0ADBC:  BRA    ADBA
0ADBE:  MOVWF  FAD
0ADC0:  MOVFF  866,FF6
0ADC4:  MOVFF  867,FF7
0ADC8:  MOVFF  868,FF8
0ADCC:  BRA    ADA6
0ADCE:  RETURN 0
*
0BF4E:  MOVLB  8
0BF50:  MOVF   xF4,W
0BF52:  BTFSC  FD8.2
0BF54:  BRA    C038
0BF56:  MOVWF  00
0BF58:  MOVF   xF8,W
0BF5A:  BTFSC  FD8.2
0BF5C:  BRA    C038
0BF5E:  ADDWF  00,F
0BF60:  BNC   BF6A
0BF62:  MOVLW  81
0BF64:  ADDWF  00,F
0BF66:  BC    C038
0BF68:  BRA    BF72
0BF6A:  MOVLW  7F
0BF6C:  SUBWF  00,F
0BF6E:  BNC   C038
0BF70:  BZ    C038
0BF72:  MOVFF  8F5,8FC
0BF76:  MOVF   xF9,W
0BF78:  XORWF  xFC,F
0BF7A:  BSF    xF5.7
0BF7C:  BSF    xF9.7
0BF7E:  MOVF   xF7,W
0BF80:  MULWF  xFB
0BF82:  MOVFF  FF4,8FE
0BF86:  MOVF   xF6,W
0BF88:  MULWF  xFA
0BF8A:  MOVFF  FF4,03
0BF8E:  MOVFF  FF3,8FD
0BF92:  MULWF  xFB
0BF94:  MOVF   FF3,W
0BF96:  ADDWF  xFE,F
0BF98:  MOVF   FF4,W
0BF9A:  ADDWFC xFD,F
0BF9C:  MOVLW  00
0BF9E:  ADDWFC 03,F
0BFA0:  MOVF   xF7,W
0BFA2:  MULWF  xFA
0BFA4:  MOVF   FF3,W
0BFA6:  ADDWF  xFE,F
0BFA8:  MOVF   FF4,W
0BFAA:  ADDWFC xFD,F
0BFAC:  MOVLW  00
0BFAE:  CLRF   02
0BFB0:  ADDWFC 03,F
0BFB2:  ADDWFC 02,F
0BFB4:  MOVF   xF5,W
0BFB6:  MULWF  xFB
0BFB8:  MOVF   FF3,W
0BFBA:  ADDWF  xFD,F
0BFBC:  MOVF   FF4,W
0BFBE:  ADDWFC 03,F
0BFC0:  MOVLW  00
0BFC2:  ADDWFC 02,F
0BFC4:  MOVF   xF5,W
0BFC6:  MULWF  xFA
0BFC8:  MOVF   FF3,W
0BFCA:  ADDWF  03,F
0BFCC:  MOVF   FF4,W
0BFCE:  ADDWFC 02,F
0BFD0:  MOVLW  00
0BFD2:  CLRF   01
0BFD4:  ADDWFC 01,F
0BFD6:  MOVF   xF7,W
0BFD8:  MULWF  xF9
0BFDA:  MOVF   FF3,W
0BFDC:  ADDWF  xFD,F
0BFDE:  MOVF   FF4,W
0BFE0:  ADDWFC 03,F
0BFE2:  MOVLW  00
0BFE4:  ADDWFC 02,F
0BFE6:  ADDWFC 01,F
0BFE8:  MOVF   xF6,W
0BFEA:  MULWF  xF9
0BFEC:  MOVF   FF3,W
0BFEE:  ADDWF  03,F
0BFF0:  MOVF   FF4,W
0BFF2:  ADDWFC 02,F
0BFF4:  MOVLW  00
0BFF6:  ADDWFC 01,F
0BFF8:  MOVF   xF5,W
0BFFA:  MULWF  xF9
0BFFC:  MOVF   FF3,W
0BFFE:  ADDWF  02,F
0C000:  MOVF   FF4,W
0C002:  ADDWFC 01,F
0C004:  INCF   00,F
0C006:  BTFSC  01.7
0C008:  BRA    C014
0C00A:  RLCF   xFD,F
0C00C:  RLCF   03,F
0C00E:  RLCF   02,F
0C010:  RLCF   01,F
0C012:  DECF   00,F
0C014:  MOVLW  00
0C016:  BTFSS  xFD.7
0C018:  BRA    C02E
0C01A:  INCF   03,F
0C01C:  ADDWFC 02,F
0C01E:  ADDWFC 01,F
0C020:  MOVF   01,W
0C022:  BNZ   C02E
0C024:  MOVF   02,W
0C026:  BNZ   C02E
0C028:  MOVF   03,W
0C02A:  BNZ   C02E
0C02C:  INCF   00,F
0C02E:  BTFSC  xFC.7
0C030:  BSF    01.7
0C032:  BTFSS  xFC.7
0C034:  BCF    01.7
0C036:  BRA    C040
0C038:  CLRF   00
0C03A:  CLRF   01
0C03C:  CLRF   02
0C03E:  CLRF   03
0C040:  MOVLB  0
0C042:  RETURN 0
0C044:  MOVLW  80
0C046:  BTFSS  FD8.1
0C048:  BRA    C04E
0C04A:  MOVLB  8
0C04C:  XORWF  xFD,F
0C04E:  MOVLB  9
0C050:  CLRF   x02
0C052:  CLRF   x03
0C054:  MOVFF  8F9,901
0C058:  MOVLB  8
0C05A:  MOVF   xFD,W
0C05C:  MOVLB  9
0C05E:  XORWF  x01,F
0C060:  MOVLB  8
0C062:  MOVF   xF8,W
0C064:  BTFSC  FD8.2
0C066:  BRA    C22E
0C068:  MOVLB  9
0C06A:  MOVWF  x00
0C06C:  MOVWF  00
0C06E:  MOVLB  8
0C070:  MOVF   xFC,W
0C072:  BTFSC  FD8.2
0C074:  BRA    C242
0C076:  MOVLB  9
0C078:  SUBWF  x00,F
0C07A:  BTFSC  FD8.2
0C07C:  BRA    C186
0C07E:  BNC   C0FC
0C080:  MOVFF  8FD,906
0C084:  BSF    x06.7
0C086:  MOVFF  8FE,905
0C08A:  MOVFF  8FF,904
0C08E:  CLRF   x03
0C090:  BCF    FD8.0
0C092:  RRCF   x06,F
0C094:  RRCF   x05,F
0C096:  RRCF   x04,F
0C098:  RRCF   x03,F
0C09A:  DECFSZ x00,F
0C09C:  BRA    C08E
0C09E:  BTFSS  x01.7
0C0A0:  BRA    C0A8
0C0A2:  BSF    x02.0
0C0A4:  BRA    C26C
0C0A6:  BCF    x02.0
0C0A8:  BCF    x00.0
0C0AA:  BSF    x02.4
0C0AC:  MOVLW  08
0C0AE:  MOVWF  FEA
0C0B0:  MOVLW  FB
0C0B2:  MOVWF  FE9
0C0B4:  BRA    C292
0C0B6:  BCF    x02.4
0C0B8:  BTFSC  x01.7
0C0BA:  BRA    C0D0
0C0BC:  BTFSS  x00.0
0C0BE:  BRA    C0E6
0C0C0:  RRCF   x06,F
0C0C2:  RRCF   x05,F
0C0C4:  RRCF   x04,F
0C0C6:  RRCF   x03,F
0C0C8:  INCF   00,F
0C0CA:  BTFSC  FD8.2
0C0CC:  BRA    C262
0C0CE:  BRA    C0E6
0C0D0:  BTFSC  x06.7
0C0D2:  BRA    C0EC
0C0D4:  BCF    FD8.0
0C0D6:  RLCF   x03,F
0C0D8:  RLCF   x04,F
0C0DA:  RLCF   x05,F
0C0DC:  RLCF   x06,F
0C0DE:  DECF   00,F
0C0E0:  BTFSC  FD8.2
0C0E2:  BRA    C262
0C0E4:  BRA    C0D0
0C0E6:  BSF    x02.6
0C0E8:  BRA    C1C6
0C0EA:  BCF    x02.6
0C0EC:  MOVFF  8F9,901
0C0F0:  BTFSS  x01.7
0C0F2:  BRA    C0F8
0C0F4:  BSF    x06.7
0C0F6:  BRA    C254
0C0F8:  BCF    x06.7
0C0FA:  BRA    C254
0C0FC:  MOVFF  8FC,900
0C100:  MOVFF  8FC,00
0C104:  MOVLB  8
0C106:  MOVF   xF8,W
0C108:  MOVLB  9
0C10A:  SUBWF  x00,F
0C10C:  MOVFF  8F9,906
0C110:  BSF    x06.7
0C112:  MOVFF  8FA,905
0C116:  MOVFF  8FB,904
0C11A:  CLRF   x03
0C11C:  BCF    FD8.0
0C11E:  RRCF   x06,F
0C120:  RRCF   x05,F
0C122:  RRCF   x04,F
0C124:  RRCF   x03,F
0C126:  DECFSZ x00,F
0C128:  BRA    C11A
0C12A:  BTFSS  x01.7
0C12C:  BRA    C134
0C12E:  BSF    x02.1
0C130:  BRA    C26C
0C132:  BCF    x02.1
0C134:  BCF    x00.0
0C136:  BSF    x02.5
0C138:  MOVLW  08
0C13A:  MOVWF  FEA
0C13C:  SETF   FE9
0C13E:  BRA    C292
0C140:  BCF    x02.5
0C142:  BTFSC  x01.7
0C144:  BRA    C15A
0C146:  BTFSS  x00.0
0C148:  BRA    C170
0C14A:  RRCF   x06,F
0C14C:  RRCF   x05,F
0C14E:  RRCF   x04,F
0C150:  RRCF   x03,F
0C152:  INCF   00,F
0C154:  BTFSC  FD8.2
0C156:  BRA    C262
0C158:  BRA    C170
0C15A:  BTFSC  x06.7
0C15C:  BRA    C176
0C15E:  BCF    FD8.0
0C160:  RLCF   x03,F
0C162:  RLCF   x04,F
0C164:  RLCF   x05,F
0C166:  RLCF   x06,F
0C168:  DECF   00,F
0C16A:  BTFSC  FD8.2
0C16C:  BRA    C262
0C16E:  BRA    C15A
0C170:  BSF    x02.7
0C172:  BRA    C1C6
0C174:  BCF    x02.7
0C176:  MOVFF  8FD,901
0C17A:  BTFSS  x01.7
0C17C:  BRA    C182
0C17E:  BSF    x06.7
0C180:  BRA    C254
0C182:  BCF    x06.7
0C184:  BRA    C254
0C186:  MOVFF  8FD,906
0C18A:  BSF    x06.7
0C18C:  MOVFF  8FE,905
0C190:  MOVFF  8FF,904
0C194:  BTFSS  x01.7
0C196:  BRA    C1A0
0C198:  BCF    x06.7
0C19A:  BSF    x02.2
0C19C:  BRA    C26C
0C19E:  BCF    x02.2
0C1A0:  CLRF   x03
0C1A2:  BCF    x00.0
0C1A4:  MOVLW  08
0C1A6:  MOVWF  FEA
0C1A8:  MOVLW  FB
0C1AA:  MOVWF  FE9
0C1AC:  BRA    C292
0C1AE:  BTFSC  x01.7
0C1B0:  BRA    C1EA
0C1B2:  MOVFF  8F9,901
0C1B6:  BTFSS  x00.0
0C1B8:  BRA    C1C6
0C1BA:  RRCF   x06,F
0C1BC:  RRCF   x05,F
0C1BE:  RRCF   x04,F
0C1C0:  RRCF   x03,F
0C1C2:  INCF   00,F
0C1C4:  BZ    C262
0C1C6:  BTFSS  x03.7
0C1C8:  BRA    C1E0
0C1CA:  INCF   x04,F
0C1CC:  BNZ   C1E0
0C1CE:  INCF   x05,F
0C1D0:  BNZ   C1E0
0C1D2:  INCF   x06,F
0C1D4:  BNZ   C1E0
0C1D6:  RRCF   x06,F
0C1D8:  RRCF   x05,F
0C1DA:  RRCF   x04,F
0C1DC:  INCF   00,F
0C1DE:  BZ    C262
0C1E0:  BTFSC  x02.6
0C1E2:  BRA    C0EA
0C1E4:  BTFSC  x02.7
0C1E6:  BRA    C174
0C1E8:  BRA    C222
0C1EA:  MOVLW  80
0C1EC:  XORWF  x06,F
0C1EE:  BTFSS  x06.7
0C1F0:  BRA    C1FA
0C1F2:  BRA    C26C
0C1F4:  MOVFF  8FD,901
0C1F8:  BRA    C20E
0C1FA:  MOVFF  8F9,901
0C1FE:  MOVF   x06,F
0C200:  BNZ   C20E
0C202:  MOVF   x05,F
0C204:  BNZ   C20E
0C206:  MOVF   x04,F
0C208:  BNZ   C20E
0C20A:  CLRF   00
0C20C:  BRA    C254
0C20E:  BTFSC  x06.7
0C210:  BRA    C222
0C212:  BCF    FD8.0
0C214:  RLCF   x03,F
0C216:  RLCF   x04,F
0C218:  RLCF   x05,F
0C21A:  RLCF   x06,F
0C21C:  DECFSZ 00,F
0C21E:  BRA    C20E
0C220:  BRA    C262
0C222:  BTFSS  x01.7
0C224:  BRA    C22A
0C226:  BSF    x06.7
0C228:  BRA    C254
0C22A:  BCF    x06.7
0C22C:  BRA    C254
0C22E:  MOVFF  8FC,00
0C232:  MOVFF  8FD,906
0C236:  MOVFF  8FE,905
0C23A:  MOVFF  8FF,904
0C23E:  MOVLB  9
0C240:  BRA    C254
0C242:  MOVFF  8F8,00
0C246:  MOVFF  8F9,906
0C24A:  MOVFF  8FA,905
0C24E:  MOVFF  8FB,904
0C252:  MOVLB  9
0C254:  MOVFF  906,01
0C258:  MOVFF  905,02
0C25C:  MOVFF  904,03
0C260:  BRA    C2CA
0C262:  CLRF   00
0C264:  CLRF   01
0C266:  CLRF   02
0C268:  CLRF   03
0C26A:  BRA    C2CA
0C26C:  CLRF   x03
0C26E:  COMF   x04,F
0C270:  COMF   x05,F
0C272:  COMF   x06,F
0C274:  COMF   x03,F
0C276:  INCF   x03,F
0C278:  BNZ   C284
0C27A:  INCF   x04,F
0C27C:  BNZ   C284
0C27E:  INCF   x05,F
0C280:  BNZ   C284
0C282:  INCF   x06,F
0C284:  BTFSC  x02.0
0C286:  BRA    C0A6
0C288:  BTFSC  x02.1
0C28A:  BRA    C132
0C28C:  BTFSC  x02.2
0C28E:  BRA    C19E
0C290:  BRA    C1F4
0C292:  MOVF   FEF,W
0C294:  ADDWF  x04,F
0C296:  BNC   C2A2
0C298:  INCF   x05,F
0C29A:  BNZ   C2A2
0C29C:  INCF   x06,F
0C29E:  BTFSC  FD8.2
0C2A0:  BSF    x00.0
0C2A2:  MOVF   FED,F
0C2A4:  MOVF   FEF,W
0C2A6:  ADDWF  x05,F
0C2A8:  BNC   C2B0
0C2AA:  INCF   x06,F
0C2AC:  BTFSC  FD8.2
0C2AE:  BSF    x00.0
0C2B0:  MOVF   FED,F
0C2B2:  MOVF   FEF,W
0C2B4:  BTFSC  FEF.7
0C2B6:  BRA    C2BA
0C2B8:  XORLW  80
0C2BA:  ADDWF  x06,F
0C2BC:  BTFSC  FD8.0
0C2BE:  BSF    x00.0
0C2C0:  BTFSC  x02.4
0C2C2:  BRA    C0B6
0C2C4:  BTFSC  x02.5
0C2C6:  BRA    C140
0C2C8:  BRA    C1AE
0C2CA:  MOVLB  0
0C2CC:  RETURN 0
0C2CE:  MOVLB  8
0C2D0:  MOVF   xBD,W
0C2D2:  SUBLW  B6
0C2D4:  MOVWF  xBD
0C2D6:  CLRF   03
0C2D8:  MOVFF  8BE,8C1
0C2DC:  BSF    xBE.7
0C2DE:  BCF    FD8.0
0C2E0:  RRCF   xBE,F
0C2E2:  RRCF   xBF,F
0C2E4:  RRCF   xC0,F
0C2E6:  RRCF   03,F
0C2E8:  RRCF   02,F
0C2EA:  RRCF   01,F
0C2EC:  RRCF   00,F
0C2EE:  DECFSZ xBD,F
0C2F0:  BRA    C2DE
0C2F2:  BTFSS  xC1.7
0C2F4:  BRA    C30C
0C2F6:  COMF   00,F
0C2F8:  COMF   01,F
0C2FA:  COMF   02,F
0C2FC:  COMF   03,F
0C2FE:  INCF   00,F
0C300:  BTFSC  FD8.2
0C302:  INCF   01,F
0C304:  BTFSC  FD8.2
0C306:  INCF   02,F
0C308:  BTFSC  FD8.2
0C30A:  INCF   03,F
0C30C:  MOVLB  0
0C30E:  RETURN 0
0C310:  MOVF   FE9,W
0C312:  MOVLB  8
0C314:  MOVWF  x6B
0C316:  MOVF   x6A,W
0C318:  MOVWF  x6D
0C31A:  BZ    C352
0C31C:  MOVFF  869,8F7
0C320:  MOVFF  868,8F6
0C324:  MOVFF  867,8F5
0C328:  MOVFF  866,8F4
0C32C:  CLRF   xFB
0C32E:  CLRF   xFA
0C330:  MOVLW  20
0C332:  MOVWF  xF9
0C334:  MOVLW  82
0C336:  MOVWF  xF8
0C338:  MOVLB  0
0C33A:  RCALL  BF4E
0C33C:  MOVFF  03,869
0C340:  MOVFF  02,868
0C344:  MOVFF  01,867
0C348:  MOVFF  00,866
0C34C:  MOVLB  8
0C34E:  DECFSZ x6D,F
0C350:  BRA    C31C
0C352:  MOVLW  7E
0C354:  MOVWF  00
0C356:  CLRF   01
0C358:  BTFSC  x67.7
0C35A:  BSF    01.7
0C35C:  CLRF   02
0C35E:  CLRF   03
0C360:  BCF    FD8.1
0C362:  MOVFF  869,8FB
0C366:  MOVFF  868,8FA
0C36A:  MOVFF  867,8F9
0C36E:  MOVFF  866,8F8
0C372:  MOVFF  03,8FF
0C376:  MOVFF  02,8FE
0C37A:  MOVFF  01,8FD
0C37E:  MOVWF  xFC
0C380:  MOVLB  0
0C382:  RCALL  C044
0C384:  MOVFF  03,869
0C388:  MOVFF  02,868
0C38C:  MOVFF  01,867
0C390:  MOVFF  00,866
0C394:  MOVFF  869,8C0
0C398:  MOVFF  868,8BF
0C39C:  MOVFF  867,8BE
0C3A0:  MOVFF  866,8BD
0C3A4:  RCALL  C2CE
0C3A6:  MOVFF  03,869
0C3AA:  MOVFF  02,868
0C3AE:  MOVFF  01,867
0C3B2:  MOVFF  00,866
0C3B6:  MOVLB  8
0C3B8:  BTFSS  x69.7
0C3BA:  BRA    C3D6
0C3BC:  DECF   x6B,F
0C3BE:  BSF    x6B.5
0C3C0:  COMF   x66,F
0C3C2:  COMF   x67,F
0C3C4:  COMF   x68,F
0C3C6:  COMF   x69,F
0C3C8:  INCF   x66,F
0C3CA:  BTFSC  FD8.2
0C3CC:  INCF   x67,F
0C3CE:  BTFSC  FD8.2
0C3D0:  INCF   x68,F
0C3D2:  BTFSC  FD8.2
0C3D4:  INCF   x69,F
0C3D6:  MOVLW  3B
0C3D8:  MOVWF  x72
0C3DA:  MOVLW  9A
0C3DC:  MOVWF  x71
0C3DE:  MOVLW  CA
0C3E0:  MOVWF  x70
0C3E2:  CLRF   x6F
0C3E4:  MOVLW  0A
0C3E6:  MOVWF  x6D
0C3E8:  MOVF   x6A,W
0C3EA:  BTFSC  FD8.2
0C3EC:  INCF   x6B,F
0C3EE:  BSF    FD8.1
0C3F0:  MOVLW  08
0C3F2:  MOVWF  FEA
0C3F4:  MOVLW  66
0C3F6:  MOVWF  FE9
0C3F8:  CLRF   1B
0C3FA:  BTFSC  FF2.7
0C3FC:  BSF    1B.7
0C3FE:  BCF    FF2.7
0C400:  MOVFF  869,A2B
0C404:  MOVFF  868,A2A
0C408:  MOVFF  867,A29
0C40C:  MOVFF  866,A28
0C410:  MOVFF  872,A2F
0C414:  MOVFF  871,A2E
0C418:  MOVFF  870,A2D
0C41C:  MOVFF  86F,A2C
0C420:  MOVLB  0
0C422:  CALL   1056
0C426:  BTFSC  1B.7
0C428:  BSF    FF2.7
0C42A:  MOVF   01,W
0C42C:  MOVF   00,F
0C42E:  BNZ   C456
0C430:  MOVLB  8
0C432:  INCF   x6A,W
0C434:  SUBWF  x6D,W
0C436:  BTFSS  FD8.2
0C438:  BRA    C43E
0C43A:  MOVLB  0
0C43C:  BRA    C456
0C43E:  MOVF   x6B,W
0C440:  BZ    C45C
0C442:  ANDLW  0F
0C444:  SUBWF  x6D,W
0C446:  BZ    C44A
0C448:  BC    C4C2
0C44A:  BTFSC  x6B.7
0C44C:  BRA    C4C2
0C44E:  BTFSC  x6B.6
0C450:  BRA    C45C
0C452:  MOVLW  20
0C454:  BRA    C4B8
0C456:  MOVLW  20
0C458:  MOVLB  8
0C45A:  ANDWF  x6B,F
0C45C:  BTFSS  x6B.5
0C45E:  BRA    C47A
0C460:  BCF    x6B.5
0C462:  MOVF   x6A,W
0C464:  BTFSS  FD8.2
0C466:  DECF   x6B,F
0C468:  MOVF   00,W
0C46A:  MOVWF  x6B
0C46C:  MOVLW  2D
0C46E:  BTFSS  F9E.4
0C470:  BRA    C46E
0C472:  MOVWF  FAD
0C474:  MOVF   x6B,W
0C476:  MOVWF  00
0C478:  CLRF   x6B
0C47A:  MOVF   x6A,W
0C47C:  SUBWF  x6D,W
0C47E:  BNZ   C496
0C480:  MOVF   00,W
0C482:  MOVWF  x6B
0C484:  MOVLW  2E
0C486:  BTFSS  F9E.4
0C488:  BRA    C486
0C48A:  MOVWF  FAD
0C48C:  MOVF   x6B,W
0C48E:  MOVWF  00
0C490:  MOVLW  20
0C492:  ANDWF  x6B,F
0C494:  MOVLW  00
0C496:  MOVLW  30
0C498:  BTFSS  x6B.5
0C49A:  BRA    C4B8
0C49C:  BCF    x6B.5
0C49E:  MOVF   x6A,W
0C4A0:  BTFSS  FD8.2
0C4A2:  DECF   x6B,F
0C4A4:  MOVF   00,W
0C4A6:  MOVWF  x6B
0C4A8:  MOVLW  2D
0C4AA:  BTFSS  F9E.4
0C4AC:  BRA    C4AA
0C4AE:  MOVWF  FAD
0C4B0:  MOVF   x6B,W
0C4B2:  MOVWF  00
0C4B4:  CLRF   x6B
0C4B6:  MOVLW  30
0C4B8:  ADDWF  00,F
0C4BA:  MOVF   00,W
0C4BC:  BTFSS  F9E.4
0C4BE:  BRA    C4BC
0C4C0:  MOVWF  FAD
0C4C2:  BCF    FD8.1
0C4C4:  CLRF   1B
0C4C6:  BTFSC  FF2.7
0C4C8:  BSF    1B.7
0C4CA:  BCF    FF2.7
0C4CC:  MOVFF  872,A2B
0C4D0:  MOVFF  871,A2A
0C4D4:  MOVFF  870,A29
0C4D8:  MOVFF  86F,A28
0C4DC:  MOVLB  A
0C4DE:  CLRF   x2F
0C4E0:  CLRF   x2E
0C4E2:  CLRF   x2D
0C4E4:  MOVLW  0A
0C4E6:  MOVWF  x2C
0C4E8:  MOVLB  0
0C4EA:  CALL   1056
0C4EE:  BTFSC  1B.7
0C4F0:  BSF    FF2.7
0C4F2:  MOVFF  03,872
0C4F6:  MOVFF  02,871
0C4FA:  MOVFF  01,870
0C4FE:  MOVFF  00,86F
0C502:  MOVLB  8
0C504:  DECFSZ x6D,F
0C506:  BRA    C3EE
0C508:  MOVLB  0
0C50A:  RETURN 0
*
0C58E:  MOVLW  8E
0C590:  MOVWF  00
0C592:  MOVFF  8F9,01
0C596:  MOVFF  8F8,02
0C59A:  CLRF   03
0C59C:  MOVF   01,F
0C59E:  BNZ   C5B2
0C5A0:  MOVFF  02,01
0C5A4:  CLRF   02
0C5A6:  MOVLW  08
0C5A8:  SUBWF  00,F
0C5AA:  MOVF   01,F
0C5AC:  BNZ   C5B2
0C5AE:  CLRF   00
0C5B0:  BRA    C5C2
0C5B2:  BCF    FD8.0
0C5B4:  BTFSC  01.7
0C5B6:  BRA    C5C0
0C5B8:  RLCF   02,F
0C5BA:  RLCF   01,F
0C5BC:  DECF   00,F
0C5BE:  BRA    C5B2
0C5C0:  BCF    01.7
0C5C2:  RETURN 0
0C5C4:  MOVLB  8
0C5C6:  MOVF   xDC,W
0C5C8:  BTFSC  FD8.2
0C5CA:  BRA    C716
0C5CC:  MOVWF  xE8
0C5CE:  MOVF   xE0,W
0C5D0:  BTFSC  FD8.2
0C5D2:  BRA    C716
0C5D4:  SUBWF  xE8,F
0C5D6:  BNC   C5E2
0C5D8:  MOVLW  7F
0C5DA:  ADDWF  xE8,F
0C5DC:  BTFSC  FD8.0
0C5DE:  BRA    C716
0C5E0:  BRA    C5EE
0C5E2:  MOVLW  81
0C5E4:  SUBWF  xE8,F
0C5E6:  BTFSS  FD8.0
0C5E8:  BRA    C716
0C5EA:  BTFSC  FD8.2
0C5EC:  BRA    C716
0C5EE:  MOVFF  8E8,00
0C5F2:  CLRF   01
0C5F4:  CLRF   02
0C5F6:  CLRF   03
0C5F8:  CLRF   xE7
0C5FA:  MOVFF  8DD,8E6
0C5FE:  BSF    xE6.7
0C600:  MOVFF  8DE,8E5
0C604:  MOVFF  8DF,8E4
0C608:  MOVLW  19
0C60A:  MOVWF  xE8
0C60C:  MOVF   xE3,W
0C60E:  SUBWF  xE4,F
0C610:  BC    C62C
0C612:  MOVLW  01
0C614:  SUBWF  xE5,F
0C616:  BC    C62C
0C618:  SUBWF  xE6,F
0C61A:  BC    C62C
0C61C:  SUBWF  xE7,F
0C61E:  BC    C62C
0C620:  INCF   xE7,F
0C622:  INCF   xE6,F
0C624:  INCF   xE5,F
0C626:  MOVF   xE3,W
0C628:  ADDWF  xE4,F
0C62A:  BRA    C67C
0C62C:  MOVF   xE2,W
0C62E:  SUBWF  xE5,F
0C630:  BC    C656
0C632:  MOVLW  01
0C634:  SUBWF  xE6,F
0C636:  BC    C656
0C638:  SUBWF  xE7,F
0C63A:  BC    C656
0C63C:  INCF   xE7,F
0C63E:  INCF   xE6,F
0C640:  MOVF   xE2,W
0C642:  ADDWF  xE5,F
0C644:  MOVF   xE3,W
0C646:  ADDWF  xE4,F
0C648:  BNC   C67C
0C64A:  INCF   xE5,F
0C64C:  BNZ   C67C
0C64E:  INCF   xE6,F
0C650:  BNZ   C67C
0C652:  INCF   xE7,F
0C654:  BRA    C67C
0C656:  MOVF   xE1,W
0C658:  IORLW  80
0C65A:  SUBWF  xE6,F
0C65C:  BC    C67A
0C65E:  MOVLW  01
0C660:  SUBWF  xE7,F
0C662:  BC    C67A
0C664:  INCF   xE7,F
0C666:  MOVF   xE1,W
0C668:  IORLW  80
0C66A:  ADDWF  xE6,F
0C66C:  MOVF   xE2,W
0C66E:  ADDWF  xE5,F
0C670:  BNC   C644
0C672:  INCF   xE6,F
0C674:  BNZ   C644
0C676:  INCF   xE7,F
0C678:  BRA    C644
0C67A:  BSF    03.0
0C67C:  DECFSZ xE8,F
0C67E:  BRA    C682
0C680:  BRA    C698
0C682:  BCF    FD8.0
0C684:  RLCF   xE4,F
0C686:  RLCF   xE5,F
0C688:  RLCF   xE6,F
0C68A:  RLCF   xE7,F
0C68C:  BCF    FD8.0
0C68E:  RLCF   03,F
0C690:  RLCF   02,F
0C692:  RLCF   01,F
0C694:  RLCF   xE9,F
0C696:  BRA    C60C
0C698:  BTFSS  xE9.0
0C69A:  BRA    C6A8
0C69C:  BCF    FD8.0
0C69E:  RRCF   01,F
0C6A0:  RRCF   02,F
0C6A2:  RRCF   03,F
0C6A4:  RRCF   xE9,F
0C6A6:  BRA    C6AC
0C6A8:  DECF   00,F
0C6AA:  BZ    C716
0C6AC:  BTFSC  xE9.7
0C6AE:  BRA    C6EC
0C6B0:  BCF    FD8.0
0C6B2:  RLCF   xE4,F
0C6B4:  RLCF   xE5,F
0C6B6:  RLCF   xE6,F
0C6B8:  RLCF   xE7,F
0C6BA:  MOVF   xE3,W
0C6BC:  SUBWF  xE4,F
0C6BE:  BC    C6CE
0C6C0:  MOVLW  01
0C6C2:  SUBWF  xE5,F
0C6C4:  BC    C6CE
0C6C6:  SUBWF  xE6,F
0C6C8:  BC    C6CE
0C6CA:  SUBWF  xE7,F
0C6CC:  BNC   C702
0C6CE:  MOVF   xE2,W
0C6D0:  SUBWF  xE5,F
0C6D2:  BC    C6DE
0C6D4:  MOVLW  01
0C6D6:  SUBWF  xE6,F
0C6D8:  BC    C6DE
0C6DA:  SUBWF  xE7,F
0C6DC:  BNC   C702
0C6DE:  MOVF   xE1,W
0C6E0:  IORLW  80
0C6E2:  SUBWF  xE6,F
0C6E4:  BC    C6EC
0C6E6:  MOVLW  01
0C6E8:  SUBWF  xE7,F
0C6EA:  BNC   C702
0C6EC:  INCF   03,F
0C6EE:  BNZ   C702
0C6F0:  INCF   02,F
0C6F2:  BNZ   C702
0C6F4:  INCF   01,F
0C6F6:  BNZ   C702
0C6F8:  INCF   00,F
0C6FA:  BZ    C716
0C6FC:  RRCF   01,F
0C6FE:  RRCF   02,F
0C700:  RRCF   03,F
0C702:  MOVFF  8DD,8E8
0C706:  MOVF   xE1,W
0C708:  XORWF  xE8,F
0C70A:  BTFSS  xE8.7
0C70C:  BRA    C712
0C70E:  BSF    01.7
0C710:  BRA    C71E
0C712:  BCF    01.7
0C714:  BRA    C71E
0C716:  CLRF   00
0C718:  CLRF   01
0C71A:  CLRF   02
0C71C:  CLRF   03
0C71E:  MOVLB  0
0C720:  RETURN 0
*
0D1AC:  MOVFF  FEA,8AA
0D1B0:  MOVFF  FE9,8A9
0D1B4:  MOVLB  8
0D1B6:  BTFSS  xA3.7
0D1B8:  BRA    D1CA
0D1BA:  BSF    xA9.7
0D1BC:  BTFSS  xA9.4
0D1BE:  INCF   xA9,F
0D1C0:  COMF   xA2,F
0D1C2:  COMF   xA3,F
0D1C4:  INCF   xA2,F
0D1C6:  BTFSC  FD8.2
0D1C8:  INCF   xA3,F
0D1CA:  SWAPF  xA3,W
0D1CC:  IORLW  F0
0D1CE:  MOVWF  xA5
0D1D0:  ADDWF  xA5,F
0D1D2:  ADDLW  E2
0D1D4:  MOVWF  xA6
0D1D6:  ADDLW  32
0D1D8:  MOVWF  xA8
0D1DA:  MOVF   xA3,W
0D1DC:  ANDLW  0F
0D1DE:  ADDWF  xA6,F
0D1E0:  ADDWF  xA6,F
0D1E2:  ADDWF  xA8,F
0D1E4:  ADDLW  E9
0D1E6:  MOVWF  xA7
0D1E8:  ADDWF  xA7,F
0D1EA:  ADDWF  xA7,F
0D1EC:  SWAPF  xA2,W
0D1EE:  ANDLW  0F
0D1F0:  ADDWF  xA7,F
0D1F2:  ADDWF  xA8,F
0D1F4:  RLCF   xA7,F
0D1F6:  RLCF   xA8,F
0D1F8:  COMF   xA8,F
0D1FA:  RLCF   xA8,F
0D1FC:  MOVF   xA2,W
0D1FE:  ANDLW  0F
0D200:  ADDWF  xA8,F
0D202:  RLCF   xA5,F
0D204:  MOVLW  07
0D206:  MOVWF  xA4
0D208:  MOVLW  0A
0D20A:  DECF   xA7,F
0D20C:  ADDWF  xA8,F
0D20E:  BNC   D20A
0D210:  DECF   xA6,F
0D212:  ADDWF  xA7,F
0D214:  BNC   D210
0D216:  DECF   xA5,F
0D218:  ADDWF  xA6,F
0D21A:  BNC   D216
0D21C:  DECF   xA4,F
0D21E:  ADDWF  xA5,F
0D220:  BNC   D21C
0D222:  MOVLW  08
0D224:  MOVWF  FEA
0D226:  MOVLW  A4
0D228:  MOVWF  FE9
0D22A:  MOVLW  07
0D22C:  ANDWF  xA9,W
0D22E:  BCF    xA9.6
0D230:  MOVF   FED,F
0D232:  ANDWF  xA9,W
0D234:  BNZ   D244
0D236:  BTFSC  xA9.4
0D238:  MOVF   FEE,F
0D23A:  BTFSC  xA9.4
0D23C:  BRA    D244
0D23E:  MOVLW  20
0D240:  MOVWF  00
0D242:  BRA    D286
0D244:  ADDWF  FE9,F
0D246:  MOVLW  00
0D248:  ADDWFC FEA,F
0D24A:  MOVF   FE9,W
0D24C:  SUBLW  A8
0D24E:  BNZ   D258
0D250:  MOVF   FEA,W
0D252:  SUBLW  08
0D254:  BNZ   D258
0D256:  BSF    xA9.6
0D258:  MOVF   FEF,W
0D25A:  MOVWF  00
0D25C:  BNZ   D26E
0D25E:  BTFSC  xA9.6
0D260:  BRA    D26E
0D262:  BTFSC  xA9.4
0D264:  BRA    D2A2
0D266:  BTFSC  xA9.3
0D268:  BRA    D26E
0D26A:  MOVLW  20
0D26C:  BRA    D284
0D26E:  BTFSS  xA9.7
0D270:  BRA    D27E
0D272:  MOVLW  2D
0D274:  MOVWF  00
0D276:  MOVF   FED,W
0D278:  BCF    xA9.6
0D27A:  BCF    xA9.7
0D27C:  BRA    D286
0D27E:  BSF    xA9.3
0D280:  BCF    xA9.4
0D282:  MOVLW  30
0D284:  ADDWF  00,F
0D286:  MOVFF  FEA,8A3
0D28A:  MOVFF  FE9,8A2
0D28E:  MOVFF  00,8E0
0D292:  MOVLB  0
0D294:  CALL   5032
0D298:  MOVFF  8A3,FEA
0D29C:  MOVFF  8A2,FE9
0D2A0:  MOVLB  8
0D2A2:  MOVF   FEE,W
0D2A4:  BTFSS  xA9.6
0D2A6:  BRA    D24A
0D2A8:  MOVLB  0
0D2AA:  GOTO   D3CE (RETURN)
*
0D652:  ADDWF  FE8,W
0D654:  CLRF   FF7
0D656:  RLCF   FF7,F
0D658:  ADDLW  73
0D65A:  MOVWF  FF6
0D65C:  MOVLW  D6
0D65E:  ADDWFC FF7,F
0D660:  MOVLW  00
0D662:  MOVWF  FF8
0D664:  MOVWF  FFB
0D666:  TBLRD*-
0D668:  MOVF   FF5,W
0D66A:  MOVWF  FFA
0D66C:  TBLRD*
0D66E:  MOVF   FF5,W
0D670:  MOVWF  FF9
0D672:  DATA 84,D5
0D674:  DATA AC,D5
0D676:  DATA CC,D5
0D678:  DATA EC,D5
0D67A:  DATA 0C,D6
0D67C:  DATA 2C,D6
*
0D6FC:  TBLRD*+
0D6FE:  MOVFF  FF6,89A
0D702:  MOVFF  FF7,89B
0D706:  MOVFF  FF8,89C
0D70A:  MOVF   FF5,W
0D70C:  BTFSS  FA4.4
0D70E:  BRA    D70C
0D710:  MOVLB  F
0D712:  MOVWF  x1C
0D714:  MOVFF  89A,FF6
0D718:  MOVFF  89B,FF7
0D71C:  MOVFF  89C,FF8
0D720:  MOVLB  8
0D722:  DECFSZ x99,F
0D724:  BRA    D728
0D726:  BRA    D72C
0D728:  MOVLB  0
0D72A:  BRA    D6FC
0D72C:  MOVLB  0
0D72E:  RETURN 0
0D730:  MOVF   01,W
0D732:  CLRF   1B
0D734:  BTFSC  FF2.7
0D736:  BSF    1B.7
0D738:  BCF    FF2.7
0D73A:  MOVFF  8D4,A1E
0D73E:  MOVLW  64
0D740:  MOVLB  A
0D742:  MOVWF  x1F
0D744:  MOVLB  0
0D746:  CALL   0F7A
0D74A:  BTFSC  1B.7
0D74C:  BSF    FF2.7
0D74E:  MOVFF  00,8D4
0D752:  MOVF   01,W
0D754:  MOVLW  30
0D756:  BNZ   D768
0D758:  MOVLB  8
0D75A:  BTFSS  xD5.1
0D75C:  BRA    D77E
0D75E:  BTFSC  xD5.3
0D760:  BRA    D77E
0D762:  BTFSC  xD5.4
0D764:  MOVLW  20
0D766:  BRA    D770
0D768:  MOVLB  8
0D76A:  BCF    xD5.3
0D76C:  BCF    xD5.4
0D76E:  BSF    xD5.0
0D770:  ADDWF  01,F
0D772:  MOVF   01,W
0D774:  BTFSS  FA4.4
0D776:  BRA    D774
0D778:  MOVLB  F
0D77A:  MOVWF  x1C
0D77C:  MOVLB  8
0D77E:  CLRF   1B
0D780:  BTFSC  FF2.7
0D782:  BSF    1B.7
0D784:  BCF    FF2.7
0D786:  MOVFF  8D4,A1E
0D78A:  MOVLW  0A
0D78C:  MOVLB  A
0D78E:  MOVWF  x1F
0D790:  MOVLB  0
0D792:  CALL   0F7A
0D796:  BTFSC  1B.7
0D798:  BSF    FF2.7
0D79A:  MOVFF  00,8D4
0D79E:  MOVF   01,W
0D7A0:  MOVLW  30
0D7A2:  BNZ   D7B4
0D7A4:  MOVLB  8
0D7A6:  BTFSC  xD5.3
0D7A8:  BRA    D7C2
0D7AA:  BTFSS  xD5.0
0D7AC:  BRA    D7C2
0D7AE:  BTFSC  xD5.4
0D7B0:  MOVLW  20
0D7B2:  MOVLB  0
0D7B4:  ADDWF  01,F
0D7B6:  MOVF   01,W
0D7B8:  BTFSS  FA4.4
0D7BA:  BRA    D7B8
0D7BC:  MOVLB  F
0D7BE:  MOVWF  x1C
0D7C0:  MOVLB  8
0D7C2:  MOVLW  30
0D7C4:  ADDWF  xD4,F
0D7C6:  MOVF   xD4,W
0D7C8:  BTFSS  FA4.4
0D7CA:  BRA    D7C8
0D7CC:  MOVLB  F
0D7CE:  MOVWF  x1C
0D7D0:  MOVLB  0
0D7D2:  RETURN 0
*
0D7F6:  TBLRD*+
0D7F8:  MOVF   FF5,F
0D7FA:  BZ    D822
0D7FC:  MOVFF  FF6,898
0D800:  MOVFF  FF7,899
0D804:  MOVFF  FF8,89A
0D808:  MOVF   FF5,W
0D80A:  BTFSS  FA4.4
0D80C:  BRA    D80A
0D80E:  MOVLB  F
0D810:  MOVWF  x1C
0D812:  MOVFF  898,FF6
0D816:  MOVFF  899,FF7
0D81A:  MOVFF  89A,FF8
0D81E:  MOVLB  0
0D820:  BRA    D7F6
0D822:  GOTO   D8E4 (RETURN)
*
0DDFE:  MOVF   FE9,W
0DE00:  MOVLB  8
0DE02:  MOVWF  x6D
0DE04:  MOVLW  3B
0DE06:  MOVWF  x74
0DE08:  MOVLW  9A
0DE0A:  MOVWF  x73
0DE0C:  MOVLW  CA
0DE0E:  MOVWF  x72
0DE10:  CLRF   x71
0DE12:  MOVLW  0A
0DE14:  MOVWF  x6F
0DE16:  MOVF   x6C,W
0DE18:  BTFSS  FD8.2
0DE1A:  DECF   x6D,F
0DE1C:  BSF    FD8.1
0DE1E:  MOVLW  08
0DE20:  MOVWF  FEA
0DE22:  MOVLW  68
0DE24:  MOVWF  FE9
0DE26:  CLRF   1B
0DE28:  BTFSC  FF2.7
0DE2A:  BSF    1B.7
0DE2C:  BCF    FF2.7
0DE2E:  MOVFF  86B,A2B
0DE32:  MOVFF  86A,A2A
0DE36:  MOVFF  869,A29
0DE3A:  MOVFF  868,A28
0DE3E:  MOVFF  874,A2F
0DE42:  MOVFF  873,A2E
0DE46:  MOVFF  872,A2D
0DE4A:  MOVFF  871,A2C
0DE4E:  MOVLB  0
0DE50:  CALL   1056
0DE54:  BTFSC  1B.7
0DE56:  BSF    FF2.7
0DE58:  MOVF   01,W
0DE5A:  MOVF   00,F
0DE5C:  BNZ   DE84
0DE5E:  MOVLB  8
0DE60:  INCF   x6C,W
0DE62:  SUBWF  x6F,W
0DE64:  BTFSS  FD8.2
0DE66:  BRA    DE6C
0DE68:  MOVLB  0
0DE6A:  BRA    DE84
0DE6C:  MOVF   x6D,W
0DE6E:  BZ    DE88
0DE70:  ANDLW  0F
0DE72:  SUBWF  x6F,W
0DE74:  BZ    DE78
0DE76:  BC    DEB0
0DE78:  BTFSC  x6D.7
0DE7A:  BRA    DEB0
0DE7C:  BTFSC  x6D.6
0DE7E:  BRA    DE88
0DE80:  MOVLW  20
0DE82:  BRA    DEA6
0DE84:  MOVLB  8
0DE86:  CLRF   x6D
0DE88:  MOVF   x6C,W
0DE8A:  SUBWF  x6F,W
0DE8C:  BNZ   DEA4
0DE8E:  MOVFF  00,86D
0DE92:  MOVLW  2E
0DE94:  BTFSS  F9E.4
0DE96:  BRA    DE94
0DE98:  MOVWF  FAD
0DE9A:  MOVFF  86D,00
0DE9E:  MOVLW  20
0DEA0:  ANDWF  x6D,F
0DEA2:  MOVLW  00
0DEA4:  MOVLW  30
0DEA6:  ADDWF  00,F
0DEA8:  MOVF   00,W
0DEAA:  BTFSS  F9E.4
0DEAC:  BRA    DEAA
0DEAE:  MOVWF  FAD
0DEB0:  BCF    FD8.1
0DEB2:  CLRF   1B
0DEB4:  BTFSC  FF2.7
0DEB6:  BSF    1B.7
0DEB8:  BCF    FF2.7
0DEBA:  MOVFF  874,A2B
0DEBE:  MOVFF  873,A2A
0DEC2:  MOVFF  872,A29
0DEC6:  MOVFF  871,A28
0DECA:  MOVLB  A
0DECC:  CLRF   x2F
0DECE:  CLRF   x2E
0DED0:  CLRF   x2D
0DED2:  MOVLW  0A
0DED4:  MOVWF  x2C
0DED6:  MOVLB  0
0DED8:  CALL   1056
0DEDC:  BTFSC  1B.7
0DEDE:  BSF    FF2.7
0DEE0:  MOVFF  03,874
0DEE4:  MOVFF  02,873
0DEE8:  MOVFF  01,872
0DEEC:  MOVFF  00,871
0DEF0:  MOVLB  8
0DEF2:  DECFSZ x6F,F
0DEF4:  BRA    DE1C
0DEF6:  MOVLB  0
0DEF8:  RETURN 0
*
0EF92:  MOVF   FE9,W
0EF94:  MOVLB  8
0EF96:  MOVWF  xD8
0EF98:  MOVLW  3B
0EF9A:  MOVWF  xDF
0EF9C:  MOVLW  9A
0EF9E:  MOVWF  xDE
0EFA0:  MOVLW  CA
0EFA2:  MOVWF  xDD
0EFA4:  CLRF   xDC
0EFA6:  MOVLW  0A
0EFA8:  MOVWF  xDA
0EFAA:  BSF    FD8.1
0EFAC:  MOVLW  08
0EFAE:  MOVWF  FEA
0EFB0:  MOVLW  D4
0EFB2:  MOVWF  FE9
0EFB4:  CLRF   1B
0EFB6:  BTFSC  FF2.7
0EFB8:  BSF    1B.7
0EFBA:  BCF    FF2.7
0EFBC:  MOVFF  8D7,A2B
0EFC0:  MOVFF  8D6,A2A
0EFC4:  MOVFF  8D5,A29
0EFC8:  MOVFF  8D4,A28
0EFCC:  MOVFF  8DF,A2F
0EFD0:  MOVFF  8DE,A2E
0EFD4:  MOVFF  8DD,A2D
0EFD8:  MOVFF  8DC,A2C
0EFDC:  MOVLB  0
0EFDE:  CALL   1056
0EFE2:  BTFSC  1B.7
0EFE4:  BSF    FF2.7
0EFE6:  MOVF   01,W
0EFE8:  MOVF   00,F
0EFEA:  BNZ   F012
0EFEC:  MOVLB  8
0EFEE:  MOVF   xDA,W
0EFF0:  XORLW  01
0EFF2:  BTFSS  FD8.2
0EFF4:  BRA    EFFA
0EFF6:  MOVLB  0
0EFF8:  BRA    F012
0EFFA:  MOVF   xD8,W
0EFFC:  BZ    F016
0EFFE:  ANDLW  0F
0F000:  SUBWF  xDA,W
0F002:  BZ    F006
0F004:  BC    F026
0F006:  BTFSC  xD8.7
0F008:  BRA    F026
0F00A:  BTFSC  xD8.6
0F00C:  BRA    F016
0F00E:  MOVLW  20
0F010:  BRA    F018
0F012:  MOVLB  8
0F014:  CLRF   xD8
0F016:  MOVLW  30
0F018:  ADDWF  00,F
0F01A:  MOVF   00,W
0F01C:  BTFSS  FA4.4
0F01E:  BRA    F01C
0F020:  MOVLB  F
0F022:  MOVWF  x1C
0F024:  MOVLB  8
0F026:  BCF    FD8.1
0F028:  CLRF   1B
0F02A:  BTFSC  FF2.7
0F02C:  BSF    1B.7
0F02E:  BCF    FF2.7
0F030:  MOVFF  8DF,A2B
0F034:  MOVFF  8DE,A2A
0F038:  MOVFF  8DD,A29
0F03C:  MOVFF  8DC,A28
0F040:  MOVLB  A
0F042:  CLRF   x2F
0F044:  CLRF   x2E
0F046:  CLRF   x2D
0F048:  MOVLW  0A
0F04A:  MOVWF  x2C
0F04C:  MOVLB  0
0F04E:  CALL   1056
0F052:  BTFSC  1B.7
0F054:  BSF    FF2.7
0F056:  MOVFF  03,8DF
0F05A:  MOVFF  02,8DE
0F05E:  MOVFF  01,8DD
0F062:  MOVFF  00,8DC
0F066:  MOVLB  8
0F068:  DECFSZ xDA,F
0F06A:  BRA    EFAA
0F06C:  MOVLB  0
0F06E:  GOTO   F198 (RETURN)
*
0F268:  ADDWF  FE8,W
0F26A:  CLRF   FF7
0F26C:  RLCF   FF7,F
0F26E:  ADDLW  89
0F270:  MOVWF  FF6
0F272:  MOVLW  F2
0F274:  ADDWFC FF7,F
0F276:  MOVLW  00
0F278:  MOVWF  FF8
0F27A:  MOVWF  FFB
0F27C:  TBLRD*-
0F27E:  MOVF   FF5,W
0F280:  MOVWF  FFA
0F282:  TBLRD*
0F284:  MOVF   FF5,W
0F286:  MOVWF  FF9
0F288:  DATA 28,F2
0F28A:  DATA 30,F2
0F28C:  DATA 38,F2
0F28E:  DATA 40,F2
*
0FA9E:  MOVF   FEF,F
0FAA0:  BZ    FAC2
0FAA2:  MOVFF  FEA,8CD
0FAA6:  MOVFF  FE9,8CC
0FAAA:  MOVFF  FEF,8E0
0FAAE:  CALL   5032
0FAB2:  MOVFF  8CD,FEA
0FAB6:  MOVFF  8CC,FE9
0FABA:  INCF   FE9,F
0FABC:  BTFSC  FD8.2
0FABE:  INCF   FEA,F
0FAC0:  BRA    FA9E
0FAC2:  RETURN 0
0FAC4:  MOVFF  FEA,FE2
0FAC8:  MOVFF  FE9,FE1
0FACC:  CLRF   01
0FACE:  BSF    00.0
0FAD0:  TBLRD*+
0FAD2:  MOVF   FF5,W
0FAD4:  BTFSS  00.0
0FAD6:  BRA    FAE2
0FAD8:  SUBWF  FEE,W
0FADA:  BNZ   FAE2
0FADC:  MOVF   FF5,F
0FADE:  BNZ   FAD0
0FAE0:  BRA    FAFC
0FAE2:  BCF    00.0
0FAE4:  MOVF   FF5,F
0FAE6:  BNZ   FAD0
0FAE8:  INCF   01,F
0FAEA:  BSF    00.0
0FAEC:  MOVFF  FE2,FEA
0FAF0:  MOVFF  FE1,FE9
0FAF4:  TBLRD*
0FAF6:  MOVF   FF5,F
0FAF8:  BNZ   FAD0
0FAFA:  SETF   01
0FAFC:  RETURN 0
*
103C4:  MOVFF  8F5,8FC
103C8:  MOVLB  8
103CA:  MOVF   xF9,W
103CC:  XORWF  xFC,F
103CE:  BTFSS  xFC.7
103D0:  BRA    103DC
103D2:  BCF    FD8.2
103D4:  BCF    FD8.0
103D6:  BTFSC  xF5.7
103D8:  BSF    FD8.0
103DA:  BRA    1043A
103DC:  MOVFF  8F5,8FC
103E0:  MOVFF  8F8,8FD
103E4:  MOVF   xF4,W
103E6:  SUBWF  xFD,F
103E8:  BZ    103F6
103EA:  BTFSS  xFC.7
103EC:  BRA    1043A
103EE:  MOVF   FD8,W
103F0:  XORLW  01
103F2:  MOVWF  FD8
103F4:  BRA    1043A
103F6:  MOVFF  8F9,8FD
103FA:  MOVF   xF5,W
103FC:  SUBWF  xFD,F
103FE:  BZ    1040C
10400:  BTFSS  xFC.7
10402:  BRA    1043A
10404:  MOVF   FD8,W
10406:  XORLW  01
10408:  MOVWF  FD8
1040A:  BRA    1043A
1040C:  MOVFF  8FA,8FD
10410:  MOVF   xF6,W
10412:  SUBWF  xFD,F
10414:  BZ    10422
10416:  BTFSS  xFC.7
10418:  BRA    1043A
1041A:  MOVF   FD8,W
1041C:  XORLW  01
1041E:  MOVWF  FD8
10420:  BRA    1043A
10422:  MOVFF  8FB,8FD
10426:  MOVF   xF7,W
10428:  SUBWF  xFD,F
1042A:  BZ    10438
1042C:  BTFSS  xFC.7
1042E:  BRA    1043A
10430:  MOVF   FD8,W
10432:  XORLW  01
10434:  MOVWF  FD8
10436:  BRA    1043A
10438:  BCF    FD8.0
1043A:  MOVLB  0
1043C:  RETURN 0
1043E:  MOVLW  8E
10440:  MOVWF  00
10442:  MOVFF  8CE,01
10446:  MOVFF  8CD,02
1044A:  CLRF   03
1044C:  BTFSS  01.7
1044E:  BRA    1045A
10450:  COMF   01,F
10452:  COMF   02,F
10454:  INCF   02,F
10456:  BNZ   1045A
10458:  INCF   01,F
1045A:  MOVF   01,F
1045C:  BNZ   10470
1045E:  MOVFF  02,01
10462:  CLRF   02
10464:  MOVLW  08
10466:  SUBWF  00,F
10468:  MOVF   01,F
1046A:  BNZ   10470
1046C:  CLRF   00
1046E:  BRA    1048C
10470:  BCF    FD8.0
10472:  BTFSC  01.7
10474:  BRA    1047E
10476:  RLCF   02,F
10478:  RLCF   01,F
1047A:  DECF   00,F
1047C:  BRA    10470
1047E:  MOVLB  8
10480:  BTFSS  xCE.7
10482:  BRA    10488
10484:  MOVLB  0
10486:  BRA    1048C
10488:  BCF    01.7
1048A:  MOVLB  0
1048C:  RETURN 0
*
1088A:  MOVF   FE9,W
1088C:  MOVLB  8
1088E:  MOVWF  xB5
10890:  MOVF   xB4,W
10892:  MOVWF  xB7
10894:  BZ    108CE
10896:  MOVFF  8B3,8F7
1089A:  MOVFF  8B2,8F6
1089E:  MOVFF  8B1,8F5
108A2:  MOVFF  8B0,8F4
108A6:  CLRF   xFB
108A8:  CLRF   xFA
108AA:  MOVLW  20
108AC:  MOVWF  xF9
108AE:  MOVLW  82
108B0:  MOVWF  xF8
108B2:  MOVLB  0
108B4:  CALL   BF4E
108B8:  MOVFF  03,8B3
108BC:  MOVFF  02,8B2
108C0:  MOVFF  01,8B1
108C4:  MOVFF  00,8B0
108C8:  MOVLB  8
108CA:  DECFSZ xB7,F
108CC:  BRA    10896
108CE:  MOVLW  7E
108D0:  MOVWF  00
108D2:  CLRF   01
108D4:  BTFSC  xB1.7
108D6:  BSF    01.7
108D8:  CLRF   02
108DA:  CLRF   03
108DC:  BCF    FD8.1
108DE:  MOVFF  8B3,8FB
108E2:  MOVFF  8B2,8FA
108E6:  MOVFF  8B1,8F9
108EA:  MOVFF  8B0,8F8
108EE:  MOVFF  03,8FF
108F2:  MOVFF  02,8FE
108F6:  MOVFF  01,8FD
108FA:  MOVWF  xFC
108FC:  MOVLB  0
108FE:  CALL   C044
10902:  MOVFF  03,8B3
10906:  MOVFF  02,8B2
1090A:  MOVFF  01,8B1
1090E:  MOVFF  00,8B0
10912:  MOVFF  8B3,8C0
10916:  MOVFF  8B2,8BF
1091A:  MOVFF  8B1,8BE
1091E:  MOVFF  8B0,8BD
10922:  CALL   C2CE
10926:  MOVFF  03,8B3
1092A:  MOVFF  02,8B2
1092E:  MOVFF  01,8B1
10932:  MOVFF  00,8B0
10936:  MOVLB  8
10938:  BTFSS  xB3.7
1093A:  BRA    10956
1093C:  DECF   xB5,F
1093E:  BSF    xB5.5
10940:  COMF   xB0,F
10942:  COMF   xB1,F
10944:  COMF   xB2,F
10946:  COMF   xB3,F
10948:  INCF   xB0,F
1094A:  BTFSC  FD8.2
1094C:  INCF   xB1,F
1094E:  BTFSC  FD8.2
10950:  INCF   xB2,F
10952:  BTFSC  FD8.2
10954:  INCF   xB3,F
10956:  MOVLW  3B
10958:  MOVWF  xBC
1095A:  MOVLW  9A
1095C:  MOVWF  xBB
1095E:  MOVLW  CA
10960:  MOVWF  xBA
10962:  CLRF   xB9
10964:  MOVLW  0A
10966:  MOVWF  xB7
10968:  MOVF   xB4,W
1096A:  BTFSC  FD8.2
1096C:  INCF   xB5,F
1096E:  BSF    FD8.1
10970:  MOVLW  08
10972:  MOVWF  FEA
10974:  MOVLW  B0
10976:  MOVWF  FE9
10978:  CLRF   1B
1097A:  BTFSC  FF2.7
1097C:  BSF    1B.7
1097E:  BCF    FF2.7
10980:  MOVFF  8B3,A2B
10984:  MOVFF  8B2,A2A
10988:  MOVFF  8B1,A29
1098C:  MOVFF  8B0,A28
10990:  MOVFF  8BC,A2F
10994:  MOVFF  8BB,A2E
10998:  MOVFF  8BA,A2D
1099C:  MOVFF  8B9,A2C
109A0:  MOVLB  0
109A2:  CALL   1056
109A6:  BTFSC  1B.7
109A8:  BSF    FF2.7
109AA:  MOVF   01,W
109AC:  MOVF   00,F
109AE:  BNZ   109D6
109B0:  MOVLB  8
109B2:  INCF   xB4,W
109B4:  SUBWF  xB7,W
109B6:  BTFSS  FD8.2
109B8:  BRA    109BE
109BA:  MOVLB  0
109BC:  BRA    109D6
109BE:  MOVF   xB5,W
109C0:  BZ    109DC
109C2:  ANDLW  0F
109C4:  SUBWF  xB7,W
109C6:  BZ    109CA
109C8:  BC    10A52
109CA:  BTFSC  xB5.7
109CC:  BRA    10A52
109CE:  BTFSC  xB5.6
109D0:  BRA    109DC
109D2:  MOVLW  20
109D4:  BRA    10A44
109D6:  MOVLW  20
109D8:  MOVLB  8
109DA:  ANDWF  xB5,F
109DC:  BTFSS  xB5.5
109DE:  BRA    109FE
109E0:  BCF    xB5.5
109E2:  MOVF   xB4,W
109E4:  BTFSS  FD8.2
109E6:  DECF   xB5,F
109E8:  MOVF   00,W
109EA:  MOVWF  xB5
109EC:  MOVLW  2D
109EE:  MOVWF  xE0
109F0:  MOVLB  0
109F2:  CALL   5032
109F6:  MOVLB  8
109F8:  MOVF   xB5,W
109FA:  MOVWF  00
109FC:  CLRF   xB5
109FE:  MOVF   xB4,W
10A00:  SUBWF  xB7,W
10A02:  BNZ   10A1E
10A04:  MOVF   00,W
10A06:  MOVWF  xB5
10A08:  MOVLW  2E
10A0A:  MOVWF  xE0
10A0C:  MOVLB  0
10A0E:  CALL   5032
10A12:  MOVLB  8
10A14:  MOVF   xB5,W
10A16:  MOVWF  00
10A18:  MOVLW  20
10A1A:  ANDWF  xB5,F
10A1C:  MOVLW  00
10A1E:  MOVLW  30
10A20:  BTFSS  xB5.5
10A22:  BRA    10A44
10A24:  BCF    xB5.5
10A26:  MOVF   xB4,W
10A28:  BTFSS  FD8.2
10A2A:  DECF   xB5,F
10A2C:  MOVF   00,W
10A2E:  MOVWF  xB5
10A30:  MOVLW  2D
10A32:  MOVWF  xE0
10A34:  MOVLB  0
10A36:  CALL   5032
10A3A:  MOVLB  8
10A3C:  MOVF   xB5,W
10A3E:  MOVWF  00
10A40:  CLRF   xB5
10A42:  MOVLW  30
10A44:  ADDWF  00,F
10A46:  MOVFF  00,8E0
10A4A:  MOVLB  0
10A4C:  CALL   5032
10A50:  MOVLB  8
10A52:  BCF    FD8.1
10A54:  CLRF   1B
10A56:  BTFSC  FF2.7
10A58:  BSF    1B.7
10A5A:  BCF    FF2.7
10A5C:  MOVFF  8BC,A2B
10A60:  MOVFF  8BB,A2A
10A64:  MOVFF  8BA,A29
10A68:  MOVFF  8B9,A28
10A6C:  MOVLB  A
10A6E:  CLRF   x2F
10A70:  CLRF   x2E
10A72:  CLRF   x2D
10A74:  MOVLW  0A
10A76:  MOVWF  x2C
10A78:  MOVLB  0
10A7A:  CALL   1056
10A7E:  BTFSC  1B.7
10A80:  BSF    FF2.7
10A82:  MOVFF  03,8BC
10A86:  MOVFF  02,8BB
10A8A:  MOVFF  01,8BA
10A8E:  MOVFF  00,8B9
10A92:  MOVLB  8
10A94:  DECFSZ xB7,F
10A96:  BRA    1096E
10A98:  MOVLB  0
10A9A:  RETURN 0
*
1239E:  ADDWF  FE8,W
123A0:  CLRF   FF7
123A2:  RLCF   FF7,F
123A4:  ADDLW  BF
123A6:  MOVWF  FF6
123A8:  MOVLW  23
123AA:  ADDWFC FF7,F
123AC:  MOVLW  01
123AE:  MOVWF  FF8
123B0:  MOVWF  FFB
123B2:  TBLRD*-
123B4:  MOVF   FF5,W
123B6:  MOVWF  FFA
123B8:  TBLRD*
123BA:  MOVF   FF5,W
123BC:  MOVWF  FF9
123BE:  DATA 62,23
123C0:  DATA 6A,23
123C2:  DATA 70,23
123C4:  DATA 76,23
*
12456:  MOVLW  8E
12458:  MOVWF  00
1245A:  MOVLB  8
1245C:  MOVF   xF4,W
1245E:  SUBWF  00,F
12460:  MOVFF  8F5,02
12464:  MOVFF  8F6,01
12468:  BSF    02.7
1246A:  MOVF   00,F
1246C:  BZ    12480
1246E:  BCF    FD8.0
12470:  MOVF   02,F
12472:  BNZ   12478
12474:  MOVF   01,F
12476:  BZ    12480
12478:  RRCF   02,F
1247A:  RRCF   01,F
1247C:  DECFSZ 00,F
1247E:  BRA    1246E
12480:  BTFSS  xF5.7
12482:  BRA    1248E
12484:  COMF   01,F
12486:  COMF   02,F
12488:  INCF   01,F
1248A:  BTFSC  FD8.2
1248C:  INCF   02,F
1248E:  MOVLB  0
12490:  RETURN 0
*
12F4E:  ADDWF  FE8,W
12F50:  CLRF   FF7
12F52:  RLCF   FF7,F
12F54:  ADDLW  6F
12F56:  MOVWF  FF6
12F58:  MOVLW  2F
12F5A:  ADDWFC FF7,F
12F5C:  MOVLW  01
12F5E:  MOVWF  FF8
12F60:  MOVWF  FFB
12F62:  TBLRD*-
12F64:  MOVF   FF5,W
12F66:  MOVWF  FFA
12F68:  TBLRD*
12F6A:  MOVF   FF5,W
12F6C:  MOVWF  FF9
12F6E:  DATA 8A,2D
12F70:  DATA 90,2D
12F72:  DATA AE,2D
12F74:  DATA CC,2D
*
12FE6:  MOVLB  8
12FE8:  MOVF   xBE,W
12FEA:  XORWF  xC0,W
12FEC:  ANDLW  80
12FEE:  MOVWF  xC2
12FF0:  BTFSS  xBE.7
12FF2:  BRA    12FFE
12FF4:  COMF   xBD,F
12FF6:  COMF   xBE,F
12FF8:  INCF   xBD,F
12FFA:  BTFSC  FD8.2
12FFC:  INCF   xBE,F
12FFE:  BTFSS  xC0.7
13000:  BRA    1300C
13002:  COMF   xBF,F
13004:  COMF   xC0,F
13006:  INCF   xBF,F
13008:  BTFSC  FD8.2
1300A:  INCF   xC0,F
1300C:  MOVF   xBD,W
1300E:  MULWF  xBF
13010:  MOVFF  FF3,01
13014:  MOVFF  FF4,00
13018:  MULWF  xC0
1301A:  MOVF   FF3,W
1301C:  ADDWF  00,F
1301E:  MOVF   xBE,W
13020:  MULWF  xBF
13022:  MOVF   FF3,W
13024:  ADDWFC 00,W
13026:  MOVWF  02
13028:  BTFSS  xC2.7
1302A:  BRA    13036
1302C:  COMF   01,F
1302E:  COMF   02,F
13030:  INCF   01,F
13032:  BTFSC  FD8.2
13034:  INCF   02,F
13036:  MOVLB  0
13038:  GOTO   13116 (RETURN)
*
13E3E:  ADDWF  FE8,W
13E40:  CLRF   FF7
13E42:  RLCF   FF7,F
13E44:  ADDLW  5F
13E46:  MOVWF  FF6
13E48:  MOVLW  3E
13E4A:  ADDWFC FF7,F
13E4C:  MOVLW  01
13E4E:  MOVWF  FF8
13E50:  MOVWF  FFB
13E52:  TBLRD*-
13E54:  MOVF   FF5,W
13E56:  MOVWF  FFA
13E58:  TBLRD*
13E5A:  MOVF   FF5,W
13E5C:  MOVWF  FF9
13E5E:  DATA 2C,3C
13E60:  DATA 32,3E
13E62:  DATA 58,3C
13E64:  DATA 32,3E
13E66:  DATA 24,3B
13E68:  DATA 32,3E
13E6A:  DATA 32,3E
13E6C:  DATA 32,3E
13E6E:  DATA 32,3E
13E70:  DATA 32,3E
13E72:  DATA 32,3E
13E74:  DATA 32,3E
13E76:  DATA 32,3E
13E78:  DATA 32,3E
13E7A:  DATA 32,3E
13E7C:  DATA 32,3E
13E7E:  DATA 2A,3E
13E80:  DATA 32,3E
13E82:  DATA 32,3E
13E84:  DATA 32,3E
13E86:  DATA 32,3E
13E88:  DATA 32,3E
13E8A:  DATA C4,3A
13E8C:  DATA 32,3E
13E8E:  DATA F8,3A
13E90:  DATA 00,3B
13E92:  DATA 32,3E
13E94:  DATA 14,3B
13E96:  DATA 84,3C
13E98:  DATA 48,3B
13E9A:  DATA 32,3E
13E9C:  DATA 32,3E
13E9E:  DATA DA,3B
13EA0:  DATA BC,3B
13EA2:  DATA 32,3E
13EA4:  DATA 32,3E
13EA6:  DATA 32,3E
13EA8:  DATA 9E,3C
13EAA:  DATA CA,3C
13EAC:  DATA F6,3C
13EAE:  DATA F6,3B
13EB0:  DATA 22,3C
13EB2:  DATA 32,3E
13EB4:  DATA 32,3E
13EB6:  DATA 32,3E
13EB8:  DATA 32,3E
13EBA:  DATA 22,3D
13EBC:  DATA 32,3E
13EBE:  DATA 32,3E
13EC0:  DATA 32,3E
13EC2:  DATA 32,3E
13EC4:  DATA 32,3E
13EC6:  DATA 32,3E
13EC8:  DATA 32,3E
13ECA:  DATA 32,3E
13ECC:  DATA 32,3E
13ECE:  DATA 32,3E
13ED0:  DATA 30,3B
13ED2:  DATA 32,3E
13ED4:  DATA 32,3E
13ED6:  DATA 32,3E
13ED8:  DATA 32,3E
13EDA:  DATA 60,3B
13EDC:  DATA 32,3E
13EDE:  DATA 32,3E
13EE0:  DATA 86,3B
13EE2:  DATA 32,3E
13EE4:  DATA 32,3E
13EE6:  DATA 32,3E
13EE8:  DATA D4,3A
13EEA:  DATA 32,3E
13EEC:  DATA 32,3E
13EEE:  DATA 32,3E
13EF0:  DATA 32,3E
13EF2:  DATA 32,3E
13EF4:  DATA 4C,3D
*
13FAA:  MOVFF  FEA,8A1
13FAE:  MOVFF  FE9,8A0
13FB2:  MOVLB  8
13FB4:  SWAPF  x9A,W
13FB6:  IORLW  F0
13FB8:  MOVWF  x9C
13FBA:  ADDWF  x9C,F
13FBC:  ADDLW  E2
13FBE:  MOVWF  x9D
13FC0:  ADDLW  32
13FC2:  MOVWF  x9F
13FC4:  MOVF   x9A,W
13FC6:  ANDLW  0F
13FC8:  ADDWF  x9D,F
13FCA:  ADDWF  x9D,F
13FCC:  ADDWF  x9F,F
13FCE:  ADDLW  E9
13FD0:  MOVWF  x9E
13FD2:  ADDWF  x9E,F
13FD4:  ADDWF  x9E,F
13FD6:  SWAPF  x99,W
13FD8:  ANDLW  0F
13FDA:  ADDWF  x9E,F
13FDC:  ADDWF  x9F,F
13FDE:  RLCF   x9E,F
13FE0:  RLCF   x9F,F
13FE2:  COMF   x9F,F
13FE4:  RLCF   x9F,F
13FE6:  MOVF   x99,W
13FE8:  ANDLW  0F
13FEA:  ADDWF  x9F,F
13FEC:  RLCF   x9C,F
13FEE:  MOVLW  07
13FF0:  MOVWF  x9B
13FF2:  MOVLW  0A
13FF4:  DECF   x9E,F
13FF6:  ADDWF  x9F,F
13FF8:  BNC   13FF4
13FFA:  DECF   x9D,F
13FFC:  ADDWF  x9E,F
13FFE:  BNC   13FFA
14000:  DECF   x9C,F
14002:  ADDWF  x9D,F
14004:  BNC   14000
14006:  DECF   x9B,F
14008:  ADDWF  x9C,F
1400A:  BNC   14006
1400C:  MOVLW  08
1400E:  MOVWF  FEA
14010:  MOVLW  9B
14012:  MOVWF  FE9
14014:  MOVLW  07
14016:  ANDWF  xA0,W
14018:  BCF    xA0.6
1401A:  ADDWF  FE9,F
1401C:  MOVLW  00
1401E:  ADDWFC FEA,F
14020:  MOVF   FE9,W
14022:  SUBLW  9F
14024:  BNZ   1402E
14026:  MOVF   FEA,W
14028:  SUBLW  08
1402A:  BNZ   1402E
1402C:  BSF    xA0.6
1402E:  MOVF   FEF,W
14030:  MOVWF  00
14032:  BNZ   14044
14034:  BTFSC  xA0.6
14036:  BRA    14044
14038:  BTFSC  xA0.4
1403A:  BRA    14058
1403C:  BTFSC  xA0.3
1403E:  BRA    14044
14040:  MOVLW  20
14042:  BRA    1404A
14044:  BSF    xA0.3
14046:  BCF    xA0.4
14048:  MOVLW  30
1404A:  ADDWF  00,F
1404C:  MOVF   00,W
1404E:  BTFSS  FA4.4
14050:  BRA    1404E
14052:  MOVLB  F
14054:  MOVWF  x1C
14056:  MOVLB  8
14058:  MOVF   FEE,W
1405A:  BTFSS  xA0.6
1405C:  BRA    14020
1405E:  MOVLB  0
14060:  GOTO   140FC (RETURN)
*
14540:  ADDWF  FE8,W
14542:  CLRF   FF7
14544:  RLCF   FF7,F
14546:  ADDLW  61
14548:  MOVWF  FF6
1454A:  MOVLW  45
1454C:  ADDWFC FF7,F
1454E:  MOVLW  01
14550:  MOVWF  FF8
14552:  MOVWF  FFB
14554:  TBLRD*-
14556:  MOVF   FF5,W
14558:  MOVWF  FFA
1455A:  TBLRD*
1455C:  MOVF   FF5,W
1455E:  MOVWF  FF9
14560:  DATA 2C,41
14562:  DATA 8C,41
14564:  DATA A8,41
14566:  DATA C4,41
14568:  DATA E0,41
1456A:  DATA FC,41
1456C:  DATA 18,42
1456E:  DATA 34,42
14570:  DATA 50,42
14572:  DATA 6C,42
14574:  DATA 88,42
14576:  DATA A4,42
14578:  DATA C0,42
1457A:  DATA DC,42
1457C:  DATA F8,42
1457E:  DATA 14,43
14580:  DATA 30,43
14582:  DATA 4C,43
14584:  DATA 68,43
14586:  DATA 84,43
14588:  DATA A0,43
1458A:  DATA BC,43
1458C:  DATA D8,43
1458E:  DATA F4,43
14590:  DATA 10,44
14592:  DATA 2C,44
14594:  DATA 48,44
14596:  DATA 64,44
14598:  DATA 80,44
1459A:  DATA 9C,44
1459C:  DATA B8,44
1459E:  DATA D4,44
145A0:  DATA F0,44
*
14D76:  ADDWF  FE8,W
14D78:  CLRF   FF7
14D7A:  RLCF   FF7,F
14D7C:  ADDLW  97
14D7E:  MOVWF  FF6
14D80:  MOVLW  4D
14D82:  ADDWFC FF7,F
14D84:  MOVLW  01
14D86:  MOVWF  FF8
14D88:  MOVWF  FFB
14D8A:  TBLRD*-
14D8C:  MOVF   FF5,W
14D8E:  MOVWF  FFA
14D90:  TBLRD*
14D92:  MOVF   FF5,W
14D94:  MOVWF  FF9
14D96:  DATA 82,49
14D98:  DATA AA,4A
14D9A:  DATA AE,49
14D9C:  DATA AA,4A
14D9E:  DATA 74,48
14DA0:  DATA AA,4A
14DA2:  DATA AA,4A
14DA4:  DATA AA,4A
14DA6:  DATA AA,4A
14DA8:  DATA AA,4A
14DAA:  DATA AA,4A
14DAC:  DATA AA,4A
14DAE:  DATA AA,4A
14DB0:  DATA AA,4A
14DB2:  DATA AA,4A
14DB4:  DATA AA,4A
14DB6:  DATA A2,4A
14DB8:  DATA AA,4A
14DBA:  DATA AA,4A
14DBC:  DATA AA,4A
14DBE:  DATA AA,4A
14DC0:  DATA AA,4A
14DC2:  DATA 7E,46
14DC4:  DATA AA,4A
14DC6:  DATA B2,46
14DC8:  DATA 50,48
14DCA:  DATA AA,4A
14DCC:  DATA 64,48
14DCE:  DATA DA,49
14DD0:  DATA 98,48
14DD2:  DATA AA,4A
14DD4:  DATA AA,4A
14DD6:  DATA 2A,49
14DD8:  DATA 0C,49
14DDA:  DATA AA,4A
14DDC:  DATA AA,4A
14DDE:  DATA AA,4A
14DE0:  DATA F4,49
14DE2:  DATA 20,4A
14DE4:  DATA 4C,4A
14DE6:  DATA 46,49
14DE8:  DATA 76,49
14DEA:  DATA AA,4A
14DEC:  DATA AA,4A
14DEE:  DATA AA,4A
14DF0:  DATA AA,4A
14DF2:  DATA 78,4A
14DF4:  DATA AA,4A
14DF6:  DATA AA,4A
14DF8:  DATA AA,4A
14DFA:  DATA AA,4A
14DFC:  DATA AA,4A
14DFE:  DATA AA,4A
14E00:  DATA AA,4A
14E02:  DATA AA,4A
14E04:  DATA AA,4A
14E06:  DATA AA,4A
14E08:  DATA 80,48
14E0A:  DATA AA,4A
14E0C:  DATA AA,4A
14E0E:  DATA AA,4A
14E10:  DATA AA,4A
14E12:  DATA B0,48
14E14:  DATA AA,4A
14E16:  DATA AA,4A
14E18:  DATA D6,48
14E1A:  DATA AA,4A
14E1C:  DATA AA,4A
14E1E:  DATA AA,4A
14E20:  DATA 8E,46
14E22:  DATA AA,4A
14E24:  DATA BA,46
*
15288:  ADDWF  FE8,W
1528A:  CLRF   FF7
1528C:  RLCF   FF7,F
1528E:  ADDLW  A9
15290:  MOVWF  FF6
15292:  MOVLW  52
15294:  ADDWFC FF7,F
15296:  MOVLW  01
15298:  MOVWF  FF8
1529A:  MOVWF  FFB
1529C:  TBLRD*-
1529E:  MOVF   FF5,W
152A0:  MOVWF  FFA
152A2:  TBLRD*
152A4:  MOVF   FF5,W
152A6:  MOVWF  FF9
152A8:  DATA FA,50
152AA:  DATA 1A,51
152AC:  DATA 3A,51
152AE:  DATA 5A,51
152B0:  DATA 7A,51
152B2:  DATA 9A,51
152B4:  DATA BA,51
*
1839E:  MOVLW  20
183A0:  MOVLB  8
183A2:  BTFSS  x69.4
183A4:  MOVLW  30
183A6:  MOVWF  x6A
183A8:  MOVFF  868,00
183AC:  BTFSS  x68.7
183AE:  BRA    183C0
183B0:  COMF   00,F
183B2:  INCF   00,F
183B4:  MOVFF  00,868
183B8:  MOVLW  2D
183BA:  MOVWF  x6A
183BC:  BSF    x69.7
183BE:  BSF    x69.0
183C0:  MOVF   01,W
183C2:  CLRF   1B
183C4:  BTFSC  FF2.7
183C6:  BSF    1B.7
183C8:  BCF    FF2.7
183CA:  MOVFF  868,A1E
183CE:  MOVLW  64
183D0:  MOVLB  A
183D2:  MOVWF  x1F
183D4:  MOVLB  0
183D6:  CALL   0F7A
183DA:  BTFSC  1B.7
183DC:  BSF    FF2.7
183DE:  MOVFF  00,868
183E2:  MOVLW  30
183E4:  ADDWF  01,W
183E6:  MOVLB  8
183E8:  MOVWF  x6B
183EA:  CLRF   1B
183EC:  BTFSC  FF2.7
183EE:  BSF    1B.7
183F0:  BCF    FF2.7
183F2:  MOVFF  868,A1E
183F6:  MOVLW  0A
183F8:  MOVLB  A
183FA:  MOVWF  x1F
183FC:  MOVLB  0
183FE:  CALL   0F7A
18402:  BTFSC  1B.7
18404:  BSF    FF2.7
18406:  MOVLW  30
18408:  ADDWF  00,W
1840A:  MOVLB  8
1840C:  MOVWF  x6D
1840E:  MOVLW  30
18410:  ADDWF  01,W
18412:  MOVWF  x6C
18414:  MOVFF  86A,00
18418:  MOVLW  30
1841A:  SUBWF  x6B,W
1841C:  BZ    18426
1841E:  BSF    x69.1
18420:  BTFSC  x69.7
18422:  BSF    x69.2
18424:  BRA    1844A
18426:  MOVFF  86A,86B
1842A:  MOVLW  20
1842C:  MOVWF  x6A
1842E:  MOVLW  30
18430:  SUBWF  x6C,W
18432:  BZ    1843C
18434:  BSF    x69.0
18436:  BTFSC  x69.7
18438:  BSF    x69.1
1843A:  BRA    1844A
1843C:  BTFSS  FD8.2
1843E:  BSF    x69.0
18440:  BNZ   1844A
18442:  MOVFF  86B,86C
18446:  MOVLW  20
18448:  MOVWF  x6B
1844A:  BTFSC  x69.2
1844C:  BRA    18458
1844E:  BTFSC  x69.1
18450:  BRA    18460
18452:  BTFSC  x69.0
18454:  BRA    18468
18456:  BRA    18470
18458:  MOVF   x6A,W
1845A:  BTFSS  F9E.4
1845C:  BRA    1845A
1845E:  MOVWF  FAD
18460:  MOVF   x6B,W
18462:  BTFSS  F9E.4
18464:  BRA    18462
18466:  MOVWF  FAD
18468:  MOVF   x6C,W
1846A:  BTFSS  F9E.4
1846C:  BRA    1846A
1846E:  MOVWF  FAD
18470:  MOVF   x6D,W
18472:  BTFSS  F9E.4
18474:  BRA    18472
18476:  MOVWF  FAD
18478:  MOVLB  0
1847A:  GOTO   185DA (RETURN)
*
1B022:  ADDWF  FE8,W
1B024:  CLRF   FF7
1B026:  RLCF   FF7,F
1B028:  ADDLW  43
1B02A:  MOVWF  FF6
1B02C:  MOVLW  B0
1B02E:  ADDWFC FF7,F
1B030:  MOVLW  01
1B032:  MOVWF  FF8
1B034:  MOVWF  FFB
1B036:  TBLRD*-
1B038:  MOVF   FF5,W
1B03A:  MOVWF  FFA
1B03C:  TBLRD*
1B03E:  MOVF   FF5,W
1B040:  MOVWF  FF9
1B042:  DATA 9E,AE
1B044:  DATA 1E,B0
1B046:  DATA A4,AE
1B048:  DATA 98,AE
1B04A:  DATA 1E,B0
1B04C:  DATA 1E,B0
1B04E:  DATA 1E,B0
1B050:  DATA AA,AE
1B052:  DATA 5E,AF
1B054:  DATA 1E,B0
1B056:  DATA 7A,AF
1B058:  DATA 1E,B0
1B05A:  DATA B0,AE
1B05C:  DATA 1E,B0
1B05E:  DATA 1E,B0
1B060:  DATA 1E,B0
1B062:  DATA 1E,B0
1B064:  DATA 1E,B0
1B066:  DATA 1E,B0
1B068:  DATA 1E,B0
1B06A:  DATA 1E,B0
1B06C:  DATA 1E,B0
1B06E:  DATA 1E,B0
1B070:  DATA 1E,B0
1B072:  DATA 1E,B0
1B074:  DATA 1E,B0
1B076:  DATA 1E,B0
1B078:  DATA 1E,B0
1B07A:  DATA 1E,B0
1B07C:  DATA 1E,B0
1B07E:  DATA B6,AE
1B080:  DATA BC,AE
1B082:  DATA C2,AE
1B084:  DATA C8,AE
1B086:  DATA CE,AE
1B088:  DATA D4,AE
1B08A:  DATA DA,AE
1B08C:  DATA E0,AE
1B08E:  DATA E6,AE
1B090:  DATA EC,AE
1B092:  DATA F2,AE
1B094:  DATA F8,AE
1B096:  DATA FE,AE
1B098:  DATA 0A,AF
1B09A:  DATA 10,AF
1B09C:  DATA 16,AF
1B09E:  DATA 1C,AF
1B0A0:  DATA 22,AF
1B0A2:  DATA 28,AF
1B0A4:  DATA 2E,AF
1B0A6:  DATA 34,AF
1B0A8:  DATA 3A,AF
1B0AA:  DATA 40,AF
1B0AC:  DATA 46,AF
1B0AE:  DATA 4C,AF
1B0B0:  DATA 52,AF
1B0B2:  DATA 1E,B0
1B0B4:  DATA 1E,B0
1B0B6:  DATA 1E,B0
1B0B8:  DATA 58,AF
1B0BA:  DATA 1E,B0
1B0BC:  DATA 1E,B0
1B0BE:  DATA 96,AF
1B0C0:  DATA 9C,AF
1B0C2:  DATA A2,AF
1B0C4:  DATA A8,AF
1B0C6:  DATA AE,AF
1B0C8:  DATA B4,AF
1B0CA:  DATA BA,AF
1B0CC:  DATA C0,AF
1B0CE:  DATA C6,AF
1B0D0:  DATA CC,AF
1B0D2:  DATA D2,AF
1B0D4:  DATA D8,AF
1B0D6:  DATA DE,AF
1B0D8:  DATA E4,AF
1B0DA:  DATA EA,AF
1B0DC:  DATA F0,AF
1B0DE:  DATA F6,AF
1B0E0:  DATA FC,AF
1B0E2:  DATA 00,B0
1B0E4:  DATA 04,B0
1B0E6:  DATA 08,B0
1B0E8:  DATA 0C,B0
1B0EA:  DATA 10,B0
1B0EC:  DATA 14,B0
1B0EE:  DATA 18,B0
1B0F0:  DATA 1C,B0
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8D5
1F8BA:  MOVFF  FF7,8D6
1F8BE:  MOVFF  FF8,8D7
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8D5,FF6
1F8CE:  MOVFF  8D6,FF7
1F8D2:  MOVFF  8D7,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8D6
1F8E0:  MOVFF  FF7,8D7
1F8E4:  MOVFF  FF8,8D8
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8D6,FF6
1F8F4:  MOVFF  8D7,FF7
1F8F8:  MOVFF  8D8,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xD5,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xD6.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xD5,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xD6,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xD5,F
1F936:  MOVLW  0A
1F938:  SUBWF  xD5,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xD6.7
1F942:  MOVF   xD6,W
1F944:  ADDWF  xD5,F
1F946:  MOVF   xD5,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xD8,W
1F956:  CLRF   01
1F958:  SUBWF  xD7,W
1F95A:  BC    1F962
1F95C:  MOVFF  8D7,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xD9
1F968:  RLCF   xD7,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xD8,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xD9,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8D5,8D7
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xD8
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8D5
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xD6.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xD6.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xD6.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xD6.3
1F9AC:  BCF    xD6.4
1F9AE:  BSF    xD6.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8D5,8D7
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xD8
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8D5
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xD6.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xD6.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xD6.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xD5,F
1F9F0:  MOVF   xD5,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8D5,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8D6,01
1FA60:  MOVFF  8D5,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... //#ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... //#else 
....................    //#FUSES NOMCLR 
.................... //#endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... #FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... #FUSES WDT_SW   
.................... //#use delay(clock=2000000) 
....................  
.................... #FUSES NOWDT 
....................  
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
028AC:  MOVLW  09
028AE:  MOVWF  FEA
028B0:  MOVLW  CD
028B2:  MOVWF  FE9
028B4:  MOVF   FEF,W
028B6:  BZ    28D4
028B8:  MOVLW  14
028BA:  MOVWF  01
028BC:  CLRF   00
028BE:  DECFSZ 00,F
028C0:  BRA    28BE
028C2:  DECFSZ 01,F
028C4:  BRA    28BC
028C6:  MOVLW  BF
028C8:  MOVWF  00
028CA:  DECFSZ 00,F
028CC:  BRA    28CA
028CE:  BRA    28D0
028D0:  DECFSZ FEF,F
028D2:  BRA    28B8
028D4:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E38:  BTFSS  F9E.5
00E3A:  BRA    0E38
00E3C:  MOVFF  FAB,1C
00E40:  MOVFF  FAE,01
00E44:  BTFSS  1C.1
00E46:  BRA    0E4C
00E48:  BCF    FAB.4
00E4A:  BSF    FAB.4
00E4C:  RETURN 0
*
0ADD8:  BTFSS  F9E.4
0ADDA:  BRA    ADD8
0ADDC:  MOVWF  FAD
0ADDE:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12A7C:  BTFSS  FA4.5
12A7E:  BRA    12A7C
12A80:  MOVLB  F
12A82:  MOVFF  F22,1C
12A86:  MOVFF  F1D,01
12A8A:  BTFSS  1C.1
12A8C:  BRA    12A92
12A8E:  BCF    x22.4
12A90:  BSF    x22.4
12A92:  MOVLB  0
12A94:  RETURN 0
*
16ADA:  BTFSS  FA4.4
16ADC:  BRA    16ADA
16ADE:  MOVLB  F
16AE0:  MOVWF  x1C
16AE2:  MOVLB  0
16AE4:  GOTO   16B88 (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xDB
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xDC
1F850:  MOVF   xDC,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8DA,03
1F85A:  MOVFF  8D9,FE9
1F85E:  MOVFF  8DA,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xDB,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8DD
1F870:  MOVFF  8D9,FE9
1F874:  MOVFF  8DA,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xDD,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xDB
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xDB,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8DD
1F88C:  MOVFF  8D9,FE9
1F890:  MOVFF  8DA,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xDD,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xDB
....................       }  
1F89C:  MOVF   xDC,W
1F89E:  INCF   xDC,F
1F8A0:  INCF   xD9,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xDA,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8DB,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xD9,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8D6,03
1FA84:  MOVFF  8D5,FE9
1FA88:  MOVFF  8D6,FEA
1FA8C:  MOVFF  FEF,8DA
1FA90:  MOVFF  8D8,03
1FA94:  MOVFF  8D7,FE9
1FA98:  MOVFF  8D8,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xDA,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8D6,03
1FAA6:  MOVFF  8D5,FE9
1FAAA:  MOVFF  8D6,FEA
1FAAE:  MOVFF  FEF,8DA
1FAB2:  MOVFF  8D8,03
1FAB6:  MOVFF  8D7,FE9
1FABA:  MOVFF  8D8,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xDA,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8D6,03
1FAD4:  MOVFF  8D5,FE9
1FAD8:  MOVFF  8D6,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8D6,03
1FAEA:  MOVF   xD5,W
1FAEC:  INCF   xD5,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xD6,F
1FAF2:  MOVFF  8D8,03
1FAF6:  MOVF   xD7,W
1FAF8:  INCF   xD7,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xD8,F
1FAFE:  DECF   xD9,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x66.1
1FB0E:  CLRF   x70
1FB10:  CLRF   x6F
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xCD
1FB2A:  MOVLB  0
1FB2C:  CALL   28AC
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x66.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x6C
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x6C,W
1FB3C:  ADDLW  95
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x6C,W
1FB50:  INCF   x6C,F
1FB52:  CLRF   03
1FB54:  ADDLW  95
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x6C,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x66.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   x95,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xDA
1FB80:  MOVLW  96
1FB82:  MOVWF  xD9
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,86B
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xDA
1FB92:  MOVLW  98
1FB94:  MOVWF  xD9
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8D5
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xDA
1FBA4:  MOVLW  9A
1FBA6:  MOVWF  xD9
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8D5,86E
1FBB0:  MOVFF  01,86D
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xDA
1FBBA:  MOVLW  9C
1FBBC:  MOVWF  xD9
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,868
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  86F,873
1FBCA:  MOVFF  870,874
1FBCE:  MOVFF  86D,871
1FBD2:  MOVFF  86E,872
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x68,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x66.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x66.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x74,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x73,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x72,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x74,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x73,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x74,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x73,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x67
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x6A
1FC26:  MOVLW  03
1FC28:  SUBWF  x6C,W
1FC2A:  SUBWF  x6A,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x6A,W
1FC32:  ADDLW  95
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8D5
1FC3E:  MOVFF  03,8D6
1FC42:  MOVFF  03,8DA
1FC46:  MOVFF  01,8D9
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x67,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x6A,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x67,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x67
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x6C,W
1FC68:  CLRF   03
1FC6A:  ADDLW  95
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8D5
1FC76:  MOVFF  03,8D6
1FC7A:  MOVFF  03,8DA
1FC7E:  MOVFF  01,8D9
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x67,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x66.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x68,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x6A
1FCAE:  CLRF   x69
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x6C,W
1FCB4:  SUBWF  x6A,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x69,W
1FCBA:  INCF   x69,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  75
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8D5
1FCCA:  MOVFF  03,8D6
1FCCE:  CLRF   03
1FCD0:  MOVF   x6A,W
1FCD2:  ADDLW  95
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8D7
1FCDE:  MOVFF  03,8D8
1FCE2:  MOVFF  03,8DA
1FCE6:  MOVFF  01,8D9
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8D6,FEA
1FCF2:  MOVFF  8D5,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x6A,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xD5
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  874,8D5
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xD6
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  873,8D5
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xD6
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  872,8D5
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xD6
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  871,8D5
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xD6
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  86B,8D5
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xD6
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  873,FF8
1FD80:  MOVFF  872,FF7
1FD84:  MOVFF  871,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  75
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  86B,8D5
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  873,FF8
1FD9A:  MOVFF  872,FF7
1FD9E:  MOVFF  871,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  95
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xD6
1FDAE:  MOVFF  86B,8D5
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xD6
1FDBC:  MOVLW  75
1FDBE:  MOVWF  xD5
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xD8
1FDC4:  MOVLW  95
1FDC6:  MOVWF  xD7
1FDC8:  MOVFF  86B,8D9
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x66.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x68,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xDA
1FE02:  MOVLW  9E
1FE04:  MOVWF  xD9
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8D5
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xDA
1FE14:  MOVLW  A0
1FE16:  MOVWF  xD9
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8D5,870
1FE20:  MOVFF  01,86F
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xD5
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  86F,8D5
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xD6
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x66.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x66.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xD5
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xCD
1FE8E:  MOVLB  0
1FE90:  CALL   28AC
1FE94:  MOVLB  8
1FE96:  DECFSZ xD5,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... int16 valve_align_timeout = -1; 
.................... int16 valve_align_counter = -1; 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
054E4:  BCF    FF2.5
....................    restart_wdt(); 
054E6:  CLRWDT
054E8:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
054EA:  CLRF   FCF
054EC:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
054EE:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
054F0:  MOVF   2F,W
054F2:  SUBLW  02
054F4:  BNZ   54FC
054F6:  MOVF   30,F
054F8:  BNZ   54FC
054FA:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
054FC:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
054FE:  BSF    F9D.0
05500:  GOTO   5514 (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
05504:  MOVLW  0B
05506:  MOVWF  FD7
05508:  MOVLW  DC
0550A:  MOVWF  FD6
....................    restart_wdt(); 
0550C:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
0550E:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
05510:  BSF    FF2.5
....................    setup_led_pulse(); 
05512:  BRA    54EA
05514:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
05516:  MOVLB  8
05518:  MOVF   xCE,W
0551A:  XORLW  00
0551C:  MOVLB  0
0551E:  BZ    5526
05520:  XORLW  01
05522:  BZ    552A
05524:  BRA    552C
....................       case 0 : suspend_heartbeat(); 
05526:  RCALL  54E4
....................          break; 
05528:  BRA    552C
....................       case 1 : restart_heartbeat(); 
0552A:  RCALL  5504
....................          break; 
....................    } 
0552C:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
03092:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
03094:  BCF    FD1.0
03096:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
0289C:  MOVLW  0B
0289E:  MOVWF  FD7
028A0:  MOVLW  DC
028A2:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
028A4:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
028A6:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
028A8:  BSF    FD1.0
028AA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0786A:  MOVFF  992,998
0786E:  MOVFF  991,997
07872:  MOVLB  9
07874:  MOVF   x95,F
07876:  BNZ   787C
07878:  MOVF   x96,F
0787A:  BZ    78C6
0787C:  MOVFF  994,03
07880:  MOVFF  993,FE9
07884:  MOVFF  994,FEA
07888:  MOVF   FEF,F
0788A:  BZ    78C6
....................      *s++ = *s2++; 
0788C:  MOVFF  998,99A
07890:  MOVF   x97,W
07892:  INCF   x97,F
07894:  BTFSC  FD8.2
07896:  INCF   x98,F
07898:  MOVWF  x99
0789A:  MOVFF  994,03
0789E:  MOVF   x93,W
078A0:  INCF   x93,F
078A2:  BTFSC  FD8.2
078A4:  INCF   x94,F
078A6:  MOVWF  FE9
078A8:  MOVFF  03,FEA
078AC:  MOVFF  FEF,99B
078B0:  MOVFF  99A,FEA
078B4:  MOVFF  999,FE9
078B8:  MOVFF  99B,FEF
078BC:  MOVF   x95,W
078BE:  BTFSC  FD8.2
078C0:  DECF   x96,F
078C2:  DECF   x95,F
078C4:  BRA    7874
....................   for (; n > 0; n--) 
078C6:  MOVF   x95,F
078C8:  BNZ   78CE
078CA:  MOVF   x96,F
078CC:  BZ    78EC
....................      *s++ = '\0'; 
078CE:  MOVFF  998,03
078D2:  MOVF   x97,W
078D4:  INCF   x97,F
078D6:  BTFSC  FD8.2
078D8:  INCF   x98,F
078DA:  MOVWF  FE9
078DC:  MOVFF  03,FEA
078E0:  CLRF   FEF
078E2:  MOVF   x95,W
078E4:  BTFSC  FD8.2
078E6:  DECF   x96,F
078E8:  DECF   x95,F
078EA:  BRA    78C6
....................  
....................   return(s1); 
078EC:  MOVFF  991,01
078F0:  MOVFF  992,02
078F4:  MOVLB  0
078F6:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
05472:  MOVFF  8DA,8DE
05476:  MOVFF  8D9,8DD
0547A:  MOVFF  8DE,03
0547E:  MOVLB  8
05480:  MOVFF  8DD,FE9
05484:  MOVFF  8DE,FEA
05488:  MOVF   FEF,F
0548A:  BZ    5498
0548C:  INCF   xDD,F
0548E:  BTFSC  FD8.2
05490:  INCF   xDE,F
05492:  MOVLB  0
05494:  BRA    547A
05496:  MOVLB  8
....................    while(*s2 != '\0') 
05498:  MOVFF  8DC,03
0549C:  MOVFF  8DB,FE9
054A0:  MOVFF  8DC,FEA
054A4:  MOVF   FEF,F
054A6:  BZ    54CE
....................    { 
....................       *s = *s2; 
054A8:  MOVFF  8DB,FE9
054AC:  MOVFF  8DC,FEA
054B0:  MOVFF  FEF,8E1
054B4:  MOVFF  8DE,FEA
054B8:  MOVFF  8DD,FE9
054BC:  MOVFF  8E1,FEF
....................       ++s; 
054C0:  INCF   xDD,F
054C2:  BTFSC  FD8.2
054C4:  INCF   xDE,F
....................       ++s2; 
054C6:  INCF   xDB,F
054C8:  BTFSC  FD8.2
054CA:  INCF   xDC,F
054CC:  BRA    5498
....................    } 
....................  
....................    *s = '\0'; 
054CE:  MOVFF  8DD,FE9
054D2:  MOVFF  8DE,FEA
054D6:  CLRF   FEF
....................    return(s1); 
054D8:  MOVFF  8D9,01
054DC:  MOVFF  8DA,02
054E0:  MOVLB  0
054E2:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
129F8:  MOVFF  8CF,8D5
129FC:  MOVFF  8CE,8D4
12A00:  MOVFF  8D5,03
12A04:  MOVLB  8
12A06:  MOVFF  8D4,FE9
12A0A:  MOVFF  8D5,FEA
12A0E:  MOVF   FEF,F
12A10:  BZ    12A1E
12A12:  INCF   xD4,F
12A14:  BTFSC  FD8.2
12A16:  INCF   xD5,F
12A18:  MOVLB  0
12A1A:  BRA    12A00
12A1C:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12A1E:  MOVFF  8D1,03
12A22:  MOVFF  8D0,FE9
12A26:  MOVFF  8D1,FEA
12A2A:  MOVF   FEF,F
12A2C:  BZ    12A66
12A2E:  MOVF   xD3,F
12A30:  BNZ   12A38
12A32:  MOVF   xD2,W
12A34:  SUBLW  00
12A36:  BC    12A66
....................    { 
....................       *s = *s2; 
12A38:  MOVFF  8D0,FE9
12A3C:  MOVFF  8D1,FEA
12A40:  MOVFF  FEF,8D8
12A44:  MOVFF  8D5,FEA
12A48:  MOVFF  8D4,FE9
12A4C:  MOVFF  8D8,FEF
....................       ++s; 
12A50:  INCF   xD4,F
12A52:  BTFSC  FD8.2
12A54:  INCF   xD5,F
....................       ++s2; 
12A56:  INCF   xD0,F
12A58:  BTFSC  FD8.2
12A5A:  INCF   xD1,F
....................       --n; 
12A5C:  MOVF   xD2,W
12A5E:  BTFSC  FD8.2
12A60:  DECF   xD3,F
12A62:  DECF   xD2,F
12A64:  BRA    12A1E
....................    } 
....................  
....................    *s = '\0'; 
12A66:  MOVFF  8D4,FE9
12A6A:  MOVFF  8D5,FEA
12A6E:  CLRF   FEF
....................    return(s1); 
12A70:  MOVFF  8CE,01
12A74:  MOVFF  8CF,02
12A78:  MOVLB  0
12A7A:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
045AC:  MOVFF  9CB,9D1
045B0:  MOVFF  9CA,9D0
045B4:  MOVFF  9CD,9D3
045B8:  MOVFF  9CC,9D2
045BC:  MOVLB  9
045BE:  MOVF   xCF,F
045C0:  BNZ   45C8
045C2:  MOVF   xCE,W
045C4:  SUBLW  00
045C6:  BC    4628
.................... { 
....................    if(*su1!=*su2) 
045C8:  MOVFF  9D0,FE9
045CC:  MOVFF  9D1,FEA
045D0:  MOVFF  FEF,9D4
045D4:  MOVFF  9D3,03
045D8:  MOVFF  9D2,FE9
045DC:  MOVFF  9D3,FEA
045E0:  MOVF   FEF,W
045E2:  SUBWF  xD4,W
045E4:  BZ    4612
....................       return ((*su1<*su2)?-1:1); 
045E6:  MOVFF  9D1,03
045EA:  MOVFF  9D0,FE9
045EE:  MOVFF  03,FEA
045F2:  MOVFF  FEF,9D4
045F6:  MOVFF  9D3,03
045FA:  MOVFF  9D2,FE9
045FE:  MOVFF  9D3,FEA
04602:  MOVF   FEF,W
04604:  SUBWF  xD4,W
04606:  BC    460C
04608:  MOVLW  FF
0460A:  BRA    460E
0460C:  MOVLW  01
0460E:  MOVWF  01
04610:  BRA    462C
04612:  INCF   xD0,F
04614:  BTFSC  FD8.2
04616:  INCF   xD1,F
04618:  INCF   xD2,F
0461A:  BTFSC  FD8.2
0461C:  INCF   xD3,F
0461E:  MOVF   xCE,W
04620:  BTFSC  FD8.2
04622:  DECF   xCF,F
04624:  DECF   xCE,F
04626:  BRA    45BE
.................... } 
.................... return 0; 
04628:  MOVLW  00
0462A:  MOVWF  01
0462C:  MOVLB  0
0462E:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
129BC:  MOVFF  8CD,8CF
129C0:  MOVFF  8CC,8CE
129C4:  MOVFF  8CF,03
129C8:  MOVLB  8
129CA:  MOVFF  8CE,FE9
129CE:  MOVFF  8CF,FEA
129D2:  MOVF   FEF,F
129D4:  BZ    129E2
129D6:  INCF   xCE,F
129D8:  BTFSC  FD8.2
129DA:  INCF   xCF,F
129DC:  MOVLB  0
129DE:  BRA    129C4
129E0:  MOVLB  8
....................    return(sc - s); 
129E2:  MOVF   xCC,W
129E4:  SUBWF  xCE,W
129E6:  MOVWF  00
129E8:  MOVF   xCD,W
129EA:  SUBWFB xCF,W
129EC:  MOVWF  03
129EE:  MOVFF  00,01
129F2:  MOVWF  02
129F4:  MOVLB  0
129F6:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
1303C:  MOVLB  8
1303E:  CLRF   xBB
....................    sign = 0; 
13040:  CLRF   xB9
....................    base = 10; 
13042:  MOVLW  0A
13044:  MOVWF  xBA
....................    result = 0; 
13046:  CLRF   xB8
13048:  CLRF   xB7
....................  
....................    if (!s) 
1304A:  MOVF   xB5,W
1304C:  IORWF  xB6,W
1304E:  BNZ   13058
....................       return 0; 
13050:  MOVLW  00
13052:  MOVWF  01
13054:  MOVWF  02
13056:  BRA    1321C
....................    c = s[index++]; 
13058:  MOVF   xBB,W
1305A:  INCF   xBB,F
1305C:  ADDWF  xB5,W
1305E:  MOVWF  FE9
13060:  MOVLW  00
13062:  ADDWFC xB6,W
13064:  MOVWF  FEA
13066:  MOVFF  FEF,8BC
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
1306A:  MOVF   xBC,W
1306C:  SUBLW  2D
1306E:  BNZ   13088
....................    { 
....................       sign = 1;         // Set the sign to negative 
13070:  MOVLW  01
13072:  MOVWF  xB9
....................       c = s[index++]; 
13074:  MOVF   xBB,W
13076:  INCF   xBB,F
13078:  ADDWF  xB5,W
1307A:  MOVWF  FE9
1307C:  MOVLW  00
1307E:  ADDWFC xB6,W
13080:  MOVWF  FEA
13082:  MOVFF  FEF,8BC
....................    } 
13086:  BRA    130A0
....................    else if (c == '+') 
13088:  MOVF   xBC,W
1308A:  SUBLW  2B
1308C:  BNZ   130A0
....................    { 
....................       c = s[index++]; 
1308E:  MOVF   xBB,W
13090:  INCF   xBB,F
13092:  ADDWF  xB5,W
13094:  MOVWF  FE9
13096:  MOVLW  00
13098:  ADDWFC xB6,W
1309A:  MOVWF  FEA
1309C:  MOVFF  FEF,8BC
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
130A0:  MOVF   xBC,W
130A2:  SUBLW  2F
130A4:  BTFSC  FD8.0
130A6:  BRA    13200
130A8:  MOVF   xBC,W
130AA:  SUBLW  39
130AC:  BTFSS  FD8.0
130AE:  BRA    13200
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
130B0:  MOVF   xBC,W
130B2:  SUBLW  30
130B4:  BNZ   130F2
130B6:  MOVF   xBB,W
130B8:  ADDWF  xB5,W
130BA:  MOVWF  FE9
130BC:  MOVLW  00
130BE:  ADDWFC xB6,W
130C0:  MOVWF  FEA
130C2:  MOVF   FEF,W
130C4:  SUBLW  78
130C6:  BZ    130DA
130C8:  MOVF   xBB,W
130CA:  ADDWF  xB5,W
130CC:  MOVWF  FE9
130CE:  MOVLW  00
130D0:  ADDWFC xB6,W
130D2:  MOVWF  FEA
130D4:  MOVF   FEF,W
130D6:  SUBLW  58
130D8:  BNZ   130F2
....................       { 
....................          base = 16; 
130DA:  MOVLW  10
130DC:  MOVWF  xBA
....................          index++; 
130DE:  INCF   xBB,F
....................          c = s[index++]; 
130E0:  MOVF   xBB,W
130E2:  INCF   xBB,F
130E4:  ADDWF  xB5,W
130E6:  MOVWF  FE9
130E8:  MOVLW  00
130EA:  ADDWFC xB6,W
130EC:  MOVWF  FEA
130EE:  MOVFF  FEF,8BC
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
130F2:  MOVF   xBA,W
130F4:  SUBLW  0A
130F6:  BNZ   1313C
....................       { 
....................          while (c >= '0' && c <= '9') 
130F8:  MOVF   xBC,W
130FA:  SUBLW  2F
130FC:  BC    1313A
130FE:  MOVF   xBC,W
13100:  SUBLW  39
13102:  BNC   1313A
....................          { 
....................             result = 10*result + (c - '0'); 
13104:  CLRF   xBE
13106:  MOVLW  0A
13108:  MOVWF  xBD
1310A:  MOVFF  8B8,8C0
1310E:  MOVFF  8B7,8BF
13112:  MOVLB  0
13114:  BRA    12FE6
13116:  MOVLW  30
13118:  MOVLB  8
1311A:  SUBWF  xBC,W
1311C:  ADDWF  01,W
1311E:  MOVWF  xB7
13120:  MOVLW  00
13122:  ADDWFC 02,W
13124:  MOVWF  xB8
....................             c = s[index++]; 
13126:  MOVF   xBB,W
13128:  INCF   xBB,F
1312A:  ADDWF  xB5,W
1312C:  MOVWF  FE9
1312E:  MOVLW  00
13130:  ADDWFC xB6,W
13132:  MOVWF  FEA
13134:  MOVFF  FEF,8BC
13138:  BRA    130F8
....................          } 
....................       } 
1313A:  BRA    13200
....................       else if (base == 16)    // The number is a hexa number 
1313C:  MOVF   xBA,W
1313E:  SUBLW  10
13140:  BNZ   13200
....................       { 
....................          c = toupper(c); 
13142:  MOVF   xBC,W
13144:  SUBLW  60
13146:  BC    13154
13148:  MOVF   xBC,W
1314A:  SUBLW  7A
1314C:  BNC   13154
1314E:  MOVF   xBC,W
13150:  ANDLW  DF
13152:  BRA    13156
13154:  MOVF   xBC,W
13156:  MOVWF  xBC
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
13158:  MOVF   xBC,W
1315A:  SUBLW  2F
1315C:  BC    13164
1315E:  MOVF   xBC,W
13160:  SUBLW  39
13162:  BC    13170
13164:  MOVF   xBC,W
13166:  SUBLW  40
13168:  BC    13200
1316A:  MOVF   xBC,W
1316C:  SUBLW  46
1316E:  BNC   13200
....................          { 
....................             if (c >= '0' && c <= '9') 
13170:  MOVF   xBC,W
13172:  SUBLW  2F
13174:  BC    131AA
13176:  MOVF   xBC,W
13178:  SUBLW  39
1317A:  BNC   131AA
....................                result = (result << 4) + (c - '0'); 
1317C:  RLCF   xB7,W
1317E:  MOVWF  xBD
13180:  RLCF   xB8,W
13182:  MOVWF  xBE
13184:  RLCF   xBD,F
13186:  RLCF   xBE,F
13188:  RLCF   xBD,F
1318A:  RLCF   xBE,F
1318C:  RLCF   xBD,F
1318E:  RLCF   xBE,F
13190:  MOVLW  F0
13192:  ANDWF  xBD,F
13194:  MOVLW  30
13196:  SUBWF  xBC,W
13198:  ADDWF  xBD,W
1319A:  MOVWF  01
1319C:  MOVLW  00
1319E:  ADDWFC xBE,W
131A0:  MOVWF  03
131A2:  MOVFF  01,8B7
131A6:  MOVWF  xB8
131A8:  BRA    131D6
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
131AA:  RLCF   xB7,W
131AC:  MOVWF  xBD
131AE:  RLCF   xB8,W
131B0:  MOVWF  xBE
131B2:  RLCF   xBD,F
131B4:  RLCF   xBE,F
131B6:  RLCF   xBD,F
131B8:  RLCF   xBE,F
131BA:  RLCF   xBD,F
131BC:  RLCF   xBE,F
131BE:  MOVLW  F0
131C0:  ANDWF  xBD,F
131C2:  MOVLW  41
131C4:  SUBWF  xBC,W
131C6:  ADDLW  0A
131C8:  ADDWF  xBD,W
131CA:  MOVWF  01
131CC:  MOVLW  00
131CE:  ADDWFC xBE,W
131D0:  MOVFF  01,8B7
131D4:  MOVWF  xB8
....................  
....................             c = s[index++];c = toupper(c); 
131D6:  MOVF   xBB,W
131D8:  INCF   xBB,F
131DA:  ADDWF  xB5,W
131DC:  MOVWF  FE9
131DE:  MOVLW  00
131E0:  ADDWFC xB6,W
131E2:  MOVWF  FEA
131E4:  MOVFF  FEF,8BC
131E8:  MOVF   xBC,W
131EA:  SUBLW  60
131EC:  BC    131FA
131EE:  MOVF   xBC,W
131F0:  SUBLW  7A
131F2:  BNC   131FA
131F4:  MOVF   xBC,W
131F6:  ANDLW  DF
131F8:  BRA    131FC
131FA:  MOVF   xBC,W
131FC:  MOVWF  xBC
131FE:  BRA    13158
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
13200:  MOVF   xBA,W
13202:  SUBLW  0A
13204:  BNZ   13214
13206:  DECFSZ xB9,W
13208:  BRA    13214
....................       result = -result; 
1320A:  COMF   xB7,F
1320C:  COMF   xB8,F
1320E:  INCF   xB7,F
13210:  BTFSC  FD8.2
13212:  INCF   xB8,F
....................  
....................    return(result); 
13214:  MOVFF  8B7,01
13218:  MOVFF  8B8,02
1321C:  MOVLB  0
1321E:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0C722:  MOVLB  8
0C724:  CLRF   x85
0C726:  CLRF   x84
0C728:  CLRF   x83
0C72A:  MOVLW  7F
0C72C:  MOVWF  x82
0C72E:  CLRF   x89
0C730:  CLRF   x88
0C732:  CLRF   x87
0C734:  CLRF   x86
0C736:  BSF    x8A.0
0C738:  BCF    x8A.1
0C73A:  BCF    x8A.2
0C73C:  CLRF   x8C
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0C73E:  MOVF   x7E,W
0C740:  IORWF  x7F,W
0C742:  BNZ   C74E
....................       return 0; 
0C744:  CLRF   00
0C746:  CLRF   01
0C748:  CLRF   02
0C74A:  CLRF   03
0C74C:  BRA    C972
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0C74E:  MOVF   x8C,W
0C750:  INCF   x8C,F
0C752:  ADDWF  x7E,W
0C754:  MOVWF  FE9
0C756:  MOVLW  00
0C758:  ADDWFC x7F,W
0C75A:  MOVWF  FEA
0C75C:  MOVFF  FEF,88B
0C760:  MOVF   x8B,F
0C762:  BTFSC  FD8.2
0C764:  BRA    C8F6
....................    { 
....................       if (skip && !isspace(c)) 
0C766:  BTFSS  x8A.0
0C768:  BRA    C788
0C76A:  MOVF   x8B,W
0C76C:  SUBLW  20
0C76E:  BZ    C788
....................       { 
....................          skip = 0; 
0C770:  BCF    x8A.0
....................          if (c == '+') 
0C772:  MOVF   x8B,W
0C774:  SUBLW  2B
0C776:  BNZ   C77E
....................          { 
....................             sign = 0; 
0C778:  BCF    x8A.1
....................             continue; 
0C77A:  BRA    C8DE
....................          }             
0C77C:  BRA    C788
....................          else if (c == '-') 
0C77E:  MOVF   x8B,W
0C780:  SUBLW  2D
0C782:  BNZ   C788
....................          { 
....................             sign = 1; 
0C784:  BSF    x8A.1
....................             continue; 
0C786:  BRA    C8DE
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0C788:  BTFSC  x8A.0
0C78A:  BRA    C79A
0C78C:  MOVF   x8B,W
0C78E:  SUBLW  2E
0C790:  BNZ   C79A
0C792:  BTFSC  x8A.2
0C794:  BRA    C79A
....................          point = 1; 
0C796:  BSF    x8A.2
0C798:  BRA    C8DE
....................       else if (!skip && isdigit(c)) 
0C79A:  BTFSC  x8A.0
0C79C:  BRA    C8D8
0C79E:  MOVF   x8B,W
0C7A0:  SUBLW  2F
0C7A2:  BTFSC  FD8.0
0C7A4:  BRA    C8D8
0C7A6:  MOVF   x8B,W
0C7A8:  SUBLW  39
0C7AA:  BTFSS  FD8.0
0C7AC:  BRA    C8D8
....................       { 
....................          c -= '0'; 
0C7AE:  MOVLW  30
0C7B0:  SUBWF  x8B,F
....................          if (point) 
0C7B2:  BTFSS  x8A.2
0C7B4:  BRA    C860
....................          { 
....................             pow10 = pow10 * 10.0; 
0C7B6:  MOVFF  885,8F7
0C7BA:  MOVFF  884,8F6
0C7BE:  MOVFF  883,8F5
0C7C2:  MOVFF  882,8F4
0C7C6:  CLRF   xFB
0C7C8:  CLRF   xFA
0C7CA:  MOVLW  20
0C7CC:  MOVWF  xF9
0C7CE:  MOVLW  82
0C7D0:  MOVWF  xF8
0C7D2:  MOVLB  0
0C7D4:  CALL   BF4E
0C7D8:  MOVFF  03,885
0C7DC:  MOVFF  02,884
0C7E0:  MOVFF  01,883
0C7E4:  MOVFF  00,882
....................             result += (float)c / pow10;    
0C7E8:  MOVLB  8
0C7EA:  CLRF   xF9
0C7EC:  MOVFF  88B,8F8
0C7F0:  MOVLB  0
0C7F2:  RCALL  C58E
0C7F4:  MOVFF  03,890
0C7F8:  MOVFF  02,88F
0C7FC:  MOVFF  01,88E
0C800:  MOVFF  00,88D
0C804:  MOVFF  03,8DF
0C808:  MOVFF  02,8DE
0C80C:  MOVFF  01,8DD
0C810:  MOVFF  00,8DC
0C814:  MOVFF  885,8E3
0C818:  MOVFF  884,8E2
0C81C:  MOVFF  883,8E1
0C820:  MOVFF  882,8E0
0C824:  RCALL  C5C4
0C826:  BCF    FD8.1
0C828:  MOVFF  889,8FB
0C82C:  MOVFF  888,8FA
0C830:  MOVFF  887,8F9
0C834:  MOVFF  886,8F8
0C838:  MOVFF  03,8FF
0C83C:  MOVFF  02,8FE
0C840:  MOVFF  01,8FD
0C844:  MOVFF  00,8FC
0C848:  CALL   C044
0C84C:  MOVFF  03,889
0C850:  MOVFF  02,888
0C854:  MOVFF  01,887
0C858:  MOVFF  00,886
....................          } 
0C85C:  BRA    C8D4
0C85E:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0C860:  CLRF   xF7
0C862:  CLRF   xF6
0C864:  MOVLW  20
0C866:  MOVWF  xF5
0C868:  MOVLW  82
0C86A:  MOVWF  xF4
0C86C:  MOVFF  889,8FB
0C870:  MOVFF  888,8FA
0C874:  MOVFF  887,8F9
0C878:  MOVFF  886,8F8
0C87C:  MOVLB  0
0C87E:  CALL   BF4E
0C882:  MOVFF  03,890
0C886:  MOVFF  02,88F
0C88A:  MOVFF  01,88E
0C88E:  MOVFF  00,88D
0C892:  MOVLB  8
0C894:  CLRF   xF9
0C896:  MOVFF  88B,8F8
0C89A:  MOVLB  0
0C89C:  RCALL  C58E
0C89E:  BCF    FD8.1
0C8A0:  MOVFF  890,8FB
0C8A4:  MOVFF  88F,8FA
0C8A8:  MOVFF  88E,8F9
0C8AC:  MOVFF  88D,8F8
0C8B0:  MOVFF  03,8FF
0C8B4:  MOVFF  02,8FE
0C8B8:  MOVFF  01,8FD
0C8BC:  MOVFF  00,8FC
0C8C0:  CALL   C044
0C8C4:  MOVFF  03,889
0C8C8:  MOVFF  02,888
0C8CC:  MOVFF  01,887
0C8D0:  MOVFF  00,886
....................          } 
....................       } 
0C8D4:  BRA    C8E0
0C8D6:  MOVLB  8
....................       else if (!skip) 
0C8D8:  BTFSC  x8A.0
0C8DA:  BRA    C8DE
....................          break; 
0C8DC:  BRA    C8F6
0C8DE:  MOVLB  0
0C8E0:  MOVLB  8
0C8E2:  MOVF   x8C,W
0C8E4:  INCF   x8C,F
0C8E6:  ADDWF  x7E,W
0C8E8:  MOVWF  FE9
0C8EA:  MOVLW  00
0C8EC:  ADDWFC x7F,W
0C8EE:  MOVWF  FEA
0C8F0:  MOVFF  FEF,88B
0C8F4:  BRA    C760
....................    } 
....................  
....................    if (sign) 
0C8F6:  BTFSS  x8A.1
0C8F8:  BRA    C92E
....................       result = -1*result; 
0C8FA:  CLRF   xF7
0C8FC:  CLRF   xF6
0C8FE:  MOVLW  80
0C900:  MOVWF  xF5
0C902:  MOVLW  7F
0C904:  MOVWF  xF4
0C906:  MOVFF  889,8FB
0C90A:  MOVFF  888,8FA
0C90E:  MOVFF  887,8F9
0C912:  MOVFF  886,8F8
0C916:  MOVLB  0
0C918:  CALL   BF4E
0C91C:  MOVFF  03,889
0C920:  MOVFF  02,888
0C924:  MOVFF  01,887
0C928:  MOVFF  00,886
0C92C:  MOVLB  8
....................        
....................    if(endptr) 
0C92E:  MOVF   x80,W
0C930:  IORWF  x81,W
0C932:  BZ    C962
....................    { 
....................       if (ptr) { 
0C934:  MOVF   x8C,F
0C936:  BZ    C950
....................          ptr--; 
0C938:  DECF   x8C,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0C93A:  MOVFF  880,FE9
0C93E:  MOVFF  881,FEA
0C942:  MOVF   x8C,W
0C944:  ADDWF  x7E,W
0C946:  MOVWF  FEF
0C948:  MOVLW  00
0C94A:  ADDWFC x7F,W
0C94C:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0C94E:  BRA    C962
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0C950:  MOVFF  880,FE9
0C954:  MOVFF  881,FEA
0C958:  MOVFF  87F,FEC
0C95C:  MOVF   FED,F
0C95E:  MOVFF  87E,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0C962:  MOVFF  886,00
0C966:  MOVFF  887,01
0C96A:  MOVFF  888,02
0C96E:  MOVFF  889,03
0C972:  MOVLB  0
0C974:  GOTO   C99C (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
12492:  MOVLB  8
12494:  BCF    xF3.0
....................    y = x; 
12496:  MOVFF  8E7,8EC
1249A:  MOVFF  8E6,8EB
1249E:  MOVFF  8E5,8EA
124A2:  MOVFF  8E4,8E9
....................  
....................    if (x < 0) 
124A6:  MOVFF  8E7,8F7
124AA:  MOVFF  8E6,8F6
124AE:  MOVFF  8E5,8F5
124B2:  MOVFF  8E4,8F4
124B6:  CLRF   xFB
124B8:  CLRF   xFA
124BA:  CLRF   xF9
124BC:  CLRF   xF8
124BE:  MOVLB  0
124C0:  CALL   103C4
124C4:  BNC   124D2
....................    { 
....................       s = 1; 
124C6:  MOVLB  8
124C8:  BSF    xF3.0
....................       y = -y; 
124CA:  MOVF   xEA,W
124CC:  XORLW  80
124CE:  MOVWF  xEA
124D0:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
124D2:  MOVFF  8EC,8F7
124D6:  MOVFF  8EB,8F6
124DA:  MOVFF  8EA,8F5
124DE:  MOVFF  8E9,8F4
124E2:  MOVLB  8
124E4:  CLRF   xFB
124E6:  CLRF   xFA
124E8:  CLRF   xF9
124EA:  MOVLW  8E
124EC:  MOVWF  xF8
124EE:  MOVLB  0
124F0:  CALL   103C4
124F4:  BC    124F8
124F6:  BNZ   12528
....................       res = (float32)(unsigned int16)y; 
124F8:  MOVFF  8EC,8F7
124FC:  MOVFF  8EB,8F6
12500:  MOVFF  8EA,8F5
12504:  MOVFF  8E9,8F4
12508:  RCALL  12456
1250A:  MOVFF  02,8F9
1250E:  MOVFF  01,8F8
12512:  CALL   C58E
12516:  MOVFF  03,8F0
1251A:  MOVFF  02,8EF
1251E:  MOVFF  01,8EE
12522:  MOVFF  00,8ED
12526:  BRA    126CA
....................  
....................  else if (y < 10000000.0) 
12528:  MOVFF  8EC,8F7
1252C:  MOVFF  8EB,8F6
12530:  MOVFF  8EA,8F5
12534:  MOVFF  8E9,8F4
12538:  MOVLW  80
1253A:  MOVLB  8
1253C:  MOVWF  xFB
1253E:  MOVLW  96
12540:  MOVWF  xFA
12542:  MOVLW  18
12544:  MOVWF  xF9
12546:  MOVLW  96
12548:  MOVWF  xF8
1254A:  MOVLB  0
1254C:  CALL   103C4
12550:  BTFSS  FD8.0
12552:  BRA    126BA
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
12554:  MOVFF  8EC,8F7
12558:  MOVFF  8EB,8F6
1255C:  MOVFF  8EA,8F5
12560:  MOVFF  8E9,8F4
12564:  MOVLB  8
12566:  CLRF   xFB
12568:  CLRF   xFA
1256A:  CLRF   xF9
1256C:  MOVLW  70
1256E:  MOVWF  xF8
12570:  MOVLB  0
12572:  CALL   BF4E
12576:  MOVFF  03,8F7
1257A:  MOVFF  02,8F6
1257E:  MOVFF  01,8F5
12582:  MOVFF  00,8F4
12586:  RCALL  12456
12588:  MOVFF  02,8F2
1258C:  MOVFF  01,8F1
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
12590:  MOVFF  8EC,8F7
12594:  MOVFF  8EB,8F6
12598:  MOVFF  8EA,8F5
1259C:  MOVFF  8E9,8F4
125A0:  MOVLB  8
125A2:  CLRF   xFB
125A4:  CLRF   xFA
125A6:  CLRF   xF9
125A8:  MOVLW  70
125AA:  MOVWF  xF8
125AC:  MOVLB  0
125AE:  CALL   BF4E
125B2:  MOVFF  03,8F7
125B6:  MOVFF  02,8F6
125BA:  MOVFF  01,8F5
125BE:  MOVFF  00,8F4
125C2:  MOVFF  8F2,8F9
125C6:  MOVFF  8F1,8F8
125CA:  CALL   C58E
125CE:  BSF    FD8.1
125D0:  MOVFF  8F7,8FB
125D4:  MOVFF  8F6,8FA
125D8:  MOVFF  8F5,8F9
125DC:  MOVFF  8F4,8F8
125E0:  MOVFF  03,8FF
125E4:  MOVFF  02,8FE
125E8:  MOVFF  01,8FD
125EC:  MOVFF  00,8FC
125F0:  CALL   C044
125F4:  MOVLB  8
125F6:  CLRF   xF7
125F8:  CLRF   xF6
125FA:  CLRF   xF5
125FC:  MOVLW  8E
125FE:  MOVWF  xF4
12600:  MOVFF  03,8FB
12604:  MOVFF  02,8FA
12608:  MOVFF  01,8F9
1260C:  MOVFF  00,8F8
12610:  MOVLB  0
12612:  CALL   BF4E
12616:  MOVFF  03,8EC
1261A:  MOVFF  02,8EB
1261E:  MOVFF  01,8EA
12622:  MOVFF  00,8E9
....................       res = 32768.0*(float32)l; 
12626:  MOVFF  8F2,8F9
1262A:  MOVFF  8F1,8F8
1262E:  CALL   C58E
12632:  MOVLB  8
12634:  CLRF   xF7
12636:  CLRF   xF6
12638:  CLRF   xF5
1263A:  MOVLW  8E
1263C:  MOVWF  xF4
1263E:  MOVFF  03,8FB
12642:  MOVFF  02,8FA
12646:  MOVFF  01,8F9
1264A:  MOVFF  00,8F8
1264E:  MOVLB  0
12650:  CALL   BF4E
12654:  MOVFF  03,8F0
12658:  MOVFF  02,8EF
1265C:  MOVFF  01,8EE
12660:  MOVFF  00,8ED
....................       res += (float32)(unsigned int16)y; 
12664:  MOVFF  8EC,8F7
12668:  MOVFF  8EB,8F6
1266C:  MOVFF  8EA,8F5
12670:  MOVFF  8E9,8F4
12674:  RCALL  12456
12676:  MOVFF  02,8F9
1267A:  MOVFF  01,8F8
1267E:  CALL   C58E
12682:  BCF    FD8.1
12684:  MOVFF  8F0,8FB
12688:  MOVFF  8EF,8FA
1268C:  MOVFF  8EE,8F9
12690:  MOVFF  8ED,8F8
12694:  MOVFF  03,8FF
12698:  MOVFF  02,8FE
1269C:  MOVFF  01,8FD
126A0:  MOVFF  00,8FC
126A4:  CALL   C044
126A8:  MOVFF  03,8F0
126AC:  MOVFF  02,8EF
126B0:  MOVFF  01,8EE
126B4:  MOVFF  00,8ED
....................    } 
126B8:  BRA    126CA
....................  
....................  else 
....................   res = y; 
126BA:  MOVFF  8EC,8F0
126BE:  MOVFF  8EB,8EF
126C2:  MOVFF  8EA,8EE
126C6:  MOVFF  8E9,8ED
....................  
....................  y = y - (float32)(unsigned int16)y; 
126CA:  MOVFF  8EC,8F7
126CE:  MOVFF  8EB,8F6
126D2:  MOVFF  8EA,8F5
126D6:  MOVFF  8E9,8F4
126DA:  RCALL  12456
126DC:  MOVFF  02,8F9
126E0:  MOVFF  01,8F8
126E4:  CALL   C58E
126E8:  BSF    FD8.1
126EA:  MOVFF  8EC,8FB
126EE:  MOVFF  8EB,8FA
126F2:  MOVFF  8EA,8F9
126F6:  MOVFF  8E9,8F8
126FA:  MOVFF  03,8FF
126FE:  MOVFF  02,8FE
12702:  MOVFF  01,8FD
12706:  MOVFF  00,8FC
1270A:  CALL   C044
1270E:  MOVFF  03,8EC
12712:  MOVFF  02,8EB
12716:  MOVFF  01,8EA
1271A:  MOVFF  00,8E9
....................  
....................  if (s) 
1271E:  MOVLB  8
12720:  BTFSS  xF3.0
12722:  BRA    1272A
....................   res = -res; 
12724:  MOVF   xEE,W
12726:  XORLW  80
12728:  MOVWF  xEE
....................  
....................  if (y != 0) 
1272A:  MOVFF  8EC,8F7
1272E:  MOVFF  8EB,8F6
12732:  MOVFF  8EA,8F5
12736:  MOVFF  8E9,8F4
1273A:  CLRF   xFB
1273C:  CLRF   xFA
1273E:  CLRF   xF9
12740:  CLRF   xF8
12742:  MOVLB  0
12744:  CALL   103C4
12748:  BZ    127C2
....................  { 
....................   if (s == 1 && n == 0) 
1274A:  MOVLB  8
1274C:  BTFSS  xF3.0
1274E:  BRA    12788
12750:  MOVF   xE8,F
12752:  BNZ   12788
....................    res -= 1.0; 
12754:  BSF    FD8.1
12756:  MOVFF  8F0,8FB
1275A:  MOVFF  8EF,8FA
1275E:  MOVFF  8EE,8F9
12762:  MOVFF  8ED,8F8
12766:  CLRF   xFF
12768:  CLRF   xFE
1276A:  CLRF   xFD
1276C:  MOVLW  7F
1276E:  MOVWF  xFC
12770:  MOVLB  0
12772:  CALL   C044
12776:  MOVFF  03,8F0
1277A:  MOVFF  02,8EF
1277E:  MOVFF  01,8EE
12782:  MOVFF  00,8ED
12786:  MOVLB  8
....................  
....................   if (s == 0 && n == 1) 
12788:  BTFSC  xF3.0
1278A:  BRA    127C4
1278C:  DECFSZ xE8,W
1278E:  BRA    127C4
....................    res += 1.0; 
12790:  BCF    FD8.1
12792:  MOVFF  8F0,8FB
12796:  MOVFF  8EF,8FA
1279A:  MOVFF  8EE,8F9
1279E:  MOVFF  8ED,8F8
127A2:  CLRF   xFF
127A4:  CLRF   xFE
127A6:  CLRF   xFD
127A8:  MOVLW  7F
127AA:  MOVWF  xFC
127AC:  MOVLB  0
127AE:  CALL   C044
127B2:  MOVFF  03,8F0
127B6:  MOVFF  02,8EF
127BA:  MOVFF  01,8EE
127BE:  MOVFF  00,8ED
127C2:  MOVLB  8
....................  } 
....................  if (x == 0) 
127C4:  MOVFF  8E7,8F7
127C8:  MOVFF  8E6,8F6
127CC:  MOVFF  8E5,8F5
127D0:  MOVFF  8E4,8F4
127D4:  CLRF   xFB
127D6:  CLRF   xFA
127D8:  CLRF   xF9
127DA:  CLRF   xF8
127DC:  MOVLB  0
127DE:  CALL   103C4
127E2:  BNZ   127F0
....................     res = 0; 
127E4:  MOVLB  8
127E6:  CLRF   xF0
127E8:  CLRF   xEF
127EA:  CLRF   xEE
127EC:  CLRF   xED
127EE:  MOVLB  0
....................  
....................  return (res); 
127F0:  MOVFF  8ED,00
127F4:  MOVFF  8EE,01
127F8:  MOVFF  8EF,02
127FC:  MOVFF  8F0,03
12800:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
12820:  MOVFF  8E3,8E7
12824:  MOVFF  8E2,8E6
12828:  MOVFF  8E1,8E5
1282C:  MOVFF  8E0,8E4
12830:  MOVLB  8
12832:  CLRF   xE8
12834:  MOVLB  0
12836:  RCALL  12492
12838:  GOTO   12944 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
12802:  MOVFF  8E3,8E7
12806:  MOVFF  8E2,8E6
1280A:  MOVFF  8E1,8E5
1280E:  MOVFF  8E0,8E4
12812:  MOVLW  01
12814:  MOVLB  8
12816:  MOVWF  xE8
12818:  MOVLB  0
1281A:  RCALL  12492
1281C:  GOTO   128FC (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
1283C:  MOVFF  8D7,8F7
12840:  MOVFF  8D6,8F6
12844:  MOVFF  8D5,8F5
12848:  MOVFF  8D4,8F4
1284C:  MOVLB  8
1284E:  CLRF   xFB
12850:  CLRF   xFA
12852:  CLRF   xF9
12854:  CLRF   xF8
12856:  MOVLB  0
12858:  CALL   103C4
1285C:  BTFSC  FD8.2
1285E:  BRA    129A0
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
12860:  MOVFF  8D3,8DF
12864:  MOVFF  8D2,8DE
12868:  MOVFF  8D1,8DD
1286C:  MOVFF  8D0,8DC
12870:  MOVFF  8D7,8E3
12874:  MOVFF  8D6,8E2
12878:  MOVFF  8D5,8E1
1287C:  MOVFF  8D4,8E0
12880:  CALL   C5C4
12884:  MOVFF  03,8DF
12888:  MOVFF  02,8DE
1288C:  MOVFF  01,8DD
12890:  MOVFF  00,8DC
12894:  MOVFF  03,8F7
12898:  MOVFF  02,8F6
1289C:  MOVFF  01,8F5
128A0:  MOVFF  00,8F4
128A4:  MOVLB  8
128A6:  CLRF   xFB
128A8:  CLRF   xFA
128AA:  CLRF   xF9
128AC:  CLRF   xF8
128AE:  MOVLB  0
128B0:  CALL   103C4
128B4:  BNC   128FE
128B6:  MOVFF  8D3,8DF
128BA:  MOVFF  8D2,8DE
128BE:  MOVFF  8D1,8DD
128C2:  MOVFF  8D0,8DC
128C6:  MOVFF  8D7,8E3
128CA:  MOVFF  8D6,8E2
128CE:  MOVFF  8D5,8E1
128D2:  MOVFF  8D4,8E0
128D6:  CALL   C5C4
128DA:  MOVFF  03,8DF
128DE:  MOVFF  02,8DE
128E2:  MOVFF  01,8DD
128E6:  MOVFF  00,8DC
128EA:  MOVFF  03,8E3
128EE:  MOVFF  02,8E2
128F2:  MOVFF  01,8E1
128F6:  MOVFF  00,8E0
128FA:  BRA    12802
128FC:  BRA    12944
128FE:  MOVFF  8D3,8DF
12902:  MOVFF  8D2,8DE
12906:  MOVFF  8D1,8DD
1290A:  MOVFF  8D0,8DC
1290E:  MOVFF  8D7,8E3
12912:  MOVFF  8D6,8E2
12916:  MOVFF  8D5,8E1
1291A:  MOVFF  8D4,8E0
1291E:  CALL   C5C4
12922:  MOVFF  03,8DF
12926:  MOVFF  02,8DE
1292A:  MOVFF  01,8DD
1292E:  MOVFF  00,8DC
12932:  MOVFF  03,8E3
12936:  MOVFF  02,8E2
1293A:  MOVFF  01,8E1
1293E:  MOVFF  00,8E0
12942:  BRA    12820
12944:  MOVFF  03,8DB
12948:  MOVFF  02,8DA
1294C:  MOVFF  01,8D9
12950:  MOVFF  00,8D8
....................       return(x-(i*y)); 
12954:  MOVFF  8DB,8F7
12958:  MOVFF  8DA,8F6
1295C:  MOVFF  8D9,8F5
12960:  MOVFF  8D8,8F4
12964:  MOVFF  8D7,8FB
12968:  MOVFF  8D6,8FA
1296C:  MOVFF  8D5,8F9
12970:  MOVFF  8D4,8F8
12974:  CALL   BF4E
12978:  BSF    FD8.1
1297A:  MOVFF  8D3,8FB
1297E:  MOVFF  8D2,8FA
12982:  MOVFF  8D1,8F9
12986:  MOVFF  8D0,8F8
1298A:  MOVFF  03,8FF
1298E:  MOVFF  02,8FE
12992:  MOVFF  01,8FD
12996:  MOVFF  00,8FC
1299A:  CALL   C044
1299E:  BRA    129A0
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
129A0:  GOTO   12C38 (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
1048E:  MOVFF  8BB,8BF
10492:  MOVFF  8BA,8BE
10496:  MOVFF  8B9,8BD
1049A:  MOVFF  8B8,8BC
....................  
....................    if (y != 1.0) 
1049E:  MOVFF  8BF,8F7
104A2:  MOVFF  8BE,8F6
104A6:  MOVFF  8BD,8F5
104AA:  MOVFF  8BC,8F4
104AE:  MOVLB  8
104B0:  CLRF   xFB
104B2:  CLRF   xFA
104B4:  CLRF   xF9
104B6:  MOVLW  7F
104B8:  MOVWF  xF8
104BA:  MOVLB  0
104BC:  RCALL  103C4
104BE:  BTFSC  FD8.2
104C0:  BRA    107FE
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
104C2:  MOVLW  08
104C4:  MOVLB  8
104C6:  MOVWF  xCE
104C8:  MOVLW  BC
104CA:  MOVWF  FE9
104CC:  MOVFF  8CE,FEA
104D0:  MOVLW  7E
104D2:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
104D4:  BSF    FD8.1
104D6:  MOVFF  8BF,8FB
104DA:  MOVFF  8BE,8FA
104DE:  MOVFF  8BD,8F9
104E2:  MOVFF  8BC,8F8
104E6:  CLRF   xFF
104E8:  CLRF   xFE
104EA:  CLRF   xFD
104EC:  MOVLW  7F
104EE:  MOVWF  xFC
104F0:  MOVLB  0
104F2:  CALL   C044
104F6:  MOVFF  03,8D0
104FA:  MOVFF  02,8CF
104FE:  MOVFF  01,8CE
10502:  MOVFF  00,8CD
10506:  BCF    FD8.1
10508:  MOVFF  8BF,8FB
1050C:  MOVFF  8BE,8FA
10510:  MOVFF  8BD,8F9
10514:  MOVFF  8BC,8F8
10518:  MOVLB  8
1051A:  CLRF   xFF
1051C:  CLRF   xFE
1051E:  CLRF   xFD
10520:  MOVLW  7F
10522:  MOVWF  xFC
10524:  MOVLB  0
10526:  CALL   C044
1052A:  MOVFF  8D0,8DF
1052E:  MOVFF  8CF,8DE
10532:  MOVFF  8CE,8DD
10536:  MOVFF  8CD,8DC
1053A:  MOVFF  03,8E3
1053E:  MOVFF  02,8E2
10542:  MOVFF  01,8E1
10546:  MOVFF  00,8E0
1054A:  CALL   C5C4
1054E:  MOVFF  03,8BF
10552:  MOVFF  02,8BE
10556:  MOVFF  01,8BD
1055A:  MOVFF  00,8BC
....................  
....................       y2=y*y; 
1055E:  MOVFF  8BF,8F7
10562:  MOVFF  8BE,8F6
10566:  MOVFF  8BD,8F5
1056A:  MOVFF  8BC,8F4
1056E:  MOVFF  8BF,8FB
10572:  MOVFF  8BE,8FA
10576:  MOVFF  8BD,8F9
1057A:  MOVFF  8BC,8F8
1057E:  CALL   BF4E
10582:  MOVFF  03,8CB
10586:  MOVFF  02,8CA
1058A:  MOVFF  01,8C9
1058E:  MOVFF  00,8C8
....................  
....................       res = pl[0]*y2 + pl[1]; 
10592:  MOVLW  99
10594:  MOVLB  8
10596:  MOVWF  xF7
10598:  MOVLW  47
1059A:  MOVWF  xF6
1059C:  MOVLW  8A
1059E:  MOVWF  xF5
105A0:  MOVLW  7F
105A2:  MOVWF  xF4
105A4:  MOVFF  8CB,8FB
105A8:  MOVFF  8CA,8FA
105AC:  MOVFF  8C9,8F9
105B0:  MOVFF  8C8,8F8
105B4:  MOVLB  0
105B6:  CALL   BF4E
105BA:  MOVFF  03,8D0
105BE:  MOVFF  02,8CF
105C2:  MOVFF  01,8CE
105C6:  MOVFF  00,8CD
105CA:  BCF    FD8.1
105CC:  MOVFF  03,8FB
105D0:  MOVFF  02,8FA
105D4:  MOVFF  01,8F9
105D8:  MOVFF  00,8F8
105DC:  MOVLB  8
105DE:  CLRF   xFF
105E0:  CLRF   xFE
105E2:  CLRF   xFD
105E4:  MOVLW  80
105E6:  MOVWF  xFC
105E8:  MOVLB  0
105EA:  CALL   C044
105EE:  MOVFF  03,8C3
105F2:  MOVFF  02,8C2
105F6:  MOVFF  01,8C1
105FA:  MOVFF  00,8C0
....................  
....................       r = ql[0]*y2 + ql[1]; 
105FE:  MOVLW  4C
10600:  MOVLB  8
10602:  MOVWF  xF7
10604:  MOVLW  F3
10606:  MOVWF  xF6
10608:  MOVLW  3A
1060A:  MOVWF  xF5
1060C:  MOVLW  7B
1060E:  MOVWF  xF4
10610:  MOVFF  8CB,8FB
10614:  MOVFF  8CA,8FA
10618:  MOVFF  8C9,8F9
1061C:  MOVFF  8C8,8F8
10620:  MOVLB  0
10622:  CALL   BF4E
10626:  MOVFF  03,8D0
1062A:  MOVFF  02,8CF
1062E:  MOVFF  01,8CE
10632:  MOVFF  00,8CD
10636:  BCF    FD8.1
10638:  MOVFF  03,8FB
1063C:  MOVFF  02,8FA
10640:  MOVFF  01,8F9
10644:  MOVFF  00,8F8
10648:  MOVLW  2B
1064A:  MOVLB  8
1064C:  MOVWF  xFF
1064E:  MOVLW  9D
10650:  MOVWF  xFE
10652:  MOVLW  DF
10654:  MOVWF  xFD
10656:  MOVLW  7E
10658:  MOVWF  xFC
1065A:  MOVLB  0
1065C:  CALL   C044
10660:  MOVFF  03,8C7
10664:  MOVFF  02,8C6
10668:  MOVFF  01,8C5
1066C:  MOVFF  00,8C4
....................       r = r*y2 + 1.0; 
10670:  MOVFF  8C7,8F7
10674:  MOVFF  8C6,8F6
10678:  MOVFF  8C5,8F5
1067C:  MOVFF  8C4,8F4
10680:  MOVFF  8CB,8FB
10684:  MOVFF  8CA,8FA
10688:  MOVFF  8C9,8F9
1068C:  MOVFF  8C8,8F8
10690:  CALL   BF4E
10694:  MOVFF  03,8D0
10698:  MOVFF  02,8CF
1069C:  MOVFF  01,8CE
106A0:  MOVFF  00,8CD
106A4:  BCF    FD8.1
106A6:  MOVFF  03,8FB
106AA:  MOVFF  02,8FA
106AE:  MOVFF  01,8F9
106B2:  MOVFF  00,8F8
106B6:  MOVLB  8
106B8:  CLRF   xFF
106BA:  CLRF   xFE
106BC:  CLRF   xFD
106BE:  MOVLW  7F
106C0:  MOVWF  xFC
106C2:  MOVLB  0
106C4:  CALL   C044
106C8:  MOVFF  03,8C7
106CC:  MOVFF  02,8C6
106D0:  MOVFF  01,8C5
106D4:  MOVFF  00,8C4
....................  
....................       res = y*res/r; 
106D8:  MOVFF  8BF,8F7
106DC:  MOVFF  8BE,8F6
106E0:  MOVFF  8BD,8F5
106E4:  MOVFF  8BC,8F4
106E8:  MOVFF  8C3,8FB
106EC:  MOVFF  8C2,8FA
106F0:  MOVFF  8C1,8F9
106F4:  MOVFF  8C0,8F8
106F8:  CALL   BF4E
106FC:  MOVFF  03,8D0
10700:  MOVFF  02,8CF
10704:  MOVFF  01,8CE
10708:  MOVFF  00,8CD
1070C:  MOVFF  03,8DF
10710:  MOVFF  02,8DE
10714:  MOVFF  01,8DD
10718:  MOVFF  00,8DC
1071C:  MOVFF  8C7,8E3
10720:  MOVFF  8C6,8E2
10724:  MOVFF  8C5,8E1
10728:  MOVFF  8C4,8E0
1072C:  CALL   C5C4
10730:  MOVFF  03,8C3
10734:  MOVFF  02,8C2
10738:  MOVFF  01,8C1
1073C:  MOVFF  00,8C0
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
10740:  MOVLW  08
10742:  MOVLB  8
10744:  MOVWF  xCE
10746:  MOVLW  B8
10748:  MOVWF  FE9
1074A:  MOVFF  8CE,FEA
1074E:  MOVLW  7E
10750:  SUBWF  FEF,W
10752:  MOVWF  xCC
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
10754:  BTFSS  xCC.7
10756:  BRA    10780
....................          r = -(float32)-n; 
10758:  MOVLW  00
1075A:  BSF    FD8.0
1075C:  SUBFWB xCC,W
1075E:  CLRF   xCE
10760:  MOVWF  xCD
10762:  BTFSC  xCD.7
10764:  DECF   xCE,F
10766:  MOVLB  0
10768:  RCALL  1043E
1076A:  MOVFF  00,8C4
1076E:  MOVF   01,W
10770:  XORLW  80
10772:  MOVLB  8
10774:  MOVWF  xC5
10776:  MOVFF  02,8C6
1077A:  MOVFF  03,8C7
1077E:  BRA    107A0
....................       else 
....................          r = (float32)n; 
10780:  CLRF   xCE
10782:  MOVFF  8CC,8CD
10786:  BTFSC  xCD.7
10788:  DECF   xCE,F
1078A:  MOVLB  0
1078C:  RCALL  1043E
1078E:  MOVFF  03,8C7
10792:  MOVFF  02,8C6
10796:  MOVFF  01,8C5
1079A:  MOVFF  00,8C4
1079E:  MOVLB  8
....................  
....................       res += r*LN2; 
107A0:  MOVFF  8C7,8F7
107A4:  MOVFF  8C6,8F6
107A8:  MOVFF  8C5,8F5
107AC:  MOVFF  8C4,8F4
107B0:  MOVLW  18
107B2:  MOVWF  xFB
107B4:  MOVLW  72
107B6:  MOVWF  xFA
107B8:  MOVLW  31
107BA:  MOVWF  xF9
107BC:  MOVLW  7E
107BE:  MOVWF  xF8
107C0:  MOVLB  0
107C2:  CALL   BF4E
107C6:  BCF    FD8.1
107C8:  MOVFF  8C3,8FB
107CC:  MOVFF  8C2,8FA
107D0:  MOVFF  8C1,8F9
107D4:  MOVFF  8C0,8F8
107D8:  MOVFF  03,8FF
107DC:  MOVFF  02,8FE
107E0:  MOVFF  01,8FD
107E4:  MOVFF  00,8FC
107E8:  CALL   C044
107EC:  MOVFF  03,8C3
107F0:  MOVFF  02,8C2
107F4:  MOVFF  01,8C1
107F8:  MOVFF  00,8C0
....................    } 
107FC:  BRA    1080A
....................  
....................    else 
....................       res = 0.0; 
107FE:  MOVLB  8
10800:  CLRF   xC3
10802:  CLRF   xC2
10804:  CLRF   xC1
10806:  CLRF   xC0
10808:  MOVLB  0
....................  
....................    return(res); 
1080A:  MOVFF  8C0,00
1080E:  MOVFF  8C1,01
10812:  MOVFF  8C2,02
10816:  MOVFF  8C3,03
1081A:  GOTO   10830 (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
1081E:  MOVFF  8B3,8BB
10822:  MOVFF  8B2,8BA
10826:  MOVFF  8B1,8B9
1082A:  MOVFF  8B0,8B8
1082E:  BRA    1048E
10830:  MOVFF  03,8B7
10834:  MOVFF  02,8B6
10838:  MOVFF  01,8B5
1083C:  MOVFF  00,8B4
....................    r = r*LN10_INV; 
10840:  MOVFF  8B7,8F7
10844:  MOVFF  8B6,8F6
10848:  MOVFF  8B5,8F5
1084C:  MOVFF  8B4,8F4
10850:  MOVLW  D9
10852:  MOVLB  8
10854:  MOVWF  xFB
10856:  MOVLW  5B
10858:  MOVWF  xFA
1085A:  MOVLW  5E
1085C:  MOVWF  xF9
1085E:  MOVLW  7D
10860:  MOVWF  xF8
10862:  MOVLB  0
10864:  CALL   BF4E
10868:  MOVFF  03,8B7
1086C:  MOVFF  02,8B6
10870:  MOVFF  01,8B5
10874:  MOVFF  00,8B4
....................    return(r); 
10878:  MOVFF  8B4,00
1087C:  MOVFF  8B5,01
10880:  MOVFF  8B6,02
10884:  MOVFF  8B7,03
10888:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
0FFEE:  BCF    FC6.5
0FFF0:  MOVLW  21
0FFF2:  MOVWF  FC6
0FFF4:  MOVLW  40
0FFF6:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
0FFF8:  BSF    F91.2
....................    output_high(EEP_WP); 
0FFFA:  BSF    F91.3
0FFFC:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
*
1022C:  BCF    F91.2
....................    spi_write(0x05);  
1022E:  MOVF   FC9,W
10230:  MOVLW  05
10232:  MOVWF  FC9
10234:  RRCF   FC7,W
10236:  BNC   10234
....................    data = spi_read(0);  
10238:  MOVF   FC9,W
1023A:  CLRF   FC9
1023C:  RRCF   FC7,W
1023E:  BNC   1023C
10240:  MOVFF  FC9,8AF
....................    output_high(EEP_CS);  
10244:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
10246:  MOVLW  00
10248:  MOVLB  8
1024A:  BTFSS  xAF.0
1024C:  MOVLW  01
1024E:  MOVWF  01
10250:  MOVLB  0
10252:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
17BC6:  MOVLB  8
17BC8:  CLRF   xCE
17BCA:  MOVLB  0
17BCC:  CALL   5516
....................       while(!ext_eeprom_ready()); 
17BD0:  CALL   1022C
17BD4:  MOVF   01,F
17BD6:  BZ    17BD0
....................     
....................       output_low(EEP_CS);  
17BD8:  BCF    F91.2
....................       spi_write(0x06);  
17BDA:  MOVF   FC9,W
17BDC:  MOVLW  06
17BDE:  MOVWF  FC9
17BE0:  RRCF   FC7,W
17BE2:  BNC   17BE0
....................       output_high(EEP_CS);  
17BE4:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
17BE6:  BCF    F91.2
....................       spi_write(0x02);  
17BE8:  MOVF   FC9,W
17BEA:  MOVLW  02
17BEC:  MOVWF  FC9
17BEE:  RRCF   FC7,W
17BF0:  BNC   17BEE
....................       spi_write(address >> 8);  
17BF2:  MOVFF  889,88B
17BF6:  MOVLB  8
17BF8:  CLRF   x8C
17BFA:  MOVF   FC9,W
17BFC:  MOVFF  889,FC9
17C00:  RRCF   FC7,W
17C02:  BNC   17C00
....................       spi_write(address);  
17C04:  MOVF   FC9,W
17C06:  MOVFF  888,FC9
17C0A:  RRCF   FC7,W
17C0C:  BNC   17C0A
....................       spi_write(data);  
17C0E:  MOVF   FC9,W
17C10:  MOVFF  88A,FC9
17C14:  RRCF   FC7,W
17C16:  BNC   17C14
....................       output_high(EEP_CS);  
17C18:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
17C1A:  MOVLW  01
17C1C:  MOVWF  xCE
17C1E:  MOVLB  0
17C20:  CALL   5516
17C24:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
10254:  MOVLB  8
10256:  CLRF   xCE
10258:  MOVLB  0
1025A:  CALL   5516
....................     
....................       while(!ext_eeprom_ready()); 
1025E:  RCALL  1022C
10260:  MOVF   01,F
10262:  BZ    1025E
....................        
....................       output_low(EEP_CS);  
10264:  BCF    F91.2
....................       spi_write(0x03);  
10266:  MOVF   FC9,W
10268:  MOVLW  03
1026A:  MOVWF  FC9
1026C:  RRCF   FC7,W
1026E:  BNC   1026C
....................       spi_write(address >> 8);  
10270:  MOVFF  8AD,8AF
10274:  MOVLB  8
10276:  CLRF   xB0
10278:  MOVF   FC9,W
1027A:  MOVFF  8AD,FC9
1027E:  RRCF   FC7,W
10280:  BNC   1027E
....................       spi_write(address);  
10282:  MOVF   FC9,W
10284:  MOVFF  8AC,FC9
10288:  RRCF   FC7,W
1028A:  BNC   10288
....................        
....................       data = spi_read(0);  
1028C:  MOVF   FC9,W
1028E:  CLRF   FC9
10290:  RRCF   FC7,W
10292:  BNC   10290
10294:  MOVFF  FC9,8AE
....................       output_high(EEP_CS);  
10298:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
1029A:  MOVLW  01
1029C:  MOVWF  xCE
1029E:  MOVLB  0
102A0:  CALL   5516
....................     
....................    return(data);  
102A4:  MOVLB  8
102A6:  MOVFF  8AE,01
102AA:  MOVLB  0
102AC:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
033AE:  MOVF   FF2,W
033B0:  MOVWF  00
033B2:  BCF    FF2.7
033B4:  CLRF   F63
033B6:  MOVFF  86A,F62
033BA:  MOVFF  86B,F61
033BE:  BCF    F7F.6
033C0:  BCF    F7F.7
033C2:  BSF    F7F.2
033C4:  MOVLB  F
033C6:  MOVLW  55
033C8:  MOVWF  F7E
033CA:  MOVLW  AA
033CC:  MOVWF  F7E
033CE:  BSF    F7F.1
033D0:  BTFSC  F7F.1
033D2:  BRA    33D0
033D4:  BCF    F7F.2
033D6:  MOVF   00,W
033D8:  IORWF  FF2,F
033DA:  MOVLB  0
033DC:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
029C0:  MOVLB  8
029C2:  CLRF   x99
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
029C4:  MOVFF  FF2,89A
029C8:  BCF    FF2.7
029CA:  CLRF   F63
029CC:  MOVFF  898,F62
029D0:  BCF    F7F.6
029D2:  BCF    F7F.7
029D4:  BSF    F7F.0
029D6:  MOVF   F61,W
029D8:  BTFSC  x9A.7
029DA:  BSF    FF2.7
029DC:  MOVWF  x99
....................    return(data); 
029DE:  MOVFF  899,01
029E2:  MOVLB  0
029E4:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
04F68:  MOVLB  8
04F6A:  CLRF   xD2
04F6C:  MOVF   xD2,W
04F6E:  SUBLW  01
04F70:  BNC   4FCA
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
04F72:  MOVF   xCF,W
04F74:  ADDWF  xD2,W
04F76:  MOVWF  xD3
04F78:  MOVLW  08
04F7A:  MOVWF  xD5
04F7C:  MOVLW  D0
04F7E:  MOVWF  xD4
04F80:  MOVF   xD2,W
04F82:  ADDWF  xD4,W
04F84:  MOVWF  01
04F86:  MOVLW  00
04F88:  ADDWFC xD5,W
04F8A:  MOVWF  03
04F8C:  MOVF   01,W
04F8E:  MOVWF  FE9
04F90:  MOVFF  03,FEA
04F94:  MOVFF  FEF,8D4
04F98:  MOVF   FF2,W
04F9A:  MOVWF  00
04F9C:  BCF    FF2.7
04F9E:  CLRF   F63
04FA0:  MOVFF  8D3,F62
04FA4:  MOVFF  8D4,F61
04FA8:  BCF    F7F.6
04FAA:  BCF    F7F.7
04FAC:  BSF    F7F.2
04FAE:  MOVLB  F
04FB0:  MOVLW  55
04FB2:  MOVWF  F7E
04FB4:  MOVLW  AA
04FB6:  MOVWF  F7E
04FB8:  BSF    F7F.1
04FBA:  BTFSC  F7F.1
04FBC:  BRA    4FBA
04FBE:  BCF    F7F.2
04FC0:  MOVF   00,W
04FC2:  IORWF  FF2,F
04FC4:  MOVLB  8
04FC6:  INCF   xD2,F
04FC8:  BRA    4F6C
....................     }  
04FCA:  MOVLB  0
04FCC:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
02966:  MOVLB  8
02968:  CLRF   x7B
0296A:  CLRF   x7A
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
0296C:  CLRF   x79
0296E:  MOVF   x79,W
02970:  SUBLW  01
02972:  BNC   29B4
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02974:  MOVLW  08
02976:  MOVWF  x7D
02978:  MOVLW  7A
0297A:  MOVWF  x7C
0297C:  MOVF   x79,W
0297E:  ADDWF  x7C,W
02980:  MOVWF  01
02982:  MOVLW  00
02984:  ADDWFC x7D,W
02986:  MOVWF  03
02988:  MOVF   01,W
0298A:  MOVWF  FE9
0298C:  MOVFF  03,FEA
02990:  MOVF   x78,W
02992:  ADDWF  x79,W
02994:  MOVWF  x7E
02996:  MOVFF  FF2,87F
0299A:  BCF    FF2.7
0299C:  CLRF   F63
0299E:  MOVFF  87E,F62
029A2:  BCF    F7F.6
029A4:  BCF    F7F.7
029A6:  BSF    F7F.0
029A8:  MOVF   F61,W
029AA:  BTFSC  x7F.7
029AC:  BSF    FF2.7
029AE:  MOVWF  FEF
029B0:  INCF   x79,F
029B2:  BRA    296E
....................    } 
....................  
....................    return(data);  
029B4:  MOVFF  87A,01
029B8:  MOVFF  87B,02
029BC:  MOVLB  0
029BE:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0C9BE:  MOVLB  8
0C9C0:  CLRF   x6C
0C9C2:  MOVF   x6C,W
0C9C4:  SUBLW  03
0C9C6:  BNC   CA28
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0C9C8:  MOVF   x6C,W
0C9CA:  ADDWF  x66,W
0C9CC:  MOVWF  x6D
0C9CE:  MOVLW  00
0C9D0:  ADDWFC x67,W
0C9D2:  MOVWF  x6E
0C9D4:  MOVLW  08
0C9D6:  MOVWF  x70
0C9D8:  MOVLW  68
0C9DA:  MOVWF  x6F
0C9DC:  MOVF   x6C,W
0C9DE:  ADDWF  x6F,W
0C9E0:  MOVWF  01
0C9E2:  MOVLW  00
0C9E4:  ADDWFC x70,W
0C9E6:  MOVWF  03
0C9E8:  MOVF   01,W
0C9EA:  MOVWF  FE9
0C9EC:  MOVFF  03,FEA
0C9F0:  MOVFF  FEF,86F
0C9F4:  MOVF   FF2,W
0C9F6:  MOVWF  00
0C9F8:  BCF    FF2.7
0C9FA:  MOVFF  86E,F63
0C9FE:  MOVFF  86D,F62
0CA02:  MOVFF  86F,F61
0CA06:  BCF    F7F.6
0CA08:  BCF    F7F.7
0CA0A:  BSF    F7F.2
0CA0C:  MOVLB  F
0CA0E:  MOVLW  55
0CA10:  MOVWF  F7E
0CA12:  MOVLW  AA
0CA14:  MOVWF  F7E
0CA16:  BSF    F7F.1
0CA18:  BTFSC  F7F.1
0CA1A:  BRA    CA18
0CA1C:  BCF    F7F.2
0CA1E:  MOVF   00,W
0CA20:  IORWF  FF2,F
0CA22:  MOVLB  8
0CA24:  INCF   x6C,F
0CA26:  BRA    C9C2
....................    } 
0CA28:  MOVLB  0
0CA2A:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
029E6:  MOVLB  8
029E8:  CLRF   x6C
029EA:  CLRF   x6B
029EC:  CLRF   x6A
029EE:  CLRF   x69
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
029F0:  CLRF   x68
029F2:  MOVF   x68,W
029F4:  SUBLW  03
029F6:  BNC   2A40
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
029F8:  MOVLW  08
029FA:  MOVWF  x6E
029FC:  MOVLW  69
029FE:  MOVWF  x6D
02A00:  MOVF   x68,W
02A02:  ADDWF  x6D,W
02A04:  MOVWF  01
02A06:  MOVLW  00
02A08:  ADDWFC x6E,W
02A0A:  MOVWF  03
02A0C:  MOVF   01,W
02A0E:  MOVWF  FE9
02A10:  MOVFF  03,FEA
02A14:  MOVF   x68,W
02A16:  ADDWF  x66,W
02A18:  MOVWF  x6F
02A1A:  MOVLW  00
02A1C:  ADDWFC x67,W
02A1E:  MOVWF  x70
02A20:  MOVFF  FF2,871
02A24:  BCF    FF2.7
02A26:  MOVFF  870,F63
02A2A:  MOVFF  86F,F62
02A2E:  BCF    F7F.6
02A30:  BCF    F7F.7
02A32:  BSF    F7F.0
02A34:  MOVF   F61,W
02A36:  BTFSC  x71.7
02A38:  BSF    FF2.7
02A3A:  MOVWF  FEF
02A3C:  INCF   x68,F
02A3E:  BRA    29F2
....................    } 
....................  
....................    return(data);  
02A40:  MOVFF  869,00
02A44:  MOVFF  86A,01
02A48:  MOVFF  86B,02
02A4C:  MOVFF  86C,03
02A50:  MOVLB  0
02A52:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
17E06:  MOVLB  8
17E08:  CLRF   x84
17E0A:  MOVF   x84,W
17E0C:  SUBLW  01
17E0E:  BNC   17E4C
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
17E10:  MOVF   x84,W
17E12:  ADDWF  x80,W
17E14:  MOVWF  x85
17E16:  MOVLW  00
17E18:  ADDWFC x81,W
17E1A:  MOVWF  x86
17E1C:  MOVLW  08
17E1E:  MOVWF  x88
17E20:  MOVLW  82
17E22:  MOVWF  x87
17E24:  MOVF   x84,W
17E26:  ADDWF  x87,W
17E28:  MOVWF  01
17E2A:  MOVLW  00
17E2C:  ADDWFC x88,W
17E2E:  MOVWF  03
17E30:  MOVFF  01,FE9
17E34:  MOVWF  FEA
17E36:  MOVFF  FEF,88A
17E3A:  MOVFF  886,889
17E3E:  MOVFF  885,888
17E42:  MOVLB  0
17E44:  RCALL  17BC6
17E46:  MOVLB  8
17E48:  INCF   x84,F
17E4A:  BRA    17E0A
....................     }  
17E4C:  MOVLB  0
17E4E:  GOTO   17EBE (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
10368:  MOVLB  8
1036A:  CLRF   xA7
1036C:  CLRF   xA6
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
1036E:  CLRF   xA5
10370:  MOVF   xA5,W
10372:  SUBLW  01
10374:  BNC   103B8
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
10376:  MOVLW  08
10378:  MOVWF  xA9
1037A:  MOVLW  A6
1037C:  MOVWF  xA8
1037E:  MOVF   xA5,W
10380:  ADDWF  xA8,W
10382:  MOVWF  01
10384:  MOVLW  00
10386:  ADDWFC xA9,W
10388:  MOVWF  03
1038A:  MOVFF  01,8A8
1038E:  MOVWF  xA9
10390:  MOVF   xA5,W
10392:  ADDWF  xA3,W
10394:  MOVWF  xAA
10396:  MOVLW  00
10398:  ADDWFC xA4,W
1039A:  MOVWF  xAB
1039C:  MOVWF  xAD
1039E:  MOVFF  8AA,8AC
103A2:  MOVLB  0
103A4:  RCALL  10254
103A6:  MOVFF  8A9,FEA
103AA:  MOVFF  8A8,FE9
103AE:  MOVFF  01,FEF
103B2:  MOVLB  8
103B4:  INCF   xA5,F
103B6:  BRA    10370
....................    } 
....................    return(data);  
103B8:  MOVFF  8A6,01
103BC:  MOVFF  8A7,02
103C0:  MOVLB  0
103C2:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
15886:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
15888:  MOVF   2F,W
1588A:  SUBLW  02
1588C:  BNZ   15894
1588E:  MOVF   30,F
15890:  BNZ   15894
15892:  BSF    F90.6
....................    delay_ms(32); 
15894:  MOVLW  20
15896:  MOVLB  9
15898:  MOVWF  xCD
1589A:  MOVLB  0
1589C:  CALL   28AC
....................    output_bit(BOARD_LED, OFF); 
158A0:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
158A2:  MOVF   2F,W
158A4:  SUBLW  02
158A6:  BNZ   158AE
158A8:  MOVF   30,F
158AA:  BNZ   158AE
158AC:  BCF    F90.6
....................    delay_ms(32); 
158AE:  MOVLW  20
158B0:  MOVLB  9
158B2:  MOVWF  xCD
158B4:  MOVLB  0
158B6:  CALL   28AC
158BA:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
030E4:  MOVF   2F,W
030E6:  MOVWF  00
030E8:  MOVF   30,W
030EA:  MOVWF  03
030EC:  BNZ   30F2
030EE:  MOVF   00,F
030F0:  BZ    3114
030F2:  MOVF   03,W
030F4:  BNZ   30FC
030F6:  MOVLW  01
030F8:  SUBWF  00,W
030FA:  BZ    3166
030FC:  MOVF   03,W
030FE:  BNZ   3106
03100:  MOVLW  02
03102:  SUBWF  00,W
03104:  BZ    31B8
03106:  MOVF   03,W
03108:  BNZ   3112
0310A:  MOVLW  03
0310C:  SUBWF  00,W
0310E:  BTFSC  FD8.2
03110:  BRA    320A
03112:  BRA    325C
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
03114:  MOVLW  BE
03116:  MOVWF  FF6
03118:  MOVLW  05
0311A:  MOVWF  FF7
0311C:  MOVLW  00
0311E:  MOVWF  FF8
03120:  CLRF   1B
03122:  BTFSC  FF2.7
03124:  BSF    1B.7
03126:  BCF    FF2.7
03128:  MOVLW  06
0312A:  MOVLB  A
0312C:  MOVWF  x1C
0312E:  MOVLB  0
03130:  CALL   1024
03134:  BTFSC  1B.7
03136:  BSF    FF2.7
03138:  MOVLW  CA
0313A:  MOVWF  FF6
0313C:  MOVLW  05
0313E:  MOVWF  FF7
03140:  MOVLW  00
03142:  MOVWF  FF8
03144:  CLRF   1B
03146:  BTFSC  FF2.7
03148:  BSF    1B.7
0314A:  BCF    FF2.7
0314C:  CALL   0E4E
03150:  BTFSC  1B.7
03152:  BSF    FF2.7
03154:  MOVLW  0D
03156:  BTFSS  F9E.4
03158:  BRA    3156
0315A:  MOVWF  FAD
0315C:  MOVLW  0A
0315E:  BTFSS  F9E.4
03160:  BRA    315E
03162:  MOVWF  FAD
....................          break; 
03164:  BRA    32AC
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
03166:  MOVLW  D2
03168:  MOVWF  FF6
0316A:  MOVLW  05
0316C:  MOVWF  FF7
0316E:  MOVLW  00
03170:  MOVWF  FF8
03172:  CLRF   1B
03174:  BTFSC  FF2.7
03176:  BSF    1B.7
03178:  BCF    FF2.7
0317A:  MOVLW  09
0317C:  MOVLB  A
0317E:  MOVWF  x1C
03180:  MOVLB  0
03182:  CALL   1024
03186:  BTFSC  1B.7
03188:  BSF    FF2.7
0318A:  MOVLW  E0
0318C:  MOVWF  FF6
0318E:  MOVLW  05
03190:  MOVWF  FF7
03192:  MOVLW  00
03194:  MOVWF  FF8
03196:  CLRF   1B
03198:  BTFSC  FF2.7
0319A:  BSF    1B.7
0319C:  BCF    FF2.7
0319E:  CALL   0E4E
031A2:  BTFSC  1B.7
031A4:  BSF    FF2.7
031A6:  MOVLW  0D
031A8:  BTFSS  F9E.4
031AA:  BRA    31A8
031AC:  MOVWF  FAD
031AE:  MOVLW  0A
031B0:  BTFSS  F9E.4
031B2:  BRA    31B0
031B4:  MOVWF  FAD
....................          break;  
031B6:  BRA    32AC
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
031B8:  MOVLW  E8
031BA:  MOVWF  FF6
031BC:  MOVLW  05
031BE:  MOVWF  FF7
031C0:  MOVLW  00
031C2:  MOVWF  FF8
031C4:  CLRF   1B
031C6:  BTFSC  FF2.7
031C8:  BSF    1B.7
031CA:  BCF    FF2.7
031CC:  MOVLW  06
031CE:  MOVLB  A
031D0:  MOVWF  x1C
031D2:  MOVLB  0
031D4:  CALL   1024
031D8:  BTFSC  1B.7
031DA:  BSF    FF2.7
031DC:  MOVLW  F4
031DE:  MOVWF  FF6
031E0:  MOVLW  05
031E2:  MOVWF  FF7
031E4:  MOVLW  00
031E6:  MOVWF  FF8
031E8:  CLRF   1B
031EA:  BTFSC  FF2.7
031EC:  BSF    1B.7
031EE:  BCF    FF2.7
031F0:  CALL   0E4E
031F4:  BTFSC  1B.7
031F6:  BSF    FF2.7
031F8:  MOVLW  0D
031FA:  BTFSS  F9E.4
031FC:  BRA    31FA
031FE:  MOVWF  FAD
03200:  MOVLW  0A
03202:  BTFSS  F9E.4
03204:  BRA    3202
03206:  MOVWF  FAD
....................          break; 
03208:  BRA    32AC
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
0320A:  MOVLW  FC
0320C:  MOVWF  FF6
0320E:  MOVLW  05
03210:  MOVWF  FF7
03212:  MOVLW  00
03214:  MOVWF  FF8
03216:  CLRF   1B
03218:  BTFSC  FF2.7
0321A:  BSF    1B.7
0321C:  BCF    FF2.7
0321E:  MOVLW  09
03220:  MOVLB  A
03222:  MOVWF  x1C
03224:  MOVLB  0
03226:  CALL   1024
0322A:  BTFSC  1B.7
0322C:  BSF    FF2.7
0322E:  MOVLW  0A
03230:  MOVWF  FF6
03232:  MOVLW  06
03234:  MOVWF  FF7
03236:  MOVLW  00
03238:  MOVWF  FF8
0323A:  CLRF   1B
0323C:  BTFSC  FF2.7
0323E:  BSF    1B.7
03240:  BCF    FF2.7
03242:  CALL   0E4E
03246:  BTFSC  1B.7
03248:  BSF    FF2.7
0324A:  MOVLW  0D
0324C:  BTFSS  F9E.4
0324E:  BRA    324C
03250:  MOVWF  FAD
03252:  MOVLW  0A
03254:  BTFSS  F9E.4
03256:  BRA    3254
03258:  MOVWF  FAD
....................          break;           
0325A:  BRA    32AC
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
0325C:  MOVLW  12
0325E:  MOVWF  FF6
03260:  MOVLW  06
03262:  MOVWF  FF7
03264:  MOVLW  00
03266:  MOVWF  FF8
03268:  CLRF   1B
0326A:  BTFSC  FF2.7
0326C:  BSF    1B.7
0326E:  BCF    FF2.7
03270:  MOVLW  06
03272:  MOVLB  A
03274:  MOVWF  x1C
03276:  MOVLB  0
03278:  CALL   1024
0327C:  BTFSC  1B.7
0327E:  BSF    FF2.7
03280:  MOVLW  1E
03282:  MOVWF  FF6
03284:  MOVLW  06
03286:  MOVWF  FF7
03288:  MOVLW  00
0328A:  MOVWF  FF8
0328C:  CLRF   1B
0328E:  BTFSC  FF2.7
03290:  BSF    1B.7
03292:  BCF    FF2.7
03294:  CALL   0E4E
03298:  BTFSC  1B.7
0329A:  BSF    FF2.7
0329C:  MOVLW  0D
0329E:  BTFSS  F9E.4
032A0:  BRA    329E
032A2:  MOVWF  FAD
032A4:  MOVLW  0A
032A6:  BTFSS  F9E.4
032A8:  BRA    32A6
032AA:  MOVWF  FAD
....................          break; 
....................    } 
032AC:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
172BC:  MOVLW  26
172BE:  MOVWF  FF6
172C0:  MOVLW  06
172C2:  MOVWF  FF7
172C4:  MOVLW  00
172C6:  MOVWF  FF8
172C8:  CLRF   1B
172CA:  BTFSC  FF2.7
172CC:  BSF    1B.7
172CE:  BCF    FF2.7
172D0:  CALL   0E4E
172D4:  BTFSC  1B.7
172D6:  BSF    FF2.7
172D8:  GOTO   17682 (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0AF88:  MOVLW  2E
0AF8A:  MOVWF  FF6
0AF8C:  MOVLW  06
0AF8E:  MOVWF  FF7
0AF90:  MOVLW  00
0AF92:  MOVWF  FF8
0AF94:  CLRF   1B
0AF96:  BTFSC  FF2.7
0AF98:  BSF    1B.7
0AF9A:  BCF    FF2.7
0AF9C:  CALL   0E4E
0AFA0:  BTFSC  1B.7
0AFA2:  BSF    FF2.7
0AFA4:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BC4A:  MOVLW  36
0BC4C:  MOVWF  FF6
0BC4E:  MOVLW  06
0BC50:  MOVWF  FF7
0BC52:  MOVLW  00
0BC54:  MOVWF  FF8
0BC56:  CLRF   1B
0BC58:  BTFSC  FF2.7
0BC5A:  BSF    1B.7
0BC5C:  BCF    FF2.7
0BC5E:  CALL   0E4E
0BC62:  BTFSC  1B.7
0BC64:  BSF    FF2.7
0BC66:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
035F2:  MOVLW  4E
035F4:  MOVWF  FF6
035F6:  MOVLW  06
035F8:  MOVWF  FF7
035FA:  MOVLW  00
035FC:  MOVWF  FF8
035FE:  CLRF   1B
03600:  BTFSC  FF2.7
03602:  BSF    1B.7
03604:  BCF    FF2.7
03606:  CALL   0E4E
0360A:  BTFSC  1B.7
0360C:  BSF    FF2.7
0360E:  GOTO   4364 (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
05014:  MOVLW  56
05016:  MOVWF  FF6
05018:  MOVLW  06
0501A:  MOVWF  FF7
0501C:  MOVLW  00
0501E:  MOVWF  FF8
05020:  CLRF   1B
05022:  BTFSC  FF2.7
05024:  BSF    1B.7
05026:  BCF    FF2.7
05028:  CALL   0E4E
0502C:  BTFSC  1B.7
0502E:  BSF    FF2.7
05030:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
15DB2:  MOVLW  5E
15DB4:  MOVWF  FF6
15DB6:  MOVLW  06
15DB8:  MOVWF  FF7
15DBA:  MOVLW  00
15DBC:  MOVWF  FF8
15DBE:  CLRF   1B
15DC0:  BTFSC  FF2.7
15DC2:  BSF    1B.7
15DC4:  BCF    FF2.7
15DC6:  CALL   0E4E
15DCA:  BTFSC  1B.7
15DCC:  BSF    FF2.7
15DCE:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
*
0ADE0:  DECFSZ 4E,W
0ADE2:  BRA    AE02
0ADE4:  MOVLW  66
0ADE6:  MOVWF  FF6
0ADE8:  MOVLW  06
0ADEA:  MOVWF  FF7
0ADEC:  MOVLW  00
0ADEE:  MOVWF  FF8
0ADF0:  CLRF   1B
0ADF2:  BTFSC  FF2.7
0ADF4:  BSF    1B.7
0ADF6:  BCF    FF2.7
0ADF8:  CALL   0E4E
0ADFC:  BTFSC  1B.7
0ADFE:  BSF    FF2.7
0AE00:  BRA    AE1E
....................    else fprintf(COM_A, "@RDY\r\n"); 
0AE02:  MOVLW  6E
0AE04:  MOVWF  FF6
0AE06:  MOVLW  06
0AE08:  MOVWF  FF7
0AE0A:  MOVLW  00
0AE0C:  MOVWF  FF8
0AE0E:  CLRF   1B
0AE10:  BTFSC  FF2.7
0AE12:  BSF    1B.7
0AE14:  BCF    FF2.7
0AE16:  CALL   0E4E
0AE1A:  BTFSC  1B.7
0AE1C:  BSF    FF2.7
0AE1E:  GOTO   1B290 (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
034DC:  MOVLW  0A
034DE:  MOVLB  A
034E0:  MOVWF  x12
034E2:  MOVLW  09
034E4:  MOVFF  A12,A10
034E8:  MOVWF  x0F
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
034EA:  MOVF   FC9,W
034EC:  SETF   FC9
034EE:  RRCF   FC7,W
034F0:  BNC   34EE
....................    SD_spi_read(sdcmd); 
034F2:  MOVF   FC9,W
034F4:  MOVFF  A08,FC9
034F8:  RRCF   FC7,W
034FA:  BNC   34F8
....................    SD_spi_read(value[3]); 
034FC:  MOVLW  03
034FE:  ADDWF  x0F,W
03500:  MOVWF  FE9
03502:  MOVLW  00
03504:  ADDWFC x10,W
03506:  MOVWF  FEA
03508:  MOVFF  FEF,A11
0350C:  MOVF   FC9,W
0350E:  MOVFF  A11,FC9
03512:  RRCF   FC7,W
03514:  BNC   3512
....................    SD_spi_read(value[2]); 
03516:  MOVLW  02
03518:  ADDWF  x0F,W
0351A:  MOVWF  FE9
0351C:  MOVLW  00
0351E:  ADDWFC x10,W
03520:  MOVWF  FEA
03522:  MOVFF  FEF,A11
03526:  MOVF   FC9,W
03528:  MOVFF  A11,FC9
0352C:  RRCF   FC7,W
0352E:  BNC   352C
....................    SD_spi_read(value[1]); 
03530:  MOVLW  01
03532:  ADDWF  x0F,W
03534:  MOVWF  FE9
03536:  MOVLW  00
03538:  ADDWFC x10,W
0353A:  MOVWF  FEA
0353C:  MOVFF  FEF,A11
03540:  MOVF   FC9,W
03542:  MOVFF  A11,FC9
03546:  RRCF   FC7,W
03548:  BNC   3546
....................    SD_spi_read(value[0]); 
0354A:  MOVFF  A0F,FE9
0354E:  MOVFF  A10,FEA
03552:  MOVFF  FEF,A11
03556:  MOVF   FC9,W
03558:  MOVFF  A11,FC9
0355C:  RRCF   FC7,W
0355E:  BNC   355C
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
03560:  MOVF   x08,W
03562:  SUBLW  48
03564:  BNZ   3572
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
03566:  MOVF   FC9,W
03568:  MOVLW  87
0356A:  MOVWF  FC9
0356C:  RRCF   FC7,W
0356E:  BNC   356C
03570:  BRA    357C
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
03572:  MOVF   FC9,W
03574:  MOVLW  95
03576:  MOVWF  FC9
03578:  RRCF   FC7,W
0357A:  BNC   3578
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
0357C:  CLRF   x0D
....................    response = SD_spi_read(0xFF); 
0357E:  MOVF   FC9,W
03580:  SETF   FC9
03582:  RRCF   FC7,W
03584:  BNC   3582
03586:  MOVFF  FC9,A0E
....................    while ((response == 0xFF) && (i < 100)) 
0358A:  INCFSZ x0E,W
0358C:  BRA    35A4
0358E:  MOVF   x0D,W
03590:  SUBLW  63
03592:  BNC   35A4
....................       { 
....................       i++; 
03594:  INCF   x0D,F
....................       response = SD_spi_read(0xFF); 
03596:  MOVF   FC9,W
03598:  SETF   FC9
0359A:  RRCF   FC7,W
0359C:  BNC   359A
0359E:  MOVFF  FC9,A0E
035A2:  BRA    358A
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
035A4:  MOVFF  A0E,01
035A8:  MOVLB  0
035AA:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
04370:  MOVLW  50
04372:  MOVLB  A
04374:  MOVWF  x08
04376:  MOVFF  A07,A0C
0437A:  MOVFF  A06,A0B
0437E:  MOVFF  A05,A0A
04382:  MOVFF  A04,A09
04386:  MOVLB  0
04388:  CALL   34DC
0438C:  MOVF   01,W
0438E:  BZ    4396
04390:  XORLW  40
04392:  BZ    43AC
04394:  BRA    43B2
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
04396:  MOVFF  A07,4EC
0439A:  MOVFF  A06,4EB
0439E:  MOVFF  A05,4EA
043A2:  MOVFF  A04,4E9
....................          return(TRUE); 
043A6:  MOVLW  01
043A8:  MOVWF  01
043AA:  BRA    43B6
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
043AC:  MOVLW  00
043AE:  MOVWF  01
043B0:  BRA    43B6
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
043B2:  MOVLW  00
043B4:  MOVWF  01
....................       } 
043B6:  GOTO   449A (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
043BA:  MOVF   FC9,W
043BC:  SETF   FC9
043BE:  RRCF   FC7,W
043C0:  BNC   43BE
043C2:  MOVFF  FC9,A0C
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
043C6:  MOVLB  A
043C8:  CLRF   x0B
043CA:  CLRF   x0A
043CC:  MOVF   x0B,W
043CE:  SUBLW  27
043D0:  BNC   43FA
043D2:  BNZ   43DA
043D4:  MOVF   x0A,W
043D6:  SUBLW  0F
043D8:  BNC   43FA
043DA:  INCFSZ x0C,W
043DC:  BRA    43FA
....................       { 
....................       delay_us(10); 
043DE:  MOVLW  35
043E0:  MOVWF  00
043E2:  DECFSZ 00,F
043E4:  BRA    43E2
....................       response = SD_spi_read(0xFF);  
043E6:  MOVF   FC9,W
043E8:  SETF   FC9
043EA:  RRCF   FC7,W
043EC:  BNC   43EA
043EE:  MOVFF  FC9,A0C
043F2:  INCF   x0A,F
043F4:  BTFSC  FD8.2
043F6:  INCF   x0B,F
043F8:  BRA    43CC
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
043FA:  MOVF   x0C,W
043FC:  SUBLW  FE
043FE:  BZ    440E
....................       { 
....................       if (!response) 
04400:  MOVF   x0C,F
04402:  BNZ   4408
....................          response = 0xFE; 
04404:  MOVLW  FE
04406:  MOVWF  x0C
....................       return(response); 
04408:  MOVFF  A0C,01
0440C:  BRA    4464
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
0440E:  CLRF   x0B
04410:  CLRF   x0A
04412:  MOVF   x09,F
04414:  BNZ   4428
04416:  MOVF   x08,F
04418:  BNZ   4428
0441A:  MOVF   x0B,W
0441C:  SUBWF  x07,W
0441E:  BNC   4448
04420:  BNZ   4428
04422:  MOVF   x06,W
04424:  SUBWF  x0A,W
04426:  BC    4448
....................       ptr[i]=SD_spi_read(0xFF); 
04428:  MOVF   x04,W
0442A:  ADDWF  x0A,W
0442C:  MOVWF  FE9
0442E:  MOVF   x05,W
04430:  ADDWFC x0B,W
04432:  MOVWF  FEA
04434:  MOVF   FC9,W
04436:  SETF   FC9
04438:  RRCF   FC7,W
0443A:  BNC   4438
0443C:  MOVFF  FC9,FEF
04440:  INCF   x0A,F
04442:  BTFSC  FD8.2
04444:  INCF   x0B,F
04446:  BRA    4412
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
04448:  MOVF   FC9,W
0444A:  SETF   FC9
0444C:  RRCF   FC7,W
0444E:  BNC   444C
....................    SD_spi_read(0xFF); 
04450:  MOVF   FC9,W
04452:  SETF   FC9
04454:  RRCF   FC7,W
04456:  BNC   4454
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
04458:  MOVF   FC9,W
0445A:  SETF   FC9
0445C:  RRCF   FC7,W
0445E:  BNC   445C
....................    return(0); 
04460:  MOVLW  00
04462:  MOVWF  01
04464:  MOVLB  0
04466:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
057D6:  MOVLW  C3
057D8:  MOVLB  A
057DA:  MOVWF  x0C
057DC:  MOVLW  50
057DE:  MOVWF  x0B
....................    SD_spi_read(0xFF); 
057E0:  MOVF   FC9,W
057E2:  SETF   FC9
057E4:  RRCF   FC7,W
057E6:  BNC   57E4
....................    do 
....................       { 
....................       delay_us(10); 
057E8:  MOVLW  35
057EA:  MOVWF  00
057EC:  DECFSZ 00,F
057EE:  BRA    57EC
....................       response = SD_spi_read(0xFF); 
057F0:  MOVF   FC9,W
057F2:  SETF   FC9
057F4:  RRCF   FC7,W
057F6:  BNC   57F4
057F8:  MOVFF  FC9,A0A
....................       Timer--; 
057FC:  MOVF   x0B,W
057FE:  BTFSC  FD8.2
05800:  DECF   x0C,F
05802:  DECF   x0B,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
05804:  INCFSZ x0A,W
05806:  BRA    580A
05808:  BRA    5810
0580A:  MOVF   x0B,W
0580C:  IORWF  x0C,W
0580E:  BNZ   57E8
....................       ; 
....................  
....................    return (response); 
05810:  MOVFF  A0A,01
05814:  MOVLB  0
05816:  GOTO   5826 (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
0581A:  MOVLW  02
0581C:  MOVLB  A
0581E:  MOVWF  x09
05820:  CLRF   x08
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
05822:  MOVLB  0
05824:  BRA    57D6
05826:  INCFSZ 01,W
05828:  BRA    582C
0582A:  BRA    5832
....................       return (FALSE); 
0582C:  MOVLW  00
0582E:  MOVWF  01
05830:  BRA    58CC
....................  
....................    SD_spi_write(token);               // transmit data token 
05832:  MOVF   FC9,W
05834:  MOVFF  A06,FC9
05838:  RRCF   FC7,W
0583A:  BNC   5838
....................    if (token != 0xFD) 
0583C:  MOVLB  A
0583E:  MOVF   x06,W
05840:  SUBLW  FD
05842:  BZ    58C6
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
05844:  MOVFF  A09,03
05848:  MOVF   x08,W
0584A:  BTFSC  FD8.2
0584C:  DECF   x09,F
0584E:  DECF   x08,F
05850:  IORWF  03,W
05852:  BZ    5876
....................          SD_spi_write(*ptr++); 
05854:  MOVFF  A05,03
05858:  MOVF   x04,W
0585A:  INCF   x04,F
0585C:  BTFSC  FD8.2
0585E:  INCF   x05,F
05860:  MOVWF  FE9
05862:  MOVFF  03,FEA
05866:  MOVFF  FEF,A0A
0586A:  MOVF   FC9,W
0586C:  MOVFF  A0A,FC9
05870:  RRCF   FC7,W
05872:  BNC   5870
05874:  BRA    5844
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
05876:  MOVF   FC9,W
05878:  SETF   FC9
0587A:  RRCF   FC7,W
0587C:  BNC   587A
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
0587E:  MOVF   FC9,W
05880:  SETF   FC9
05882:  RRCF   FC7,W
05884:  BNC   5882
....................       response = SD_spi_read(0xFF);      // Receive data response 
05886:  MOVF   FC9,W
05888:  SETF   FC9
0588A:  RRCF   FC7,W
0588C:  BNC   588A
0588E:  MOVFF  FC9,A07
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
05892:  CLRF   x09
05894:  CLRF   x08
05896:  MOVF   x09,W
05898:  SUBLW  C3
0589A:  BNC   58C6
0589C:  BNZ   58A4
0589E:  MOVF   x08,W
058A0:  SUBLW  4F
058A2:  BNC   58C6
....................          { 
....................          delay_us(10); 
058A4:  MOVLW  35
058A6:  MOVWF  00
058A8:  DECFSZ 00,F
058AA:  BRA    58A8
....................          response = SD_spi_read(0xFF);   // digest prior operation 
058AC:  MOVF   FC9,W
058AE:  SETF   FC9
058B0:  RRCF   FC7,W
058B2:  BNC   58B0
058B4:  MOVFF  FC9,A07
....................          if (response != 0x00) 
058B8:  MOVF   x07,F
058BA:  BZ    58BE
....................             break; 
058BC:  BRA    58C6
058BE:  INCF   x08,F
058C0:  BTFSC  FD8.2
058C2:  INCF   x09,F
058C4:  BRA    5896
....................          } 
....................  
....................       } 
....................    return(TRUE); 
058C6:  MOVLW  01
058C8:  MOVWF  01
058CA:  MOVLB  0
058CC:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
058CE:  MOVLB  4
058D0:  BTFSS  xED.0
058D2:  BRA    58DA
....................       return (RES_NOTRDY); 
058D4:  MOVLW  03
058D6:  MOVWF  01
058D8:  BRA    5A12
....................  
....................    if (Media_Status & STA_PROTECT) 
058DA:  BTFSS  xED.2
058DC:  BRA    58E4
....................       return (RES_WRPRT); 
058DE:  MOVLW  02
058E0:  MOVWF  01
058E2:  BRA    5A12
....................  
....................    if (!SectorCount) 
058E4:  MOVLB  A
058E6:  MOVF   x03,F
058E8:  BNZ   58F4
....................       return (RES_PARERR); 
058EA:  MOVLW  04
058EC:  MOVWF  01
058EE:  MOVLB  4
058F0:  BRA    5A12
058F2:  MOVLB  A
....................  
....................    SelectSD; 
058F4:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
058F6:  MOVLB  4
058F8:  MOVF   xE7,W
058FA:  SUBLW  05
058FC:  BZ    591A
....................       SectorNumber *= 512; 
058FE:  BCF    FD8.0
05900:  MOVFF  A01,A02
05904:  MOVFF  A00,A01
05908:  MOVFF  9FF,A00
0590C:  MOVLB  9
0590E:  CLRF   xFF
05910:  MOVLB  A
05912:  RLCF   x00,F
05914:  RLCF   x01,F
05916:  RLCF   x02,F
05918:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
0591A:  MOVLB  A
0591C:  DECFSZ x03,W
0591E:  BRA    595E
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
05920:  MOVLW  58
05922:  MOVWF  x08
05924:  MOVFF  A02,A0C
05928:  MOVFF  A01,A0B
0592C:  MOVFF  A00,A0A
05930:  MOVFF  9FF,A09
05934:  MOVLB  0
05936:  CALL   34DC
0593A:  MOVF   01,F
0593C:  BNZ   595A
....................          if (SD_write_data(Buffer, 0xFE)) 
0593E:  MOVFF  9FE,A05
05942:  MOVFF  9FD,A04
05946:  MOVLW  FE
05948:  MOVLB  A
0594A:  MOVWF  x06
0594C:  MOVLB  0
0594E:  RCALL  581A
05950:  MOVF   01,F
05952:  BZ    595A
....................             SectorCount = 0; 
05954:  MOVLB  A
05956:  CLRF   x03
05958:  MOVLB  0
....................       } 
0595A:  BRA    59F8
0595C:  MOVLB  A
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
0595E:  MOVLB  4
05960:  MOVF   xE7,W
05962:  ANDLW  03
05964:  BZ    5992
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
05966:  MOVLW  77
05968:  MOVLB  A
0596A:  MOVWF  x08
0596C:  CLRF   x0C
0596E:  CLRF   x0B
05970:  CLRF   x0A
05972:  CLRF   x09
05974:  MOVLB  0
05976:  CALL   34DC
....................          SD_cmd(SD_ACMD23, SectorCount); 
0597A:  MOVLW  57
0597C:  MOVLB  A
0597E:  MOVWF  x08
05980:  CLRF   x0C
05982:  CLRF   x0B
05984:  CLRF   x0A
05986:  MOVFF  A03,A09
0598A:  MOVLB  0
0598C:  CALL   34DC
05990:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
05992:  MOVLW  59
05994:  MOVLB  A
05996:  MOVWF  x08
05998:  MOVFF  A02,A0C
0599C:  MOVFF  A01,A0B
059A0:  MOVFF  A00,A0A
059A4:  MOVFF  9FF,A09
059A8:  MOVLB  0
059AA:  CALL   34DC
059AE:  MOVF   01,F
059B0:  BNZ   59F8
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
059B2:  MOVFF  9FE,A05
059B6:  MOVFF  9FD,A04
059BA:  MOVLW  FC
059BC:  MOVLB  A
059BE:  MOVWF  x06
059C0:  MOVLB  0
059C2:  RCALL  581A
059C4:  MOVF   01,F
059C6:  BNZ   59CA
....................                break; 
059C8:  BRA    59DE
....................             Buffer += 512; 
059CA:  MOVLW  02
059CC:  MOVLB  9
059CE:  ADDWF  xFE,F
....................             } while (--SectorCount); 
059D0:  MOVLB  A
059D2:  DECF   x03,F
059D4:  BTFSC  FD8.2
059D6:  BRA    59DC
059D8:  MOVLB  0
059DA:  BRA    59B2
059DC:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
059DE:  MOVLB  A
059E0:  CLRF   x05
059E2:  CLRF   x04
059E4:  MOVLW  FD
059E6:  MOVWF  x06
059E8:  MOVLB  0
059EA:  RCALL  581A
059EC:  MOVF   01,F
059EE:  BNZ   59F8
....................             SectorCount = 1; 
059F0:  MOVLW  01
059F2:  MOVLB  A
059F4:  MOVWF  x03
059F6:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
059F8:  BSF    F91.1
....................    SD_spi_read(0xFF); 
059FA:  MOVF   FC9,W
059FC:  SETF   FC9
059FE:  RRCF   FC7,W
05A00:  BNC   59FE
....................    return SectorCount ? RES_ERROR : RES_OK; 
05A02:  MOVLB  A
05A04:  MOVF   x03,F
05A06:  BZ    5A0C
05A08:  MOVLW  01
05A0A:  BRA    5A0E
05A0C:  MOVLW  00
05A0E:  MOVWF  01
05A10:  MOVLB  4
05A12:  MOVLB  0
05A14:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
04468:  MOVLB  4
0446A:  BTFSS  xED.0
0446C:  BRA    4474
....................       return (RES_NOTRDY); 
0446E:  MOVLW  03
04470:  MOVWF  01
04472:  BRA    45A8
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
04474:  MOVLB  A
04476:  MOVF   x03,W
04478:  SUBLW  01
0447A:  BNC   4480
0447C:  MOVF   x03,F
0447E:  BNZ   448A
....................       return(RES_PARERR); 
04480:  MOVLW  04
04482:  MOVWF  01
04484:  MOVLB  4
04486:  BRA    45A8
04488:  MOVLB  A
....................  
....................    SelectSD; 
0448A:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
0448C:  CLRF   x07
0448E:  CLRF   x06
04490:  MOVLW  02
04492:  MOVWF  x05
04494:  CLRF   x04
04496:  MOVLB  0
04498:  BRA    4370
0449A:  MOVF   01,F
0449C:  BNZ   44AA
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
0449E:  BSF    F91.1
....................       return(RES_ERROR); 
044A0:  MOVLW  01
044A2:  MOVWF  01
044A4:  MOVLB  4
044A6:  BRA    45A8
044A8:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
044AA:  MOVLB  4
044AC:  MOVF   xE7,W
044AE:  SUBLW  05
044B0:  BZ    44CE
....................       SectorNumber *= 512; 
044B2:  BCF    FD8.0
044B4:  MOVFF  A01,A02
044B8:  MOVFF  A00,A01
044BC:  MOVFF  9FF,A00
044C0:  MOVLB  9
044C2:  CLRF   xFF
044C4:  MOVLB  A
044C6:  RLCF   x00,F
044C8:  RLCF   x01,F
044CA:  RLCF   x02,F
044CC:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
044CE:  MOVLB  A
044D0:  DECFSZ x03,W
044D2:  BRA    452A
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
044D4:  MOVLW  51
044D6:  MOVWF  x08
044D8:  MOVFF  A02,A0C
044DC:  MOVFF  A01,A0B
044E0:  MOVFF  A00,A0A
044E4:  MOVFF  9FF,A09
044E8:  MOVLB  0
044EA:  CALL   34DC
044EE:  MOVF   01,F
044F0:  BZ    44FE
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
044F2:  BSF    F91.1
....................          return(RES_PARERR); 
044F4:  MOVLW  04
044F6:  MOVWF  01
044F8:  MOVLB  4
044FA:  BRA    45A8
044FC:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
044FE:  MOVFF  9FE,A05
04502:  MOVFF  9FD,A04
04506:  MOVLB  A
04508:  CLRF   x09
0450A:  CLRF   x08
0450C:  MOVLW  02
0450E:  MOVWF  x07
04510:  CLRF   x06
04512:  MOVLB  0
04514:  RCALL  43BA
04516:  MOVF   01,F
04518:  BZ    4526
....................          { 
....................          DeselectSD; 
0451A:  BSF    F91.1
....................          return(RES_ERROR); 
0451C:  MOVLW  01
0451E:  MOVWF  01
04520:  MOVLB  4
04522:  BRA    45A8
04524:  MOVLB  0
....................          } 
....................       } 
04526:  BRA    45A0
04528:  MOVLB  A
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
0452A:  MOVLW  52
0452C:  MOVWF  x08
0452E:  MOVFF  A02,A0C
04532:  MOVFF  A01,A0B
04536:  MOVFF  A00,A0A
0453A:  MOVFF  9FF,A09
0453E:  MOVLB  0
04540:  CALL   34DC
04544:  MOVF   01,F
04546:  BZ    4554
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
04548:  BSF    F91.1
....................          return(RES_PARERR); 
0454A:  MOVLW  04
0454C:  MOVWF  01
0454E:  MOVLB  4
04550:  BRA    45A8
04552:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
04554:  MOVFF  9FE,A05
04558:  MOVFF  9FD,A04
0455C:  MOVLB  A
0455E:  CLRF   x09
04560:  CLRF   x08
04562:  MOVLW  02
04564:  MOVWF  x07
04566:  CLRF   x06
04568:  MOVLB  0
0456A:  RCALL  43BA
0456C:  MOVF   01,F
0456E:  BZ    457C
....................             { 
....................             DeselectSD; 
04570:  BSF    F91.1
....................             return(RES_ERROR); 
04572:  MOVLW  01
04574:  MOVWF  01
04576:  MOVLB  4
04578:  BRA    45A8
0457A:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
0457C:  MOVLW  02
0457E:  MOVLB  9
04580:  ADDWF  xFE,F
....................          } while (--SectorCount); 
04582:  MOVLB  A
04584:  DECF   x03,F
04586:  BTFSC  FD8.2
04588:  BRA    458E
0458A:  MOVLB  0
0458C:  BRA    4554
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
0458E:  MOVLW  4C
04590:  MOVWF  x08
04592:  CLRF   x0C
04594:  CLRF   x0B
04596:  CLRF   x0A
04598:  CLRF   x09
0459A:  MOVLB  0
0459C:  CALL   34DC
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
045A0:  BSF    F91.1
....................    return(RES_OK); 
045A2:  MOVLW  00
045A4:  MOVWF  01
045A6:  MOVLB  4
045A8:  MOVLB  0
045AA:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
0552E:  MOVLB  4
05530:  BCF    xED.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
05532:  BCF    xED.2
....................  
....................    return(Media_Status); 
05534:  MOVFF  4ED,01
05538:  MOVLB  0
0553A:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
03612:  MOVLB  9
03614:  CLRF   xCC
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
03616:  MOVLB  4
03618:  CLRF   xE7
....................  
....................    DeselectSD; 
0361A:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
0361C:  MOVLW  0A
0361E:  MOVLB  9
03620:  MOVWF  xCD
03622:  MOVLB  0
03624:  CALL   28AC
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
03628:  BCF    FC6.5
0362A:  MOVLW  22
0362C:  MOVWF  FC6
0362E:  MOVLW  40
03630:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
03632:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
03634:  MOVLB  9
03636:  CLRF   xC4
03638:  MOVF   xC4,W
0363A:  SUBLW  09
0363C:  BNC   364A
....................       SD_spi_read(0xFF); 
0363E:  MOVF   FC9,W
03640:  SETF   FC9
03642:  RRCF   FC7,W
03644:  BNC   3642
03646:  INCF   xC4,F
03648:  BRA    3638
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
0364A:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
0364C:  MOVF   1F,W
0364E:  SUBLW  04
03650:  BNZ   3676
03652:  MOVF   20,F
03654:  BNZ   3676
03656:  MOVLW  76
03658:  MOVWF  FF6
0365A:  MOVLW  06
0365C:  MOVWF  FF7
0365E:  MOVLW  00
03660:  MOVWF  FF8
03662:  CLRF   1B
03664:  BTFSC  FF2.7
03666:  BSF    1B.7
03668:  BCF    FF2.7
0366A:  MOVLB  0
0366C:  CALL   0E4E
03670:  BTFSC  1B.7
03672:  BSF    FF2.7
03674:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
03676:  MOVLW  40
03678:  MOVLB  A
0367A:  MOVWF  x08
0367C:  CLRF   x0C
0367E:  CLRF   x0B
03680:  CLRF   x0A
03682:  CLRF   x09
03684:  MOVLB  0
03686:  RCALL  34DC
03688:  MOVFF  01,9C5
....................    if (response > 1 ) 
0368C:  MOVLB  9
0368E:  MOVF   xC5,W
03690:  SUBLW  01
03692:  BC    36E8
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
03694:  MOVF   1F,W
03696:  SUBLW  04
03698:  BNZ   36E2
0369A:  MOVF   20,F
0369C:  BNZ   36E2
0369E:  MOVLW  86
036A0:  MOVWF  FF6
036A2:  MOVLW  06
036A4:  MOVWF  FF7
036A6:  MOVLW  00
036A8:  MOVWF  FF8
036AA:  CLRF   1B
036AC:  BTFSC  FF2.7
036AE:  BSF    1B.7
036B0:  BCF    FF2.7
036B2:  MOVLW  31
036B4:  MOVLB  A
036B6:  MOVWF  x1C
036B8:  MOVLB  0
036BA:  CALL   1024
036BE:  BTFSC  1B.7
036C0:  BSF    FF2.7
036C2:  MOVFF  9C5,9CD
036C6:  MOVLW  57
036C8:  MOVLB  9
036CA:  MOVWF  xCE
036CC:  MOVLB  0
036CE:  RCALL  35AC
036D0:  MOVLW  0D
036D2:  BTFSS  F9E.4
036D4:  BRA    36D2
036D6:  MOVWF  FAD
036D8:  MOVLW  0A
036DA:  BTFSS  F9E.4
036DC:  BRA    36DA
036DE:  MOVWF  FAD
036E0:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
036E2:  BSF    xCC.0
....................       goto Exit_disk_initialize; 
036E4:  GOTO   4366
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
036E8:  MOVF   1F,W
036EA:  SUBLW  04
036EC:  BNZ   3736
036EE:  MOVF   20,F
036F0:  BNZ   3736
036F2:  MOVLW  BE
036F4:  MOVWF  FF6
036F6:  MOVLW  06
036F8:  MOVWF  FF7
036FA:  MOVLW  00
036FC:  MOVWF  FF8
036FE:  CLRF   1B
03700:  BTFSC  FF2.7
03702:  BSF    1B.7
03704:  BCF    FF2.7
03706:  MOVLW  1A
03708:  MOVLB  A
0370A:  MOVWF  x1C
0370C:  MOVLB  0
0370E:  CALL   1024
03712:  BTFSC  1B.7
03714:  BSF    FF2.7
03716:  MOVFF  9C5,9CD
0371A:  MOVLW  57
0371C:  MOVLB  9
0371E:  MOVWF  xCE
03720:  MOVLB  0
03722:  RCALL  35AC
03724:  MOVLW  0D
03726:  BTFSS  F9E.4
03728:  BRA    3726
0372A:  MOVWF  FAD
0372C:  MOVLW  0A
0372E:  BTFSS  F9E.4
03730:  BRA    372E
03732:  MOVWF  FAD
03734:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
03736:  MOVLW  48
03738:  MOVLB  A
0373A:  MOVWF  x08
0373C:  CLRF   x0C
0373E:  CLRF   x0B
03740:  MOVLW  01
03742:  MOVWF  x0A
03744:  MOVLW  AA
03746:  MOVWF  x09
03748:  MOVLB  0
0374A:  RCALL  34DC
0374C:  MOVFF  01,9C5
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
03750:  MOVF   1F,W
03752:  SUBLW  04
03754:  BNZ   379C
03756:  MOVF   20,F
03758:  BNZ   379C
0375A:  MOVLW  E0
0375C:  MOVWF  FF6
0375E:  MOVLW  06
03760:  MOVWF  FF7
03762:  MOVLW  00
03764:  MOVWF  FF8
03766:  CLRF   1B
03768:  BTFSC  FF2.7
0376A:  BSF    1B.7
0376C:  BCF    FF2.7
0376E:  MOVLW  25
03770:  MOVLB  A
03772:  MOVWF  x1C
03774:  MOVLB  0
03776:  CALL   1024
0377A:  BTFSC  1B.7
0377C:  BSF    FF2.7
0377E:  MOVFF  9C5,9CD
03782:  MOVLW  57
03784:  MOVLB  9
03786:  MOVWF  xCE
03788:  MOVLB  0
0378A:  RCALL  35AC
0378C:  MOVLW  0D
0378E:  BTFSS  F9E.4
03790:  BRA    378E
03792:  MOVWF  FAD
03794:  MOVLW  0A
03796:  BTFSS  F9E.4
03798:  BRA    3796
0379A:  MOVWF  FAD
....................    if (response == 1)  
0379C:  MOVLB  9
0379E:  DECFSZ xC5,W
037A0:  BRA    3B72
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
037A2:  MOVF   1F,W
037A4:  SUBLW  04
037A6:  BNZ   37CC
037A8:  MOVF   20,F
037AA:  BNZ   37CC
037AC:  MOVLW  0A
037AE:  MOVWF  FF6
037B0:  MOVLW  07
037B2:  MOVWF  FF7
037B4:  MOVLW  00
037B6:  MOVWF  FF8
037B8:  CLRF   1B
037BA:  BTFSC  FF2.7
037BC:  BSF    1B.7
037BE:  BCF    FF2.7
037C0:  MOVLB  0
037C2:  CALL   0E4E
037C6:  BTFSC  1B.7
037C8:  BSF    FF2.7
037CA:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
037CC:  CLRF   xC4
037CE:  MOVF   xC4,W
037D0:  SUBLW  03
037D2:  BNC   37F2
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
037D4:  CLRF   03
037D6:  MOVF   xC4,W
037D8:  ADDLW  C6
037DA:  MOVWF  FE9
037DC:  MOVLW  09
037DE:  ADDWFC 03,W
037E0:  MOVWF  FEA
037E2:  MOVF   FC9,W
037E4:  SETF   FC9
037E6:  RRCF   FC7,W
037E8:  BNC   37E6
037EA:  MOVFF  FC9,FEF
037EE:  INCF   xC4,F
037F0:  BRA    37CE
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
037F2:  MOVF   1F,W
037F4:  SUBLW  04
037F6:  BNZ   386A
037F8:  MOVF   20,F
037FA:  BNZ   386A
037FC:  MOVLW  2C
037FE:  MOVWF  FF6
03800:  MOVLW  07
03802:  MOVWF  FF7
03804:  MOVLW  00
03806:  MOVWF  FF8
03808:  CLRF   1B
0380A:  BTFSC  FF2.7
0380C:  BSF    1B.7
0380E:  BCF    FF2.7
03810:  MOVLW  1F
03812:  MOVLB  A
03814:  MOVWF  x1C
03816:  MOVLB  0
03818:  CALL   1024
0381C:  BTFSC  1B.7
0381E:  BSF    FF2.7
03820:  MOVFF  9C6,9CD
03824:  MOVLW  57
03826:  MOVLB  9
03828:  MOVWF  xCE
0382A:  MOVLB  0
0382C:  RCALL  35AC
0382E:  MOVFF  9C7,9CD
03832:  MOVLW  57
03834:  MOVLB  9
03836:  MOVWF  xCE
03838:  MOVLB  0
0383A:  RCALL  35AC
0383C:  MOVFF  9C8,9CD
03840:  MOVLW  57
03842:  MOVLB  9
03844:  MOVWF  xCE
03846:  MOVLB  0
03848:  RCALL  35AC
0384A:  MOVFF  9C9,9CD
0384E:  MOVLW  57
03850:  MOVLB  9
03852:  MOVWF  xCE
03854:  MOVLB  0
03856:  RCALL  35AC
03858:  MOVLW  0D
0385A:  BTFSS  F9E.4
0385C:  BRA    385A
0385E:  MOVWF  FAD
03860:  MOVLW  0A
03862:  BTFSS  F9E.4
03864:  BRA    3862
03866:  MOVWF  FAD
03868:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
0386A:  DECFSZ xC8,W
0386C:  BRA    3B48
0386E:  MOVF   xC9,W
03870:  SUBLW  AA
03872:  BTFSS  FD8.2
03874:  BRA    3B48
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
03876:  MOVF   1F,W
03878:  SUBLW  04
0387A:  BNZ   38A0
0387C:  MOVF   20,F
0387E:  BNZ   38A0
03880:  MOVLW  5E
03882:  MOVWF  FF6
03884:  MOVLW  07
03886:  MOVWF  FF7
03888:  MOVLW  00
0388A:  MOVWF  FF8
0388C:  CLRF   1B
0388E:  BTFSC  FF2.7
03890:  BSF    1B.7
03892:  BCF    FF2.7
03894:  MOVLB  0
03896:  CALL   0E4E
0389A:  BTFSC  1B.7
0389C:  BSF    FF2.7
0389E:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
038A0:  MOVF   1F,W
038A2:  SUBLW  04
038A4:  BNZ   38CA
038A6:  MOVF   20,F
038A8:  BNZ   38CA
038AA:  MOVLW  84
038AC:  MOVWF  FF6
038AE:  MOVLW  07
038B0:  MOVWF  FF7
038B2:  MOVLW  00
038B4:  MOVWF  FF8
038B6:  CLRF   1B
038B8:  BTFSC  FF2.7
038BA:  BSF    1B.7
038BC:  BCF    FF2.7
038BE:  MOVLB  0
038C0:  CALL   0E4E
038C4:  BTFSC  1B.7
038C6:  BSF    FF2.7
038C8:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
038CA:  CLRF   xCB
038CC:  CLRF   xCA
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
038CE:  MOVLW  77
038D0:  MOVLB  A
038D2:  MOVWF  x08
038D4:  CLRF   x0C
038D6:  CLRF   x0B
038D8:  CLRF   x0A
038DA:  CLRF   x09
038DC:  MOVLB  0
038DE:  RCALL  34DC
038E0:  MOVFF  01,9C5
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
038E4:  MOVLW  69
038E6:  MOVLB  A
038E8:  MOVWF  x08
038EA:  MOVLW  40
038EC:  MOVWF  x0C
038EE:  CLRF   x0B
038F0:  CLRF   x0A
038F2:  CLRF   x09
038F4:  MOVLB  0
038F6:  RCALL  34DC
038F8:  MOVFF  01,9C5
....................          while (response && (Timer < 50000)) 
038FC:  MOVLB  9
038FE:  MOVF   xC5,F
03900:  BZ    3952
03902:  MOVF   xCB,W
03904:  SUBLW  C3
03906:  BNC   3952
03908:  BNZ   3910
0390A:  MOVF   xCA,W
0390C:  SUBLW  4F
0390E:  BNC   3952
....................          { 
....................             delay_us(20); 
03910:  MOVLW  6A
03912:  MOVWF  00
03914:  DECFSZ 00,F
03916:  BRA    3914
03918:  NOP   
....................             Timer++; 
0391A:  INCF   xCA,F
0391C:  BTFSC  FD8.2
0391E:  INCF   xCB,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
03920:  MOVLW  77
03922:  MOVLB  A
03924:  MOVWF  x08
03926:  CLRF   x0C
03928:  CLRF   x0B
0392A:  CLRF   x0A
0392C:  CLRF   x09
0392E:  MOVLB  0
03930:  RCALL  34DC
03932:  MOVFF  01,9C5
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
03936:  MOVLW  69
03938:  MOVLB  A
0393A:  MOVWF  x08
0393C:  MOVLW  40
0393E:  MOVWF  x0C
03940:  CLRF   x0B
03942:  CLRF   x0A
03944:  CLRF   x09
03946:  MOVLB  0
03948:  RCALL  34DC
0394A:  MOVFF  01,9C5
0394E:  BRA    38FC
03950:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
03952:  MOVF   1F,W
03954:  SUBLW  04
03956:  BNZ   39E0
03958:  MOVF   20,F
0395A:  BNZ   39E0
0395C:  MOVLW  B2
0395E:  MOVWF  FF6
03960:  MOVLW  07
03962:  MOVWF  FF7
03964:  MOVLW  00
03966:  MOVWF  FF8
03968:  CLRF   1B
0396A:  BTFSC  FF2.7
0396C:  BSF    1B.7
0396E:  BCF    FF2.7
03970:  MOVLW  23
03972:  MOVLB  A
03974:  MOVWF  x1C
03976:  MOVLB  0
03978:  CALL   1024
0397C:  BTFSC  1B.7
0397E:  BSF    FF2.7
03980:  MOVFF  9C5,9CD
03984:  MOVLW  57
03986:  MOVLB  9
03988:  MOVWF  xCE
0398A:  MOVLB  0
0398C:  RCALL  35AC
0398E:  MOVLW  D9
03990:  MOVWF  FF6
03992:  MOVLW  07
03994:  MOVWF  FF7
03996:  MOVLW  00
03998:  MOVWF  FF8
0399A:  CLRF   1B
0399C:  BTFSC  FF2.7
0399E:  BSF    1B.7
039A0:  BCF    FF2.7
039A2:  MOVLW  0A
039A4:  MOVLB  A
039A6:  MOVWF  x1C
039A8:  MOVLB  0
039AA:  CALL   1024
039AE:  BTFSC  1B.7
039B0:  BSF    FF2.7
039B2:  MOVLW  10
039B4:  MOVWF  FE9
039B6:  CLRF   1B
039B8:  BTFSC  FF2.7
039BA:  BSF    1B.7
039BC:  BCF    FF2.7
039BE:  MOVFF  9CB,A1D
039C2:  MOVFF  9CA,A1C
039C6:  CALL   11A6
039CA:  BTFSC  1B.7
039CC:  BSF    FF2.7
039CE:  MOVLW  0D
039D0:  BTFSS  F9E.4
039D2:  BRA    39D0
039D4:  MOVWF  FAD
039D6:  MOVLW  0A
039D8:  BTFSS  F9E.4
039DA:  BRA    39D8
039DC:  MOVWF  FAD
039DE:  MOVLB  9
....................          if (!response) 
039E0:  MOVF   xC5,F
039E2:  BTFSS  FD8.2
039E4:  BRA    3B46
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
039E6:  MOVLW  7A
039E8:  MOVLB  A
039EA:  MOVWF  x08
039EC:  MOVLW  40
039EE:  MOVWF  x0C
039F0:  CLRF   x0B
039F2:  CLRF   x0A
039F4:  CLRF   x09
039F6:  MOVLB  0
039F8:  RCALL  34DC
039FA:  MOVFF  01,9C5
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
039FE:  MOVF   1F,W
03A00:  SUBLW  04
03A02:  BNZ   3A4A
03A04:  MOVF   20,F
03A06:  BNZ   3A4A
03A08:  MOVLW  EA
03A0A:  MOVWF  FF6
03A0C:  MOVLW  07
03A0E:  MOVWF  FF7
03A10:  MOVLW  00
03A12:  MOVWF  FF8
03A14:  CLRF   1B
03A16:  BTFSC  FF2.7
03A18:  BSF    1B.7
03A1A:  BCF    FF2.7
03A1C:  MOVLW  18
03A1E:  MOVLB  A
03A20:  MOVWF  x1C
03A22:  MOVLB  0
03A24:  CALL   1024
03A28:  BTFSC  1B.7
03A2A:  BSF    FF2.7
03A2C:  MOVFF  9C5,9CD
03A30:  MOVLW  57
03A32:  MOVLB  9
03A34:  MOVWF  xCE
03A36:  MOVLB  0
03A38:  RCALL  35AC
03A3A:  MOVLW  0D
03A3C:  BTFSS  F9E.4
03A3E:  BRA    3A3C
03A40:  MOVWF  FAD
03A42:  MOVLW  0A
03A44:  BTFSS  F9E.4
03A46:  BRA    3A44
03A48:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03A4A:  MOVLB  9
03A4C:  MOVF   xC5,F
03A4E:  BTFSS  FD8.2
03A50:  BRA    3B46
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03A52:  CLRF   xC4
03A54:  MOVF   xC4,W
03A56:  SUBLW  03
03A58:  BNC   3A78
....................                   ocr[i] = SD_spi_read(0xFF); 
03A5A:  CLRF   03
03A5C:  MOVF   xC4,W
03A5E:  ADDLW  C6
03A60:  MOVWF  FE9
03A62:  MOVLW  09
03A64:  ADDWFC 03,W
03A66:  MOVWF  FEA
03A68:  MOVF   FC9,W
03A6A:  SETF   FC9
03A6C:  RRCF   FC7,W
03A6E:  BNC   3A6C
03A70:  MOVFF  FC9,FEF
03A74:  INCF   xC4,F
03A76:  BRA    3A54
....................                if (ocr[0] & 0x40) 
03A78:  BTFSS  xC6.6
03A7A:  BRA    3A86
....................                   Card = SDHC; 
03A7C:  MOVLW  05
03A7E:  MOVLB  4
03A80:  MOVWF  xE7
03A82:  BRA    3A8C
03A84:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03A86:  MOVLW  04
03A88:  MOVLB  4
03A8A:  MOVWF  xE7
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03A8C:  MOVF   1F,W
03A8E:  SUBLW  04
03A90:  BNZ   3B44
03A92:  MOVF   20,F
03A94:  BNZ   3B44
03A96:  MOVLW  08
03A98:  MOVWF  FF6
03A9A:  MOVLW  08
03A9C:  MOVWF  FF7
03A9E:  MOVLW  00
03AA0:  MOVWF  FF8
03AA2:  CLRF   1B
03AA4:  BTFSC  FF2.7
03AA6:  BSF    1B.7
03AA8:  BCF    FF2.7
03AAA:  MOVLW  1F
03AAC:  MOVLB  A
03AAE:  MOVWF  x1C
03AB0:  MOVLB  0
03AB2:  CALL   1024
03AB6:  BTFSC  1B.7
03AB8:  BSF    FF2.7
03ABA:  MOVLW  10
03ABC:  MOVWF  FE9
03ABE:  CLRF   1B
03AC0:  BTFSC  FF2.7
03AC2:  BSF    1B.7
03AC4:  BCF    FF2.7
03AC6:  MOVFF  9CB,A1D
03ACA:  MOVFF  9CA,A1C
03ACE:  CALL   11A6
03AD2:  BTFSC  1B.7
03AD4:  BSF    FF2.7
03AD6:  MOVLW  2A
03AD8:  MOVWF  FF6
03ADA:  MOVLW  08
03ADC:  MOVWF  FF7
03ADE:  MOVLW  00
03AE0:  MOVWF  FF8
03AE2:  CLRF   1B
03AE4:  BTFSC  FF2.7
03AE6:  BSF    1B.7
03AE8:  BCF    FF2.7
03AEA:  MOVLW  08
03AEC:  MOVLB  A
03AEE:  MOVWF  x1C
03AF0:  MOVLB  0
03AF2:  CALL   1024
03AF6:  BTFSC  1B.7
03AF8:  BSF    FF2.7
03AFA:  MOVFF  9C6,9CD
03AFE:  MOVLW  57
03B00:  MOVLB  9
03B02:  MOVWF  xCE
03B04:  MOVLB  0
03B06:  RCALL  35AC
03B08:  MOVFF  9C7,9CD
03B0C:  MOVLW  57
03B0E:  MOVLB  9
03B10:  MOVWF  xCE
03B12:  MOVLB  0
03B14:  RCALL  35AC
03B16:  MOVFF  9C8,9CD
03B1A:  MOVLW  57
03B1C:  MOVLB  9
03B1E:  MOVWF  xCE
03B20:  MOVLB  0
03B22:  RCALL  35AC
03B24:  MOVFF  9C9,9CD
03B28:  MOVLW  57
03B2A:  MOVLB  9
03B2C:  MOVWF  xCE
03B2E:  MOVLB  0
03B30:  RCALL  35AC
03B32:  MOVLW  0D
03B34:  BTFSS  F9E.4
03B36:  BRA    3B34
03B38:  MOVWF  FAD
03B3A:  MOVLW  0A
03B3C:  BTFSS  F9E.4
03B3E:  BRA    3B3C
03B40:  MOVWF  FAD
03B42:  MOVLB  4
03B44:  MOVLB  9
....................             } 
....................          } 
....................       } 
03B46:  BRA    3B72
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03B48:  MOVF   1F,W
03B4A:  SUBLW  04
03B4C:  BNZ   3B72
03B4E:  MOVF   20,F
03B50:  BNZ   3B72
03B52:  MOVLW  46
03B54:  MOVWF  FF6
03B56:  MOVLW  08
03B58:  MOVWF  FF7
03B5A:  MOVLW  00
03B5C:  MOVWF  FF8
03B5E:  CLRF   1B
03B60:  BTFSC  FF2.7
03B62:  BSF    1B.7
03B64:  BCF    FF2.7
03B66:  MOVLB  0
03B68:  CALL   0E4E
03B6C:  BTFSC  1B.7
03B6E:  BSF    FF2.7
03B70:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03B72:  MOVLB  4
03B74:  MOVF   xE7,F
03B76:  BTFSS  FD8.2
03B78:  BRA    4048
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03B7A:  MOVF   1F,W
03B7C:  SUBLW  04
03B7E:  BNZ   3BA4
03B80:  MOVF   20,F
03B82:  BNZ   3BA4
03B84:  MOVLW  78
03B86:  MOVWF  FF6
03B88:  MOVLW  08
03B8A:  MOVWF  FF7
03B8C:  MOVLW  00
03B8E:  MOVWF  FF8
03B90:  CLRF   1B
03B92:  BTFSC  FF2.7
03B94:  BSF    1B.7
03B96:  BCF    FF2.7
03B98:  MOVLB  0
03B9A:  CALL   0E4E
03B9E:  BTFSC  1B.7
03BA0:  BSF    FF2.7
03BA2:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03BA4:  MOVLW  40
03BA6:  MOVLB  A
03BA8:  MOVWF  x08
03BAA:  CLRF   x0C
03BAC:  CLRF   x0B
03BAE:  CLRF   x0A
03BB0:  CLRF   x09
03BB2:  MOVLB  0
03BB4:  RCALL  34DC
03BB6:  MOVFF  01,9C5
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03BBA:  MOVF   1F,W
03BBC:  SUBLW  04
03BBE:  BNZ   3C06
03BC0:  MOVF   20,F
03BC2:  BNZ   3C06
03BC4:  MOVLW  B8
03BC6:  MOVWF  FF6
03BC8:  MOVLW  08
03BCA:  MOVWF  FF7
03BCC:  MOVLW  00
03BCE:  MOVWF  FF8
03BD0:  CLRF   1B
03BD2:  BTFSC  FF2.7
03BD4:  BSF    1B.7
03BD6:  BCF    FF2.7
03BD8:  MOVLW  1C
03BDA:  MOVLB  A
03BDC:  MOVWF  x1C
03BDE:  MOVLB  0
03BE0:  CALL   1024
03BE4:  BTFSC  1B.7
03BE6:  BSF    FF2.7
03BE8:  MOVFF  9C5,9CD
03BEC:  MOVLW  57
03BEE:  MOVLB  9
03BF0:  MOVWF  xCE
03BF2:  MOVLB  0
03BF4:  RCALL  35AC
03BF6:  MOVLW  0D
03BF8:  BTFSS  F9E.4
03BFA:  BRA    3BF8
03BFC:  MOVWF  FAD
03BFE:  MOVLW  0A
03C00:  BTFSS  F9E.4
03C02:  BRA    3C00
03C04:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03C06:  MOVLB  9
03C08:  DECFSZ xC5,W
03C0A:  BRA    3C0E
03C0C:  BRA    3C18
03C0E:  MOVF   xC5,F
03C10:  BZ    3C18
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03C12:  BSF    xCC.0
....................          goto Exit_disk_initialize; 
03C14:  GOTO   4366
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03C18:  CLRF   xCB
03C1A:  CLRF   xCA
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03C1C:  MOVLW  41
03C1E:  MOVLB  A
03C20:  MOVWF  x08
03C22:  CLRF   x0C
03C24:  CLRF   x0B
03C26:  CLRF   x0A
03C28:  CLRF   x09
03C2A:  MOVLB  0
03C2C:  RCALL  34DC
03C2E:  MOVFF  01,9C5
....................          if (response != 0x00 ) 
03C32:  MOVLB  9
03C34:  MOVF   xC5,F
03C36:  BZ    3C40
....................             delay_us(10); 
03C38:  MOVLW  35
03C3A:  MOVWF  00
03C3C:  DECFSZ 00,F
03C3E:  BRA    3C3C
....................          Timer++; 
03C40:  INCF   xCA,F
03C42:  BTFSC  FD8.2
03C44:  INCF   xCB,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03C46:  MOVF   xC5,F
03C48:  BZ    3C58
03C4A:  MOVF   xCB,W
03C4C:  SUBLW  C3
03C4E:  BNC   3C58
03C50:  BNZ   3C1C
03C52:  MOVF   xCA,W
03C54:  SUBLW  4F
03C56:  BC    3C1C
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03C58:  MOVF   1F,W
03C5A:  SUBLW  04
03C5C:  BNZ   3CE6
03C5E:  MOVF   20,F
03C60:  BNZ   3CE6
03C62:  MOVLW  DC
03C64:  MOVWF  FF6
03C66:  MOVLW  08
03C68:  MOVWF  FF7
03C6A:  MOVLW  00
03C6C:  MOVWF  FF8
03C6E:  CLRF   1B
03C70:  BTFSC  FF2.7
03C72:  BSF    1B.7
03C74:  BCF    FF2.7
03C76:  MOVLW  28
03C78:  MOVLB  A
03C7A:  MOVWF  x1C
03C7C:  MOVLB  0
03C7E:  CALL   1024
03C82:  BTFSC  1B.7
03C84:  BSF    FF2.7
03C86:  MOVFF  9C5,9CD
03C8A:  MOVLW  57
03C8C:  MOVLB  9
03C8E:  MOVWF  xCE
03C90:  MOVLB  0
03C92:  RCALL  35AC
03C94:  MOVLW  08
03C96:  MOVWF  FF6
03C98:  MOVLW  09
03C9A:  MOVWF  FF7
03C9C:  MOVLW  00
03C9E:  MOVWF  FF8
03CA0:  CLRF   1B
03CA2:  BTFSC  FF2.7
03CA4:  BSF    1B.7
03CA6:  BCF    FF2.7
03CA8:  MOVLW  0A
03CAA:  MOVLB  A
03CAC:  MOVWF  x1C
03CAE:  MOVLB  0
03CB0:  CALL   1024
03CB4:  BTFSC  1B.7
03CB6:  BSF    FF2.7
03CB8:  MOVLW  10
03CBA:  MOVWF  FE9
03CBC:  CLRF   1B
03CBE:  BTFSC  FF2.7
03CC0:  BSF    1B.7
03CC2:  BCF    FF2.7
03CC4:  MOVFF  9CB,A1D
03CC8:  MOVFF  9CA,A1C
03CCC:  CALL   11A6
03CD0:  BTFSC  1B.7
03CD2:  BSF    FF2.7
03CD4:  MOVLW  0D
03CD6:  BTFSS  F9E.4
03CD8:  BRA    3CD6
03CDA:  MOVWF  FAD
03CDC:  MOVLW  0A
03CDE:  BTFSS  F9E.4
03CE0:  BRA    3CDE
03CE2:  MOVWF  FAD
03CE4:  MOVLB  9
....................       if(response) 
03CE6:  MOVF   xC5,F
03CE8:  BZ    3CEE
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03CEA:  BSF    xCC.0
....................          goto Exit_disk_initialize; 
03CEC:  BRA    4366
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03CEE:  MOVLW  77
03CF0:  MOVLB  A
03CF2:  MOVWF  x08
03CF4:  CLRF   x0C
03CF6:  CLRF   x0B
03CF8:  CLRF   x0A
03CFA:  CLRF   x09
03CFC:  MOVLB  0
03CFE:  CALL   34DC
03D02:  MOVFF  01,9C5
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03D06:  MOVF   1F,W
03D08:  SUBLW  04
03D0A:  BNZ   3D52
03D0C:  MOVF   20,F
03D0E:  BNZ   3D52
03D10:  MOVLW  18
03D12:  MOVWF  FF6
03D14:  MOVLW  09
03D16:  MOVWF  FF7
03D18:  MOVLW  00
03D1A:  MOVWF  FF8
03D1C:  CLRF   1B
03D1E:  BTFSC  FF2.7
03D20:  BSF    1B.7
03D22:  BCF    FF2.7
03D24:  MOVLW  43
03D26:  MOVLB  A
03D28:  MOVWF  x1C
03D2A:  MOVLB  0
03D2C:  CALL   1024
03D30:  BTFSC  1B.7
03D32:  BSF    FF2.7
03D34:  MOVFF  9C5,9CD
03D38:  MOVLW  57
03D3A:  MOVLB  9
03D3C:  MOVWF  xCE
03D3E:  MOVLB  0
03D40:  RCALL  35AC
03D42:  MOVLW  0D
03D44:  BTFSS  F9E.4
03D46:  BRA    3D44
03D48:  MOVWF  FAD
03D4A:  MOVLW  0A
03D4C:  BTFSS  F9E.4
03D4E:  BRA    3D4C
03D50:  MOVWF  FAD
....................       if (response) 
03D52:  MOVLB  9
03D54:  MOVF   xC5,F
03D56:  BZ    3D62
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03D58:  MOVLW  02
03D5A:  MOVLB  4
03D5C:  MOVWF  xE7
....................          } 
03D5E:  BRA    3F5C
03D60:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03D62:  MOVLW  69
03D64:  MOVLB  A
03D66:  MOVWF  x08
03D68:  CLRF   x0C
03D6A:  CLRF   x0B
03D6C:  CLRF   x0A
03D6E:  CLRF   x09
03D70:  MOVLB  0
03D72:  CALL   34DC
03D76:  MOVFF  01,9C5
....................          if (response <= 1 ) 
03D7A:  MOVLB  9
03D7C:  MOVF   xC5,W
03D7E:  SUBLW  01
03D80:  BNC   3D8C
....................             Card = SDv1; 
03D82:  MOVLW  03
03D84:  MOVLB  4
03D86:  MOVWF  xE7
03D88:  BRA    3F5C
03D8A:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03D8C:  MOVF   1F,W
03D8E:  SUBLW  04
03D90:  BNZ   3DF0
03D92:  MOVF   20,F
03D94:  BNZ   3DF0
03D96:  MOVLW  62
03D98:  MOVWF  FF6
03D9A:  MOVLW  09
03D9C:  MOVWF  FF7
03D9E:  MOVLW  00
03DA0:  MOVWF  FF8
03DA2:  CLRF   1B
03DA4:  BTFSC  FF2.7
03DA6:  BSF    1B.7
03DA8:  BCF    FF2.7
03DAA:  MOVLW  2E
03DAC:  MOVLB  A
03DAE:  MOVWF  x1C
03DB0:  MOVLB  0
03DB2:  CALL   1024
03DB6:  BTFSC  1B.7
03DB8:  BSF    FF2.7
03DBA:  MOVFF  9C5,9CD
03DBE:  MOVLW  37
03DC0:  MOVLB  9
03DC2:  MOVWF  xCE
03DC4:  MOVLB  0
03DC6:  CALL   35AC
03DCA:  MOVLW  94
03DCC:  MOVWF  FF6
03DCE:  MOVLW  09
03DD0:  MOVWF  FF7
03DD2:  MOVLW  00
03DD4:  MOVWF  FF8
03DD6:  CLRF   1B
03DD8:  BTFSC  FF2.7
03DDA:  BSF    1B.7
03DDC:  BCF    FF2.7
03DDE:  MOVLW  19
03DE0:  MOVLB  A
03DE2:  MOVWF  x1C
03DE4:  MOVLB  0
03DE6:  CALL   1024
03DEA:  BTFSC  1B.7
03DEC:  BSF    FF2.7
03DEE:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03DF0:  MOVLW  40
03DF2:  MOVLB  A
03DF4:  MOVWF  x08
03DF6:  CLRF   x0C
03DF8:  CLRF   x0B
03DFA:  CLRF   x0A
03DFC:  CLRF   x09
03DFE:  MOVLB  0
03E00:  CALL   34DC
03E04:  MOVFF  01,9C5
....................             if ((response !=0x01) && (response != 0)) 
03E08:  MOVLB  9
03E0A:  DECFSZ xC5,W
03E0C:  BRA    3E10
03E0E:  BRA    3E7C
03E10:  MOVF   xC5,F
03E12:  BZ    3E7C
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03E14:  MOVF   1F,W
03E16:  SUBLW  04
03E18:  BNZ   3E78
03E1A:  MOVF   20,F
03E1C:  BNZ   3E78
03E1E:  MOVLW  AE
03E20:  MOVWF  FF6
03E22:  MOVLW  09
03E24:  MOVWF  FF7
03E26:  MOVLW  00
03E28:  MOVWF  FF8
03E2A:  CLRF   1B
03E2C:  BTFSC  FF2.7
03E2E:  BSF    1B.7
03E30:  BCF    FF2.7
03E32:  MOVLW  2C
03E34:  MOVLB  A
03E36:  MOVWF  x1C
03E38:  MOVLB  0
03E3A:  CALL   1024
03E3E:  BTFSC  1B.7
03E40:  BSF    FF2.7
03E42:  MOVFF  9C5,9CD
03E46:  MOVLW  37
03E48:  MOVLB  9
03E4A:  MOVWF  xCE
03E4C:  MOVLB  0
03E4E:  CALL   35AC
03E52:  MOVLW  DE
03E54:  MOVWF  FF6
03E56:  MOVLW  09
03E58:  MOVWF  FF7
03E5A:  MOVLW  00
03E5C:  MOVWF  FF8
03E5E:  CLRF   1B
03E60:  BTFSC  FF2.7
03E62:  BSF    1B.7
03E64:  BCF    FF2.7
03E66:  MOVLW  0B
03E68:  MOVLB  A
03E6A:  MOVWF  x1C
03E6C:  MOVLB  0
03E6E:  CALL   1024
03E72:  BTFSC  1B.7
03E74:  BSF    FF2.7
03E76:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03E78:  BSF    xCC.0
....................                goto Exit_disk_initialize; 
03E7A:  BRA    4366
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03E7C:  CLRF   xCB
03E7E:  CLRF   xCA
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03E80:  MOVLW  41
03E82:  MOVLB  A
03E84:  MOVWF  x08
03E86:  CLRF   x0C
03E88:  CLRF   x0B
03E8A:  CLRF   x0A
03E8C:  CLRF   x09
03E8E:  MOVLB  0
03E90:  CALL   34DC
03E94:  MOVFF  01,9C5
....................                if (response != 0x00 ) 
03E98:  MOVLB  9
03E9A:  MOVF   xC5,F
03E9C:  BZ    3EA6
....................                   delay_us(10); 
03E9E:  MOVLW  35
03EA0:  MOVWF  00
03EA2:  DECFSZ 00,F
03EA4:  BRA    3EA2
....................                Timer++; 
03EA6:  INCF   xCA,F
03EA8:  BTFSC  FD8.2
03EAA:  INCF   xCB,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03EAC:  MOVF   xC5,F
03EAE:  BZ    3EBE
03EB0:  MOVF   xCB,W
03EB2:  SUBLW  C3
03EB4:  BNC   3EBE
03EB6:  BNZ   3E80
03EB8:  MOVF   xCA,W
03EBA:  SUBLW  4F
03EBC:  BC    3E80
....................     
....................             if(response) 
03EBE:  MOVF   xC5,F
03EC0:  BZ    3F56
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03EC2:  MOVF   1F,W
03EC4:  SUBLW  04
03EC6:  BNZ   3F52
03EC8:  MOVF   20,F
03ECA:  BNZ   3F52
03ECC:  MOVLW  EA
03ECE:  MOVWF  FF6
03ED0:  MOVLW  09
03ED2:  MOVWF  FF7
03ED4:  MOVLW  00
03ED6:  MOVWF  FF8
03ED8:  CLRF   1B
03EDA:  BTFSC  FF2.7
03EDC:  BSF    1B.7
03EDE:  BCF    FF2.7
03EE0:  MOVLW  4A
03EE2:  MOVLB  A
03EE4:  MOVWF  x1C
03EE6:  MOVLB  0
03EE8:  CALL   1024
03EEC:  BTFSC  1B.7
03EEE:  BSF    FF2.7
03EF0:  MOVFF  9C5,9CD
03EF4:  MOVLW  37
03EF6:  MOVLB  9
03EF8:  MOVWF  xCE
03EFA:  MOVLB  0
03EFC:  CALL   35AC
03F00:  MOVLW  38
03F02:  MOVWF  FF6
03F04:  MOVLW  0A
03F06:  MOVWF  FF7
03F08:  MOVLW  00
03F0A:  MOVWF  FF8
03F0C:  CLRF   1B
03F0E:  BTFSC  FF2.7
03F10:  BSF    1B.7
03F12:  BCF    FF2.7
03F14:  MOVLW  0A
03F16:  MOVLB  A
03F18:  MOVWF  x1C
03F1A:  MOVLB  0
03F1C:  CALL   1024
03F20:  BTFSC  1B.7
03F22:  BSF    FF2.7
03F24:  MOVLW  10
03F26:  MOVWF  FE9
03F28:  CLRF   1B
03F2A:  BTFSC  FF2.7
03F2C:  BSF    1B.7
03F2E:  BCF    FF2.7
03F30:  MOVFF  9CB,A1D
03F34:  MOVFF  9CA,A1C
03F38:  CALL   11A6
03F3C:  BTFSC  1B.7
03F3E:  BSF    FF2.7
03F40:  MOVLW  0D
03F42:  BTFSS  F9E.4
03F44:  BRA    3F42
03F46:  MOVWF  FAD
03F48:  MOVLW  0A
03F4A:  BTFSS  F9E.4
03F4C:  BRA    3F4A
03F4E:  MOVWF  FAD
03F50:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03F52:  BSF    xCC.0
....................                goto Exit_disk_initialize; 
03F54:  BRA    4366
....................                } 
....................  
....................             Card = MMC; 
03F56:  MOVLW  02
03F58:  MOVLB  4
03F5A:  MOVWF  xE7
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
03F5C:  MOVF   1F,W
03F5E:  SUBLW  04
03F60:  BNZ   3F86
03F62:  MOVF   20,F
03F64:  BNZ   3F86
03F66:  MOVLW  48
03F68:  MOVWF  FF6
03F6A:  MOVLW  0A
03F6C:  MOVWF  FF7
03F6E:  MOVLW  00
03F70:  MOVWF  FF8
03F72:  CLRF   1B
03F74:  BTFSC  FF2.7
03F76:  BSF    1B.7
03F78:  BCF    FF2.7
03F7A:  MOVLB  0
03F7C:  CALL   0E4E
03F80:  BTFSC  1B.7
03F82:  BSF    FF2.7
03F84:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
03F86:  MOVLW  50
03F88:  MOVLB  A
03F8A:  MOVWF  x08
03F8C:  CLRF   x0C
03F8E:  CLRF   x0B
03F90:  MOVLW  02
03F92:  MOVWF  x0A
03F94:  CLRF   x09
03F96:  MOVLB  0
03F98:  CALL   34DC
03F9C:  MOVFF  01,9C5
....................       if ((Timer == 50000) || (response > 1))    
03FA0:  MOVLB  9
03FA2:  MOVF   xCA,W
03FA4:  SUBLW  50
03FA6:  BNZ   3FAE
03FA8:  MOVF   xCB,W
03FAA:  SUBLW  C3
03FAC:  BZ    3FB4
03FAE:  MOVF   xC5,W
03FB0:  SUBLW  01
03FB2:  BC    404A
....................       { 
....................          Card = None; 
03FB4:  MOVLB  4
03FB6:  CLRF   xE7
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
03FB8:  MOVF   1F,W
03FBA:  SUBLW  04
03FBC:  BNZ   4048
03FBE:  MOVF   20,F
03FC0:  BNZ   4048
03FC2:  MOVLW  64
03FC4:  MOVWF  FF6
03FC6:  MOVLW  0A
03FC8:  MOVWF  FF7
03FCA:  MOVLW  00
03FCC:  MOVWF  FF8
03FCE:  CLRF   1B
03FD0:  BTFSC  FF2.7
03FD2:  BSF    1B.7
03FD4:  BCF    FF2.7
03FD6:  MOVLW  2B
03FD8:  MOVLB  A
03FDA:  MOVWF  x1C
03FDC:  MOVLB  0
03FDE:  CALL   1024
03FE2:  BTFSC  1B.7
03FE4:  BSF    FF2.7
03FE6:  MOVFF  9C5,9CD
03FEA:  MOVLW  57
03FEC:  MOVLB  9
03FEE:  MOVWF  xCE
03FF0:  MOVLB  0
03FF2:  CALL   35AC
03FF6:  MOVLW  93
03FF8:  MOVWF  FF6
03FFA:  MOVLW  0A
03FFC:  MOVWF  FF7
03FFE:  MOVLW  00
04000:  MOVWF  FF8
04002:  CLRF   1B
04004:  BTFSC  FF2.7
04006:  BSF    1B.7
04008:  BCF    FF2.7
0400A:  MOVLW  0A
0400C:  MOVLB  A
0400E:  MOVWF  x1C
04010:  MOVLB  0
04012:  CALL   1024
04016:  BTFSC  1B.7
04018:  BSF    FF2.7
0401A:  MOVLW  10
0401C:  MOVWF  FE9
0401E:  CLRF   1B
04020:  BTFSC  FF2.7
04022:  BSF    1B.7
04024:  BCF    FF2.7
04026:  MOVFF  9CB,A1D
0402A:  MOVFF  9CA,A1C
0402E:  CALL   11A6
04032:  BTFSC  1B.7
04034:  BSF    FF2.7
04036:  MOVLW  0D
04038:  BTFSS  F9E.4
0403A:  BRA    4038
0403C:  MOVWF  FAD
0403E:  MOVLW  0A
04040:  BTFSS  F9E.4
04042:  BRA    4040
04044:  MOVWF  FAD
04046:  MOVLB  4
04048:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
0404A:  MOVLB  4
0404C:  MOVF   xE7,F
0404E:  BNZ   4082
....................    { 
....................       if (nv_report_mode == 4) 
04050:  MOVF   1F,W
04052:  SUBLW  04
04054:  BNZ   407A
04056:  MOVF   20,F
04058:  BNZ   407A
....................          printf("@FS:Card Type Discovery Error\r\n"); 
0405A:  MOVLW  A4
0405C:  MOVWF  FF6
0405E:  MOVLW  0A
04060:  MOVWF  FF7
04062:  MOVLW  00
04064:  MOVWF  FF8
04066:  CLRF   1B
04068:  BTFSC  FF2.7
0406A:  BSF    1B.7
0406C:  BCF    FF2.7
0406E:  MOVLB  0
04070:  CALL   0E4E
04074:  BTFSC  1B.7
04076:  BSF    FF2.7
04078:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
0407A:  MOVLB  9
0407C:  BSF    xCC.0
....................       goto Exit_disk_initialize; 
0407E:  BRA    4366
04080:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
04082:  MOVF   xE7,W
04084:  XORLW  02
04086:  MOVLB  0
04088:  BZ    4098
0408A:  XORLW  01
0408C:  BZ    40C0
0408E:  XORLW  07
04090:  BZ    40E8
04092:  XORLW  01
04094:  BZ    4110
04096:  BRA    4138
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
04098:  MOVF   1F,W
0409A:  SUBLW  04
0409C:  BNZ   40BE
0409E:  MOVF   20,F
040A0:  BNZ   40BE
040A2:  MOVLW  C4
040A4:  MOVWF  FF6
040A6:  MOVLW  0A
040A8:  MOVWF  FF7
040AA:  MOVLW  00
040AC:  MOVWF  FF8
040AE:  CLRF   1B
040B0:  BTFSC  FF2.7
040B2:  BSF    1B.7
040B4:  BCF    FF2.7
040B6:  CALL   0E4E
040BA:  BTFSC  1B.7
040BC:  BSF    FF2.7
....................          break; 
040BE:  BRA    418E
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
040C0:  MOVF   1F,W
040C2:  SUBLW  04
040C4:  BNZ   40E6
040C6:  MOVF   20,F
040C8:  BNZ   40E6
040CA:  MOVLW  DA
040CC:  MOVWF  FF6
040CE:  MOVLW  0A
040D0:  MOVWF  FF7
040D2:  MOVLW  00
040D4:  MOVWF  FF8
040D6:  CLRF   1B
040D8:  BTFSC  FF2.7
040DA:  BSF    1B.7
040DC:  BCF    FF2.7
040DE:  CALL   0E4E
040E2:  BTFSC  1B.7
040E4:  BSF    FF2.7
....................          break; 
040E6:  BRA    418E
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
040E8:  MOVF   1F,W
040EA:  SUBLW  04
040EC:  BNZ   410E
040EE:  MOVF   20,F
040F0:  BNZ   410E
040F2:  MOVLW  F0
040F4:  MOVWF  FF6
040F6:  MOVLW  0A
040F8:  MOVWF  FF7
040FA:  MOVLW  00
040FC:  MOVWF  FF8
040FE:  CLRF   1B
04100:  BTFSC  FF2.7
04102:  BSF    1B.7
04104:  BCF    FF2.7
04106:  CALL   0E4E
0410A:  BTFSC  1B.7
0410C:  BSF    FF2.7
....................          break; 
0410E:  BRA    418E
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
04110:  MOVF   1F,W
04112:  SUBLW  04
04114:  BNZ   4136
04116:  MOVF   20,F
04118:  BNZ   4136
0411A:  MOVLW  06
0411C:  MOVWF  FF6
0411E:  MOVLW  0B
04120:  MOVWF  FF7
04122:  MOVLW  00
04124:  MOVWF  FF8
04126:  CLRF   1B
04128:  BTFSC  FF2.7
0412A:  BSF    1B.7
0412C:  BCF    FF2.7
0412E:  CALL   0E4E
04132:  BTFSC  1B.7
04134:  BSF    FF2.7
....................          break; 
04136:  BRA    418E
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
04138:  MOVF   1F,W
0413A:  SUBLW  04
0413C:  BNZ   4186
0413E:  MOVF   20,F
04140:  BNZ   4186
04142:  MOVLW  1C
04144:  MOVWF  FF6
04146:  MOVLW  0B
04148:  MOVWF  FF7
0414A:  MOVLW  00
0414C:  MOVWF  FF8
0414E:  CLRF   1B
04150:  BTFSC  FF2.7
04152:  BSF    1B.7
04154:  BCF    FF2.7
04156:  MOVLW  26
04158:  MOVLB  A
0415A:  MOVWF  x1C
0415C:  MOVLB  0
0415E:  CALL   1024
04162:  BTFSC  1B.7
04164:  BSF    FF2.7
04166:  MOVFF  4E7,9CD
0416A:  MOVLW  37
0416C:  MOVLB  9
0416E:  MOVWF  xCE
04170:  MOVLB  0
04172:  CALL   35AC
04176:  MOVLW  0D
04178:  BTFSS  F9E.4
0417A:  BRA    4178
0417C:  MOVWF  FAD
0417E:  MOVLW  0A
04180:  BTFSS  F9E.4
04182:  BRA    4180
04184:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
04186:  MOVLB  9
04188:  BSF    xCC.0
....................          goto Exit_disk_initialize; 
0418A:  BRA    4366
0418C:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
0418E:  MOVLB  9
04190:  BCF    xCC.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
04192:  MOVF   1F,W
04194:  SUBLW  04
04196:  BNZ   41EE
04198:  MOVF   20,F
0419A:  BNZ   41EE
0419C:  MOVLW  4A
0419E:  MOVWF  FF6
041A0:  MOVLW  0B
041A2:  MOVWF  FF7
041A4:  MOVLW  00
041A6:  MOVWF  FF8
041A8:  CLRF   1B
041AA:  BTFSC  FF2.7
041AC:  BSF    1B.7
041AE:  BCF    FF2.7
041B0:  MOVLW  2E
041B2:  MOVLB  A
041B4:  MOVWF  x1C
041B6:  MOVLB  0
041B8:  CALL   1024
041BC:  BTFSC  1B.7
041BE:  BSF    FF2.7
041C0:  MOVLW  10
041C2:  MOVWF  FE9
041C4:  CLRF   1B
041C6:  BTFSC  FF2.7
041C8:  BSF    1B.7
041CA:  BCF    FF2.7
041CC:  MOVFF  9CB,A1D
041D0:  MOVFF  9CA,A1C
041D4:  CALL   11A6
041D8:  BTFSC  1B.7
041DA:  BSF    FF2.7
041DC:  MOVLW  0D
041DE:  BTFSS  F9E.4
041E0:  BRA    41DE
041E2:  MOVWF  FAD
041E4:  MOVLW  0A
041E6:  BTFSS  F9E.4
041E8:  BRA    41E6
041EA:  MOVWF  FAD
041EC:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
041EE:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
041F0:  BCF    FC6.5
041F2:  MOVLW  20
041F4:  MOVWF  FC6
041F6:  MOVLW  40
041F8:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
041FA:  BCF    F9E.3
....................    SelectSD; 
041FC:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
041FE:  MOVF   1F,W
04200:  SUBLW  04
04202:  BNZ   4228
04204:  MOVF   20,F
04206:  BNZ   4228
04208:  MOVLW  7E
0420A:  MOVWF  FF6
0420C:  MOVLW  0B
0420E:  MOVWF  FF7
04210:  MOVLW  00
04212:  MOVWF  FF8
04214:  CLRF   1B
04216:  BTFSC  FF2.7
04218:  BSF    1B.7
0421A:  BCF    FF2.7
0421C:  MOVLB  0
0421E:  CALL   0E4E
04222:  BTFSC  1B.7
04224:  BSF    FF2.7
04226:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
04228:  CLRF   xCB
0422A:  CLRF   xCA
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
0422C:  MOVLW  41
0422E:  MOVLB  A
04230:  MOVWF  x08
04232:  CLRF   x0C
04234:  CLRF   x0B
04236:  CLRF   x0A
04238:  CLRF   x09
0423A:  MOVLB  0
0423C:  CALL   34DC
04240:  MOVFF  01,9C5
....................       if (response != 0x00 ) 
04244:  MOVLB  9
04246:  MOVF   xC5,F
04248:  BZ    4252
....................          delay_us(10); 
0424A:  MOVLW  35
0424C:  MOVWF  00
0424E:  DECFSZ 00,F
04250:  BRA    424E
....................  
....................       Timer++; 
04252:  INCF   xCA,F
04254:  BTFSC  FD8.2
04256:  INCF   xCB,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
04258:  MOVF   xC5,F
0425A:  BZ    426A
0425C:  MOVF   xCB,W
0425E:  SUBLW  C3
04260:  BNC   426A
04262:  BNZ   422C
04264:  MOVF   xCA,W
04266:  SUBLW  4F
04268:  BC    422C
....................  
....................    if (response != 0x00) 
0426A:  MOVF   xC5,F
0426C:  BZ    4302
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
0426E:  MOVF   1F,W
04270:  SUBLW  04
04272:  BNZ   42FE
04274:  MOVF   20,F
04276:  BNZ   42FE
04278:  MOVLW  9E
0427A:  MOVWF  FF6
0427C:  MOVLW  0B
0427E:  MOVWF  FF7
04280:  MOVLW  00
04282:  MOVWF  FF8
04284:  CLRF   1B
04286:  BTFSC  FF2.7
04288:  BSF    1B.7
0428A:  BCF    FF2.7
0428C:  MOVLW  26
0428E:  MOVLB  A
04290:  MOVWF  x1C
04292:  MOVLB  0
04294:  CALL   1024
04298:  BTFSC  1B.7
0429A:  BSF    FF2.7
0429C:  MOVFF  9C5,9CD
042A0:  MOVLW  37
042A2:  MOVLB  9
042A4:  MOVWF  xCE
042A6:  MOVLB  0
042A8:  CALL   35AC
042AC:  MOVLW  C8
042AE:  MOVWF  FF6
042B0:  MOVLW  0B
042B2:  MOVWF  FF7
042B4:  MOVLW  00
042B6:  MOVWF  FF8
042B8:  CLRF   1B
042BA:  BTFSC  FF2.7
042BC:  BSF    1B.7
042BE:  BCF    FF2.7
042C0:  MOVLW  0A
042C2:  MOVLB  A
042C4:  MOVWF  x1C
042C6:  MOVLB  0
042C8:  CALL   1024
042CC:  BTFSC  1B.7
042CE:  BSF    FF2.7
042D0:  MOVLW  10
042D2:  MOVWF  FE9
042D4:  CLRF   1B
042D6:  BTFSC  FF2.7
042D8:  BSF    1B.7
042DA:  BCF    FF2.7
042DC:  MOVFF  9CB,A1D
042E0:  MOVFF  9CA,A1C
042E4:  CALL   11A6
042E8:  BTFSC  1B.7
042EA:  BSF    FF2.7
042EC:  MOVLW  0D
042EE:  BTFSS  F9E.4
042F0:  BRA    42EE
042F2:  MOVWF  FAD
042F4:  MOVLW  0A
042F6:  BTFSS  F9E.4
042F8:  BRA    42F6
042FA:  MOVWF  FAD
042FC:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
042FE:  BSF    xCC.0
....................       goto Exit_disk_initialize; 
04300:  BRA    4366
....................    } 
....................  
....................    if (nv_report_mode == 4) 
04302:  MOVF   1F,W
04304:  SUBLW  04
04306:  BNZ   435E
04308:  MOVF   20,F
0430A:  BNZ   435E
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
0430C:  MOVLW  D8
0430E:  MOVWF  FF6
04310:  MOVLW  0B
04312:  MOVWF  FF7
04314:  MOVLW  00
04316:  MOVWF  FF8
04318:  CLRF   1B
0431A:  BTFSC  FF2.7
0431C:  BSF    1B.7
0431E:  BCF    FF2.7
04320:  MOVLW  25
04322:  MOVLB  A
04324:  MOVWF  x1C
04326:  MOVLB  0
04328:  CALL   1024
0432C:  BTFSC  1B.7
0432E:  BSF    FF2.7
04330:  MOVLW  10
04332:  MOVWF  FE9
04334:  CLRF   1B
04336:  BTFSC  FF2.7
04338:  BSF    1B.7
0433A:  BCF    FF2.7
0433C:  MOVFF  9CB,A1D
04340:  MOVFF  9CA,A1C
04344:  CALL   11A6
04348:  BTFSC  1B.7
0434A:  BSF    FF2.7
0434C:  MOVLW  0D
0434E:  BTFSS  F9E.4
04350:  BRA    434E
04352:  MOVWF  FAD
04354:  MOVLW  0A
04356:  BTFSS  F9E.4
04358:  BRA    4356
0435A:  MOVWF  FAD
0435C:  MOVLB  9
....................  
....................    msg_card_ok(); 
0435E:  MOVLB  0
04360:  GOTO   35F2
04364:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
04366:  BSF    F91.1
....................    return(SDCardStatus); 
04368:  MOVFF  9CC,01
0436C:  MOVLB  0
0436E:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05A16:  MOVLW  20
05A18:  MOVLB  7
05A1A:  ADDWF  x12,W
05A1C:  MOVWF  FE9
05A1E:  MOVLW  00
05A20:  ADDWFC x13,W
05A22:  MOVWF  FEA
05A24:  MOVFF  FEF,9F5
05A28:  MOVFF  FEC,9F6
05A2C:  MOVFF  FEC,9F7
05A30:  MOVFF  FEC,9F8
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05A34:  MOVLB  9
05A36:  MOVF   xF1,W
05A38:  SUBWF  xF5,W
05A3A:  BNZ   5A50
05A3C:  MOVF   xF2,W
05A3E:  SUBWF  xF6,W
05A40:  BNZ   5A50
05A42:  MOVF   xF3,W
05A44:  SUBWF  xF7,W
05A46:  BNZ   5A50
05A48:  MOVF   xF4,W
05A4A:  SUBWF  xF8,W
05A4C:  BTFSC  FD8.2
05A4E:  BRA    5C2A
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05A50:  MOVLW  06
05A52:  MOVLB  7
05A54:  ADDWF  x12,W
05A56:  MOVWF  FE9
05A58:  MOVLW  00
05A5A:  ADDWFC x13,W
05A5C:  MOVWF  FEA
05A5E:  MOVF   FEF,F
05A60:  BTFSC  FD8.2
05A62:  BRA    5BB2
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05A64:  MOVLW  24
05A66:  ADDWF  x12,W
05A68:  MOVWF  01
05A6A:  MOVLW  00
05A6C:  ADDWFC x13,W
05A6E:  MOVWF  03
05A70:  MOVFF  01,9FB
05A74:  MOVLB  9
05A76:  MOVWF  xFC
05A78:  MOVWF  xFE
05A7A:  MOVFF  01,9FD
05A7E:  MOVFF  9F8,A02
05A82:  MOVFF  9F7,A01
05A86:  MOVFF  9F6,A00
05A8A:  MOVFF  9F5,9FF
05A8E:  MOVLW  01
05A90:  MOVLB  A
05A92:  MOVWF  x03
05A94:  MOVLB  0
05A96:  RCALL  58CE
05A98:  MOVFF  01,9F9
....................             if (response != RES_OK) 
05A9C:  MOVLB  9
05A9E:  MOVF   xF9,F
05AA0:  BZ    5AA8
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05AA2:  MOVLW  00
05AA4:  MOVWF  01
05AA6:  BRA    5C2E
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05AA8:  MOVLW  06
05AAA:  MOVLB  7
05AAC:  ADDWF  x12,W
05AAE:  MOVWF  FE9
05AB0:  MOVLW  00
05AB2:  ADDWFC x13,W
05AB4:  MOVWF  FEA
05AB6:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05AB8:  MOVLW  10
05ABA:  ADDWF  x12,W
05ABC:  MOVWF  FE9
05ABE:  MOVLW  00
05AC0:  ADDWFC x13,W
05AC2:  MOVWF  FEA
05AC4:  MOVFF  FEF,9FB
05AC8:  MOVFF  FEC,9FC
05ACC:  MOVFF  FEC,9FD
05AD0:  MOVFF  FEC,9FE
05AD4:  MOVLW  08
05AD6:  ADDWF  x12,W
05AD8:  MOVWF  FE9
05ADA:  MOVLW  00
05ADC:  ADDWFC x13,W
05ADE:  MOVWF  FEA
05AE0:  MOVFF  FEF,00
05AE4:  MOVFF  FEC,01
05AE8:  MOVFF  FEC,02
05AEC:  MOVFF  FEC,03
05AF0:  MOVLB  9
05AF2:  MOVF   xFB,W
05AF4:  ADDWF  00,F
05AF6:  MOVF   xFC,W
05AF8:  ADDWFC 01,F
05AFA:  MOVF   xFD,W
05AFC:  ADDWFC 02,F
05AFE:  MOVF   xFE,W
05B00:  ADDWFC 03,F
05B02:  MOVF   xF8,W
05B04:  SUBWF  03,W
05B06:  BNC   5BB0
05B08:  BNZ   5B20
05B0A:  MOVF   xF7,W
05B0C:  SUBWF  02,W
05B0E:  BNC   5BB0
05B10:  BNZ   5B20
05B12:  MOVF   xF6,W
05B14:  SUBWF  01,W
05B16:  BNC   5BB0
05B18:  BNZ   5B20
05B1A:  MOVF   00,W
05B1C:  SUBWF  xF5,W
05B1E:  BC    5BB0
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05B20:  MOVLW  03
05B22:  MOVLB  7
05B24:  ADDWF  x12,W
05B26:  MOVWF  FE9
05B28:  MOVLW  00
05B2A:  ADDWFC x13,W
05B2C:  MOVWF  FEA
05B2E:  MOVFF  FEF,9FA
05B32:  MOVLB  9
05B34:  MOVF   xFA,W
05B36:  SUBLW  01
05B38:  BC    5BB0
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05B3A:  MOVLW  08
05B3C:  MOVLB  7
05B3E:  ADDWF  x12,W
05B40:  MOVWF  FE9
05B42:  MOVLW  00
05B44:  ADDWFC x13,W
05B46:  MOVWF  FEA
05B48:  MOVFF  FEF,00
05B4C:  MOVFF  FEC,01
05B50:  MOVFF  FEC,02
05B54:  MOVFF  FEC,03
05B58:  MOVF   00,W
05B5A:  MOVLB  9
05B5C:  ADDWF  xF5,F
05B5E:  MOVF   01,W
05B60:  ADDWFC xF6,F
05B62:  MOVF   02,W
05B64:  ADDWFC xF7,F
05B66:  MOVF   03,W
05B68:  ADDWFC xF8,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05B6A:  MOVLW  24
05B6C:  MOVLB  7
05B6E:  ADDWF  x12,W
05B70:  MOVWF  01
05B72:  MOVLW  00
05B74:  ADDWFC x13,W
05B76:  MOVWF  03
05B78:  MOVFF  01,9FB
05B7C:  MOVLB  9
05B7E:  MOVWF  xFC
05B80:  MOVWF  xFE
05B82:  MOVFF  01,9FD
05B86:  MOVFF  9F8,A02
05B8A:  MOVFF  9F7,A01
05B8E:  MOVFF  9F6,A00
05B92:  MOVFF  9F5,9FF
05B96:  MOVLW  01
05B98:  MOVLB  A
05B9A:  MOVWF  x03
05B9C:  MOVLB  0
05B9E:  RCALL  58CE
05BA0:  MOVF   01,F
05BA2:  BZ    5BAA
....................                      break; 
05BA4:  MOVLB  9
05BA6:  BRA    5BB0
05BA8:  MOVLB  0
05BAA:  MOVLB  9
05BAC:  DECF   xFA,F
05BAE:  BRA    5B34
05BB0:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05BB2:  MOVLB  9
05BB4:  MOVF   xF1,F
05BB6:  BNZ   5BC4
05BB8:  MOVF   xF2,F
05BBA:  BNZ   5BC4
05BBC:  MOVF   xF3,F
05BBE:  BNZ   5BC4
05BC0:  MOVF   xF4,F
05BC2:  BZ    5C2A
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05BC4:  MOVLW  24
05BC6:  MOVLB  7
05BC8:  ADDWF  x12,W
05BCA:  MOVWF  01
05BCC:  MOVLW  00
05BCE:  ADDWFC x13,W
05BD0:  MOVWF  03
05BD2:  MOVFF  01,9FB
05BD6:  MOVLB  9
05BD8:  MOVWF  xFC
05BDA:  MOVWF  xFE
05BDC:  MOVFF  01,9FD
05BE0:  MOVFF  9F4,A02
05BE4:  MOVFF  9F3,A01
05BE8:  MOVFF  9F2,A00
05BEC:  MOVFF  9F1,9FF
05BF0:  MOVLW  01
05BF2:  MOVLB  A
05BF4:  MOVWF  x03
05BF6:  MOVLB  0
05BF8:  CALL   4468
05BFC:  MOVF   01,F
05BFE:  BZ    5C0A
....................             return FALSE; 
05C00:  MOVLW  00
05C02:  MOVWF  01
05C04:  MOVLB  9
05C06:  BRA    5C2E
05C08:  MOVLB  0
....................          fs->winsect = sector; 
05C0A:  MOVLW  20
05C0C:  MOVLB  7
05C0E:  ADDWF  x12,W
05C10:  MOVWF  FE9
05C12:  MOVLW  00
05C14:  ADDWFC x13,W
05C16:  MOVWF  FEA
05C18:  MOVFF  9F1,FEF
05C1C:  MOVFF  9F2,FEC
05C20:  MOVFF  9F3,FEC
05C24:  MOVFF  9F4,FEC
05C28:  MOVLB  9
....................          } 
....................       } 
....................    return (TRUE); 
05C2A:  MOVLW  01
05C2C:  MOVWF  01
05C2E:  MOVLB  0
05C30:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05C54:  MOVLB  9
05C56:  MOVF   xE0,F
05C58:  BNZ   5C6A
05C5A:  MOVF   xDF,F
05C5C:  BNZ   5C6A
05C5E:  MOVF   xDE,F
05C60:  BNZ   5C6A
05C62:  MOVF   xDD,W
05C64:  SUBLW  01
05C66:  BTFSC  FD8.0
05C68:  BRA    5F7A
05C6A:  MOVLW  0C
05C6C:  MOVLB  7
05C6E:  ADDWF  x12,W
05C70:  MOVWF  FE9
05C72:  MOVLW  00
05C74:  ADDWFC x13,W
05C76:  MOVWF  FEA
05C78:  MOVFF  FEF,00
05C7C:  MOVFF  FEC,01
05C80:  MOVFF  FEC,02
05C84:  MOVFF  FEC,03
05C88:  MOVLB  9
05C8A:  MOVF   xE0,W
05C8C:  SUBWF  03,W
05C8E:  BTFSS  FD8.0
05C90:  BRA    5F7A
05C92:  BNZ   5CB0
05C94:  MOVF   xDF,W
05C96:  SUBWF  02,W
05C98:  BTFSS  FD8.0
05C9A:  BRA    5F7A
05C9C:  BNZ   5CB0
05C9E:  MOVF   xDE,W
05CA0:  SUBWF  01,W
05CA2:  BTFSS  FD8.0
05CA4:  BRA    5F7A
05CA6:  BNZ   5CB0
05CA8:  MOVF   00,W
05CAA:  SUBWF  xDD,W
05CAC:  BTFSC  FD8.0
05CAE:  BRA    5F7A
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05CB0:  MOVLW  10
05CB2:  MOVLB  7
05CB4:  ADDWF  x12,W
05CB6:  MOVWF  FE9
05CB8:  MOVLW  00
05CBA:  ADDWFC x13,W
05CBC:  MOVWF  FEA
05CBE:  MOVFF  FEF,9E5
05CC2:  MOVFF  FEC,9E6
05CC6:  MOVFF  FEC,9E7
05CCA:  MOVFF  FEC,9E8
....................       switch (fs->fs_type)  
05CCE:  MOVF   x12,W
05CD0:  MOVWF  FE9
05CD2:  MOVF   x13,W
05CD4:  MOVWF  FEA
05CD6:  MOVF   FEF,W
05CD8:  XORLW  01
05CDA:  MOVLB  0
05CDC:  BZ    5CEC
05CDE:  XORLW  03
05CE0:  BTFSC  FD8.2
05CE2:  BRA    5E32
05CE4:  XORLW  01
05CE6:  BTFSC  FD8.2
05CE8:  BRA    5EB4
05CEA:  BRA    5F7C
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05CEC:  MOVFF  9DE,9EE
05CF0:  MOVFF  9DD,9ED
05CF4:  MOVLB  9
05CF6:  CLRF   xF0
05CF8:  MOVLW  03
05CFA:  MOVWF  xEF
05CFC:  MOVLB  0
05CFE:  RCALL  5C32
05D00:  BCF    FD8.0
05D02:  MOVLB  9
05D04:  RRCF   02,W
05D06:  MOVWF  xE4
05D08:  RRCF   01,W
05D0A:  MOVWF  xE3
....................             if (!move_window(fatsect + bc / 512))  
05D0C:  BCF    FD8.0
05D0E:  CLRF   03
05D10:  RRCF   xE4,W
05D12:  MOVWF  02
05D14:  ADDWF  xE5,W
05D16:  MOVWF  xE9
05D18:  MOVF   03,W
05D1A:  ADDWFC xE6,W
05D1C:  MOVWF  xEA
05D1E:  MOVLW  00
05D20:  ADDWFC xE7,W
05D22:  MOVWF  xEB
05D24:  MOVLW  00
05D26:  ADDWFC xE8,W
05D28:  MOVWF  xEC
05D2A:  MOVWF  xF4
05D2C:  MOVFF  9EB,9F3
05D30:  MOVFF  9EA,9F2
05D34:  MOVFF  9E9,9F1
05D38:  MOVLB  0
05D3A:  RCALL  5A16
05D3C:  MOVF   01,F
05D3E:  BNZ   5D42
....................                break; 
05D40:  BRA    5F7C
....................             wc = fs->win[bc % 512]; 
05D42:  MOVLB  9
05D44:  MOVF   xE4,W
05D46:  ANDLW  01
05D48:  MOVWF  xEA
05D4A:  MOVLW  24
05D4C:  ADDWF  xE3,W
05D4E:  MOVWF  01
05D50:  MOVLW  00
05D52:  ADDWFC xEA,W
05D54:  MOVWF  03
05D56:  MOVF   01,W
05D58:  MOVLB  7
05D5A:  ADDWF  x12,W
05D5C:  MOVWF  FE9
05D5E:  MOVF   x13,W
05D60:  ADDWFC 03,W
05D62:  MOVWF  FEA
05D64:  MOVLB  9
05D66:  CLRF   xE2
05D68:  MOVFF  FEF,9E1
....................             bc++; 
05D6C:  INCF   xE3,F
05D6E:  BTFSC  FD8.2
05D70:  INCF   xE4,F
....................             if (!move_window(fatsect + bc / 512))  
05D72:  BCF    FD8.0
05D74:  CLRF   03
05D76:  RRCF   xE4,W
05D78:  MOVWF  02
05D7A:  ADDWF  xE5,W
05D7C:  MOVWF  xE9
05D7E:  MOVF   03,W
05D80:  ADDWFC xE6,W
05D82:  MOVWF  xEA
05D84:  MOVLW  00
05D86:  ADDWFC xE7,W
05D88:  MOVWF  xEB
05D8A:  MOVLW  00
05D8C:  ADDWFC xE8,W
05D8E:  MOVWF  xEC
05D90:  MOVWF  xF4
05D92:  MOVFF  9EB,9F3
05D96:  MOVFF  9EA,9F2
05D9A:  MOVFF  9E9,9F1
05D9E:  MOVLB  0
05DA0:  RCALL  5A16
05DA2:  MOVF   01,F
05DA4:  BNZ   5DA8
....................                break; 
05DA6:  BRA    5F7C
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05DA8:  MOVLB  9
05DAA:  MOVF   xE4,W
05DAC:  ANDLW  01
05DAE:  MOVWF  xEA
05DB0:  MOVLW  24
05DB2:  ADDWF  xE3,W
05DB4:  MOVWF  01
05DB6:  MOVLW  00
05DB8:  ADDWFC xEA,W
05DBA:  MOVWF  03
05DBC:  MOVF   01,W
05DBE:  MOVLB  7
05DC0:  ADDWF  x12,W
05DC2:  MOVWF  FE9
05DC4:  MOVF   x13,W
05DC6:  ADDWFC 03,W
05DC8:  MOVWF  FEA
05DCA:  MOVF   FEF,W
05DCC:  MOVLB  9
05DCE:  MOVWF  xEB
05DD0:  MOVLW  00
05DD2:  IORWF  xE1,F
05DD4:  MOVF   xEB,W
05DD6:  IORWF  xE2,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05DD8:  MOVF   xDD,W
05DDA:  ANDLW  01
05DDC:  MOVWF  00
05DDE:  CLRF   01
05DE0:  CLRF   02
05DE2:  CLRF   03
05DE4:  MOVF   00,F
05DE6:  BNZ   5DF4
05DE8:  MOVF   01,F
05DEA:  BNZ   5DF4
05DEC:  MOVF   02,F
05DEE:  BNZ   5DF4
05DF0:  MOVF   03,F
05DF2:  BZ    5E1A
05DF4:  RRCF   xE2,W
05DF6:  MOVWF  03
05DF8:  RRCF   xE1,W
05DFA:  MOVWF  02
05DFC:  RRCF   03,F
05DFE:  RRCF   02,F
05E00:  RRCF   03,F
05E02:  RRCF   02,F
05E04:  RRCF   03,F
05E06:  RRCF   02,F
05E08:  MOVLW  0F
05E0A:  ANDWF  03,F
05E0C:  MOVFF  02,00
05E10:  MOVFF  03,01
05E14:  CLRF   02
05E16:  CLRF   03
05E18:  BRA    5E2E
05E1A:  MOVFF  9E1,00
05E1E:  MOVF   xE2,W
05E20:  ANDLW  0F
05E22:  MOVWF  03
05E24:  MOVF   xE1,W
05E26:  MOVFF  03,01
05E2A:  CLRF   02
05E2C:  CLRF   03
05E2E:  BRA    5F88
05E30:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05E32:  MOVFF  9DE,00
05E36:  MOVFF  9DF,01
05E3A:  MOVFF  9E0,02
05E3E:  CLRF   03
05E40:  MOVF   00,W
05E42:  MOVLB  9
05E44:  ADDWF  xE5,W
05E46:  MOVWF  xE9
05E48:  MOVF   xDF,W
05E4A:  ADDWFC xE6,W
05E4C:  MOVWF  xEA
05E4E:  MOVF   xE0,W
05E50:  ADDWFC xE7,W
05E52:  MOVWF  xEB
05E54:  MOVF   03,W
05E56:  ADDWFC xE8,W
05E58:  MOVWF  xEC
05E5A:  MOVWF  xF4
05E5C:  MOVFF  9EB,9F3
05E60:  MOVFF  9EA,9F2
05E64:  MOVFF  9E9,9F1
05E68:  MOVLB  0
05E6A:  RCALL  5A16
05E6C:  MOVF   01,F
05E6E:  BNZ   5E72
....................                break; 
05E70:  BRA    5F7C
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05E72:  BCF    FD8.0
05E74:  MOVLB  9
05E76:  RLCF   xDD,W
05E78:  MOVWF  xE9
05E7A:  RLCF   xDE,W
05E7C:  MOVWF  xEA
05E7E:  MOVLW  01
05E80:  ANDWF  xEA,F
05E82:  MOVLW  24
05E84:  ADDWF  xE9,W
05E86:  MOVWF  01
05E88:  MOVLW  00
05E8A:  ADDWFC xEA,W
05E8C:  MOVWF  03
05E8E:  MOVF   01,W
05E90:  MOVLB  7
05E92:  ADDWF  x12,W
05E94:  MOVWF  01
05E96:  MOVF   x13,W
05E98:  ADDWFC 03,F
05E9A:  MOVFF  01,FE9
05E9E:  MOVFF  03,FEA
05EA2:  MOVFF  FEF,00
05EA6:  MOVFF  FEC,01
05EAA:  CLRF   02
05EAC:  CLRF   03
05EAE:  MOVLB  9
05EB0:  BRA    5F88
05EB2:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05EB4:  MOVLB  9
05EB6:  RRCF   xE0,W
05EB8:  MOVWF  03
05EBA:  RRCF   xDF,W
05EBC:  MOVWF  02
05EBE:  RRCF   xDE,W
05EC0:  MOVWF  01
05EC2:  RRCF   xDD,W
05EC4:  MOVWF  00
05EC6:  RRCF   03,F
05EC8:  RRCF   02,F
05ECA:  RRCF   01,F
05ECC:  RRCF   00,F
05ECE:  RRCF   03,F
05ED0:  RRCF   02,F
05ED2:  RRCF   01,F
05ED4:  RRCF   00,F
05ED6:  RRCF   03,F
05ED8:  RRCF   02,F
05EDA:  RRCF   01,F
05EDC:  RRCF   00,F
05EDE:  RRCF   03,F
05EE0:  RRCF   02,F
05EE2:  RRCF   01,F
05EE4:  RRCF   00,F
05EE6:  RRCF   03,F
05EE8:  RRCF   02,F
05EEA:  RRCF   01,F
05EEC:  RRCF   00,F
05EEE:  RRCF   03,F
05EF0:  RRCF   02,F
05EF2:  RRCF   01,F
05EF4:  RRCF   00,F
05EF6:  MOVLW  01
05EF8:  ANDWF  03,F
05EFA:  MOVF   00,W
05EFC:  ADDWF  xE5,W
05EFE:  MOVWF  xE9
05F00:  MOVF   01,W
05F02:  ADDWFC xE6,W
05F04:  MOVWF  xEA
05F06:  MOVF   02,W
05F08:  ADDWFC xE7,W
05F0A:  MOVWF  xEB
05F0C:  MOVF   03,W
05F0E:  ADDWFC xE8,W
05F10:  MOVWF  xEC
05F12:  MOVWF  xF4
05F14:  MOVFF  9EB,9F3
05F18:  MOVFF  9EA,9F2
05F1C:  MOVFF  9E9,9F1
05F20:  MOVLB  0
05F22:  RCALL  5A16
05F24:  MOVF   01,F
05F26:  BNZ   5F2A
....................                break; 
05F28:  BRA    5F7C
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05F2A:  MOVLB  9
05F2C:  RLCF   xDD,W
05F2E:  MOVWF  xE9
05F30:  RLCF   xDE,W
05F32:  MOVWF  xEA
05F34:  RLCF   xE9,F
05F36:  RLCF   xEA,F
05F38:  MOVLW  FC
05F3A:  ANDWF  xE9,F
05F3C:  MOVLW  01
05F3E:  ANDWF  xEA,F
05F40:  MOVLW  24
05F42:  ADDWF  xE9,W
05F44:  MOVWF  01
05F46:  MOVLW  00
05F48:  ADDWFC xEA,W
05F4A:  MOVWF  03
05F4C:  MOVF   01,W
05F4E:  MOVLB  7
05F50:  ADDWF  x12,W
05F52:  MOVWF  01
05F54:  MOVF   x13,W
05F56:  ADDWFC 03,F
05F58:  MOVFF  01,FE9
05F5C:  MOVFF  03,FEA
05F60:  MOVFF  FEF,00
05F64:  MOVFF  FEC,01
05F68:  MOVFF  FEC,02
05F6C:  MOVFF  FEC,9EE
05F70:  MOVLB  9
05F72:  MOVF   xEE,W
05F74:  ANDLW  0F
05F76:  MOVWF  03
05F78:  BRA    5F88
05F7A:  MOVLB  0
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
05F7C:  MOVLW  01
05F7E:  MOVWF  00
05F80:  CLRF   01
05F82:  CLRF   02
05F84:  CLRF   03
05F86:  MOVLB  9
05F88:  MOVLB  0
05F8A:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
0654E:  MOVLW  10
06550:  MOVLB  7
06552:  ADDWF  x12,W
06554:  MOVWF  FE9
06556:  MOVLW  00
06558:  ADDWFC x13,W
0655A:  MOVWF  FEA
0655C:  MOVFF  FEF,9E9
06560:  MOVFF  FEC,9EA
06564:  MOVFF  FEC,9EB
06568:  MOVFF  FEC,9EC
....................    switch (fs->fs_type)  
0656C:  MOVF   x12,W
0656E:  MOVWF  FE9
06570:  MOVF   x13,W
06572:  MOVWF  FEA
06574:  MOVF   FEF,W
06576:  XORLW  01
06578:  MOVLB  0
0657A:  BZ    658A
0657C:  XORLW  03
0657E:  BTFSC  FD8.2
06580:  BRA    6762
06582:  XORLW  01
06584:  BTFSC  FD8.2
06586:  BRA    67E6
06588:  BRA    68AE
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
0658A:  MOVFF  9DE,9EE
0658E:  MOVFF  9DD,9ED
06592:  MOVLB  9
06594:  CLRF   xF0
06596:  MOVLW  03
06598:  MOVWF  xEF
0659A:  MOVLB  0
0659C:  CALL   5C32
065A0:  BCF    FD8.0
065A2:  MOVLB  9
065A4:  RRCF   02,W
065A6:  MOVWF  xE6
065A8:  RRCF   01,W
065AA:  MOVWF  xE5
....................          if (!move_window(fatsect + bc / 512)) 
065AC:  BCF    FD8.0
065AE:  CLRF   03
065B0:  RRCF   xE6,W
065B2:  MOVWF  02
065B4:  ADDWF  xE9,W
065B6:  MOVWF  xED
065B8:  MOVF   03,W
065BA:  ADDWFC xEA,W
065BC:  MOVWF  xEE
065BE:  MOVLW  00
065C0:  ADDWFC xEB,W
065C2:  MOVWF  xEF
065C4:  MOVLW  00
065C6:  ADDWFC xEC,W
065C8:  MOVWF  xF0
065CA:  MOVWF  xF4
065CC:  MOVFF  9EF,9F3
065D0:  MOVFF  9EE,9F2
065D4:  MOVFF  9ED,9F1
065D8:  MOVLB  0
065DA:  CALL   5A16
065DE:  MOVF   01,F
065E0:  BNZ   65E8
....................             return (FALSE); 
065E2:  MOVLW  00
065E4:  MOVWF  01
065E6:  BRA    68CC
....................          p = &fs->win[bc % 512]; 
065E8:  MOVLB  9
065EA:  MOVF   xE6,W
065EC:  ANDLW  01
065EE:  MOVWF  xEE
065F0:  MOVLW  24
065F2:  ADDWF  xE5,W
065F4:  MOVWF  01
065F6:  MOVLW  00
065F8:  ADDWFC xEE,W
065FA:  MOVWF  03
065FC:  MOVF   01,W
065FE:  MOVLB  7
06600:  ADDWF  x12,W
06602:  MOVWF  01
06604:  MOVF   x13,W
06606:  ADDWFC 03,F
06608:  MOVFF  01,9E7
0660C:  MOVLB  9
0660E:  MOVFF  03,9E8
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
06612:  MOVFF  9E7,9ED
06616:  MOVFF  9E8,9EE
0661A:  MOVF   xDD,W
0661C:  ANDLW  01
0661E:  MOVWF  00
06620:  CLRF   01
06622:  CLRF   02
06624:  CLRF   03
06626:  MOVF   00,F
06628:  BNZ   6636
0662A:  MOVF   01,F
0662C:  BNZ   6636
0662E:  MOVF   02,F
06630:  BNZ   6636
06632:  MOVF   03,F
06634:  BZ    6656
06636:  MOVFF  9E8,03
0663A:  MOVFF  9E7,FE9
0663E:  MOVFF  9E8,FEA
06642:  MOVF   FEF,W
06644:  ANDLW  0F
06646:  MOVWF  xEF
06648:  SWAPF  xE1,W
0664A:  MOVWF  00
0664C:  MOVLW  F0
0664E:  ANDWF  00,F
06650:  MOVF   00,W
06652:  IORWF  xEF,W
06654:  BRA    6658
06656:  MOVF   xE1,W
06658:  MOVFF  9EE,FEA
0665C:  MOVFF  9ED,FE9
06660:  MOVWF  FEF
....................          fs->winflag = 1; 
06662:  MOVLW  06
06664:  MOVLB  7
06666:  ADDWF  x12,W
06668:  MOVWF  FE9
0666A:  MOVLW  00
0666C:  ADDWFC x13,W
0666E:  MOVWF  FEA
06670:  MOVLW  01
06672:  MOVWF  FEF
....................          bc++; 
06674:  MOVLB  9
06676:  INCF   xE5,F
06678:  BTFSC  FD8.2
0667A:  INCF   xE6,F
....................          if (!move_window(fatsect + bc / 512)) 
0667C:  BCF    FD8.0
0667E:  CLRF   03
06680:  RRCF   xE6,W
06682:  MOVWF  02
06684:  ADDWF  xE9,W
06686:  MOVWF  xED
06688:  MOVF   03,W
0668A:  ADDWFC xEA,W
0668C:  MOVWF  xEE
0668E:  MOVLW  00
06690:  ADDWFC xEB,W
06692:  MOVWF  xEF
06694:  MOVLW  00
06696:  ADDWFC xEC,W
06698:  MOVWF  xF0
0669A:  MOVWF  xF4
0669C:  MOVFF  9EF,9F3
066A0:  MOVFF  9EE,9F2
066A4:  MOVFF  9ED,9F1
066A8:  MOVLB  0
066AA:  CALL   5A16
066AE:  MOVF   01,F
066B0:  BNZ   66B8
....................             return (FALSE); 
066B2:  MOVLW  00
066B4:  MOVWF  01
066B6:  BRA    68CC
....................          p = &fs->win[bc % 512]; 
066B8:  MOVLB  9
066BA:  MOVF   xE6,W
066BC:  ANDLW  01
066BE:  MOVWF  xEE
066C0:  MOVLW  24
066C2:  ADDWF  xE5,W
066C4:  MOVWF  01
066C6:  MOVLW  00
066C8:  ADDWFC xEE,W
066CA:  MOVWF  03
066CC:  MOVF   01,W
066CE:  MOVLB  7
066D0:  ADDWF  x12,W
066D2:  MOVWF  01
066D4:  MOVF   x13,W
066D6:  ADDWFC 03,F
066D8:  MOVFF  01,9E7
066DC:  MOVLB  9
066DE:  MOVFF  03,9E8
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
066E2:  MOVFF  9E7,9ED
066E6:  MOVFF  9E8,9EE
066EA:  MOVF   xDD,W
066EC:  ANDLW  01
066EE:  MOVWF  00
066F0:  CLRF   01
066F2:  CLRF   02
066F4:  CLRF   03
066F6:  MOVF   00,F
066F8:  BNZ   6706
066FA:  MOVF   01,F
066FC:  BNZ   6706
066FE:  MOVF   02,F
06700:  BNZ   6706
06702:  MOVF   03,F
06704:  BZ    6736
06706:  RRCF   xE4,W
06708:  MOVWF  03
0670A:  RRCF   xE3,W
0670C:  MOVWF  02
0670E:  RRCF   xE2,W
06710:  MOVWF  01
06712:  RRCF   xE1,W
06714:  MOVWF  00
06716:  RRCF   03,F
06718:  RRCF   02,F
0671A:  RRCF   01,F
0671C:  RRCF   00,F
0671E:  RRCF   03,F
06720:  RRCF   02,F
06722:  RRCF   01,F
06724:  RRCF   00,F
06726:  RRCF   03,F
06728:  RRCF   02,F
0672A:  RRCF   01,F
0672C:  RRCF   00,F
0672E:  MOVLW  0F
06730:  ANDWF  03,F
06732:  MOVF   00,W
06734:  BRA    6756
06736:  MOVFF  9E7,FE9
0673A:  MOVFF  9E8,FEA
0673E:  MOVF   FEF,W
06740:  ANDLW  F0
06742:  MOVWF  xF0
06744:  MOVFF  9E2,00
06748:  MOVFF  9E3,01
0674C:  MOVFF  9E4,02
06750:  MOVF   xE2,W
06752:  ANDLW  0F
06754:  IORWF  xF0,W
06756:  MOVFF  9EE,FEA
0675A:  MOVFF  9ED,FE9
0675E:  MOVWF  FEF
....................          break; 
06760:  BRA    68B6
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
06762:  MOVFF  9DE,00
06766:  MOVFF  9DF,01
0676A:  MOVFF  9E0,02
0676E:  CLRF   03
06770:  MOVF   00,W
06772:  MOVLB  9
06774:  ADDWF  xE9,W
06776:  MOVWF  xED
06778:  MOVF   xDF,W
0677A:  ADDWFC xEA,W
0677C:  MOVWF  xEE
0677E:  MOVF   xE0,W
06780:  ADDWFC xEB,W
06782:  MOVWF  xEF
06784:  MOVF   03,W
06786:  ADDWFC xEC,W
06788:  MOVWF  xF0
0678A:  MOVWF  xF4
0678C:  MOVFF  9EF,9F3
06790:  MOVFF  9EE,9F2
06794:  MOVFF  9ED,9F1
06798:  MOVLB  0
0679A:  CALL   5A16
0679E:  MOVF   01,F
067A0:  BNZ   67A8
....................             return (FALSE); 
067A2:  MOVLW  00
067A4:  MOVWF  01
067A6:  BRA    68CC
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
067A8:  BCF    FD8.0
067AA:  MOVLB  9
067AC:  RLCF   xDD,W
067AE:  MOVWF  xED
067B0:  RLCF   xDE,W
067B2:  MOVWF  xEE
067B4:  MOVLW  01
067B6:  ANDWF  xEE,F
067B8:  MOVLW  24
067BA:  ADDWF  xED,W
067BC:  MOVWF  01
067BE:  MOVLW  00
067C0:  ADDWFC xEE,W
067C2:  MOVWF  03
067C4:  MOVF   01,W
067C6:  MOVLB  7
067C8:  ADDWF  x12,W
067CA:  MOVWF  01
067CC:  MOVF   x13,W
067CE:  ADDWFC 03,F
067D0:  MOVFF  01,FE9
067D4:  MOVFF  03,FEA
067D8:  MOVFF  9E2,FEC
067DC:  MOVF   FED,F
067DE:  MOVFF  9E1,FEF
....................          break; 
067E2:  MOVLB  9
067E4:  BRA    68B6
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
067E6:  MOVLB  9
067E8:  RRCF   xE0,W
067EA:  MOVWF  03
067EC:  RRCF   xDF,W
067EE:  MOVWF  02
067F0:  RRCF   xDE,W
067F2:  MOVWF  01
067F4:  RRCF   xDD,W
067F6:  MOVWF  00
067F8:  RRCF   03,F
067FA:  RRCF   02,F
067FC:  RRCF   01,F
067FE:  RRCF   00,F
06800:  RRCF   03,F
06802:  RRCF   02,F
06804:  RRCF   01,F
06806:  RRCF   00,F
06808:  RRCF   03,F
0680A:  RRCF   02,F
0680C:  RRCF   01,F
0680E:  RRCF   00,F
06810:  RRCF   03,F
06812:  RRCF   02,F
06814:  RRCF   01,F
06816:  RRCF   00,F
06818:  RRCF   03,F
0681A:  RRCF   02,F
0681C:  RRCF   01,F
0681E:  RRCF   00,F
06820:  RRCF   03,F
06822:  RRCF   02,F
06824:  RRCF   01,F
06826:  RRCF   00,F
06828:  MOVLW  01
0682A:  ANDWF  03,F
0682C:  MOVF   00,W
0682E:  ADDWF  xE9,W
06830:  MOVWF  xED
06832:  MOVF   01,W
06834:  ADDWFC xEA,W
06836:  MOVWF  xEE
06838:  MOVF   02,W
0683A:  ADDWFC xEB,W
0683C:  MOVWF  xEF
0683E:  MOVF   03,W
06840:  ADDWFC xEC,W
06842:  MOVWF  xF0
06844:  MOVWF  xF4
06846:  MOVFF  9EF,9F3
0684A:  MOVFF  9EE,9F2
0684E:  MOVFF  9ED,9F1
06852:  MOVLB  0
06854:  CALL   5A16
06858:  MOVF   01,F
0685A:  BNZ   6862
....................             return (FALSE); 
0685C:  MOVLW  00
0685E:  MOVWF  01
06860:  BRA    68CC
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
06862:  MOVLB  9
06864:  RLCF   xDD,W
06866:  MOVWF  xED
06868:  RLCF   xDE,W
0686A:  MOVWF  xEE
0686C:  RLCF   xED,F
0686E:  RLCF   xEE,F
06870:  MOVLW  FC
06872:  ANDWF  xED,F
06874:  MOVLW  01
06876:  ANDWF  xEE,F
06878:  MOVLW  24
0687A:  ADDWF  xED,W
0687C:  MOVWF  01
0687E:  MOVLW  00
06880:  ADDWFC xEE,W
06882:  MOVWF  03
06884:  MOVF   01,W
06886:  MOVLB  7
06888:  ADDWF  x12,W
0688A:  MOVWF  01
0688C:  MOVF   x13,W
0688E:  ADDWFC 03,F
06890:  MOVFF  01,FE9
06894:  MOVFF  03,FEA
06898:  MOVFF  9E1,FEF
0689C:  MOVFF  9E2,FEC
068A0:  MOVFF  9E3,FEC
068A4:  MOVFF  9E4,FEC
....................          break; 
068A8:  MOVLB  9
068AA:  BRA    68B6
068AC:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
068AE:  MOVLW  00
068B0:  MOVWF  01
068B2:  BRA    68CC
068B4:  MOVLB  9
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
068B6:  MOVLW  06
068B8:  MOVLB  7
068BA:  ADDWF  x12,W
068BC:  MOVWF  FE9
068BE:  MOVLW  00
068C0:  ADDWFC x13,W
068C2:  MOVWF  FEA
068C4:  MOVLW  01
068C6:  MOVWF  FEF
....................    return (TRUE); 
068C8:  MOVWF  01
068CA:  MOVLB  0
068CC:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06EAA:  MOVFF  9BF,9E0
06EAE:  MOVFF  9BE,9DF
06EB2:  MOVFF  9BD,9DE
06EB6:  MOVFF  9BC,9DD
06EBA:  CALL   5C54
06EBE:  MOVFF  03,9C3
06EC2:  MOVFF  02,9C2
06EC6:  MOVFF  01,9C1
06ECA:  MOVFF  00,9C0
06ECE:  MOVLB  9
06ED0:  MOVF   xC3,F
06ED2:  BNZ   6EE2
06ED4:  MOVF   xC2,F
06ED6:  BNZ   6EE2
06ED8:  MOVF   xC1,F
06EDA:  BNZ   6EE2
06EDC:  MOVF   xC0,W
06EDE:  SUBLW  01
06EE0:  BC    6F42
....................       { 
....................       if (!put_cluster(clust, 0)) 
06EE2:  MOVFF  9BF,9E0
06EE6:  MOVFF  9BE,9DF
06EEA:  MOVFF  9BD,9DE
06EEE:  MOVFF  9BC,9DD
06EF2:  CLRF   xE4
06EF4:  CLRF   xE3
06EF6:  CLRF   xE2
06EF8:  CLRF   xE1
06EFA:  MOVLB  0
06EFC:  CALL   654E
06F00:  MOVF   01,F
06F02:  BNZ   6F0A
....................          return FALSE; 
06F04:  MOVLW  00
06F06:  MOVWF  01
06F08:  BRA    6F48
....................       clust = nxt; 
06F0A:  MOVFF  9C3,9BF
06F0E:  MOVFF  9C2,9BE
06F12:  MOVFF  9C1,9BD
06F16:  MOVFF  9C0,9BC
06F1A:  MOVFF  9BF,9E0
06F1E:  MOVFF  9BE,9DF
06F22:  MOVFF  9BD,9DE
06F26:  MOVFF  9BC,9DD
06F2A:  CALL   5C54
06F2E:  MOVFF  03,9C3
06F32:  MOVFF  02,9C2
06F36:  MOVFF  01,9C1
06F3A:  MOVFF  00,9C0
06F3E:  BRA    6ECE
06F40:  MOVLB  9
....................       } 
....................    return TRUE; 
06F42:  MOVLW  01
06F44:  MOVWF  01
06F46:  MOVLB  0
06F48:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
068CE:  MOVLW  0C
068D0:  MOVLB  7
068D2:  ADDWF  x12,W
068D4:  MOVWF  FE9
068D6:  MOVLW  00
068D8:  ADDWFC x13,W
068DA:  MOVWF  FEA
068DC:  MOVFF  FEF,9D9
068E0:  MOVFF  FEC,9DA
068E4:  MOVFF  FEC,9DB
068E8:  MOVFF  FEC,9DC
....................    if (clust == 0)  
068EC:  MOVLB  9
068EE:  MOVF   xC9,F
068F0:  BNZ   695A
068F2:  MOVF   xCA,F
068F4:  BNZ   695A
068F6:  MOVF   xCB,F
068F8:  BNZ   695A
068FA:  MOVF   xCC,F
068FC:  BNZ   695A
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
068FE:  MOVLW  1C
06900:  MOVLB  7
06902:  ADDWF  x12,W
06904:  MOVWF  FE9
06906:  MOVLW  00
06908:  ADDWFC x13,W
0690A:  MOVWF  FEA
0690C:  MOVFF  FEF,9D5
06910:  MOVFF  FEC,9D6
06914:  MOVFF  FEC,9D7
06918:  MOVFF  FEC,9D8
....................       if (scl < 2 || scl >= mcl) scl = 1; 
0691C:  MOVLB  9
0691E:  MOVF   xD8,F
06920:  BNZ   6930
06922:  MOVF   xD7,F
06924:  BNZ   6930
06926:  MOVF   xD6,F
06928:  BNZ   6930
0692A:  MOVF   xD5,W
0692C:  SUBLW  01
0692E:  BC    694E
06930:  MOVF   xDC,W
06932:  SUBWF  xD8,W
06934:  BNC   6958
06936:  BNZ   694E
06938:  MOVF   xDB,W
0693A:  SUBWF  xD7,W
0693C:  BNC   6958
0693E:  BNZ   694E
06940:  MOVF   xDA,W
06942:  SUBWF  xD6,W
06944:  BNC   6958
06946:  BNZ   694E
06948:  MOVF   xD9,W
0694A:  SUBWF  xD5,W
0694C:  BNC   6958
0694E:  CLRF   xD8
06950:  CLRF   xD7
06952:  CLRF   xD6
06954:  MOVLW  01
06956:  MOVWF  xD5
....................       } 
06958:  BRA    69DE
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
0695A:  MOVFF  9CC,9E0
0695E:  MOVFF  9CB,9DF
06962:  MOVFF  9CA,9DE
06966:  MOVFF  9C9,9DD
0696A:  MOVLB  0
0696C:  CALL   5C54
06970:  MOVFF  03,9D0
06974:  MOVFF  02,9CF
06978:  MOVFF  01,9CE
0697C:  MOVFF  00,9CD
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
06980:  MOVLB  9
06982:  MOVF   xD0,F
06984:  BNZ   699E
06986:  MOVF   xCF,F
06988:  BNZ   699E
0698A:  MOVF   xCE,F
0698C:  BNZ   699E
0698E:  MOVF   xCD,W
06990:  SUBLW  01
06992:  BNC   699E
06994:  CLRF   00
06996:  CLRF   01
06998:  CLRF   02
0699A:  CLRF   03
0699C:  BRA    6B60
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
0699E:  MOVF   xD0,W
069A0:  SUBWF  xDC,W
069A2:  BNC   69CE
069A4:  BNZ   69BC
069A6:  MOVF   xCF,W
069A8:  SUBWF  xDB,W
069AA:  BNC   69CE
069AC:  BNZ   69BC
069AE:  MOVF   xCE,W
069B0:  SUBWF  xDA,W
069B2:  BNC   69CE
069B4:  BNZ   69BC
069B6:  MOVF   xD9,W
069B8:  SUBWF  xCD,W
069BA:  BC    69CE
069BC:  MOVFF  9CD,00
069C0:  MOVFF  9CE,01
069C4:  MOVFF  9CF,02
069C8:  MOVFF  9D0,03
069CC:  BRA    6B60
....................       scl = clust; 
069CE:  MOVFF  9CC,9D8
069D2:  MOVFF  9CB,9D7
069D6:  MOVFF  9CA,9D6
069DA:  MOVFF  9C9,9D5
....................       } 
....................       ncl = scl;                  // Scan start cluster 
069DE:  MOVFF  9D8,9D4
069E2:  MOVFF  9D7,9D3
069E6:  MOVFF  9D6,9D2
069EA:  MOVFF  9D5,9D1
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
069EE:  MOVLW  01
069F0:  ADDWF  xD1,F
069F2:  BTFSC  FD8.0
069F4:  INCF   xD2,F
069F6:  BTFSC  FD8.2
069F8:  INCF   xD3,F
069FA:  BTFSC  FD8.2
069FC:  INCF   xD4,F
....................       if (ncl >= mcl)  
069FE:  MOVF   xDC,W
06A00:  SUBWF  xD4,W
06A02:  BNC   6A40
06A04:  BNZ   6A1C
06A06:  MOVF   xDB,W
06A08:  SUBWF  xD3,W
06A0A:  BNC   6A40
06A0C:  BNZ   6A1C
06A0E:  MOVF   xDA,W
06A10:  SUBWF  xD2,W
06A12:  BNC   6A40
06A14:  BNZ   6A1C
06A16:  MOVF   xD9,W
06A18:  SUBWF  xD1,W
06A1A:  BNC   6A40
....................          {         // Wrap around 
....................          ncl = 2; 
06A1C:  CLRF   xD4
06A1E:  CLRF   xD3
06A20:  CLRF   xD2
06A22:  MOVLW  02
06A24:  MOVWF  xD1
....................          if (scl == 1) return 0;      // No free custer was found 
06A26:  DECFSZ xD5,W
06A28:  BRA    6A40
06A2A:  MOVF   xD6,F
06A2C:  BNZ   6A40
06A2E:  MOVF   xD7,F
06A30:  BNZ   6A40
06A32:  MOVF   xD8,F
06A34:  BNZ   6A40
06A36:  CLRF   00
06A38:  CLRF   01
06A3A:  CLRF   02
06A3C:  CLRF   03
06A3E:  BRA    6B60
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06A40:  MOVF   xD5,W
06A42:  SUBWF  xD1,W
06A44:  BNZ   6A62
06A46:  MOVF   xD6,W
06A48:  SUBWF  xD2,W
06A4A:  BNZ   6A62
06A4C:  MOVF   xD7,W
06A4E:  SUBWF  xD3,W
06A50:  BNZ   6A62
06A52:  MOVF   xD8,W
06A54:  SUBWF  xD4,W
06A56:  BNZ   6A62
06A58:  CLRF   00
06A5A:  CLRF   01
06A5C:  CLRF   02
06A5E:  CLRF   03
06A60:  BRA    6B60
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06A62:  MOVFF  9D4,9E0
06A66:  MOVFF  9D3,9DF
06A6A:  MOVFF  9D2,9DE
06A6E:  MOVFF  9D1,9DD
06A72:  MOVLB  0
06A74:  CALL   5C54
06A78:  MOVFF  03,9D0
06A7C:  MOVFF  02,9CF
06A80:  MOVFF  01,9CE
06A84:  MOVFF  00,9CD
....................       if (cstat == 1) return 0;      // Any error occured 
06A88:  MOVLB  9
06A8A:  DECFSZ xCD,W
06A8C:  BRA    6AA4
06A8E:  MOVF   xCE,F
06A90:  BNZ   6AA4
06A92:  MOVF   xCF,F
06A94:  BNZ   6AA4
06A96:  MOVF   xD0,F
06A98:  BNZ   6AA4
06A9A:  CLRF   00
06A9C:  CLRF   01
06A9E:  CLRF   02
06AA0:  CLRF   03
06AA2:  BRA    6B60
....................       } while (cstat);            // Repeat until find a free cluster 
06AA4:  MOVF   xCD,F
06AA6:  BNZ   69EE
06AA8:  MOVF   xCE,F
06AAA:  BNZ   69EE
06AAC:  MOVF   xCF,F
06AAE:  BNZ   69EE
06AB0:  MOVF   xD0,F
06AB2:  BNZ   69EE
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06AB4:  MOVFF  9D4,9E0
06AB8:  MOVFF  9D3,9DF
06ABC:  MOVFF  9D2,9DE
06AC0:  MOVFF  9D1,9DD
06AC4:  MOVLW  0F
06AC6:  MOVWF  xE4
06AC8:  SETF   xE3
06ACA:  SETF   xE2
06ACC:  SETF   xE1
06ACE:  MOVLB  0
06AD0:  RCALL  654E
06AD2:  MOVF   01,F
06AD4:  BNZ   6AE4
06AD6:  CLRF   00
06AD8:  CLRF   01
06ADA:  CLRF   02
06ADC:  CLRF   03
06ADE:  MOVLB  9
06AE0:  BRA    6B60
06AE2:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06AE4:  MOVLB  9
06AE6:  MOVF   xC9,F
06AE8:  BNZ   6AF6
06AEA:  MOVF   xCA,F
06AEC:  BNZ   6AF6
06AEE:  MOVF   xCB,F
06AF0:  BNZ   6AF6
06AF2:  MOVF   xCC,F
06AF4:  BZ    6B30
06AF6:  MOVFF  9CC,9E0
06AFA:  MOVFF  9CB,9DF
06AFE:  MOVFF  9CA,9DE
06B02:  MOVFF  9C9,9DD
06B06:  MOVFF  9D4,9E4
06B0A:  MOVFF  9D3,9E3
06B0E:  MOVFF  9D2,9E2
06B12:  MOVFF  9D1,9E1
06B16:  MOVLB  0
06B18:  RCALL  654E
06B1A:  MOVF   01,F
06B1C:  BTFSC  FD8.2
06B1E:  BRA    6B24
06B20:  MOVLB  9
06B22:  BRA    6B30
06B24:  CLRF   00
06B26:  CLRF   01
06B28:  CLRF   02
06B2A:  CLRF   03
06B2C:  MOVLB  9
06B2E:  BRA    6B60
....................    fs->last_clust = ncl; 
06B30:  MOVLW  1C
06B32:  MOVLB  7
06B34:  ADDWF  x12,W
06B36:  MOVWF  FE9
06B38:  MOVLW  00
06B3A:  ADDWFC x13,W
06B3C:  MOVWF  FEA
06B3E:  MOVFF  9D1,FEF
06B42:  MOVFF  9D2,FEC
06B46:  MOVFF  9D3,FEC
06B4A:  MOVFF  9D4,FEC
....................  
....................    return ncl;      // Return new cluster number 
06B4E:  MOVFF  9D1,00
06B52:  MOVFF  9D2,01
06B56:  MOVFF  9D3,02
06B5A:  MOVFF  9D4,03
06B5E:  MOVLB  9
06B60:  MOVLB  0
06B62:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
0559E:  MOVLW  02
055A0:  MOVLB  9
055A2:  SUBWF  xD0,F
055A4:  MOVLW  00
055A6:  SUBWFB xD1,F
055A8:  SUBWFB xD2,F
055AA:  SUBWFB xD3,F
....................    if (clust >= fs->max_clust)  
055AC:  MOVLW  0C
055AE:  MOVLB  7
055B0:  ADDWF  x12,W
055B2:  MOVWF  FE9
055B4:  MOVLW  00
055B6:  ADDWFC x13,W
055B8:  MOVWF  FEA
055BA:  MOVFF  FEF,00
055BE:  MOVFF  FEC,01
055C2:  MOVFF  FEC,02
055C6:  MOVFF  FEC,03
055CA:  MOVF   03,W
055CC:  MOVLB  9
055CE:  SUBWF  xD3,W
055D0:  BNC   55F4
055D2:  BNZ   55EA
055D4:  MOVF   02,W
055D6:  SUBWF  xD2,W
055D8:  BNC   55F4
055DA:  BNZ   55EA
055DC:  MOVF   01,W
055DE:  SUBWF  xD1,W
055E0:  BNC   55F4
055E2:  BNZ   55EA
055E4:  MOVF   00,W
055E6:  SUBWF  xD0,W
055E8:  BNC   55F4
....................       return 0;      // Invalid cluster#  
055EA:  CLRF   00
055EC:  CLRF   01
055EE:  CLRF   02
055F0:  CLRF   03
055F2:  BRA    5674
....................    return (clust * fs->sects_clust + fs->database); 
055F4:  MOVLW  02
055F6:  MOVLB  7
055F8:  ADDWF  x12,W
055FA:  MOVWF  FE9
055FC:  MOVLW  00
055FE:  ADDWFC x13,W
05600:  MOVWF  FEA
05602:  MOVFF  FEF,9DB
05606:  MOVLB  9
05608:  MOVFF  FEA,9D6
0560C:  MOVFF  FE9,9D5
05610:  MOVFF  9D3,9DA
05614:  MOVFF  9D2,9D9
05618:  MOVFF  9D1,9D8
0561C:  MOVFF  9D0,9D7
05620:  CLRF   xDE
05622:  CLRF   xDD
05624:  CLRF   xDC
05626:  MOVLB  0
05628:  CALL   478E
0562C:  MOVFF  9D6,FEA
05630:  MOVFF  9D5,FE9
05634:  MOVFF  03,9D7
05638:  MOVFF  02,9D6
0563C:  MOVFF  01,9D5
05640:  MOVFF  00,9D4
05644:  MOVLW  18
05646:  MOVLB  7
05648:  ADDWF  x12,W
0564A:  MOVWF  FE9
0564C:  MOVLW  00
0564E:  ADDWFC x13,W
05650:  MOVWF  FEA
05652:  MOVFF  FEF,00
05656:  MOVFF  FEC,01
0565A:  MOVFF  FEC,02
0565E:  MOVFF  FEC,03
05662:  MOVLB  9
05664:  MOVF   xD4,W
05666:  ADDWF  00,F
05668:  MOVF   xD5,W
0566A:  ADDWFC 01,F
0566C:  MOVF   xD6,W
0566E:  ADDWFC 02,F
05670:  MOVF   xD7,W
05672:  ADDWFC 03,F
05674:  MOVLB  0
05676:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
04630:  MOVLW  24
04632:  MOVLB  7
04634:  ADDWF  x12,W
04636:  MOVWF  01
04638:  MOVLW  00
0463A:  ADDWFC x13,W
0463C:  MOVWF  03
0463E:  MOVFF  01,9C8
04642:  MOVLB  9
04644:  MOVWF  xC9
04646:  MOVWF  FEA
04648:  MOVFF  01,FE9
0464C:  CLRF   00
0464E:  MOVLW  02
04650:  MOVWF  02
04652:  CLRF   01
04654:  MOVLB  0
04656:  CALL   34C2
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
0465A:  MOVLW  24
0465C:  MOVLB  7
0465E:  ADDWF  x12,W
04660:  MOVWF  01
04662:  MOVLW  00
04664:  ADDWFC x13,W
04666:  MOVWF  03
04668:  MOVFF  01,9C8
0466C:  MOVLB  9
0466E:  MOVWF  xC9
04670:  MOVWF  xFE
04672:  MOVFF  01,9FD
04676:  MOVFF  9C7,A02
0467A:  MOVFF  9C6,A01
0467E:  MOVFF  9C5,A00
04682:  MOVFF  9C4,9FF
04686:  MOVLW  01
04688:  MOVLB  A
0468A:  MOVWF  x03
0468C:  MOVLB  0
0468E:  RCALL  4468
04690:  MOVF   01,F
04692:  BTFSS  FD8.2
04694:  BRA    4784
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
04696:  MOVLW  22
04698:  MOVLB  7
0469A:  ADDWF  x12,W
0469C:  MOVWF  01
0469E:  MOVLW  02
046A0:  ADDWFC x13,W
046A2:  MOVWF  03
046A4:  MOVFF  01,FE9
046A8:  MOVWF  FEA
046AA:  MOVFF  FEC,9C9
046AE:  MOVF   FED,F
046B0:  MOVFF  FEF,9C8
046B4:  MOVLB  9
046B6:  MOVF   xC8,W
046B8:  SUBLW  55
046BA:  BNZ   4786
046BC:  MOVF   xC9,W
046BE:  SUBLW  AA
046C0:  BNZ   4786
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
046C2:  MOVLW  5A
046C4:  MOVLB  7
046C6:  ADDWF  x12,W
046C8:  MOVWF  01
046CA:  MOVLW  00
046CC:  ADDWFC x13,W
046CE:  MOVWF  03
046D0:  MOVFF  01,9C8
046D4:  MOVLB  9
046D6:  MOVWF  xC9
046D8:  MOVWF  xCB
046DA:  MOVFF  01,9CA
046DE:  MOVLW  07
046E0:  MOVWF  xCD
046E2:  MOVLW  14
046E4:  MOVWF  xCC
046E6:  CLRF   xCF
046E8:  MOVLW  05
046EA:  MOVWF  xCE
046EC:  MOVLB  0
046EE:  RCALL  45AC
046F0:  MOVF   01,F
046F2:  BNZ   46FA
....................             return (FS_FAT12); 
046F4:  MOVLW  01
046F6:  MOVWF  01
046F8:  BRA    478C
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
046FA:  MOVLW  5A
046FC:  MOVLB  7
046FE:  ADDWF  x12,W
04700:  MOVWF  01
04702:  MOVLW  00
04704:  ADDWFC x13,W
04706:  MOVWF  03
04708:  MOVFF  01,9C8
0470C:  MOVLB  9
0470E:  MOVWF  xC9
04710:  MOVWF  xCB
04712:  MOVFF  01,9CA
04716:  MOVLW  07
04718:  MOVWF  xCD
0471A:  MOVLW  19
0471C:  MOVWF  xCC
0471E:  CLRF   xCF
04720:  MOVLW  05
04722:  MOVWF  xCE
04724:  MOVLB  0
04726:  RCALL  45AC
04728:  MOVF   01,F
0472A:  BNZ   4732
....................             return (FS_FAT16); 
0472C:  MOVLW  02
0472E:  MOVWF  01
04730:  BRA    478C
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
04732:  MOVLW  76
04734:  MOVLB  7
04736:  ADDWF  x12,W
04738:  MOVWF  01
0473A:  MOVLW  00
0473C:  ADDWFC x13,W
0473E:  MOVWF  03
04740:  MOVFF  01,9C8
04744:  MOVLB  9
04746:  MOVWF  xC9
04748:  MOVWF  xCB
0474A:  MOVFF  01,9CA
0474E:  MOVLW  07
04750:  MOVWF  xCD
04752:  MOVLW  1E
04754:  MOVWF  xCC
04756:  CLRF   xCF
04758:  MOVLW  05
0475A:  MOVWF  xCE
0475C:  MOVLB  0
0475E:  RCALL  45AC
04760:  MOVF   01,F
04762:  BNZ   4784
04764:  MOVLW  4C
04766:  MOVLB  7
04768:  ADDWF  x12,W
0476A:  MOVWF  FE9
0476C:  MOVLW  00
0476E:  ADDWFC x13,W
04770:  MOVWF  FEA
04772:  MOVF   FEF,F
04774:  BTFSC  FD8.2
04776:  BRA    477C
04778:  MOVLB  0
0477A:  BRA    4784
....................             return (FS_FAT32); 
0477C:  MOVLW  03
0477E:  MOVWF  01
04780:  MOVLB  0
04782:  BRA    478C
04784:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
04786:  MOVLW  00
04788:  MOVWF  01
0478A:  MOVLB  0
0478C:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
05F8C:  MOVLW  0C
05F8E:  MOVLB  9
05F90:  ADDWF  xC6,W
05F92:  MOVWF  FE9
05F94:  MOVLW  00
05F96:  ADDWFC xC7,W
05F98:  MOVWF  FEA
05F9A:  MOVFF  FEC,9CF
05F9E:  MOVF   FED,F
05FA0:  MOVFF  FEF,9CE
05FA4:  MOVLW  01
05FA6:  ADDWF  xCE,W
05FA8:  MOVWF  xCC
05FAA:  MOVLW  00
05FAC:  ADDWFC xCF,W
05FAE:  MOVWF  xCD
....................    if ((idx & 15) == 0)  
05FB0:  MOVF   xCC,W
05FB2:  ANDLW  0F
05FB4:  MOVWF  xCE
05FB6:  CLRF   xCF
05FB8:  MOVF   xCE,F
05FBA:  BTFSS  FD8.2
05FBC:  BRA    6148
05FBE:  MOVF   xCF,F
05FC0:  BTFSS  FD8.2
05FC2:  BRA    6148
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
05FC4:  MOVLW  08
05FC6:  ADDWF  xC6,W
05FC8:  MOVWF  FE9
05FCA:  MOVLW  00
05FCC:  ADDWFC xC7,W
05FCE:  MOVWF  FEA
05FD0:  MOVLW  01
05FD2:  ADDWF  FEE,F
05FD4:  MOVLW  00
05FD6:  ADDWFC FEE,F
05FD8:  ADDWFC FEE,F
05FDA:  ADDWFC FED,F
....................       if (!scan->clust)  
05FDC:  MOVLW  04
05FDE:  ADDWF  xC6,W
05FE0:  MOVWF  FE9
05FE2:  MOVLW  00
05FE4:  ADDWFC xC7,W
05FE6:  MOVWF  FEA
05FE8:  MOVF   FEF,F
05FEA:  BNZ   6028
05FEC:  MOVF   FEC,F
05FEE:  BNZ   6028
05FF0:  MOVF   FEC,F
05FF2:  BNZ   6028
05FF4:  MOVF   FEC,F
05FF6:  BNZ   6028
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
05FF8:  MOVLW  04
05FFA:  MOVLB  7
05FFC:  ADDWF  x12,W
05FFE:  MOVWF  FE9
06000:  MOVLW  00
06002:  ADDWFC x13,W
06004:  MOVWF  FEA
06006:  MOVFF  FEC,03
0600A:  MOVF   FED,F
0600C:  MOVFF  FEF,01
06010:  MOVF   03,W
06012:  MOVLB  9
06014:  SUBWF  xCD,W
06016:  BNC   6026
06018:  BNZ   6020
0601A:  MOVF   01,W
0601C:  SUBWF  xCC,W
0601E:  BNC   6026
....................             return (FALSE);   // Reached to end of table  
06020:  MOVLW  00
06022:  MOVWF  01
06024:  BRA    6162
....................          }  
06026:  BRA    6148
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
06028:  RRCF   xCD,W
0602A:  MOVWF  xCF
0602C:  RRCF   xCC,W
0602E:  MOVWF  xCE
06030:  RRCF   xCF,F
06032:  RRCF   xCE,F
06034:  RRCF   xCF,F
06036:  RRCF   xCE,F
06038:  RRCF   xCF,F
0603A:  RRCF   xCE,F
0603C:  MOVLW  0F
0603E:  ANDWF  xCF,F
06040:  MOVLW  02
06042:  MOVLB  7
06044:  ADDWF  x12,W
06046:  MOVWF  FE9
06048:  MOVLW  00
0604A:  ADDWFC x13,W
0604C:  MOVWF  FEA
0604E:  MOVLW  01
06050:  SUBWF  FEF,W
06052:  MOVLB  9
06054:  ANDWF  xCE,F
06056:  CLRF   xCF
06058:  MOVF   xCE,F
0605A:  BTFSS  FD8.2
0605C:  BRA    6148
0605E:  MOVF   xCF,F
06060:  BTFSS  FD8.2
06062:  BRA    6148
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
06064:  MOVLW  04
06066:  ADDWF  xC6,W
06068:  MOVWF  FE9
0606A:  MOVLW  00
0606C:  ADDWFC xC7,W
0606E:  MOVWF  FEA
06070:  MOVFF  FEF,9DD
06074:  MOVFF  FEC,9DE
06078:  MOVFF  FEC,9DF
0607C:  MOVFF  FEC,9E0
06080:  MOVLB  0
06082:  RCALL  5C54
06084:  MOVFF  03,9CB
06088:  MOVFF  02,9CA
0608C:  MOVFF  01,9C9
06090:  MOVFF  00,9C8
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
06094:  MOVLW  0C
06096:  MOVLB  7
06098:  ADDWF  x12,W
0609A:  MOVWF  FE9
0609C:  MOVLW  00
0609E:  ADDWFC x13,W
060A0:  MOVWF  FEA
060A2:  MOVFF  FEF,00
060A6:  MOVFF  FEC,01
060AA:  MOVFF  FEC,02
060AE:  MOVFF  FEC,03
060B2:  MOVF   03,W
060B4:  MOVLB  9
060B6:  SUBWF  xCB,W
060B8:  BNC   60D2
060BA:  BNZ   60E4
060BC:  MOVF   02,W
060BE:  SUBWF  xCA,W
060C0:  BNC   60D2
060C2:  BNZ   60E4
060C4:  MOVF   01,W
060C6:  SUBWF  xC9,W
060C8:  BNC   60D2
060CA:  BNZ   60E4
060CC:  MOVF   00,W
060CE:  SUBWF  xC8,W
060D0:  BC    60E4
060D2:  MOVF   xCB,F
060D4:  BNZ   60EA
060D6:  MOVF   xCA,F
060D8:  BNZ   60EA
060DA:  MOVF   xC9,F
060DC:  BNZ   60EA
060DE:  MOVF   xC8,W
060E0:  SUBLW  01
060E2:  BNC   60EA
....................                return (FALSE); 
060E4:  MOVLW  00
060E6:  MOVWF  01
060E8:  BRA    6162
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
060EA:  MOVLW  04
060EC:  ADDWF  xC6,W
060EE:  MOVWF  FE9
060F0:  MOVLW  00
060F2:  ADDWFC xC7,W
060F4:  MOVWF  FEA
060F6:  MOVFF  9C8,FEF
060FA:  MOVFF  9C9,FEC
060FE:  MOVFF  9CA,FEC
06102:  MOVFF  9CB,FEC
....................             scan->sect = clust2sect(clust); 
06106:  MOVLW  08
06108:  ADDWF  xC6,W
0610A:  MOVWF  01
0610C:  MOVLW  00
0610E:  ADDWFC xC7,W
06110:  MOVWF  03
06112:  MOVFF  01,9CE
06116:  MOVWF  xCF
06118:  MOVFF  9CB,9D3
0611C:  MOVFF  9CA,9D2
06120:  MOVFF  9C9,9D1
06124:  MOVFF  9C8,9D0
06128:  MOVLB  0
0612A:  CALL   559E
0612E:  MOVFF  9CF,FEA
06132:  MOVFF  9CE,FE9
06136:  MOVFF  00,FEF
0613A:  MOVFF  01,FEC
0613E:  MOVFF  02,FEC
06142:  MOVFF  03,FEC
06146:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
06148:  MOVLW  0C
0614A:  ADDWF  xC6,W
0614C:  MOVWF  FE9
0614E:  MOVLW  00
06150:  ADDWFC xC7,W
06152:  MOVWF  FEA
06154:  MOVFF  9CD,FEC
06158:  MOVF   FED,F
0615A:  MOVFF  9CC,FEF
....................    return (TRUE); 
0615E:  MOVLW  01
06160:  MOVWF  01
06162:  MOVLB  0
06164:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
05678:  MOVFF  9C9,FEA
0567C:  MOVFF  9C8,FE9
05680:  MOVLW  20
05682:  MOVWF  00
05684:  CLRF   02
05686:  MOVLW  0B
05688:  MOVWF  01
0568A:  CALL   34C2
....................    a = 0; b = 0x18;            // NT flag 
0568E:  MOVLB  9
05690:  CLRF   xCD
05692:  MOVLW  18
05694:  MOVWF  xCE
....................    n = 0; t = 8; 
05696:  CLRF   xCA
05698:  MOVLW  08
0569A:  MOVWF  xCB
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
0569C:  MOVFF  9C6,FE9
056A0:  MOVFF  9C7,FEA
056A4:  MOVFF  FEC,9D0
056A8:  MOVF   FED,F
056AA:  MOVFF  FEF,9CF
....................       c = *ptr; 
056AE:  MOVFF  9CF,FE9
056B2:  MOVFF  9D0,FEA
056B6:  MOVFF  FEF,9CC
....................       (*path)++; 
056BA:  MOVFF  9C7,03
056BE:  MOVFF  9C6,FE9
056C2:  MOVFF  9C7,FEA
056C6:  MOVLW  01
056C8:  ADDWF  FEE,F
056CA:  BNC   56CE
056CC:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
056CE:  MOVF   xCC,W
056D0:  SUBLW  20
056D2:  BNC   56D6
....................          c = 0; 
056D4:  CLRF   xCC
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
056D6:  MOVF   xCC,F
056D8:  BZ    56E6
056DA:  MOVF   xCC,W
056DC:  SUBLW  2F
056DE:  BZ    56E6
056E0:  MOVF   xCC,W
056E2:  SUBLW  5C
056E4:  BNZ   5704
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
056E6:  MOVF   xCA,F
056E8:  BNZ   56EC
....................             break; 
056EA:  BRA    57CC
....................          dirname[11] = a & b;  
056EC:  MOVLW  0B
056EE:  ADDWF  xC8,W
056F0:  MOVWF  FE9
056F2:  MOVLW  00
056F4:  ADDWFC xC9,W
056F6:  MOVWF  FEA
056F8:  MOVF   xCD,W
056FA:  ANDWF  xCE,W
056FC:  MOVWF  FEF
....................             return (c); 
056FE:  MOVFF  9CC,01
05702:  BRA    57D0
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
05704:  MOVF   xCC,W
05706:  SUBLW  20
05708:  BC    5710
0570A:  MOVF   xCC,W
0570C:  SUBLW  7F
0570E:  BNZ   5712
....................          break;   // reject invisible characters 
05710:  BRA    57CC
....................       if (c == '.')  
05712:  MOVF   xCC,W
05714:  SUBLW  2E
05716:  BNZ   5734
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
05718:  BTFSC  xCD.0
0571A:  BRA    5732
0571C:  MOVF   xCA,W
0571E:  SUBLW  00
05720:  BC    5732
05722:  MOVF   xCA,W
05724:  SUBLW  08
05726:  BNC   5732
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
05728:  MOVLW  08
0572A:  MOVWF  xCA
0572C:  MOVLW  0B
0572E:  MOVWF  xCB
....................             continue; 
05730:  BRA    57CA
....................             } 
....................          break; 
05732:  BRA    57CC
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
05734:  MOVF   xCC,W
05736:  SUBLW  22
05738:  BNZ   573C
....................          break;               // Reject "  
0573A:  BRA    57CC
....................  
....................       if (c <= ')')  
0573C:  MOVF   xCC,W
0573E:  SUBLW  29
05740:  BNC   5744
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
05742:  BRA    57AE
....................  
....................       if (c <= ',') 
05744:  MOVF   xCC,W
05746:  SUBLW  2C
05748:  BNC   574C
....................          break;               // Reject * + ,  
0574A:  BRA    57CC
....................  
....................       if (c <= '9')  
0574C:  MOVF   xCC,W
0574E:  SUBLW  39
05750:  BNC   5754
....................          goto md_l1;            // Accept - 0-9  
05752:  BRA    57AE
....................  
....................       if (c <= '?')  
05754:  MOVF   xCC,W
05756:  SUBLW  3F
05758:  BNC   575C
....................          break;               // Reject : ; < = > ?  
0575A:  BRA    57CC
....................  
....................       if (!(a & 1))  
0575C:  BTFSC  xCD.0
0575E:  BRA    57AE
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
05760:  MOVF   xCC,W
05762:  SUBLW  7C
05764:  BNZ   5768
....................             break;            // Reject |  
05766:  BRA    57CC
....................  
....................          if ((c >= '[') && (c <= ']')) 
05768:  MOVF   xCC,W
0576A:  SUBLW  5A
0576C:  BC    5776
0576E:  MOVF   xCC,W
05770:  SUBLW  5D
05772:  BNC   5776
....................             break;// Reject [ \ ]  
05774:  BRA    57CC
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
05776:  MOVF   xCC,W
05778:  SUBLW  40
0577A:  BC    5790
0577C:  MOVF   xCC,W
0577E:  SUBLW  5A
05780:  BNC   5790
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
05782:  MOVF   xCB,W
05784:  SUBLW  08
05786:  BNZ   578E
05788:  BCF    xCE.3
0578A:  MOVF   xCE,W
0578C:  BRA    5790
0578E:  BCF    xCE.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
05790:  MOVF   xCC,W
05792:  SUBLW  60
05794:  BC    57AE
05796:  MOVF   xCC,W
05798:  SUBLW  7A
0579A:  BNC   57AE
....................             {      // Convert to upper case  
....................             c -= 0x20; 
0579C:  MOVLW  20
0579E:  SUBWF  xCC,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
057A0:  MOVF   xCB,W
057A2:  SUBLW  08
057A4:  BNZ   57AC
057A6:  BSF    xCD.3
057A8:  MOVF   xCD,W
057AA:  BRA    57AE
057AC:  BSF    xCD.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
057AE:  BCF    xCD.0
....................    md_l2: 
....................       if (n >= t)  
057B0:  MOVF   xCB,W
057B2:  SUBWF  xCA,W
057B4:  BNC   57B8
....................          break; 
057B6:  BRA    57CC
....................       dirname[n++] = c; 
057B8:  MOVF   xCA,W
057BA:  INCF   xCA,F
057BC:  ADDWF  xC8,W
057BE:  MOVWF  FE9
057C0:  MOVLW  00
057C2:  ADDWFC xC9,W
057C4:  MOVWF  FEA
057C6:  MOVFF  9CC,FEF
057CA:  BRA    569C
....................       } 
....................    return 1; 
057CC:  MOVLW  01
057CE:  MOVWF  01
057D0:  MOVLB  0
057D2:  GOTO   6308 (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
06166:  MOVLB  9
06168:  CLRF   xC5
0616A:  CLRF   xC4
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
0616C:  MOVLW  14
0616E:  MOVLB  7
06170:  ADDWF  x12,W
06172:  MOVWF  FE9
06174:  MOVLW  00
06176:  ADDWFC x13,W
06178:  MOVWF  FEA
0617A:  MOVFF  FEF,9BF
0617E:  MOVFF  FEC,9C0
06182:  MOVFF  FEC,9C1
06186:  MOVFF  FEC,9C2
....................    if (fs->fs_type == FS_FAT32)  
0618A:  MOVFF  712,FE9
0618E:  MOVFF  713,FEA
06192:  MOVF   FEF,W
06194:  SUBLW  03
06196:  BNZ   621A
....................       { 
....................       scan->clust = scan->sclust = clust; 
06198:  MOVLW  04
0619A:  MOVLB  9
0619C:  ADDWF  xB7,W
0619E:  MOVWF  01
061A0:  MOVLW  00
061A2:  ADDWFC xB8,W
061A4:  MOVFF  01,9C6
061A8:  MOVFF  9B7,FE9
061AC:  MOVFF  9B8,FEA
061B0:  MOVFF  9BF,FEF
061B4:  MOVFF  9C0,FEC
061B8:  MOVFF  9C1,FEC
061BC:  MOVFF  9C2,FEC
061C0:  MOVWF  FEA
061C2:  MOVFF  9C6,FE9
061C6:  MOVFF  9BF,FEF
061CA:  MOVFF  9C0,FEC
061CE:  MOVFF  9C1,FEC
061D2:  MOVFF  9C2,FEC
....................       scan->sect = clust2sect(clust); 
061D6:  MOVLW  08
061D8:  ADDWF  xB7,W
061DA:  MOVWF  01
061DC:  MOVLW  00
061DE:  ADDWFC xB8,W
061E0:  MOVWF  03
061E2:  MOVFF  01,9C6
061E6:  MOVWF  xC7
061E8:  MOVFF  9C2,9D3
061EC:  MOVFF  9C1,9D2
061F0:  MOVFF  9C0,9D1
061F4:  MOVFF  9BF,9D0
061F8:  MOVLB  0
061FA:  CALL   559E
061FE:  MOVFF  9C7,FEA
06202:  MOVFF  9C6,FE9
06206:  MOVFF  00,FEF
0620A:  MOVFF  01,FEC
0620E:  MOVFF  02,FEC
06212:  MOVFF  03,FEC
....................       } 
06216:  BRA    627A
06218:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
0621A:  MOVLW  04
0621C:  MOVLB  9
0621E:  ADDWF  xB7,W
06220:  MOVWF  01
06222:  MOVLW  00
06224:  ADDWFC xB8,W
06226:  MOVWF  03
06228:  MOVFF  9B7,FE9
0622C:  MOVFF  9B8,FEA
06230:  MOVF   FEE,F
06232:  MOVF   FEE,F
06234:  CLRF   FEC
06236:  MOVF   FED,F
06238:  CLRF   FEF
0623A:  MOVF   FED,F
0623C:  CLRF   FEF
0623E:  MOVF   FED,F
06240:  CLRF   FEF
06242:  MOVLW  00
06244:  MOVFF  03,FEA
06248:  MOVFF  01,FE9
0624C:  MOVFF  00,FEF
06250:  MOVFF  01,FEC
06254:  MOVFF  02,FEC
06258:  MOVFF  03,FEC
....................       scan->sect = clust; 
0625C:  MOVLW  08
0625E:  ADDWF  xB7,W
06260:  MOVWF  FE9
06262:  MOVLW  00
06264:  ADDWFC xB8,W
06266:  MOVWF  FEA
06268:  MOVFF  9BF,FEF
0626C:  MOVFF  9C0,FEC
06270:  MOVFF  9C1,FEC
06274:  MOVFF  9C2,FEC
06278:  MOVLB  0
....................       } 
....................    scan->index = 0; 
0627A:  MOVLW  0C
0627C:  MOVLB  9
0627E:  ADDWF  xB7,W
06280:  MOVWF  FE9
06282:  MOVLW  00
06284:  ADDWFC xB8,W
06286:  MOVWF  FEA
06288:  CLRF   FEC
0628A:  MOVF   FED,F
0628C:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
0628E:  MOVFF  9BC,03
06292:  MOVFF  9BB,FE9
06296:  MOVFF  9BC,FEA
0629A:  MOVF   FEF,W
0629C:  SUBLW  20
0629E:  BZ    62C4
062A0:  MOVFF  9BC,03
062A4:  MOVFF  9BB,FE9
062A8:  MOVFF  9BC,FEA
062AC:  MOVF   FEF,W
062AE:  SUBLW  2F
062B0:  BZ    62C4
062B2:  MOVFF  9BC,03
062B6:  MOVFF  9BB,FE9
062BA:  MOVFF  9BC,FEA
062BE:  MOVF   FEF,W
062C0:  SUBLW  5C
062C2:  BNZ   62CC
....................        path++; 
062C4:  INCF   xBB,F
062C6:  BTFSC  FD8.2
062C8:  INCF   xBC,F
062CA:  BRA    628E
....................  
....................    if ((BYTE)*path < ' ')  
062CC:  MOVFF  9BC,03
062D0:  MOVFF  9BB,FE9
062D4:  MOVFF  9BC,FEA
062D8:  MOVF   FEF,W
062DA:  SUBLW  1F
062DC:  BNC   62F2
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
062DE:  MOVFF  9BD,FE9
062E2:  MOVFF  9BE,FEA
062E6:  CLRF   FEC
062E8:  MOVF   FED,F
062EA:  CLRF   FEF
....................       return (FR_OK); 
062EC:  MOVLW  00
062EE:  MOVWF  01
062F0:  BRA    654A
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
062F2:  MOVLW  09
062F4:  MOVWF  xC7
062F6:  MOVLW  BB
062F8:  MOVWF  xC6
062FA:  MOVFF  9BA,9C9
062FE:  MOVFF  9B9,9C8
06302:  MOVLB  0
06304:  GOTO   5678
06308:  MOVFF  01,9C3
....................       if (ds == 1)  
0630C:  MOVLB  9
0630E:  DECFSZ xC3,W
06310:  BRA    6318
....................          return (FR_INVALID_NAME); 
06312:  MOVLW  04
06314:  MOVWF  01
06316:  BRA    654A
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
06318:  MOVLW  08
0631A:  ADDWF  xB7,W
0631C:  MOVWF  FE9
0631E:  MOVLW  00
06320:  ADDWFC xB8,W
06322:  MOVWF  FEA
06324:  MOVFF  FEF,9F1
06328:  MOVFF  FEC,9F2
0632C:  MOVFF  FEC,9F3
06330:  MOVFF  FEC,9F4
06334:  MOVLB  0
06336:  CALL   5A16
0633A:  MOVF   01,F
0633C:  BNZ   6348
....................             return (FR_RW_ERROR); 
0633E:  MOVLW  07
06340:  MOVWF  01
06342:  MOVLB  9
06344:  BRA    654A
06346:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
06348:  MOVLW  0C
0634A:  MOVLB  9
0634C:  ADDWF  xB7,W
0634E:  MOVWF  FE9
06350:  MOVLW  00
06352:  ADDWFC xB8,W
06354:  MOVWF  FEA
06356:  MOVFF  FEC,9C7
0635A:  MOVF   FED,F
0635C:  MOVFF  FEF,9C6
06360:  MOVLW  0F
06362:  ANDWF  xC6,F
06364:  CLRF   xC7
06366:  RLCF   xC6,F
06368:  RLCF   xC7,F
0636A:  RLCF   xC6,F
0636C:  RLCF   xC7,F
0636E:  RLCF   xC6,F
06370:  RLCF   xC7,F
06372:  RLCF   xC6,F
06374:  RLCF   xC7,F
06376:  RLCF   xC6,F
06378:  RLCF   xC7,F
0637A:  MOVLW  E0
0637C:  ANDWF  xC6,F
0637E:  MOVLW  24
06380:  ADDWF  xC6,W
06382:  MOVWF  01
06384:  MOVLW  00
06386:  ADDWFC xC7,W
06388:  MOVWF  03
0638A:  MOVF   01,W
0638C:  MOVLB  7
0638E:  ADDWF  x12,W
06390:  MOVWF  01
06392:  MOVF   x13,W
06394:  ADDWFC 03,F
06396:  MOVFF  01,9C4
0639A:  MOVLB  9
0639C:  MOVFF  03,9C5
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
063A0:  MOVFF  9C5,03
063A4:  MOVFF  9C4,FE9
063A8:  MOVFF  9C5,FEA
063AC:  MOVF   FEF,F
063AE:  BNZ   63BE
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
063B0:  MOVF   xC3,F
063B2:  BNZ   63B8
063B4:  MOVLW  02
063B6:  BRA    63BA
063B8:  MOVLW  03
063BA:  MOVWF  01
063BC:  BRA    654A
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
063BE:  MOVFF  9C5,03
063C2:  MOVFF  9C4,FE9
063C6:  MOVFF  9C5,FEA
063CA:  MOVF   FEF,W
063CC:  SUBLW  E5
063CE:  BZ    6410
063D0:  MOVLW  0B
063D2:  ADDWF  xC4,W
063D4:  MOVWF  01
063D6:  MOVLW  00
063D8:  ADDWFC xC5,W
063DA:  MOVWF  03
063DC:  MOVFF  01,FE9
063E0:  MOVWF  FEA
063E2:  BTFSC  FEF.3
063E4:  BRA    6410
063E6:  MOVFF  9C5,9CB
063EA:  MOVFF  9C4,9CA
063EE:  MOVFF  9BA,9CD
063F2:  MOVFF  9B9,9CC
063F6:  CLRF   xCF
063F8:  MOVLW  0B
063FA:  MOVWF  xCE
063FC:  MOVLB  0
063FE:  CALL   45AC
06402:  MOVF   01,F
06404:  BTFSC  FD8.2
06406:  BRA    640C
06408:  MOVLB  9
0640A:  BRA    6410
....................              break; 
0640C:  BRA    6438
0640E:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
06410:  MOVFF  9B8,9C7
06414:  MOVFF  9B7,9C6
06418:  MOVLB  0
0641A:  RCALL  5F8C
0641C:  MOVF   01,F
0641E:  BNZ   6432
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06420:  MOVLB  9
06422:  MOVF   xC3,F
06424:  BNZ   642A
06426:  MOVLW  02
06428:  BRA    642C
0642A:  MOVLW  03
0642C:  MOVWF  01
0642E:  BRA    654A
06430:  MOVLB  0
06432:  MOVLB  9
06434:  BRA    6318
06436:  MOVLB  0
....................          } 
....................       if (!ds)  
06438:  MOVLB  9
0643A:  MOVF   xC3,F
0643C:  BNZ   6456
....................          {  
....................          *win_dir = dptr;  
0643E:  MOVFF  9BD,FE9
06442:  MOVFF  9BE,FEA
06446:  MOVFF  9C5,FEC
0644A:  MOVF   FED,F
0644C:  MOVFF  9C4,FEF
....................          return (FR_OK); 
06450:  MOVLW  00
06452:  MOVWF  01
06454:  BRA    654A
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
06456:  MOVLW  0B
06458:  ADDWF  xC4,W
0645A:  MOVWF  01
0645C:  MOVLW  00
0645E:  ADDWFC xC5,W
06460:  MOVWF  03
06462:  MOVFF  01,FE9
06466:  MOVWF  FEA
06468:  BTFSC  FEF.4
0646A:  BRA    6472
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
0646C:  MOVLW  03
0646E:  MOVWF  01
06470:  BRA    654A
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
06472:  MOVLW  14
06474:  ADDWF  xC4,W
06476:  MOVWF  01
06478:  MOVLW  00
0647A:  ADDWFC xC5,W
0647C:  MOVWF  03
0647E:  MOVFF  01,FE9
06482:  MOVWF  FEA
06484:  MOVFF  FEC,9C2
06488:  MOVF   FED,F
0648A:  MOVFF  FEF,9C6
0648E:  MOVFF  9C6,9C1
06492:  CLRF   xC6
06494:  CLRF   xC7
06496:  MOVLW  1A
06498:  ADDWF  xC4,W
0649A:  MOVWF  01
0649C:  MOVLW  00
0649E:  ADDWFC xC5,W
064A0:  MOVFF  01,FE9
064A4:  MOVWF  FEA
064A6:  MOVFF  FEC,03
064AA:  MOVF   FED,F
064AC:  MOVF   FEF,W
064AE:  IORWF  xC6,W
064B0:  MOVWF  xBF
064B2:  MOVF   03,W
064B4:  IORWF  xC7,W
064B6:  MOVWF  xC0
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
064B8:  MOVLW  04
064BA:  ADDWF  xB7,W
064BC:  MOVWF  01
064BE:  MOVLW  00
064C0:  ADDWFC xB8,W
064C2:  MOVFF  01,9C6
064C6:  MOVFF  9B7,FE9
064CA:  MOVFF  9B8,FEA
064CE:  MOVFF  9BF,FEF
064D2:  MOVFF  9C0,FEC
064D6:  MOVFF  9C1,FEC
064DA:  MOVFF  9C2,FEC
064DE:  MOVWF  FEA
064E0:  MOVFF  9C6,FE9
064E4:  MOVFF  9BF,FEF
064E8:  MOVFF  9C0,FEC
064EC:  MOVFF  9C1,FEC
064F0:  MOVFF  9C2,FEC
....................       scan->sect = clust2sect(clust); 
064F4:  MOVLW  08
064F6:  ADDWF  xB7,W
064F8:  MOVWF  01
064FA:  MOVLW  00
064FC:  ADDWFC xB8,W
064FE:  MOVWF  03
06500:  MOVFF  01,9C6
06504:  MOVWF  xC7
06506:  MOVFF  9C2,9D3
0650A:  MOVFF  9C1,9D2
0650E:  MOVFF  9C0,9D1
06512:  MOVFF  9BF,9D0
06516:  MOVLB  0
06518:  CALL   559E
0651C:  MOVFF  9C7,FEA
06520:  MOVFF  9C6,FE9
06524:  MOVFF  00,FEF
06528:  MOVFF  01,FEC
0652C:  MOVFF  02,FEC
06530:  MOVFF  03,FEC
....................       scan->index = 0; 
06534:  MOVLW  0C
06536:  MOVLB  9
06538:  ADDWF  xB7,W
0653A:  MOVWF  FE9
0653C:  MOVLW  00
0653E:  ADDWFC xB8,W
06540:  MOVWF  FEA
06542:  CLRF   FEC
06544:  MOVF   FED,F
06546:  CLRF   FEF
06548:  BRA    62F2
....................       } 
0654A:  MOVLB  0
0654C:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06B64:  MOVLB  9
06B66:  MOVFF  9B7,FE9
06B6A:  MOVFF  9B8,FEA
06B6E:  MOVFF  FEF,9B9
06B72:  MOVFF  FEC,9BA
06B76:  MOVFF  FEC,9BB
06B7A:  MOVFF  FEC,9BC
....................    if (clust) {   // Dyanmic directory table  
06B7E:  MOVF   xB9,F
06B80:  BNZ   6B8E
06B82:  MOVF   xBA,F
06B84:  BNZ   6B8E
06B86:  MOVF   xBB,F
06B88:  BNZ   6B8E
06B8A:  MOVF   xBC,F
06B8C:  BZ    6BEE
....................       scan->clust = clust; 
06B8E:  MOVLW  04
06B90:  ADDWF  xB7,W
06B92:  MOVWF  FE9
06B94:  MOVLW  00
06B96:  ADDWFC xB8,W
06B98:  MOVWF  FEA
06B9A:  MOVFF  9B9,FEF
06B9E:  MOVFF  9BA,FEC
06BA2:  MOVFF  9BB,FEC
06BA6:  MOVFF  9BC,FEC
....................       scan->sect = clust2sect(clust); 
06BAA:  MOVLW  08
06BAC:  ADDWF  xB7,W
06BAE:  MOVWF  01
06BB0:  MOVLW  00
06BB2:  ADDWFC xB8,W
06BB4:  MOVWF  03
06BB6:  MOVFF  01,9C5
06BBA:  MOVWF  xC6
06BBC:  MOVFF  9BC,9D3
06BC0:  MOVFF  9BB,9D2
06BC4:  MOVFF  9BA,9D1
06BC8:  MOVFF  9B9,9D0
06BCC:  MOVLB  0
06BCE:  CALL   559E
06BD2:  MOVFF  9C6,FEA
06BD6:  MOVFF  9C5,FE9
06BDA:  MOVFF  00,FEF
06BDE:  MOVFF  01,FEC
06BE2:  MOVFF  02,FEC
06BE6:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06BEA:  BRA    6C38
06BEC:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06BEE:  MOVLW  08
06BF0:  ADDWF  xB7,W
06BF2:  MOVWF  01
06BF4:  MOVLW  00
06BF6:  ADDWFC xB8,W
06BF8:  MOVWF  03
06BFA:  MOVFF  01,9C5
06BFE:  MOVWF  xC6
06C00:  MOVLW  14
06C02:  MOVLB  7
06C04:  ADDWF  x12,W
06C06:  MOVWF  FE9
06C08:  MOVLW  00
06C0A:  ADDWFC x13,W
06C0C:  MOVWF  FEA
06C0E:  MOVFF  FEF,00
06C12:  MOVFF  FEC,01
06C16:  MOVFF  FEC,02
06C1A:  MOVFF  FEC,03
06C1E:  MOVFF  9C6,FEA
06C22:  MOVFF  9C5,FE9
06C26:  MOVFF  00,FEF
06C2A:  MOVFF  01,FEC
06C2E:  MOVFF  02,FEC
06C32:  MOVFF  03,FEC
06C36:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06C38:  MOVLW  0C
06C3A:  MOVLB  9
06C3C:  ADDWF  xB7,W
06C3E:  MOVWF  FE9
06C40:  MOVLW  00
06C42:  ADDWFC xB8,W
06C44:  MOVWF  FEA
06C46:  CLRF   FEC
06C48:  MOVF   FED,F
06C4A:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06C4C:  MOVLW  08
06C4E:  ADDWF  xB7,W
06C50:  MOVWF  FE9
06C52:  MOVLW  00
06C54:  ADDWFC xB8,W
06C56:  MOVWF  FEA
06C58:  MOVFF  FEF,9F1
06C5C:  MOVFF  FEC,9F2
06C60:  MOVFF  FEC,9F3
06C64:  MOVFF  FEC,9F4
06C68:  MOVLB  0
06C6A:  CALL   5A16
06C6E:  MOVF   01,F
06C70:  BNZ   6C7A
....................          return (NULL); 
06C72:  MOVLW  00
06C74:  MOVWF  01
06C76:  MOVWF  02
06C78:  BRA    6EA4
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06C7A:  MOVLW  0C
06C7C:  MOVLB  9
06C7E:  ADDWF  xB7,W
06C80:  MOVWF  FE9
06C82:  MOVLW  00
06C84:  ADDWFC xB8,W
06C86:  MOVWF  FEA
06C88:  MOVFF  FEC,9C6
06C8C:  MOVF   FED,F
06C8E:  MOVFF  FEF,9C5
06C92:  MOVLW  0F
06C94:  ANDWF  xC5,F
06C96:  CLRF   xC6
06C98:  RLCF   xC5,F
06C9A:  RLCF   xC6,F
06C9C:  RLCF   xC5,F
06C9E:  RLCF   xC6,F
06CA0:  RLCF   xC5,F
06CA2:  RLCF   xC6,F
06CA4:  RLCF   xC5,F
06CA6:  RLCF   xC6,F
06CA8:  RLCF   xC5,F
06CAA:  RLCF   xC6,F
06CAC:  MOVLW  E0
06CAE:  ANDWF  xC5,F
06CB0:  MOVLW  24
06CB2:  ADDWF  xC5,W
06CB4:  MOVWF  01
06CB6:  MOVLW  00
06CB8:  ADDWFC xC6,W
06CBA:  MOVWF  03
06CBC:  MOVF   01,W
06CBE:  MOVLB  7
06CC0:  ADDWF  x12,W
06CC2:  MOVWF  01
06CC4:  MOVF   x13,W
06CC6:  ADDWFC 03,F
06CC8:  MOVFF  01,9C3
06CCC:  MOVLB  9
06CCE:  MOVFF  03,9C4
....................       c = *dptr; 
06CD2:  MOVFF  9C3,FE9
06CD6:  MOVFF  9C4,FEA
06CDA:  MOVFF  FEF,9C1
....................       if ((c == 0) || (c == 0xE5))  
06CDE:  MOVF   xC1,F
06CE0:  BZ    6CE8
06CE2:  MOVF   xC1,W
06CE4:  SUBLW  E5
06CE6:  BNZ   6CF6
....................          return (dptr);      // Found an empty entry!  
06CE8:  MOVFF  9C3,01
06CEC:  MOVFF  9C4,02
06CF0:  MOVLB  0
06CF2:  BRA    6EA4
06CF4:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06CF6:  MOVFF  9B8,9C7
06CFA:  MOVFF  9B7,9C6
06CFE:  MOVLB  0
06D00:  CALL   5F8C
06D04:  MOVF   01,F
06D06:  BTFSC  FD8.2
06D08:  BRA    6D0E
06D0A:  MOVLB  9
06D0C:  BRA    6C4C
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06D0E:  MOVLB  9
06D10:  MOVF   xB9,F
06D12:  BNZ   6D2C
06D14:  MOVF   xBA,F
06D16:  BNZ   6D2C
06D18:  MOVF   xBB,F
06D1A:  BNZ   6D2C
06D1C:  MOVF   xBC,F
06D1E:  BNZ   6D2C
....................        return (NULL); 
06D20:  MOVLW  00
06D22:  MOVWF  01
06D24:  MOVWF  02
06D26:  MOVLB  0
06D28:  BRA    6EA4
06D2A:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06D2C:  MOVLW  04
06D2E:  ADDWF  xB7,W
06D30:  MOVWF  FE9
06D32:  MOVLW  00
06D34:  ADDWFC xB8,W
06D36:  MOVWF  FEA
06D38:  MOVFF  FEF,9C9
06D3C:  MOVFF  FEC,9CA
06D40:  MOVFF  FEC,9CB
06D44:  MOVFF  FEC,9CC
06D48:  MOVLB  0
06D4A:  RCALL  68CE
06D4C:  MOVFF  03,9BC
06D50:  MOVFF  02,9BB
06D54:  MOVFF  01,9BA
06D58:  MOVFF  00,9B9
....................    if (!(clust))  
06D5C:  MOVLB  9
06D5E:  MOVF   xB9,F
06D60:  BNZ   6D7A
06D62:  MOVF   xBA,F
06D64:  BNZ   6D7A
06D66:  MOVF   xBB,F
06D68:  BNZ   6D7A
06D6A:  MOVF   xBC,F
06D6C:  BNZ   6D7A
....................       return (NULL); 
06D6E:  MOVLW  00
06D70:  MOVWF  01
06D72:  MOVWF  02
06D74:  MOVLB  0
06D76:  BRA    6EA4
06D78:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06D7A:  CLRF   xF4
06D7C:  CLRF   xF3
06D7E:  CLRF   xF2
06D80:  CLRF   xF1
06D82:  MOVLB  0
06D84:  CALL   5A16
06D88:  MOVF   01,F
06D8A:  BNZ   6D94
....................       return (0); 
06D8C:  MOVLW  00
06D8E:  MOVWF  01
06D90:  MOVWF  02
06D92:  BRA    6EA4
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06D94:  MOVLW  20
06D96:  MOVLB  7
06D98:  ADDWF  x12,W
06D9A:  MOVWF  01
06D9C:  MOVLW  00
06D9E:  ADDWFC x13,W
06DA0:  MOVWF  03
06DA2:  MOVFF  01,9C5
06DA6:  MOVLB  9
06DA8:  MOVWF  xC6
06DAA:  MOVFF  9BC,9D3
06DAE:  MOVFF  9BB,9D2
06DB2:  MOVFF  9BA,9D1
06DB6:  MOVFF  9B9,9D0
06DBA:  MOVLB  0
06DBC:  CALL   559E
06DC0:  MOVFF  03,9C0
06DC4:  MOVFF  02,9BF
06DC8:  MOVFF  01,9BE
06DCC:  MOVFF  00,9BD
06DD0:  MOVFF  9C6,FEA
06DD4:  MOVFF  9C5,FE9
06DD8:  MOVFF  9BD,FEF
06DDC:  MOVFF  9BE,FEC
06DE0:  MOVFF  9BF,FEC
06DE4:  MOVFF  9C0,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06DE8:  MOVLW  24
06DEA:  MOVLB  7
06DEC:  ADDWF  x12,W
06DEE:  MOVWF  01
06DF0:  MOVLW  00
06DF2:  ADDWFC x13,W
06DF4:  MOVWF  03
06DF6:  MOVFF  01,9C5
06DFA:  MOVLB  9
06DFC:  MOVWF  xC6
06DFE:  MOVWF  FEA
06E00:  MOVFF  01,FE9
06E04:  CLRF   00
06E06:  MOVLW  02
06E08:  MOVWF  02
06E0A:  CLRF   01
06E0C:  MOVLB  0
06E0E:  CALL   34C2
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06E12:  MOVLW  02
06E14:  MOVLB  7
06E16:  ADDWF  x12,W
06E18:  MOVWF  FE9
06E1A:  MOVLW  00
06E1C:  ADDWFC x13,W
06E1E:  MOVWF  FEA
06E20:  MOVFF  FEF,9C2
06E24:  MOVLB  9
06E26:  MOVF   xC2,F
06E28:  BZ    6E84
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06E2A:  MOVLW  24
06E2C:  MOVLB  7
06E2E:  ADDWF  x12,W
06E30:  MOVWF  01
06E32:  MOVLW  00
06E34:  ADDWFC x13,W
06E36:  MOVWF  03
06E38:  MOVFF  01,9C5
06E3C:  MOVLB  9
06E3E:  MOVWF  xC6
06E40:  MOVWF  xFE
06E42:  MOVFF  01,9FD
06E46:  MOVFF  9C0,A02
06E4A:  MOVFF  9BF,A01
06E4E:  MOVFF  9BE,A00
06E52:  MOVFF  9BD,9FF
06E56:  MOVLW  01
06E58:  MOVLB  A
06E5A:  MOVWF  x03
06E5C:  MOVLB  0
06E5E:  CALL   58CE
06E62:  MOVF   01,F
06E64:  BZ    6E6E
....................          return (NULL); 
06E66:  MOVLW  00
06E68:  MOVWF  01
06E6A:  MOVWF  02
06E6C:  BRA    6EA4
....................       sector++; 
06E6E:  MOVLW  01
06E70:  MOVLB  9
06E72:  ADDWF  xBD,F
06E74:  BTFSC  FD8.0
06E76:  INCF   xBE,F
06E78:  BTFSC  FD8.2
06E7A:  INCF   xBF,F
06E7C:  BTFSC  FD8.2
06E7E:  INCF   xC0,F
06E80:  DECF   xC2,F
06E82:  BRA    6E26
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06E84:  MOVLW  06
06E86:  MOVLB  7
06E88:  ADDWF  x12,W
06E8A:  MOVWF  FE9
06E8C:  MOVLW  00
06E8E:  ADDWFC x13,W
06E90:  MOVWF  FEA
06E92:  MOVLW  01
06E94:  MOVWF  FEF
....................    return (fs->win); 
06E96:  MOVLW  24
06E98:  ADDWF  x12,W
06E9A:  MOVWF  01
06E9C:  MOVLW  00
06E9E:  ADDWFC x13,W
06EA0:  MOVWF  03
06EA2:  MOVWF  02
06EA4:  MOVLB  0
06EA6:  GOTO   713C (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
0553C:  MOVLB  7
0553E:  MOVF   x12,W
05540:  IORWF  x13,W
05542:  BNZ   554A
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
05544:  MOVLW  0B
05546:  MOVWF  01
05548:  BRA    559A
....................  
....................    if (disk_status() & STA_NOINIT)  
0554A:  MOVLB  0
0554C:  RCALL  552E
0554E:  BTFSS  01.0
05550:  BRA    557C
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
05552:  MOVLW  01
05554:  MOVLB  7
05556:  ADDWF  x12,W
05558:  MOVWF  FE9
0555A:  MOVLW  00
0555C:  ADDWFC x13,W
0555E:  MOVWF  FEA
05560:  MOVF   FEF,F
05562:  BZ    556C
....................          return (FR_INCORRECT_DISK_CHANGE); 
05564:  MOVLW  09
05566:  MOVWF  01
05568:  BRA    559A
0556A:  BRA    5578
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
0556C:  MOVLB  0
0556E:  CALL   47EA
05572:  MOVF   01,W
05574:  MOVLB  7
05576:  BRA    559A
....................       }  
05578:  BRA    5596
0557A:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
0557C:  MOVLB  7
0557E:  MOVFF  712,FE9
05582:  MOVFF  713,FEA
05586:  MOVF   FEF,F
05588:  BNZ   5596
....................          return (f_mountdrv());      // Initialize file system and return resulut  
0558A:  MOVLB  0
0558C:  CALL   47EA
05590:  MOVF   01,W
05592:  MOVLB  7
05594:  BRA    559A
....................       } 
....................    return FR_OK;                  // File system is valid  
05596:  MOVLW  00
05598:  MOVWF  01
0559A:  MOVLB  0
0559C:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B600:  MOVLB  8
0B602:  MOVF   xAD,W
0B604:  XORLW  00
0B606:  MOVLB  0
0B608:  BZ    B642
0B60A:  XORLW  04
0B60C:  BZ    B65E
0B60E:  XORLW  05
0B610:  BZ    B67A
0B612:  XORLW  03
0B614:  BZ    B696
0B616:  XORLW  01
0B618:  BZ    B6B2
0B61A:  XORLW  06
0B61C:  BZ    B6CE
0B61E:  XORLW  03
0B620:  BZ    B6EA
0B622:  XORLW  01
0B624:  BTFSC  FD8.2
0B626:  BRA    B706
0B628:  XORLW  0E
0B62A:  BTFSC  FD8.2
0B62C:  BRA    B722
0B62E:  XORLW  03
0B630:  BTFSC  FD8.2
0B632:  BRA    B73E
0B634:  XORLW  01
0B636:  BTFSC  FD8.2
0B638:  BRA    B75A
0B63A:  XORLW  07
0B63C:  BTFSC  FD8.2
0B63E:  BRA    B776
0B640:  BRA    B792
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B642:  MOVFF  8AF,FEA
0B646:  MOVFF  8AE,FE9
0B64A:  MOVLW  00
0B64C:  CALL   0106
0B650:  TBLRD*-
0B652:  TBLRD*+
0B654:  MOVF   FF5,W
0B656:  MOVWF  FEE
0B658:  IORLW  00
0B65A:  BNZ   B652
....................          break; 
0B65C:  BRA    B7AC
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B65E:  MOVFF  8AF,FEA
0B662:  MOVFF  8AE,FE9
0B666:  MOVLW  00
0B668:  CALL   0124
0B66C:  TBLRD*-
0B66E:  TBLRD*+
0B670:  MOVF   FF5,W
0B672:  MOVWF  FEE
0B674:  IORLW  00
0B676:  BNZ   B66E
....................          break; 
0B678:  BRA    B7AC
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0B67A:  MOVFF  8AF,FEA
0B67E:  MOVFF  8AE,FE9
0B682:  MOVLW  00
0B684:  CALL   014A
0B688:  TBLRD*-
0B68A:  TBLRD*+
0B68C:  MOVF   FF5,W
0B68E:  MOVWF  FEE
0B690:  IORLW  00
0B692:  BNZ   B68A
....................          break; 
0B694:  BRA    B7AC
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0B696:  MOVFF  8AF,FEA
0B69A:  MOVFF  8AE,FE9
0B69E:  MOVLW  00
0B6A0:  CALL   016E
0B6A4:  TBLRD*-
0B6A6:  TBLRD*+
0B6A8:  MOVF   FF5,W
0B6AA:  MOVWF  FEE
0B6AC:  IORLW  00
0B6AE:  BNZ   B6A6
....................          break; 
0B6B0:  BRA    B7AC
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0B6B2:  MOVFF  8AF,FEA
0B6B6:  MOVFF  8AE,FE9
0B6BA:  MOVLW  00
0B6BC:  CALL   0192
0B6C0:  TBLRD*-
0B6C2:  TBLRD*+
0B6C4:  MOVF   FF5,W
0B6C6:  MOVWF  FEE
0B6C8:  IORLW  00
0B6CA:  BNZ   B6C2
....................          break; 
0B6CC:  BRA    B7AC
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0B6CE:  MOVFF  8AF,FEA
0B6D2:  MOVFF  8AE,FE9
0B6D6:  MOVLW  00
0B6D8:  CALL   01B6
0B6DC:  TBLRD*-
0B6DE:  TBLRD*+
0B6E0:  MOVF   FF5,W
0B6E2:  MOVWF  FEE
0B6E4:  IORLW  00
0B6E6:  BNZ   B6DE
....................          break; 
0B6E8:  BRA    B7AC
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0B6EA:  MOVFF  8AF,FEA
0B6EE:  MOVFF  8AE,FE9
0B6F2:  MOVLW  00
0B6F4:  CALL   01D8
0B6F8:  TBLRD*-
0B6FA:  TBLRD*+
0B6FC:  MOVF   FF5,W
0B6FE:  MOVWF  FEE
0B700:  IORLW  00
0B702:  BNZ   B6FA
....................          break; 
0B704:  BRA    B7AC
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0B706:  MOVFF  8AF,FEA
0B70A:  MOVFF  8AE,FE9
0B70E:  MOVLW  00
0B710:  CALL   01F8
0B714:  TBLRD*-
0B716:  TBLRD*+
0B718:  MOVF   FF5,W
0B71A:  MOVWF  FEE
0B71C:  IORLW  00
0B71E:  BNZ   B716
....................          break; 
0B720:  BRA    B7AC
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0B722:  MOVFF  8AF,FEA
0B726:  MOVFF  8AE,FE9
0B72A:  MOVLW  00
0B72C:  CALL   0216
0B730:  TBLRD*-
0B732:  TBLRD*+
0B734:  MOVF   FF5,W
0B736:  MOVWF  FEE
0B738:  IORLW  00
0B73A:  BNZ   B732
....................          break; 
0B73C:  BRA    B7AC
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0B73E:  MOVFF  8AF,FEA
0B742:  MOVFF  8AE,FE9
0B746:  MOVLW  00
0B748:  CALL   0242
0B74C:  TBLRD*-
0B74E:  TBLRD*+
0B750:  MOVF   FF5,W
0B752:  MOVWF  FEE
0B754:  IORLW  00
0B756:  BNZ   B74E
....................          break; 
0B758:  BRA    B7AC
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0B75A:  MOVFF  8AF,FEA
0B75E:  MOVFF  8AE,FE9
0B762:  MOVLW  00
0B764:  CALL   0266
0B768:  TBLRD*-
0B76A:  TBLRD*+
0B76C:  MOVF   FF5,W
0B76E:  MOVWF  FEE
0B770:  IORLW  00
0B772:  BNZ   B76A
....................          break; 
0B774:  BRA    B7AC
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0B776:  MOVFF  8AF,FEA
0B77A:  MOVFF  8AE,FE9
0B77E:  MOVLW  00
0B780:  CALL   028A
0B784:  TBLRD*-
0B786:  TBLRD*+
0B788:  MOVF   FF5,W
0B78A:  MOVWF  FEE
0B78C:  IORLW  00
0B78E:  BNZ   B786
....................          break; 
0B790:  BRA    B7AC
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0B792:  MOVFF  8AF,FEA
0B796:  MOVFF  8AE,FE9
0B79A:  MOVLW  00
0B79C:  CALL   02AC
0B7A0:  TBLRD*-
0B7A2:  TBLRD*+
0B7A4:  MOVF   FF5,W
0B7A6:  MOVWF  FEE
0B7A8:  IORLW  00
0B7AA:  BNZ   B7A2
....................       } 
0B7AC:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
047EA:  MOVLB  7
047EC:  MOVF   x12,W
047EE:  IORWF  x13,W
047F0:  BNZ   47F8
....................       return (FR_NOT_ENABLED); 
047F2:  MOVLW  0B
047F4:  MOVWF  01
047F6:  BRA    4D84
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
047F8:  MOVFF  713,FEA
047FC:  MOVFF  712,FE9
04800:  CLRF   00
04802:  MOVLW  02
04804:  MOVWF  02
04806:  MOVLW  24
04808:  MOVWF  01
0480A:  MOVLB  0
0480C:  CALL   34C2
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
04810:  CALL   3612
04814:  MOVFF  01,4ED
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
04818:  MOVLB  4
0481A:  BTFSS  xED.0
0481C:  BRA    482A
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
0481E:  MOVLB  0
04820:  CALL   3612
04824:  MOVFF  01,4ED
04828:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
0482A:  BTFSS  xED.0
0482C:  BRA    4838
0482E:  MOVLW  01
04830:  MOVWF  01
04832:  MOVLB  7
04834:  BRA    4D84
04836:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
04838:  MOVLB  9
0483A:  CLRF   xBB
0483C:  CLRF   xBA
0483E:  CLRF   xB9
04840:  CLRF   xB8
04842:  MOVFF  9BB,9C7
04846:  MOVFF  9BA,9C6
0484A:  MOVFF  9B9,9C5
0484E:  MOVFF  9B8,9C4
04852:  MOVLB  0
04854:  RCALL  4630
04856:  MOVFF  01,9B7
....................    if (!fat)  
0485A:  MOVLB  9
0485C:  MOVF   xB7,F
0485E:  BNZ   48CE
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
04860:  MOVLW  E6
04862:  MOVLB  7
04864:  ADDWF  x12,W
04866:  MOVWF  FE9
04868:  MOVLW  01
0486A:  ADDWFC x13,W
0486C:  MOVWF  FEA
0486E:  MOVF   FEF,F
04870:  BZ    48AE
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
04872:  MOVLW  EA
04874:  ADDWF  x12,W
04876:  MOVWF  01
04878:  MOVLW  01
0487A:  ADDWFC x13,W
0487C:  MOVFF  01,FE9
04880:  MOVWF  FEA
04882:  MOVFF  FEF,9B8
04886:  MOVFF  FEC,9B9
0488A:  MOVFF  FEC,9BA
0488E:  MOVFF  FEC,9BB
....................          fat = check_fs(sect);            // Check the partition  
04892:  MOVFF  9BB,9C7
04896:  MOVFF  9BA,9C6
0489A:  MOVFF  9B9,9C5
0489E:  MOVFF  9B8,9C4
048A2:  MOVLB  0
048A4:  RCALL  4630
048A6:  MOVFF  01,9B7
....................          } 
048AA:  BRA    48CC
048AC:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
048AE:  MOVLW  04
048B0:  MOVWF  FF6
048B2:  MOVLW  0C
048B4:  MOVWF  FF7
048B6:  MOVLW  00
048B8:  MOVWF  FF8
048BA:  CLRF   1B
048BC:  BTFSC  FF2.7
048BE:  BSF    1B.7
048C0:  BCF    FF2.7
048C2:  MOVLB  0
048C4:  CALL   0E4E
048C8:  BTFSC  1B.7
048CA:  BSF    FF2.7
048CC:  MOVLB  9
....................       } 
....................    if (!fat)  
048CE:  MOVF   xB7,F
048D0:  BNZ   48DC
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
048D2:  MOVLW  0C
048D4:  MOVWF  01
048D6:  MOVLB  7
048D8:  BRA    4D84
048DA:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
048DC:  MOVLB  7
048DE:  MOVFF  712,FE9
048E2:  MOVFF  713,FEA
048E6:  MOVFF  9B7,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
048EA:  MOVLB  9
048EC:  MOVF   xB7,W
048EE:  SUBLW  03
048F0:  BNZ   4956
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
048F2:  MOVLW  08
048F4:  MOVLB  7
048F6:  ADDWF  x12,W
048F8:  MOVWF  01
048FA:  MOVLW  00
048FC:  ADDWFC x13,W
048FE:  MOVWF  03
04900:  MOVFF  01,9C4
04904:  MOVLB  9
04906:  MOVWF  xC5
04908:  MOVLW  48
0490A:  MOVLB  7
0490C:  ADDWF  x12,W
0490E:  MOVWF  01
04910:  MOVLW  00
04912:  ADDWFC x13,W
04914:  MOVFF  01,FE9
04918:  MOVWF  FEA
0491A:  MOVFF  FEF,00
0491E:  MOVFF  FEC,01
04922:  MOVFF  FEC,02
04926:  MOVFF  FEC,03
0492A:  MOVFF  03,9C9
0492E:  MOVFF  02,9C8
04932:  MOVFF  01,9C7
04936:  MOVFF  00,9C6
0493A:  MOVFF  9C5,FEA
0493E:  MOVFF  9C4,FE9
04942:  MOVFF  00,FEF
04946:  MOVFF  01,FEC
0494A:  MOVFF  02,FEC
0494E:  MOVFF  03,FEC
04952:  BRA    49AE
04954:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
04956:  MOVLW  08
04958:  MOVLB  7
0495A:  ADDWF  x12,W
0495C:  MOVWF  01
0495E:  MOVLW  00
04960:  ADDWFC x13,W
04962:  MOVWF  03
04964:  MOVFF  01,9C4
04968:  MOVLB  9
0496A:  MOVWF  xC5
0496C:  MOVLW  3A
0496E:  MOVLB  7
04970:  ADDWF  x12,W
04972:  MOVWF  01
04974:  MOVLW  00
04976:  ADDWFC x13,W
04978:  MOVFF  01,FE9
0497C:  MOVWF  FEA
0497E:  MOVFF  FEC,03
04982:  MOVF   FED,F
04984:  MOVFF  FEF,9C6
04988:  MOVLB  9
0498A:  MOVFF  03,9C7
0498E:  MOVFF  9C5,FEA
04992:  MOVFF  9C4,FE9
04996:  MOVF   FEE,F
04998:  MOVF   FEE,F
0499A:  CLRF   FEC
0499C:  MOVF   FED,F
0499E:  CLRF   FEF
049A0:  MOVF   FED,F
049A2:  MOVFF  03,FEF
049A6:  MOVF   FED,F
049A8:  MOVFF  9C6,FEF
049AC:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
049AE:  MOVLW  02
049B0:  ADDWF  x12,W
049B2:  MOVWF  01
049B4:  MOVLW  00
049B6:  ADDWFC x13,W
049B8:  MOVWF  03
049BA:  MOVLW  31
049BC:  MOVLB  7
049BE:  ADDWF  x12,W
049C0:  MOVWF  FE9
049C2:  MOVLW  00
049C4:  ADDWFC x13,W
049C6:  MOVWF  FEA
049C8:  MOVFF  FEF,9C6
049CC:  MOVLB  9
049CE:  MOVFF  03,FEA
049D2:  MOVFF  01,FE9
049D6:  MOVFF  9C6,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
049DA:  MOVLW  03
049DC:  MOVLB  7
049DE:  ADDWF  x12,W
049E0:  MOVWF  01
049E2:  MOVLW  00
049E4:  ADDWFC x13,W
049E6:  MOVWF  03
049E8:  MOVLW  34
049EA:  MOVLB  7
049EC:  ADDWF  x12,W
049EE:  MOVWF  FE9
049F0:  MOVLW  00
049F2:  ADDWFC x13,W
049F4:  MOVWF  FEA
049F6:  MOVFF  FEF,9C6
049FA:  MOVLB  9
049FC:  MOVFF  03,FEA
04A00:  MOVFF  01,FE9
04A04:  MOVFF  9C6,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
04A08:  MOVLW  10
04A0A:  MOVLB  7
04A0C:  ADDWF  x12,W
04A0E:  MOVWF  01
04A10:  MOVLW  00
04A12:  ADDWFC x13,W
04A14:  MOVWF  03
04A16:  MOVFF  01,9C4
04A1A:  MOVLB  9
04A1C:  MOVWF  xC5
04A1E:  MOVLW  32
04A20:  MOVLB  7
04A22:  ADDWF  x12,W
04A24:  MOVWF  01
04A26:  MOVLW  00
04A28:  ADDWFC x13,W
04A2A:  MOVFF  01,FE9
04A2E:  MOVWF  FEA
04A30:  MOVFF  FEC,03
04A34:  MOVF   FED,F
04A36:  MOVF   FEF,W
04A38:  MOVLB  9
04A3A:  ADDWF  xB8,W
04A3C:  MOVWF  00
04A3E:  MOVF   03,W
04A40:  ADDWFC xB9,W
04A42:  MOVWF  01
04A44:  MOVLW  00
04A46:  ADDWFC xBA,W
04A48:  MOVWF  02
04A4A:  MOVLW  00
04A4C:  ADDWFC xBB,W
04A4E:  MOVFF  9C5,FEA
04A52:  MOVFF  9C4,FE9
04A56:  MOVFF  00,FEF
04A5A:  MOVFF  01,FEC
04A5E:  MOVFF  02,FEC
04A62:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04A64:  MOVLW  04
04A66:  MOVLB  7
04A68:  ADDWF  x12,W
04A6A:  MOVWF  01
04A6C:  MOVLW  00
04A6E:  ADDWFC x13,W
04A70:  MOVWF  03
04A72:  MOVFF  01,9C4
04A76:  MOVLB  9
04A78:  MOVWF  xC5
04A7A:  MOVLW  35
04A7C:  MOVLB  7
04A7E:  ADDWF  x12,W
04A80:  MOVWF  01
04A82:  MOVLW  00
04A84:  ADDWFC x13,W
04A86:  MOVFF  01,FE9
04A8A:  MOVWF  FEA
04A8C:  MOVFF  FEC,03
04A90:  MOVF   FED,F
04A92:  MOVFF  FEF,9C6
04A96:  MOVLB  9
04A98:  MOVFF  9C5,FEA
04A9C:  MOVFF  9C4,FE9
04AA0:  MOVFF  03,FEC
04AA4:  MOVF   FED,F
04AA6:  MOVFF  9C6,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04AAA:  MOVLW  08
04AAC:  MOVLB  7
04AAE:  ADDWF  x12,W
04AB0:  MOVWF  FE9
04AB2:  MOVLW  00
04AB4:  ADDWFC x13,W
04AB6:  MOVWF  FEA
04AB8:  MOVFF  FEF,9D7
04ABC:  MOVFF  FEC,9D8
04AC0:  MOVFF  FEC,9D9
04AC4:  MOVFF  FEC,9DA
04AC8:  MOVLW  03
04ACA:  ADDWF  x12,W
04ACC:  MOVWF  FE9
04ACE:  MOVLW  00
04AD0:  ADDWFC x13,W
04AD2:  MOVWF  FEA
04AD4:  MOVFF  FEF,9DB
04AD8:  MOVLB  9
04ADA:  MOVFF  FEA,9CA
04ADE:  MOVFF  FE9,9C9
04AE2:  CLRF   xDE
04AE4:  CLRF   xDD
04AE6:  CLRF   xDC
04AE8:  MOVLB  0
04AEA:  RCALL  478E
04AEC:  MOVFF  9CA,FEA
04AF0:  MOVFF  9C9,FE9
04AF4:  MOVFF  03,9C7
04AF8:  MOVFF  02,9C6
04AFC:  MOVFF  01,9C5
04B00:  MOVFF  00,9C4
04B04:  MOVLW  10
04B06:  MOVLB  7
04B08:  ADDWF  x12,W
04B0A:  MOVWF  FE9
04B0C:  MOVLW  00
04B0E:  ADDWFC x13,W
04B10:  MOVWF  FEA
04B12:  MOVFF  FEF,00
04B16:  MOVFF  FEC,01
04B1A:  MOVFF  FEC,02
04B1E:  MOVFF  FEC,03
04B22:  MOVF   00,W
04B24:  MOVLB  9
04B26:  ADDWF  xC4,W
04B28:  MOVWF  xBC
04B2A:  MOVF   01,W
04B2C:  ADDWFC xC5,W
04B2E:  MOVWF  xBD
04B30:  MOVF   02,W
04B32:  ADDWFC xC6,W
04B34:  MOVWF  xBE
04B36:  MOVF   03,W
04B38:  ADDWFC xC7,W
04B3A:  MOVWF  xBF
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04B3C:  MOVF   xB7,W
04B3E:  SUBLW  03
04B40:  BNZ   4BB2
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04B42:  MOVLW  14
04B44:  MOVLB  7
04B46:  ADDWF  x12,W
04B48:  MOVWF  01
04B4A:  MOVLW  00
04B4C:  ADDWFC x13,W
04B4E:  MOVWF  03
04B50:  MOVFF  01,9C4
04B54:  MOVLB  9
04B56:  MOVWF  xC5
04B58:  MOVLW  50
04B5A:  MOVLB  7
04B5C:  ADDWF  x12,W
04B5E:  MOVWF  01
04B60:  MOVLW  00
04B62:  ADDWFC x13,W
04B64:  MOVFF  01,FE9
04B68:  MOVWF  FEA
04B6A:  MOVFF  FEF,00
04B6E:  MOVFF  FEC,01
04B72:  MOVFF  FEC,02
04B76:  MOVFF  FEC,03
04B7A:  MOVFF  9C5,FEA
04B7E:  MOVFF  9C4,FE9
04B82:  MOVFF  00,FEF
04B86:  MOVFF  01,FEC
04B8A:  MOVFF  02,FEC
04B8E:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04B92:  MOVLW  18
04B94:  ADDWF  x12,W
04B96:  MOVWF  FE9
04B98:  MOVLW  00
04B9A:  ADDWFC x13,W
04B9C:  MOVWF  FEA
04B9E:  MOVFF  9BC,FEF
04BA2:  MOVFF  9BD,FEC
04BA6:  MOVFF  9BE,FEC
04BAA:  MOVFF  9BF,FEC
....................       }  
04BAE:  BRA    4C3E
04BB0:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04BB2:  MOVLW  14
04BB4:  MOVLB  7
04BB6:  ADDWF  x12,W
04BB8:  MOVWF  FE9
04BBA:  MOVLW  00
04BBC:  ADDWFC x13,W
04BBE:  MOVWF  FEA
04BC0:  MOVFF  9BC,FEF
04BC4:  MOVFF  9BD,FEC
04BC8:  MOVFF  9BE,FEC
04BCC:  MOVFF  9BF,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04BD0:  MOVLW  18
04BD2:  ADDWF  x12,W
04BD4:  MOVWF  01
04BD6:  MOVLW  00
04BD8:  ADDWFC x13,W
04BDA:  MOVFF  01,9C4
04BDE:  MOVLB  9
04BE0:  MOVWF  xC5
04BE2:  MOVLW  04
04BE4:  MOVLB  7
04BE6:  ADDWF  x12,W
04BE8:  MOVWF  FE9
04BEA:  MOVLW  00
04BEC:  ADDWFC x13,W
04BEE:  MOVWF  FEA
04BF0:  MOVFF  FEC,9C7
04BF4:  MOVF   FED,F
04BF6:  MOVFF  FEF,9C6
04BFA:  MOVLB  9
04BFC:  RRCF   xC7,F
04BFE:  RRCF   xC6,F
04C00:  RRCF   xC7,F
04C02:  RRCF   xC6,F
04C04:  RRCF   xC7,F
04C06:  RRCF   xC6,F
04C08:  RRCF   xC7,F
04C0A:  RRCF   xC6,F
04C0C:  MOVLW  0F
04C0E:  ANDWF  xC7,F
04C10:  MOVF   xC6,W
04C12:  ADDWF  xBC,W
04C14:  MOVWF  00
04C16:  MOVF   xC7,W
04C18:  ADDWFC xBD,W
04C1A:  MOVWF  01
04C1C:  MOVLW  00
04C1E:  ADDWFC xBE,W
04C20:  MOVWF  02
04C22:  MOVLW  00
04C24:  ADDWFC xBF,W
04C26:  MOVFF  9C5,FEA
04C2A:  MOVFF  9C4,FE9
04C2E:  MOVFF  00,FEF
04C32:  MOVFF  01,FEC
04C36:  MOVFF  02,FEC
04C3A:  MOVWF  FEC
04C3C:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04C3E:  MOVLW  44
04C40:  ADDWF  x12,W
04C42:  MOVWF  01
04C44:  MOVLW  00
04C46:  ADDWFC x13,W
04C48:  MOVFF  01,FE9
04C4C:  MOVWF  FEA
04C4E:  MOVFF  FEF,9C0
04C52:  MOVFF  FEC,9C1
04C56:  MOVFF  FEC,9C2
04C5A:  MOVFF  FEC,9C3
....................    if (!maxsect)  
04C5E:  MOVLB  9
04C60:  MOVF   xC0,F
04C62:  BNZ   4C92
04C64:  MOVF   xC1,F
04C66:  BNZ   4C92
04C68:  MOVF   xC2,F
04C6A:  BNZ   4C92
04C6C:  MOVF   xC3,F
04C6E:  BNZ   4C92
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04C70:  MOVLW  37
04C72:  MOVLB  7
04C74:  ADDWF  x12,W
04C76:  MOVWF  01
04C78:  MOVLW  00
04C7A:  ADDWFC x13,W
04C7C:  MOVFF  01,FE9
04C80:  MOVWF  FEA
04C82:  MOVLB  9
04C84:  CLRF   xC3
04C86:  CLRF   xC2
04C88:  MOVFF  FEC,9C1
04C8C:  MOVF   FED,F
04C8E:  MOVFF  FEF,9C0
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04C92:  MOVLW  0C
04C94:  MOVLB  7
04C96:  ADDWF  x12,W
04C98:  MOVWF  01
04C9A:  MOVLW  00
04C9C:  ADDWFC x13,W
04C9E:  MOVWF  03
04CA0:  MOVFF  01,9C4
04CA4:  MOVLB  9
04CA6:  MOVWF  xC5
04CA8:  MOVLW  18
04CAA:  MOVLB  7
04CAC:  ADDWF  x12,W
04CAE:  MOVWF  FE9
04CB0:  MOVLW  00
04CB2:  ADDWFC x13,W
04CB4:  MOVWF  FEA
04CB6:  MOVFF  FEF,00
04CBA:  MOVFF  FEC,01
04CBE:  MOVFF  FEC,02
04CC2:  MOVFF  FEC,03
04CC6:  MOVF   00,W
04CC8:  MOVLB  9
04CCA:  SUBWF  xC0,W
04CCC:  MOVWF  xC6
04CCE:  MOVF   01,W
04CD0:  SUBWFB xC1,W
04CD2:  MOVWF  xC7
04CD4:  MOVF   02,W
04CD6:  SUBWFB xC2,W
04CD8:  MOVWF  xC8
04CDA:  MOVF   03,W
04CDC:  SUBWFB xC3,W
04CDE:  MOVWF  xC9
04CE0:  MOVF   xB8,W
04CE2:  ADDWF  xC6,F
04CE4:  MOVF   xB9,W
04CE6:  ADDWFC xC7,F
04CE8:  MOVF   xBA,W
04CEA:  ADDWFC xC8,F
04CEC:  MOVF   xBB,W
04CEE:  ADDWFC xC9,F
04CF0:  MOVLW  02
04CF2:  MOVLB  7
04CF4:  ADDWF  x12,W
04CF6:  MOVWF  FE9
04CF8:  MOVLW  00
04CFA:  ADDWFC x13,W
04CFC:  MOVWF  FEA
04CFE:  MOVFF  FEF,A2C
04D02:  MOVLB  9
04D04:  MOVFF  FEA,9CC
04D08:  MOVFF  FE9,9CB
04D0C:  BCF    FD8.1
04D0E:  CLRF   1B
04D10:  BTFSC  FF2.7
04D12:  BSF    1B.7
04D14:  BCF    FF2.7
04D16:  MOVFF  9C9,A2B
04D1A:  MOVFF  9C8,A2A
04D1E:  MOVFF  9C7,A29
04D22:  MOVFF  9C6,A28
04D26:  MOVLB  A
04D28:  CLRF   x2F
04D2A:  CLRF   x2E
04D2C:  CLRF   x2D
04D2E:  MOVLB  0
04D30:  CALL   1056
04D34:  BTFSC  1B.7
04D36:  BSF    FF2.7
04D38:  MOVFF  9CC,FEA
04D3C:  MOVFF  9CB,FE9
04D40:  MOVFF  03,9C9
04D44:  MOVFF  02,9C8
04D48:  MOVFF  01,9C7
04D4C:  MOVFF  00,9C6
04D50:  MOVLW  02
04D52:  MOVLB  9
04D54:  ADDWF  00,W
04D56:  MOVWF  00
04D58:  MOVLW  00
04D5A:  ADDWFC 01,W
04D5C:  MOVWF  01
04D5E:  MOVLW  00
04D60:  ADDWFC 02,W
04D62:  MOVWF  02
04D64:  MOVLW  00
04D66:  ADDWFC 03,W
04D68:  MOVFF  9C5,FEA
04D6C:  MOVFF  9C4,FE9
04D70:  MOVFF  00,FEF
04D74:  MOVFF  01,FEC
04D78:  MOVFF  02,FEC
04D7C:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04D7E:  MOVLW  00
04D80:  MOVWF  01
04D82:  MOVLB  7
04D84:  MOVLB  0
04D86:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
070BA:  CALL   553C
070BE:  MOVFF  01,9A4
....................    if (result != FR_OK)  
070C2:  MOVLB  9
070C4:  MOVF   xA4,F
070C6:  BZ    70CE
....................       return (result); 
070C8:  MOVFF  9A4,01
070CC:  BRA    74FE
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
070CE:  MOVF   x95,W
070D0:  ANDLW  0A
070D2:  BZ    70EA
070D4:  MOVLB  0
070D6:  CALL   552E
070DA:  BTFSC  01.2
070DC:  BRA    70E2
070DE:  MOVLB  9
070E0:  BRA    70EA
....................          return (FR_WRITE_PROTECTED); 
070E2:  MOVLW  0A
070E4:  MOVWF  01
070E6:  MOVLB  9
070E8:  BRA    74FE
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
070EA:  MOVLW  09
070EC:  MOVWF  xB8
070EE:  MOVLW  96
070F0:  MOVWF  xB7
070F2:  MOVLW  09
070F4:  MOVWF  xBA
070F6:  MOVLW  A7
070F8:  MOVWF  xB9
070FA:  MOVFF  994,9BC
070FE:  MOVFF  993,9BB
07102:  MOVLW  09
07104:  MOVWF  xBE
07106:  MOVLW  A5
07108:  MOVWF  xBD
0710A:  MOVLB  0
0710C:  CALL   6166
07110:  MOVFF  01,9A4
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
07114:  MOVLB  9
07116:  MOVF   x95,W
07118:  ANDLW  18
0711A:  BTFSC  FD8.2
0711C:  BRA    7340
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
0711E:  MOVF   xA4,F
07120:  BZ    71A8
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
07122:  BSF    x95.3
....................          if (result != FR_NO_FILE) 
07124:  MOVF   xA4,W
07126:  SUBLW  02
07128:  BZ    7130
....................             return (result); 
0712A:  MOVFF  9A4,01
0712E:  BRA    74FE
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
07130:  MOVLW  09
07132:  MOVWF  xB8
07134:  MOVLW  96
07136:  MOVWF  xB7
07138:  MOVLB  0
0713A:  BRA    6B64
0713C:  MOVFF  02,9A6
07140:  MOVFF  01,9A5
....................          if (dir_ptr == NULL) 
07144:  MOVLB  9
07146:  MOVF   xA5,F
07148:  BNZ   7154
0714A:  MOVF   xA6,F
0714C:  BNZ   7154
....................             return (FR_DENIED); 
0714E:  MOVLW  05
07150:  MOVWF  01
07152:  BRA    74FE
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
07154:  MOVFF  9A6,FEA
07158:  MOVFF  9A5,FE9
0715C:  MOVLW  09
0715E:  MOVWF  FE2
07160:  MOVLW  A7
07162:  MOVWF  FE1
07164:  MOVLW  0B
07166:  MOVWF  01
07168:  MOVFF  FE6,FEE
0716C:  DECFSZ 01,F
0716E:  BRA    7168
....................          *(dir_ptr+12) = fn[11]; 
07170:  MOVLW  0C
07172:  ADDWF  xA5,W
07174:  MOVWF  01
07176:  MOVLW  00
07178:  ADDWFC xA6,W
0717A:  MOVFF  01,FE9
0717E:  MOVWF  FEA
07180:  MOVFF  9B2,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
07184:  MOVLW  0D
07186:  ADDWF  xA5,W
07188:  MOVWF  xB7
0718A:  MOVLW  00
0718C:  ADDWFC xA6,W
0718E:  MOVWF  xB8
07190:  MOVWF  FEA
07192:  MOVFF  9B7,FE9
07196:  CLRF   00
07198:  CLRF   02
0719A:  MOVLW  13
0719C:  MOVWF  01
0719E:  MOVLB  0
071A0:  CALL   34C2
....................       }  
071A4:  BRA    72BA
071A6:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
071A8:  MOVF   xA5,F
071AA:  BNZ   71B0
071AC:  MOVF   xA6,F
071AE:  BZ    71C8
071B0:  MOVLW  0B
071B2:  ADDWF  xA5,W
071B4:  MOVWF  01
071B6:  MOVLW  00
071B8:  ADDWFC xA6,W
071BA:  MOVWF  03
071BC:  MOVFF  01,FE9
071C0:  MOVWF  FEA
071C2:  MOVF   FEF,W
071C4:  ANDLW  11
071C6:  BZ    71CE
....................             return (FR_DENIED); 
071C8:  MOVLW  05
071CA:  MOVWF  01
071CC:  BRA    74FE
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
071CE:  BTFSS  x95.3
071D0:  BRA    72B8
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
071D2:  MOVLW  20
071D4:  MOVLB  7
071D6:  ADDWF  x12,W
071D8:  MOVWF  FE9
071DA:  MOVLW  00
071DC:  ADDWFC x13,W
071DE:  MOVWF  FEA
071E0:  MOVFF  FEF,9B3
071E4:  MOVFF  FEC,9B4
071E8:  MOVFF  FEC,9B5
071EC:  MOVFF  FEC,9B6
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
071F0:  MOVLW  14
071F2:  MOVLB  9
071F4:  ADDWF  xA5,W
071F6:  MOVWF  01
071F8:  MOVLW  00
071FA:  ADDWFC xA6,W
071FC:  MOVWF  03
071FE:  MOVFF  01,FE9
07202:  MOVWF  FEA
07204:  MOVFF  FEC,9BF
07208:  MOVF   FED,F
0720A:  MOVFF  FEF,9B7
0720E:  CLRF   xB9
07210:  MOVFF  9B7,9BE
07214:  CLRF   xB7
07216:  CLRF   xB8
07218:  MOVLW  1A
0721A:  ADDWF  xA5,W
0721C:  MOVWF  01
0721E:  MOVLW  00
07220:  ADDWFC xA6,W
07222:  MOVFF  01,FE9
07226:  MOVWF  FEA
07228:  MOVFF  FEC,03
0722C:  MOVF   FED,F
0722E:  MOVF   FEF,W
07230:  IORWF  xB7,F
07232:  MOVF   03,W
07234:  IORWF  xB8,F
07236:  MOVFF  9B8,9BD
0723A:  MOVFF  9B7,9BC
0723E:  MOVLB  0
07240:  RCALL  6EAA
07242:  MOVF   01,F
07244:  BZ    725E
07246:  MOVFF  9B6,9F4
0724A:  MOVFF  9B5,9F3
0724E:  MOVFF  9B4,9F2
07252:  MOVFF  9B3,9F1
07256:  CALL   5A16
0725A:  MOVF   01,F
0725C:  BNZ   7268
....................                return (FR_RW_ERROR); 
0725E:  MOVLW  07
07260:  MOVWF  01
07262:  MOVLB  9
07264:  BRA    74FE
07266:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
07268:  MOVLW  14
0726A:  MOVLB  9
0726C:  ADDWF  xA5,W
0726E:  MOVWF  01
07270:  MOVLW  00
07272:  ADDWFC xA6,W
07274:  MOVFF  01,FE9
07278:  MOVWF  FEA
0727A:  CLRF   FEC
0727C:  MOVF   FED,F
0727E:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
07280:  MOVLW  1A
07282:  ADDWF  xA5,W
07284:  MOVWF  01
07286:  MOVLW  00
07288:  ADDWFC xA6,W
0728A:  MOVFF  01,FE9
0728E:  MOVWF  FEA
07290:  CLRF   FEC
07292:  MOVF   FED,F
07294:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
07296:  MOVLW  1C
07298:  ADDWF  xA5,W
0729A:  MOVWF  01
0729C:  MOVLW  00
0729E:  ADDWFC xA6,W
072A0:  MOVFF  01,FE9
072A4:  MOVWF  FEA
072A6:  MOVF   FEE,F
072A8:  MOVF   FEE,F
072AA:  CLRF   FEC
072AC:  MOVF   FED,F
072AE:  CLRF   FEF
072B0:  MOVF   FED,F
072B2:  CLRF   FEF
072B4:  MOVF   FED,F
072B6:  CLRF   FEF
072B8:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
072BA:  MOVLB  9
072BC:  BTFSS  x95.3
072BE:  BRA    733E
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
072C0:  MOVLW  0B
072C2:  ADDWF  xA5,W
072C4:  MOVWF  01
072C6:  MOVLW  00
072C8:  ADDWFC xA6,W
072CA:  MOVFF  01,FE9
072CE:  MOVWF  FEA
072D0:  MOVLW  20
072D2:  MOVWF  FEF
....................          dw = get_fattime(); 
072D4:  MOVLB  0
072D6:  RCALL  6F4A
072D8:  MOVFF  03,9B6
072DC:  MOVFF  02,9B5
072E0:  MOVFF  01,9B4
072E4:  MOVFF  00,9B3
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
072E8:  MOVLW  0E
072EA:  MOVLB  9
072EC:  ADDWF  xA5,W
072EE:  MOVWF  01
072F0:  MOVLW  00
072F2:  ADDWFC xA6,W
072F4:  MOVFF  01,FE9
072F8:  MOVWF  FEA
072FA:  MOVFF  9B3,FEF
072FE:  MOVFF  9B4,FEC
07302:  MOVFF  9B5,FEC
07306:  MOVFF  9B6,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
0730A:  MOVLW  16
0730C:  ADDWF  xA5,W
0730E:  MOVWF  01
07310:  MOVLW  00
07312:  ADDWFC xA6,W
07314:  MOVFF  01,FE9
07318:  MOVWF  FEA
0731A:  MOVFF  9B3,FEF
0731E:  MOVFF  9B4,FEC
07322:  MOVFF  9B5,FEC
07326:  MOVFF  9B6,FEC
....................          fs->winflag = 1; 
0732A:  MOVLW  06
0732C:  MOVLB  7
0732E:  ADDWF  x12,W
07330:  MOVWF  FE9
07332:  MOVLW  00
07334:  ADDWFC x13,W
07336:  MOVWF  FEA
07338:  MOVLW  01
0733A:  MOVWF  FEF
0733C:  MOVLB  9
....................       } 
....................    } 
0733E:  BRA    738E
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
07340:  MOVF   xA4,F
07342:  BZ    734A
....................          return (result);      // Trace failed  
07344:  MOVFF  9A4,01
07348:  BRA    74FE
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
0734A:  MOVF   xA5,F
0734C:  BNZ   7352
0734E:  MOVF   xA6,F
07350:  BZ    7368
07352:  MOVLW  0B
07354:  ADDWF  xA5,W
07356:  MOVWF  01
07358:  MOVLW  00
0735A:  ADDWFC xA6,W
0735C:  MOVWF  03
0735E:  MOVFF  01,FE9
07362:  MOVWF  FEA
07364:  BTFSS  FEF.4
07366:  BRA    736E
....................          return (FR_NO_FILE); 
07368:  MOVLW  02
0736A:  MOVWF  01
0736C:  BRA    74FE
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
0736E:  BTFSS  x95.1
07370:  BRA    738E
07372:  MOVLW  0B
07374:  ADDWF  xA5,W
07376:  MOVWF  01
07378:  MOVLW  00
0737A:  ADDWFC xA6,W
0737C:  MOVWF  03
0737E:  MOVFF  01,FE9
07382:  MOVWF  FEA
07384:  BTFSS  FEF.0
07386:  BRA    738E
....................          return (FR_DENIED); 
07388:  MOVLW  05
0738A:  MOVWF  01
0738C:  BRA    74FE
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
0738E:  MOVLW  1A
07390:  ADDWF  x91,W
07392:  MOVWF  FE9
07394:  MOVLW  00
07396:  ADDWFC x92,W
07398:  MOVWF  FEA
0739A:  MOVF   x95,W
0739C:  ANDLW  03
0739E:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
073A0:  MOVLW  14
073A2:  ADDWF  x91,W
073A4:  MOVWF  01
073A6:  MOVLW  00
073A8:  ADDWFC x92,W
073AA:  MOVWF  03
073AC:  MOVFF  01,9B7
073B0:  MOVWF  xB8
073B2:  MOVLW  20
073B4:  MOVLB  7
073B6:  ADDWF  x12,W
073B8:  MOVWF  FE9
073BA:  MOVLW  00
073BC:  ADDWFC x13,W
073BE:  MOVWF  FEA
073C0:  MOVFF  FEF,00
073C4:  MOVFF  FEC,01
073C8:  MOVFF  FEC,02
073CC:  MOVFF  FEC,03
073D0:  MOVFF  9B8,FEA
073D4:  MOVFF  9B7,FE9
073D8:  MOVFF  00,FEF
073DC:  MOVFF  01,FEC
073E0:  MOVFF  02,FEC
073E4:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
073E8:  MOVLW  18
073EA:  MOVLB  9
073EC:  ADDWF  x91,W
073EE:  MOVWF  FE9
073F0:  MOVLW  00
073F2:  ADDWFC x92,W
073F4:  MOVWF  FEA
073F6:  MOVFF  9A6,FEC
073FA:  MOVF   FED,F
073FC:  MOVFF  9A5,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
07400:  MOVLW  08
07402:  ADDWF  x91,W
07404:  MOVWF  01
07406:  MOVLW  00
07408:  ADDWFC x92,W
0740A:  MOVWF  03
0740C:  MOVFF  01,9B7
07410:  MOVWF  xB8
07412:  MOVLW  14
07414:  ADDWF  xA5,W
07416:  MOVWF  01
07418:  MOVLW  00
0741A:  ADDWFC xA6,W
0741C:  MOVWF  03
0741E:  MOVFF  01,FE9
07422:  MOVWF  FEA
07424:  MOVFF  FEC,9BC
07428:  MOVF   FED,F
0742A:  MOVFF  FEF,9B9
0742E:  CLRF   xBB
07430:  MOVFF  9B9,9BB
07434:  CLRF   xB9
07436:  CLRF   xBA
07438:  MOVLW  1A
0743A:  ADDWF  xA5,W
0743C:  MOVWF  01
0743E:  MOVLW  00
07440:  ADDWFC xA6,W
07442:  MOVFF  01,FE9
07446:  MOVWF  FEA
07448:  MOVFF  FEC,03
0744C:  MOVF   FED,F
0744E:  MOVF   FEF,W
07450:  IORWF  xB9,W
07452:  MOVWF  00
07454:  MOVF   03,W
07456:  IORWF  xBA,W
07458:  MOVFF  9BB,02
0745C:  MOVFF  9BC,03
07460:  MOVFF  9B8,FEA
07464:  MOVFF  9B7,FE9
07468:  MOVFF  00,FEF
0746C:  MOVWF  FEC
0746E:  MOVFF  9BB,FEC
07472:  MOVFF  9BC,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
07476:  MOVLW  04
07478:  ADDWF  x91,W
0747A:  MOVWF  01
0747C:  MOVLW  00
0747E:  ADDWFC x92,W
07480:  MOVWF  03
07482:  MOVFF  01,9B7
07486:  MOVWF  xB8
07488:  MOVLW  1C
0748A:  ADDWF  xA5,W
0748C:  MOVWF  01
0748E:  MOVLW  00
07490:  ADDWFC xA6,W
07492:  MOVFF  01,FE9
07496:  MOVWF  FEA
07498:  MOVFF  FEF,00
0749C:  MOVFF  FEC,01
074A0:  MOVFF  FEC,02
074A4:  MOVFF  FEC,03
074A8:  MOVFF  9B8,FEA
074AC:  MOVFF  9B7,FE9
074B0:  MOVFF  00,FEF
074B4:  MOVFF  01,FEC
074B8:  MOVFF  02,FEC
074BC:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
074C0:  MOVFF  991,FE9
074C4:  MOVFF  992,FEA
074C8:  MOVF   FEE,F
074CA:  MOVF   FEE,F
074CC:  CLRF   FEC
074CE:  MOVF   FED,F
074D0:  CLRF   FEF
074D2:  MOVF   FED,F
074D4:  CLRF   FEF
074D6:  MOVF   FED,F
074D8:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
074DA:  MOVLW  1B
074DC:  ADDWF  x91,W
074DE:  MOVWF  FE9
074E0:  MOVLW  00
074E2:  ADDWFC x92,W
074E4:  MOVWF  FEA
074E6:  MOVLW  01
074E8:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
074EA:  MOVLB  7
074EC:  ADDWF  x12,W
074EE:  MOVWF  FE9
074F0:  MOVLW  00
074F2:  ADDWFC x13,W
074F4:  MOVWF  FEA
074F6:  INCF   FEF,F
....................    return (FR_OK); 
074F8:  MOVLW  00
074FA:  MOVWF  01
074FC:  MOVLB  9
074FE:  MOVLB  0
07500:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B0F2:  MOVFF  8B0,8C5
0B0F6:  MOVFF  8AF,8C4
....................       *br = 0; 
0B0FA:  MOVLB  8
0B0FC:  MOVFF  8B3,FE9
0B100:  MOVFF  8B4,FEA
0B104:  CLRF   FEC
0B106:  MOVF   FED,F
0B108:  CLRF   FEF
....................       if (!fs)  
0B10A:  MOVLB  7
0B10C:  MOVF   x12,W
0B10E:  IORWF  x13,W
0B110:  BNZ   B118
....................          return (FR_NOT_ENABLED); 
0B112:  MOVLW  0B
0B114:  MOVWF  01
0B116:  BRA    B5FA
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B118:  MOVLB  0
0B11A:  CALL   552E
0B11E:  BTFSC  01.0
0B120:  BRA    B132
0B122:  MOVLB  7
0B124:  MOVFF  712,FE9
0B128:  MOVFF  713,FEA
0B12C:  MOVF   FEF,F
0B12E:  BNZ   B13A
0B130:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B132:  MOVLW  01
0B134:  MOVWF  01
0B136:  MOVLB  7
0B138:  BRA    B5FA
....................     
....................       if (fp->flag & FA__ERROR) 
0B13A:  MOVLW  1A
0B13C:  MOVLB  8
0B13E:  ADDWF  xAD,W
0B140:  MOVWF  FE9
0B142:  MOVLW  00
0B144:  ADDWFC xAE,W
0B146:  MOVWF  FEA
0B148:  BTFSS  FEF.7
0B14A:  BRA    B156
....................          return (FR_RW_ERROR);   // Check error flag  
0B14C:  MOVLW  07
0B14E:  MOVWF  01
0B150:  MOVLB  7
0B152:  BRA    B5FA
0B154:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B156:  MOVLW  1A
0B158:  ADDWF  xAD,W
0B15A:  MOVWF  FE9
0B15C:  MOVLW  00
0B15E:  ADDWFC xAE,W
0B160:  MOVWF  FEA
0B162:  BTFSC  FEF.0
0B164:  BRA    B170
....................          return (FR_DENIED);      // Check access mode  
0B166:  MOVLW  05
0B168:  MOVWF  01
0B16A:  MOVLB  7
0B16C:  BRA    B5FA
0B16E:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B170:  MOVLW  04
0B172:  ADDWF  xAD,W
0B174:  MOVWF  FE9
0B176:  MOVLW  00
0B178:  ADDWFC xAE,W
0B17A:  MOVWF  FEA
0B17C:  MOVFF  FEF,8C6
0B180:  MOVFF  FEC,8C7
0B184:  MOVFF  FEC,8C8
0B188:  MOVFF  FEC,8C9
0B18C:  MOVFF  8AD,FE9
0B190:  MOVFF  8AE,FEA
0B194:  MOVFF  FEF,00
0B198:  MOVFF  FEC,01
0B19C:  MOVFF  FEC,02
0B1A0:  MOVFF  FEC,03
0B1A4:  MOVF   00,W
0B1A6:  SUBWF  xC6,W
0B1A8:  MOVWF  xBD
0B1AA:  MOVF   01,W
0B1AC:  SUBWFB xC7,W
0B1AE:  MOVWF  xBE
0B1B0:  MOVF   02,W
0B1B2:  SUBWFB xC8,W
0B1B4:  MOVWF  xBF
0B1B6:  MOVF   03,W
0B1B8:  SUBWFB xC9,W
0B1BA:  MOVWF  xC0
....................       if (btr > ln) 
0B1BC:  MOVF   xC0,F
0B1BE:  BNZ   B1DA
0B1C0:  MOVF   xBF,F
0B1C2:  BNZ   B1DA
0B1C4:  MOVF   xBE,W
0B1C6:  SUBWF  xB2,W
0B1C8:  BNC   B1DA
0B1CA:  BNZ   B1D2
0B1CC:  MOVF   xB1,W
0B1CE:  SUBWF  xBD,W
0B1D0:  BC    B1DA
....................          btr = ln;            // Truncate read count by number of bytes left  
0B1D2:  MOVFF  8BE,8B2
0B1D6:  MOVFF  8BD,8B1
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B1DA:  MOVF   xB1,W
0B1DC:  IORWF  xB2,W
0B1DE:  BTFSC  FD8.2
0B1E0:  BRA    B5D8
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B1E2:  MOVFF  8AD,FE9
0B1E6:  MOVFF  8AE,FEA
0B1EA:  MOVFF  FEF,8C6
0B1EE:  MOVFF  FEC,8C7
0B1F2:  MOVFF  FEC,8C8
0B1F6:  MOVFF  FEC,8C9
0B1FA:  MOVLW  01
0B1FC:  ANDWF  xC7,F
0B1FE:  CLRF   xC8
0B200:  CLRF   xC9
0B202:  MOVF   xC6,F
0B204:  BTFSS  FD8.2
0B206:  BRA    B480
0B208:  MOVF   xC7,F
0B20A:  BTFSS  FD8.2
0B20C:  BRA    B480
0B20E:  MOVF   xC8,F
0B210:  BTFSS  FD8.2
0B212:  BRA    B480
0B214:  MOVF   xC9,F
0B216:  BTFSS  FD8.2
0B218:  BRA    B480
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B21A:  MOVLW  1B
0B21C:  ADDWF  xAD,W
0B21E:  MOVWF  FE9
0B220:  MOVLW  00
0B222:  ADDWFC xAE,W
0B224:  MOVWF  FEA
0B226:  DECF   FEF,F
0B228:  BZ    B260
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B22A:  MOVLW  10
0B22C:  ADDWF  xAD,W
0B22E:  MOVWF  FE9
0B230:  MOVLW  00
0B232:  ADDWFC xAE,W
0B234:  MOVWF  FEA
0B236:  MOVFF  FEF,8C6
0B23A:  MOVFF  FEC,8C7
0B23E:  MOVFF  FEC,8C8
0B242:  MOVFF  FEC,8C9
0B246:  MOVLW  01
0B248:  ADDWF  xC6,W
0B24A:  MOVWF  xB9
0B24C:  MOVLW  00
0B24E:  ADDWFC xC7,W
0B250:  MOVWF  xBA
0B252:  MOVLW  00
0B254:  ADDWFC xC8,W
0B256:  MOVWF  xBB
0B258:  MOVLW  00
0B25A:  ADDWFC xC9,W
0B25C:  MOVWF  xBC
....................                }  
0B25E:  BRA    B39C
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B260:  MOVFF  8AD,FE9
0B264:  MOVFF  8AE,FEA
0B268:  MOVFF  FEF,8C6
0B26C:  MOVFF  FEC,8C7
0B270:  MOVFF  FEC,8C8
0B274:  MOVFF  FEC,8C9
0B278:  MOVF   xC6,F
0B27A:  BNZ   B2A6
0B27C:  MOVF   xC7,F
0B27E:  BNZ   B2A6
0B280:  MOVF   xC8,F
0B282:  BNZ   B2A6
0B284:  MOVF   xC9,F
0B286:  BNZ   B2A6
0B288:  MOVLW  08
0B28A:  ADDWF  xAD,W
0B28C:  MOVWF  FE9
0B28E:  MOVLW  00
0B290:  ADDWFC xAE,W
0B292:  MOVWF  FEA
0B294:  MOVFF  FEF,00
0B298:  MOVFF  FEC,01
0B29C:  MOVFF  FEC,02
0B2A0:  MOVFF  FEC,03
0B2A4:  BRA    B2CA
0B2A6:  MOVLW  0C
0B2A8:  ADDWF  xAD,W
0B2AA:  MOVWF  FE9
0B2AC:  MOVLW  00
0B2AE:  ADDWFC xAE,W
0B2B0:  MOVWF  FEA
0B2B2:  MOVFF  FEF,9DD
0B2B6:  MOVFF  FEC,9DE
0B2BA:  MOVFF  FEC,9DF
0B2BE:  MOVFF  FEC,9E0
0B2C2:  MOVLB  0
0B2C4:  CALL   5C54
0B2C8:  MOVLB  8
0B2CA:  MOVFF  03,8B8
0B2CE:  MOVFF  02,8B7
0B2D2:  MOVFF  01,8B6
0B2D6:  MOVFF  00,8B5
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B2DA:  MOVF   xB8,F
0B2DC:  BNZ   B2EC
0B2DE:  MOVF   xB7,F
0B2E0:  BNZ   B2EC
0B2E2:  MOVF   xB6,F
0B2E4:  BNZ   B2EC
0B2E6:  MOVF   xB5,W
0B2E8:  SUBLW  01
0B2EA:  BC    B32A
0B2EC:  MOVLW  0C
0B2EE:  MOVLB  7
0B2F0:  ADDWF  x12,W
0B2F2:  MOVWF  FE9
0B2F4:  MOVLW  00
0B2F6:  ADDWFC x13,W
0B2F8:  MOVWF  FEA
0B2FA:  MOVFF  FEF,00
0B2FE:  MOVFF  FEC,01
0B302:  MOVFF  FEC,02
0B306:  MOVFF  FEC,03
0B30A:  MOVF   03,W
0B30C:  MOVLB  8
0B30E:  SUBWF  xB8,W
0B310:  BNC   B32C
0B312:  BNZ   B32A
0B314:  MOVF   02,W
0B316:  SUBWF  xB7,W
0B318:  BNC   B32C
0B31A:  BNZ   B32A
0B31C:  MOVF   01,W
0B31E:  SUBWF  xB6,W
0B320:  BNC   B32C
0B322:  BNZ   B32A
0B324:  MOVF   00,W
0B326:  SUBWF  xB5,W
0B328:  BNC   B32C
....................                   goto fr_error; 
0B32A:  BRA    B5E2
....................                fp->curr_clust = clust;            // Current cluster  
0B32C:  MOVLW  0C
0B32E:  ADDWF  xAD,W
0B330:  MOVWF  FE9
0B332:  MOVLW  00
0B334:  ADDWFC xAE,W
0B336:  MOVWF  FEA
0B338:  MOVFF  8B5,FEF
0B33C:  MOVFF  8B6,FEC
0B340:  MOVFF  8B7,FEC
0B344:  MOVFF  8B8,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B348:  MOVFF  8B8,9D3
0B34C:  MOVFF  8B7,9D2
0B350:  MOVFF  8B6,9D1
0B354:  MOVFF  8B5,9D0
0B358:  MOVLB  0
0B35A:  CALL   559E
0B35E:  MOVFF  03,8BC
0B362:  MOVFF  02,8BB
0B366:  MOVFF  01,8BA
0B36A:  MOVFF  00,8B9
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B36E:  MOVLW  1B
0B370:  MOVLB  8
0B372:  ADDWF  xAD,W
0B374:  MOVWF  01
0B376:  MOVLW  00
0B378:  ADDWFC xAE,W
0B37A:  MOVWF  03
0B37C:  MOVLW  02
0B37E:  MOVLB  7
0B380:  ADDWF  x12,W
0B382:  MOVWF  FE9
0B384:  MOVLW  00
0B386:  ADDWFC x13,W
0B388:  MOVWF  FEA
0B38A:  MOVFF  FEF,8C8
0B38E:  MOVLB  8
0B390:  MOVFF  03,FEA
0B394:  MOVFF  01,FE9
0B398:  MOVFF  8C8,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B39C:  MOVLW  10
0B39E:  ADDWF  xAD,W
0B3A0:  MOVWF  FE9
0B3A2:  MOVLW  00
0B3A4:  ADDWFC xAE,W
0B3A6:  MOVWF  FEA
0B3A8:  MOVFF  8B9,FEF
0B3AC:  MOVFF  8BA,FEC
0B3B0:  MOVFF  8BB,FEC
0B3B4:  MOVFF  8BC,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B3B8:  BCF    FD8.0
0B3BA:  RRCF   xB2,W
0B3BC:  MOVWF  xC3
....................             if (cc)  
0B3BE:  MOVF   xC3,F
0B3C0:  BZ    B480
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B3C2:  MOVLW  1B
0B3C4:  ADDWF  xAD,W
0B3C6:  MOVWF  FE9
0B3C8:  MOVLW  00
0B3CA:  ADDWFC xAE,W
0B3CC:  MOVWF  FEA
0B3CE:  MOVF   FEF,W
0B3D0:  SUBWF  xC3,W
0B3D2:  BZ    B3E6
0B3D4:  BNC   B3E6
....................                   cc = fp->sect_clust; 
0B3D6:  MOVLW  1B
0B3D8:  ADDWF  xAD,W
0B3DA:  MOVWF  FE9
0B3DC:  MOVLW  00
0B3DE:  ADDWFC xAE,W
0B3E0:  MOVWF  FEA
0B3E2:  MOVFF  FEF,8C3
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B3E6:  MOVFF  8C5,9FE
0B3EA:  MOVFF  8C4,9FD
0B3EE:  MOVFF  8BC,A02
0B3F2:  MOVFF  8BB,A01
0B3F6:  MOVFF  8BA,A00
0B3FA:  MOVFF  8B9,9FF
0B3FE:  MOVFF  8C3,A03
0B402:  MOVLB  0
0B404:  CALL   4468
0B408:  MOVF   01,F
0B40A:  BZ    B412
....................                   goto fr_error; 
0B40C:  MOVLB  8
0B40E:  BRA    B5E2
0B410:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B412:  MOVLW  1B
0B414:  MOVLB  8
0B416:  ADDWF  xAD,W
0B418:  MOVWF  FE9
0B41A:  MOVLW  00
0B41C:  ADDWFC xAE,W
0B41E:  MOVWF  FEA
0B420:  MOVLW  01
0B422:  SUBWF  xC3,W
0B424:  SUBWF  FEF,W
0B426:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B428:  MOVLW  10
0B42A:  ADDWF  xAD,W
0B42C:  MOVWF  FE9
0B42E:  MOVLW  00
0B430:  ADDWFC xAE,W
0B432:  MOVWF  FEA
0B434:  MOVLW  01
0B436:  SUBWF  xC3,W
0B438:  ADDWF  FEF,W
0B43A:  MOVWF  00
0B43C:  MOVLW  00
0B43E:  ADDWFC FEC,W
0B440:  MOVWF  01
0B442:  MOVLW  00
0B444:  ADDWFC FEC,W
0B446:  MOVWF  02
0B448:  MOVLW  00
0B44A:  ADDWFC FEC,W
0B44C:  MOVF   FED,F
0B44E:  MOVF   FED,F
0B450:  MOVF   FED,F
0B452:  MOVFF  00,FEF
0B456:  MOVFF  01,FEC
0B45A:  MOVFF  02,FEC
0B45E:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B460:  MOVLB  9
0B462:  CLRF   xEE
0B464:  MOVFF  8C3,9ED
0B468:  MOVLW  02
0B46A:  MOVWF  xF0
0B46C:  CLRF   xEF
0B46E:  MOVLB  0
0B470:  CALL   5C32
0B474:  MOVFF  02,8C2
0B478:  MOVFF  01,8C1
....................                continue; 
0B47C:  BRA    B574
0B47E:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B480:  MOVLW  10
0B482:  ADDWF  xAD,W
0B484:  MOVWF  FE9
0B486:  MOVLW  00
0B488:  ADDWFC xAE,W
0B48A:  MOVWF  FEA
0B48C:  MOVFF  FEF,9F1
0B490:  MOVFF  FEC,9F2
0B494:  MOVFF  FEC,9F3
0B498:  MOVFF  FEC,9F4
0B49C:  MOVLB  0
0B49E:  CALL   5A16
0B4A2:  MOVF   01,F
0B4A4:  BNZ   B4AC
....................                goto fr_error; 
0B4A6:  MOVLB  8
0B4A8:  BRA    B5E2
0B4AA:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B4AC:  MOVLB  8
0B4AE:  MOVFF  8AD,FE9
0B4B2:  MOVFF  8AE,FEA
0B4B6:  MOVFF  FEF,8C6
0B4BA:  MOVFF  FEC,8C7
0B4BE:  MOVFF  FEC,8C8
0B4C2:  MOVFF  FEC,8C9
0B4C6:  MOVF   xC7,W
0B4C8:  ANDLW  01
0B4CA:  MOVWF  01
0B4CC:  MOVLW  00
0B4CE:  BSF    FD8.0
0B4D0:  SUBFWB xC6,W
0B4D2:  MOVWF  xC1
0B4D4:  MOVLW  02
0B4D6:  SUBFWB 01,W
0B4D8:  MOVWF  xC2
....................          if (rcnt > btr) 
0B4DA:  MOVF   xB2,W
0B4DC:  SUBWF  xC2,W
0B4DE:  BNC   B4F0
0B4E0:  BNZ   B4E8
0B4E2:  MOVF   xC1,W
0B4E4:  SUBWF  xB1,W
0B4E6:  BC    B4F0
....................             rcnt = btr; 
0B4E8:  MOVFF  8B2,8C2
0B4EC:  MOVFF  8B1,8C1
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B4F0:  MOVFF  8AD,FE9
0B4F4:  MOVFF  8AE,FEA
0B4F8:  MOVFF  FEF,8C6
0B4FC:  MOVFF  FEC,8C7
0B500:  MOVFF  FEC,8C8
0B504:  MOVFF  FEC,8C9
0B508:  MOVLW  01
0B50A:  ANDWF  xC7,F
0B50C:  CLRF   xC8
0B50E:  CLRF   xC9
0B510:  MOVLW  24
0B512:  ADDWF  xC6,W
0B514:  MOVWF  00
0B516:  MOVLW  00
0B518:  ADDWFC xC7,W
0B51A:  MOVWF  01
0B51C:  MOVLW  00
0B51E:  ADDWFC xC8,W
0B520:  MOVWF  02
0B522:  MOVLW  00
0B524:  ADDWFC xC9,W
0B526:  MOVWF  03
0B528:  MOVFF  01,03
0B52C:  MOVF   00,W
0B52E:  MOVLB  7
0B530:  ADDWF  x12,W
0B532:  MOVWF  01
0B534:  MOVF   x13,W
0B536:  ADDWFC 03,F
0B538:  MOVFF  01,8CA
0B53C:  MOVLB  8
0B53E:  MOVFF  03,8CB
0B542:  MOVFF  8C5,FEA
0B546:  MOVFF  8C4,FE9
0B54A:  MOVFF  03,FE2
0B54E:  MOVFF  01,FE1
0B552:  MOVFF  8C2,02
0B556:  MOVFF  8C1,01
0B55A:  MOVF   01,F
0B55C:  BZ    B562
0B55E:  INCF   02,F
0B560:  BRA    B566
0B562:  MOVF   02,F
0B564:  BZ    B572
0B566:  MOVFF  FE6,FEE
0B56A:  DECFSZ 01,F
0B56C:  BRA    B566
0B56E:  DECFSZ 02,F
0B570:  BRA    B566
0B572:  MOVLB  0
0B574:  MOVLB  8
0B576:  MOVF   xC1,W
0B578:  ADDWF  xC4,F
0B57A:  MOVF   xC2,W
0B57C:  ADDWFC xC5,F
0B57E:  MOVFF  8AD,FE9
0B582:  MOVFF  8AE,FEA
0B586:  MOVF   xC1,W
0B588:  ADDWF  FEF,W
0B58A:  MOVWF  00
0B58C:  MOVF   xC2,W
0B58E:  ADDWFC FEC,W
0B590:  MOVWF  01
0B592:  MOVLW  00
0B594:  ADDWFC FEC,W
0B596:  MOVWF  02
0B598:  MOVLW  00
0B59A:  ADDWFC FEC,W
0B59C:  MOVWF  03
0B59E:  MOVF   FED,F
0B5A0:  MOVF   FED,F
0B5A2:  MOVF   FED,F
0B5A4:  MOVFF  00,FEF
0B5A8:  MOVFF  01,FEC
0B5AC:  MOVFF  02,FEC
0B5B0:  MOVWF  FEC
0B5B2:  MOVFF  8B3,FE9
0B5B6:  MOVFF  8B4,FEA
0B5BA:  MOVF   xC1,W
0B5BC:  ADDWF  FEF,W
0B5BE:  MOVWF  01
0B5C0:  MOVF   xC2,W
0B5C2:  ADDWFC FEC,W
0B5C4:  MOVWF  03
0B5C6:  MOVF   FED,F
0B5C8:  MOVFF  01,FEF
0B5CC:  MOVWF  FEC
0B5CE:  MOVF   xC1,W
0B5D0:  SUBWF  xB1,F
0B5D2:  MOVF   xC2,W
0B5D4:  SUBWFB xB2,F
0B5D6:  BRA    B1DA
....................          } 
....................       return (FR_OK); 
0B5D8:  MOVLW  00
0B5DA:  MOVWF  01
0B5DC:  MOVLB  7
0B5DE:  BRA    B5FA
0B5E0:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B5E2:  MOVLW  1A
0B5E4:  ADDWF  xAD,W
0B5E6:  MOVWF  FE9
0B5E8:  MOVLW  00
0B5EA:  ADDWFC xAE,W
0B5EC:  MOVWF  FEA
0B5EE:  MOVF   FEF,W
0B5F0:  IORLW  80
0B5F2:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B5F4:  MOVLW  07
0B5F6:  MOVWF  01
0B5F8:  MOVLB  7
0B5FA:  MOVLB  0
0B5FC:  GOTO   B7F8 (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
0795C:  MOVFF  994,9A5
07960:  MOVFF  993,9A4
....................       *bw = 0; 
07964:  MOVLB  9
07966:  MOVFF  997,FE9
0796A:  MOVFF  998,FEA
0796E:  CLRF   FEC
07970:  MOVF   FED,F
07972:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
07974:  CLRF   xA2
07976:  CLRF   xA1
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
07978:  MOVLB  7
0797A:  MOVF   x12,W
0797C:  IORWF  x13,W
0797E:  BNZ   7986
....................          return (FR_NOT_ENABLED); 
07980:  MOVLW  0B
07982:  MOVWF  01
07984:  BRA    8022
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
07986:  MOVLB  0
07988:  CALL   552E
0798C:  BTFSC  01.0
0798E:  BRA    79A0
07990:  MOVLB  7
07992:  MOVFF  712,FE9
07996:  MOVFF  713,FEA
0799A:  MOVF   FEF,F
0799C:  BNZ   79A8
0799E:  MOVLB  0
....................          return (FR_NOT_READY); 
079A0:  MOVLW  01
079A2:  MOVWF  01
079A4:  MOVLB  7
079A6:  BRA    8022
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
079A8:  MOVLW  1A
079AA:  MOVLB  9
079AC:  ADDWF  x91,W
079AE:  MOVWF  FE9
079B0:  MOVLW  00
079B2:  ADDWFC x92,W
079B4:  MOVWF  FEA
079B6:  BTFSS  FEF.7
079B8:  BRA    79C4
....................          return (FR_RW_ERROR);         // Check error flag  
079BA:  MOVLW  07
079BC:  MOVWF  01
079BE:  MOVLB  7
079C0:  BRA    8022
079C2:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
079C4:  MOVLW  1A
079C6:  ADDWF  x91,W
079C8:  MOVWF  FE9
079CA:  MOVLW  00
079CC:  ADDWFC x92,W
079CE:  MOVWF  FEA
079D0:  BTFSC  FEF.1
079D2:  BRA    79DE
....................          return (FR_DENIED);            // Check access mode  
079D4:  MOVLW  05
079D6:  MOVWF  01
079D8:  MOVLB  7
079DA:  BRA    8022
079DC:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
079DE:  MOVLW  04
079E0:  ADDWF  x91,W
079E2:  MOVWF  FE9
079E4:  MOVLW  00
079E6:  ADDWFC x92,W
079E8:  MOVWF  FEA
079EA:  MOVFF  FEF,9A6
079EE:  MOVFF  FEC,9A7
079F2:  MOVFF  FEC,9A8
079F6:  MOVFF  FEC,9A9
079FA:  MOVF   x95,W
079FC:  ADDWF  xA6,F
079FE:  MOVF   x96,W
07A00:  ADDWFC xA7,F
07A02:  MOVLW  00
07A04:  ADDWFC xA8,F
07A06:  ADDWFC xA9,F
07A08:  MOVLW  04
07A0A:  ADDWF  x91,W
07A0C:  MOVWF  FE9
07A0E:  MOVLW  00
07A10:  ADDWFC x92,W
07A12:  MOVWF  FEA
07A14:  MOVFF  FEF,00
07A18:  MOVFF  FEC,01
07A1C:  MOVFF  FEC,02
07A20:  MOVFF  FEC,03
07A24:  MOVF   xA9,W
07A26:  SUBWF  03,W
07A28:  BNC   7A46
07A2A:  BNZ   7A42
07A2C:  MOVF   xA8,W
07A2E:  SUBWF  02,W
07A30:  BNC   7A46
07A32:  BNZ   7A42
07A34:  MOVF   xA7,W
07A36:  SUBWF  01,W
07A38:  BNC   7A46
07A3A:  BNZ   7A42
07A3C:  MOVF   00,W
07A3E:  SUBWF  xA6,W
07A40:  BC    7A46
....................          btw = 0;                  // File size cannot reach 4GB  
07A42:  CLRF   x96
07A44:  CLRF   x95
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07A46:  MOVF   x95,W
07A48:  IORWF  x96,W
07A4A:  BTFSC  FD8.2
07A4C:  BRA    7F56
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07A4E:  MOVFF  991,FE9
07A52:  MOVFF  992,FEA
07A56:  MOVFF  FEF,9A6
07A5A:  MOVFF  FEC,9A7
07A5E:  MOVFF  FEC,9A8
07A62:  MOVFF  FEC,9A9
07A66:  MOVLW  01
07A68:  ANDWF  xA7,F
07A6A:  CLRF   xA8
07A6C:  CLRF   xA9
07A6E:  MOVF   xA6,F
07A70:  BTFSS  FD8.2
07A72:  BRA    7DF0
07A74:  MOVF   xA7,F
07A76:  BTFSS  FD8.2
07A78:  BRA    7DF0
07A7A:  MOVF   xA8,F
07A7C:  BTFSS  FD8.2
07A7E:  BRA    7DF0
07A80:  MOVF   xA9,F
07A82:  BTFSS  FD8.2
07A84:  BRA    7DF0
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07A86:  MOVLW  1B
07A88:  ADDWF  x91,W
07A8A:  MOVWF  FE9
07A8C:  MOVLW  00
07A8E:  ADDWFC x92,W
07A90:  MOVWF  FEA
07A92:  DECF   FEF,F
07A94:  BZ    7ACC
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07A96:  MOVLW  10
07A98:  ADDWF  x91,W
07A9A:  MOVWF  FE9
07A9C:  MOVLW  00
07A9E:  ADDWFC x92,W
07AA0:  MOVWF  FEA
07AA2:  MOVFF  FEF,9A6
07AA6:  MOVFF  FEC,9A7
07AAA:  MOVFF  FEC,9A8
07AAE:  MOVFF  FEC,9A9
07AB2:  MOVLW  01
07AB4:  ADDWF  xA6,W
07AB6:  MOVWF  x9D
07AB8:  MOVLW  00
07ABA:  ADDWFC xA7,W
07ABC:  MOVWF  x9E
07ABE:  MOVLW  00
07AC0:  ADDWFC xA8,W
07AC2:  MOVWF  x9F
07AC4:  MOVLW  00
07AC6:  ADDWFC xA9,W
07AC8:  MOVWF  xA0
....................                }  
07ACA:  BRA    7C62
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07ACC:  MOVFF  991,FE9
07AD0:  MOVFF  992,FEA
07AD4:  MOVFF  FEF,9A6
07AD8:  MOVFF  FEC,9A7
07ADC:  MOVFF  FEC,9A8
07AE0:  MOVFF  FEC,9A9
07AE4:  MOVF   xA6,F
07AE6:  BNZ   7B6C
07AE8:  MOVF   xA7,F
07AEA:  BNZ   7B6C
07AEC:  MOVF   xA8,F
07AEE:  BNZ   7B6C
07AF0:  MOVF   xA9,F
07AF2:  BNZ   7B6C
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07AF4:  MOVLW  08
07AF6:  ADDWF  x91,W
07AF8:  MOVWF  FE9
07AFA:  MOVLW  00
07AFC:  ADDWFC x92,W
07AFE:  MOVWF  FEA
07B00:  MOVFF  FEF,999
07B04:  MOVFF  FEC,99A
07B08:  MOVFF  FEC,99B
07B0C:  MOVFF  FEC,99C
....................                   if (clust == 0)            // No cluster is created  
07B10:  MOVF   x99,F
07B12:  BNZ   7B6A
07B14:  MOVF   x9A,F
07B16:  BNZ   7B6A
07B18:  MOVF   x9B,F
07B1A:  BNZ   7B6A
07B1C:  MOVF   x9C,F
07B1E:  BNZ   7B6A
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07B20:  MOVLW  08
07B22:  ADDWF  x91,W
07B24:  MOVWF  01
07B26:  MOVLW  00
07B28:  ADDWFC x92,W
07B2A:  MOVWF  03
07B2C:  MOVFF  01,9A6
07B30:  MOVWF  xA7
07B32:  CLRF   xCC
07B34:  CLRF   xCB
07B36:  CLRF   xCA
07B38:  CLRF   xC9
07B3A:  MOVLB  0
07B3C:  CALL   68CE
07B40:  MOVFF  03,99C
07B44:  MOVFF  02,99B
07B48:  MOVFF  01,99A
07B4C:  MOVFF  00,999
07B50:  MOVFF  9A7,FEA
07B54:  MOVFF  9A6,FE9
07B58:  MOVFF  999,FEF
07B5C:  MOVFF  99A,FEC
07B60:  MOVFF  99B,FEC
07B64:  MOVFF  99C,FEC
07B68:  MOVLB  9
....................                   } 
07B6A:  BRA    7BA0
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07B6C:  MOVLW  0C
07B6E:  ADDWF  x91,W
07B70:  MOVWF  FE9
07B72:  MOVLW  00
07B74:  ADDWFC x92,W
07B76:  MOVWF  FEA
07B78:  MOVFF  FEF,9C9
07B7C:  MOVFF  FEC,9CA
07B80:  MOVFF  FEC,9CB
07B84:  MOVFF  FEC,9CC
07B88:  MOVLB  0
07B8A:  CALL   68CE
07B8E:  MOVFF  03,99C
07B92:  MOVFF  02,99B
07B96:  MOVFF  01,99A
07B9A:  MOVFF  00,999
07B9E:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07BA0:  MOVF   x9C,F
07BA2:  BNZ   7BB2
07BA4:  MOVF   x9B,F
07BA6:  BNZ   7BB2
07BA8:  MOVF   x9A,F
07BAA:  BNZ   7BB2
07BAC:  MOVF   x99,W
07BAE:  SUBLW  01
07BB0:  BC    7BF0
07BB2:  MOVLW  0C
07BB4:  MOVLB  7
07BB6:  ADDWF  x12,W
07BB8:  MOVWF  FE9
07BBA:  MOVLW  00
07BBC:  ADDWFC x13,W
07BBE:  MOVWF  FEA
07BC0:  MOVFF  FEF,00
07BC4:  MOVFF  FEC,01
07BC8:  MOVFF  FEC,02
07BCC:  MOVFF  FEC,03
07BD0:  MOVF   03,W
07BD2:  MOVLB  9
07BD4:  SUBWF  x9C,W
07BD6:  BNC   7BF2
07BD8:  BNZ   7BF0
07BDA:  MOVF   02,W
07BDC:  SUBWF  x9B,W
07BDE:  BNC   7BF2
07BE0:  BNZ   7BF0
07BE2:  MOVF   01,W
07BE4:  SUBWF  x9A,W
07BE6:  BNC   7BF2
07BE8:  BNZ   7BF0
07BEA:  MOVF   00,W
07BEC:  SUBWF  x99,W
07BEE:  BNC   7BF2
....................                   break; 
07BF0:  BRA    7F56
....................                fp->curr_clust = clust;            // Current cluster  
07BF2:  MOVLW  0C
07BF4:  ADDWF  x91,W
07BF6:  MOVWF  FE9
07BF8:  MOVLW  00
07BFA:  ADDWFC x92,W
07BFC:  MOVWF  FEA
07BFE:  MOVFF  999,FEF
07C02:  MOVFF  99A,FEC
07C06:  MOVFF  99B,FEC
07C0A:  MOVFF  99C,FEC
....................                sect = clust2sect(clust);         // Current sector  
07C0E:  MOVFF  99C,9D3
07C12:  MOVFF  99B,9D2
07C16:  MOVFF  99A,9D1
07C1A:  MOVFF  999,9D0
07C1E:  MOVLB  0
07C20:  CALL   559E
07C24:  MOVFF  03,9A0
07C28:  MOVFF  02,99F
07C2C:  MOVFF  01,99E
07C30:  MOVFF  00,99D
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07C34:  MOVLW  1B
07C36:  MOVLB  9
07C38:  ADDWF  x91,W
07C3A:  MOVWF  01
07C3C:  MOVLW  00
07C3E:  ADDWFC x92,W
07C40:  MOVWF  03
07C42:  MOVLW  02
07C44:  MOVLB  7
07C46:  ADDWF  x12,W
07C48:  MOVWF  FE9
07C4A:  MOVLW  00
07C4C:  ADDWFC x13,W
07C4E:  MOVWF  FEA
07C50:  MOVFF  FEF,9A8
07C54:  MOVLB  9
07C56:  MOVFF  03,FEA
07C5A:  MOVFF  01,FE9
07C5E:  MOVFF  9A8,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07C62:  MOVLW  10
07C64:  ADDWF  x91,W
07C66:  MOVWF  FE9
07C68:  MOVLW  00
07C6A:  ADDWFC x92,W
07C6C:  MOVWF  FEA
07C6E:  MOVFF  99D,FEF
07C72:  MOVFF  99E,FEC
07C76:  MOVFF  99F,FEC
07C7A:  MOVFF  9A0,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07C7E:  BCF    FD8.0
07C80:  RRCF   x96,W
07C82:  MOVWF  xA3
....................             if (cc)  
07C84:  MOVF   xA3,F
07C86:  BZ    7D40
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07C88:  MOVLW  1B
07C8A:  ADDWF  x91,W
07C8C:  MOVWF  FE9
07C8E:  MOVLW  00
07C90:  ADDWFC x92,W
07C92:  MOVWF  FEA
07C94:  MOVF   FEF,W
07C96:  SUBWF  xA3,W
07C98:  BZ    7CAC
07C9A:  BNC   7CAC
....................                   cc = fp->sect_clust; 
07C9C:  MOVLW  1B
07C9E:  ADDWF  x91,W
07CA0:  MOVWF  FE9
07CA2:  MOVLW  00
07CA4:  ADDWFC x92,W
07CA6:  MOVWF  FEA
07CA8:  MOVFF  FEF,9A3
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07CAC:  MOVFF  9A5,9FE
07CB0:  MOVFF  9A4,9FD
07CB4:  MOVFF  9A0,A02
07CB8:  MOVFF  99F,A01
07CBC:  MOVFF  99E,A00
07CC0:  MOVFF  99D,9FF
07CC4:  MOVFF  9A3,A03
07CC8:  MOVLB  0
07CCA:  CALL   58CE
07CCE:  MOVF   01,F
07CD0:  BZ    7CD4
....................                   goto fw_error; 
07CD2:  BRA    8008
....................                fp->sect_clust -= cc - 1; 
07CD4:  MOVLW  1B
07CD6:  MOVLB  9
07CD8:  ADDWF  x91,W
07CDA:  MOVWF  FE9
07CDC:  MOVLW  00
07CDE:  ADDWFC x92,W
07CE0:  MOVWF  FEA
07CE2:  MOVLW  01
07CE4:  SUBWF  xA3,W
07CE6:  SUBWF  FEF,W
07CE8:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07CEA:  MOVLW  10
07CEC:  ADDWF  x91,W
07CEE:  MOVWF  FE9
07CF0:  MOVLW  00
07CF2:  ADDWFC x92,W
07CF4:  MOVWF  FEA
07CF6:  MOVLW  01
07CF8:  SUBWF  xA3,W
07CFA:  ADDWF  FEF,W
07CFC:  MOVWF  00
07CFE:  MOVLW  00
07D00:  ADDWFC FEC,W
07D02:  MOVWF  01
07D04:  MOVLW  00
07D06:  ADDWFC FEC,W
07D08:  MOVWF  02
07D0A:  MOVLW  00
07D0C:  ADDWFC FEC,W
07D0E:  MOVF   FED,F
07D10:  MOVF   FED,F
07D12:  MOVF   FED,F
07D14:  MOVFF  00,FEF
07D18:  MOVFF  01,FEC
07D1C:  MOVFF  02,FEC
07D20:  MOVWF  FEC
....................                wcnt = cc * 512; 
07D22:  CLRF   xEE
07D24:  MOVFF  9A3,9ED
07D28:  MOVLW  02
07D2A:  MOVWF  xF0
07D2C:  CLRF   xEF
07D2E:  MOVLB  0
07D30:  CALL   5C32
07D34:  MOVFF  02,9A2
07D38:  MOVFF  01,9A1
....................                continue; 
07D3C:  BRA    7EF2
07D3E:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07D40:  MOVFF  991,FE9
07D44:  MOVFF  992,FEA
07D48:  MOVFF  FEF,9A6
07D4C:  MOVFF  FEC,9A7
07D50:  MOVFF  FEC,9A8
07D54:  MOVFF  FEC,9A9
07D58:  MOVLW  04
07D5A:  ADDWF  x91,W
07D5C:  MOVWF  FE9
07D5E:  MOVLW  00
07D60:  ADDWFC x92,W
07D62:  MOVWF  FEA
07D64:  MOVFF  FEF,00
07D68:  MOVFF  FEC,01
07D6C:  MOVFF  FEC,02
07D70:  MOVFF  FEC,03
07D74:  MOVF   03,W
07D76:  SUBWF  xA9,W
07D78:  BNC   7DF0
07D7A:  BNZ   7D92
07D7C:  MOVF   02,W
07D7E:  SUBWF  xA8,W
07D80:  BNC   7DF0
07D82:  BNZ   7D92
07D84:  MOVF   01,W
07D86:  SUBWF  xA7,W
07D88:  BNC   7DF0
07D8A:  BNZ   7D92
07D8C:  MOVF   00,W
07D8E:  SUBWF  xA6,W
07D90:  BNC   7DF0
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07D92:  CLRF   xF4
07D94:  CLRF   xF3
07D96:  CLRF   xF2
07D98:  CLRF   xF1
07D9A:  MOVLB  0
07D9C:  CALL   5A16
07DA0:  MOVF   01,F
07DA2:  BNZ   7DA6
....................                   goto fw_error; 
07DA4:  BRA    8008
....................                fs->winsect = fp->curr_sect; 
07DA6:  MOVLW  20
07DA8:  MOVLB  7
07DAA:  ADDWF  x12,W
07DAC:  MOVWF  01
07DAE:  MOVLW  00
07DB0:  ADDWFC x13,W
07DB2:  MOVWF  03
07DB4:  MOVFF  01,9A6
07DB8:  MOVLB  9
07DBA:  MOVWF  xA7
07DBC:  MOVLW  10
07DBE:  ADDWF  x91,W
07DC0:  MOVWF  FE9
07DC2:  MOVLW  00
07DC4:  ADDWFC x92,W
07DC6:  MOVWF  FEA
07DC8:  MOVFF  FEF,00
07DCC:  MOVFF  FEC,01
07DD0:  MOVFF  FEC,02
07DD4:  MOVFF  FEC,03
07DD8:  MOVFF  9A7,FEA
07DDC:  MOVFF  9A6,FE9
07DE0:  MOVFF  00,FEF
07DE4:  MOVFF  01,FEC
07DE8:  MOVFF  02,FEC
07DEC:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07DF0:  MOVLW  10
07DF2:  ADDWF  x91,W
07DF4:  MOVWF  FE9
07DF6:  MOVLW  00
07DF8:  ADDWFC x92,W
07DFA:  MOVWF  FEA
07DFC:  MOVFF  FEF,9F1
07E00:  MOVFF  FEC,9F2
07E04:  MOVFF  FEC,9F3
07E08:  MOVFF  FEC,9F4
07E0C:  MOVLB  0
07E0E:  CALL   5A16
07E12:  MOVF   01,F
07E14:  BNZ   7E18
....................             goto fw_error;               // Move sector window 
07E16:  BRA    8008
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07E18:  MOVLB  9
07E1A:  MOVFF  991,FE9
07E1E:  MOVFF  992,FEA
07E22:  MOVFF  FEF,9A6
07E26:  MOVFF  FEC,9A7
07E2A:  MOVFF  FEC,9A8
07E2E:  MOVFF  FEC,9A9
07E32:  MOVF   xA7,W
07E34:  ANDLW  01
07E36:  MOVWF  01
07E38:  MOVLW  00
07E3A:  BSF    FD8.0
07E3C:  SUBFWB xA6,W
07E3E:  MOVWF  xA1
07E40:  MOVLW  02
07E42:  SUBFWB 01,W
07E44:  MOVWF  xA2
....................          if (wcnt > btw) 
07E46:  MOVF   x96,W
07E48:  SUBWF  xA2,W
07E4A:  BNC   7E5C
07E4C:  BNZ   7E54
07E4E:  MOVF   xA1,W
07E50:  SUBWF  x95,W
07E52:  BC    7E5C
....................             wcnt = btw; 
07E54:  MOVFF  996,9A2
07E58:  MOVFF  995,9A1
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07E5C:  MOVFF  991,FE9
07E60:  MOVFF  992,FEA
07E64:  MOVFF  FEF,9A6
07E68:  MOVFF  FEC,9A7
07E6C:  MOVFF  FEC,9A8
07E70:  MOVFF  FEC,9A9
07E74:  MOVLW  01
07E76:  ANDWF  xA7,F
07E78:  CLRF   xA8
07E7A:  CLRF   xA9
07E7C:  MOVLW  24
07E7E:  ADDWF  xA6,W
07E80:  MOVWF  00
07E82:  MOVLW  00
07E84:  ADDWFC xA7,W
07E86:  MOVWF  01
07E88:  MOVLW  00
07E8A:  ADDWFC xA8,W
07E8C:  MOVWF  02
07E8E:  MOVLW  00
07E90:  ADDWFC xA9,W
07E92:  MOVWF  03
07E94:  MOVFF  01,03
07E98:  MOVF   00,W
07E9A:  MOVLB  7
07E9C:  ADDWF  x12,W
07E9E:  MOVWF  01
07EA0:  MOVF   x13,W
07EA2:  ADDWFC 03,F
07EA4:  MOVFF  01,9AA
07EA8:  MOVLB  9
07EAA:  MOVFF  03,9AB
07EAE:  MOVFF  03,FEA
07EB2:  MOVFF  01,FE9
07EB6:  MOVFF  9A5,FE2
07EBA:  MOVFF  9A4,FE1
07EBE:  MOVFF  9A2,02
07EC2:  MOVFF  9A1,01
07EC6:  MOVF   01,F
07EC8:  BZ    7ECE
07ECA:  INCF   02,F
07ECC:  BRA    7ED2
07ECE:  MOVF   02,F
07ED0:  BZ    7EDE
07ED2:  MOVFF  FE6,FEE
07ED6:  DECFSZ 01,F
07ED8:  BRA    7ED2
07EDA:  DECFSZ 02,F
07EDC:  BRA    7ED2
....................          fs->winflag = 1; 
07EDE:  MOVLW  06
07EE0:  MOVLB  7
07EE2:  ADDWF  x12,W
07EE4:  MOVWF  FE9
07EE6:  MOVLW  00
07EE8:  ADDWFC x13,W
07EEA:  MOVWF  FEA
07EEC:  MOVLW  01
07EEE:  MOVWF  FEF
07EF0:  MOVLB  0
07EF2:  MOVLB  9
07EF4:  MOVF   xA1,W
07EF6:  ADDWF  xA4,F
07EF8:  MOVF   xA2,W
07EFA:  ADDWFC xA5,F
07EFC:  MOVFF  991,FE9
07F00:  MOVFF  992,FEA
07F04:  MOVF   xA1,W
07F06:  ADDWF  FEF,W
07F08:  MOVWF  00
07F0A:  MOVF   xA2,W
07F0C:  ADDWFC FEC,W
07F0E:  MOVWF  01
07F10:  MOVLW  00
07F12:  ADDWFC FEC,W
07F14:  MOVWF  02
07F16:  MOVLW  00
07F18:  ADDWFC FEC,W
07F1A:  MOVWF  03
07F1C:  MOVF   FED,F
07F1E:  MOVF   FED,F
07F20:  MOVF   FED,F
07F22:  MOVFF  00,FEF
07F26:  MOVFF  01,FEC
07F2A:  MOVFF  02,FEC
07F2E:  MOVWF  FEC
07F30:  MOVFF  997,FE9
07F34:  MOVFF  998,FEA
07F38:  MOVF   xA1,W
07F3A:  ADDWF  FEF,W
07F3C:  MOVWF  01
07F3E:  MOVF   xA2,W
07F40:  ADDWFC FEC,W
07F42:  MOVWF  03
07F44:  MOVF   FED,F
07F46:  MOVFF  01,FEF
07F4A:  MOVWF  FEC
07F4C:  MOVF   xA1,W
07F4E:  SUBWF  x95,F
07F50:  MOVF   xA2,W
07F52:  SUBWFB x96,F
07F54:  BRA    7A46
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
07F56:  MOVFF  991,FE9
07F5A:  MOVFF  992,FEA
07F5E:  MOVFF  FEF,9A6
07F62:  MOVFF  FEC,9A7
07F66:  MOVFF  FEC,9A8
07F6A:  MOVFF  FEC,9A9
07F6E:  MOVLW  04
07F70:  ADDWF  x91,W
07F72:  MOVWF  FE9
07F74:  MOVLW  00
07F76:  ADDWFC x92,W
07F78:  MOVWF  FEA
07F7A:  MOVFF  FEF,00
07F7E:  MOVFF  FEC,01
07F82:  MOVFF  FEC,02
07F86:  MOVFF  FEC,03
07F8A:  MOVF   03,W
07F8C:  SUBWF  xA9,W
07F8E:  BNC   7FEC
07F90:  BNZ   7FA8
07F92:  MOVF   02,W
07F94:  SUBWF  xA8,W
07F96:  BNC   7FEC
07F98:  BNZ   7FA8
07F9A:  MOVF   01,W
07F9C:  SUBWF  xA7,W
07F9E:  BNC   7FEC
07FA0:  BNZ   7FA8
07FA2:  MOVF   xA6,W
07FA4:  SUBWF  00,W
07FA6:  BC    7FEC
....................          fp->fsize = fp->fptr;      // Update file size if needed  
07FA8:  MOVLW  04
07FAA:  ADDWF  x91,W
07FAC:  MOVWF  01
07FAE:  MOVLW  00
07FB0:  ADDWFC x92,W
07FB2:  MOVWF  03
07FB4:  MOVFF  01,9A6
07FB8:  MOVFF  03,9A7
07FBC:  MOVFF  991,FE9
07FC0:  MOVFF  992,FEA
07FC4:  MOVFF  FEF,00
07FC8:  MOVFF  FEC,01
07FCC:  MOVFF  FEC,02
07FD0:  MOVFF  FEC,03
07FD4:  MOVFF  9A7,FEA
07FD8:  MOVFF  9A6,FE9
07FDC:  MOVFF  00,FEF
07FE0:  MOVFF  01,FEC
07FE4:  MOVFF  02,FEC
07FE8:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
07FEC:  MOVLW  1A
07FEE:  ADDWF  x91,W
07FF0:  MOVWF  FE9
07FF2:  MOVLW  00
07FF4:  ADDWFC x92,W
07FF6:  MOVWF  FEA
07FF8:  MOVF   FEF,W
07FFA:  IORLW  20
07FFC:  MOVWF  FEF
....................       return (FR_OK); 
07FFE:  MOVLW  00
08000:  MOVWF  01
08002:  MOVLB  7
08004:  BRA    8022
08006:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
08008:  MOVLW  1A
0800A:  MOVLB  9
0800C:  ADDWF  x91,W
0800E:  MOVWF  FE9
08010:  MOVLW  00
08012:  ADDWFC x92,W
08014:  MOVWF  FEA
08016:  MOVF   FEF,W
08018:  IORLW  80
0801A:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0801C:  MOVLW  07
0801E:  MOVWF  01
08020:  MOVLB  7
08022:  MOVLB  0
08024:  GOTO   83C8 (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
07502:  MOVLB  7
07504:  MOVF   x12,W
07506:  IORWF  x13,W
07508:  BNZ   7510
....................          return (FR_NOT_ENABLED); 
0750A:  MOVLW  0B
0750C:  MOVWF  01
0750E:  BRA    7864
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
07510:  MOVLB  0
07512:  CALL   552E
07516:  BTFSC  01.0
07518:  BRA    752A
0751A:  MOVLB  7
0751C:  MOVFF  712,FE9
07520:  MOVFF  713,FEA
07524:  MOVF   FEF,F
07526:  BNZ   7532
07528:  MOVLB  0
....................          return (FR_NOT_READY); 
0752A:  MOVLW  01
0752C:  MOVWF  01
0752E:  MOVLB  7
07530:  BRA    7864
....................     
....................       if (fp->flag & FA__ERROR) 
07532:  MOVLW  1A
07534:  MOVLB  9
07536:  ADDWF  x91,W
07538:  MOVWF  FE9
0753A:  MOVLW  00
0753C:  ADDWFC x92,W
0753E:  MOVWF  FEA
07540:  BTFSS  FEF.7
07542:  BRA    754E
....................          return (FR_RW_ERROR); 
07544:  MOVLW  07
07546:  MOVWF  01
07548:  MOVLB  7
0754A:  BRA    7864
0754C:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
0754E:  MOVLW  04
07550:  ADDWF  x91,W
07552:  MOVWF  FE9
07554:  MOVLW  00
07556:  ADDWFC x92,W
07558:  MOVWF  FEA
0755A:  MOVFF  FEF,00
0755E:  MOVFF  FEC,01
07562:  MOVFF  FEC,02
07566:  MOVFF  FEC,03
0756A:  MOVF   03,W
0756C:  SUBWF  x96,W
0756E:  BNC   75A4
07570:  BNZ   7588
07572:  MOVF   02,W
07574:  SUBWF  x95,W
07576:  BNC   75A4
07578:  BNZ   7588
0757A:  MOVF   01,W
0757C:  SUBWF  x94,W
0757E:  BNC   75A4
07580:  BNZ   7588
07582:  MOVF   x93,W
07584:  SUBWF  00,W
07586:  BC    75A4
....................          ofs = fp->fsize;               // Clip offset by file size  
07588:  MOVLW  04
0758A:  ADDWF  x91,W
0758C:  MOVWF  FE9
0758E:  MOVLW  00
07590:  ADDWFC x92,W
07592:  MOVWF  FEA
07594:  MOVFF  FEF,993
07598:  MOVFF  FEC,994
0759C:  MOVFF  FEC,995
075A0:  MOVFF  FEC,996
....................       fp->fptr = ofs;  
075A4:  MOVFF  991,FE9
075A8:  MOVF   x92,W
075AA:  MOVWF  FEA
075AC:  MOVFF  993,FEF
075B0:  MOVFF  994,FEC
075B4:  MOVFF  995,FEC
075B8:  MOVFF  996,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
075BC:  MOVLW  1B
075BE:  ADDWF  x91,W
075C0:  MOVWF  FE9
075C2:  MOVLW  00
075C4:  ADDWFC x92,W
075C6:  MOVWF  FEA
075C8:  MOVLW  01
075CA:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
075CC:  MOVF   x93,F
075CE:  BNZ   75DE
075D0:  MOVF   x94,F
075D2:  BNZ   75DE
075D4:  MOVF   x95,F
075D6:  BNZ   75DE
075D8:  MOVF   x96,F
075DA:  BTFSC  FD8.2
075DC:  BRA    7842
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
075DE:  MOVLW  01
075E0:  SUBWF  x93,W
075E2:  MOVLW  00
075E4:  SUBWFB x94,W
075E6:  MOVWF  x9D
075E8:  MOVLW  00
075EA:  SUBWFB x95,W
075EC:  MOVWF  x9E
075EE:  MOVLW  00
075F0:  SUBWFB x96,W
075F2:  MOVWF  x9F
075F4:  BCF    FD8.0
075F6:  CLRF   x96
075F8:  RRCF   x9F,W
075FA:  MOVWF  x95
075FC:  RRCF   x9E,W
075FE:  MOVWF  x94
07600:  RRCF   x9D,W
07602:  MOVWF  x93
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
07604:  MOVLW  02
07606:  MOVLB  7
07608:  ADDWF  x12,W
0760A:  MOVWF  FE9
0760C:  MOVLW  00
0760E:  ADDWFC x13,W
07610:  MOVWF  FEA
07612:  MOVFF  FEF,99B
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
07616:  MOVLW  1B
07618:  MOVLB  9
0761A:  ADDWF  x91,W
0761C:  MOVWF  01
0761E:  MOVLW  00
07620:  ADDWFC x92,W
07622:  MOVWF  03
07624:  MOVFF  01,99C
07628:  MOVWF  x9D
0762A:  MOVFF  FEA,99F
0762E:  MOVFF  FE9,99E
07632:  BSF    FD8.1
07634:  MOVLW  09
07636:  MOVWF  FEA
07638:  MOVLW  A0
0763A:  MOVWF  FE9
0763C:  CLRF   1B
0763E:  BTFSC  FF2.7
07640:  BSF    1B.7
07642:  BCF    FF2.7
07644:  MOVFF  996,A2B
07648:  MOVFF  995,A2A
0764C:  MOVFF  994,A29
07650:  MOVFF  993,A28
07654:  MOVLB  A
07656:  CLRF   x2F
07658:  CLRF   x2E
0765A:  CLRF   x2D
0765C:  MOVFF  99B,A2C
07660:  MOVLB  0
07662:  CALL   1056
07666:  BTFSC  1B.7
07668:  BSF    FF2.7
0766A:  MOVFF  9A0,00
0766E:  MOVFF  9A1,01
07672:  MOVFF  9A2,02
07676:  MOVFF  9A3,03
0767A:  MOVFF  99F,FEA
0767E:  MOVFF  99E,FE9
07682:  MOVF   00,W
07684:  MOVLB  9
07686:  SUBWF  x9B,W
07688:  MOVWF  00
0768A:  MOVLW  00
0768C:  SUBFWB 01,F
0768E:  SUBFWB 02,F
07690:  SUBFWB 03,F
07692:  MOVFF  99D,FEA
07696:  MOVFF  99C,FE9
0769A:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
0769E:  BCF    FD8.1
076A0:  CLRF   1B
076A2:  BTFSC  FF2.7
076A4:  BSF    1B.7
076A6:  BCF    FF2.7
076A8:  MOVFF  996,A2B
076AC:  MOVFF  995,A2A
076B0:  MOVFF  994,A29
076B4:  MOVFF  993,A28
076B8:  MOVLB  A
076BA:  CLRF   x2F
076BC:  CLRF   x2E
076BE:  CLRF   x2D
076C0:  MOVFF  99B,A2C
076C4:  MOVLB  0
076C6:  CALL   1056
076CA:  BTFSC  1B.7
076CC:  BSF    FF2.7
076CE:  MOVFF  03,996
076D2:  MOVFF  02,995
076D6:  MOVFF  01,994
076DA:  MOVFF  00,993
....................          clust = fp->org_clust;            // Seek to current cluster  
076DE:  MOVLW  08
076E0:  MOVLB  9
076E2:  ADDWF  x91,W
076E4:  MOVWF  FE9
076E6:  MOVLW  00
076E8:  ADDWFC x92,W
076EA:  MOVWF  FEA
076EC:  MOVFF  FEF,997
076F0:  MOVFF  FEC,998
076F4:  MOVFF  FEC,999
076F8:  MOVFF  FEC,99A
....................     
....................          while (ofs--) 
076FC:  MOVFF  996,03
07700:  MOVFF  995,02
07704:  MOVFF  994,01
07708:  MOVFF  993,00
0770C:  MOVLW  FF
0770E:  ADDWF  x93,F
07710:  BTFSS  FD8.0
07712:  ADDWF  x94,F
07714:  BTFSS  FD8.0
07716:  ADDWF  x95,F
07718:  BTFSS  FD8.0
0771A:  ADDWF  x96,F
0771C:  MOVF   00,F
0771E:  BNZ   772C
07720:  MOVF   01,F
07722:  BNZ   772C
07724:  MOVF   02,F
07726:  BNZ   772C
07728:  MOVF   03,F
0772A:  BZ    7756
....................             clust = get_cluster(clust); 
0772C:  MOVFF  99A,9E0
07730:  MOVFF  999,9DF
07734:  MOVFF  998,9DE
07738:  MOVFF  997,9DD
0773C:  MOVLB  0
0773E:  CALL   5C54
07742:  MOVFF  03,99A
07746:  MOVFF  02,999
0774A:  MOVFF  01,998
0774E:  MOVFF  00,997
07752:  MOVLB  9
07754:  BRA    76FC
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
07756:  MOVF   x9A,F
07758:  BNZ   7768
0775A:  MOVF   x99,F
0775C:  BNZ   7768
0775E:  MOVF   x98,F
07760:  BNZ   7768
07762:  MOVF   x97,W
07764:  SUBLW  01
07766:  BC    77A6
07768:  MOVLW  0C
0776A:  MOVLB  7
0776C:  ADDWF  x12,W
0776E:  MOVWF  FE9
07770:  MOVLW  00
07772:  ADDWFC x13,W
07774:  MOVWF  FEA
07776:  MOVFF  FEF,00
0777A:  MOVFF  FEC,01
0777E:  MOVFF  FEC,02
07782:  MOVFF  FEC,03
07786:  MOVF   03,W
07788:  MOVLB  9
0778A:  SUBWF  x9A,W
0778C:  BNC   77A8
0778E:  BNZ   77A6
07790:  MOVF   02,W
07792:  SUBWF  x99,W
07794:  BNC   77A8
07796:  BNZ   77A6
07798:  MOVF   01,W
0779A:  SUBWF  x98,W
0779C:  BNC   77A8
0779E:  BNZ   77A6
077A0:  MOVF   00,W
077A2:  SUBWF  x97,W
077A4:  BNC   77A8
....................             goto fk_error; 
077A6:  BRA    784C
....................     
....................          fp->curr_clust = clust; 
077A8:  MOVLW  0C
077AA:  ADDWF  x91,W
077AC:  MOVWF  FE9
077AE:  MOVLW  00
077B0:  ADDWFC x92,W
077B2:  MOVWF  FEA
077B4:  MOVFF  997,FEF
077B8:  MOVFF  998,FEC
077BC:  MOVFF  999,FEC
077C0:  MOVFF  99A,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
077C4:  MOVLW  10
077C6:  ADDWF  x91,W
077C8:  MOVWF  01
077CA:  MOVLW  00
077CC:  ADDWFC x92,W
077CE:  MOVWF  03
077D0:  MOVFF  01,99C
077D4:  MOVWF  x9D
077D6:  MOVFF  99A,9D3
077DA:  MOVFF  999,9D2
077DE:  MOVFF  998,9D1
077E2:  MOVFF  997,9D0
077E6:  MOVLB  0
077E8:  CALL   559E
077EC:  MOVFF  03,9A1
077F0:  MOVFF  02,9A0
077F4:  MOVFF  01,99F
077F8:  MOVFF  00,99E
077FC:  MOVLB  9
077FE:  MOVF   x9B,W
07800:  ADDWF  x9E,F
07802:  MOVLW  00
07804:  ADDWFC x9F,F
07806:  ADDWFC xA0,F
07808:  ADDWFC xA1,F
0780A:  MOVLW  1B
0780C:  ADDWF  x91,W
0780E:  MOVWF  FE9
07810:  MOVLW  00
07812:  ADDWFC x92,W
07814:  MOVWF  FEA
07816:  MOVF   FEF,W
07818:  SUBWF  x9E,W
0781A:  MOVWF  00
0781C:  MOVLW  00
0781E:  SUBWFB x9F,W
07820:  MOVWF  01
07822:  MOVLW  00
07824:  SUBWFB xA0,W
07826:  MOVWF  02
07828:  MOVLW  00
0782A:  SUBWFB xA1,W
0782C:  MOVFF  99D,FEA
07830:  MOVFF  99C,FE9
07834:  MOVFF  00,FEF
07838:  MOVFF  01,FEC
0783C:  MOVFF  02,FEC
07840:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
07842:  MOVLW  00
07844:  MOVWF  01
07846:  MOVLB  7
07848:  BRA    7864
0784A:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0784C:  MOVLW  1A
0784E:  ADDWF  x91,W
07850:  MOVWF  FE9
07852:  MOVLW  00
07854:  ADDWFC x92,W
07856:  MOVWF  FEA
07858:  MOVF   FEF,W
0785A:  IORLW  80
0785C:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0785E:  MOVLW  07
07860:  MOVWF  01
07862:  MOVLB  7
07864:  MOVLB  0
07866:  GOTO   82E0 (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
08028:  MOVLB  7
0802A:  MOVF   x12,W
0802C:  IORWF  x13,W
0802E:  BNZ   8036
....................       return (FR_NOT_ENABLED); 
08030:  MOVLW  0B
08032:  MOVWF  01
08034:  BRA    8202
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
08036:  MOVLB  0
08038:  CALL   552E
0803C:  BTFSC  01.0
0803E:  BRA    8050
08040:  MOVLB  7
08042:  MOVFF  712,FE9
08046:  MOVFF  713,FEA
0804A:  MOVF   FEF,F
0804C:  BNZ   8058
0804E:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
08050:  MOVLW  09
08052:  MOVWF  01
08054:  MOVLB  7
08056:  BRA    8202
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
08058:  MOVLW  1A
0805A:  MOVLB  9
0805C:  ADDWF  x94,W
0805E:  MOVWF  FE9
08060:  MOVLW  00
08062:  ADDWFC x95,W
08064:  MOVWF  FEA
08066:  BTFSS  FEF.5
08068:  BRA    81E0
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
0806A:  MOVLW  14
0806C:  ADDWF  x94,W
0806E:  MOVWF  FE9
08070:  MOVLW  00
08072:  ADDWFC x95,W
08074:  MOVWF  FEA
08076:  MOVFF  FEF,9F1
0807A:  MOVFF  FEC,9F2
0807E:  MOVFF  FEC,9F3
08082:  MOVFF  FEC,9F4
08086:  MOVLB  0
08088:  CALL   5A16
0808C:  MOVF   01,F
0808E:  BNZ   809A
....................          return (FR_RW_ERROR); 
08090:  MOVLW  07
08092:  MOVWF  01
08094:  MOVLB  7
08096:  BRA    8202
08098:  MOVLB  0
....................       ptr = fp->dir_ptr; 
0809A:  MOVLW  18
0809C:  MOVLB  9
0809E:  ADDWF  x94,W
080A0:  MOVWF  FE9
080A2:  MOVLW  00
080A4:  ADDWFC x95,W
080A6:  MOVWF  FEA
080A8:  MOVFF  FEC,997
080AC:  MOVF   FED,F
080AE:  MOVFF  FEF,996
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
080B2:  MOVLW  0B
080B4:  ADDWF  x96,W
080B6:  MOVWF  01
080B8:  MOVLW  00
080BA:  ADDWFC x97,W
080BC:  MOVFF  01,FE9
080C0:  MOVWF  FEA
080C2:  MOVF   FEF,W
080C4:  IORLW  20
080C6:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
080C8:  MOVLW  1C
080CA:  ADDWF  x96,W
080CC:  MOVWF  01
080CE:  MOVLW  00
080D0:  ADDWFC x97,W
080D2:  MOVWF  03
080D4:  MOVFF  01,998
080D8:  MOVWF  x99
080DA:  MOVLW  04
080DC:  ADDWF  x94,W
080DE:  MOVWF  FE9
080E0:  MOVLW  00
080E2:  ADDWFC x95,W
080E4:  MOVWF  FEA
080E6:  MOVFF  FEF,00
080EA:  MOVFF  FEC,01
080EE:  MOVFF  FEC,02
080F2:  MOVFF  FEC,03
080F6:  MOVFF  999,FEA
080FA:  MOVFF  998,FE9
080FE:  MOVFF  00,FEF
08102:  MOVFF  01,FEC
08106:  MOVFF  02,FEC
0810A:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
0810E:  MOVLW  1A
08110:  ADDWF  x96,W
08112:  MOVWF  01
08114:  MOVLW  00
08116:  ADDWFC x97,W
08118:  MOVWF  03
0811A:  MOVFF  01,998
0811E:  MOVWF  x99
08120:  MOVLW  08
08122:  ADDWF  x94,W
08124:  MOVWF  FE9
08126:  MOVLW  00
08128:  ADDWFC x95,W
0812A:  MOVWF  FEA
0812C:  MOVFF  FEF,00
08130:  MOVFF  FEC,01
08134:  MOVFF  FEC,02
08138:  MOVFF  FEC,03
0813C:  MOVFF  999,FEA
08140:  MOVFF  998,FE9
08144:  MOVFF  00,FEF
08148:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
0814C:  MOVLW  14
0814E:  ADDWF  x96,W
08150:  MOVWF  01
08152:  MOVLW  00
08154:  ADDWFC x97,W
08156:  MOVWF  03
08158:  MOVFF  01,998
0815C:  MOVWF  x99
0815E:  MOVLW  08
08160:  ADDWF  x94,W
08162:  MOVWF  FE9
08164:  MOVLW  00
08166:  ADDWFC x95,W
08168:  MOVWF  FEA
0816A:  MOVFF  FEF,99A
0816E:  MOVFF  FEC,99B
08172:  MOVFF  FEC,00
08176:  MOVFF  FEC,01
0817A:  MOVFF  999,FEA
0817E:  MOVFF  998,FE9
08182:  MOVFF  00,FEF
08186:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
0818A:  MOVLW  16
0818C:  ADDWF  x96,W
0818E:  MOVWF  01
08190:  MOVLW  00
08192:  ADDWFC x97,W
08194:  MOVWF  03
08196:  MOVFF  01,998
0819A:  MOVWF  x99
0819C:  MOVLB  0
0819E:  CALL   6F4A
081A2:  MOVFF  999,FEA
081A6:  MOVFF  998,FE9
081AA:  MOVFF  00,FEF
081AE:  MOVFF  01,FEC
081B2:  MOVFF  02,FEC
081B6:  MOVFF  03,FEC
....................       fs->winflag = 1; 
081BA:  MOVLW  06
081BC:  MOVLB  7
081BE:  ADDWF  x12,W
081C0:  MOVWF  FE9
081C2:  MOVLW  00
081C4:  ADDWFC x13,W
081C6:  MOVWF  FEA
081C8:  MOVLW  01
081CA:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
081CC:  MOVLW  1A
081CE:  MOVLB  9
081D0:  ADDWF  x94,W
081D2:  MOVWF  FE9
081D4:  MOVLW  00
081D6:  ADDWFC x95,W
081D8:  MOVWF  FEA
081DA:  MOVF   FEF,W
081DC:  ANDLW  DF
081DE:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
081E0:  CLRF   xF4
081E2:  CLRF   xF3
081E4:  CLRF   xF2
081E6:  CLRF   xF1
081E8:  MOVLB  0
081EA:  CALL   5A16
081EE:  MOVF   01,F
081F0:  BNZ   81FC
....................       return (FR_RW_ERROR); 
081F2:  MOVLW  07
081F4:  MOVWF  01
081F6:  MOVLB  7
081F8:  BRA    8202
081FA:  MOVLB  0
....................  
....................    return (FR_OK); 
081FC:  MOVLW  00
081FE:  MOVWF  01
08200:  MOVLB  7
08202:  MOVLB  0
08204:  GOTO   8212 (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
08208:  MOVFF  992,995
0820C:  MOVFF  991,994
08210:  BRA    8028
08212:  MOVFF  01,993
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
08216:  MOVLB  9
08218:  MOVF   x93,F
0821A:  BNZ   824C
....................       { 
....................       fp->flag = 0; 
0821C:  MOVLW  1A
0821E:  ADDWF  x91,W
08220:  MOVWF  FE9
08222:  MOVLW  00
08224:  ADDWFC x92,W
08226:  MOVWF  FEA
08228:  CLRF   FEF
....................       if (fs->files) 
0822A:  MOVLW  01
0822C:  MOVLB  7
0822E:  ADDWF  x12,W
08230:  MOVWF  FE9
08232:  MOVLW  00
08234:  ADDWFC x13,W
08236:  MOVWF  FEA
08238:  MOVF   FEF,F
0823A:  BZ    824A
....................          fs->files--; 
0823C:  MOVLW  01
0823E:  ADDWF  x12,W
08240:  MOVWF  FE9
08242:  MOVLW  00
08244:  ADDWFC x13,W
08246:  MOVWF  FEA
08248:  DECF   FEF,F
0824A:  MOVLB  9
....................       } 
....................    return (res); 
0824C:  MOVFF  993,01
08250:  MOVLB  0
08252:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0B928:  CALL   553C
0B92C:  MOVFF  01,86C
....................    if (res != FR_OK)  
0B930:  MOVLB  8
0B932:  MOVF   x6C,F
0B934:  BZ    B93C
....................       return (res); 
0B936:  MOVFF  86C,01
0B93A:  BRA    BBCC
....................  
....................    if (disk_status() & STA_PROTECT) 
0B93C:  MOVLB  0
0B93E:  CALL   552E
0B942:  BTFSS  01.2
0B944:  BRA    B950
....................       return (FR_WRITE_PROTECTED); 
0B946:  MOVLW  0A
0B948:  MOVWF  01
0B94A:  MOVLB  8
0B94C:  BRA    BBCC
0B94E:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0B950:  MOVLW  08
0B952:  MOVLB  9
0B954:  MOVWF  xB8
0B956:  MOVLW  79
0B958:  MOVWF  xB7
0B95A:  MOVLW  08
0B95C:  MOVWF  xBA
0B95E:  MOVLW  87
0B960:  MOVWF  xB9
0B962:  MOVFF  86B,9BC
0B966:  MOVFF  86A,9BB
0B96A:  MOVLW  08
0B96C:  MOVWF  xBE
0B96E:  MOVLW  6D
0B970:  MOVWF  xBD
0B972:  MOVLB  0
0B974:  CALL   6166
0B978:  MOVFF  01,86C
....................  
....................    if (res != FR_OK)  
0B97C:  MOVLB  8
0B97E:  MOVF   x6C,F
0B980:  BZ    B988
....................       return (res);            // Trace failed  
0B982:  MOVFF  86C,01
0B986:  BRA    BBCC
....................  
....................    if (dir_ptr == NULL)  
0B988:  MOVF   x6D,F
0B98A:  BNZ   B996
0B98C:  MOVF   x6E,F
0B98E:  BNZ   B996
....................       return (FR_NO_FILE);      // It is a root directory  
0B990:  MOVLW  02
0B992:  MOVWF  01
0B994:  BRA    BBCC
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0B996:  MOVLW  0B
0B998:  ADDWF  x6D,W
0B99A:  MOVWF  01
0B99C:  MOVLW  00
0B99E:  ADDWFC x6E,W
0B9A0:  MOVWF  03
0B9A2:  MOVFF  01,FE9
0B9A6:  MOVWF  FEA
0B9A8:  BTFSS  FEF.0
0B9AA:  BRA    B9B2
....................       return (FR_DENIED);         // It is a R/O item  
0B9AC:  MOVLW  05
0B9AE:  MOVWF  01
0B9B0:  BRA    BBCC
....................  
....................    dsect = fs->winsect; 
0B9B2:  MOVLW  20
0B9B4:  MOVLB  7
0B9B6:  ADDWF  x12,W
0B9B8:  MOVWF  FE9
0B9BA:  MOVLW  00
0B9BC:  ADDWFC x13,W
0B9BE:  MOVWF  FEA
0B9C0:  MOVFF  FEF,875
0B9C4:  MOVFF  FEC,876
0B9C8:  MOVFF  FEC,877
0B9CC:  MOVFF  FEC,878
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0B9D0:  MOVLW  14
0B9D2:  MOVLB  8
0B9D4:  ADDWF  x6D,W
0B9D6:  MOVWF  01
0B9D8:  MOVLW  00
0B9DA:  ADDWFC x6E,W
0B9DC:  MOVWF  03
0B9DE:  MOVFF  01,FE9
0B9E2:  MOVWF  FEA
0B9E4:  MOVFF  FEC,874
0B9E8:  MOVF   FED,F
0B9EA:  MOVFF  FEF,893
0B9EE:  MOVFF  893,873
0B9F2:  CLRF   x93
0B9F4:  CLRF   x94
0B9F6:  MOVLW  1A
0B9F8:  ADDWF  x6D,W
0B9FA:  MOVWF  01
0B9FC:  MOVLW  00
0B9FE:  ADDWFC x6E,W
0BA00:  MOVFF  01,FE9
0BA04:  MOVWF  FEA
0BA06:  MOVFF  FEC,03
0BA0A:  MOVF   FED,F
0BA0C:  MOVF   FEF,W
0BA0E:  IORWF  x93,W
0BA10:  MOVWF  x71
0BA12:  MOVF   03,W
0BA14:  IORWF  x94,W
0BA16:  MOVWF  x72
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BA18:  MOVLW  0B
0BA1A:  ADDWF  x6D,W
0BA1C:  MOVWF  01
0BA1E:  MOVLW  00
0BA20:  ADDWFC x6E,W
0BA22:  MOVWF  03
0BA24:  MOVFF  01,FE9
0BA28:  MOVWF  FEA
0BA2A:  BTFSS  FEF.4
0BA2C:  BRA    BB40
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BA2E:  MOVFF  874,880
0BA32:  MOVFF  873,87F
0BA36:  MOVFF  872,87E
0BA3A:  MOVFF  871,87D
....................       dirscan.sect = clust2sect(dclust); 
0BA3E:  MOVFF  874,9D3
0BA42:  MOVFF  873,9D2
0BA46:  MOVFF  872,9D1
0BA4A:  MOVFF  871,9D0
0BA4E:  MOVLB  0
0BA50:  CALL   559E
0BA54:  MOVFF  03,884
0BA58:  MOVFF  02,883
0BA5C:  MOVFF  01,882
0BA60:  MOVFF  00,881
....................       dirscan.index = 0; 
0BA64:  MOVLB  8
0BA66:  CLRF   x86
0BA68:  CLRF   x85
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BA6A:  MOVFF  884,9F4
0BA6E:  MOVFF  883,9F3
0BA72:  MOVFF  882,9F2
0BA76:  MOVFF  881,9F1
0BA7A:  MOVLB  0
0BA7C:  CALL   5A16
0BA80:  MOVF   01,F
0BA82:  BNZ   BA8E
....................             return (FR_RW_ERROR); 
0BA84:  MOVLW  07
0BA86:  MOVWF  01
0BA88:  MOVLB  8
0BA8A:  BRA    BBCC
0BA8C:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BA8E:  MOVLB  8
0BA90:  MOVF   x85,W
0BA92:  ANDLW  0F
0BA94:  MOVWF  x93
0BA96:  CLRF   x94
0BA98:  RLCF   x93,F
0BA9A:  RLCF   x94,F
0BA9C:  RLCF   x93,F
0BA9E:  RLCF   x94,F
0BAA0:  RLCF   x93,F
0BAA2:  RLCF   x94,F
0BAA4:  RLCF   x93,F
0BAA6:  RLCF   x94,F
0BAA8:  RLCF   x93,F
0BAAA:  RLCF   x94,F
0BAAC:  MOVLW  E0
0BAAE:  ANDWF  x93,F
0BAB0:  MOVLW  24
0BAB2:  ADDWF  x93,W
0BAB4:  MOVWF  01
0BAB6:  MOVLW  00
0BAB8:  ADDWFC x94,W
0BABA:  MOVWF  03
0BABC:  MOVF   01,W
0BABE:  MOVLB  7
0BAC0:  ADDWF  x12,W
0BAC2:  MOVWF  01
0BAC4:  MOVF   x13,W
0BAC6:  ADDWFC 03,F
0BAC8:  MOVFF  01,86F
0BACC:  MOVLB  8
0BACE:  MOVFF  03,870
....................          if (*sdir == 0) 
0BAD2:  MOVFF  870,03
0BAD6:  MOVFF  86F,FE9
0BADA:  MOVFF  870,FEA
0BADE:  MOVF   FEF,F
0BAE0:  BNZ   BAE4
....................             break; 
0BAE2:  BRA    BB40
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BAE4:  MOVFF  870,03
0BAE8:  MOVFF  86F,FE9
0BAEC:  MOVFF  870,FEA
0BAF0:  MOVF   FEF,W
0BAF2:  SUBLW  E5
0BAF4:  BZ    BB24
0BAF6:  MOVFF  870,03
0BAFA:  MOVFF  86F,FE9
0BAFE:  MOVFF  870,FEA
0BB02:  MOVF   FEF,W
0BB04:  SUBLW  2E
0BB06:  BZ    BB24
0BB08:  MOVLW  0B
0BB0A:  ADDWF  x6F,W
0BB0C:  MOVWF  01
0BB0E:  MOVLW  00
0BB10:  ADDWFC x70,W
0BB12:  MOVWF  03
0BB14:  MOVFF  01,FE9
0BB18:  MOVWF  FEA
0BB1A:  BTFSC  FEF.3
0BB1C:  BRA    BB24
....................             return (FR_DENIED);   // The directory is not empty  
0BB1E:  MOVLW  05
0BB20:  MOVWF  01
0BB22:  BRA    BBCC
....................          } while (next_dir_ptr(&dirscan)); 
0BB24:  MOVLW  08
0BB26:  MOVLB  9
0BB28:  MOVWF  xC7
0BB2A:  MOVLW  79
0BB2C:  MOVWF  xC6
0BB2E:  MOVLB  0
0BB30:  CALL   5F8C
0BB34:  MOVF   01,F
0BB36:  BTFSC  FD8.2
0BB38:  BRA    BB3E
0BB3A:  MOVLB  8
0BB3C:  BRA    BA6A
0BB3E:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BB40:  MOVFF  878,9F4
0BB44:  MOVFF  877,9F3
0BB48:  MOVFF  876,9F2
0BB4C:  MOVFF  875,9F1
0BB50:  MOVLB  0
0BB52:  CALL   5A16
0BB56:  MOVF   01,F
0BB58:  BNZ   BB64
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BB5A:  MOVLW  07
0BB5C:  MOVWF  01
0BB5E:  MOVLB  8
0BB60:  BRA    BBCC
0BB62:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BB64:  MOVLB  8
0BB66:  MOVFF  86D,FE9
0BB6A:  MOVFF  86E,FEA
0BB6E:  MOVLW  E5
0BB70:  MOVWF  FEF
....................    fs->winflag = 1; 
0BB72:  MOVLW  06
0BB74:  MOVLB  7
0BB76:  ADDWF  x12,W
0BB78:  MOVWF  FE9
0BB7A:  MOVLW  00
0BB7C:  ADDWFC x13,W
0BB7E:  MOVWF  FEA
0BB80:  MOVLW  01
0BB82:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BB84:  MOVFF  874,9BF
0BB88:  MOVFF  873,9BE
0BB8C:  MOVFF  872,9BD
0BB90:  MOVFF  871,9BC
0BB94:  MOVLB  0
0BB96:  CALL   6EAA
0BB9A:  MOVF   01,F
0BB9C:  BNZ   BBA8
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BB9E:  MOVLW  07
0BBA0:  MOVWF  01
0BBA2:  MOVLB  8
0BBA4:  BRA    BBCC
0BBA6:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BBA8:  MOVLB  9
0BBAA:  CLRF   xF4
0BBAC:  CLRF   xF3
0BBAE:  CLRF   xF2
0BBB0:  CLRF   xF1
0BBB2:  MOVLB  0
0BBB4:  CALL   5A16
0BBB8:  MOVF   01,F
0BBBA:  BNZ   BBC6
....................       return (FR_RW_ERROR); 
0BBBC:  MOVLW  07
0BBBE:  MOVWF  01
0BBC0:  MOVLB  8
0BBC2:  BRA    BBCC
0BBC4:  MOVLB  0
....................  
....................    return (FR_OK); 
0BBC6:  MOVLW  00
0BBC8:  MOVWF  01
0BBCA:  MOVLB  8
0BBCC:  MOVLB  0
0BBCE:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0791E:  MOVFF  992,994
07922:  MOVFF  991,993
07926:  MOVFF  994,03
0792A:  MOVLB  9
0792C:  MOVFF  993,FE9
07930:  MOVFF  994,FEA
07934:  MOVF   FEF,F
07936:  BZ    7944
07938:  INCF   x93,F
0793A:  BTFSC  FD8.2
0793C:  INCF   x94,F
0793E:  MOVLB  0
07940:  BRA    7926
07942:  MOVLB  9
....................    return(sc - s); 
07944:  MOVF   x91,W
07946:  SUBWF  x93,W
07948:  MOVWF  00
0794A:  MOVF   x92,W
0794C:  SUBWFB x94,W
0794E:  MOVWF  03
07950:  MOVFF  00,01
07954:  MOVWF  02
07956:  MOVLB  0
07958:  GOTO   8398 (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
034A4:  MOVLB  4
034A6:  CLRF   xE6
034A8:  MOVLW  01
034AA:  MOVWF  xE5
....................    rtc.year=10; 
034AC:  MOVLW  0A
034AE:  MOVWF  xE4
....................    rtc.month=1; 
034B0:  MOVLW  01
034B2:  MOVWF  xE3
....................    rtc.day=1; 
034B4:  MOVWF  xE2
....................    rtc.hour=0; 
034B6:  CLRF   xE1
....................    rtc.min=0; 
034B8:  CLRF   xE0
....................    rtc.sec=0; 
034BA:  CLRF   xDF
....................    rtc.ms100=0; 
034BC:  CLRF   xDE
034BE:  MOVLB  0
034C0:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
06F4A:  MOVLB  9
06F4C:  CLRF   xBE
06F4E:  CLRF   xBD
06F50:  CLRF   xBC
06F52:  MOVFF  4E4,9BB
06F56:  MOVLW  14
06F58:  ADDWF  xBB,F
06F5A:  MOVLW  00
06F5C:  ADDWFC xBC,F
06F5E:  ADDWFC xBD,F
06F60:  ADDWFC xBE,F
06F62:  BCF    FD8.0
06F64:  CLRF   xB7
06F66:  CLRF   xB8
06F68:  CLRF   xB9
06F6A:  RLCF   xBB,W
06F6C:  MOVWF  xBA
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
06F6E:  CLRF   xBE
06F70:  CLRF   xBD
06F72:  CLRF   xBC
06F74:  MOVFF  4E3,9BB
06F78:  MOVLW  0F
06F7A:  ANDWF  xBB,F
06F7C:  CLRF   xBC
06F7E:  CLRF   xBD
06F80:  CLRF   xBE
06F82:  CLRF   00
06F84:  CLRF   01
06F86:  RLCF   xBB,W
06F88:  MOVWF  02
06F8A:  RLCF   xBC,W
06F8C:  MOVWF  03
06F8E:  RLCF   02,F
06F90:  RLCF   03,F
06F92:  RLCF   02,F
06F94:  RLCF   03,F
06F96:  RLCF   02,F
06F98:  RLCF   03,F
06F9A:  RLCF   02,F
06F9C:  RLCF   03,F
06F9E:  MOVLW  E0
06FA0:  ANDWF  02,F
06FA2:  MOVF   00,W
06FA4:  IORWF  xB7,F
06FA6:  MOVF   01,W
06FA8:  IORWF  xB8,F
06FAA:  MOVF   02,W
06FAC:  IORWF  xB9,F
06FAE:  MOVF   03,W
06FB0:  IORWF  xBA,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
06FB2:  CLRF   xBE
06FB4:  CLRF   xBD
06FB6:  CLRF   xBC
06FB8:  MOVFF  4E2,9BB
06FBC:  MOVLW  1F
06FBE:  ANDWF  xBB,F
06FC0:  CLRF   xBC
06FC2:  CLRF   xBD
06FC4:  CLRF   xBE
06FC6:  CLRF   00
06FC8:  CLRF   01
06FCA:  MOVF   00,W
06FCC:  IORWF  xB7,F
06FCE:  MOVF   01,W
06FD0:  IORWF  xB8,F
06FD2:  MOVF   xBB,W
06FD4:  IORWF  xB9,F
06FD6:  MOVF   xBC,W
06FD8:  IORWF  xBA,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
06FDA:  CLRF   xBE
06FDC:  CLRF   xBD
06FDE:  CLRF   xBC
06FE0:  MOVFF  4E1,9BB
06FE4:  MOVLW  1F
06FE6:  ANDWF  xBB,F
06FE8:  CLRF   xBC
06FEA:  CLRF   xBD
06FEC:  CLRF   xBE
06FEE:  CLRF   00
06FF0:  RLCF   xBB,W
06FF2:  MOVWF  01
06FF4:  RLCF   xBC,W
06FF6:  MOVWF  02
06FF8:  RLCF   xBD,W
06FFA:  MOVWF  03
06FFC:  RLCF   01,F
06FFE:  RLCF   02,F
07000:  RLCF   03,F
07002:  RLCF   01,F
07004:  RLCF   02,F
07006:  RLCF   03,F
07008:  MOVLW  F8
0700A:  ANDWF  01,F
0700C:  MOVF   00,W
0700E:  IORWF  xB7,F
07010:  MOVF   01,W
07012:  IORWF  xB8,F
07014:  MOVF   02,W
07016:  IORWF  xB9,F
07018:  MOVF   03,W
0701A:  IORWF  xBA,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
0701C:  CLRF   xBE
0701E:  CLRF   xBD
07020:  CLRF   xBC
07022:  MOVFF  4E0,9BB
07026:  MOVLW  3F
07028:  ANDWF  xBB,F
0702A:  CLRF   xBC
0702C:  CLRF   xBD
0702E:  CLRF   xBE
07030:  RLCF   xBB,W
07032:  MOVWF  00
07034:  RLCF   xBC,W
07036:  MOVWF  01
07038:  RLCF   xBD,W
0703A:  MOVWF  02
0703C:  RLCF   xBE,W
0703E:  MOVWF  03
07040:  RLCF   00,F
07042:  RLCF   01,F
07044:  RLCF   02,F
07046:  RLCF   03,F
07048:  RLCF   00,F
0704A:  RLCF   01,F
0704C:  RLCF   02,F
0704E:  RLCF   03,F
07050:  RLCF   00,F
07052:  RLCF   01,F
07054:  RLCF   02,F
07056:  RLCF   03,F
07058:  RLCF   00,F
0705A:  RLCF   01,F
0705C:  RLCF   02,F
0705E:  RLCF   03,F
07060:  MOVLW  E0
07062:  ANDWF  00,F
07064:  MOVF   00,W
07066:  IORWF  xB7,F
07068:  MOVF   01,W
0706A:  IORWF  xB8,F
0706C:  MOVF   02,W
0706E:  IORWF  xB9,F
07070:  MOVF   03,W
07072:  IORWF  xBA,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
07074:  CLRF   xBE
07076:  CLRF   xBD
07078:  CLRF   xBC
0707A:  MOVFF  4DF,9BB
0707E:  MOVLW  3F
07080:  ANDWF  xBB,F
07082:  CLRF   xBC
07084:  CLRF   xBD
07086:  CLRF   xBE
07088:  BCF    FD8.0
0708A:  RRCF   xBE,W
0708C:  MOVWF  03
0708E:  RRCF   xBD,W
07090:  MOVWF  02
07092:  RRCF   xBC,W
07094:  MOVWF  01
07096:  RRCF   xBB,W
07098:  IORWF  xB7,F
0709A:  MOVF   01,W
0709C:  IORWF  xB8,F
0709E:  MOVF   02,W
070A0:  IORWF  xB9,F
070A2:  MOVF   03,W
070A4:  IORWF  xBA,F
....................    return (work); 
070A6:  MOVFF  9B7,00
070AA:  MOVFF  9B8,01
070AE:  MOVFF  9B9,02
070B2:  MOVFF  9BA,03
070B6:  MOVLB  0
070B8:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0B7AE:  MOVLW  08
0B7B0:  MOVLB  9
0B7B2:  MOVWF  x92
0B7B4:  MOVLW  6C
0B7B6:  MOVWF  x91
0B7B8:  MOVFF  86B,994
0B7BC:  MOVFF  86A,993
0B7C0:  MOVLW  01
0B7C2:  MOVWF  x95
0B7C4:  MOVLB  0
0B7C6:  CALL   70BA
0B7CA:  MOVFF  01,888
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0B7CE:  MOVLB  8
0B7D0:  MOVF   x88,F
0B7D2:  BTFSS  FD8.2
0B7D4:  BRA    B8D6
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0B7D6:  MOVLW  08
0B7D8:  MOVWF  xAE
0B7DA:  MOVLW  6C
0B7DC:  MOVWF  xAD
0B7DE:  MOVLW  08
0B7E0:  MOVWF  xB0
0B7E2:  MOVLW  89
0B7E4:  MOVWF  xAF
0B7E6:  CLRF   xB2
0B7E8:  MOVLW  20
0B7EA:  MOVWF  xB1
0B7EC:  MOVLW  08
0B7EE:  MOVWF  xB4
0B7F0:  MOVLW  AB
0B7F2:  MOVWF  xB3
0B7F4:  MOVLB  0
0B7F6:  BRA    B0F2
0B7F8:  MOVFF  01,888
....................          for (i = 0; i < br; i++) 
0B7FC:  MOVLB  8
0B7FE:  CLRF   xAA
0B800:  CLRF   xA9
0B802:  MOVF   xAA,W
0B804:  SUBWF  xAC,W
0B806:  BNC   B832
0B808:  BNZ   B810
0B80A:  MOVF   xAB,W
0B80C:  SUBWF  xA9,W
0B80E:  BC    B832
....................          { 
....................             putc(mesg[i]); 
0B810:  MOVLW  89
0B812:  ADDWF  xA9,W
0B814:  MOVWF  FE9
0B816:  MOVLW  08
0B818:  ADDWFC xAA,W
0B81A:  MOVWF  FEA
0B81C:  MOVFF  FEF,8AD
0B820:  MOVF   xAD,W
0B822:  MOVLB  0
0B824:  CALL   ADD8
0B828:  MOVLB  8
0B82A:  INCF   xA9,F
0B82C:  BTFSC  FD8.2
0B82E:  INCF   xAA,F
0B830:  BRA    B802
....................          } 
....................       } while ((result == FR_OK) && br); 
0B832:  MOVF   x88,F
0B834:  BNZ   B83C
0B836:  MOVF   xAB,W
0B838:  IORWF  xAC,W
0B83A:  BNZ   B7D6
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0B83C:  MOVF   x88,F
0B83E:  BZ    B8B2
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0B840:  MOVLW  16
0B842:  MOVWF  FF6
0B844:  MOVLW  0C
0B846:  MOVWF  FF7
0B848:  MOVLW  00
0B84A:  MOVWF  FF8
0B84C:  CLRF   1B
0B84E:  BTFSC  FF2.7
0B850:  BSF    1B.7
0B852:  BCF    FF2.7
0B854:  MOVLB  0
0B856:  CALL   0E4E
0B85A:  BTFSC  1B.7
0B85C:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0B85E:  MOVFF  888,8AD
0B862:  MOVLW  08
0B864:  MOVLB  8
0B866:  MOVWF  xAF
0B868:  MOVLW  89
0B86A:  MOVWF  xAE
0B86C:  MOVLB  0
0B86E:  RCALL  B600
....................          printf("@FS: %s\r\n",mesg); 
0B870:  MOVLW  2C
0B872:  MOVWF  FF6
0B874:  MOVLW  0C
0B876:  MOVWF  FF7
0B878:  MOVLW  00
0B87A:  MOVWF  FF8
0B87C:  CLRF   1B
0B87E:  BTFSC  FF2.7
0B880:  BSF    1B.7
0B882:  BCF    FF2.7
0B884:  MOVLW  05
0B886:  MOVLB  A
0B888:  MOVWF  x1C
0B88A:  MOVLB  0
0B88C:  CALL   1024
0B890:  BTFSC  1B.7
0B892:  BSF    FF2.7
0B894:  MOVLW  08
0B896:  MOVWF  FEA
0B898:  MOVLW  89
0B89A:  MOVWF  FE9
0B89C:  CALL   78F8
0B8A0:  MOVLW  0D
0B8A2:  BTFSS  F9E.4
0B8A4:  BRA    B8A2
0B8A6:  MOVWF  FAD
0B8A8:  MOVLW  0A
0B8AA:  BTFSS  F9E.4
0B8AC:  BRA    B8AA
0B8AE:  MOVWF  FAD
0B8B0:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0B8B2:  MOVLW  08
0B8B4:  MOVLB  9
0B8B6:  MOVWF  x92
0B8B8:  MOVLW  6C
0B8BA:  MOVWF  x91
0B8BC:  MOVLB  0
0B8BE:  CALL   8208
....................       printf("\r\n");       
0B8C2:  MOVLW  0D
0B8C4:  BTFSS  F9E.4
0B8C6:  BRA    B8C4
0B8C8:  MOVWF  FAD
0B8CA:  MOVLW  0A
0B8CC:  BTFSS  F9E.4
0B8CE:  BRA    B8CC
0B8D0:  MOVWF  FAD
....................    } 
0B8D2:  BRA    B926
0B8D4:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0B8D6:  MOVFF  888,8AD
0B8DA:  MOVLW  08
0B8DC:  MOVWF  xAF
0B8DE:  MOVLW  89
0B8E0:  MOVWF  xAE
0B8E2:  MOVLB  0
0B8E4:  RCALL  B600
....................       printf("@FS: %s\r\n",mesg); 
0B8E6:  MOVLW  36
0B8E8:  MOVWF  FF6
0B8EA:  MOVLW  0C
0B8EC:  MOVWF  FF7
0B8EE:  MOVLW  00
0B8F0:  MOVWF  FF8
0B8F2:  CLRF   1B
0B8F4:  BTFSC  FF2.7
0B8F6:  BSF    1B.7
0B8F8:  BCF    FF2.7
0B8FA:  MOVLW  05
0B8FC:  MOVLB  A
0B8FE:  MOVWF  x1C
0B900:  MOVLB  0
0B902:  CALL   1024
0B906:  BTFSC  1B.7
0B908:  BSF    FF2.7
0B90A:  MOVLW  08
0B90C:  MOVWF  FEA
0B90E:  MOVLW  89
0B910:  MOVWF  FE9
0B912:  CALL   78F8
0B916:  MOVLW  0D
0B918:  BTFSS  F9E.4
0B91A:  BRA    B918
0B91C:  MOVWF  FAD
0B91E:  MOVLW  0A
0B920:  BTFSS  F9E.4
0B922:  BRA    B920
0B924:  MOVWF  FAD
....................    } 
0B926:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04D88:  MOVLW  40
04D8A:  MOVWF  FF6
04D8C:  MOVLW  0C
04D8E:  MOVWF  FF7
04D90:  MOVLW  00
04D92:  MOVWF  FF8
04D94:  CLRF   1B
04D96:  BTFSC  FF2.7
04D98:  BSF    1B.7
04D9A:  BCF    FF2.7
04D9C:  CALL   0E4E
04DA0:  BTFSC  1B.7
04DA2:  BSF    FF2.7
....................    if (status & FR_OK) 
04DA4:  ANDLW  00
04DA6:  BZ    4DC4
....................       printf("   NoError\r\n"); 
04DA8:  MOVLW  50
04DAA:  MOVWF  FF6
04DAC:  MOVLW  0C
04DAE:  MOVWF  FF7
04DB0:  MOVLW  00
04DB2:  MOVWF  FF8
04DB4:  CLRF   1B
04DB6:  BTFSC  FF2.7
04DB8:  BSF    1B.7
04DBA:  BCF    FF2.7
04DBC:  CALL   0E4E
04DC0:  BTFSC  1B.7
04DC2:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04DC4:  MOVLB  8
04DC6:  BTFSS  x6B.0
04DC8:  BRA    4DEA
....................       printf("   Media Not Ready\r\n"); 
04DCA:  MOVLW  5E
04DCC:  MOVWF  FF6
04DCE:  MOVLW  0C
04DD0:  MOVWF  FF7
04DD2:  MOVLW  00
04DD4:  MOVWF  FF8
04DD6:  CLRF   1B
04DD8:  BTFSC  FF2.7
04DDA:  BSF    1B.7
04DDC:  BCF    FF2.7
04DDE:  MOVLB  0
04DE0:  CALL   0E4E
04DE4:  BTFSC  1B.7
04DE6:  BSF    FF2.7
04DE8:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04DEA:  BTFSS  x6B.1
04DEC:  BRA    4E0E
....................       printf("   File Not Found\r\n"); 
04DEE:  MOVLW  74
04DF0:  MOVWF  FF6
04DF2:  MOVLW  0C
04DF4:  MOVWF  FF7
04DF6:  MOVLW  00
04DF8:  MOVWF  FF8
04DFA:  CLRF   1B
04DFC:  BTFSC  FF2.7
04DFE:  BSF    1B.7
04E00:  BCF    FF2.7
04E02:  MOVLB  0
04E04:  CALL   0E4E
04E08:  BTFSC  1B.7
04E0A:  BSF    FF2.7
04E0C:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04E0E:  MOVF   x6B,W
04E10:  ANDLW  03
04E12:  BZ    4E34
....................       printf("   Invalid Path\r\n"); 
04E14:  MOVLW  88
04E16:  MOVWF  FF6
04E18:  MOVLW  0C
04E1A:  MOVWF  FF7
04E1C:  MOVLW  00
04E1E:  MOVWF  FF8
04E20:  CLRF   1B
04E22:  BTFSC  FF2.7
04E24:  BSF    1B.7
04E26:  BCF    FF2.7
04E28:  MOVLB  0
04E2A:  CALL   0E4E
04E2E:  BTFSC  1B.7
04E30:  BSF    FF2.7
04E32:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04E34:  BTFSS  x6B.2
04E36:  BRA    4E58
....................       printf("   Invalid Name\r\n"); 
04E38:  MOVLW  9A
04E3A:  MOVWF  FF6
04E3C:  MOVLW  0C
04E3E:  MOVWF  FF7
04E40:  MOVLW  00
04E42:  MOVWF  FF8
04E44:  CLRF   1B
04E46:  BTFSC  FF2.7
04E48:  BSF    1B.7
04E4A:  BCF    FF2.7
04E4C:  MOVLB  0
04E4E:  CALL   0E4E
04E52:  BTFSC  1B.7
04E54:  BSF    FF2.7
04E56:  MOVLB  8
....................    if (status & FR_DENIED) 
04E58:  MOVF   x6B,W
04E5A:  ANDLW  05
04E5C:  BZ    4E7E
....................       printf("   Access Denied\r\n"); 
04E5E:  MOVLW  AC
04E60:  MOVWF  FF6
04E62:  MOVLW  0C
04E64:  MOVWF  FF7
04E66:  MOVLW  00
04E68:  MOVWF  FF8
04E6A:  CLRF   1B
04E6C:  BTFSC  FF2.7
04E6E:  BSF    1B.7
04E70:  BCF    FF2.7
04E72:  MOVLB  0
04E74:  CALL   0E4E
04E78:  BTFSC  1B.7
04E7A:  BSF    FF2.7
04E7C:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04E7E:  MOVF   x6B,W
04E80:  ANDLW  06
04E82:  BZ    4EA4
....................       printf("   Disk Full\r\n"); 
04E84:  MOVLW  C0
04E86:  MOVWF  FF6
04E88:  MOVLW  0C
04E8A:  MOVWF  FF7
04E8C:  MOVLW  00
04E8E:  MOVWF  FF8
04E90:  CLRF   1B
04E92:  BTFSC  FF2.7
04E94:  BSF    1B.7
04E96:  BCF    FF2.7
04E98:  MOVLB  0
04E9A:  CALL   0E4E
04E9E:  BTFSC  1B.7
04EA0:  BSF    FF2.7
04EA2:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04EA4:  MOVF   x6B,W
04EA6:  ANDLW  07
04EA8:  BZ    4ECA
....................       printf("   Read/Write Error\r\n"); 
04EAA:  MOVLW  D0
04EAC:  MOVWF  FF6
04EAE:  MOVLW  0C
04EB0:  MOVWF  FF7
04EB2:  MOVLW  00
04EB4:  MOVWF  FF8
04EB6:  CLRF   1B
04EB8:  BTFSC  FF2.7
04EBA:  BSF    1B.7
04EBC:  BCF    FF2.7
04EBE:  MOVLB  0
04EC0:  CALL   0E4E
04EC4:  BTFSC  1B.7
04EC6:  BSF    FF2.7
04EC8:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04ECA:  MOVF   x6B,W
04ECC:  ANDLW  09
04ECE:  BZ    4EF0
....................       printf("   Incorrect Media Change\r\n"); 
04ED0:  MOVLW  E6
04ED2:  MOVWF  FF6
04ED4:  MOVLW  0C
04ED6:  MOVWF  FF7
04ED8:  MOVLW  00
04EDA:  MOVWF  FF8
04EDC:  CLRF   1B
04EDE:  BTFSC  FF2.7
04EE0:  BSF    1B.7
04EE2:  BCF    FF2.7
04EE4:  MOVLB  0
04EE6:  CALL   0E4E
04EEA:  BTFSC  1B.7
04EEC:  BSF    FF2.7
04EEE:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04EF0:  MOVF   x6B,W
04EF2:  ANDLW  0A
04EF4:  BZ    4F16
....................       printf("   Write Protected\r\n"); 
04EF6:  MOVLW  02
04EF8:  MOVWF  FF6
04EFA:  MOVLW  0D
04EFC:  MOVWF  FF7
04EFE:  MOVLW  00
04F00:  MOVWF  FF8
04F02:  CLRF   1B
04F04:  BTFSC  FF2.7
04F06:  BSF    1B.7
04F08:  BCF    FF2.7
04F0A:  MOVLB  0
04F0C:  CALL   0E4E
04F10:  BTFSC  1B.7
04F12:  BSF    FF2.7
04F14:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04F16:  MOVF   x6B,W
04F18:  ANDLW  0B
04F1A:  BZ    4F3C
....................       printf("   Not Enabled\r\n"); 
04F1C:  MOVLW  18
04F1E:  MOVWF  FF6
04F20:  MOVLW  0D
04F22:  MOVWF  FF7
04F24:  MOVLW  00
04F26:  MOVWF  FF8
04F28:  CLRF   1B
04F2A:  BTFSC  FF2.7
04F2C:  BSF    1B.7
04F2E:  BCF    FF2.7
04F30:  MOVLB  0
04F32:  CALL   0E4E
04F36:  BTFSC  1B.7
04F38:  BSF    FF2.7
04F3A:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04F3C:  MOVF   x6B,W
04F3E:  ANDLW  0C
04F40:  BZ    4F62
....................       printf("   No File System\r\n"); 
04F42:  MOVLW  2A
04F44:  MOVWF  FF6
04F46:  MOVLW  0D
04F48:  MOVWF  FF7
04F4A:  MOVLW  00
04F4C:  MOVWF  FF8
04F4E:  CLRF   1B
04F50:  BTFSC  FF2.7
04F52:  BSF    1B.7
04F54:  BCF    FF2.7
04F56:  MOVLB  0
04F58:  CALL   0E4E
04F5C:  BTFSC  1B.7
04F5E:  BSF    FF2.7
04F60:  MOVLB  8
04F62:  MOVLB  0
04F64:  GOTO   4FEE (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
08254:  MOVLW  08
08256:  MOVWF  FEA
08258:  MOVLW  F1
0825A:  MOVWF  FE9
0825C:  CLRF   00
0825E:  CLRF   02
08260:  MOVLW  A0
08262:  MOVWF  01
08264:  CALL   34C2
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
08268:  MOVLW  08
0826A:  MOVLB  9
0826C:  MOVWF  x92
0826E:  MOVLW  D0
08270:  MOVWF  x91
08272:  MOVFF  8CF,994
08276:  MOVFF  8CE,993
0827A:  MOVLW  12
0827C:  MOVWF  x95
0827E:  MOVLB  0
08280:  CALL   70BA
08284:  MOVFF  01,8EC
....................    if (result) 
08288:  MOVLB  8
0828A:  MOVF   xEC,F
0828C:  BZ    82B0
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
0828E:  MOVLW  3E
08290:  MOVWF  FF6
08292:  MOVLW  0D
08294:  MOVWF  FF7
08296:  MOVLW  00
08298:  MOVWF  FF8
0829A:  CLRF   1B
0829C:  BTFSC  FF2.7
0829E:  BSF    1B.7
082A0:  BCF    FF2.7
082A2:  MOVLB  0
082A4:  CALL   0E4E
082A8:  BTFSC  1B.7
082AA:  BSF    FF2.7
....................    } 
082AC:  BRA    842C
082AE:  MOVLB  8
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
082B0:  MOVF   xD4,F
082B2:  BNZ   82C0
082B4:  MOVF   xD5,F
082B6:  BNZ   82C0
082B8:  MOVF   xD6,F
082BA:  BNZ   82C0
082BC:  MOVF   xD7,F
082BE:  BZ    82E6
....................          result = f_lseek(&fdst, fdst.fsize);  
082C0:  MOVLW  08
082C2:  MOVLB  9
082C4:  MOVWF  x92
082C6:  MOVLW  D0
082C8:  MOVWF  x91
082CA:  MOVFF  8D7,996
082CE:  MOVFF  8D6,995
082D2:  MOVFF  8D5,994
082D6:  MOVFF  8D4,993
082DA:  MOVLB  0
082DC:  GOTO   7502
082E0:  MOVFF  01,8EC
082E4:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
082E6:  MOVLB  0
082E8:  MOVF   x66,F
082EA:  BNZ   8308
082EC:  MOVLW  08
082EE:  MOVLB  9
082F0:  MOVWF  x92
082F2:  MOVLW  F1
082F4:  MOVWF  x91
082F6:  CLRF   x94
082F8:  MOVLW  67
082FA:  MOVWF  x93
082FC:  CLRF   x96
082FE:  MOVLW  9F
08300:  MOVWF  x95
08302:  MOVLB  0
08304:  CALL   786A
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
08308:  DECFSZ x66,W
0830A:  BRA    832A
0830C:  MOVLW  08
0830E:  MOVLB  9
08310:  MOVWF  x92
08312:  MOVLW  F1
08314:  MOVWF  x91
08316:  MOVLW  01
08318:  MOVWF  x94
0831A:  MOVLW  07
0831C:  MOVWF  x93
0831E:  CLRF   x96
08320:  MOVLW  9F
08322:  MOVWF  x95
08324:  MOVLB  0
08326:  CALL   786A
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
0832A:  MOVF   20,F
0832C:  BNZ   8334
0832E:  MOVF   1F,W
08330:  SUBLW  04
08332:  BC    8388
08334:  MOVLW  5E
08336:  MOVWF  FF6
08338:  MOVLW  0D
0833A:  MOVWF  FF7
0833C:  MOVLW  00
0833E:  MOVWF  FF8
08340:  CLRF   1B
08342:  BTFSC  FF2.7
08344:  BSF    1B.7
08346:  BCF    FF2.7
08348:  MOVLW  0E
0834A:  MOVLB  A
0834C:  MOVWF  x1C
0834E:  MOVLB  0
08350:  CALL   1024
08354:  BTFSC  1B.7
08356:  BSF    FF2.7
08358:  MOVLW  08
0835A:  MOVWF  FEA
0835C:  MOVLW  F1
0835E:  MOVWF  FE9
08360:  CALL   78F8
08364:  MOVLW  6E
08366:  MOVWF  FF6
08368:  MOVLW  0D
0836A:  MOVWF  FF7
0836C:  MOVLW  00
0836E:  MOVWF  FF8
08370:  CLRF   1B
08372:  BTFSC  FF2.7
08374:  BSF    1B.7
08376:  BCF    FF2.7
08378:  MOVLW  03
0837A:  MOVLB  A
0837C:  MOVWF  x1C
0837E:  MOVLB  0
08380:  CALL   1024
08384:  BTFSC  1B.7
08386:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
08388:  MOVLW  08
0838A:  MOVLB  9
0838C:  MOVWF  x92
0838E:  MOVLW  F1
08390:  MOVWF  x91
08392:  MOVLB  0
08394:  GOTO   791E
08398:  MOVFF  02,8EE
0839C:  MOVFF  01,8ED
....................       result = f_write(&fdst, mesg, btw, &bw); 
083A0:  MOVLW  08
083A2:  MOVLB  9
083A4:  MOVWF  x92
083A6:  MOVLW  D0
083A8:  MOVWF  x91
083AA:  MOVLW  08
083AC:  MOVWF  x94
083AE:  MOVLW  F1
083B0:  MOVWF  x93
083B2:  MOVFF  8EE,996
083B6:  MOVFF  8ED,995
083BA:  MOVLW  08
083BC:  MOVWF  x98
083BE:  MOVLW  EF
083C0:  MOVWF  x97
083C2:  MOVLB  0
083C4:  GOTO   795C
083C8:  MOVFF  01,8EC
....................       if (result) 
083CC:  MOVLB  8
083CE:  MOVF   xEC,F
083D0:  BZ    83F4
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
083D2:  MOVLW  72
083D4:  MOVWF  FF6
083D6:  MOVLW  0D
083D8:  MOVWF  FF7
083DA:  MOVLW  00
083DC:  MOVWF  FF8
083DE:  CLRF   1B
083E0:  BTFSC  FF2.7
083E2:  BSF    1B.7
083E4:  BCF    FF2.7
083E6:  MOVLB  0
083E8:  CALL   0E4E
083EC:  BTFSC  1B.7
083EE:  BSF    FF2.7
....................       } 
083F0:  BRA    841C
083F2:  MOVLB  8
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
083F4:  MOVF   20,F
083F6:  BNZ   83FE
083F8:  MOVF   1F,W
083FA:  SUBLW  04
083FC:  BC    841E
083FE:  MOVLW  86
08400:  MOVWF  FF6
08402:  MOVLW  0D
08404:  MOVWF  FF7
08406:  MOVLW  00
08408:  MOVWF  FF8
0840A:  CLRF   1B
0840C:  BTFSC  FF2.7
0840E:  BSF    1B.7
08410:  BCF    FF2.7
08412:  MOVLB  0
08414:  CALL   0E4E
08418:  BTFSC  1B.7
0841A:  BSF    FF2.7
0841C:  MOVLB  8
....................       } 
....................  
....................       f_close(&fdst); 
0841E:  MOVLW  08
08420:  MOVLB  9
08422:  MOVWF  x92
08424:  MOVLW  D0
08426:  MOVWF  x91
08428:  MOVLB  0
0842A:  RCALL  8208
....................    } 
....................  
....................    return (result); 
0842C:  MOVLB  8
0842E:  MOVFF  8EC,01
08432:  MOVLB  0
08434:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
17696:  CLRF   1B
17698:  BTFSC  FF2.7
1769A:  BSF    1B.7
1769C:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
1769E:  MOVFF  868,A1E
176A2:  MOVLW  0A
176A4:  MOVLB  A
176A6:  MOVWF  x1F
176A8:  MOVLB  0
176AA:  CALL   0F7A
176AE:  BTFSC  1B.7
176B0:  BSF    FF2.7
176B2:  MOVFF  01,869
....................    nibl=data-(nibh*10); 
176B6:  MOVLB  8
176B8:  MOVF   x69,W
176BA:  MULLW  0A
176BC:  MOVF   FF3,W
176BE:  SUBWF  x68,W
176C0:  MOVWF  x6A
....................  
....................    return((nibh<<4)|nibl); 
176C2:  SWAPF  x69,W
176C4:  MOVWF  00
176C6:  MOVLW  F0
176C8:  ANDWF  00,F
176CA:  MOVF   00,W
176CC:  IORWF  x6A,W
176CE:  MOVWF  01
176D0:  MOVLB  0
176D2:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
032AE:  MOVFF  8CF,8D0
....................    data=(i>>4)*10; 
032B2:  MOVLB  8
032B4:  SWAPF  xD0,W
032B6:  MOVWF  00
032B8:  MOVLW  0F
032BA:  ANDWF  00,F
032BC:  MOVF   00,W
032BE:  MULLW  0A
032C0:  MOVFF  FF3,8CF
....................    data=data+(i<<4>>4); 
032C4:  SWAPF  xD0,W
032C6:  MOVWF  00
032C8:  MOVLW  F0
032CA:  ANDWF  00,F
032CC:  MOVF   00,W
032CE:  SWAPF  00,F
032D0:  MOVLW  0F
032D2:  ANDWF  00,F
032D4:  MOVF   00,W
032D6:  ADDWF  xCF,F
....................  
....................    return data; 
032D8:  MOVFF  8CF,01
032DC:  MOVLB  0
032DE:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0344E:  MOVLB  8
03450:  CLRF   xAC
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
03452:  BCF    FC6.5
03454:  MOVLW  21
03456:  MOVWF  FC6
03458:  MOVLW  40
0345A:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0345C:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
0345E:  MOVF   FC9,W
03460:  MOVLW  0C
03462:  MOVWF  FC9
03464:  RRCF   FC7,W
03466:  BNC   3464
03468:  MOVFF  FC9,8AC
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0346C:  MOVF   FC9,W
0346E:  MOVFF  8AC,FC9
03472:  RRCF   FC7,W
03474:  BNC   3472
03476:  MOVFF  FC9,730
....................    output_bit(RTC_CS, DISABLE); 
0347A:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
0347C:  MOVLB  7
0347E:  BCF    x30.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
03480:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
03482:  MOVF   FC9,W
03484:  MOVLW  8C
03486:  MOVWF  FC9
03488:  RRCF   FC7,W
0348A:  BNC   3488
0348C:  MOVFF  FC9,8AC
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
03490:  MOVF   FC9,W
03492:  MOVFF  730,FC9
03496:  RRCF   FC7,W
03498:  BNC   3496
0349A:  MOVFF  FC9,8AC
....................    output_bit(RTC_CS, DISABLE); 
0349E:  BSF    F91.0
034A0:  MOVLB  0
034A2:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0DEFA:  MOVLW  1A
0DEFC:  MOVLB  8
0DEFE:  MOVWF  x78
0DF00:  MOVLB  0
0DF02:  CALL   2966
0DF06:  MOVFF  01,4F
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0DF0A:  MOVF   4F,F
0DF0C:  BNZ   DF7A
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0DF0E:  MOVLW  94
0DF10:  MOVWF  FF6
0DF12:  MOVLW  0D
0DF14:  MOVWF  FF7
0DF16:  MOVLW  00
0DF18:  MOVWF  FF8
0DF1A:  CLRF   1B
0DF1C:  BTFSC  FF2.7
0DF1E:  BSF    1B.7
0DF20:  BCF    FF2.7
0DF22:  MOVLW  05
0DF24:  MOVLB  A
0DF26:  MOVWF  x1C
0DF28:  MOVLB  0
0DF2A:  CALL   1024
0DF2E:  BTFSC  1B.7
0DF30:  BSF    FF2.7
0DF32:  CLRF   1B
0DF34:  BTFSC  FF2.7
0DF36:  BSF    1B.7
0DF38:  BCF    FF2.7
0DF3A:  MOVFF  72A,A1C
0DF3E:  MOVLW  01
0DF40:  MOVLB  A
0DF42:  MOVWF  x1D
0DF44:  MOVLB  0
0DF46:  CALL   0FA6
0DF4A:  BTFSC  1B.7
0DF4C:  BSF    FF2.7
0DF4E:  MOVLW  2F
0DF50:  BTFSS  F9E.4
0DF52:  BRA    DF50
0DF54:  MOVWF  FAD
0DF56:  CLRF   1B
0DF58:  BTFSC  FF2.7
0DF5A:  BSF    1B.7
0DF5C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0DF5E:  MOVFF  729,A1C
0DF62:  MOVLW  01
0DF64:  MOVLB  A
0DF66:  MOVWF  x1D
0DF68:  MOVLB  0
0DF6A:  CALL   0FA6
0DF6E:  BTFSC  1B.7
0DF70:  BSF    FF2.7
0DF72:  MOVLW  2F
0DF74:  BTFSS  F9E.4
0DF76:  BRA    DF74
0DF78:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0DF7A:  DECFSZ 4F,W
0DF7C:  BRA    DFEA
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0DF7E:  MOVLW  A0
0DF80:  MOVWF  FF6
0DF82:  MOVLW  0D
0DF84:  MOVWF  FF7
0DF86:  MOVLW  00
0DF88:  MOVWF  FF8
0DF8A:  CLRF   1B
0DF8C:  BTFSC  FF2.7
0DF8E:  BSF    1B.7
0DF90:  BCF    FF2.7
0DF92:  MOVLW  05
0DF94:  MOVLB  A
0DF96:  MOVWF  x1C
0DF98:  MOVLB  0
0DF9A:  CALL   1024
0DF9E:  BTFSC  1B.7
0DFA0:  BSF    FF2.7
0DFA2:  CLRF   1B
0DFA4:  BTFSC  FF2.7
0DFA6:  BSF    1B.7
0DFA8:  BCF    FF2.7
0DFAA:  MOVFF  729,A1C
0DFAE:  MOVLW  01
0DFB0:  MOVLB  A
0DFB2:  MOVWF  x1D
0DFB4:  MOVLB  0
0DFB6:  CALL   0FA6
0DFBA:  BTFSC  1B.7
0DFBC:  BSF    FF2.7
0DFBE:  MOVLW  2F
0DFC0:  BTFSS  F9E.4
0DFC2:  BRA    DFC0
0DFC4:  MOVWF  FAD
0DFC6:  CLRF   1B
0DFC8:  BTFSC  FF2.7
0DFCA:  BSF    1B.7
0DFCC:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0DFCE:  MOVFF  72A,A1C
0DFD2:  MOVLW  01
0DFD4:  MOVLB  A
0DFD6:  MOVWF  x1D
0DFD8:  MOVLB  0
0DFDA:  CALL   0FA6
0DFDE:  BTFSC  1B.7
0DFE0:  BSF    FF2.7
0DFE2:  MOVLW  2F
0DFE4:  BTFSS  F9E.4
0DFE6:  BRA    DFE4
0DFE8:  MOVWF  FAD
0DFEA:  CLRF   1B
0DFEC:  BTFSC  FF2.7
0DFEE:  BSF    1B.7
0DFF0:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0DFF2:  MOVFF  72B,A1C
0DFF6:  MOVLW  01
0DFF8:  MOVLB  A
0DFFA:  MOVWF  x1D
0DFFC:  MOVLB  0
0DFFE:  CALL   0FA6
0E002:  BTFSC  1B.7
0E004:  BSF    FF2.7
0E006:  MOVLW  20
0E008:  BTFSS  F9E.4
0E00A:  BRA    E008
0E00C:  MOVWF  FAD
0E00E:  CLRF   1B
0E010:  BTFSC  FF2.7
0E012:  BSF    1B.7
0E014:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E016:  MOVFF  727,A1C
0E01A:  MOVLW  01
0E01C:  MOVLB  A
0E01E:  MOVWF  x1D
0E020:  MOVLB  0
0E022:  CALL   0FA6
0E026:  BTFSC  1B.7
0E028:  BSF    FF2.7
0E02A:  MOVLW  3A
0E02C:  BTFSS  F9E.4
0E02E:  BRA    E02C
0E030:  MOVWF  FAD
0E032:  CLRF   1B
0E034:  BTFSC  FF2.7
0E036:  BSF    1B.7
0E038:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E03A:  MOVFF  726,A1C
0E03E:  MOVLW  01
0E040:  MOVLB  A
0E042:  MOVWF  x1D
0E044:  MOVLB  0
0E046:  CALL   0FA6
0E04A:  BTFSC  1B.7
0E04C:  BSF    FF2.7
0E04E:  MOVLW  3A
0E050:  BTFSS  F9E.4
0E052:  BRA    E050
0E054:  MOVWF  FAD
0E056:  CLRF   1B
0E058:  BTFSC  FF2.7
0E05A:  BSF    1B.7
0E05C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E05E:  MOVFF  725,A1C
0E062:  MOVLW  01
0E064:  MOVLB  A
0E066:  MOVWF  x1D
0E068:  MOVLB  0
0E06A:  CALL   0FA6
0E06E:  BTFSC  1B.7
0E070:  BSF    FF2.7
0E072:  MOVLW  0A
0E074:  BTFSS  F9E.4
0E076:  BRA    E074
0E078:  MOVWF  FAD
0E07A:  MOVLW  0D
0E07C:  BTFSS  F9E.4
0E07E:  BRA    E07C
0E080:  MOVWF  FAD
0E082:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
032E0:  MOVLB  8
032E2:  CLRF   xCE
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
032E4:  BCF    FC6.5
032E6:  MOVLW  21
032E8:  MOVWF  FC6
032EA:  MOVLW  40
032EC:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
032EE:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
032F0:  MOVF   FC9,W
032F2:  CLRF   FC9
032F4:  RRCF   FC7,W
032F6:  BNC   32F4
032F8:  MOVFF  FC9,8CE
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
032FC:  MOVF   FC9,W
032FE:  MOVFF  8CE,FC9
03302:  RRCF   FC7,W
03304:  BNC   3302
03306:  MOVFF  FC9,72C
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
0330A:  MOVF   FC9,W
0330C:  MOVFF  8CE,FC9
03310:  RRCF   FC7,W
03312:  BNC   3310
03314:  MOVFF  FC9,725
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
03318:  MOVF   FC9,W
0331A:  MOVFF  8CE,FC9
0331E:  RRCF   FC7,W
03320:  BNC   331E
03322:  MOVFF  FC9,726
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
03326:  MOVF   FC9,W
03328:  MOVFF  8CE,FC9
0332C:  RRCF   FC7,W
0332E:  BNC   332C
03330:  MOVFF  FC9,727
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
03334:  MOVF   FC9,W
03336:  MOVFF  8CE,FC9
0333A:  RRCF   FC7,W
0333C:  BNC   333A
0333E:  MOVFF  FC9,728
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
03342:  MOVF   FC9,W
03344:  MOVFF  8CE,FC9
03348:  RRCF   FC7,W
0334A:  BNC   3348
0334C:  MOVFF  FC9,729
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
03350:  MOVF   FC9,W
03352:  MOVFF  8CE,FC9
03356:  RRCF   FC7,W
03358:  BNC   3356
0335A:  MOVFF  FC9,72A
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
0335E:  MOVF   FC9,W
03360:  MOVFF  8CE,FC9
03364:  RRCF   FC7,W
03366:  BNC   3364
03368:  MOVFF  FC9,72B
....................    output_bit(RTC_CS, DISABLE); 
0336C:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
0336E:  MOVFF  725,8CF
03372:  MOVLB  0
03374:  RCALL  32AE
03376:  MOVFF  01,725
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
0337A:  MOVFF  726,8CF
0337E:  RCALL  32AE
03380:  MOVFF  01,726
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
03384:  MOVFF  727,8CF
03388:  RCALL  32AE
0338A:  MOVFF  01,727
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
0338E:  MOVFF  729,8CF
03392:  RCALL  32AE
03394:  MOVFF  01,729
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
03398:  MOVFF  72A,8CF
0339C:  RCALL  32AE
0339E:  MOVFF  01,72A
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
033A2:  MOVFF  72B,8CF
033A6:  RCALL  32AE
033A8:  MOVFF  01,72B
033AC:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DD8:  MOVLB  A
00DDA:  CLRF   x13
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DDC:  BCF    FC6.5
00DDE:  MOVLW  21
00DE0:  MOVWF  FC6
00DE2:  MOVLW  40
00DE4:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00DE6:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00DE8:  MOVF   FC9,W
00DEA:  MOVLW  0F
00DEC:  MOVWF  FC9
00DEE:  RRCF   FC7,W
00DF0:  BNC   0DEE
00DF2:  MOVFF  FC9,A13
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00DF6:  MOVF   FC9,W
00DF8:  MOVFF  A13,FC9
00DFC:  RRCF   FC7,W
00DFE:  BNC   0DFC
00E00:  MOVFF  FC9,733
....................    spi_read(0x00); 
00E04:  MOVF   FC9,W
00E06:  CLRF   FC9
00E08:  RRCF   FC7,W
00E0A:  BNC   0E08
....................    output_bit(RTC_CS, DISABLE); 
00E0C:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00E0E:  BCF    4D.2
00E10:  MOVLB  0
00E12:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E15A:  MOVF   4F,F
0E15C:  BNZ   E1CA
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E15E:  MOVLW  AC
0E160:  MOVWF  FF6
0E162:  MOVLW  0D
0E164:  MOVWF  FF7
0E166:  MOVLW  00
0E168:  MOVWF  FF8
0E16A:  CLRF   1B
0E16C:  BTFSC  FF2.7
0E16E:  BSF    1B.7
0E170:  BCF    FF2.7
0E172:  MOVLW  05
0E174:  MOVLB  A
0E176:  MOVWF  x1C
0E178:  MOVLB  0
0E17A:  CALL   1024
0E17E:  BTFSC  1B.7
0E180:  BSF    FF2.7
0E182:  CLRF   1B
0E184:  BTFSC  FF2.7
0E186:  BSF    1B.7
0E188:  BCF    FF2.7
0E18A:  MOVFF  72E,A1C
0E18E:  MOVLW  01
0E190:  MOVLB  A
0E192:  MOVWF  x1D
0E194:  MOVLB  0
0E196:  CALL   0FA6
0E19A:  BTFSC  1B.7
0E19C:  BSF    FF2.7
0E19E:  MOVLW  2F
0E1A0:  BTFSS  F9E.4
0E1A2:  BRA    E1A0
0E1A4:  MOVWF  FAD
0E1A6:  CLRF   1B
0E1A8:  BTFSC  FF2.7
0E1AA:  BSF    1B.7
0E1AC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E1AE:  MOVFF  72F,A1C
0E1B2:  MOVLW  01
0E1B4:  MOVLB  A
0E1B6:  MOVWF  x1D
0E1B8:  MOVLB  0
0E1BA:  CALL   0FA6
0E1BE:  BTFSC  1B.7
0E1C0:  BSF    FF2.7
0E1C2:  MOVLW  2F
0E1C4:  BTFSS  F9E.4
0E1C6:  BRA    E1C4
0E1C8:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E1CA:  DECFSZ 4F,W
0E1CC:  BRA    E23A
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E1CE:  MOVLW  B8
0E1D0:  MOVWF  FF6
0E1D2:  MOVLW  0D
0E1D4:  MOVWF  FF7
0E1D6:  MOVLW  00
0E1D8:  MOVWF  FF8
0E1DA:  CLRF   1B
0E1DC:  BTFSC  FF2.7
0E1DE:  BSF    1B.7
0E1E0:  BCF    FF2.7
0E1E2:  MOVLW  05
0E1E4:  MOVLB  A
0E1E6:  MOVWF  x1C
0E1E8:  MOVLB  0
0E1EA:  CALL   1024
0E1EE:  BTFSC  1B.7
0E1F0:  BSF    FF2.7
0E1F2:  CLRF   1B
0E1F4:  BTFSC  FF2.7
0E1F6:  BSF    1B.7
0E1F8:  BCF    FF2.7
0E1FA:  MOVFF  72F,A1C
0E1FE:  MOVLW  01
0E200:  MOVLB  A
0E202:  MOVWF  x1D
0E204:  MOVLB  0
0E206:  CALL   0FA6
0E20A:  BTFSC  1B.7
0E20C:  BSF    FF2.7
0E20E:  MOVLW  2F
0E210:  BTFSS  F9E.4
0E212:  BRA    E210
0E214:  MOVWF  FAD
0E216:  CLRF   1B
0E218:  BTFSC  FF2.7
0E21A:  BSF    1B.7
0E21C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E21E:  MOVFF  72E,A1C
0E222:  MOVLW  01
0E224:  MOVLB  A
0E226:  MOVWF  x1D
0E228:  MOVLB  0
0E22A:  CALL   0FA6
0E22E:  BTFSC  1B.7
0E230:  BSF    FF2.7
0E232:  MOVLW  2F
0E234:  BTFSS  F9E.4
0E236:  BRA    E234
0E238:  MOVWF  FAD
0E23A:  CLRF   1B
0E23C:  BTFSC  FF2.7
0E23E:  BSF    1B.7
0E240:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E242:  MOVFF  72D,A1C
0E246:  MOVLW  01
0E248:  MOVLB  A
0E24A:  MOVWF  x1D
0E24C:  MOVLB  0
0E24E:  CALL   0FA6
0E252:  BTFSC  1B.7
0E254:  BSF    FF2.7
0E256:  MOVLW  20
0E258:  BTFSS  F9E.4
0E25A:  BRA    E258
0E25C:  MOVWF  FAD
0E25E:  CLRF   1B
0E260:  BTFSC  FF2.7
0E262:  BSF    1B.7
0E264:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E266:  MOVFF  730,A1C
0E26A:  MOVLW  01
0E26C:  MOVLB  A
0E26E:  MOVWF  x1D
0E270:  MOVLB  0
0E272:  CALL   0FA6
0E276:  BTFSC  1B.7
0E278:  BSF    FF2.7
0E27A:  MOVLW  3A
0E27C:  BTFSS  F9E.4
0E27E:  BRA    E27C
0E280:  MOVWF  FAD
0E282:  CLRF   1B
0E284:  BTFSC  FF2.7
0E286:  BSF    1B.7
0E288:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E28A:  MOVFF  731,A1C
0E28E:  MOVLW  01
0E290:  MOVLB  A
0E292:  MOVWF  x1D
0E294:  MOVLB  0
0E296:  CALL   0FA6
0E29A:  BTFSC  1B.7
0E29C:  BSF    FF2.7
0E29E:  MOVLW  3A
0E2A0:  BTFSS  F9E.4
0E2A2:  BRA    E2A0
0E2A4:  MOVWF  FAD
0E2A6:  CLRF   1B
0E2A8:  BTFSC  FF2.7
0E2AA:  BSF    1B.7
0E2AC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E2AE:  MOVFF  732,A1C
0E2B2:  MOVLW  01
0E2B4:  MOVLB  A
0E2B6:  MOVWF  x1D
0E2B8:  MOVLB  0
0E2BA:  CALL   0FA6
0E2BE:  BTFSC  1B.7
0E2C0:  BSF    FF2.7
0E2C2:  MOVLW  0A
0E2C4:  BTFSS  F9E.4
0E2C6:  BRA    E2C4
0E2C8:  MOVWF  FAD
0E2CA:  MOVLW  0D
0E2CC:  BTFSS  F9E.4
0E2CE:  BRA    E2CC
0E2D0:  MOVWF  FAD
0E2D2:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E084:  MOVLB  8
0E086:  CLRF   x98
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E088:  BCF    FC6.5
0E08A:  MOVLW  21
0E08C:  MOVWF  FC6
0E08E:  MOVLW  40
0E090:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E092:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E094:  MOVF   FC9,W
0E096:  MOVLW  0A
0E098:  MOVWF  FC9
0E09A:  RRCF   FC7,W
0E09C:  BNC   E09A
0E09E:  MOVFF  FC9,898
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E0A2:  MOVF   FC9,W
0E0A4:  MOVFF  898,FC9
0E0A8:  RRCF   FC7,W
0E0AA:  BNC   E0A8
0E0AC:  MOVFF  FC9,72E
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E0B0:  MOVF   FC9,W
0E0B2:  MOVFF  898,FC9
0E0B6:  RRCF   FC7,W
0E0B8:  BNC   E0B6
0E0BA:  MOVFF  FC9,72F
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E0BE:  MOVF   FC9,W
0E0C0:  MOVFF  898,FC9
0E0C4:  RRCF   FC7,W
0E0C6:  BNC   E0C4
0E0C8:  MOVFF  FC9,730
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E0CC:  MOVF   FC9,W
0E0CE:  MOVFF  898,FC9
0E0D2:  RRCF   FC7,W
0E0D4:  BNC   E0D2
0E0D6:  MOVFF  FC9,731
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E0DA:  MOVF   FC9,W
0E0DC:  MOVFF  898,FC9
0E0E0:  RRCF   FC7,W
0E0E2:  BNC   E0E0
0E0E4:  MOVFF  FC9,732
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E0E8:  MOVF   FC9,W
0E0EA:  MOVFF  898,FC9
0E0EE:  RRCF   FC7,W
0E0F0:  BNC   E0EE
0E0F2:  MOVFF  FC9,733
....................    output_bit(RTC_CS, DISABLE); 
0E0F6:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E0F8:  MOVLW  1F
0E0FA:  MOVLB  7
0E0FC:  ANDWF  x2E,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E0FE:  MOVFF  72E,8CF
0E102:  MOVLB  0
0E104:  CALL   32AE
0E108:  MOVFF  01,72E
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E10C:  MOVLW  3F
0E10E:  MOVLB  7
0E110:  ANDWF  x2F,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E112:  MOVFF  72F,8CF
0E116:  MOVLB  0
0E118:  CALL   32AE
0E11C:  MOVFF  01,72F
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E120:  MOVLW  3F
0E122:  MOVLB  7
0E124:  ANDWF  x30,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E126:  MOVFF  730,8CF
0E12A:  MOVLB  0
0E12C:  CALL   32AE
0E130:  MOVFF  01,730
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E134:  MOVLB  7
0E136:  BCF    x31.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E138:  MOVFF  731,8CF
0E13C:  MOVLB  0
0E13E:  CALL   32AE
0E142:  MOVFF  01,731
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E146:  MOVLB  7
0E148:  BCF    x32.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E14A:  MOVFF  732,8CF
0E14E:  MOVLB  0
0E150:  CALL   32AE
0E154:  MOVFF  01,732
0E158:  RETURN 0
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
172DC:  MOVLW  08
172DE:  MOVWF  FEA
172E0:  MOVLW  6A
172E2:  MOVWF  FE9
172E4:  CLRF   00
172E6:  CLRF   02
172E8:  MOVLW  0C
172EA:  MOVWF  01
172EC:  CALL   34C2
....................  
....................    time_error = 0; 
172F0:  MOVLB  8
172F2:  CLRF   x76
....................     
....................    fputc('[', COM_A); 
172F4:  MOVLW  5B
172F6:  MOVLB  0
172F8:  CALL   ADD8
....................     
....................    for (n=0; n<12; ++n){ 
172FC:  MOVLB  8
172FE:  CLRF   x69
17300:  MOVF   x69,W
17302:  SUBLW  0B
17304:  BNC   1734A
....................       c = fgetc(COM_A); 
17306:  MOVLB  0
17308:  CALL   0E38
1730C:  MOVFF  01,868
....................       if (com_echo == TRUE) 
17310:  DECFSZ 4C,W
17312:  BRA    1731E
....................       { 
....................          fputc(c, COM_A); 
17314:  MOVLB  8
17316:  MOVF   x68,W
17318:  MOVLB  0
1731A:  CALL   ADD8
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
1731E:  MOVLB  8
17320:  MOVF   x68,W
17322:  SUBLW  2F
17324:  BC    17340
17326:  MOVF   x68,W
17328:  SUBLW  39
1732A:  BNC   17340
1732C:  CLRF   03
1732E:  MOVF   x69,W
17330:  ADDLW  6A
17332:  MOVWF  FE9
17334:  MOVLW  08
17336:  ADDWFC 03,W
17338:  MOVWF  FEA
1733A:  MOVFF  868,FEF
1733E:  BRA    17346
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
17340:  MOVLW  01
17342:  MOVWF  x76
....................          break; 
17344:  BRA    1734A
....................       } 
17346:  INCF   x69,F
17348:  BRA    17300
....................    } 
....................     
....................    if (time_error == 0){ 
1734A:  MOVF   x76,F
1734C:  BTFSS  FD8.2
1734E:  BRA    17686
....................     
....................       fputc(']', COM_A); 
17350:  MOVLW  5D
17352:  MOVLB  0
17354:  CALL   ADD8
....................        
....................       for (n=0; n<12; ++n){ 
17358:  MOVLB  8
1735A:  CLRF   x69
1735C:  MOVF   x69,W
1735E:  SUBLW  0B
17360:  BNC   17392
....................          t_entry[n] = (t_entry[n] - 48); 
17362:  CLRF   03
17364:  MOVF   x69,W
17366:  ADDLW  6A
17368:  MOVWF  01
1736A:  MOVLW  08
1736C:  ADDWFC 03,F
1736E:  MOVFF  03,878
17372:  CLRF   03
17374:  MOVF   x69,W
17376:  ADDLW  6A
17378:  MOVWF  FE9
1737A:  MOVLW  08
1737C:  ADDWFC 03,W
1737E:  MOVWF  FEA
17380:  MOVLW  30
17382:  SUBWF  FEF,W
17384:  MOVFF  878,FEA
17388:  MOVFF  01,FE9
1738C:  MOVWF  FEF
1738E:  INCF   x69,F
17390:  BRA    1735C
....................       } 
....................        
....................       if (RTCfmt == 0) 
17392:  MOVF   4F,F
17394:  BNZ   173D2
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
17396:  MOVF   x6A,W
17398:  MULLW  0A
1739A:  MOVF   FF3,W
1739C:  ADDWF  x6B,W
1739E:  MOVLB  7
173A0:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
173A2:  MOVF   x38,F
173A4:  BZ    173AC
173A6:  MOVF   x38,W
173A8:  SUBLW  0C
173AA:  BC    173B4
173AC:  MOVLW  02
173AE:  MOVLB  8
173B0:  MOVWF  x76
173B2:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
173B4:  MOVLB  8
173B6:  MOVF   x6C,W
173B8:  MULLW  0A
173BA:  MOVF   FF3,W
173BC:  ADDWF  x6D,W
173BE:  MOVLB  7
173C0:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
173C2:  MOVF   x37,F
173C4:  BZ    173CC
173C6:  MOVF   x37,W
173C8:  SUBLW  1F
173CA:  BC    173D4
173CC:  MOVLW  02
173CE:  MOVLB  8
173D0:  MOVWF  x76
173D2:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
173D4:  DECFSZ 4F,W
173D6:  BRA    17418
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
173D8:  MOVLB  8
173DA:  MOVF   x6A,W
173DC:  MULLW  0A
173DE:  MOVF   FF3,W
173E0:  ADDWF  x6B,W
173E2:  MOVLB  7
173E4:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
173E6:  MOVF   x37,F
173E8:  BZ    173F0
173EA:  MOVF   x37,W
173EC:  SUBLW  1F
173EE:  BC    173F8
173F0:  MOVLW  02
173F2:  MOVLB  8
173F4:  MOVWF  x76
173F6:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
173F8:  MOVLB  8
173FA:  MOVF   x6C,W
173FC:  MULLW  0A
173FE:  MOVF   FF3,W
17400:  ADDWF  x6D,W
17402:  MOVLB  7
17404:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17406:  MOVF   x38,F
17408:  BZ    17410
1740A:  MOVF   x38,W
1740C:  SUBLW  0C
1740E:  BC    17418
17410:  MOVLW  02
17412:  MOVLB  8
17414:  MOVWF  x76
17416:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
17418:  MOVLB  8
1741A:  MOVF   x6E,W
1741C:  MULLW  0A
1741E:  MOVF   FF3,W
17420:  ADDWF  x6F,W
17422:  MOVLB  7
17424:  MOVWF  x39
....................       if (RTC_Yr_Data > 99) time_error = 2;  
17426:  MOVF   x39,W
17428:  SUBLW  63
1742A:  BC    17434
1742C:  MOVLW  02
1742E:  MOVLB  8
17430:  MOVWF  x76
17432:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
17434:  MOVLB  8
17436:  MOVF   x70,W
17438:  MULLW  0A
1743A:  MOVF   FF3,W
1743C:  ADDWF  x71,W
1743E:  MOVLB  7
17440:  MOVWF  x36
....................       if (RTC_Hr_Data > 24) time_error = 2;  
17442:  MOVF   x36,W
17444:  SUBLW  18
17446:  BC    17450
17448:  MOVLW  02
1744A:  MOVLB  8
1744C:  MOVWF  x76
1744E:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
17450:  MOVLB  8
17452:  MOVF   x72,W
17454:  MULLW  0A
17456:  MOVF   FF3,W
17458:  ADDWF  x73,W
1745A:  MOVLB  7
1745C:  MOVWF  x35
....................       if (RTC_Min_Data > 60) time_error = 2;  
1745E:  MOVF   x35,W
17460:  SUBLW  3C
17462:  BC    1746C
17464:  MOVLW  02
17466:  MOVLB  8
17468:  MOVWF  x76
1746A:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
1746C:  MOVLB  8
1746E:  MOVF   x74,W
17470:  MULLW  0A
17472:  MOVF   FF3,W
17474:  ADDWF  x75,W
17476:  MOVLB  7
17478:  MOVWF  x34
....................       if (RTC_Sec_Data > 60) time_error = 2; 
1747A:  MOVF   x34,W
1747C:  SUBLW  3C
1747E:  BC    17488
17480:  MOVLW  02
17482:  MOVLB  8
17484:  MOVWF  x76
17486:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
17488:  MOVF   4F,F
1748A:  BTFSS  FD8.2
1748C:  BRA    17580
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
1748E:  MOVLW  0A
17490:  BTFSS  F9E.4
17492:  BRA    17490
17494:  MOVWF  FAD
17496:  MOVLW  0D
17498:  BTFSS  F9E.4
1749A:  BRA    17498
1749C:  MOVWF  FAD
1749E:  CLRF   1B
174A0:  BTFSC  FF2.7
174A2:  BSF    1B.7
174A4:  BCF    FF2.7
174A6:  MOVFF  738,A1C
174AA:  MOVLW  01
174AC:  MOVLB  A
174AE:  MOVWF  x1D
174B0:  MOVLB  0
174B2:  CALL   0FA6
174B6:  BTFSC  1B.7
174B8:  BSF    FF2.7
174BA:  MOVLW  2F
174BC:  BTFSS  F9E.4
174BE:  BRA    174BC
174C0:  MOVWF  FAD
174C2:  CLRF   1B
174C4:  BTFSC  FF2.7
174C6:  BSF    1B.7
174C8:  BCF    FF2.7
174CA:  MOVFF  737,A1C
174CE:  MOVLW  01
174D0:  MOVLB  A
174D2:  MOVWF  x1D
174D4:  MOVLB  0
174D6:  CALL   0FA6
174DA:  BTFSC  1B.7
174DC:  BSF    FF2.7
174DE:  MOVLW  2F
174E0:  BTFSS  F9E.4
174E2:  BRA    174E0
174E4:  MOVWF  FAD
174E6:  CLRF   1B
174E8:  BTFSC  FF2.7
174EA:  BSF    1B.7
174EC:  BCF    FF2.7
174EE:  MOVFF  739,A1C
174F2:  MOVLW  01
174F4:  MOVLB  A
174F6:  MOVWF  x1D
174F8:  MOVLB  0
174FA:  CALL   0FA6
174FE:  BTFSC  1B.7
17500:  BSF    FF2.7
17502:  MOVLW  20
17504:  BTFSS  F9E.4
17506:  BRA    17504
17508:  MOVWF  FAD
1750A:  CLRF   1B
1750C:  BTFSC  FF2.7
1750E:  BSF    1B.7
17510:  BCF    FF2.7
17512:  MOVFF  736,A1C
17516:  MOVLW  01
17518:  MOVLB  A
1751A:  MOVWF  x1D
1751C:  MOVLB  0
1751E:  CALL   0FA6
17522:  BTFSC  1B.7
17524:  BSF    FF2.7
17526:  MOVLW  3A
17528:  BTFSS  F9E.4
1752A:  BRA    17528
1752C:  MOVWF  FAD
1752E:  CLRF   1B
17530:  BTFSC  FF2.7
17532:  BSF    1B.7
17534:  BCF    FF2.7
17536:  MOVFF  735,A1C
1753A:  MOVLW  01
1753C:  MOVLB  A
1753E:  MOVWF  x1D
17540:  MOVLB  0
17542:  CALL   0FA6
17546:  BTFSC  1B.7
17548:  BSF    FF2.7
1754A:  MOVLW  3A
1754C:  BTFSS  F9E.4
1754E:  BRA    1754C
17550:  MOVWF  FAD
17552:  CLRF   1B
17554:  BTFSC  FF2.7
17556:  BSF    1B.7
17558:  BCF    FF2.7
1755A:  MOVFF  734,A1C
1755E:  MOVLW  01
17560:  MOVLB  A
17562:  MOVWF  x1D
17564:  MOVLB  0
17566:  CALL   0FA6
1756A:  BTFSC  1B.7
1756C:  BSF    FF2.7
1756E:  MOVLW  0A
17570:  BTFSS  F9E.4
17572:  BRA    17570
17574:  MOVWF  FAD
17576:  MOVLW  0D
17578:  BTFSS  F9E.4
1757A:  BRA    17578
1757C:  MOVWF  FAD
1757E:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17580:  DECFSZ 4F,W
17582:  BRA    17676
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
17584:  MOVLW  0A
17586:  BTFSS  F9E.4
17588:  BRA    17586
1758A:  MOVWF  FAD
1758C:  MOVLW  0D
1758E:  BTFSS  F9E.4
17590:  BRA    1758E
17592:  MOVWF  FAD
17594:  CLRF   1B
17596:  BTFSC  FF2.7
17598:  BSF    1B.7
1759A:  BCF    FF2.7
1759C:  MOVFF  737,A1C
175A0:  MOVLW  01
175A2:  MOVLB  A
175A4:  MOVWF  x1D
175A6:  MOVLB  0
175A8:  CALL   0FA6
175AC:  BTFSC  1B.7
175AE:  BSF    FF2.7
175B0:  MOVLW  2F
175B2:  BTFSS  F9E.4
175B4:  BRA    175B2
175B6:  MOVWF  FAD
175B8:  CLRF   1B
175BA:  BTFSC  FF2.7
175BC:  BSF    1B.7
175BE:  BCF    FF2.7
175C0:  MOVFF  738,A1C
175C4:  MOVLW  01
175C6:  MOVLB  A
175C8:  MOVWF  x1D
175CA:  MOVLB  0
175CC:  CALL   0FA6
175D0:  BTFSC  1B.7
175D2:  BSF    FF2.7
175D4:  MOVLW  2F
175D6:  BTFSS  F9E.4
175D8:  BRA    175D6
175DA:  MOVWF  FAD
175DC:  CLRF   1B
175DE:  BTFSC  FF2.7
175E0:  BSF    1B.7
175E2:  BCF    FF2.7
175E4:  MOVFF  739,A1C
175E8:  MOVLW  01
175EA:  MOVLB  A
175EC:  MOVWF  x1D
175EE:  MOVLB  0
175F0:  CALL   0FA6
175F4:  BTFSC  1B.7
175F6:  BSF    FF2.7
175F8:  MOVLW  20
175FA:  BTFSS  F9E.4
175FC:  BRA    175FA
175FE:  MOVWF  FAD
17600:  CLRF   1B
17602:  BTFSC  FF2.7
17604:  BSF    1B.7
17606:  BCF    FF2.7
17608:  MOVFF  736,A1C
1760C:  MOVLW  01
1760E:  MOVLB  A
17610:  MOVWF  x1D
17612:  MOVLB  0
17614:  CALL   0FA6
17618:  BTFSC  1B.7
1761A:  BSF    FF2.7
1761C:  MOVLW  3A
1761E:  BTFSS  F9E.4
17620:  BRA    1761E
17622:  MOVWF  FAD
17624:  CLRF   1B
17626:  BTFSC  FF2.7
17628:  BSF    1B.7
1762A:  BCF    FF2.7
1762C:  MOVFF  735,A1C
17630:  MOVLW  01
17632:  MOVLB  A
17634:  MOVWF  x1D
17636:  MOVLB  0
17638:  CALL   0FA6
1763C:  BTFSC  1B.7
1763E:  BSF    FF2.7
17640:  MOVLW  3A
17642:  BTFSS  F9E.4
17644:  BRA    17642
17646:  MOVWF  FAD
17648:  CLRF   1B
1764A:  BTFSC  FF2.7
1764C:  BSF    1B.7
1764E:  BCF    FF2.7
17650:  MOVFF  734,A1C
17654:  MOVLW  01
17656:  MOVLB  A
17658:  MOVWF  x1D
1765A:  MOVLB  0
1765C:  CALL   0FA6
17660:  BTFSC  1B.7
17662:  BSF    FF2.7
17664:  MOVLW  0A
17666:  BTFSS  F9E.4
17668:  BRA    17666
1766A:  MOVWF  FAD
1766C:  MOVLW  0D
1766E:  BTFSS  F9E.4
17670:  BRA    1766E
17672:  MOVWF  FAD
17674:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
17676:  MOVLB  8
17678:  MOVF   x76,W
1767A:  SUBLW  02
1767C:  BNZ   17684
1767E:  MOVLB  0
17680:  BRA    172BC
17682:  MOVLB  8
....................  
....................    } 
17684:  BRA    1768E
....................    else cmd_arg(); 
17686:  MOVLB  0
17688:  CALL   AF88
1768C:  MOVLB  8
....................     
....................    return time_error; 
1768E:  MOVFF  876,01
17692:  MOVLB  0
17694:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
176D4:  RCALL  172DC
176D6:  MOVFF  01,866
....................     
....................    if (time_error ==0 ){ 
176DA:  MOVLB  8
176DC:  MOVF   x66,F
176DE:  BTFSS  FD8.2
176E0:  BRA    17818
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
176E2:  BCF    FC6.5
176E4:  MOVLW  21
176E6:  MOVWF  FC6
176E8:  MOVLW  40
176EA:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
176EC:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
176EE:  MOVF   FC9,W
176F0:  MOVLW  86
176F2:  MOVWF  FC9
176F4:  RRCF   FC7,W
176F6:  BNC   176F4
176F8:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
176FC:  MOVFF  738,868
17700:  MOVLB  0
17702:  RCALL  17696
17704:  MOVFF  01,868
17708:  MOVF   FC9,W
1770A:  MOVFF  01,FC9
1770E:  RRCF   FC7,W
17710:  BNC   1770E
17712:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
17716:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17718:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
1771A:  MOVF   FC9,W
1771C:  MOVLW  85
1771E:  MOVWF  FC9
17720:  RRCF   FC7,W
17722:  BNC   17720
17724:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
17728:  MOVFF  737,868
1772C:  RCALL  17696
1772E:  MOVFF  01,868
17732:  MOVF   FC9,W
17734:  MOVFF  01,FC9
17738:  RRCF   FC7,W
1773A:  BNC   17738
1773C:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
17740:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17742:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
17744:  MOVF   FC9,W
17746:  MOVLW  87
17748:  MOVWF  FC9
1774A:  RRCF   FC7,W
1774C:  BNC   1774A
1774E:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
17752:  MOVFF  739,868
17756:  RCALL  17696
17758:  MOVFF  01,868
1775C:  MOVF   FC9,W
1775E:  MOVFF  01,FC9
17762:  RRCF   FC7,W
17764:  BNC   17762
17766:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
1776A:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
1776C:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
1776E:  MOVF   FC9,W
17770:  MOVLW  83
17772:  MOVWF  FC9
17774:  RRCF   FC7,W
17776:  BNC   17774
17778:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
1777C:  MOVFF  736,868
17780:  RCALL  17696
17782:  MOVFF  01,868
17786:  MOVF   FC9,W
17788:  MOVFF  01,FC9
1778C:  RRCF   FC7,W
1778E:  BNC   1778C
17790:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
17794:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17796:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
17798:  MOVF   FC9,W
1779A:  MOVLW  82
1779C:  MOVWF  FC9
1779E:  RRCF   FC7,W
177A0:  BNC   1779E
177A2:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
177A6:  MOVFF  735,868
177AA:  RCALL  17696
177AC:  MOVFF  01,868
177B0:  MOVF   FC9,W
177B2:  MOVFF  01,FC9
177B6:  RRCF   FC7,W
177B8:  BNC   177B6
177BA:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
177BE:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
177C0:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
177C2:  MOVF   FC9,W
177C4:  MOVLW  81
177C6:  MOVWF  FC9
177C8:  RRCF   FC7,W
177CA:  BNC   177C8
177CC:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
177D0:  MOVFF  734,868
177D4:  RCALL  17696
177D6:  MOVFF  01,868
177DA:  MOVF   FC9,W
177DC:  MOVFF  01,FC9
177E0:  RRCF   FC7,W
177E2:  BNC   177E0
177E4:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
177E8:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
177EA:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
177EC:  MOVF   FC9,W
177EE:  MOVLW  80
177F0:  MOVWF  FC9
177F2:  RRCF   FC7,W
177F4:  BNC   177F2
177F6:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
177FA:  MOVLB  8
177FC:  CLRF   x68
177FE:  MOVLB  0
17800:  RCALL  17696
17802:  MOVFF  01,868
17806:  MOVF   FC9,W
17808:  MOVFF  01,FC9
1780C:  RRCF   FC7,W
1780E:  BNC   1780C
17810:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
17814:  BSF    F91.0
17816:  MOVLB  8
....................    } 
17818:  MOVLB  0
1781A:  GOTO   178A6 (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
1847E:  CALL   E084
....................     
....................    time_error = get_time(); 
18482:  CALL   172DC
18486:  MOVFF  01,866
....................     
....................    if (time_error == 0 ){ 
1848A:  MOVLB  8
1848C:  MOVF   x66,F
1848E:  BTFSS  FD8.2
18490:  BRA    18608
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
18492:  MOVFF  739,72D
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
18496:  MOVLW  04
18498:  MOVWF  x6A
1849A:  MOVFF  72D,86B
1849E:  MOVLB  0
184A0:  CALL   33AE
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
184A4:  MOVFF  738,868
184A8:  CALL   17696
184AC:  MOVFF  01,738
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
184B0:  MOVLB  7
184B2:  BSF    x38.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
184B4:  BCF    FC6.5
184B6:  MOVLW  21
184B8:  MOVWF  FC6
184BA:  MOVLW  40
184BC:  MOVWF  FC7
....................       delay_us(10); 
184BE:  MOVLW  35
184C0:  MOVWF  00
184C2:  DECFSZ 00,F
184C4:  BRA    184C2
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
184C6:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
184C8:  MOVF   FC9,W
184CA:  MOVLW  8E
184CC:  MOVWF  FC9
184CE:  RRCF   FC7,W
184D0:  BNC   184CE
184D2:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
184D6:  MOVFF  734,868
184DA:  MOVLB  0
184DC:  CALL   17696
184E0:  MOVFF  01,868
184E4:  MOVF   FC9,W
184E6:  MOVFF  01,FC9
184EA:  RRCF   FC7,W
184EC:  BNC   184EA
184EE:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
184F2:  BSF    F91.0
....................       delay_us(1); // Delays added 1.020A 
184F4:  MOVLW  05
184F6:  MOVWF  00
184F8:  DECFSZ 00,F
184FA:  BRA    184F8
....................        
....................       output_bit(RTC_CS, ENABLE); 
184FC:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
184FE:  MOVF   FC9,W
18500:  MOVLW  8D
18502:  MOVWF  FC9
18504:  RRCF   FC7,W
18506:  BNC   18504
18508:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
1850C:  MOVFF  735,868
18510:  CALL   17696
18514:  MOVFF  01,868
18518:  MOVF   FC9,W
1851A:  MOVFF  01,FC9
1851E:  RRCF   FC7,W
18520:  BNC   1851E
18522:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
18526:  BSF    F91.0
....................       delay_us(1); 
18528:  MOVLW  05
1852A:  MOVWF  00
1852C:  DECFSZ 00,F
1852E:  BRA    1852C
....................        
....................       output_bit(RTC_CS, ENABLE); 
18530:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
18532:  MOVF   FC9,W
18534:  MOVLW  8C
18536:  MOVWF  FC9
18538:  RRCF   FC7,W
1853A:  BNC   18538
1853C:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
18540:  MOVFF  736,868
18544:  CALL   17696
18548:  MOVFF  01,868
1854C:  MOVF   FC9,W
1854E:  MOVFF  01,FC9
18552:  RRCF   FC7,W
18554:  BNC   18552
18556:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
1855A:  BSF    F91.0
....................       delay_us(1);  
1855C:  MOVLW  05
1855E:  MOVWF  00
18560:  DECFSZ 00,F
18562:  BRA    18560
....................        
....................       output_bit(RTC_CS, ENABLE); 
18564:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
18566:  MOVF   FC9,W
18568:  MOVLW  8B
1856A:  MOVWF  FC9
1856C:  RRCF   FC7,W
1856E:  BNC   1856C
18570:  MOVFF  FC9,867
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
18574:  MOVFF  737,868
18578:  CALL   17696
1857C:  MOVFF  01,868
18580:  MOVF   FC9,W
18582:  MOVFF  01,FC9
18586:  RRCF   FC7,W
18588:  BNC   18586
1858A:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE);  
1858E:  BSF    F91.0
....................       delay_us(1); 
18590:  MOVLW  05
18592:  MOVWF  00
18594:  DECFSZ 00,F
18596:  BRA    18594
....................        
....................       output_bit(RTC_CS, ENABLE); 
18598:  BCF    F91.0
....................       //fprintf(COM_A,"test61\r\n"); 
....................       RTC_buffer = spi_read(0x8A);// address - Month 
1859A:  MOVF   FC9,W
1859C:  MOVLW  8A
1859E:  MOVWF  FC9
185A0:  RRCF   FC7,W
185A2:  BNC   185A0
185A4:  MOVFF  FC9,867
....................       //fprintf(COM_A,"test62\r\n"); 
....................       fprintf(COM_A,"test6: %d\r\n",RTC_Mon_Data); 
185A8:  MOVLW  C4
185AA:  MOVWF  FF6
185AC:  MOVLW  0D
185AE:  MOVWF  FF7
185B0:  MOVLW  00
185B2:  MOVWF  FF8
185B4:  CLRF   1B
185B6:  BTFSC  FF2.7
185B8:  BSF    1B.7
185BA:  BCF    FF2.7
185BC:  MOVLW  07
185BE:  MOVLB  A
185C0:  MOVWF  x1C
185C2:  MOVLB  0
185C4:  CALL   1024
185C8:  BTFSC  1B.7
185CA:  BSF    FF2.7
185CC:  MOVFF  738,868
185D0:  MOVLW  18
185D2:  MOVLB  8
185D4:  MOVWF  x69
185D6:  MOVLB  0
185D8:  BRA    1839E
185DA:  MOVLW  0D
185DC:  BTFSS  F9E.4
185DE:  BRA    185DC
185E0:  MOVWF  FAD
185E2:  MOVLW  0A
185E4:  BTFSS  F9E.4
185E6:  BRA    185E4
185E8:  MOVWF  FAD
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
185EA:  MOVF   FC9,W
185EC:  MOVFF  738,FC9
185F0:  RRCF   FC7,W
185F2:  BNC   185F0
185F4:  MOVFF  FC9,867
....................       output_bit(RTC_CS, DISABLE); 
185F8:  BSF    F91.0
....................       delay_us(1); 
185FA:  MOVLW  05
185FC:  MOVWF  00
185FE:  DECFSZ 00,F
18600:  BRA    185FE
....................       //fprintf(COM_A,"test6\r\n"); 
....................     
....................    RTC_read_alarm(); 
18602:  CALL   E084
18606:  MOVLB  8
....................    } 
18608:  MOVLB  0
1860A:  GOTO   18620 (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
15A6C:  BCF    FC6.5
15A6E:  MOVLW  21
15A70:  MOVWF  FC6
15A72:  MOVLW  40
15A74:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
15A76:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
15A78:  MOVF   FC9,W
15A7A:  MOVLW  8E
15A7C:  MOVWF  FC9
15A7E:  RRCF   FC7,W
15A80:  BNC   15A7E
15A82:  MOVFF  FC9,868
....................    RTC_buffer = spi_read(0b00000000);  // data 
15A86:  MOVF   FC9,W
15A88:  CLRF   FC9
15A8A:  RRCF   FC7,W
15A8C:  BNC   15A8A
15A8E:  MOVFF  FC9,868
....................    output_bit(RTC_CS, DISABLE); 
15A92:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A94:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15A96:  MOVF   FC9,W
15A98:  MOVLW  8D
15A9A:  MOVWF  FC9
15A9C:  RRCF   FC7,W
15A9E:  BNC   15A9C
15AA0:  MOVFF  FC9,868
....................    RTC_buffer = spi_read(0b10000000);  // data 
15AA4:  MOVF   FC9,W
15AA6:  MOVLW  80
15AA8:  MOVWF  FC9
15AAA:  RRCF   FC7,W
15AAC:  BNC   15AAA
15AAE:  MOVFF  FC9,868
....................    output_bit(RTC_CS, DISABLE); 
15AB2:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15AB4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15AB6:  MOVF   FC9,W
15AB8:  MOVLW  8C
15ABA:  MOVWF  FC9
15ABC:  RRCF   FC7,W
15ABE:  BNC   15ABC
15AC0:  MOVFF  FC9,868
....................    RTC_buffer = spi_read(0b10000000);  // data 
15AC4:  MOVF   FC9,W
15AC6:  MOVLW  80
15AC8:  MOVWF  FC9
15ACA:  RRCF   FC7,W
15ACC:  BNC   15ACA
15ACE:  MOVFF  FC9,868
....................    output_bit(RTC_CS, DISABLE); 
15AD2:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15AD4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15AD6:  MOVF   FC9,W
15AD8:  MOVLW  8B
15ADA:  MOVWF  FC9
15ADC:  RRCF   FC7,W
15ADE:  BNC   15ADC
15AE0:  MOVFF  FC9,868
....................    RTC_buffer = spi_read(0b11000000);  // data 
15AE4:  MOVF   FC9,W
15AE6:  MOVLW  C0
15AE8:  MOVWF  FC9
15AEA:  RRCF   FC7,W
15AEC:  BNC   15AEA
15AEE:  MOVFF  FC9,868
....................    output_bit(RTC_CS, DISABLE);    
15AF2:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15AF4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15AF6:  MOVF   FC9,W
15AF8:  MOVLW  8A
15AFA:  MOVWF  FC9
15AFC:  RRCF   FC7,W
15AFE:  BNC   15AFC
15B00:  MOVFF  FC9,868
....................    RTC_buffer = spi_read(0b10000000);  // data 
15B04:  MOVF   FC9,W
15B06:  MOVLW  80
15B08:  MOVWF  FC9
15B0A:  RRCF   FC7,W
15B0C:  BNC   15B0A
15B0E:  MOVFF  FC9,868
....................    output_bit(RTC_CS, DISABLE); 
15B12:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15B14:  CALL   E084
15B18:  GOTO   168D8 (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
152B6:  MOVLB  8
152B8:  CLRF   x68
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
152BA:  BCF    FC6.5
152BC:  MOVLW  21
152BE:  MOVWF  FC6
152C0:  MOVLW  40
152C2:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
152C4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
152C6:  MOVF   FC9,W
152C8:  MOVLW  0A
152CA:  MOVWF  FC9
152CC:  RRCF   FC7,W
152CE:  BNC   152CC
152D0:  MOVFF  FC9,868
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
152D4:  MOVF   FC9,W
152D6:  MOVFF  868,FC9
152DA:  RRCF   FC7,W
152DC:  BNC   152DA
152DE:  MOVFF  FC9,72E
....................    output_bit(RTC_CS, DISABLE); 
152E2:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
152E4:  MOVLB  7
152E6:  BSF    x2E.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
152E8:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
152EA:  MOVF   FC9,W
152EC:  MOVLW  8A
152EE:  MOVWF  FC9
152F0:  RRCF   FC7,W
152F2:  BNC   152F0
152F4:  MOVFF  FC9,868
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
152F8:  MOVF   FC9,W
152FA:  MOVFF  72E,FC9
152FE:  RRCF   FC7,W
15300:  BNC   152FE
15302:  MOVFF  FC9,868
....................    output_bit(RTC_CS, DISABLE); 
15306:  BSF    F91.0
15308:  MOVLB  0
1530A:  GOTO   16802 (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
033DE:  MOVFF  725,73F
....................    rtc_last_min   = RTC_Min_Reg; 
033E2:  MOVFF  726,73E
....................    rtc_last_hour  = RTC_Hr_Reg; 
033E6:  MOVFF  727,73D
....................    rtc_last_day   = RTC_DOM_Reg; 
033EA:  MOVFF  729,73B
....................    rtc_last_month = RTC_Mon_Reg; 
033EE:  MOVFF  72A,73A
....................    rtc_last_year  = RTC_Yr_Reg; 
033F2:  MOVFF  72B,73C
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
033F6:  MOVLW  06
033F8:  MOVLB  8
033FA:  MOVWF  x6A
033FC:  MOVFF  73A,86B
03400:  MOVLB  0
03402:  RCALL  33AE
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
03404:  MOVLW  08
03406:  MOVLB  8
03408:  MOVWF  x6A
0340A:  MOVFF  73B,86B
0340E:  MOVLB  0
03410:  RCALL  33AE
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
03412:  MOVLW  0A
03414:  MOVLB  8
03416:  MOVWF  x6A
03418:  MOVFF  73C,86B
0341C:  MOVLB  0
0341E:  RCALL  33AE
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
03420:  MOVLW  0C
03422:  MOVLB  8
03424:  MOVWF  x6A
03426:  MOVFF  73D,86B
0342A:  MOVLB  0
0342C:  RCALL  33AE
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
0342E:  MOVLW  0E
03430:  MOVLB  8
03432:  MOVWF  x6A
03434:  MOVFF  73E,86B
03438:  MOVLB  0
0343A:  RCALL  33AE
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
0343C:  MOVLW  10
0343E:  MOVLB  8
03440:  MOVWF  x6A
03442:  MOVFF  73F,86B
03446:  MOVLB  0
03448:  RCALL  33AE
0344A:  GOTO   1B4EE (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
1530E:  MOVLB  8
15310:  CLRF   x6B
15312:  CLRF   x6A
15314:  CLRF   x69
15316:  CLRF   x68
15318:  CLRF   x6F
1531A:  CLRF   x6E
1531C:  CLRF   x6D
1531E:  CLRF   x6C
15320:  CLRF   x73
15322:  CLRF   x72
15324:  CLRF   x71
15326:  CLRF   x70
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
15328:  CLRF   x80
1532A:  CLRF   x81
1532C:  MOVLW  1F
1532E:  MOVWF  x82
15330:  CLRF   x83
15332:  MOVLW  3B
15334:  MOVWF  x84
15336:  CLRF   x85
15338:  MOVLW  5A
1533A:  MOVWF  x86
1533C:  CLRF   x87
1533E:  MOVLW  78
15340:  MOVWF  x88
15342:  CLRF   x89
15344:  MOVLW  97
15346:  MOVWF  x8A
15348:  CLRF   x8B
1534A:  MOVLW  B5
1534C:  MOVWF  x8C
1534E:  CLRF   x8D
15350:  MOVLW  D4
15352:  MOVWF  x8E
15354:  CLRF   x8F
15356:  MOVLW  F3
15358:  MOVWF  x90
1535A:  CLRF   x91
1535C:  MOVLW  11
1535E:  MOVWF  x92
15360:  MOVLW  01
15362:  MOVWF  x93
15364:  MOVLW  30
15366:  MOVWF  x94
15368:  MOVLW  01
1536A:  MOVWF  x95
1536C:  MOVLW  4E
1536E:  MOVWF  x96
15370:  MOVLW  01
15372:  MOVWF  x97
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
15374:  BCF    4D.3
....................     
....................    RTC_read(); 
15376:  MOVLB  0
15378:  CALL   32E0
....................    RTC_read_alarm(); 
1537C:  CALL   E084
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
15380:  MOVLW  04
15382:  MOVLB  8
15384:  MOVWF  x98
15386:  MOVLB  0
15388:  CALL   29C0
1538C:  MOVFF  01,72D
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
15390:  MOVLB  7
15392:  MOVF   x2B,W
15394:  SUBWF  x2D,W
15396:  BC    1539C
15398:  BSF    4D.3
1539A:  BRA    157C4
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
1539C:  MOVF   x2D,W
1539E:  SUBWF  x2B,W
153A0:  BTFSS  FD8.2
153A2:  BRA    157C4
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
153A4:  MOVLW  01
153A6:  SUBWF  x2A,W
153A8:  MOVWF  00
153AA:  BCF    FD8.0
153AC:  RLCF   00,F
153AE:  MOVF   00,W
153B0:  CLRF   03
153B2:  ADDLW  80
153B4:  MOVWF  FE9
153B6:  MOVLW  08
153B8:  ADDWFC 03,W
153BA:  MOVWF  FEA
153BC:  MOVFF  FEC,03
153C0:  MOVF   FED,F
153C2:  MOVFF  FEF,8F8
153C6:  MOVFF  03,8F9
153CA:  MOVLB  0
153CC:  CALL   C58E
153D0:  MOVFF  03,86B
153D4:  MOVFF  02,86A
153D8:  MOVFF  01,869
153DC:  MOVFF  00,868
....................          time_now = time_now + RTC_DOM_Reg; 
153E0:  MOVLB  8
153E2:  CLRF   xF9
153E4:  MOVFF  729,8F8
153E8:  MOVLB  0
153EA:  CALL   C58E
153EE:  BCF    FD8.1
153F0:  MOVFF  86B,8FB
153F4:  MOVFF  86A,8FA
153F8:  MOVFF  869,8F9
153FC:  MOVFF  868,8F8
15400:  MOVFF  03,8FF
15404:  MOVFF  02,8FE
15408:  MOVFF  01,8FD
1540C:  MOVFF  00,8FC
15410:  CALL   C044
15414:  MOVFF  03,86B
15418:  MOVFF  02,86A
1541C:  MOVFF  01,869
15420:  MOVFF  00,868
....................           
....................          hour = RTC_Hr_Reg; 
15424:  MOVLB  8
15426:  CLRF   xF9
15428:  MOVFF  727,8F8
1542C:  MOVLB  0
1542E:  CALL   C58E
15432:  MOVFF  03,877
15436:  MOVFF  02,876
1543A:  MOVFF  01,875
1543E:  MOVFF  00,874
....................          minute = RTC_Min_Reg; 
15442:  MOVLB  8
15444:  CLRF   xF9
15446:  MOVFF  726,8F8
1544A:  MOVLB  0
1544C:  CALL   C58E
15450:  MOVFF  03,87B
15454:  MOVFF  02,87A
15458:  MOVFF  01,879
1545C:  MOVFF  00,878
....................          second = RTC_Sec_Reg; 
15460:  MOVLB  8
15462:  CLRF   xF9
15464:  MOVFF  725,8F8
15468:  MOVLB  0
1546A:  CALL   C58E
1546E:  MOVFF  03,87F
15472:  MOVFF  02,87E
15476:  MOVFF  01,87D
1547A:  MOVFF  00,87C
....................           
....................          fraction_of_day = (hour / 24); 
1547E:  MOVFF  877,8DF
15482:  MOVFF  876,8DE
15486:  MOVFF  875,8DD
1548A:  MOVFF  874,8DC
1548E:  MOVLB  8
15490:  CLRF   xE3
15492:  CLRF   xE2
15494:  MOVLW  40
15496:  MOVWF  xE1
15498:  MOVLW  83
1549A:  MOVWF  xE0
1549C:  MOVLB  0
1549E:  CALL   C5C4
154A2:  MOVFF  03,873
154A6:  MOVFF  02,872
154AA:  MOVFF  01,871
154AE:  MOVFF  00,870
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
154B2:  MOVFF  87B,8DF
154B6:  MOVFF  87A,8DE
154BA:  MOVFF  879,8DD
154BE:  MOVFF  878,8DC
154C2:  MOVLB  8
154C4:  CLRF   xE3
154C6:  CLRF   xE2
154C8:  MOVLW  34
154CA:  MOVWF  xE1
154CC:  MOVLW  89
154CE:  MOVWF  xE0
154D0:  MOVLB  0
154D2:  CALL   C5C4
154D6:  BCF    FD8.1
154D8:  MOVFF  873,8FB
154DC:  MOVFF  872,8FA
154E0:  MOVFF  871,8F9
154E4:  MOVFF  870,8F8
154E8:  MOVFF  03,8FF
154EC:  MOVFF  02,8FE
154F0:  MOVFF  01,8FD
154F4:  MOVFF  00,8FC
154F8:  CALL   C044
154FC:  MOVFF  03,873
15500:  MOVFF  02,872
15504:  MOVFF  01,871
15508:  MOVFF  00,870
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
1550C:  MOVFF  87F,8DF
15510:  MOVFF  87E,8DE
15514:  MOVFF  87D,8DD
15518:  MOVFF  87C,8DC
1551C:  MOVLB  8
1551E:  CLRF   xE3
15520:  MOVLW  C0
15522:  MOVWF  xE2
15524:  MOVLW  28
15526:  MOVWF  xE1
15528:  MOVLW  8F
1552A:  MOVWF  xE0
1552C:  MOVLB  0
1552E:  CALL   C5C4
15532:  BCF    FD8.1
15534:  MOVFF  873,8FB
15538:  MOVFF  872,8FA
1553C:  MOVFF  871,8F9
15540:  MOVFF  870,8F8
15544:  MOVFF  03,8FF
15548:  MOVFF  02,8FE
1554C:  MOVFF  01,8FD
15550:  MOVFF  00,8FC
15554:  CALL   C044
15558:  MOVFF  03,873
1555C:  MOVFF  02,872
15560:  MOVFF  01,871
15564:  MOVFF  00,870
....................           
....................          time_now = time_now + fraction_of_day; 
15568:  BCF    FD8.1
1556A:  MOVFF  86B,8FB
1556E:  MOVFF  86A,8FA
15572:  MOVFF  869,8F9
15576:  MOVFF  868,8F8
1557A:  MOVFF  873,8FF
1557E:  MOVFF  872,8FE
15582:  MOVFF  871,8FD
15586:  MOVFF  870,8FC
1558A:  CALL   C044
1558E:  MOVFF  03,86B
15592:  MOVFF  02,86A
15596:  MOVFF  01,869
1559A:  MOVFF  00,868
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
1559E:  MOVLB  8
155A0:  CLRF   xF9
155A2:  MOVFF  730,8F8
155A6:  MOVLB  0
155A8:  CALL   C58E
155AC:  MOVFF  03,877
155B0:  MOVFF  02,876
155B4:  MOVFF  01,875
155B8:  MOVFF  00,874
....................          minute = RTC_Al_Min_Reg; 
155BC:  MOVLB  8
155BE:  CLRF   xF9
155C0:  MOVFF  731,8F8
155C4:  MOVLB  0
155C6:  CALL   C58E
155CA:  MOVFF  03,87B
155CE:  MOVFF  02,87A
155D2:  MOVFF  01,879
155D6:  MOVFF  00,878
....................          second = RTC_Al_Sec_Reg; 
155DA:  MOVLB  8
155DC:  CLRF   xF9
155DE:  MOVFF  732,8F8
155E2:  MOVLB  0
155E4:  CALL   C58E
155E8:  MOVFF  03,87F
155EC:  MOVFF  02,87E
155F0:  MOVFF  01,87D
155F4:  MOVFF  00,87C
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
155F8:  MOVLW  01
155FA:  MOVLB  7
155FC:  SUBWF  x2E,W
155FE:  MOVWF  00
15600:  BCF    FD8.0
15602:  RLCF   00,F
15604:  MOVF   00,W
15606:  CLRF   03
15608:  ADDLW  80
1560A:  MOVWF  FE9
1560C:  MOVLW  08
1560E:  ADDWFC 03,W
15610:  MOVWF  FEA
15612:  MOVFF  FEC,03
15616:  MOVF   FED,F
15618:  MOVFF  FEF,8F8
1561C:  MOVFF  03,8F9
15620:  MOVLB  0
15622:  CALL   C58E
15626:  MOVFF  03,86F
1562A:  MOVFF  02,86E
1562E:  MOVFF  01,86D
15632:  MOVFF  00,86C
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
15636:  MOVLB  8
15638:  CLRF   xF9
1563A:  MOVFF  72F,8F8
1563E:  MOVLB  0
15640:  CALL   C58E
15644:  BCF    FD8.1
15646:  MOVFF  86F,8FB
1564A:  MOVFF  86E,8FA
1564E:  MOVFF  86D,8F9
15652:  MOVFF  86C,8F8
15656:  MOVFF  03,8FF
1565A:  MOVFF  02,8FE
1565E:  MOVFF  01,8FD
15662:  MOVFF  00,8FC
15666:  CALL   C044
1566A:  MOVFF  03,86F
1566E:  MOVFF  02,86E
15672:  MOVFF  01,86D
15676:  MOVFF  00,86C
....................           
....................          fraction_of_day = (hour / 24); 
1567A:  MOVFF  877,8DF
1567E:  MOVFF  876,8DE
15682:  MOVFF  875,8DD
15686:  MOVFF  874,8DC
1568A:  MOVLB  8
1568C:  CLRF   xE3
1568E:  CLRF   xE2
15690:  MOVLW  40
15692:  MOVWF  xE1
15694:  MOVLW  83
15696:  MOVWF  xE0
15698:  MOVLB  0
1569A:  CALL   C5C4
1569E:  MOVFF  03,873
156A2:  MOVFF  02,872
156A6:  MOVFF  01,871
156AA:  MOVFF  00,870
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
156AE:  MOVFF  87B,8DF
156B2:  MOVFF  87A,8DE
156B6:  MOVFF  879,8DD
156BA:  MOVFF  878,8DC
156BE:  MOVLB  8
156C0:  CLRF   xE3
156C2:  CLRF   xE2
156C4:  MOVLW  34
156C6:  MOVWF  xE1
156C8:  MOVLW  89
156CA:  MOVWF  xE0
156CC:  MOVLB  0
156CE:  CALL   C5C4
156D2:  BCF    FD8.1
156D4:  MOVFF  873,8FB
156D8:  MOVFF  872,8FA
156DC:  MOVFF  871,8F9
156E0:  MOVFF  870,8F8
156E4:  MOVFF  03,8FF
156E8:  MOVFF  02,8FE
156EC:  MOVFF  01,8FD
156F0:  MOVFF  00,8FC
156F4:  CALL   C044
156F8:  MOVFF  03,873
156FC:  MOVFF  02,872
15700:  MOVFF  01,871
15704:  MOVFF  00,870
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
15708:  MOVFF  87F,8DF
1570C:  MOVFF  87E,8DE
15710:  MOVFF  87D,8DD
15714:  MOVFF  87C,8DC
15718:  MOVLB  8
1571A:  CLRF   xE3
1571C:  MOVLW  C0
1571E:  MOVWF  xE2
15720:  MOVLW  28
15722:  MOVWF  xE1
15724:  MOVLW  8F
15726:  MOVWF  xE0
15728:  MOVLB  0
1572A:  CALL   C5C4
1572E:  BCF    FD8.1
15730:  MOVFF  873,8FB
15734:  MOVFF  872,8FA
15738:  MOVFF  871,8F9
1573C:  MOVFF  870,8F8
15740:  MOVFF  03,8FF
15744:  MOVFF  02,8FE
15748:  MOVFF  01,8FD
1574C:  MOVFF  00,8FC
15750:  CALL   C044
15754:  MOVFF  03,873
15758:  MOVFF  02,872
1575C:  MOVFF  01,871
15760:  MOVFF  00,870
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
15764:  BCF    FD8.1
15766:  MOVFF  86F,8FB
1576A:  MOVFF  86E,8FA
1576E:  MOVFF  86D,8F9
15772:  MOVFF  86C,8F8
15776:  MOVFF  873,8FF
1577A:  MOVFF  872,8FE
1577E:  MOVFF  871,8FD
15782:  MOVFF  870,8FC
15786:  CALL   C044
1578A:  MOVFF  03,86F
1578E:  MOVFF  02,86E
15792:  MOVFF  01,86D
15796:  MOVFF  00,86C
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
1579A:  MOVFF  86F,8F7
1579E:  MOVFF  86E,8F6
157A2:  MOVFF  86D,8F5
157A6:  MOVFF  86C,8F4
157AA:  MOVFF  86B,8FB
157AE:  MOVFF  86A,8FA
157B2:  MOVFF  869,8F9
157B6:  MOVFF  868,8F8
157BA:  CALL   103C4
157BE:  BNC   157C2
157C0:  BSF    4D.3
157C2:  MOVLB  7
....................       } 
....................    } 
157C4:  MOVLB  0
157C6:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
157C8:  BTFSS  4D.3
157CA:  BRA    157E8
157CC:  MOVLW  D0
157CE:  MOVWF  FF6
157D0:  MOVLW  0D
157D2:  MOVWF  FF7
157D4:  MOVLW  00
157D6:  MOVWF  FF8
157D8:  CLRF   1B
157DA:  BTFSC  FF2.7
157DC:  BSF    1B.7
157DE:  BCF    FF2.7
157E0:  CALL   0E4E
157E4:  BTFSC  1B.7
157E6:  BSF    FF2.7
157E8:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F1E8:  BCF    F67.5
0F1EA:  MOVLW  32
0F1EC:  MOVWF  F67
0F1EE:  MOVLW  40
0F1F0:  MOVWF  F68
....................     
....................    data = 0; 
0F1F2:  MOVLB  8
0F1F4:  CLRF   xB8
0F1F6:  CLRF   xB7
....................     
....................    DAC_MS_byte = 0; 
0F1F8:  CLRF   xB9
....................    DAC_LS_byte = 0; 
0F1FA:  CLRF   xBA
....................     
....................    data = setting & 0b0000111100000000; 
0F1FC:  CLRF   xB7
0F1FE:  MOVF   xB6,W
0F200:  ANDLW  0F
0F202:  MOVWF  xB8
....................    data = data >> 8; 
0F204:  MOVFF  8B8,8B7
0F208:  CLRF   xB8
....................    DAC_MS_byte = data; 
0F20A:  MOVFF  8B7,8B9
....................     
....................    data = setting & 0b0000000011111111; 
0F20E:  MOVFF  8B5,8B7
0F212:  CLRF   xB8
....................    DAC_LS_byte = data; 
0F214:  MOVFF  8B7,8BA
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F218:  MOVLW  01
0F21A:  SUBWF  xB4,W
0F21C:  ADDLW  FC
0F21E:  BC    F24A
0F220:  ADDLW  04
0F222:  MOVLB  0
0F224:  GOTO   F268
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F228:  MOVLW  30
0F22A:  MOVLB  8
0F22C:  IORWF  xB9,F
....................          break; 
0F22E:  BRA    F24A
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F230:  MOVLW  70
0F232:  MOVLB  8
0F234:  IORWF  xB9,F
....................          break; 
0F236:  BRA    F24A
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F238:  MOVLW  B0
0F23A:  MOVLB  8
0F23C:  IORWF  xB9,F
....................          break; 
0F23E:  BRA    F24A
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F240:  MOVLW  F0
0F242:  MOVLB  8
0F244:  IORWF  xB9,F
....................          break; 
0F246:  BRA    F24A
0F248:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F24A:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F24C:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F24E:  MOVF   F6A,W
0F250:  MOVFF  8B9,F6A
0F254:  RRCF   F68,W
0F256:  BNC   F254
....................    spi_write2(DAC_LS_byte); 
0F258:  MOVF   F6A,W
0F25A:  MOVFF  8BA,F6A
0F25E:  RRCF   F68,W
0F260:  BNC   F25E
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F262:  BSF    F8C.3
0F264:  MOVLB  0
0F266:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F290:  MOVLB  8
0F292:  CLRF   xB9
0F294:  CLRF   xBA
0F296:  CLRF   xBB
0F298:  CLRF   xBC
0F29A:  CLRF   xBD
0F29C:  CLRF   xBE
0F29E:  CLRF   xBF
0F2A0:  CLRF   xC0
0F2A2:  CLRF   xC1
0F2A4:  CLRF   xC2
0F2A6:  CLRF   xC3
0F2A8:  CLRF   xC4
0F2AA:  CLRF   xC5
0F2AC:  CLRF   xC6
0F2AE:  CLRF   xC7
0F2B0:  CLRF   xC8
0F2B2:  CLRF   xC9
0F2B4:  CLRF   xCA
0F2B6:  CLRF   xCB
0F2B8:  CLRF   xCC
0F2BA:  CLRF   xCD
0F2BC:  CLRF   xCE
0F2BE:  CLRF   xCF
0F2C0:  CLRF   xD0
0F2C2:  CLRF   xD1
0F2C4:  CLRF   xD2
0F2C6:  CLRF   xD3
0F2C8:  CLRF   xD4
0F2CA:  CLRF   xD5
0F2CC:  CLRF   xD6
0F2CE:  CLRF   xD7
0F2D0:  CLRF   xD8
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F2D2:  CLRF   xD9
0F2D4:  CLRF   xDA
0F2D6:  CLRF   xDB
0F2D8:  CLRF   xDC
0F2DA:  CLRF   xDD
0F2DC:  CLRF   xDE
0F2DE:  CLRF   xDF
0F2E0:  CLRF   xE0
0F2E2:  CLRF   xE1
0F2E4:  CLRF   xE2
0F2E6:  CLRF   xE3
0F2E8:  CLRF   xE4
0F2EA:  CLRF   xE5
0F2EC:  CLRF   xE6
0F2EE:  CLRF   xE7
0F2F0:  CLRF   xE8
0F2F2:  CLRF   xE9
0F2F4:  CLRF   xEA
0F2F6:  CLRF   xEB
0F2F8:  CLRF   xEC
0F2FA:  CLRF   xED
0F2FC:  CLRF   xEE
0F2FE:  CLRF   xEF
0F300:  CLRF   xF0
0F302:  CLRF   xF1
0F304:  CLRF   xF2
0F306:  CLRF   xF3
0F308:  CLRF   xF4
0F30A:  CLRF   xF5
0F30C:  CLRF   xF6
0F30E:  CLRF   xF7
0F310:  CLRF   xF8
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F312:  CLRF   xB8
0F314:  MOVLW  01
0F316:  MOVWF  xB7
0F318:  MOVLW  01
0F31A:  ADDWF  xB4,W
0F31C:  MOVWF  01
0F31E:  MOVLW  00
0F320:  ADDWFC xB5,W
0F322:  MOVWF  03
0F324:  MOVF   xB8,W
0F326:  SUBWF  03,W
0F328:  BNC   F40E
0F32A:  BNZ   F332
0F32C:  MOVF   01,W
0F32E:  SUBWF  xB7,W
0F330:  BC    F40E
....................    { 
....................       for (n=1; n<5; ++n) 
0F332:  MOVLW  01
0F334:  MOVWF  xB6
0F336:  MOVF   xB6,W
0F338:  SUBLW  04
0F33A:  BNC   F406
....................       { 
....................          set_adc_channel(n,VSS); 
0F33C:  RLCF   xB6,W
0F33E:  MOVWF  00
0F340:  RLCF   00,F
0F342:  MOVLW  FC
0F344:  ANDWF  00,F
0F346:  MOVF   FC2,W
0F348:  ANDLW  83
0F34A:  IORWF  00,W
0F34C:  MOVWF  FC2
0F34E:  MOVLW  00
0F350:  MOVWF  01
0F352:  MOVF   FC1,W
0F354:  ANDLW  F8
0F356:  IORWF  01,W
0F358:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F35A:  MOVF   xB6,W
0F35C:  MULLW  04
0F35E:  MOVF   FF3,W
0F360:  CLRF   03
0F362:  ADDLW  D9
0F364:  MOVWF  FE9
0F366:  MOVLW  08
0F368:  ADDWFC 03,W
0F36A:  MOVWF  FEA
0F36C:  BSF    FC2.1
0F36E:  BTFSC  FC2.1
0F370:  BRA    F36E
0F372:  MOVFF  FC3,FEF
0F376:  MOVFF  FC4,FEC
0F37A:  CLRF   FEC
0F37C:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F37E:  MOVF   xB6,W
0F380:  MULLW  04
0F382:  MOVF   FF3,W
0F384:  CLRF   03
0F386:  ADDLW  B9
0F388:  MOVWF  01
0F38A:  MOVLW  08
0F38C:  ADDWFC 03,F
0F38E:  MOVFF  01,8F9
0F392:  MOVFF  03,8FA
0F396:  MOVF   xB6,W
0F398:  MULLW  04
0F39A:  MOVF   FF3,W
0F39C:  CLRF   03
0F39E:  ADDLW  B9
0F3A0:  MOVWF  FE9
0F3A2:  MOVLW  08
0F3A4:  ADDWFC 03,W
0F3A6:  MOVWF  FEA
0F3A8:  MOVFF  FEF,8FB
0F3AC:  MOVFF  FEC,8FC
0F3B0:  MOVFF  FEC,8FD
0F3B4:  MOVFF  FEC,8FE
0F3B8:  MOVF   xB6,W
0F3BA:  MULLW  04
0F3BC:  MOVF   FF3,W
0F3BE:  CLRF   03
0F3C0:  ADDLW  D9
0F3C2:  MOVWF  FE9
0F3C4:  MOVLW  08
0F3C6:  ADDWFC 03,W
0F3C8:  MOVWF  FEA
0F3CA:  MOVFF  FEF,00
0F3CE:  MOVFF  FEC,01
0F3D2:  MOVFF  FEC,02
0F3D6:  MOVFF  FEC,03
0F3DA:  MOVF   xFB,W
0F3DC:  ADDWF  00,F
0F3DE:  MOVF   xFC,W
0F3E0:  ADDWFC 01,F
0F3E2:  MOVF   xFD,W
0F3E4:  ADDWFC 02,F
0F3E6:  MOVF   xFE,W
0F3E8:  ADDWFC 03,F
0F3EA:  MOVFF  8FA,FEA
0F3EE:  MOVFF  8F9,FE9
0F3F2:  MOVFF  00,FEF
0F3F6:  MOVFF  01,FEC
0F3FA:  MOVFF  02,FEC
0F3FE:  MOVFF  03,FEC
0F402:  INCF   xB6,F
0F404:  BRA    F336
....................       } 
0F406:  INCF   xB7,F
0F408:  BTFSC  FD8.2
0F40A:  INCF   xB8,F
0F40C:  BRA    F318
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F40E:  MOVLW  01
0F410:  MOVWF  xB6
0F412:  MOVF   xB6,W
0F414:  SUBLW  04
0F416:  BNC   F488
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F418:  BCF    FD8.0
0F41A:  RLCF   xB6,W
0F41C:  CLRF   03
0F41E:  ADDLW  A5
0F420:  MOVWF  01
0F422:  MOVLW  04
0F424:  ADDWFC 03,F
0F426:  MOVFF  01,8F9
0F42A:  MOVFF  03,8FA
0F42E:  MOVF   xB6,W
0F430:  MULLW  04
0F432:  MOVF   FF3,W
0F434:  CLRF   03
0F436:  ADDLW  B9
0F438:  MOVWF  FE9
0F43A:  MOVLW  08
0F43C:  ADDWFC 03,W
0F43E:  MOVWF  FEA
0F440:  MOVFF  FEF,A28
0F444:  MOVFF  FEC,A29
0F448:  MOVFF  FEC,A2A
0F44C:  MOVFF  FEC,A2B
0F450:  BCF    FD8.1
0F452:  CLRF   1B
0F454:  BTFSC  FF2.7
0F456:  BSF    1B.7
0F458:  BCF    FF2.7
0F45A:  MOVLB  A
0F45C:  CLRF   x2F
0F45E:  CLRF   x2E
0F460:  MOVFF  8B5,A2D
0F464:  MOVFF  8B4,A2C
0F468:  MOVLB  0
0F46A:  CALL   1056
0F46E:  BTFSC  1B.7
0F470:  BSF    FF2.7
0F472:  MOVFF  8FA,FEA
0F476:  MOVFF  8F9,FE9
0F47A:  MOVFF  00,FEF
0F47E:  MOVFF  01,FEC
0F482:  MOVLB  8
0F484:  INCF   xB6,F
0F486:  BRA    F412
....................    } 
0F488:  MOVLB  0
0F48A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    //Handle updating variables for the valve timeout 
....................    /*if(valve_align_timeout != -1){ 
....................       fprintf(COM_A,"align_var: %Ld \r\n",valve_align_timeout); 
....................       if(valve_align_timeout >= 2){ 
....................          valve_align_timeout = -1; 
....................          reset_cpu(); 
....................       } 
....................       valve_align_timeout++; 
....................    }*/ 
....................    //Service watchdog 
....................    output_bit(PIN_J7,(!input(PIN_J7))); 
*
00E14:  BTFSS  F88.7
00E16:  BRA    0E1C
00E18:  BCF    F91.7
00E1A:  BRA    0E1E
00E1C:  BSF    F91.7
....................     
....................    rtc_alarm = TRUE; 
00E1E:  BSF    4D.0
....................    sleep_mode = FALSE; 
00E20:  BCF    4D.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E22:  BTFSS  4D.2
00E24:  BRA    0E28
....................    { 
....................       ; 
00E26:  BRA    0E22
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E28:  BSF    4D.2
....................    RTC_read_flags(); 
00E2A:  RCALL  0DD8
....................    ++nv_elapsed; 
00E2C:  INCF   35,F
00E2E:  BTFSC  FD8.2
00E30:  INCF   36,F
.................... } 
....................  
00E32:  BCF    FF2.1
00E34:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E78:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E7A:  BTFSC  4D.1
00E7C:  BRA    0ECE
....................    { 
....................       if (kbhit(COM_A)) 
00E7E:  BTFSS  F9E.5
00E80:  BRA    0ECC
....................       { 
....................          c = getc(COM_A); 
00E82:  RCALL  0E38
00E84:  MOVFF  01,A13
....................          switch (c) 
00E88:  MOVLB  A
00E8A:  MOVF   x13,W
00E8C:  XORLW  3F
00E8E:  MOVLB  0
00E90:  BZ    0E9C
00E92:  XORLW  2E
00E94:  BZ    0EC0
00E96:  XORLW  0A
00E98:  BZ    0EC6
00E9A:  BRA    0ECC
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00E9C:  DECFSZ 4E,W
00E9E:  BRA    0EB0
00EA0:  MOVLW  D8
00EA2:  MOVWF  FF6
00EA4:  MOVLW  0E
00EA6:  MOVWF  FF7
00EA8:  MOVLW  00
00EAA:  MOVWF  FF8
00EAC:  RCALL  0E4E
00EAE:  BRA    0EBE
....................                else fprintf(COM_A, "@RDY\r\n"); 
00EB0:  MOVLW  E0
00EB2:  MOVWF  FF6
00EB4:  MOVLW  0E
00EB6:  MOVWF  FF7
00EB8:  MOVLW  00
00EBA:  MOVWF  FF8
00EBC:  RCALL  0E4E
....................                break; 
00EBE:  BRA    0ECC
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EC0:  MOVLW  01
00EC2:  MOVWF  50
....................                break;          
00EC4:  BRA    0ECC
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EC6:  CLRF   32
00EC8:  MOVLW  01
00ECA:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00ECC:  BRA    0ED2
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00ECE:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00ED0:  BCF    F9E.5
....................    } 
00ED2:  BCF    F9E.5
00ED4:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0ADD0:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0ADD2:  MOVF   FAE,W
....................    busy_status = FALSE; 
0ADD4:  CLRF   4E
0ADD6:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
0295C:  MOVLW  01
0295E:  MOVWF  4E
....................    clear_interrupt(INT_RDA); 
02960:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
02962:  BSF    F9D.5
02964:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00EE8:  MOVLW  0B
00EEA:  MOVWF  FD7
00EEC:  MOVLW  DC
00EEE:  MOVWF  FD6
....................    restart_wdt(); 
00EF0:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00EF2:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00EF4:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00EF6:  CLRF   FCF
00EF8:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00EFA:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00EFC:  MOVF   2F,W
00EFE:  SUBLW  02
00F00:  BNZ   0F08
00F02:  MOVF   30,F
00F04:  BNZ   0F08
00F06:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00F08:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00F0A:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00F0C:  BCF    FF2.2
00F0E:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00F12:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00F14:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00F16:  MOVF   2F,W
00F18:  SUBLW  02
00F1A:  BNZ   0F22
00F1C:  MOVF   30,F
00F1E:  BNZ   0F22
00F20:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F22:  BCF    F9E.0
00F24:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
158BC:  MOVLB  8
158BE:  CLRF   x6D
158C0:  CLRF   x71
158C2:  CLRF   x70
158C4:  CLRF   x6F
158C6:  CLRF   x6E
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
158C8:  MOVLW  01
158CA:  ADDWF  x6E,F
158CC:  BTFSC  FD8.0
158CE:  INCF   x6F,F
158D0:  BTFSC  FD8.2
158D2:  INCF   x70,F
158D4:  BTFSC  FD8.2
158D6:  INCF   x71,F
158D8:  MOVF   x71,F
158DA:  BNZ   1591C
158DC:  MOVF   x70,W
158DE:  SUBLW  04
158E0:  BNC   1591C
158E2:  BNZ   158F2
158E4:  MOVF   x6F,W
158E6:  SUBLW  93
158E8:  BNC   1591C
158EA:  BNZ   158F2
158EC:  MOVF   x6E,W
158EE:  SUBLW  DF
158F0:  BNC   1591C
....................    { 
....................       if(kbhit(COM_A)) 
158F2:  BTFSS  F9E.5
158F4:  BRA    15912
....................       { 
....................          c = fgetc(COM_A); 
158F6:  MOVLB  0
158F8:  CALL   0E38
158FC:  MOVFF  01,86D
....................          if (com_echo == TRUE) 
15900:  DECFSZ 4C,W
15902:  BRA    1590E
....................          { 
....................             fputc(c, COM_A); 
15904:  MOVLB  8
15906:  MOVF   x6D,W
15908:  MOVLB  0
1590A:  CALL   ADD8
....................          } 
....................          break; 
1590E:  MOVLB  8
15910:  BRA    1591C
....................       } 
....................  
....................       delay_us(10); 
15912:  MOVLW  35
15914:  MOVWF  00
15916:  DECFSZ 00,F
15918:  BRA    15916
1591A:  BRA    158C8
....................    } 
....................  
....................    return(c); 
1591C:  MOVFF  86D,01
15920:  MOVLB  0
15922:  GOTO   15932 (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AD4C:  MOVLW  58
0AD4E:  MOVLB  8
0AD50:  MOVWF  x64
0AD52:  CLRF   x68
0AD54:  CLRF   x67
0AD56:  CLRF   x66
0AD58:  CLRF   x65
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AD5A:  MOVLW  01
0AD5C:  ADDWF  x65,F
0AD5E:  BTFSC  FD8.0
0AD60:  INCF   x66,F
0AD62:  BTFSC  FD8.2
0AD64:  INCF   x67,F
0AD66:  BTFSC  FD8.2
0AD68:  INCF   x68,F
0AD6A:  MOVF   x68,F
0AD6C:  BNZ   AD9C
0AD6E:  MOVF   x67,F
0AD70:  BNZ   AD9C
0AD72:  MOVF   x66,W
0AD74:  SUBLW  C3
0AD76:  BNC   AD9C
0AD78:  BNZ   AD80
0AD7A:  MOVF   x65,W
0AD7C:  SUBLW  4F
0AD7E:  BNC   AD9C
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AD80:  MOVLW  05
0AD82:  MOVWF  00
0AD84:  DECFSZ 00,F
0AD86:  BRA    AD84
....................  
....................       if(kbhit()) 
0AD88:  BTFSS  F9E.5
0AD8A:  BRA    AD9A
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AD8C:  MOVLB  0
0AD8E:  CALL   0E38
0AD92:  MOVFF  01,864
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AD96:  MOVLB  8
0AD98:  BRA    AD9C
....................       } 
0AD9A:  BRA    AD5A
....................    } 
....................  
....................    return(EscChar); 
0AD9C:  MOVFF  864,01
0ADA0:  MOVLB  0
0ADA2:  GOTO   1B6E2 (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0D6E8:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0D6EA:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0D6EC:  BSF    F8F.3
....................    delay_ms(10); 
0D6EE:  MOVLW  0A
0D6F0:  MOVLB  9
0D6F2:  MOVWF  xCD
0D6F4:  MOVLB  0
0D6F6:  CALL   28AC
0D6FA:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0D7D4:  MOVLB  8
0D7D6:  CLRF   xD5
0D7D8:  CLRF   xD4
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0D7DA:  MOVLB  F
0D7DC:  BTFSC  x21.1
0D7DE:  BRA    D7EC
....................       ++c; 
0D7E0:  MOVLB  8
0D7E2:  INCF   xD4,F
0D7E4:  BTFSC  FD8.2
0D7E6:  INCF   xD5,F
0D7E8:  BRA    D7DA
0D7EA:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0D7EC:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0D7EE:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0D7F0:  BCF    F8F.3
0D7F2:  MOVLB  0
0D7F4:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
16AE8:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
16AEA:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
16AEC:  BCF    F8F.3
16AEE:  GOTO   16BDC (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
16AF2:  MOVLB  8
16AF4:  CLRF   x66
16AF6:  CLRF   x67
16AF8:  CLRF   xB8
16AFA:  CLRF   xB9
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16AFC:  MOVLW  28
16AFE:  MOVWF  FF6
16B00:  MOVLW  0F
16B02:  MOVWF  FF7
16B04:  MOVLW  00
16B06:  MOVWF  FF8
16B08:  CLRF   1B
16B0A:  BTFSC  FF2.7
16B0C:  BSF    1B.7
16B0E:  BCF    FF2.7
16B10:  MOVLB  0
16B12:  CALL   0E4E
16B16:  BTFSC  1B.7
16B18:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16B1A:  MOVLB  8
16B1C:  MOVF   x67,W
16B1E:  SUBLW  04
16B20:  BZ    16BD8
....................    { 
....................        if (kbhit(COM_A)) 
16B22:  BTFSS  F9E.5
16B24:  BRA    16BBC
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16B26:  MOVLB  0
16B28:  CALL   0E38
16B2C:  MOVFF  01,866
....................           if (com_echo == TRUE) 
16B30:  DECFSZ 4C,W
16B32:  BRA    16B3E
....................           { 
....................              fputc(charFromA, COM_A); 
16B34:  MOVLB  8
16B36:  MOVF   x66,W
16B38:  MOVLB  0
16B3A:  CALL   ADD8
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16B3E:  MOVLB  8
16B40:  MOVF   xB9,W
16B42:  SUBLW  4F
16B44:  BNC   16B9A
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
16B46:  MOVF   xB9,W
16B48:  INCF   xB9,F
16B4A:  CLRF   03
16B4C:  ADDLW  68
16B4E:  MOVWF  FE9
16B50:  MOVLW  08
16B52:  ADDWFC 03,W
16B54:  MOVWF  FEA
16B56:  MOVFF  866,FEF
....................              if (CARRIAGE_RET == charFromA) 
16B5A:  MOVF   x66,W
16B5C:  SUBLW  0D
16B5E:  BNZ   16B98
....................              { 
....................                 multidrop_on(); 
16B60:  MOVLB  0
16B62:  CALL   D6E8
....................                 for (index = 0 ; index < charCount; index++) 
16B66:  MOVLB  8
16B68:  CLRF   xB8
16B6A:  MOVF   xB9,W
16B6C:  SUBWF  xB8,W
16B6E:  BC    16B8E
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
16B70:  CLRF   03
16B72:  MOVF   xB8,W
16B74:  ADDLW  68
16B76:  MOVWF  FE9
16B78:  MOVLW  08
16B7A:  ADDWFC 03,W
16B7C:  MOVWF  FEA
16B7E:  MOVFF  FEF,8BA
16B82:  MOVF   xBA,W
16B84:  MOVLB  0
16B86:  BRA    16ADA
16B88:  MOVLB  8
16B8A:  INCF   xB8,F
16B8C:  BRA    16B6A
....................                 } 
....................                 charCount = 0; 
16B8E:  CLRF   xB9
....................                 multidrop_off(); 
16B90:  MOVLB  0
16B92:  CALL   D7D4
16B96:  MOVLB  8
....................              } 
....................           } 
16B98:  BRA    16BBC
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
16B9A:  MOVLW  30
16B9C:  MOVWF  FF6
16B9E:  MOVLW  0F
16BA0:  MOVWF  FF7
16BA2:  MOVLW  00
16BA4:  MOVWF  FF8
16BA6:  CLRF   1B
16BA8:  BTFSC  FF2.7
16BAA:  BSF    1B.7
16BAC:  BCF    FF2.7
16BAE:  MOVLB  0
16BB0:  CALL   0E4E
16BB4:  BTFSC  1B.7
16BB6:  BSF    FF2.7
....................              charCount = 0; 
16BB8:  MOVLB  8
16BBA:  CLRF   xB9
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
16BBC:  BTFSS  FA4.5
16BBE:  BRA    16BD6
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
16BC0:  MOVLB  0
16BC2:  CALL   12A7C
16BC6:  MOVFF  01,867
....................           fputc(charFromB, COM_A);                  // send data via USART 
16BCA:  MOVLB  8
16BCC:  MOVF   x67,W
16BCE:  MOVLB  0
16BD0:  CALL   ADD8
16BD4:  MOVLB  8
....................        } 
16BD6:  BRA    16B1C
....................    } 
....................  
....................    multidrop_shdn(); 
16BD8:  MOVLB  0
16BDA:  BRA    16AE8
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
16BDC:  MOVLW  40
16BDE:  MOVWF  FF6
16BE0:  MOVLW  0F
16BE2:  MOVWF  FF7
16BE4:  MOVLW  00
16BE6:  MOVWF  FF8
16BE8:  CLRF   1B
16BEA:  BTFSC  FF2.7
16BEC:  BSF    1B.7
16BEE:  BCF    FF2.7
16BF0:  CALL   0E4E
16BF4:  BTFSC  1B.7
16BF6:  BSF    FF2.7
16BF8:  GOTO   16C12 (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C50C:  MOVLB  8
0C50E:  DECF   x80,F
....................    len=0; 
0C510:  CLRF   x81
....................    do { 
....................      c=getc(); 
0C512:  MOVLB  0
0C514:  CALL   0E38
0C518:  MOVFF  01,882
....................      if(c==8) {  // Backspace 
0C51C:  MOVLB  8
0C51E:  MOVF   x82,W
0C520:  SUBLW  08
0C522:  BNZ   C546
....................         if(len>0) { 
0C524:  MOVF   x81,F
0C526:  BZ    C544
....................           len--; 
0C528:  DECF   x81,F
....................           putc(c); 
0C52A:  MOVF   x82,W
0C52C:  MOVLB  0
0C52E:  CALL   ADD8
....................           putc(' '); 
0C532:  MOVLW  20
0C534:  CALL   ADD8
....................           putc(c); 
0C538:  MOVLB  8
0C53A:  MOVF   x82,W
0C53C:  MOVLB  0
0C53E:  CALL   ADD8
0C542:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C544:  BRA    C574
0C546:  MOVF   x82,W
0C548:  SUBLW  1F
0C54A:  BC    C574
0C54C:  MOVF   x82,W
0C54E:  SUBLW  7E
0C550:  BNC   C574
....................        if(len<=max) { 
0C552:  MOVF   x81,W
0C554:  SUBWF  x80,W
0C556:  BNC   C574
....................          s[len++]=c; 
0C558:  MOVF   x81,W
0C55A:  INCF   x81,F
0C55C:  ADDWF  x7E,W
0C55E:  MOVWF  FE9
0C560:  MOVLW  00
0C562:  ADDWFC x7F,W
0C564:  MOVWF  FEA
0C566:  MOVFF  882,FEF
....................          putc(c); 
0C56A:  MOVF   x82,W
0C56C:  MOVLB  0
0C56E:  CALL   ADD8
0C572:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C574:  MOVF   x82,W
0C576:  SUBLW  0D
0C578:  BNZ   C512
....................    s[len]=0; 
0C57A:  MOVF   x81,W
0C57C:  ADDWF  x7E,W
0C57E:  MOVWF  FE9
0C580:  MOVLW  00
0C582:  ADDWFC x7F,W
0C584:  MOVWF  FEA
0C586:  CLRF   FEF
0C588:  MOVLB  0
0C58A:  GOTO   C98A (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0C978:  MOVLW  08
0C97A:  MOVLB  8
0C97C:  MOVWF  x7F
0C97E:  MOVLW  66
0C980:  MOVWF  x7E
0C982:  MOVLW  14
0C984:  MOVWF  x80
0C986:  MOVLB  0
0C988:  BRA    C50C
....................   f = atof(s); 
0C98A:  MOVLW  08
0C98C:  MOVLB  8
0C98E:  MOVWF  x7F
0C990:  MOVLW  66
0C992:  MOVWF  x7E
0C994:  CLRF   x81
0C996:  CLRF   x80
0C998:  MOVLB  0
0C99A:  BRA    C722
0C99C:  MOVFF  03,87D
0C9A0:  MOVFF  02,87C
0C9A4:  MOVFF  01,87B
0C9A8:  MOVFF  00,87A
....................   return(f); 
0C9AC:  MOVFF  87A,00
0C9B0:  MOVFF  87B,01
0C9B4:  MOVFF  87C,02
0C9B8:  MOVFF  87D,03
0C9BC:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
028D6:  MOVLW  2F
028D8:  MOVWF  F92
....................    set_tris_b(0b00110111); 
028DA:  MOVLW  37
028DC:  MOVWF  F93
....................    set_tris_c(0b10010000); 
028DE:  MOVLW  90
028E0:  MOVWF  F94
....................    set_tris_d(0b00100000); 
028E2:  MOVLW  20
028E4:  MOVWF  F95
....................    set_tris_e(0b01000000); 
028E6:  MOVLW  40
028E8:  MOVWF  F96
....................    set_tris_f(0b00000000); 
028EA:  MOVLW  00
028EC:  MOVWF  F97
....................    set_tris_g(0b11100100); 
028EE:  MOVLW  E4
028F0:  MOVWF  F98
....................    set_tris_h(0b01000000); 
028F2:  MOVLW  40
028F4:  MOVWF  F99
....................    set_tris_j(0b00000000); 
028F6:  MOVLW  00
028F8:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
028FA:  BCF    F8E.3
....................    output_low(HB_IN1); 
028FC:  BCF    F8E.4
....................    output_low(HB_IN2); 
028FE:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
02900:  BCF    F91.3
....................    output_high(EEP_CS);        
02902:  BSF    F91.2
....................    output_high(RTC_CS); 
02904:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
02906:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
02908:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
0290A:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
0290C:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
0290E:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
02910:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
02912:  BCF    F8F.3
....................    delay_ms(20);   
02914:  MOVLW  14
02916:  MOVLB  9
02918:  MOVWF  xCD
0291A:  MOVLB  0
0291C:  RCALL  28AC
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
0291E:  BCF    F8E.1
....................    output_low(VDET);     
02920:  BCF    F90.7
....................    bus_pwr_status=0; 
02922:  MOVLB  4
02924:  CLRF   xB6
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
02926:  BSF    F8C.2
....................    output_high(DAC_CS); 
02928:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
0292A:  BCF    F8C.0
....................    output_low(HSW2); 
0292C:  BCF    F8C.1
....................    heater_stat=0; 
0292E:  CLRF   xB5
02930:  MOVLB  0
02932:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
157EA:  BSF    F91.1
....................    output_low(EEP_WP);        
157EC:  BCF    F91.3
....................    output_high(EEP_CS);        
157EE:  BSF    F91.2
....................    output_high(RTC_CS);  
157F0:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
157F2:  BCF    F8E.3
....................    output_low(HB_IN1);        
157F4:  BCF    F8E.4
....................    output_low(HB_IN2); 
157F6:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
157F8:  BCF    F8C.2
....................    output_low(DAC_CS); 
157FA:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
157FC:  BCF    F8C.0
....................    output_low(HSW2); 
157FE:  BCF    F8C.1
....................    heater_stat=0; 
15800:  MOVLB  4
15802:  CLRF   xB5
....................    // Power switches 
....................    output_low(VMOT);         
15804:  BCF    F8E.1
....................    output_low(VDET);  
15806:  BCF    F90.7
....................    bus_pwr_status=0; 
15808:  CLRF   xB6
....................    output_low(VENC1);         
1580A:  BCF    F8E.6
....................    output_low(VENC2);         
1580C:  BCF    F8E.7
....................    output_low(VHBRDG);  
1580E:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
15810:  MOVLW  48
15812:  MOVWF  FF6
15814:  MOVLW  0F
15816:  MOVWF  FF7
15818:  MOVLW  00
1581A:  MOVWF  FF8
1581C:  CLRF   1B
1581E:  BTFSC  FF2.7
15820:  BSF    1B.7
15822:  BCF    FF2.7
15824:  MOVLB  0
15826:  CALL   0E4E
1582A:  BTFSC  1B.7
1582C:  BSF    FF2.7
....................    delay_ms(50); 
1582E:  MOVLW  32
15830:  MOVLB  9
15832:  MOVWF  xCD
15834:  MOVLB  0
15836:  CALL   28AC
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
1583A:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
1583C:  BSF    F91.6
....................    output_low(MD1_TXEN); 
1583E:  BCF    F91.5
....................    output_low(MD2_SHDN);    
15840:  BCF    F8F.0
....................    output_low(MD2_REN); 
15842:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
15844:  BCF    F8F.3
....................  
....................    delay_ms(30); 
15846:  MOVLW  1E
15848:  MOVLB  9
1584A:  MOVWF  xCD
1584C:  MOVLB  0
1584E:  CALL   28AC
15852:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
04FCE:  MOVLB  8
04FD0:  CLRF   x6A
04FD2:  MOVF   x6A,W
04FD4:  SUBLW  02
04FD6:  BNC   4FFC
....................       FS_Status = f_mountdrv(); 
04FD8:  MOVLB  0
04FDA:  RCALL  47EA
04FDC:  MOVFF  01,724
....................       if (FS_Status) 
04FE0:  MOVLB  7
04FE2:  MOVF   x24,F
04FE4:  BZ    4FF0
....................          { 
....................          display_file_result(FS_Status); 
04FE6:  MOVFF  724,86B
04FEA:  MOVLB  0
04FEC:  BRA    4D88
....................          } 
04FEE:  BRA    4FF6
....................       else break; 
04FF0:  MOVLB  8
04FF2:  BRA    4FFC
04FF4:  MOVLB  0
04FF6:  MOVLB  8
04FF8:  INCF   x6A,F
04FFA:  BRA    4FD2
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
04FFC:  MOVLW  3E
04FFE:  MOVWF  xCF
05000:  CLRF   xD1
05002:  MOVFF  724,8D0
05006:  MOVLB  0
05008:  RCALL  4F68
....................     
....................    return(FS_Status); 
0500A:  MOVLB  7
0500C:  MOVFF  724,01
05010:  MOVLB  0
05012:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
03098:  MOVLW  01
0309A:  MOVLB  8
0309C:  MOVWF  x64
0309E:  MOVF   x64,W
030A0:  SUBLW  03
030A2:  BNC   30DE
....................    { 
....................       output_bit(BOARD_LED, ON); 
030A4:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
030A6:  MOVF   2F,W
030A8:  SUBLW  02
030AA:  BNZ   30B2
030AC:  MOVF   30,F
030AE:  BNZ   30B2
030B0:  BSF    F90.6
....................       delay_ms(32); 
030B2:  MOVLW  20
030B4:  MOVLB  9
030B6:  MOVWF  xCD
030B8:  MOVLB  0
030BA:  CALL   28AC
....................       output_bit(BOARD_LED, OFF); 
030BE:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
030C0:  MOVF   2F,W
030C2:  SUBLW  02
030C4:  BNZ   30CC
030C6:  MOVF   30,F
030C8:  BNZ   30CC
030CA:  BCF    F90.6
....................       delay_ms(32); 
030CC:  MOVLW  20
030CE:  MOVLB  9
030D0:  MOVWF  xCD
030D2:  MOVLB  0
030D4:  CALL   28AC
030D8:  MOVLB  8
030DA:  INCF   x64,F
030DC:  BRA    309E
....................    } 
030DE:  MOVLB  0
030E0:  GOTO   1B4E2 (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
05090:  MOVLB  8
05092:  CLRF   xD4
05094:  CLRF   xD3
05096:  CLRF   xD2
05098:  CLRF   xD1
....................    set_adc_channel(0,VSS); 
0509A:  MOVLW  00
0509C:  MOVWF  01
0509E:  MOVF   FC2,W
050A0:  ANDLW  83
050A2:  IORWF  01,W
050A4:  MOVWF  FC2
050A6:  MOVLW  00
050A8:  MOVWF  01
050AA:  MOVF   FC1,W
050AC:  ANDLW  F8
050AE:  IORWF  01,W
050B0:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
050B2:  MOVLW  01
050B4:  MOVWF  xCE
050B6:  MOVF   xCE,W
050B8:  SUBLW  32
050BA:  BNC   50E0
....................       reading=read_adc(); 
050BC:  BSF    FC2.1
050BE:  BTFSC  FC2.1
050C0:  BRA    50BE
050C2:  MOVFF  FC3,8D5
050C6:  MOVFF  FC4,8D6
050CA:  CLRF   xD7
050CC:  CLRF   xD8
....................       delay_ms(5); 
050CE:  MOVLW  05
050D0:  MOVLB  9
050D2:  MOVWF  xCD
050D4:  MOVLB  0
050D6:  CALL   28AC
050DA:  MOVLB  8
050DC:  INCF   xCE,F
050DE:  BRA    50B6
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
050E0:  MOVLW  01
050E2:  MOVWF  xCE
050E4:  MOVF   xCE,W
050E6:  SUBLW  64
050E8:  BNC   5196
....................       reading=read_adc(); 
050EA:  BSF    FC2.1
050EC:  BTFSC  FC2.1
050EE:  BRA    50EC
050F0:  MOVFF  FC3,8D5
050F4:  MOVFF  FC4,8D6
050F8:  CLRF   xD7
050FA:  CLRF   xD8
....................       result=(((result*(i-1))+reading)/i); 
050FC:  MOVLW  01
050FE:  SUBWF  xCE,W
05100:  MOVWF  xD9
05102:  MOVFF  8D4,9DA
05106:  MOVFF  8D3,9D9
0510A:  MOVFF  8D2,9D8
0510E:  MOVFF  8D1,9D7
05112:  MOVLB  9
05114:  CLRF   xDE
05116:  CLRF   xDD
05118:  CLRF   xDC
0511A:  MOVWF  xDB
0511C:  MOVLB  0
0511E:  CALL   478E
05122:  MOVFF  03,8DC
05126:  MOVFF  02,8DB
0512A:  MOVFF  01,8DA
0512E:  MOVFF  00,8D9
05132:  MOVLB  8
05134:  MOVF   xD5,W
05136:  ADDWF  xD9,F
05138:  MOVF   xD6,W
0513A:  ADDWFC xDA,F
0513C:  MOVF   xD7,W
0513E:  ADDWFC xDB,F
05140:  MOVF   xD8,W
05142:  ADDWFC xDC,F
05144:  BCF    FD8.1
05146:  CLRF   1B
05148:  BTFSC  FF2.7
0514A:  BSF    1B.7
0514C:  BCF    FF2.7
0514E:  MOVFF  8DC,A2B
05152:  MOVFF  8DB,A2A
05156:  MOVFF  8DA,A29
0515A:  MOVFF  8D9,A28
0515E:  MOVLB  A
05160:  CLRF   x2F
05162:  CLRF   x2E
05164:  CLRF   x2D
05166:  MOVFF  8CE,A2C
0516A:  MOVLB  0
0516C:  CALL   1056
05170:  BTFSC  1B.7
05172:  BSF    FF2.7
05174:  MOVFF  03,8D4
05178:  MOVFF  02,8D3
0517C:  MOVFF  01,8D2
05180:  MOVFF  00,8D1
....................       delay_ms(5); 
05184:  MOVLW  05
05186:  MOVLB  9
05188:  MOVWF  xCD
0518A:  MOVLB  0
0518C:  CALL   28AC
05190:  MOVLB  8
05192:  INCF   xCE,F
05194:  BRA    50E4
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
05196:  MOVFF  8D4,9DA
0519A:  MOVFF  8D3,9D9
0519E:  MOVFF  8D2,9D8
051A2:  MOVFF  8D1,9D7
051A6:  MOVLB  9
051A8:  CLRF   xDE
051AA:  CLRF   xDD
051AC:  CLRF   xDC
051AE:  MOVLW  64
051B0:  MOVWF  xDB
051B2:  MOVLB  0
051B4:  CALL   478E
051B8:  MOVFF  03,8DC
051BC:  MOVFF  02,8DB
051C0:  MOVFF  01,8DA
051C4:  MOVFF  00,8D9
051C8:  BCF    FD8.1
051CA:  CLRF   1B
051CC:  BTFSC  FF2.7
051CE:  BSF    1B.7
051D0:  BCF    FF2.7
051D2:  MOVFF  03,A2B
051D6:  MOVFF  02,A2A
051DA:  MOVFF  01,A29
051DE:  MOVFF  00,A28
051E2:  MOVLB  A
051E4:  CLRF   x2F
051E6:  CLRF   x2E
051E8:  MOVLW  01
051EA:  MOVWF  x2D
051EC:  MOVLW  10
051EE:  MOVWF  x2C
051F0:  MOVLB  0
051F2:  CALL   1056
051F6:  BTFSC  1B.7
051F8:  BSF    FF2.7
051FA:  MOVLW  56
051FC:  MOVLB  8
051FE:  ADDWF  00,W
05200:  MOVWF  xCF
05202:  MOVLW  00
05204:  ADDWFC 01,W
05206:  MOVWF  xD0
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
05208:  MOVFF  8CF,01
0520C:  MOVFF  8D0,02
05210:  MOVLB  0
05212:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
0507A:  MOVLW  02
0507C:  MOVWF  FEA
0507E:  MOVLW  99
05080:  MOVWF  FE9
05082:  CLRF   00
05084:  CLRF   02
05086:  MOVLW  1E
05088:  MOVWF  01
0508A:  CALL   34C2
0508E:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
129A4:  MOVLW  02
129A6:  MOVWF  FEA
129A8:  MOVLW  B7
129AA:  MOVWF  FE9
129AC:  CLRF   00
129AE:  CLRF   02
129B0:  MOVLW  1E
129B2:  MOVWF  01
129B4:  CALL   34C2
129B8:  GOTO   12C60 (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
053AE:  RCALL  507A
....................     
....................    v_supply = read_supply(); 
053B0:  RCALL  5090
053B2:  MOVFF  02,8CD
053B6:  MOVFF  01,8CC
....................    RTC_read(); 
053BA:  CALL   32E0
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
053BE:  MOVLW  02
053C0:  MOVWF  1E
053C2:  MOVLW  99
053C4:  MOVWF  1D
053C6:  MOVFF  72A,8CE
053CA:  MOVLW  01
053CC:  MOVLB  8
053CE:  MOVWF  xCF
053D0:  MOVLB  0
053D2:  RCALL  5214
053D4:  MOVLW  2F
053D6:  MOVLB  8
053D8:  MOVWF  xE0
053DA:  MOVLB  0
053DC:  RCALL  5032
053DE:  MOVFF  729,8CE
053E2:  MOVLW  01
053E4:  MOVLB  8
053E6:  MOVWF  xCF
053E8:  MOVLB  0
053EA:  RCALL  5214
053EC:  MOVLW  2F
053EE:  MOVLB  8
053F0:  MOVWF  xE0
053F2:  MOVLB  0
053F4:  RCALL  5032
053F6:  MOVFF  72B,8CE
053FA:  MOVLW  01
053FC:  MOVLB  8
053FE:  MOVWF  xCF
05400:  MOVLB  0
05402:  RCALL  5214
05404:  MOVLW  20
05406:  MOVLB  8
05408:  MOVWF  xE0
0540A:  MOVLB  0
0540C:  RCALL  5032
0540E:  MOVFF  727,8CE
05412:  MOVLW  01
05414:  MOVLB  8
05416:  MOVWF  xCF
05418:  MOVLB  0
0541A:  RCALL  5214
0541C:  MOVLW  3A
0541E:  MOVLB  8
05420:  MOVWF  xE0
05422:  MOVLB  0
05424:  RCALL  5032
05426:  MOVFF  726,8CE
0542A:  MOVLW  01
0542C:  MOVLB  8
0542E:  MOVWF  xCF
05430:  MOVLB  0
05432:  RCALL  5214
05434:  MOVLW  3A
05436:  MOVLB  8
05438:  MOVWF  xE0
0543A:  MOVLB  0
0543C:  RCALL  5032
0543E:  MOVFF  725,8CE
05442:  MOVLW  01
05444:  MOVLB  8
05446:  MOVWF  xCF
05448:  MOVLB  0
0544A:  RCALL  5214
0544C:  MOVLW  2C
0544E:  MOVLB  8
05450:  MOVWF  xE0
05452:  MOVLB  0
05454:  RCALL  5032
05456:  MOVLW  44
05458:  MOVWF  FE9
0545A:  MOVLB  8
0545C:  CLRF   xD1
0545E:  CLRF   xD0
05460:  MOVFF  8CD,8CF
05464:  MOVFF  8CC,8CE
05468:  MOVLW  02
0546A:  MOVWF  xD2
0546C:  MOVLB  0
0546E:  RCALL  52AE
05470:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
08436:  MOVLB  2
08438:  MOVF   xDC,F
0843A:  BNZ   84B6
....................    { 
....................       strcopy(event_buffer,""); 
0843C:  MOVLW  01
0843E:  MOVWF  FEA
08440:  MOVLW  07
08442:  MOVWF  FE9
08444:  MOVLW  00
08446:  MOVLB  0
08448:  CALL   02CE
0844C:  TBLRD*-
0844E:  TBLRD*+
08450:  MOVF   FF5,W
08452:  MOVWF  FEE
08454:  IORLW  00
08456:  BNZ   844E
....................       time_stamp(); 
08458:  CALL   53AE
....................       strcat(event_buffer, time_stmp_str); 
0845C:  MOVLW  01
0845E:  MOVLB  8
08460:  MOVWF  xDA
08462:  MOVLW  07
08464:  MOVWF  xD9
08466:  MOVLW  02
08468:  MOVWF  xDC
0846A:  MOVLW  99
0846C:  MOVWF  xDB
0846E:  MOVLB  0
08470:  CALL   5472
....................       strcat(event_buffer, event_str); 
08474:  MOVLW  01
08476:  MOVLB  8
08478:  MOVWF  xDA
0847A:  MOVLW  07
0847C:  MOVWF  xD9
0847E:  MOVLW  01
08480:  MOVWF  xDC
08482:  MOVLW  A7
08484:  MOVWF  xDB
08486:  MOVLB  0
08488:  CALL   5472
....................       buffer_select = 1; 
0848C:  MOVLW  01
0848E:  MOVWF  x66
....................     
....................       heartbeat(FALSE); 
08490:  MOVLB  8
08492:  CLRF   xCE
08494:  MOVLB  0
08496:  CALL   5516
....................          append_data(file_ptr_events); 
0849A:  MOVLW  03
0849C:  MOVLB  8
0849E:  MOVWF  xCF
084A0:  MOVLW  15
084A2:  MOVWF  xCE
084A4:  MOVLB  0
084A6:  RCALL  8254
....................       heartbeat(TRUE); 
084A8:  MOVLW  01
084AA:  MOVLB  8
084AC:  MOVWF  xCE
084AE:  MOVLB  0
084B0:  CALL   5516
084B4:  MOVLB  2
....................    } 
084B6:  MOVLB  0
084B8:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
02860:  BCF    F8B.2
02862:  MOVLW  0C
02864:  MOVWF  FBB
02866:  CLRF   FBE
02868:  CLRF   FBF
0286A:  MOVLW  01
0286C:  MOVWF  F9C
0286E:  MOVLW  F8
02870:  MOVLB  F
02872:  ANDWF  x2D,F
02874:  MOVLW  00
02876:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
02878:  BCF    F8B.1
0287A:  MOVLW  0C
0287C:  MOVWF  x4E
0287E:  CLRF   x51
02880:  CLRF   x52
02882:  MOVLW  01
02884:  MOVWF  x1B
02886:  MOVLW  C7
02888:  ANDWF  x2D,F
0288A:  MOVLW  00
0288C:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
0288E:  IORLW  05
02890:  MOVWF  FCA
02892:  MOVLW  7F
02894:  MOVWF  FCB
02896:  MOVLB  0
02898:  GOTO   1B498 (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09C5E:  MOVLW  52
09C60:  MOVWF  FF6
09C62:  MOVLW  0F
09C64:  MOVWF  FF7
09C66:  MOVLW  00
09C68:  MOVWF  FF8
09C6A:  CLRF   1B
09C6C:  BTFSC  FF2.7
09C6E:  BSF    1B.7
09C70:  BCF    FF2.7
09C72:  MOVLW  05
09C74:  MOVLB  A
09C76:  MOVWF  x1C
09C78:  MOVLB  0
09C7A:  CALL   1024
09C7E:  BTFSC  1B.7
09C80:  BSF    FF2.7
09C82:  MOVLW  10
09C84:  MOVWF  FE9
09C86:  CLRF   1B
09C88:  BTFSC  FF2.7
09C8A:  BSF    1B.7
09C8C:  BCF    FF2.7
09C8E:  MOVFF  797,A1D
09C92:  MOVFF  796,A1C
09C96:  CALL   11A6
09C9A:  BTFSC  1B.7
09C9C:  BSF    FF2.7
09C9E:  MOVLW  2C
09CA0:  BTFSS  F9E.4
09CA2:  BRA    9CA0
09CA4:  MOVWF  FAD
09CA6:  MOVLW  10
09CA8:  MOVWF  FE9
09CAA:  CLRF   1B
09CAC:  BTFSC  FF2.7
09CAE:  BSF    1B.7
09CB0:  BCF    FF2.7
09CB2:  MOVFF  799,A1D
09CB6:  MOVFF  798,A1C
09CBA:  CALL   11A6
09CBE:  BTFSC  1B.7
09CC0:  BSF    FF2.7
09CC2:  MOVLW  0D
09CC4:  BTFSS  F9E.4
09CC6:  BRA    9CC4
09CC8:  MOVWF  FAD
09CCA:  MOVLW  0A
09CCC:  BTFSS  F9E.4
09CCE:  BRA    9CCC
09CD0:  MOVWF  FAD
09CD2:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02CB6:  MOVLW  86
02CB8:  MOVLB  8
02CBA:  MOVWF  x78
02CBC:  MOVLB  0
02CBE:  RCALL  2966
02CC0:  MOVFF  02,743
02CC4:  MOVFF  01,742
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02CC8:  MOVLW  8A
02CCA:  MOVLB  8
02CCC:  MOVWF  x78
02CCE:  MOVLB  0
02CD0:  RCALL  2966
02CD2:  MOVFF  02,747
02CD6:  MOVFF  01,746
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02CDA:  MOVLW  8E
02CDC:  MOVLB  8
02CDE:  MOVWF  x78
02CE0:  MOVLB  0
02CE2:  RCALL  2966
02CE4:  MOVFF  02,74B
02CE8:  MOVFF  01,74A
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02CEC:  MOVLW  92
02CEE:  MOVLB  8
02CF0:  MOVWF  x78
02CF2:  MOVLB  0
02CF4:  RCALL  2966
02CF6:  MOVFF  02,74F
02CFA:  MOVFF  01,74E
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02CFE:  MOVLW  96
02D00:  MOVLB  8
02D02:  MOVWF  x78
02D04:  MOVLB  0
02D06:  RCALL  2966
02D08:  MOVFF  02,753
02D0C:  MOVFF  01,752
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02D10:  MOVLW  9A
02D12:  MOVLB  8
02D14:  MOVWF  x78
02D16:  MOVLB  0
02D18:  RCALL  2966
02D1A:  MOVFF  02,757
02D1E:  MOVFF  01,756
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02D22:  MOVLW  9E
02D24:  MOVLB  8
02D26:  MOVWF  x78
02D28:  MOVLB  0
02D2A:  RCALL  2966
02D2C:  MOVFF  02,75B
02D30:  MOVFF  01,75A
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02D34:  MOVLW  A2
02D36:  MOVLB  8
02D38:  MOVWF  x78
02D3A:  MOVLB  0
02D3C:  RCALL  2966
02D3E:  MOVFF  02,75F
02D42:  MOVFF  01,75E
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02D46:  MOVLW  A6
02D48:  MOVLB  8
02D4A:  MOVWF  x78
02D4C:  MOVLB  0
02D4E:  RCALL  2966
02D50:  MOVFF  02,763
02D54:  MOVFF  01,762
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02D58:  MOVLW  82
02D5A:  MOVLB  8
02D5C:  MOVWF  x78
02D5E:  MOVLB  0
02D60:  RCALL  2966
02D62:  MOVFF  02,767
02D66:  MOVFF  01,766
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02D6A:  MOVLW  7E
02D6C:  MOVLB  8
02D6E:  MOVWF  x78
02D70:  MOVLB  0
02D72:  RCALL  2966
02D74:  MOVFF  02,7C0
02D78:  MOVFF  01,7BF
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02D7C:  MOVLW  AA
02D7E:  MOVLB  8
02D80:  MOVWF  x78
02D82:  MOVLB  0
02D84:  RCALL  2966
02D86:  MOVFF  02,7C4
02D8A:  MOVFF  01,7C3
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02D8E:  MOVLW  7A
02D90:  MOVLB  8
02D92:  MOVWF  x78
02D94:  MOVLB  0
02D96:  RCALL  2966
02D98:  MOVFF  02,76B
02D9C:  MOVFF  01,76A
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02DA0:  MOVLW  76
02DA2:  MOVLB  8
02DA4:  MOVWF  x78
02DA6:  MOVLB  0
02DA8:  RCALL  2966
02DAA:  MOVFF  02,76F
02DAE:  MOVFF  01,76E
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02DB2:  MOVLW  72
02DB4:  MOVLB  8
02DB6:  MOVWF  x78
02DB8:  MOVLB  0
02DBA:  RCALL  2966
02DBC:  MOVFF  02,773
02DC0:  MOVFF  01,772
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02DC4:  MOVLW  6E
02DC6:  MOVLB  8
02DC8:  MOVWF  x78
02DCA:  MOVLB  0
02DCC:  RCALL  2966
02DCE:  MOVFF  02,797
02DD2:  MOVFF  01,796
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02DD6:  MOVLW  AE
02DD8:  MOVLB  8
02DDA:  MOVWF  x78
02DDC:  MOVLB  0
02DDE:  RCALL  2966
02DE0:  MOVFF  02,777
02DE4:  MOVFF  01,776
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02DE8:  MOVLW  B2
02DEA:  MOVLB  8
02DEC:  MOVWF  x78
02DEE:  MOVLB  0
02DF0:  RCALL  2966
02DF2:  MOVFF  02,7B0
02DF6:  MOVFF  01,7AF
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02DFA:  MOVLW  B6
02DFC:  MOVLB  8
02DFE:  MOVWF  x78
02E00:  MOVLB  0
02E02:  RCALL  2966
02E04:  MOVFF  02,7B4
02E08:  MOVFF  01,7B3
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02E0C:  MOVLW  BA
02E0E:  MOVLB  8
02E10:  MOVWF  x78
02E12:  MOVLB  0
02E14:  RCALL  2966
02E16:  MOVFF  02,77B
02E1A:  MOVFF  01,77A
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02E1E:  MOVLW  BE
02E20:  MOVLB  8
02E22:  MOVWF  x78
02E24:  MOVLB  0
02E26:  RCALL  2966
02E28:  MOVFF  02,77F
02E2C:  MOVFF  01,77E
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02E30:  MOVLW  C2
02E32:  MOVLB  8
02E34:  MOVWF  x78
02E36:  MOVLB  0
02E38:  RCALL  2966
02E3A:  MOVFF  02,783
02E3E:  MOVFF  01,782
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02E42:  MOVLW  88
02E44:  MOVLB  8
02E46:  MOVWF  x78
02E48:  MOVLB  0
02E4A:  RCALL  2966
02E4C:  MOVFF  02,745
02E50:  MOVFF  01,744
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02E54:  MOVLW  8C
02E56:  MOVLB  8
02E58:  MOVWF  x78
02E5A:  MOVLB  0
02E5C:  RCALL  2966
02E5E:  MOVFF  02,749
02E62:  MOVFF  01,748
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02E66:  MOVLW  90
02E68:  MOVLB  8
02E6A:  MOVWF  x78
02E6C:  MOVLB  0
02E6E:  RCALL  2966
02E70:  MOVFF  02,74D
02E74:  MOVFF  01,74C
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02E78:  MOVLW  94
02E7A:  MOVLB  8
02E7C:  MOVWF  x78
02E7E:  MOVLB  0
02E80:  RCALL  2966
02E82:  MOVFF  02,751
02E86:  MOVFF  01,750
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02E8A:  MOVLW  98
02E8C:  MOVLB  8
02E8E:  MOVWF  x78
02E90:  MOVLB  0
02E92:  RCALL  2966
02E94:  MOVFF  02,755
02E98:  MOVFF  01,754
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02E9C:  MOVLW  9C
02E9E:  MOVLB  8
02EA0:  MOVWF  x78
02EA2:  MOVLB  0
02EA4:  RCALL  2966
02EA6:  MOVFF  02,759
02EAA:  MOVFF  01,758
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02EAE:  MOVLW  A0
02EB0:  MOVLB  8
02EB2:  MOVWF  x78
02EB4:  MOVLB  0
02EB6:  RCALL  2966
02EB8:  MOVFF  02,75D
02EBC:  MOVFF  01,75C
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02EC0:  MOVLW  A4
02EC2:  MOVLB  8
02EC4:  MOVWF  x78
02EC6:  MOVLB  0
02EC8:  RCALL  2966
02ECA:  MOVFF  02,761
02ECE:  MOVFF  01,760
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02ED2:  MOVLW  A8
02ED4:  MOVLB  8
02ED6:  MOVWF  x78
02ED8:  MOVLB  0
02EDA:  RCALL  2966
02EDC:  MOVFF  02,765
02EE0:  MOVFF  01,764
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02EE4:  MOVLW  84
02EE6:  MOVLB  8
02EE8:  MOVWF  x78
02EEA:  MOVLB  0
02EEC:  RCALL  2966
02EEE:  MOVFF  02,769
02EF2:  MOVFF  01,768
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02EF6:  MOVLW  80
02EF8:  MOVLB  8
02EFA:  MOVWF  x78
02EFC:  MOVLB  0
02EFE:  RCALL  2966
02F00:  MOVFF  02,7C2
02F04:  MOVFF  01,7C1
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02F08:  MOVLW  AC
02F0A:  MOVLB  8
02F0C:  MOVWF  x78
02F0E:  MOVLB  0
02F10:  RCALL  2966
02F12:  MOVFF  02,7C6
02F16:  MOVFF  01,7C5
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02F1A:  MOVLW  7C
02F1C:  MOVLB  8
02F1E:  MOVWF  x78
02F20:  MOVLB  0
02F22:  RCALL  2966
02F24:  MOVFF  02,76D
02F28:  MOVFF  01,76C
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02F2C:  MOVLW  78
02F2E:  MOVLB  8
02F30:  MOVWF  x78
02F32:  MOVLB  0
02F34:  RCALL  2966
02F36:  MOVFF  02,771
02F3A:  MOVFF  01,770
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02F3E:  MOVLW  74
02F40:  MOVLB  8
02F42:  MOVWF  x78
02F44:  MOVLB  0
02F46:  RCALL  2966
02F48:  MOVFF  02,775
02F4C:  MOVFF  01,774
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
02F50:  MOVLW  70
02F52:  MOVLB  8
02F54:  MOVWF  x78
02F56:  MOVLB  0
02F58:  RCALL  2966
02F5A:  MOVFF  02,799
02F5E:  MOVFF  01,798
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
02F62:  MOVLW  B0
02F64:  MOVLB  8
02F66:  MOVWF  x78
02F68:  MOVLB  0
02F6A:  RCALL  2966
02F6C:  MOVFF  02,779
02F70:  MOVFF  01,778
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
02F74:  MOVLW  B4
02F76:  MOVLB  8
02F78:  MOVWF  x78
02F7A:  MOVLB  0
02F7C:  RCALL  2966
02F7E:  MOVFF  02,7B2
02F82:  MOVFF  01,7B1
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
02F86:  MOVLW  B8
02F88:  MOVLB  8
02F8A:  MOVWF  x78
02F8C:  MOVLB  0
02F8E:  RCALL  2966
02F90:  MOVFF  02,7B6
02F94:  MOVFF  01,7B5
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
02F98:  MOVLW  BC
02F9A:  MOVLB  8
02F9C:  MOVWF  x78
02F9E:  MOVLB  0
02FA0:  RCALL  2966
02FA2:  MOVFF  02,77D
02FA6:  MOVFF  01,77C
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
02FAA:  MOVLW  C0
02FAC:  MOVLB  8
02FAE:  MOVWF  x78
02FB0:  MOVLB  0
02FB2:  RCALL  2966
02FB4:  MOVFF  02,781
02FB8:  MOVFF  01,780
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
02FBC:  MOVLW  C4
02FBE:  MOVLB  8
02FC0:  MOVWF  x78
02FC2:  MOVLB  0
02FC4:  RCALL  2966
02FC6:  MOVFF  02,785
02FCA:  MOVFF  01,784
....................     
....................    motor=0; 
02FCE:  MOVLB  7
02FD0:  CLRF   x40
....................    m_fixed=1; 
02FD2:  MOVLW  01
02FD4:  MOVWF  x41
....................    m_step_cnt[0]=0; 
02FD6:  CLRF   xA5
02FD8:  CLRF   xA4
02FDA:  CLRF   xA3
02FDC:  CLRF   xA2
....................    m_step_cnt[1]=0; 
02FDE:  CLRF   xA9
02FE0:  CLRF   xA8
02FE2:  CLRF   xA7
02FE4:  CLRF   xA6
....................    e_cha_cnt[0]=0; 
02FE6:  CLRF   xBC
02FE8:  CLRF   xBB
....................    e_cha_cnt[1]=0;  
02FEA:  CLRF   xBE
02FEC:  CLRF   xBD
....................    m_gb_cnt[0]=0; 
02FEE:  CLRF   x9B
02FF0:  CLRF   x9A
....................    m_gb_cnt[1]=0; 
02FF2:  CLRF   x9D
02FF4:  CLRF   x9C
....................    e_mode_rst[0]=0; 
02FF6:  CLRF   x9F
02FF8:  CLRF   x9E
....................    e_mode_rst[1]=0;    
02FFA:  CLRF   xA1
02FFC:  CLRF   xA0
....................    e_port_dist[0]=0; 
02FFE:  CLRF   xB8
03000:  CLRF   xB7
....................    e_port_dist[1]=0; 
03002:  CLRF   xBA
03004:  CLRF   xB9
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
03006:  MOVFF  777,8BD
0300A:  MOVFF  776,8BC
0300E:  MOVFF  763,8BF
03012:  MOVFF  762,8BE
03016:  MOVLB  0
03018:  RCALL  2C70
0301A:  BCF    FD8.0
0301C:  MOVLB  8
0301E:  RLCF   01,W
03020:  MOVLB  7
03022:  MOVWF  xAB
03024:  MOVLB  8
03026:  RLCF   02,W
03028:  MOVLB  7
0302A:  MOVWF  xAC
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
0302C:  MOVFF  779,8BD
03030:  MOVFF  778,8BC
03034:  MOVFF  765,8BF
03038:  MOVFF  764,8BE
0303C:  MOVLB  0
0303E:  RCALL  2C70
03040:  BCF    FD8.0
03042:  MOVLB  8
03044:  RLCF   01,W
03046:  MOVLB  7
03048:  MOVWF  xAD
0304A:  MOVLB  8
0304C:  RLCF   02,W
0304E:  MOVLB  7
03050:  MOVWF  xAE
03052:  MOVLB  0
03054:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
19D96:  MOVLW  86
19D98:  MOVLB  8
19D9A:  MOVWF  xCF
19D9C:  CLRF   xD1
19D9E:  MOVLW  01
19DA0:  MOVWF  xD0
19DA2:  MOVLB  0
19DA4:  CALL   4F68
....................    write16(ADDR_M1_MODE,FULL); 
19DA8:  MOVLW  8A
19DAA:  MOVLB  8
19DAC:  MOVWF  xCF
19DAE:  CLRF   xD1
19DB0:  CLRF   xD0
19DB2:  MOVLB  0
19DB4:  CALL   4F68
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
19DB8:  MOVLW  8E
19DBA:  MOVLB  8
19DBC:  MOVWF  xCF
19DBE:  CLRF   xD1
19DC0:  MOVLW  0A
19DC2:  MOVWF  xD0
19DC4:  MOVLB  0
19DC6:  CALL   4F68
....................    write16(ADDR_M1_POS_DIR,0); 
19DCA:  MOVLW  92
19DCC:  MOVLB  8
19DCE:  MOVWF  xCF
19DD0:  CLRF   xD1
19DD2:  CLRF   xD0
19DD4:  MOVLB  0
19DD6:  CALL   4F68
....................    write16(ADDR_M1_PWM_HLD,0); 
19DDA:  MOVLW  96
19DDC:  MOVLB  8
19DDE:  MOVWF  xCF
19DE0:  CLRF   xD1
19DE2:  CLRF   xD0
19DE4:  MOVLB  0
19DE6:  CALL   4F68
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
19DEA:  MOVLW  9A
19DEC:  MOVLB  8
19DEE:  MOVWF  xCF
19DF0:  CLRF   xD1
19DF2:  MOVLW  7F
19DF4:  MOVWF  xD0
19DF6:  MOVLB  0
19DF8:  CALL   4F68
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
19DFC:  MOVLW  9E
19DFE:  MOVLB  8
19E00:  MOVWF  xCF
19E02:  MOVLW  17
19E04:  MOVWF  xD1
19E06:  MOVLW  70
19E08:  MOVWF  xD0
19E0A:  MOVLB  0
19E0C:  CALL   4F68
....................    write16(ADDR_E1_CPR,16); 
19E10:  MOVLW  A2
19E12:  MOVLB  8
19E14:  MOVWF  xCF
19E16:  CLRF   xD1
19E18:  MOVLW  10
19E1A:  MOVWF  xD0
19E1C:  MOVLB  0
19E1E:  CALL   4F68
....................    write16(ADDR_E1_PPR,16); 
19E22:  MOVLW  A6
19E24:  MOVLB  8
19E26:  MOVWF  xCF
19E28:  CLRF   xD1
19E2A:  MOVLW  10
19E2C:  MOVWF  xD0
19E2E:  MOVLB  0
19E30:  CALL   4F68
....................    write16(ADDR_E1_MODE,2); 
19E34:  MOVLW  82
19E36:  MOVLB  8
19E38:  MOVWF  xCF
19E3A:  CLRF   xD1
19E3C:  MOVLW  02
19E3E:  MOVWF  xD0
19E40:  MOVLB  0
19E42:  CALL   4F68
....................    write16(ADDR_E1_POS,0); 
19E46:  MOVLW  7E
19E48:  MOVLB  8
19E4A:  MOVWF  xCF
19E4C:  CLRF   xD1
19E4E:  CLRF   xD0
19E50:  MOVLB  0
19E52:  CALL   4F68
....................    write16(ADDR_E1_PORT,0); 
19E56:  MOVLW  AA
19E58:  MOVLB  8
19E5A:  MOVWF  xCF
19E5C:  CLRF   xD1
19E5E:  CLRF   xD0
19E60:  MOVLB  0
19E62:  CALL   4F68
....................    write16(ADDR_E1_TYPE,2); 
19E66:  MOVLW  7A
19E68:  MOVLB  8
19E6A:  MOVWF  xCF
19E6C:  CLRF   xD1
19E6E:  MOVLW  02
19E70:  MOVWF  xD0
19E72:  MOVLB  0
19E74:  CALL   4F68
....................    write16(ADDR_M1_RUN,270); 
19E78:  MOVLW  76
19E7A:  MOVLB  8
19E7C:  MOVWF  xCF
19E7E:  MOVLW  01
19E80:  MOVWF  xD1
19E82:  MOVLW  0E
19E84:  MOVWF  xD0
19E86:  MOVLB  0
19E88:  CALL   4F68
....................    write16(ADDR_M1_BKLSH,0); 
19E8C:  MOVLW  72
19E8E:  MOVLB  8
19E90:  MOVWF  xCF
19E92:  CLRF   xD1
19E94:  CLRF   xD0
19E96:  MOVLB  0
19E98:  CALL   4F68
....................    write16(ADDR_M1_ERROR,0);   
19E9C:  MOVLW  6E
19E9E:  MOVLB  8
19EA0:  MOVWF  xCF
19EA2:  CLRF   xD1
19EA4:  CLRF   xD0
19EA6:  MOVLB  0
19EA8:  CALL   4F68
....................    write16(ADDR_M1_SPR,38400); 
19EAC:  MOVLW  AE
19EAE:  MOVLB  8
19EB0:  MOVWF  xCF
19EB2:  MOVLW  96
19EB4:  MOVWF  xD1
19EB6:  CLRF   xD0
19EB8:  MOVLB  0
19EBA:  CALL   4F68
....................    write16(ADDR_M1_COMP,0); 
19EBE:  MOVLW  B2
19EC0:  MOVLB  8
19EC2:  MOVWF  xCF
19EC4:  CLRF   xD1
19EC6:  CLRF   xD0
19EC8:  MOVLB  0
19ECA:  CALL   4F68
....................    write16(ADDR_M1_LIN_POS,0); 
19ECE:  MOVLW  B6
19ED0:  MOVLB  8
19ED2:  MOVWF  xCF
19ED4:  CLRF   xD1
19ED6:  CLRF   xD0
19ED8:  MOVLB  0
19EDA:  CALL   4F68
....................    write16(ADDR_E1_INDEX,1); 
19EDE:  MOVLW  BA
19EE0:  MOVLB  8
19EE2:  MOVWF  xCF
19EE4:  CLRF   xD1
19EE6:  MOVLW  01
19EE8:  MOVWF  xD0
19EEA:  MOVLB  0
19EEC:  CALL   4F68
....................    write16(ADDR_M1_EVN_SO,0); 
19EF0:  MOVLW  BE
19EF2:  MOVLB  8
19EF4:  MOVWF  xCF
19EF6:  CLRF   xD1
19EF8:  CLRF   xD0
19EFA:  MOVLB  0
19EFC:  CALL   4F68
....................    write16(ADDR_M1_ALIGN_OS,0); 
19F00:  MOVLW  C2
19F02:  MOVLB  8
19F04:  MOVWF  xCF
19F06:  CLRF   xD1
19F08:  CLRF   xD0
19F0A:  MOVLB  0
19F0C:  CALL   4F68
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
19F10:  MOVLW  88
19F12:  MOVLB  8
19F14:  MOVWF  xCF
19F16:  CLRF   xD1
19F18:  MOVLW  01
19F1A:  MOVWF  xD0
19F1C:  MOVLB  0
19F1E:  CALL   4F68
....................    write16(ADDR_M2_MODE,HALF); 
19F22:  MOVLW  8C
19F24:  MOVLB  8
19F26:  MOVWF  xCF
19F28:  CLRF   xD1
19F2A:  MOVLW  01
19F2C:  MOVWF  xD0
19F2E:  MOVLB  0
19F30:  CALL   4F68
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
19F34:  MOVLW  90
19F36:  MOVLB  8
19F38:  MOVWF  xCF
19F3A:  CLRF   xD1
19F3C:  MOVLW  05
19F3E:  MOVWF  xD0
19F40:  MOVLB  0
19F42:  CALL   4F68
....................    write16(ADDR_M2_POS_DIR,0); 
19F46:  MOVLW  94
19F48:  MOVLB  8
19F4A:  MOVWF  xCF
19F4C:  CLRF   xD1
19F4E:  CLRF   xD0
19F50:  MOVLB  0
19F52:  CALL   4F68
....................    write16(ADDR_M2_PWM_HLD,0); 
19F56:  MOVLW  98
19F58:  MOVLB  8
19F5A:  MOVWF  xCF
19F5C:  CLRF   xD1
19F5E:  CLRF   xD0
19F60:  MOVLB  0
19F62:  CALL   4F68
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
19F66:  MOVLW  9C
19F68:  MOVLB  8
19F6A:  MOVWF  xCF
19F6C:  CLRF   xD1
19F6E:  MOVLW  7F
19F70:  MOVWF  xD0
19F72:  MOVLB  0
19F74:  CALL   4F68
....................    write16(ADDR_M2_GB_ERR,0); 
19F78:  MOVLW  A0
19F7A:  MOVLB  8
19F7C:  MOVWF  xCF
19F7E:  CLRF   xD1
19F80:  CLRF   xD0
19F82:  MOVLB  0
19F84:  CALL   4F68
....................    write16(ADDR_E2_CPR,0); 
19F88:  MOVLW  A4
19F8A:  MOVLB  8
19F8C:  MOVWF  xCF
19F8E:  CLRF   xD1
19F90:  CLRF   xD0
19F92:  MOVLB  0
19F94:  CALL   4F68
....................    write16(ADDR_E2_PPR,0);   
19F98:  MOVLW  A8
19F9A:  MOVLB  8
19F9C:  MOVWF  xCF
19F9E:  CLRF   xD1
19FA0:  CLRF   xD0
19FA2:  MOVLB  0
19FA4:  CALL   4F68
....................    write16(ADDR_E2_MODE,0); 
19FA8:  MOVLW  84
19FAA:  MOVLB  8
19FAC:  MOVWF  xCF
19FAE:  CLRF   xD1
19FB0:  CLRF   xD0
19FB2:  MOVLB  0
19FB4:  CALL   4F68
....................    write16(ADDR_E2_POS,0); 
19FB8:  MOVLW  80
19FBA:  MOVLB  8
19FBC:  MOVWF  xCF
19FBE:  CLRF   xD1
19FC0:  CLRF   xD0
19FC2:  MOVLB  0
19FC4:  CALL   4F68
....................    write16(ADDR_E2_PORT,0); 
19FC8:  MOVLW  AC
19FCA:  MOVLB  8
19FCC:  MOVWF  xCF
19FCE:  CLRF   xD1
19FD0:  CLRF   xD0
19FD2:  MOVLB  0
19FD4:  CALL   4F68
....................    write16(ADDR_E2_TYPE,0); 
19FD8:  MOVLW  7C
19FDA:  MOVLB  8
19FDC:  MOVWF  xCF
19FDE:  CLRF   xD1
19FE0:  CLRF   xD0
19FE2:  MOVLB  0
19FE4:  CALL   4F68
....................    write16(ADDR_M2_RUN,0); 
19FE8:  MOVLW  78
19FEA:  MOVLB  8
19FEC:  MOVWF  xCF
19FEE:  CLRF   xD1
19FF0:  CLRF   xD0
19FF2:  MOVLB  0
19FF4:  CALL   4F68
....................    write16(ADDR_M2_BKLSH,0); 
19FF8:  MOVLW  74
19FFA:  MOVLB  8
19FFC:  MOVWF  xCF
19FFE:  CLRF   xD1
1A000:  CLRF   xD0
1A002:  MOVLB  0
1A004:  CALL   4F68
....................    write16(ADDR_M2_ERROR,0);   
1A008:  MOVLW  70
1A00A:  MOVLB  8
1A00C:  MOVWF  xCF
1A00E:  CLRF   xD1
1A010:  CLRF   xD0
1A012:  MOVLB  0
1A014:  CALL   4F68
....................    write16(ADDR_M2_SPR,0); 
1A018:  MOVLW  B0
1A01A:  MOVLB  8
1A01C:  MOVWF  xCF
1A01E:  CLRF   xD1
1A020:  CLRF   xD0
1A022:  MOVLB  0
1A024:  CALL   4F68
....................    write16(ADDR_M2_COMP,0); 
1A028:  MOVLW  B4
1A02A:  MOVLB  8
1A02C:  MOVWF  xCF
1A02E:  CLRF   xD1
1A030:  CLRF   xD0
1A032:  MOVLB  0
1A034:  CALL   4F68
....................    write16(ADDR_M2_LIN_POS,0);    
1A038:  MOVLW  B8
1A03A:  MOVLB  8
1A03C:  MOVWF  xCF
1A03E:  CLRF   xD1
1A040:  CLRF   xD0
1A042:  MOVLB  0
1A044:  CALL   4F68
....................    write16(ADDR_E2_INDEX,0); 
1A048:  MOVLW  BC
1A04A:  MOVLB  8
1A04C:  MOVWF  xCF
1A04E:  CLRF   xD1
1A050:  CLRF   xD0
1A052:  MOVLB  0
1A054:  CALL   4F68
....................    write16(ADDR_M2_EVN_SO,0); 
1A058:  MOVLW  C0
1A05A:  MOVLB  8
1A05C:  MOVWF  xCF
1A05E:  CLRF   xD1
1A060:  CLRF   xD0
1A062:  MOVLB  0
1A064:  CALL   4F68
....................    write16(ADDR_M2_ALIGN_OS,0); 
1A068:  MOVLW  C4
1A06A:  MOVLB  8
1A06C:  MOVWF  xCF
1A06E:  CLRF   xD1
1A070:  CLRF   xD0
1A072:  MOVLB  0
1A074:  CALL   4F68
....................     
....................    get_step_vars(); 
1A078:  CALL   2CB6
1A07C:  GOTO   1A8C6 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A080:  MOVLW  86
1A082:  MOVLB  8
1A084:  MOVWF  xCF
1A086:  CLRF   xD1
1A088:  MOVLW  01
1A08A:  MOVWF  xD0
1A08C:  MOVLB  0
1A08E:  CALL   4F68
....................    write16(ADDR_M1_MODE,FULL); 
1A092:  MOVLW  8A
1A094:  MOVLB  8
1A096:  MOVWF  xCF
1A098:  CLRF   xD1
1A09A:  CLRF   xD0
1A09C:  MOVLB  0
1A09E:  CALL   4F68
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
1A0A2:  MOVLW  8E
1A0A4:  MOVLB  8
1A0A6:  MOVWF  xCF
1A0A8:  CLRF   xD1
1A0AA:  MOVLW  14
1A0AC:  MOVWF  xD0
1A0AE:  MOVLB  0
1A0B0:  CALL   4F68
....................    write16(ADDR_M1_POS_DIR,1); 
1A0B4:  MOVLW  92
1A0B6:  MOVLB  8
1A0B8:  MOVWF  xCF
1A0BA:  CLRF   xD1
1A0BC:  MOVLW  01
1A0BE:  MOVWF  xD0
1A0C0:  MOVLB  0
1A0C2:  CALL   4F68
....................    write16(ADDR_M1_PWM_HLD,51); 
1A0C6:  MOVLW  96
1A0C8:  MOVLB  8
1A0CA:  MOVWF  xCF
1A0CC:  CLRF   xD1
1A0CE:  MOVLW  33
1A0D0:  MOVWF  xD0
1A0D2:  MOVLB  0
1A0D4:  CALL   4F68
....................    write16(ADDR_M1_PWM_DRV,511); 
1A0D8:  MOVLW  9A
1A0DA:  MOVLB  8
1A0DC:  MOVWF  xCF
1A0DE:  MOVLW  01
1A0E0:  MOVWF  xD1
1A0E2:  SETF   xD0
1A0E4:  MOVLB  0
1A0E6:  CALL   4F68
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
1A0EA:  MOVLW  9E
1A0EC:  MOVLB  8
1A0EE:  MOVWF  xCF
1A0F0:  MOVLW  02
1A0F2:  MOVWF  xD1
1A0F4:  MOVLW  9E
1A0F6:  MOVWF  xD0
1A0F8:  MOVLB  0
1A0FA:  CALL   4F68
....................    write16(ADDR_E1_CPR,24); 
1A0FE:  MOVLW  A2
1A100:  MOVLB  8
1A102:  MOVWF  xCF
1A104:  CLRF   xD1
1A106:  MOVLW  18
1A108:  MOVWF  xD0
1A10A:  MOVLB  0
1A10C:  CALL   4F68
....................    write16(ADDR_E1_PPR,48); 
1A110:  MOVLW  A6
1A112:  MOVLB  8
1A114:  MOVWF  xCF
1A116:  CLRF   xD1
1A118:  MOVLW  30
1A11A:  MOVWF  xD0
1A11C:  MOVLB  0
1A11E:  CALL   4F68
....................    write16(ADDR_E1_MODE,2); 
1A122:  MOVLW  82
1A124:  MOVLB  8
1A126:  MOVWF  xCF
1A128:  CLRF   xD1
1A12A:  MOVLW  02
1A12C:  MOVWF  xD0
1A12E:  MOVLB  0
1A130:  CALL   4F68
....................    write16(ADDR_E1_POS,0); 
1A134:  MOVLW  7E
1A136:  MOVLB  8
1A138:  MOVWF  xCF
1A13A:  CLRF   xD1
1A13C:  CLRF   xD0
1A13E:  MOVLB  0
1A140:  CALL   4F68
....................    write16(ADDR_E1_PORT,0); 
1A144:  MOVLW  AA
1A146:  MOVLB  8
1A148:  MOVWF  xCF
1A14A:  CLRF   xD1
1A14C:  CLRF   xD0
1A14E:  MOVLB  0
1A150:  CALL   4F68
....................    write16(ADDR_E1_TYPE,2); 
1A154:  MOVLW  7A
1A156:  MOVLB  8
1A158:  MOVWF  xCF
1A15A:  CLRF   xD1
1A15C:  MOVLW  02
1A15E:  MOVWF  xD0
1A160:  MOVLB  0
1A162:  CALL   4F68
....................    write16(ADDR_M1_RUN,34); 
1A166:  MOVLW  76
1A168:  MOVLB  8
1A16A:  MOVWF  xCF
1A16C:  CLRF   xD1
1A16E:  MOVLW  22
1A170:  MOVWF  xD0
1A172:  MOVLB  0
1A174:  CALL   4F68
....................    write16(ADDR_M1_BKLSH,0); 
1A178:  MOVLW  72
1A17A:  MOVLB  8
1A17C:  MOVWF  xCF
1A17E:  CLRF   xD1
1A180:  CLRF   xD0
1A182:  MOVLB  0
1A184:  CALL   4F68
....................    write16(ADDR_M1_ERROR,0);   
1A188:  MOVLW  6E
1A18A:  MOVLB  8
1A18C:  MOVWF  xCF
1A18E:  CLRF   xD1
1A190:  CLRF   xD0
1A192:  MOVLB  0
1A194:  CALL   4F68
....................    write16(ADDR_M1_SPR,6400); 
1A198:  MOVLW  AE
1A19A:  MOVLB  8
1A19C:  MOVWF  xCF
1A19E:  MOVLW  19
1A1A0:  MOVWF  xD1
1A1A2:  CLRF   xD0
1A1A4:  MOVLB  0
1A1A6:  CALL   4F68
....................    write16(ADDR_M1_COMP,0); 
1A1AA:  MOVLW  B2
1A1AC:  MOVLB  8
1A1AE:  MOVWF  xCF
1A1B0:  CLRF   xD1
1A1B2:  CLRF   xD0
1A1B4:  MOVLB  0
1A1B6:  CALL   4F68
....................    write16(ADDR_M1_LIN_POS,0); 
1A1BA:  MOVLW  B6
1A1BC:  MOVLB  8
1A1BE:  MOVWF  xCF
1A1C0:  CLRF   xD1
1A1C2:  CLRF   xD0
1A1C4:  MOVLB  0
1A1C6:  CALL   4F68
....................    write16(ADDR_E1_INDEX,1);    
1A1CA:  MOVLW  BA
1A1CC:  MOVLB  8
1A1CE:  MOVWF  xCF
1A1D0:  CLRF   xD1
1A1D2:  MOVLW  01
1A1D4:  MOVWF  xD0
1A1D6:  MOVLB  0
1A1D8:  CALL   4F68
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A1DC:  MOVLW  88
1A1DE:  MOVLB  8
1A1E0:  MOVWF  xCF
1A1E2:  CLRF   xD1
1A1E4:  MOVLW  01
1A1E6:  MOVWF  xD0
1A1E8:  MOVLB  0
1A1EA:  CALL   4F68
....................    write16(ADDR_M2_MODE,HALF); 
1A1EE:  MOVLW  8C
1A1F0:  MOVLB  8
1A1F2:  MOVWF  xCF
1A1F4:  CLRF   xD1
1A1F6:  MOVLW  01
1A1F8:  MOVWF  xD0
1A1FA:  MOVLB  0
1A1FC:  CALL   4F68
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A200:  MOVLW  90
1A202:  MOVLB  8
1A204:  MOVWF  xCF
1A206:  CLRF   xD1
1A208:  MOVLW  28
1A20A:  MOVWF  xD0
1A20C:  MOVLB  0
1A20E:  CALL   4F68
....................    write16(ADDR_M2_POS_DIR,0); 
1A212:  MOVLW  94
1A214:  MOVLB  8
1A216:  MOVWF  xCF
1A218:  CLRF   xD1
1A21A:  CLRF   xD0
1A21C:  MOVLB  0
1A21E:  CALL   4F68
....................    write16(ADDR_M2_PWM_HLD,0); 
1A222:  MOVLW  98
1A224:  MOVLB  8
1A226:  MOVWF  xCF
1A228:  CLRF   xD1
1A22A:  CLRF   xD0
1A22C:  MOVLB  0
1A22E:  CALL   4F68
....................    write16(ADDR_M2_PWM_DRV,511); 
1A232:  MOVLW  9C
1A234:  MOVLB  8
1A236:  MOVWF  xCF
1A238:  MOVLW  01
1A23A:  MOVWF  xD1
1A23C:  SETF   xD0
1A23E:  MOVLB  0
1A240:  CALL   4F68
....................    write16(ADDR_M2_GB_ERR,0); 
1A244:  MOVLW  A0
1A246:  MOVLB  8
1A248:  MOVWF  xCF
1A24A:  CLRF   xD1
1A24C:  CLRF   xD0
1A24E:  MOVLB  0
1A250:  CALL   4F68
....................    write16(ADDR_E2_CPR,0); 
1A254:  MOVLW  A4
1A256:  MOVLB  8
1A258:  MOVWF  xCF
1A25A:  CLRF   xD1
1A25C:  CLRF   xD0
1A25E:  MOVLB  0
1A260:  CALL   4F68
....................    write16(ADDR_E2_PPR,0);   
1A264:  MOVLW  A8
1A266:  MOVLB  8
1A268:  MOVWF  xCF
1A26A:  CLRF   xD1
1A26C:  CLRF   xD0
1A26E:  MOVLB  0
1A270:  CALL   4F68
....................    write16(ADDR_E2_MODE,0); 
1A274:  MOVLW  84
1A276:  MOVLB  8
1A278:  MOVWF  xCF
1A27A:  CLRF   xD1
1A27C:  CLRF   xD0
1A27E:  MOVLB  0
1A280:  CALL   4F68
....................    write16(ADDR_E2_POS,0); 
1A284:  MOVLW  80
1A286:  MOVLB  8
1A288:  MOVWF  xCF
1A28A:  CLRF   xD1
1A28C:  CLRF   xD0
1A28E:  MOVLB  0
1A290:  CALL   4F68
....................    write16(ADDR_E2_PORT,0); 
1A294:  MOVLW  AC
1A296:  MOVLB  8
1A298:  MOVWF  xCF
1A29A:  CLRF   xD1
1A29C:  CLRF   xD0
1A29E:  MOVLB  0
1A2A0:  CALL   4F68
....................    write16(ADDR_E2_TYPE,0); 
1A2A4:  MOVLW  7C
1A2A6:  MOVLB  8
1A2A8:  MOVWF  xCF
1A2AA:  CLRF   xD1
1A2AC:  CLRF   xD0
1A2AE:  MOVLB  0
1A2B0:  CALL   4F68
....................    write16(ADDR_M2_RUN,0); 
1A2B4:  MOVLW  78
1A2B6:  MOVLB  8
1A2B8:  MOVWF  xCF
1A2BA:  CLRF   xD1
1A2BC:  CLRF   xD0
1A2BE:  MOVLB  0
1A2C0:  CALL   4F68
....................    write16(ADDR_M2_BKLSH,0); 
1A2C4:  MOVLW  74
1A2C6:  MOVLB  8
1A2C8:  MOVWF  xCF
1A2CA:  CLRF   xD1
1A2CC:  CLRF   xD0
1A2CE:  MOVLB  0
1A2D0:  CALL   4F68
....................    write16(ADDR_M2_ERROR,0);   
1A2D4:  MOVLW  70
1A2D6:  MOVLB  8
1A2D8:  MOVWF  xCF
1A2DA:  CLRF   xD1
1A2DC:  CLRF   xD0
1A2DE:  MOVLB  0
1A2E0:  CALL   4F68
....................    write16(ADDR_M2_SPR,0); 
1A2E4:  MOVLW  B0
1A2E6:  MOVLB  8
1A2E8:  MOVWF  xCF
1A2EA:  CLRF   xD1
1A2EC:  CLRF   xD0
1A2EE:  MOVLB  0
1A2F0:  CALL   4F68
....................    write16(ADDR_M2_COMP,0); 
1A2F4:  MOVLW  B4
1A2F6:  MOVLB  8
1A2F8:  MOVWF  xCF
1A2FA:  CLRF   xD1
1A2FC:  CLRF   xD0
1A2FE:  MOVLB  0
1A300:  CALL   4F68
....................    write16(ADDR_M2_LIN_POS,0);   
1A304:  MOVLW  B8
1A306:  MOVLB  8
1A308:  MOVWF  xCF
1A30A:  CLRF   xD1
1A30C:  CLRF   xD0
1A30E:  MOVLB  0
1A310:  CALL   4F68
....................    write16(ADDR_E2_INDEX,0);    
1A314:  MOVLW  BC
1A316:  MOVLB  8
1A318:  MOVWF  xCF
1A31A:  CLRF   xD1
1A31C:  CLRF   xD0
1A31E:  MOVLB  0
1A320:  CALL   4F68
....................     
....................    get_step_vars(); 
1A324:  CALL   2CB6
1A328:  GOTO   1A8C6 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A32C:  MOVLW  86
1A32E:  MOVLB  8
1A330:  MOVWF  xCF
1A332:  CLRF   xD1
1A334:  MOVLW  01
1A336:  MOVWF  xD0
1A338:  MOVLB  0
1A33A:  CALL   4F68
....................    write16(ADDR_M1_MODE,FULL); 
1A33E:  MOVLW  8A
1A340:  MOVLB  8
1A342:  MOVWF  xCF
1A344:  CLRF   xD1
1A346:  CLRF   xD0
1A348:  MOVLB  0
1A34A:  CALL   4F68
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A34E:  MOVLW  8E
1A350:  MOVLB  8
1A352:  MOVWF  xCF
1A354:  CLRF   xD1
1A356:  MOVLW  0A
1A358:  MOVWF  xD0
1A35A:  MOVLB  0
1A35C:  CALL   4F68
....................    write16(ADDR_M1_POS_DIR,0); 
1A360:  MOVLW  92
1A362:  MOVLB  8
1A364:  MOVWF  xCF
1A366:  CLRF   xD1
1A368:  CLRF   xD0
1A36A:  MOVLB  0
1A36C:  CALL   4F68
....................    write16(ADDR_M1_PWM_HLD,0); 
1A370:  MOVLW  96
1A372:  MOVLB  8
1A374:  MOVWF  xCF
1A376:  CLRF   xD1
1A378:  CLRF   xD0
1A37A:  MOVLB  0
1A37C:  CALL   4F68
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A380:  MOVLW  9A
1A382:  MOVLB  8
1A384:  MOVWF  xCF
1A386:  CLRF   xD1
1A388:  MOVLW  7F
1A38A:  MOVWF  xD0
1A38C:  MOVLB  0
1A38E:  CALL   4F68
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A392:  MOVLW  9E
1A394:  MOVLB  8
1A396:  MOVWF  xCF
1A398:  MOVLW  17
1A39A:  MOVWF  xD1
1A39C:  MOVLW  70
1A39E:  MOVWF  xD0
1A3A0:  MOVLB  0
1A3A2:  CALL   4F68
....................    write16(ADDR_E1_CPR,16); 
1A3A6:  MOVLW  A2
1A3A8:  MOVLB  8
1A3AA:  MOVWF  xCF
1A3AC:  CLRF   xD1
1A3AE:  MOVLW  10
1A3B0:  MOVWF  xD0
1A3B2:  MOVLB  0
1A3B4:  CALL   4F68
....................    write16(ADDR_E1_PPR,16); 
1A3B8:  MOVLW  A6
1A3BA:  MOVLB  8
1A3BC:  MOVWF  xCF
1A3BE:  CLRF   xD1
1A3C0:  MOVLW  10
1A3C2:  MOVWF  xD0
1A3C4:  MOVLB  0
1A3C6:  CALL   4F68
....................    write16(ADDR_E1_MODE,2); 
1A3CA:  MOVLW  82
1A3CC:  MOVLB  8
1A3CE:  MOVWF  xCF
1A3D0:  CLRF   xD1
1A3D2:  MOVLW  02
1A3D4:  MOVWF  xD0
1A3D6:  MOVLB  0
1A3D8:  CALL   4F68
....................    write16(ADDR_E1_POS,0); 
1A3DC:  MOVLW  7E
1A3DE:  MOVLB  8
1A3E0:  MOVWF  xCF
1A3E2:  CLRF   xD1
1A3E4:  CLRF   xD0
1A3E6:  MOVLB  0
1A3E8:  CALL   4F68
....................    write16(ADDR_E1_PORT,0); 
1A3EC:  MOVLW  AA
1A3EE:  MOVLB  8
1A3F0:  MOVWF  xCF
1A3F2:  CLRF   xD1
1A3F4:  CLRF   xD0
1A3F6:  MOVLB  0
1A3F8:  CALL   4F68
....................    write16(ADDR_E1_TYPE,2); 
1A3FC:  MOVLW  7A
1A3FE:  MOVLB  8
1A400:  MOVWF  xCF
1A402:  CLRF   xD1
1A404:  MOVLW  02
1A406:  MOVWF  xD0
1A408:  MOVLB  0
1A40A:  CALL   4F68
....................    write16(ADDR_M1_RUN,270); 
1A40E:  MOVLW  76
1A410:  MOVLB  8
1A412:  MOVWF  xCF
1A414:  MOVLW  01
1A416:  MOVWF  xD1
1A418:  MOVLW  0E
1A41A:  MOVWF  xD0
1A41C:  MOVLB  0
1A41E:  CALL   4F68
....................    write16(ADDR_M1_BKLSH,0); 
1A422:  MOVLW  72
1A424:  MOVLB  8
1A426:  MOVWF  xCF
1A428:  CLRF   xD1
1A42A:  CLRF   xD0
1A42C:  MOVLB  0
1A42E:  CALL   4F68
....................    write16(ADDR_M1_ERROR,0);   
1A432:  MOVLW  6E
1A434:  MOVLB  8
1A436:  MOVWF  xCF
1A438:  CLRF   xD1
1A43A:  CLRF   xD0
1A43C:  MOVLB  0
1A43E:  CALL   4F68
....................    write16(ADDR_M1_SPR,38400); 
1A442:  MOVLW  AE
1A444:  MOVLB  8
1A446:  MOVWF  xCF
1A448:  MOVLW  96
1A44A:  MOVWF  xD1
1A44C:  CLRF   xD0
1A44E:  MOVLB  0
1A450:  CALL   4F68
....................    write16(ADDR_M1_COMP,0); 
1A454:  MOVLW  B2
1A456:  MOVLB  8
1A458:  MOVWF  xCF
1A45A:  CLRF   xD1
1A45C:  CLRF   xD0
1A45E:  MOVLB  0
1A460:  CALL   4F68
....................    write16(ADDR_M1_LIN_POS,0); 
1A464:  MOVLW  B6
1A466:  MOVLB  8
1A468:  MOVWF  xCF
1A46A:  CLRF   xD1
1A46C:  CLRF   xD0
1A46E:  MOVLB  0
1A470:  CALL   4F68
....................    write16(ADDR_E1_INDEX,1); 
1A474:  MOVLW  BA
1A476:  MOVLB  8
1A478:  MOVWF  xCF
1A47A:  CLRF   xD1
1A47C:  MOVLW  01
1A47E:  MOVWF  xD0
1A480:  MOVLB  0
1A482:  CALL   4F68
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A486:  MOVLW  88
1A488:  MOVLB  8
1A48A:  MOVWF  xCF
1A48C:  CLRF   xD1
1A48E:  MOVLW  01
1A490:  MOVWF  xD0
1A492:  MOVLB  0
1A494:  CALL   4F68
....................    write16(ADDR_M2_MODE,HALF); 
1A498:  MOVLW  8C
1A49A:  MOVLB  8
1A49C:  MOVWF  xCF
1A49E:  CLRF   xD1
1A4A0:  MOVLW  01
1A4A2:  MOVWF  xD0
1A4A4:  MOVLB  0
1A4A6:  CALL   4F68
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A4AA:  MOVLW  90
1A4AC:  MOVLB  8
1A4AE:  MOVWF  xCF
1A4B0:  CLRF   xD1
1A4B2:  MOVLW  64
1A4B4:  MOVWF  xD0
1A4B6:  MOVLB  0
1A4B8:  CALL   4F68
....................    write16(ADDR_M2_POS_DIR,0); 
1A4BC:  MOVLW  94
1A4BE:  MOVLB  8
1A4C0:  MOVWF  xCF
1A4C2:  CLRF   xD1
1A4C4:  CLRF   xD0
1A4C6:  MOVLB  0
1A4C8:  CALL   4F68
....................    write16(ADDR_M2_PWM_HLD,0); 
1A4CC:  MOVLW  98
1A4CE:  MOVLB  8
1A4D0:  MOVWF  xCF
1A4D2:  CLRF   xD1
1A4D4:  CLRF   xD0
1A4D6:  MOVLB  0
1A4D8:  CALL   4F68
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A4DC:  MOVLW  9C
1A4DE:  MOVLB  8
1A4E0:  MOVWF  xCF
1A4E2:  CLRF   xD1
1A4E4:  MOVLW  7F
1A4E6:  MOVWF  xD0
1A4E8:  MOVLB  0
1A4EA:  CALL   4F68
....................    write16(ADDR_M2_GB_ERR,0); 
1A4EE:  MOVLW  A0
1A4F0:  MOVLB  8
1A4F2:  MOVWF  xCF
1A4F4:  CLRF   xD1
1A4F6:  CLRF   xD0
1A4F8:  MOVLB  0
1A4FA:  CALL   4F68
....................    write16(ADDR_E2_CPR,0); 
1A4FE:  MOVLW  A4
1A500:  MOVLB  8
1A502:  MOVWF  xCF
1A504:  CLRF   xD1
1A506:  CLRF   xD0
1A508:  MOVLB  0
1A50A:  CALL   4F68
....................    write16(ADDR_E2_PPR,0);   
1A50E:  MOVLW  A8
1A510:  MOVLB  8
1A512:  MOVWF  xCF
1A514:  CLRF   xD1
1A516:  CLRF   xD0
1A518:  MOVLB  0
1A51A:  CALL   4F68
....................    write16(ADDR_E2_MODE,0); 
1A51E:  MOVLW  84
1A520:  MOVLB  8
1A522:  MOVWF  xCF
1A524:  CLRF   xD1
1A526:  CLRF   xD0
1A528:  MOVLB  0
1A52A:  CALL   4F68
....................    write16(ADDR_E2_POS,0); 
1A52E:  MOVLW  80
1A530:  MOVLB  8
1A532:  MOVWF  xCF
1A534:  CLRF   xD1
1A536:  CLRF   xD0
1A538:  MOVLB  0
1A53A:  CALL   4F68
....................    write16(ADDR_E2_PORT,0); 
1A53E:  MOVLW  AC
1A540:  MOVLB  8
1A542:  MOVWF  xCF
1A544:  CLRF   xD1
1A546:  CLRF   xD0
1A548:  MOVLB  0
1A54A:  CALL   4F68
....................    write16(ADDR_E2_TYPE,0); 
1A54E:  MOVLW  7C
1A550:  MOVLB  8
1A552:  MOVWF  xCF
1A554:  CLRF   xD1
1A556:  CLRF   xD0
1A558:  MOVLB  0
1A55A:  CALL   4F68
....................    write16(ADDR_M2_RUN,0); 
1A55E:  MOVLW  78
1A560:  MOVLB  8
1A562:  MOVWF  xCF
1A564:  CLRF   xD1
1A566:  CLRF   xD0
1A568:  MOVLB  0
1A56A:  CALL   4F68
....................    write16(ADDR_M2_BKLSH,0); 
1A56E:  MOVLW  74
1A570:  MOVLB  8
1A572:  MOVWF  xCF
1A574:  CLRF   xD1
1A576:  CLRF   xD0
1A578:  MOVLB  0
1A57A:  CALL   4F68
....................    write16(ADDR_M2_ERROR,0);   
1A57E:  MOVLW  70
1A580:  MOVLB  8
1A582:  MOVWF  xCF
1A584:  CLRF   xD1
1A586:  CLRF   xD0
1A588:  MOVLB  0
1A58A:  CALL   4F68
....................    write16(ADDR_M2_SPR,0); 
1A58E:  MOVLW  B0
1A590:  MOVLB  8
1A592:  MOVWF  xCF
1A594:  CLRF   xD1
1A596:  CLRF   xD0
1A598:  MOVLB  0
1A59A:  CALL   4F68
....................    write16(ADDR_M2_COMP,0); 
1A59E:  MOVLW  B4
1A5A0:  MOVLB  8
1A5A2:  MOVWF  xCF
1A5A4:  CLRF   xD1
1A5A6:  CLRF   xD0
1A5A8:  MOVLB  0
1A5AA:  CALL   4F68
....................    write16(ADDR_M2_LIN_POS,0);    
1A5AE:  MOVLW  B8
1A5B0:  MOVLB  8
1A5B2:  MOVWF  xCF
1A5B4:  CLRF   xD1
1A5B6:  CLRF   xD0
1A5B8:  MOVLB  0
1A5BA:  CALL   4F68
....................     
....................    get_step_vars(); 
1A5BE:  CALL   2CB6
1A5C2:  GOTO   1A8C6 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A5C6:  MOVLW  86
1A5C8:  MOVLB  8
1A5CA:  MOVWF  xCF
1A5CC:  CLRF   xD1
1A5CE:  MOVLW  01
1A5D0:  MOVWF  xD0
1A5D2:  MOVLB  0
1A5D4:  CALL   4F68
....................    write16(ADDR_M1_MODE,FULL); 
1A5D8:  MOVLW  8A
1A5DA:  MOVLB  8
1A5DC:  MOVWF  xCF
1A5DE:  CLRF   xD1
1A5E0:  CLRF   xD0
1A5E2:  MOVLB  0
1A5E4:  CALL   4F68
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1A5E8:  MOVLW  8E
1A5EA:  MOVLB  8
1A5EC:  MOVWF  xCF
1A5EE:  CLRF   xD1
1A5F0:  MOVLW  28
1A5F2:  MOVWF  xD0
1A5F4:  MOVLB  0
1A5F6:  CALL   4F68
....................    write16(ADDR_M1_POS_DIR,1); 
1A5FA:  MOVLW  92
1A5FC:  MOVLB  8
1A5FE:  MOVWF  xCF
1A600:  CLRF   xD1
1A602:  MOVLW  01
1A604:  MOVWF  xD0
1A606:  MOVLB  0
1A608:  CALL   4F68
....................    write16(ADDR_M1_PWM_HLD,0); 
1A60C:  MOVLW  96
1A60E:  MOVLB  8
1A610:  MOVWF  xCF
1A612:  CLRF   xD1
1A614:  CLRF   xD0
1A616:  MOVLB  0
1A618:  CALL   4F68
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A61C:  MOVLW  9A
1A61E:  MOVLB  8
1A620:  MOVWF  xCF
1A622:  CLRF   xD1
1A624:  MOVLW  7F
1A626:  MOVWF  xD0
1A628:  MOVLB  0
1A62A:  CALL   4F68
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1A62E:  MOVLW  9E
1A630:  MOVLB  8
1A632:  MOVWF  xCF
1A634:  MOVLW  02
1A636:  MOVWF  xD1
1A638:  MOVLW  9E
1A63A:  MOVWF  xD0
1A63C:  MOVLB  0
1A63E:  CALL   4F68
....................    write16(ADDR_E1_CPR,500); 
1A642:  MOVLW  A2
1A644:  MOVLB  8
1A646:  MOVWF  xCF
1A648:  MOVLW  01
1A64A:  MOVWF  xD1
1A64C:  MOVLW  F4
1A64E:  MOVWF  xD0
1A650:  MOVLB  0
1A652:  CALL   4F68
....................    write16(ADDR_E1_PPR,50); 
1A656:  MOVLW  A6
1A658:  MOVLB  8
1A65A:  MOVWF  xCF
1A65C:  CLRF   xD1
1A65E:  MOVLW  32
1A660:  MOVWF  xD0
1A662:  MOVLB  0
1A664:  CALL   4F68
....................    write16(ADDR_E1_MODE,2); 
1A668:  MOVLW  82
1A66A:  MOVLB  8
1A66C:  MOVWF  xCF
1A66E:  CLRF   xD1
1A670:  MOVLW  02
1A672:  MOVWF  xD0
1A674:  MOVLB  0
1A676:  CALL   4F68
....................    write16(ADDR_E1_POS,0); 
1A67A:  MOVLW  7E
1A67C:  MOVLB  8
1A67E:  MOVWF  xCF
1A680:  CLRF   xD1
1A682:  CLRF   xD0
1A684:  MOVLB  0
1A686:  CALL   4F68
....................    write16(ADDR_E1_PORT,0); 
1A68A:  MOVLW  AA
1A68C:  MOVLB  8
1A68E:  MOVWF  xCF
1A690:  CLRF   xD1
1A692:  CLRF   xD0
1A694:  MOVLB  0
1A696:  CALL   4F68
....................    write16(ADDR_E1_TYPE,1); 
1A69A:  MOVLW  7A
1A69C:  MOVLB  8
1A69E:  MOVWF  xCF
1A6A0:  CLRF   xD1
1A6A2:  MOVLW  01
1A6A4:  MOVWF  xD0
1A6A6:  MOVLB  0
1A6A8:  CALL   4F68
....................    write16(ADDR_M1_RUN,0); 
1A6AC:  MOVLW  76
1A6AE:  MOVLB  8
1A6B0:  MOVWF  xCF
1A6B2:  CLRF   xD1
1A6B4:  CLRF   xD0
1A6B6:  MOVLB  0
1A6B8:  CALL   4F68
....................    write16(ADDR_M1_BKLSH,1300); 
1A6BC:  MOVLW  72
1A6BE:  MOVLB  8
1A6C0:  MOVWF  xCF
1A6C2:  MOVLW  05
1A6C4:  MOVWF  xD1
1A6C6:  MOVLW  14
1A6C8:  MOVWF  xD0
1A6CA:  MOVLB  0
1A6CC:  CALL   4F68
....................    write16(ADDR_M1_ERROR,0);   
1A6D0:  MOVLW  6E
1A6D2:  MOVLB  8
1A6D4:  MOVWF  xCF
1A6D6:  CLRF   xD1
1A6D8:  CLRF   xD0
1A6DA:  MOVLB  0
1A6DC:  CALL   4F68
....................    write16(ADDR_M1_SPR,20000); 
1A6E0:  MOVLW  AE
1A6E2:  MOVLB  8
1A6E4:  MOVWF  xCF
1A6E6:  MOVLW  4E
1A6E8:  MOVWF  xD1
1A6EA:  MOVLW  20
1A6EC:  MOVWF  xD0
1A6EE:  MOVLB  0
1A6F0:  CALL   4F68
....................    write16(ADDR_M1_COMP,0); 
1A6F4:  MOVLW  B2
1A6F6:  MOVLB  8
1A6F8:  MOVWF  xCF
1A6FA:  CLRF   xD1
1A6FC:  CLRF   xD0
1A6FE:  MOVLB  0
1A700:  CALL   4F68
....................    write16(ADDR_M1_LIN_POS,0); 
1A704:  MOVLW  B6
1A706:  MOVLB  8
1A708:  MOVWF  xCF
1A70A:  CLRF   xD1
1A70C:  CLRF   xD0
1A70E:  MOVLB  0
1A710:  CALL   4F68
....................    write16(ADDR_E1_INDEX,0); 
1A714:  MOVLW  BA
1A716:  MOVLB  8
1A718:  MOVWF  xCF
1A71A:  CLRF   xD1
1A71C:  CLRF   xD0
1A71E:  MOVLB  0
1A720:  CALL   4F68
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A724:  MOVLW  88
1A726:  MOVLB  8
1A728:  MOVWF  xCF
1A72A:  CLRF   xD1
1A72C:  MOVLW  01
1A72E:  MOVWF  xD0
1A730:  MOVLB  0
1A732:  CALL   4F68
....................    write16(ADDR_M2_MODE,HALF); 
1A736:  MOVLW  8C
1A738:  MOVLB  8
1A73A:  MOVWF  xCF
1A73C:  CLRF   xD1
1A73E:  MOVLW  01
1A740:  MOVWF  xD0
1A742:  MOVLB  0
1A744:  CALL   4F68
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A748:  MOVLW  90
1A74A:  MOVLB  8
1A74C:  MOVWF  xCF
1A74E:  CLRF   xD1
1A750:  MOVLW  28
1A752:  MOVWF  xD0
1A754:  MOVLB  0
1A756:  CALL   4F68
....................    write16(ADDR_M2_POS_DIR,1); 
1A75A:  MOVLW  94
1A75C:  MOVLB  8
1A75E:  MOVWF  xCF
1A760:  CLRF   xD1
1A762:  MOVLW  01
1A764:  MOVWF  xD0
1A766:  MOVLB  0
1A768:  CALL   4F68
....................    write16(ADDR_M2_PWM_HLD,0); 
1A76C:  MOVLW  98
1A76E:  MOVLB  8
1A770:  MOVWF  xCF
1A772:  CLRF   xD1
1A774:  CLRF   xD0
1A776:  MOVLB  0
1A778:  CALL   4F68
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A77C:  MOVLW  9C
1A77E:  MOVLB  8
1A780:  MOVWF  xCF
1A782:  CLRF   xD1
1A784:  MOVLW  7F
1A786:  MOVWF  xD0
1A788:  MOVLB  0
1A78A:  CALL   4F68
....................    write16(ADDR_M2_GB_ERR,0); 
1A78E:  MOVLW  A0
1A790:  MOVLB  8
1A792:  MOVWF  xCF
1A794:  CLRF   xD1
1A796:  CLRF   xD0
1A798:  MOVLB  0
1A79A:  CALL   4F68
....................    write16(ADDR_E2_CPR,0); 
1A79E:  MOVLW  A4
1A7A0:  MOVLB  8
1A7A2:  MOVWF  xCF
1A7A4:  CLRF   xD1
1A7A6:  CLRF   xD0
1A7A8:  MOVLB  0
1A7AA:  CALL   4F68
....................    write16(ADDR_E2_PPR,0);   
1A7AE:  MOVLW  A8
1A7B0:  MOVLB  8
1A7B2:  MOVWF  xCF
1A7B4:  CLRF   xD1
1A7B6:  CLRF   xD0
1A7B8:  MOVLB  0
1A7BA:  CALL   4F68
....................    write16(ADDR_E2_MODE,0); 
1A7BE:  MOVLW  84
1A7C0:  MOVLB  8
1A7C2:  MOVWF  xCF
1A7C4:  CLRF   xD1
1A7C6:  CLRF   xD0
1A7C8:  MOVLB  0
1A7CA:  CALL   4F68
....................    write16(ADDR_E2_POS,0); 
1A7CE:  MOVLW  80
1A7D0:  MOVLB  8
1A7D2:  MOVWF  xCF
1A7D4:  CLRF   xD1
1A7D6:  CLRF   xD0
1A7D8:  MOVLB  0
1A7DA:  CALL   4F68
....................    write16(ADDR_E2_PORT,0); 
1A7DE:  MOVLW  AC
1A7E0:  MOVLB  8
1A7E2:  MOVWF  xCF
1A7E4:  CLRF   xD1
1A7E6:  CLRF   xD0
1A7E8:  MOVLB  0
1A7EA:  CALL   4F68
....................    write16(ADDR_E2_TYPE,0); 
1A7EE:  MOVLW  7C
1A7F0:  MOVLB  8
1A7F2:  MOVWF  xCF
1A7F4:  CLRF   xD1
1A7F6:  CLRF   xD0
1A7F8:  MOVLB  0
1A7FA:  CALL   4F68
....................    write16(ADDR_M2_RUN,0); 
1A7FE:  MOVLW  78
1A800:  MOVLB  8
1A802:  MOVWF  xCF
1A804:  CLRF   xD1
1A806:  CLRF   xD0
1A808:  MOVLB  0
1A80A:  CALL   4F68
....................    write16(ADDR_M2_BKLSH,0); 
1A80E:  MOVLW  74
1A810:  MOVLB  8
1A812:  MOVWF  xCF
1A814:  CLRF   xD1
1A816:  CLRF   xD0
1A818:  MOVLB  0
1A81A:  CALL   4F68
....................    write16(ADDR_M2_ERROR,0);   
1A81E:  MOVLW  70
1A820:  MOVLB  8
1A822:  MOVWF  xCF
1A824:  CLRF   xD1
1A826:  CLRF   xD0
1A828:  MOVLB  0
1A82A:  CALL   4F68
....................    write16(ADDR_M2_SPR,0); 
1A82E:  MOVLW  B0
1A830:  MOVLB  8
1A832:  MOVWF  xCF
1A834:  CLRF   xD1
1A836:  CLRF   xD0
1A838:  MOVLB  0
1A83A:  CALL   4F68
....................    write16(ADDR_M2_COMP,0); 
1A83E:  MOVLW  B4
1A840:  MOVLB  8
1A842:  MOVWF  xCF
1A844:  CLRF   xD1
1A846:  CLRF   xD0
1A848:  MOVLB  0
1A84A:  CALL   4F68
....................    write16(ADDR_M2_LIN_POS,0);    
1A84E:  MOVLW  B8
1A850:  MOVLB  8
1A852:  MOVWF  xCF
1A854:  CLRF   xD1
1A856:  CLRF   xD0
1A858:  MOVLB  0
1A85A:  CALL   4F68
....................    write16(ADDR_E2_INDEX,0); 
1A85E:  MOVLW  BC
1A860:  MOVLB  8
1A862:  MOVWF  xCF
1A864:  CLRF   xD1
1A866:  CLRF   xD0
1A868:  MOVLB  0
1A86A:  CALL   4F68
....................     
....................    get_step_vars(); 
1A86E:  CALL   2CB6
1A872:  GOTO   1A8C6 (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
02934:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
02936:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
02938:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
0293A:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
0293C:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
0293E:  BCF    F90.5
....................    set_pwm1_duty(0);    
02940:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
02942:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
02944:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
02946:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
02948:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
0294A:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
0294C:  BCF    F8D.5
....................    set_pwm2_duty(0);  
0294E:  MOVLB  F
02950:  CLRF   x4F
....................  
....................    output_low(VENC1); 
02952:  BCF    F8E.6
....................    output_low(VENC2);         
02954:  BCF    F8E.7
....................    output_low(VHBRDG); 
02956:  BCF    F8E.2
02958:  MOVLB  0
0295A:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
0125A:  BCF    FD8.0
0125C:  MOVLB  7
0125E:  RLCF   x40,W
01260:  CLRF   03
01262:  ADDLW  4E
01264:  MOVWF  FE9
01266:  MOVLW  07
01268:  ADDWFC 03,W
0126A:  MOVWF  FEA
0126C:  MOVFF  FEC,A14
01270:  MOVF   FED,F
01272:  MOVFF  FEF,A13
01276:  MOVLB  A
01278:  MOVF   x13,F
0127A:  BTFSS  FD8.2
0127C:  BRA    1404
0127E:  MOVF   x14,F
01280:  BTFSS  FD8.2
01282:  BRA    1404
....................       if(m_way[motor]==POS) { 
01284:  BCF    FD8.0
01286:  MOVLB  7
01288:  RLCF   x40,W
0128A:  CLRF   03
0128C:  ADDLW  86
0128E:  MOVWF  FE9
01290:  MOVLW  07
01292:  ADDWFC 03,W
01294:  MOVWF  FEA
01296:  MOVFF  FEC,A14
0129A:  MOVF   FED,F
0129C:  MOVFF  FEF,A13
012A0:  MOVLB  A
012A2:  MOVF   x13,F
012A4:  BNZ   133E
012A6:  MOVF   x14,F
012A8:  BNZ   133E
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
012AA:  BCF    FD8.0
012AC:  MOVLB  7
012AE:  RLCF   x40,W
012B0:  CLRF   03
012B2:  ADDLW  BF
012B4:  MOVWF  FE9
012B6:  MOVLW  07
012B8:  ADDWFC 03,W
012BA:  MOVWF  FEA
012BC:  MOVFF  FEC,A14
012C0:  MOVF   FED,F
012C2:  MOVFF  FEF,A13
012C6:  BCF    FD8.0
012C8:  RLCF   x40,W
012CA:  CLRF   03
012CC:  ADDLW  5E
012CE:  MOVWF  FE9
012D0:  MOVLW  07
012D2:  ADDWFC 03,W
012D4:  MOVWF  FEA
012D6:  MOVFF  FEC,03
012DA:  MOVF   FED,F
012DC:  MOVFF  FEF,01
012E0:  MOVF   03,W
012E2:  MOVLB  A
012E4:  SUBWF  x14,W
012E6:  BNC   130A
012E8:  BNZ   12F0
012EA:  MOVF   01,W
012EC:  SUBWF  x13,W
012EE:  BNC   130A
012F0:  BCF    FD8.0
012F2:  MOVLB  7
012F4:  RLCF   x40,W
012F6:  CLRF   03
012F8:  ADDLW  BF
012FA:  MOVWF  FE9
012FC:  MOVLW  07
012FE:  ADDWFC 03,W
01300:  MOVWF  FEA
01302:  CLRF   FEC
01304:  MOVF   FED,F
01306:  CLRF   FEF
01308:  MOVLB  A
....................          e_pos[motor]++; 
0130A:  BCF    FD8.0
0130C:  MOVLB  7
0130E:  RLCF   x40,W
01310:  CLRF   03
01312:  ADDLW  BF
01314:  MOVWF  FE9
01316:  MOVLW  07
01318:  ADDWFC 03,W
0131A:  MOVWF  FEA
0131C:  MOVLW  01
0131E:  ADDWF  FEE,F
01320:  BNC   1324
01322:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
01324:  BCF    FD8.0
01326:  RLCF   x40,W
01328:  CLRF   03
0132A:  ADDLW  9A
0132C:  MOVWF  FE9
0132E:  MOVLW  07
01330:  ADDWFC 03,W
01332:  MOVWF  FEA
01334:  CLRF   FEC
01336:  MOVF   FED,F
01338:  CLRF   FEF
....................       } 
0133A:  BRA    1402
0133C:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
0133E:  BCF    FD8.0
01340:  MOVLB  7
01342:  RLCF   x40,W
01344:  CLRF   03
01346:  ADDLW  86
01348:  MOVWF  FE9
0134A:  MOVLW  07
0134C:  ADDWFC 03,W
0134E:  MOVWF  FEA
01350:  MOVFF  FEC,A14
01354:  MOVF   FED,F
01356:  MOVFF  FEF,A13
0135A:  MOVLB  A
0135C:  DECFSZ x13,W
0135E:  BRA    1404
01360:  MOVF   x14,F
01362:  BNZ   1404
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01364:  BCF    FD8.0
01366:  MOVLB  7
01368:  RLCF   x40,W
0136A:  CLRF   03
0136C:  ADDLW  BF
0136E:  MOVWF  FE9
01370:  MOVLW  07
01372:  ADDWFC 03,W
01374:  MOVWF  FEA
01376:  MOVFF  FEC,A14
0137A:  MOVF   FED,F
0137C:  MOVFF  FEF,A13
01380:  MOVLB  A
01382:  MOVF   x13,F
01384:  BNZ   13D0
01386:  MOVF   x14,F
01388:  BNZ   13D0
0138A:  BCF    FD8.0
0138C:  MOVLB  7
0138E:  RLCF   x40,W
01390:  CLRF   03
01392:  ADDLW  BF
01394:  MOVWF  01
01396:  MOVLW  07
01398:  ADDWFC 03,F
0139A:  MOVLB  A
0139C:  MOVFF  03,A14
013A0:  BCF    FD8.0
013A2:  MOVLB  7
013A4:  RLCF   x40,W
013A6:  CLRF   03
013A8:  ADDLW  5E
013AA:  MOVWF  FE9
013AC:  MOVLW  07
013AE:  ADDWFC 03,W
013B0:  MOVWF  FEA
013B2:  MOVFF  FEC,03
013B6:  MOVF   FED,F
013B8:  MOVFF  FEF,A15
013BC:  MOVLB  A
013BE:  MOVFF  A14,FEA
013C2:  MOVFF  01,FE9
013C6:  MOVFF  03,FEC
013CA:  MOVF   FED,F
013CC:  MOVFF  A15,FEF
....................          e_pos[motor]--; 
013D0:  BCF    FD8.0
013D2:  MOVLB  7
013D4:  RLCF   x40,W
013D6:  CLRF   03
013D8:  ADDLW  BF
013DA:  MOVWF  FE9
013DC:  MOVLW  07
013DE:  ADDWFC 03,W
013E0:  MOVWF  FEA
013E2:  MOVLW  FF
013E4:  ADDWF  FEF,F
013E6:  BC    13EC
013E8:  MOVF   FEE,F
013EA:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
013EC:  BCF    FD8.0
013EE:  RLCF   x40,W
013F0:  CLRF   03
013F2:  ADDLW  9A
013F4:  MOVWF  FE9
013F6:  MOVLW  07
013F8:  ADDWFC 03,W
013FA:  MOVWF  FEA
013FC:  CLRF   FEC
013FE:  MOVF   FED,F
01400:  CLRF   FEF
01402:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
01404:  BCF    FD8.0
01406:  MOVLB  7
01408:  RLCF   x40,W
0140A:  CLRF   03
0140C:  ADDLW  4E
0140E:  MOVWF  FE9
01410:  MOVLW  07
01412:  ADDWFC 03,W
01414:  MOVWF  FEA
01416:  MOVFF  FEC,A14
0141A:  MOVF   FED,F
0141C:  MOVFF  FEF,A13
01420:  MOVLB  A
01422:  DECFSZ x13,W
01424:  BRA    15AC
01426:  MOVF   x14,F
01428:  BTFSS  FD8.2
0142A:  BRA    15AC
....................       if(m_way[motor]==NEG) { 
0142C:  BCF    FD8.0
0142E:  MOVLB  7
01430:  RLCF   x40,W
01432:  CLRF   03
01434:  ADDLW  86
01436:  MOVWF  FE9
01438:  MOVLW  07
0143A:  ADDWFC 03,W
0143C:  MOVWF  FEA
0143E:  MOVFF  FEC,A14
01442:  MOVF   FED,F
01444:  MOVFF  FEF,A13
01448:  MOVLB  A
0144A:  DECFSZ x13,W
0144C:  BRA    14E6
0144E:  MOVF   x14,F
01450:  BNZ   14E6
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
01452:  BCF    FD8.0
01454:  MOVLB  7
01456:  RLCF   x40,W
01458:  CLRF   03
0145A:  ADDLW  BF
0145C:  MOVWF  FE9
0145E:  MOVLW  07
01460:  ADDWFC 03,W
01462:  MOVWF  FEA
01464:  MOVFF  FEC,A14
01468:  MOVF   FED,F
0146A:  MOVFF  FEF,A13
0146E:  BCF    FD8.0
01470:  RLCF   x40,W
01472:  CLRF   03
01474:  ADDLW  5E
01476:  MOVWF  FE9
01478:  MOVLW  07
0147A:  ADDWFC 03,W
0147C:  MOVWF  FEA
0147E:  MOVFF  FEC,03
01482:  MOVF   FED,F
01484:  MOVFF  FEF,01
01488:  MOVF   03,W
0148A:  MOVLB  A
0148C:  SUBWF  x14,W
0148E:  BNC   14B2
01490:  BNZ   1498
01492:  MOVF   01,W
01494:  SUBWF  x13,W
01496:  BNC   14B2
01498:  BCF    FD8.0
0149A:  MOVLB  7
0149C:  RLCF   x40,W
0149E:  CLRF   03
014A0:  ADDLW  BF
014A2:  MOVWF  FE9
014A4:  MOVLW  07
014A6:  ADDWFC 03,W
014A8:  MOVWF  FEA
014AA:  CLRF   FEC
014AC:  MOVF   FED,F
014AE:  CLRF   FEF
014B0:  MOVLB  A
....................          e_pos[motor]++; 
014B2:  BCF    FD8.0
014B4:  MOVLB  7
014B6:  RLCF   x40,W
014B8:  CLRF   03
014BA:  ADDLW  BF
014BC:  MOVWF  FE9
014BE:  MOVLW  07
014C0:  ADDWFC 03,W
014C2:  MOVWF  FEA
014C4:  MOVLW  01
014C6:  ADDWF  FEE,F
014C8:  BNC   14CC
014CA:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014CC:  BCF    FD8.0
014CE:  RLCF   x40,W
014D0:  CLRF   03
014D2:  ADDLW  9A
014D4:  MOVWF  FE9
014D6:  MOVLW  07
014D8:  ADDWFC 03,W
014DA:  MOVWF  FEA
014DC:  CLRF   FEC
014DE:  MOVF   FED,F
014E0:  CLRF   FEF
....................       } 
014E2:  BRA    15AA
014E4:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
014E6:  BCF    FD8.0
014E8:  MOVLB  7
014EA:  RLCF   x40,W
014EC:  CLRF   03
014EE:  ADDLW  86
014F0:  MOVWF  FE9
014F2:  MOVLW  07
014F4:  ADDWFC 03,W
014F6:  MOVWF  FEA
014F8:  MOVFF  FEC,A14
014FC:  MOVF   FED,F
014FE:  MOVFF  FEF,A13
01502:  MOVLB  A
01504:  MOVF   x13,F
01506:  BNZ   15AC
01508:  MOVF   x14,F
0150A:  BNZ   15AC
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
0150C:  BCF    FD8.0
0150E:  MOVLB  7
01510:  RLCF   x40,W
01512:  CLRF   03
01514:  ADDLW  BF
01516:  MOVWF  FE9
01518:  MOVLW  07
0151A:  ADDWFC 03,W
0151C:  MOVWF  FEA
0151E:  MOVFF  FEC,A14
01522:  MOVF   FED,F
01524:  MOVFF  FEF,A13
01528:  MOVLB  A
0152A:  MOVF   x13,F
0152C:  BNZ   1578
0152E:  MOVF   x14,F
01530:  BNZ   1578
01532:  BCF    FD8.0
01534:  MOVLB  7
01536:  RLCF   x40,W
01538:  CLRF   03
0153A:  ADDLW  BF
0153C:  MOVWF  01
0153E:  MOVLW  07
01540:  ADDWFC 03,F
01542:  MOVLB  A
01544:  MOVFF  03,A14
01548:  BCF    FD8.0
0154A:  MOVLB  7
0154C:  RLCF   x40,W
0154E:  CLRF   03
01550:  ADDLW  5E
01552:  MOVWF  FE9
01554:  MOVLW  07
01556:  ADDWFC 03,W
01558:  MOVWF  FEA
0155A:  MOVFF  FEC,03
0155E:  MOVF   FED,F
01560:  MOVFF  FEF,A15
01564:  MOVLB  A
01566:  MOVFF  A14,FEA
0156A:  MOVFF  01,FE9
0156E:  MOVFF  03,FEC
01572:  MOVF   FED,F
01574:  MOVFF  A15,FEF
....................          e_pos[motor]--; 
01578:  BCF    FD8.0
0157A:  MOVLB  7
0157C:  RLCF   x40,W
0157E:  CLRF   03
01580:  ADDLW  BF
01582:  MOVWF  FE9
01584:  MOVLW  07
01586:  ADDWFC 03,W
01588:  MOVWF  FEA
0158A:  MOVLW  FF
0158C:  ADDWF  FEF,F
0158E:  BC    1594
01590:  MOVF   FEE,F
01592:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
01594:  BCF    FD8.0
01596:  RLCF   x40,W
01598:  CLRF   03
0159A:  ADDLW  9A
0159C:  MOVWF  FE9
0159E:  MOVLW  07
015A0:  ADDWFC 03,W
015A2:  MOVWF  FEA
015A4:  CLRF   FEC
015A6:  MOVF   FED,F
015A8:  CLRF   FEF
015AA:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
015AC:  MOVF   1F,W
015AE:  SUBLW  04
015B0:  BTFSS  FD8.2
015B2:  BRA    16E6
015B4:  MOVF   20,F
015B6:  BTFSS  FD8.2
015B8:  BRA    16E6
015BA:  BCF    FD8.0
015BC:  MOVLB  7
015BE:  RLCF   x40,W
015C0:  CLRF   03
015C2:  ADDLW  6A
015C4:  MOVWF  FE9
015C6:  MOVLW  07
015C8:  ADDWFC 03,W
015CA:  MOVWF  FEA
015CC:  MOVFF  FEC,A14
015D0:  MOVF   FED,F
015D2:  MOVFF  FEF,A13
015D6:  MOVLB  A
015D8:  MOVF   x13,W
015DA:  SUBLW  02
015DC:  BTFSS  FD8.2
015DE:  BRA    16E6
015E0:  MOVF   x14,F
015E2:  BTFSS  FD8.2
015E4:  BRA    16E6
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
015E6:  MOVLW  01
015E8:  MOVLB  7
015EA:  ADDWF  x40,W
015EC:  MOVLB  A
015EE:  MOVWF  x13
015F0:  MOVLB  7
015F2:  MOVF   x40,W
015F4:  MULLW  04
015F6:  MOVF   FF3,W
015F8:  CLRF   03
015FA:  ADDLW  A2
015FC:  MOVWF  FE9
015FE:  MOVLW  07
01600:  ADDWFC 03,W
01602:  MOVWF  FEA
01604:  MOVFF  FEF,A14
01608:  MOVFF  FEC,A15
0160C:  MOVFF  FEC,A16
01610:  MOVFF  FEC,A17
01614:  BCF    FD8.0
01616:  RLCF   x40,W
01618:  CLRF   03
0161A:  ADDLW  BB
0161C:  MOVWF  FE9
0161E:  MOVLW  07
01620:  ADDWFC 03,W
01622:  MOVWF  FEA
01624:  MOVFF  FEC,A19
01628:  MOVF   FED,F
0162A:  MOVFF  FEF,A18
0162E:  BCF    FD8.0
01630:  RLCF   x40,W
01632:  CLRF   03
01634:  ADDLW  BF
01636:  MOVWF  FE9
01638:  MOVLW  07
0163A:  ADDWFC 03,W
0163C:  MOVWF  FEA
0163E:  MOVFF  FEC,A1B
01642:  MOVF   FED,F
01644:  MOVFF  FEF,A1A
01648:  MOVLW  6D
0164A:  BTFSS  F9E.4
0164C:  BRA    164A
0164E:  MOVWF  FAD
01650:  MOVLW  3A
01652:  BTFSS  F9E.4
01654:  BRA    1652
01656:  MOVWF  FAD
01658:  MOVFF  A13,A1C
0165C:  MOVLW  1B
0165E:  MOVLB  A
01660:  MOVWF  x1D
01662:  MOVLB  0
01664:  RCALL  0FA6
01666:  MOVLW  2C
01668:  BTFSS  F9E.4
0166A:  BRA    1668
0166C:  MOVWF  FAD
0166E:  MOVFF  7AA,A1C
01672:  MOVLW  1B
01674:  MOVLB  A
01676:  MOVWF  x1D
01678:  MOVLB  0
0167A:  RCALL  0FA6
0167C:  MOVLW  69
0167E:  MOVWF  FF6
01680:  MOVLW  0F
01682:  MOVWF  FF7
01684:  MOVLW  00
01686:  MOVWF  FF8
01688:  MOVLW  03
0168A:  MOVLB  A
0168C:  MOVWF  x1C
0168E:  MOVLB  0
01690:  RCALL  1024
01692:  MOVLW  41
01694:  MOVWF  FE9
01696:  MOVFF  A17,A1F
0169A:  MOVFF  A16,A1E
0169E:  MOVFF  A15,A1D
016A2:  MOVFF  A14,A1C
016A6:  RCALL  10EA
016A8:  MOVLW  2C
016AA:  BTFSS  F9E.4
016AC:  BRA    16AA
016AE:  MOVWF  FAD
016B0:  MOVLW  10
016B2:  MOVWF  FE9
016B4:  MOVFF  A19,A1D
016B8:  MOVFF  A18,A1C
016BC:  RCALL  11A6
016BE:  MOVLW  2C
016C0:  BTFSS  F9E.4
016C2:  BRA    16C0
016C4:  MOVWF  FAD
016C6:  MOVLW  10
016C8:  MOVWF  FE9
016CA:  MOVFF  A1B,A1D
016CE:  MOVFF  A1A,A1C
016D2:  RCALL  11A6
016D4:  MOVLW  0D
016D6:  BTFSS  F9E.4
016D8:  BRA    16D6
016DA:  MOVWF  FAD
016DC:  MOVLW  0A
016DE:  BTFSS  F9E.4
016E0:  BRA    16DE
016E2:  MOVWF  FAD
016E4:  MOVLB  A
....................    }    
016E6:  MOVLB  0
016E8:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A6DE:  MOVLB  7
0A6E0:  MOVF   x40,W
0A6E2:  XORLW  00
0A6E4:  MOVLB  0
0A6E6:  BZ    A6EE
0A6E8:  XORLW  01
0A6EA:  BZ    A77E
0A6EC:  BRA    A80C
....................       case 0 : if (e_type[motor]==1) { 
0A6EE:  BCF    FD8.0
0A6F0:  MOVLB  7
0A6F2:  RLCF   x40,W
0A6F4:  CLRF   03
0A6F6:  ADDLW  6A
0A6F8:  MOVWF  FE9
0A6FA:  MOVLW  07
0A6FC:  ADDWFC 03,W
0A6FE:  MOVWF  FEA
0A700:  MOVFF  FEC,8A9
0A704:  MOVF   FED,F
0A706:  MOVFF  FEF,8A8
0A70A:  MOVLB  8
0A70C:  DECFSZ xA8,W
0A70E:  BRA    A72E
0A710:  MOVF   xA9,F
0A712:  BNZ   A72E
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A714:  CLRF   03
0A716:  MOVLB  7
0A718:  MOVF   x40,W
0A71A:  ADDLW  CB
0A71C:  MOVWF  FE9
0A71E:  MOVLW  07
0A720:  ADDWFC 03,W
0A722:  MOVWF  FEA
0A724:  MOVLW  00
0A726:  BTFSC  F81.4
0A728:  MOVLW  01
0A72A:  MOVWF  FEF
0A72C:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A72E:  BCF    FD8.0
0A730:  MOVLB  7
0A732:  RLCF   x40,W
0A734:  CLRF   03
0A736:  ADDLW  6A
0A738:  MOVWF  FE9
0A73A:  MOVLW  07
0A73C:  ADDWFC 03,W
0A73E:  MOVWF  FEA
0A740:  MOVFF  FEC,8A9
0A744:  MOVF   FED,F
0A746:  MOVFF  FEF,8A8
0A74A:  MOVLB  8
0A74C:  MOVF   xA8,W
0A74E:  SUBLW  02
0A750:  BNZ   A77A
0A752:  MOVF   xA9,F
0A754:  BNZ   A77A
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A756:  CLRF   03
0A758:  MOVLB  7
0A75A:  MOVF   x40,W
0A75C:  ADDLW  CB
0A75E:  MOVWF  FE9
0A760:  MOVLW  07
0A762:  ADDWFC 03,W
0A764:  MOVWF  FEA
0A766:  MOVLW  00
0A768:  BTFSC  F81.4
0A76A:  MOVLW  01
0A76C:  MOVLB  8
0A76E:  MOVWF  xAA
0A770:  MOVLW  00
0A772:  BTFSC  F81.1
0A774:  MOVLW  01
0A776:  ANDWF  xAA,W
0A778:  MOVWF  FEF
....................                } 
....................          break; 
0A77A:  MOVLB  0
0A77C:  BRA    A80C
....................       case 1 : if (e_type[motor]==1) { 
0A77E:  BCF    FD8.0
0A780:  MOVLB  7
0A782:  RLCF   x40,W
0A784:  CLRF   03
0A786:  ADDLW  6A
0A788:  MOVWF  FE9
0A78A:  MOVLW  07
0A78C:  ADDWFC 03,W
0A78E:  MOVWF  FEA
0A790:  MOVFF  FEC,8A9
0A794:  MOVF   FED,F
0A796:  MOVFF  FEF,8A8
0A79A:  MOVLB  8
0A79C:  DECFSZ xA8,W
0A79E:  BRA    A7BE
0A7A0:  MOVF   xA9,F
0A7A2:  BNZ   A7BE
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A7A4:  CLRF   03
0A7A6:  MOVLB  7
0A7A8:  MOVF   x40,W
0A7AA:  ADDLW  CB
0A7AC:  MOVWF  FE9
0A7AE:  MOVLW  07
0A7B0:  ADDWFC 03,W
0A7B2:  MOVWF  FEA
0A7B4:  MOVLW  00
0A7B6:  BTFSC  F81.5
0A7B8:  MOVLW  01
0A7BA:  MOVWF  FEF
0A7BC:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A7BE:  BCF    FD8.0
0A7C0:  MOVLB  7
0A7C2:  RLCF   x40,W
0A7C4:  CLRF   03
0A7C6:  ADDLW  6A
0A7C8:  MOVWF  FE9
0A7CA:  MOVLW  07
0A7CC:  ADDWFC 03,W
0A7CE:  MOVWF  FEA
0A7D0:  MOVFF  FEC,8A9
0A7D4:  MOVF   FED,F
0A7D6:  MOVFF  FEF,8A8
0A7DA:  MOVLB  8
0A7DC:  MOVF   xA8,W
0A7DE:  SUBLW  02
0A7E0:  BNZ   A80A
0A7E2:  MOVF   xA9,F
0A7E4:  BNZ   A80A
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A7E6:  CLRF   03
0A7E8:  MOVLB  7
0A7EA:  MOVF   x40,W
0A7EC:  ADDLW  CB
0A7EE:  MOVWF  FE9
0A7F0:  MOVLW  07
0A7F2:  ADDWFC 03,W
0A7F4:  MOVWF  FEA
0A7F6:  MOVLW  00
0A7F8:  BTFSC  F81.5
0A7FA:  MOVLW  01
0A7FC:  MOVLB  8
0A7FE:  MOVWF  xAA
0A800:  MOVLW  00
0A802:  BTFSC  F81.2
0A804:  MOVLW  01
0A806:  ANDWF  xAA,W
0A808:  MOVWF  FEF
....................                } 
....................          break; 
0A80A:  MOVLB  0
....................    } 
0A80C:  GOTO   A8C6 (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017D6:  MOVLB  7
017D8:  MOVF   x40,W
017DA:  XORLW  00
017DC:  MOVLB  0
017DE:  BZ    17E6
017E0:  XORLW  01
017E2:  BZ    1876
017E4:  BRA    1904
....................       case 0 : if (e_type[motor]==1) { 
017E6:  BCF    FD8.0
017E8:  MOVLB  7
017EA:  RLCF   x40,W
017EC:  CLRF   03
017EE:  ADDLW  6A
017F0:  MOVWF  FE9
017F2:  MOVLW  07
017F4:  ADDWFC 03,W
017F6:  MOVWF  FEA
017F8:  MOVFF  FEC,A14
017FC:  MOVF   FED,F
017FE:  MOVFF  FEF,A13
01802:  MOVLB  A
01804:  DECFSZ x13,W
01806:  BRA    1826
01808:  MOVF   x14,F
0180A:  BNZ   1826
....................                   e_ch_n[motor]=input(ENC1_IND); 
0180C:  CLRF   03
0180E:  MOVLB  7
01810:  MOVF   x40,W
01812:  ADDLW  CB
01814:  MOVWF  FE9
01816:  MOVLW  07
01818:  ADDWFC 03,W
0181A:  MOVWF  FEA
0181C:  MOVLW  00
0181E:  BTFSC  F81.4
01820:  MOVLW  01
01822:  MOVWF  FEF
01824:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01826:  BCF    FD8.0
01828:  MOVLB  7
0182A:  RLCF   x40,W
0182C:  CLRF   03
0182E:  ADDLW  6A
01830:  MOVWF  FE9
01832:  MOVLW  07
01834:  ADDWFC 03,W
01836:  MOVWF  FEA
01838:  MOVFF  FEC,A14
0183C:  MOVF   FED,F
0183E:  MOVFF  FEF,A13
01842:  MOVLB  A
01844:  MOVF   x13,W
01846:  SUBLW  02
01848:  BNZ   1872
0184A:  MOVF   x14,F
0184C:  BNZ   1872
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0184E:  CLRF   03
01850:  MOVLB  7
01852:  MOVF   x40,W
01854:  ADDLW  CB
01856:  MOVWF  FE9
01858:  MOVLW  07
0185A:  ADDWFC 03,W
0185C:  MOVWF  FEA
0185E:  MOVLW  00
01860:  BTFSC  F81.4
01862:  MOVLW  01
01864:  MOVLB  A
01866:  MOVWF  x15
01868:  MOVLW  00
0186A:  BTFSC  F81.1
0186C:  MOVLW  01
0186E:  ANDWF  x15,W
01870:  MOVWF  FEF
....................                } 
....................          break; 
01872:  MOVLB  0
01874:  BRA    1904
....................       case 1 : if (e_type[motor]==1) { 
01876:  BCF    FD8.0
01878:  MOVLB  7
0187A:  RLCF   x40,W
0187C:  CLRF   03
0187E:  ADDLW  6A
01880:  MOVWF  FE9
01882:  MOVLW  07
01884:  ADDWFC 03,W
01886:  MOVWF  FEA
01888:  MOVFF  FEC,A14
0188C:  MOVF   FED,F
0188E:  MOVFF  FEF,A13
01892:  MOVLB  A
01894:  DECFSZ x13,W
01896:  BRA    18B6
01898:  MOVF   x14,F
0189A:  BNZ   18B6
....................                   e_ch_n[motor]=input(ENC2_IND); 
0189C:  CLRF   03
0189E:  MOVLB  7
018A0:  MOVF   x40,W
018A2:  ADDLW  CB
018A4:  MOVWF  FE9
018A6:  MOVLW  07
018A8:  ADDWFC 03,W
018AA:  MOVWF  FEA
018AC:  MOVLW  00
018AE:  BTFSC  F81.5
018B0:  MOVLW  01
018B2:  MOVWF  FEF
018B4:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
018B6:  BCF    FD8.0
018B8:  MOVLB  7
018BA:  RLCF   x40,W
018BC:  CLRF   03
018BE:  ADDLW  6A
018C0:  MOVWF  FE9
018C2:  MOVLW  07
018C4:  ADDWFC 03,W
018C6:  MOVWF  FEA
018C8:  MOVFF  FEC,A14
018CC:  MOVF   FED,F
018CE:  MOVFF  FEF,A13
018D2:  MOVLB  A
018D4:  MOVF   x13,W
018D6:  SUBLW  02
018D8:  BNZ   1902
018DA:  MOVF   x14,F
018DC:  BNZ   1902
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018DE:  CLRF   03
018E0:  MOVLB  7
018E2:  MOVF   x40,W
018E4:  ADDLW  CB
018E6:  MOVWF  FE9
018E8:  MOVLW  07
018EA:  ADDWFC 03,W
018EC:  MOVWF  FEA
018EE:  MOVLW  00
018F0:  BTFSC  F81.5
018F2:  MOVLW  01
018F4:  MOVLB  A
018F6:  MOVWF  x15
018F8:  MOVLW  00
018FA:  BTFSC  F81.2
018FC:  MOVLW  01
018FE:  ANDWF  x15,W
01900:  MOVWF  FEF
....................                } 
....................          break; 
01902:  MOVLB  0
....................    } 
01904:  GOTO   1A52 (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
016EA:  BCF    FD8.0
016EC:  MOVLB  7
016EE:  RLCF   x40,W
016F0:  CLRF   03
016F2:  ADDLW  BB
016F4:  MOVWF  FE9
016F6:  MOVLW  07
016F8:  ADDWFC 03,W
016FA:  MOVWF  FEA
016FC:  MOVLW  01
016FE:  ADDWF  FEE,F
01700:  BNC   1704
01702:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
01704:  MOVF   xAA,W
01706:  XORLW  00
01708:  MOVLB  0
0170A:  BZ    1716
0170C:  XORLW  01
0170E:  BZ    171C
01710:  XORLW  03
01712:  BZ    172E
01714:  BRA    1758
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
01716:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
01718:  BCF    FF0.0
....................          break; 
0171A:  BRA    1758
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
0171C:  MOVLW  02
0171E:  MOVLB  7
01720:  MOVWF  xAA
....................                disable_interrupts(INT_EXT1_L2H); 
01722:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
01724:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
01726:  BSF    FF0.3
01728:  BCF    FF1.5
....................          break; 
0172A:  MOVLB  0
0172C:  BRA    1758
....................       case 2 : edge_mode=1; 
0172E:  MOVLW  01
01730:  MOVLB  7
01732:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01734:  BCF    FD8.0
01736:  RLCF   x40,W
01738:  CLRF   03
0173A:  ADDLW  BB
0173C:  MOVWF  FE9
0173E:  MOVLW  07
01740:  ADDWFC 03,W
01742:  MOVWF  FEA
01744:  MOVLW  FF
01746:  ADDWF  FEF,F
01748:  BC    174E
0174A:  MOVF   FEE,F
0174C:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
0174E:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
01750:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
01752:  BSF    FF0.3
01754:  BSF    FF1.5
....................          break; 
01756:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
01758:  RCALL  125A
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
0175A:  BCF    FF0.0
0175C:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
01760:  BCF    FD8.0
01762:  MOVLB  7
01764:  RLCF   x40,W
01766:  CLRF   03
01768:  ADDLW  BB
0176A:  MOVWF  FE9
0176C:  MOVLW  07
0176E:  ADDWFC 03,W
01770:  MOVWF  FEA
01772:  MOVLW  01
01774:  ADDWF  FEE,F
01776:  BNC   177A
01778:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
0177A:  MOVF   xAA,W
0177C:  XORLW  00
0177E:  MOVLB  0
01780:  BZ    178C
01782:  XORLW  01
01784:  BZ    1792
01786:  XORLW  03
01788:  BZ    17A4
0178A:  BRA    17CE
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
0178C:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
0178E:  BCF    FF0.1
....................          break; 
01790:  BRA    17CE
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01792:  MOVLW  02
01794:  MOVLB  7
01796:  MOVWF  xAA
....................                disable_interrupts(INT_EXT2_L2H); 
01798:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
0179A:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
0179C:  BSF    FF0.4
0179E:  BCF    FF1.4
....................          break; 
017A0:  MOVLB  0
017A2:  BRA    17CE
....................       case 2 : edge_mode=1; 
017A4:  MOVLW  01
017A6:  MOVLB  7
017A8:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
017AA:  BCF    FD8.0
017AC:  RLCF   x40,W
017AE:  CLRF   03
017B0:  ADDLW  BB
017B2:  MOVWF  FE9
017B4:  MOVLW  07
017B6:  ADDWFC 03,W
017B8:  MOVWF  FEA
017BA:  MOVLW  FF
017BC:  ADDWF  FEF,F
017BE:  BC    17C4
017C0:  MOVF   FEE,F
017C2:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017C4:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017C6:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017C8:  BSF    FF0.4
017CA:  BSF    FF1.4
....................          break; 
017CC:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017CE:  RCALL  125A
.................... } 
....................  
.................... // motor step timer interrupt 
017D0:  BCF    FF0.1
017D2:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
01908:  MOVLW  F9
0190A:  MOVWF  FB3
0190C:  MOVLW  C0
0190E:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
01910:  BCF    FD8.0
01912:  MOVLB  7
01914:  RLCF   x40,W
01916:  CLRF   03
01918:  ADDLW  8E
0191A:  MOVWF  FE9
0191C:  MOVLW  07
0191E:  ADDWFC 03,W
01920:  MOVWF  FEA
01922:  MOVLW  01
01924:  ADDWF  FEE,F
01926:  BNC   192A
01928:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
0192A:  BCF    FD8.0
0192C:  RLCF   x40,W
0192E:  CLRF   03
01930:  ADDLW  8E
01932:  MOVWF  FE9
01934:  MOVLW  07
01936:  ADDWFC 03,W
01938:  MOVWF  FEA
0193A:  MOVFF  FEC,A14
0193E:  MOVF   FED,F
01940:  MOVFF  FEF,A13
01944:  BCF    FD8.0
01946:  RLCF   x40,W
01948:  CLRF   03
0194A:  ADDLW  4A
0194C:  MOVWF  FE9
0194E:  MOVLW  07
01950:  ADDWFC 03,W
01952:  MOVWF  FEA
01954:  MOVFF  FEC,03
01958:  MOVF   FED,F
0195A:  MOVFF  FEF,01
0195E:  MOVF   03,W
01960:  MOVLB  A
01962:  SUBWF  x14,W
01964:  BTFSS  FD8.0
01966:  BRA    1A54
01968:  BNZ   1972
0196A:  MOVF   01,W
0196C:  SUBWF  x13,W
0196E:  BTFSS  FD8.0
01970:  BRA    1A54
....................    { 
....................       m_step_cnt[motor]++; 
01972:  MOVLB  7
01974:  MOVF   x40,W
01976:  MULLW  04
01978:  MOVF   FF3,W
0197A:  CLRF   03
0197C:  ADDLW  A2
0197E:  MOVWF  FE9
01980:  MOVLW  07
01982:  ADDWFC 03,W
01984:  MOVWF  FEA
01986:  MOVLW  01
01988:  ADDWF  FEE,F
0198A:  MOVLW  00
0198C:  ADDWFC FEE,F
0198E:  ADDWFC FEE,F
01990:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
01992:  BCF    FD8.0
01994:  RLCF   x40,W
01996:  CLRF   03
01998:  ADDLW  9A
0199A:  MOVWF  FE9
0199C:  MOVLW  07
0199E:  ADDWFC 03,W
019A0:  MOVWF  FEA
019A2:  MOVLW  01
019A4:  ADDWF  FEE,F
019A6:  BNC   19AA
019A8:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
019AA:  BCF    FD8.0
019AC:  RLCF   x40,W
019AE:  CLRF   03
019B0:  ADDLW  8E
019B2:  MOVWF  FE9
019B4:  MOVLW  07
019B6:  ADDWFC 03,W
019B8:  MOVWF  FEA
019BA:  CLRF   FEC
019BC:  MOVF   FED,F
019BE:  CLRF   FEF
....................  
....................       if (motor==0) 
019C0:  MOVF   x40,F
019C2:  BNZ   19C8
....................       { 
....................          output_toggle(M1_CLOCK); 
019C4:  BTG    F90.4
....................       } 
019C6:  BRA    1A28
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019C8:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019CA:  BCF    FD8.0
019CC:  RLCF   x40,W
019CE:  CLRF   03
019D0:  ADDLW  86
019D2:  MOVWF  FE9
019D4:  MOVLW  07
019D6:  ADDWFC 03,W
019D8:  MOVWF  FEA
019DA:  MOVFF  FEC,A14
019DE:  MOVF   FED,F
019E0:  MOVFF  FEF,A13
019E4:  MOVLB  A
019E6:  MOVF   x13,F
019E8:  BNZ   1A0E
019EA:  MOVF   x14,F
019EC:  BNZ   1A0E
019EE:  BCF    FD8.0
019F0:  MOVLB  7
019F2:  RLCF   x40,W
019F4:  CLRF   03
019F6:  ADDLW  B3
019F8:  MOVWF  FE9
019FA:  MOVLW  07
019FC:  ADDWFC 03,W
019FE:  MOVWF  FEA
01A00:  MOVLW  FF
01A02:  ADDWF  FEF,F
01A04:  BC    1A0A
01A06:  MOVF   FEE,F
01A08:  DECF   FED,F
01A0A:  BRA    1A28
01A0C:  MOVLB  A
....................          else m_lin_pos[motor]++;          
01A0E:  BCF    FD8.0
01A10:  MOVLB  7
01A12:  RLCF   x40,W
01A14:  CLRF   03
01A16:  ADDLW  B3
01A18:  MOVWF  FE9
01A1A:  MOVLW  07
01A1C:  ADDWFC 03,W
01A1E:  MOVWF  FEA
01A20:  MOVLW  01
01A22:  ADDWF  FEE,F
01A24:  BNC   1A28
01A26:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A28:  BCF    FD8.0
01A2A:  RLCF   x40,W
01A2C:  CLRF   03
01A2E:  ADDLW  66
01A30:  MOVWF  FE9
01A32:  MOVLW  07
01A34:  ADDWFC 03,W
01A36:  MOVWF  FEA
01A38:  MOVFF  FEC,A14
01A3C:  MOVF   FED,F
01A3E:  MOVFF  FEF,A13
01A42:  MOVLB  A
01A44:  MOVF   x13,W
01A46:  SUBLW  03
01A48:  BNZ   1A54
01A4A:  MOVF   x14,F
01A4C:  BNZ   1A54
01A4E:  MOVLB  0
01A50:  BRA    17D6
01A52:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A54:  BCF    FA1.1
01A56:  BCF    FA1.1
01A58:  MOVLB  0
01A5A:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
08940:  BCF    FD8.0
08942:  MOVLB  7
08944:  RLCF   x40,W
08946:  CLRF   03
08948:  ADDLW  4E
0894A:  MOVWF  FE9
0894C:  MOVLW  07
0894E:  ADDWFC 03,W
08950:  MOVWF  FEA
08952:  MOVFF  FEC,8BA
08956:  MOVF   FED,F
08958:  MOVFF  FEF,8B9
0895C:  MOVLB  8
0895E:  DECFSZ xB9,W
08960:  BRA    89B0
08962:  MOVF   xBA,F
08964:  BNZ   89B0
08966:  BCF    FD8.0
08968:  MOVLB  7
0896A:  RLCF   x40,W
0896C:  CLRF   03
0896E:  ADDLW  86
08970:  MOVWF  01
08972:  MOVLW  07
08974:  ADDWFC 03,F
08976:  MOVFF  01,8B9
0897A:  MOVLB  8
0897C:  MOVFF  03,8BA
08980:  BCF    FD8.0
08982:  MOVLB  7
08984:  RLCF   x40,W
08986:  CLRF   03
08988:  ADDLW  86
0898A:  MOVWF  FE9
0898C:  MOVLW  07
0898E:  ADDWFC 03,W
08990:  MOVWF  FEA
08992:  MOVF   FEF,F
08994:  BNZ   899A
08996:  MOVF   FEC,F
08998:  BZ    899E
0899A:  MOVLW  00
0899C:  BRA    89A0
0899E:  MOVLW  01
089A0:  MOVLB  8
089A2:  MOVFF  8BA,FEA
089A6:  MOVFF  8B9,FE9
089AA:  CLRF   FEC
089AC:  MOVF   FED,F
089AE:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
089B0:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
089B2:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
089B4:  BCF    FD8.0
089B6:  MOVLB  7
089B8:  RLCF   x40,W
089BA:  CLRF   03
089BC:  ADDLW  42
089BE:  MOVWF  FE9
089C0:  MOVLW  07
089C2:  ADDWFC 03,W
089C4:  MOVWF  FEA
089C6:  MOVF   FEF,F
089C8:  BNZ   89D2
089CA:  MOVF   FEC,F
089CC:  BNZ   89D2
089CE:  BCF    F90.2
089D0:  BRA    89D4
089D2:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
089D4:  BCF    FD8.0
089D6:  RLCF   x40,W
089D8:  CLRF   03
089DA:  ADDLW  46
089DC:  MOVWF  FE9
089DE:  MOVLW  07
089E0:  ADDWFC 03,W
089E2:  MOVWF  FEA
089E4:  MOVF   FEF,F
089E6:  BNZ   89F0
089E8:  MOVF   FEC,F
089EA:  BNZ   89F0
089EC:  BCF    F90.3
089EE:  BRA    89F2
089F0:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
089F2:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
089F4:  BCF    FD8.0
089F6:  RLCF   x40,W
089F8:  CLRF   03
089FA:  ADDLW  86
089FC:  MOVWF  FE9
089FE:  MOVLW  07
08A00:  ADDWFC 03,W
08A02:  MOVWF  FEA
08A04:  MOVF   FEF,F
08A06:  BNZ   8A10
08A08:  MOVF   FEC,F
08A0A:  BNZ   8A10
08A0C:  BCF    F90.5
08A0E:  BRA    8A12
08A10:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
08A12:  BCF    FD8.0
08A14:  RLCF   x40,W
08A16:  CLRF   03
08A18:  ADDLW  56
08A1A:  MOVWF  FE9
08A1C:  MOVLW  07
08A1E:  ADDWFC 03,W
08A20:  MOVWF  FEA
08A22:  MOVFF  FEC,8BA
08A26:  MOVF   FED,F
08A28:  MOVFF  FEF,8B9
08A2C:  MOVLB  8
08A2E:  RRCF   xBA,F
08A30:  RRCF   xB9,F
08A32:  RRCF   xBA,F
08A34:  RRCF   xB9,F
08A36:  RRCF   xBA,F
08A38:  MOVFF  8B9,FBC
08A3C:  RRCF   xBA,F
08A3E:  RRCF   xBA,W
08A40:  ANDLW  30
08A42:  MOVWF  00
08A44:  MOVF   FBB,W
08A46:  ANDLW  CF
08A48:  IORWF  00,W
08A4A:  MOVWF  FBB
08A4C:  MOVLB  0
08A4E:  GOTO   8BD8 (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08A52:  BCF    FD8.0
08A54:  MOVLB  7
08A56:  RLCF   x40,W
08A58:  CLRF   03
08A5A:  ADDLW  4E
08A5C:  MOVWF  FE9
08A5E:  MOVLW  07
08A60:  ADDWFC 03,W
08A62:  MOVWF  FEA
08A64:  MOVFF  FEC,8BA
08A68:  MOVF   FED,F
08A6A:  MOVFF  FEF,8B9
08A6E:  MOVLB  8
08A70:  DECFSZ xB9,W
08A72:  BRA    8AC2
08A74:  MOVF   xBA,F
08A76:  BNZ   8AC2
08A78:  BCF    FD8.0
08A7A:  MOVLB  7
08A7C:  RLCF   x40,W
08A7E:  CLRF   03
08A80:  ADDLW  86
08A82:  MOVWF  01
08A84:  MOVLW  07
08A86:  ADDWFC 03,F
08A88:  MOVFF  01,8B9
08A8C:  MOVLB  8
08A8E:  MOVFF  03,8BA
08A92:  BCF    FD8.0
08A94:  MOVLB  7
08A96:  RLCF   x40,W
08A98:  CLRF   03
08A9A:  ADDLW  86
08A9C:  MOVWF  FE9
08A9E:  MOVLW  07
08AA0:  ADDWFC 03,W
08AA2:  MOVWF  FEA
08AA4:  MOVF   FEF,F
08AA6:  BNZ   8AAC
08AA8:  MOVF   FEC,F
08AAA:  BZ    8AB0
08AAC:  MOVLW  00
08AAE:  BRA    8AB2
08AB0:  MOVLW  01
08AB2:  MOVLB  8
08AB4:  MOVFF  8BA,FEA
08AB8:  MOVFF  8B9,FE9
08ABC:  CLRF   FEC
08ABE:  MOVF   FED,F
08AC0:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08AC2:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08AC4:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08AC6:  BCF    FD8.0
08AC8:  MOVLB  7
08ACA:  RLCF   x40,W
08ACC:  CLRF   03
08ACE:  ADDLW  42
08AD0:  MOVWF  FE9
08AD2:  MOVLW  07
08AD4:  ADDWFC 03,W
08AD6:  MOVWF  FEA
08AD8:  MOVF   FEF,F
08ADA:  BNZ   8AE4
08ADC:  MOVF   FEC,F
08ADE:  BNZ   8AE4
08AE0:  BCF    F8D.2
08AE2:  BRA    8AE6
08AE4:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08AE6:  BCF    FD8.0
08AE8:  RLCF   x40,W
08AEA:  CLRF   03
08AEC:  ADDLW  46
08AEE:  MOVWF  FE9
08AF0:  MOVLW  07
08AF2:  ADDWFC 03,W
08AF4:  MOVWF  FEA
08AF6:  MOVF   FEF,F
08AF8:  BNZ   8B02
08AFA:  MOVF   FEC,F
08AFC:  BNZ   8B02
08AFE:  BCF    F8D.3
08B00:  BRA    8B04
08B02:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08B04:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08B06:  BCF    FD8.0
08B08:  RLCF   x40,W
08B0A:  CLRF   03
08B0C:  ADDLW  86
08B0E:  MOVWF  FE9
08B10:  MOVLW  07
08B12:  ADDWFC 03,W
08B14:  MOVWF  FEA
08B16:  MOVF   FEF,F
08B18:  BNZ   8B22
08B1A:  MOVF   FEC,F
08B1C:  BNZ   8B22
08B1E:  BCF    F8D.5
08B20:  BRA    8B24
08B22:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08B24:  BCF    FD8.0
08B26:  RLCF   x40,W
08B28:  CLRF   03
08B2A:  ADDLW  56
08B2C:  MOVWF  FE9
08B2E:  MOVLW  07
08B30:  ADDWFC 03,W
08B32:  MOVWF  FEA
08B34:  MOVFF  FEC,8BA
08B38:  MOVF   FED,F
08B3A:  MOVFF  FEF,8B9
08B3E:  MOVLB  8
08B40:  RRCF   xBA,F
08B42:  RRCF   xB9,F
08B44:  RRCF   xBA,F
08B46:  RRCF   xB9,F
08B48:  RRCF   xBA,F
08B4A:  MOVFF  8B9,F4F
08B4E:  RRCF   xBA,F
08B50:  RRCF   xBA,W
08B52:  ANDLW  30
08B54:  MOVWF  00
08B56:  MOVLB  F
08B58:  MOVF   x4E,W
08B5A:  ANDLW  CF
08B5C:  IORWF  00,W
08B5E:  MOVWF  x4E
08B60:  MOVLB  0
08B62:  GOTO   8BD8 (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
0892C:  MOVLB  8
0892E:  MOVF   xCD,F
08930:  BZ    8938
....................       output_bit(VENC1,ON); 
08932:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
08934:  BSF    F8E.7
....................    } 
08936:  BRA    893C
....................    else {       
....................       output_bit(VENC1,OFF); 
08938:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
0893A:  BCF    F8E.7
....................    } 
0893C:  MOVLB  0
0893E:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08CC6:  MOVLB  8
08CC8:  MOVF   xCE,F
08CCA:  BNZ   8CF2
08CCC:  MOVF   xCF,F
08CCE:  BNZ   8CF2
....................       edge_mode=0; 
08CD0:  MOVLB  7
08CD2:  CLRF   xAA
....................       switch (motor){ 
08CD4:  MOVF   x40,W
08CD6:  XORLW  00
08CD8:  MOVLB  0
08CDA:  BZ    8CE2
08CDC:  XORLW  01
08CDE:  BZ    8CEA
08CE0:  BRA    8CF0
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08CE2:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08CE4:  BSF    FF0.3
08CE6:  BCF    FF1.5
....................             break; 
08CE8:  BRA    8CF0
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08CEA:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08CEC:  BSF    FF0.4
08CEE:  BCF    FF1.4
....................             break; 
08CF0:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08CF2:  DECFSZ xCE,W
08CF4:  BRA    8D1C
08CF6:  MOVF   xCF,F
08CF8:  BNZ   8D1C
....................       edge_mode=0; 
08CFA:  MOVLB  7
08CFC:  CLRF   xAA
....................       switch (motor){ 
08CFE:  MOVF   x40,W
08D00:  XORLW  00
08D02:  MOVLB  0
08D04:  BZ    8D0C
08D06:  XORLW  01
08D08:  BZ    8D14
08D0A:  BRA    8D1A
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08D0C:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08D0E:  BSF    FF0.3
08D10:  BSF    FF1.5
....................             break; 
08D12:  BRA    8D1A
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08D14:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08D16:  BSF    FF0.4
08D18:  BSF    FF1.4
....................             break; 
08D1A:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08D1C:  MOVF   xCE,W
08D1E:  SUBLW  02
08D20:  BNZ   8D72
08D22:  MOVF   xCF,F
08D24:  BNZ   8D72
08D26:  BCF    FD8.0
08D28:  MOVLB  7
08D2A:  RLCF   x40,W
08D2C:  CLRF   03
08D2E:  ADDLW  6A
08D30:  MOVWF  FE9
08D32:  MOVLW  07
08D34:  ADDWFC 03,W
08D36:  MOVWF  FEA
08D38:  MOVFF  FEC,8D1
08D3C:  MOVF   FED,F
08D3E:  MOVFF  FEF,8D0
08D42:  MOVLB  8
08D44:  MOVF   xD0,W
08D46:  SUBLW  02
08D48:  BNZ   8D72
08D4A:  MOVF   xD1,F
08D4C:  BNZ   8D72
....................       edge_mode=1; 
08D4E:  MOVLW  01
08D50:  MOVLB  7
08D52:  MOVWF  xAA
....................       switch (motor){ 
08D54:  MOVF   x40,W
08D56:  XORLW  00
08D58:  MOVLB  0
08D5A:  BZ    8D62
08D5C:  XORLW  01
08D5E:  BZ    8D6A
08D60:  BRA    8D70
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08D62:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08D64:  BSF    FF0.3
08D66:  BSF    FF1.5
....................             break; 
08D68:  BRA    8D70
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08D6A:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08D6C:  BSF    FF0.4
08D6E:  BSF    FF1.4
....................             break; 
08D70:  MOVLB  8
....................       }  
....................    }     
08D72:  MOVLB  0
08D74:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08EDC:  MOVLB  7
08EDE:  MOVF   x40,W
08EE0:  XORLW  00
08EE2:  MOVLB  0
08EE4:  BZ    8EEC
08EE6:  XORLW  01
08EE8:  BZ    8F16
08EEA:  BRA    8F3E
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08EEC:  BCF    FD8.0
08EEE:  MOVLB  7
08EF0:  RLCF   x40,W
08EF2:  CLRF   03
08EF4:  ADDLW  96
08EF6:  MOVWF  FE9
08EF8:  MOVLW  07
08EFA:  ADDWFC 03,W
08EFC:  MOVWF  FEA
08EFE:  MOVFF  FEC,8D1
08F02:  MOVF   FED,F
08F04:  MOVFF  FEF,8D0
08F08:  MOVLW  6E
08F0A:  MOVLB  8
08F0C:  MOVWF  xCF
08F0E:  MOVLB  0
08F10:  CALL   4F68
....................          break; 
08F14:  BRA    8F3E
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08F16:  BCF    FD8.0
08F18:  MOVLB  7
08F1A:  RLCF   x40,W
08F1C:  CLRF   03
08F1E:  ADDLW  96
08F20:  MOVWF  FE9
08F22:  MOVLW  07
08F24:  ADDWFC 03,W
08F26:  MOVWF  FEA
08F28:  MOVFF  FEC,8D1
08F2C:  MOVF   FED,F
08F2E:  MOVFF  FEF,8D0
08F32:  MOVLW  70
08F34:  MOVLB  8
08F36:  MOVWF  xCF
08F38:  MOVLB  0
08F3A:  CALL   4F68
....................          break;          
....................    } 
08F3E:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08D76:  MOVLB  8
08D78:  MOVF   xCD,F
08D7A:  BNZ   8D98
....................    { 
....................       switch (motor) 
08D7C:  MOVLB  7
08D7E:  MOVF   x40,W
08D80:  XORLW  00
08D82:  MOVLB  0
08D84:  BZ    8D8C
08D86:  XORLW  01
08D88:  BZ    8D92
08D8A:  BRA    8D96
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08D8C:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08D8E:  BCF    FF0.3
....................             break; 
08D90:  BRA    8D96
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08D92:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08D94:  BCF    FF0.4
....................             break; 
08D96:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08D98:  DECFSZ xCD,W
08D9A:  BRA    8E00
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08D9C:  BCF    FD8.0
08D9E:  MOVLB  7
08DA0:  RLCF   x40,W
08DA2:  CLRF   03
08DA4:  ADDLW  6A
08DA6:  MOVWF  FE9
08DA8:  MOVLW  07
08DAA:  ADDWFC 03,W
08DAC:  MOVWF  FEA
08DAE:  MOVFF  FEC,8CF
08DB2:  MOVF   FED,F
08DB4:  MOVFF  FEF,8CE
08DB8:  MOVLB  8
08DBA:  DECFSZ xCE,W
08DBC:  BRA    8DCC
08DBE:  MOVF   xCF,F
08DC0:  BNZ   8DCC
08DC2:  CLRF   xCF
08DC4:  CLRF   xCE
08DC6:  MOVLB  0
08DC8:  RCALL  8CC6
08DCA:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08DCC:  BCF    FD8.0
08DCE:  MOVLB  7
08DD0:  RLCF   x40,W
08DD2:  CLRF   03
08DD4:  ADDLW  6A
08DD6:  MOVWF  FE9
08DD8:  MOVLW  07
08DDA:  ADDWFC 03,W
08DDC:  MOVWF  FEA
08DDE:  MOVFF  FEC,8CF
08DE2:  MOVF   FED,F
08DE4:  MOVFF  FEF,8CE
08DE8:  MOVLB  8
08DEA:  MOVF   xCE,W
08DEC:  SUBLW  02
08DEE:  BNZ   8E00
08DF0:  MOVF   xCF,F
08DF2:  BNZ   8E00
08DF4:  CLRF   xCF
08DF6:  MOVLW  01
08DF8:  MOVWF  xCE
08DFA:  MOVLB  0
08DFC:  RCALL  8CC6
08DFE:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08E00:  MOVF   xCD,W
08E02:  SUBLW  02
08E04:  BNZ   8E3A
08E06:  BCF    FD8.0
08E08:  MOVLB  7
08E0A:  RLCF   x40,W
08E0C:  CLRF   03
08E0E:  ADDLW  6A
08E10:  MOVWF  FE9
08E12:  MOVLW  07
08E14:  ADDWFC 03,W
08E16:  MOVWF  FEA
08E18:  MOVFF  FEC,8CF
08E1C:  MOVF   FED,F
08E1E:  MOVFF  FEF,8CE
08E22:  MOVLB  8
08E24:  MOVF   xCE,W
08E26:  SUBLW  02
08E28:  BNZ   8E3A
08E2A:  MOVF   xCF,F
08E2C:  BNZ   8E3A
....................    { 
....................       enable_enc_isr(2);   
08E2E:  CLRF   xCF
08E30:  MOVLW  02
08E32:  MOVWF  xCE
08E34:  MOVLB  0
08E36:  RCALL  8CC6
08E38:  MOVLB  8
....................    } 
08E3A:  MOVLB  0
08E3C:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08B66:  BCF    FD8.0
08B68:  MOVLB  7
08B6A:  RLCF   x40,W
08B6C:  CLRF   03
08B6E:  ADDLW  8E
08B70:  MOVWF  FE9
08B72:  MOVLW  07
08B74:  ADDWFC 03,W
08B76:  MOVWF  FEA
08B78:  CLRF   FEC
08B7A:  MOVF   FED,F
08B7C:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08B7E:  BCF    FD8.0
08B80:  RLCF   x40,W
08B82:  CLRF   03
08B84:  ADDLW  BB
08B86:  MOVWF  FE9
08B88:  MOVLW  07
08B8A:  ADDWFC 03,W
08B8C:  MOVWF  FEA
08B8E:  CLRF   FEC
08B90:  MOVF   FED,F
08B92:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08B94:  BCF    FD8.0
08B96:  RLCF   x40,W
08B98:  CLRF   03
08B9A:  ADDLW  9A
08B9C:  MOVWF  FE9
08B9E:  MOVLW  07
08BA0:  ADDWFC 03,W
08BA2:  MOVWF  FEA
08BA4:  CLRF   FEC
08BA6:  MOVF   FED,F
08BA8:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08BAA:  BSF    F8E.1
....................    enc_pwr(ON); 
08BAC:  MOVLW  01
08BAE:  MOVLB  8
08BB0:  MOVWF  xCD
08BB2:  MOVLB  0
08BB4:  RCALL  892C
....................    delay_ms(100); 
08BB6:  MOVLW  64
08BB8:  MOVLB  9
08BBA:  MOVWF  xCD
08BBC:  MOVLB  0
08BBE:  CALL   28AC
....................     
....................    switch (motor){ 
08BC2:  MOVLB  7
08BC4:  MOVF   x40,W
08BC6:  XORLW  00
08BC8:  MOVLB  0
08BCA:  BZ    8BD2
08BCC:  XORLW  01
08BCE:  BZ    8BD6
08BD0:  BRA    8BD8
....................       case 0 : motor_setup1(); 
08BD2:  BRA    8940
....................          break; 
08BD4:  BRA    8BD8
....................       case 1 : motor_setup2(); 
08BD6:  BRA    8A52
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08BD8:  BCF    FD8.0
08BDA:  MOVLB  7
08BDC:  RLCF   x40,W
08BDE:  CLRF   03
08BE0:  ADDLW  8A
08BE2:  MOVWF  FE9
08BE4:  MOVLW  07
08BE6:  ADDWFC 03,W
08BE8:  MOVWF  FEA
08BEA:  MOVFF  FEC,8BA
08BEE:  MOVF   FED,F
08BF0:  MOVFF  FEF,8B9
08BF4:  BCF    FD8.0
08BF6:  RLCF   x40,W
08BF8:  CLRF   03
08BFA:  ADDLW  86
08BFC:  MOVWF  FE9
08BFE:  MOVLW  07
08C00:  ADDWFC 03,W
08C02:  MOVWF  FEA
08C04:  MOVFF  FEC,03
08C08:  MOVF   FED,F
08C0A:  MOVF   FEF,W
08C0C:  MOVLB  8
08C0E:  SUBWF  xB9,W
08C10:  BNZ   8C18
08C12:  MOVF   03,W
08C14:  SUBWF  xBA,W
08C16:  BZ    8CC0
....................       m_way_rst[motor]=m_way[motor]; 
08C18:  BCF    FD8.0
08C1A:  MOVLB  7
08C1C:  RLCF   x40,W
08C1E:  CLRF   03
08C20:  ADDLW  8A
08C22:  MOVWF  01
08C24:  MOVLW  07
08C26:  ADDWFC 03,F
08C28:  MOVLB  8
08C2A:  MOVFF  03,8BA
08C2E:  BCF    FD8.0
08C30:  MOVLB  7
08C32:  RLCF   x40,W
08C34:  CLRF   03
08C36:  ADDLW  86
08C38:  MOVWF  FE9
08C3A:  MOVLW  07
08C3C:  ADDWFC 03,W
08C3E:  MOVWF  FEA
08C40:  MOVFF  FEC,03
08C44:  MOVF   FED,F
08C46:  MOVFF  FEF,8BB
08C4A:  MOVLB  8
08C4C:  MOVFF  8BA,FEA
08C50:  MOVFF  01,FE9
08C54:  MOVFF  03,FEC
08C58:  MOVF   FED,F
08C5A:  MOVFF  8BB,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08C5E:  BCF    FD8.0
08C60:  MOVLB  7
08C62:  RLCF   x40,W
08C64:  CLRF   03
08C66:  ADDLW  9E
08C68:  MOVWF  01
08C6A:  MOVLW  07
08C6C:  ADDWFC 03,F
08C6E:  MOVLB  8
08C70:  MOVFF  03,8BA
08C74:  BCF    FD8.0
08C76:  MOVLB  7
08C78:  RLCF   x40,W
08C7A:  CLRF   03
08C7C:  ADDLW  66
08C7E:  MOVWF  FE9
08C80:  MOVLW  07
08C82:  ADDWFC 03,W
08C84:  MOVWF  FEA
08C86:  MOVFF  FEC,03
08C8A:  MOVF   FED,F
08C8C:  MOVFF  FEF,8BB
08C90:  MOVLB  8
08C92:  MOVFF  8BA,FEA
08C96:  MOVFF  01,FE9
08C9A:  MOVFF  03,FEC
08C9E:  MOVF   FED,F
08CA0:  MOVFF  8BB,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08CA4:  BCF    FD8.0
08CA6:  MOVLB  7
08CA8:  RLCF   x40,W
08CAA:  CLRF   03
08CAC:  ADDLW  66
08CAE:  MOVWF  FE9
08CB0:  MOVLW  07
08CB2:  ADDWFC 03,W
08CB4:  MOVWF  FEA
08CB6:  CLRF   FEC
08CB8:  MOVF   FED,F
08CBA:  MOVLW  05
08CBC:  MOVWF  FEF
08CBE:  MOVLB  8
....................    } 
08CC0:  MOVLB  0
08CC2:  GOTO   8E40 (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08E3E:  BRA    8B66
....................     
....................    m_comp[motor]=FALSE; 
08E40:  BCF    FD8.0
08E42:  MOVLB  7
08E44:  RLCF   x40,W
08E46:  CLRF   03
08E48:  ADDLW  AF
08E4A:  MOVWF  FE9
08E4C:  MOVLW  07
08E4E:  ADDWFC 03,W
08E50:  MOVWF  FEA
08E52:  CLRF   FEC
08E54:  MOVF   FED,F
08E56:  CLRF   FEF
....................     
....................    switch (motor){ 
08E58:  MOVF   x40,W
08E5A:  XORLW  00
08E5C:  MOVLB  0
08E5E:  BZ    8E66
08E60:  XORLW  01
08E62:  BZ    8E78
08E64:  BRA    8E88
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08E66:  MOVLW  B2
08E68:  MOVLB  8
08E6A:  MOVWF  xCF
08E6C:  CLRF   xD1
08E6E:  CLRF   xD0
08E70:  MOVLB  0
08E72:  CALL   4F68
....................          break; 
08E76:  BRA    8E88
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08E78:  MOVLW  B4
08E7A:  MOVLB  8
08E7C:  MOVWF  xCF
08E7E:  CLRF   xD1
08E80:  CLRF   xD0
08E82:  MOVLB  0
08E84:  CALL   4F68
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08E88:  MOVLB  7
08E8A:  MOVF   x40,W
08E8C:  XORLW  00
08E8E:  MOVLB  0
08E90:  BZ    8E98
08E92:  XORLW  01
08E94:  BZ    8E9C
08E96:  BRA    8E9E
....................       case 0 : output_bit(M1_ENABLE, ON); 
08E98:  BSF    F90.1
....................          break; 
08E9A:  BRA    8E9E
....................       case 1 : output_bit(M2_ENABLE, ON); 
08E9C:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08E9E:  MOVLW  32
08EA0:  MOVLB  9
08EA2:  MOVWF  xCD
08EA4:  MOVLB  0
08EA6:  CALL   28AC
....................     
....................    set_timer3(STEP_INTERVAL); 
08EAA:  MOVLW  F9
08EAC:  MOVWF  FB3
08EAE:  MOVLW  C0
08EB0:  MOVWF  FB2
....................    enc_isr(int_mode); 
08EB2:  MOVFF  8B8,8CD
08EB6:  RCALL  8D76
....................    clear_interrupt(INT_TIMER3); 
08EB8:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08EBA:  BCF    FD8.0
08EBC:  MOVLB  7
08EBE:  RLCF   x40,W
08EC0:  CLRF   03
08EC2:  ADDLW  92
08EC4:  MOVWF  FE9
08EC6:  MOVLW  07
08EC8:  ADDWFC 03,W
08ECA:  MOVWF  FEA
08ECC:  CLRF   FEC
08ECE:  MOVF   FED,F
08ED0:  MOVLW  01
08ED2:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08ED4:  BSF    FA0.1
08ED6:  MOVLB  0
08ED8:  GOTO   A150 (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
08562:  MOVFF  8BB,8C3
08566:  MOVFF  8BA,8C2
0856A:  MOVFF  8B9,8C1
0856E:  MOVFF  8B8,8C0
....................    enc_res    = e_cpr[motor]; 
08572:  BCF    FD8.0
08574:  MOVLB  7
08576:  RLCF   x40,W
08578:  CLRF   03
0857A:  ADDLW  5E
0857C:  MOVWF  FE9
0857E:  MOVLW  07
08580:  ADDWFC 03,W
08582:  MOVWF  FEA
08584:  MOVLB  8
08586:  CLRF   xC7
08588:  CLRF   xC6
0858A:  MOVFF  FEC,8C5
0858E:  MOVF   FED,F
08590:  MOVFF  FEF,8C4
....................    ports      = e_ppr[motor]; 
08594:  BCF    FD8.0
08596:  MOVLB  7
08598:  RLCF   x40,W
0859A:  CLRF   03
0859C:  ADDLW  62
0859E:  MOVWF  FE9
085A0:  MOVLW  07
085A2:  ADDWFC 03,W
085A4:  MOVWF  FEA
085A6:  MOVLB  8
085A8:  CLRF   xCF
085AA:  CLRF   xCE
085AC:  MOVFF  FEC,8CD
085B0:  MOVF   FED,F
085B2:  MOVFF  FEF,8CC
....................     
....................    enc_res = enc_res * 1000; 
085B6:  MOVFF  8C7,9DA
085BA:  MOVFF  8C6,9D9
085BE:  MOVFF  8C5,9D8
085C2:  MOVFF  8C4,9D7
085C6:  MOVLB  9
085C8:  CLRF   xDE
085CA:  CLRF   xDD
085CC:  MOVLW  03
085CE:  MOVWF  xDC
085D0:  MOVLW  E8
085D2:  MOVWF  xDB
085D4:  MOVLB  0
085D6:  CALL   478E
085DA:  MOVFF  03,8C7
085DE:  MOVFF  02,8C6
085E2:  MOVFF  01,8C5
085E6:  MOVFF  00,8C4
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
085EA:  BCF    FD8.1
085EC:  CLRF   1B
085EE:  BTFSC  FF2.7
085F0:  BSF    1B.7
085F2:  BCF    FF2.7
085F4:  MOVFF  8C7,A2B
085F8:  MOVFF  8C6,A2A
085FC:  MOVFF  8C5,A29
08600:  MOVFF  8C4,A28
08604:  MOVFF  8CF,A2F
08608:  MOVFF  8CE,A2E
0860C:  MOVFF  8CD,A2D
08610:  MOVFF  8CC,A2C
08614:  CALL   1056
08618:  BTFSC  1B.7
0861A:  BSF    FF2.7
0861C:  MOVFF  03,8BF
08620:  MOVFF  02,8BE
08624:  MOVFF  01,8BD
08628:  MOVFF  00,8BC
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
0862C:  MOVFF  8BB,9DA
08630:  MOVFF  8BA,9D9
08634:  MOVFF  8B9,9D8
08638:  MOVFF  8B8,9D7
0863C:  MOVFF  8BF,9DE
08640:  MOVFF  8BE,9DD
08644:  MOVFF  8BD,9DC
08648:  MOVFF  8BC,9DB
0864C:  CALL   478E
08650:  MOVLB  8
08652:  MOVF   xBC,W
08654:  SUBWF  00,W
08656:  MOVWF  xC0
08658:  MOVF   xBD,W
0865A:  SUBWFB 01,W
0865C:  MOVWF  xC1
0865E:  MOVF   xBE,W
08660:  SUBWFB 02,W
08662:  MOVWF  xC2
08664:  MOVF   xBF,W
08666:  SUBWFB 03,W
08668:  MOVWF  xC3
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
0866A:  BCF    FD8.1
0866C:  CLRF   1B
0866E:  BTFSC  FF2.7
08670:  BSF    1B.7
08672:  BCF    FF2.7
08674:  MOVFF  8C3,A2B
08678:  MOVFF  8C2,A2A
0867C:  MOVFF  8C1,A29
08680:  MOVFF  8C0,A28
08684:  MOVLB  A
08686:  CLRF   x2F
08688:  CLRF   x2E
0868A:  MOVLW  03
0868C:  MOVWF  x2D
0868E:  MOVLW  E8
08690:  MOVWF  x2C
08692:  MOVLB  0
08694:  CALL   1056
08698:  BTFSC  1B.7
0869A:  BSF    FF2.7
0869C:  MOVFF  03,8CB
086A0:  MOVFF  02,8CA
086A4:  MOVFF  01,8C9
086A8:  MOVFF  00,8C8
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
086AC:  MOVFF  8CB,9DA
086B0:  MOVFF  8CA,9D9
086B4:  MOVFF  8C9,9D8
086B8:  MOVFF  8C8,9D7
086BC:  MOVLB  9
086BE:  CLRF   xDE
086C0:  CLRF   xDD
086C2:  MOVLW  03
086C4:  MOVWF  xDC
086C6:  MOVLW  E8
086C8:  MOVWF  xDB
086CA:  MOVLB  0
086CC:  CALL   478E
086D0:  MOVFF  03,8CB
086D4:  MOVFF  02,8CA
086D8:  MOVFF  01,8C9
086DC:  MOVFF  00,8C8
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
086E0:  MOVLB  8
086E2:  MOVF   xC8,W
086E4:  SUBWF  xC0,F
086E6:  MOVF   xC9,W
086E8:  SUBWFB xC1,F
086EA:  MOVF   xCA,W
086EC:  SUBWFB xC2,F
086EE:  MOVF   xCB,W
086F0:  SUBWFB xC3,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
086F2:  BCF    FD8.1
086F4:  CLRF   1B
086F6:  BTFSC  FF2.7
086F8:  BSF    1B.7
086FA:  BCF    FF2.7
086FC:  MOVFF  8CB,A2B
08700:  MOVFF  8CA,A2A
08704:  MOVFF  8C9,A29
08708:  MOVFF  8C8,A28
0870C:  MOVLB  A
0870E:  CLRF   x2F
08710:  CLRF   x2E
08712:  MOVLW  03
08714:  MOVWF  x2D
08716:  MOVLW  E8
08718:  MOVWF  x2C
0871A:  MOVLB  0
0871C:  CALL   1056
08720:  BTFSC  1B.7
08722:  BSF    FF2.7
08724:  MOVFF  03,8CB
08728:  MOVFF  02,8CA
0872C:  MOVFF  01,8C9
08730:  MOVFF  00,8C8
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
08734:  MOVLB  8
08736:  MOVF   xC3,F
08738:  BNZ   874E
0873A:  MOVF   xC2,F
0873C:  BNZ   874E
0873E:  MOVF   xC1,W
08740:  SUBLW  00
08742:  BC    875E
08744:  XORLW  FF
08746:  BNZ   874E
08748:  MOVF   xC0,W
0874A:  SUBLW  F3
0874C:  BC    875E
0874E:  MOVLW  01
08750:  ADDWF  xC8,F
08752:  BTFSC  FD8.0
08754:  INCF   xC9,F
08756:  BTFSC  FD8.2
08758:  INCF   xCA,F
0875A:  BTFSC  FD8.2
0875C:  INCF   xCB,F
....................    return(enc_pos); 
0875E:  MOVFF  8C8,00
08762:  MOVFF  8C9,01
08766:  MOVFF  8CA,02
0876A:  MOVFF  8CB,03
0876E:  MOVLB  0
08770:  GOTO   A0D8 (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
08774:  BCF    FD8.0
08776:  MOVLB  7
08778:  RLCF   x40,W
0877A:  CLRF   03
0877C:  ADDLW  BF
0877E:  MOVWF  FE9
08780:  MOVLW  07
08782:  ADDWFC 03,W
08784:  MOVWF  FEA
08786:  MOVFF  FEC,03
0878A:  MOVF   FED,F
0878C:  MOVFF  FEF,01
08790:  MOVF   03,W
08792:  MOVLB  8
08794:  SUBWF  xBB,W
08796:  BNC   885E
08798:  BNZ   87A0
0879A:  MOVF   xBA,W
0879C:  SUBWF  01,W
0879E:  BC    885E
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
087A0:  BCF    FD8.0
087A2:  MOVLB  7
087A4:  RLCF   x40,W
087A6:  CLRF   03
087A8:  ADDLW  BF
087AA:  MOVWF  FE9
087AC:  MOVLW  07
087AE:  ADDWFC 03,W
087B0:  MOVWF  FEA
087B2:  MOVFF  FEC,03
087B6:  MOVF   FED,F
087B8:  MOVF   FEF,W
087BA:  MOVLB  8
087BC:  SUBWF  xBA,W
087BE:  MOVWF  xBC
087C0:  MOVF   03,W
087C2:  SUBWFB xBB,W
087C4:  MOVWF  xBD
....................       if (e_pos_r > (e_cpr[motor]/2)) 
087C6:  BCF    FD8.0
087C8:  MOVLB  7
087CA:  RLCF   x40,W
087CC:  CLRF   03
087CE:  ADDLW  5E
087D0:  MOVWF  FE9
087D2:  MOVLW  07
087D4:  ADDWFC 03,W
087D6:  MOVWF  FEA
087D8:  MOVFF  FEC,8BF
087DC:  MOVF   FED,F
087DE:  MOVFF  FEF,8BE
087E2:  BCF    FD8.0
087E4:  MOVLB  8
087E6:  RRCF   xBF,W
087E8:  MOVWF  03
087EA:  RRCF   xBE,W
087EC:  MOVWF  02
087EE:  MOVWF  01
087F0:  MOVF   03,W
087F2:  SUBWF  xBD,W
087F4:  BNC   8842
087F6:  BNZ   87FE
087F8:  MOVF   xBC,W
087FA:  SUBWF  01,W
087FC:  BC    8842
....................       { 
....................          m_way[motor] = NEG; 
087FE:  BCF    FD8.0
08800:  MOVLB  7
08802:  RLCF   x40,W
08804:  CLRF   03
08806:  ADDLW  86
08808:  MOVWF  FE9
0880A:  MOVLW  07
0880C:  ADDWFC 03,W
0880E:  MOVWF  FEA
08810:  CLRF   FEC
08812:  MOVF   FED,F
08814:  MOVLW  01
08816:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
08818:  BCF    FD8.0
0881A:  RLCF   x40,W
0881C:  CLRF   03
0881E:  ADDLW  5E
08820:  MOVWF  FE9
08822:  MOVLW  07
08824:  ADDWFC 03,W
08826:  MOVWF  FEA
08828:  MOVFF  FEC,8BF
0882C:  MOVF   FED,F
0882E:  MOVFF  FEF,8BE
08832:  MOVLB  8
08834:  MOVF   xBC,W
08836:  SUBWF  xBE,W
08838:  MOVWF  xBC
0883A:  MOVF   xBD,W
0883C:  SUBWFB xBF,W
0883E:  MOVWF  xBD
....................       } 
08840:  BRA    885C
....................       else 
....................       { 
....................          m_way[motor] = POS; 
08842:  BCF    FD8.0
08844:  MOVLB  7
08846:  RLCF   x40,W
08848:  CLRF   03
0884A:  ADDLW  86
0884C:  MOVWF  FE9
0884E:  MOVLW  07
08850:  ADDWFC 03,W
08852:  MOVWF  FEA
08854:  CLRF   FEC
08856:  MOVF   FED,F
08858:  CLRF   FEF
0885A:  MOVLB  8
....................       } 
....................    } 
0885C:  BRA    891E
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
0885E:  BCF    FD8.0
08860:  MOVLB  7
08862:  RLCF   x40,W
08864:  CLRF   03
08866:  ADDLW  BF
08868:  MOVWF  FE9
0886A:  MOVLW  07
0886C:  ADDWFC 03,W
0886E:  MOVWF  FEA
08870:  MOVFF  FEC,8BF
08874:  MOVF   FED,F
08876:  MOVFF  FEF,8BE
0887A:  MOVLB  8
0887C:  MOVF   xBA,W
0887E:  SUBWF  xBE,W
08880:  MOVWF  xBC
08882:  MOVF   xBB,W
08884:  SUBWFB xBF,W
08886:  MOVWF  xBD
....................       if (e_pos_r > (e_cpr[motor]/2)) 
08888:  BCF    FD8.0
0888A:  MOVLB  7
0888C:  RLCF   x40,W
0888E:  CLRF   03
08890:  ADDLW  5E
08892:  MOVWF  FE9
08894:  MOVLW  07
08896:  ADDWFC 03,W
08898:  MOVWF  FEA
0889A:  MOVFF  FEC,8BF
0889E:  MOVF   FED,F
088A0:  MOVFF  FEF,8BE
088A4:  BCF    FD8.0
088A6:  MOVLB  8
088A8:  RRCF   xBF,W
088AA:  MOVWF  03
088AC:  RRCF   xBE,W
088AE:  MOVWF  02
088B0:  MOVWF  01
088B2:  MOVF   03,W
088B4:  SUBWF  xBD,W
088B6:  BNC   8902
088B8:  BNZ   88C0
088BA:  MOVF   xBC,W
088BC:  SUBWF  01,W
088BE:  BC    8902
....................       { 
....................          m_way[motor] = POS; 
088C0:  BCF    FD8.0
088C2:  MOVLB  7
088C4:  RLCF   x40,W
088C6:  CLRF   03
088C8:  ADDLW  86
088CA:  MOVWF  FE9
088CC:  MOVLW  07
088CE:  ADDWFC 03,W
088D0:  MOVWF  FEA
088D2:  CLRF   FEC
088D4:  MOVF   FED,F
088D6:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088D8:  BCF    FD8.0
088DA:  RLCF   x40,W
088DC:  CLRF   03
088DE:  ADDLW  5E
088E0:  MOVWF  FE9
088E2:  MOVLW  07
088E4:  ADDWFC 03,W
088E6:  MOVWF  FEA
088E8:  MOVFF  FEC,8BF
088EC:  MOVF   FED,F
088EE:  MOVFF  FEF,8BE
088F2:  MOVLB  8
088F4:  MOVF   xBC,W
088F6:  SUBWF  xBE,W
088F8:  MOVWF  xBC
088FA:  MOVF   xBD,W
088FC:  SUBWFB xBF,W
088FE:  MOVWF  xBD
....................       } 
08900:  BRA    891E
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
08902:  BCF    FD8.0
08904:  MOVLB  7
08906:  RLCF   x40,W
08908:  CLRF   03
0890A:  ADDLW  86
0890C:  MOVWF  FE9
0890E:  MOVLW  07
08910:  ADDWFC 03,W
08912:  MOVWF  FEA
08914:  CLRF   FEC
08916:  MOVF   FED,F
08918:  MOVLW  01
0891A:  MOVWF  FEF
0891C:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
0891E:  MOVFF  8BC,01
08922:  MOVFF  8BD,02
08926:  MOVLB  0
08928:  GOTO   A104 (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
0902C:  BCF    FD8.0
0902E:  MOVLB  7
09030:  RLCF   x40,W
09032:  CLRF   03
09034:  ADDLW  92
09036:  MOVWF  FE9
09038:  MOVLW  07
0903A:  ADDWFC 03,W
0903C:  MOVWF  FEA
0903E:  CLRF   FEC
09040:  MOVF   FED,F
09042:  CLRF   FEF
....................           
....................    switch (motor){ 
09044:  MOVF   x40,W
09046:  XORLW  00
09048:  MOVLB  0
0904A:  BZ    9052
0904C:  XORLW  01
0904E:  BZ    90BC
09050:  BRA    912A
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
09052:  BCF    FD8.0
09054:  MOVLB  7
09056:  RLCF   x40,W
09058:  CLRF   03
0905A:  ADDLW  52
0905C:  MOVWF  FE9
0905E:  MOVLW  07
09060:  ADDWFC 03,W
09062:  MOVWF  FEA
09064:  MOVFF  FEC,8CE
09068:  MOVF   FED,F
0906A:  MOVFF  FEF,8CD
0906E:  MOVLB  8
09070:  MOVF   xCD,F
09072:  BNZ   9078
09074:  MOVF   xCE,F
09076:  BZ    90B6
09078:  BCF    FD8.0
0907A:  MOVLB  7
0907C:  RLCF   x40,W
0907E:  CLRF   03
09080:  ADDLW  52
09082:  MOVWF  FE9
09084:  MOVLW  07
09086:  ADDWFC 03,W
09088:  MOVWF  FEA
0908A:  MOVFF  FEC,8CE
0908E:  MOVF   FED,F
09090:  MOVFF  FEF,8CD
09094:  MOVLB  8
09096:  RRCF   xCE,F
09098:  RRCF   xCD,F
0909A:  RRCF   xCE,F
0909C:  RRCF   xCD,F
0909E:  RRCF   xCE,F
090A0:  MOVFF  8CD,FBC
090A4:  RRCF   xCE,F
090A6:  RRCF   xCE,W
090A8:  ANDLW  30
090AA:  MOVWF  00
090AC:  MOVF   FBB,W
090AE:  ANDLW  CF
090B0:  IORWF  00,W
090B2:  MOVWF  FBB
090B4:  BRA    90B8
....................                else output_bit(M1_ENABLE, OFF); 
090B6:  BCF    F90.1
....................          break;   
090B8:  MOVLB  0
090BA:  BRA    912A
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
090BC:  BCF    FD8.0
090BE:  MOVLB  7
090C0:  RLCF   x40,W
090C2:  CLRF   03
090C4:  ADDLW  52
090C6:  MOVWF  FE9
090C8:  MOVLW  07
090CA:  ADDWFC 03,W
090CC:  MOVWF  FEA
090CE:  MOVFF  FEC,8CE
090D2:  MOVF   FED,F
090D4:  MOVFF  FEF,8CD
090D8:  MOVLB  8
090DA:  MOVF   xCD,F
090DC:  BNZ   90E2
090DE:  MOVF   xCE,F
090E0:  BZ    9124
090E2:  BCF    FD8.0
090E4:  MOVLB  7
090E6:  RLCF   x40,W
090E8:  CLRF   03
090EA:  ADDLW  52
090EC:  MOVWF  FE9
090EE:  MOVLW  07
090F0:  ADDWFC 03,W
090F2:  MOVWF  FEA
090F4:  MOVFF  FEC,8CE
090F8:  MOVF   FED,F
090FA:  MOVFF  FEF,8CD
090FE:  MOVLB  8
09100:  RRCF   xCE,F
09102:  RRCF   xCD,F
09104:  RRCF   xCE,F
09106:  RRCF   xCD,F
09108:  RRCF   xCE,F
0910A:  MOVFF  8CD,F4F
0910E:  RRCF   xCE,F
09110:  RRCF   xCE,W
09112:  ANDLW  30
09114:  MOVWF  00
09116:  MOVLB  F
09118:  MOVF   x4E,W
0911A:  ANDLW  CF
0911C:  IORWF  00,W
0911E:  MOVWF  x4E
09120:  BRA    9128
09122:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
09124:  BCF    F8D.1
09126:  MOVLB  F
....................          break; 
09128:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
0912A:  BCF    FA0.1
....................    enc_isr(OFF); 
0912C:  MOVLB  8
0912E:  CLRF   xCD
09130:  MOVLB  0
09132:  RCALL  8D76
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
09134:  MOVLB  7
09136:  MOVF   x52,F
09138:  BNZ   9148
0913A:  MOVF   x53,F
0913C:  BNZ   9148
0913E:  MOVF   x54,F
09140:  BNZ   9148
09142:  MOVF   x55,F
09144:  BNZ   9148
....................    { 
....................       output_bit(VMOT,OFF); 
09146:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
09148:  MOVLB  8
0914A:  CLRF   xCD
0914C:  MOVLB  0
0914E:  CALL   892C
....................  
....................    if(success==TRUE) 
09152:  MOVLB  8
09154:  DECFSZ xCC,W
09156:  BRA    92F2
....................    { 
....................       m_error[motor]=FALSE; 
09158:  BCF    FD8.0
0915A:  MOVLB  7
0915C:  RLCF   x40,W
0915E:  CLRF   03
09160:  ADDLW  96
09162:  MOVWF  FE9
09164:  MOVLW  07
09166:  ADDWFC 03,W
09168:  MOVWF  FEA
0916A:  CLRF   FEC
0916C:  MOVF   FED,F
0916E:  CLRF   FEF
....................       wrt_m_error(); 
09170:  MOVLB  0
09172:  RCALL  8EDC
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
09174:  BCF    FD8.0
09176:  MOVLB  7
09178:  RLCF   x40,W
0917A:  CLRF   03
0917C:  ADDLW  66
0917E:  MOVWF  FE9
09180:  MOVLW  07
09182:  ADDWFC 03,W
09184:  MOVWF  FEA
09186:  MOVFF  FEC,8CE
0918A:  MOVF   FED,F
0918C:  MOVFF  FEF,8CD
09190:  MOVLB  8
09192:  MOVF   xCD,W
09194:  SUBLW  03
09196:  BNZ   91CE
09198:  MOVF   xCE,F
0919A:  BNZ   91CE
....................       { 
....................          e_pos[motor] = 0; 
0919C:  BCF    FD8.0
0919E:  MOVLB  7
091A0:  RLCF   x40,W
091A2:  CLRF   03
091A4:  ADDLW  BF
091A6:  MOVWF  FE9
091A8:  MOVLW  07
091AA:  ADDWFC 03,W
091AC:  MOVWF  FEA
091AE:  CLRF   FEC
091B0:  MOVF   FED,F
091B2:  CLRF   FEF
....................          e_port[motor] = 1; 
091B4:  BCF    FD8.0
091B6:  RLCF   x40,W
091B8:  CLRF   03
091BA:  ADDLW  C3
091BC:  MOVWF  FE9
091BE:  MOVLW  07
091C0:  ADDWFC 03,W
091C2:  MOVWF  FEA
091C4:  CLRF   FEC
091C6:  MOVF   FED,F
091C8:  MOVLW  01
091CA:  MOVWF  FEF
091CC:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
091CE:  BCF    FD8.0
091D0:  MOVLB  7
091D2:  RLCF   x40,W
091D4:  CLRF   03
091D6:  ADDLW  66
091D8:  MOVWF  FE9
091DA:  MOVLW  07
091DC:  ADDWFC 03,W
091DE:  MOVWF  FEA
091E0:  MOVFF  FEC,8CE
091E4:  MOVF   FED,F
091E6:  MOVFF  FEF,8CD
091EA:  MOVLB  8
091EC:  MOVF   xCD,W
091EE:  SUBLW  02
091F0:  BNZ   923C
091F2:  MOVF   xCE,F
091F4:  BNZ   923C
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
091F6:  BCF    FD8.0
091F8:  MOVLB  7
091FA:  RLCF   x40,W
091FC:  CLRF   03
091FE:  ADDLW  C3
09200:  MOVWF  01
09202:  MOVLW  07
09204:  ADDWFC 03,F
09206:  MOVLB  8
09208:  MOVFF  03,8CE
0920C:  BCF    FD8.0
0920E:  MOVLB  7
09210:  RLCF   x40,W
09212:  CLRF   03
09214:  ADDLW  C7
09216:  MOVWF  FE9
09218:  MOVLW  07
0921A:  ADDWFC 03,W
0921C:  MOVWF  FEA
0921E:  MOVFF  FEC,03
09222:  MOVF   FED,F
09224:  MOVFF  FEF,8CF
09228:  MOVLB  8
0922A:  MOVFF  8CE,FEA
0922E:  MOVFF  01,FE9
09232:  MOVFF  03,FEC
09236:  MOVF   FED,F
09238:  MOVFF  8CF,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
0923C:  BCF    FD8.0
0923E:  MOVLB  7
09240:  RLCF   x40,W
09242:  CLRF   03
09244:  ADDLW  66
09246:  MOVWF  FE9
09248:  MOVLW  07
0924A:  ADDWFC 03,W
0924C:  MOVWF  FEA
0924E:  MOVFF  FEC,8CE
09252:  MOVF   FED,F
09254:  MOVFF  FEF,8CD
09258:  MOVLB  8
0925A:  MOVF   xCD,W
0925C:  SUBLW  02
0925E:  BNZ   9264
09260:  MOVF   xCE,F
09262:  BZ    928C
09264:  BCF    FD8.0
09266:  MOVLB  7
09268:  RLCF   x40,W
0926A:  CLRF   03
0926C:  ADDLW  66
0926E:  MOVWF  FE9
09270:  MOVLW  07
09272:  ADDWFC 03,W
09274:  MOVWF  FEA
09276:  MOVFF  FEC,8CE
0927A:  MOVF   FED,F
0927C:  MOVFF  FEF,8CD
09280:  MOVLB  8
09282:  MOVF   xCD,W
09284:  SUBLW  03
09286:  BNZ   92F0
09288:  MOVF   xCE,F
0928A:  BNZ   92F0
....................       { 
....................          switch(motor) 
0928C:  MOVLB  7
0928E:  MOVF   x40,W
09290:  XORLW  00
09292:  MOVLB  0
09294:  BZ    929C
09296:  XORLW  01
09298:  BZ    92C6
0929A:  BRA    92EE
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
0929C:  MOVLW  7E
0929E:  MOVLB  8
092A0:  MOVWF  xCF
092A2:  MOVFF  7C0,8D1
092A6:  MOVFF  7BF,8D0
092AA:  MOVLB  0
092AC:  CALL   4F68
....................                      write16(ADDR_E1_PORT,e_port[0]); 
092B0:  MOVLW  AA
092B2:  MOVLB  8
092B4:  MOVWF  xCF
092B6:  MOVFF  7C4,8D1
092BA:  MOVFF  7C3,8D0
092BE:  MOVLB  0
092C0:  CALL   4F68
....................                break; 
092C4:  BRA    92EE
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
092C6:  MOVLW  80
092C8:  MOVLB  8
092CA:  MOVWF  xCF
092CC:  MOVFF  7C2,8D1
092D0:  MOVFF  7C1,8D0
092D4:  MOVLB  0
092D6:  CALL   4F68
....................                      write16(ADDR_E2_PORT,e_port[1]); 
092DA:  MOVLW  AC
092DC:  MOVLB  8
092DE:  MOVWF  xCF
092E0:  MOVFF  7C6,8D1
092E4:  MOVFF  7C5,8D0
092E8:  MOVLB  0
092EA:  CALL   4F68
....................                break;             
092EE:  MOVLB  8
....................          } 
....................       } 
....................    } 
092F0:  BRA    939A
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
092F2:  BCF    FD8.0
092F4:  MOVLB  7
092F6:  RLCF   x40,W
092F8:  CLRF   03
092FA:  ADDLW  96
092FC:  MOVWF  FE9
092FE:  MOVLW  07
09300:  ADDWFC 03,W
09302:  MOVWF  FEA
09304:  CLRF   FEC
09306:  MOVF   FED,F
09308:  MOVLW  01
0930A:  MOVWF  FEF
....................       e_pos[motor] = 0; 
0930C:  BCF    FD8.0
0930E:  RLCF   x40,W
09310:  CLRF   03
09312:  ADDLW  BF
09314:  MOVWF  FE9
09316:  MOVLW  07
09318:  ADDWFC 03,W
0931A:  MOVWF  FEA
0931C:  CLRF   FEC
0931E:  MOVF   FED,F
09320:  CLRF   FEF
....................       e_port[motor] = 0; 
09322:  BCF    FD8.0
09324:  RLCF   x40,W
09326:  CLRF   03
09328:  ADDLW  C3
0932A:  MOVWF  FE9
0932C:  MOVLW  07
0932E:  ADDWFC 03,W
09330:  MOVWF  FEA
09332:  CLRF   FEC
09334:  MOVF   FED,F
09336:  CLRF   FEF
....................       switch(motor) 
09338:  MOVF   x40,W
0933A:  XORLW  00
0933C:  MOVLB  0
0933E:  BZ    9346
09340:  XORLW  01
09342:  BZ    9370
09344:  BRA    9398
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09346:  MOVLW  7E
09348:  MOVLB  8
0934A:  MOVWF  xCF
0934C:  MOVFF  7C0,8D1
09350:  MOVFF  7BF,8D0
09354:  MOVLB  0
09356:  CALL   4F68
....................                   write16(ADDR_E1_PORT,e_port[0]); 
0935A:  MOVLW  AA
0935C:  MOVLB  8
0935E:  MOVWF  xCF
09360:  MOVFF  7C4,8D1
09364:  MOVFF  7C3,8D0
09368:  MOVLB  0
0936A:  CALL   4F68
....................             break; 
0936E:  BRA    9398
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
09370:  MOVLW  80
09372:  MOVLB  8
09374:  MOVWF  xCF
09376:  MOVFF  7C2,8D1
0937A:  MOVFF  7C1,8D0
0937E:  MOVLB  0
09380:  CALL   4F68
....................                   write16(ADDR_E2_PORT,e_port[1]); 
09384:  MOVLW  AC
09386:  MOVLB  8
09388:  MOVWF  xCF
0938A:  MOVFF  7C6,8D1
0938E:  MOVFF  7C5,8D0
09392:  MOVLB  0
09394:  CALL   4F68
....................             break;             
09398:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
0939A:  BCF    FD8.0
0939C:  MOVLB  7
0939E:  RLCF   x40,W
093A0:  CLRF   03
093A2:  ADDLW  AF
093A4:  MOVWF  FE9
093A6:  MOVLW  07
093A8:  ADDWFC 03,W
093AA:  MOVWF  FEA
093AC:  CLRF   FEC
093AE:  MOVF   FED,F
093B0:  MOVLW  01
093B2:  MOVWF  FEF
....................     
....................    switch (motor) 
093B4:  MOVF   x40,W
093B6:  XORLW  00
093B8:  MOVLB  0
093BA:  BZ    93C2
093BC:  XORLW  01
093BE:  BZ    93EA
093C0:  BRA    9410
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
093C2:  MOVLW  B2
093C4:  MOVLB  8
093C6:  MOVWF  xCF
093C8:  CLRF   xD1
093CA:  MOVLW  01
093CC:  MOVWF  xD0
093CE:  MOVLB  0
093D0:  CALL   4F68
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
093D4:  MOVLW  B6
093D6:  MOVLB  8
093D8:  MOVWF  xCF
093DA:  MOVFF  7B4,8D1
093DE:  MOVFF  7B3,8D0
093E2:  MOVLB  0
093E4:  CALL   4F68
....................          break; 
093E8:  BRA    9410
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
093EA:  MOVLW  B4
093EC:  MOVLB  8
093EE:  MOVWF  xCF
093F0:  CLRF   xD1
093F2:  MOVLW  01
093F4:  MOVWF  xD0
093F6:  MOVLB  0
093F8:  CALL   4F68
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
093FC:  MOVLW  B8
093FE:  MOVLB  8
09400:  MOVWF  xCF
09402:  MOVFF  7B6,8D1
09406:  MOVFF  7B5,8D0
0940A:  MOVLB  0
0940C:  CALL   4F68
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
09410:  MOVF   1F,W
09412:  SUBLW  04
09414:  BNZ   94BA
09416:  MOVF   20,F
09418:  BNZ   94BA
....................    { 
....................       if(motor==1) 
0941A:  MOVLB  7
0941C:  DECFSZ x40,W
0941E:  BRA    94BC
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
09420:  BCF    FD8.0
09422:  RLCF   x40,W
09424:  CLRF   03
09426:  ADDLW  AF
09428:  MOVWF  FE9
0942A:  MOVLW  07
0942C:  ADDWFC 03,W
0942E:  MOVWF  FEA
09430:  MOVFF  FEC,8CE
09434:  MOVF   FED,F
09436:  MOVFF  FEF,8CD
0943A:  BCF    FD8.0
0943C:  RLCF   x40,W
0943E:  CLRF   03
09440:  ADDLW  B3
09442:  MOVWF  FE9
09444:  MOVLW  07
09446:  ADDWFC 03,W
09448:  MOVWF  FEA
0944A:  MOVFF  FEC,8D0
0944E:  MOVF   FED,F
09450:  MOVFF  FEF,8CF
09454:  MOVLW  5E
09456:  MOVWF  FF6
09458:  MOVLW  1A
0945A:  MOVWF  FF7
0945C:  MOVLW  00
0945E:  MOVWF  FF8
09460:  CLRF   1B
09462:  BTFSC  FF2.7
09464:  BSF    1B.7
09466:  BCF    FF2.7
09468:  MOVLW  05
0946A:  MOVLB  A
0946C:  MOVWF  x1C
0946E:  MOVLB  0
09470:  CALL   1024
09474:  BTFSC  1B.7
09476:  BSF    FF2.7
09478:  MOVLW  10
0947A:  MOVWF  FE9
0947C:  CLRF   1B
0947E:  BTFSC  FF2.7
09480:  BSF    1B.7
09482:  BCF    FF2.7
09484:  MOVFF  8CE,A1D
09488:  MOVFF  8CD,A1C
0948C:  CALL   11A6
09490:  BTFSC  1B.7
09492:  BSF    FF2.7
09494:  MOVLW  2C
09496:  BTFSS  F9E.4
09498:  BRA    9496
0949A:  MOVWF  FAD
0949C:  MOVLW  10
0949E:  MOVWF  FE9
094A0:  MOVFF  8D0,8D2
094A4:  MOVFF  8CF,8D1
094A8:  RCALL  8F40
094AA:  MOVLW  0D
094AC:  BTFSS  F9E.4
094AE:  BRA    94AC
094B0:  MOVWF  FAD
094B2:  MOVLW  0A
094B4:  BTFSS  F9E.4
094B6:  BRA    94B4
094B8:  MOVWF  FAD
094BA:  MOVLB  7
....................       } 
....................    } 
094BC:  MOVLB  0
094BE:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
095EC:  BCF    FD8.0
095EE:  MOVLB  7
095F0:  RLCF   x40,W
095F2:  CLRF   03
095F4:  ADDLW  6A
095F6:  MOVWF  FE9
095F8:  MOVLW  07
095FA:  ADDWFC 03,W
095FC:  MOVWF  FEA
095FE:  MOVFF  FEC,8CD
09602:  MOVF   FED,F
09604:  MOVFF  FEF,8CC
09608:  MOVLB  8
0960A:  DECFSZ xCC,W
0960C:  BRA    961C
0960E:  MOVF   xCD,F
09610:  BNZ   961C
09612:  MOVLW  01
09614:  MOVWF  xCC
09616:  MOVLB  0
09618:  RCALL  902C
0961A:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
0961C:  BCF    FD8.0
0961E:  MOVLB  7
09620:  RLCF   x40,W
09622:  CLRF   03
09624:  ADDLW  6A
09626:  MOVWF  FE9
09628:  MOVLW  07
0962A:  ADDWFC 03,W
0962C:  MOVWF  FEA
0962E:  MOVFF  FEC,8CD
09632:  MOVF   FED,F
09634:  MOVFF  FEF,8CC
09638:  MOVLB  8
0963A:  MOVF   xCC,W
0963C:  SUBLW  02
0963E:  BTFSS  FD8.2
09640:  BRA    9C4A
09642:  MOVF   xCD,F
09644:  BTFSS  FD8.2
09646:  BRA    9C4A
....................       if (e_mode[motor]==2){ 
09648:  BCF    FD8.0
0964A:  MOVLB  7
0964C:  RLCF   x40,W
0964E:  CLRF   03
09650:  ADDLW  66
09652:  MOVWF  FE9
09654:  MOVLW  07
09656:  ADDWFC 03,W
09658:  MOVWF  FEA
0965A:  MOVFF  FEC,8CD
0965E:  MOVF   FED,F
09660:  MOVFF  FEF,8CC
09664:  MOVLB  8
09666:  MOVF   xCC,W
09668:  SUBLW  02
0966A:  BTFSS  FD8.2
0966C:  BRA    9BC6
0966E:  MOVF   xCD,F
09670:  BTFSS  FD8.2
09672:  BRA    9BC6
....................          if(nv_product==ECO || nv_product==WMS2){ 
09674:  MOVF   2F,F
09676:  BNZ   967C
09678:  MOVF   30,F
0967A:  BZ    968A
0967C:  MOVF   2F,W
0967E:  SUBLW  03
09680:  BTFSS  FD8.2
09682:  BRA    97CE
09684:  MOVF   30,F
09686:  BTFSS  FD8.2
09688:  BRA    97CE
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
0968A:  BCF    FD8.0
0968C:  MOVLB  7
0968E:  RLCF   x40,W
09690:  CLRF   03
09692:  ADDLW  AB
09694:  MOVWF  FE9
09696:  MOVLW  07
09698:  ADDWFC 03,W
0969A:  MOVWF  FEA
0969C:  MOVFF  FEC,9D8
096A0:  MOVF   FED,F
096A2:  MOVFF  FEF,9D7
096A6:  MOVFF  FEA,8CF
096AA:  MOVFF  FE9,8CE
096AE:  MOVLB  9
096B0:  CLRF   xDA
096B2:  CLRF   xD9
096B4:  MOVFF  8BD,9DE
096B8:  MOVFF  8BC,9DD
096BC:  MOVFF  8BB,9DC
096C0:  MOVFF  8BA,9DB
096C4:  MOVLB  0
096C6:  CALL   478E
096CA:  MOVFF  8CF,FEA
096CE:  MOVFF  8CE,FE9
096D2:  MOVFF  03,8CF
096D6:  MOVFF  02,8CE
096DA:  MOVFF  01,8CD
096DE:  MOVFF  00,8CC
096E2:  BCF    FD8.0
096E4:  MOVLB  7
096E6:  RLCF   x40,W
096E8:  CLRF   03
096EA:  ADDLW  AB
096EC:  MOVWF  FE9
096EE:  MOVLW  07
096F0:  ADDWFC 03,W
096F2:  MOVWF  FEA
096F4:  MOVFF  FEC,8D1
096F8:  MOVF   FED,F
096FA:  MOVFF  FEF,8D0
096FE:  BCF    FD8.0
09700:  MOVLB  8
09702:  RRCF   xD1,W
09704:  MOVWF  03
09706:  RRCF   xD0,W
09708:  MOVWF  02
0970A:  ADDWF  00,W
0970C:  MOVWF  00
0970E:  MOVF   03,W
09710:  ADDWFC 01,W
09712:  MOVWF  01
09714:  MOVLW  00
09716:  ADDWFC xCE,W
09718:  MOVWF  02
0971A:  MOVLW  00
0971C:  ADDWFC xCF,W
0971E:  MOVWF  xC7
09720:  MOVFF  02,8C6
09724:  MOVFF  01,8C5
09728:  MOVFF  00,8C4
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
0972C:  BCF    FD8.0
0972E:  MOVLB  7
09730:  RLCF   x40,W
09732:  CLRF   03
09734:  ADDLW  AB
09736:  MOVWF  FE9
09738:  MOVLW  07
0973A:  ADDWFC 03,W
0973C:  MOVWF  FEA
0973E:  MOVFF  FEC,9D8
09742:  MOVF   FED,F
09744:  MOVFF  FEF,9D7
09748:  MOVFF  FEA,8CF
0974C:  MOVFF  FE9,8CE
09750:  MOVLB  9
09752:  CLRF   xDA
09754:  CLRF   xD9
09756:  MOVFF  8BD,9DE
0975A:  MOVFF  8BC,9DD
0975E:  MOVFF  8BB,9DC
09762:  MOVFF  8BA,9DB
09766:  MOVLB  0
09768:  CALL   478E
0976C:  MOVFF  8CF,FEA
09770:  MOVFF  8CE,FE9
09774:  MOVFF  03,8CF
09778:  MOVFF  02,8CE
0977C:  MOVFF  01,8CD
09780:  MOVFF  00,8CC
09784:  BCF    FD8.0
09786:  MOVLB  7
09788:  RLCF   x40,W
0978A:  CLRF   03
0978C:  ADDLW  AB
0978E:  MOVWF  FE9
09790:  MOVLW  07
09792:  ADDWFC 03,W
09794:  MOVWF  FEA
09796:  MOVFF  FEC,8D1
0979A:  MOVF   FED,F
0979C:  MOVFF  FEF,8D0
097A0:  BCF    FD8.0
097A2:  MOVLB  8
097A4:  RRCF   xD1,W
097A6:  MOVWF  03
097A8:  RRCF   xD0,W
097AA:  MOVWF  02
097AC:  SUBWF  00,W
097AE:  MOVWF  00
097B0:  MOVF   03,W
097B2:  SUBWFB 01,W
097B4:  MOVWF  01
097B6:  MOVLW  00
097B8:  SUBWFB xCE,W
097BA:  MOVWF  02
097BC:  MOVLW  00
097BE:  SUBWFB xCF,W
097C0:  MOVWF  xCB
097C2:  MOVFF  02,8CA
097C6:  MOVFF  01,8C9
097CA:  MOVFF  00,8C8
....................          } 
....................          if (nv_product==WMS4){ 
097CE:  DECFSZ 2F,W
097D0:  BRA    99E8
097D2:  MOVF   30,F
097D4:  BTFSS  FD8.2
097D6:  BRA    99E8
....................             if (end_even_port==FALSE){ 
097D8:  MOVLB  2
097DA:  MOVF   xDB,F
097DC:  BNZ   98D2
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
097DE:  BCF    FD8.0
097E0:  MOVLB  7
097E2:  RLCF   x40,W
097E4:  CLRF   03
097E6:  ADDLW  AB
097E8:  MOVWF  FE9
097EA:  MOVLW  07
097EC:  ADDWFC 03,W
097EE:  MOVWF  FEA
097F0:  MOVFF  FEC,9EE
097F4:  MOVF   FED,F
097F6:  MOVFF  FEF,9ED
097FA:  MOVFF  8BF,9F0
097FE:  MOVFF  8BE,9EF
09802:  MOVLB  0
09804:  CALL   5C32
09808:  MOVFF  02,8CD
0980C:  MOVFF  01,8CC
09810:  BCF    FD8.0
09812:  MOVLB  7
09814:  RLCF   x40,W
09816:  CLRF   03
09818:  ADDLW  AB
0981A:  MOVWF  FE9
0981C:  MOVLW  07
0981E:  ADDWFC 03,W
09820:  MOVWF  FEA
09822:  MOVFF  FEC,8CF
09826:  MOVF   FED,F
09828:  MOVFF  FEF,8CE
0982C:  BCF    FD8.0
0982E:  MOVLB  8
09830:  RRCF   xCF,W
09832:  MOVWF  03
09834:  RRCF   xCE,W
09836:  MOVWF  02
09838:  ADDWF  01,W
0983A:  MOVWF  01
0983C:  MOVF   xCD,W
0983E:  ADDWFC 03,F
09840:  MOVFF  01,8C4
09844:  MOVFF  03,8C5
09848:  CLRF   02
0984A:  CLRF   03
0984C:  MOVFF  03,8C7
09850:  MOVFF  02,8C6
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
09854:  BCF    FD8.0
09856:  MOVLB  7
09858:  RLCF   x40,W
0985A:  CLRF   03
0985C:  ADDLW  AB
0985E:  MOVWF  FE9
09860:  MOVLW  07
09862:  ADDWFC 03,W
09864:  MOVWF  FEA
09866:  MOVFF  FEC,9EE
0986A:  MOVF   FED,F
0986C:  MOVFF  FEF,9ED
09870:  MOVFF  8BF,9F0
09874:  MOVFF  8BE,9EF
09878:  MOVLB  0
0987A:  CALL   5C32
0987E:  MOVFF  02,8CD
09882:  MOVFF  01,8CC
09886:  BCF    FD8.0
09888:  MOVLB  7
0988A:  RLCF   x40,W
0988C:  CLRF   03
0988E:  ADDLW  AB
09890:  MOVWF  FE9
09892:  MOVLW  07
09894:  ADDWFC 03,W
09896:  MOVWF  FEA
09898:  MOVFF  FEC,8CF
0989C:  MOVF   FED,F
0989E:  MOVFF  FEF,8CE
098A2:  BCF    FD8.0
098A4:  MOVLB  8
098A6:  RRCF   xCF,W
098A8:  MOVWF  03
098AA:  RRCF   xCE,W
098AC:  MOVWF  02
098AE:  SUBWF  01,W
098B0:  MOVWF  00
098B2:  MOVF   03,W
098B4:  SUBWFB xCD,W
098B6:  MOVWF  03
098B8:  MOVF   00,W
098BA:  MOVFF  03,8C9
098BE:  CLRF   02
098C0:  CLRF   03
098C2:  MOVFF  03,8CB
098C6:  MOVFF  02,8CA
098CA:  MOVFF  00,8C8
....................             } 
098CE:  BRA    99E8
098D0:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
098D2:  DECFSZ xDB,W
098D4:  BRA    99EA
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
098D6:  BCF    FD8.0
098D8:  MOVLB  7
098DA:  RLCF   x40,W
098DC:  CLRF   03
098DE:  ADDLW  AB
098E0:  MOVWF  FE9
098E2:  MOVLW  07
098E4:  ADDWFC 03,W
098E6:  MOVWF  FEA
098E8:  MOVFF  FEC,9EE
098EC:  MOVF   FED,F
098EE:  MOVFF  FEF,9ED
098F2:  MOVLW  01
098F4:  MOVLB  8
098F6:  SUBWF  xBE,W
098F8:  MOVWF  00
098FA:  MOVLW  00
098FC:  SUBWFB xBF,W
098FE:  MOVWF  03
09900:  MOVFF  00,8CE
09904:  MOVWF  xCF
09906:  MOVFF  FE8,9F0
0990A:  MOVFF  00,9EF
0990E:  MOVLB  0
09910:  CALL   5C32
09914:  MOVFF  02,8CD
09918:  MOVFF  01,8CC
0991C:  BCF    FD8.0
0991E:  MOVLB  7
09920:  RLCF   x40,W
09922:  CLRF   03
09924:  ADDLW  AB
09926:  MOVWF  FE9
09928:  MOVLW  07
0992A:  ADDWFC 03,W
0992C:  MOVWF  FEA
0992E:  MOVFF  FEC,8CF
09932:  MOVF   FED,F
09934:  MOVFF  FEF,8CE
09938:  BCF    FD8.0
0993A:  MOVLB  8
0993C:  RRCF   xCF,W
0993E:  MOVWF  03
09940:  RRCF   xCE,W
09942:  MOVWF  02
09944:  ADDWF  01,W
09946:  MOVWF  01
09948:  MOVF   xCD,W
0994A:  ADDWFC 03,F
0994C:  MOVFF  01,8C4
09950:  MOVFF  03,8C5
09954:  CLRF   02
09956:  CLRF   03
09958:  MOVFF  03,8C7
0995C:  MOVFF  02,8C6
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
09960:  BCF    FD8.0
09962:  MOVLB  7
09964:  RLCF   x40,W
09966:  CLRF   03
09968:  ADDLW  AB
0996A:  MOVWF  FE9
0996C:  MOVLW  07
0996E:  ADDWFC 03,W
09970:  MOVWF  FEA
09972:  MOVFF  FEC,9EE
09976:  MOVF   FED,F
09978:  MOVFF  FEF,9ED
0997C:  MOVLW  01
0997E:  MOVLB  8
09980:  SUBWF  xBE,W
09982:  MOVWF  00
09984:  MOVLW  00
09986:  SUBWFB xBF,W
09988:  MOVWF  03
0998A:  MOVFF  00,8CE
0998E:  MOVWF  xCF
09990:  MOVFF  FE8,9F0
09994:  MOVFF  00,9EF
09998:  MOVLB  0
0999A:  CALL   5C32
0999E:  MOVFF  02,03
099A2:  MOVFF  01,8C8
099A6:  MOVFF  02,8C9
099AA:  CLRF   02
099AC:  CLRF   03
099AE:  MOVFF  03,8CB
099B2:  MOVFF  02,8CA
....................                m_pll = m_pll -(m_ppp[motor]/2); 
099B6:  BCF    FD8.0
099B8:  MOVLB  7
099BA:  RLCF   x40,W
099BC:  CLRF   03
099BE:  ADDLW  AB
099C0:  MOVWF  FE9
099C2:  MOVLW  07
099C4:  ADDWFC 03,W
099C6:  MOVWF  FEA
099C8:  MOVFF  FEC,8CD
099CC:  MOVF   FED,F
099CE:  MOVFF  FEF,8CC
099D2:  BCF    FD8.0
099D4:  MOVLB  8
099D6:  RRCF   xCD,W
099D8:  MOVWF  03
099DA:  RRCF   xCC,W
099DC:  SUBWF  xC8,F
099DE:  MOVF   03,W
099E0:  SUBWFB xC9,F
099E2:  MOVLW  00
099E4:  SUBWFB xCA,F
099E6:  SUBWFB xCB,F
099E8:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
099EA:  MOVLB  7
099EC:  MOVF   x40,W
099EE:  MULLW  04
099F0:  MOVF   FF3,W
099F2:  CLRF   03
099F4:  ADDLW  A2
099F6:  MOVWF  FE9
099F8:  MOVLW  07
099FA:  ADDWFC 03,W
099FC:  MOVWF  FEA
099FE:  MOVFF  FEF,8CC
09A02:  MOVFF  FEC,8CD
09A06:  MOVFF  FEC,8CE
09A0A:  MOVFF  FEC,8CF
09A0E:  MOVLB  8
09A10:  BTFSC  xC7.7
09A12:  BRA    9A82
09A14:  MOVF   xC7,W
09A16:  SUBWF  xCF,W
09A18:  BNC   9A32
09A1A:  BNZ   9A82
09A1C:  MOVF   xC6,W
09A1E:  SUBWF  xCE,W
09A20:  BNC   9A32
09A22:  BNZ   9A82
09A24:  MOVF   xC5,W
09A26:  SUBWF  xCD,W
09A28:  BNC   9A32
09A2A:  BNZ   9A82
09A2C:  MOVF   xCC,W
09A2E:  SUBWF  xC4,W
09A30:  BNC   9A82
09A32:  MOVLB  7
09A34:  MOVF   x40,W
09A36:  MULLW  04
09A38:  MOVF   FF3,W
09A3A:  CLRF   03
09A3C:  ADDLW  A2
09A3E:  MOVWF  FE9
09A40:  MOVLW  07
09A42:  ADDWFC 03,W
09A44:  MOVWF  FEA
09A46:  MOVFF  FEF,8CC
09A4A:  MOVFF  FEC,8CD
09A4E:  MOVFF  FEC,8CE
09A52:  MOVFF  FEC,8CF
09A56:  MOVLB  8
09A58:  BTFSC  xCB.7
09A5A:  BRA    9BC6
09A5C:  MOVF   xCF,W
09A5E:  SUBWF  xCB,W
09A60:  BTFSS  FD8.0
09A62:  BRA    9BC6
09A64:  BNZ   9A82
09A66:  MOVF   xCE,W
09A68:  SUBWF  xCA,W
09A6A:  BTFSS  FD8.0
09A6C:  BRA    9BC6
09A6E:  BNZ   9A82
09A70:  MOVF   xCD,W
09A72:  SUBWF  xC9,W
09A74:  BTFSS  FD8.0
09A76:  BRA    9BC6
09A78:  BNZ   9A82
09A7A:  MOVF   xC8,W
09A7C:  SUBWF  xCC,W
09A7E:  BTFSC  FD8.0
09A80:  BRA    9BC6
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09A82:  MOVLW  01
09A84:  MOVLB  7
09A86:  ADDWF  x40,W
09A88:  MOVLB  8
09A8A:  MOVWF  xCC
09A8C:  BCF    FD8.0
09A8E:  MOVLB  7
09A90:  RLCF   x40,W
09A92:  CLRF   03
09A94:  ADDLW  AB
09A96:  MOVWF  FE9
09A98:  MOVLW  07
09A9A:  ADDWFC 03,W
09A9C:  MOVWF  FEA
09A9E:  MOVFF  FEC,8CE
09AA2:  MOVF   FED,F
09AA4:  MOVFF  FEF,8CD
09AA8:  MOVF   x40,W
09AAA:  MULLW  04
09AAC:  MOVF   FF3,W
09AAE:  CLRF   03
09AB0:  ADDLW  A2
09AB2:  MOVWF  FE9
09AB4:  MOVLW  07
09AB6:  ADDWFC 03,W
09AB8:  MOVWF  FEA
09ABA:  MOVFF  FEF,8CF
09ABE:  MOVFF  FEC,8D0
09AC2:  MOVFF  FEC,8D1
09AC6:  MOVFF  FEC,8D2
09ACA:  MOVLW  6E
09ACC:  MOVWF  FF6
09ACE:  MOVLW  1A
09AD0:  MOVWF  FF7
09AD2:  MOVLW  00
09AD4:  MOVWF  FF8
09AD6:  CLRF   1B
09AD8:  BTFSC  FF2.7
09ADA:  BSF    1B.7
09ADC:  BCF    FF2.7
09ADE:  MOVLW  05
09AE0:  MOVLB  A
09AE2:  MOVWF  x1C
09AE4:  MOVLB  0
09AE6:  CALL   1024
09AEA:  BTFSC  1B.7
09AEC:  BSF    FF2.7
09AEE:  CLRF   1B
09AF0:  BTFSC  FF2.7
09AF2:  BSF    1B.7
09AF4:  BCF    FF2.7
09AF6:  MOVFF  8CC,A1C
09AFA:  MOVLW  1B
09AFC:  MOVLB  A
09AFE:  MOVWF  x1D
09B00:  MOVLB  0
09B02:  CALL   0FA6
09B06:  BTFSC  1B.7
09B08:  BSF    FF2.7
09B0A:  MOVLW  2C
09B0C:  BTFSS  F9E.4
09B0E:  BRA    9B0C
09B10:  MOVWF  FAD
09B12:  MOVLW  41
09B14:  MOVWF  FE9
09B16:  MOVFF  8BD,8D6
09B1A:  MOVFF  8BC,8D5
09B1E:  MOVFF  8BB,8D4
09B22:  MOVFF  8BA,8D3
09B26:  RCALL  94C0
09B28:  MOVLW  2C
09B2A:  BTFSS  F9E.4
09B2C:  BRA    9B2A
09B2E:  MOVWF  FAD
09B30:  MOVLW  10
09B32:  MOVWF  FE9
09B34:  CLRF   1B
09B36:  BTFSC  FF2.7
09B38:  BSF    1B.7
09B3A:  BCF    FF2.7
09B3C:  MOVFF  8CE,A1D
09B40:  MOVFF  8CD,A1C
09B44:  CALL   11A6
09B48:  BTFSC  1B.7
09B4A:  BSF    FF2.7
09B4C:  MOVLW  2C
09B4E:  BTFSS  F9E.4
09B50:  BRA    9B4E
09B52:  MOVWF  FAD
09B54:  MOVLW  41
09B56:  MOVWF  FE9
09B58:  CLRF   1B
09B5A:  BTFSC  FF2.7
09B5C:  BSF    1B.7
09B5E:  BCF    FF2.7
09B60:  MOVFF  8D2,A1F
09B64:  MOVFF  8D1,A1E
09B68:  MOVFF  8D0,A1D
09B6C:  MOVFF  8CF,A1C
09B70:  CALL   10EA
09B74:  BTFSC  1B.7
09B76:  BSF    FF2.7
09B78:  MOVLW  2C
09B7A:  BTFSS  F9E.4
09B7C:  BRA    9B7A
09B7E:  MOVWF  FAD
09B80:  MOVLW  41
09B82:  MOVWF  FE9
09B84:  MOVFF  8C7,8D6
09B88:  MOVFF  8C6,8D5
09B8C:  MOVFF  8C5,8D4
09B90:  MOVFF  8C4,8D3
09B94:  RCALL  94C0
09B96:  MOVLW  2C
09B98:  BTFSS  F9E.4
09B9A:  BRA    9B98
09B9C:  MOVWF  FAD
09B9E:  MOVLW  41
09BA0:  MOVWF  FE9
09BA2:  MOVFF  8CB,8D6
09BA6:  MOVFF  8CA,8D5
09BAA:  MOVFF  8C9,8D4
09BAE:  MOVFF  8C8,8D3
09BB2:  RCALL  94C0
09BB4:  MOVLW  0D
09BB6:  BTFSS  F9E.4
09BB8:  BRA    9BB6
09BBA:  MOVWF  FAD
09BBC:  MOVLW  0A
09BBE:  BTFSS  F9E.4
09BC0:  BRA    9BBE
09BC2:  MOVWF  FAD
09BC4:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09BC6:  BCF    FD8.0
09BC8:  MOVLB  7
09BCA:  RLCF   x40,W
09BCC:  CLRF   03
09BCE:  ADDLW  9E
09BD0:  MOVWF  01
09BD2:  MOVLW  07
09BD4:  ADDWFC 03,F
09BD6:  MOVLB  8
09BD8:  MOVFF  03,8CD
09BDC:  BCF    FD8.0
09BDE:  MOVLB  7
09BE0:  RLCF   x40,W
09BE2:  CLRF   03
09BE4:  ADDLW  66
09BE6:  MOVWF  FE9
09BE8:  MOVLW  07
09BEA:  ADDWFC 03,W
09BEC:  MOVWF  FEA
09BEE:  MOVFF  FEC,03
09BF2:  MOVF   FED,F
09BF4:  MOVFF  FEF,8CE
09BF8:  MOVLB  8
09BFA:  MOVFF  8CD,FEA
09BFE:  MOVFF  01,FE9
09C02:  MOVFF  03,FEC
09C06:  MOVF   FED,F
09C08:  MOVFF  8CE,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09C0C:  BCF    FD8.0
09C0E:  MOVLB  7
09C10:  RLCF   x40,W
09C12:  CLRF   03
09C14:  ADDLW  66
09C16:  MOVWF  FE9
09C18:  MOVLW  07
09C1A:  ADDWFC 03,W
09C1C:  MOVWF  FEA
09C1E:  CLRF   FEC
09C20:  MOVF   FED,F
09C22:  MOVLW  04
09C24:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09C26:  MOVF   x40,W
09C28:  MULLW  04
09C2A:  MOVF   FF3,W
09C2C:  CLRF   03
09C2E:  ADDLW  A2
09C30:  MOVWF  FE9
09C32:  MOVLW  07
09C34:  ADDWFC 03,W
09C36:  MOVWF  FEA
09C38:  MOVFF  FEF,8C0
09C3C:  MOVFF  FEC,8C1
09C40:  MOVFF  FEC,8C2
09C44:  MOVFF  FEC,8C3
09C48:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09C4A:  MOVFF  8C0,00
09C4E:  MOVFF  8C1,01
09C52:  MOVFF  8C2,02
09C56:  MOVFF  8C3,03
09C5A:  MOVLB  0
09C5C:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
084BA:  MOVLB  2
084BC:  CLRF   xDB
....................    start_even_port = FALSE; 
084BE:  CLRF   xDA
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
084C0:  BCF    FD8.0
084C2:  MOVLB  7
084C4:  RLCF   x40,W
084C6:  CLRF   03
084C8:  ADDLW  C7
084CA:  MOVWF  FE9
084CC:  MOVLW  07
084CE:  ADDWFC 03,W
084D0:  MOVWF  FEA
084D2:  MOVFF  FEC,8BA
084D6:  MOVF   FED,F
084D8:  MOVFF  FEF,8B9
084DC:  MOVLW  01
084DE:  MOVLB  8
084E0:  ANDWF  xB9,F
084E2:  CLRF   xBA
084E4:  MOVF   xB9,F
084E6:  BNZ   84F4
084E8:  MOVF   xBA,F
084EA:  BNZ   84F4
....................    { 
....................       end_even_port = TRUE; 
084EC:  MOVLW  01
084EE:  MOVLB  2
084F0:  MOVWF  xDB
084F2:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
084F4:  BCF    FD8.0
084F6:  MOVLB  7
084F8:  RLCF   x40,W
084FA:  CLRF   03
084FC:  ADDLW  C3
084FE:  MOVWF  FE9
08500:  MOVLW  07
08502:  ADDWFC 03,W
08504:  MOVWF  FEA
08506:  MOVFF  FEC,8BA
0850A:  MOVF   FED,F
0850C:  MOVFF  FEF,8B9
08510:  MOVLW  01
08512:  MOVLB  8
08514:  ANDWF  xB9,F
08516:  CLRF   xBA
08518:  MOVF   xB9,F
0851A:  BNZ   8528
0851C:  MOVF   xBA,F
0851E:  BNZ   8528
....................    { 
....................       start_even_port = TRUE; 
08520:  MOVLW  01
08522:  MOVLB  2
08524:  MOVWF  xDA
08526:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
08528:  MOVLB  2
0852A:  MOVF   xDA,F
0852C:  BNZ   8542
....................    { 
....................       evenOdd = 0; 
0852E:  MOVLB  8
08530:  CLRF   xB8
....................       if (TRUE == end_even_port) 
08532:  MOVLB  2
08534:  DECFSZ xDB,W
08536:  BRA    8540
....................       { 
....................          evenOdd = 1; 
08538:  MOVLW  01
0853A:  MOVLB  8
0853C:  MOVWF  xB8
0853E:  MOVLB  2
....................       } 
....................    } 
08540:  BRA    8556
....................    else 
....................    { 
....................       evenOdd = 2; 
08542:  MOVLW  02
08544:  MOVLB  8
08546:  MOVWF  xB8
....................       if (TRUE == end_even_port) 
08548:  MOVLB  2
0854A:  DECFSZ xDB,W
0854C:  BRA    8556
....................       { 
....................          evenOdd = 3; 
0854E:  MOVLW  03
08550:  MOVLB  8
08552:  MOVWF  xB8
08554:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
08556:  MOVLB  8
08558:  MOVFF  8B8,01
0855C:  MOVLB  0
0855E:  GOTO   9FAC (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09CD4:  BCF    FD8.0
09CD6:  MOVLB  7
09CD8:  RLCF   x40,W
09CDA:  CLRF   03
09CDC:  ADDLW  86
09CDE:  MOVWF  FE9
09CE0:  MOVLW  07
09CE2:  ADDWFC 03,W
09CE4:  MOVWF  FEA
09CE6:  CLRF   FEC
09CE8:  MOVF   FED,F
09CEA:  MOVFF  8A9,FEF
....................    m_step_cnt[motor] = 0; 
09CEE:  MOVF   x40,W
09CF0:  MULLW  04
09CF2:  MOVF   FF3,W
09CF4:  CLRF   03
09CF6:  ADDLW  A2
09CF8:  MOVWF  FE9
09CFA:  MOVLW  07
09CFC:  ADDWFC 03,W
09CFE:  MOVWF  FEA
09D00:  MOVF   FEE,F
09D02:  MOVF   FEE,F
09D04:  CLRF   FEC
09D06:  MOVF   FED,F
09D08:  CLRF   FEF
09D0A:  MOVF   FED,F
09D0C:  CLRF   FEF
09D0E:  MOVF   FED,F
09D10:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09D12:  BCF    FD8.0
09D14:  RLCF   x40,W
09D16:  CLRF   03
09D18:  ADDLW  6E
09D1A:  MOVWF  FE9
09D1C:  MOVLW  07
09D1E:  ADDWFC 03,W
09D20:  MOVWF  FEA
09D22:  MOVFF  FEC,8B6
09D26:  MOVF   FED,F
09D28:  MOVFF  FEF,8B5
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09D2C:  BCF    FD8.0
09D2E:  RLCF   x40,W
09D30:  CLRF   03
09D32:  ADDLW  76
09D34:  MOVWF  FE9
09D36:  MOVLW  07
09D38:  ADDWFC 03,W
09D3A:  MOVWF  FEA
09D3C:  MOVFF  FEC,8BD
09D40:  MOVF   FED,F
09D42:  MOVFF  FEF,8BC
09D46:  BCF    FD8.0
09D48:  RLCF   x40,W
09D4A:  CLRF   03
09D4C:  ADDLW  5E
09D4E:  MOVWF  FE9
09D50:  MOVLW  07
09D52:  ADDWFC 03,W
09D54:  MOVWF  FEA
09D56:  MOVFF  FEC,03
09D5A:  MOVF   FED,F
09D5C:  MOVFF  FEF,8BE
09D60:  MOVFF  03,8BB
09D64:  MOVFF  03,8BF
09D68:  MOVLB  0
09D6A:  CALL   2C70
09D6E:  MOVFF  02,8B4
09D72:  MOVFF  01,8B3
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09D76:  BCF    FD8.0
09D78:  MOVLB  7
09D7A:  RLCF   x40,W
09D7C:  CLRF   03
09D7E:  ADDLW  66
09D80:  MOVWF  FE9
09D82:  MOVLW  07
09D84:  ADDWFC 03,W
09D86:  MOVWF  FEA
09D88:  MOVFF  FEC,8B9
09D8C:  MOVF   FED,F
09D8E:  MOVFF  FEF,8B8
09D92:  MOVLB  8
09D94:  MOVF   xB8,W
09D96:  SUBLW  02
09D98:  BNZ   9DC8
09D9A:  MOVF   xB9,F
09D9C:  BNZ   9DC8
09D9E:  BCF    FD8.0
09DA0:  MOVLB  7
09DA2:  RLCF   x40,W
09DA4:  CLRF   03
09DA6:  ADDLW  C3
09DA8:  MOVWF  FE9
09DAA:  MOVLW  07
09DAC:  ADDWFC 03,W
09DAE:  MOVWF  FEA
09DB0:  MOVFF  FEC,8B9
09DB4:  MOVF   FED,F
09DB6:  MOVFF  FEF,8B8
09DBA:  MOVLB  8
09DBC:  MOVF   xB8,F
09DBE:  BNZ   9DC8
09DC0:  MOVF   xB9,F
09DC2:  BTFSC  FD8.2
09DC4:  GOTO   A666
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09DC8:  BCF    FD8.0
09DCA:  MOVLB  7
09DCC:  RLCF   x40,W
09DCE:  CLRF   03
09DD0:  ADDLW  66
09DD2:  MOVWF  FE9
09DD4:  MOVLW  07
09DD6:  ADDWFC 03,W
09DD8:  MOVWF  FEA
09DDA:  MOVFF  FEC,8B9
09DDE:  MOVF   FED,F
09DE0:  MOVFF  FEF,8B8
09DE4:  MOVLB  8
09DE6:  MOVF   xB8,W
09DE8:  SUBLW  02
09DEA:  BTFSS  FD8.2
09DEC:  BRA    A146
09DEE:  MOVF   xB9,F
09DF0:  BTFSS  FD8.2
09DF2:  BRA    A146
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09DF4:  BCF    FD8.0
09DF6:  MOVLB  7
09DF8:  RLCF   x40,W
09DFA:  CLRF   03
09DFC:  ADDLW  C7
09DFE:  MOVWF  FE9
09E00:  MOVLW  07
09E02:  ADDWFC 03,W
09E04:  MOVWF  FEA
09E06:  MOVFF  8AA,FEF
09E0A:  MOVFF  8AB,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09E0E:  DECFSZ 2F,W
09E10:  BRA    A0C2
09E12:  MOVF   30,F
09E14:  BTFSS  FD8.2
09E16:  BRA    A0C2
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09E18:  BCF    FD8.0
09E1A:  RLCF   x40,W
09E1C:  CLRF   03
09E1E:  ADDLW  C7
09E20:  MOVWF  FE9
09E22:  MOVLW  07
09E24:  ADDWFC 03,W
09E26:  MOVWF  FEA
09E28:  MOVFF  FEC,8B9
09E2C:  MOVF   FED,F
09E2E:  MOVFF  FEF,8B8
09E32:  BCF    FD8.0
09E34:  RLCF   x40,W
09E36:  CLRF   03
09E38:  ADDLW  C3
09E3A:  MOVWF  FE9
09E3C:  MOVLW  07
09E3E:  ADDWFC 03,W
09E40:  MOVWF  FEA
09E42:  MOVFF  FEC,03
09E46:  MOVF   FED,F
09E48:  MOVFF  FEF,01
09E4C:  MOVF   03,W
09E4E:  MOVLB  8
09E50:  SUBWF  xB9,W
09E52:  BNC   9EEE
09E54:  BNZ   9E5C
09E56:  MOVF   xB8,W
09E58:  SUBWF  01,W
09E5A:  BC    9EEE
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09E5C:  BCF    FD8.0
09E5E:  MOVLB  7
09E60:  RLCF   x40,W
09E62:  CLRF   03
09E64:  ADDLW  B7
09E66:  MOVWF  01
09E68:  MOVLW  07
09E6A:  ADDWFC 03,F
09E6C:  MOVLB  8
09E6E:  MOVFF  03,8B9
09E72:  BCF    FD8.0
09E74:  MOVLB  7
09E76:  RLCF   x40,W
09E78:  CLRF   03
09E7A:  ADDLW  C7
09E7C:  MOVWF  FE9
09E7E:  MOVLW  07
09E80:  ADDWFC 03,W
09E82:  MOVWF  FEA
09E84:  MOVFF  FEC,8BB
09E88:  MOVF   FED,F
09E8A:  MOVFF  FEF,8BA
09E8E:  BCF    FD8.0
09E90:  RLCF   x40,W
09E92:  CLRF   03
09E94:  ADDLW  C3
09E96:  MOVWF  FE9
09E98:  MOVLW  07
09E9A:  ADDWFC 03,W
09E9C:  MOVWF  FEA
09E9E:  MOVFF  FEC,03
09EA2:  MOVF   FED,F
09EA4:  MOVF   FEF,W
09EA6:  MOVLB  8
09EA8:  SUBWF  xBA,W
09EAA:  MOVWF  00
09EAC:  MOVF   03,W
09EAE:  SUBWFB xBB,W
09EB0:  MOVFF  8B9,FEA
09EB4:  MOVFF  01,FE9
09EB8:  MOVWF  FEC
09EBA:  MOVF   FED,F
09EBC:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09EC0:  BCF    FD8.0
09EC2:  MOVLB  7
09EC4:  RLCF   x40,W
09EC6:  CLRF   03
09EC8:  ADDLW  B7
09ECA:  MOVWF  FE9
09ECC:  MOVLW  07
09ECE:  ADDWFC 03,W
09ED0:  MOVWF  FEA
09ED2:  MOVFF  FEC,8B9
09ED6:  MOVF   FED,F
09ED8:  MOVFF  FEF,8B8
09EDC:  BCF    FD8.0
09EDE:  MOVLB  8
09EE0:  CLRF   xAD
09EE2:  CLRF   xAC
09EE4:  RRCF   xB9,W
09EE6:  MOVWF  xAB
09EE8:  RRCF   xB8,W
09EEA:  MOVWF  xAA
....................             } 
09EEC:  BRA    9FA6
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09EEE:  BCF    FD8.0
09EF0:  MOVLB  7
09EF2:  RLCF   x40,W
09EF4:  CLRF   03
09EF6:  ADDLW  B7
09EF8:  MOVWF  01
09EFA:  MOVLW  07
09EFC:  ADDWFC 03,F
09EFE:  MOVFF  01,8B8
09F02:  MOVLB  8
09F04:  MOVFF  03,8B9
09F08:  BCF    FD8.0
09F0A:  MOVLB  7
09F0C:  RLCF   x40,W
09F0E:  CLRF   03
09F10:  ADDLW  62
09F12:  MOVWF  FE9
09F14:  MOVLW  07
09F16:  ADDWFC 03,W
09F18:  MOVWF  FEA
09F1A:  MOVFF  FEC,8BB
09F1E:  MOVF   FED,F
09F20:  MOVFF  FEF,8BA
09F24:  BCF    FD8.0
09F26:  RLCF   x40,W
09F28:  CLRF   03
09F2A:  ADDLW  C3
09F2C:  MOVWF  FE9
09F2E:  MOVLW  07
09F30:  ADDWFC 03,W
09F32:  MOVWF  FEA
09F34:  MOVFF  FEC,03
09F38:  MOVF   FED,F
09F3A:  MOVF   FEF,W
09F3C:  MOVLB  8
09F3E:  SUBWF  xBA,F
09F40:  MOVF   03,W
09F42:  SUBWFB xBB,F
09F44:  BCF    FD8.0
09F46:  MOVLB  7
09F48:  RLCF   x40,W
09F4A:  CLRF   03
09F4C:  ADDLW  C7
09F4E:  MOVWF  FE9
09F50:  MOVLW  07
09F52:  ADDWFC 03,W
09F54:  MOVWF  FEA
09F56:  MOVFF  FEC,03
09F5A:  MOVF   FED,F
09F5C:  MOVF   FEF,W
09F5E:  MOVLB  8
09F60:  ADDWF  xBA,W
09F62:  MOVWF  01
09F64:  MOVF   xBB,W
09F66:  ADDWFC 03,F
09F68:  MOVFF  8B9,FEA
09F6C:  MOVFF  8B8,FE9
09F70:  MOVFF  03,FEC
09F74:  MOVF   FED,F
09F76:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F7A:  BCF    FD8.0
09F7C:  MOVLB  7
09F7E:  RLCF   x40,W
09F80:  CLRF   03
09F82:  ADDLW  B7
09F84:  MOVWF  FE9
09F86:  MOVLW  07
09F88:  ADDWFC 03,W
09F8A:  MOVWF  FEA
09F8C:  MOVFF  FEC,8B9
09F90:  MOVF   FED,F
09F92:  MOVFF  FEF,8B8
09F96:  BCF    FD8.0
09F98:  MOVLB  8
09F9A:  CLRF   xAD
09F9C:  CLRF   xAC
09F9E:  RRCF   xB9,W
09FA0:  MOVWF  xAB
09FA2:  RRCF   xB8,W
09FA4:  MOVWF  xAA
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
09FA6:  MOVLB  0
09FA8:  GOTO   84BA
09FAC:  MOVFF  01,8B7
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
09FB0:  BCF    FD8.0
09FB2:  MOVLB  7
09FB4:  RLCF   x40,W
09FB6:  CLRF   03
09FB8:  ADDLW  C7
09FBA:  MOVWF  FE9
09FBC:  MOVLW  07
09FBE:  ADDWFC 03,W
09FC0:  MOVWF  FEA
09FC2:  MOVFF  FEC,8B9
09FC6:  MOVF   FED,F
09FC8:  MOVFF  FEF,8B8
09FCC:  MOVLB  8
09FCE:  MOVF   xB8,W
09FD0:  SUBLW  02
09FD2:  BNZ   A002
09FD4:  MOVF   xB9,F
09FD6:  BNZ   A002
09FD8:  BCF    FD8.0
09FDA:  MOVLB  7
09FDC:  RLCF   x40,W
09FDE:  CLRF   03
09FE0:  ADDLW  C3
09FE2:  MOVWF  FE9
09FE4:  MOVLW  07
09FE6:  ADDWFC 03,W
09FE8:  MOVWF  FEA
09FEA:  MOVFF  FEC,8B9
09FEE:  MOVF   FED,F
09FF0:  MOVFF  FEF,8B8
09FF4:  MOVLB  8
09FF6:  DECFSZ xB8,W
09FF8:  BRA    A002
09FFA:  MOVF   xB9,F
09FFC:  BNZ   A002
....................             { 
....................                port_port=4; 
09FFE:  MOVLW  04
0A000:  MOVWF  xB7
....................             } 
....................              
....................             switch(port_port){ 
0A002:  MOVF   xB7,W
0A004:  ADDLW  FB
0A006:  BC    A0BE
0A008:  ADDLW  05
0A00A:  MOVLB  0
0A00C:  GOTO   A6B4
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
0A010:  BCF    FD8.0
0A012:  MOVLB  7
0A014:  RLCF   x40,W
0A016:  CLRF   03
0A018:  ADDLW  6E
0A01A:  MOVWF  FE9
0A01C:  MOVLW  07
0A01E:  ADDWFC 03,W
0A020:  MOVWF  FEA
0A022:  MOVFF  FEC,8B6
0A026:  MOVF   FED,F
0A028:  MOVFF  FEF,8B5
....................                   break; 
0A02C:  MOVLB  8
0A02E:  BRA    A0BE
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A030:  BCF    FD8.0
0A032:  MOVLB  7
0A034:  RLCF   x40,W
0A036:  CLRF   03
0A038:  ADDLW  7E
0A03A:  MOVWF  FE9
0A03C:  MOVLW  07
0A03E:  ADDWFC 03,W
0A040:  MOVWF  FEA
0A042:  MOVFF  FEC,03
0A046:  MOVF   FED,F
0A048:  MOVF   FEF,W
0A04A:  MOVLB  8
0A04C:  ADDWF  xB3,W
0A04E:  MOVWF  xB5
0A050:  MOVF   03,W
0A052:  ADDWFC xB4,W
0A054:  MOVWF  xB6
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A056:  BRA    A0BE
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A058:  BCF    FD8.0
0A05A:  MOVLB  7
0A05C:  RLCF   x40,W
0A05E:  CLRF   03
0A060:  ADDLW  6E
0A062:  MOVWF  FE9
0A064:  MOVLW  07
0A066:  ADDWFC 03,W
0A068:  MOVWF  FEA
0A06A:  MOVFF  FEC,8B6
0A06E:  MOVF   FED,F
0A070:  MOVFF  FEF,8B5
....................                         ++m_steps; 
0A074:  MOVLW  01
0A076:  MOVLB  8
0A078:  ADDWF  xAA,F
0A07A:  BTFSC  FD8.0
0A07C:  INCF   xAB,F
0A07E:  BTFSC  FD8.2
0A080:  INCF   xAC,F
0A082:  BTFSC  FD8.2
0A084:  INCF   xAD,F
....................                   break; 
0A086:  BRA    A0BE
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A088:  BCF    FD8.0
0A08A:  MOVLB  7
0A08C:  RLCF   x40,W
0A08E:  CLRF   03
0A090:  ADDLW  7E
0A092:  MOVWF  FE9
0A094:  MOVLW  07
0A096:  ADDWFC 03,W
0A098:  MOVWF  FEA
0A09A:  MOVFF  FEC,03
0A09E:  MOVF   FED,F
0A0A0:  MOVF   FEF,W
0A0A2:  MOVLB  8
0A0A4:  ADDWF  xB3,W
0A0A6:  MOVWF  xB5
0A0A8:  MOVF   03,W
0A0AA:  ADDWFC xB4,W
0A0AC:  MOVWF  xB6
....................  
....................                   break; 
0A0AE:  BRA    A0BE
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A0B0:  MOVFF  8B4,8B6
0A0B4:  MOVFF  8B3,8B5
....................                   break;     
0A0B8:  MOVLB  8
0A0BA:  BRA    A0BE
0A0BC:  MOVLB  8
....................             } 
....................          } 
0A0BE:  BRA    A0EA
0A0C0:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A0C2:  MOVFF  8AD,8BB
0A0C6:  MOVFF  8AC,8BA
0A0CA:  MOVFF  8AB,8B9
0A0CE:  MOVFF  8AA,8B8
0A0D2:  MOVLB  0
0A0D4:  GOTO   8562
0A0D8:  MOVFF  03,8AD
0A0DC:  MOVFF  02,8AC
0A0E0:  MOVFF  01,8AB
0A0E4:  MOVFF  00,8AA
0A0E8:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A0EA:  DECFSZ xA8,W
0A0EC:  BRA    A114
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A0EE:  MOVFF  8AB,8B9
0A0F2:  MOVFF  8AA,8B8
0A0F6:  MOVFF  8AB,8BB
0A0FA:  MOVFF  8AA,8BA
0A0FE:  MOVLB  0
0A100:  GOTO   8774
0A104:  MOVLB  8
0A106:  CLRF   xAD
0A108:  CLRF   xAC
0A10A:  MOVFF  02,8AB
0A10E:  MOVFF  01,8AA
....................          } 
0A112:  BRA    A146
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A114:  MOVF   2F,W
0A116:  SUBLW  03
0A118:  BNZ   A146
0A11A:  MOVF   30,F
0A11C:  BNZ   A146
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A11E:  BCF    FD8.0
0A120:  MOVLB  7
0A122:  RLCF   x40,W
0A124:  CLRF   03
0A126:  ADDLW  BF
0A128:  MOVWF  FE9
0A12A:  MOVLW  07
0A12C:  ADDWFC 03,W
0A12E:  MOVWF  FEA
0A130:  MOVFF  FEC,03
0A134:  MOVF   FED,F
0A136:  MOVF   FEF,W
0A138:  MOVLB  8
0A13A:  SUBWF  xAA,F
0A13C:  MOVF   03,W
0A13E:  SUBWFB xAB,F
0A140:  MOVLW  00
0A142:  SUBWFB xAC,F
0A144:  SUBWFB xAD,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A146:  MOVFF  8AE,8B8
0A14A:  MOVLB  0
0A14C:  GOTO   8E3E
....................        
....................       //timeout could be set here!!! 
....................       while (m_running[motor]) 
0A150:  BCF    FD8.0
0A152:  MOVLB  7
0A154:  RLCF   x40,W
0A156:  CLRF   03
0A158:  ADDLW  92
0A15A:  MOVWF  FE9
0A15C:  MOVLW  07
0A15E:  ADDWFC 03,W
0A160:  MOVWF  FEA
0A162:  MOVF   FEF,F
0A164:  BNZ   A16C
0A166:  MOVF   FEC,F
0A168:  BTFSC  FD8.2
0A16A:  BRA    A662
....................       { 
....................          switch(e_mode[motor]) 
0A16C:  BCF    FD8.0
0A16E:  RLCF   x40,W
0A170:  CLRF   03
0A172:  ADDLW  66
0A174:  MOVWF  FE9
0A176:  MOVLW  07
0A178:  ADDWFC 03,W
0A17A:  MOVWF  FEA
0A17C:  MOVF   FEF,W
0A17E:  MOVWF  00
0A180:  MOVF   FEE,F
0A182:  MOVF   FED,W
0A184:  MOVWF  03
0A186:  MOVF   03,W
0A188:  BNZ   A192
0A18A:  MOVF   00,F
0A18C:  MOVLB  0
0A18E:  BZ    A1E0
0A190:  MOVLB  7
0A192:  MOVF   03,W
0A194:  BNZ   A1A0
0A196:  MOVLW  01
0A198:  SUBWF  00,W
0A19A:  MOVLB  0
0A19C:  BZ    A236
0A19E:  MOVLB  7
0A1A0:  MOVF   03,W
0A1A2:  BNZ   A1AE
0A1A4:  MOVLW  02
0A1A6:  SUBWF  00,W
0A1A8:  MOVLB  0
0A1AA:  BZ    A236
0A1AC:  MOVLB  7
0A1AE:  MOVF   03,W
0A1B0:  BNZ   A1BE
0A1B2:  MOVLW  03
0A1B4:  SUBWF  00,W
0A1B6:  MOVLB  0
0A1B8:  BTFSC  FD8.2
0A1BA:  BRA    A304
0A1BC:  MOVLB  7
0A1BE:  MOVF   03,W
0A1C0:  BNZ   A1CE
0A1C2:  MOVLW  04
0A1C4:  SUBWF  00,W
0A1C6:  MOVLB  0
0A1C8:  BTFSC  FD8.2
0A1CA:  BRA    A454
0A1CC:  MOVLB  7
0A1CE:  MOVF   03,W
0A1D0:  BNZ   A1DE
0A1D2:  MOVLW  05
0A1D4:  SUBWF  00,W
0A1D6:  MOVLB  0
0A1D8:  BTFSC  FD8.2
0A1DA:  BRA    A5A4
0A1DC:  MOVLB  7
0A1DE:  BRA    A65C
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A1E0:  MOVLB  7
0A1E2:  MOVF   x40,W
0A1E4:  MULLW  04
0A1E6:  MOVF   FF3,W
0A1E8:  CLRF   03
0A1EA:  ADDLW  A2
0A1EC:  MOVWF  FE9
0A1EE:  MOVLW  07
0A1F0:  ADDWFC 03,W
0A1F2:  MOVWF  FEA
0A1F4:  MOVFF  FEF,8B8
0A1F8:  MOVFF  FEC,8B9
0A1FC:  MOVFF  FEC,8BA
0A200:  MOVFF  FEC,8BB
0A204:  MOVLB  8
0A206:  MOVF   xAD,W
0A208:  SUBWF  xBB,W
0A20A:  BNC   A230
0A20C:  BNZ   A224
0A20E:  MOVF   xAC,W
0A210:  SUBWF  xBA,W
0A212:  BNC   A230
0A214:  BNZ   A224
0A216:  MOVF   xAB,W
0A218:  SUBWF  xB9,W
0A21A:  BNC   A230
0A21C:  BNZ   A224
0A21E:  MOVF   xAA,W
0A220:  SUBWF  xB8,W
0A222:  BNC   A230
....................                { 
....................                   terminate(1); 
0A224:  MOVLW  01
0A226:  MOVWF  xCC
0A228:  MOVLB  0
0A22A:  CALL   902C
0A22E:  MOVLB  8
....................                } 
....................                break; 
0A230:  MOVLB  7
0A232:  BRA    A65C
0A234:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A236:  BCF    FD8.0
0A238:  MOVLB  7
0A23A:  RLCF   x40,W
0A23C:  CLRF   03
0A23E:  ADDLW  9A
0A240:  MOVWF  FE9
0A242:  MOVLW  07
0A244:  ADDWFC 03,W
0A246:  MOVWF  FEA
0A248:  MOVFF  FEC,8B9
0A24C:  MOVF   FED,F
0A24E:  MOVFF  FEF,8B8
0A252:  BCF    FD8.0
0A254:  RLCF   x40,W
0A256:  CLRF   03
0A258:  ADDLW  5A
0A25A:  MOVWF  FE9
0A25C:  MOVLW  07
0A25E:  ADDWFC 03,W
0A260:  MOVWF  FEA
0A262:  MOVFF  FEC,03
0A266:  MOVF   FED,F
0A268:  MOVFF  FEF,01
0A26C:  MOVF   03,W
0A26E:  MOVLB  8
0A270:  SUBWF  xB9,W
0A272:  BNC   A286
0A274:  BNZ   A27C
0A276:  MOVF   01,W
0A278:  SUBWF  xB8,W
0A27A:  BNC   A286
....................                { 
....................                   terminate(0); 
0A27C:  CLRF   xCC
0A27E:  MOVLB  0
0A280:  CALL   902C
0A284:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A286:  BCF    FD8.0
0A288:  MOVLB  7
0A28A:  RLCF   x40,W
0A28C:  CLRF   03
0A28E:  ADDLW  BB
0A290:  MOVWF  FE9
0A292:  MOVLW  07
0A294:  ADDWFC 03,W
0A296:  MOVWF  FEA
0A298:  MOVFF  FEC,8B9
0A29C:  MOVF   FED,F
0A29E:  MOVFF  FEF,8B8
0A2A2:  MOVLB  8
0A2A4:  MOVF   xAD,F
0A2A6:  BNZ   A2FE
0A2A8:  MOVF   xAC,F
0A2AA:  BNZ   A2FE
0A2AC:  MOVF   xAB,W
0A2AE:  SUBWF  xB9,W
0A2B0:  BNC   A2FE
0A2B2:  BNZ   A2BA
0A2B4:  MOVF   xAA,W
0A2B6:  SUBWF  xB8,W
0A2B8:  BNC   A2FE
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A2BA:  BCF    FD8.0
0A2BC:  MOVLB  7
0A2BE:  RLCF   x40,W
0A2C0:  CLRF   03
0A2C2:  ADDLW  B7
0A2C4:  MOVWF  FE9
0A2C6:  MOVLW  07
0A2C8:  ADDWFC 03,W
0A2CA:  MOVWF  FEA
0A2CC:  MOVFF  FEC,8BF
0A2D0:  MOVF   FED,F
0A2D2:  MOVFF  FEF,8BE
0A2D6:  MOVFF  8AD,8BD
0A2DA:  MOVFF  8AC,8BC
0A2DE:  MOVFF  8AB,8BB
0A2E2:  MOVFF  8AA,8BA
0A2E6:  MOVLB  0
0A2E8:  CALL   95EC
0A2EC:  MOVFF  03,8B2
0A2F0:  MOVFF  02,8B1
0A2F4:  MOVFF  01,8B0
0A2F8:  MOVFF  00,8AF
0A2FC:  MOVLB  8
....................                } 
....................                break; 
0A2FE:  MOVLB  7
0A300:  BRA    A65C
0A302:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A304:  BCF    FD8.0
0A306:  MOVLB  7
0A308:  RLCF   x40,W
0A30A:  CLRF   03
0A30C:  ADDLW  BB
0A30E:  MOVWF  FE9
0A310:  MOVLW  07
0A312:  ADDWFC 03,W
0A314:  MOVWF  FEA
0A316:  MOVFF  FEC,8B9
0A31A:  MOVF   FED,F
0A31C:  MOVFF  FEF,8B8
0A320:  MOVLB  8
0A322:  MOVF   xAD,F
0A324:  BNZ   A342
0A326:  MOVF   xAC,F
0A328:  BNZ   A342
0A32A:  MOVF   xAB,W
0A32C:  SUBWF  xB9,W
0A32E:  BNC   A342
0A330:  BNZ   A338
0A332:  MOVF   xAA,W
0A334:  SUBWF  xB8,W
0A336:  BNC   A342
....................                { 
....................                   terminate(0); 
0A338:  CLRF   xCC
0A33A:  MOVLB  0
0A33C:  CALL   902C
0A340:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A342:  BCF    FD8.0
0A344:  MOVLB  7
0A346:  RLCF   x40,W
0A348:  CLRF   03
0A34A:  ADDLW  7A
0A34C:  MOVWF  FE9
0A34E:  MOVLW  07
0A350:  ADDWFC 03,W
0A352:  MOVWF  FEA
0A354:  MOVFF  FEC,8B9
0A358:  MOVF   FED,F
0A35A:  MOVFF  FEF,8B8
0A35E:  MOVLB  8
0A360:  MOVF   xB8,F
0A362:  BNZ   A3C8
0A364:  MOVF   xB9,F
0A366:  BNZ   A3C8
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A368:  CLRF   03
0A36A:  MOVLB  7
0A36C:  MOVF   x40,W
0A36E:  ADDLW  CB
0A370:  MOVWF  FE9
0A372:  MOVLW  07
0A374:  ADDWFC 03,W
0A376:  MOVWF  FEA
0A378:  MOVF   FEF,F
0A37A:  BNZ   A3C6
....................                   { 
....................                      wrt_m_error(); 
0A37C:  MOVLB  0
0A37E:  CALL   8EDC
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A382:  BCF    FD8.0
0A384:  MOVLB  7
0A386:  RLCF   x40,W
0A388:  CLRF   03
0A38A:  ADDLW  B7
0A38C:  MOVWF  FE9
0A38E:  MOVLW  07
0A390:  ADDWFC 03,W
0A392:  MOVWF  FEA
0A394:  MOVFF  FEC,8BF
0A398:  MOVF   FED,F
0A39A:  MOVFF  FEF,8BE
0A39E:  MOVFF  8AD,8BD
0A3A2:  MOVFF  8AC,8BC
0A3A6:  MOVFF  8AB,8BB
0A3AA:  MOVFF  8AA,8BA
0A3AE:  MOVLB  0
0A3B0:  CALL   95EC
0A3B4:  MOVFF  03,8B2
0A3B8:  MOVFF  02,8B1
0A3BC:  MOVFF  01,8B0
0A3C0:  MOVFF  00,8AF
0A3C4:  MOVLB  7
0A3C6:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A3C8:  BCF    FD8.0
0A3CA:  MOVLB  7
0A3CC:  RLCF   x40,W
0A3CE:  CLRF   03
0A3D0:  ADDLW  7A
0A3D2:  MOVWF  FE9
0A3D4:  MOVLW  07
0A3D6:  ADDWFC 03,W
0A3D8:  MOVWF  FEA
0A3DA:  MOVFF  FEC,8B9
0A3DE:  MOVF   FED,F
0A3E0:  MOVFF  FEF,8B8
0A3E4:  MOVLB  8
0A3E6:  DECFSZ xB8,W
0A3E8:  BRA    A44E
0A3EA:  MOVF   xB9,F
0A3EC:  BNZ   A44E
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A3EE:  CLRF   03
0A3F0:  MOVLB  7
0A3F2:  MOVF   x40,W
0A3F4:  ADDLW  CB
0A3F6:  MOVWF  FE9
0A3F8:  MOVLW  07
0A3FA:  ADDWFC 03,W
0A3FC:  MOVWF  FEA
0A3FE:  DECFSZ FEF,W
0A400:  BRA    A44C
....................                   { 
....................                      wrt_m_error(); 
0A402:  MOVLB  0
0A404:  CALL   8EDC
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A408:  BCF    FD8.0
0A40A:  MOVLB  7
0A40C:  RLCF   x40,W
0A40E:  CLRF   03
0A410:  ADDLW  B7
0A412:  MOVWF  FE9
0A414:  MOVLW  07
0A416:  ADDWFC 03,W
0A418:  MOVWF  FEA
0A41A:  MOVFF  FEC,8BF
0A41E:  MOVF   FED,F
0A420:  MOVFF  FEF,8BE
0A424:  MOVFF  8AD,8BD
0A428:  MOVFF  8AC,8BC
0A42C:  MOVFF  8AB,8BB
0A430:  MOVFF  8AA,8BA
0A434:  MOVLB  0
0A436:  CALL   95EC
0A43A:  MOVFF  03,8B2
0A43E:  MOVFF  02,8B1
0A442:  MOVFF  01,8B0
0A446:  MOVFF  00,8AF
0A44A:  MOVLB  7
0A44C:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A44E:  MOVLB  7
0A450:  BRA    A65C
0A452:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A454:  MOVLB  7
0A456:  MOVF   x40,W
0A458:  MULLW  04
0A45A:  MOVF   FF3,W
0A45C:  CLRF   03
0A45E:  ADDLW  A2
0A460:  MOVWF  FE9
0A462:  MOVLW  07
0A464:  ADDWFC 03,W
0A466:  MOVWF  FEA
0A468:  MOVFF  FEF,8B8
0A46C:  MOVFF  FEC,8B9
0A470:  MOVFF  FEC,8BA
0A474:  MOVFF  FEC,8BB
0A478:  MOVLB  8
0A47A:  MOVF   xAF,W
0A47C:  SUBWF  xB8,F
0A47E:  MOVF   xB0,W
0A480:  SUBWFB xB9,F
0A482:  MOVF   xB1,W
0A484:  SUBWFB xBA,F
0A486:  MOVF   xB2,W
0A488:  SUBWFB xBB,F
0A48A:  BNZ   A4A2
0A48C:  MOVF   xBA,F
0A48E:  BNZ   A4A2
0A490:  MOVF   xB6,W
0A492:  SUBWF  xB9,W
0A494:  BTFSS  FD8.0
0A496:  BRA    A59E
0A498:  BNZ   A4A2
0A49A:  MOVF   xB5,W
0A49C:  SUBWF  xB8,W
0A49E:  BTFSS  FD8.0
0A4A0:  BRA    A59E
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A4A2:  BCF    FD8.0
0A4A4:  MOVLB  7
0A4A6:  RLCF   x40,W
0A4A8:  CLRF   03
0A4AA:  ADDLW  66
0A4AC:  MOVWF  01
0A4AE:  MOVLW  07
0A4B0:  ADDWFC 03,F
0A4B2:  MOVLB  8
0A4B4:  MOVFF  03,8B9
0A4B8:  BCF    FD8.0
0A4BA:  MOVLB  7
0A4BC:  RLCF   x40,W
0A4BE:  CLRF   03
0A4C0:  ADDLW  9E
0A4C2:  MOVWF  FE9
0A4C4:  MOVLW  07
0A4C6:  ADDWFC 03,W
0A4C8:  MOVWF  FEA
0A4CA:  MOVFF  FEC,03
0A4CE:  MOVF   FED,F
0A4D0:  MOVFF  FEF,8BA
0A4D4:  MOVLB  8
0A4D6:  MOVFF  8B9,FEA
0A4DA:  MOVFF  01,FE9
0A4DE:  MOVFF  03,FEC
0A4E2:  MOVF   FED,F
0A4E4:  MOVFF  8BA,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A4E8:  MOVLB  7
0A4EA:  MOVF   x40,W
0A4EC:  MULLW  04
0A4EE:  MOVF   FF3,W
0A4F0:  CLRF   03
0A4F2:  ADDLW  A2
0A4F4:  MOVWF  FE9
0A4F6:  MOVLW  07
0A4F8:  ADDWFC 03,W
0A4FA:  MOVWF  FEA
0A4FC:  MOVFF  FEF,8B8
0A500:  MOVFF  FEC,8B9
0A504:  MOVFF  FEC,8BA
0A508:  MOVFF  FEC,8BB
0A50C:  MOVLW  8C
0A50E:  MOVWF  FF6
0A510:  MOVLW  1A
0A512:  MOVWF  FF7
0A514:  MOVLW  00
0A516:  MOVWF  FF8
0A518:  CLRF   1B
0A51A:  BTFSC  FF2.7
0A51C:  BSF    1B.7
0A51E:  BCF    FF2.7
0A520:  MOVLW  0B
0A522:  MOVLB  A
0A524:  MOVWF  x1C
0A526:  MOVLB  0
0A528:  CALL   1024
0A52C:  BTFSC  1B.7
0A52E:  BSF    FF2.7
0A530:  MOVLW  41
0A532:  MOVWF  FE9
0A534:  CLRF   1B
0A536:  BTFSC  FF2.7
0A538:  BSF    1B.7
0A53A:  BCF    FF2.7
0A53C:  MOVFF  8BB,A1F
0A540:  MOVFF  8BA,A1E
0A544:  MOVFF  8B9,A1D
0A548:  MOVFF  8B8,A1C
0A54C:  CALL   10EA
0A550:  BTFSC  1B.7
0A552:  BSF    FF2.7
0A554:  MOVLW  2C
0A556:  BTFSS  F9E.4
0A558:  BRA    A556
0A55A:  MOVWF  FAD
0A55C:  MOVLW  41
0A55E:  MOVWF  FE9
0A560:  CLRF   1B
0A562:  BTFSC  FF2.7
0A564:  BSF    1B.7
0A566:  BCF    FF2.7
0A568:  MOVFF  8B2,A1F
0A56C:  MOVFF  8B1,A1E
0A570:  MOVFF  8B0,A1D
0A574:  MOVFF  8AF,A1C
0A578:  CALL   10EA
0A57C:  BTFSC  1B.7
0A57E:  BSF    FF2.7
0A580:  MOVLW  0D
0A582:  BTFSS  F9E.4
0A584:  BRA    A582
0A586:  MOVWF  FAD
0A588:  MOVLW  0A
0A58A:  BTFSS  F9E.4
0A58C:  BRA    A58A
0A58E:  MOVWF  FAD
....................                   terminate(1); 
0A590:  MOVLW  01
0A592:  MOVLB  8
0A594:  MOVWF  xCC
0A596:  MOVLB  0
0A598:  CALL   902C
0A59C:  MOVLB  8
....................                } 
....................                break; 
0A59E:  MOVLB  7
0A5A0:  BRA    A65C
0A5A2:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A5A4:  MOVLB  7
0A5A6:  MOVF   x40,W
0A5A8:  MULLW  04
0A5AA:  MOVF   FF3,W
0A5AC:  CLRF   03
0A5AE:  ADDLW  A2
0A5B0:  MOVWF  FE9
0A5B2:  MOVLW  07
0A5B4:  ADDWFC 03,W
0A5B6:  MOVWF  FEA
0A5B8:  MOVFF  FEF,8B8
0A5BC:  MOVFF  FEC,8B9
0A5C0:  MOVFF  FEC,8BA
0A5C4:  MOVFF  FEC,8BB
0A5C8:  BCF    FD8.0
0A5CA:  RLCF   x40,W
0A5CC:  CLRF   03
0A5CE:  ADDLW  72
0A5D0:  MOVWF  FE9
0A5D2:  MOVLW  07
0A5D4:  ADDWFC 03,W
0A5D6:  MOVWF  FEA
0A5D8:  MOVFF  FEC,03
0A5DC:  MOVF   FED,F
0A5DE:  MOVFF  FEF,01
0A5E2:  MOVLB  8
0A5E4:  MOVF   xBB,F
0A5E6:  BNZ   A5FA
0A5E8:  MOVF   xBA,F
0A5EA:  BNZ   A5FA
0A5EC:  MOVF   03,W
0A5EE:  SUBWF  xB9,W
0A5F0:  BNC   A65A
0A5F2:  BNZ   A5FA
0A5F4:  MOVF   01,W
0A5F6:  SUBWF  xB8,W
0A5F8:  BNC   A65A
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A5FA:  BCF    FD8.0
0A5FC:  MOVLB  7
0A5FE:  RLCF   x40,W
0A600:  CLRF   03
0A602:  ADDLW  66
0A604:  MOVWF  01
0A606:  MOVLW  07
0A608:  ADDWFC 03,F
0A60A:  MOVLB  8
0A60C:  MOVFF  03,8B9
0A610:  BCF    FD8.0
0A612:  MOVLB  7
0A614:  RLCF   x40,W
0A616:  CLRF   03
0A618:  ADDLW  9E
0A61A:  MOVWF  FE9
0A61C:  MOVLW  07
0A61E:  ADDWFC 03,W
0A620:  MOVWF  FEA
0A622:  MOVFF  FEC,03
0A626:  MOVF   FED,F
0A628:  MOVFF  FEF,8BA
0A62C:  MOVLB  8
0A62E:  MOVFF  8B9,FEA
0A632:  MOVFF  01,FE9
0A636:  MOVFF  03,FEC
0A63A:  MOVF   FED,F
0A63C:  MOVFF  8BA,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A640:  BCF    FD8.0
0A642:  MOVLB  7
0A644:  RLCF   x40,W
0A646:  CLRF   03
0A648:  ADDLW  BB
0A64A:  MOVWF  FE9
0A64C:  MOVLW  07
0A64E:  ADDWFC 03,W
0A650:  MOVWF  FEA
0A652:  CLRF   FEC
0A654:  MOVF   FED,F
0A656:  CLRF   FEF
0A658:  MOVLB  8
....................                } 
....................                break; 
0A65A:  MOVLB  7
....................             } 
....................          } 
0A65C:  MOVLB  0
0A65E:  BRA    A150
0A660:  MOVLB  7
....................       } 
....................    } 
0A662:  BRA    A680
0A664:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A666:  BCF    FD8.0
0A668:  MOVLB  7
0A66A:  RLCF   x40,W
0A66C:  CLRF   03
0A66E:  ADDLW  96
0A670:  MOVWF  FE9
0A672:  MOVLW  07
0A674:  ADDWFC 03,W
0A676:  MOVWF  FEA
0A678:  CLRF   FEC
0A67A:  MOVF   FED,F
0A67C:  MOVLW  01
0A67E:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A680:  BCF    FD8.0
0A682:  RLCF   x40,W
0A684:  CLRF   03
0A686:  ADDLW  96
0A688:  MOVWF  FE9
0A68A:  MOVLW  07
0A68C:  ADDWFC 03,W
0A68E:  MOVWF  FEA
0A690:  MOVFF  FEC,8B9
0A694:  MOVF   FED,F
0A696:  MOVFF  FEF,8B8
0A69A:  MOVLB  8
0A69C:  DECFSZ xB8,W
0A69E:  BRA    A6B0
0A6A0:  MOVF   xB9,F
0A6A2:  BNZ   A6B0
....................       wrt_m_error(); 
0A6A4:  MOVLB  0
0A6A6:  CALL   8EDC
....................       msg_mer(); 
0A6AA:  CALL   9C5E
0A6AE:  MOVLB  8
....................    } 
0A6B0:  MOVLB  0
0A6B2:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
16C20:  MOVF   48,F
16C22:  BNZ   16C30
16C24:  MOVF   49,F
16C26:  BNZ   16C30
16C28:  MOVF   4A,F
16C2A:  BNZ   16C30
16C2C:  MOVF   4B,F
16C2E:  BZ    16C5C
16C30:  MOVF   4B,F
16C32:  BNZ   16C5C
16C34:  MOVF   4A,W
16C36:  SUBLW  00
16C38:  BNC   16C5C
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
16C3A:  MOVFF  866,8A8
16C3E:  MOVFF  867,8A9
16C42:  MOVFF  4B,8AD
16C46:  MOVFF  4A,8AC
16C4A:  MOVFF  49,8AB
16C4E:  MOVFF  48,8AA
16C52:  MOVFF  868,8AE
16C56:  CALL   9CD4
....................    } 
16C5A:  BRA    16CD8
....................    else if(arg==0) 
16C5C:  MOVF   48,F
16C5E:  BNZ   16CD4
16C60:  MOVF   49,F
16C62:  BNZ   16CD4
16C64:  MOVF   4A,F
16C66:  BNZ   16CD4
16C68:  MOVF   4B,F
16C6A:  BNZ   16CD4
....................    { 
....................       m_lin_pos[motor]=0; 
16C6C:  BCF    FD8.0
16C6E:  MOVLB  7
16C70:  RLCF   x40,W
16C72:  CLRF   03
16C74:  ADDLW  B3
16C76:  MOVWF  FE9
16C78:  MOVLW  07
16C7A:  ADDWFC 03,W
16C7C:  MOVWF  FEA
16C7E:  CLRF   FEC
16C80:  MOVF   FED,F
16C82:  CLRF   FEF
....................       switch (motor){ 
16C84:  MOVF   x40,W
16C86:  XORLW  00
16C88:  MOVLB  0
16C8A:  BZ    16C92
16C8C:  XORLW  01
16C8E:  BZ    16CA4
16C90:  BRA    16CB4
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
16C92:  MOVLW  B6
16C94:  MOVLB  8
16C96:  MOVWF  xCF
16C98:  CLRF   xD1
16C9A:  CLRF   xD0
16C9C:  MOVLB  0
16C9E:  CALL   4F68
....................             break; 
16CA2:  BRA    16CB4
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
16CA4:  MOVLW  B8
16CA6:  MOVLB  8
16CA8:  MOVWF  xCF
16CAA:  CLRF   xD1
16CAC:  CLRF   xD0
16CAE:  MOVLB  0
16CB0:  CALL   4F68
....................             break; 
....................       }  
....................       m_error[motor]=0; 
16CB4:  BCF    FD8.0
16CB6:  MOVLB  7
16CB8:  RLCF   x40,W
16CBA:  CLRF   03
16CBC:  ADDLW  96
16CBE:  MOVWF  FE9
16CC0:  MOVLW  07
16CC2:  ADDWFC 03,W
16CC4:  MOVWF  FEA
16CC6:  CLRF   FEC
16CC8:  MOVF   FED,F
16CCA:  CLRF   FEF
....................       wrt_m_error(); 
16CCC:  MOVLB  0
16CCE:  CALL   8EDC
....................    } 
16CD2:  BRA    16CD8
....................    else cmd_arg(); 
16CD4:  CALL   AF88
16CD8:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
187EC:  MOVLW  01
187EE:  MOVLB  8
187F0:  MOVWF  xCD
187F2:  MOVLB  0
187F4:  CALL   892C
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
187F8:  MOVLW  FA
187FA:  MOVLB  9
187FC:  MOVWF  xCD
187FE:  MOVLB  0
18800:  CALL   28AC
....................       switch(motor) 
18804:  MOVLB  7
18806:  MOVF   x40,W
18808:  XORLW  00
1880A:  MOVLB  0
1880C:  BZ    18814
1880E:  XORLW  01
18810:  BZ    18826
18812:  BRA    18836
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18814:  MOVLB  8
18816:  CLRF   x66
18818:  BTFSC  F81.4
1881A:  INCF   x66,F
....................             chanA = input(ENC1_PHA); 
1881C:  CLRF   x67
1881E:  BTFSC  F81.1
18820:  INCF   x67,F
....................             break; 
18822:  MOVLB  0
18824:  BRA    18836
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
18826:  MOVLB  8
18828:  CLRF   x66
1882A:  BTFSC  F81.5
1882C:  INCF   x66,F
....................             chanA = input(ENC2_PHA); 
1882E:  CLRF   x67
18830:  BTFSC  F81.2
18832:  INCF   x67,F
....................             break; 
18834:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
18836:  MOVLW  A2
18838:  MOVWF  FF6
1883A:  MOVLW  1A
1883C:  MOVWF  FF7
1883E:  MOVLW  00
18840:  MOVWF  FF8
18842:  CLRF   1B
18844:  BTFSC  FF2.7
18846:  BSF    1B.7
18848:  BCF    FF2.7
1884A:  MOVLW  04
1884C:  MOVLB  A
1884E:  MOVWF  x1C
18850:  MOVLB  0
18852:  CALL   1024
18856:  BTFSC  1B.7
18858:  BSF    FF2.7
1885A:  CLRF   1B
1885C:  BTFSC  FF2.7
1885E:  BSF    1B.7
18860:  BCF    FF2.7
18862:  MOVFF  866,A1C
18866:  MOVLW  1B
18868:  MOVLB  A
1886A:  MOVWF  x1D
1886C:  MOVLB  0
1886E:  CALL   0FA6
18872:  BTFSC  1B.7
18874:  BSF    FF2.7
18876:  MOVLW  A8
18878:  MOVWF  FF6
1887A:  MOVLW  1A
1887C:  MOVWF  FF7
1887E:  MOVLW  00
18880:  MOVWF  FF8
18882:  CLRF   1B
18884:  BTFSC  FF2.7
18886:  BSF    1B.7
18888:  BCF    FF2.7
1888A:  MOVLW  07
1888C:  MOVLB  A
1888E:  MOVWF  x1C
18890:  MOVLB  0
18892:  CALL   1024
18896:  BTFSC  1B.7
18898:  BSF    FF2.7
1889A:  CLRF   1B
1889C:  BTFSC  FF2.7
1889E:  BSF    1B.7
188A0:  BCF    FF2.7
188A2:  MOVFF  867,A1C
188A6:  MOVLW  1B
188A8:  MOVLB  A
188AA:  MOVWF  x1D
188AC:  MOVLB  0
188AE:  CALL   0FA6
188B2:  BTFSC  1B.7
188B4:  BSF    FF2.7
188B6:  MOVLW  0D
188B8:  BTFSS  F9E.4
188BA:  BRA    188B8
188BC:  MOVWF  FAD
188BE:  MOVLW  0A
188C0:  BTFSS  F9E.4
188C2:  BRA    188C0
188C4:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
188C6:  BTFSS  F9E.5
188C8:  BRA    188D6
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
188CA:  CALL   0E38
188CE:  MOVF   01,W
188D0:  SUBLW  1B
188D2:  BNZ   188D6
....................          { 
....................             break; 
188D4:  BRA    188D8
....................          } 
....................       } 
188D6:  BRA    187F8
....................    } 
....................  
....................    delay_ms(100); 
188D8:  MOVLW  64
188DA:  MOVLB  9
188DC:  MOVWF  xCD
188DE:  MOVLB  0
188E0:  CALL   28AC
....................    enc_pwr(OFF); 
188E4:  MOVLB  8
188E6:  CLRF   xCD
188E8:  MOVLB  0
188EA:  CALL   892C
188EE:  GOTO   1890A (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A810:  BCF    FD8.0
0A812:  MOVLB  7
0A814:  RLCF   x40,W
0A816:  CLRF   03
0A818:  ADDLW  66
0A81A:  MOVWF  FE9
0A81C:  MOVLW  07
0A81E:  ADDWFC 03,W
0A820:  MOVWF  FEA
0A822:  MOVFF  FEC,8A7
0A826:  MOVF   FED,F
0A828:  MOVFF  FEF,8A6
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A82C:  BCF    FD8.0
0A82E:  RLCF   x40,W
0A830:  CLRF   03
0A832:  ADDLW  76
0A834:  MOVWF  FE9
0A836:  MOVLW  07
0A838:  ADDWFC 03,W
0A83A:  MOVWF  FEA
0A83C:  MOVFF  FEC,8BD
0A840:  MOVF   FED,F
0A842:  MOVFF  FEF,8BC
0A846:  BCF    FD8.0
0A848:  RLCF   x40,W
0A84A:  CLRF   03
0A84C:  ADDLW  62
0A84E:  MOVWF  FE9
0A850:  MOVLW  07
0A852:  ADDWFC 03,W
0A854:  MOVWF  FEA
0A856:  MOVFF  FEC,03
0A85A:  MOVF   FED,F
0A85C:  MOVFF  FEF,8BE
0A860:  MOVFF  03,8AB
0A864:  MOVFF  03,8BF
0A868:  MOVLB  0
0A86A:  CALL   2C70
0A86E:  MOVFF  02,8A5
0A872:  MOVFF  01,8A4
....................    e_mode[motor] = 0;                          // motor steps 
0A876:  BCF    FD8.0
0A878:  MOVLB  7
0A87A:  RLCF   x40,W
0A87C:  CLRF   03
0A87E:  ADDLW  66
0A880:  MOVWF  FE9
0A882:  MOVLW  07
0A884:  ADDWFC 03,W
0A886:  MOVWF  FEA
0A888:  CLRF   FEC
0A88A:  MOVF   FED,F
0A88C:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A88E:  MOVLB  8
0A890:  CLRF   xA8
0A892:  MOVFF  8A3,8A9
0A896:  CLRF   xAD
0A898:  CLRF   xAC
0A89A:  MOVFF  8A5,8AB
0A89E:  MOVFF  8A4,8AA
0A8A2:  MOVLW  01
0A8A4:  MOVWF  xAE
0A8A6:  MOVLB  0
0A8A8:  CALL   9CD4
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A8AC:  MOVLW  01
0A8AE:  MOVLB  8
0A8B0:  MOVWF  xCD
0A8B2:  MOVLB  0
0A8B4:  CALL   892C
....................    delay_ms(100); 
0A8B8:  MOVLW  64
0A8BA:  MOVLB  9
0A8BC:  MOVWF  xCD
0A8BE:  MOVLB  0
0A8C0:  CALL   28AC
....................    poll_index(); 
0A8C4:  BRA    A6DE
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A8C6:  BCF    FD8.0
0A8C8:  MOVLB  7
0A8CA:  RLCF   x40,W
0A8CC:  CLRF   03
0A8CE:  ADDLW  5E
0A8D0:  MOVWF  FE9
0A8D2:  MOVLW  07
0A8D4:  ADDWFC 03,W
0A8D6:  MOVWF  FEA
0A8D8:  MOVFF  FEC,8A9
0A8DC:  MOVF   FED,F
0A8DE:  MOVFF  FEF,8A8
0A8E2:  MOVLW  02
0A8E4:  MOVLB  8
0A8E6:  ADDWF  xA8,W
0A8E8:  MOVWF  xA4
0A8EA:  MOVLW  00
0A8EC:  ADDWFC xA9,W
0A8EE:  MOVWF  xA5
....................    e_mode[motor] = 3; 
0A8F0:  BCF    FD8.0
0A8F2:  MOVLB  7
0A8F4:  RLCF   x40,W
0A8F6:  CLRF   03
0A8F8:  ADDLW  66
0A8FA:  MOVWF  FE9
0A8FC:  MOVLW  07
0A8FE:  ADDWFC 03,W
0A900:  MOVWF  FEA
0A902:  CLRF   FEC
0A904:  MOVF   FED,F
0A906:  MOVLW  03
0A908:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A90A:  MOVLB  8
0A90C:  CLRF   xA8
0A90E:  MOVFF  8A3,8A9
0A912:  CLRF   xAD
0A914:  CLRF   xAC
0A916:  MOVFF  8A5,8AB
0A91A:  MOVFF  8A4,8AA
0A91E:  MOVLW  01
0A920:  MOVWF  xAE
0A922:  MOVLB  0
0A924:  CALL   9CD4
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A928:  MOVFF  783,8A5
0A92C:  MOVFF  782,8A4
....................    e_mode[motor] = 0;                          // motor steps 
0A930:  BCF    FD8.0
0A932:  MOVLB  7
0A934:  RLCF   x40,W
0A936:  CLRF   03
0A938:  ADDLW  66
0A93A:  MOVWF  FE9
0A93C:  MOVLW  07
0A93E:  ADDWFC 03,W
0A940:  MOVWF  FEA
0A942:  CLRF   FEC
0A944:  MOVF   FED,F
0A946:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0A948:  MOVLB  8
0A94A:  CLRF   xA8
0A94C:  MOVFF  8A3,8A9
0A950:  CLRF   xAD
0A952:  CLRF   xAC
0A954:  MOVFF  8A5,8AB
0A958:  MOVFF  8A4,8AA
0A95C:  MOVLW  01
0A95E:  MOVWF  xAE
0A960:  MOVLB  0
0A962:  CALL   9CD4
....................  
....................    e_pos[motor] = 0; 
0A966:  BCF    FD8.0
0A968:  MOVLB  7
0A96A:  RLCF   x40,W
0A96C:  CLRF   03
0A96E:  ADDLW  BF
0A970:  MOVWF  FE9
0A972:  MOVLW  07
0A974:  ADDWFC 03,W
0A976:  MOVWF  FEA
0A978:  CLRF   FEC
0A97A:  MOVF   FED,F
0A97C:  CLRF   FEF
....................    e_port[motor] = 1; 
0A97E:  BCF    FD8.0
0A980:  RLCF   x40,W
0A982:  CLRF   03
0A984:  ADDLW  C3
0A986:  MOVWF  FE9
0A988:  MOVLW  07
0A98A:  ADDWFC 03,W
0A98C:  MOVWF  FEA
0A98E:  CLRF   FEC
0A990:  MOVF   FED,F
0A992:  MOVLW  01
0A994:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0A996:  BCF    FD8.0
0A998:  RLCF   x40,W
0A99A:  CLRF   03
0A99C:  ADDLW  66
0A99E:  MOVWF  FE9
0A9A0:  MOVLW  07
0A9A2:  ADDWFC 03,W
0A9A4:  MOVWF  FEA
0A9A6:  MOVFF  8A7,FEC
0A9AA:  MOVF   FED,F
0A9AC:  MOVFF  8A6,FEF
0A9B0:  MOVLB  0
0A9B2:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0DD24:  BCF    FD8.0
0DD26:  MOVLB  7
0DD28:  RLCF   x40,W
0DD2A:  CLRF   03
0DD2C:  ADDLW  5E
0DD2E:  MOVWF  FE9
0DD30:  MOVLW  07
0DD32:  ADDWFC 03,W
0DD34:  MOVWF  FEA
0DD36:  MOVFF  FEC,86A
0DD3A:  MOVF   FED,F
0DD3C:  MOVFF  FEF,869
0DD40:  MOVLW  02
0DD42:  MOVLB  8
0DD44:  ADDWF  x69,W
0DD46:  MOVWF  x67
0DD48:  MOVLW  00
0DD4A:  ADDWFC x6A,W
0DD4C:  MOVWF  x68
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0DD4E:  CLRF   xA8
0DD50:  MOVFF  866,8A9
0DD54:  CLRF   xAD
0DD56:  CLRF   xAC
0DD58:  MOVFF  868,8AB
0DD5C:  MOVFF  867,8AA
0DD60:  MOVLW  02
0DD62:  MOVWF  xAE
0DD64:  MOVLB  0
0DD66:  CALL   9CD4
0DD6A:  GOTO   DDEA (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0A9B4:  MOVF   2F,W
0A9B6:  SUBLW  02
0A9B8:  BNZ   A9BE
0A9BA:  MOVF   30,F
0A9BC:  BZ    AA26
....................    { 
....................       //setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_256); 
....................       //set up valve timeout variable 
....................       /*ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
....................       enable_interrupts(INT_EXT); 
....................  
....................       start_heartbeat(); 
....................  
....................       enable_interrupts(GLOBAL); 
....................       busy_set();*/ 
....................       valve_align_timeout = 0; 
0A9BE:  CLRF   3A
0A9C0:  CLRF   39
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0A9C2:  MOVLW  B4
0A9C4:  MOVWF  FF6
0A9C6:  MOVLW  1A
0A9C8:  MOVWF  FF7
0A9CA:  MOVLW  00
0A9CC:  MOVWF  FF8
0A9CE:  CLRF   1B
0A9D0:  BTFSC  FF2.7
0A9D2:  BSF    1B.7
0A9D4:  BCF    FF2.7
0A9D6:  CALL   0E4E
0A9DA:  BTFSC  1B.7
0A9DC:  BSF    FF2.7
....................       motor=0; 
0A9DE:  MOVLB  7
0A9E0:  CLRF   x40
....................       align(0); 
0A9E2:  MOVLB  8
0A9E4:  CLRF   xA3
0A9E6:  MOVLB  0
0A9E8:  RCALL  A810
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0A9EA:  MOVLW  01
0A9EC:  MOVLB  7
0A9EE:  MOVWF  x40
....................       move_motor(0,0,22000,1); 
0A9F0:  MOVLB  8
0A9F2:  CLRF   xA8
0A9F4:  CLRF   xA9
0A9F6:  CLRF   xAD
0A9F8:  CLRF   xAC
0A9FA:  MOVLW  55
0A9FC:  MOVWF  xAB
0A9FE:  MOVLW  F0
0AA00:  MOVWF  xAA
0AA02:  MOVLW  01
0AA04:  MOVWF  xAE
0AA06:  MOVLB  0
0AA08:  CALL   9CD4
....................        
....................       m_lin_pos[1]=0; 
0AA0C:  MOVLB  7
0AA0E:  CLRF   xB6
0AA10:  CLRF   xB5
....................       write16(ADDR_M2_LIN_POS,0); 
0AA12:  MOVLW  B8
0AA14:  MOVLB  8
0AA16:  MOVWF  xCF
0AA18:  CLRF   xD1
0AA1A:  CLRF   xD0
0AA1C:  MOVLB  0
0AA1E:  CALL   4F68
....................       valve_align_timeout = -1; 
0AA22:  SETF   3A
0AA24:  SETF   39
....................    } 
0AA26:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0BE8C:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BE8E:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0BE90:  BCF    F8E.3
....................   delay_ms(20); 
0BE92:  MOVLW  14
0BE94:  MOVLB  9
0BE96:  MOVWF  xCD
0BE98:  MOVLB  0
0BE9A:  CALL   28AC
....................   output_bit(VMOT,  OFF); 
0BE9E:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0BEA0:  BCF    F8E.2
0BEA2:  GOTO   BEF8 (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BEA6:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BEA8:  BSF    F8E.1
....................   delay_ms(50); 
0BEAA:  MOVLW  32
0BEAC:  MOVLB  9
0BEAE:  MOVWF  xCD
0BEB0:  MOVLB  0
0BEB2:  CALL   28AC
....................   output_bit(HB_IN1,ON);           
0BEB6:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BEB8:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0BEBA:  BSF    F8E.3
0BEBC:  GOTO   BEF8 (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BEC0:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BEC2:  BSF    F8E.1
....................   delay_ms(50); 
0BEC4:  MOVLW  32
0BEC6:  MOVLB  9
0BEC8:  MOVWF  xCD
0BECA:  MOVLB  0
0BECC:  CALL   28AC
....................   output_bit(HB_IN1,OFF);           
0BED0:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0BED2:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0BED4:  BSF    F8E.3
0BED6:  GOTO   BEF8 (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0BEDA:  MOVLB  8
0BEDC:  MOVF   x96,W
0BEDE:  XORLW  00
0BEE0:  MOVLB  0
0BEE2:  BZ    BEEE
0BEE4:  XORLW  01
0BEE6:  BZ    BEF2
0BEE8:  XORLW  03
0BEEA:  BZ    BEF6
0BEEC:  BRA    BEF8
....................       case 0:  HB_all_OFF(); 
0BEEE:  BRA    BE8C
....................          break; 
0BEF0:  BRA    BEF8
....................       case 1:  HB_m1_ON(); 
0BEF2:  BRA    BEA6
....................          break; 
0BEF4:  BRA    BEF8
....................       case 2:  HB_m2_ON(); 
0BEF6:  BRA    BEC0
....................          break; 
....................    } 
0BEF8:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
15926:  MOVLB  8
15928:  CLRF   x6A
1592A:  CLRF   x6B
1592C:  CLRF   x6C
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
1592E:  MOVLB  0
15930:  BRA    158BC
15932:  MOVFF  01,86B
....................       if (serChar) 
15936:  MOVLB  8
15938:  MOVF   x6B,F
1593A:  BZ    15964
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
1593C:  MOVF   x6B,W
1593E:  SUBLW  24
15940:  BNZ   1594A
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
15942:  MOVLW  02
15944:  MOVWF  x6C
....................             break; 
15946:  BRA    15970
....................          }else if (serChar == 'D'){ 
15948:  BRA    15964
1594A:  MOVF   x6B,W
1594C:  SUBLW  44
1594E:  BNZ   15960
....................             wakeup_char_is_D = 1; 
15950:  MOVLW  01
15952:  MOVLB  7
15954:  MOVWF  xCD
....................             wakeUpReason = WAKE_UP_GOOD; 
15956:  MOVLW  02
15958:  MOVLB  8
1595A:  MOVWF  x6C
....................             break; 
1595C:  BRA    15970
....................          }else 
1595E:  BRA    15964
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
15960:  MOVLW  01
15962:  MOVWF  x6C
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
15964:  INCF   x6A,F
15966:  MOVF   x6A,W
15968:  SUBLW  02
1596A:  BC    1596E
....................       { 
....................          break; 
1596C:  BRA    15970
....................       } 
1596E:  BRA    1592E
....................    } 
....................  
....................    return (wakeUpReason); 
15970:  MOVFF  86C,01
15974:  MOVLB  0
15976:  GOTO   1598A (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
15854:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
15856:  BSF    4D.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
15858:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
1585A:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
1585C:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
1585E:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
15860:  BSF    FF2.6
15862:  GOTO   1586E (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
15866:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
15868:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
1586A:  BCF    4D.0
....................    set_usart_int(); 
1586C:  BRA    15854
....................    kill_wd(); 
1586E:  CALL   3092
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
15872:  BSF    FF2.4
....................    sleep();  
15874:  MOVFF  FD3,00
15878:  BCF    FD1.7
1587A:  BCF    FD3.7
1587C:  SLEEP 
1587E:  MOVFF  00,FD3
....................    delay_cycles(1); 
15882:  NOP   
15884:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
1597A:  MOVLB  8
1597C:  CLRF   x69
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
1597E:  MOVLB  0
15980:  RCALL  15886
....................  
....................    if (TRUE != rtc_alarm) 
15982:  BTFSC  4D.0
15984:  BRA    15A46
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
15986:  RCALL  15886
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
15988:  BRA    15926
1598A:  MOVFF  01,869
....................       if (WAKE_UP_GOOD == serWakeupReason) 
1598E:  MOVLB  8
15990:  MOVF   x69,W
15992:  SUBLW  02
15994:  BNZ   15A3E
....................       { 
....................          sleep_mode = FALSE; 
15996:  BCF    4D.1
....................          start_heartbeat(); 
15998:  MOVLB  0
1599A:  CALL   289C
....................          init_hardware(); 
1599E:  CALL   28D6
....................          init_rtc();                      // This is the FAT RTC 
159A2:  CALL   34A4
....................          sd_status = init_sdcard(); 
159A6:  CALL   4FCE
159AA:  MOVFF  01,2DC
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
159AE:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
159B0:  MOVLW  01
159B2:  MOVWF  1E
159B4:  MOVLW  A7
159B6:  MOVWF  1D
159B8:  MOVLW  EA
159BA:  MOVWF  FF6
159BC:  MOVLW  1A
159BE:  MOVWF  FF7
159C0:  MOVLW  00
159C2:  MOVWF  FF8
159C4:  CALL   5052
....................          record_event(); 
159C8:  CALL   8436
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
159CC:  CLRF   32
159CE:  MOVLW  01
159D0:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
159D2:  MOVLW  02
159D4:  MOVLB  8
159D6:  MOVWF  x6A
159D8:  MOVFF  31,86B
159DC:  MOVLB  0
159DE:  CALL   33AE
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
159E2:  MOVLB  7
159E4:  MOVF   xCD,F
159E6:  BZ    15A0C
....................             file_list(file_ptr_rel_new); 
159E8:  MOVLW  03
159EA:  MOVLB  8
159EC:  MOVWF  x6B
159EE:  MOVLW  07
159F0:  MOVWF  x6A
159F2:  MOVLB  0
159F4:  CALL   B7AE
....................             f_unlink(file_ptr_rel_new); 
159F8:  MOVLW  03
159FA:  MOVLB  8
159FC:  MOVWF  x6B
159FE:  MOVLW  07
15A00:  MOVWF  x6A
15A02:  MOVLB  0
15A04:  CALL   B928
....................              
....................             wakeup_char_is_D = 0; 
15A08:  MOVLB  7
15A0A:  CLRF   xCD
....................          } 
....................          if(sd_status>0) 
15A0C:  MOVLB  2
15A0E:  MOVF   xDC,F
15A10:  BZ    15A1A
....................          { 
....................             msg_card_fail(); 
15A12:  MOVLB  0
15A14:  CALL   5014
15A18:  MOVLB  2
....................          } 
....................  
....................          fprintf(COM_A, "@RST\r\n"); 
15A1A:  MOVLW  0C
15A1C:  MOVWF  FF6
15A1E:  MOVLW  1B
15A20:  MOVWF  FF7
15A22:  MOVLW  00
15A24:  MOVWF  FF8
15A26:  CLRF   1B
15A28:  BTFSC  FF2.7
15A2A:  BSF    1B.7
15A2C:  BCF    FF2.7
15A2E:  MOVLB  0
15A30:  CALL   0E4E
15A34:  BTFSC  1B.7
15A36:  BSF    FF2.7
....................          reset_cpu(); 
15A38:  RESET
....................       } 
15A3A:  BRA    15A46
15A3C:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
15A3E:  DECFSZ x69,W
15A40:  BRA    15A48
....................          { 
....................             initilizeSleepState(); 
15A42:  MOVLB  0
15A44:  RCALL  15866
15A46:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
15A48:  MOVLW  00
15A4A:  BTFSC  4D.0
15A4C:  MOVLW  01
15A4E:  MOVWF  01
15A50:  MOVLB  0
15A52:  GOTO   15A5C (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
15A56:  RCALL  157EA
....................    initilizeSleepState(); 
15A58:  RCALL  15866
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
15A5A:  BRA    1597A
15A5C:  DECFSZ 01,W
15A5E:  BRA    15A64
....................       { 
....................          rtc_alarm = FALSE; 
15A60:  BCF    4D.0
....................          break; 
15A62:  BRA    15A6A
....................       } 
....................  
....................       blip(); 
15A64:  RCALL  15886
....................       blip(); 
15A66:  RCALL  15886
15A68:  BRA    15A5A
....................    } 
15A6A:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0AB22:  MOVF   FD0,W
0AB24:  ANDLW  0F
0AB26:  BTFSS  FD0.4
0AB28:  MOVLW  00
0AB2A:  BSF    FD0.0
0AB2C:  BSF    FD0.1
0AB2E:  BSF    FD0.4
0AB30:  BSF    FD8.3
0AB32:  BSF    FD8.4
0AB34:  ADDLW  F0
0AB36:  BTFSC  FD8.0
0AB38:  BRA    AD08
0AB3A:  ADDLW  10
0AB3C:  GOTO   AD0C
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0AB40:  MOVLW  14
0AB42:  MOVWF  FF6
0AB44:  MOVLW  1B
0AB46:  MOVWF  FF7
0AB48:  MOVLW  00
0AB4A:  MOVWF  FF8
0AB4C:  CLRF   1B
0AB4E:  BTFSC  FF2.7
0AB50:  BSF    1B.7
0AB52:  BCF    FF2.7
0AB54:  CALL   0E4E
0AB58:  BTFSC  1B.7
0AB5A:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0AB5C:  MOVLW  01
0AB5E:  MOVWF  1E
0AB60:  MOVLW  A7
0AB62:  MOVWF  1D
0AB64:  MOVLW  1C
0AB66:  MOVWF  FF6
0AB68:  MOVLW  1B
0AB6A:  MOVWF  FF7
0AB6C:  MOVLW  00
0AB6E:  MOVWF  FF8
0AB70:  CALL   5052
....................          record_event(); 
0AB74:  CALL   8436
....................          recovery(); 
0AB78:  RCALL  A9B4
....................          break; 
0AB7A:  BRA    AD08
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AB7C:  MOVLW  3A
0AB7E:  MOVWF  FF6
0AB80:  MOVLW  1B
0AB82:  MOVWF  FF7
0AB84:  MOVLW  00
0AB86:  MOVWF  FF8
0AB88:  CLRF   1B
0AB8A:  BTFSC  FF2.7
0AB8C:  BSF    1B.7
0AB8E:  BCF    FF2.7
0AB90:  CALL   0E4E
0AB94:  BTFSC  1B.7
0AB96:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AB98:  MOVLW  01
0AB9A:  MOVWF  1E
0AB9C:  MOVLW  A7
0AB9E:  MOVWF  1D
0ABA0:  MOVLW  42
0ABA2:  MOVWF  FF6
0ABA4:  MOVLW  1B
0ABA6:  MOVWF  FF7
0ABA8:  MOVLW  00
0ABAA:  MOVWF  FF8
0ABAC:  CALL   5052
....................          record_event(); 
0ABB0:  CALL   8436
....................          recovery(); 
0ABB4:  RCALL  A9B4
....................          break; 
0ABB6:  BRA    AD08
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0ABB8:  MOVLW  62
0ABBA:  MOVWF  FF6
0ABBC:  MOVLW  1B
0ABBE:  MOVWF  FF7
0ABC0:  MOVLW  00
0ABC2:  MOVWF  FF8
0ABC4:  CLRF   1B
0ABC6:  BTFSC  FF2.7
0ABC8:  BSF    1B.7
0ABCA:  BCF    FF2.7
0ABCC:  CALL   0E4E
0ABD0:  BTFSC  1B.7
0ABD2:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0ABD4:  MOVLW  01
0ABD6:  MOVWF  1E
0ABD8:  MOVLW  A7
0ABDA:  MOVWF  1D
0ABDC:  MOVLW  6A
0ABDE:  MOVWF  FF6
0ABE0:  MOVLW  1B
0ABE2:  MOVWF  FF7
0ABE4:  MOVLW  00
0ABE6:  MOVWF  FF8
0ABE8:  MOVLW  05
0ABEA:  MOVLB  8
0ABEC:  MOVWF  xCC
0ABEE:  MOVLB  0
0ABF0:  RCALL  AA28
0ABF2:  MOVLW  10
0ABF4:  MOVWF  FE9
0ABF6:  MOVFF  26,8D8
0ABFA:  MOVFF  25,8D7
0ABFE:  RCALL  AA5A
0AC00:  MOVLW  72
0AC02:  MOVWF  FF6
0AC04:  MOVLW  1B
0AC06:  MOVWF  FF7
0AC08:  MOVLW  00
0AC0A:  MOVWF  FF8
0AC0C:  MOVLW  20
0AC0E:  MOVLB  8
0AC10:  MOVWF  xCC
0AC12:  MOVLB  0
0AC14:  RCALL  AA28
....................          record_event(); 
0AC16:  CALL   8436
....................          break; 
0AC1A:  BRA    AD08
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0AC1C:  MOVLW  94
0AC1E:  MOVWF  FF6
0AC20:  MOVLW  1B
0AC22:  MOVWF  FF7
0AC24:  MOVLW  00
0AC26:  MOVWF  FF8
0AC28:  CLRF   1B
0AC2A:  BTFSC  FF2.7
0AC2C:  BSF    1B.7
0AC2E:  BCF    FF2.7
0AC30:  CALL   0E4E
0AC34:  BTFSC  1B.7
0AC36:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0AC38:  MOVLW  01
0AC3A:  MOVWF  1E
0AC3C:  MOVLW  A7
0AC3E:  MOVWF  1D
0AC40:  MOVLW  9C
0AC42:  MOVWF  FF6
0AC44:  MOVLW  1B
0AC46:  MOVWF  FF7
0AC48:  MOVLW  00
0AC4A:  MOVWF  FF8
0AC4C:  CALL   5052
....................          record_event(); 
0AC50:  CALL   8436
....................          break; 
0AC54:  BRA    AD08
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0AC56:  MOVLW  C0
0AC58:  MOVWF  FF6
0AC5A:  MOVLW  1B
0AC5C:  MOVWF  FF7
0AC5E:  MOVLW  00
0AC60:  MOVWF  FF8
0AC62:  CLRF   1B
0AC64:  BTFSC  FF2.7
0AC66:  BSF    1B.7
0AC68:  BCF    FF2.7
0AC6A:  CALL   0E4E
0AC6E:  BTFSC  1B.7
0AC70:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AC72:  MOVLW  01
0AC74:  MOVWF  1E
0AC76:  MOVLW  A7
0AC78:  MOVWF  1D
0AC7A:  MOVLW  C8
0AC7C:  MOVWF  FF6
0AC7E:  MOVLW  1B
0AC80:  MOVWF  FF7
0AC82:  MOVLW  00
0AC84:  MOVWF  FF8
0AC86:  CALL   5052
....................          record_event(); 
0AC8A:  CALL   8436
....................          recovery(); 
0AC8E:  RCALL  A9B4
....................          break; 
0AC90:  BRA    AD08
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AC92:  MOVLW  E4
0AC94:  MOVWF  FF6
0AC96:  MOVLW  1B
0AC98:  MOVWF  FF7
0AC9A:  MOVLW  00
0AC9C:  MOVWF  FF8
0AC9E:  CLRF   1B
0ACA0:  BTFSC  FF2.7
0ACA2:  BSF    1B.7
0ACA4:  BCF    FF2.7
0ACA6:  CALL   0E4E
0ACAA:  BTFSC  1B.7
0ACAC:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0ACAE:  MOVLW  01
0ACB0:  MOVWF  1E
0ACB2:  MOVLW  A7
0ACB4:  MOVWF  1D
0ACB6:  MOVLW  EC
0ACB8:  MOVWF  FF6
0ACBA:  MOVLW  1B
0ACBC:  MOVWF  FF7
0ACBE:  MOVLW  00
0ACC0:  MOVWF  FF8
0ACC2:  CALL   5052
....................          record_event(); 
0ACC6:  CALL   8436
....................          recovery(); 
0ACCA:  RCALL  A9B4
....................          break; 
0ACCC:  BRA    AD08
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0ACCE:  MOVLW  0E
0ACD0:  MOVWF  FF6
0ACD2:  MOVLW  1C
0ACD4:  MOVWF  FF7
0ACD6:  MOVLW  00
0ACD8:  MOVWF  FF8
0ACDA:  CLRF   1B
0ACDC:  BTFSC  FF2.7
0ACDE:  BSF    1B.7
0ACE0:  BCF    FF2.7
0ACE2:  CALL   0E4E
0ACE6:  BTFSC  1B.7
0ACE8:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0ACEA:  MOVLW  01
0ACEC:  MOVWF  1E
0ACEE:  MOVLW  A7
0ACF0:  MOVWF  1D
0ACF2:  MOVLW  16
0ACF4:  MOVWF  FF6
0ACF6:  MOVLW  1C
0ACF8:  MOVWF  FF7
0ACFA:  MOVLW  00
0ACFC:  MOVWF  FF8
0ACFE:  CALL   5052
....................          record_event(); 
0AD02:  CALL   8436
....................          recovery(); 
0AD06:  RCALL  A9B4
....................          break; 
....................       }         
....................    } 
0AD08:  GOTO   1B57E (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02A54:  MOVLW  1E
02A56:  MOVLB  8
02A58:  MOVWF  x78
02A5A:  MOVLB  0
02A5C:  RCALL  2966
02A5E:  MOVFF  02,30
02A62:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02A66:  MOVLW  1C
02A68:  MOVLB  8
02A6A:  MOVWF  x78
02A6C:  MOVLB  0
02A6E:  RCALL  2966
02A70:  MOVFF  02,20
02A74:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02A78:  MOVLW  16
02A7A:  MOVLB  8
02A7C:  MOVWF  x78
02A7E:  MOVLB  0
02A80:  RCALL  2966
02A82:  MOVFF  02,22
02A86:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02A8A:  MOVLW  14
02A8C:  MOVLB  8
02A8E:  MOVWF  x78
02A90:  MOVLB  0
02A92:  RCALL  2966
02A94:  MOVFF  02,24
02A98:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02A9C:  MOVLB  8
02A9E:  CLRF   x78
02AA0:  MOVLB  0
02AA2:  RCALL  2966
02AA4:  MOVFF  02,26
02AA8:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02AAC:  MOVLW  18
02AAE:  MOVLB  8
02AB0:  MOVWF  x78
02AB2:  MOVLB  0
02AB4:  RCALL  2966
02AB6:  MOVFF  02,28
02ABA:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02ABE:  MOVLW  02
02AC0:  MOVLB  8
02AC2:  MOVWF  x98
02AC4:  MOVLB  0
02AC6:  RCALL  29C0
02AC8:  CLRF   32
02ACA:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02ACE:  MOVLW  28
02AD0:  MOVLB  8
02AD2:  MOVWF  x98
02AD4:  MOVLB  0
02AD6:  RCALL  29C0
02AD8:  CLRF   34
02ADA:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02ADE:  MOVLW  12
02AE0:  MOVLB  8
02AE2:  MOVWF  x78
02AE4:  MOVLB  0
02AE6:  RCALL  2966
02AE8:  MOVFF  02,36
02AEC:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02AF0:  MOVLW  3A
02AF2:  MOVLB  8
02AF4:  MOVWF  x78
02AF6:  MOVLB  0
02AF8:  RCALL  2966
02AFA:  MOVFF  02,38
02AFE:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02B02:  MOVLW  3C
02B04:  MOVLB  8
02B06:  MOVWF  x78
02B08:  MOVLB  0
02B0A:  RCALL  2966
02B0C:  MOVFF  02,3E
02B10:  MOVFF  01,3D
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02B14:  MOVLW  3E
02B16:  MOVLB  8
02B18:  MOVWF  x78
02B1A:  MOVLB  0
02B1C:  RCALL  2966
02B1E:  MOVFF  02,40
02B22:  MOVFF  01,3F
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02B26:  MOVLW  40
02B28:  MOVLB  8
02B2A:  MOVWF  x78
02B2C:  MOVLB  0
02B2E:  RCALL  2966
02B30:  MOVFF  02,42
02B34:  MOVFF  01,41
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02B38:  MOVLW  42
02B3A:  MOVLB  8
02B3C:  MOVWF  x78
02B3E:  MOVLB  0
02B40:  RCALL  2966
02B42:  MOVFF  02,44
02B46:  MOVFF  01,43
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02B4A:  MOVLW  04
02B4C:  MOVLB  8
02B4E:  MOVWF  x98
02B50:  MOVLB  0
02B52:  RCALL  29C0
02B54:  MOVFF  01,72D
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02B58:  MOVLB  8
02B5A:  CLRF   x67
02B5C:  MOVLW  44
02B5E:  MOVWF  x66
02B60:  MOVLB  0
02B62:  RCALL  29E6
02B64:  MOVFF  03,3F8
02B68:  MOVFF  02,3F7
02B6C:  MOVFF  01,3F6
02B70:  MOVFF  00,3F5
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02B74:  MOVLB  8
02B76:  CLRF   x67
02B78:  MOVLW  48
02B7A:  MOVWF  x66
02B7C:  MOVLB  0
02B7E:  RCALL  29E6
02B80:  MOVFF  03,3FC
02B84:  MOVFF  02,3FB
02B88:  MOVFF  01,3FA
02B8C:  MOVFF  00,3F9
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02B90:  MOVLB  8
02B92:  CLRF   x67
02B94:  MOVLW  4C
02B96:  MOVWF  x66
02B98:  MOVLB  0
02B9A:  RCALL  29E6
02B9C:  MOVFF  03,400
02BA0:  MOVFF  02,3FF
02BA4:  MOVFF  01,3FE
02BA8:  MOVFF  00,3FD
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02BAC:  MOVLB  8
02BAE:  CLRF   x67
02BB0:  MOVLW  52
02BB2:  MOVWF  x66
02BB4:  MOVLB  0
02BB6:  RCALL  29E6
02BB8:  MOVFF  03,404
02BBC:  MOVFF  02,403
02BC0:  MOVFF  01,402
02BC4:  MOVFF  00,401
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02BC8:  MOVLB  8
02BCA:  CLRF   x67
02BCC:  MOVLW  56
02BCE:  MOVWF  x66
02BD0:  MOVLB  0
02BD2:  RCALL  29E6
02BD4:  MOVFF  03,408
02BD8:  MOVFF  02,407
02BDC:  MOVFF  01,406
02BE0:  MOVFF  00,405
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02BE4:  MOVLB  8
02BE6:  CLRF   x67
02BE8:  MOVLW  5A
02BEA:  MOVWF  x66
02BEC:  MOVLB  0
02BEE:  RCALL  29E6
02BF0:  MOVFF  03,40C
02BF4:  MOVFF  02,40B
02BF8:  MOVFF  01,40A
02BFC:  MOVFF  00,409
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02C00:  MOVLB  8
02C02:  CLRF   x67
02C04:  MOVLW  5E
02C06:  MOVWF  x66
02C08:  MOVLB  0
02C0A:  RCALL  29E6
02C0C:  MOVFF  03,410
02C10:  MOVFF  02,40F
02C14:  MOVFF  01,40E
02C18:  MOVFF  00,40D
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02C1C:  MOVLB  8
02C1E:  CLRF   x67
02C20:  MOVLW  62
02C22:  MOVWF  x66
02C24:  MOVLB  0
02C26:  RCALL  29E6
02C28:  MOVFF  03,414
02C2C:  MOVFF  02,413
02C30:  MOVFF  01,412
02C34:  MOVFF  00,411
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02C38:  MOVLW  20
02C3A:  MOVLB  8
02C3C:  MOVWF  x78
02C3E:  MOVLB  0
02C40:  RCALL  2966
02C42:  MOVFF  02,2A
02C46:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02C4A:  MOVLW  22
02C4C:  MOVLB  8
02C4E:  MOVWF  x78
02C50:  MOVLB  0
02C52:  RCALL  2966
02C54:  MOVFF  02,2C
02C58:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02C5C:  MOVLW  24
02C5E:  MOVLB  8
02C60:  MOVWF  x78
02C62:  MOVLB  0
02C64:  RCALL  2966
02C66:  MOVFF  02,2E
02C6A:  MOVFF  01,2D
02C6E:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DB1C:  MOVLW  1C
0DB1E:  MOVLB  8
0DB20:  MOVWF  xCF
0DB22:  CLRF   xD1
0DB24:  CLRF   xD0
0DB26:  MOVLB  0
0DB28:  CALL   4F68
....................    write16(ADDR_SAMPLE,0); 
0DB2C:  MOVLW  16
0DB2E:  MOVLB  8
0DB30:  MOVWF  xCF
0DB32:  CLRF   xD1
0DB34:  CLRF   xD0
0DB36:  MOVLB  0
0DB38:  CALL   4F68
....................    write16(ADDR_INTERVAL,60); 
0DB3C:  MOVLW  14
0DB3E:  MOVLB  8
0DB40:  MOVWF  xCF
0DB42:  CLRF   xD1
0DB44:  MOVLW  3C
0DB46:  MOVWF  xD0
0DB48:  MOVLB  0
0DB4A:  CALL   4F68
....................    write16(ADDR_SERIALNO,9999); 
0DB4E:  MOVLB  8
0DB50:  CLRF   xCF
0DB52:  MOVLW  27
0DB54:  MOVWF  xD1
0DB56:  MOVLW  0F
0DB58:  MOVWF  xD0
0DB5A:  MOVLB  0
0DB5C:  CALL   4F68
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DB60:  MOVLW  18
0DB62:  MOVLB  8
0DB64:  MOVWF  xCF
0DB66:  MOVLW  0D
0DB68:  MOVWF  xD1
0DB6A:  MOVLW  20
0DB6C:  MOVWF  xD0
0DB6E:  MOVLB  0
0DB70:  CALL   4F68
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DB74:  MOVLW  02
0DB76:  MOVLB  8
0DB78:  MOVWF  x6A
0DB7A:  MOVLW  01
0DB7C:  MOVWF  x6B
0DB7E:  MOVLB  0
0DB80:  CALL   33AE
....................    write16(ADDR_MACRO_STEP, 0); 
0DB84:  MOVLW  3A
0DB86:  MOVLB  8
0DB88:  MOVWF  xCF
0DB8A:  CLRF   xD1
0DB8C:  CLRF   xD0
0DB8E:  MOVLB  0
0DB90:  CALL   4F68
....................    write16(ADDR_COM_ERR,3); 
0DB94:  MOVLW  3C
0DB96:  MOVLB  8
0DB98:  MOVWF  xCF
0DB9A:  CLRF   xD1
0DB9C:  MOVLW  03
0DB9E:  MOVWF  xD0
0DBA0:  MOVLB  0
0DBA2:  CALL   4F68
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DBA6:  MOVLW  04
0DBA8:  MOVLB  8
0DBAA:  MOVWF  x6A
0DBAC:  MOVLW  0A
0DBAE:  MOVWF  x6B
0DBB0:  MOVLB  0
0DBB2:  CALL   33AE
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DBB6:  MOVLB  8
0DBB8:  CLRF   x67
0DBBA:  MOVLW  44
0DBBC:  MOVWF  x66
0DBBE:  CLRF   x6B
0DBC0:  CLRF   x6A
0DBC2:  CLRF   x69
0DBC4:  MOVLW  7F
0DBC6:  MOVWF  x68
0DBC8:  MOVLB  0
0DBCA:  CALL   C9BE
....................    write_float(ADDR_CAL_C1,0); 
0DBCE:  MOVLB  8
0DBD0:  CLRF   x67
0DBD2:  MOVLW  48
0DBD4:  MOVWF  x66
0DBD6:  CLRF   x6B
0DBD8:  CLRF   x6A
0DBDA:  CLRF   x69
0DBDC:  CLRF   x68
0DBDE:  MOVLB  0
0DBE0:  CALL   C9BE
....................    write_float(ADDR_CAL_M2,1); 
0DBE4:  MOVLB  8
0DBE6:  CLRF   x67
0DBE8:  MOVLW  4C
0DBEA:  MOVWF  x66
0DBEC:  CLRF   x6B
0DBEE:  CLRF   x6A
0DBF0:  CLRF   x69
0DBF2:  MOVLW  7F
0DBF4:  MOVWF  x68
0DBF6:  MOVLB  0
0DBF8:  CALL   C9BE
....................    write_float(ADDR_CAL_C2,0); 
0DBFC:  MOVLB  8
0DBFE:  CLRF   x67
0DC00:  MOVLW  52
0DC02:  MOVWF  x66
0DC04:  CLRF   x6B
0DC06:  CLRF   x6A
0DC08:  CLRF   x69
0DC0A:  CLRF   x68
0DC0C:  MOVLB  0
0DC0E:  CALL   C9BE
....................    write_float(ADDR_CAL_M3,1); 
0DC12:  MOVLB  8
0DC14:  CLRF   x67
0DC16:  MOVLW  56
0DC18:  MOVWF  x66
0DC1A:  CLRF   x6B
0DC1C:  CLRF   x6A
0DC1E:  CLRF   x69
0DC20:  MOVLW  7F
0DC22:  MOVWF  x68
0DC24:  MOVLB  0
0DC26:  CALL   C9BE
....................    write_float(ADDR_CAL_C3,0); 
0DC2A:  MOVLB  8
0DC2C:  CLRF   x67
0DC2E:  MOVLW  5A
0DC30:  MOVWF  x66
0DC32:  CLRF   x6B
0DC34:  CLRF   x6A
0DC36:  CLRF   x69
0DC38:  CLRF   x68
0DC3A:  MOVLB  0
0DC3C:  CALL   C9BE
....................    write_float(ADDR_CAL_M4,1); 
0DC40:  MOVLB  8
0DC42:  CLRF   x67
0DC44:  MOVLW  5E
0DC46:  MOVWF  x66
0DC48:  CLRF   x6B
0DC4A:  CLRF   x6A
0DC4C:  CLRF   x69
0DC4E:  MOVLW  7F
0DC50:  MOVWF  x68
0DC52:  MOVLB  0
0DC54:  CALL   C9BE
....................    write_float(ADDR_CAL_C4,0);  
0DC58:  MOVLB  8
0DC5A:  CLRF   x67
0DC5C:  MOVLW  62
0DC5E:  MOVWF  x66
0DC60:  CLRF   x6B
0DC62:  CLRF   x6A
0DC64:  CLRF   x69
0DC66:  CLRF   x68
0DC68:  MOVLB  0
0DC6A:  CALL   C9BE
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0DC6E:  MOVLW  40
0DC70:  MOVLB  8
0DC72:  MOVWF  xCF
0DC74:  MOVLW  4E
0DC76:  MOVWF  xD1
0DC78:  MOVLW  20
0DC7A:  MOVWF  xD0
0DC7C:  MOVLB  0
0DC7E:  CALL   4F68
....................    write16(ADDR_D2_TEMP,20000); 
0DC82:  MOVLW  42
0DC84:  MOVLB  8
0DC86:  MOVWF  xCF
0DC88:  MOVLW  4E
0DC8A:  MOVWF  xD1
0DC8C:  MOVLW  20
0DC8E:  MOVWF  xD0
0DC90:  MOVLB  0
0DC92:  CALL   4F68
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0DC96:  MOVLW  20
0DC98:  MOVLB  8
0DC9A:  MOVWF  xCF
0DC9C:  CLRF   xD1
0DC9E:  CLRF   xD0
0DCA0:  MOVLB  0
0DCA2:  CALL   4F68
....................    write16(ADDR_VOLUME,22500);  
0DCA6:  MOVLW  22
0DCA8:  MOVLB  8
0DCAA:  MOVWF  xCF
0DCAC:  MOVLW  57
0DCAE:  MOVWF  xD1
0DCB0:  MOVLW  E4
0DCB2:  MOVWF  xD0
0DCB4:  MOVLB  0
0DCB6:  CALL   4F68
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0DCBA:  MOVF   2F,W
0DCBC:  SUBLW  02
0DCBE:  BNZ   DCC4
0DCC0:  MOVF   30,F
0DCC2:  BZ    DCD8
0DCC4:  MOVLW  24
0DCC6:  MOVLB  8
0DCC8:  MOVWF  xCF
0DCCA:  CLRF   xD1
0DCCC:  MOVLW  02
0DCCE:  MOVWF  xD0
0DCD0:  MOVLB  0
0DCD2:  CALL   4F68
0DCD6:  BRA    DCEA
....................    else write16(ADDR_PORT,1); 
0DCD8:  MOVLW  24
0DCDA:  MOVLB  8
0DCDC:  MOVWF  xCF
0DCDE:  CLRF   xD1
0DCE0:  MOVLW  01
0DCE2:  MOVWF  xD0
0DCE4:  MOVLB  0
0DCE6:  CALL   4F68
....................     
....................    write16(ADDR_DET_TYPE,1); 
0DCEA:  MOVLW  26
0DCEC:  MOVLB  8
0DCEE:  MOVWF  xCF
0DCF0:  CLRF   xD1
0DCF2:  MOVLW  01
0DCF4:  MOVWF  xD0
0DCF6:  MOVLB  0
0DCF8:  CALL   4F68
....................     
....................    init_nv_vars(); 
0DCFC:  CALL   2A54
0DD00:  GOTO   DD1A (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
12440:  MOVLW  02
12442:  MOVWF  FEA
12444:  MOVLW  47
12446:  MOVWF  FE9
12448:  CLRF   00
1244A:  CLRF   02
1244C:  MOVLW  51
1244E:  MOVWF  01
12450:  CALL   34C2
12454:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F57E:  MOVLW  03
0F580:  MOVWF  FEA
0F582:  MOVLW  25
0F584:  MOVWF  FE9
0F586:  CLRF   00
0F588:  CLRF   02
0F58A:  MOVLW  14
0F58C:  MOVWF  01
0F58E:  CALL   34C2
0F592:  GOTO   F5B2 (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
12F76:  MOVLB  8
12F78:  CLRF   xB5
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
12F7A:  CLRF   FEA
12F7C:  MOVLW  52
12F7E:  MOVWF  FE9
12F80:  CLRF   00
12F82:  CLRF   02
12F84:  MOVLW  14
12F86:  MOVWF  01
12F88:  MOVLB  0
12F8A:  CALL   34C2
....................  
....................    for(n=0; n<20; n++) { 
12F8E:  MOVLB  8
12F90:  CLRF   xB6
12F92:  MOVF   xB6,W
12F94:  SUBLW  13
12F96:  BNC   12FDC
....................         c = data_buffer[string_pos];  
12F98:  CLRF   03
12F9A:  MOVLB  2
12F9C:  MOVF   x98,W
12F9E:  ADDLW  67
12FA0:  MOVWF  FE9
12FA2:  MOVLW  00
12FA4:  ADDWFC 03,W
12FA6:  MOVWF  FEA
12FA8:  MOVFF  FEF,8B5
....................         ++string_pos; 
12FAC:  INCF   x98,F
....................         if (c == '\0') return(1); // found end 
12FAE:  MOVLB  8
12FB0:  MOVF   xB5,F
12FB2:  BNZ   12FBA
12FB4:  MOVLW  01
12FB6:  MOVWF  01
12FB8:  BRA    12FE0
....................         if (c == ',')  return(0); // found seperator  
12FBA:  MOVF   xB5,W
12FBC:  SUBLW  2C
12FBE:  BNZ   12FC6
12FC0:  MOVLW  00
12FC2:  MOVWF  01
12FC4:  BRA    12FE0
....................         sub_string[n] = c; 
12FC6:  CLRF   03
12FC8:  MOVF   xB6,W
12FCA:  ADDLW  52
12FCC:  MOVWF  FE9
12FCE:  MOVLW  00
12FD0:  ADDWFC 03,W
12FD2:  MOVWF  FEA
12FD4:  MOVFF  8B5,FEF
12FD8:  INCF   xB6,F
12FDA:  BRA    12F92
....................    } 
....................     
....................    return(2); // failed = bad string 
12FDC:  MOVLW  02
12FDE:  MOVWF  01
12FE0:  MOVLB  0
12FE2:  GOTO   1330C (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
13220:  MOVLW  3A
13222:  MOVWF  FF6
13224:  MOVLW  1C
13226:  MOVWF  FF7
13228:  MOVLW  00
1322A:  MOVWF  FF8
1322C:  MOVLW  03
1322E:  MOVWF  FEA
13230:  MOVLW  3D
13232:  MOVWF  FE9
13234:  CALL   FAC4
13238:  MOVF   01,W
1323A:  BZ    1324E
1323C:  XORLW  01
1323E:  BZ    1326E
13240:  XORLW  03
13242:  BZ    1328E
13244:  XORLW  01
13246:  BZ    132AE
13248:  XORLW  07
1324A:  BZ    132CE
1324C:  BRA    132EC
....................       case "NO3" : NO3_array[read_i] = result; 
1324E:  BCF    FD8.0
13250:  MOVLB  3
13252:  RLCF   x4A,W
13254:  CLRF   03
13256:  ADDLW  4B
13258:  MOVWF  FE9
1325A:  MOVLW  03
1325C:  ADDWFC 03,W
1325E:  MOVWF  FEA
13260:  MOVFF  8B6,FEC
13264:  MOVF   FED,F
13266:  MOVFF  8B5,FEF
....................          break; 
1326A:  MOVLB  0
1326C:  BRA    132EC
....................       case "NO2" : NO2_array[read_i] = result; 
1326E:  BCF    FD8.0
13270:  MOVLB  3
13272:  RLCF   x4A,W
13274:  CLRF   03
13276:  ADDLW  5D
13278:  MOVWF  FE9
1327A:  MOVLW  03
1327C:  ADDWFC 03,W
1327E:  MOVWF  FEA
13280:  MOVFF  8B6,FEC
13284:  MOVF   FED,F
13286:  MOVFF  8B5,FEF
....................          break;    
1328A:  MOVLB  0
1328C:  BRA    132EC
....................       case "PO4" : PO4_array[read_i] = result; 
1328E:  BCF    FD8.0
13290:  MOVLB  3
13292:  RLCF   x4A,W
13294:  CLRF   03
13296:  ADDLW  6F
13298:  MOVWF  FE9
1329A:  MOVLW  03
1329C:  ADDWFC 03,W
1329E:  MOVWF  FEA
132A0:  MOVFF  8B6,FEC
132A4:  MOVF   FED,F
132A6:  MOVFF  8B5,FEF
....................          break; 
132AA:  MOVLB  0
132AC:  BRA    132EC
....................       case "NH4" : NH4_array[read_i] = result; 
132AE:  BCF    FD8.0
132B0:  MOVLB  3
132B2:  RLCF   x4A,W
132B4:  CLRF   03
132B6:  ADDLW  81
132B8:  MOVWF  FE9
132BA:  MOVLW  03
132BC:  ADDWFC 03,W
132BE:  MOVWF  FEA
132C0:  MOVFF  8B6,FEC
132C4:  MOVF   FED,F
132C6:  MOVFF  8B5,FEF
....................          break; 
132CA:  MOVLB  0
132CC:  BRA    132EC
....................       case "SiO" : SiO_array[read_i] = result; 
132CE:  BCF    FD8.0
132D0:  MOVLB  3
132D2:  RLCF   x4A,W
132D4:  CLRF   03
132D6:  ADDLW  93
132D8:  MOVWF  FE9
132DA:  MOVLW  03
132DC:  ADDWFC 03,W
132DE:  MOVWF  FEA
132E0:  MOVFF  8B6,FEC
132E4:  MOVF   FED,F
132E6:  MOVFF  8B5,FEF
....................          break; 
132EA:  MOVLB  0
....................    } 
132EC:  GOTO   13364 (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
132F0:  MOVLB  8
132F2:  CLRF   xB0
132F4:  CLRF   xAF
132F6:  CLRF   xB2
132F8:  CLRF   xB1
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
132FA:  MOVLB  2
132FC:  CLRF   x98
....................     
....................    for (n=0; n<11; ++n){ 
132FE:  MOVLB  8
13300:  CLRF   xB3
13302:  MOVF   xB3,W
13304:  SUBLW  0A
13306:  BNC   13358
....................       parsed = parse_string(); 
13308:  MOVLB  0
1330A:  BRA    12F76
1330C:  MOVFF  01,8B4
....................       if (parsed == 2) return(0); 
13310:  MOVLB  8
13312:  MOVF   xB4,W
13314:  SUBLW  02
13316:  BNZ   13320
13318:  MOVLW  00
1331A:  MOVWF  01
1331C:  MOVWF  02
1331E:  BRA    1336E
....................       if (n==8) result = atol(sub_string); 
13320:  MOVF   xB3,W
13322:  SUBLW  08
13324:  BNZ   1333A
13326:  CLRF   xB6
13328:  MOVLW  52
1332A:  MOVWF  xB5
1332C:  MOVLB  0
1332E:  RCALL  1303C
13330:  MOVFF  02,8B0
13334:  MOVFF  01,8AF
13338:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
1333A:  MOVF   xB3,W
1333C:  SUBLW  0A
1333E:  BNZ   13354
13340:  CLRF   xB6
13342:  MOVLW  52
13344:  MOVWF  xB5
13346:  MOVLB  0
13348:  RCALL  1303C
1334A:  MOVFF  02,8B2
1334E:  MOVFF  01,8B1
13352:  MOVLB  8
13354:  INCF   xB3,F
13356:  BRA    13302
....................    } 
....................    load_parsed_data(result); 
13358:  MOVFF  8B0,8B6
1335C:  MOVFF  8AF,8B5
13360:  MOVLB  0
13362:  BRA    13220
....................    return (temp); 
13364:  MOVLB  8
13366:  MOVFF  8B1,01
1336A:  MOVFF  8B2,02
1336E:  MOVLB  0
13370:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D198:  CLRF   FEA
0D19A:  MOVLW  67
0D19C:  MOVWF  FE9
0D19E:  CLRF   00
0D1A0:  CLRF   02
0D1A2:  MOVLW  A0
0D1A4:  MOVWF  01
0D1A6:  CALL   34C2
0D1AA:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F596:  MOVLW  03
0F598:  MOVWF  FEA
0F59A:  MOVLW  3D
0F59C:  MOVWF  FE9
0F59E:  MOVLW  00
0F5A0:  CALL   02E4
0F5A4:  TBLRD*-
0F5A6:  TBLRD*+
0F5A8:  MOVF   FF5,W
0F5AA:  MOVWF  FEE
0F5AC:  IORLW  00
0F5AE:  BNZ   F5A6
....................  
....................    clear_flag_str(); 
0F5B0:  BRA    F57E
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F5B2:  MOVLW  08
0F5B4:  MOVWF  1E
0F5B6:  MOVLW  CE
0F5B8:  MOVWF  1D
0F5BA:  MOVLW  10
0F5BC:  MOVWF  FE9
0F5BE:  MOVFF  324,8D8
0F5C2:  MOVFF  323,8D7
0F5C6:  CALL   AA5A
....................  
....................    if (macro_flag < 100) { 
0F5CA:  MOVLB  3
0F5CC:  MOVF   x24,F
0F5CE:  BNZ   F5E8
0F5D0:  MOVF   x23,W
0F5D2:  SUBLW  63
0F5D4:  BNC   F5E8
....................       temp_str[3] = '\0'; 
0F5D6:  MOVLB  8
0F5D8:  CLRF   xD1
....................       temp_str[2] = temp_str[1]; 
0F5DA:  MOVFF  8CF,8D0
....................       temp_str[1] = temp_str[0]; 
0F5DE:  MOVFF  8CE,8CF
....................       temp_str[0] = '0'; 
0F5E2:  MOVLW  30
0F5E4:  MOVWF  xCE
0F5E6:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F5E8:  MOVLB  8
0F5EA:  MOVF   xCE,W
0F5EC:  XORLW  30
0F5EE:  MOVLB  0
0F5F0:  BZ    F614
0F5F2:  XORLW  01
0F5F4:  BZ    F63A
0F5F6:  XORLW  03
0F5F8:  BZ    F660
0F5FA:  XORLW  01
0F5FC:  BZ    F686
0F5FE:  XORLW  07
0F600:  BZ    F6AC
0F602:  XORLW  01
0F604:  BZ    F6D2
0F606:  XORLW  03
0F608:  BTFSC  FD8.2
0F60A:  BRA    F6F8
0F60C:  XORLW  01
0F60E:  BTFSC  FD8.2
0F610:  BRA    F71E
0F612:  BRA    F746
....................       case '0' : strcopy(chem,"NO3"); 
0F614:  MOVLW  03
0F616:  MOVWF  FEA
0F618:  MOVLW  3D
0F61A:  MOVWF  FE9
0F61C:  MOVLW  00
0F61E:  CALL   02FC
0F622:  TBLRD*-
0F624:  TBLRD*+
0F626:  MOVF   FF5,W
0F628:  MOVWF  FEE
0F62A:  IORLW  00
0F62C:  BNZ   F624
....................                  wave_l=543; 
0F62E:  MOVLW  02
0F630:  MOVLB  8
0F632:  MOVWF  xCD
0F634:  MOVLW  1F
0F636:  MOVWF  xCC
....................          break; 
0F638:  BRA    F76A
....................       case '1' : strcopy(chem,"PO4"); 
0F63A:  MOVLW  03
0F63C:  MOVWF  FEA
0F63E:  MOVLW  3D
0F640:  MOVWF  FE9
0F642:  MOVLW  00
0F644:  CALL   0314
0F648:  TBLRD*-
0F64A:  TBLRD*+
0F64C:  MOVF   FF5,W
0F64E:  MOVWF  FEE
0F650:  IORLW  00
0F652:  BNZ   F64A
....................                  wave_l=880;       
0F654:  MOVLW  03
0F656:  MOVLB  8
0F658:  MOVWF  xCD
0F65A:  MOVLW  70
0F65C:  MOVWF  xCC
....................          break; 
0F65E:  BRA    F76A
....................       case '2' : strcopy(chem,"NH4"); 
0F660:  MOVLW  03
0F662:  MOVWF  FEA
0F664:  MOVLW  3D
0F666:  MOVWF  FE9
0F668:  MOVLW  00
0F66A:  CALL   032C
0F66E:  TBLRD*-
0F670:  TBLRD*+
0F672:  MOVF   FF5,W
0F674:  MOVWF  FEE
0F676:  IORLW  00
0F678:  BNZ   F670
....................                  wave_l=660;       
0F67A:  MOVLW  02
0F67C:  MOVLB  8
0F67E:  MOVWF  xCD
0F680:  MOVLW  94
0F682:  MOVWF  xCC
....................          break; 
0F684:  BRA    F76A
....................       case '3' : strcopy(chem,"SiO"); 
0F686:  MOVLW  03
0F688:  MOVWF  FEA
0F68A:  MOVLW  3D
0F68C:  MOVWF  FE9
0F68E:  MOVLW  00
0F690:  CALL   0344
0F694:  TBLRD*-
0F696:  TBLRD*+
0F698:  MOVF   FF5,W
0F69A:  MOVWF  FEE
0F69C:  IORLW  00
0F69E:  BNZ   F696
....................                  wave_l=810;       
0F6A0:  MOVLW  03
0F6A2:  MOVLB  8
0F6A4:  MOVWF  xCD
0F6A6:  MOVLW  2A
0F6A8:  MOVWF  xCC
....................          break; 
0F6AA:  BRA    F76A
....................       case '4' : strcopy(chem,"Ure"); 
0F6AC:  MOVLW  03
0F6AE:  MOVWF  FEA
0F6B0:  MOVLW  3D
0F6B2:  MOVWF  FE9
0F6B4:  MOVLW  00
0F6B6:  CALL   035C
0F6BA:  TBLRD*-
0F6BC:  TBLRD*+
0F6BE:  MOVF   FF5,W
0F6C0:  MOVWF  FEE
0F6C2:  IORLW  00
0F6C4:  BNZ   F6BC
....................                  wave_l=525;       
0F6C6:  MOVLW  02
0F6C8:  MOVLB  8
0F6CA:  MOVWF  xCD
0F6CC:  MOVLW  0D
0F6CE:  MOVWF  xCC
....................          break; 
0F6D0:  BRA    F76A
....................       case '5' : strcopy(chem,"NO2"); 
0F6D2:  MOVLW  03
0F6D4:  MOVWF  FEA
0F6D6:  MOVLW  3D
0F6D8:  MOVWF  FE9
0F6DA:  MOVLW  00
0F6DC:  CALL   0374
0F6E0:  TBLRD*-
0F6E2:  TBLRD*+
0F6E4:  MOVF   FF5,W
0F6E6:  MOVWF  FEE
0F6E8:  IORLW  00
0F6EA:  BNZ   F6E2
....................                  wave_l=543;       
0F6EC:  MOVLW  02
0F6EE:  MOVLB  8
0F6F0:  MOVWF  xCD
0F6F2:  MOVLW  1F
0F6F4:  MOVWF  xCC
....................          break; 
0F6F6:  BRA    F76A
....................       case '6' : strcopy(chem,"Fe_"); 
0F6F8:  MOVLW  03
0F6FA:  MOVWF  FEA
0F6FC:  MOVLW  3D
0F6FE:  MOVWF  FE9
0F700:  MOVLW  00
0F702:  CALL   038C
0F706:  TBLRD*-
0F708:  TBLRD*+
0F70A:  MOVF   FF5,W
0F70C:  MOVWF  FEE
0F70E:  IORLW  00
0F710:  BNZ   F708
....................                  wave_l=543;       
0F712:  MOVLW  02
0F714:  MOVLB  8
0F716:  MOVWF  xCD
0F718:  MOVLW  1F
0F71A:  MOVWF  xCC
....................          break; 
0F71C:  BRA    F76A
....................       case '7' : strcopy(chem,"Cl_"); 
0F71E:  MOVLW  03
0F720:  MOVWF  FEA
0F722:  MOVLW  3D
0F724:  MOVWF  FE9
0F726:  MOVLW  00
0F728:  CALL   03A4
0F72C:  TBLRD*-
0F72E:  TBLRD*+
0F730:  MOVF   FF5,W
0F732:  MOVWF  FEE
0F734:  IORLW  00
0F736:  BNZ   F72E
....................                  wave_l=560;       
0F738:  MOVLW  02
0F73A:  MOVLB  8
0F73C:  MOVWF  xCD
0F73E:  MOVLW  30
0F740:  MOVWF  xCC
....................          break; 
0F742:  BRA    F76A
0F744:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0F746:  MOVLW  03
0F748:  MOVWF  FEA
0F74A:  MOVLW  3D
0F74C:  MOVWF  FE9
0F74E:  MOVLW  00
0F750:  CALL   02E4
0F754:  TBLRD*-
0F756:  TBLRD*+
0F758:  MOVF   FF5,W
0F75A:  MOVWF  FEE
0F75C:  IORLW  00
0F75E:  BNZ   F756
....................                  wave_l=999;       
0F760:  MOVLW  03
0F762:  MOVLB  8
0F764:  MOVWF  xCD
0F766:  MOVLW  E7
0F768:  MOVWF  xCC
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0F76A:  MOVF   xCF,W
0F76C:  XORLW  31
0F76E:  MOVLB  0
0F770:  BZ    F790
0F772:  XORLW  03
0F774:  BZ    F7AC
0F776:  XORLW  01
0F778:  BZ    F7C8
0F77A:  XORLW  07
0F77C:  BZ    F7E4
0F77E:  XORLW  01
0F780:  BZ    F800
0F782:  XORLW  03
0F784:  BZ    F81C
0F786:  XORLW  01
0F788:  BZ    F838
0F78A:  XORLW  0F
0F78C:  BZ    F854
0F78E:  BRA    F870
....................       case '1' : strcopy(anal,"Smp"); 
0F790:  MOVLW  03
0F792:  MOVWF  FEA
0F794:  MOVLW  42
0F796:  MOVWF  FE9
0F798:  MOVLW  00
0F79A:  CALL   03BC
0F79E:  TBLRD*-
0F7A0:  TBLRD*+
0F7A2:  MOVF   FF5,W
0F7A4:  MOVWF  FEE
0F7A6:  IORLW  00
0F7A8:  BNZ   F7A0
....................          break; 
0F7AA:  BRA    F88A
....................       case '2' : strcopy(anal,"Std"); 
0F7AC:  MOVLW  03
0F7AE:  MOVWF  FEA
0F7B0:  MOVLW  42
0F7B2:  MOVWF  FE9
0F7B4:  MOVLW  00
0F7B6:  CALL   03D4
0F7BA:  TBLRD*-
0F7BC:  TBLRD*+
0F7BE:  MOVF   FF5,W
0F7C0:  MOVWF  FEE
0F7C2:  IORLW  00
0F7C4:  BNZ   F7BC
....................          break; 
0F7C6:  BRA    F88A
....................       case '3' : strcopy(anal,"Cmb"); 
0F7C8:  MOVLW  03
0F7CA:  MOVWF  FEA
0F7CC:  MOVLW  42
0F7CE:  MOVWF  FE9
0F7D0:  MOVLW  00
0F7D2:  CALL   03EC
0F7D6:  TBLRD*-
0F7D8:  TBLRD*+
0F7DA:  MOVF   FF5,W
0F7DC:  MOVWF  FEE
0F7DE:  IORLW  00
0F7E0:  BNZ   F7D8
....................          break; 
0F7E2:  BRA    F88A
....................       case '4' : strcopy(anal,"Tst"); 
0F7E4:  MOVLW  03
0F7E6:  MOVWF  FEA
0F7E8:  MOVLW  42
0F7EA:  MOVWF  FE9
0F7EC:  MOVLW  00
0F7EE:  CALL   0404
0F7F2:  TBLRD*-
0F7F4:  TBLRD*+
0F7F6:  MOVF   FF5,W
0F7F8:  MOVWF  FEE
0F7FA:  IORLW  00
0F7FC:  BNZ   F7F4
....................          break; 
0F7FE:  BRA    F88A
....................       case '5' : strcopy(anal,"Rbl"); 
0F800:  MOVLW  03
0F802:  MOVWF  FEA
0F804:  MOVLW  42
0F806:  MOVWF  FE9
0F808:  MOVLW  00
0F80A:  CALL   041C
0F80E:  TBLRD*-
0F810:  TBLRD*+
0F812:  MOVF   FF5,W
0F814:  MOVWF  FEE
0F816:  IORLW  00
0F818:  BNZ   F810
....................          break; 
0F81A:  BRA    F88A
....................       case '6' : strcopy(anal,"Cal"); 
0F81C:  MOVLW  03
0F81E:  MOVWF  FEA
0F820:  MOVLW  42
0F822:  MOVWF  FE9
0F824:  MOVLW  00
0F826:  CALL   0434
0F82A:  TBLRD*-
0F82C:  TBLRD*+
0F82E:  MOVF   FF5,W
0F830:  MOVWF  FEE
0F832:  IORLW  00
0F834:  BNZ   F82C
....................          break; 
0F836:  BRA    F88A
....................       case '7' : strcopy(anal,"Fls"); 
0F838:  MOVLW  03
0F83A:  MOVWF  FEA
0F83C:  MOVLW  42
0F83E:  MOVWF  FE9
0F840:  MOVLW  00
0F842:  CALL   044C
0F846:  TBLRD*-
0F848:  TBLRD*+
0F84A:  MOVF   FF5,W
0F84C:  MOVWF  FEE
0F84E:  IORLW  00
0F850:  BNZ   F848
....................          break; 
0F852:  BRA    F88A
....................       case '8' : strcopy(anal,"Utl"); 
0F854:  MOVLW  03
0F856:  MOVWF  FEA
0F858:  MOVLW  42
0F85A:  MOVWF  FE9
0F85C:  MOVLW  00
0F85E:  CALL   0464
0F862:  TBLRD*-
0F864:  TBLRD*+
0F866:  MOVF   FF5,W
0F868:  MOVWF  FEE
0F86A:  IORLW  00
0F86C:  BNZ   F864
....................          break;     
0F86E:  BRA    F88A
....................       default  : strcopy(anal,"XXX"); 
0F870:  MOVLW  03
0F872:  MOVWF  FEA
0F874:  MOVLW  42
0F876:  MOVWF  FE9
0F878:  MOVLW  00
0F87A:  CALL   02E4
0F87E:  TBLRD*-
0F880:  TBLRD*+
0F882:  MOVF   FF5,W
0F884:  MOVWF  FEE
0F886:  IORLW  00
0F888:  BNZ   F880
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0F88A:  MOVLB  8
0F88C:  MOVF   xD0,W
0F88E:  XORLW  31
0F890:  MOVLB  0
0F892:  BZ    F8BC
0F894:  XORLW  03
0F896:  BZ    F8DC
0F898:  XORLW  01
0F89A:  BZ    F8FE
0F89C:  XORLW  07
0F89E:  BZ    F920
0F8A0:  XORLW  01
0F8A2:  BZ    F942
0F8A4:  XORLW  03
0F8A6:  BZ    F964
0F8A8:  XORLW  01
0F8AA:  BTFSC  FD8.2
0F8AC:  BRA    F986
0F8AE:  XORLW  0F
0F8B0:  BTFSC  FD8.2
0F8B2:  BRA    F9A8
0F8B4:  XORLW  01
0F8B6:  BTFSC  FD8.2
0F8B8:  BRA    F9CA
0F8BA:  BRA    F9EE
....................       case '1' : strcopy(read_t,"I0s"); 
0F8BC:  MOVLW  03
0F8BE:  MOVWF  FEA
0F8C0:  MOVLW  46
0F8C2:  MOVWF  FE9
0F8C4:  MOVLW  00
0F8C6:  CALL   047C
0F8CA:  TBLRD*-
0F8CC:  TBLRD*+
0F8CE:  MOVF   FF5,W
0F8D0:  MOVWF  FEE
0F8D2:  IORLW  00
0F8D4:  BNZ   F8CC
....................                  read_i = 0; 
0F8D6:  MOVLB  3
0F8D8:  CLRF   x4A
....................          break; 
0F8DA:  BRA    FA0C
....................       case '2' : strcopy(read_t,"I1s"); 
0F8DC:  MOVLW  03
0F8DE:  MOVWF  FEA
0F8E0:  MOVLW  46
0F8E2:  MOVWF  FE9
0F8E4:  MOVLW  00
0F8E6:  CALL   0494
0F8EA:  TBLRD*-
0F8EC:  TBLRD*+
0F8EE:  MOVF   FF5,W
0F8F0:  MOVWF  FEE
0F8F2:  IORLW  00
0F8F4:  BNZ   F8EC
....................                  read_i = 1;       
0F8F6:  MOVLW  01
0F8F8:  MOVLB  3
0F8FA:  MOVWF  x4A
....................          break; 
0F8FC:  BRA    FA0C
....................       case '3' : strcopy(read_t,"I0t"); 
0F8FE:  MOVLW  03
0F900:  MOVWF  FEA
0F902:  MOVLW  46
0F904:  MOVWF  FE9
0F906:  MOVLW  00
0F908:  CALL   04AC
0F90C:  TBLRD*-
0F90E:  TBLRD*+
0F910:  MOVF   FF5,W
0F912:  MOVWF  FEE
0F914:  IORLW  00
0F916:  BNZ   F90E
....................                  read_i = 2;       
0F918:  MOVLW  02
0F91A:  MOVLB  3
0F91C:  MOVWF  x4A
....................          break; 
0F91E:  BRA    FA0C
....................       case '4' : strcopy(read_t,"I1t"); 
0F920:  MOVLW  03
0F922:  MOVWF  FEA
0F924:  MOVLW  46
0F926:  MOVWF  FE9
0F928:  MOVLW  00
0F92A:  CALL   04C4
0F92E:  TBLRD*-
0F930:  TBLRD*+
0F932:  MOVF   FF5,W
0F934:  MOVWF  FEE
0F936:  IORLW  00
0F938:  BNZ   F930
....................                  read_i = 3;       
0F93A:  MOVLW  03
0F93C:  MOVLB  3
0F93E:  MOVWF  x4A
....................          break; 
0F940:  BRA    FA0C
....................       case '5' : strcopy(read_t,"I0r"); 
0F942:  MOVLW  03
0F944:  MOVWF  FEA
0F946:  MOVLW  46
0F948:  MOVWF  FE9
0F94A:  MOVLW  00
0F94C:  CALL   04DC
0F950:  TBLRD*-
0F952:  TBLRD*+
0F954:  MOVF   FF5,W
0F956:  MOVWF  FEE
0F958:  IORLW  00
0F95A:  BNZ   F952
....................                  read_i = 4;       
0F95C:  MOVLW  04
0F95E:  MOVLB  3
0F960:  MOVWF  x4A
....................          break; 
0F962:  BRA    FA0C
....................       case '6' : strcopy(read_t,"I1r"); 
0F964:  MOVLW  03
0F966:  MOVWF  FEA
0F968:  MOVLW  46
0F96A:  MOVWF  FE9
0F96C:  MOVLW  00
0F96E:  CALL   04F4
0F972:  TBLRD*-
0F974:  TBLRD*+
0F976:  MOVF   FF5,W
0F978:  MOVWF  FEE
0F97A:  IORLW  00
0F97C:  BNZ   F974
....................                  read_i = 5;       
0F97E:  MOVLW  05
0F980:  MOVLB  3
0F982:  MOVWF  x4A
....................          break; 
0F984:  BRA    FA0C
....................       case '7' : strcopy(read_t,"I0u"); 
0F986:  MOVLW  03
0F988:  MOVWF  FEA
0F98A:  MOVLW  46
0F98C:  MOVWF  FE9
0F98E:  MOVLW  00
0F990:  CALL   050C
0F994:  TBLRD*-
0F996:  TBLRD*+
0F998:  MOVF   FF5,W
0F99A:  MOVWF  FEE
0F99C:  IORLW  00
0F99E:  BNZ   F996
....................                  read_i = 6;       
0F9A0:  MOVLW  06
0F9A2:  MOVLB  3
0F9A4:  MOVWF  x4A
....................          break; 
0F9A6:  BRA    FA0C
....................       case '8' : strcopy(read_t,"I1u"); 
0F9A8:  MOVLW  03
0F9AA:  MOVWF  FEA
0F9AC:  MOVLW  46
0F9AE:  MOVWF  FE9
0F9B0:  MOVLW  00
0F9B2:  CALL   0524
0F9B6:  TBLRD*-
0F9B8:  TBLRD*+
0F9BA:  MOVF   FF5,W
0F9BC:  MOVWF  FEE
0F9BE:  IORLW  00
0F9C0:  BNZ   F9B8
....................                  read_i = 7;       
0F9C2:  MOVLW  07
0F9C4:  MOVLB  3
0F9C6:  MOVWF  x4A
....................          break; 
0F9C8:  BRA    FA0C
....................       case '9' : strcopy(read_t,"Chk"); 
0F9CA:  MOVLW  03
0F9CC:  MOVWF  FEA
0F9CE:  MOVLW  46
0F9D0:  MOVWF  FE9
0F9D2:  MOVLW  00
0F9D4:  CALL   053C
0F9D8:  TBLRD*-
0F9DA:  TBLRD*+
0F9DC:  MOVF   FF5,W
0F9DE:  MOVWF  FEE
0F9E0:  IORLW  00
0F9E2:  BNZ   F9DA
....................                  read_i = 8;       
0F9E4:  MOVLW  08
0F9E6:  MOVLB  3
0F9E8:  MOVWF  x4A
....................          break;        
0F9EA:  BRA    FA0C
0F9EC:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0F9EE:  MOVLW  03
0F9F0:  MOVWF  FEA
0F9F2:  MOVLW  46
0F9F4:  MOVWF  FE9
0F9F6:  MOVLW  00
0F9F8:  CALL   0554
0F9FC:  TBLRD*-
0F9FE:  TBLRD*+
0FA00:  MOVF   FF5,W
0FA02:  MOVWF  FEE
0FA04:  IORLW  00
0FA06:  BNZ   F9FE
....................                  read_i = 0;       
0FA08:  MOVLB  3
0FA0A:  CLRF   x4A
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FA0C:  MOVLW  03
0FA0E:  MOVLB  8
0FA10:  MOVWF  xDA
0FA12:  MOVLW  25
0FA14:  MOVWF  xD9
0FA16:  MOVLW  03
0FA18:  MOVWF  xDC
0FA1A:  MOVLW  3D
0FA1C:  MOVWF  xDB
0FA1E:  MOVLB  0
0FA20:  CALL   5472
....................    strcat(flag_str, (char *)","); 
0FA24:  MOVLW  2C
0FA26:  MOVLB  8
0FA28:  MOVWF  xD5
0FA2A:  CLRF   xD6
0FA2C:  MOVLW  03
0FA2E:  MOVWF  xDA
0FA30:  MOVLW  25
0FA32:  MOVWF  xD9
0FA34:  MOVLW  08
0FA36:  MOVWF  xDC
0FA38:  MOVLW  D5
0FA3A:  MOVWF  xDB
0FA3C:  MOVLB  0
0FA3E:  CALL   5472
....................    strcat(flag_str, anal); 
0FA42:  MOVLW  03
0FA44:  MOVLB  8
0FA46:  MOVWF  xDA
0FA48:  MOVLW  25
0FA4A:  MOVWF  xD9
0FA4C:  MOVLW  03
0FA4E:  MOVWF  xDC
0FA50:  MOVLW  42
0FA52:  MOVWF  xDB
0FA54:  MOVLB  0
0FA56:  CALL   5472
....................    strcat(flag_str, (char *)","); 
0FA5A:  MOVLW  2C
0FA5C:  MOVLB  8
0FA5E:  MOVWF  xD5
0FA60:  CLRF   xD6
0FA62:  MOVLW  03
0FA64:  MOVWF  xDA
0FA66:  MOVLW  25
0FA68:  MOVWF  xD9
0FA6A:  MOVLW  08
0FA6C:  MOVWF  xDC
0FA6E:  MOVLW  D5
0FA70:  MOVWF  xDB
0FA72:  MOVLB  0
0FA74:  CALL   5472
....................    strcat(flag_str, read_t);   
0FA78:  MOVLW  03
0FA7A:  MOVLB  8
0FA7C:  MOVWF  xDA
0FA7E:  MOVLW  25
0FA80:  MOVWF  xD9
0FA82:  MOVLW  03
0FA84:  MOVWF  xDC
0FA86:  MOVLW  46
0FA88:  MOVWF  xDB
0FA8A:  MOVLB  0
0FA8C:  CALL   5472
....................     
....................    return wave_l; 
0FA90:  MOVLB  8
0FA92:  MOVFF  8CC,01
0FA96:  MOVFF  8CD,02
0FA9A:  MOVLB  0
0FA9C:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F072:  MOVF   47,W
0F074:  SUBLW  4B
0F076:  BTFSC  FD8.2
0F078:  MOVFF  48,2D6
....................    if (cmd=='L') detector_li = arg; 
0F07C:  MOVF   47,W
0F07E:  SUBLW  4C
0F080:  BNZ   F08A
0F082:  MOVFF  49,2D8
0F086:  MOVFF  48,2D7
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F08A:  MOVF   1F,W
0F08C:  SUBLW  04
0F08E:  BNZ   F158
0F090:  MOVF   20,F
0F092:  BNZ   F158
0F094:  MOVLW  50
0F096:  MOVWF  FF6
0F098:  MOVLW  1C
0F09A:  MOVWF  FF7
0F09C:  MOVLW  00
0F09E:  MOVWF  FF8
0F0A0:  CLRF   1B
0F0A2:  BTFSC  FF2.7
0F0A4:  BSF    1B.7
0F0A6:  BCF    FF2.7
0F0A8:  MOVLW  06
0F0AA:  MOVLB  A
0F0AC:  MOVWF  x1C
0F0AE:  MOVLB  0
0F0B0:  CALL   1024
0F0B4:  BTFSC  1B.7
0F0B6:  BSF    FF2.7
0F0B8:  CLRF   1B
0F0BA:  BTFSC  FF2.7
0F0BC:  BSF    1B.7
0F0BE:  BCF    FF2.7
0F0C0:  MOVFF  2D5,A1C
0F0C4:  MOVLW  1B
0F0C6:  MOVLB  A
0F0C8:  MOVWF  x1D
0F0CA:  MOVLB  0
0F0CC:  CALL   0FA6
0F0D0:  BTFSC  1B.7
0F0D2:  BSF    FF2.7
0F0D4:  MOVLW  5D
0F0D6:  BTFSS  F9E.4
0F0D8:  BRA    F0D6
0F0DA:  MOVWF  FAD
0F0DC:  MOVLW  5B
0F0DE:  BTFSS  F9E.4
0F0E0:  BRA    F0DE
0F0E2:  MOVWF  FAD
0F0E4:  MOVF   47,W
0F0E6:  BTFSS  F9E.4
0F0E8:  BRA    F0E6
0F0EA:  MOVWF  FAD
0F0EC:  MOVLW  5C
0F0EE:  MOVWF  FF6
0F0F0:  MOVLW  1C
0F0F2:  MOVWF  FF7
0F0F4:  MOVLW  00
0F0F6:  MOVWF  FF8
0F0F8:  CLRF   1B
0F0FA:  BTFSC  FF2.7
0F0FC:  BSF    1B.7
0F0FE:  BCF    FF2.7
0F100:  MOVLW  05
0F102:  MOVLB  A
0F104:  MOVWF  x1C
0F106:  MOVLB  0
0F108:  CALL   1024
0F10C:  BTFSC  1B.7
0F10E:  BSF    FF2.7
0F110:  MOVLW  41
0F112:  MOVWF  FE9
0F114:  CLRF   1B
0F116:  BTFSC  FF2.7
0F118:  BSF    1B.7
0F11A:  BCF    FF2.7
0F11C:  MOVFF  4B,A1F
0F120:  MOVFF  4A,A1E
0F124:  MOVFF  49,A1D
0F128:  MOVFF  48,A1C
0F12C:  CALL   10EA
0F130:  BTFSC  1B.7
0F132:  BSF    FF2.7
0F134:  MOVLW  64
0F136:  MOVWF  FF6
0F138:  MOVLW  1C
0F13A:  MOVWF  FF7
0F13C:  MOVLW  00
0F13E:  MOVWF  FF8
0F140:  CLRF   1B
0F142:  BTFSC  FF2.7
0F144:  BSF    1B.7
0F146:  BCF    FF2.7
0F148:  MOVLW  03
0F14A:  MOVLB  A
0F14C:  MOVWF  x1C
0F14E:  MOVLB  0
0F150:  CALL   1024
0F154:  BTFSC  1B.7
0F156:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F158:  CALL   D6E8
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F15C:  MOVLW  2F
0F15E:  BTFSS  FA4.4
0F160:  BRA    F15E
0F162:  MOVLB  F
0F164:  MOVWF  x1C
0F166:  MOVFF  2D5,8D4
0F16A:  MOVLW  1B
0F16C:  MOVLB  8
0F16E:  MOVWF  xD5
0F170:  MOVLB  0
0F172:  CALL   D730
0F176:  MOVF   47,W
0F178:  BTFSS  FA4.4
0F17A:  BRA    F178
0F17C:  MOVLB  F
0F17E:  MOVWF  x1C
0F180:  MOVLW  41
0F182:  MOVWF  FE9
0F184:  MOVFF  4B,8D7
0F188:  MOVFF  4A,8D6
0F18C:  MOVFF  49,8D5
0F190:  MOVFF  48,8D4
0F194:  MOVLB  0
0F196:  BRA    EF92
0F198:  MOVLW  0D
0F19A:  BTFSS  FA4.4
0F19C:  BRA    F19A
0F19E:  MOVLB  F
0F1A0:  MOVWF  x1C
0F1A2:  MOVLW  0A
0F1A4:  BTFSS  FA4.4
0F1A6:  BRA    F1A4
0F1A8:  MOVWF  x1C
....................    multidrop_off(); 
0F1AA:  MOVLB  0
0F1AC:  CALL   D7D4
0F1B0:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12A96:  MOVLB  8
12A98:  CLRF   xCD
12A9A:  BCF    xCE.0
12A9C:  CLRF   xCF
12A9E:  CLRF   xD3
12AA0:  CLRF   xD2
12AA2:  CLRF   xD1
12AA4:  CLRF   xD0
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12AA6:  MOVLW  02
12AA8:  MOVWF  FEA
12AAA:  MOVLW  47
12AAC:  MOVWF  FE9
12AAE:  CLRF   00
12AB0:  CLRF   02
12AB2:  MOVLW  51
12AB4:  MOVWF  01
12AB6:  MOVLB  0
12AB8:  CALL   34C2
....................  
....................    det_cmd(); 
12ABC:  CALL   F072
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12AC0:  CALL   54E4
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12AC4:  MOVLB  8
12AC6:  MOVF   xCF,W
12AC8:  SUBLW  02
12ACA:  BZ    12B5E
12ACC:  MOVF   xCF,W
12ACE:  SUBLW  03
12AD0:  BZ    12B5E
12AD2:  MOVF   xCD,W
12AD4:  SUBLW  50
12AD6:  BNC   12B5E
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12AD8:  BTFSS  FA4.5
12ADA:  BRA    12B12
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12ADC:  MOVLB  0
12ADE:  RCALL  12A7C
12AE0:  MOVFF  01,8CC
....................  
....................          if(startCharacterRcvd) 
12AE4:  MOVLB  8
12AE6:  BTFSS  xCE.0
12AE8:  BRA    12B0A
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12AEA:  MOVF   xCD,W
12AEC:  INCF   xCD,F
12AEE:  CLRF   03
12AF0:  ADDLW  47
12AF2:  MOVWF  FE9
12AF4:  MOVLW  02
12AF6:  ADDWFC 03,W
12AF8:  MOVWF  FEA
12AFA:  MOVFF  8CC,FEF
....................             if (CARRIAGE_RET == c) 
12AFE:  MOVF   xCC,W
12B00:  SUBLW  0D
12B02:  BNZ   12B08
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12B04:  MOVLW  02
12B06:  MOVWF  xCF
....................             } 
....................          } 
12B08:  BRA    12B12
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12B0A:  MOVF   xCC,W
12B0C:  SUBLW  40
12B0E:  BNZ   12B12
....................             { 
....................                startCharacterRcvd = TRUE; 
12B10:  BSF    xCE.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12B12:  MOVLW  35
12B14:  MOVWF  00
12B16:  DECFSZ 00,F
12B18:  BRA    12B16
....................       if (tenMicroSecDelayCounter++ > 500000) 
12B1A:  MOVFF  8D3,8D7
12B1E:  MOVFF  8D2,8D6
12B22:  MOVFF  8D1,8D5
12B26:  MOVFF  8D0,8D4
12B2A:  MOVLW  01
12B2C:  ADDWF  xD0,F
12B2E:  BTFSC  FD8.0
12B30:  INCF   xD1,F
12B32:  BTFSC  FD8.2
12B34:  INCF   xD2,F
12B36:  BTFSC  FD8.2
12B38:  INCF   xD3,F
12B3A:  MOVF   xD7,F
12B3C:  BNZ   12B58
12B3E:  MOVF   xD6,W
12B40:  SUBLW  06
12B42:  BC    12B5C
12B44:  XORLW  FF
12B46:  BNZ   12B58
12B48:  MOVF   xD5,W
12B4A:  SUBLW  A0
12B4C:  BC    12B5C
12B4E:  XORLW  FF
12B50:  BNZ   12B58
12B52:  MOVF   xD4,W
12B54:  SUBLW  20
12B56:  BC    12B5C
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12B58:  MOVLW  03
12B5A:  MOVWF  xCF
....................       } 
12B5C:  BRA    12AC6
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12B5E:  MOVF   xCD,W
12B60:  SUBLW  50
12B62:  BC    12B74
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12B64:  MOVF   xCF,W
12B66:  SUBLW  03
12B68:  BZ    12B74
12B6A:  MOVF   xCF,W
12B6C:  SUBLW  02
12B6E:  BZ    12B74
....................       { 
....................          rcvDataType = SOME_DATA; 
12B70:  MOVLW  01
12B72:  MOVWF  xCF
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12B74:  MOVLB  0
12B76:  CALL   5504
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12B7A:  MOVLB  8
12B7C:  MOVFF  8CF,01
12B80:  MOVLB  0
12B82:  GOTO   12CFA (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
0FBCC:  MOVF   1F,F
0FBCE:  BNZ   FBEE
0FBD0:  MOVF   20,F
0FBD2:  BNZ   FBEE
0FBD4:  MOVLB  8
0FBD6:  DECFSZ xCD,W
0FBD8:  BRA    FBDC
0FBDA:  BRA    FBE0
0FBDC:  MOVLB  0
0FBDE:  BRA    FBEE
0FBE0:  CLRF   FEA
0FBE2:  MOVLW  67
0FBE4:  MOVWF  FE9
0FBE6:  MOVLB  0
0FBE8:  CALL   78F8
0FBEC:  BRA    FC02
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
0FBEE:  MOVF   20,F
0FBF0:  BNZ   FBF8
0FBF2:  MOVF   1F,W
0FBF4:  SUBLW  03
0FBF6:  BC    FC02
0FBF8:  CLRF   FEA
0FBFA:  MOVLW  67
0FBFC:  MOVWF  FE9
0FBFE:  CALL   78F8
....................  
....................    if (store==TRUE && sd_status==0) { 
0FC02:  MOVLB  8
0FC04:  DECFSZ xCC,W
0FC06:  BRA    FC66
0FC08:  MOVLB  2
0FC0A:  MOVF   xDC,F
0FC0C:  BTFSC  FD8.2
0FC0E:  BRA    FC14
0FC10:  MOVLB  8
0FC12:  BRA    FC66
....................        
....................       buffer_select = 0; 
0FC14:  MOVLB  0
0FC16:  CLRF   x66
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FC18:  MOVLB  8
0FC1A:  CLRF   xCE
0FC1C:  MOVLB  0
0FC1E:  CALL   5516
....................          append_data(file_ptr_raw_all); 
0FC22:  MOVLW  02
0FC24:  MOVLB  8
0FC26:  MOVWF  xCF
0FC28:  MOVLW  DD
0FC2A:  MOVWF  xCE
0FC2C:  MOVLB  0
0FC2E:  CALL   8254
....................       heartbeat(TRUE); 
0FC32:  MOVLW  01
0FC34:  MOVLB  8
0FC36:  MOVWF  xCE
0FC38:  MOVLB  0
0FC3A:  CALL   5516
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FC3E:  MOVLB  8
0FC40:  CLRF   xCE
0FC42:  MOVLB  0
0FC44:  CALL   5516
....................          append_data(file_ptr_raw_new); 
0FC48:  MOVLW  02
0FC4A:  MOVLB  8
0FC4C:  MOVWF  xCF
0FC4E:  MOVLW  EB
0FC50:  MOVWF  xCE
0FC52:  MOVLB  0
0FC54:  CALL   8254
....................       heartbeat(TRUE); 
0FC58:  MOVLW  01
0FC5A:  MOVLB  8
0FC5C:  MOVWF  xCE
0FC5E:  MOVLB  0
0FC60:  CALL   5516
0FC64:  MOVLB  8
....................    } 
0FC66:  MOVLB  0
0FC68:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12B92:  CLRF   xC6
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12B86:  MOVLW  0D
12B88:  MOVLB  8
12B8A:  MOVWF  xAF
12B8C:  MOVLW  0A
12B8E:  MOVWF  xB0
12B90:  CLRF   xB1
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12B94:  MOVLB  0
12B96:  RCALL  12440
....................    clear_data_buffer(); 
12B98:  CALL   D198
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12B9C:  MOVLW  08
12B9E:  MOVWF  FEA
12BA0:  MOVLW  B2
12BA2:  MOVWF  FE9
12BA4:  CLRF   00
12BA6:  CLRF   02
12BA8:  MOVLW  14
12BAA:  MOVWF  01
12BAC:  CALL   34C2
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12BB0:  MOVLW  01
12BB2:  MOVWF  FEA
12BB4:  MOVLW  A7
12BB6:  MOVWF  FE9
12BB8:  CLRF   00
12BBA:  CLRF   02
12BBC:  MOVLW  A0
12BBE:  MOVWF  01
12BC0:  CALL   34C2
....................  
....................    time_stamp(); 
12BC4:  CALL   53AE
....................    strcpy(data_buffer, time_stmp_str); 
12BC8:  CLRF   FEA
12BCA:  MOVLW  67
12BCC:  MOVWF  FE9
12BCE:  MOVLW  02
12BD0:  MOVWF  FE2
12BD2:  MOVLW  99
12BD4:  MOVWF  FE1
12BD6:  MOVF   FE7,F
12BD8:  MOVFF  FE6,FEE
12BDC:  BNZ   12BD6
....................    strcat(data_buffer, (char *)","); 
12BDE:  MOVLW  2C
12BE0:  MOVLB  8
12BE2:  MOVWF  xCA
12BE4:  CLRF   xCB
12BE6:  CLRF   xDA
12BE8:  MOVLW  67
12BEA:  MOVWF  xD9
12BEC:  MOVLW  08
12BEE:  MOVWF  xDC
12BF0:  MOVLW  CA
12BF2:  MOVWF  xDB
12BF4:  MOVLB  0
12BF6:  CALL   5472
....................  
....................    flag_mod=fmod(macro_flag,10); 
12BFA:  MOVFF  324,8F9
12BFE:  MOVFF  323,8F8
12C02:  CALL   C58E
12C06:  MOVFF  03,8CF
12C0A:  MOVFF  02,8CE
12C0E:  MOVFF  01,8CD
12C12:  MOVFF  00,8CC
12C16:  MOVFF  03,8D3
12C1A:  MOVFF  02,8D2
12C1E:  MOVFF  01,8D1
12C22:  MOVFF  00,8D0
12C26:  MOVLB  8
12C28:  CLRF   xD7
12C2A:  CLRF   xD6
12C2C:  MOVLW  20
12C2E:  MOVWF  xD5
12C30:  MOVLW  82
12C32:  MOVWF  xD4
12C34:  MOVLB  0
12C36:  BRA    1283C
12C38:  MOVFF  03,8F7
12C3C:  MOVFF  02,8F6
12C40:  MOVFF  01,8F5
12C44:  MOVFF  00,8F4
12C48:  RCALL  12456
12C4A:  MOVFF  01,8C9
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
12C4E:  MOVLB  8
12C50:  DECFSZ xC9,W
12C52:  BRA    12C56
12C54:  BRA    12C5C
12C56:  MOVF   xC9,W
12C58:  SUBLW  03
12C5A:  BNZ   12C7A
....................    { 
....................       clear_proc_time_stmp_str(); 
12C5C:  MOVLB  0
12C5E:  BRA    129A4
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
12C60:  MOVLW  02
12C62:  MOVWF  FEA
12C64:  MOVLW  B7
12C66:  MOVWF  FE9
12C68:  MOVLW  02
12C6A:  MOVWF  FE2
12C6C:  MOVLW  99
12C6E:  MOVWF  FE1
12C70:  MOVF   FE7,F
12C72:  MOVFF  FE6,FEE
12C76:  BNZ   12C70
12C78:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
12C7A:  MOVLB  0
12C7C:  CALL   F596
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12C80:  MOVLB  8
12C82:  CLRF   xCD
12C84:  MOVLW  67
12C86:  MOVWF  xCC
12C88:  MOVLB  0
12C8A:  RCALL  129BC
12C8C:  MOVFF  02,03
12C90:  MOVF   01,W
12C92:  XORLW  FF
12C94:  ADDLW  A1
12C96:  MOVLB  8
12C98:  MOVWF  xCC
12C9A:  MOVLW  00
12C9C:  SUBFWB 02,W
12C9E:  MOVWF  xCD
12CA0:  MOVLW  01
12CA2:  SUBWF  xCC,F
12CA4:  MOVLW  00
12CA6:  SUBWFB xCD,F
12CA8:  CLRF   xCF
12CAA:  MOVLW  67
12CAC:  MOVWF  xCE
12CAE:  MOVLW  03
12CB0:  MOVWF  xD1
12CB2:  MOVLW  25
12CB4:  MOVWF  xD0
12CB6:  MOVFF  8CD,8D3
12CBA:  MOVFF  8CC,8D2
12CBE:  MOVLB  0
12CC0:  RCALL  129F8
....................    strcat(data_buffer, (char *)","); 
12CC2:  MOVLW  2C
12CC4:  MOVLB  8
12CC6:  MOVWF  xCA
12CC8:  CLRF   xCB
12CCA:  CLRF   xDA
12CCC:  MOVLW  67
12CCE:  MOVWF  xD9
12CD0:  MOVLW  08
12CD2:  MOVWF  xDC
12CD4:  MOVLW  CA
12CD6:  MOVWF  xDB
12CD8:  MOVLB  0
12CDA:  CALL   5472
....................     
....................    cmd = 'S'; 
12CDE:  MOVLW  53
12CE0:  MOVWF  47
....................    arg = 1; 
12CE2:  CLRF   4B
12CE4:  CLRF   4A
12CE6:  CLRF   49
12CE8:  MOVLW  01
12CEA:  MOVWF  48
....................  
....................    for(i = 0; i < 6; i++) 
12CEC:  MOVLB  8
12CEE:  CLRF   xC7
12CF0:  MOVF   xC7,W
12CF2:  SUBLW  05
12CF4:  BNC   12D0C
....................    { 
....................       rcvdData = get_slave_data(); 
12CF6:  MOVLB  0
12CF8:  BRA    12A96
12CFA:  MOVFF  01,8C6
....................       if (DATA_COMPLETE == rcvdData) 
12CFE:  MOVLB  8
12D00:  MOVF   xC6,W
12D02:  SUBLW  02
12D04:  BNZ   12D08
....................       { 
....................          break; 
12D06:  BRA    12D0C
....................       } 
12D08:  INCF   xC7,F
12D0A:  BRA    12CF0
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12D0C:  CLRF   xCD
12D0E:  MOVLW  67
12D10:  MOVWF  xCC
12D12:  MOVLB  0
12D14:  RCALL  129BC
12D16:  MOVFF  02,03
12D1A:  MOVF   01,W
12D1C:  XORLW  FF
12D1E:  ADDLW  A1
12D20:  MOVLB  8
12D22:  MOVWF  xCC
12D24:  MOVLW  00
12D26:  SUBFWB 02,W
12D28:  MOVWF  xCD
12D2A:  MOVLW  01
12D2C:  SUBWF  xCC,F
12D2E:  MOVLW  00
12D30:  SUBWFB xCD,F
12D32:  CLRF   xCF
12D34:  MOVLW  67
12D36:  MOVWF  xCE
12D38:  MOVLW  02
12D3A:  MOVWF  xD1
12D3C:  MOVLW  47
12D3E:  MOVWF  xD0
12D40:  MOVFF  8CD,8D3
12D44:  MOVFF  8CC,8D2
12D48:  MOVLB  0
12D4A:  RCALL  129F8
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
12D4C:  MOVLW  02
12D4E:  MOVLB  8
12D50:  MOVWF  xCD
12D52:  MOVLW  47
12D54:  MOVWF  xCC
12D56:  MOVLB  0
12D58:  RCALL  129BC
12D5A:  MOVFF  01,8C8
....................    if (rec_len > 0 && rec_len < 12) 
12D5E:  MOVLB  8
12D60:  MOVF   xC8,F
12D62:  BZ    12D70
12D64:  MOVF   xC8,W
12D66:  SUBLW  0B
12D68:  BNC   12D70
....................    { 
....................       rcvdData = SHORT_DATA; 
12D6A:  MOVLW  04
12D6C:  MOVWF  xC6
....................    } 
12D6E:  BRA    12D7A
....................    else 
....................    { 
....................       if (rec_len > 30) 
12D70:  MOVF   xC8,W
12D72:  SUBLW  1E
12D74:  BC    12D7A
....................       { 
....................          rcvdData = LONG_DATA; 
12D76:  MOVLW  05
12D78:  MOVWF  xC6
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
12D7A:  MOVLW  02
12D7C:  SUBWF  xC6,W
12D7E:  ADDLW  FC
12D80:  BC    12DEC
12D82:  ADDLW  04
12D84:  MOVLB  0
12D86:  GOTO   12F4E
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
12D8A:  MOVLB  8
12D8C:  BRA    12DEC
12D8E:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
12D90:  MOVLW  08
12D92:  MOVWF  1E
12D94:  MOVLW  B2
12D96:  MOVWF  1D
12D98:  MOVLW  68
12D9A:  MOVWF  FF6
12D9C:  MOVLW  1C
12D9E:  MOVWF  FF7
12DA0:  MOVLW  00
12DA2:  MOVWF  FF8
12DA4:  CALL   5052
....................          break; 
12DA8:  MOVLB  8
12DAA:  BRA    12DEC
12DAC:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
12DAE:  MOVLW  08
12DB0:  MOVWF  1E
12DB2:  MOVLW  B2
12DB4:  MOVWF  1D
12DB6:  MOVLW  72
12DB8:  MOVWF  FF6
12DBA:  MOVLW  1C
12DBC:  MOVWF  FF7
12DBE:  MOVLW  00
12DC0:  MOVWF  FF8
12DC2:  CALL   5052
....................          break; 
12DC6:  MOVLB  8
12DC8:  BRA    12DEC
12DCA:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
12DCC:  MOVLW  08
12DCE:  MOVWF  1E
12DD0:  MOVLW  B2
12DD2:  MOVWF  1D
12DD4:  MOVLW  82
12DD6:  MOVWF  FF6
12DD8:  MOVLW  1C
12DDA:  MOVWF  FF7
12DDC:  MOVLW  00
12DDE:  MOVWF  FF8
12DE0:  CALL   5052
....................          break; 
12DE4:  MOVLB  8
12DE6:  BRA    12DEC
12DE8:  MOVLB  0
12DEA:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12DEC:  CLRF   xCD
12DEE:  MOVLW  67
12DF0:  MOVWF  xCC
12DF2:  MOVLB  0
12DF4:  RCALL  129BC
12DF6:  MOVFF  02,03
12DFA:  MOVF   01,W
12DFC:  XORLW  FF
12DFE:  ADDLW  A1
12E00:  MOVLB  8
12E02:  MOVWF  xCC
12E04:  MOVLW  00
12E06:  SUBFWB 02,W
12E08:  MOVWF  xCD
12E0A:  MOVLW  01
12E0C:  SUBWF  xCC,F
12E0E:  MOVLW  00
12E10:  SUBWFB xCD,F
12E12:  CLRF   xCF
12E14:  MOVLW  67
12E16:  MOVWF  xCE
12E18:  MOVLW  08
12E1A:  MOVWF  xD1
12E1C:  MOVLW  B2
12E1E:  MOVWF  xD0
12E20:  MOVFF  8CD,8D3
12E24:  MOVFF  8CC,8D2
12E28:  MOVLB  0
12E2A:  RCALL  129F8
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12E2C:  MOVLB  8
12E2E:  CLRF   xCD
12E30:  MOVLW  67
12E32:  MOVWF  xCC
12E34:  MOVLB  0
12E36:  RCALL  129BC
12E38:  MOVFF  02,03
12E3C:  MOVF   01,W
12E3E:  XORLW  FF
12E40:  ADDLW  A1
12E42:  MOVLB  8
12E44:  MOVWF  xCC
12E46:  MOVLW  00
12E48:  SUBFWB 02,W
12E4A:  MOVWF  xCD
12E4C:  MOVLW  01
12E4E:  SUBWF  xCC,F
12E50:  MOVLW  00
12E52:  SUBWFB xCD,F
12E54:  CLRF   xCF
12E56:  MOVLW  67
12E58:  MOVWF  xCE
12E5A:  MOVLW  08
12E5C:  MOVWF  xD1
12E5E:  MOVLW  AF
12E60:  MOVWF  xD0
12E62:  MOVFF  8CD,8D3
12E66:  MOVFF  8CC,8D2
12E6A:  MOVLB  0
12E6C:  RCALL  129F8
....................  
....................    if(DATA_COMPLETE != rcvdData) 
12E6E:  MOVLB  8
12E70:  MOVF   xC6,W
12E72:  SUBLW  02
12E74:  BZ    12F30
....................    {    //housekeeping 
....................       time_stamp(); 
12E76:  MOVLB  0
12E78:  CALL   53AE
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
12E7C:  MOVLW  01
12E7E:  MOVWF  1E
12E80:  MOVLW  A7
12E82:  MOVWF  1D
12E84:  MOVLW  92
12E86:  MOVWF  FF6
12E88:  MOVLW  1C
12E8A:  MOVWF  FF7
12E8C:  MOVLW  00
12E8E:  MOVWF  FF8
12E90:  MOVLW  0A
12E92:  MOVLB  8
12E94:  MOVWF  xCC
12E96:  MOVLB  0
12E98:  CALL   AA28
12E9C:  MOVFF  1E,FEA
12EA0:  MOVFF  1D,FE9
12EA4:  CLRF   FEF
12EA6:  MOVLW  08
12EA8:  MOVWF  FEA
12EAA:  MOVLW  B2
12EAC:  MOVWF  FE9
12EAE:  CALL   FA9E
12EB2:  MOVLW  9E
12EB4:  MOVWF  FF6
12EB6:  MOVLW  1C
12EB8:  MOVWF  FF7
12EBA:  MOVLW  00
12EBC:  MOVWF  FF8
12EBE:  MOVLW  06
12EC0:  MOVLB  8
12EC2:  MOVWF  xCC
12EC4:  MOVLB  0
12EC6:  CALL   AA28
12ECA:  MOVFF  8C8,8CE
12ECE:  MOVLW  1B
12ED0:  MOVLB  8
12ED2:  MOVWF  xCF
12ED4:  MOVLB  0
12ED6:  CALL   5214
12EDA:  MOVLW  5D
12EDC:  MOVLB  8
12EDE:  MOVWF  xE0
12EE0:  MOVLB  0
12EE2:  CALL   5032
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
12EE6:  MOVLW  01
12EE8:  MOVLB  8
12EEA:  MOVWF  xCD
12EEC:  MOVLW  A7
12EEE:  MOVWF  xCC
12EF0:  MOVLB  0
12EF2:  RCALL  129BC
12EF4:  MOVFF  02,03
12EF8:  MOVF   01,W
12EFA:  XORLW  FF
12EFC:  ADDLW  A1
12EFE:  MOVLB  8
12F00:  MOVWF  xCC
12F02:  MOVLW  00
12F04:  SUBFWB 02,W
12F06:  MOVWF  xCD
12F08:  MOVLW  01
12F0A:  SUBWF  xCC,F
12F0C:  MOVLW  00
12F0E:  SUBWFB xCD,F
12F10:  MOVLW  01
12F12:  MOVWF  xCF
12F14:  MOVLW  A7
12F16:  MOVWF  xCE
12F18:  CLRF   xD1
12F1A:  MOVLW  67
12F1C:  MOVWF  xD0
12F1E:  MOVFF  8CD,8D3
12F22:  MOVFF  8CC,8D2
12F26:  MOVLB  0
12F28:  RCALL  129F8
....................       record_event(); 
12F2A:  CALL   8436
12F2E:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
12F30:  MOVFF  8AD,8CC
12F34:  MOVFF  8AE,8CD
12F38:  MOVLB  0
12F3A:  CALL   FBCC
....................  
....................    return (rcvdData); 
12F3E:  CLRF   03
12F40:  MOVLB  8
12F42:  MOVFF  8C6,01
12F46:  MOVFF  03,02
12F4A:  MOVLB  0
12F4C:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
13372:  MOVLB  8
13374:  CLRF   xA5
13376:  MOVF   xA5,W
13378:  SUBLW  02
1337A:  BTFSS  FD8.0
1337C:  BRA    13492
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
1337E:  MOVFF  8A3,8AD
13382:  MOVFF  8A4,8AE
13386:  MOVLB  0
13388:  CALL   12B86
1338C:  MOVFF  02,03
13390:  MOVF   01,W
13392:  SUBLW  02
13394:  BNZ   133A2
13396:  MOVF   03,F
13398:  BNZ   133A2
....................       { 
....................          break; 
1339A:  MOVLB  8
1339C:  BRA    13492
....................       } 
1339E:  BRA    1348E
133A0:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
133A2:  MOVLW  01
133A4:  MOVLB  8
133A6:  ADDWF  xA5,W
133A8:  MOVWF  xA6
133AA:  MOVLW  A8
133AC:  MOVWF  FF6
133AE:  MOVLW  1C
133B0:  MOVWF  FF7
133B2:  MOVLW  00
133B4:  MOVWF  FF8
133B6:  CLRF   1B
133B8:  BTFSC  FF2.7
133BA:  BSF    1B.7
133BC:  BCF    FF2.7
133BE:  MOVLW  05
133C0:  MOVLB  A
133C2:  MOVWF  x1C
133C4:  MOVLB  0
133C6:  CALL   1024
133CA:  BTFSC  1B.7
133CC:  BSF    FF2.7
133CE:  CLRF   1B
133D0:  BTFSC  FF2.7
133D2:  BSF    1B.7
133D4:  BCF    FF2.7
133D6:  MOVFF  8A6,A1C
133DA:  MOVLW  1B
133DC:  MOVLB  A
133DE:  MOVWF  x1D
133E0:  MOVLB  0
133E2:  CALL   0FA6
133E6:  BTFSC  1B.7
133E8:  BSF    FF2.7
133EA:  MOVLW  0D
133EC:  BTFSS  F9E.4
133EE:  BRA    133EC
133F0:  MOVWF  FAD
133F2:  MOVLW  0A
133F4:  BTFSS  F9E.4
133F6:  BRA    133F4
133F8:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
133FA:  BCF    F90.7
....................          delay_ms(1000); 
133FC:  MOVLW  04
133FE:  MOVLB  8
13400:  MOVWF  xA6
13402:  MOVLW  FA
13404:  MOVLB  9
13406:  MOVWF  xCD
13408:  MOVLB  0
1340A:  CALL   28AC
1340E:  MOVLB  8
13410:  DECFSZ xA6,F
13412:  BRA    13402
....................          output_bit(VDET,ON); 
13414:  BSF    F90.7
....................          delay_ms(1000); 
13416:  MOVLW  04
13418:  MOVWF  xA6
1341A:  MOVLW  FA
1341C:  MOVLB  9
1341E:  MOVWF  xCD
13420:  MOVLB  0
13422:  CALL   28AC
13426:  MOVLB  8
13428:  DECFSZ xA6,F
1342A:  BRA    1341A
....................          if (LightTargetFlag==0) 
1342C:  MOVLB  2
1342E:  MOVF   xD9,F
13430:  BNZ   13478
....................          { 
....................           cmd='K'; 
13432:  MOVLW  4B
13434:  MOVWF  47
....................           arg=detector_ch; 
13436:  CLRF   4B
13438:  CLRF   4A
1343A:  CLRF   49
1343C:  MOVFF  2D6,48
....................           det_cmd(); 
13440:  MOVLB  0
13442:  CALL   F072
....................           delay_ms(1000); 
13446:  MOVLW  04
13448:  MOVLB  8
1344A:  MOVWF  xA6
1344C:  MOVLW  FA
1344E:  MOVLB  9
13450:  MOVWF  xCD
13452:  MOVLB  0
13454:  CALL   28AC
13458:  MOVLB  8
1345A:  DECFSZ xA6,F
1345C:  BRA    1344C
....................           cmd='L'; 
1345E:  MOVLW  4C
13460:  MOVWF  47
....................           arg=detector_li; 
13462:  CLRF   4B
13464:  CLRF   4A
13466:  MOVFF  2D8,49
1346A:  MOVFF  2D7,48
....................           det_cmd(); 
1346E:  MOVLB  0
13470:  CALL   F072
....................          }  
13474:  BRA    1348C
13476:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
13478:  MOVLW  6C
1347A:  MOVWF  47
....................           arg=1; 
1347C:  CLRF   4B
1347E:  CLRF   4A
13480:  CLRF   49
13482:  MOVLW  01
13484:  MOVWF  48
....................           det_cmd(); 
13486:  MOVLB  0
13488:  CALL   F072
1348C:  MOVLB  8
....................          }  
....................       } 
1348E:  INCF   xA5,F
13490:  BRA    13376
....................    } 
....................  
....................    parse_data(); 
13492:  MOVLB  0
13494:  RCALL  132F0
....................    data_available = TRUE; 
13496:  MOVLW  01
13498:  MOVLB  3
1349A:  MOVWF  x3B
....................    macro_flag = 900; 
1349C:  MOVLW  03
1349E:  MOVWF  x24
134A0:  MOVLW  84
134A2:  MOVWF  x23
....................  
....................    return; 
134A4:  MOVLB  0
134A6:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
13812:  MOVLB  8
13814:  CLRF   xAE
13816:  CLRF   xAD
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
13818:  MOVLB  0
1381A:  RCALL  132F0
1381C:  MOVFF  02,8AE
13820:  MOVFF  01,8AD
....................    return (temp); 
13824:  MOVLB  8
13826:  MOVFF  8AD,01
1382A:  MOVFF  8AE,02
1382E:  MOVLB  0
13830:  GOTO   13942 (RETURN)
.................... } 
....................  
.................... void det_temp() 
13834:  MOVLB  8
13836:  CLRF   xAA
13838:  CLRF   xA9
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
1383A:  MOVLB  2
1383C:  MOVF   xD5,W
1383E:  XORLW  01
13840:  MOVLB  0
13842:  BZ    1384A
13844:  XORLW  03
13846:  BZ    13854
13848:  BRA    1385E
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
1384A:  MOVFF  42,8AC
1384E:  MOVFF  41,8AB
....................          break; 
13852:  BRA    1386A
....................       case 2 : target_temp = nv_d2_temp; 
13854:  MOVFF  44,8AC
13858:  MOVFF  43,8AB
....................          break; 
1385C:  BRA    1386A
....................       default : target_temp = 20000; 
1385E:  MOVLW  4E
13860:  MOVLB  8
13862:  MOVWF  xAC
13864:  MOVLW  20
13866:  MOVWF  xAB
....................          break; 
13868:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
1386A:  MOVLB  8
1386C:  CLRF   xA8
1386E:  MOVLW  3C
13870:  MOVWF  xA7
....................    n = 0; 
13872:  CLRF   xA6
13874:  CLRF   xA5
....................    store=FALSE; 
13876:  CLRF   xA3
....................    display=FALSE; 
13878:  CLRF   xA4
....................  
....................    time_stamp(); 
1387A:  MOVLB  0
1387C:  CALL   53AE
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
13880:  MOVLW  01
13882:  MOVWF  1E
13884:  MOVLW  A7
13886:  MOVWF  1D
13888:  MOVLW  B2
1388A:  MOVWF  FF6
1388C:  MOVLW  1C
1388E:  MOVWF  FF7
13890:  MOVLW  00
13892:  MOVWF  FF8
13894:  MOVLW  16
13896:  MOVLB  8
13898:  MOVWF  xCC
1389A:  MOVLB  0
1389C:  CALL   AA28
138A0:  MOVLW  10
138A2:  MOVWF  FE9
138A4:  MOVFF  8AC,8D8
138A8:  MOVFF  8AB,8D7
138AC:  CALL   AA5A
138B0:  MOVLW  CB
138B2:  MOVWF  FF6
138B4:  MOVLW  1C
138B6:  MOVWF  FF7
138B8:  MOVLW  00
138BA:  MOVWF  FF8
138BC:  MOVLW  09
138BE:  MOVLB  8
138C0:  MOVWF  xCC
138C2:  MOVLB  0
138C4:  CALL   AA28
138C8:  MOVLW  10
138CA:  MOVWF  FE9
138CC:  MOVFF  8AA,8D8
138D0:  MOVFF  8A9,8D7
138D4:  CALL   AA5A
138D8:  MOVLW  D7
138DA:  MOVWF  FF6
138DC:  MOVLW  1C
138DE:  MOVWF  FF7
138E0:  MOVLW  00
138E2:  MOVWF  FF8
138E4:  MOVLW  0B
138E6:  MOVLB  8
138E8:  MOVWF  xCC
138EA:  MOVLB  0
138EC:  CALL   AA28
138F0:  MOVLW  10
138F2:  MOVWF  FE9
138F4:  MOVFF  8A6,8D8
138F8:  MOVFF  8A5,8D7
138FC:  CALL   AA5A
13900:  MOVLW  E5
13902:  MOVWF  FF6
13904:  MOVLW  1C
13906:  MOVWF  FF7
13908:  MOVLW  00
1390A:  MOVWF  FF8
1390C:  MOVLW  03
1390E:  MOVLB  8
13910:  MOVWF  xCC
13912:  MOVLB  0
13914:  CALL   AA28
....................    record_event(); 
13918:  CALL   8436
....................  
....................    for (n=1; n<t; ++n) 
1391C:  MOVLB  8
1391E:  CLRF   xA6
13920:  MOVLW  01
13922:  MOVWF  xA5
13924:  MOVF   xA6,W
13926:  SUBWF  xA8,W
13928:  BNC   13984
1392A:  BNZ   13932
1392C:  MOVF   xA7,W
1392E:  SUBWF  xA5,W
13930:  BC    13984
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
13932:  MOVFF  8A3,8AD
13936:  MOVFF  8A4,8AE
1393A:  MOVLB  0
1393C:  CALL   12B86
....................       current_temp=parse_temp(); 
13940:  BRA    13812
13942:  MOVFF  02,8AA
13946:  MOVFF  01,8A9
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
1394A:  MOVLB  8
1394C:  MOVF   xAC,W
1394E:  SUBWF  xAA,W
13950:  BNC   1395A
13952:  BNZ   13962
13954:  MOVF   xAB,W
13956:  SUBWF  xA9,W
13958:  BC    13962
1395A:  MOVF   xA9,F
1395C:  BNZ   13966
1395E:  MOVF   xAA,F
13960:  BNZ   13966
13962:  BRA    13984
13964:  BRA    1397C
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13966:  MOVLW  0A
13968:  MOVWF  xAD
1396A:  MOVLW  FA
1396C:  MOVLB  9
1396E:  MOVWF  xCD
13970:  MOVLB  0
13972:  CALL   28AC
13976:  MOVLB  8
13978:  DECFSZ xAD,F
1397A:  BRA    1396A
1397C:  INCF   xA5,F
1397E:  BTFSC  FD8.2
13980:  INCF   xA6,F
13982:  BRA    13924
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13984:  MOVLW  01
13986:  MOVWF  1E
13988:  MOVLW  A7
1398A:  MOVWF  1D
1398C:  MOVLW  EA
1398E:  MOVWF  FF6
13990:  MOVLW  1C
13992:  MOVWF  FF7
13994:  MOVLW  00
13996:  MOVWF  FF8
13998:  MOVLW  14
1399A:  MOVWF  xCC
1399C:  MOVLB  0
1399E:  CALL   AA28
139A2:  MOVLW  10
139A4:  MOVWF  FE9
139A6:  MOVFF  8AC,8D8
139AA:  MOVFF  8AB,8D7
139AE:  CALL   AA5A
139B2:  MOVLW  01
139B4:  MOVWF  FF6
139B6:  MOVLW  1D
139B8:  MOVWF  FF7
139BA:  MOVLW  00
139BC:  MOVWF  FF8
139BE:  MOVLW  09
139C0:  MOVLB  8
139C2:  MOVWF  xCC
139C4:  MOVLB  0
139C6:  CALL   AA28
139CA:  MOVLW  10
139CC:  MOVWF  FE9
139CE:  MOVFF  8AA,8D8
139D2:  MOVFF  8A9,8D7
139D6:  CALL   AA5A
139DA:  MOVLW  0D
139DC:  MOVWF  FF6
139DE:  MOVLW  1D
139E0:  MOVWF  FF7
139E2:  MOVLW  00
139E4:  MOVWF  FF8
139E6:  MOVLW  0B
139E8:  MOVLB  8
139EA:  MOVWF  xCC
139EC:  MOVLB  0
139EE:  CALL   AA28
139F2:  MOVLW  10
139F4:  MOVWF  FE9
139F6:  MOVFF  8A6,8D8
139FA:  MOVFF  8A5,8D7
139FE:  CALL   AA5A
13A02:  MOVLW  1B
13A04:  MOVWF  FF6
13A06:  MOVLW  1D
13A08:  MOVWF  FF7
13A0A:  MOVLW  00
13A0C:  MOVWF  FF8
13A0E:  MOVLW  03
13A10:  MOVLB  8
13A12:  MOVWF  xCC
13A14:  MOVLB  0
13A16:  CALL   AA28
....................    record_event();    
13A1A:  CALL   8436
13A1E:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
134EA:  MOVLB  8
134EC:  CLRF   xB6
134EE:  CLRF   xB5
134F0:  CLRF   xB4
134F2:  CLRF   xB3
....................    set_adc_channel(1,VSS); 
134F4:  MOVLW  04
134F6:  MOVWF  01
134F8:  MOVF   FC2,W
134FA:  ANDLW  83
134FC:  IORWF  01,W
134FE:  MOVWF  FC2
13500:  MOVLW  00
13502:  MOVWF  01
13504:  MOVF   FC1,W
13506:  ANDLW  F8
13508:  IORWF  01,W
1350A:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
1350C:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
1350E:  MOVLW  01
13510:  MOVWF  xB0
13512:  MOVF   xB0,W
13514:  SUBLW  32
13516:  BNC   1353C
....................       reading=read_adc(); 
13518:  BSF    FC2.1
1351A:  BTFSC  FC2.1
1351C:  BRA    1351A
1351E:  MOVFF  FC3,8B7
13522:  MOVFF  FC4,8B8
13526:  CLRF   xB9
13528:  CLRF   xBA
....................       delay_ms(5); 
1352A:  MOVLW  05
1352C:  MOVLB  9
1352E:  MOVWF  xCD
13530:  MOVLB  0
13532:  CALL   28AC
13536:  MOVLB  8
13538:  INCF   xB0,F
1353A:  BRA    13512
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
1353C:  MOVLW  01
1353E:  MOVWF  xB0
13540:  MOVF   xB0,W
13542:  SUBLW  64
13544:  BNC   135F2
....................       reading=read_adc(); 
13546:  BSF    FC2.1
13548:  BTFSC  FC2.1
1354A:  BRA    13548
1354C:  MOVFF  FC3,8B7
13550:  MOVFF  FC4,8B8
13554:  CLRF   xB9
13556:  CLRF   xBA
....................       result=(((result*(i-1))+reading)/i); 
13558:  MOVLW  01
1355A:  SUBWF  xB0,W
1355C:  MOVWF  xBB
1355E:  MOVFF  8B6,9DA
13562:  MOVFF  8B5,9D9
13566:  MOVFF  8B4,9D8
1356A:  MOVFF  8B3,9D7
1356E:  MOVLB  9
13570:  CLRF   xDE
13572:  CLRF   xDD
13574:  CLRF   xDC
13576:  MOVWF  xDB
13578:  MOVLB  0
1357A:  CALL   478E
1357E:  MOVFF  03,8BE
13582:  MOVFF  02,8BD
13586:  MOVFF  01,8BC
1358A:  MOVFF  00,8BB
1358E:  MOVLB  8
13590:  MOVF   xB7,W
13592:  ADDWF  xBB,F
13594:  MOVF   xB8,W
13596:  ADDWFC xBC,F
13598:  MOVF   xB9,W
1359A:  ADDWFC xBD,F
1359C:  MOVF   xBA,W
1359E:  ADDWFC xBE,F
135A0:  BCF    FD8.1
135A2:  CLRF   1B
135A4:  BTFSC  FF2.7
135A6:  BSF    1B.7
135A8:  BCF    FF2.7
135AA:  MOVFF  8BE,A2B
135AE:  MOVFF  8BD,A2A
135B2:  MOVFF  8BC,A29
135B6:  MOVFF  8BB,A28
135BA:  MOVLB  A
135BC:  CLRF   x2F
135BE:  CLRF   x2E
135C0:  CLRF   x2D
135C2:  MOVFF  8B0,A2C
135C6:  MOVLB  0
135C8:  CALL   1056
135CC:  BTFSC  1B.7
135CE:  BSF    FF2.7
135D0:  MOVFF  03,8B6
135D4:  MOVFF  02,8B5
135D8:  MOVFF  01,8B4
135DC:  MOVFF  00,8B3
....................       delay_ms(5); 
135E0:  MOVLW  05
135E2:  MOVLB  9
135E4:  MOVWF  xCD
135E6:  MOVLB  0
135E8:  CALL   28AC
135EC:  MOVLB  8
135EE:  INCF   xB0,F
135F0:  BRA    13540
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
135F2:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
135F4:  MOVFF  8B6,9DA
135F8:  MOVFF  8B5,9D9
135FC:  MOVFF  8B4,9D8
13600:  MOVFF  8B3,9D7
13604:  MOVLB  9
13606:  CLRF   xDE
13608:  CLRF   xDD
1360A:  MOVLW  10
1360C:  MOVWF  xDC
1360E:  MOVLW  25
13610:  MOVWF  xDB
13612:  MOVLB  0
13614:  CALL   478E
13618:  MOVFF  03,8BE
1361C:  MOVFF  02,8BD
13620:  MOVFF  01,8BC
13624:  MOVFF  00,8BB
13628:  BCF    FD8.1
1362A:  CLRF   1B
1362C:  BTFSC  FF2.7
1362E:  BSF    1B.7
13630:  BCF    FF2.7
13632:  MOVFF  03,A2B
13636:  MOVFF  02,A2A
1363A:  MOVFF  01,A29
1363E:  MOVFF  00,A28
13642:  MOVLB  A
13644:  CLRF   x2F
13646:  CLRF   x2E
13648:  CLRF   x2D
1364A:  MOVLW  64
1364C:  MOVWF  x2C
1364E:  MOVLB  0
13650:  CALL   1056
13654:  BTFSC  1B.7
13656:  BSF    FF2.7
13658:  MOVLW  21
1365A:  MOVLB  8
1365C:  SUBWF  00,W
1365E:  MOVWF  xB1
13660:  MOVLW  50
13662:  SUBWFB 01,W
13664:  MOVWF  xB2
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
13666:  MOVFF  8B1,01
1366A:  MOVFF  8B2,02
1366E:  MOVLB  0
13670:  GOTO   136D6 (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
13680:  CLRF   xA9
13682:  CLRF   xA8
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
13674:  MOVLW  0D
13676:  MOVLB  8
13678:  MOVWF  xA5
1367A:  MOVLW  0A
1367C:  MOVWF  xA6
1367E:  CLRF   xA7
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
13684:  MOVLB  0
13686:  CALL   12440
....................    clear_data_buffer(); 
1368A:  CALL   D198
....................  
....................    time_stamp(); 
1368E:  CALL   53AE
....................    strcpy(data_buffer, time_stmp_str); 
13692:  CLRF   FEA
13694:  MOVLW  67
13696:  MOVWF  FE9
13698:  MOVLW  02
1369A:  MOVWF  FE2
1369C:  MOVLW  99
1369E:  MOVWF  FE1
136A0:  MOVF   FE7,F
136A2:  MOVFF  FE6,FEE
136A6:  BNZ   136A0
....................    strcat(data_buffer, (char *)",Tmp,"); 
136A8:  MOVLW  2C
136AA:  MOVLB  8
136AC:  MOVWF  xAA
136AE:  MOVLW  54
136B0:  MOVWF  xAB
136B2:  MOVLW  6D
136B4:  MOVWF  xAC
136B6:  MOVLW  70
136B8:  MOVWF  xAD
136BA:  MOVLW  2C
136BC:  MOVWF  xAE
136BE:  CLRF   xAF
136C0:  CLRF   xDA
136C2:  MOVLW  67
136C4:  MOVWF  xD9
136C6:  MOVLW  08
136C8:  MOVWF  xDC
136CA:  MOVLW  AA
136CC:  MOVWF  xDB
136CE:  MOVLB  0
136D0:  CALL   5472
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
136D4:  BRA    134EA
136D6:  MOVFF  02,8A9
136DA:  MOVFF  01,8A8
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
136DE:  MOVLW  02
136E0:  MOVWF  1E
136E2:  MOVLW  47
136E4:  MOVWF  1D
136E6:  MOVLW  45
136E8:  MOVWF  FE9
136EA:  MOVLB  8
136EC:  CLRF   xD1
136EE:  CLRF   xD0
136F0:  MOVFF  8A9,8CF
136F4:  MOVFF  8A8,8CE
136F8:  MOVLW  03
136FA:  MOVWF  xD2
136FC:  MOVLB  0
136FE:  CALL   52AE
....................  
....................    strcat(slave_reply, endofline); 
13702:  MOVLW  02
13704:  MOVLB  8
13706:  MOVWF  xDA
13708:  MOVLW  47
1370A:  MOVWF  xD9
1370C:  MOVLW  08
1370E:  MOVWF  xDC
13710:  MOVLW  A5
13712:  MOVWF  xDB
13714:  MOVLB  0
13716:  CALL   5472
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
1371A:  MOVLB  8
1371C:  CLRF   xCD
1371E:  MOVLW  67
13720:  MOVWF  xCC
13722:  MOVLB  0
13724:  CALL   129BC
13728:  MOVFF  02,03
1372C:  MOVF   01,W
1372E:  XORLW  FF
13730:  ADDLW  A1
13732:  MOVLB  8
13734:  MOVWF  xB0
13736:  MOVLW  00
13738:  SUBFWB 02,W
1373A:  MOVWF  xB1
1373C:  MOVLW  01
1373E:  SUBWF  xB0,F
13740:  MOVLW  00
13742:  SUBWFB xB1,F
13744:  CLRF   xCF
13746:  MOVLW  67
13748:  MOVWF  xCE
1374A:  MOVLW  02
1374C:  MOVWF  xD1
1374E:  MOVLW  47
13750:  MOVWF  xD0
13752:  MOVFF  8B1,8D3
13756:  MOVFF  8B0,8D2
1375A:  MOVLB  0
1375C:  CALL   129F8
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
13760:  MOVF   1F,F
13762:  BNZ   13782
13764:  MOVF   20,F
13766:  BNZ   13782
13768:  MOVLB  8
1376A:  DECFSZ xA4,W
1376C:  BRA    13770
1376E:  BRA    13774
13770:  MOVLB  0
13772:  BRA    13782
13774:  CLRF   FEA
13776:  MOVLW  67
13778:  MOVWF  FE9
1377A:  MOVLB  0
1377C:  CALL   78F8
13780:  BRA    13796
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
13782:  MOVF   20,F
13784:  BNZ   1378C
13786:  MOVF   1F,W
13788:  SUBLW  03
1378A:  BC    13796
1378C:  CLRF   FEA
1378E:  MOVLW  67
13790:  MOVWF  FE9
13792:  CALL   78F8
....................  
....................    if (store == TRUE && sd_status==0) { 
13796:  MOVLB  8
13798:  DECFSZ xA3,W
1379A:  BRA    137FA
1379C:  MOVLB  2
1379E:  MOVF   xDC,F
137A0:  BTFSC  FD8.2
137A2:  BRA    137A8
137A4:  MOVLB  8
137A6:  BRA    137FA
....................       buffer_select = 0; 
137A8:  MOVLB  0
137AA:  CLRF   x66
....................       
....................       heartbeat(FALSE); 
137AC:  MOVLB  8
137AE:  CLRF   xCE
137B0:  MOVLB  0
137B2:  CALL   5516
....................          append_data(file_ptr_raw_all); 
137B6:  MOVLW  02
137B8:  MOVLB  8
137BA:  MOVWF  xCF
137BC:  MOVLW  DD
137BE:  MOVWF  xCE
137C0:  MOVLB  0
137C2:  CALL   8254
....................       heartbeat(TRUE); 
137C6:  MOVLW  01
137C8:  MOVLB  8
137CA:  MOVWF  xCE
137CC:  MOVLB  0
137CE:  CALL   5516
....................        
....................       heartbeat(FALSE); 
137D2:  MOVLB  8
137D4:  CLRF   xCE
137D6:  MOVLB  0
137D8:  CALL   5516
....................          append_data(file_ptr_raw_new); 
137DC:  MOVLW  02
137DE:  MOVLB  8
137E0:  MOVWF  xCF
137E2:  MOVLW  EB
137E4:  MOVWF  xCE
137E6:  MOVLB  0
137E8:  CALL   8254
....................       heartbeat(TRUE); 
137EC:  MOVLW  01
137EE:  MOVLB  8
137F0:  MOVWF  xCE
137F2:  MOVLB  0
137F4:  CALL   5516
137F8:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
137FA:  MOVLW  03
137FC:  MOVLB  3
137FE:  MOVWF  x24
13800:  MOVLW  84
13802:  MOVWF  x23
....................     
....................    return (temp); 
13804:  MOVLB  8
13806:  MOVFF  8A8,01
1380A:  MOVFF  8A9,02
1380E:  MOVLB  0
13810:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
12352:  MOVLB  8
12354:  MOVF   xA6,W
12356:  ADDLW  FC
12358:  BC    12396
1235A:  ADDLW  04
1235C:  MOVLB  0
1235E:  GOTO   1239E
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
12362:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
12364:  BCF    F8C.1
....................          break; 
12366:  MOVLB  8
12368:  BRA    12396
....................       case 1 :  
....................             output_bit(HSW1, ON); 
1236A:  BSF    F8C.0
....................          break; 
1236C:  MOVLB  8
1236E:  BRA    12396
....................       case 2 :  
....................             output_bit(HSW2, ON); 
12370:  BSF    F8C.1
....................          break;  
12372:  MOVLB  8
12374:  BRA    12396
....................       case 3 :  
....................             output_bit(HSW1, ON); 
12376:  BSF    F8C.0
....................             delay_ms(500); 
12378:  MOVLW  02
1237A:  MOVLB  8
1237C:  MOVWF  xA7
1237E:  MOVLW  FA
12380:  MOVLB  9
12382:  MOVWF  xCD
12384:  MOVLB  0
12386:  CALL   28AC
1238A:  MOVLB  8
1238C:  DECFSZ xA7,F
1238E:  BRA    1237E
....................             output_bit(HSW2, ON); 
12390:  BSF    F8C.1
....................          break;             
12392:  BRA    12396
12394:  MOVLB  8
....................    } 
....................    heater_stat=set; 
12396:  MOVFF  8A6,4B5
1239A:  MOVLB  0
1239C:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F48C:  MOVLW  08
0F48E:  MOVLB  8
0F490:  MOVWF  xAD
0F492:  CLRF   xAC
....................    LED_level_change=2048; 
0F494:  MOVWF  xAF
0F496:  CLRF   xAE
....................     
....................    for (i=0; i<12; i++){ 
0F498:  CLRF   xAB
0F49A:  MOVF   xAB,W
0F49C:  SUBLW  0B
0F49E:  BNC   F516
....................       DAC_set(1,LED_level); 
0F4A0:  MOVLW  01
0F4A2:  MOVWF  xB4
0F4A4:  MOVFF  8AD,8B6
0F4A8:  MOVFF  8AC,8B5
0F4AC:  MOVLB  0
0F4AE:  RCALL  F1E8
....................       LED_level_change = LED_level_change/2; 
0F4B0:  BCF    FD8.0
0F4B2:  MOVLB  8
0F4B4:  RRCF   xAF,F
0F4B6:  RRCF   xAE,F
....................       ADC_average(200); 
0F4B8:  CLRF   xB5
0F4BA:  MOVLW  C8
0F4BC:  MOVWF  xB4
0F4BE:  MOVLB  0
0F4C0:  RCALL  F290
....................       output = ADC_val[2]; 
0F4C2:  MOVFF  4AA,8B1
0F4C6:  MOVFF  4A9,8B0
....................       temp = ADC_val[3]; 
0F4CA:  MOVFF  4AC,8B3
0F4CE:  MOVFF  4AB,8B2
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F4D2:  MOVLB  8
0F4D4:  MOVF   xAA,W
0F4D6:  SUBWF  xB1,W
0F4D8:  BNC   F4EC
0F4DA:  BNZ   F4E2
0F4DC:  MOVF   xB0,W
0F4DE:  SUBWF  xA9,W
0F4E0:  BC    F4EC
....................          LED_level=LED_level-LED_level_change; 
0F4E2:  MOVF   xAE,W
0F4E4:  SUBWF  xAC,F
0F4E6:  MOVF   xAF,W
0F4E8:  SUBWFB xAD,F
....................       } 
0F4EA:  BRA    F512
....................       else if(output<intensity){ 
0F4EC:  MOVF   xB1,W
0F4EE:  SUBWF  xAA,W
0F4F0:  BNC   F504
0F4F2:  BNZ   F4FA
0F4F4:  MOVF   xA9,W
0F4F6:  SUBWF  xB0,W
0F4F8:  BC    F504
....................          LED_level=LED_level+LED_level_change; 
0F4FA:  MOVF   xAE,W
0F4FC:  ADDWF  xAC,F
0F4FE:  MOVF   xAF,W
0F500:  ADDWFC xAD,F
....................       } 
0F502:  BRA    F512
....................       else if(output==intensity) break; 
0F504:  MOVF   xA9,W
0F506:  SUBWF  xB0,W
0F508:  BNZ   F512
0F50A:  MOVF   xAA,W
0F50C:  SUBWF  xB1,W
0F50E:  BTFSC  FD8.2
0F510:  BRA    F516
0F512:  INCF   xAB,F
0F514:  BRA    F49A
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F516:  MOVLW  01
0F518:  MOVWF  xB4
0F51A:  MOVFF  8AD,8B6
0F51E:  MOVFF  8AC,8B5
0F522:  MOVLB  0
0F524:  RCALL  F1E8
0F526:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F528:  MOVLW  01
0F52A:  MOVLB  8
0F52C:  MOVWF  xA8
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F52E:  MOVF   xA6,F
0F530:  BNZ   F536
0F532:  MOVF   xA7,F
0F534:  BZ    F54A
0F536:  MOVF   xA7,W
0F538:  SUBLW  0F
0F53A:  BNC   F54A
0F53C:  MOVFF  8A7,8AA
0F540:  MOVFF  8A6,8A9
0F544:  MOVLB  0
0F546:  RCALL  F48C
0F548:  MOVLB  8
....................   if(intensity == 0) { 
0F54A:  MOVF   xA6,F
0F54C:  BNZ   F570
0F54E:  MOVF   xA7,F
0F550:  BNZ   F570
....................       DAC_set(1, 0); 
0F552:  MOVLW  01
0F554:  MOVWF  xB4
0F556:  CLRF   xB6
0F558:  CLRF   xB5
0F55A:  MOVLB  0
0F55C:  RCALL  F1E8
....................       DAC_set(2, 0); 
0F55E:  MOVLW  02
0F560:  MOVLB  8
0F562:  MOVWF  xB4
0F564:  CLRF   xB6
0F566:  CLRF   xB5
0F568:  MOVLB  0
0F56A:  RCALL  F1E8
....................    } 
0F56C:  BRA    F574
0F56E:  MOVLB  8
....................    else valid=FALSE; 
0F570:  CLRF   xA8
0F572:  MOVLB  0
....................    return(valid); 
0F574:  MOVLB  8
0F576:  MOVFF  8A8,01
0F57A:  MOVLB  0
0F57C:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FAFE:  MOVLW  20
0FB00:  MOVWF  FF6
0FB02:  MOVLW  1D
0FB04:  MOVWF  FF7
0FB06:  MOVLW  00
0FB08:  MOVWF  FF8
0FB0A:  MOVLW  03
0FB0C:  MOVWF  FEA
0FB0E:  MOVLW  3D
0FB10:  MOVWF  FE9
0FB12:  RCALL  FAC4
0FB14:  MOVF   01,W
0FB16:  BZ    FB2A
0FB18:  XORLW  01
0FB1A:  BZ    FB4A
0FB1C:  XORLW  03
0FB1E:  BZ    FB6A
0FB20:  XORLW  01
0FB22:  BZ    FB8A
0FB24:  XORLW  07
0FB26:  BZ    FBAA
0FB28:  BRA    FBC8
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FB2A:  BCF    FD8.0
0FB2C:  MOVLB  3
0FB2E:  RLCF   x4A,W
0FB30:  CLRF   03
0FB32:  ADDLW  4B
0FB34:  MOVWF  FE9
0FB36:  MOVLW  03
0FB38:  ADDWFC 03,W
0FB3A:  MOVWF  FEA
0FB3C:  MOVFF  4A8,FEC
0FB40:  MOVF   FED,F
0FB42:  MOVFF  4A7,FEF
....................          break; 
0FB46:  MOVLB  0
0FB48:  BRA    FBC8
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FB4A:  BCF    FD8.0
0FB4C:  MOVLB  3
0FB4E:  RLCF   x4A,W
0FB50:  CLRF   03
0FB52:  ADDLW  5D
0FB54:  MOVWF  FE9
0FB56:  MOVLW  03
0FB58:  ADDWFC 03,W
0FB5A:  MOVWF  FEA
0FB5C:  MOVFF  4A8,FEC
0FB60:  MOVF   FED,F
0FB62:  MOVFF  4A7,FEF
....................          break;    
0FB66:  MOVLB  0
0FB68:  BRA    FBC8
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FB6A:  BCF    FD8.0
0FB6C:  MOVLB  3
0FB6E:  RLCF   x4A,W
0FB70:  CLRF   03
0FB72:  ADDLW  6F
0FB74:  MOVWF  FE9
0FB76:  MOVLW  03
0FB78:  ADDWFC 03,W
0FB7A:  MOVWF  FEA
0FB7C:  MOVFF  4A8,FEC
0FB80:  MOVF   FED,F
0FB82:  MOVFF  4A7,FEF
....................          break; 
0FB86:  MOVLB  0
0FB88:  BRA    FBC8
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FB8A:  BCF    FD8.0
0FB8C:  MOVLB  3
0FB8E:  RLCF   x4A,W
0FB90:  CLRF   03
0FB92:  ADDLW  81
0FB94:  MOVWF  FE9
0FB96:  MOVLW  03
0FB98:  ADDWFC 03,W
0FB9A:  MOVWF  FEA
0FB9C:  MOVFF  4A8,FEC
0FBA0:  MOVF   FED,F
0FBA2:  MOVFF  4A7,FEF
....................          break; 
0FBA6:  MOVLB  0
0FBA8:  BRA    FBC8
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FBAA:  BCF    FD8.0
0FBAC:  MOVLB  3
0FBAE:  RLCF   x4A,W
0FBB0:  CLRF   03
0FBB2:  ADDLW  93
0FBB4:  MOVWF  FE9
0FBB6:  MOVLW  03
0FBB8:  ADDWFC 03,W
0FBBA:  MOVWF  FEA
0FBBC:  MOVFF  4A8,FEC
0FBC0:  MOVF   FED,F
0FBC2:  MOVFF  4A7,FEF
....................          break; 
0FBC6:  MOVLB  0
....................    } 
0FBC8:  GOTO   FEAC (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
0FC6A:  MOVFF  8A4,8B5
0FC6E:  MOVFF  8A3,8B4
0FC72:  CALL   F290
....................     
....................    v_supply = read_supply(); 
0FC76:  CALL   5090
0FC7A:  MOVFF  02,8A9
0FC7E:  MOVFF  01,8A8
....................        
....................    RTC_reset_HT(); 
0FC82:  CALL   344E
....................    RTC_read(); 
0FC86:  CALL   32E0
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
0FC8A:  RCALL  F596
0FC8C:  MOVFF  02,8AB
0FC90:  MOVFF  01,8AA
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
0FC94:  MOVLB  8
0FC96:  DECFSZ xA7,W
0FC98:  BRA    FCC2
0FC9A:  MOVLW  10
0FC9C:  MOVWF  FE9
0FC9E:  CLRF   1B
0FCA0:  BTFSC  FF2.7
0FCA2:  BSF    1B.7
0FCA4:  BCF    FF2.7
0FCA6:  MOVFF  4AA,A1D
0FCAA:  MOVFF  4A9,A1C
0FCAE:  MOVLB  0
0FCB0:  CALL   11A6
0FCB4:  BTFSC  1B.7
0FCB6:  BSF    FF2.7
0FCB8:  MOVLW  2C
0FCBA:  BTFSS  F9E.4
0FCBC:  BRA    FCBA
0FCBE:  MOVWF  FAD
0FCC0:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
0FCC2:  CLRF   1E
0FCC4:  MOVLW  67
0FCC6:  MOVWF  1D
0FCC8:  MOVFF  72A,8CE
0FCCC:  MOVLW  01
0FCCE:  MOVWF  xCF
0FCD0:  MOVLB  0
0FCD2:  CALL   5214
0FCD6:  MOVLW  2F
0FCD8:  MOVLB  8
0FCDA:  MOVWF  xE0
0FCDC:  MOVLB  0
0FCDE:  CALL   5032
0FCE2:  MOVFF  729,8CE
0FCE6:  MOVLW  01
0FCE8:  MOVLB  8
0FCEA:  MOVWF  xCF
0FCEC:  MOVLB  0
0FCEE:  CALL   5214
0FCF2:  MOVLW  2F
0FCF4:  MOVLB  8
0FCF6:  MOVWF  xE0
0FCF8:  MOVLB  0
0FCFA:  CALL   5032
0FCFE:  MOVFF  72B,8CE
0FD02:  MOVLW  01
0FD04:  MOVLB  8
0FD06:  MOVWF  xCF
0FD08:  MOVLB  0
0FD0A:  CALL   5214
0FD0E:  MOVLW  20
0FD10:  MOVLB  8
0FD12:  MOVWF  xE0
0FD14:  MOVLB  0
0FD16:  CALL   5032
0FD1A:  MOVFF  727,8CE
0FD1E:  MOVLW  01
0FD20:  MOVLB  8
0FD22:  MOVWF  xCF
0FD24:  MOVLB  0
0FD26:  CALL   5214
0FD2A:  MOVLW  3A
0FD2C:  MOVLB  8
0FD2E:  MOVWF  xE0
0FD30:  MOVLB  0
0FD32:  CALL   5032
0FD36:  MOVFF  726,8CE
0FD3A:  MOVLW  01
0FD3C:  MOVLB  8
0FD3E:  MOVWF  xCF
0FD40:  MOVLB  0
0FD42:  CALL   5214
0FD46:  MOVLW  3A
0FD48:  MOVLB  8
0FD4A:  MOVWF  xE0
0FD4C:  MOVLB  0
0FD4E:  CALL   5032
0FD52:  MOVFF  725,8CE
0FD56:  MOVLW  01
0FD58:  MOVLB  8
0FD5A:  MOVWF  xCF
0FD5C:  MOVLB  0
0FD5E:  CALL   5214
0FD62:  MOVLW  2C
0FD64:  MOVLB  8
0FD66:  MOVWF  xE0
0FD68:  MOVLB  0
0FD6A:  CALL   5032
0FD6E:  MOVLW  04
0FD70:  MOVWF  FE9
0FD72:  MOVLB  8
0FD74:  CLRF   xD1
0FD76:  CLRF   xD0
0FD78:  MOVFF  8A9,8CF
0FD7C:  MOVFF  8A8,8CE
0FD80:  MOVLW  02
0FD82:  MOVWF  xD2
0FD84:  MOVLB  0
0FD86:  CALL   52AE
0FD8A:  MOVLW  2C
0FD8C:  MOVLB  8
0FD8E:  MOVWF  xE0
0FD90:  MOVLB  0
0FD92:  CALL   5032
0FD96:  MOVFF  1E,FEA
0FD9A:  MOVFF  1D,FE9
0FD9E:  CLRF   FEF
0FDA0:  MOVLW  03
0FDA2:  MOVWF  FEA
0FDA4:  MOVLW  3D
0FDA6:  MOVWF  FE9
0FDA8:  RCALL  FA9E
0FDAA:  MOVLW  2C
0FDAC:  MOVLB  8
0FDAE:  MOVWF  xE0
0FDB0:  MOVLB  0
0FDB2:  CALL   5032
0FDB6:  MOVFF  1E,FEA
0FDBA:  MOVFF  1D,FE9
0FDBE:  CLRF   FEF
0FDC0:  MOVLW  03
0FDC2:  MOVWF  FEA
0FDC4:  MOVLW  42
0FDC6:  MOVWF  FE9
0FDC8:  RCALL  FA9E
0FDCA:  MOVLW  2C
0FDCC:  MOVLB  8
0FDCE:  MOVWF  xE0
0FDD0:  MOVLB  0
0FDD2:  CALL   5032
0FDD6:  MOVFF  1E,FEA
0FDDA:  MOVFF  1D,FE9
0FDDE:  CLRF   FEF
0FDE0:  MOVLW  03
0FDE2:  MOVWF  FEA
0FDE4:  MOVLW  46
0FDE6:  MOVWF  FE9
0FDE8:  RCALL  FA9E
0FDEA:  MOVLW  2C
0FDEC:  MOVLB  8
0FDEE:  MOVWF  xE0
0FDF0:  MOVLB  0
0FDF2:  CALL   5032
0FDF6:  MOVLW  10
0FDF8:  MOVWF  FE9
0FDFA:  MOVFF  26,8D8
0FDFE:  MOVFF  25,8D7
0FE02:  CALL   AA5A
0FE06:  MOVLW  2C
0FE08:  MOVLB  8
0FE0A:  MOVWF  xE0
0FE0C:  MOVLB  0
0FE0E:  CALL   5032
0FE12:  MOVLW  10
0FE14:  MOVWF  FE9
0FE16:  MOVFF  8AB,8D8
0FE1A:  MOVFF  8AA,8D7
0FE1E:  CALL   AA5A
0FE22:  MOVLW  2C
0FE24:  MOVLB  8
0FE26:  MOVWF  xE0
0FE28:  MOVLB  0
0FE2A:  CALL   5032
0FE2E:  MOVFF  4B5,8CE
0FE32:  MOVLW  1B
0FE34:  MOVLB  8
0FE36:  MOVWF  xCF
0FE38:  MOVLB  0
0FE3A:  CALL   5214
0FE3E:  MOVLW  2C
0FE40:  MOVLB  8
0FE42:  MOVWF  xE0
0FE44:  MOVLB  0
0FE46:  CALL   5032
0FE4A:  MOVLW  10
0FE4C:  MOVWF  FE9
0FE4E:  MOVFF  4A8,8D8
0FE52:  MOVFF  4A7,8D7
0FE56:  CALL   AA5A
0FE5A:  MOVLW  2C
0FE5C:  MOVLB  8
0FE5E:  MOVWF  xE0
0FE60:  MOVLB  0
0FE62:  CALL   5032
0FE66:  MOVLW  10
0FE68:  MOVWF  FE9
0FE6A:  MOVFF  4AE,8D8
0FE6E:  MOVFF  4AD,8D7
0FE72:  CALL   AA5A
0FE76:  MOVLW  2C
0FE78:  MOVLB  8
0FE7A:  MOVWF  xE0
0FE7C:  MOVLB  0
0FE7E:  CALL   5032
0FE82:  MOVLW  10
0FE84:  MOVWF  FE9
0FE86:  MOVFF  4AC,8D8
0FE8A:  MOVFF  4AB,8D7
0FE8E:  CALL   AA5A
0FE92:  MOVLW  0D
0FE94:  MOVLB  8
0FE96:  MOVWF  xE0
0FE98:  MOVLB  0
0FE9A:  CALL   5032
0FE9E:  MOVLW  0A
0FEA0:  MOVLB  8
0FEA2:  MOVWF  xE0
0FEA4:  MOVLB  0
0FEA6:  CALL   5032
....................  
....................    load_scanned_data();  
0FEAA:  BRA    FAFE
....................  
....................    display_rec(store, display); 
0FEAC:  MOVFF  8A5,8CC
0FEB0:  MOVFF  8A6,8CD
0FEB4:  RCALL  FBCC
....................     
....................    data_available = TRUE; 
0FEB6:  MOVLW  01
0FEB8:  MOVLB  3
0FEBA:  MOVWF  x3B
....................    macro_flag = 900; 
0FEBC:  MOVLW  03
0FEBE:  MOVWF  x24
0FEC0:  MOVLW  84
0FEC2:  MOVWF  x23
0FEC4:  MOVLB  0
0FEC6:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
0FEC8:  MOVLB  8
0FECA:  CLRF   x6C
0FECC:  CLRF   x6B
....................    channel=channel-20000; 
0FECE:  MOVLW  20
0FED0:  SUBWF  x68,F
0FED2:  MOVLW  4E
0FED4:  SUBWFB x69,F
....................     
....................    for (i=0; i<9; i++){ 
0FED6:  CLRF   x6A
0FED8:  MOVF   x6A,W
0FEDA:  SUBLW  08
0FEDC:  BNC   FF7E
....................       DAC_set(channel, setting); 
0FEDE:  MOVFF  868,8B4
0FEE2:  MOVFF  86C,8B6
0FEE6:  MOVFF  86B,8B5
0FEEA:  MOVLB  0
0FEEC:  CALL   F1E8
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
0FEF0:  MOVLW  36
0FEF2:  MOVWF  FF6
0FEF4:  MOVLW  1D
0FEF6:  MOVWF  FF7
0FEF8:  MOVLW  00
0FEFA:  MOVWF  FF8
0FEFC:  CLRF   1B
0FEFE:  BTFSC  FF2.7
0FF00:  BSF    1B.7
0FF02:  BCF    FF2.7
0FF04:  MOVLW  05
0FF06:  MOVLB  A
0FF08:  MOVWF  x1C
0FF0A:  MOVLB  0
0FF0C:  CALL   1024
0FF10:  BTFSC  1B.7
0FF12:  BSF    FF2.7
0FF14:  MOVLW  10
0FF16:  MOVWF  FE9
0FF18:  CLRF   1B
0FF1A:  BTFSC  FF2.7
0FF1C:  BSF    1B.7
0FF1E:  BCF    FF2.7
0FF20:  MOVFF  869,A1D
0FF24:  MOVFF  868,A1C
0FF28:  CALL   11A6
0FF2C:  BTFSC  1B.7
0FF2E:  BSF    FF2.7
0FF30:  MOVLW  2C
0FF32:  BTFSS  F9E.4
0FF34:  BRA    FF32
0FF36:  MOVWF  FAD
0FF38:  MOVLW  10
0FF3A:  MOVWF  FE9
0FF3C:  CLRF   1B
0FF3E:  BTFSC  FF2.7
0FF40:  BSF    1B.7
0FF42:  BCF    FF2.7
0FF44:  MOVFF  86C,A1D
0FF48:  MOVFF  86B,A1C
0FF4C:  CALL   11A6
0FF50:  BTFSC  1B.7
0FF52:  BSF    FF2.7
0FF54:  MOVLW  2C
0FF56:  BTFSS  F9E.4
0FF58:  BRA    FF56
0FF5A:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
0FF5C:  MOVLB  8
0FF5E:  CLRF   xA4
0FF60:  MOVLW  C8
0FF62:  MOVWF  xA3
0FF64:  CLRF   xA5
0FF66:  MOVLW  01
0FF68:  MOVWF  xA6
0FF6A:  MOVWF  xA7
0FF6C:  MOVLB  0
0FF6E:  RCALL  FC6A
....................       setting = setting+500; 
0FF70:  MOVLW  F4
0FF72:  MOVLB  8
0FF74:  ADDWF  x6B,F
0FF76:  MOVLW  01
0FF78:  ADDWFC x6C,F
0FF7A:  INCF   x6A,F
0FF7C:  BRA    FED8
....................    } 
0FF7E:  MOVLB  0
0FF80:  GOTO   10162 (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
*
10000:  MOVLB  8
10002:  CLRF   x68
10004:  CLRF   x67
....................     
....................    for (i=0; i<9; i++){ 
10006:  CLRF   x66
10008:  MOVF   x66,W
1000A:  SUBLW  08
1000C:  BTFSS  FD8.0
1000E:  GOTO   10090
....................       LED_SAR(intensity); 
10012:  MOVFF  868,8AA
10016:  MOVFF  867,8A9
1001A:  MOVLB  0
1001C:  CALL   F48C
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
10020:  MOVLW  44
10022:  MOVWF  FF6
10024:  MOVLW  1D
10026:  MOVWF  FF7
10028:  MOVLW  00
1002A:  MOVWF  FF8
1002C:  CLRF   1B
1002E:  BTFSC  FF2.7
10030:  BSF    1B.7
10032:  BCF    FF2.7
10034:  MOVLW  07
10036:  MOVLB  A
10038:  MOVWF  x1C
1003A:  MOVLB  0
1003C:  CALL   1024
10040:  BTFSC  1B.7
10042:  BSF    FF2.7
10044:  MOVLW  10
10046:  MOVWF  FE9
10048:  CLRF   1B
1004A:  BTFSC  FF2.7
1004C:  BSF    1B.7
1004E:  BCF    FF2.7
10050:  MOVFF  868,A1D
10054:  MOVFF  867,A1C
10058:  CALL   11A6
1005C:  BTFSC  1B.7
1005E:  BSF    FF2.7
10060:  MOVLW  2C
10062:  BTFSS  F9E.4
10064:  GOTO   10062
10068:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
1006A:  MOVLB  8
1006C:  CLRF   xA4
1006E:  MOVLW  C8
10070:  MOVWF  xA3
10072:  CLRF   xA5
10074:  MOVLW  01
10076:  MOVWF  xA6
10078:  MOVWF  xA7
1007A:  MOVLB  0
1007C:  CALL   FC6A
....................       intensity = intensity+500; 
10080:  MOVLW  F4
10082:  MOVLB  8
10084:  ADDWF  x67,F
10086:  MOVLW  01
10088:  ADDWFC x68,F
1008A:  INCF   x66,F
1008C:  GOTO   10008
....................    } 
10090:  MOVLB  0
10092:  GOTO   10162 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
03056:  MOVLB  8
03058:  CLRF   x97
0305A:  MOVF   x97,W
0305C:  SUBLW  20
0305E:  BNC   3074
03060:  CLRF   03
03062:  MOVF   x97,W
03064:  ADDLW  B7
03066:  MOVWF  FE9
03068:  MOVLW  04
0306A:  ADDWFC 03,W
0306C:  MOVWF  FEA
0306E:  CLRF   FEF
03070:  INCF   x97,F
03072:  BRA    305A
03074:  MOVLB  0
03076:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
03078:  MOVF   2F,W
0307A:  SUBLW  02
0307C:  BNZ   3086
0307E:  MOVF   30,F
03080:  BNZ   3086
03082:  MOVLW  00
03084:  MOVWF  F99
....................    init_valve_status(); 
03086:  RCALL  3056
....................    bus_pwr_status=0; 
03088:  MOVLB  4
0308A:  CLRF   xB6
0308C:  MOVLB  0
0308E:  GOTO   1B4DA (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0E9D6:  MOVLW  50
0E9D8:  MOVWF  FF6
0E9DA:  MOVLW  1D
0E9DC:  MOVWF  FF7
0E9DE:  MOVLW  00
0E9E0:  MOVWF  FF8
0E9E2:  CLRF   1B
0E9E4:  BTFSC  FF2.7
0E9E6:  BSF    1B.7
0E9E8:  BCF    FF2.7
0E9EA:  CALL   0E4E
0E9EE:  BTFSC  1B.7
0E9F0:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0E9F2:  MOVLW  01
0E9F4:  MOVLB  8
0E9F6:  MOVWF  x97
0E9F8:  MOVF   x97,W
0E9FA:  SUBLW  08
0E9FC:  BNC   EA66
0E9FE:  CLRF   03
0EA00:  MOVF   x97,W
0EA02:  ADDLW  B7
0EA04:  MOVWF  FE9
0EA06:  MOVLW  04
0EA08:  ADDWFC 03,W
0EA0A:  MOVWF  FEA
0EA0C:  MOVFF  FEF,898
0EA10:  CLRF   1B
0EA12:  BTFSC  FF2.7
0EA14:  BSF    1B.7
0EA16:  BCF    FF2.7
0EA18:  MOVFF  897,A1C
0EA1C:  MOVLW  01
0EA1E:  MOVLB  A
0EA20:  MOVWF  x1D
0EA22:  MOVLB  0
0EA24:  CALL   0FA6
0EA28:  BTFSC  1B.7
0EA2A:  BSF    FF2.7
0EA2C:  MOVLW  5B
0EA2E:  BTFSS  F9E.4
0EA30:  BRA    EA2E
0EA32:  MOVWF  FAD
0EA34:  CLRF   1B
0EA36:  BTFSC  FF2.7
0EA38:  BSF    1B.7
0EA3A:  BCF    FF2.7
0EA3C:  MOVFF  898,A1C
0EA40:  MOVLW  1B
0EA42:  MOVLB  A
0EA44:  MOVWF  x1D
0EA46:  MOVLB  0
0EA48:  CALL   0FA6
0EA4C:  BTFSC  1B.7
0EA4E:  BSF    FF2.7
0EA50:  MOVLW  5D
0EA52:  BTFSS  F9E.4
0EA54:  BRA    EA52
0EA56:  MOVWF  FAD
0EA58:  MOVLW  20
0EA5A:  BTFSS  F9E.4
0EA5C:  BRA    EA5A
0EA5E:  MOVWF  FAD
0EA60:  MOVLB  8
0EA62:  INCF   x97,F
0EA64:  BRA    E9F8
....................    fprintf(COM_A, "\r\n"); 
0EA66:  MOVLW  0D
0EA68:  BTFSS  F9E.4
0EA6A:  BRA    EA68
0EA6C:  MOVWF  FAD
0EA6E:  MOVLW  0A
0EA70:  BTFSS  F9E.4
0EA72:  BRA    EA70
0EA74:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EA76:  MOVLW  56
0EA78:  MOVWF  FF6
0EA7A:  MOVLW  1D
0EA7C:  MOVWF  FF7
0EA7E:  MOVLW  00
0EA80:  MOVWF  FF8
0EA82:  CLRF   1B
0EA84:  BTFSC  FF2.7
0EA86:  BSF    1B.7
0EA88:  BCF    FF2.7
0EA8A:  MOVLB  0
0EA8C:  CALL   0E4E
0EA90:  BTFSC  1B.7
0EA92:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EA94:  MOVLW  09
0EA96:  MOVLB  8
0EA98:  MOVWF  x97
0EA9A:  MOVF   x97,W
0EA9C:  SUBLW  10
0EA9E:  BNC   EB08
0EAA0:  CLRF   03
0EAA2:  MOVF   x97,W
0EAA4:  ADDLW  B7
0EAA6:  MOVWF  FE9
0EAA8:  MOVLW  04
0EAAA:  ADDWFC 03,W
0EAAC:  MOVWF  FEA
0EAAE:  MOVFF  FEF,898
0EAB2:  CLRF   1B
0EAB4:  BTFSC  FF2.7
0EAB6:  BSF    1B.7
0EAB8:  BCF    FF2.7
0EABA:  MOVFF  897,A1C
0EABE:  MOVLW  01
0EAC0:  MOVLB  A
0EAC2:  MOVWF  x1D
0EAC4:  MOVLB  0
0EAC6:  CALL   0FA6
0EACA:  BTFSC  1B.7
0EACC:  BSF    FF2.7
0EACE:  MOVLW  5B
0EAD0:  BTFSS  F9E.4
0EAD2:  BRA    EAD0
0EAD4:  MOVWF  FAD
0EAD6:  CLRF   1B
0EAD8:  BTFSC  FF2.7
0EADA:  BSF    1B.7
0EADC:  BCF    FF2.7
0EADE:  MOVFF  898,A1C
0EAE2:  MOVLW  1B
0EAE4:  MOVLB  A
0EAE6:  MOVWF  x1D
0EAE8:  MOVLB  0
0EAEA:  CALL   0FA6
0EAEE:  BTFSC  1B.7
0EAF0:  BSF    FF2.7
0EAF2:  MOVLW  5D
0EAF4:  BTFSS  F9E.4
0EAF6:  BRA    EAF4
0EAF8:  MOVWF  FAD
0EAFA:  MOVLW  20
0EAFC:  BTFSS  F9E.4
0EAFE:  BRA    EAFC
0EB00:  MOVWF  FAD
0EB02:  MOVLB  8
0EB04:  INCF   x97,F
0EB06:  BRA    EA9A
....................    fprintf(COM_A, "\r\n"); 
0EB08:  MOVLW  0D
0EB0A:  BTFSS  F9E.4
0EB0C:  BRA    EB0A
0EB0E:  MOVWF  FAD
0EB10:  MOVLW  0A
0EB12:  BTFSS  F9E.4
0EB14:  BRA    EB12
0EB16:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EB18:  MOVLW  5C
0EB1A:  MOVWF  FF6
0EB1C:  MOVLW  1D
0EB1E:  MOVWF  FF7
0EB20:  MOVLW  00
0EB22:  MOVWF  FF8
0EB24:  CLRF   1B
0EB26:  BTFSC  FF2.7
0EB28:  BSF    1B.7
0EB2A:  BCF    FF2.7
0EB2C:  MOVLB  0
0EB2E:  CALL   0E4E
0EB32:  BTFSC  1B.7
0EB34:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EB36:  MOVLW  11
0EB38:  MOVLB  8
0EB3A:  MOVWF  x97
0EB3C:  MOVF   x97,W
0EB3E:  SUBLW  18
0EB40:  BNC   EBAA
0EB42:  CLRF   03
0EB44:  MOVF   x97,W
0EB46:  ADDLW  B7
0EB48:  MOVWF  FE9
0EB4A:  MOVLW  04
0EB4C:  ADDWFC 03,W
0EB4E:  MOVWF  FEA
0EB50:  MOVFF  FEF,898
0EB54:  CLRF   1B
0EB56:  BTFSC  FF2.7
0EB58:  BSF    1B.7
0EB5A:  BCF    FF2.7
0EB5C:  MOVFF  897,A1C
0EB60:  MOVLW  01
0EB62:  MOVLB  A
0EB64:  MOVWF  x1D
0EB66:  MOVLB  0
0EB68:  CALL   0FA6
0EB6C:  BTFSC  1B.7
0EB6E:  BSF    FF2.7
0EB70:  MOVLW  5B
0EB72:  BTFSS  F9E.4
0EB74:  BRA    EB72
0EB76:  MOVWF  FAD
0EB78:  CLRF   1B
0EB7A:  BTFSC  FF2.7
0EB7C:  BSF    1B.7
0EB7E:  BCF    FF2.7
0EB80:  MOVFF  898,A1C
0EB84:  MOVLW  1B
0EB86:  MOVLB  A
0EB88:  MOVWF  x1D
0EB8A:  MOVLB  0
0EB8C:  CALL   0FA6
0EB90:  BTFSC  1B.7
0EB92:  BSF    FF2.7
0EB94:  MOVLW  5D
0EB96:  BTFSS  F9E.4
0EB98:  BRA    EB96
0EB9A:  MOVWF  FAD
0EB9C:  MOVLW  20
0EB9E:  BTFSS  F9E.4
0EBA0:  BRA    EB9E
0EBA2:  MOVWF  FAD
0EBA4:  MOVLB  8
0EBA6:  INCF   x97,F
0EBA8:  BRA    EB3C
....................    fprintf(COM_A, "\r\n"); 
0EBAA:  MOVLW  0D
0EBAC:  BTFSS  F9E.4
0EBAE:  BRA    EBAC
0EBB0:  MOVWF  FAD
0EBB2:  MOVLW  0A
0EBB4:  BTFSS  F9E.4
0EBB6:  BRA    EBB4
0EBB8:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EBBA:  MOVLW  62
0EBBC:  MOVWF  FF6
0EBBE:  MOVLW  1D
0EBC0:  MOVWF  FF7
0EBC2:  MOVLW  00
0EBC4:  MOVWF  FF8
0EBC6:  CLRF   1B
0EBC8:  BTFSC  FF2.7
0EBCA:  BSF    1B.7
0EBCC:  BCF    FF2.7
0EBCE:  MOVLB  0
0EBD0:  CALL   0E4E
0EBD4:  BTFSC  1B.7
0EBD6:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EBD8:  MOVLW  19
0EBDA:  MOVLB  8
0EBDC:  MOVWF  x97
0EBDE:  MOVF   x97,W
0EBE0:  SUBLW  20
0EBE2:  BNC   EC4C
0EBE4:  CLRF   03
0EBE6:  MOVF   x97,W
0EBE8:  ADDLW  B7
0EBEA:  MOVWF  FE9
0EBEC:  MOVLW  04
0EBEE:  ADDWFC 03,W
0EBF0:  MOVWF  FEA
0EBF2:  MOVFF  FEF,898
0EBF6:  CLRF   1B
0EBF8:  BTFSC  FF2.7
0EBFA:  BSF    1B.7
0EBFC:  BCF    FF2.7
0EBFE:  MOVFF  897,A1C
0EC02:  MOVLW  01
0EC04:  MOVLB  A
0EC06:  MOVWF  x1D
0EC08:  MOVLB  0
0EC0A:  CALL   0FA6
0EC0E:  BTFSC  1B.7
0EC10:  BSF    FF2.7
0EC12:  MOVLW  5B
0EC14:  BTFSS  F9E.4
0EC16:  BRA    EC14
0EC18:  MOVWF  FAD
0EC1A:  CLRF   1B
0EC1C:  BTFSC  FF2.7
0EC1E:  BSF    1B.7
0EC20:  BCF    FF2.7
0EC22:  MOVFF  898,A1C
0EC26:  MOVLW  1B
0EC28:  MOVLB  A
0EC2A:  MOVWF  x1D
0EC2C:  MOVLB  0
0EC2E:  CALL   0FA6
0EC32:  BTFSC  1B.7
0EC34:  BSF    FF2.7
0EC36:  MOVLW  5D
0EC38:  BTFSS  F9E.4
0EC3A:  BRA    EC38
0EC3C:  MOVWF  FAD
0EC3E:  MOVLW  20
0EC40:  BTFSS  F9E.4
0EC42:  BRA    EC40
0EC44:  MOVWF  FAD
0EC46:  MOVLB  8
0EC48:  INCF   x97,F
0EC4A:  BRA    EBDE
....................    fprintf(COM_A, "\r\n");    
0EC4C:  MOVLW  0D
0EC4E:  BTFSS  F9E.4
0EC50:  BRA    EC4E
0EC52:  MOVWF  FAD
0EC54:  MOVLW  0A
0EC56:  BTFSS  F9E.4
0EC58:  BRA    EC56
0EC5A:  MOVWF  FAD
0EC5C:  MOVLB  0
0EC5E:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
14064:  MOVF   1F,W
14066:  SUBLW  04
14068:  BNZ   140D2
1406A:  MOVF   20,F
1406C:  BNZ   140D2
1406E:  MOVLW  68
14070:  MOVWF  FF6
14072:  MOVLW  1D
14074:  MOVWF  FF7
14076:  MOVLW  00
14078:  MOVWF  FF8
1407A:  CLRF   1B
1407C:  BTFSC  FF2.7
1407E:  BSF    1B.7
14080:  BCF    FF2.7
14082:  MOVLW  0C
14084:  MOVLB  A
14086:  MOVWF  x1C
14088:  MOVLB  0
1408A:  CALL   1024
1408E:  BTFSC  1B.7
14090:  BSF    FF2.7
14092:  MOVLW  10
14094:  MOVWF  FE9
14096:  CLRF   1B
14098:  BTFSC  FF2.7
1409A:  BSF    1B.7
1409C:  BCF    FF2.7
1409E:  MOVFF  898,A1D
140A2:  MOVFF  897,A1C
140A6:  CALL   11A6
140AA:  BTFSC  1B.7
140AC:  BSF    FF2.7
140AE:  MOVLW  77
140B0:  MOVWF  FF6
140B2:  MOVLW  1D
140B4:  MOVWF  FF7
140B6:  MOVLW  00
140B8:  MOVWF  FF8
140BA:  CLRF   1B
140BC:  BTFSC  FF2.7
140BE:  BSF    1B.7
140C0:  BCF    FF2.7
140C2:  MOVLW  03
140C4:  MOVLB  A
140C6:  MOVWF  x1C
140C8:  MOVLB  0
140CA:  CALL   1024
140CE:  BTFSC  1B.7
140D0:  BSF    FF2.7
....................  
....................    multidrop_on(); 
140D2:  CALL   D6E8
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
140D6:  MOVLW  7C
140D8:  MOVWF  FF6
140DA:  MOVLW  1D
140DC:  MOVWF  FF7
140DE:  MOVLW  00
140E0:  MOVWF  FF8
140E2:  MOVLW  03
140E4:  MOVLB  8
140E6:  MOVWF  x99
140E8:  MOVLB  0
140EA:  CALL   D6FC
140EE:  MOVLW  10
140F0:  MOVWF  FE9
140F2:  MOVFF  898,89A
140F6:  MOVFF  897,899
140FA:  BRA    13FAA
140FC:  MOVLW  0D
140FE:  BTFSS  FA4.4
14100:  BRA    140FE
14102:  MOVLB  F
14104:  MOVWF  x1C
....................    multidrop_off(); 
14106:  MOVLB  0
14108:  CALL   D7D4
....................  
....................    delay_ms(100); 
1410C:  MOVLW  64
1410E:  MOVLB  9
14110:  MOVWF  xCD
14112:  MOVLB  0
14114:  CALL   28AC
14118:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0D826:  MOVF   1F,W
0D828:  SUBLW  04
0D82A:  BNZ   D894
0D82C:  MOVF   20,F
0D82E:  BNZ   D894
0D830:  MOVLW  84
0D832:  MOVWF  FF6
0D834:  MOVLW  1D
0D836:  MOVWF  FF7
0D838:  MOVLW  00
0D83A:  MOVWF  FF8
0D83C:  CLRF   1B
0D83E:  BTFSC  FF2.7
0D840:  BSF    1B.7
0D842:  BCF    FF2.7
0D844:  MOVLW  0C
0D846:  MOVLB  A
0D848:  MOVWF  x1C
0D84A:  MOVLB  0
0D84C:  CALL   1024
0D850:  BTFSC  1B.7
0D852:  BSF    FF2.7
0D854:  CLRF   1B
0D856:  BTFSC  FF2.7
0D858:  BSF    1B.7
0D85A:  BCF    FF2.7
0D85C:  MOVFF  897,A1C
0D860:  MOVLW  1B
0D862:  MOVLB  A
0D864:  MOVWF  x1D
0D866:  MOVLB  0
0D868:  CALL   0FA6
0D86C:  BTFSC  1B.7
0D86E:  BSF    FF2.7
0D870:  MOVLW  92
0D872:  MOVWF  FF6
0D874:  MOVLW  1D
0D876:  MOVWF  FF7
0D878:  MOVLW  00
0D87A:  MOVWF  FF8
0D87C:  CLRF   1B
0D87E:  BTFSC  FF2.7
0D880:  BSF    1B.7
0D882:  BCF    FF2.7
0D884:  MOVLW  03
0D886:  MOVLB  A
0D888:  MOVWF  x1C
0D88A:  MOVLB  0
0D88C:  CALL   1024
0D890:  BTFSC  1B.7
0D892:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0D894:  RCALL  D6E8
....................       fprintf(COM_B, "/1c%u\r",chip); 
0D896:  MOVLW  96
0D898:  MOVWF  FF6
0D89A:  MOVLW  1D
0D89C:  MOVWF  FF7
0D89E:  MOVLW  00
0D8A0:  MOVWF  FF8
0D8A2:  MOVLW  03
0D8A4:  MOVLB  8
0D8A6:  MOVWF  x99
0D8A8:  MOVLB  0
0D8AA:  RCALL  D6FC
0D8AC:  MOVFF  897,8D4
0D8B0:  MOVLW  1B
0D8B2:  MOVLB  8
0D8B4:  MOVWF  xD5
0D8B6:  MOVLB  0
0D8B8:  RCALL  D730
0D8BA:  MOVLW  0D
0D8BC:  BTFSS  FA4.4
0D8BE:  BRA    D8BC
0D8C0:  MOVLB  F
0D8C2:  MOVWF  x1C
....................    multidrop_off(); 
0D8C4:  MOVLB  0
0D8C6:  RCALL  D7D4
....................    delay_ms(100); 
0D8C8:  MOVLW  64
0D8CA:  MOVLB  9
0D8CC:  MOVWF  xCD
0D8CE:  MOVLB  0
0D8D0:  CALL   28AC
....................  
....................    multidrop_on(); 
0D8D4:  RCALL  D6E8
....................      fprintf(COM_B, "/1s256\r"); 
0D8D6:  MOVLW  9E
0D8D8:  MOVWF  FF6
0D8DA:  MOVLW  1D
0D8DC:  MOVWF  FF7
0D8DE:  MOVLW  00
0D8E0:  MOVWF  FF8
0D8E2:  BRA    D7F6
....................    multidrop_off();  
0D8E4:  RCALL  D7D4
....................    delay_ms(100); 
0D8E6:  MOVLW  64
0D8E8:  MOVLB  9
0D8EA:  MOVWF  xCD
0D8EC:  MOVLB  0
0D8EE:  CALL   28AC
0D8F2:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
1411A:  MOVLB  8
1411C:  MOVF   x96,W
1411E:  ADDLW  DF
14120:  BTFSC  FD8.0
14122:  BRA    1450E
14124:  ADDLW  21
14126:  MOVLB  0
14128:  GOTO   14540
....................       case 0 : sol_chip_cmd(1); 
1412C:  MOVLW  01
1412E:  MOVLB  8
14130:  MOVWF  x97
14132:  MOVLB  0
14134:  CALL   D826
....................                sol_switch_cmd(0); 
14138:  MOVLB  8
1413A:  CLRF   x98
1413C:  CLRF   x97
1413E:  MOVLB  0
14140:  RCALL  14064
....................                sol_chip_cmd(2); 
14142:  MOVLW  02
14144:  MOVLB  8
14146:  MOVWF  x97
14148:  MOVLB  0
1414A:  CALL   D826
....................                sol_switch_cmd(0); 
1414E:  MOVLB  8
14150:  CLRF   x98
14152:  CLRF   x97
14154:  MOVLB  0
14156:  RCALL  14064
....................                sol_chip_cmd(3); 
14158:  MOVLW  03
1415A:  MOVLB  8
1415C:  MOVWF  x97
1415E:  MOVLB  0
14160:  CALL   D826
....................                sol_switch_cmd(0); 
14164:  MOVLB  8
14166:  CLRF   x98
14168:  CLRF   x97
1416A:  MOVLB  0
1416C:  RCALL  14064
....................                sol_chip_cmd(4); 
1416E:  MOVLW  04
14170:  MOVLB  8
14172:  MOVWF  x97
14174:  MOVLB  0
14176:  CALL   D826
....................                sol_switch_cmd(0); 
1417A:  MOVLB  8
1417C:  CLRF   x98
1417E:  CLRF   x97
14180:  MOVLB  0
14182:  RCALL  14064
....................                init_valve_status(); 
14184:  CALL   3056
....................          break; 
14188:  MOVLB  8
1418A:  BRA    1450E
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
1418C:  MOVLW  01
1418E:  MOVLB  8
14190:  MOVWF  x97
14192:  MOVLB  0
14194:  CALL   D826
....................                sol_switch_cmd(1); 
14198:  MOVLB  8
1419A:  CLRF   x98
1419C:  MOVLW  01
1419E:  MOVWF  x97
141A0:  MOVLB  0
141A2:  RCALL  14064
....................          break;     
141A4:  MOVLB  8
141A6:  BRA    1450E
....................       case 2 : sol_chip_cmd(1); 
141A8:  MOVLW  01
141AA:  MOVLB  8
141AC:  MOVWF  x97
141AE:  MOVLB  0
141B0:  CALL   D826
....................                sol_switch_cmd(2); 
141B4:  MOVLB  8
141B6:  CLRF   x98
141B8:  MOVLW  02
141BA:  MOVWF  x97
141BC:  MOVLB  0
141BE:  RCALL  14064
....................          break;           
141C0:  MOVLB  8
141C2:  BRA    1450E
....................       case 3 : sol_chip_cmd(1); 
141C4:  MOVLW  01
141C6:  MOVLB  8
141C8:  MOVWF  x97
141CA:  MOVLB  0
141CC:  CALL   D826
....................                sol_switch_cmd(4); 
141D0:  MOVLB  8
141D2:  CLRF   x98
141D4:  MOVLW  04
141D6:  MOVWF  x97
141D8:  MOVLB  0
141DA:  RCALL  14064
....................          break;  
141DC:  MOVLB  8
141DE:  BRA    1450E
....................       case 4 : sol_chip_cmd(1); 
141E0:  MOVLW  01
141E2:  MOVLB  8
141E4:  MOVWF  x97
141E6:  MOVLB  0
141E8:  CALL   D826
....................                sol_switch_cmd(8); 
141EC:  MOVLB  8
141EE:  CLRF   x98
141F0:  MOVLW  08
141F2:  MOVWF  x97
141F4:  MOVLB  0
141F6:  RCALL  14064
....................          break;  
141F8:  MOVLB  8
141FA:  BRA    1450E
....................       case 5 : sol_chip_cmd(1); 
141FC:  MOVLW  01
141FE:  MOVLB  8
14200:  MOVWF  x97
14202:  MOVLB  0
14204:  CALL   D826
....................                sol_switch_cmd(16); 
14208:  MOVLB  8
1420A:  CLRF   x98
1420C:  MOVLW  10
1420E:  MOVWF  x97
14210:  MOVLB  0
14212:  RCALL  14064
....................          break;  
14214:  MOVLB  8
14216:  BRA    1450E
....................       case 6 : sol_chip_cmd(1); 
14218:  MOVLW  01
1421A:  MOVLB  8
1421C:  MOVWF  x97
1421E:  MOVLB  0
14220:  CALL   D826
....................                sol_switch_cmd(32); 
14224:  MOVLB  8
14226:  CLRF   x98
14228:  MOVLW  20
1422A:  MOVWF  x97
1422C:  MOVLB  0
1422E:  RCALL  14064
....................          break;  
14230:  MOVLB  8
14232:  BRA    1450E
....................       case 7 : sol_chip_cmd(1); 
14234:  MOVLW  01
14236:  MOVLB  8
14238:  MOVWF  x97
1423A:  MOVLB  0
1423C:  CALL   D826
....................                sol_switch_cmd(64); 
14240:  MOVLB  8
14242:  CLRF   x98
14244:  MOVLW  40
14246:  MOVWF  x97
14248:  MOVLB  0
1424A:  RCALL  14064
....................          break;  
1424C:  MOVLB  8
1424E:  BRA    1450E
....................       case 8 : sol_chip_cmd(1); 
14250:  MOVLW  01
14252:  MOVLB  8
14254:  MOVWF  x97
14256:  MOVLB  0
14258:  CALL   D826
....................                sol_switch_cmd(128); 
1425C:  MOVLB  8
1425E:  CLRF   x98
14260:  MOVLW  80
14262:  MOVWF  x97
14264:  MOVLB  0
14266:  RCALL  14064
....................          break;   
14268:  MOVLB  8
1426A:  BRA    1450E
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
1426C:  MOVLW  02
1426E:  MOVLB  8
14270:  MOVWF  x97
14272:  MOVLB  0
14274:  CALL   D826
....................                sol_switch_cmd(1); 
14278:  MOVLB  8
1427A:  CLRF   x98
1427C:  MOVLW  01
1427E:  MOVWF  x97
14280:  MOVLB  0
14282:  RCALL  14064
....................          break;     
14284:  MOVLB  8
14286:  BRA    1450E
....................       case 10 : sol_chip_cmd(2); 
14288:  MOVLW  02
1428A:  MOVLB  8
1428C:  MOVWF  x97
1428E:  MOVLB  0
14290:  CALL   D826
....................                sol_switch_cmd(2); 
14294:  MOVLB  8
14296:  CLRF   x98
14298:  MOVLW  02
1429A:  MOVWF  x97
1429C:  MOVLB  0
1429E:  RCALL  14064
....................          break;           
142A0:  MOVLB  8
142A2:  BRA    1450E
....................       case 11 : sol_chip_cmd(2); 
142A4:  MOVLW  02
142A6:  MOVLB  8
142A8:  MOVWF  x97
142AA:  MOVLB  0
142AC:  CALL   D826
....................                sol_switch_cmd(4); 
142B0:  MOVLB  8
142B2:  CLRF   x98
142B4:  MOVLW  04
142B6:  MOVWF  x97
142B8:  MOVLB  0
142BA:  RCALL  14064
....................          break;  
142BC:  MOVLB  8
142BE:  BRA    1450E
....................       case 12 : sol_chip_cmd(2); 
142C0:  MOVLW  02
142C2:  MOVLB  8
142C4:  MOVWF  x97
142C6:  MOVLB  0
142C8:  CALL   D826
....................                sol_switch_cmd(8); 
142CC:  MOVLB  8
142CE:  CLRF   x98
142D0:  MOVLW  08
142D2:  MOVWF  x97
142D4:  MOVLB  0
142D6:  RCALL  14064
....................          break;  
142D8:  MOVLB  8
142DA:  BRA    1450E
....................       case 13 : sol_chip_cmd(2); 
142DC:  MOVLW  02
142DE:  MOVLB  8
142E0:  MOVWF  x97
142E2:  MOVLB  0
142E4:  CALL   D826
....................                sol_switch_cmd(16); 
142E8:  MOVLB  8
142EA:  CLRF   x98
142EC:  MOVLW  10
142EE:  MOVWF  x97
142F0:  MOVLB  0
142F2:  RCALL  14064
....................          break;  
142F4:  MOVLB  8
142F6:  BRA    1450E
....................       case 14 : sol_chip_cmd(2); 
142F8:  MOVLW  02
142FA:  MOVLB  8
142FC:  MOVWF  x97
142FE:  MOVLB  0
14300:  CALL   D826
....................                sol_switch_cmd(32); 
14304:  MOVLB  8
14306:  CLRF   x98
14308:  MOVLW  20
1430A:  MOVWF  x97
1430C:  MOVLB  0
1430E:  RCALL  14064
....................          break;  
14310:  MOVLB  8
14312:  BRA    1450E
....................       case 15 : sol_chip_cmd(2); 
14314:  MOVLW  02
14316:  MOVLB  8
14318:  MOVWF  x97
1431A:  MOVLB  0
1431C:  CALL   D826
....................                sol_switch_cmd(64); 
14320:  MOVLB  8
14322:  CLRF   x98
14324:  MOVLW  40
14326:  MOVWF  x97
14328:  MOVLB  0
1432A:  RCALL  14064
....................          break;  
1432C:  MOVLB  8
1432E:  BRA    1450E
....................       case 16 : sol_chip_cmd(2); 
14330:  MOVLW  02
14332:  MOVLB  8
14334:  MOVWF  x97
14336:  MOVLB  0
14338:  CALL   D826
....................                sol_switch_cmd(128); 
1433C:  MOVLB  8
1433E:  CLRF   x98
14340:  MOVLW  80
14342:  MOVWF  x97
14344:  MOVLB  0
14346:  RCALL  14064
....................          break;   
14348:  MOVLB  8
1434A:  BRA    1450E
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
1434C:  MOVLW  03
1434E:  MOVLB  8
14350:  MOVWF  x97
14352:  MOVLB  0
14354:  CALL   D826
....................                sol_switch_cmd(1); 
14358:  MOVLB  8
1435A:  CLRF   x98
1435C:  MOVLW  01
1435E:  MOVWF  x97
14360:  MOVLB  0
14362:  RCALL  14064
....................          break;     
14364:  MOVLB  8
14366:  BRA    1450E
....................       case 18 : sol_chip_cmd(3); 
14368:  MOVLW  03
1436A:  MOVLB  8
1436C:  MOVWF  x97
1436E:  MOVLB  0
14370:  CALL   D826
....................                sol_switch_cmd(2); 
14374:  MOVLB  8
14376:  CLRF   x98
14378:  MOVLW  02
1437A:  MOVWF  x97
1437C:  MOVLB  0
1437E:  RCALL  14064
....................          break;           
14380:  MOVLB  8
14382:  BRA    1450E
....................       case 19 : sol_chip_cmd(3); 
14384:  MOVLW  03
14386:  MOVLB  8
14388:  MOVWF  x97
1438A:  MOVLB  0
1438C:  CALL   D826
....................                sol_switch_cmd(4); 
14390:  MOVLB  8
14392:  CLRF   x98
14394:  MOVLW  04
14396:  MOVWF  x97
14398:  MOVLB  0
1439A:  RCALL  14064
....................          break;  
1439C:  MOVLB  8
1439E:  BRA    1450E
....................       case 20 : sol_chip_cmd(3); 
143A0:  MOVLW  03
143A2:  MOVLB  8
143A4:  MOVWF  x97
143A6:  MOVLB  0
143A8:  CALL   D826
....................                sol_switch_cmd(8); 
143AC:  MOVLB  8
143AE:  CLRF   x98
143B0:  MOVLW  08
143B2:  MOVWF  x97
143B4:  MOVLB  0
143B6:  RCALL  14064
....................          break;  
143B8:  MOVLB  8
143BA:  BRA    1450E
....................       case 21 : sol_chip_cmd(3); 
143BC:  MOVLW  03
143BE:  MOVLB  8
143C0:  MOVWF  x97
143C2:  MOVLB  0
143C4:  CALL   D826
....................                sol_switch_cmd(16); 
143C8:  MOVLB  8
143CA:  CLRF   x98
143CC:  MOVLW  10
143CE:  MOVWF  x97
143D0:  MOVLB  0
143D2:  RCALL  14064
....................          break;  
143D4:  MOVLB  8
143D6:  BRA    1450E
....................       case 22 : sol_chip_cmd(3); 
143D8:  MOVLW  03
143DA:  MOVLB  8
143DC:  MOVWF  x97
143DE:  MOVLB  0
143E0:  CALL   D826
....................                sol_switch_cmd(32); 
143E4:  MOVLB  8
143E6:  CLRF   x98
143E8:  MOVLW  20
143EA:  MOVWF  x97
143EC:  MOVLB  0
143EE:  RCALL  14064
....................          break;  
143F0:  MOVLB  8
143F2:  BRA    1450E
....................       case 23 : sol_chip_cmd(3); 
143F4:  MOVLW  03
143F6:  MOVLB  8
143F8:  MOVWF  x97
143FA:  MOVLB  0
143FC:  CALL   D826
....................                sol_switch_cmd(64); 
14400:  MOVLB  8
14402:  CLRF   x98
14404:  MOVLW  40
14406:  MOVWF  x97
14408:  MOVLB  0
1440A:  RCALL  14064
....................          break;  
1440C:  MOVLB  8
1440E:  BRA    1450E
....................       case 24 : sol_chip_cmd(3); 
14410:  MOVLW  03
14412:  MOVLB  8
14414:  MOVWF  x97
14416:  MOVLB  0
14418:  CALL   D826
....................                sol_switch_cmd(128); 
1441C:  MOVLB  8
1441E:  CLRF   x98
14420:  MOVLW  80
14422:  MOVWF  x97
14424:  MOVLB  0
14426:  RCALL  14064
....................          break;      
14428:  MOVLB  8
1442A:  BRA    1450E
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
1442C:  MOVLW  04
1442E:  MOVLB  8
14430:  MOVWF  x97
14432:  MOVLB  0
14434:  CALL   D826
....................                sol_switch_cmd(1); 
14438:  MOVLB  8
1443A:  CLRF   x98
1443C:  MOVLW  01
1443E:  MOVWF  x97
14440:  MOVLB  0
14442:  RCALL  14064
....................          break;     
14444:  MOVLB  8
14446:  BRA    1450E
....................       case 26 : sol_chip_cmd(4); 
14448:  MOVLW  04
1444A:  MOVLB  8
1444C:  MOVWF  x97
1444E:  MOVLB  0
14450:  CALL   D826
....................                sol_switch_cmd(2); 
14454:  MOVLB  8
14456:  CLRF   x98
14458:  MOVLW  02
1445A:  MOVWF  x97
1445C:  MOVLB  0
1445E:  RCALL  14064
....................          break;           
14460:  MOVLB  8
14462:  BRA    1450E
....................       case 27 : sol_chip_cmd(4); 
14464:  MOVLW  04
14466:  MOVLB  8
14468:  MOVWF  x97
1446A:  MOVLB  0
1446C:  CALL   D826
....................                sol_switch_cmd(4); 
14470:  MOVLB  8
14472:  CLRF   x98
14474:  MOVLW  04
14476:  MOVWF  x97
14478:  MOVLB  0
1447A:  RCALL  14064
....................          break;  
1447C:  MOVLB  8
1447E:  BRA    1450E
....................       case 28 : sol_chip_cmd(4); 
14480:  MOVLW  04
14482:  MOVLB  8
14484:  MOVWF  x97
14486:  MOVLB  0
14488:  CALL   D826
....................                sol_switch_cmd(8); 
1448C:  MOVLB  8
1448E:  CLRF   x98
14490:  MOVLW  08
14492:  MOVWF  x97
14494:  MOVLB  0
14496:  RCALL  14064
....................          break;  
14498:  MOVLB  8
1449A:  BRA    1450E
....................       case 29 : sol_chip_cmd(4); 
1449C:  MOVLW  04
1449E:  MOVLB  8
144A0:  MOVWF  x97
144A2:  MOVLB  0
144A4:  CALL   D826
....................                sol_switch_cmd(16); 
144A8:  MOVLB  8
144AA:  CLRF   x98
144AC:  MOVLW  10
144AE:  MOVWF  x97
144B0:  MOVLB  0
144B2:  RCALL  14064
....................          break;  
144B4:  MOVLB  8
144B6:  BRA    1450E
....................       case 30 : sol_chip_cmd(4); 
144B8:  MOVLW  04
144BA:  MOVLB  8
144BC:  MOVWF  x97
144BE:  MOVLB  0
144C0:  CALL   D826
....................                sol_switch_cmd(32); 
144C4:  MOVLB  8
144C6:  CLRF   x98
144C8:  MOVLW  20
144CA:  MOVWF  x97
144CC:  MOVLB  0
144CE:  RCALL  14064
....................          break;  
144D0:  MOVLB  8
144D2:  BRA    1450E
....................       case 31 : sol_chip_cmd(4); 
144D4:  MOVLW  04
144D6:  MOVLB  8
144D8:  MOVWF  x97
144DA:  MOVLB  0
144DC:  CALL   D826
....................                sol_switch_cmd(64); 
144E0:  MOVLB  8
144E2:  CLRF   x98
144E4:  MOVLW  40
144E6:  MOVWF  x97
144E8:  MOVLB  0
144EA:  RCALL  14064
....................          break;  
144EC:  MOVLB  8
144EE:  BRA    1450E
....................       case 32 : sol_chip_cmd(4); 
144F0:  MOVLW  04
144F2:  MOVLB  8
144F4:  MOVWF  x97
144F6:  MOVLB  0
144F8:  CALL   D826
....................                sol_switch_cmd(128); 
144FC:  MOVLB  8
144FE:  CLRF   x98
14500:  MOVLW  80
14502:  MOVWF  x97
14504:  MOVLB  0
14506:  RCALL  14064
....................          break; 
14508:  MOVLB  8
1450A:  BRA    1450E
1450C:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
1450E:  MOVF   x96,F
14510:  BZ    1452A
14512:  MOVF   x96,W
14514:  SUBLW  20
14516:  BNC   1452A
14518:  CLRF   03
1451A:  MOVF   x96,W
1451C:  ADDLW  B7
1451E:  MOVWF  FE9
14520:  MOVLW  04
14522:  ADDWFC 03,W
14524:  MOVWF  FEA
14526:  MOVLW  01
14528:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
1452A:  MOVF   1F,W
1452C:  SUBLW  04
1452E:  BNZ   1453C
14530:  MOVF   20,F
14532:  BNZ   1453C
14534:  MOVLB  0
14536:  CALL   E9D6
1453A:  MOVLB  8
1453C:  MOVLB  0
1453E:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
10166:  MOVLB  8
10168:  CLRF   x7E
1016A:  MOVF   x7E,W
1016C:  SUBLW  07
1016E:  BNC   1018A
10170:  BCF    FD8.0
10172:  RLCF   x7E,W
10174:  CLRF   03
10176:  ADDLW  4B
10178:  MOVWF  FE9
1017A:  MOVLW  03
1017C:  ADDWFC 03,W
1017E:  MOVWF  FEA
10180:  CLRF   FEC
10182:  MOVF   FED,F
10184:  CLRF   FEF
10186:  INCF   x7E,F
10188:  BRA    1016A
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
1018A:  CLRF   x7E
1018C:  MOVF   x7E,W
1018E:  SUBLW  07
10190:  BNC   101AC
10192:  BCF    FD8.0
10194:  RLCF   x7E,W
10196:  CLRF   03
10198:  ADDLW  5D
1019A:  MOVWF  FE9
1019C:  MOVLW  03
1019E:  ADDWFC 03,W
101A0:  MOVWF  FEA
101A2:  CLRF   FEC
101A4:  MOVF   FED,F
101A6:  CLRF   FEF
101A8:  INCF   x7E,F
101AA:  BRA    1018C
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
101AC:  CLRF   x7E
101AE:  MOVF   x7E,W
101B0:  SUBLW  07
101B2:  BNC   101CE
101B4:  BCF    FD8.0
101B6:  RLCF   x7E,W
101B8:  CLRF   03
101BA:  ADDLW  6F
101BC:  MOVWF  FE9
101BE:  MOVLW  03
101C0:  ADDWFC 03,W
101C2:  MOVWF  FEA
101C4:  CLRF   FEC
101C6:  MOVF   FED,F
101C8:  CLRF   FEF
101CA:  INCF   x7E,F
101CC:  BRA    101AE
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
101CE:  CLRF   x7E
101D0:  MOVF   x7E,W
101D2:  SUBLW  07
101D4:  BNC   101F0
101D6:  BCF    FD8.0
101D8:  RLCF   x7E,W
101DA:  CLRF   03
101DC:  ADDLW  81
101DE:  MOVWF  FE9
101E0:  MOVLW  03
101E2:  ADDWFC 03,W
101E4:  MOVWF  FEA
101E6:  CLRF   FEC
101E8:  MOVF   FED,F
101EA:  CLRF   FEF
101EC:  INCF   x7E,F
101EE:  BRA    101D0
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
101F0:  CLRF   x7E
101F2:  MOVF   x7E,W
101F4:  SUBLW  07
101F6:  BNC   10212
101F8:  BCF    FD8.0
101FA:  RLCF   x7E,W
101FC:  CLRF   03
101FE:  ADDLW  93
10200:  MOVWF  FE9
10202:  MOVLW  03
10204:  ADDWFC 03,W
10206:  MOVWF  FEA
10208:  CLRF   FEC
1020A:  MOVF   FED,F
1020C:  CLRF   FEF
1020E:  INCF   x7E,F
10210:  BRA    101F2
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
10212:  MOVLW  04
10214:  MOVWF  FEA
10216:  MOVLW  25
10218:  MOVWF  FE9
1021A:  CLRF   00
1021C:  CLRF   02
1021E:  MOVLW  44
10220:  MOVWF  01
10222:  MOVLB  0
10224:  CALL   34C2
10228:  GOTO   14F60 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10A9C:  MOVLB  8
10A9E:  CLRF   xA3
10AA0:  MOVF   xA3,W
10AA2:  SUBLW  03
10AA4:  BNC   10AC4
10AA6:  MOVF   xA3,W
10AA8:  MULLW  04
10AAA:  MOVF   FF3,W
10AAC:  CLRF   03
10AAE:  ADDLW  A5
10AB0:  MOVWF  FE9
10AB2:  MOVLW  03
10AB4:  ADDWFC 03,W
10AB6:  MOVWF  FEA
10AB8:  CLRF   FEF
10ABA:  CLRF   FEC
10ABC:  CLRF   FEC
10ABE:  CLRF   FEC
10AC0:  INCF   xA3,F
10AC2:  BRA    10AA0
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10AC4:  MOVLB  3
10AC6:  MOVF   x4B,F
10AC8:  BTFSS  FD8.2
10ACA:  BRA    10AD0
10ACC:  MOVF   x4C,F
10ACE:  BZ    10B6A
10AD0:  MOVF   x4D,F
10AD2:  BNZ   10AD8
10AD4:  MOVF   x4E,F
10AD6:  BZ    10B6A
....................       blank = NO3_array[0]; 
10AD8:  MOVFF  34C,8F9
10ADC:  MOVFF  34B,8F8
10AE0:  MOVLB  0
10AE2:  CALL   C58E
10AE6:  MOVFF  03,8A7
10AEA:  MOVFF  02,8A6
10AEE:  MOVFF  01,8A5
10AF2:  MOVFF  00,8A4
....................       react = NO3_array[1]; 
10AF6:  MOVFF  34E,8F9
10AFA:  MOVFF  34D,8F8
10AFE:  CALL   C58E
10B02:  MOVFF  03,8AB
10B06:  MOVFF  02,8AA
10B0A:  MOVFF  01,8A9
10B0E:  MOVFF  00,8A8
....................       ratio = blank / react; 
10B12:  MOVFF  8A7,8DF
10B16:  MOVFF  8A6,8DE
10B1A:  MOVFF  8A5,8DD
10B1E:  MOVFF  8A4,8DC
10B22:  MOVFF  8AB,8E3
10B26:  MOVFF  8AA,8E2
10B2A:  MOVFF  8A9,8E1
10B2E:  MOVFF  8A8,8E0
10B32:  CALL   C5C4
10B36:  MOVFF  03,8AF
10B3A:  MOVFF  02,8AE
10B3E:  MOVFF  01,8AD
10B42:  MOVFF  00,8AC
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10B46:  MOVFF  8AF,8B3
10B4A:  MOVFF  8AE,8B2
10B4E:  MOVFF  8AD,8B1
10B52:  MOVFF  8AC,8B0
10B56:  RCALL  1081E
10B58:  MOVFF  03,3A8
10B5C:  MOVFF  02,3A7
10B60:  MOVFF  01,3A6
10B64:  MOVFF  00,3A5
10B68:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10B6A:  MOVF   x4F,F
10B6C:  BNZ   10B72
10B6E:  MOVF   x50,F
10B70:  BZ    10C0C
10B72:  MOVF   x51,F
10B74:  BNZ   10B7A
10B76:  MOVF   x52,F
10B78:  BZ    10C0C
....................       blank = NO3_array[2]; 
10B7A:  MOVFF  350,8F9
10B7E:  MOVFF  34F,8F8
10B82:  MOVLB  0
10B84:  CALL   C58E
10B88:  MOVFF  03,8A7
10B8C:  MOVFF  02,8A6
10B90:  MOVFF  01,8A5
10B94:  MOVFF  00,8A4
....................       react = NO3_array[3]; 
10B98:  MOVFF  352,8F9
10B9C:  MOVFF  351,8F8
10BA0:  CALL   C58E
10BA4:  MOVFF  03,8AB
10BA8:  MOVFF  02,8AA
10BAC:  MOVFF  01,8A9
10BB0:  MOVFF  00,8A8
....................       ratio = blank / react;    
10BB4:  MOVFF  8A7,8DF
10BB8:  MOVFF  8A6,8DE
10BBC:  MOVFF  8A5,8DD
10BC0:  MOVFF  8A4,8DC
10BC4:  MOVFF  8AB,8E3
10BC8:  MOVFF  8AA,8E2
10BCC:  MOVFF  8A9,8E1
10BD0:  MOVFF  8A8,8E0
10BD4:  CALL   C5C4
10BD8:  MOVFF  03,8AF
10BDC:  MOVFF  02,8AE
10BE0:  MOVFF  01,8AD
10BE4:  MOVFF  00,8AC
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10BE8:  MOVFF  8AF,8B3
10BEC:  MOVFF  8AE,8B2
10BF0:  MOVFF  8AD,8B1
10BF4:  MOVFF  8AC,8B0
10BF8:  RCALL  1081E
10BFA:  MOVFF  03,3AC
10BFE:  MOVFF  02,3AB
10C02:  MOVFF  01,3AA
10C06:  MOVFF  00,3A9
10C0A:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
10C0C:  MOVF   x53,F
10C0E:  BNZ   10C14
10C10:  MOVF   x54,F
10C12:  BZ    10CAE
10C14:  MOVF   x55,F
10C16:  BNZ   10C1C
10C18:  MOVF   x56,F
10C1A:  BZ    10CAE
....................       blank = NO3_array[4]; 
10C1C:  MOVFF  354,8F9
10C20:  MOVFF  353,8F8
10C24:  MOVLB  0
10C26:  CALL   C58E
10C2A:  MOVFF  03,8A7
10C2E:  MOVFF  02,8A6
10C32:  MOVFF  01,8A5
10C36:  MOVFF  00,8A4
....................       react = NO3_array[5]; 
10C3A:  MOVFF  356,8F9
10C3E:  MOVFF  355,8F8
10C42:  CALL   C58E
10C46:  MOVFF  03,8AB
10C4A:  MOVFF  02,8AA
10C4E:  MOVFF  01,8A9
10C52:  MOVFF  00,8A8
....................       ratio = blank / react; 
10C56:  MOVFF  8A7,8DF
10C5A:  MOVFF  8A6,8DE
10C5E:  MOVFF  8A5,8DD
10C62:  MOVFF  8A4,8DC
10C66:  MOVFF  8AB,8E3
10C6A:  MOVFF  8AA,8E2
10C6E:  MOVFF  8A9,8E1
10C72:  MOVFF  8A8,8E0
10C76:  CALL   C5C4
10C7A:  MOVFF  03,8AF
10C7E:  MOVFF  02,8AE
10C82:  MOVFF  01,8AD
10C86:  MOVFF  00,8AC
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
10C8A:  MOVFF  8AF,8B3
10C8E:  MOVFF  8AE,8B2
10C92:  MOVFF  8AD,8B1
10C96:  MOVFF  8AC,8B0
10C9A:  RCALL  1081E
10C9C:  MOVFF  03,3B0
10CA0:  MOVFF  02,3AF
10CA4:  MOVFF  01,3AE
10CA8:  MOVFF  00,3AD
10CAC:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
10CAE:  MOVF   x57,F
10CB0:  BNZ   10CB6
10CB2:  MOVF   x58,F
10CB4:  BZ    10D50
10CB6:  MOVF   x59,F
10CB8:  BNZ   10CBE
10CBA:  MOVF   x5A,F
10CBC:  BZ    10D50
....................       blank = NO3_array[6]; 
10CBE:  MOVFF  358,8F9
10CC2:  MOVFF  357,8F8
10CC6:  MOVLB  0
10CC8:  CALL   C58E
10CCC:  MOVFF  03,8A7
10CD0:  MOVFF  02,8A6
10CD4:  MOVFF  01,8A5
10CD8:  MOVFF  00,8A4
....................       react = NO3_array[7]; 
10CDC:  MOVFF  35A,8F9
10CE0:  MOVFF  359,8F8
10CE4:  CALL   C58E
10CE8:  MOVFF  03,8AB
10CEC:  MOVFF  02,8AA
10CF0:  MOVFF  01,8A9
10CF4:  MOVFF  00,8A8
....................       ratio = blank / react; 
10CF8:  MOVFF  8A7,8DF
10CFC:  MOVFF  8A6,8DE
10D00:  MOVFF  8A5,8DD
10D04:  MOVFF  8A4,8DC
10D08:  MOVFF  8AB,8E3
10D0C:  MOVFF  8AA,8E2
10D10:  MOVFF  8A9,8E1
10D14:  MOVFF  8A8,8E0
10D18:  CALL   C5C4
10D1C:  MOVFF  03,8AF
10D20:  MOVFF  02,8AE
10D24:  MOVFF  01,8AD
10D28:  MOVFF  00,8AC
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
10D2C:  MOVFF  8AF,8B3
10D30:  MOVFF  8AE,8B2
10D34:  MOVFF  8AD,8B1
10D38:  MOVFF  8AC,8B0
10D3C:  RCALL  1081E
10D3E:  MOVFF  03,3B4
10D42:  MOVFF  02,3B3
10D46:  MOVFF  01,3B2
10D4A:  MOVFF  00,3B1
10D4E:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
10D50:  MOVLW  04
10D52:  MOVWF  1E
10D54:  MOVLW  25
10D56:  MOVWF  1D
10D58:  MOVLW  A6
10D5A:  MOVWF  FF6
10D5C:  MOVLW  1D
10D5E:  MOVWF  FF7
10D60:  MOVLW  00
10D62:  MOVWF  FF8
10D64:  MOVLW  06
10D66:  MOVLB  8
10D68:  MOVWF  xCC
10D6A:  MOVLB  0
10D6C:  CALL   AA28
10D70:  MOVLW  10
10D72:  MOVWF  FE9
10D74:  MOVFF  34C,8D8
10D78:  MOVFF  34B,8D7
10D7C:  CALL   AA5A
10D80:  MOVLW  AF
10D82:  MOVWF  FF6
10D84:  MOVLW  1D
10D86:  MOVWF  FF7
10D88:  MOVLW  00
10D8A:  MOVWF  FF8
10D8C:  MOVLW  07
10D8E:  MOVLB  8
10D90:  MOVWF  xCC
10D92:  MOVLB  0
10D94:  CALL   AA28
10D98:  MOVLW  10
10D9A:  MOVWF  FE9
10D9C:  MOVFF  34E,8D8
10DA0:  MOVFF  34D,8D7
10DA4:  CALL   AA5A
10DA8:  MOVLW  B9
10DAA:  MOVWF  FF6
10DAC:  MOVLW  1D
10DAE:  MOVWF  FF7
10DB0:  MOVLW  00
10DB2:  MOVWF  FF8
10DB4:  MOVLW  09
10DB6:  MOVLB  8
10DB8:  MOVWF  xCC
10DBA:  MOVLB  0
10DBC:  CALL   AA28
10DC0:  MOVLW  89
10DC2:  MOVWF  FE9
10DC4:  MOVFF  3A8,8B3
10DC8:  MOVFF  3A7,8B2
10DCC:  MOVFF  3A6,8B1
10DD0:  MOVFF  3A5,8B0
10DD4:  MOVLW  04
10DD6:  MOVLB  8
10DD8:  MOVWF  xB4
10DDA:  MOVLB  0
10DDC:  RCALL  1088A
10DDE:  MOVLW  C7
10DE0:  MOVWF  FF6
10DE2:  MOVLW  1D
10DE4:  MOVWF  FF7
10DE6:  MOVLW  00
10DE8:  MOVWF  FF8
10DEA:  MOVLW  07
10DEC:  MOVLB  8
10DEE:  MOVWF  xCC
10DF0:  MOVLB  0
10DF2:  CALL   AA28
10DF6:  MOVLW  10
10DF8:  MOVWF  FE9
10DFA:  MOVFF  350,8D8
10DFE:  MOVFF  34F,8D7
10E02:  CALL   AA5A
10E06:  MOVLW  D1
10E08:  MOVWF  FF6
10E0A:  MOVLW  1D
10E0C:  MOVWF  FF7
10E0E:  MOVLW  00
10E10:  MOVWF  FF8
10E12:  MOVLW  07
10E14:  MOVLB  8
10E16:  MOVWF  xCC
10E18:  MOVLB  0
10E1A:  CALL   AA28
10E1E:  MOVLW  10
10E20:  MOVWF  FE9
10E22:  MOVFF  352,8D8
10E26:  MOVFF  351,8D7
10E2A:  CALL   AA5A
10E2E:  MOVLW  DB
10E30:  MOVWF  FF6
10E32:  MOVLW  1D
10E34:  MOVWF  FF7
10E36:  MOVLW  00
10E38:  MOVWF  FF8
10E3A:  MOVLW  09
10E3C:  MOVLB  8
10E3E:  MOVWF  xCC
10E40:  MOVLB  0
10E42:  CALL   AA28
10E46:  MOVLW  89
10E48:  MOVWF  FE9
10E4A:  MOVFF  3AC,8B3
10E4E:  MOVFF  3AB,8B2
10E52:  MOVFF  3AA,8B1
10E56:  MOVFF  3A9,8B0
10E5A:  MOVLW  04
10E5C:  MOVLB  8
10E5E:  MOVWF  xB4
10E60:  MOVLB  0
10E62:  RCALL  1088A
10E64:  MOVLW  E9
10E66:  MOVWF  FF6
10E68:  MOVLW  1D
10E6A:  MOVWF  FF7
10E6C:  MOVLW  00
10E6E:  MOVWF  FF8
10E70:  MOVLW  07
10E72:  MOVLB  8
10E74:  MOVWF  xCC
10E76:  MOVLB  0
10E78:  CALL   AA28
10E7C:  MOVLW  10
10E7E:  MOVWF  FE9
10E80:  MOVFF  354,8D8
10E84:  MOVFF  353,8D7
10E88:  CALL   AA5A
10E8C:  MOVLW  F3
10E8E:  MOVWF  FF6
10E90:  MOVLW  1D
10E92:  MOVWF  FF7
10E94:  MOVLW  00
10E96:  MOVWF  FF8
10E98:  MOVLW  07
10E9A:  MOVLB  8
10E9C:  MOVWF  xCC
10E9E:  MOVLB  0
10EA0:  CALL   AA28
10EA4:  MOVLW  10
10EA6:  MOVWF  FE9
10EA8:  MOVFF  356,8D8
10EAC:  MOVFF  355,8D7
10EB0:  CALL   AA5A
10EB4:  MOVLW  FD
10EB6:  MOVWF  FF6
10EB8:  MOVLW  1D
10EBA:  MOVWF  FF7
10EBC:  MOVLW  00
10EBE:  MOVWF  FF8
10EC0:  MOVLW  09
10EC2:  MOVLB  8
10EC4:  MOVWF  xCC
10EC6:  MOVLB  0
10EC8:  CALL   AA28
10ECC:  MOVLW  89
10ECE:  MOVWF  FE9
10ED0:  MOVFF  3B0,8B3
10ED4:  MOVFF  3AF,8B2
10ED8:  MOVFF  3AE,8B1
10EDC:  MOVFF  3AD,8B0
10EE0:  MOVLW  04
10EE2:  MOVLB  8
10EE4:  MOVWF  xB4
10EE6:  MOVLB  0
10EE8:  RCALL  1088A
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
10EEA:  MOVF   1F,W
10EEC:  SUBLW  02
10EEE:  BNZ   10EF4
10EF0:  MOVF   20,F
10EF2:  BZ    10F34
10EF4:  MOVLW  0C
10EF6:  MOVWF  FF6
10EF8:  MOVLW  1E
10EFA:  MOVWF  FF7
10EFC:  MOVLW  00
10EFE:  MOVWF  FF8
10F00:  CLRF   1B
10F02:  BTFSC  FF2.7
10F04:  BSF    1B.7
10F06:  BCF    FF2.7
10F08:  MOVLW  09
10F0A:  MOVLB  A
10F0C:  MOVWF  x1C
10F0E:  MOVLB  0
10F10:  CALL   1024
10F14:  BTFSC  1B.7
10F16:  BSF    FF2.7
10F18:  MOVLW  04
10F1A:  MOVWF  FEA
10F1C:  MOVLW  25
10F1E:  MOVWF  FE9
10F20:  CALL   78F8
10F24:  MOVLW  0D
10F26:  BTFSS  F9E.4
10F28:  BRA    10F26
10F2A:  MOVWF  FAD
10F2C:  MOVLW  0A
10F2E:  BTFSS  F9E.4
10F30:  BRA    10F2E
10F32:  MOVWF  FAD
10F34:  GOTO   12240 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
10F38:  MOVLB  8
10F3A:  CLRF   xA3
10F3C:  MOVF   xA3,W
10F3E:  SUBLW  03
10F40:  BNC   10F60
10F42:  MOVF   xA3,W
10F44:  MULLW  04
10F46:  MOVF   FF3,W
10F48:  CLRF   03
10F4A:  ADDLW  B5
10F4C:  MOVWF  FE9
10F4E:  MOVLW  03
10F50:  ADDWFC 03,W
10F52:  MOVWF  FEA
10F54:  CLRF   FEF
10F56:  CLRF   FEC
10F58:  CLRF   FEC
10F5A:  CLRF   FEC
10F5C:  INCF   xA3,F
10F5E:  BRA    10F3C
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
10F60:  MOVLB  3
10F62:  MOVF   x5D,F
10F64:  BTFSS  FD8.2
10F66:  BRA    10F6C
10F68:  MOVF   x5E,F
10F6A:  BZ    11006
10F6C:  MOVF   x5F,F
10F6E:  BNZ   10F74
10F70:  MOVF   x60,F
10F72:  BZ    11006
....................       blank = NO2_array[0]; 
10F74:  MOVFF  35E,8F9
10F78:  MOVFF  35D,8F8
10F7C:  MOVLB  0
10F7E:  CALL   C58E
10F82:  MOVFF  03,8A7
10F86:  MOVFF  02,8A6
10F8A:  MOVFF  01,8A5
10F8E:  MOVFF  00,8A4
....................       react = NO2_array[1]; 
10F92:  MOVFF  360,8F9
10F96:  MOVFF  35F,8F8
10F9A:  CALL   C58E
10F9E:  MOVFF  03,8AB
10FA2:  MOVFF  02,8AA
10FA6:  MOVFF  01,8A9
10FAA:  MOVFF  00,8A8
....................       ratio = blank / react; 
10FAE:  MOVFF  8A7,8DF
10FB2:  MOVFF  8A6,8DE
10FB6:  MOVFF  8A5,8DD
10FBA:  MOVFF  8A4,8DC
10FBE:  MOVFF  8AB,8E3
10FC2:  MOVFF  8AA,8E2
10FC6:  MOVFF  8A9,8E1
10FCA:  MOVFF  8A8,8E0
10FCE:  CALL   C5C4
10FD2:  MOVFF  03,8AF
10FD6:  MOVFF  02,8AE
10FDA:  MOVFF  01,8AD
10FDE:  MOVFF  00,8AC
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
10FE2:  MOVFF  8AF,8B3
10FE6:  MOVFF  8AE,8B2
10FEA:  MOVFF  8AD,8B1
10FEE:  MOVFF  8AC,8B0
10FF2:  RCALL  1081E
10FF4:  MOVFF  03,3B8
10FF8:  MOVFF  02,3B7
10FFC:  MOVFF  01,3B6
11000:  MOVFF  00,3B5
11004:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
11006:  MOVF   x61,F
11008:  BNZ   1100E
1100A:  MOVF   x62,F
1100C:  BZ    110AA
1100E:  MOVF   x63,F
11010:  BNZ   11016
11012:  MOVF   x64,F
11014:  BZ    110AA
....................       blank = NO2_array[2]; 
11016:  MOVFF  362,8F9
1101A:  MOVFF  361,8F8
1101E:  MOVLB  0
11020:  CALL   C58E
11024:  MOVFF  03,8A7
11028:  MOVFF  02,8A6
1102C:  MOVFF  01,8A5
11030:  MOVFF  00,8A4
....................       react = NO2_array[3]; 
11034:  MOVFF  364,8F9
11038:  MOVFF  363,8F8
1103C:  CALL   C58E
11040:  MOVFF  03,8AB
11044:  MOVFF  02,8AA
11048:  MOVFF  01,8A9
1104C:  MOVFF  00,8A8
....................       ratio = blank / react;    
11050:  MOVFF  8A7,8DF
11054:  MOVFF  8A6,8DE
11058:  MOVFF  8A5,8DD
1105C:  MOVFF  8A4,8DC
11060:  MOVFF  8AB,8E3
11064:  MOVFF  8AA,8E2
11068:  MOVFF  8A9,8E1
1106C:  MOVFF  8A8,8E0
11070:  CALL   C5C4
11074:  MOVFF  03,8AF
11078:  MOVFF  02,8AE
1107C:  MOVFF  01,8AD
11080:  MOVFF  00,8AC
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
11084:  MOVFF  8AF,8B3
11088:  MOVFF  8AE,8B2
1108C:  MOVFF  8AD,8B1
11090:  MOVFF  8AC,8B0
11094:  CALL   1081E
11098:  MOVFF  03,3BC
1109C:  MOVFF  02,3BB
110A0:  MOVFF  01,3BA
110A4:  MOVFF  00,3B9
110A8:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
110AA:  MOVF   x65,F
110AC:  BNZ   110B2
110AE:  MOVF   x66,F
110B0:  BZ    1114E
110B2:  MOVF   x67,F
110B4:  BNZ   110BA
110B6:  MOVF   x68,F
110B8:  BZ    1114E
....................       blank = NO2_array[4]; 
110BA:  MOVFF  366,8F9
110BE:  MOVFF  365,8F8
110C2:  MOVLB  0
110C4:  CALL   C58E
110C8:  MOVFF  03,8A7
110CC:  MOVFF  02,8A6
110D0:  MOVFF  01,8A5
110D4:  MOVFF  00,8A4
....................       react = NO2_array[5]; 
110D8:  MOVFF  368,8F9
110DC:  MOVFF  367,8F8
110E0:  CALL   C58E
110E4:  MOVFF  03,8AB
110E8:  MOVFF  02,8AA
110EC:  MOVFF  01,8A9
110F0:  MOVFF  00,8A8
....................       ratio = blank / react; 
110F4:  MOVFF  8A7,8DF
110F8:  MOVFF  8A6,8DE
110FC:  MOVFF  8A5,8DD
11100:  MOVFF  8A4,8DC
11104:  MOVFF  8AB,8E3
11108:  MOVFF  8AA,8E2
1110C:  MOVFF  8A9,8E1
11110:  MOVFF  8A8,8E0
11114:  CALL   C5C4
11118:  MOVFF  03,8AF
1111C:  MOVFF  02,8AE
11120:  MOVFF  01,8AD
11124:  MOVFF  00,8AC
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
11128:  MOVFF  8AF,8B3
1112C:  MOVFF  8AE,8B2
11130:  MOVFF  8AD,8B1
11134:  MOVFF  8AC,8B0
11138:  CALL   1081E
1113C:  MOVFF  03,3C0
11140:  MOVFF  02,3BF
11144:  MOVFF  01,3BE
11148:  MOVFF  00,3BD
1114C:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
1114E:  MOVF   x69,F
11150:  BNZ   11156
11152:  MOVF   x6A,F
11154:  BZ    111F2
11156:  MOVF   x6B,F
11158:  BNZ   1115E
1115A:  MOVF   x6C,F
1115C:  BZ    111F2
....................       blank = NO2_array[6]; 
1115E:  MOVFF  36A,8F9
11162:  MOVFF  369,8F8
11166:  MOVLB  0
11168:  CALL   C58E
1116C:  MOVFF  03,8A7
11170:  MOVFF  02,8A6
11174:  MOVFF  01,8A5
11178:  MOVFF  00,8A4
....................       react = NO2_array[7]; 
1117C:  MOVFF  36C,8F9
11180:  MOVFF  36B,8F8
11184:  CALL   C58E
11188:  MOVFF  03,8AB
1118C:  MOVFF  02,8AA
11190:  MOVFF  01,8A9
11194:  MOVFF  00,8A8
....................       ratio = blank / react; 
11198:  MOVFF  8A7,8DF
1119C:  MOVFF  8A6,8DE
111A0:  MOVFF  8A5,8DD
111A4:  MOVFF  8A4,8DC
111A8:  MOVFF  8AB,8E3
111AC:  MOVFF  8AA,8E2
111B0:  MOVFF  8A9,8E1
111B4:  MOVFF  8A8,8E0
111B8:  CALL   C5C4
111BC:  MOVFF  03,8AF
111C0:  MOVFF  02,8AE
111C4:  MOVFF  01,8AD
111C8:  MOVFF  00,8AC
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
111CC:  MOVFF  8AF,8B3
111D0:  MOVFF  8AE,8B2
111D4:  MOVFF  8AD,8B1
111D8:  MOVFF  8AC,8B0
111DC:  CALL   1081E
111E0:  MOVFF  03,3C4
111E4:  MOVFF  02,3C3
111E8:  MOVFF  01,3C2
111EC:  MOVFF  00,3C1
111F0:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
111F2:  MOVLW  04
111F4:  MOVWF  1E
111F6:  MOVLW  25
111F8:  MOVWF  1D
111FA:  MOVLW  1A
111FC:  MOVWF  FF6
111FE:  MOVLW  1E
11200:  MOVWF  FF7
11202:  MOVLW  00
11204:  MOVWF  FF8
11206:  MOVLW  06
11208:  MOVLB  8
1120A:  MOVWF  xCC
1120C:  MOVLB  0
1120E:  CALL   AA28
11212:  MOVLW  10
11214:  MOVWF  FE9
11216:  MOVFF  35E,8D8
1121A:  MOVFF  35D,8D7
1121E:  CALL   AA5A
11222:  MOVLW  23
11224:  MOVWF  FF6
11226:  MOVLW  1E
11228:  MOVWF  FF7
1122A:  MOVLW  00
1122C:  MOVWF  FF8
1122E:  MOVLW  07
11230:  MOVLB  8
11232:  MOVWF  xCC
11234:  MOVLB  0
11236:  CALL   AA28
1123A:  MOVLW  10
1123C:  MOVWF  FE9
1123E:  MOVFF  360,8D8
11242:  MOVFF  35F,8D7
11246:  CALL   AA5A
1124A:  MOVLW  2D
1124C:  MOVWF  FF6
1124E:  MOVLW  1E
11250:  MOVWF  FF7
11252:  MOVLW  00
11254:  MOVWF  FF8
11256:  MOVLW  09
11258:  MOVLB  8
1125A:  MOVWF  xCC
1125C:  MOVLB  0
1125E:  CALL   AA28
11262:  MOVLW  89
11264:  MOVWF  FE9
11266:  MOVFF  3B8,8B3
1126A:  MOVFF  3B7,8B2
1126E:  MOVFF  3B6,8B1
11272:  MOVFF  3B5,8B0
11276:  MOVLW  04
11278:  MOVLB  8
1127A:  MOVWF  xB4
1127C:  MOVLB  0
1127E:  CALL   1088A
11282:  MOVLW  3B
11284:  MOVWF  FF6
11286:  MOVLW  1E
11288:  MOVWF  FF7
1128A:  MOVLW  00
1128C:  MOVWF  FF8
1128E:  MOVLW  07
11290:  MOVLB  8
11292:  MOVWF  xCC
11294:  MOVLB  0
11296:  CALL   AA28
1129A:  MOVLW  10
1129C:  MOVWF  FE9
1129E:  MOVFF  362,8D8
112A2:  MOVFF  361,8D7
112A6:  CALL   AA5A
112AA:  MOVLW  45
112AC:  MOVWF  FF6
112AE:  MOVLW  1E
112B0:  MOVWF  FF7
112B2:  MOVLW  00
112B4:  MOVWF  FF8
112B6:  MOVLW  07
112B8:  MOVLB  8
112BA:  MOVWF  xCC
112BC:  MOVLB  0
112BE:  CALL   AA28
112C2:  MOVLW  10
112C4:  MOVWF  FE9
112C6:  MOVFF  364,8D8
112CA:  MOVFF  363,8D7
112CE:  CALL   AA5A
112D2:  MOVLW  4F
112D4:  MOVWF  FF6
112D6:  MOVLW  1E
112D8:  MOVWF  FF7
112DA:  MOVLW  00
112DC:  MOVWF  FF8
112DE:  MOVLW  09
112E0:  MOVLB  8
112E2:  MOVWF  xCC
112E4:  MOVLB  0
112E6:  CALL   AA28
112EA:  MOVLW  89
112EC:  MOVWF  FE9
112EE:  MOVFF  3BC,8B3
112F2:  MOVFF  3BB,8B2
112F6:  MOVFF  3BA,8B1
112FA:  MOVFF  3B9,8B0
112FE:  MOVLW  04
11300:  MOVLB  8
11302:  MOVWF  xB4
11304:  MOVLB  0
11306:  CALL   1088A
1130A:  MOVLW  5D
1130C:  MOVWF  FF6
1130E:  MOVLW  1E
11310:  MOVWF  FF7
11312:  MOVLW  00
11314:  MOVWF  FF8
11316:  MOVLW  07
11318:  MOVLB  8
1131A:  MOVWF  xCC
1131C:  MOVLB  0
1131E:  CALL   AA28
11322:  MOVLW  10
11324:  MOVWF  FE9
11326:  MOVFF  366,8D8
1132A:  MOVFF  365,8D7
1132E:  CALL   AA5A
11332:  MOVLW  67
11334:  MOVWF  FF6
11336:  MOVLW  1E
11338:  MOVWF  FF7
1133A:  MOVLW  00
1133C:  MOVWF  FF8
1133E:  MOVLW  07
11340:  MOVLB  8
11342:  MOVWF  xCC
11344:  MOVLB  0
11346:  CALL   AA28
1134A:  MOVLW  10
1134C:  MOVWF  FE9
1134E:  MOVFF  368,8D8
11352:  MOVFF  367,8D7
11356:  CALL   AA5A
1135A:  MOVLW  71
1135C:  MOVWF  FF6
1135E:  MOVLW  1E
11360:  MOVWF  FF7
11362:  MOVLW  00
11364:  MOVWF  FF8
11366:  MOVLW  09
11368:  MOVLB  8
1136A:  MOVWF  xCC
1136C:  MOVLB  0
1136E:  CALL   AA28
11372:  MOVLW  89
11374:  MOVWF  FE9
11376:  MOVFF  3C0,8B3
1137A:  MOVFF  3BF,8B2
1137E:  MOVFF  3BE,8B1
11382:  MOVFF  3BD,8B0
11386:  MOVLW  04
11388:  MOVLB  8
1138A:  MOVWF  xB4
1138C:  MOVLB  0
1138E:  CALL   1088A
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
11392:  MOVF   1F,W
11394:  SUBLW  02
11396:  BNZ   1139C
11398:  MOVF   20,F
1139A:  BZ    113DC
1139C:  MOVLW  80
1139E:  MOVWF  FF6
113A0:  MOVLW  1E
113A2:  MOVWF  FF7
113A4:  MOVLW  00
113A6:  MOVWF  FF8
113A8:  CLRF   1B
113AA:  BTFSC  FF2.7
113AC:  BSF    1B.7
113AE:  BCF    FF2.7
113B0:  MOVLW  09
113B2:  MOVLB  A
113B4:  MOVWF  x1C
113B6:  MOVLB  0
113B8:  CALL   1024
113BC:  BTFSC  1B.7
113BE:  BSF    FF2.7
113C0:  MOVLW  04
113C2:  MOVWF  FEA
113C4:  MOVLW  25
113C6:  MOVWF  FE9
113C8:  CALL   78F8
113CC:  MOVLW  0D
113CE:  BTFSS  F9E.4
113D0:  BRA    113CE
113D2:  MOVWF  FAD
113D4:  MOVLW  0A
113D6:  BTFSS  F9E.4
113D8:  BRA    113D6
113DA:  MOVWF  FAD
113DC:  GOTO   12240 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
113E0:  MOVLB  8
113E2:  CLRF   xA3
113E4:  MOVF   xA3,W
113E6:  SUBLW  03
113E8:  BNC   11408
113EA:  MOVF   xA3,W
113EC:  MULLW  04
113EE:  MOVF   FF3,W
113F0:  CLRF   03
113F2:  ADDLW  C5
113F4:  MOVWF  FE9
113F6:  MOVLW  03
113F8:  ADDWFC 03,W
113FA:  MOVWF  FEA
113FC:  CLRF   FEF
113FE:  CLRF   FEC
11400:  CLRF   FEC
11402:  CLRF   FEC
11404:  INCF   xA3,F
11406:  BRA    113E4
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
11408:  MOVLB  3
1140A:  MOVF   x6F,F
1140C:  BTFSS  FD8.2
1140E:  BRA    11414
11410:  MOVF   x70,F
11412:  BZ    114B0
11414:  MOVF   x71,F
11416:  BNZ   1141C
11418:  MOVF   x72,F
1141A:  BZ    114B0
....................       blank = PO4_array[0]; 
1141C:  MOVFF  370,8F9
11420:  MOVFF  36F,8F8
11424:  MOVLB  0
11426:  CALL   C58E
1142A:  MOVFF  03,8A7
1142E:  MOVFF  02,8A6
11432:  MOVFF  01,8A5
11436:  MOVFF  00,8A4
....................       react = PO4_array[1]; 
1143A:  MOVFF  372,8F9
1143E:  MOVFF  371,8F8
11442:  CALL   C58E
11446:  MOVFF  03,8AB
1144A:  MOVFF  02,8AA
1144E:  MOVFF  01,8A9
11452:  MOVFF  00,8A8
....................       ratio = blank / react; 
11456:  MOVFF  8A7,8DF
1145A:  MOVFF  8A6,8DE
1145E:  MOVFF  8A5,8DD
11462:  MOVFF  8A4,8DC
11466:  MOVFF  8AB,8E3
1146A:  MOVFF  8AA,8E2
1146E:  MOVFF  8A9,8E1
11472:  MOVFF  8A8,8E0
11476:  CALL   C5C4
1147A:  MOVFF  03,8AF
1147E:  MOVFF  02,8AE
11482:  MOVFF  01,8AD
11486:  MOVFF  00,8AC
....................       PO4_abs_array[0] = log10(ratio); 
1148A:  MOVFF  8AF,8B3
1148E:  MOVFF  8AE,8B2
11492:  MOVFF  8AD,8B1
11496:  MOVFF  8AC,8B0
1149A:  CALL   1081E
1149E:  MOVFF  03,3C8
114A2:  MOVFF  02,3C7
114A6:  MOVFF  01,3C6
114AA:  MOVFF  00,3C5
114AE:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
114B0:  MOVF   x73,F
114B2:  BNZ   114B8
114B4:  MOVF   x74,F
114B6:  BZ    11554
114B8:  MOVF   x75,F
114BA:  BNZ   114C0
114BC:  MOVF   x76,F
114BE:  BZ    11554
....................       blank = PO4_array[2]; 
114C0:  MOVFF  374,8F9
114C4:  MOVFF  373,8F8
114C8:  MOVLB  0
114CA:  CALL   C58E
114CE:  MOVFF  03,8A7
114D2:  MOVFF  02,8A6
114D6:  MOVFF  01,8A5
114DA:  MOVFF  00,8A4
....................       react = PO4_array[3]; 
114DE:  MOVFF  376,8F9
114E2:  MOVFF  375,8F8
114E6:  CALL   C58E
114EA:  MOVFF  03,8AB
114EE:  MOVFF  02,8AA
114F2:  MOVFF  01,8A9
114F6:  MOVFF  00,8A8
....................       ratio = blank / react;    
114FA:  MOVFF  8A7,8DF
114FE:  MOVFF  8A6,8DE
11502:  MOVFF  8A5,8DD
11506:  MOVFF  8A4,8DC
1150A:  MOVFF  8AB,8E3
1150E:  MOVFF  8AA,8E2
11512:  MOVFF  8A9,8E1
11516:  MOVFF  8A8,8E0
1151A:  CALL   C5C4
1151E:  MOVFF  03,8AF
11522:  MOVFF  02,8AE
11526:  MOVFF  01,8AD
1152A:  MOVFF  00,8AC
....................       PO4_abs_array[1] = log10(ratio); 
1152E:  MOVFF  8AF,8B3
11532:  MOVFF  8AE,8B2
11536:  MOVFF  8AD,8B1
1153A:  MOVFF  8AC,8B0
1153E:  CALL   1081E
11542:  MOVFF  03,3CC
11546:  MOVFF  02,3CB
1154A:  MOVFF  01,3CA
1154E:  MOVFF  00,3C9
11552:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
11554:  MOVF   x77,F
11556:  BNZ   1155C
11558:  MOVF   x78,F
1155A:  BZ    115F8
1155C:  MOVF   x79,F
1155E:  BNZ   11564
11560:  MOVF   x7A,F
11562:  BZ    115F8
....................       blank = PO4_array[4]; 
11564:  MOVFF  378,8F9
11568:  MOVFF  377,8F8
1156C:  MOVLB  0
1156E:  CALL   C58E
11572:  MOVFF  03,8A7
11576:  MOVFF  02,8A6
1157A:  MOVFF  01,8A5
1157E:  MOVFF  00,8A4
....................       react = PO4_array[5]; 
11582:  MOVFF  37A,8F9
11586:  MOVFF  379,8F8
1158A:  CALL   C58E
1158E:  MOVFF  03,8AB
11592:  MOVFF  02,8AA
11596:  MOVFF  01,8A9
1159A:  MOVFF  00,8A8
....................       ratio = blank / react; 
1159E:  MOVFF  8A7,8DF
115A2:  MOVFF  8A6,8DE
115A6:  MOVFF  8A5,8DD
115AA:  MOVFF  8A4,8DC
115AE:  MOVFF  8AB,8E3
115B2:  MOVFF  8AA,8E2
115B6:  MOVFF  8A9,8E1
115BA:  MOVFF  8A8,8E0
115BE:  CALL   C5C4
115C2:  MOVFF  03,8AF
115C6:  MOVFF  02,8AE
115CA:  MOVFF  01,8AD
115CE:  MOVFF  00,8AC
....................       PO4_abs_array[2] = log10(ratio); 
115D2:  MOVFF  8AF,8B3
115D6:  MOVFF  8AE,8B2
115DA:  MOVFF  8AD,8B1
115DE:  MOVFF  8AC,8B0
115E2:  CALL   1081E
115E6:  MOVFF  03,3D0
115EA:  MOVFF  02,3CF
115EE:  MOVFF  01,3CE
115F2:  MOVFF  00,3CD
115F6:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
115F8:  MOVF   x7B,F
115FA:  BNZ   11600
115FC:  MOVF   x7C,F
115FE:  BZ    1169C
11600:  MOVF   x7D,F
11602:  BNZ   11608
11604:  MOVF   x7E,F
11606:  BZ    1169C
....................       blank = PO4_array[6]; 
11608:  MOVFF  37C,8F9
1160C:  MOVFF  37B,8F8
11610:  MOVLB  0
11612:  CALL   C58E
11616:  MOVFF  03,8A7
1161A:  MOVFF  02,8A6
1161E:  MOVFF  01,8A5
11622:  MOVFF  00,8A4
....................       react = PO4_array[7]; 
11626:  MOVFF  37E,8F9
1162A:  MOVFF  37D,8F8
1162E:  CALL   C58E
11632:  MOVFF  03,8AB
11636:  MOVFF  02,8AA
1163A:  MOVFF  01,8A9
1163E:  MOVFF  00,8A8
....................       ratio = blank / react; 
11642:  MOVFF  8A7,8DF
11646:  MOVFF  8A6,8DE
1164A:  MOVFF  8A5,8DD
1164E:  MOVFF  8A4,8DC
11652:  MOVFF  8AB,8E3
11656:  MOVFF  8AA,8E2
1165A:  MOVFF  8A9,8E1
1165E:  MOVFF  8A8,8E0
11662:  CALL   C5C4
11666:  MOVFF  03,8AF
1166A:  MOVFF  02,8AE
1166E:  MOVFF  01,8AD
11672:  MOVFF  00,8AC
....................       PO4_abs_array[3] = log10(ratio); 
11676:  MOVFF  8AF,8B3
1167A:  MOVFF  8AE,8B2
1167E:  MOVFF  8AD,8B1
11682:  MOVFF  8AC,8B0
11686:  CALL   1081E
1168A:  MOVFF  03,3D4
1168E:  MOVFF  02,3D3
11692:  MOVFF  01,3D2
11696:  MOVFF  00,3D1
1169A:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
1169C:  MOVLW  04
1169E:  MOVWF  1E
116A0:  MOVLW  25
116A2:  MOVWF  1D
116A4:  MOVLW  8E
116A6:  MOVWF  FF6
116A8:  MOVLW  1E
116AA:  MOVWF  FF7
116AC:  MOVLW  00
116AE:  MOVWF  FF8
116B0:  MOVLW  06
116B2:  MOVLB  8
116B4:  MOVWF  xCC
116B6:  MOVLB  0
116B8:  CALL   AA28
116BC:  MOVLW  10
116BE:  MOVWF  FE9
116C0:  MOVFF  370,8D8
116C4:  MOVFF  36F,8D7
116C8:  CALL   AA5A
116CC:  MOVLW  97
116CE:  MOVWF  FF6
116D0:  MOVLW  1E
116D2:  MOVWF  FF7
116D4:  MOVLW  00
116D6:  MOVWF  FF8
116D8:  MOVLW  07
116DA:  MOVLB  8
116DC:  MOVWF  xCC
116DE:  MOVLB  0
116E0:  CALL   AA28
116E4:  MOVLW  10
116E6:  MOVWF  FE9
116E8:  MOVFF  372,8D8
116EC:  MOVFF  371,8D7
116F0:  CALL   AA5A
116F4:  MOVLW  A1
116F6:  MOVWF  FF6
116F8:  MOVLW  1E
116FA:  MOVWF  FF7
116FC:  MOVLW  00
116FE:  MOVWF  FF8
11700:  MOVLW  09
11702:  MOVLB  8
11704:  MOVWF  xCC
11706:  MOVLB  0
11708:  CALL   AA28
1170C:  MOVLW  89
1170E:  MOVWF  FE9
11710:  MOVFF  3C8,8B3
11714:  MOVFF  3C7,8B2
11718:  MOVFF  3C6,8B1
1171C:  MOVFF  3C5,8B0
11720:  MOVLW  04
11722:  MOVLB  8
11724:  MOVWF  xB4
11726:  MOVLB  0
11728:  CALL   1088A
1172C:  MOVLW  AF
1172E:  MOVWF  FF6
11730:  MOVLW  1E
11732:  MOVWF  FF7
11734:  MOVLW  00
11736:  MOVWF  FF8
11738:  MOVLW  07
1173A:  MOVLB  8
1173C:  MOVWF  xCC
1173E:  MOVLB  0
11740:  CALL   AA28
11744:  MOVLW  10
11746:  MOVWF  FE9
11748:  MOVFF  374,8D8
1174C:  MOVFF  373,8D7
11750:  CALL   AA5A
11754:  MOVLW  B9
11756:  MOVWF  FF6
11758:  MOVLW  1E
1175A:  MOVWF  FF7
1175C:  MOVLW  00
1175E:  MOVWF  FF8
11760:  MOVLW  07
11762:  MOVLB  8
11764:  MOVWF  xCC
11766:  MOVLB  0
11768:  CALL   AA28
1176C:  MOVLW  10
1176E:  MOVWF  FE9
11770:  MOVFF  376,8D8
11774:  MOVFF  375,8D7
11778:  CALL   AA5A
1177C:  MOVLW  C3
1177E:  MOVWF  FF6
11780:  MOVLW  1E
11782:  MOVWF  FF7
11784:  MOVLW  00
11786:  MOVWF  FF8
11788:  MOVLW  09
1178A:  MOVLB  8
1178C:  MOVWF  xCC
1178E:  MOVLB  0
11790:  CALL   AA28
11794:  MOVLW  89
11796:  MOVWF  FE9
11798:  MOVFF  3CC,8B3
1179C:  MOVFF  3CB,8B2
117A0:  MOVFF  3CA,8B1
117A4:  MOVFF  3C9,8B0
117A8:  MOVLW  04
117AA:  MOVLB  8
117AC:  MOVWF  xB4
117AE:  MOVLB  0
117B0:  CALL   1088A
117B4:  MOVLW  D1
117B6:  MOVWF  FF6
117B8:  MOVLW  1E
117BA:  MOVWF  FF7
117BC:  MOVLW  00
117BE:  MOVWF  FF8
117C0:  MOVLW  07
117C2:  MOVLB  8
117C4:  MOVWF  xCC
117C6:  MOVLB  0
117C8:  CALL   AA28
117CC:  MOVLW  10
117CE:  MOVWF  FE9
117D0:  MOVFF  378,8D8
117D4:  MOVFF  377,8D7
117D8:  CALL   AA5A
117DC:  MOVLW  DB
117DE:  MOVWF  FF6
117E0:  MOVLW  1E
117E2:  MOVWF  FF7
117E4:  MOVLW  00
117E6:  MOVWF  FF8
117E8:  MOVLW  07
117EA:  MOVLB  8
117EC:  MOVWF  xCC
117EE:  MOVLB  0
117F0:  CALL   AA28
117F4:  MOVLW  10
117F6:  MOVWF  FE9
117F8:  MOVFF  37A,8D8
117FC:  MOVFF  379,8D7
11800:  CALL   AA5A
11804:  MOVLW  E5
11806:  MOVWF  FF6
11808:  MOVLW  1E
1180A:  MOVWF  FF7
1180C:  MOVLW  00
1180E:  MOVWF  FF8
11810:  MOVLW  09
11812:  MOVLB  8
11814:  MOVWF  xCC
11816:  MOVLB  0
11818:  CALL   AA28
1181C:  MOVLW  89
1181E:  MOVWF  FE9
11820:  MOVFF  3D0,8B3
11824:  MOVFF  3CF,8B2
11828:  MOVFF  3CE,8B1
1182C:  MOVFF  3CD,8B0
11830:  MOVLW  04
11832:  MOVLB  8
11834:  MOVWF  xB4
11836:  MOVLB  0
11838:  CALL   1088A
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
1183C:  MOVF   1F,W
1183E:  SUBLW  02
11840:  BNZ   11846
11842:  MOVF   20,F
11844:  BZ    11886
11846:  MOVLW  F4
11848:  MOVWF  FF6
1184A:  MOVLW  1E
1184C:  MOVWF  FF7
1184E:  MOVLW  00
11850:  MOVWF  FF8
11852:  CLRF   1B
11854:  BTFSC  FF2.7
11856:  BSF    1B.7
11858:  BCF    FF2.7
1185A:  MOVLW  09
1185C:  MOVLB  A
1185E:  MOVWF  x1C
11860:  MOVLB  0
11862:  CALL   1024
11866:  BTFSC  1B.7
11868:  BSF    FF2.7
1186A:  MOVLW  04
1186C:  MOVWF  FEA
1186E:  MOVLW  25
11870:  MOVWF  FE9
11872:  CALL   78F8
11876:  MOVLW  0D
11878:  BTFSS  F9E.4
1187A:  BRA    11878
1187C:  MOVWF  FAD
1187E:  MOVLW  0A
11880:  BTFSS  F9E.4
11882:  BRA    11880
11884:  MOVWF  FAD
11886:  GOTO   12240 (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
1188A:  MOVLB  8
1188C:  CLRF   xA3
1188E:  MOVF   xA3,W
11890:  SUBLW  03
11892:  BNC   118B2
11894:  MOVF   xA3,W
11896:  MULLW  04
11898:  MOVF   FF3,W
1189A:  CLRF   03
1189C:  ADDLW  D5
1189E:  MOVWF  FE9
118A0:  MOVLW  03
118A2:  ADDWFC 03,W
118A4:  MOVWF  FEA
118A6:  CLRF   FEF
118A8:  CLRF   FEC
118AA:  CLRF   FEC
118AC:  CLRF   FEC
118AE:  INCF   xA3,F
118B0:  BRA    1188E
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
118B2:  MOVLB  3
118B4:  MOVF   x81,F
118B6:  BTFSS  FD8.2
118B8:  BRA    118BE
118BA:  MOVF   x82,F
118BC:  BZ    1195A
118BE:  MOVF   x83,F
118C0:  BNZ   118C6
118C2:  MOVF   x84,F
118C4:  BZ    1195A
....................       blank = NH4_array[0]; 
118C6:  MOVFF  382,8F9
118CA:  MOVFF  381,8F8
118CE:  MOVLB  0
118D0:  CALL   C58E
118D4:  MOVFF  03,8A7
118D8:  MOVFF  02,8A6
118DC:  MOVFF  01,8A5
118E0:  MOVFF  00,8A4
....................       react = NH4_array[1]; 
118E4:  MOVFF  384,8F9
118E8:  MOVFF  383,8F8
118EC:  CALL   C58E
118F0:  MOVFF  03,8AB
118F4:  MOVFF  02,8AA
118F8:  MOVFF  01,8A9
118FC:  MOVFF  00,8A8
....................       ratio = blank / react; 
11900:  MOVFF  8A7,8DF
11904:  MOVFF  8A6,8DE
11908:  MOVFF  8A5,8DD
1190C:  MOVFF  8A4,8DC
11910:  MOVFF  8AB,8E3
11914:  MOVFF  8AA,8E2
11918:  MOVFF  8A9,8E1
1191C:  MOVFF  8A8,8E0
11920:  CALL   C5C4
11924:  MOVFF  03,8AF
11928:  MOVFF  02,8AE
1192C:  MOVFF  01,8AD
11930:  MOVFF  00,8AC
....................       NH4_abs_array[0] = log10(ratio); 
11934:  MOVFF  8AF,8B3
11938:  MOVFF  8AE,8B2
1193C:  MOVFF  8AD,8B1
11940:  MOVFF  8AC,8B0
11944:  CALL   1081E
11948:  MOVFF  03,3D8
1194C:  MOVFF  02,3D7
11950:  MOVFF  01,3D6
11954:  MOVFF  00,3D5
11958:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
1195A:  MOVF   x85,F
1195C:  BNZ   11962
1195E:  MOVF   x86,F
11960:  BZ    119FE
11962:  MOVF   x87,F
11964:  BNZ   1196A
11966:  MOVF   x88,F
11968:  BZ    119FE
....................       blank = NH4_array[2]; 
1196A:  MOVFF  386,8F9
1196E:  MOVFF  385,8F8
11972:  MOVLB  0
11974:  CALL   C58E
11978:  MOVFF  03,8A7
1197C:  MOVFF  02,8A6
11980:  MOVFF  01,8A5
11984:  MOVFF  00,8A4
....................       react = NH4_array[3]; 
11988:  MOVFF  388,8F9
1198C:  MOVFF  387,8F8
11990:  CALL   C58E
11994:  MOVFF  03,8AB
11998:  MOVFF  02,8AA
1199C:  MOVFF  01,8A9
119A0:  MOVFF  00,8A8
....................       ratio = blank / react;    
119A4:  MOVFF  8A7,8DF
119A8:  MOVFF  8A6,8DE
119AC:  MOVFF  8A5,8DD
119B0:  MOVFF  8A4,8DC
119B4:  MOVFF  8AB,8E3
119B8:  MOVFF  8AA,8E2
119BC:  MOVFF  8A9,8E1
119C0:  MOVFF  8A8,8E0
119C4:  CALL   C5C4
119C8:  MOVFF  03,8AF
119CC:  MOVFF  02,8AE
119D0:  MOVFF  01,8AD
119D4:  MOVFF  00,8AC
....................       NH4_abs_array[1] = log10(ratio); 
119D8:  MOVFF  8AF,8B3
119DC:  MOVFF  8AE,8B2
119E0:  MOVFF  8AD,8B1
119E4:  MOVFF  8AC,8B0
119E8:  CALL   1081E
119EC:  MOVFF  03,3DC
119F0:  MOVFF  02,3DB
119F4:  MOVFF  01,3DA
119F8:  MOVFF  00,3D9
119FC:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
119FE:  MOVF   x89,F
11A00:  BNZ   11A06
11A02:  MOVF   x8A,F
11A04:  BZ    11AA2
11A06:  MOVF   x8B,F
11A08:  BNZ   11A0E
11A0A:  MOVF   x8C,F
11A0C:  BZ    11AA2
....................       blank = NH4_array[4]; 
11A0E:  MOVFF  38A,8F9
11A12:  MOVFF  389,8F8
11A16:  MOVLB  0
11A18:  CALL   C58E
11A1C:  MOVFF  03,8A7
11A20:  MOVFF  02,8A6
11A24:  MOVFF  01,8A5
11A28:  MOVFF  00,8A4
....................       react = NH4_array[5]; 
11A2C:  MOVFF  38C,8F9
11A30:  MOVFF  38B,8F8
11A34:  CALL   C58E
11A38:  MOVFF  03,8AB
11A3C:  MOVFF  02,8AA
11A40:  MOVFF  01,8A9
11A44:  MOVFF  00,8A8
....................       ratio = blank / react; 
11A48:  MOVFF  8A7,8DF
11A4C:  MOVFF  8A6,8DE
11A50:  MOVFF  8A5,8DD
11A54:  MOVFF  8A4,8DC
11A58:  MOVFF  8AB,8E3
11A5C:  MOVFF  8AA,8E2
11A60:  MOVFF  8A9,8E1
11A64:  MOVFF  8A8,8E0
11A68:  CALL   C5C4
11A6C:  MOVFF  03,8AF
11A70:  MOVFF  02,8AE
11A74:  MOVFF  01,8AD
11A78:  MOVFF  00,8AC
....................       NH4_abs_array[2] = log10(ratio); 
11A7C:  MOVFF  8AF,8B3
11A80:  MOVFF  8AE,8B2
11A84:  MOVFF  8AD,8B1
11A88:  MOVFF  8AC,8B0
11A8C:  CALL   1081E
11A90:  MOVFF  03,3E0
11A94:  MOVFF  02,3DF
11A98:  MOVFF  01,3DE
11A9C:  MOVFF  00,3DD
11AA0:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11AA2:  MOVF   x8D,F
11AA4:  BNZ   11AAA
11AA6:  MOVF   x8E,F
11AA8:  BZ    11B46
11AAA:  MOVF   x8F,F
11AAC:  BNZ   11AB2
11AAE:  MOVF   x90,F
11AB0:  BZ    11B46
....................       blank = NH4_array[6]; 
11AB2:  MOVFF  38E,8F9
11AB6:  MOVFF  38D,8F8
11ABA:  MOVLB  0
11ABC:  CALL   C58E
11AC0:  MOVFF  03,8A7
11AC4:  MOVFF  02,8A6
11AC8:  MOVFF  01,8A5
11ACC:  MOVFF  00,8A4
....................       react = NH4_array[7]; 
11AD0:  MOVFF  390,8F9
11AD4:  MOVFF  38F,8F8
11AD8:  CALL   C58E
11ADC:  MOVFF  03,8AB
11AE0:  MOVFF  02,8AA
11AE4:  MOVFF  01,8A9
11AE8:  MOVFF  00,8A8
....................       ratio = blank / react; 
11AEC:  MOVFF  8A7,8DF
11AF0:  MOVFF  8A6,8DE
11AF4:  MOVFF  8A5,8DD
11AF8:  MOVFF  8A4,8DC
11AFC:  MOVFF  8AB,8E3
11B00:  MOVFF  8AA,8E2
11B04:  MOVFF  8A9,8E1
11B08:  MOVFF  8A8,8E0
11B0C:  CALL   C5C4
11B10:  MOVFF  03,8AF
11B14:  MOVFF  02,8AE
11B18:  MOVFF  01,8AD
11B1C:  MOVFF  00,8AC
....................       NH4_abs_array[3] = log10(ratio); 
11B20:  MOVFF  8AF,8B3
11B24:  MOVFF  8AE,8B2
11B28:  MOVFF  8AD,8B1
11B2C:  MOVFF  8AC,8B0
11B30:  CALL   1081E
11B34:  MOVFF  03,3E4
11B38:  MOVFF  02,3E3
11B3C:  MOVFF  01,3E2
11B40:  MOVFF  00,3E1
11B44:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11B46:  MOVLW  04
11B48:  MOVWF  1E
11B4A:  MOVLW  25
11B4C:  MOVWF  1D
11B4E:  MOVLW  02
11B50:  MOVWF  FF6
11B52:  MOVLW  1F
11B54:  MOVWF  FF7
11B56:  MOVLW  00
11B58:  MOVWF  FF8
11B5A:  MOVLW  06
11B5C:  MOVLB  8
11B5E:  MOVWF  xCC
11B60:  MOVLB  0
11B62:  CALL   AA28
11B66:  MOVLW  10
11B68:  MOVWF  FE9
11B6A:  MOVFF  382,8D8
11B6E:  MOVFF  381,8D7
11B72:  CALL   AA5A
11B76:  MOVLW  0B
11B78:  MOVWF  FF6
11B7A:  MOVLW  1F
11B7C:  MOVWF  FF7
11B7E:  MOVLW  00
11B80:  MOVWF  FF8
11B82:  MOVLW  07
11B84:  MOVLB  8
11B86:  MOVWF  xCC
11B88:  MOVLB  0
11B8A:  CALL   AA28
11B8E:  MOVLW  10
11B90:  MOVWF  FE9
11B92:  MOVFF  384,8D8
11B96:  MOVFF  383,8D7
11B9A:  CALL   AA5A
11B9E:  MOVLW  15
11BA0:  MOVWF  FF6
11BA2:  MOVLW  1F
11BA4:  MOVWF  FF7
11BA6:  MOVLW  00
11BA8:  MOVWF  FF8
11BAA:  MOVLW  09
11BAC:  MOVLB  8
11BAE:  MOVWF  xCC
11BB0:  MOVLB  0
11BB2:  CALL   AA28
11BB6:  MOVLW  89
11BB8:  MOVWF  FE9
11BBA:  MOVFF  3D8,8B3
11BBE:  MOVFF  3D7,8B2
11BC2:  MOVFF  3D6,8B1
11BC6:  MOVFF  3D5,8B0
11BCA:  MOVLW  04
11BCC:  MOVLB  8
11BCE:  MOVWF  xB4
11BD0:  MOVLB  0
11BD2:  CALL   1088A
11BD6:  MOVLW  23
11BD8:  MOVWF  FF6
11BDA:  MOVLW  1F
11BDC:  MOVWF  FF7
11BDE:  MOVLW  00
11BE0:  MOVWF  FF8
11BE2:  MOVLW  07
11BE4:  MOVLB  8
11BE6:  MOVWF  xCC
11BE8:  MOVLB  0
11BEA:  CALL   AA28
11BEE:  MOVLW  10
11BF0:  MOVWF  FE9
11BF2:  MOVFF  386,8D8
11BF6:  MOVFF  385,8D7
11BFA:  CALL   AA5A
11BFE:  MOVLW  2D
11C00:  MOVWF  FF6
11C02:  MOVLW  1F
11C04:  MOVWF  FF7
11C06:  MOVLW  00
11C08:  MOVWF  FF8
11C0A:  MOVLW  07
11C0C:  MOVLB  8
11C0E:  MOVWF  xCC
11C10:  MOVLB  0
11C12:  CALL   AA28
11C16:  MOVLW  10
11C18:  MOVWF  FE9
11C1A:  MOVFF  388,8D8
11C1E:  MOVFF  387,8D7
11C22:  CALL   AA5A
11C26:  MOVLW  37
11C28:  MOVWF  FF6
11C2A:  MOVLW  1F
11C2C:  MOVWF  FF7
11C2E:  MOVLW  00
11C30:  MOVWF  FF8
11C32:  MOVLW  09
11C34:  MOVLB  8
11C36:  MOVWF  xCC
11C38:  MOVLB  0
11C3A:  CALL   AA28
11C3E:  MOVLW  89
11C40:  MOVWF  FE9
11C42:  MOVFF  3DC,8B3
11C46:  MOVFF  3DB,8B2
11C4A:  MOVFF  3DA,8B1
11C4E:  MOVFF  3D9,8B0
11C52:  MOVLW  04
11C54:  MOVLB  8
11C56:  MOVWF  xB4
11C58:  MOVLB  0
11C5A:  CALL   1088A
11C5E:  MOVLW  45
11C60:  MOVWF  FF6
11C62:  MOVLW  1F
11C64:  MOVWF  FF7
11C66:  MOVLW  00
11C68:  MOVWF  FF8
11C6A:  MOVLW  07
11C6C:  MOVLB  8
11C6E:  MOVWF  xCC
11C70:  MOVLB  0
11C72:  CALL   AA28
11C76:  MOVLW  10
11C78:  MOVWF  FE9
11C7A:  MOVFF  38A,8D8
11C7E:  MOVFF  389,8D7
11C82:  CALL   AA5A
11C86:  MOVLW  4F
11C88:  MOVWF  FF6
11C8A:  MOVLW  1F
11C8C:  MOVWF  FF7
11C8E:  MOVLW  00
11C90:  MOVWF  FF8
11C92:  MOVLW  07
11C94:  MOVLB  8
11C96:  MOVWF  xCC
11C98:  MOVLB  0
11C9A:  CALL   AA28
11C9E:  MOVLW  10
11CA0:  MOVWF  FE9
11CA2:  MOVFF  38C,8D8
11CA6:  MOVFF  38B,8D7
11CAA:  CALL   AA5A
11CAE:  MOVLW  59
11CB0:  MOVWF  FF6
11CB2:  MOVLW  1F
11CB4:  MOVWF  FF7
11CB6:  MOVLW  00
11CB8:  MOVWF  FF8
11CBA:  MOVLW  09
11CBC:  MOVLB  8
11CBE:  MOVWF  xCC
11CC0:  MOVLB  0
11CC2:  CALL   AA28
11CC6:  MOVLW  89
11CC8:  MOVWF  FE9
11CCA:  MOVFF  3E0,8B3
11CCE:  MOVFF  3DF,8B2
11CD2:  MOVFF  3DE,8B1
11CD6:  MOVFF  3DD,8B0
11CDA:  MOVLW  04
11CDC:  MOVLB  8
11CDE:  MOVWF  xB4
11CE0:  MOVLB  0
11CE2:  CALL   1088A
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
11CE6:  MOVF   1F,W
11CE8:  SUBLW  02
11CEA:  BNZ   11CF0
11CEC:  MOVF   20,F
11CEE:  BZ    11D30
11CF0:  MOVLW  68
11CF2:  MOVWF  FF6
11CF4:  MOVLW  1F
11CF6:  MOVWF  FF7
11CF8:  MOVLW  00
11CFA:  MOVWF  FF8
11CFC:  CLRF   1B
11CFE:  BTFSC  FF2.7
11D00:  BSF    1B.7
11D02:  BCF    FF2.7
11D04:  MOVLW  09
11D06:  MOVLB  A
11D08:  MOVWF  x1C
11D0A:  MOVLB  0
11D0C:  CALL   1024
11D10:  BTFSC  1B.7
11D12:  BSF    FF2.7
11D14:  MOVLW  04
11D16:  MOVWF  FEA
11D18:  MOVLW  25
11D1A:  MOVWF  FE9
11D1C:  CALL   78F8
11D20:  MOVLW  0D
11D22:  BTFSS  F9E.4
11D24:  BRA    11D22
11D26:  MOVWF  FAD
11D28:  MOVLW  0A
11D2A:  BTFSS  F9E.4
11D2C:  BRA    11D2A
11D2E:  MOVWF  FAD
11D30:  GOTO   12240 (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
11D34:  MOVLB  8
11D36:  CLRF   xA3
11D38:  MOVF   xA3,W
11D3A:  SUBLW  03
11D3C:  BNC   11D5C
11D3E:  MOVF   xA3,W
11D40:  MULLW  04
11D42:  MOVF   FF3,W
11D44:  CLRF   03
11D46:  ADDLW  E5
11D48:  MOVWF  FE9
11D4A:  MOVLW  03
11D4C:  ADDWFC 03,W
11D4E:  MOVWF  FEA
11D50:  CLRF   FEF
11D52:  CLRF   FEC
11D54:  CLRF   FEC
11D56:  CLRF   FEC
11D58:  INCF   xA3,F
11D5A:  BRA    11D38
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
11D5C:  MOVLB  3
11D5E:  MOVF   x93,F
11D60:  BTFSS  FD8.2
11D62:  BRA    11D68
11D64:  MOVF   x94,F
11D66:  BZ    11E04
11D68:  MOVF   x95,F
11D6A:  BNZ   11D70
11D6C:  MOVF   x96,F
11D6E:  BZ    11E04
....................       blank = SiO_array[0]; 
11D70:  MOVFF  394,8F9
11D74:  MOVFF  393,8F8
11D78:  MOVLB  0
11D7A:  CALL   C58E
11D7E:  MOVFF  03,8A7
11D82:  MOVFF  02,8A6
11D86:  MOVFF  01,8A5
11D8A:  MOVFF  00,8A4
....................       react = SiO_array[1]; 
11D8E:  MOVFF  396,8F9
11D92:  MOVFF  395,8F8
11D96:  CALL   C58E
11D9A:  MOVFF  03,8AB
11D9E:  MOVFF  02,8AA
11DA2:  MOVFF  01,8A9
11DA6:  MOVFF  00,8A8
....................       ratio = blank / react; 
11DAA:  MOVFF  8A7,8DF
11DAE:  MOVFF  8A6,8DE
11DB2:  MOVFF  8A5,8DD
11DB6:  MOVFF  8A4,8DC
11DBA:  MOVFF  8AB,8E3
11DBE:  MOVFF  8AA,8E2
11DC2:  MOVFF  8A9,8E1
11DC6:  MOVFF  8A8,8E0
11DCA:  CALL   C5C4
11DCE:  MOVFF  03,8AF
11DD2:  MOVFF  02,8AE
11DD6:  MOVFF  01,8AD
11DDA:  MOVFF  00,8AC
....................       SiO_abs_array[0] = log10(ratio); 
11DDE:  MOVFF  8AF,8B3
11DE2:  MOVFF  8AE,8B2
11DE6:  MOVFF  8AD,8B1
11DEA:  MOVFF  8AC,8B0
11DEE:  CALL   1081E
11DF2:  MOVFF  03,3E8
11DF6:  MOVFF  02,3E7
11DFA:  MOVFF  01,3E6
11DFE:  MOVFF  00,3E5
11E02:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
11E04:  MOVF   x97,F
11E06:  BNZ   11E0C
11E08:  MOVF   x98,F
11E0A:  BZ    11EA8
11E0C:  MOVF   x99,F
11E0E:  BNZ   11E14
11E10:  MOVF   x9A,F
11E12:  BZ    11EA8
....................       blank = SiO_array[2]; 
11E14:  MOVFF  398,8F9
11E18:  MOVFF  397,8F8
11E1C:  MOVLB  0
11E1E:  CALL   C58E
11E22:  MOVFF  03,8A7
11E26:  MOVFF  02,8A6
11E2A:  MOVFF  01,8A5
11E2E:  MOVFF  00,8A4
....................       react = SiO_array[3]; 
11E32:  MOVFF  39A,8F9
11E36:  MOVFF  399,8F8
11E3A:  CALL   C58E
11E3E:  MOVFF  03,8AB
11E42:  MOVFF  02,8AA
11E46:  MOVFF  01,8A9
11E4A:  MOVFF  00,8A8
....................       ratio = blank / react;    
11E4E:  MOVFF  8A7,8DF
11E52:  MOVFF  8A6,8DE
11E56:  MOVFF  8A5,8DD
11E5A:  MOVFF  8A4,8DC
11E5E:  MOVFF  8AB,8E3
11E62:  MOVFF  8AA,8E2
11E66:  MOVFF  8A9,8E1
11E6A:  MOVFF  8A8,8E0
11E6E:  CALL   C5C4
11E72:  MOVFF  03,8AF
11E76:  MOVFF  02,8AE
11E7A:  MOVFF  01,8AD
11E7E:  MOVFF  00,8AC
....................       SiO_abs_array[1] = log10(ratio); 
11E82:  MOVFF  8AF,8B3
11E86:  MOVFF  8AE,8B2
11E8A:  MOVFF  8AD,8B1
11E8E:  MOVFF  8AC,8B0
11E92:  CALL   1081E
11E96:  MOVFF  03,3EC
11E9A:  MOVFF  02,3EB
11E9E:  MOVFF  01,3EA
11EA2:  MOVFF  00,3E9
11EA6:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
11EA8:  MOVF   x9B,F
11EAA:  BNZ   11EB0
11EAC:  MOVF   x9C,F
11EAE:  BZ    11F4C
11EB0:  MOVF   x9D,F
11EB2:  BNZ   11EB8
11EB4:  MOVF   x9E,F
11EB6:  BZ    11F4C
....................       blank = SiO_array[4]; 
11EB8:  MOVFF  39C,8F9
11EBC:  MOVFF  39B,8F8
11EC0:  MOVLB  0
11EC2:  CALL   C58E
11EC6:  MOVFF  03,8A7
11ECA:  MOVFF  02,8A6
11ECE:  MOVFF  01,8A5
11ED2:  MOVFF  00,8A4
....................       react = SiO_array[5]; 
11ED6:  MOVFF  39E,8F9
11EDA:  MOVFF  39D,8F8
11EDE:  CALL   C58E
11EE2:  MOVFF  03,8AB
11EE6:  MOVFF  02,8AA
11EEA:  MOVFF  01,8A9
11EEE:  MOVFF  00,8A8
....................       ratio = blank / react; 
11EF2:  MOVFF  8A7,8DF
11EF6:  MOVFF  8A6,8DE
11EFA:  MOVFF  8A5,8DD
11EFE:  MOVFF  8A4,8DC
11F02:  MOVFF  8AB,8E3
11F06:  MOVFF  8AA,8E2
11F0A:  MOVFF  8A9,8E1
11F0E:  MOVFF  8A8,8E0
11F12:  CALL   C5C4
11F16:  MOVFF  03,8AF
11F1A:  MOVFF  02,8AE
11F1E:  MOVFF  01,8AD
11F22:  MOVFF  00,8AC
....................       SiO_abs_array[2] = log10(ratio); 
11F26:  MOVFF  8AF,8B3
11F2A:  MOVFF  8AE,8B2
11F2E:  MOVFF  8AD,8B1
11F32:  MOVFF  8AC,8B0
11F36:  CALL   1081E
11F3A:  MOVFF  03,3F0
11F3E:  MOVFF  02,3EF
11F42:  MOVFF  01,3EE
11F46:  MOVFF  00,3ED
11F4A:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
11F4C:  MOVF   x9F,F
11F4E:  BNZ   11F54
11F50:  MOVF   xA0,F
11F52:  BZ    11FF0
11F54:  MOVF   xA1,F
11F56:  BNZ   11F5C
11F58:  MOVF   xA2,F
11F5A:  BZ    11FF0
....................       blank = SiO_array[6]; 
11F5C:  MOVFF  3A0,8F9
11F60:  MOVFF  39F,8F8
11F64:  MOVLB  0
11F66:  CALL   C58E
11F6A:  MOVFF  03,8A7
11F6E:  MOVFF  02,8A6
11F72:  MOVFF  01,8A5
11F76:  MOVFF  00,8A4
....................       react = SiO_array[7]; 
11F7A:  MOVFF  3A2,8F9
11F7E:  MOVFF  3A1,8F8
11F82:  CALL   C58E
11F86:  MOVFF  03,8AB
11F8A:  MOVFF  02,8AA
11F8E:  MOVFF  01,8A9
11F92:  MOVFF  00,8A8
....................       ratio = blank / react; 
11F96:  MOVFF  8A7,8DF
11F9A:  MOVFF  8A6,8DE
11F9E:  MOVFF  8A5,8DD
11FA2:  MOVFF  8A4,8DC
11FA6:  MOVFF  8AB,8E3
11FAA:  MOVFF  8AA,8E2
11FAE:  MOVFF  8A9,8E1
11FB2:  MOVFF  8A8,8E0
11FB6:  CALL   C5C4
11FBA:  MOVFF  03,8AF
11FBE:  MOVFF  02,8AE
11FC2:  MOVFF  01,8AD
11FC6:  MOVFF  00,8AC
....................       SiO_abs_array[3] = log10(ratio); 
11FCA:  MOVFF  8AF,8B3
11FCE:  MOVFF  8AE,8B2
11FD2:  MOVFF  8AD,8B1
11FD6:  MOVFF  8AC,8B0
11FDA:  CALL   1081E
11FDE:  MOVFF  03,3F4
11FE2:  MOVFF  02,3F3
11FE6:  MOVFF  01,3F2
11FEA:  MOVFF  00,3F1
11FEE:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
11FF0:  MOVLW  04
11FF2:  MOVWF  1E
11FF4:  MOVLW  25
11FF6:  MOVWF  1D
11FF8:  MOVLW  76
11FFA:  MOVWF  FF6
11FFC:  MOVLW  1F
11FFE:  MOVWF  FF7
12000:  MOVLW  00
12002:  MOVWF  FF8
12004:  MOVLW  06
12006:  MOVLB  8
12008:  MOVWF  xCC
1200A:  MOVLB  0
1200C:  CALL   AA28
12010:  MOVLW  10
12012:  MOVWF  FE9
12014:  MOVFF  394,8D8
12018:  MOVFF  393,8D7
1201C:  CALL   AA5A
12020:  MOVLW  7F
12022:  MOVWF  FF6
12024:  MOVLW  1F
12026:  MOVWF  FF7
12028:  MOVLW  00
1202A:  MOVWF  FF8
1202C:  MOVLW  07
1202E:  MOVLB  8
12030:  MOVWF  xCC
12032:  MOVLB  0
12034:  CALL   AA28
12038:  MOVLW  10
1203A:  MOVWF  FE9
1203C:  MOVFF  396,8D8
12040:  MOVFF  395,8D7
12044:  CALL   AA5A
12048:  MOVLW  89
1204A:  MOVWF  FF6
1204C:  MOVLW  1F
1204E:  MOVWF  FF7
12050:  MOVLW  00
12052:  MOVWF  FF8
12054:  MOVLW  09
12056:  MOVLB  8
12058:  MOVWF  xCC
1205A:  MOVLB  0
1205C:  CALL   AA28
12060:  MOVLW  89
12062:  MOVWF  FE9
12064:  MOVFF  3E8,8B3
12068:  MOVFF  3E7,8B2
1206C:  MOVFF  3E6,8B1
12070:  MOVFF  3E5,8B0
12074:  MOVLW  04
12076:  MOVLB  8
12078:  MOVWF  xB4
1207A:  MOVLB  0
1207C:  CALL   1088A
12080:  MOVLW  97
12082:  MOVWF  FF6
12084:  MOVLW  1F
12086:  MOVWF  FF7
12088:  MOVLW  00
1208A:  MOVWF  FF8
1208C:  MOVLW  07
1208E:  MOVLB  8
12090:  MOVWF  xCC
12092:  MOVLB  0
12094:  CALL   AA28
12098:  MOVLW  10
1209A:  MOVWF  FE9
1209C:  MOVFF  398,8D8
120A0:  MOVFF  397,8D7
120A4:  CALL   AA5A
120A8:  MOVLW  A1
120AA:  MOVWF  FF6
120AC:  MOVLW  1F
120AE:  MOVWF  FF7
120B0:  MOVLW  00
120B2:  MOVWF  FF8
120B4:  MOVLW  07
120B6:  MOVLB  8
120B8:  MOVWF  xCC
120BA:  MOVLB  0
120BC:  CALL   AA28
120C0:  MOVLW  10
120C2:  MOVWF  FE9
120C4:  MOVFF  39A,8D8
120C8:  MOVFF  399,8D7
120CC:  CALL   AA5A
120D0:  MOVLW  AB
120D2:  MOVWF  FF6
120D4:  MOVLW  1F
120D6:  MOVWF  FF7
120D8:  MOVLW  00
120DA:  MOVWF  FF8
120DC:  MOVLW  09
120DE:  MOVLB  8
120E0:  MOVWF  xCC
120E2:  MOVLB  0
120E4:  CALL   AA28
120E8:  MOVLW  89
120EA:  MOVWF  FE9
120EC:  MOVFF  3EC,8B3
120F0:  MOVFF  3EB,8B2
120F4:  MOVFF  3EA,8B1
120F8:  MOVFF  3E9,8B0
120FC:  MOVLW  04
120FE:  MOVLB  8
12100:  MOVWF  xB4
12102:  MOVLB  0
12104:  CALL   1088A
12108:  MOVLW  B9
1210A:  MOVWF  FF6
1210C:  MOVLW  1F
1210E:  MOVWF  FF7
12110:  MOVLW  00
12112:  MOVWF  FF8
12114:  MOVLW  07
12116:  MOVLB  8
12118:  MOVWF  xCC
1211A:  MOVLB  0
1211C:  CALL   AA28
12120:  MOVLW  10
12122:  MOVWF  FE9
12124:  MOVFF  39C,8D8
12128:  MOVFF  39B,8D7
1212C:  CALL   AA5A
12130:  MOVLW  C3
12132:  MOVWF  FF6
12134:  MOVLW  1F
12136:  MOVWF  FF7
12138:  MOVLW  00
1213A:  MOVWF  FF8
1213C:  MOVLW  07
1213E:  MOVLB  8
12140:  MOVWF  xCC
12142:  MOVLB  0
12144:  CALL   AA28
12148:  MOVLW  10
1214A:  MOVWF  FE9
1214C:  MOVFF  39E,8D8
12150:  MOVFF  39D,8D7
12154:  CALL   AA5A
12158:  MOVLW  CD
1215A:  MOVWF  FF6
1215C:  MOVLW  1F
1215E:  MOVWF  FF7
12160:  MOVLW  00
12162:  MOVWF  FF8
12164:  MOVLW  09
12166:  MOVLB  8
12168:  MOVWF  xCC
1216A:  MOVLB  0
1216C:  CALL   AA28
12170:  MOVLW  89
12172:  MOVWF  FE9
12174:  MOVFF  3F0,8B3
12178:  MOVFF  3EF,8B2
1217C:  MOVFF  3EE,8B1
12180:  MOVFF  3ED,8B0
12184:  MOVLW  04
12186:  MOVLB  8
12188:  MOVWF  xB4
1218A:  MOVLB  0
1218C:  CALL   1088A
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
12190:  MOVF   1F,W
12192:  SUBLW  02
12194:  BNZ   1219A
12196:  MOVF   20,F
12198:  BZ    121DA
1219A:  MOVLW  DC
1219C:  MOVWF  FF6
1219E:  MOVLW  1F
121A0:  MOVWF  FF7
121A2:  MOVLW  00
121A4:  MOVWF  FF8
121A6:  CLRF   1B
121A8:  BTFSC  FF2.7
121AA:  BSF    1B.7
121AC:  BCF    FF2.7
121AE:  MOVLW  09
121B0:  MOVLB  A
121B2:  MOVWF  x1C
121B4:  MOVLB  0
121B6:  CALL   1024
121BA:  BTFSC  1B.7
121BC:  BSF    FF2.7
121BE:  MOVLW  04
121C0:  MOVWF  FEA
121C2:  MOVLW  25
121C4:  MOVWF  FE9
121C6:  CALL   78F8
121CA:  MOVLW  0D
121CC:  BTFSS  F9E.4
121CE:  BRA    121CC
121D0:  MOVWF  FAD
121D2:  MOVLW  0A
121D4:  BTFSS  F9E.4
121D6:  BRA    121D4
121D8:  MOVWF  FAD
121DA:  GOTO   12240 (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
121DE:  MOVLW  04
121E0:  MOVWF  FEA
121E2:  MOVLW  25
121E4:  MOVWF  FE9
121E6:  MOVLW  00
121E8:  CALL   056C
121EC:  TBLRD*-
121EE:  TBLRD*+
121F0:  MOVF   FF5,W
121F2:  MOVWF  FEE
121F4:  IORLW  00
121F6:  BNZ   121EE
....................     
....................    switch (chem){ 
121F8:  MOVLW  EA
121FA:  MOVWF  FF6
121FC:  MOVLW  1F
121FE:  MOVWF  FF7
12200:  MOVLW  00
12202:  MOVWF  FF8
12204:  MOVLW  03
12206:  MOVWF  FEA
12208:  MOVLW  3D
1220A:  MOVWF  FE9
1220C:  CALL   FAC4
12210:  MOVF   01,W
12212:  BZ    12226
12214:  XORLW  01
12216:  BZ    1222C
12218:  XORLW  03
1221A:  BZ    12232
1221C:  XORLW  01
1221E:  BZ    12238
12220:  XORLW  07
12222:  BZ    1223E
12224:  BRA    12240
....................       case "NO3" : calc_abs_NO3(); 
12226:  GOTO   10A9C
....................          break; 
1222A:  BRA    12240
....................       case "NO2" : calc_abs_NO2 (); 
1222C:  GOTO   10F38
....................          break;    
12230:  BRA    12240
....................       case "PO4" : calc_abs_PO4(); 
12232:  GOTO   113E0
....................          break; 
12236:  BRA    12240
....................       case "NH4" : calc_abs_NH4(); 
12238:  GOTO   1188A
....................          break; 
1223C:  BRA    12240
....................       case "SiO" : calc_abs_SiO(); 
1223E:  BRA    11D34
....................          break; 
....................    } 
12240:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
12242:  CALL   D198
....................     
....................    if (data_available == TRUE) { 
12246:  MOVLB  3
12248:  DECFSZ x3B,W
1224A:  BRA    1234E
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
1224C:  MOVLB  8
1224E:  CLRF   xDA
12250:  MOVLW  67
12252:  MOVWF  xD9
12254:  MOVLW  02
12256:  MOVWF  xDC
12258:  MOVLW  B7
1225A:  MOVWF  xDB
1225C:  MOVLB  0
1225E:  CALL   5472
....................       strcat(data_buffer, comma); 
12262:  MOVLB  8
12264:  CLRF   xDA
12266:  MOVLW  67
12268:  MOVWF  xD9
1226A:  MOVLW  03
1226C:  MOVWF  xDC
1226E:  MOVLW  39
12270:  MOVWF  xDB
12272:  MOVLB  0
12274:  CALL   5472
....................       strcat(data_buffer, chem); 
12278:  MOVLB  8
1227A:  CLRF   xDA
1227C:  MOVLW  67
1227E:  MOVWF  xD9
12280:  MOVLW  03
12282:  MOVWF  xDC
12284:  MOVLW  3D
12286:  MOVWF  xDB
12288:  MOVLB  0
1228A:  CALL   5472
....................       strcat(data_buffer, comma); 
1228E:  MOVLB  8
12290:  CLRF   xDA
12292:  MOVLW  67
12294:  MOVWF  xD9
12296:  MOVLW  03
12298:  MOVWF  xDC
1229A:  MOVLW  39
1229C:  MOVWF  xDB
1229E:  MOVLB  0
122A0:  CALL   5472
....................       strcat(data_buffer, abs_str); 
122A4:  MOVLB  8
122A6:  CLRF   xDA
122A8:  MOVLW  67
122AA:  MOVWF  xD9
122AC:  MOVLW  04
122AE:  MOVWF  xDC
122B0:  MOVLW  25
122B2:  MOVWF  xDB
122B4:  MOVLB  0
122B6:  CALL   5472
....................       strcat(data_buffer, endofline); 
122BA:  MOVLB  8
122BC:  CLRF   xDA
122BE:  MOVLW  67
122C0:  MOVWF  xD9
122C2:  MOVLW  07
122C4:  MOVWF  xDC
122C6:  MOVLW  CE
122C8:  MOVWF  xDB
122CA:  MOVLB  0
122CC:  CALL   5472
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
122D0:  MOVF   1F,W
122D2:  SUBLW  04
122D4:  BNZ   122F4
122D6:  MOVF   20,F
122D8:  BNZ   122F4
122DA:  CLRF   FEA
122DC:  MOVLW  67
122DE:  MOVWF  FE9
122E0:  CALL   78F8
122E4:  MOVLW  0D
122E6:  BTFSS  F9E.4
122E8:  BRA    122E6
122EA:  MOVWF  FAD
122EC:  MOVLW  0A
122EE:  BTFSS  F9E.4
122F0:  BRA    122EE
122F2:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
122F4:  MOVLB  2
122F6:  MOVF   xDC,F
122F8:  BNZ   1234C
....................        
....................          buffer_select = 0; 
122FA:  MOVLB  0
122FC:  CLRF   x66
....................           
....................          heartbeat(FALSE); 
122FE:  MOVLB  8
12300:  CLRF   xCE
12302:  MOVLB  0
12304:  CALL   5516
....................             append_data(file_ptr_rel_all); 
12308:  MOVLW  02
1230A:  MOVLB  8
1230C:  MOVWF  xCF
1230E:  MOVLW  F9
12310:  MOVWF  xCE
12312:  MOVLB  0
12314:  CALL   8254
....................          heartbeat(TRUE);          
12318:  MOVLW  01
1231A:  MOVLB  8
1231C:  MOVWF  xCE
1231E:  MOVLB  0
12320:  CALL   5516
....................           
....................          heartbeat(FALSE); 
12324:  MOVLB  8
12326:  CLRF   xCE
12328:  MOVLB  0
1232A:  CALL   5516
....................             append_data(file_ptr_rel_new);    
1232E:  MOVLW  03
12330:  MOVLB  8
12332:  MOVWF  xCF
12334:  MOVLW  07
12336:  MOVWF  xCE
12338:  MOVLB  0
1233A:  CALL   8254
....................          heartbeat(TRUE); 
1233E:  MOVLW  01
12340:  MOVLB  8
12342:  MOVWF  xCE
12344:  MOVLB  0
12346:  CALL   5516
1234A:  MOVLB  2
1234C:  MOVLB  3
....................       } 
....................    } 
1234E:  MOVLB  0
12350:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D2AE:  MOVLW  2C
0D2B0:  MOVLB  8
0D2B2:  MOVWF  x7F
0D2B4:  CLRF   x80
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D2B6:  MOVLW  0D
0D2B8:  MOVWF  x81
0D2BA:  MOVLW  0A
0D2BC:  MOVWF  x82
0D2BE:  CLRF   x83
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D2C0:  MOVLB  0
0D2C2:  RCALL  D198
....................    time_stamp(); 
0D2C4:  CALL   53AE
....................    strcat(data_buffer, time_stmp_str); 
0D2C8:  MOVLB  8
0D2CA:  CLRF   xDA
0D2CC:  MOVLW  67
0D2CE:  MOVWF  xD9
0D2D0:  MOVLW  02
0D2D2:  MOVWF  xDC
0D2D4:  MOVLW  99
0D2D6:  MOVWF  xDB
0D2D8:  MOVLB  0
0D2DA:  CALL   5472
....................    strcat(data_buffer, comma); 
0D2DE:  MOVLB  8
0D2E0:  CLRF   xDA
0D2E2:  MOVLW  67
0D2E4:  MOVWF  xD9
0D2E6:  MOVLW  08
0D2E8:  MOVWF  xDC
0D2EA:  MOVLW  7F
0D2EC:  MOVWF  xDB
0D2EE:  MOVLB  0
0D2F0:  CALL   5472
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D2F4:  MOVLW  08
0D2F6:  MOVWF  1E
0D2F8:  MOVLW  84
0D2FA:  MOVWF  1D
0D2FC:  MOVFF  87E,8CE
0D300:  MOVLW  1B
0D302:  MOVLB  8
0D304:  MOVWF  xCF
0D306:  MOVLB  0
0D308:  CALL   5214
0D30C:  MOVLW  2C
0D30E:  MOVLB  8
0D310:  MOVWF  xE0
0D312:  MOVLB  0
0D314:  CALL   5032
0D318:  MOVLW  10
0D31A:  MOVWF  FE9
0D31C:  MOVFF  2A,8D8
0D320:  MOVFF  29,8D7
0D324:  CALL   AA5A
0D328:  MOVLW  2C
0D32A:  MOVLB  8
0D32C:  MOVWF  xE0
0D32E:  MOVLB  0
0D330:  CALL   5032
0D334:  MOVLW  10
0D336:  MOVWF  FE9
0D338:  MOVFF  24,8D8
0D33C:  MOVFF  23,8D7
0D340:  CALL   AA5A
0D344:  MOVLW  2C
0D346:  MOVLB  8
0D348:  MOVWF  xE0
0D34A:  MOVLB  0
0D34C:  CALL   5032
0D350:  MOVLW  10
0D352:  MOVWF  FE9
0D354:  MOVFF  2C,8D8
0D358:  MOVFF  2B,8D7
0D35C:  CALL   AA5A
0D360:  MOVLW  2C
0D362:  MOVLB  8
0D364:  MOVWF  xE0
0D366:  MOVLB  0
0D368:  CALL   5032
0D36C:  MOVLW  10
0D36E:  MOVWF  FE9
0D370:  MOVFF  2E,8D8
0D374:  MOVFF  2D,8D7
0D378:  CALL   AA5A
0D37C:  MOVLW  2C
0D37E:  MOVLB  8
0D380:  MOVWF  xE0
0D382:  MOVLB  0
0D384:  CALL   5032
0D388:  MOVLW  10
0D38A:  MOVWF  FE9
0D38C:  MOVFF  22,8D8
0D390:  MOVFF  21,8D7
0D394:  CALL   AA5A
0D398:  MOVLW  2C
0D39A:  MOVLB  8
0D39C:  MOVWF  xE0
0D39E:  MOVLB  0
0D3A0:  CALL   5032
0D3A4:  MOVLW  10
0D3A6:  MOVWF  FE9
0D3A8:  MOVFF  7C8,8D8
0D3AC:  MOVFF  7C7,8D7
0D3B0:  CALL   AA5A
0D3B4:  MOVLW  2C
0D3B6:  MOVLB  8
0D3B8:  MOVWF  xE0
0D3BA:  MOVLB  0
0D3BC:  CALL   5032
0D3C0:  MOVLW  10
0D3C2:  MOVWF  FE9
0D3C4:  MOVFF  7B6,8A3
0D3C8:  MOVFF  7B5,8A2
0D3CC:  BRA    D1AC
....................    strcat(data_buffer, config_str); 
0D3CE:  MOVLB  8
0D3D0:  CLRF   xDA
0D3D2:  MOVLW  67
0D3D4:  MOVWF  xD9
0D3D6:  MOVLW  08
0D3D8:  MOVWF  xDC
0D3DA:  MOVLW  84
0D3DC:  MOVWF  xDB
0D3DE:  MOVLB  0
0D3E0:  CALL   5472
....................    strcat(data_buffer, endofline); 
0D3E4:  MOVLB  8
0D3E6:  CLRF   xDA
0D3E8:  MOVLW  67
0D3EA:  MOVWF  xD9
0D3EC:  MOVLW  08
0D3EE:  MOVWF  xDC
0D3F0:  MOVLW  81
0D3F2:  MOVWF  xDB
0D3F4:  MOVLB  0
0D3F6:  CALL   5472
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D3FA:  CLRF   FEA
0D3FC:  MOVLW  67
0D3FE:  MOVWF  FE9
0D400:  CALL   78F8
0D404:  MOVLW  0D
0D406:  BTFSS  F9E.4
0D408:  BRA    D406
0D40A:  MOVWF  FAD
0D40C:  MOVLW  0A
0D40E:  BTFSS  F9E.4
0D410:  BRA    D40E
0D412:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D414:  MOVLB  2
0D416:  MOVF   xDC,F
0D418:  BNZ   D46C
....................     
....................       buffer_select = 0; 
0D41A:  MOVLB  0
0D41C:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
0D41E:  MOVLB  8
0D420:  CLRF   xCE
0D422:  MOVLB  0
0D424:  CALL   5516
....................          append_data(file_ptr_raw_all); 
0D428:  MOVLW  02
0D42A:  MOVLB  8
0D42C:  MOVWF  xCF
0D42E:  MOVLW  DD
0D430:  MOVWF  xCE
0D432:  MOVLB  0
0D434:  CALL   8254
....................       heartbeat(TRUE);          
0D438:  MOVLW  01
0D43A:  MOVLB  8
0D43C:  MOVWF  xCE
0D43E:  MOVLB  0
0D440:  CALL   5516
....................        
....................       heartbeat(FALSE); 
0D444:  MOVLB  8
0D446:  CLRF   xCE
0D448:  MOVLB  0
0D44A:  CALL   5516
....................          append_data(file_ptr_raw_new);    
0D44E:  MOVLW  02
0D450:  MOVLB  8
0D452:  MOVWF  xCF
0D454:  MOVLW  EB
0D456:  MOVWF  xCE
0D458:  MOVLB  0
0D45A:  CALL   8254
....................       heartbeat(TRUE); 
0D45E:  MOVLW  01
0D460:  MOVLB  8
0D462:  MOVWF  xCE
0D464:  MOVLB  0
0D466:  CALL   5516
0D46A:  MOVLB  2
....................    } 
0D46C:  MOVLB  0
0D46E:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
14E26:  MOVLW  2C
14E28:  MOVLB  8
14E2A:  MOVWF  x81
14E2C:  CLRF   x82
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
14E2E:  MOVLW  0D
14E30:  MOVWF  x83
14E32:  MOVLW  0A
14E34:  MOVWF  x84
14E36:  CLRF   x85
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
14E38:  MOVLB  0
14E3A:  CALL   D198
....................    time_stamp(); 
14E3E:  CALL   53AE
....................    strcat(data_buffer, time_stmp_str); 
14E42:  MOVLB  8
14E44:  CLRF   xDA
14E46:  MOVLW  67
14E48:  MOVWF  xD9
14E4A:  MOVLW  02
14E4C:  MOVWF  xDC
14E4E:  MOVLW  99
14E50:  MOVWF  xDB
14E52:  MOVLB  0
14E54:  CALL   5472
....................    strcat(data_buffer, comma); 
14E58:  MOVLB  8
14E5A:  CLRF   xDA
14E5C:  MOVLW  67
14E5E:  MOVWF  xD9
14E60:  MOVLW  08
14E62:  MOVWF  xDC
14E64:  MOVLW  81
14E66:  MOVWF  xDB
14E68:  MOVLB  0
14E6A:  CALL   5472
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
14E6E:  MOVLW  08
14E70:  MOVWF  1E
14E72:  MOVLW  86
14E74:  MOVWF  1D
14E76:  MOVFF  87E,8CE
14E7A:  MOVLW  1B
14E7C:  MOVLB  8
14E7E:  MOVWF  xCF
14E80:  MOVLB  0
14E82:  CALL   5214
14E86:  MOVLW  2C
14E88:  MOVLB  8
14E8A:  MOVWF  xE0
14E8C:  MOVLB  0
14E8E:  CALL   5032
14E92:  MOVLW  10
14E94:  MOVWF  FE9
14E96:  MOVFF  880,8D8
14E9A:  MOVFF  87F,8D7
14E9E:  CALL   AA5A
....................    strcat(data_buffer, config_str); 
14EA2:  MOVLB  8
14EA4:  CLRF   xDA
14EA6:  MOVLW  67
14EA8:  MOVWF  xD9
14EAA:  MOVLW  08
14EAC:  MOVWF  xDC
14EAE:  MOVLW  86
14EB0:  MOVWF  xDB
14EB2:  MOVLB  0
14EB4:  CALL   5472
....................    strcat(data_buffer, endofline); 
14EB8:  MOVLB  8
14EBA:  CLRF   xDA
14EBC:  MOVLW  67
14EBE:  MOVWF  xD9
14EC0:  MOVLW  08
14EC2:  MOVWF  xDC
14EC4:  MOVLW  83
14EC6:  MOVWF  xDB
14EC8:  MOVLB  0
14ECA:  CALL   5472
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
14ECE:  MOVF   1F,W
14ED0:  SUBLW  04
14ED2:  BNZ   14EF2
14ED4:  MOVF   20,F
14ED6:  BNZ   14EF2
14ED8:  CLRF   FEA
14EDA:  MOVLW  67
14EDC:  MOVWF  FE9
14EDE:  CALL   78F8
14EE2:  MOVLW  0D
14EE4:  BTFSS  F9E.4
14EE6:  BRA    14EE4
14EE8:  MOVWF  FAD
14EEA:  MOVLW  0A
14EEC:  BTFSS  F9E.4
14EEE:  BRA    14EEC
14EF0:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
14EF2:  MOVLB  2
14EF4:  MOVF   xDC,F
14EF6:  BNZ   14F4A
....................     
....................       buffer_select = 0; 
14EF8:  MOVLB  0
14EFA:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
14EFC:  MOVLB  8
14EFE:  CLRF   xCE
14F00:  MOVLB  0
14F02:  CALL   5516
....................          append_data(file_ptr_raw_all); 
14F06:  MOVLW  02
14F08:  MOVLB  8
14F0A:  MOVWF  xCF
14F0C:  MOVLW  DD
14F0E:  MOVWF  xCE
14F10:  MOVLB  0
14F12:  CALL   8254
....................       heartbeat(TRUE);          
14F16:  MOVLW  01
14F18:  MOVLB  8
14F1A:  MOVWF  xCE
14F1C:  MOVLB  0
14F1E:  CALL   5516
....................        
....................       heartbeat(FALSE); 
14F22:  MOVLB  8
14F24:  CLRF   xCE
14F26:  MOVLB  0
14F28:  CALL   5516
....................          append_data(file_ptr_raw_new);    
14F2C:  MOVLW  02
14F2E:  MOVLB  8
14F30:  MOVWF  xCF
14F32:  MOVLW  EB
14F34:  MOVWF  xCE
14F36:  MOVLB  0
14F38:  CALL   8254
....................       heartbeat(TRUE); 
14F3C:  MOVLW  01
14F3E:  MOVLB  8
14F40:  MOVWF  xCE
14F42:  MOVLB  0
14F44:  CALL   5516
14F48:  MOVLB  2
....................    } 
14F4A:  MOVLB  0
14F4C:  GOTO   150E8 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0CFE0:  BSF    F90.7
....................    delay_ms(500); 
0CFE2:  MOVLW  02
0CFE4:  MOVLB  8
0CFE6:  MOVWF  xA3
0CFE8:  MOVLW  FA
0CFEA:  MOVLB  9
0CFEC:  MOVWF  xCD
0CFEE:  MOVLB  0
0CFF0:  CALL   28AC
0CFF4:  MOVLB  8
0CFF6:  DECFSZ xA3,F
0CFF8:  BRA    CFE8
....................    bus_pwr_status=1; 
0CFFA:  MOVLW  01
0CFFC:  MOVLB  4
0CFFE:  MOVWF  xB6
0D000:  MOVLB  0
0D002:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D004:  BCF    F90.7
....................    delay_ms(100); 
0D006:  MOVLW  64
0D008:  MOVLB  9
0D00A:  MOVWF  xCD
0D00C:  MOVLB  0
0D00E:  CALL   28AC
....................    bus_pwr_status=0; 
0D012:  MOVLB  4
0D014:  CLRF   xB6
0D016:  MOVLB  0
0D018:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
17B20:  MOVLB  8
17B22:  CLRF   x78
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
17B24:  CLRF   x78
17B26:  MOVF   x78,W
17B28:  SUBLW  31
17B2A:  BNC   17B40
....................       string_arg[i] = 0; 
17B2C:  CLRF   03
17B2E:  MOVF   x78,W
17B30:  ADDLW  25
17B32:  MOVWF  FE9
17B34:  MOVLW  08
17B36:  ADDWFC 03,W
17B38:  MOVWF  FEA
17B3A:  CLRF   FEF
17B3C:  INCF   x78,F
17B3E:  BRA    17B26
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
17B40:  CLRF   x78
17B42:  MOVF   x78,W
17B44:  SUBLW  31
17B46:  BNC   17BC0
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
17B48:  CLRF   03
17B4A:  MOVF   x78,W
17B4C:  ADDLW  25
17B4E:  MOVWF  FE9
17B50:  MOVLW  08
17B52:  ADDWFC 03,W
17B54:  MOVWF  FEA
17B56:  MOVFF  FEA,87C
17B5A:  MOVFF  FE9,87B
17B5E:  MOVLB  0
17B60:  CALL   0E38
17B64:  MOVFF  87C,FEA
17B68:  MOVFF  87B,FE9
17B6C:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
17B70:  DECFSZ 4C,W
17B72:  BRA    17B90
....................       { 
....................          fputc(string_arg[i],COM_A); 
17B74:  CLRF   03
17B76:  MOVLB  8
17B78:  MOVF   x78,W
17B7A:  ADDLW  25
17B7C:  MOVWF  FE9
17B7E:  MOVLW  08
17B80:  ADDWFC 03,W
17B82:  MOVWF  FEA
17B84:  MOVFF  FEF,879
17B88:  MOVF   x79,W
17B8A:  MOVLB  0
17B8C:  CALL   ADD8
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
17B90:  CLRF   03
17B92:  MOVLB  8
17B94:  MOVF   x78,W
17B96:  ADDLW  25
17B98:  MOVWF  FE9
17B9A:  MOVLW  08
17B9C:  ADDWFC 03,W
17B9E:  MOVWF  FEA
17BA0:  MOVF   FEF,W
17BA2:  SUBLW  0D
17BA4:  BZ    17BBA
17BA6:  CLRF   03
17BA8:  MOVF   x78,W
17BAA:  ADDLW  25
17BAC:  MOVWF  FE9
17BAE:  MOVLW  08
17BB0:  ADDWFC 03,W
17BB2:  MOVWF  FEA
17BB4:  MOVF   FEF,W
17BB6:  SUBLW  0A
17BB8:  BNZ   17BBC
....................       { 
....................          break; 
17BBA:  BRA    17BC0
....................       } 
17BBC:  INCF   x78,F
17BBE:  BRA    17B42
....................    } 
17BC0:  MOVLB  0
17BC2:  GOTO   17EEA (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
17D68:  MOVLB  8
17D6A:  CLRF   x78
....................    macro_arg = 0; 
17D6C:  CLRF   x7A
17D6E:  CLRF   x79
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
17D70:  MOVF   x78,W
17D72:  SUBLW  0D
17D74:  BZ    17E00
....................       number = fgetc(COM_A); 
17D76:  MOVLB  0
17D78:  CALL   0E38
17D7C:  MOVFF  01,878
....................       if (com_echo == TRUE) 
17D80:  DECFSZ 4C,W
17D82:  BRA    17D94
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
17D84:  MOVLB  8
17D86:  MOVF   x78,W
17D88:  SUBLW  0D
17D8A:  BZ    17D96
17D8C:  MOVF   x78,W
17D8E:  MOVLB  0
17D90:  CALL   ADD8
17D94:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
17D96:  MOVF   x78,W
17D98:  SUBLW  2F
17D9A:  BC    17DD0
17D9C:  MOVF   x78,W
17D9E:  SUBLW  39
17DA0:  BNC   17DD0
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
17DA2:  MOVLW  30
17DA4:  SUBWF  x78,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
17DA6:  MOVFF  87A,9EE
17DAA:  MOVFF  879,9ED
17DAE:  MOVLB  9
17DB0:  CLRF   xF0
17DB2:  MOVLW  0A
17DB4:  MOVWF  xEF
17DB6:  MOVLB  0
17DB8:  CALL   5C32
17DBC:  MOVFF  02,87A
17DC0:  MOVFF  01,879
....................          macro_arg = macro_arg + number;                // for each number 
17DC4:  MOVLB  8
17DC6:  MOVF   x78,W
17DC8:  ADDWF  x79,F
17DCA:  MOVLW  00
17DCC:  ADDWFC x7A,F
....................       } 
17DCE:  BRA    17DFE
....................       else if (number == CARRIAGE_RET) 
17DD0:  MOVF   x78,W
17DD2:  SUBLW  0D
17DD4:  BNZ   17DF6
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
17DD6:  INCFSZ x79,W
17DD8:  BRA    17DE0
17DDA:  INCFSZ x7A,W
17DDC:  BRA    17DE0
17DDE:  BRA    17DEC
17DE0:  MOVFF  879,01
17DE4:  MOVFF  87A,02
17DE8:  BRA    17E00
17DEA:  BRA    17DF4
....................          else return(65535); 
17DEC:  MOVLW  FF
17DEE:  MOVWF  01
17DF0:  MOVWF  02
17DF2:  BRA    17E00
....................       } 
17DF4:  BRA    17DFE
....................       else 
....................       { 
....................          return(65535); 
17DF6:  MOVLW  FF
17DF8:  MOVWF  01
17DFA:  MOVWF  02
17DFC:  BRA    17E00
....................       } 
17DFE:  BRA    17D70
....................    } 
17E00:  MOVLB  0
17E02:  GOTO   17F14 (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
178B0:  MOVF   2F,W
178B2:  MOVWF  00
178B4:  MOVF   30,W
178B6:  MOVWF  03
178B8:  BNZ   178BE
178BA:  MOVF   00,F
178BC:  BZ    178E4
178BE:  MOVF   03,W
178C0:  BNZ   178CA
178C2:  MOVLW  03
178C4:  SUBWF  00,W
178C6:  BTFSC  FD8.2
178C8:  BRA    179A2
178CA:  MOVF   03,W
178CC:  BNZ   178D6
178CE:  MOVLW  01
178D0:  SUBWF  00,W
178D2:  BTFSC  FD8.2
178D4:  BRA    179A2
178D6:  MOVF   03,W
178D8:  BNZ   178E2
178DA:  MOVLW  02
178DC:  SUBWF  00,W
178DE:  BTFSC  FD8.2
178E0:  BRA    17A18
178E2:  BRA    17A86
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
178E4:  MOVLB  8
178E6:  MOVF   x7C,F
178E8:  BNZ   17918
178EA:  MOVF   x7B,W
178EC:  SUBLW  23
178EE:  BZ    17912
178F0:  MOVF   x7B,W
178F2:  SUBLW  25
178F4:  BZ    17912
178F6:  MOVF   x7B,W
178F8:  SUBLW  3B
178FA:  BZ    17912
178FC:  MOVF   x7B,W
178FE:  SUBLW  4D
17900:  BZ    17912
17902:  MOVF   x7B,W
17904:  SUBLW  5A
17906:  BZ    17912
17908:  MOVF   x7B,W
1790A:  SUBLW  72
1790C:  BZ    17912
1790E:  MOVLW  00
17910:  BRA    17914
17912:  MOVLW  01
17914:  MOVWF  x7D
17916:  BRA    1799E
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
17918:  MOVF   x7B,W
1791A:  SUBLW  23
1791C:  BZ    1799A
1791E:  MOVF   x7B,W
17920:  SUBLW  25
17922:  BZ    1799A
17924:  MOVF   x7B,W
17926:  SUBLW  2B
17928:  BZ    1799A
1792A:  MOVF   x7B,W
1792C:  SUBLW  2D
1792E:  BZ    1799A
17930:  MOVF   x7B,W
17932:  SUBLW  2F
17934:  BZ    1799A
17936:  MOVF   x7B,W
17938:  SUBLW  3B
1793A:  BZ    1799A
1793C:  MOVF   x7B,W
1793E:  SUBLW  41
17940:  BZ    1799A
17942:  MOVF   x7B,W
17944:  SUBLW  42
17946:  BC    1794E
17948:  MOVF   x7B,W
1794A:  SUBLW  44
1794C:  BC    1799A
1794E:  MOVF   x7B,W
17950:  SUBLW  45
17952:  BC    1795A
17954:  MOVF   x7B,W
17956:  SUBLW  48
17958:  BC    1799A
1795A:  MOVF   x7B,W
1795C:  SUBLW  4A
1795E:  BC    17966
17960:  MOVF   x7B,W
17962:  SUBLW  4C
17964:  BC    1799A
17966:  MOVF   x7B,W
17968:  SUBLW  4F
1796A:  BC    17972
1796C:  MOVF   x7B,W
1796E:  SUBLW  55
17970:  BC    1799A
17972:  MOVF   x7B,W
17974:  SUBLW  59
17976:  BZ    1799A
17978:  MOVF   x7B,W
1797A:  SUBLW  64
1797C:  BZ    1799A
1797E:  MOVF   x7B,W
17980:  SUBLW  69
17982:  BZ    1799A
17984:  MOVF   x7B,W
17986:  SUBLW  6C
17988:  BZ    1799A
1798A:  MOVF   x7B,W
1798C:  SUBLW  70
1798E:  BZ    1799A
17990:  MOVF   x7B,W
17992:  SUBLW  72
17994:  BZ    1799A
17996:  MOVLW  00
17998:  BRA    1799C
1799A:  MOVLW  01
1799C:  MOVWF  x7D
....................          break; 
1799E:  MOVLB  0
179A0:  BRA    17A86
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
179A2:  MOVLB  8
179A4:  MOVF   x7C,F
179A6:  BNZ   179D0
179A8:  MOVF   x7B,W
179AA:  SUBLW  23
179AC:  BZ    179CA
179AE:  MOVF   x7B,W
179B0:  SUBLW  3B
179B2:  BZ    179CA
179B4:  MOVF   x7B,W
179B6:  SUBLW  4A
179B8:  BZ    179CA
179BA:  MOVF   x7B,W
179BC:  SUBLW  4D
179BE:  BZ    179CA
179C0:  MOVF   x7B,W
179C2:  SUBLW  50
179C4:  BZ    179CA
179C6:  MOVLW  00
179C8:  BRA    179CC
179CA:  MOVLW  01
179CC:  MOVWF  x7D
179CE:  BRA    17A14
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
179D0:  MOVF   x7B,W
179D2:  SUBLW  23
179D4:  BZ    17A10
179D6:  MOVF   x7B,W
179D8:  SUBLW  2B
179DA:  BZ    17A10
179DC:  MOVF   x7B,W
179DE:  SUBLW  2D
179E0:  BZ    17A10
179E2:  MOVF   x7B,W
179E4:  SUBLW  3B
179E6:  BZ    17A10
179E8:  MOVF   x7B,W
179EA:  SUBLW  42
179EC:  BZ    17A10
179EE:  MOVF   x7B,W
179F0:  SUBLW  47
179F2:  BZ    17A10
179F4:  MOVF   x7B,W
179F6:  SUBLW  4F
179F8:  BC    17A00
179FA:  MOVF   x7B,W
179FC:  SUBLW  52
179FE:  BC    17A10
17A00:  MOVF   x7B,W
17A02:  SUBLW  54
17A04:  BZ    17A10
17A06:  MOVF   x7B,W
17A08:  SUBLW  59
17A0A:  BZ    17A10
17A0C:  MOVLW  00
17A0E:  BRA    17A12
17A10:  MOVLW  01
17A12:  MOVWF  x7D
....................          break;   
17A14:  MOVLB  0
17A16:  BRA    17A86
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
17A18:  MOVLB  8
17A1A:  MOVF   x7C,F
17A1C:  BNZ   17A40
17A1E:  MOVF   x7B,W
17A20:  SUBLW  23
17A22:  BZ    17A3A
17A24:  MOVF   x7B,W
17A26:  SUBLW  3B
17A28:  BZ    17A3A
17A2A:  MOVF   x7B,W
17A2C:  SUBLW  4D
17A2E:  BZ    17A3A
17A30:  MOVF   x7B,W
17A32:  SUBLW  50
17A34:  BZ    17A3A
17A36:  MOVLW  00
17A38:  BRA    17A3C
17A3A:  MOVLW  01
17A3C:  MOVWF  x7D
17A3E:  BRA    17A84
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
17A40:  MOVF   x7B,W
17A42:  SUBLW  23
17A44:  BZ    17A80
17A46:  MOVF   x7B,W
17A48:  SUBLW  2B
17A4A:  BZ    17A80
17A4C:  MOVF   x7B,W
17A4E:  SUBLW  2D
17A50:  BZ    17A80
17A52:  MOVF   x7B,W
17A54:  SUBLW  3B
17A56:  BZ    17A80
17A58:  MOVF   x7B,W
17A5A:  SUBLW  42
17A5C:  BC    17A64
17A5E:  MOVF   x7B,W
17A60:  SUBLW  44
17A62:  BC    17A80
17A64:  MOVF   x7B,W
17A66:  SUBLW  4F
17A68:  BC    17A70
17A6A:  MOVF   x7B,W
17A6C:  SUBLW  51
17A6E:  BC    17A80
17A70:  MOVF   x7B,W
17A72:  SUBLW  53
17A74:  BZ    17A80
17A76:  MOVF   x7B,W
17A78:  SUBLW  59
17A7A:  BZ    17A80
17A7C:  MOVLW  00
17A7E:  BRA    17A82
17A80:  MOVLW  01
17A82:  MOVWF  x7D
....................          break;   
17A84:  MOVLB  0
....................    } 
....................    return(valid_macro); 
17A86:  MOVLB  8
17A88:  MOVFF  87D,01
17A8C:  MOVLB  0
17A8E:  GOTO   17ABA (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
17A92:  MOVLW  01
17A94:  MOVLB  8
17A96:  MOVWF  x7A
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
17A98:  MOVLB  0
17A9A:  CALL   0E38
17A9E:  MOVFF  01,879
....................       if (com_echo == TRUE) fputc(e,COM_A); 
17AA2:  DECFSZ 4C,W
17AA4:  BRA    17AB0
17AA6:  MOVLB  8
17AA8:  MOVF   x79,W
17AAA:  MOVLB  0
17AAC:  CALL   ADD8
....................          valid_macro = check_macro(e, macro); 
17AB0:  MOVFF  879,87B
17AB4:  MOVFF  878,87C
17AB8:  BRA    178B0
17ABA:  MOVFF  01,87A
....................       if (valid_macro == TRUE) { 
17ABE:  MOVLB  8
17AC0:  DECFSZ x7A,W
17AC2:  BRA    17ACC
....................          return(e); 
17AC4:  MOVFF  879,01
17AC8:  BRA    17AD8
....................       } 
17ACA:  BRA    17AD2
....................       else return(0); 
17ACC:  MOVLW  00
17ACE:  MOVWF  01
17AD0:  BRA    17AD8
....................    } while (valid_macro == TRUE); 
17AD2:  DECFSZ x7A,W
17AD4:  BRA    17AD8
17AD6:  BRA    17A98
17AD8:  MOVLB  0
17ADA:  GOTO   17ECC (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
17E52:  BCF    FD8.0
17E54:  MOVLB  8
17E56:  RLCF   x7B,W
17E58:  CLRF   03
17E5A:  ADDLW  D1
17E5C:  MOVWF  FE9
17E5E:  MOVLW  07
17E60:  ADDWFC 03,W
17E62:  MOVWF  FEA
17E64:  MOVFF  FEC,881
17E68:  MOVF   FED,F
17E6A:  MOVFF  FEF,880
17E6E:  MOVFF  87D,9EE
17E72:  MOVFF  87C,9ED
17E76:  MOVLB  9
17E78:  CLRF   xF0
17E7A:  MOVLW  03
17E7C:  MOVWF  xEF
17E7E:  MOVLB  0
17E80:  CALL   5C32
17E84:  MOVF   01,W
17E86:  MOVLB  8
17E88:  ADDWF  x80,W
17E8A:  MOVWF  x7E
17E8C:  MOVF   02,W
17E8E:  ADDWFC x81,W
17E90:  MOVWF  x7F
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
17E92:  MOVFF  87F,889
17E96:  MOVFF  87E,888
17E9A:  MOVFF  878,88A
17E9E:  MOVLB  0
17EA0:  RCALL  17BC6
....................     
....................    ++addr; 
17EA2:  MOVLB  8
17EA4:  INCF   x7E,F
17EA6:  BTFSC  FD8.2
17EA8:  INCF   x7F,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
17EAA:  MOVFF  87F,881
17EAE:  MOVFF  87E,880
17EB2:  MOVFF  87A,883
17EB6:  MOVFF  879,882
17EBA:  MOVLB  0
17EBC:  BRA    17E06
17EBE:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
17C26:  BCF    FD8.0
17C28:  MOVLB  8
17C2A:  RLCF   x79,W
17C2C:  CLRF   03
17C2E:  ADDLW  D1
17C30:  MOVWF  FE9
17C32:  MOVLW  07
17C34:  ADDWFC 03,W
17C36:  MOVWF  FEA
17C38:  MOVFF  FEC,882
17C3C:  MOVF   FED,F
17C3E:  MOVFF  FEF,881
17C42:  MOVFF  87B,9EE
17C46:  MOVFF  87A,9ED
17C4A:  MOVLB  9
17C4C:  CLRF   xF0
17C4E:  MOVLW  03
17C50:  MOVWF  xEF
17C52:  MOVLB  0
17C54:  CALL   5C32
17C58:  MOVF   01,W
17C5A:  MOVLB  8
17C5C:  ADDWF  x81,W
17C5E:  MOVWF  x7E
17C60:  MOVF   02,W
17C62:  ADDWFC x82,W
17C64:  MOVWF  x7F
....................    write_ext_eeprom(addr, macro_cmd); 
17C66:  MOVFF  87F,889
17C6A:  MOVFF  87E,888
17C6E:  MOVFF  878,88A
17C72:  MOVLB  0
17C74:  RCALL  17BC6
....................     
....................    int i = 0; 
17C76:  MOVLB  8
17C78:  CLRF   x80
....................    addr = string_address[macro] + (count*50); 
17C7A:  BCF    FD8.0
17C7C:  RLCF   x79,W
17C7E:  CLRF   03
17C80:  ADDLW  FB
17C82:  MOVWF  FE9
17C84:  MOVLW  07
17C86:  ADDWFC 03,W
17C88:  MOVWF  FEA
17C8A:  MOVFF  FEC,882
17C8E:  MOVF   FED,F
17C90:  MOVFF  FEF,881
17C94:  MOVFF  87D,9EE
17C98:  MOVFF  87C,9ED
17C9C:  MOVLB  9
17C9E:  CLRF   xF0
17CA0:  MOVLW  32
17CA2:  MOVWF  xEF
17CA4:  MOVLB  0
17CA6:  CALL   5C32
17CAA:  MOVF   01,W
17CAC:  MOVLB  8
17CAE:  ADDWF  x81,W
17CB0:  MOVWF  x7E
17CB2:  MOVF   02,W
17CB4:  ADDWFC x82,W
17CB6:  MOVWF  x7F
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
17CB8:  MOVF   x7D,F
17CBA:  BNZ   17D10
17CBC:  MOVF   x7C,W
17CBE:  SUBLW  14
17CC0:  BNC   17D10
....................       for(i = 0; i<50; i++) { 
17CC2:  CLRF   x80
17CC4:  MOVF   x80,W
17CC6:  SUBLW  31
17CC8:  BNC   17D0E
....................          write_ext_eeprom(addr + i, string_arg[i]); 
17CCA:  MOVF   x80,W
17CCC:  ADDWF  x7E,W
17CCE:  MOVWF  x81
17CD0:  MOVLW  00
17CD2:  ADDWFC x7F,W
17CD4:  MOVWF  x82
17CD6:  CLRF   03
17CD8:  MOVF   x80,W
17CDA:  ADDLW  25
17CDC:  MOVWF  FE9
17CDE:  MOVLW  08
17CE0:  ADDWFC 03,W
17CE2:  MOVWF  FEA
17CE4:  MOVFF  FEF,88A
17CE8:  MOVFF  882,889
17CEC:  MOVFF  881,888
17CF0:  MOVLB  0
17CF2:  RCALL  17BC6
....................          if(string_arg[i] == 0){ 
17CF4:  CLRF   03
17CF6:  MOVLB  8
17CF8:  MOVF   x80,W
17CFA:  ADDLW  25
17CFC:  MOVWF  FE9
17CFE:  MOVLW  08
17D00:  ADDWFC 03,W
17D02:  MOVWF  FEA
17D04:  MOVF   FEF,F
17D06:  BNZ   17D0A
....................             break; 
17D08:  BRA    17D0E
....................          } 
17D0A:  INCF   x80,F
17D0C:  BRA    17CC4
....................       
....................       } 
....................    }else{ 
17D0E:  BRA    17D62
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
17D10:  MOVLW  D2
17D12:  MOVWF  FF6
17D14:  MOVLW  20
17D16:  MOVWF  FF7
17D18:  MOVLW  00
17D1A:  MOVWF  FF8
17D1C:  CLRF   1B
17D1E:  BTFSC  FF2.7
17D20:  BSF    1B.7
17D22:  BCF    FF2.7
17D24:  MOVLW  1E
17D26:  MOVLB  A
17D28:  MOVWF  x1C
17D2A:  MOVLB  0
17D2C:  CALL   1024
17D30:  BTFSC  1B.7
17D32:  BSF    FF2.7
17D34:  MOVLW  10
17D36:  MOVWF  FE9
17D38:  CLRF   1B
17D3A:  BTFSC  FF2.7
17D3C:  BSF    1B.7
17D3E:  BCF    FF2.7
17D40:  MOVFF  87B,A1D
17D44:  MOVFF  87A,A1C
17D48:  CALL   11A6
17D4C:  BTFSC  1B.7
17D4E:  BSF    FF2.7
17D50:  MOVLW  0A
17D52:  BTFSS  F9E.4
17D54:  BRA    17D52
17D56:  MOVWF  FAD
17D58:  MOVLW  0D
17D5A:  BTFSS  F9E.4
17D5C:  BRA    17D5A
17D5E:  MOVWF  FAD
17D60:  MOVLB  8
....................    } 
17D62:  MOVLB  0
17D64:  GOTO   17F04 (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
180A4:  CALL   FFEE
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
180A8:  MOVLW  3B
180AA:  MOVLB  8
180AC:  MOVWF  x78
180AE:  CLRF   x7A
180B0:  CLRF   x79
180B2:  CLRF   x7B
180B4:  CLRF   x7D
180B6:  CLRF   x7C
180B8:  MOVLB  0
180BA:  RCALL  17E52
....................     
....................    write_macro_line(59, 0, 1, 0); 
180BC:  MOVLW  3B
180BE:  MOVLB  8
180C0:  MOVWF  x78
180C2:  CLRF   x7A
180C4:  CLRF   x79
180C6:  MOVLW  01
180C8:  MOVWF  x7B
180CA:  CLRF   x7D
180CC:  CLRF   x7C
180CE:  MOVLB  0
180D0:  RCALL  17E52
....................    write_macro_line(59, 0, 2, 0); 
180D2:  MOVLW  3B
180D4:  MOVLB  8
180D6:  MOVWF  x78
180D8:  CLRF   x7A
180DA:  CLRF   x79
180DC:  MOVLW  02
180DE:  MOVWF  x7B
180E0:  CLRF   x7D
180E2:  CLRF   x7C
180E4:  MOVLB  0
180E6:  RCALL  17E52
....................    write_macro_line(59, 0, 3, 0); 
180E8:  MOVLW  3B
180EA:  MOVLB  8
180EC:  MOVWF  x78
180EE:  CLRF   x7A
180F0:  CLRF   x79
180F2:  MOVLW  03
180F4:  MOVWF  x7B
180F6:  CLRF   x7D
180F8:  CLRF   x7C
180FA:  MOVLB  0
180FC:  RCALL  17E52
....................    write_macro_line(59, 0, 4, 0); 
180FE:  MOVLW  3B
18100:  MOVLB  8
18102:  MOVWF  x78
18104:  CLRF   x7A
18106:  CLRF   x79
18108:  MOVLW  04
1810A:  MOVWF  x7B
1810C:  CLRF   x7D
1810E:  CLRF   x7C
18110:  MOVLB  0
18112:  RCALL  17E52
....................    write_macro_line(59, 0, 5, 0); 
18114:  MOVLW  3B
18116:  MOVLB  8
18118:  MOVWF  x78
1811A:  CLRF   x7A
1811C:  CLRF   x79
1811E:  MOVLW  05
18120:  MOVWF  x7B
18122:  CLRF   x7D
18124:  CLRF   x7C
18126:  MOVLB  0
18128:  RCALL  17E52
....................    write_macro_line(59, 0, 6, 0); 
1812A:  MOVLW  3B
1812C:  MOVLB  8
1812E:  MOVWF  x78
18130:  CLRF   x7A
18132:  CLRF   x79
18134:  MOVLW  06
18136:  MOVWF  x7B
18138:  CLRF   x7D
1813A:  CLRF   x7C
1813C:  MOVLB  0
1813E:  RCALL  17E52
....................    write_macro_line(59, 0, 7, 0); 
18140:  MOVLW  3B
18142:  MOVLB  8
18144:  MOVWF  x78
18146:  CLRF   x7A
18148:  CLRF   x79
1814A:  MOVLW  07
1814C:  MOVWF  x7B
1814E:  CLRF   x7D
18150:  CLRF   x7C
18152:  MOVLB  0
18154:  RCALL  17E52
....................    write_macro_line(59, 0, 8, 0); 
18156:  MOVLW  3B
18158:  MOVLB  8
1815A:  MOVWF  x78
1815C:  CLRF   x7A
1815E:  CLRF   x79
18160:  MOVLW  08
18162:  MOVWF  x7B
18164:  CLRF   x7D
18166:  CLRF   x7C
18168:  MOVLB  0
1816A:  RCALL  17E52
....................     
....................    write_macro_line(59, 0, 9, 0); 
1816C:  MOVLW  3B
1816E:  MOVLB  8
18170:  MOVWF  x78
18172:  CLRF   x7A
18174:  CLRF   x79
18176:  MOVLW  09
18178:  MOVWF  x7B
1817A:  CLRF   x7D
1817C:  CLRF   x7C
1817E:  MOVLB  0
18180:  RCALL  17E52
....................    write_macro_line(59, 0, 10, 0); 
18182:  MOVLW  3B
18184:  MOVLB  8
18186:  MOVWF  x78
18188:  CLRF   x7A
1818A:  CLRF   x79
1818C:  MOVLW  0A
1818E:  MOVWF  x7B
18190:  CLRF   x7D
18192:  CLRF   x7C
18194:  MOVLB  0
18196:  RCALL  17E52
....................    write_macro_line(59, 0, 11, 0); 
18198:  MOVLW  3B
1819A:  MOVLB  8
1819C:  MOVWF  x78
1819E:  CLRF   x7A
181A0:  CLRF   x79
181A2:  MOVLW  0B
181A4:  MOVWF  x7B
181A6:  CLRF   x7D
181A8:  CLRF   x7C
181AA:  MOVLB  0
181AC:  RCALL  17E52
....................    write_macro_line(59, 0, 12, 0); 
181AE:  MOVLW  3B
181B0:  MOVLB  8
181B2:  MOVWF  x78
181B4:  CLRF   x7A
181B6:  CLRF   x79
181B8:  MOVLW  0C
181BA:  MOVWF  x7B
181BC:  CLRF   x7D
181BE:  CLRF   x7C
181C0:  MOVLB  0
181C2:  RCALL  17E52
....................    write_macro_line(59, 0, 13, 0); 
181C4:  MOVLW  3B
181C6:  MOVLB  8
181C8:  MOVWF  x78
181CA:  CLRF   x7A
181CC:  CLRF   x79
181CE:  MOVLW  0D
181D0:  MOVWF  x7B
181D2:  CLRF   x7D
181D4:  CLRF   x7C
181D6:  MOVLB  0
181D8:  RCALL  17E52
....................    write_macro_line(59, 0, 14, 0); 
181DA:  MOVLW  3B
181DC:  MOVLB  8
181DE:  MOVWF  x78
181E0:  CLRF   x7A
181E2:  CLRF   x79
181E4:  MOVLW  0E
181E6:  MOVWF  x7B
181E8:  CLRF   x7D
181EA:  CLRF   x7C
181EC:  MOVLB  0
181EE:  RCALL  17E52
....................    write_macro_line(59, 0, 15, 0); 
181F0:  MOVLW  3B
181F2:  MOVLB  8
181F4:  MOVWF  x78
181F6:  CLRF   x7A
181F8:  CLRF   x79
181FA:  MOVLW  0F
181FC:  MOVWF  x7B
181FE:  CLRF   x7D
18200:  CLRF   x7C
18202:  MOVLB  0
18204:  RCALL  17E52
....................    write_macro_line(59, 0, 16, 0); 
18206:  MOVLW  3B
18208:  MOVLB  8
1820A:  MOVWF  x78
1820C:  CLRF   x7A
1820E:  CLRF   x79
18210:  MOVLW  10
18212:  MOVWF  x7B
18214:  CLRF   x7D
18216:  CLRF   x7C
18218:  MOVLB  0
1821A:  RCALL  17E52
1821C:  GOTO   18254 (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
17ADE:  MOVLB  8
17AE0:  CLRF   x78
....................     
....................    heartbeat(FALSE); 
17AE2:  CLRF   xCE
17AE4:  MOVLB  0
17AE6:  CALL   5516
....................     
....................    while(mcc != CARRIAGE_RET){ 
17AEA:  MOVLB  8
17AEC:  MOVF   x78,W
17AEE:  SUBLW  0D
17AF0:  BZ    17B12
....................       if (kbhit(COM_A)) { 
17AF2:  BTFSS  F9E.5
17AF4:  BRA    17B10
....................          mcc=fgetc(COM_A); 
17AF6:  MOVLB  0
17AF8:  CALL   0E38
17AFC:  MOVFF  01,878
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
17B00:  DECFSZ 4C,W
17B02:  BRA    17B0E
17B04:  MOVLB  8
17B06:  MOVF   x78,W
17B08:  MOVLB  0
17B0A:  CALL   ADD8
17B0E:  MOVLB  8
....................       } 
17B10:  BRA    17AEC
....................    } 
....................     
....................    heartbeat(TRUE); 
17B12:  MOVLW  01
17B14:  MOVWF  xCE
17B16:  MOVLB  0
17B18:  CALL   5516
17B1C:  GOTO   17EDC (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
17EC0:  MOVLB  8
17EC2:  CLRF   x77
....................     
....................    macro_cmd = get_cmd(macro); 
17EC4:  MOVFF  86F,878
17EC8:  MOVLB  0
17ECA:  BRA    17A92
17ECC:  MOVFF  01,874
....................    if (macro_cmd == 35){  
17ED0:  MOVLB  8
17ED2:  MOVF   x74,W
17ED4:  SUBLW  23
17ED6:  BNZ   17EE0
....................       macro_comment();        // # = 35 
17ED8:  MOVLB  0
17EDA:  BRA    17ADE
....................    }else if(macro_cmd == 112){// 112 is p 
17EDC:  BRA    17F62
17EDE:  MOVLB  8
17EE0:  MOVF   x74,W
17EE2:  SUBLW  70
17EE4:  BNZ   17F0C
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
17EE6:  MOVLB  0
17EE8:  BRA    17B20
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
17EEA:  MOVFF  874,878
17EEE:  MOVFF  86F,879
17EF2:  MOVFF  871,87B
17EF6:  MOVFF  870,87A
17EFA:  MOVFF  873,87D
17EFE:  MOVFF  872,87C
17F02:  BRA    17C26
....................       valid_macro = TRUE; 
17F04:  MOVLW  01
17F06:  MOVLB  8
17F08:  MOVWF  x77
....................    }else{ 
17F0A:  BRA    17F60
....................       if (macro_cmd != 0) { 
17F0C:  MOVF   x74,F
17F0E:  BZ    17F36
....................          macro_arg = get_arg(); 
17F10:  MOVLB  0
17F12:  BRA    17D68
17F14:  MOVFF  02,876
17F18:  MOVFF  01,875
....................          if (macro_arg != 65535) valid_macro = TRUE; 
17F1C:  MOVLB  8
17F1E:  INCFSZ x75,W
17F20:  BRA    17F28
17F22:  INCFSZ x76,W
17F24:  BRA    17F28
17F26:  BRA    17F2E
17F28:  MOVLW  01
17F2A:  MOVWF  x77
17F2C:  BRA    17F34
....................          else return(macro_cmd); 
17F2E:  MOVFF  874,01
17F32:  BRA    17F68
....................       }else return(macro_cmd); 
17F34:  BRA    17F3C
17F36:  MOVFF  874,01
17F3A:  BRA    17F68
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
17F3C:  MOVFF  874,878
17F40:  MOVFF  876,87A
17F44:  MOVFF  875,879
17F48:  MOVFF  86F,87B
17F4C:  MOVFF  871,87D
17F50:  MOVFF  870,87C
17F54:  MOVLB  0
17F56:  RCALL  17E52
....................       return(macro_cmd); 
17F58:  MOVLB  8
17F5A:  MOVFF  874,01
17F5E:  BRA    17F68
17F60:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
17F62:  MOVLB  8
17F64:  MOVFF  874,01
17F68:  MOVLB  0
17F6A:  GOTO   17FB0 (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
17F6E:  MOVLB  8
17F70:  CLRF   x6E
17F72:  CLRF   x6D
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
17F74:  CLRF   x69
17F76:  CLRF   x68
....................    valid_macro = TRUE; 
17F78:  MOVLW  01
17F7A:  MOVWF  x6A
....................    macro_cmd = 1; 
17F7C:  MOVWF  x6B
....................     
....................    init_ext_eeprom(); 
17F7E:  MOVLB  0
17F80:  CALL   FFEE
....................     
....................    fprintf(COM_A, ":"); 
17F84:  MOVLW  3A
17F86:  BTFSS  F9E.4
17F88:  BRA    17F86
17F8A:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
17F8C:  MOVLB  8
17F8E:  MOVF   x6B,W
17F90:  SUBLW  3B
17F92:  BZ    17FF6
17F94:  MOVF   x6B,F
17F96:  BZ    17FF6
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
17F98:  MOVFF  867,86F
17F9C:  MOVFF  869,871
17FA0:  MOVFF  868,870
17FA4:  MOVFF  86E,873
17FA8:  MOVFF  86D,872
17FAC:  MOVLB  0
17FAE:  BRA    17EC0
17FB0:  MOVFF  01,86B
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
17FB4:  MOVLB  8
17FB6:  MOVF   x6B,W
17FB8:  SUBLW  70
17FBA:  BNZ   17FC2
....................          count++; 
17FBC:  INCF   x6D,F
17FBE:  BTFSC  FD8.2
17FC0:  INCF   x6E,F
....................       } 
....................       if (macro_cmd != 35) ++line; 
17FC2:  MOVF   x6B,W
17FC4:  SUBLW  23
17FC6:  BZ    17FCE
17FC8:  INCF   x68,F
17FCA:  BTFSC  FD8.2
17FCC:  INCF   x69,F
....................       if (macro_cmd != 59) printf("\r\n:"); 
17FCE:  MOVF   x6B,W
17FD0:  SUBLW  3B
17FD2:  BZ    17FF4
17FD4:  MOVLW  F6
17FD6:  MOVWF  FF6
17FD8:  MOVLW  20
17FDA:  MOVWF  FF7
17FDC:  MOVLW  00
17FDE:  MOVWF  FF8
17FE0:  CLRF   1B
17FE2:  BTFSC  FF2.7
17FE4:  BSF    1B.7
17FE6:  BCF    FF2.7
17FE8:  MOVLB  0
17FEA:  CALL   0E4E
17FEE:  BTFSC  1B.7
17FF0:  BSF    FF2.7
17FF2:  MOVLB  8
17FF4:  BRA    17F8E
....................    }       
....................    if (macro_cmd == 0){ 
17FF6:  MOVF   x6B,F
17FF8:  BNZ   1808E
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
17FFA:  MOVLW  FA
17FFC:  MOVWF  FF6
17FFE:  MOVLW  20
18000:  MOVWF  FF7
18002:  MOVLW  00
18004:  MOVWF  FF8
18006:  CLRF   1B
18008:  BTFSC  FF2.7
1800A:  BSF    1B.7
1800C:  BCF    FF2.7
1800E:  MOVLB  0
18010:  CALL   0E4E
18014:  BTFSC  1B.7
18016:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
18018:  MOVLW  22
1801A:  MOVWF  FF6
1801C:  MOVLW  21
1801E:  MOVWF  FF7
18020:  MOVLW  00
18022:  MOVWF  FF8
18024:  CLRF   1B
18026:  BTFSC  FF2.7
18028:  BSF    1B.7
1802A:  BCF    FF2.7
1802C:  MOVLW  15
1802E:  MOVLB  A
18030:  MOVWF  x1C
18032:  MOVLB  0
18034:  CALL   1024
18038:  BTFSC  1B.7
1803A:  BSF    FF2.7
1803C:  MOVLW  10
1803E:  MOVWF  FE9
18040:  MOVFF  869,8D2
18044:  MOVFF  868,8D1
18048:  CALL   8F40
1804C:  MOVLW  3A
1804E:  MOVWF  FF6
18050:  MOVLW  21
18052:  MOVWF  FF7
18054:  MOVLW  00
18056:  MOVWF  FF8
18058:  CLRF   1B
1805A:  BTFSC  FF2.7
1805C:  BSF    1B.7
1805E:  BCF    FF2.7
18060:  MOVLW  03
18062:  MOVLB  A
18064:  MOVWF  x1C
18066:  MOVLB  0
18068:  CALL   1024
1806C:  BTFSC  1B.7
1806E:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
18070:  MOVLW  3E
18072:  MOVWF  FF6
18074:  MOVLW  21
18076:  MOVWF  FF7
18078:  MOVLW  00
1807A:  MOVWF  FF8
1807C:  CLRF   1B
1807E:  BTFSC  FF2.7
18080:  BSF    1B.7
18082:  BCF    FF2.7
18084:  CALL   0E4E
18088:  BTFSC  1B.7
1808A:  BSF    FF2.7
1808C:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
1808E:  MOVLW  0D
18090:  BTFSS  F9E.4
18092:  BRA    18090
18094:  MOVWF  FAD
18096:  MOVLW  0A
18098:  BTFSS  F9E.4
1809A:  BRA    18098
1809C:  MOVWF  FAD
1809E:  MOVLB  0
180A0:  GOTO   1823C (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
1825E:  BCF    FD8.0
18260:  MOVLB  8
18262:  RLCF   x6C,W
18264:  CLRF   03
18266:  ADDLW  D1
18268:  MOVWF  FE9
1826A:  MOVLW  07
1826C:  ADDWFC 03,W
1826E:  MOVWF  FEA
18270:  MOVFF  FEC,875
18274:  MOVF   FED,F
18276:  MOVFF  FEF,874
1827A:  MOVFF  86E,9EE
1827E:  MOVFF  86D,9ED
18282:  MOVLB  9
18284:  CLRF   xF0
18286:  MOVLW  03
18288:  MOVWF  xEF
1828A:  MOVLB  0
1828C:  CALL   5C32
18290:  MOVF   01,W
18292:  MOVLB  8
18294:  ADDWF  x74,W
18296:  MOVWF  x6F
18298:  MOVF   02,W
1829A:  ADDWFC x75,W
1829C:  MOVWF  x70
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
1829E:  MOVFF  870,8AD
182A2:  MOVFF  86F,8AC
182A6:  MOVLB  0
182A8:  CALL   10254
182AC:  MOVFF  01,871
....................    ++addr; 
182B0:  MOVLB  8
182B2:  INCF   x6F,F
182B4:  BTFSC  FD8.2
182B6:  INCF   x70,F
....................    macro_arg = read16_ext_eeprom(addr); 
182B8:  MOVFF  870,8A4
182BC:  MOVFF  86F,8A3
182C0:  MOVLB  0
182C2:  CALL   10368
182C6:  MOVFF  02,873
182CA:  MOVFF  01,872
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
182CE:  MOVLB  8
182D0:  MOVF   x71,W
182D2:  BTFSS  F9E.4
182D4:  BRA    182D2
182D6:  MOVWF  FAD
182D8:  MOVLW  10
182DA:  MOVWF  FE9
182DC:  CLRF   1B
182DE:  BTFSC  FF2.7
182E0:  BSF    1B.7
182E2:  BCF    FF2.7
182E4:  MOVFF  873,A1D
182E8:  MOVFF  872,A1C
182EC:  MOVLB  0
182EE:  CALL   11A6
182F2:  BTFSC  1B.7
182F4:  BSF    FF2.7
182F6:  MOVLW  0D
182F8:  BTFSS  F9E.4
182FA:  BRA    182F8
182FC:  MOVWF  FAD
182FE:  MOVLW  0A
18300:  BTFSS  F9E.4
18302:  BRA    18300
18304:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
18306:  MOVLB  8
18308:  MOVFF  871,01
1830C:  MOVLB  0
1830E:  GOTO   18342 (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
13EF6:  BCF    FD8.0
13EF8:  MOVLB  8
13EFA:  RLCF   x98,W
13EFC:  CLRF   03
13EFE:  ADDLW  D1
13F00:  MOVWF  FE9
13F02:  MOVLW  07
13F04:  ADDWFC 03,W
13F06:  MOVWF  FEA
13F08:  MOVFF  FEC,8A1
13F0C:  MOVF   FED,F
13F0E:  MOVFF  FEF,8A0
13F12:  MOVFF  89A,9EE
13F16:  MOVFF  899,9ED
13F1A:  MOVLB  9
13F1C:  CLRF   xF0
13F1E:  MOVLW  03
13F20:  MOVWF  xEF
13F22:  MOVLB  0
13F24:  CALL   5C32
13F28:  MOVF   01,W
13F2A:  MOVLB  8
13F2C:  ADDWF  xA0,W
13F2E:  MOVWF  x9B
13F30:  MOVF   02,W
13F32:  ADDWFC xA1,W
13F34:  MOVWF  x9C
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
13F36:  MOVFF  89C,8AD
13F3A:  MOVFF  89B,8AC
13F3E:  MOVLB  0
13F40:  CALL   10254
13F44:  MOVFF  01,89D
....................    ++addr; 
13F48:  MOVLB  8
13F4A:  INCF   x9B,F
13F4C:  BTFSC  FD8.2
13F4E:  INCF   x9C,F
....................    macro_arg = read16_ext_eeprom(addr); 
13F50:  MOVFF  89C,8A4
13F54:  MOVFF  89B,8A3
13F58:  MOVLB  0
13F5A:  CALL   10368
13F5E:  MOVFF  02,89F
13F62:  MOVFF  01,89E
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
13F66:  MOVLB  8
13F68:  MOVF   x9D,W
13F6A:  BTFSS  F9E.4
13F6C:  BRA    13F6A
13F6E:  MOVWF  FAD
13F70:  MOVLW  10
13F72:  MOVWF  FE9
13F74:  CLRF   1B
13F76:  BTFSC  FF2.7
13F78:  BSF    1B.7
13F7A:  BCF    FF2.7
13F7C:  MOVFF  89F,A1D
13F80:  MOVFF  89E,A1C
13F84:  MOVLB  0
13F86:  CALL   11A6
13F8A:  BTFSC  1B.7
13F8C:  BSF    FF2.7
13F8E:  MOVLW  0D
13F90:  BTFSS  F9E.4
13F92:  BRA    13F90
13F94:  MOVWF  FAD
13F96:  MOVLW  0A
13F98:  BTFSS  F9E.4
13F9A:  BRA    13F98
13F9C:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
13F9E:  MOVLB  8
13FA0:  MOVFF  89D,01
13FA4:  MOVLB  0
13FA6:  GOTO   1477E (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
102AE:  BCF    FD8.0
102B0:  MOVLB  8
102B2:  RLCF   x96,W
102B4:  CLRF   03
102B6:  ADDLW  FB
102B8:  MOVWF  FE9
102BA:  MOVLW  07
102BC:  ADDWFC 03,W
102BE:  MOVWF  FEA
102C0:  MOVFF  FEC,89F
102C4:  MOVF   FED,F
102C6:  MOVFF  FEF,89E
102CA:  MOVFF  89A,9EE
102CE:  MOVFF  899,9ED
102D2:  MOVLB  9
102D4:  CLRF   xF0
102D6:  MOVLW  32
102D8:  MOVWF  xEF
102DA:  MOVLB  0
102DC:  CALL   5C32
102E0:  MOVF   01,W
102E2:  MOVLB  8
102E4:  ADDWF  x9E,W
102E6:  MOVWF  x9B
102E8:  MOVF   02,W
102EA:  ADDWFC x9F,W
102EC:  MOVWF  x9C
....................     
....................    int i = 0; 
102EE:  CLRF   x9D
....................    for(i = 0; i < 50; i++){ 
102F0:  CLRF   x9D
102F2:  MOVF   x9D,W
102F4:  SUBLW  31
102F6:  BNC   1030C
....................       string_arg[i] = 0; 
102F8:  CLRF   03
102FA:  MOVF   x9D,W
102FC:  ADDLW  25
102FE:  MOVWF  FE9
10300:  MOVLW  08
10302:  ADDWFC 03,W
10304:  MOVWF  FEA
10306:  CLRF   FEF
10308:  INCF   x9D,F
1030A:  BRA    102F2
....................    }  
....................    for(i = 0; i < 50; i++){ 
1030C:  CLRF   x9D
1030E:  MOVF   x9D,W
10310:  SUBLW  31
10312:  BNC   10364
....................       string_arg[i] = read_ext_eeprom(addr + i); 
10314:  CLRF   03
10316:  MOVF   x9D,W
10318:  ADDLW  25
1031A:  MOVWF  01
1031C:  MOVLW  08
1031E:  ADDWFC 03,F
10320:  MOVFF  01,89E
10324:  MOVFF  03,89F
10328:  MOVF   x9D,W
1032A:  ADDWF  x9B,W
1032C:  MOVWF  xA0
1032E:  MOVLW  00
10330:  ADDWFC x9C,W
10332:  MOVWF  xA1
10334:  MOVWF  xAD
10336:  MOVFF  8A0,8AC
1033A:  MOVLB  0
1033C:  RCALL  10254
1033E:  MOVFF  89F,FEA
10342:  MOVFF  89E,FE9
10346:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
1034A:  CLRF   03
1034C:  MOVLB  8
1034E:  MOVF   x9D,W
10350:  ADDLW  25
10352:  MOVWF  FE9
10354:  MOVLW  08
10356:  ADDWFC 03,W
10358:  MOVWF  FEA
1035A:  MOVF   FEF,F
1035C:  BNZ   10360
....................          break; 
1035E:  BRA    10364
....................       } 
10360:  INCF   x9D,F
10362:  BRA    1030E
....................    }   
10364:  MOVLB  0
10366:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
18312:  MOVLB  8
18314:  CLRF   x6B
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
18316:  CLRF   x69
18318:  CLRF   x68
....................    macro_cmd = 1; 
1831A:  MOVLW  01
1831C:  MOVWF  x6A
....................     
....................    init_ext_eeprom(); 
1831E:  MOVLB  0
18320:  CALL   FFEE
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
18324:  MOVLB  8
18326:  MOVF   x69,W
18328:  SUBLW  03
1832A:  BNC   18372
1832C:  MOVF   x6A,W
1832E:  SUBLW  3B
18330:  BZ    18372
....................       macro_cmd = read_macro_line(macro, line); 
18332:  MOVFF  867,86C
18336:  MOVFF  869,86E
1833A:  MOVFF  868,86D
1833E:  MOVLB  0
18340:  BRA    1825E
18342:  MOVFF  01,86A
....................       if(macro_cmd == 'p'){ 
18346:  MOVLB  8
18348:  MOVF   x6A,W
1834A:  SUBLW  70
1834C:  BNZ   1836A
....................          read_macro_line_string(macro,line,count); 
1834E:  MOVFF  867,896
18352:  MOVFF  869,898
18356:  MOVFF  868,897
1835A:  CLRF   x9A
1835C:  MOVFF  86B,899
18360:  MOVLB  0
18362:  CALL   102AE
....................          count++; 
18366:  MOVLB  8
18368:  INCF   x6B,F
....................       } 
....................       ++line; 
1836A:  INCF   x68,F
1836C:  BTFSC  FD8.2
1836E:  INCF   x69,F
18370:  BRA    18326
....................    } 
18372:  MOVLB  0
18374:  GOTO   18394 (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0CFAA:  MOVLB  8
0CFAC:  CLRF   xA6
0CFAE:  CLRF   xA5
0CFB0:  MOVF   xA6,W
0CFB2:  SUBWF  xA4,W
0CFB4:  BNC   CFDC
0CFB6:  BNZ   CFBE
0CFB8:  MOVF   xA3,W
0CFBA:  SUBWF  xA5,W
0CFBC:  BC    CFDC
....................       delay_ms(1000); 
0CFBE:  MOVLW  04
0CFC0:  MOVWF  xA7
0CFC2:  MOVLW  FA
0CFC4:  MOVLB  9
0CFC6:  MOVWF  xCD
0CFC8:  MOVLB  0
0CFCA:  CALL   28AC
0CFCE:  MOVLB  8
0CFD0:  DECFSZ xA7,F
0CFD2:  BRA    CFC2
0CFD4:  INCF   xA5,F
0CFD6:  BTFSC  FD8.2
0CFD8:  INCF   xA6,F
0CFDA:  BRA    CFB0
....................    }  
0CFDC:  MOVLB  0
0CFDE:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0CF72:  BCF    FD8.0
0CF74:  MOVLB  7
0CF76:  RLCF   x40,W
0CF78:  CLRF   03
0CF7A:  ADDLW  96
0CF7C:  MOVWF  FE9
0CF7E:  MOVLW  07
0CF80:  ADDWFC 03,W
0CF82:  MOVWF  FEA
0CF84:  MOVFF  FEC,8A5
0CF88:  MOVF   FED,F
0CF8A:  MOVFF  FEF,8A4
0CF8E:  MOVLB  8
0CF90:  DECFSZ xA4,W
0CF92:  BRA    CF9E
0CF94:  MOVF   xA5,F
0CF96:  BNZ   CF9E
....................    { 
....................       macro_status = 'e'; 
0CF98:  MOVLW  65
0CF9A:  MOVWF  xA3
....................    } 
0CF9C:  BRA    CFA2
....................    else 
....................    { 
....................       macro_status = 'a'; 
0CF9E:  MOVLW  61
0CFA0:  MOVWF  xA3
....................    } 
....................    return(macro_status); 
0CFA2:  MOVFF  8A3,01
0CFA6:  MOVLB  0
0CFA8:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
134A8:  DECFSZ 45,W
134AA:  BRA    134BE
134AC:  MOVF   46,F
134AE:  BNZ   134BE
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
134B0:  MOVLW  01
134B2:  MOVLB  8
134B4:  MOVWF  xA3
134B6:  MOVWF  xA4
134B8:  MOVLB  0
134BA:  RCALL  13372
....................    } 
134BC:  BRA    134E8
....................    else if(nv_det_type==2 || nv_det_type==3) 
134BE:  MOVF   45,W
134C0:  SUBLW  02
134C2:  BNZ   134C8
134C4:  MOVF   46,F
134C6:  BZ    134D2
134C8:  MOVF   45,W
134CA:  SUBLW  03
134CC:  BNZ   134E8
134CE:  MOVF   46,F
134D0:  BNZ   134E8
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
134D2:  MOVLB  8
134D4:  CLRF   xA4
134D6:  MOVLW  C8
134D8:  MOVWF  xA3
134DA:  MOVLW  01
134DC:  MOVWF  xA5
134DE:  MOVWF  xA6
134E0:  CLRF   xA7
134E2:  MOVLB  0
134E4:  CALL   FC6A
....................    } 
134E8:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
123C6:  DECFSZ 45,W
123C8:  BRA    123E4
123CA:  MOVF   46,F
123CC:  BNZ   123E4
....................       cmd = macro_cmd; 
123CE:  MOVFF  8A3,47
....................       arg = macro_arg; 
123D2:  CLRF   4B
123D4:  CLRF   4A
123D6:  MOVFF  8A5,49
123DA:  MOVFF  8A4,48
....................       det_cmd(); 
123DE:  CALL   F072
....................    } 
123E2:  BRA    123FE
....................    else if(nv_det_type==2 || nv_det_type==3) { 
123E4:  MOVF   45,W
123E6:  SUBLW  02
123E8:  BNZ   123EE
123EA:  MOVF   46,F
123EC:  BZ    123F8
123EE:  MOVF   45,W
123F0:  SUBLW  03
123F2:  BNZ   123FE
123F4:  MOVF   46,F
123F6:  BNZ   123FE
....................       set_heaters(macro_arg); 
123F8:  MOVFF  8A4,8A6
123FC:  RCALL  12352
....................    } 
123FE:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
12400:  DECFSZ 45,W
12402:  BRA    1241E
12404:  MOVF   46,F
12406:  BNZ   1241E
....................       cmd = macro_cmd; 
12408:  MOVFF  8A3,47
....................       arg = macro_arg; 
1240C:  CLRF   4B
1240E:  CLRF   4A
12410:  MOVFF  8A5,49
12414:  MOVFF  8A4,48
....................       det_cmd(); 
12418:  CALL   F072
....................    } 
1241C:  BRA    1243E
....................    else if(nv_det_type==2 || nv_det_type==3) { 
1241E:  MOVF   45,W
12420:  SUBLW  02
12422:  BNZ   12428
12424:  MOVF   46,F
12426:  BZ    12432
12428:  MOVF   45,W
1242A:  SUBLW  03
1242C:  BNZ   1243E
1242E:  MOVF   46,F
12430:  BNZ   1243E
....................       set_LED(macro_arg); 
12432:  MOVFF  8A5,8A7
12436:  MOVFF  8A4,8A6
1243A:  CALL   F528
....................    } 
1243E:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13A20:  MOVLW  65
13A22:  MOVLB  8
13A24:  MOVWF  xA2
....................     
....................    addr = macro_address[macro] + (line*3); 
13A26:  BCF    FD8.0
13A28:  RLCF   x98,W
13A2A:  CLRF   03
13A2C:  ADDLW  D1
13A2E:  MOVWF  FE9
13A30:  MOVLW  07
13A32:  ADDWFC 03,W
13A34:  MOVWF  FEA
13A36:  MOVFF  FEC,8A4
13A3A:  MOVF   FED,F
13A3C:  MOVFF  FEF,8A3
13A40:  MOVFF  89A,9EE
13A44:  MOVFF  899,9ED
13A48:  MOVLB  9
13A4A:  CLRF   xF0
13A4C:  MOVLW  03
13A4E:  MOVWF  xEF
13A50:  MOVLB  0
13A52:  CALL   5C32
13A56:  MOVF   01,W
13A58:  MOVLB  8
13A5A:  ADDWF  xA3,W
13A5C:  MOVWF  x9D
13A5E:  MOVF   02,W
13A60:  ADDWFC xA4,W
13A62:  MOVWF  x9E
....................  
....................    init_ext_eeprom(); 
13A64:  MOVLB  0
13A66:  CALL   FFEE
....................    macro_cmd = read_ext_eeprom(addr); 
13A6A:  MOVFF  89E,8AD
13A6E:  MOVFF  89D,8AC
13A72:  CALL   10254
13A76:  MOVFF  01,89F
....................    ++addr; 
13A7A:  MOVLB  8
13A7C:  INCF   x9D,F
13A7E:  BTFSC  FD8.2
13A80:  INCF   x9E,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13A82:  MOVFF  89E,8A4
13A86:  MOVFF  89D,8A3
13A8A:  MOVLB  0
13A8C:  CALL   10368
13A90:  MOVFF  02,8A1
13A94:  MOVFF  01,8A0
....................    //} 
....................    heartbeat(TRUE); 
13A98:  MOVLW  01
13A9A:  MOVLB  8
13A9C:  MOVWF  xCE
13A9E:  MOVLB  0
13AA0:  CALL   5516
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13AA4:  MOVF   2F,F
13AA6:  BTFSS  FD8.2
13AA8:  BRA    13E32
13AAA:  MOVF   30,F
13AAC:  BTFSS  FD8.2
13AAE:  BRA    13E32
....................       switch(macro_cmd) 
13AB0:  MOVLW  2B
13AB2:  MOVLB  8
13AB4:  SUBWF  x9F,W
13AB6:  ADDLW  B4
13AB8:  BTFSC  FD8.0
13ABA:  BRA    13E34
13ABC:  ADDLW  4C
13ABE:  MOVLB  0
13AC0:  GOTO   13E3E
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
13AC4:  CALL   121DE
....................             store_rel_data(); 
13AC8:  CALL   12242
....................             macro_status = 'a'; 
13ACC:  MOVLW  61
13ACE:  MOVLB  8
13AD0:  MOVWF  xA2
....................             break; 
13AD2:  BRA    13E34
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
13AD4:  MOVLW  08
13AD6:  MOVWF  FEA
13AD8:  MOVLW  25
13ADA:  MOVWF  FE9
13ADC:  CALL   78F8
13AE0:  MOVLW  0D
13AE2:  BTFSS  F9E.4
13AE4:  BRA    13AE2
13AE6:  MOVWF  FAD
13AE8:  MOVLW  0A
13AEA:  BTFSS  F9E.4
13AEC:  BRA    13AEA
13AEE:  MOVWF  FAD
....................             macro_status = 'a'; 
13AF0:  MOVLW  61
13AF2:  MOVLB  8
13AF4:  MOVWF  xA2
....................             break; 
13AF6:  BRA    13E34
....................          case 'C' : 
....................             calc_abs_data(); 
13AF8:  CALL   121DE
....................             break; 
13AFC:  MOVLB  8
13AFE:  BRA    13E34
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
13B00:  MOVFF  8A1,8A4
13B04:  MOVFF  8A0,8A3
13B08:  CALL   CFAA
....................             macro_status = 'a'; 
13B0C:  MOVLW  61
13B0E:  MOVLB  8
13B10:  MOVWF  xA2
....................             break; 
13B12:  BRA    13E34
....................          case 'F' : macro_flag = macro_arg; 
13B14:  MOVFF  8A1,324
13B18:  MOVFF  8A0,323
....................                     macro_status = 'a'; 
13B1C:  MOVLW  61
13B1E:  MOVLB  8
13B20:  MOVWF  xA2
....................             break ; 
13B22:  BRA    13E34
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
13B24:  MOVFF  8A0,2D5
....................                     macro_status = 'a'; 
13B28:  MOVLW  61
13B2A:  MOVLB  8
13B2C:  MOVWF  xA2
....................             break ; 
13B2E:  BRA    13E34
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
13B30:  MOVFF  89F,8A3
13B34:  MOVFF  8A1,8A5
13B38:  MOVFF  8A0,8A4
13B3C:  CALL   123C6
....................                     macro_status = 'a'; 
13B40:  MOVLW  61
13B42:  MOVLB  8
13B44:  MOVWF  xA2
....................             break; 
13B46:  BRA    13E34
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
13B48:  MOVFF  89F,8A3
13B4C:  MOVFF  8A1,8A5
13B50:  MOVFF  8A0,8A4
13B54:  CALL   123C6
....................                     macro_status = 'a'; 
13B58:  MOVLW  61
13B5A:  MOVLB  8
13B5C:  MOVWF  xA2
....................             break; 
13B5E:  BRA    13E34
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
13B60:  MOVFF  8A1,8BD
13B64:  MOVFF  8A0,8BC
13B68:  MOVLB  8
13B6A:  CLRF   xBF
13B6C:  MOVLW  64
13B6E:  MOVWF  xBE
13B70:  MOVLB  0
13B72:  CALL   2C70
13B76:  MOVFF  02,74D
13B7A:  MOVFF  01,74C
....................                     macro_status = 'a'; 
13B7E:  MOVLW  61
13B80:  MOVLB  8
13B82:  MOVWF  xA2
....................             break;    
13B84:  BRA    13E34
....................          case 'l' : LightTargetFlag = 1; 
13B86:  MOVLW  01
13B88:  MOVLB  2
13B8A:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
13B8C:  MOVFF  89F,8A3
13B90:  MOVFF  8A1,8A5
13B94:  MOVFF  8A0,8A4
13B98:  MOVLB  0
13B9A:  CALL   12400
....................                     delay_ms(10000); 
13B9E:  MOVLW  28
13BA0:  MOVLB  8
13BA2:  MOVWF  xA3
13BA4:  MOVLW  FA
13BA6:  MOVLB  9
13BA8:  MOVWF  xCD
13BAA:  MOVLB  0
13BAC:  CALL   28AC
13BB0:  MOVLB  8
13BB2:  DECFSZ xA3,F
13BB4:  BRA    13BA4
....................                     macro_status = 'a'; 
13BB6:  MOVLW  61
13BB8:  MOVWF  xA2
....................             break;        
13BBA:  BRA    13E34
....................          case 'L' : LightTargetFlag = 0; 
13BBC:  MOVLB  2
13BBE:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
13BC0:  MOVFF  89F,8A3
13BC4:  MOVFF  8A1,8A5
13BC8:  MOVFF  8A0,8A4
13BCC:  MOVLB  0
13BCE:  CALL   12400
....................                     macro_status = 'a'; 
13BD2:  MOVLW  61
13BD4:  MOVLB  8
13BD6:  MOVWF  xA2
....................             break; 
13BD8:  BRA    13E34
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
13BDA:  MOVFF  89F,47
....................                     arg = macro_arg; 
13BDE:  CLRF   4B
13BE0:  CLRF   4A
13BE2:  MOVFF  8A1,49
13BE6:  MOVFF  8A0,48
....................                     det_cmd(); 
13BEA:  CALL   F072
....................                     macro_status = 'a'; 
13BEE:  MOVLW  61
13BF0:  MOVLB  8
13BF2:  MOVWF  xA2
....................             break ; 
13BF4:  BRA    13E34
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
13BF6:  MOVLB  8
13BF8:  DECFSZ xA0,W
13BFA:  BRA    13C06
13BFC:  MOVF   xA1,F
13BFE:  BNZ   13C06
13C00:  MOVLB  0
13C02:  RCALL  134A8
13C04:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
13C06:  MOVF   xA0,W
13C08:  SUBLW  02
13C0A:  BNZ   13C1C
13C0C:  MOVF   xA1,F
13C0E:  BNZ   13C1C
13C10:  MOVLW  01
13C12:  MOVWF  xA3
13C14:  MOVWF  xA4
13C16:  MOVLB  0
13C18:  RCALL  13674
13C1A:  MOVLB  8
....................                     macro_status = 'a'; 
13C1C:  MOVLW  61
13C1E:  MOVWF  xA2
....................             break ;  
13C20:  BRA    13E34
....................          case 'T' : det_temp(); 
13C22:  RCALL  13834
....................                     macro_status = 'a'; 
13C24:  MOVLW  61
13C26:  MOVLB  8
13C28:  MOVWF  xA2
....................             break; 
13C2A:  BRA    13E34
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
13C2C:  MOVLW  01
13C2E:  MOVLB  7
13C30:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
13C32:  MOVLB  8
13C34:  CLRF   xA8
13C36:  CLRF   xA9
13C38:  CLRF   xAD
13C3A:  CLRF   xAC
13C3C:  MOVFF  8A1,8AB
13C40:  MOVFF  8A0,8AA
13C44:  MOVWF  xAE
13C46:  MOVLB  0
13C48:  CALL   9CD4
....................                     macro_status=step_err_status(); 
13C4C:  CALL   CF72
13C50:  MOVFF  01,8A2
....................             break; 
13C54:  MOVLB  8
13C56:  BRA    13E34
....................          case '-' : motor=1; 
13C58:  MOVLW  01
13C5A:  MOVLB  7
13C5C:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
13C5E:  MOVLB  8
13C60:  CLRF   xA8
13C62:  MOVWF  xA9
13C64:  CLRF   xAD
13C66:  CLRF   xAC
13C68:  MOVFF  8A1,8AB
13C6C:  MOVFF  8A0,8AA
13C70:  MOVWF  xAE
13C72:  MOVLB  0
13C74:  CALL   9CD4
....................                     macro_status=step_err_status(); 
13C78:  CALL   CF72
13C7C:  MOVFF  01,8A2
....................             break; 
13C80:  MOVLB  8
13C82:  BRA    13E34
....................          case 'G' : motor=0; 
13C84:  MOVLB  7
13C86:  CLRF   x40
....................                     align(0); 
13C88:  MOVLB  8
13C8A:  CLRF   xA3
13C8C:  MOVLB  0
13C8E:  CALL   A810
....................                     macro_status=step_err_status(); 
13C92:  CALL   CF72
13C96:  MOVFF  01,8A2
....................             break ;           
13C9A:  MOVLB  8
13C9C:  BRA    13E34
....................          case 'P' : motor=0; 
13C9E:  MOVLB  7
13CA0:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
13CA2:  MOVLW  01
13CA4:  MOVLB  8
13CA6:  MOVWF  xA8
13CA8:  CLRF   xA9
13CAA:  CLRF   xAD
13CAC:  CLRF   xAC
13CAE:  MOVFF  8A1,8AB
13CB2:  MOVFF  8A0,8AA
13CB6:  MOVWF  xAE
13CB8:  MOVLB  0
13CBA:  CALL   9CD4
....................                     macro_status=step_err_status(); 
13CBE:  CALL   CF72
13CC2:  MOVFF  01,8A2
....................             break; 
13CC6:  MOVLB  8
13CC8:  BRA    13E34
....................          case 'Q' : motor=0; 
13CCA:  MOVLB  7
13CCC:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
13CCE:  MOVLB  8
13CD0:  CLRF   xA8
13CD2:  CLRF   xA9
13CD4:  CLRF   xAD
13CD6:  CLRF   xAC
13CD8:  MOVFF  8A1,8AB
13CDC:  MOVFF  8A0,8AA
13CE0:  MOVLW  01
13CE2:  MOVWF  xAE
13CE4:  MOVLB  0
13CE6:  CALL   9CD4
....................                     macro_status=step_err_status(); 
13CEA:  CALL   CF72
13CEE:  MOVFF  01,8A2
....................             break; 
13CF2:  MOVLB  8
13CF4:  BRA    13E34
....................          case 'R' : motor=0; 
13CF6:  MOVLB  7
13CF8:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
13CFA:  MOVLB  8
13CFC:  CLRF   xA8
13CFE:  MOVLW  01
13D00:  MOVWF  xA9
13D02:  CLRF   xAD
13D04:  CLRF   xAC
13D06:  MOVFF  8A1,8AB
13D0A:  MOVFF  8A0,8AA
13D0E:  MOVWF  xAE
13D10:  MOVLB  0
13D12:  CALL   9CD4
....................                     macro_status=step_err_status(); 
13D16:  CALL   CF72
13D1A:  MOVFF  01,8A2
....................             break; 
13D1E:  MOVLB  8
13D20:  BRA    13E34
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
13D22:  MOVLB  8
13D24:  DECFSZ xA0,W
13D26:  BRA    13D36
13D28:  MOVF   xA1,F
13D2A:  BNZ   13D36
13D2C:  MOVLB  0
13D2E:  CALL   CFE0
13D32:  BRA    13D44
13D34:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
13D36:  MOVF   xA0,F
13D38:  BNZ   13D46
13D3A:  MOVF   xA1,F
13D3C:  BNZ   13D46
13D3E:  MOVLB  0
13D40:  CALL   D004
13D44:  MOVLB  8
....................                     macro_status = 'a'; 
13D46:  MOVLW  61
13D48:  MOVWF  xA2
....................             break; 
13D4A:  BRA    13E34
....................          case 'v':  
....................          //shouldve been a switch statement but I already wrote it so... 
....................             if(macro_arg == 00){ 
13D4C:  MOVLB  8
13D4E:  MOVF   xA0,F
13D50:  BNZ   13D5A
13D52:  MOVF   xA1,F
13D54:  BNZ   13D5A
....................                output_bit(PIN_D0,0); 
13D56:  BCF    F8C.0
....................             }else if(macro_arg == 01){ 
13D58:  BRA    13E28
13D5A:  DECFSZ xA0,W
13D5C:  BRA    13D66
13D5E:  MOVF   xA1,F
13D60:  BNZ   13D66
....................                output_bit(PIN_D0,1); 
13D62:  BSF    F8C.0
....................             }else if(macro_arg == 10){ 
13D64:  BRA    13E28
13D66:  MOVF   xA0,W
13D68:  SUBLW  0A
13D6A:  BNZ   13D74
13D6C:  MOVF   xA1,F
13D6E:  BNZ   13D74
....................                output_bit(PIN_D1,0); 
13D70:  BCF    F8C.1
....................             }else if(macro_arg == 11){ 
13D72:  BRA    13E28
13D74:  MOVF   xA0,W
13D76:  SUBLW  0B
13D78:  BNZ   13D82
13D7A:  MOVF   xA1,F
13D7C:  BNZ   13D82
....................                output_bit(PIN_D1,1); 
13D7E:  BSF    F8C.1
....................             }else if(macro_arg == 20){ 
13D80:  BRA    13E28
13D82:  MOVF   xA0,W
13D84:  SUBLW  14
13D86:  BNZ   13D90
13D88:  MOVF   xA1,F
13D8A:  BNZ   13D90
....................                output_bit(PIN_D2,0); 
13D8C:  BCF    F8C.2
....................             }else if(macro_arg == 21){ 
13D8E:  BRA    13E28
13D90:  MOVF   xA0,W
13D92:  SUBLW  15
13D94:  BNZ   13D9E
13D96:  MOVF   xA1,F
13D98:  BNZ   13D9E
....................                output_bit(PIN_D2,1); 
13D9A:  BSF    F8C.2
....................             }else if(macro_arg == 30){ 
13D9C:  BRA    13E28
13D9E:  MOVF   xA0,W
13DA0:  SUBLW  1E
13DA2:  BNZ   13DAC
13DA4:  MOVF   xA1,F
13DA6:  BNZ   13DAC
....................                output_bit(PIN_D3,0); 
13DA8:  BCF    F8C.3
....................             }else if(macro_arg == 31){ 
13DAA:  BRA    13E28
13DAC:  MOVF   xA0,W
13DAE:  SUBLW  1F
13DB0:  BNZ   13DBA
13DB2:  MOVF   xA1,F
13DB4:  BNZ   13DBA
....................                output_bit(PIN_D3,1); 
13DB6:  BSF    F8C.3
....................             }else if(macro_arg == 40){ 
13DB8:  BRA    13E28
13DBA:  MOVF   xA0,W
13DBC:  SUBLW  28
13DBE:  BNZ   13DC8
13DC0:  MOVF   xA1,F
13DC2:  BNZ   13DC8
....................                output_bit(PIN_D4,0); 
13DC4:  BCF    F8C.4
....................             }else if(macro_arg == 41){ 
13DC6:  BRA    13E28
13DC8:  MOVF   xA0,W
13DCA:  SUBLW  29
13DCC:  BNZ   13DD6
13DCE:  MOVF   xA1,F
13DD0:  BNZ   13DD6
....................                output_bit(PIN_D4,1); 
13DD2:  BSF    F8C.4
....................             }else if(macro_arg == 50){ 
13DD4:  BRA    13E28
13DD6:  MOVF   xA0,W
13DD8:  SUBLW  32
13DDA:  BNZ   13DE4
13DDC:  MOVF   xA1,F
13DDE:  BNZ   13DE4
....................                output_bit(PIN_D5,0); 
13DE0:  BCF    F8C.5
....................             }else if(macro_arg == 51){ 
13DE2:  BRA    13E28
13DE4:  MOVF   xA0,W
13DE6:  SUBLW  33
13DE8:  BNZ   13DF2
13DEA:  MOVF   xA1,F
13DEC:  BNZ   13DF2
....................                output_bit(PIN_D5,1); 
13DEE:  BSF    F8C.5
....................             }else if(macro_arg == 60){ 
13DF0:  BRA    13E28
13DF2:  MOVF   xA0,W
13DF4:  SUBLW  3C
13DF6:  BNZ   13E00
13DF8:  MOVF   xA1,F
13DFA:  BNZ   13E00
....................                output_bit(PIN_D6,0); 
13DFC:  BCF    F8C.6
....................             }else if(macro_arg == 61){ 
13DFE:  BRA    13E28
13E00:  MOVF   xA0,W
13E02:  SUBLW  3D
13E04:  BNZ   13E0E
13E06:  MOVF   xA1,F
13E08:  BNZ   13E0E
....................                output_bit(PIN_D6,1); 
13E0A:  BSF    F8C.6
....................             }else if(macro_arg == 70){ 
13E0C:  BRA    13E28
13E0E:  MOVF   xA0,W
13E10:  SUBLW  46
13E12:  BNZ   13E1C
13E14:  MOVF   xA1,F
13E16:  BNZ   13E1C
....................                output_bit(PIN_D7,0); 
13E18:  BCF    F8C.7
....................             }else if(macro_arg == 71){ 
13E1A:  BRA    13E28
13E1C:  MOVF   xA0,W
13E1E:  SUBLW  47
13E20:  BNZ   13E28
13E22:  MOVF   xA1,F
13E24:  BNZ   13E28
....................                output_bit(PIN_D7,1); 
13E26:  BSF    F8C.7
....................             }      
....................             break; 
13E28:  BRA    13E34
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
13E2A:  MOVLW  66
13E2C:  MOVLB  8
13E2E:  MOVWF  xA2
....................             break ; 
13E30:  BRA    13E34
13E32:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
13E34:  MOVFF  8A2,01
13E38:  MOVLB  0
13E3A:  GOTO   14746 (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
145A2:  MOVLW  65
145A4:  MOVLB  8
145A6:  MOVWF  x88
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
145A8:  BCF    FD8.0
145AA:  RLCF   x7E,W
145AC:  CLRF   03
145AE:  ADDLW  D1
145B0:  MOVWF  FE9
145B2:  MOVLW  07
145B4:  ADDWFC 03,W
145B6:  MOVWF  FEA
145B8:  MOVFF  FEC,897
145BC:  MOVF   FED,F
145BE:  MOVFF  FEF,896
145C2:  MOVFF  880,03
145C6:  MOVFF  87F,FE9
145CA:  MOVFF  880,FEA
145CE:  MOVFF  FEC,9EE
145D2:  MOVF   FED,F
145D4:  MOVFF  FEF,9ED
145D8:  MOVLB  9
145DA:  CLRF   xF0
145DC:  MOVLW  03
145DE:  MOVWF  xEF
145E0:  MOVLB  0
145E2:  CALL   5C32
145E6:  MOVF   01,W
145E8:  MOVLB  8
145EA:  ADDWF  x96,W
145EC:  MOVWF  x83
145EE:  MOVF   02,W
145F0:  ADDWFC x97,W
145F2:  MOVWF  x84
....................  
....................    init_ext_eeprom(); 
145F4:  MOVLB  0
145F6:  CALL   FFEE
....................    macro_cmd = read_ext_eeprom(addr); 
145FA:  MOVFF  884,8AD
145FE:  MOVFF  883,8AC
14602:  CALL   10254
14606:  MOVFF  01,885
....................    ++addr; 
1460A:  MOVLB  8
1460C:  INCF   x83,F
1460E:  BTFSC  FD8.2
14610:  INCF   x84,F
....................    if(macro_cmd == 'p'){ 
14612:  MOVF   x85,W
14614:  SUBLW  70
14616:  BNZ   1463C
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
14618:  MOVFF  87E,896
1461C:  MOVFF  880,898
14620:  MOVFF  87F,897
14624:  MOVFF  858,89A
14628:  MOVFF  857,899
1462C:  MOVLB  0
1462E:  CALL   102AE
....................       count1++; 
14632:  MOVLB  8
14634:  INCF   x57,F
14636:  BTFSC  FD8.2
14638:  INCF   x58,F
....................    }else{ 
1463A:  BRA    14654
....................    macro_arg = read16_ext_eeprom(addr); 
1463C:  MOVFF  884,8A4
14640:  MOVFF  883,8A3
14644:  MOVLB  0
14646:  CALL   10368
1464A:  MOVFF  02,887
1464E:  MOVFF  01,886
14652:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
14654:  MOVLW  01
14656:  MOVWF  xCE
14658:  MOVLB  0
1465A:  CALL   5516
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
1465E:  MOVF   2F,F
14660:  BTFSS  FD8.2
14662:  BRA    14AB0
14664:  MOVF   30,F
14666:  BTFSS  FD8.2
14668:  BRA    14AB0
....................       switch(macro_cmd){ 
1466A:  MOVLW  2B
1466C:  MOVLB  8
1466E:  SUBWF  x85,W
14670:  ADDLW  B8
14672:  BTFSC  FD8.0
14674:  BRA    14AAC
14676:  ADDLW  48
14678:  MOVLB  0
1467A:  GOTO   14D76
....................          case 'A' : 
....................             calc_abs_data(); 
1467E:  CALL   121DE
....................             store_rel_data(); 
14682:  CALL   12242
....................             macro_status = 'a'; 
14686:  MOVLW  61
14688:  MOVLB  8
1468A:  MOVWF  x88
....................             break; 
1468C:  BRA    14AAC
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
1468E:  MOVLW  08
14690:  MOVWF  FEA
14692:  MOVLW  25
14694:  MOVWF  FE9
14696:  CALL   78F8
1469A:  MOVLW  0D
1469C:  BTFSS  F9E.4
1469E:  BRA    1469C
146A0:  MOVWF  FAD
146A2:  MOVLW  0A
146A4:  BTFSS  F9E.4
146A6:  BRA    146A4
146A8:  MOVWF  FAD
....................             macro_status = 'a'; 
146AA:  MOVLW  61
146AC:  MOVLB  8
146AE:  MOVWF  x88
....................             break; 
146B0:  BRA    14AAC
....................          case 'C' : 
....................             calc_abs_data(); 
146B2:  CALL   121DE
....................             break; 
146B6:  MOVLB  8
146B8:  BRA    14AAC
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
146BA:  MOVLB  8
146BC:  CLRF   x8C
146BE:  CLRF   x8B
146C0:  CLRF   x8A
146C2:  CLRF   x89
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
146C4:  MOVFF  880,03
146C8:  MOVFF  87F,FE9
146CC:  MOVFF  880,FEA
146D0:  MOVLW  01
146D2:  ADDWF  FEE,F
146D4:  BNC   146D8
146D6:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
146D8:  MOVFF  87F,FE9
146DC:  MOVFF  880,FEA
146E0:  CLRF   x90
146E2:  CLRF   x8F
146E4:  MOVFF  FEC,88E
146E8:  MOVF   FED,F
146EA:  MOVFF  FEF,88D
146EE:  CLRF   x94
146F0:  CLRF   x93
146F2:  CLRF   x92
146F4:  CLRF   x91
....................                    
....................                   while(count < macro_arg){ 
146F6:  MOVF   x8C,F
146F8:  BTFSS  FD8.2
146FA:  BRA    14836
146FC:  MOVF   x8B,F
146FE:  BTFSS  FD8.2
14700:  BRA    14836
14702:  MOVF   x8A,W
14704:  SUBWF  x87,W
14706:  BTFSS  FD8.0
14708:  BRA    14836
1470A:  BNZ   14714
1470C:  MOVF   x86,W
1470E:  SUBWF  x89,W
14710:  BTFSC  FD8.0
14712:  BRA    14836
....................                      char curr = 'A'; 
14714:  MOVLW  41
14716:  MOVWF  x95
....................                      while(curr != '%'){ 
14718:  MOVF   x95,W
1471A:  SUBLW  25
1471C:  BZ    14788
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
1471E:  MOVFF  880,03
14722:  MOVFF  87F,FE9
14726:  MOVFF  880,FEA
1472A:  MOVFF  FEC,89A
1472E:  MOVF   FED,F
14730:  MOVFF  FEF,899
14734:  MOVFF  87E,898
14738:  MOVFF  882,89C
1473C:  MOVFF  881,89B
14740:  MOVLB  0
14742:  GOTO   13A20
....................                         (*line)++; 
14746:  MOVFF  880,03
1474A:  MOVLB  8
1474C:  MOVF   x7F,W
1474E:  MOVWF  FE9
14750:  MOVFF  03,FEA
14754:  MOVLW  01
14756:  ADDWF  FEE,F
14758:  BNC   1475C
1475A:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
1475C:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
1475E:  MOVFF  880,03
14762:  MOVFF  87F,FE9
14766:  MOVFF  880,FEA
1476A:  MOVFF  FEC,89A
1476E:  MOVF   FED,F
14770:  MOVFF  FEF,899
14774:  MOVFF  87E,898
14778:  MOVLB  0
1477A:  GOTO   13EF6
1477E:  MOVFF  01,895
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
14782:  BSF    F91.5
14784:  MOVLB  8
14786:  BRA    14718
....................                      } 
....................                      end_line = (*line); 
14788:  MOVFF  87F,FE9
1478C:  MOVFF  880,FEA
14790:  CLRF   x94
14792:  CLRF   x93
14794:  MOVFF  FEC,892
14798:  MOVF   FED,F
1479A:  MOVFF  FEF,891
....................                      count++; 
1479E:  MOVLW  01
147A0:  ADDWF  x89,F
147A2:  BTFSC  FD8.0
147A4:  INCF   x8A,F
147A6:  BTFSC  FD8.2
147A8:  INCF   x8B,F
147AA:  BTFSC  FD8.2
147AC:  INCF   x8C,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
147AE:  MOVF   x89,W
147B0:  SUBWF  x86,W
147B2:  MOVWF  x96
147B4:  MOVF   x8A,W
147B6:  SUBWFB x87,W
147B8:  MOVWF  x97
147BA:  MOVLW  00
147BC:  SUBFWB x8B,W
147BE:  MOVWF  x98
147C0:  MOVLW  00
147C2:  SUBFWB x8C,W
147C4:  MOVWF  x99
147C6:  MOVLW  56
147C8:  MOVWF  FF6
147CA:  MOVLW  21
147CC:  MOVWF  FF7
147CE:  MOVLW  00
147D0:  MOVWF  FF8
147D2:  CLRF   1B
147D4:  BTFSC  FF2.7
147D6:  BSF    1B.7
147D8:  BCF    FF2.7
147DA:  MOVLW  11
147DC:  MOVLB  A
147DE:  MOVWF  x1C
147E0:  MOVLB  0
147E2:  CALL   1024
147E6:  BTFSC  1B.7
147E8:  BSF    FF2.7
147EA:  MOVLW  41
147EC:  MOVWF  FE9
147EE:  CLRF   1B
147F0:  BTFSC  FF2.7
147F2:  BSF    1B.7
147F4:  BCF    FF2.7
147F6:  MOVFF  899,A1F
147FA:  MOVFF  898,A1E
147FE:  MOVFF  897,A1D
14802:  MOVFF  896,A1C
14806:  CALL   10EA
1480A:  BTFSC  1B.7
1480C:  BSF    FF2.7
1480E:  MOVLW  0D
14810:  BTFSS  F9E.4
14812:  BRA    14810
14814:  MOVWF  FAD
14816:  MOVLW  0A
14818:  BTFSS  F9E.4
1481A:  BRA    14818
1481C:  MOVWF  FAD
....................                      (*line) = start_line; 
1481E:  MOVFF  880,03
14822:  MOVLB  8
14824:  MOVFF  87F,FE9
14828:  MOVFF  880,FEA
1482C:  MOVFF  88D,FEF
14830:  MOVFF  88E,FEC
14834:  BRA    146F6
....................                   } 
....................                   (*line) = end_line + 1; 
14836:  MOVFF  87F,FE9
1483A:  MOVFF  880,FEA
1483E:  MOVLW  01
14840:  ADDWF  x91,W
14842:  MOVWF  FEF
14844:  MOVLW  00
14846:  ADDWFC x92,W
14848:  MOVWF  FEC
....................                   macro_status = 'a'; 
1484A:  MOVLW  61
1484C:  MOVWF  x88
....................             break; 
1484E:  BRA    14AAC
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
14850:  MOVFF  887,8A4
14854:  MOVFF  886,8A3
14858:  CALL   CFAA
....................                     macro_status = 'a'; 
1485C:  MOVLW  61
1485E:  MOVLB  8
14860:  MOVWF  x88
....................             break; 
14862:  BRA    14AAC
....................          case 'F' : macro_flag = macro_arg; 
14864:  MOVFF  887,324
14868:  MOVFF  886,323
....................                     macro_status = 'a'; 
1486C:  MOVLW  61
1486E:  MOVLB  8
14870:  MOVWF  x88
....................             break ; 
14872:  BRA    14AAC
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14874:  MOVFF  886,2D5
....................                     macro_status = 'a'; 
14878:  MOVLW  61
1487A:  MOVLB  8
1487C:  MOVWF  x88
....................             break ; 
1487E:  BRA    14AAC
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14880:  MOVFF  885,8A3
14884:  MOVFF  887,8A5
14888:  MOVFF  886,8A4
1488C:  CALL   123C6
....................                     macro_status = 'a'; 
14890:  MOVLW  61
14892:  MOVLB  8
14894:  MOVWF  x88
....................             break; 
14896:  BRA    14AAC
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14898:  MOVFF  885,8A3
1489C:  MOVFF  887,8A5
148A0:  MOVFF  886,8A4
148A4:  CALL   123C6
....................                     macro_status = 'a'; 
148A8:  MOVLW  61
148AA:  MOVLB  8
148AC:  MOVWF  x88
....................             break; 
148AE:  BRA    14AAC
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
148B0:  MOVFF  887,8BD
148B4:  MOVFF  886,8BC
148B8:  MOVLB  8
148BA:  CLRF   xBF
148BC:  MOVLW  64
148BE:  MOVWF  xBE
148C0:  MOVLB  0
148C2:  CALL   2C70
148C6:  MOVFF  02,74D
148CA:  MOVFF  01,74C
....................                     macro_status = 'a'; 
148CE:  MOVLW  61
148D0:  MOVLB  8
148D2:  MOVWF  x88
....................             break;    
148D4:  BRA    14AAC
....................          case 'l' : LightTargetFlag = 1; 
148D6:  MOVLW  01
148D8:  MOVLB  2
148DA:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
148DC:  MOVFF  885,8A3
148E0:  MOVFF  887,8A5
148E4:  MOVFF  886,8A4
148E8:  MOVLB  0
148EA:  CALL   12400
....................                     delay_ms(10000); 
148EE:  MOVLW  28
148F0:  MOVLB  8
148F2:  MOVWF  x96
148F4:  MOVLW  FA
148F6:  MOVLB  9
148F8:  MOVWF  xCD
148FA:  MOVLB  0
148FC:  CALL   28AC
14900:  MOVLB  8
14902:  DECFSZ x96,F
14904:  BRA    148F4
....................                     macro_status = 'a'; 
14906:  MOVLW  61
14908:  MOVWF  x88
....................             break;        
1490A:  BRA    14AAC
....................          case 'L' : LightTargetFlag = 0; 
1490C:  MOVLB  2
1490E:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
14910:  MOVFF  885,8A3
14914:  MOVFF  887,8A5
14918:  MOVFF  886,8A4
1491C:  MOVLB  0
1491E:  CALL   12400
....................                     macro_status = 'a'; 
14922:  MOVLW  61
14924:  MOVLB  8
14926:  MOVWF  x88
....................             break; 
14928:  BRA    14AAC
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
1492A:  MOVFF  885,47
....................                     arg = macro_arg; 
1492E:  CLRF   4B
14930:  CLRF   4A
14932:  MOVFF  887,49
14936:  MOVFF  886,48
....................                     det_cmd(); 
1493A:  CALL   F072
....................                     macro_status = 'a'; 
1493E:  MOVLW  61
14940:  MOVLB  8
14942:  MOVWF  x88
....................             break ; 
14944:  BRA    14AAC
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
14946:  MOVLB  8
14948:  DECFSZ x86,W
1494A:  BRA    14958
1494C:  MOVF   x87,F
1494E:  BNZ   14958
14950:  MOVLB  0
14952:  CALL   134A8
14956:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14958:  MOVF   x86,W
1495A:  SUBLW  02
1495C:  BNZ   14970
1495E:  MOVF   x87,F
14960:  BNZ   14970
14962:  MOVLW  01
14964:  MOVWF  xA3
14966:  MOVWF  xA4
14968:  MOVLB  0
1496A:  CALL   13674
1496E:  MOVLB  8
....................                     macro_status = 'a'; 
14970:  MOVLW  61
14972:  MOVWF  x88
....................             break ;  
14974:  BRA    14AAC
....................          case 'T' : det_temp(); 
14976:  CALL   13834
....................                     macro_status = 'a'; 
1497A:  MOVLW  61
1497C:  MOVLB  8
1497E:  MOVWF  x88
....................             break; 
14980:  BRA    14AAC
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14982:  MOVLW  01
14984:  MOVLB  7
14986:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14988:  MOVLB  8
1498A:  CLRF   xA8
1498C:  CLRF   xA9
1498E:  CLRF   xAD
14990:  CLRF   xAC
14992:  MOVFF  887,8AB
14996:  MOVFF  886,8AA
1499A:  MOVWF  xAE
1499C:  MOVLB  0
1499E:  CALL   9CD4
....................                     macro_status=step_err_status(); 
149A2:  CALL   CF72
149A6:  MOVFF  01,888
....................             break; 
149AA:  MOVLB  8
149AC:  BRA    14AAC
....................          case '-' : motor=1; 
149AE:  MOVLW  01
149B0:  MOVLB  7
149B2:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
149B4:  MOVLB  8
149B6:  CLRF   xA8
149B8:  MOVWF  xA9
149BA:  CLRF   xAD
149BC:  CLRF   xAC
149BE:  MOVFF  887,8AB
149C2:  MOVFF  886,8AA
149C6:  MOVWF  xAE
149C8:  MOVLB  0
149CA:  CALL   9CD4
....................                     macro_status=step_err_status(); 
149CE:  CALL   CF72
149D2:  MOVFF  01,888
....................             break; 
149D6:  MOVLB  8
149D8:  BRA    14AAC
....................          case 'G' : motor=0; 
149DA:  MOVLB  7
149DC:  CLRF   x40
....................                     align(0); 
149DE:  MOVLB  8
149E0:  CLRF   xA3
149E2:  MOVLB  0
149E4:  CALL   A810
....................                     macro_status=step_err_status(); 
149E8:  CALL   CF72
149EC:  MOVFF  01,888
....................             break ;           
149F0:  MOVLB  8
149F2:  BRA    14AAC
....................          case 'P' : motor=0; 
149F4:  MOVLB  7
149F6:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
149F8:  MOVLW  01
149FA:  MOVLB  8
149FC:  MOVWF  xA8
149FE:  CLRF   xA9
14A00:  CLRF   xAD
14A02:  CLRF   xAC
14A04:  MOVFF  887,8AB
14A08:  MOVFF  886,8AA
14A0C:  MOVWF  xAE
14A0E:  MOVLB  0
14A10:  CALL   9CD4
....................                     macro_status=step_err_status(); 
14A14:  CALL   CF72
14A18:  MOVFF  01,888
....................             break; 
14A1C:  MOVLB  8
14A1E:  BRA    14AAC
....................          case 'Q' : motor=0; 
14A20:  MOVLB  7
14A22:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
14A24:  MOVLB  8
14A26:  CLRF   xA8
14A28:  CLRF   xA9
14A2A:  CLRF   xAD
14A2C:  CLRF   xAC
14A2E:  MOVFF  887,8AB
14A32:  MOVFF  886,8AA
14A36:  MOVLW  01
14A38:  MOVWF  xAE
14A3A:  MOVLB  0
14A3C:  CALL   9CD4
....................                     macro_status=step_err_status(); 
14A40:  CALL   CF72
14A44:  MOVFF  01,888
....................             break; 
14A48:  MOVLB  8
14A4A:  BRA    14AAC
....................          case 'R' : motor=0; 
14A4C:  MOVLB  7
14A4E:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
14A50:  MOVLB  8
14A52:  CLRF   xA8
14A54:  MOVLW  01
14A56:  MOVWF  xA9
14A58:  CLRF   xAD
14A5A:  CLRF   xAC
14A5C:  MOVFF  887,8AB
14A60:  MOVFF  886,8AA
14A64:  MOVWF  xAE
14A66:  MOVLB  0
14A68:  CALL   9CD4
....................                     macro_status=step_err_status(); 
14A6C:  CALL   CF72
14A70:  MOVFF  01,888
....................             break; 
14A74:  MOVLB  8
14A76:  BRA    14AAC
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14A78:  MOVLB  8
14A7A:  DECFSZ x86,W
14A7C:  BRA    14A8C
14A7E:  MOVF   x87,F
14A80:  BNZ   14A8C
14A82:  MOVLB  0
14A84:  CALL   CFE0
14A88:  BRA    14A9A
14A8A:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14A8C:  MOVF   x86,F
14A8E:  BNZ   14A9C
14A90:  MOVF   x87,F
14A92:  BNZ   14A9C
14A94:  MOVLB  0
14A96:  CALL   D004
14A9A:  MOVLB  8
....................                     macro_status = 'a'; 
14A9C:  MOVLW  61
14A9E:  MOVWF  x88
....................             break; 
14AA0:  BRA    14AAC
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14AA2:  MOVLW  66
14AA4:  MOVLB  8
14AA6:  MOVWF  x88
....................             break ; 
14AA8:  BRA    14AAC
14AAA:  MOVLB  8
....................       } 
....................    } 
14AAC:  BRA    14D6C
14AAE:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14AB0:  DECFSZ 2F,W
14AB2:  BRA    14AB8
14AB4:  MOVF   30,F
14AB6:  BZ    14AC6
14AB8:  MOVF   2F,W
14ABA:  SUBLW  03
14ABC:  BTFSS  FD8.2
14ABE:  BRA    14C44
14AC0:  MOVF   30,F
14AC2:  BTFSS  FD8.2
14AC4:  BRA    14C44
....................       switch(macro_cmd){ 
14AC6:  MOVLB  8
14AC8:  MOVF   x85,W
14ACA:  XORLW  2B
14ACC:  MOVLB  0
14ACE:  BZ    14AFC
14AD0:  XORLW  06
14AD2:  BZ    14B26
14AD4:  XORLW  6F
14AD6:  BZ    14B50
14AD8:  XORLW  05
14ADA:  BZ    14B62
14ADC:  XORLW  17
14ADE:  BZ    14B7A
14AE0:  XORLW  01
14AE2:  BZ    14BA4
14AE4:  XORLW  03
14AE6:  BZ    14BCE
14AE8:  XORLW  06
14AEA:  BTFSC  FD8.2
14AEC:  BRA    14BF8
14AEE:  XORLW  0D
14AF0:  BTFSC  FD8.2
14AF2:  BRA    14C0E
14AF4:  XORLW  62
14AF6:  BTFSC  FD8.2
14AF8:  BRA    14C3A
14AFA:  BRA    14C42
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14AFC:  MOVLW  01
14AFE:  MOVLB  7
14B00:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14B02:  MOVLB  8
14B04:  CLRF   xA8
14B06:  CLRF   xA9
14B08:  CLRF   xAD
14B0A:  CLRF   xAC
14B0C:  MOVFF  887,8AB
14B10:  MOVFF  886,8AA
14B14:  MOVWF  xAE
14B16:  MOVLB  0
14B18:  CALL   9CD4
....................                     macro_status=step_err_status(); 
14B1C:  CALL   CF72
14B20:  MOVFF  01,888
....................             break; 
14B24:  BRA    14C42
....................          case '-' : motor=1; 
14B26:  MOVLW  01
14B28:  MOVLB  7
14B2A:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14B2C:  MOVLB  8
14B2E:  CLRF   xA8
14B30:  MOVWF  xA9
14B32:  CLRF   xAD
14B34:  CLRF   xAC
14B36:  MOVFF  887,8AB
14B3A:  MOVFF  886,8AA
14B3E:  MOVWF  xAE
14B40:  MOVLB  0
14B42:  CALL   9CD4
....................                     macro_status=step_err_status(); 
14B46:  CALL   CF72
14B4A:  MOVFF  01,888
....................             break; 
14B4E:  BRA    14C42
....................          case 'B' : h_bridge(macro_arg); 
14B50:  MOVFF  886,896
14B54:  CALL   BEDA
....................                     macro_status = 'a'; 
14B58:  MOVLW  61
14B5A:  MOVLB  8
14B5C:  MOVWF  x88
....................             break;             
14B5E:  MOVLB  0
14B60:  BRA    14C42
....................          case 'G' : motor=0; 
14B62:  MOVLB  7
14B64:  CLRF   x40
....................                     align(0); 
14B66:  MOVLB  8
14B68:  CLRF   xA3
14B6A:  MOVLB  0
14B6C:  CALL   A810
....................                     macro_status=step_err_status(); 
14B70:  CALL   CF72
14B74:  MOVFF  01,888
....................             break ;           
14B78:  BRA    14C42
....................          case 'P' : motor=0; 
14B7A:  MOVLB  7
14B7C:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1);   
14B7E:  MOVLB  8
14B80:  CLRF   xA8
14B82:  CLRF   xA9
14B84:  CLRF   xAD
14B86:  CLRF   xAC
14B88:  MOVFF  882,8AB
14B8C:  MOVFF  881,8AA
14B90:  MOVLW  01
14B92:  MOVWF  xAE
14B94:  MOVLB  0
14B96:  CALL   9CD4
....................                     macro_status=step_err_status(); 
14B9A:  CALL   CF72
14B9E:  MOVFF  01,888
....................             break; 
14BA2:  BRA    14C42
....................          case 'Q' : motor=0; 
14BA4:  MOVLB  7
14BA6:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1); 
14BA8:  MOVLB  8
14BAA:  CLRF   xA8
14BAC:  CLRF   xA9
14BAE:  CLRF   xAD
14BB0:  CLRF   xAC
14BB2:  MOVFF  882,8AB
14BB6:  MOVFF  881,8AA
14BBA:  MOVLW  01
14BBC:  MOVWF  xAE
14BBE:  MOVLB  0
14BC0:  CALL   9CD4
....................                     macro_status=step_err_status(); 
14BC4:  CALL   CF72
14BC8:  MOVFF  01,888
....................             break; 
14BCC:  BRA    14C42
....................          case 'R' : motor=0; 
14BCE:  MOVLB  7
14BD0:  CLRF   x40
....................                     move_motor(0,1,mmacro_var,1); 
14BD2:  MOVLB  8
14BD4:  CLRF   xA8
14BD6:  MOVLW  01
14BD8:  MOVWF  xA9
14BDA:  CLRF   xAD
14BDC:  CLRF   xAC
14BDE:  MOVFF  882,8AB
14BE2:  MOVFF  881,8AA
14BE6:  MOVWF  xAE
14BE8:  MOVLB  0
14BEA:  CALL   9CD4
....................                     macro_status=step_err_status(); 
14BEE:  CALL   CF72
14BF2:  MOVFF  01,888
....................             break; 
14BF6:  BRA    14C42
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
14BF8:  MOVFF  887,8A4
14BFC:  MOVFF  886,8A3
14C00:  CALL   CFAA
....................                     macro_status = 'a'; 
14C04:  MOVLW  61
14C06:  MOVLB  8
14C08:  MOVWF  x88
....................             break; 
14C0A:  MOVLB  0
14C0C:  BRA    14C42
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
14C0E:  MOVLB  8
14C10:  DECFSZ x86,W
14C12:  BRA    14C22
14C14:  MOVF   x87,F
14C16:  BNZ   14C22
14C18:  MOVLB  0
14C1A:  CALL   CFE0
14C1E:  BRA    14C30
14C20:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14C22:  MOVF   x86,F
14C24:  BNZ   14C32
14C26:  MOVF   x87,F
14C28:  BNZ   14C32
14C2A:  MOVLB  0
14C2C:  CALL   D004
14C30:  MOVLB  8
....................                     macro_status = 'a'; 
14C32:  MOVLW  61
14C34:  MOVWF  x88
....................             break; 
14C36:  MOVLB  0
14C38:  BRA    14C42
....................          case ';' : macro_status = 'f'; 
14C3A:  MOVLW  66
14C3C:  MOVLB  8
14C3E:  MOVWF  x88
....................             break;            
14C40:  MOVLB  0
....................       } 
....................    } 
14C42:  BRA    14D6A
....................    else if (nv_product==AWS){ 
14C44:  MOVF   2F,W
14C46:  SUBLW  02
14C48:  BTFSS  FD8.2
14C4A:  BRA    14D6A
14C4C:  MOVF   30,F
14C4E:  BTFSS  FD8.2
14C50:  BRA    14D6A
....................       switch(macro_cmd){ 
14C52:  MOVLB  8
14C54:  MOVF   x85,W
14C56:  XORLW  2B
14C58:  MOVLB  0
14C5A:  BZ    14C80
14C5C:  XORLW  06
14C5E:  BZ    14CAA
14C60:  XORLW  6E
14C62:  BZ    14CD4
14C64:  XORLW  07
14C66:  BZ    14CE6
14C68:  XORLW  14
14C6A:  BZ    14CFC
14C6C:  XORLW  01
14C6E:  BZ    14D0E
14C70:  XORLW  02
14C72:  BZ    14D20
14C74:  XORLW  0A
14C76:  BZ    14D36
14C78:  XORLW  62
14C7A:  BTFSC  FD8.2
14C7C:  BRA    14D62
14C7E:  BRA    14D6A
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14C80:  MOVLW  01
14C82:  MOVLB  7
14C84:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14C86:  MOVLB  8
14C88:  CLRF   xA8
14C8A:  CLRF   xA9
14C8C:  CLRF   xAD
14C8E:  CLRF   xAC
14C90:  MOVFF  887,8AB
14C94:  MOVFF  886,8AA
14C98:  MOVWF  xAE
14C9A:  MOVLB  0
14C9C:  CALL   9CD4
....................                     macro_status=step_err_status(); 
14CA0:  CALL   CF72
14CA4:  MOVFF  01,888
....................             break; 
14CA8:  BRA    14D6A
....................          case '-' : motor=1; 
14CAA:  MOVLW  01
14CAC:  MOVLB  7
14CAE:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14CB0:  MOVLB  8
14CB2:  CLRF   xA8
14CB4:  MOVWF  xA9
14CB6:  CLRF   xAD
14CB8:  CLRF   xAC
14CBA:  MOVFF  887,8AB
14CBE:  MOVFF  886,8AA
14CC2:  MOVWF  xAE
14CC4:  MOVLB  0
14CC6:  CALL   9CD4
....................                     macro_status=step_err_status(); 
14CCA:  CALL   CF72
14CCE:  MOVFF  01,888
....................             break; 
14CD2:  BRA    14D6A
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
14CD4:  MOVFF  886,897
14CD8:  CALL   D826
....................                     macro_status = 'a';  
14CDC:  MOVLW  61
14CDE:  MOVLB  8
14CE0:  MOVWF  x88
....................             break;          
14CE2:  MOVLB  0
14CE4:  BRA    14D6A
....................          case 'D' : delay_sec(macro_arg); 
14CE6:  MOVFF  887,8A4
14CEA:  MOVFF  886,8A3
14CEE:  CALL   CFAA
....................                     macro_status = 'a'; 
14CF2:  MOVLW  61
14CF4:  MOVLB  8
14CF6:  MOVWF  x88
....................             break; 
14CF8:  MOVLB  0
14CFA:  BRA    14D6A
....................          case 'P' : sol_switch(mmacro_var); 
14CFC:  MOVFF  881,896
14D00:  CALL   1411A
....................                     macro_status = 'a'; 
14D04:  MOVLW  61
14D06:  MOVLB  8
14D08:  MOVWF  x88
....................             break;              
14D0A:  MOVLB  0
14D0C:  BRA    14D6A
....................          case 'Q' : sol_switch(macro_arg); 
14D0E:  MOVFF  886,896
14D12:  CALL   1411A
....................                     macro_status = 'a'; 
14D16:  MOVLW  61
14D18:  MOVLB  8
14D1A:  MOVWF  x88
....................             break;             
14D1C:  MOVLB  0
14D1E:  BRA    14D6A
....................          case 'S' : sol_switch_cmd(macro_arg); 
14D20:  MOVFF  887,898
14D24:  MOVFF  886,897
14D28:  CALL   14064
....................                     macro_status = 'a'; 
14D2C:  MOVLW  61
14D2E:  MOVLB  8
14D30:  MOVWF  x88
....................             break; 
14D32:  MOVLB  0
14D34:  BRA    14D6A
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14D36:  MOVLB  8
14D38:  DECFSZ x86,W
14D3A:  BRA    14D4A
14D3C:  MOVF   x87,F
14D3E:  BNZ   14D4A
14D40:  MOVLB  0
14D42:  CALL   CFE0
14D46:  BRA    14D58
14D48:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14D4A:  MOVF   x86,F
14D4C:  BNZ   14D5A
14D4E:  MOVF   x87,F
14D50:  BNZ   14D5A
14D52:  MOVLB  0
14D54:  CALL   D004
14D58:  MOVLB  8
....................                     macro_status = 'a'; 
14D5A:  MOVLW  61
14D5C:  MOVWF  x88
....................             break;               
14D5E:  MOVLB  0
14D60:  BRA    14D6A
....................          case ';' : macro_status = 'f'; 
14D62:  MOVLW  66
14D64:  MOVLB  8
14D66:  MOVWF  x88
....................             break;            
14D68:  MOVLB  0
14D6A:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
14D6C:  MOVFF  888,01
14D70:  MOVLB  0
14D72:  GOTO   15082 (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
14F50:  MOVLB  8
14F52:  CLRF   x58
14F54:  CLRF   x57
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
14F56:  MOVLB  0
14F58:  CALL   507A
....................    clear_data_arrays(); 
14F5C:  GOTO   10166
....................     
....................    line = 0;  
14F60:  MOVLB  8
14F62:  CLRF   x7C
14F64:  CLRF   x7B
....................    macro_status = 'a'; 
14F66:  MOVLW  61
14F68:  MOVWF  x7D
....................    data_available = FALSE; 
14F6A:  MOVLB  3
14F6C:  CLRF   x3B
....................    macro_flag = 900; 
14F6E:  MOVLW  03
14F70:  MOVWF  x24
14F72:  MOVLW  84
14F74:  MOVWF  x23
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
14F76:  MOVLW  01
14F78:  MOVWF  1E
14F7A:  MOVLW  A7
14F7C:  MOVWF  1D
14F7E:  MOVLW  6E
14F80:  MOVWF  FF6
14F82:  MOVLW  21
14F84:  MOVWF  FF7
14F86:  MOVLW  00
14F88:  MOVWF  FF8
14F8A:  MOVLW  07
14F8C:  MOVLB  8
14F8E:  MOVWF  xCC
14F90:  MOVLB  0
14F92:  CALL   AA28
14F96:  MOVFF  878,8CE
14F9A:  MOVLW  1B
14F9C:  MOVLB  8
14F9E:  MOVWF  xCF
14FA0:  MOVLB  0
14FA2:  CALL   5214
14FA6:  MOVLW  77
14FA8:  MOVWF  FF6
14FAA:  MOVLW  21
14FAC:  MOVWF  FF7
14FAE:  MOVLW  00
14FB0:  MOVWF  FF8
14FB2:  MOVLW  09
14FB4:  MOVLB  8
14FB6:  MOVWF  xCC
14FB8:  MOVLB  0
14FBA:  CALL   AA28
....................    record_event();    
14FBE:  CALL   8436
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
14FC2:  MOVLB  8
14FC4:  MOVF   x7C,W
14FC6:  SUBLW  03
14FC8:  BNC   1509A
14FCA:  MOVF   x7D,W
14FCC:  SUBLW  61
14FCE:  BNZ   1509A
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
14FD0:  MOVF   1F,W
14FD2:  SUBLW  04
14FD4:  BNZ   15068
14FD6:  MOVF   20,F
14FD8:  BNZ   15068
....................                                                macro_status, (line + 1)); 
14FDA:  MOVLW  01
14FDC:  ADDWF  x7B,W
14FDE:  MOVWF  x7E
14FE0:  MOVLW  00
14FE2:  ADDWFC x7C,W
14FE4:  MOVWF  x7F
14FE6:  MOVLW  82
14FE8:  MOVWF  FF6
14FEA:  MOVLW  21
14FEC:  MOVWF  FF7
14FEE:  MOVLW  00
14FF0:  MOVWF  FF8
14FF2:  CLRF   1B
14FF4:  BTFSC  FF2.7
14FF6:  BSF    1B.7
14FF8:  BCF    FF2.7
14FFA:  MOVLW  05
14FFC:  MOVLB  A
14FFE:  MOVWF  x1C
15000:  MOVLB  0
15002:  CALL   1024
15006:  BTFSC  1B.7
15008:  BSF    FF2.7
1500A:  MOVLB  8
1500C:  MOVF   x7D,W
1500E:  BTFSS  F9E.4
15010:  BRA    1500E
15012:  MOVWF  FAD
15014:  MOVLW  5D
15016:  BTFSS  F9E.4
15018:  BRA    15016
1501A:  MOVWF  FAD
1501C:  MOVLW  5B
1501E:  BTFSS  F9E.4
15020:  BRA    1501E
15022:  MOVWF  FAD
15024:  MOVLW  10
15026:  MOVWF  FE9
15028:  CLRF   1B
1502A:  BTFSC  FF2.7
1502C:  BSF    1B.7
1502E:  BCF    FF2.7
15030:  MOVFF  87F,A1D
15034:  MOVFF  87E,A1C
15038:  MOVLB  0
1503A:  CALL   11A6
1503E:  BTFSC  1B.7
15040:  BSF    FF2.7
15042:  MOVLW  8E
15044:  MOVWF  FF6
15046:  MOVLW  21
15048:  MOVWF  FF7
1504A:  MOVLW  00
1504C:  MOVWF  FF8
1504E:  CLRF   1B
15050:  BTFSC  FF2.7
15052:  BSF    1B.7
15054:  BCF    FF2.7
15056:  MOVLW  03
15058:  MOVLB  A
1505A:  MOVWF  x1C
1505C:  MOVLB  0
1505E:  CALL   1024
15062:  BTFSC  1B.7
15064:  BSF    FF2.7
15066:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
15068:  MOVFF  878,87E
1506C:  MOVLW  08
1506E:  MOVWF  x80
15070:  MOVLW  7B
15072:  MOVWF  x7F
15074:  MOVFF  87A,882
15078:  MOVFF  879,881
1507C:  MOVLB  0
1507E:  GOTO   145A2
15082:  MOVFF  01,87D
....................       ++line; 
15086:  MOVLB  8
15088:  INCF   x7B,F
1508A:  BTFSC  FD8.2
1508C:  INCF   x7C,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
1508E:  DECFSZ 50,W
15090:  BRA    15098
....................          macro_status = 'g'; 
15092:  MOVLW  67
15094:  MOVWF  x7D
....................          break;    
15096:  BRA    1509A
....................       } 
15098:  BRA    14FC4
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
1509A:  MOVF   2F,W
1509C:  MOVWF  00
1509E:  MOVF   30,W
150A0:  MOVWF  03
150A2:  MOVF   03,W
150A4:  BNZ   150B0
150A6:  MOVLW  01
150A8:  SUBWF  00,W
150AA:  MOVLB  0
150AC:  BZ    150CE
150AE:  MOVLB  8
150B0:  MOVF   03,W
150B2:  BNZ   150BE
150B4:  MOVLW  03
150B6:  SUBWF  00,W
150B8:  MOVLB  0
150BA:  BZ    150CE
150BC:  MOVLB  8
150BE:  MOVF   03,W
150C0:  BNZ   150CC
150C2:  MOVLW  02
150C4:  SUBWF  00,W
150C6:  MOVLB  0
150C8:  BZ    150DA
150CA:  MOVLB  8
150CC:  BRA    150EA
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
150CE:  MOVFF  878,87E
150D2:  CALL   D2AE
....................          break; 
150D6:  MOVLB  8
150D8:  BRA    150EA
....................       case AWS : store_aws_data(macro,mmacro_var); 
150DA:  MOVFF  878,87E
150DE:  MOVFF  87A,880
150E2:  MOVFF  879,87F
150E6:  BRA    14E26
....................          break; 
150E8:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
150EA:  MOVLW  61
150EC:  SUBWF  x7D,W
150EE:  ADDLW  F9
150F0:  BC    151DC
150F2:  ADDLW  07
150F4:  MOVLB  0
150F6:  GOTO   15288
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
150FA:  MOVLW  92
150FC:  MOVWF  FF6
150FE:  MOVLW  21
15100:  MOVWF  FF7
15102:  MOVLW  00
15104:  MOVWF  FF8
15106:  CLRF   1B
15108:  BTFSC  FF2.7
1510A:  BSF    1B.7
1510C:  BCF    FF2.7
1510E:  CALL   0E4E
15112:  BTFSC  1B.7
15114:  BSF    FF2.7
....................          break; 
15116:  MOVLB  8
15118:  BRA    151DC
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
1511A:  MOVLW  9A
1511C:  MOVWF  FF6
1511E:  MOVLW  21
15120:  MOVWF  FF7
15122:  MOVLW  00
15124:  MOVWF  FF8
15126:  CLRF   1B
15128:  BTFSC  FF2.7
1512A:  BSF    1B.7
1512C:  BCF    FF2.7
1512E:  CALL   0E4E
15132:  BTFSC  1B.7
15134:  BSF    FF2.7
....................          break; 
15136:  MOVLB  8
15138:  BRA    151DC
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
1513A:  MOVLW  A2
1513C:  MOVWF  FF6
1513E:  MOVLW  21
15140:  MOVWF  FF7
15142:  MOVLW  00
15144:  MOVWF  FF8
15146:  CLRF   1B
15148:  BTFSC  FF2.7
1514A:  BSF    1B.7
1514C:  BCF    FF2.7
1514E:  CALL   0E4E
15152:  BTFSC  1B.7
15154:  BSF    FF2.7
....................          break; 
15156:  MOVLB  8
15158:  BRA    151DC
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
1515A:  MOVLW  AA
1515C:  MOVWF  FF6
1515E:  MOVLW  21
15160:  MOVWF  FF7
15162:  MOVLW  00
15164:  MOVWF  FF8
15166:  CLRF   1B
15168:  BTFSC  FF2.7
1516A:  BSF    1B.7
1516C:  BCF    FF2.7
1516E:  CALL   0E4E
15172:  BTFSC  1B.7
15174:  BSF    FF2.7
....................          break; 
15176:  MOVLB  8
15178:  BRA    151DC
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
1517A:  MOVLW  B2
1517C:  MOVWF  FF6
1517E:  MOVLW  21
15180:  MOVWF  FF7
15182:  MOVLW  00
15184:  MOVWF  FF8
15186:  CLRF   1B
15188:  BTFSC  FF2.7
1518A:  BSF    1B.7
1518C:  BCF    FF2.7
1518E:  CALL   0E4E
15192:  BTFSC  1B.7
15194:  BSF    FF2.7
....................          break;    
15196:  MOVLB  8
15198:  BRA    151DC
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
1519A:  MOVLW  BA
1519C:  MOVWF  FF6
1519E:  MOVLW  21
151A0:  MOVWF  FF7
151A2:  MOVLW  00
151A4:  MOVWF  FF8
151A6:  CLRF   1B
151A8:  BTFSC  FF2.7
151AA:  BSF    1B.7
151AC:  BCF    FF2.7
151AE:  CALL   0E4E
151B2:  BTFSC  1B.7
151B4:  BSF    FF2.7
....................          break;    
151B6:  MOVLB  8
151B8:  BRA    151DC
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
151BA:  MOVLW  C2
151BC:  MOVWF  FF6
151BE:  MOVLW  21
151C0:  MOVWF  FF7
151C2:  MOVLW  00
151C4:  MOVWF  FF8
151C6:  CLRF   1B
151C8:  BTFSC  FF2.7
151CA:  BSF    1B.7
151CC:  BCF    FF2.7
151CE:  CALL   0E4E
151D2:  BTFSC  1B.7
151D4:  BSF    FF2.7
....................          break;           
151D6:  MOVLB  8
151D8:  BRA    151DC
151DA:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
151DC:  MOVLW  01
151DE:  MOVWF  1E
151E0:  MOVLW  A7
151E2:  MOVWF  1D
151E4:  MOVLW  CA
151E6:  MOVWF  FF6
151E8:  MOVLW  21
151EA:  MOVWF  FF7
151EC:  MOVLW  00
151EE:  MOVWF  FF8
151F0:  MOVLW  07
151F2:  MOVWF  xCC
151F4:  MOVLB  0
151F6:  CALL   AA28
151FA:  MOVFF  878,8CE
151FE:  MOVLW  1B
15200:  MOVLB  8
15202:  MOVWF  xCF
15204:  MOVLB  0
15206:  CALL   5214
1520A:  MOVLW  D3
1520C:  MOVWF  FF6
1520E:  MOVLW  21
15210:  MOVWF  FF7
15212:  MOVLW  00
15214:  MOVWF  FF8
15216:  MOVLW  09
15218:  MOVLB  8
1521A:  MOVWF  xCC
1521C:  MOVLB  0
1521E:  CALL   AA28
15222:  MOVFF  87D,8E0
15226:  CALL   5032
1522A:  MOVLW  DE
1522C:  MOVWF  FF6
1522E:  MOVLW  21
15230:  MOVWF  FF7
15232:  MOVLW  00
15234:  MOVWF  FF8
15236:  MOVLW  07
15238:  MOVLB  8
1523A:  MOVWF  xCC
1523C:  MOVLB  0
1523E:  CALL   AA28
15242:  MOVLW  10
15244:  MOVWF  FE9
15246:  MOVFF  87C,8D8
1524A:  MOVFF  87B,8D7
1524E:  CALL   AA5A
15252:  MOVLW  E8
15254:  MOVWF  FF6
15256:  MOVLW  21
15258:  MOVWF  FF7
1525A:  MOVLW  00
1525C:  MOVWF  FF8
1525E:  MOVLW  03
15260:  MOVLB  8
15262:  MOVWF  xCC
15264:  MOVLB  0
15266:  CALL   AA28
....................    record_event(); 
1526A:  CALL   8436
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
1526E:  MOVLB  8
15270:  MOVF   x7D,W
15272:  SUBLW  66
15274:  BZ    15284
15276:  MOVF   x7D,W
15278:  SUBLW  67
1527A:  BZ    15284
1527C:  MOVLB  0
1527E:  CALL   A9B4
15282:  MOVLB  8
15284:  MOVLB  0
15286:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15B1C:  MOVLW  01
15B1E:  MOVLB  8
15B20:  MOVWF  x70
....................    while (macro_batch == TRUE){ 
15B22:  DECFSZ x70,W
15B24:  BRA    15DAA
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15B26:  MOVFF  38,9EE
15B2A:  MOVFF  37,9ED
15B2E:  MOVLB  9
15B30:  CLRF   xF0
15B32:  MOVLW  03
15B34:  MOVWF  xEF
15B36:  MOVLB  0
15B38:  CALL   5C32
15B3C:  MOVF   01,W
15B3E:  MOVLB  7
15B40:  ADDWF  xD1,W
15B42:  MOVLB  8
15B44:  MOVWF  x6B
15B46:  MOVF   02,W
15B48:  MOVLB  7
15B4A:  ADDWFC xD2,W
15B4C:  MOVLB  8
15B4E:  MOVWF  x6C
....................       init_ext_eeprom(); 
15B50:  MOVLB  0
15B52:  CALL   FFEE
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
15B56:  MOVFF  86C,8AD
15B5A:  MOVFF  86B,8AC
15B5E:  CALL   10254
15B62:  MOVFF  01,86D
....................       ++addr; 
15B66:  MOVLB  8
15B68:  INCF   x6B,F
15B6A:  BTFSC  FD8.2
15B6C:  INCF   x6C,F
....................       macro_arg = read16_ext_eeprom(addr); 
15B6E:  MOVFF  86C,8A4
15B72:  MOVFF  86B,8A3
15B76:  MOVLB  0
15B78:  CALL   10368
15B7C:  MOVFF  02,86F
15B80:  MOVFF  01,86E
....................       ++addr; 
15B84:  MOVLB  8
15B86:  INCF   x6B,F
15B88:  BTFSC  FD8.2
15B8A:  INCF   x6C,F
....................       ++addr;      
15B8C:  INCF   x6B,F
15B8E:  BTFSC  FD8.2
15B90:  INCF   x6C,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
15B92:  MOVF   x6D,W
15B94:  SUBLW  4D
15B96:  BTFSS  FD8.2
15B98:  BRA    15CC2
15B9A:  MOVF   x6E,F
15B9C:  BNZ   15BA4
15B9E:  MOVF   x6F,F
15BA0:  BTFSC  FD8.2
15BA2:  BRA    15CC2
....................          { 
....................          RTC_reset_HT(); 
15BA4:  MOVLB  0
15BA6:  CALL   344E
....................          RTC_read(); 
15BAA:  CALL   32E0
....................          RTC_display(); 
15BAE:  CALL   DEFA
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
15BB2:  MOVLW  EC
15BB4:  MOVWF  FF6
15BB6:  MOVLW  21
15BB8:  MOVWF  FF7
15BBA:  MOVLW  00
15BBC:  MOVWF  FF8
15BBE:  CLRF   1B
15BC0:  BTFSC  FF2.7
15BC2:  BSF    1B.7
15BC4:  BCF    FF2.7
15BC6:  MOVLW  09
15BC8:  MOVLB  A
15BCA:  MOVWF  x1C
15BCC:  MOVLB  0
15BCE:  CALL   1024
15BD2:  BTFSC  1B.7
15BD4:  BSF    FF2.7
15BD6:  MOVLB  8
15BD8:  MOVF   x6D,W
15BDA:  BTFSS  F9E.4
15BDC:  BRA    15BDA
15BDE:  MOVWF  FAD
15BE0:  MOVLW  10
15BE2:  MOVWF  FE9
15BE4:  CLRF   1B
15BE6:  BTFSC  FF2.7
15BE8:  BSF    1B.7
15BEA:  BCF    FF2.7
15BEC:  MOVFF  86F,A1D
15BF0:  MOVFF  86E,A1C
15BF4:  MOVLB  0
15BF6:  CALL   11A6
15BFA:  BTFSC  1B.7
15BFC:  BSF    FF2.7
15BFE:  MOVLW  FA
15C00:  MOVWF  FF6
15C02:  MOVLW  21
15C04:  MOVWF  FF7
15C06:  MOVLW  00
15C08:  MOVWF  FF8
15C0A:  CLRF   1B
15C0C:  BTFSC  FF2.7
15C0E:  BSF    1B.7
15C10:  BCF    FF2.7
15C12:  MOVLW  03
15C14:  MOVLB  A
15C16:  MOVWF  x1C
15C18:  MOVLB  0
15C1A:  CALL   1024
15C1E:  BTFSC  1B.7
15C20:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
15C22:  MOVLW  01
15C24:  ADDWF  21,W
15C26:  MOVLB  8
15C28:  MOVWF  x71
15C2A:  MOVLW  00
15C2C:  ADDWFC 22,W
15C2E:  MOVWF  x72
15C30:  MOVLW  FE
15C32:  MOVWF  FF6
15C34:  MOVLW  21
15C36:  MOVWF  FF7
15C38:  MOVLW  00
15C3A:  MOVWF  FF8
15C3C:  CLRF   1B
15C3E:  BTFSC  FF2.7
15C40:  BSF    1B.7
15C42:  BCF    FF2.7
15C44:  MOVLW  07
15C46:  MOVLB  A
15C48:  MOVWF  x1C
15C4A:  MOVLB  0
15C4C:  CALL   1024
15C50:  BTFSC  1B.7
15C52:  BSF    FF2.7
15C54:  MOVLW  09
15C56:  MOVWF  FE9
15C58:  CLRF   1B
15C5A:  BTFSC  FF2.7
15C5C:  BSF    1B.7
15C5E:  BCF    FF2.7
15C60:  MOVFF  872,A1D
15C64:  MOVFF  871,A1C
15C68:  CALL   11A6
15C6C:  BTFSC  1B.7
15C6E:  BSF    FF2.7
15C70:  MOVLW  0A
15C72:  MOVWF  FF6
15C74:  MOVLW  22
15C76:  MOVWF  FF7
15C78:  MOVLW  00
15C7A:  MOVWF  FF8
15C7C:  CLRF   1B
15C7E:  BTFSC  FF2.7
15C80:  BSF    1B.7
15C82:  BCF    FF2.7
15C84:  MOVLW  04
15C86:  MOVLB  A
15C88:  MOVWF  x1C
15C8A:  MOVLB  0
15C8C:  CALL   1024
15C90:  BTFSC  1B.7
15C92:  BSF    FF2.7
15C94:  MOVLW  09
15C96:  MOVWF  FE9
15C98:  CLRF   1B
15C9A:  BTFSC  FF2.7
15C9C:  BSF    1B.7
15C9E:  BCF    FF2.7
15CA0:  MOVFF  28,A1D
15CA4:  MOVFF  27,A1C
15CA8:  CALL   11A6
15CAC:  BTFSC  1B.7
15CAE:  BSF    FF2.7
15CB0:  MOVLW  0D
15CB2:  BTFSS  F9E.4
15CB4:  BRA    15CB2
15CB6:  MOVWF  FAD
15CB8:  MOVLW  0A
15CBA:  BTFSS  F9E.4
15CBC:  BRA    15CBA
15CBE:  MOVWF  FAD
15CC0:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
15CC2:  MOVF   28,W
15CC4:  SUBWF  22,W
15CC6:  BNC   15CD4
15CC8:  BNZ   15CD0
15CCA:  MOVF   27,W
15CCC:  SUBWF  21,W
15CCE:  BNC   15CD4
....................          {macro_cmd = 'Z';} 
15CD0:  MOVLW  5A
15CD2:  MOVWF  x6D
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
15CD4:  MOVF   x6D,W
15CD6:  XORLW  72
15CD8:  MOVLB  0
15CDA:  BZ    15CEE
15CDC:  XORLW  57
15CDE:  BZ    15D10
15CE0:  XORLW  68
15CE2:  BZ    15D46
15CE4:  XORLW  17
15CE6:  BZ    15D7C
15CE8:  XORLW  61
15CEA:  BZ    15D88
15CEC:  BRA    15D92
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
15CEE:  INCF   37,F
15CF0:  BTFSC  FD8.2
15CF2:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
15CF4:  MOVLB  8
15CF6:  CLRF   x60
15CF8:  CLRF   x5F
15CFA:  MOVFF  38,85E
15CFE:  MOVFF  37,85D
....................                master_macro_loop_count = macro_arg; 
15D02:  CLRF   x5C
15D04:  CLRF   x5B
15D06:  MOVFF  86F,85A
15D0A:  MOVFF  86E,859
....................             break; 
15D0E:  BRA    15D9E
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
15D10:  MOVLB  8
15D12:  MOVF   x5C,F
15D14:  BNZ   15D24
15D16:  MOVF   x5B,F
15D18:  BNZ   15D24
15D1A:  MOVF   x5A,F
15D1C:  BNZ   15D24
15D1E:  MOVF   x59,W
15D20:  SUBLW  01
15D22:  BC    15D3E
....................                   nv_macro_step = master_macro_loop_start; 
15D24:  MOVFF  85E,38
15D28:  MOVFF  85D,37
....................                   master_macro_loop_count--; 
15D2C:  MOVLW  FF
15D2E:  ADDWF  x59,F
15D30:  BTFSS  FD8.0
15D32:  ADDWF  x5A,F
15D34:  BTFSS  FD8.0
15D36:  ADDWF  x5B,F
15D38:  BTFSS  FD8.0
15D3A:  ADDWF  x5C,F
....................                }else{ 
15D3C:  BRA    15D44
....................                   nv_macro_step++; 
15D3E:  INCF   37,F
15D40:  BTFSC  FD8.2
15D42:  INCF   38,F
....................                } 
....................             break; 
15D44:  BRA    15D9E
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
15D46:  MOVLB  8
15D48:  MOVF   x6F,F
15D4A:  BNZ   15D7A
15D4C:  MOVF   x6E,W
15D4E:  SUBLW  14
15D50:  BNC   15D7A
....................                   play_macro(macro_arg,0);     // casts to int8 
15D52:  MOVFF  86E,878
15D56:  CLRF   x7A
15D58:  CLRF   x79
15D5A:  MOVLB  0
15D5C:  CALL   14F50
....................                   delay_ms(100); 
15D60:  MOVLW  64
15D62:  MOVLB  9
15D64:  MOVWF  xCD
15D66:  MOVLB  0
15D68:  CALL   28AC
....................                   ++nv_sample; 
15D6C:  INCF   21,F
15D6E:  BTFSC  FD8.2
15D70:  INCF   22,F
....................                   ++nv_macro_step; 
15D72:  INCF   37,F
15D74:  BTFSC  FD8.2
15D76:  INCF   38,F
15D78:  MOVLB  8
....................                } 
....................                break; 
15D7A:  BRA    15D9E
....................             case 'Z' : ++nv_macro_step; 
15D7C:  INCF   37,F
15D7E:  BTFSC  FD8.2
15D80:  INCF   38,F
....................                        macro_batch = FALSE; 
15D82:  MOVLB  8
15D84:  CLRF   x70
....................                break; 
15D86:  BRA    15D9E
....................             case ';' : nv_macro_step = 0; 
15D88:  CLRF   38
15D8A:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
15D8C:  MOVLB  8
15D8E:  BRA    15D9E
15D90:  MOVLB  0
....................             default  : cmd_err(); 
15D92:  CALL   BC4A
....................                        macro_cmd = 'e'; 
15D96:  MOVLW  65
15D98:  MOVLB  8
15D9A:  MOVWF  x6D
....................                        macro_batch = FALSE; 
15D9C:  CLRF   x70
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
15D9E:  DECFSZ 50,W
15DA0:  BRA    15DA8
....................             macro_cmd = ';'; 
15DA2:  MOVLW  3B
15DA4:  MOVWF  x6D
....................             break;         // 17 = CTRL-Q (quit) 
15DA6:  BRA    15DAA
....................          } 
15DA8:  BRA    15B22
....................    } 
....................    return (macro_cmd); 
15DAA:  MOVFF  86D,01
15DAE:  MOVLB  0
15DB0:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D01A:  MOVLB  8
0D01C:  MOVF   x6D,W
0D01E:  XORLW  2B
0D020:  MOVLB  0
0D022:  BZ    D052
0D024:  XORLW  06
0D026:  BZ    D07A
0D028:  XORLW  6F
0D02A:  BZ    D0A2
0D02C:  XORLW  05
0D02E:  BZ    D0B4
0D030:  XORLW  17
0D032:  BZ    D0CA
0D034:  XORLW  01
0D036:  BZ    D0FA
0D038:  XORLW  03
0D03A:  BTFSC  FD8.2
0D03C:  BRA    D122
0D03E:  XORLW  06
0D040:  BTFSC  FD8.2
0D042:  BRA    D14A
0D044:  XORLW  0D
0D046:  BTFSC  FD8.2
0D048:  BRA    D15E
0D04A:  XORLW  62
0D04C:  BTFSC  FD8.2
0D04E:  BRA    D186
0D050:  BRA    D18E
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D052:  MOVLW  01
0D054:  MOVLB  7
0D056:  MOVWF  x40
....................                  move_motor(0,0,macro_arg,1); 
0D058:  MOVLB  8
0D05A:  CLRF   xA8
0D05C:  CLRF   xA9
0D05E:  CLRF   xAD
0D060:  CLRF   xAC
0D062:  MOVFF  86F,8AB
0D066:  MOVFF  86E,8AA
0D06A:  MOVWF  xAE
0D06C:  MOVLB  0
0D06E:  CALL   9CD4
....................                  macro_status=step_err_status(); 
0D072:  RCALL  CF72
0D074:  MOVFF  01,870
....................          break; 
0D078:  BRA    D18E
....................       case '-' : motor=1; 
0D07A:  MOVLW  01
0D07C:  MOVLB  7
0D07E:  MOVWF  x40
....................                  move_motor(0,1,macro_arg,1); 
0D080:  MOVLB  8
0D082:  CLRF   xA8
0D084:  MOVWF  xA9
0D086:  CLRF   xAD
0D088:  CLRF   xAC
0D08A:  MOVFF  86F,8AB
0D08E:  MOVFF  86E,8AA
0D092:  MOVWF  xAE
0D094:  MOVLB  0
0D096:  CALL   9CD4
....................                  macro_status=step_err_status(); 
0D09A:  RCALL  CF72
0D09C:  MOVFF  01,870
....................          break; 
0D0A0:  BRA    D18E
....................       case 'B' : h_bridge(macro_arg); 
0D0A2:  MOVFF  86E,896
0D0A6:  CALL   BEDA
....................                  macro_status = 'a'; 
0D0AA:  MOVLW  61
0D0AC:  MOVLB  8
0D0AE:  MOVWF  x70
....................          break; 
0D0B0:  MOVLB  0
0D0B2:  BRA    D18E
....................       case 'G' : motor=0; 
0D0B4:  MOVLB  7
0D0B6:  CLRF   x40
....................                  align(0); 
0D0B8:  MOVLB  8
0D0BA:  CLRF   xA3
0D0BC:  MOVLB  0
0D0BE:  CALL   A810
....................                  macro_status=step_err_status(); 
0D0C2:  RCALL  CF72
0D0C4:  MOVFF  01,870
....................          break ;           
0D0C8:  BRA    D18E
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D0CA:  MOVFF  86F,2E
0D0CE:  MOVFF  86E,2D
....................                  motor=0; 
0D0D2:  MOVLB  7
0D0D4:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1);   
0D0D6:  MOVLB  8
0D0D8:  CLRF   xA8
0D0DA:  CLRF   xA9
0D0DC:  CLRF   xAD
0D0DE:  CLRF   xAC
0D0E0:  MOVFF  86F,8AB
0D0E4:  MOVFF  86E,8AA
0D0E8:  MOVLW  01
0D0EA:  MOVWF  xAE
0D0EC:  MOVLB  0
0D0EE:  CALL   9CD4
....................                  macro_status=step_err_status(); 
0D0F2:  RCALL  CF72
0D0F4:  MOVFF  01,870
....................          break; 
0D0F8:  BRA    D18E
....................       case 'Q' : motor=0; 
0D0FA:  MOVLB  7
0D0FC:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1); 
0D0FE:  MOVLB  8
0D100:  CLRF   xA8
0D102:  CLRF   xA9
0D104:  CLRF   xAD
0D106:  CLRF   xAC
0D108:  MOVFF  86F,8AB
0D10C:  MOVFF  86E,8AA
0D110:  MOVLW  01
0D112:  MOVWF  xAE
0D114:  MOVLB  0
0D116:  CALL   9CD4
....................                  macro_status=step_err_status(); 
0D11A:  RCALL  CF72
0D11C:  MOVFF  01,870
....................          break; 
0D120:  BRA    D18E
....................       case 'R' : motor=0; 
0D122:  MOVLB  7
0D124:  CLRF   x40
....................                  move_motor(0,1,macro_arg,1); 
0D126:  MOVLB  8
0D128:  CLRF   xA8
0D12A:  MOVLW  01
0D12C:  MOVWF  xA9
0D12E:  CLRF   xAD
0D130:  CLRF   xAC
0D132:  MOVFF  86F,8AB
0D136:  MOVFF  86E,8AA
0D13A:  MOVWF  xAE
0D13C:  MOVLB  0
0D13E:  CALL   9CD4
....................                  macro_status=step_err_status(); 
0D142:  RCALL  CF72
0D144:  MOVFF  01,870
....................          break; 
0D148:  BRA    D18E
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D14A:  MOVFF  86F,8A4
0D14E:  MOVFF  86E,8A3
0D152:  RCALL  CFAA
....................                  macro_status = 'a'; 
0D154:  MOVLW  61
0D156:  MOVLB  8
0D158:  MOVWF  x70
....................          break; 
0D15A:  MOVLB  0
0D15C:  BRA    D18E
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D15E:  MOVLB  8
0D160:  DECFSZ x6E,W
0D162:  BRA    D170
0D164:  MOVF   x6F,F
0D166:  BNZ   D170
0D168:  MOVLB  0
0D16A:  RCALL  CFE0
0D16C:  BRA    D17C
0D16E:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D170:  MOVF   x6E,F
0D172:  BNZ   D17E
0D174:  MOVF   x6F,F
0D176:  BNZ   D17E
0D178:  MOVLB  0
0D17A:  RCALL  D004
0D17C:  MOVLB  8
....................                  macro_status = 'a'; 
0D17E:  MOVLW  61
0D180:  MOVWF  x70
....................          break;           
0D182:  MOVLB  0
0D184:  BRA    D18E
....................       case ';' : macro_status = 'f'; 
0D186:  MOVLW  66
0D188:  MOVLB  8
0D18A:  MOVWF  x70
....................          break;            
0D18C:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D18E:  MOVLB  8
0D190:  MOVFF  870,01
0D194:  MOVLB  0
0D196:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D470:  MOVF   2E,F
0D472:  BNZ   D47A
0D474:  MOVF   2D,W
0D476:  SUBLW  01
0D478:  BC    D48C
0D47A:  MOVF   2E,F
0D47C:  BNZ   D48C
0D47E:  MOVF   2D,W
0D480:  SUBLW  30
0D482:  BNC   D48C
0D484:  DECFSZ 2F,W
0D486:  BRA    D48C
0D488:  MOVF   30,F
0D48A:  BZ    D4AA
0D48C:  MOVF   2E,F
0D48E:  BNZ   D496
0D490:  MOVF   2D,W
0D492:  SUBLW  01
0D494:  BC    D4B4
0D496:  MOVF   2E,F
0D498:  BNZ   D4B4
0D49A:  MOVF   2D,W
0D49C:  SUBLW  32
0D49E:  BNC   D4B4
0D4A0:  MOVF   2F,W
0D4A2:  SUBLW  03
0D4A4:  BNZ   D4B4
0D4A6:  MOVF   30,F
0D4A8:  BNZ   D4B4
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D4AA:  MOVLW  61
0D4AC:  MOVLB  8
0D4AE:  MOVWF  x6C
....................    } 
0D4B0:  BRA    D4BC
0D4B2:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D4B4:  MOVLW  65
0D4B6:  MOVLB  8
0D4B8:  MOVWF  x6C
....................       goto end_macro;       
0D4BA:  BRA    D56C
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D4BC:  MOVLW  59
0D4BE:  MOVWF  x6D
0D4C0:  CLRF   x6F
0D4C2:  MOVLW  01
0D4C4:  MOVWF  x6E
0D4C6:  MOVLB  0
0D4C8:  RCALL  D01A
0D4CA:  MOVFF  01,86C
....................    if (macro_status != 'a') goto end_macro; 
0D4CE:  MOVLB  8
0D4D0:  MOVF   x6C,W
0D4D2:  SUBLW  61
0D4D4:  BTFSS  FD8.2
0D4D6:  BRA    D56C
....................    macro_status = play_wms_macro_cmd('G',1); 
0D4D8:  MOVLW  47
0D4DA:  MOVWF  x6D
0D4DC:  CLRF   x6F
0D4DE:  MOVLW  01
0D4E0:  MOVWF  x6E
0D4E2:  MOVLB  0
0D4E4:  RCALL  D01A
0D4E6:  MOVFF  01,86C
....................    if (macro_status != 'a') goto end_macro; 
0D4EA:  MOVLB  8
0D4EC:  MOVF   x6C,W
0D4EE:  SUBLW  61
0D4F0:  BTFSS  FD8.2
0D4F2:  BRA    D56C
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D4F4:  MOVLW  2D
0D4F6:  MOVWF  x6D
0D4F8:  MOVFF  2C,86F
0D4FC:  MOVFF  2B,86E
0D500:  MOVLB  0
0D502:  RCALL  D01A
0D504:  MOVFF  01,86C
....................    if (macro_status != 'a') goto end_macro; 
0D508:  MOVLB  8
0D50A:  MOVF   x6C,W
0D50C:  SUBLW  61
0D50E:  BTFSS  FD8.2
0D510:  BRA    D56C
....................    macro_status = play_wms_macro_cmd('P',port); 
0D512:  MOVLW  50
0D514:  MOVWF  x6D
0D516:  MOVFF  86B,86F
0D51A:  MOVFF  86A,86E
0D51E:  MOVLB  0
0D520:  RCALL  D01A
0D522:  MOVFF  01,86C
....................    if (macro_status != 'a') goto end_macro;    
0D526:  MOVLB  8
0D528:  MOVF   x6C,W
0D52A:  SUBLW  61
0D52C:  BTFSS  FD8.2
0D52E:  BRA    D56C
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D530:  MOVLW  2B
0D532:  MOVWF  x6D
0D534:  MOVFF  2C,86F
0D538:  MOVFF  2B,86E
0D53C:  MOVLB  0
0D53E:  RCALL  D01A
0D540:  MOVFF  01,86C
....................    if (macro_status != 'a') goto end_macro; 
0D544:  MOVLB  8
0D546:  MOVF   x6C,W
0D548:  SUBLW  61
0D54A:  BTFSS  FD8.2
0D54C:  BRA    D56C
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D54E:  MOVLW  59
0D550:  MOVWF  x6D
0D552:  CLRF   x6F
0D554:  CLRF   x6E
0D556:  MOVLB  0
0D558:  RCALL  D01A
0D55A:  MOVFF  01,86C
....................    if (macro_status != 'a') goto end_macro; 
0D55E:  MOVLB  8
0D560:  MOVF   x6C,W
0D562:  SUBLW  61
0D564:  BTFSS  FD8.2
0D566:  BRA    D56C
....................    macro_status='f';  
0D568:  MOVLW  66
0D56A:  MOVWF  x6C
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D56C:  CLRF   x7E
0D56E:  MOVLB  0
0D570:  RCALL  D2AE
....................    
....................    switch(macro_status){ 
0D572:  MOVLW  61
0D574:  MOVLB  8
0D576:  SUBWF  x6C,W
0D578:  ADDLW  FA
0D57A:  BC    D64E
0D57C:  ADDLW  06
0D57E:  MOVLB  0
0D580:  GOTO   D652
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D584:  MOVF   1F,F
0D586:  BNZ   D58C
0D588:  MOVF   20,F
0D58A:  BZ    D5A8
0D58C:  MOVLW  16
0D58E:  MOVWF  FF6
0D590:  MOVLW  22
0D592:  MOVWF  FF7
0D594:  MOVLW  00
0D596:  MOVWF  FF8
0D598:  CLRF   1B
0D59A:  BTFSC  FF2.7
0D59C:  BSF    1B.7
0D59E:  BCF    FF2.7
0D5A0:  CALL   0E4E
0D5A4:  BTFSC  1B.7
0D5A6:  BSF    FF2.7
....................          break; 
0D5A8:  MOVLB  8
0D5AA:  BRA    D64E
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D5AC:  MOVLW  1E
0D5AE:  MOVWF  FF6
0D5B0:  MOVLW  22
0D5B2:  MOVWF  FF7
0D5B4:  MOVLW  00
0D5B6:  MOVWF  FF8
0D5B8:  CLRF   1B
0D5BA:  BTFSC  FF2.7
0D5BC:  BSF    1B.7
0D5BE:  BCF    FF2.7
0D5C0:  CALL   0E4E
0D5C4:  BTFSC  1B.7
0D5C6:  BSF    FF2.7
....................          break; 
0D5C8:  MOVLB  8
0D5CA:  BRA    D64E
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D5CC:  MOVLW  26
0D5CE:  MOVWF  FF6
0D5D0:  MOVLW  22
0D5D2:  MOVWF  FF7
0D5D4:  MOVLW  00
0D5D6:  MOVWF  FF8
0D5D8:  CLRF   1B
0D5DA:  BTFSC  FF2.7
0D5DC:  BSF    1B.7
0D5DE:  BCF    FF2.7
0D5E0:  CALL   0E4E
0D5E4:  BTFSC  1B.7
0D5E6:  BSF    FF2.7
....................          break; 
0D5E8:  MOVLB  8
0D5EA:  BRA    D64E
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D5EC:  MOVLW  2E
0D5EE:  MOVWF  FF6
0D5F0:  MOVLW  22
0D5F2:  MOVWF  FF7
0D5F4:  MOVLW  00
0D5F6:  MOVWF  FF8
0D5F8:  CLRF   1B
0D5FA:  BTFSC  FF2.7
0D5FC:  BSF    1B.7
0D5FE:  BCF    FF2.7
0D600:  CALL   0E4E
0D604:  BTFSC  1B.7
0D606:  BSF    FF2.7
....................          break; 
0D608:  MOVLB  8
0D60A:  BRA    D64E
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D60C:  MOVLW  36
0D60E:  MOVWF  FF6
0D610:  MOVLW  22
0D612:  MOVWF  FF7
0D614:  MOVLW  00
0D616:  MOVWF  FF8
0D618:  CLRF   1B
0D61A:  BTFSC  FF2.7
0D61C:  BSF    1B.7
0D61E:  BCF    FF2.7
0D620:  CALL   0E4E
0D624:  BTFSC  1B.7
0D626:  BSF    FF2.7
....................          break;    
0D628:  MOVLB  8
0D62A:  BRA    D64E
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D62C:  MOVLW  3E
0D62E:  MOVWF  FF6
0D630:  MOVLW  22
0D632:  MOVWF  FF7
0D634:  MOVLW  00
0D636:  MOVWF  FF8
0D638:  CLRF   1B
0D63A:  BTFSC  FF2.7
0D63C:  BSF    1B.7
0D63E:  BCF    FF2.7
0D640:  CALL   0E4E
0D644:  BTFSC  1B.7
0D646:  BSF    FF2.7
....................          break;           
0D648:  MOVLB  8
0D64A:  BRA    D64E
0D64C:  MOVLB  8
....................    } 
0D64E:  MOVLB  0
0D650:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
15FF2:  MOVLB  8
15FF4:  MOVF   x69,W
15FF6:  BTFSC  FD8.2
15FF8:  DECF   x6A,F
15FFA:  DECF   x69,F
....................    addr = macro_address[0] + (step*9); 
15FFC:  MOVFF  86A,9EE
16000:  MOVFF  869,9ED
16004:  MOVLB  9
16006:  CLRF   xF0
16008:  MOVLW  09
1600A:  MOVWF  xEF
1600C:  MOVLB  0
1600E:  CALL   5C32
16012:  MOVF   01,W
16014:  MOVLB  7
16016:  ADDWF  xD1,W
16018:  MOVLB  8
1601A:  MOVWF  x6B
1601C:  MOVF   02,W
1601E:  MOVLB  7
16020:  ADDWFC xD2,W
16022:  MOVLB  8
16024:  MOVWF  x6C
....................     
....................    init_ext_eeprom(); 
16026:  MOVLB  0
16028:  CALL   FFEE
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
1602C:  MOVFF  86C,8AD
16030:  MOVFF  86B,8AC
16034:  CALL   10254
16038:  MOVFF  01,86D
....................    ++addr; 
1603C:  MOVLB  8
1603E:  INCF   x6B,F
16040:  BTFSC  FD8.2
16042:  INCF   x6C,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
16044:  MOVFF  86C,8A4
16048:  MOVFF  86B,8A3
1604C:  MOVLB  0
1604E:  CALL   10368
16052:  MOVFF  02,871
16056:  MOVFF  01,870
....................    ++addr; 
1605A:  MOVLB  8
1605C:  INCF   x6B,F
1605E:  BTFSC  FD8.2
16060:  INCF   x6C,F
....................    ++addr; 
16062:  INCF   x6B,F
16064:  BTFSC  FD8.2
16066:  INCF   x6C,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
16068:  MOVFF  86C,8AD
1606C:  MOVFF  86B,8AC
16070:  MOVLB  0
16072:  CALL   10254
16076:  MOVFF  01,86E
....................    ++addr; 
1607A:  MOVLB  8
1607C:  INCF   x6B,F
1607E:  BTFSC  FD8.2
16080:  INCF   x6C,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
16082:  MOVFF  86C,8A4
16086:  MOVFF  86B,8A3
1608A:  MOVLB  0
1608C:  CALL   10368
16090:  MOVFF  02,873
16094:  MOVFF  01,872
....................    ++addr; 
16098:  MOVLB  8
1609A:  INCF   x6B,F
1609C:  BTFSC  FD8.2
1609E:  INCF   x6C,F
....................    ++addr; 
160A0:  INCF   x6B,F
160A2:  BTFSC  FD8.2
160A4:  INCF   x6C,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
160A6:  MOVFF  86C,8AD
160AA:  MOVFF  86B,8AC
160AE:  MOVLB  0
160B0:  CALL   10254
160B4:  MOVFF  01,86F
....................    ++addr; 
160B8:  MOVLB  8
160BA:  INCF   x6B,F
160BC:  BTFSC  FD8.2
160BE:  INCF   x6C,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
160C0:  MOVFF  86C,8A4
160C4:  MOVFF  86B,8A3
160C8:  MOVLB  0
160CA:  CALL   10368
160CE:  MOVFF  02,875
160D2:  MOVFF  01,874
....................    ++addr; 
160D6:  MOVLB  8
160D8:  INCF   x6B,F
160DA:  BTFSC  FD8.2
160DC:  INCF   x6C,F
....................    ++addr; 
160DE:  INCF   x6B,F
160E0:  BTFSC  FD8.2
160E2:  INCF   x6C,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
160E4:  MOVFF  86C,8AD
160E8:  MOVFF  86B,8AC
160EC:  MOVLB  0
160EE:  CALL   10254
160F2:  MOVFF  01,876
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
160F6:  MOVLB  8
160F8:  MOVF   x6D,W
160FA:  SUBLW  4A
160FC:  BTFSS  FD8.2
160FE:  BRA    161D4
16100:  MOVF   x6E,W
16102:  SUBLW  50
16104:  BNZ   161D4
16106:  MOVF   x6F,W
16108:  SUBLW  4D
1610A:  BNZ   161D4
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
1610C:  MOVF   x6D,W
1610E:  BTFSS  F9E.4
16110:  BRA    1610E
16112:  MOVWF  FAD
16114:  MOVLW  10
16116:  MOVWF  FE9
16118:  CLRF   1B
1611A:  BTFSC  FF2.7
1611C:  BSF    1B.7
1611E:  BCF    FF2.7
16120:  MOVFF  871,A1D
16124:  MOVFF  870,A1C
16128:  MOVLB  0
1612A:  CALL   11A6
1612E:  BTFSC  1B.7
16130:  BSF    FF2.7
16132:  MOVLW  2C
16134:  BTFSS  F9E.4
16136:  BRA    16134
16138:  MOVWF  FAD
1613A:  MOVLB  8
1613C:  MOVF   x6E,W
1613E:  BTFSS  F9E.4
16140:  BRA    1613E
16142:  MOVWF  FAD
16144:  MOVLW  10
16146:  MOVWF  FE9
16148:  CLRF   1B
1614A:  BTFSC  FF2.7
1614C:  BSF    1B.7
1614E:  BCF    FF2.7
16150:  MOVFF  873,A1D
16154:  MOVFF  872,A1C
16158:  MOVLB  0
1615A:  CALL   11A6
1615E:  BTFSC  1B.7
16160:  BSF    FF2.7
16162:  MOVLW  2C
16164:  BTFSS  F9E.4
16166:  BRA    16164
16168:  MOVWF  FAD
1616A:  MOVLB  8
1616C:  MOVF   x6F,W
1616E:  BTFSS  F9E.4
16170:  BRA    1616E
16172:  MOVWF  FAD
16174:  MOVLW  10
16176:  MOVWF  FE9
16178:  CLRF   1B
1617A:  BTFSC  FF2.7
1617C:  BSF    1B.7
1617E:  BCF    FF2.7
16180:  MOVFF  875,A1D
16184:  MOVFF  874,A1C
16188:  MOVLB  0
1618A:  CALL   11A6
1618E:  BTFSC  1B.7
16190:  BSF    FF2.7
16192:  MOVLW  0D
16194:  BTFSS  F9E.4
16196:  BRA    16194
16198:  MOVWF  FAD
1619A:  MOVLW  0A
1619C:  BTFSS  F9E.4
1619E:  BRA    1619C
161A0:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
161A2:  MOVFF  871,24
161A6:  MOVFF  870,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
161AA:  MOVLB  8
161AC:  MOVF   x74,F
161AE:  BNZ   161B4
161B0:  MOVF   x75,F
161B2:  BZ    161D2
161B4:  MOVF   x75,F
161B6:  BNZ   161D2
161B8:  MOVF   x74,W
161BA:  SUBLW  10
161BC:  BNC   161D2
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
161BE:  MOVFF  874,878
161C2:  MOVFF  873,87A
161C6:  MOVFF  872,879
161CA:  MOVLB  0
161CC:  CALL   14F50
161D0:  MOVLB  8
....................       } 
....................    } 
161D2:  BRA    161E0
....................    else { 
....................       cmd_err(); 
161D4:  MOVLB  0
161D6:  CALL   BC4A
....................       macro_end = 59; 
161DA:  MOVLW  3B
161DC:  MOVLB  8
161DE:  MOVWF  x76
....................    } 
....................     
....................    return (macro_end); 
161E0:  MOVFF  876,01
161E4:  MOVLB  0
161E6:  GOTO   162D0 (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
163D2:  MOVLB  8
163D4:  MOVF   x6D,W
163D6:  BTFSC  FD8.2
163D8:  DECF   x6E,F
163DA:  DECF   x6D,F
....................    addr = macro_address[0] + (step*6); 
163DC:  MOVFF  86E,9EE
163E0:  MOVFF  86D,9ED
163E4:  MOVLB  9
163E6:  CLRF   xF0
163E8:  MOVLW  06
163EA:  MOVWF  xEF
163EC:  MOVLB  0
163EE:  CALL   5C32
163F2:  MOVF   01,W
163F4:  MOVLB  7
163F6:  ADDWF  xD1,W
163F8:  MOVLB  8
163FA:  MOVWF  x6F
163FC:  MOVF   02,W
163FE:  MOVLB  7
16400:  ADDWFC xD2,W
16402:  MOVLB  8
16404:  MOVWF  x70
....................     
....................    init_ext_eeprom(); 
16406:  MOVLB  0
16408:  CALL   FFEE
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
1640C:  MOVFF  870,8AD
16410:  MOVFF  86F,8AC
16414:  CALL   10254
16418:  MOVFF  01,871
....................    ++addr; 
1641C:  MOVLB  8
1641E:  INCF   x6F,F
16420:  BTFSC  FD8.2
16422:  INCF   x70,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
16424:  MOVFF  870,8A4
16428:  MOVFF  86F,8A3
1642C:  MOVLB  0
1642E:  CALL   10368
16432:  MOVFF  02,874
16436:  MOVFF  01,873
....................    ++addr; 
1643A:  MOVLB  8
1643C:  INCF   x6F,F
1643E:  BTFSC  FD8.2
16440:  INCF   x70,F
....................    ++addr; 
16442:  INCF   x6F,F
16444:  BTFSC  FD8.2
16446:  INCF   x70,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
16448:  MOVFF  870,8AD
1644C:  MOVFF  86F,8AC
16450:  MOVLB  0
16452:  CALL   10254
16456:  MOVFF  01,872
....................    ++addr; 
1645A:  MOVLB  8
1645C:  INCF   x6F,F
1645E:  BTFSC  FD8.2
16460:  INCF   x70,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
16462:  MOVFF  870,8A4
16466:  MOVFF  86F,8A3
1646A:  MOVLB  0
1646C:  CALL   10368
16470:  MOVFF  02,876
16474:  MOVFF  01,875
....................    ++addr; 
16478:  MOVLB  8
1647A:  INCF   x6F,F
1647C:  BTFSC  FD8.2
1647E:  INCF   x70,F
....................    ++addr; 
16480:  INCF   x6F,F
16482:  BTFSC  FD8.2
16484:  INCF   x70,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16486:  MOVFF  870,8AD
1648A:  MOVFF  86F,8AC
1648E:  MOVLB  0
16490:  CALL   10254
16494:  MOVFF  01,877
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
16498:  MOVLB  8
1649A:  MOVF   x71,W
1649C:  SUBLW  50
1649E:  BNZ   16542
164A0:  MOVF   x72,W
164A2:  SUBLW  4D
164A4:  BNZ   16542
....................        
....................       RTC_read(); 
164A6:  MOVLB  0
164A8:  CALL   32E0
....................       RTC_display(); 
164AC:  CALL   DEFA
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
164B0:  MOVLB  8
164B2:  MOVF   x71,W
164B4:  BTFSS  F9E.4
164B6:  BRA    164B4
164B8:  MOVWF  FAD
164BA:  MOVLW  10
164BC:  MOVWF  FE9
164BE:  CLRF   1B
164C0:  BTFSC  FF2.7
164C2:  BSF    1B.7
164C4:  BCF    FF2.7
164C6:  MOVFF  874,A1D
164CA:  MOVFF  873,A1C
164CE:  MOVLB  0
164D0:  CALL   11A6
164D4:  BTFSC  1B.7
164D6:  BSF    FF2.7
164D8:  MOVLW  2C
164DA:  BTFSS  F9E.4
164DC:  BRA    164DA
164DE:  MOVWF  FAD
164E0:  MOVLB  8
164E2:  MOVF   x72,W
164E4:  BTFSS  F9E.4
164E6:  BRA    164E4
164E8:  MOVWF  FAD
164EA:  MOVLW  10
164EC:  MOVWF  FE9
164EE:  CLRF   1B
164F0:  BTFSC  FF2.7
164F2:  BSF    1B.7
164F4:  BCF    FF2.7
164F6:  MOVFF  876,A1D
164FA:  MOVFF  875,A1C
164FE:  MOVLB  0
16500:  CALL   11A6
16504:  BTFSC  1B.7
16506:  BSF    FF2.7
16508:  MOVLW  0D
1650A:  BTFSS  F9E.4
1650C:  BRA    1650A
1650E:  MOVWF  FAD
16510:  MOVLW  0A
16512:  BTFSS  F9E.4
16514:  BRA    16512
16516:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
16518:  MOVLB  8
1651A:  MOVF   x75,F
1651C:  BNZ   16522
1651E:  MOVF   x76,F
16520:  BZ    16540
16522:  MOVF   x76,F
16524:  BNZ   16540
16526:  MOVF   x75,W
16528:  SUBLW  10
1652A:  BNC   16540
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
1652C:  MOVFF  875,878
16530:  MOVFF  874,87A
16534:  MOVFF  873,879
16538:  MOVLB  0
1653A:  CALL   14F50
1653E:  MOVLB  8
....................       } 
....................    } 
16540:  BRA    1654E
....................    else { 
....................       cmd_err(); 
16542:  MOVLB  0
16544:  CALL   BC4A
....................       macro_end = 59; 
16548:  MOVLW  3B
1654A:  MOVLB  8
1654C:  MOVWF  x77
....................    } 
....................     
....................    return (macro_end); 
1654E:  MOVFF  877,01
16552:  MOVLB  0
16554:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
15DD0:  MOVF   24,W
15DD2:  SUBWF  36,W
15DD4:  BTFSS  FD8.0
15DD6:  BRA    15FDE
15DD8:  BNZ   15DE2
15DDA:  MOVF   23,W
15DDC:  SUBWF  35,W
15DDE:  BTFSS  FD8.0
15DE0:  BRA    15FDE
15DE2:  MOVF   33,F
15DE4:  BTFSS  FD8.2
15DE6:  BRA    15FDE
15DE8:  MOVF   34,F
15DEA:  BTFSS  FD8.2
15DEC:  BRA    15FDE
....................       { 
....................          nv_elapsed = 0; 
15DEE:  CLRF   36
15DF0:  CLRF   35
....................  
....................          init_hardware(); 
15DF2:  CALL   28D6
....................          sd_status = init_sdcard(); 
15DF6:  CALL   4FCE
15DFA:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
15DFE:  MOVLB  2
15E00:  MOVF   xDC,F
15E02:  BZ    15E0C
15E04:  MOVLB  0
15E06:  CALL   5014
15E0A:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
15E0C:  MOVLW  01
15E0E:  MOVWF  1E
15E10:  MOVLW  A7
15E12:  MOVWF  1D
15E14:  MOVLW  46
15E16:  MOVWF  FF6
15E18:  MOVLW  22
15E1A:  MOVWF  FF7
15E1C:  MOVLW  00
15E1E:  MOVWF  FF8
15E20:  MOVLW  14
15E22:  MOVLB  8
15E24:  MOVWF  xCC
15E26:  MOVLB  0
15E28:  CALL   AA28
15E2C:  MOVLW  10
15E2E:  MOVWF  FE9
15E30:  MOVFF  22,8D8
15E34:  MOVFF  21,8D7
15E38:  CALL   AA5A
15E3C:  MOVLW  5D
15E3E:  MOVWF  FF6
15E40:  MOVLW  22
15E42:  MOVWF  FF7
15E44:  MOVLW  00
15E46:  MOVWF  FF8
15E48:  MOVLW  09
15E4A:  MOVLB  8
15E4C:  MOVWF  xCC
15E4E:  MOVLB  0
15E50:  CALL   AA28
....................          record_event();          
15E54:  CALL   8436
....................              
....................          macro_cmd = master_macro_eco(); 
15E58:  RCALL  15B1C
15E5A:  MOVFF  01,868
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
15E5E:  MOVLW  16
15E60:  MOVLB  8
15E62:  MOVWF  xCF
15E64:  MOVFF  22,8D1
15E68:  MOVFF  21,8D0
15E6C:  MOVLB  0
15E6E:  CALL   4F68
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
15E72:  MOVLW  3A
15E74:  MOVLB  8
15E76:  MOVWF  xCF
15E78:  MOVFF  38,8D1
15E7C:  MOVFF  37,8D0
15E80:  MOVLB  0
15E82:  CALL   4F68
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
15E86:  DECFSZ 50,W
15E88:  BRA    15EAC
....................          { 
....................             disable_interrupts (INT_EXT); 
15E8A:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
15E8C:  CLRF   32
15E8E:  MOVLW  01
15E90:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
15E92:  MOVLW  02
15E94:  MOVLB  8
15E96:  MOVWF  x6A
15E98:  MOVFF  31,86B
15E9C:  MOVLB  0
15E9E:  CALL   33AE
....................             busy_clear(); 
15EA2:  CALL   ADD0
....................             return (user_quit); 
15EA6:  MOVFF  50,01
15EAA:  BRA    15FEE
....................          } 
....................  
....................          motor_sleep_rdy(); 
15EAC:  CALL   2934
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
15EB0:  MOVLW  01
15EB2:  MOVWF  1E
15EB4:  MOVLW  A7
15EB6:  MOVWF  1D
15EB8:  MOVLW  68
15EBA:  MOVWF  FF6
15EBC:  MOVLW  22
15EBE:  MOVWF  FF7
15EC0:  MOVLW  00
15EC2:  MOVWF  FF8
15EC4:  MOVLW  14
15EC6:  MOVLB  8
15EC8:  MOVWF  xCC
15ECA:  MOVLB  0
15ECC:  CALL   AA28
15ED0:  MOVLW  10
15ED2:  MOVWF  FE9
15ED4:  MOVFF  22,8D8
15ED8:  MOVFF  21,8D7
15EDC:  CALL   AA5A
15EE0:  MOVLW  7F
15EE2:  MOVWF  FF6
15EE4:  MOVLW  22
15EE6:  MOVWF  FF7
15EE8:  MOVLW  00
15EEA:  MOVWF  FF8
15EEC:  MOVLW  0C
15EEE:  MOVLB  8
15EF0:  MOVWF  xCC
15EF2:  MOVLB  0
15EF4:  CALL   AA28
....................          record_event();  
15EF8:  CALL   8436
....................           
....................          if (macro_cmd == 'e') 
15EFC:  MOVLB  8
15EFE:  MOVF   x68,W
15F00:  SUBLW  65
15F02:  BNZ   15F56
....................          { 
....................             disable_interrupts (INT_EXT); 
15F04:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
15F06:  MOVLW  01
15F08:  MOVWF  1E
15F0A:  MOVLW  A7
15F0C:  MOVWF  1D
15F0E:  MOVLW  8C
15F10:  MOVWF  FF6
15F12:  MOVLW  22
15F14:  MOVWF  FF7
15F16:  MOVLW  00
15F18:  MOVWF  FF8
15F1A:  MOVLW  14
15F1C:  MOVWF  xCC
15F1E:  MOVLB  0
15F20:  CALL   AA28
15F24:  MOVLW  10
15F26:  MOVWF  FE9
15F28:  MOVFF  22,8D8
15F2C:  MOVFF  21,8D7
15F30:  CALL   AA5A
15F34:  MOVLW  A3
15F36:  MOVWF  FF6
15F38:  MOVLW  22
15F3A:  MOVWF  FF7
15F3C:  MOVLW  00
15F3E:  MOVWF  FF8
15F40:  MOVLW  09
15F42:  MOVLB  8
15F44:  MOVWF  xCC
15F46:  MOVLB  0
15F48:  CALL   AA28
....................             record_event();  
15F4C:  CALL   8436
....................             cmd_err(); 
15F50:  CALL   BC4A
15F54:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
15F56:  MOVF   28,W
15F58:  SUBWF  22,W
15F5A:  BNC   15FE0
15F5C:  BNZ   15F64
15F5E:  MOVF   27,W
15F60:  SUBWF  21,W
15F62:  BNC   15FE0
....................          { 
....................             disable_interrupts (INT_EXT); 
15F64:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
15F66:  MOVLW  01
15F68:  MOVWF  1E
15F6A:  MOVLW  A7
15F6C:  MOVWF  1D
15F6E:  MOVLW  AE
15F70:  MOVWF  FF6
15F72:  MOVLW  22
15F74:  MOVWF  FF7
15F76:  MOVLW  00
15F78:  MOVWF  FF8
15F7A:  MOVLW  14
15F7C:  MOVWF  xCC
15F7E:  MOVLB  0
15F80:  CALL   AA28
15F84:  MOVLW  10
15F86:  MOVWF  FE9
15F88:  MOVFF  22,8D8
15F8C:  MOVFF  21,8D7
15F90:  CALL   AA5A
15F94:  MOVLW  C5
15F96:  MOVWF  FF6
15F98:  MOVLW  22
15F9A:  MOVWF  FF7
15F9C:  MOVLW  00
15F9E:  MOVWF  FF8
15FA0:  MOVLW  0F
15FA2:  MOVLB  8
15FA4:  MOVWF  xCC
15FA6:  MOVLB  0
15FA8:  CALL   AA28
....................             record_event();   
15FAC:  CALL   8436
....................             msg_max(); 
15FB0:  RCALL  15DB2
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
15FB2:  CLRF   34
15FB4:  MOVLW  01
15FB6:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
15FB8:  MOVLW  28
15FBA:  MOVLB  8
15FBC:  MOVWF  x6A
15FBE:  MOVFF  33,86B
15FC2:  MOVLB  0
15FC4:  CALL   33AE
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15FC8:  CLRF   32
15FCA:  MOVLW  01
15FCC:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
15FCE:  MOVLW  02
15FD0:  MOVLB  8
15FD2:  MOVWF  x6A
15FD4:  MOVFF  31,86B
15FD8:  MOVLB  0
15FDA:  CALL   33AE
15FDE:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
15FE0:  MOVLB  0
15FE2:  RCALL  15A56
15FE4:  BRA    15DD0
....................    } 
....................     
....................    busy_clear(); 
15FE6:  CALL   ADD0
....................    return (user_quit); 
15FEA:  MOVFF  50,01
15FEE:  GOTO   16912 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
161EA:  MOVF   24,W
161EC:  SUBWF  36,W
161EE:  BTFSS  FD8.0
161F0:  BRA    163C0
161F2:  BNZ   161FC
161F4:  MOVF   23,W
161F6:  SUBWF  35,W
161F8:  BTFSS  FD8.0
161FA:  BRA    163C0
....................       { 
....................          nv_elapsed = 0; 
161FC:  CLRF   36
161FE:  CLRF   35
....................  
....................          init_hardware(); 
16200:  CALL   28D6
....................          sd_status = init_sdcard(); 
16204:  CALL   4FCE
16208:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
1620C:  MOVLB  2
1620E:  MOVF   xDC,F
16210:  BZ    1621A
16212:  MOVLB  0
16214:  CALL   5014
16218:  MOVLB  2
....................  
....................          ++nv_sample; 
1621A:  INCF   21,F
1621C:  BTFSC  FD8.2
1621E:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
16220:  MOVLW  40
16222:  BTFSS  F9E.4
16224:  BRA    16222
16226:  MOVWF  FAD
16228:  MOVLW  53
1622A:  BTFSS  F9E.4
1622C:  BRA    1622A
1622E:  MOVWF  FAD
16230:  MOVLW  09
16232:  MOVWF  FE9
16234:  CLRF   1B
16236:  BTFSC  FF2.7
16238:  BSF    1B.7
1623A:  BCF    FF2.7
1623C:  MOVFF  22,A1D
16240:  MOVFF  21,A1C
16244:  MOVLB  0
16246:  CALL   11A6
1624A:  BTFSC  1B.7
1624C:  BSF    FF2.7
1624E:  MOVLW  0D
16250:  BTFSS  F9E.4
16252:  BRA    16250
16254:  MOVWF  FAD
16256:  MOVLW  0A
16258:  BTFSS  F9E.4
1625A:  BRA    16258
1625C:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
1625E:  MOVLW  01
16260:  MOVWF  1E
16262:  MOVLW  A7
16264:  MOVWF  1D
16266:  MOVLW  D6
16268:  MOVWF  FF6
1626A:  MOVLW  22
1626C:  MOVWF  FF7
1626E:  MOVLW  00
16270:  MOVWF  FF8
16272:  MOVLW  14
16274:  MOVLB  8
16276:  MOVWF  xCC
16278:  MOVLB  0
1627A:  CALL   AA28
1627E:  MOVLW  10
16280:  MOVWF  FE9
16282:  MOVFF  22,8D8
16286:  MOVFF  21,8D7
1628A:  CALL   AA5A
1628E:  MOVLW  ED
16290:  MOVWF  FF6
16292:  MOVLW  22
16294:  MOVWF  FF7
16296:  MOVLW  00
16298:  MOVWF  FF8
1629A:  MOVLW  09
1629C:  MOVLB  8
1629E:  MOVWF  xCC
162A0:  MOVLB  0
162A2:  CALL   AA28
....................          record_event();   
162A6:  CALL   8436
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
162AA:  MOVLW  16
162AC:  MOVLB  8
162AE:  MOVWF  xCF
162B0:  MOVFF  22,8D1
162B4:  MOVFF  21,8D0
162B8:  MOVLB  0
162BA:  CALL   4F68
....................  
....................          if (nv_macro_mode==TRUE) 
162BE:  DECFSZ 29,W
162C0:  BRA    162D6
162C2:  MOVF   2A,F
162C4:  BNZ   162D6
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
162C6:  MOVFF  22,86A
162CA:  MOVFF  21,869
162CE:  BRA    15FF2
162D0:  MOVFF  01,868
....................          } 
162D4:  BRA    1633E
....................          else 
....................          { 
....................             time_stamp(); 
162D6:  CALL   53AE
....................             play_wms_hard_macro(nv_port); 
162DA:  MOVFF  2E,86B
162DE:  MOVFF  2D,86A
162E2:  CALL   D470
....................             ++nv_port; 
162E6:  INCF   2D,F
162E8:  BTFSC  FD8.2
162EA:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
162EC:  MOVF   2E,F
162EE:  BNZ   162F6
162F0:  MOVF   2D,W
162F2:  SUBLW  01
162F4:  BC    16308
162F6:  MOVF   2E,F
162F8:  BNZ   16308
162FA:  MOVF   2D,W
162FC:  SUBLW  30
162FE:  BNC   16308
16300:  DECFSZ 2F,W
16302:  BRA    16308
16304:  MOVF   30,F
16306:  BZ    16326
16308:  MOVF   2E,F
1630A:  BNZ   16312
1630C:  MOVF   2D,W
1630E:  SUBLW  01
16310:  BC    1633C
16312:  MOVF   2E,F
16314:  BNZ   1633C
16316:  MOVF   2D,W
16318:  SUBLW  32
1631A:  BNC   1633C
1631C:  MOVF   2F,W
1631E:  SUBLW  03
16320:  BNZ   1633C
16322:  MOVF   30,F
16324:  BNZ   1633C
....................             { 
....................                write16(ADDR_PORT, nv_port);             
16326:  MOVLW  24
16328:  MOVLB  8
1632A:  MOVWF  xCF
1632C:  MOVFF  2E,8D1
16330:  MOVFF  2D,8D0
16334:  MOVLB  0
16336:  CALL   4F68
....................             } 
1633A:  BRA    1633E
....................             else disable_interrupts (INT_EXT); 
1633C:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
1633E:  DECFSZ 50,W
16340:  BRA    16364
....................          { 
....................             disable_interrupts (INT_EXT); 
16342:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
16344:  CLRF   32
16346:  MOVLW  01
16348:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
1634A:  MOVLW  02
1634C:  MOVLB  8
1634E:  MOVWF  x6A
16350:  MOVFF  31,86B
16354:  MOVLB  0
16356:  CALL   33AE
....................             busy_clear(); 
1635A:  CALL   ADD0
....................             return (user_quit); 
1635E:  MOVFF  50,01
16362:  BRA    163CE
....................          } 
....................           
....................          motor_sleep_rdy(); 
16364:  CALL   2934
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16368:  MOVLW  01
1636A:  MOVWF  1E
1636C:  MOVLW  A7
1636E:  MOVWF  1D
16370:  MOVLW  F8
16372:  MOVWF  FF6
16374:  MOVLW  22
16376:  MOVWF  FF7
16378:  MOVLW  00
1637A:  MOVWF  FF8
1637C:  MOVLW  14
1637E:  MOVLB  8
16380:  MOVWF  xCC
16382:  MOVLB  0
16384:  CALL   AA28
16388:  MOVLW  10
1638A:  MOVWF  FE9
1638C:  MOVFF  22,8D8
16390:  MOVFF  21,8D7
16394:  CALL   AA5A
16398:  MOVLW  0F
1639A:  MOVWF  FF6
1639C:  MOVLW  23
1639E:  MOVWF  FF7
163A0:  MOVLW  00
163A2:  MOVWF  FF8
163A4:  MOVLW  0C
163A6:  MOVLB  8
163A8:  MOVWF  xCC
163AA:  MOVLB  0
163AC:  CALL   AA28
....................          record_event();  
163B0:  CALL   8436
....................           
....................          if (macro_end == ';') 
163B4:  MOVLB  8
163B6:  MOVF   x68,W
163B8:  SUBLW  3B
163BA:  BNZ   163BE
....................          { 
....................             disable_interrupts (INT_EXT); 
163BC:  BCF    FF2.4
163BE:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
163C0:  CALL   15A56
163C4:  BRA    161EA
....................    } 
....................    busy_clear(); 
163C6:  CALL   ADD0
....................    return (user_quit); 
163CA:  MOVFF  50,01
163CE:  GOTO   1691A (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
16556:  MOVF   24,W
16558:  SUBWF  36,W
1655A:  BTFSS  FD8.0
1655C:  BRA    16716
1655E:  BNZ   16568
16560:  MOVF   23,W
16562:  SUBWF  35,W
16564:  BTFSS  FD8.0
16566:  BRA    16716
....................       { 
....................          nv_elapsed = 0; 
16568:  CLRF   36
1656A:  CLRF   35
....................  
....................          init_hardware(); 
1656C:  CALL   28D6
....................          sd_status = init_sdcard(); 
16570:  CALL   4FCE
16574:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
16578:  MOVLB  2
1657A:  MOVF   xDC,F
1657C:  BZ    16586
1657E:  MOVLB  0
16580:  CALL   5014
16584:  MOVLB  2
....................  
....................          ++nv_sample; 
16586:  INCF   21,F
16588:  BTFSC  FD8.2
1658A:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
1658C:  MOVLW  40
1658E:  BTFSS  F9E.4
16590:  BRA    1658E
16592:  MOVWF  FAD
16594:  MOVLW  53
16596:  BTFSS  F9E.4
16598:  BRA    16596
1659A:  MOVWF  FAD
1659C:  MOVLW  09
1659E:  MOVWF  FE9
165A0:  CLRF   1B
165A2:  BTFSC  FF2.7
165A4:  BSF    1B.7
165A6:  BCF    FF2.7
165A8:  MOVFF  22,A1D
165AC:  MOVFF  21,A1C
165B0:  MOVLB  0
165B2:  CALL   11A6
165B6:  BTFSC  1B.7
165B8:  BSF    FF2.7
165BA:  MOVLW  0D
165BC:  BTFSS  F9E.4
165BE:  BRA    165BC
165C0:  MOVWF  FAD
165C2:  MOVLW  0A
165C4:  BTFSS  F9E.4
165C6:  BRA    165C4
165C8:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
165CA:  MOVLW  01
165CC:  MOVWF  1E
165CE:  MOVLW  A7
165D0:  MOVWF  1D
165D2:  MOVLW  1C
165D4:  MOVWF  FF6
165D6:  MOVLW  23
165D8:  MOVWF  FF7
165DA:  MOVLW  00
165DC:  MOVWF  FF8
165DE:  MOVLW  14
165E0:  MOVLB  8
165E2:  MOVWF  xCC
165E4:  MOVLB  0
165E6:  CALL   AA28
165EA:  MOVLW  10
165EC:  MOVWF  FE9
165EE:  MOVFF  22,8D8
165F2:  MOVFF  21,8D7
165F6:  CALL   AA5A
165FA:  MOVLW  33
165FC:  MOVWF  FF6
165FE:  MOVLW  23
16600:  MOVWF  FF7
16602:  MOVLW  00
16604:  MOVWF  FF8
16606:  MOVLW  09
16608:  MOVLB  8
1660A:  MOVWF  xCC
1660C:  MOVLB  0
1660E:  CALL   AA28
....................          record_event();   
16612:  CALL   8436
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16616:  MOVLW  16
16618:  MOVLB  8
1661A:  MOVWF  xCF
1661C:  MOVFF  22,8D1
16620:  MOVFF  21,8D0
16624:  MOVLB  0
16626:  CALL   4F68
....................  
....................          macro_end = master_macro_aws(nv_sample); 
1662A:  MOVFF  22,86E
1662E:  MOVFF  21,86D
16632:  RCALL  163D2
16634:  MOVFF  01,868
....................           
....................          if (user_quit == TRUE) 
16638:  DECFSZ 50,W
1663A:  BRA    1665E
....................          { 
....................             disable_interrupts (INT_EXT); 
1663C:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
1663E:  CLRF   32
16640:  MOVLW  01
16642:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16644:  MOVLW  02
16646:  MOVLB  8
16648:  MOVWF  x6A
1664A:  MOVFF  31,86B
1664E:  MOVLB  0
16650:  CALL   33AE
....................             busy_clear(); 
16654:  CALL   ADD0
....................             return (user_quit); 
16658:  MOVFF  50,01
1665C:  BRA    16728
....................          } 
....................           
....................          motor_sleep_rdy(); 
1665E:  CALL   2934
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16662:  MOVLW  01
16664:  MOVWF  1E
16666:  MOVLW  A7
16668:  MOVWF  1D
1666A:  MOVLW  3E
1666C:  MOVWF  FF6
1666E:  MOVLW  23
16670:  MOVWF  FF7
16672:  MOVLW  00
16674:  MOVWF  FF8
16676:  MOVLW  14
16678:  MOVLB  8
1667A:  MOVWF  xCC
1667C:  MOVLB  0
1667E:  CALL   AA28
16682:  MOVLW  10
16684:  MOVWF  FE9
16686:  MOVFF  22,8D8
1668A:  MOVFF  21,8D7
1668E:  CALL   AA5A
16692:  MOVLW  55
16694:  MOVWF  FF6
16696:  MOVLW  23
16698:  MOVWF  FF7
1669A:  MOVLW  00
1669C:  MOVWF  FF8
1669E:  MOVLW  0C
166A0:  MOVLB  8
166A2:  MOVWF  xCC
166A4:  MOVLB  0
166A6:  CALL   AA28
....................          record_event();  
166AA:  CALL   8436
....................           
....................          if (macro_end == ';') 
166AE:  MOVLB  8
166B0:  MOVF   x68,W
166B2:  SUBLW  3B
166B4:  BNZ   166B8
....................          { 
....................             disable_interrupts (INT_EXT); 
166B6:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
166B8:  MOVF   28,W
166BA:  SUBWF  22,W
166BC:  BNC   16718
166BE:  BNZ   166C6
166C0:  MOVF   27,W
166C2:  SUBWF  21,W
166C4:  BNC   16718
....................          { 
....................             disable_interrupts (INT_EXT); 
166C6:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
166C8:  MOVLW  01
166CA:  MOVWF  1E
166CC:  MOVLW  A7
166CE:  MOVWF  1D
166D0:  MOVLW  62
166D2:  MOVWF  FF6
166D4:  MOVLW  23
166D6:  MOVWF  FF7
166D8:  MOVLW  00
166DA:  MOVWF  FF8
166DC:  MOVLW  14
166DE:  MOVWF  xCC
166E0:  MOVLB  0
166E2:  CALL   AA28
166E6:  MOVLW  10
166E8:  MOVWF  FE9
166EA:  MOVFF  22,8D8
166EE:  MOVFF  21,8D7
166F2:  CALL   AA5A
166F6:  MOVLW  79
166F8:  MOVWF  FF6
166FA:  MOVLW  23
166FC:  MOVWF  FF7
166FE:  MOVLW  00
16700:  MOVWF  FF8
16702:  MOVLW  0F
16704:  MOVLB  8
16706:  MOVWF  xCC
16708:  MOVLB  0
1670A:  CALL   AA28
....................             record_event();   
1670E:  CALL   8436
....................             msg_max(); 
16712:  CALL   15DB2
16716:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
16718:  MOVLB  0
1671A:  CALL   15A56
1671E:  BRA    16556
....................    } 
....................    busy_clear(); 
16720:  CALL   ADD0
....................    return (user_quit); 
16724:  MOVFF  50,01
16728:  GOTO   16922 (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
1672C:  CALL   295C
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
16730:  MOVLW  01
16732:  MOVWF  1E
16734:  MOVLW  A7
16736:  MOVWF  1D
16738:  MOVLW  8A
1673A:  MOVWF  FF6
1673C:  MOVLW  23
1673E:  MOVWF  FF7
16740:  MOVLW  00
16742:  MOVWF  FF8
16744:  CALL   5052
....................    record_event(); 
16748:  CALL   8436
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
1674C:  MOVLW  01
1674E:  MOVWF  1E
16750:  MOVLW  A7
16752:  MOVWF  1D
16754:  MOVLW  A4
16756:  MOVWF  FF6
16758:  MOVLW  23
1675A:  MOVWF  FF7
1675C:  MOVLW  00
1675E:  MOVWF  FF8
16760:  MOVLW  0C
16762:  MOVLB  8
16764:  MOVWF  xCC
16766:  MOVLB  0
16768:  CALL   AA28
1676C:  MOVLW  10
1676E:  MOVWF  FE9
16770:  MOVFF  26,8D8
16774:  MOVFF  25,8D7
16778:  CALL   AA5A
1677C:  MOVLW  B3
1677E:  MOVWF  FF6
16780:  MOVLW  23
16782:  MOVWF  FF7
16784:  MOVLW  00
16786:  MOVWF  FF8
16788:  MOVLW  06
1678A:  MOVLB  8
1678C:  MOVWF  xCC
1678E:  MOVLB  0
16790:  CALL   AA28
16794:  MOVLW  10
16796:  MOVWF  FE9
16798:  MOVFF  24,8D8
1679C:  MOVFF  23,8D7
167A0:  CALL   AA5A
167A4:  MOVLW  BC
167A6:  MOVWF  FF6
167A8:  MOVLW  23
167AA:  MOVWF  FF7
167AC:  MOVLW  00
167AE:  MOVWF  FF8
167B0:  MOVLW  06
167B2:  MOVLB  8
167B4:  MOVWF  xCC
167B6:  MOVLB  0
167B8:  CALL   AA28
167BC:  MOVLW  10
167BE:  MOVWF  FE9
167C0:  MOVFF  28,8D8
167C4:  MOVFF  27,8D7
167C8:  CALL   AA5A
167CC:  MOVLW  C5
167CE:  MOVWF  FF6
167D0:  MOVLW  23
167D2:  MOVWF  FF7
167D4:  MOVLW  00
167D6:  MOVWF  FF8
167D8:  MOVLW  03
167DA:  MOVLB  8
167DC:  MOVWF  xCC
167DE:  MOVLB  0
167E0:  CALL   AA28
....................    record_event(); 
167E4:  CALL   8436
....................     
....................    user_quit = FALSE; 
167E8:  CLRF   50
....................     
....................    nv_cmd_mode = FALSE; 
167EA:  CLRF   32
167EC:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
167EE:  MOVLW  02
167F0:  MOVLB  8
167F2:  MOVWF  x6A
167F4:  MOVFF  31,86B
167F8:  MOVLB  0
167FA:  CALL   33AE
....................  
....................    RTC_set_AFE(); 
167FE:  GOTO   152B6
....................    // check if start is earlier than now 
....................    RTC_late(); 
16802:  CALL   1530E
....................    // show clock 
....................    RTC_display(); 
16806:  CALL   DEFA
....................    // show alarm 
....................    RTC_display_alarm(); 
1680A:  CALL   E15A
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
1680E:  CALL   157C8
....................  
....................    if (alarm_passed == FALSE){ 
16812:  BTFSC  4D.3
16814:  BRA    16816
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
16816:  MOVLW  00
16818:  BTFSC  4D.3
1681A:  MOVLW  01
1681C:  MOVLB  8
1681E:  MOVWF  x68
16820:  MOVLW  01
16822:  MOVWF  1E
16824:  MOVLW  A7
16826:  MOVWF  1D
16828:  MOVLW  CA
1682A:  MOVWF  FF6
1682C:  MOVLW  23
1682E:  MOVWF  FF7
16830:  MOVLW  00
16832:  MOVWF  FF8
16834:  MOVLW  14
16836:  MOVWF  xCC
16838:  MOVLB  0
1683A:  CALL   AA28
1683E:  MOVLW  10
16840:  MOVWF  FE9
16842:  MOVFF  22,8D8
16846:  MOVFF  21,8D7
1684A:  CALL   AA5A
1684E:  MOVLW  E1
16850:  MOVWF  FF6
16852:  MOVLW  23
16854:  MOVWF  FF7
16856:  MOVLW  00
16858:  MOVWF  FF8
1685A:  MOVLW  08
1685C:  MOVLB  8
1685E:  MOVWF  xCC
16860:  MOVLB  0
16862:  CALL   AA28
16866:  MOVFF  868,8CE
1686A:  MOVLW  1B
1686C:  MOVLB  8
1686E:  MOVWF  xCF
16870:  MOVLB  0
16872:  CALL   5214
16876:  MOVLW  EB
16878:  MOVWF  FF6
1687A:  MOVLW  23
1687C:  MOVWF  FF7
1687E:  MOVLW  00
16880:  MOVWF  FF8
16882:  MOVLW  03
16884:  MOVLB  8
16886:  MOVWF  xCC
16888:  MOVLB  0
1688A:  CALL   AA28
....................    record_event();  
1688E:  CALL   8436
....................  
....................    while (TRUE == RTC_read_flags_running) 
16892:  BTFSS  4D.2
16894:  BRA    16898
....................    { 
....................       ; 
16896:  BRA    16892
....................    } 
....................    RTC_read_flags_running = TRUE; 
16898:  BSF    4D.2
1689A:  CLRF   1B
1689C:  BTFSC  FF2.7
1689E:  BSF    1B.7
168A0:  BCF    FF2.7
....................    RTC_read_flags(); 
168A2:  CALL   0DD8
168A6:  BTFSC  1B.7
168A8:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
168AA:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
168AC:  CALL   2934
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
168B0:  BTFSC  4D.3
168B2:  BRA    168D4
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
168B4:  MOVLW  01
168B6:  MOVWF  1E
168B8:  MOVLW  A7
168BA:  MOVWF  1D
168BC:  MOVLW  F0
168BE:  MOVWF  FF6
168C0:  MOVLW  23
168C2:  MOVWF  FF7
168C4:  MOVLW  00
168C6:  MOVWF  FF8
168C8:  CALL   5052
....................       record_event(); 
168CC:  CALL   8436
....................       go_to_sleep(); 
168D0:  CALL   15A56
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
168D4:  GOTO   15A6C
....................    nv_elapsed = nv_interval; 
168D8:  MOVFF  24,36
168DC:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
168E0:  MOVFF  2F,00
168E4:  MOVF   30,W
168E6:  MOVWF  03
168E8:  BNZ   168EE
168EA:  MOVF   00,F
168EC:  BZ    1690E
168EE:  MOVF   03,W
168F0:  BNZ   168F8
168F2:  MOVLW  01
168F4:  SUBWF  00,W
168F6:  BZ    16918
168F8:  MOVF   03,W
168FA:  BNZ   16902
168FC:  MOVLW  03
168FE:  SUBWF  00,W
16900:  BZ    16918
16902:  MOVF   03,W
16904:  BNZ   1690C
16906:  MOVLW  02
16908:  SUBWF  00,W
1690A:  BZ    16920
1690C:  BRA    16926
....................       case ECO: user_quit = auto_sample_eco(); 
1690E:  GOTO   15DD0
16912:  MOVFF  01,50
....................          break; 
16916:  BRA    16926
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
16918:  BRA    161EA
1691A:  MOVFF  01,50
....................          break; 
1691E:  BRA    16926
....................       case AWS: user_quit = auto_sample_aws(); 
16920:  BRA    16556
16922:  MOVFF  01,50
....................          break;          
....................    } 
....................    return(user_quit); 
16926:  MOVFF  50,01
1692A:  GOTO   16A3C (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BC1A:  MOVF   48,F
0BC1C:  BNZ   BC2A
0BC1E:  MOVF   49,F
0BC20:  BNZ   BC2A
0BC22:  MOVF   4A,F
0BC24:  BNZ   BC2A
0BC26:  MOVF   4B,F
0BC28:  BZ    BC42
0BC2A:  MOVF   4B,F
0BC2C:  BNZ   BC42
0BC2E:  MOVF   4A,F
0BC30:  BNZ   BC42
0BC32:  MOVF   49,F
0BC34:  BNZ   BC42
0BC36:  MOVF   48,W
0BC38:  SUBLW  02
0BC3A:  BNC   BC42
....................       detector = arg; 
0BC3C:  MOVFF  48,2D5
....................    } 
0BC40:  BRA    BC46
....................    else cmd_arg(); 
0BC42:  CALL   AF88
0BC46:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0BC68:  MOVF   48,F
0BC6A:  BNZ   BC78
0BC6C:  MOVF   49,F
0BC6E:  BNZ   BC78
0BC70:  MOVF   4A,F
0BC72:  BNZ   BC78
0BC74:  MOVF   4B,F
0BC76:  BZ    BCD2
0BC78:  MOVF   4B,F
0BC7A:  BNZ   BCD2
0BC7C:  MOVF   4A,W
0BC7E:  SUBLW  00
0BC80:  BNC   BCD2
....................       switch (detector){ 
0BC82:  MOVLB  2
0BC84:  MOVF   xD5,W
0BC86:  XORLW  01
0BC88:  MOVLB  0
0BC8A:  BZ    BC92
0BC8C:  XORLW  03
0BC8E:  BZ    BCB0
0BC90:  BRA    BCCE
....................          case 1 : nv_d1_temp = arg; 
0BC92:  MOVFF  49,42
0BC96:  MOVFF  48,41
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0BC9A:  MOVLW  40
0BC9C:  MOVLB  8
0BC9E:  MOVWF  xCF
0BCA0:  MOVFF  42,8D1
0BCA4:  MOVFF  41,8D0
0BCA8:  MOVLB  0
0BCAA:  CALL   4F68
....................             break; 
0BCAE:  BRA    BCD0
....................          case 2 : nv_d2_temp = arg; 
0BCB0:  MOVFF  49,44
0BCB4:  MOVFF  48,43
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0BCB8:  MOVLW  42
0BCBA:  MOVLB  8
0BCBC:  MOVWF  xCF
0BCBE:  MOVFF  44,8D1
0BCC2:  MOVFF  43,8D0
0BCC6:  MOVLB  0
0BCC8:  CALL   4F68
....................             break; 
0BCCC:  BRA    BCD0
....................          default : cmd_err(); 
0BCCE:  RCALL  BC4A
....................             break; 
....................       } 
....................    } 
0BCD0:  BRA    BD78
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0BCD2:  MOVF   48,F
0BCD4:  BNZ   BD74
0BCD6:  MOVF   49,F
0BCD8:  BNZ   BD74
0BCDA:  MOVF   4A,F
0BCDC:  BNZ   BD74
0BCDE:  MOVF   4B,F
0BCE0:  BNZ   BD74
0BCE2:  MOVLW  06
0BCE4:  MOVWF  FF6
0BCE6:  MOVLW  24
0BCE8:  MOVWF  FF7
0BCEA:  MOVLW  00
0BCEC:  MOVWF  FF8
0BCEE:  CLRF   1B
0BCF0:  BTFSC  FF2.7
0BCF2:  BSF    1B.7
0BCF4:  BCF    FF2.7
0BCF6:  MOVLW  03
0BCF8:  MOVLB  A
0BCFA:  MOVWF  x1C
0BCFC:  MOVLB  0
0BCFE:  CALL   1024
0BD02:  BTFSC  1B.7
0BD04:  BSF    FF2.7
0BD06:  MOVLW  10
0BD08:  MOVWF  FE9
0BD0A:  CLRF   1B
0BD0C:  BTFSC  FF2.7
0BD0E:  BSF    1B.7
0BD10:  BCF    FF2.7
0BD12:  MOVFF  42,A1D
0BD16:  MOVFF  41,A1C
0BD1A:  CALL   11A6
0BD1E:  BTFSC  1B.7
0BD20:  BSF    FF2.7
0BD22:  MOVLW  0C
0BD24:  MOVWF  FF6
0BD26:  MOVLW  24
0BD28:  MOVWF  FF7
0BD2A:  MOVLW  00
0BD2C:  MOVWF  FF8
0BD2E:  CLRF   1B
0BD30:  BTFSC  FF2.7
0BD32:  BSF    1B.7
0BD34:  BCF    FF2.7
0BD36:  MOVLW  04
0BD38:  MOVLB  A
0BD3A:  MOVWF  x1C
0BD3C:  MOVLB  0
0BD3E:  CALL   1024
0BD42:  BTFSC  1B.7
0BD44:  BSF    FF2.7
0BD46:  MOVLW  10
0BD48:  MOVWF  FE9
0BD4A:  CLRF   1B
0BD4C:  BTFSC  FF2.7
0BD4E:  BSF    1B.7
0BD50:  BCF    FF2.7
0BD52:  MOVFF  44,A1D
0BD56:  MOVFF  43,A1C
0BD5A:  CALL   11A6
0BD5E:  BTFSC  1B.7
0BD60:  BSF    FF2.7
0BD62:  MOVLW  0D
0BD64:  BTFSS  F9E.4
0BD66:  BRA    BD64
0BD68:  MOVWF  FAD
0BD6A:  MOVLW  0A
0BD6C:  BTFSS  F9E.4
0BD6E:  BRA    BD6C
0BD70:  MOVWF  FAD
0BD72:  BRA    BD78
....................    else cmd_arg(); 
0BD74:  CALL   AF88
0BD78:  GOTO   BDDE (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0BD7C:  MOVF   4B,F
0BD7E:  BNZ   BDAC
0BD80:  MOVF   4A,F
0BD82:  BNZ   BDAC
0BD84:  MOVF   49,F
0BD86:  BNZ   BDAC
0BD88:  MOVF   48,W
0BD8A:  SUBLW  01
0BD8C:  BNC   BDAC
....................       nv_macro_mode = arg; 
0BD8E:  MOVFF  49,2A
0BD92:  MOVFF  48,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0BD96:  MOVLW  20
0BD98:  MOVLB  8
0BD9A:  MOVWF  xCF
0BD9C:  MOVFF  2A,8D1
0BDA0:  MOVFF  29,8D0
0BDA4:  MOVLB  0
0BDA6:  CALL   4F68
....................    } 
0BDAA:  BRA    BDB0
....................    else cmd_arg(); 
0BDAC:  CALL   AF88
0BDB0:  GOTO   BDDE (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0BDB4:  MOVF   2F,W
0BDB6:  MOVWF  00
0BDB8:  MOVF   30,W
0BDBA:  MOVWF  03
0BDBC:  BNZ   BDC2
0BDBE:  MOVF   00,F
0BDC0:  BZ    BDD8
0BDC2:  MOVF   03,W
0BDC4:  BNZ   BDCC
0BDC6:  MOVLW  01
0BDC8:  SUBWF  00,W
0BDCA:  BZ    BDDC
0BDCC:  MOVF   03,W
0BDCE:  BNZ   BDD6
0BDD0:  MOVLW  03
0BDD2:  SUBWF  00,W
0BDD4:  BZ    BDDC
0BDD6:  BRA    BDDE
....................       case ECO : commandAe(); 
0BDD8:  BRA    BC68
....................          break; 
0BDDA:  BRA    BDDE
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0BDDC:  BRA    BD7C
....................          break; 
....................    } 
0BDDE:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0BDE2:  MOVF   48,F
0BDE4:  BNZ   BDF2
0BDE6:  MOVF   49,F
0BDE8:  BNZ   BDF2
0BDEA:  MOVF   4A,F
0BDEC:  BNZ   BDF2
0BDEE:  MOVF   4B,F
0BDF0:  BZ    BE22
0BDF2:  MOVF   4B,F
0BDF4:  BNZ   BE22
0BDF6:  MOVF   4A,F
0BDF8:  BNZ   BE22
0BDFA:  MOVF   49,F
0BDFC:  BNZ   BE22
0BDFE:  MOVF   48,W
0BE00:  SUBLW  03
0BE02:  BNC   BE22
....................       nv_det_type = arg; 
0BE04:  MOVFF  49,46
0BE08:  MOVFF  48,45
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0BE0C:  MOVLW  26
0BE0E:  MOVLB  8
0BE10:  MOVWF  xCF
0BE12:  MOVFF  46,8D1
0BE16:  MOVFF  45,8D0
0BE1A:  MOVLB  0
0BE1C:  CALL   4F68
....................    } 
0BE20:  BRA    BE88
....................    else if(arg==0) { 
0BE22:  MOVF   48,F
0BE24:  BNZ   BE84
0BE26:  MOVF   49,F
0BE28:  BNZ   BE84
0BE2A:  MOVF   4A,F
0BE2C:  BNZ   BE84
0BE2E:  MOVF   4B,F
0BE30:  BNZ   BE84
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0BE32:  MOVLW  16
0BE34:  MOVWF  FF6
0BE36:  MOVLW  24
0BE38:  MOVWF  FF7
0BE3A:  MOVLW  00
0BE3C:  MOVWF  FF8
0BE3E:  CLRF   1B
0BE40:  BTFSC  FF2.7
0BE42:  BSF    1B.7
0BE44:  BCF    FF2.7
0BE46:  MOVLW  05
0BE48:  MOVLB  A
0BE4A:  MOVWF  x1C
0BE4C:  MOVLB  0
0BE4E:  CALL   1024
0BE52:  BTFSC  1B.7
0BE54:  BSF    FF2.7
0BE56:  MOVLW  10
0BE58:  MOVWF  FE9
0BE5A:  CLRF   1B
0BE5C:  BTFSC  FF2.7
0BE5E:  BSF    1B.7
0BE60:  BCF    FF2.7
0BE62:  MOVFF  46,A1D
0BE66:  MOVFF  45,A1C
0BE6A:  CALL   11A6
0BE6E:  BTFSC  1B.7
0BE70:  BSF    FF2.7
0BE72:  MOVLW  0D
0BE74:  BTFSS  F9E.4
0BE76:  BRA    BE74
0BE78:  MOVWF  FAD
0BE7A:  MOVLW  0A
0BE7C:  BTFSS  F9E.4
0BE7E:  BRA    BE7C
0BE80:  MOVWF  FAD
....................    } 
0BE82:  BRA    BE88
....................    else cmd_arg(); 
0BE84:  CALL   AF88
0BE88:  GOTO   BF4A (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0BEFA:  MOVF   4B,F
0BEFC:  BNZ   BF18
0BEFE:  MOVF   4A,F
0BF00:  BNZ   BF18
0BF02:  MOVF   49,F
0BF04:  BNZ   BF18
0BF06:  MOVF   48,W
0BF08:  SUBLW  03
0BF0A:  BNC   BF18
....................       hb_cmd=arg; 
0BF0C:  MOVFF  48,866
....................       h_bridge(hb_cmd); 
0BF10:  MOVFF  866,896
0BF14:  RCALL  BEDA
....................    } 
0BF16:  BRA    BF1C
....................    else cmd_arg(); 
0BF18:  CALL   AF88
0BF1C:  GOTO   BF4A (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0BF20:  MOVF   2F,W
0BF22:  MOVWF  00
0BF24:  MOVF   30,W
0BF26:  MOVWF  03
0BF28:  BNZ   BF2E
0BF2A:  MOVF   00,F
0BF2C:  BZ    BF44
0BF2E:  MOVF   03,W
0BF30:  BNZ   BF38
0BF32:  MOVLW  01
0BF34:  SUBWF  00,W
0BF36:  BZ    BF48
0BF38:  MOVF   03,W
0BF3A:  BNZ   BF42
0BF3C:  MOVLW  03
0BF3E:  SUBWF  00,W
0BF40:  BZ    BF48
0BF42:  BRA    BF4A
....................       case ECO : commandBe(); 
0BF44:  BRA    BDE2
....................          break; 
0BF46:  BRA    BF4A
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0BF48:  BRA    BEFA
....................          break; 
....................    } 
0BF4A:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CA2C:  MOVF   48,W
0CA2E:  MOVWF  00
0CA30:  MOVF   49,W
0CA32:  MOVWF  03
0CA34:  BNZ   CA3A
0CA36:  MOVF   00,F
0CA38:  BZ    CA9C
0CA3A:  MOVF   03,W
0CA3C:  BNZ   CA46
0CA3E:  MOVLW  01
0CA40:  SUBWF  00,W
0CA42:  BTFSC  FD8.2
0CA44:  BRA    CC8A
0CA46:  MOVF   03,W
0CA48:  BNZ   CA52
0CA4A:  MOVLW  02
0CA4C:  SUBWF  00,W
0CA4E:  BTFSC  FD8.2
0CA50:  BRA    CCE6
0CA52:  MOVF   03,W
0CA54:  BNZ   CA5E
0CA56:  MOVLW  03
0CA58:  SUBWF  00,W
0CA5A:  BTFSC  FD8.2
0CA5C:  BRA    CD42
0CA5E:  MOVF   03,W
0CA60:  BNZ   CA6A
0CA62:  MOVLW  04
0CA64:  SUBWF  00,W
0CA66:  BTFSC  FD8.2
0CA68:  BRA    CD9E
0CA6A:  MOVF   03,W
0CA6C:  BNZ   CA76
0CA6E:  MOVLW  05
0CA70:  SUBWF  00,W
0CA72:  BTFSC  FD8.2
0CA74:  BRA    CDFA
0CA76:  MOVF   03,W
0CA78:  BNZ   CA82
0CA7A:  MOVLW  06
0CA7C:  SUBWF  00,W
0CA7E:  BTFSC  FD8.2
0CA80:  BRA    CE56
0CA82:  MOVF   03,W
0CA84:  BNZ   CA8E
0CA86:  MOVLW  07
0CA88:  SUBWF  00,W
0CA8A:  BTFSC  FD8.2
0CA8C:  BRA    CEB2
0CA8E:  MOVF   03,W
0CA90:  BNZ   CA9A
0CA92:  MOVLW  08
0CA94:  SUBWF  00,W
0CA96:  BTFSC  FD8.2
0CA98:  BRA    CF0E
0CA9A:  BRA    CF6A
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CA9C:  MOVLW  22
0CA9E:  MOVWF  FF6
0CAA0:  MOVLW  24
0CAA2:  MOVWF  FF7
0CAA4:  MOVLW  00
0CAA6:  MOVWF  FF8
0CAA8:  CLRF   1B
0CAAA:  BTFSC  FF2.7
0CAAC:  BSF    1B.7
0CAAE:  BCF    FF2.7
0CAB0:  MOVLW  04
0CAB2:  MOVLB  A
0CAB4:  MOVWF  x1C
0CAB6:  MOVLB  0
0CAB8:  CALL   1024
0CABC:  BTFSC  1B.7
0CABE:  BSF    FF2.7
0CAC0:  MOVLW  89
0CAC2:  MOVWF  FE9
0CAC4:  MOVFF  3F8,869
0CAC8:  MOVFF  3F7,868
0CACC:  MOVFF  3F6,867
0CAD0:  MOVFF  3F5,866
0CAD4:  MOVLW  05
0CAD6:  MOVLB  8
0CAD8:  MOVWF  x6A
0CADA:  MOVLB  0
0CADC:  RCALL  C310
0CADE:  MOVLW  2C
0CAE0:  BTFSS  F9E.4
0CAE2:  BRA    CAE0
0CAE4:  MOVWF  FAD
0CAE6:  MOVLW  89
0CAE8:  MOVWF  FE9
0CAEA:  MOVFF  3FC,869
0CAEE:  MOVFF  3FB,868
0CAF2:  MOVFF  3FA,867
0CAF6:  MOVFF  3F9,866
0CAFA:  MOVLW  05
0CAFC:  MOVLB  8
0CAFE:  MOVWF  x6A
0CB00:  MOVLB  0
0CB02:  RCALL  C310
0CB04:  MOVLW  0D
0CB06:  BTFSS  F9E.4
0CB08:  BRA    CB06
0CB0A:  MOVWF  FAD
0CB0C:  MOVLW  0A
0CB0E:  BTFSS  F9E.4
0CB10:  BRA    CB0E
0CB12:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CB14:  MOVLW  34
0CB16:  MOVWF  FF6
0CB18:  MOVLW  24
0CB1A:  MOVWF  FF7
0CB1C:  MOVLW  00
0CB1E:  MOVWF  FF8
0CB20:  CLRF   1B
0CB22:  BTFSC  FF2.7
0CB24:  BSF    1B.7
0CB26:  BCF    FF2.7
0CB28:  MOVLW  04
0CB2A:  MOVLB  A
0CB2C:  MOVWF  x1C
0CB2E:  MOVLB  0
0CB30:  CALL   1024
0CB34:  BTFSC  1B.7
0CB36:  BSF    FF2.7
0CB38:  MOVLW  89
0CB3A:  MOVWF  FE9
0CB3C:  MOVFF  400,869
0CB40:  MOVFF  3FF,868
0CB44:  MOVFF  3FE,867
0CB48:  MOVFF  3FD,866
0CB4C:  MOVLW  05
0CB4E:  MOVLB  8
0CB50:  MOVWF  x6A
0CB52:  MOVLB  0
0CB54:  CALL   C310
0CB58:  MOVLW  2C
0CB5A:  BTFSS  F9E.4
0CB5C:  BRA    CB5A
0CB5E:  MOVWF  FAD
0CB60:  MOVLW  89
0CB62:  MOVWF  FE9
0CB64:  MOVFF  404,869
0CB68:  MOVFF  403,868
0CB6C:  MOVFF  402,867
0CB70:  MOVFF  401,866
0CB74:  MOVLW  05
0CB76:  MOVLB  8
0CB78:  MOVWF  x6A
0CB7A:  MOVLB  0
0CB7C:  CALL   C310
0CB80:  MOVLW  0D
0CB82:  BTFSS  F9E.4
0CB84:  BRA    CB82
0CB86:  MOVWF  FAD
0CB88:  MOVLW  0A
0CB8A:  BTFSS  F9E.4
0CB8C:  BRA    CB8A
0CB8E:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CB90:  MOVLW  46
0CB92:  MOVWF  FF6
0CB94:  MOVLW  24
0CB96:  MOVWF  FF7
0CB98:  MOVLW  00
0CB9A:  MOVWF  FF8
0CB9C:  CLRF   1B
0CB9E:  BTFSC  FF2.7
0CBA0:  BSF    1B.7
0CBA2:  BCF    FF2.7
0CBA4:  MOVLW  04
0CBA6:  MOVLB  A
0CBA8:  MOVWF  x1C
0CBAA:  MOVLB  0
0CBAC:  CALL   1024
0CBB0:  BTFSC  1B.7
0CBB2:  BSF    FF2.7
0CBB4:  MOVLW  89
0CBB6:  MOVWF  FE9
0CBB8:  MOVFF  408,869
0CBBC:  MOVFF  407,868
0CBC0:  MOVFF  406,867
0CBC4:  MOVFF  405,866
0CBC8:  MOVLW  05
0CBCA:  MOVLB  8
0CBCC:  MOVWF  x6A
0CBCE:  MOVLB  0
0CBD0:  CALL   C310
0CBD4:  MOVLW  2C
0CBD6:  BTFSS  F9E.4
0CBD8:  BRA    CBD6
0CBDA:  MOVWF  FAD
0CBDC:  MOVLW  89
0CBDE:  MOVWF  FE9
0CBE0:  MOVFF  40C,869
0CBE4:  MOVFF  40B,868
0CBE8:  MOVFF  40A,867
0CBEC:  MOVFF  409,866
0CBF0:  MOVLW  05
0CBF2:  MOVLB  8
0CBF4:  MOVWF  x6A
0CBF6:  MOVLB  0
0CBF8:  CALL   C310
0CBFC:  MOVLW  0D
0CBFE:  BTFSS  F9E.4
0CC00:  BRA    CBFE
0CC02:  MOVWF  FAD
0CC04:  MOVLW  0A
0CC06:  BTFSS  F9E.4
0CC08:  BRA    CC06
0CC0A:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CC0C:  MOVLW  58
0CC0E:  MOVWF  FF6
0CC10:  MOVLW  24
0CC12:  MOVWF  FF7
0CC14:  MOVLW  00
0CC16:  MOVWF  FF8
0CC18:  CLRF   1B
0CC1A:  BTFSC  FF2.7
0CC1C:  BSF    1B.7
0CC1E:  BCF    FF2.7
0CC20:  MOVLW  05
0CC22:  MOVLB  A
0CC24:  MOVWF  x1C
0CC26:  MOVLB  0
0CC28:  CALL   1024
0CC2C:  BTFSC  1B.7
0CC2E:  BSF    FF2.7
0CC30:  MOVLW  89
0CC32:  MOVWF  FE9
0CC34:  MOVFF  410,869
0CC38:  MOVFF  40F,868
0CC3C:  MOVFF  40E,867
0CC40:  MOVFF  40D,866
0CC44:  MOVLW  05
0CC46:  MOVLB  8
0CC48:  MOVWF  x6A
0CC4A:  MOVLB  0
0CC4C:  CALL   C310
0CC50:  MOVLW  2C
0CC52:  BTFSS  F9E.4
0CC54:  BRA    CC52
0CC56:  MOVWF  FAD
0CC58:  MOVLW  89
0CC5A:  MOVWF  FE9
0CC5C:  MOVFF  414,869
0CC60:  MOVFF  413,868
0CC64:  MOVFF  412,867
0CC68:  MOVFF  411,866
0CC6C:  MOVLW  05
0CC6E:  MOVLB  8
0CC70:  MOVWF  x6A
0CC72:  MOVLB  0
0CC74:  CALL   C310
0CC78:  MOVLW  0D
0CC7A:  BTFSS  F9E.4
0CC7C:  BRA    CC7A
0CC7E:  MOVWF  FAD
0CC80:  MOVLW  0A
0CC82:  BTFSS  F9E.4
0CC84:  BRA    CC82
0CC86:  MOVWF  FAD
....................                   break; 
0CC88:  BRA    CF6E
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0CC8A:  MOVLW  6C
0CC8C:  MOVWF  FF6
0CC8E:  MOVLW  24
0CC90:  MOVWF  FF7
0CC92:  MOVLW  00
0CC94:  MOVWF  FF8
0CC96:  CLRF   1B
0CC98:  BTFSC  FF2.7
0CC9A:  BSF    1B.7
0CC9C:  BCF    FF2.7
0CC9E:  CALL   0E4E
0CCA2:  BTFSC  1B.7
0CCA4:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0CCA6:  RCALL  C978
0CCA8:  MOVFF  03,3F8
0CCAC:  MOVFF  02,3F7
0CCB0:  MOVFF  01,3F6
0CCB4:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");   
0CCB8:  MOVLW  0D
0CCBA:  BTFSS  F9E.4
0CCBC:  BRA    CCBA
0CCBE:  MOVWF  FAD
0CCC0:  MOVLW  0A
0CCC2:  BTFSS  F9E.4
0CCC4:  BRA    CCC2
0CCC6:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0CCC8:  MOVLB  8
0CCCA:  CLRF   x67
0CCCC:  MOVLW  44
0CCCE:  MOVWF  x66
0CCD0:  MOVFF  3F8,86B
0CCD4:  MOVFF  3F7,86A
0CCD8:  MOVFF  3F6,869
0CCDC:  MOVFF  3F5,868
0CCE0:  MOVLB  0
0CCE2:  RCALL  C9BE
....................          break; 
0CCE4:  BRA    CF6E
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0CCE6:  MOVLW  74
0CCE8:  MOVWF  FF6
0CCEA:  MOVLW  24
0CCEC:  MOVWF  FF7
0CCEE:  MOVLW  00
0CCF0:  MOVWF  FF8
0CCF2:  CLRF   1B
0CCF4:  BTFSC  FF2.7
0CCF6:  BSF    1B.7
0CCF8:  BCF    FF2.7
0CCFA:  CALL   0E4E
0CCFE:  BTFSC  1B.7
0CD00:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0CD02:  RCALL  C978
0CD04:  MOVFF  03,3FC
0CD08:  MOVFF  02,3FB
0CD0C:  MOVFF  01,3FA
0CD10:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n");  
0CD14:  MOVLW  0D
0CD16:  BTFSS  F9E.4
0CD18:  BRA    CD16
0CD1A:  MOVWF  FAD
0CD1C:  MOVLW  0A
0CD1E:  BTFSS  F9E.4
0CD20:  BRA    CD1E
0CD22:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0CD24:  MOVLB  8
0CD26:  CLRF   x67
0CD28:  MOVLW  48
0CD2A:  MOVWF  x66
0CD2C:  MOVFF  3FC,86B
0CD30:  MOVFF  3FB,86A
0CD34:  MOVFF  3FA,869
0CD38:  MOVFF  3F9,868
0CD3C:  MOVLB  0
0CD3E:  RCALL  C9BE
....................          break; 
0CD40:  BRA    CF6E
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0CD42:  MOVLW  7C
0CD44:  MOVWF  FF6
0CD46:  MOVLW  24
0CD48:  MOVWF  FF7
0CD4A:  MOVLW  00
0CD4C:  MOVWF  FF8
0CD4E:  CLRF   1B
0CD50:  BTFSC  FF2.7
0CD52:  BSF    1B.7
0CD54:  BCF    FF2.7
0CD56:  CALL   0E4E
0CD5A:  BTFSC  1B.7
0CD5C:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0CD5E:  RCALL  C978
0CD60:  MOVFF  03,400
0CD64:  MOVFF  02,3FF
0CD68:  MOVFF  01,3FE
0CD6C:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n"); 
0CD70:  MOVLW  0D
0CD72:  BTFSS  F9E.4
0CD74:  BRA    CD72
0CD76:  MOVWF  FAD
0CD78:  MOVLW  0A
0CD7A:  BTFSS  F9E.4
0CD7C:  BRA    CD7A
0CD7E:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0CD80:  MOVLB  8
0CD82:  CLRF   x67
0CD84:  MOVLW  4C
0CD86:  MOVWF  x66
0CD88:  MOVFF  400,86B
0CD8C:  MOVFF  3FF,86A
0CD90:  MOVFF  3FE,869
0CD94:  MOVFF  3FD,868
0CD98:  MOVLB  0
0CD9A:  RCALL  C9BE
....................          break; 
0CD9C:  BRA    CF6E
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0CD9E:  MOVLW  84
0CDA0:  MOVWF  FF6
0CDA2:  MOVLW  24
0CDA4:  MOVWF  FF7
0CDA6:  MOVLW  00
0CDA8:  MOVWF  FF8
0CDAA:  CLRF   1B
0CDAC:  BTFSC  FF2.7
0CDAE:  BSF    1B.7
0CDB0:  BCF    FF2.7
0CDB2:  CALL   0E4E
0CDB6:  BTFSC  1B.7
0CDB8:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0CDBA:  RCALL  C978
0CDBC:  MOVFF  03,404
0CDC0:  MOVFF  02,403
0CDC4:  MOVFF  01,402
0CDC8:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");  
0CDCC:  MOVLW  0D
0CDCE:  BTFSS  F9E.4
0CDD0:  BRA    CDCE
0CDD2:  MOVWF  FAD
0CDD4:  MOVLW  0A
0CDD6:  BTFSS  F9E.4
0CDD8:  BRA    CDD6
0CDDA:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0CDDC:  MOVLB  8
0CDDE:  CLRF   x67
0CDE0:  MOVLW  52
0CDE2:  MOVWF  x66
0CDE4:  MOVFF  3FC,86B
0CDE8:  MOVFF  3FB,86A
0CDEC:  MOVFF  3FA,869
0CDF0:  MOVFF  3F9,868
0CDF4:  MOVLB  0
0CDF6:  RCALL  C9BE
....................          break; 
0CDF8:  BRA    CF6E
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0CDFA:  MOVLW  8C
0CDFC:  MOVWF  FF6
0CDFE:  MOVLW  24
0CE00:  MOVWF  FF7
0CE02:  MOVLW  00
0CE04:  MOVWF  FF8
0CE06:  CLRF   1B
0CE08:  BTFSC  FF2.7
0CE0A:  BSF    1B.7
0CE0C:  BCF    FF2.7
0CE0E:  CALL   0E4E
0CE12:  BTFSC  1B.7
0CE14:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0CE16:  RCALL  C978
0CE18:  MOVFF  03,408
0CE1C:  MOVFF  02,407
0CE20:  MOVFF  01,406
0CE24:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");   
0CE28:  MOVLW  0D
0CE2A:  BTFSS  F9E.4
0CE2C:  BRA    CE2A
0CE2E:  MOVWF  FAD
0CE30:  MOVLW  0A
0CE32:  BTFSS  F9E.4
0CE34:  BRA    CE32
0CE36:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0CE38:  MOVLB  8
0CE3A:  CLRF   x67
0CE3C:  MOVLW  56
0CE3E:  MOVWF  x66
0CE40:  MOVFF  408,86B
0CE44:  MOVFF  407,86A
0CE48:  MOVFF  406,869
0CE4C:  MOVFF  405,868
0CE50:  MOVLB  0
0CE52:  RCALL  C9BE
....................          break; 
0CE54:  BRA    CF6E
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0CE56:  MOVLW  94
0CE58:  MOVWF  FF6
0CE5A:  MOVLW  24
0CE5C:  MOVWF  FF7
0CE5E:  MOVLW  00
0CE60:  MOVWF  FF8
0CE62:  CLRF   1B
0CE64:  BTFSC  FF2.7
0CE66:  BSF    1B.7
0CE68:  BCF    FF2.7
0CE6A:  CALL   0E4E
0CE6E:  BTFSC  1B.7
0CE70:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0CE72:  RCALL  C978
0CE74:  MOVFF  03,40C
0CE78:  MOVFF  02,40B
0CE7C:  MOVFF  01,40A
0CE80:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");  
0CE84:  MOVLW  0D
0CE86:  BTFSS  F9E.4
0CE88:  BRA    CE86
0CE8A:  MOVWF  FAD
0CE8C:  MOVLW  0A
0CE8E:  BTFSS  F9E.4
0CE90:  BRA    CE8E
0CE92:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0CE94:  MOVLB  8
0CE96:  CLRF   x67
0CE98:  MOVLW  5A
0CE9A:  MOVWF  x66
0CE9C:  MOVFF  40C,86B
0CEA0:  MOVFF  40B,86A
0CEA4:  MOVFF  40A,869
0CEA8:  MOVFF  409,868
0CEAC:  MOVLB  0
0CEAE:  RCALL  C9BE
....................          break; 
0CEB0:  BRA    CF6E
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0CEB2:  MOVLW  9C
0CEB4:  MOVWF  FF6
0CEB6:  MOVLW  24
0CEB8:  MOVWF  FF7
0CEBA:  MOVLW  00
0CEBC:  MOVWF  FF8
0CEBE:  CLRF   1B
0CEC0:  BTFSC  FF2.7
0CEC2:  BSF    1B.7
0CEC4:  BCF    FF2.7
0CEC6:  CALL   0E4E
0CECA:  BTFSC  1B.7
0CECC:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0CECE:  RCALL  C978
0CED0:  MOVFF  03,410
0CED4:  MOVFF  02,40F
0CED8:  MOVFF  01,40E
0CEDC:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");   
0CEE0:  MOVLW  0D
0CEE2:  BTFSS  F9E.4
0CEE4:  BRA    CEE2
0CEE6:  MOVWF  FAD
0CEE8:  MOVLW  0A
0CEEA:  BTFSS  F9E.4
0CEEC:  BRA    CEEA
0CEEE:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0CEF0:  MOVLB  8
0CEF2:  CLRF   x67
0CEF4:  MOVLW  5E
0CEF6:  MOVWF  x66
0CEF8:  MOVFF  410,86B
0CEFC:  MOVFF  40F,86A
0CF00:  MOVFF  40E,869
0CF04:  MOVFF  40D,868
0CF08:  MOVLB  0
0CF0A:  RCALL  C9BE
....................          break; 
0CF0C:  BRA    CF6E
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0CF0E:  MOVLW  A6
0CF10:  MOVWF  FF6
0CF12:  MOVLW  24
0CF14:  MOVWF  FF7
0CF16:  MOVLW  00
0CF18:  MOVWF  FF8
0CF1A:  CLRF   1B
0CF1C:  BTFSC  FF2.7
0CF1E:  BSF    1B.7
0CF20:  BCF    FF2.7
0CF22:  CALL   0E4E
0CF26:  BTFSC  1B.7
0CF28:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0CF2A:  RCALL  C978
0CF2C:  MOVFF  03,414
0CF30:  MOVFF  02,413
0CF34:  MOVFF  01,412
0CF38:  MOVFF  00,411
....................                fprintf(COM_A,"\r\n");  
0CF3C:  MOVLW  0D
0CF3E:  BTFSS  F9E.4
0CF40:  BRA    CF3E
0CF42:  MOVWF  FAD
0CF44:  MOVLW  0A
0CF46:  BTFSS  F9E.4
0CF48:  BRA    CF46
0CF4A:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0CF4C:  MOVLB  8
0CF4E:  CLRF   x67
0CF50:  MOVLW  62
0CF52:  MOVWF  x66
0CF54:  MOVFF  414,86B
0CF58:  MOVFF  413,86A
0CF5C:  MOVFF  412,869
0CF60:  MOVFF  411,868
0CF64:  MOVLB  0
0CF66:  RCALL  C9BE
....................          break;         
0CF68:  BRA    CF6E
....................       default: cmd_arg(); 
0CF6A:  CALL   AF88
....................          break; 
....................    } 
0CF6E:  GOTO   D964 (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0D67E:  MOVF   4B,F
0D680:  BNZ   D690
0D682:  MOVF   4A,F
0D684:  BNZ   D690
0D686:  MOVF   49,F
0D688:  BNZ   D690
0D68A:  MOVF   48,W
0D68C:  SUBLW  01
0D68E:  BC    D6E0
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0D690:  MOVF   4B,F
0D692:  BNZ   D6AA
0D694:  MOVF   4A,F
0D696:  BNZ   D6AA
0D698:  MOVF   49,F
0D69A:  BNZ   D6AA
0D69C:  MOVF   48,W
0D69E:  SUBLW  30
0D6A0:  BNC   D6AA
0D6A2:  DECFSZ 2F,W
0D6A4:  BRA    D6AA
0D6A6:  MOVF   30,F
0D6A8:  BZ    D6C6
0D6AA:  MOVF   4B,F
0D6AC:  BNZ   D6DA
0D6AE:  MOVF   4A,F
0D6B0:  BNZ   D6DA
0D6B2:  MOVF   49,F
0D6B4:  BNZ   D6DA
0D6B6:  MOVF   48,W
0D6B8:  SUBLW  32
0D6BA:  BNC   D6DA
0D6BC:  MOVF   2F,W
0D6BE:  SUBLW  03
0D6C0:  BNZ   D6DA
0D6C2:  MOVF   30,F
0D6C4:  BNZ   D6DA
....................          port=arg; 
0D6C6:  MOVFF  49,867
0D6CA:  MOVFF  48,866
....................          play_wms_hard_macro(port);    
0D6CE:  MOVFF  867,86B
0D6D2:  MOVFF  866,86A
0D6D6:  RCALL  D470
....................       } 
0D6D8:  BRA    D6DE
....................       else cmd_arg(); 
0D6DA:  CALL   AF88
....................    } 
0D6DE:  BRA    D6E4
....................    else cmd_arg(); 
0D6E0:  CALL   AF88
0D6E4:  GOTO   D964 (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0D8F4:  MOVF   48,F
0D8F6:  BNZ   D904
0D8F8:  MOVF   49,F
0D8FA:  BNZ   D904
0D8FC:  MOVF   4A,F
0D8FE:  BNZ   D904
0D900:  MOVF   4B,F
0D902:  BZ    D922
0D904:  MOVF   4B,F
0D906:  BNZ   D922
0D908:  MOVF   4A,F
0D90A:  BNZ   D922
0D90C:  MOVF   49,F
0D90E:  BNZ   D922
0D910:  MOVF   48,W
0D912:  SUBLW  04
0D914:  BNC   D922
....................       chip=arg; 
0D916:  MOVFF  48,866
....................       sol_chip_cmd(chip); 
0D91A:  MOVFF  866,897
0D91E:  RCALL  D826
....................    } 
0D920:  BRA    D926
....................    else cmd_arg();    
0D922:  CALL   AF88
0D926:  GOTO   D964 (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0D92A:  MOVF   2F,W
0D92C:  MOVWF  00
0D92E:  MOVF   30,W
0D930:  MOVWF  03
0D932:  BNZ   D938
0D934:  MOVF   00,F
0D936:  BZ    D958
0D938:  MOVF   03,W
0D93A:  BNZ   D942
0D93C:  MOVLW  01
0D93E:  SUBWF  00,W
0D940:  BZ    D95E
0D942:  MOVF   03,W
0D944:  BNZ   D94C
0D946:  MOVLW  03
0D948:  SUBWF  00,W
0D94A:  BZ    D95E
0D94C:  MOVF   03,W
0D94E:  BNZ   D956
0D950:  MOVLW  02
0D952:  SUBWF  00,W
0D954:  BZ    D962
0D956:  BRA    D964
....................       case ECO : commandCe(); 
0D958:  GOTO   CA2C
....................          break; 
0D95C:  BRA    D964
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0D95E:  BRA    D67E
....................          break; 
0D960:  BRA    D964
....................       case AWS : commandCa(); 
0D962:  BRA    D8F4
....................          break;          
....................    } 
0D964:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0D968:  MOVF   48,W
0D96A:  MOVWF  00
0D96C:  MOVF   49,W
0D96E:  MOVWF  03
0D970:  BNZ   D976
0D972:  MOVF   00,F
0D974:  BZ    D996
0D976:  MOVF   03,W
0D978:  BNZ   D980
0D97A:  MOVLW  01
0D97C:  SUBWF  00,W
0D97E:  BZ    D9A8
0D980:  MOVF   03,W
0D982:  BNZ   D98A
0D984:  MOVLW  02
0D986:  SUBWF  00,W
0D988:  BZ    D9CA
0D98A:  MOVF   03,W
0D98C:  BNZ   D994
0D98E:  MOVLW  03
0D990:  SUBWF  00,W
0D992:  BZ    D9DC
0D994:  BRA    D9FE
....................       case 0 : file_list(file_ptr_raw_all); 
0D996:  MOVLW  02
0D998:  MOVLB  8
0D99A:  MOVWF  x6B
0D99C:  MOVLW  DD
0D99E:  MOVWF  x6A
0D9A0:  MOVLB  0
0D9A2:  CALL   B7AE
....................          break; 
0D9A6:  BRA    DA02
....................       case 1 : file_list(file_ptr_raw_new); 
0D9A8:  MOVLW  02
0D9AA:  MOVLB  8
0D9AC:  MOVWF  x6B
0D9AE:  MOVLW  EB
0D9B0:  MOVWF  x6A
0D9B2:  MOVLB  0
0D9B4:  CALL   B7AE
....................                f_unlink(file_ptr_raw_new); 
0D9B8:  MOVLW  02
0D9BA:  MOVLB  8
0D9BC:  MOVWF  x6B
0D9BE:  MOVLW  EB
0D9C0:  MOVWF  x6A
0D9C2:  MOVLB  0
0D9C4:  CALL   B928
....................          break; 
0D9C8:  BRA    DA02
....................       case 2 : file_list(file_ptr_rel_all); 
0D9CA:  MOVLW  02
0D9CC:  MOVLB  8
0D9CE:  MOVWF  x6B
0D9D0:  MOVLW  F9
0D9D2:  MOVWF  x6A
0D9D4:  MOVLB  0
0D9D6:  CALL   B7AE
....................          break; 
0D9DA:  BRA    DA02
....................       case 3 : file_list(file_ptr_rel_new); 
0D9DC:  MOVLW  03
0D9DE:  MOVLB  8
0D9E0:  MOVWF  x6B
0D9E2:  MOVLW  07
0D9E4:  MOVWF  x6A
0D9E6:  MOVLB  0
0D9E8:  CALL   B7AE
....................                f_unlink(file_ptr_rel_new); 
0D9EC:  MOVLW  03
0D9EE:  MOVLB  8
0D9F0:  MOVWF  x6B
0D9F2:  MOVLW  07
0D9F4:  MOVWF  x6A
0D9F6:  MOVLB  0
0D9F8:  CALL   B928
....................          break;  
0D9FC:  BRA    DA02
....................       default : cmd_arg(); 
0D9FE:  CALL   AF88
....................          break; 
....................    } 
0DA02:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DA06:  MOVF   48,W
0DA08:  MOVWF  00
0DA0A:  MOVF   49,W
0DA0C:  MOVWF  03
0DA0E:  BNZ   DA14
0DA10:  MOVF   00,F
0DA12:  BZ    DA20
0DA14:  MOVF   03,W
0DA16:  BNZ   DA1E
0DA18:  MOVLW  02
0DA1A:  SUBWF  00,W
0DA1C:  BZ    DA9A
0DA1E:  BRA    DB14
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DA20:  MOVLW  B0
0DA22:  MOVWF  FF6
0DA24:  MOVLW  24
0DA26:  MOVWF  FF7
0DA28:  MOVLW  00
0DA2A:  MOVWF  FF8
0DA2C:  CLRF   1B
0DA2E:  BTFSC  FF2.7
0DA30:  BSF    1B.7
0DA32:  BCF    FF2.7
0DA34:  CALL   0E4E
0DA38:  BTFSC  1B.7
0DA3A:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DA3C:  CALL   0E38
0DA40:  MOVFF  01,866
....................       if(result == 'Y'){ 
0DA44:  MOVLB  8
0DA46:  MOVF   x66,W
0DA48:  SUBLW  59
0DA4A:  BNZ   DA7A
....................       f_unlink(file_ptr_raw_all); 
0DA4C:  MOVLW  02
0DA4E:  MOVWF  x6B
0DA50:  MOVLW  DD
0DA52:  MOVWF  x6A
0DA54:  MOVLB  0
0DA56:  CALL   B928
....................       printf("File deleted!\n\r"); 
0DA5A:  MOVLW  EC
0DA5C:  MOVWF  FF6
0DA5E:  MOVLW  24
0DA60:  MOVWF  FF7
0DA62:  MOVLW  00
0DA64:  MOVWF  FF8
0DA66:  CLRF   1B
0DA68:  BTFSC  FF2.7
0DA6A:  BSF    1B.7
0DA6C:  BCF    FF2.7
0DA6E:  CALL   0E4E
0DA72:  BTFSC  1B.7
0DA74:  BSF    FF2.7
....................       }else{ 
0DA76:  BRA    DA98
0DA78:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DA7A:  MOVLW  FC
0DA7C:  MOVWF  FF6
0DA7E:  MOVLW  24
0DA80:  MOVWF  FF7
0DA82:  MOVLW  00
0DA84:  MOVWF  FF8
0DA86:  CLRF   1B
0DA88:  BTFSC  FF2.7
0DA8A:  BSF    1B.7
0DA8C:  BCF    FF2.7
0DA8E:  MOVLB  0
0DA90:  CALL   0E4E
0DA94:  BTFSC  1B.7
0DA96:  BSF    FF2.7
....................       } 
....................          break; 
0DA98:  BRA    DB18
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DA9A:  MOVLW  12
0DA9C:  MOVWF  FF6
0DA9E:  MOVLW  25
0DAA0:  MOVWF  FF7
0DAA2:  MOVLW  00
0DAA4:  MOVWF  FF8
0DAA6:  CLRF   1B
0DAA8:  BTFSC  FF2.7
0DAAA:  BSF    1B.7
0DAAC:  BCF    FF2.7
0DAAE:  CALL   0E4E
0DAB2:  BTFSC  1B.7
0DAB4:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DAB6:  CALL   0E38
0DABA:  MOVFF  01,866
....................          if(result == 'Y'){ 
0DABE:  MOVLB  8
0DAC0:  MOVF   x66,W
0DAC2:  SUBLW  59
0DAC4:  BNZ   DAF4
....................             f_unlink(file_ptr_rel_all); 
0DAC6:  MOVLW  02
0DAC8:  MOVWF  x6B
0DACA:  MOVLW  F9
0DACC:  MOVWF  x6A
0DACE:  MOVLB  0
0DAD0:  CALL   B928
....................             printf("File deleted!\n\r"); 
0DAD4:  MOVLW  56
0DAD6:  MOVWF  FF6
0DAD8:  MOVLW  25
0DADA:  MOVWF  FF7
0DADC:  MOVLW  00
0DADE:  MOVWF  FF8
0DAE0:  CLRF   1B
0DAE2:  BTFSC  FF2.7
0DAE4:  BSF    1B.7
0DAE6:  BCF    FF2.7
0DAE8:  CALL   0E4E
0DAEC:  BTFSC  1B.7
0DAEE:  BSF    FF2.7
....................          }else{ 
0DAF0:  BRA    DB12
0DAF2:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DAF4:  MOVLW  66
0DAF6:  MOVWF  FF6
0DAF8:  MOVLW  25
0DAFA:  MOVWF  FF7
0DAFC:  MOVLW  00
0DAFE:  MOVWF  FF8
0DB00:  CLRF   1B
0DB02:  BTFSC  FF2.7
0DB04:  BSF    1B.7
0DB06:  BCF    FF2.7
0DB08:  MOVLB  0
0DB0A:  CALL   0E4E
0DB0E:  BTFSC  1B.7
0DB10:  BSF    FF2.7
....................          } 
....................          break; 
0DB12:  BRA    DB18
....................       default : cmd_arg(); 
0DB14:  CALL   AF88
....................          break;          
....................    } 
0DB18:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0DD04:  MOVF   48,W
0DD06:  SUBLW  95
0DD08:  BNZ   DD1C
0DD0A:  MOVF   49,W
0DD0C:  SUBLW  15
0DD0E:  BNZ   DD1C
0DD10:  MOVF   4A,F
0DD12:  BNZ   DD1C
0DD14:  MOVF   4B,F
0DD16:  BNZ   DD1C
....................       reset_nv_vars(); 
0DD18:  BRA    DB1C
....................    } 
0DD1A:  BRA    DD20
....................    else cmd_arg(); 
0DD1C:  CALL   AF88
0DD20:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0DD6E:  MOVF   2F,F
0DD70:  BNZ   DD76
0DD72:  MOVF   30,F
0DD74:  BZ    DD88
0DD76:  DECFSZ 2F,W
0DD78:  BRA    DD7E
0DD7A:  MOVF   30,F
0DD7C:  BZ    DD88
0DD7E:  MOVF   2F,W
0DD80:  SUBLW  03
0DD82:  BNZ   DDFA
0DD84:  MOVF   30,F
0DD86:  BNZ   DDFA
....................    { 
....................       busy_set(); 
0DD88:  CALL   295C
....................  
....................       switch(arg) 
0DD8C:  MOVFF  48,00
0DD90:  MOVF   49,W
0DD92:  MOVWF  03
0DD94:  BNZ   DD9C
0DD96:  MOVLW  01
0DD98:  SUBWF  00,W
0DD9A:  BZ    DDB2
0DD9C:  MOVF   03,W
0DD9E:  BNZ   DDA6
0DDA0:  MOVLW  02
0DDA2:  SUBWF  00,W
0DDA4:  BZ    DDC2
0DDA6:  MOVF   03,W
0DDA8:  BNZ   DDB0
0DDAA:  MOVLW  03
0DDAC:  SUBWF  00,W
0DDAE:  BZ    DDEC
0DDB0:  BRA    DDF2
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0DDB2:  MOVLB  7
0DDB4:  CLRF   x40
....................             align(0); 
0DDB6:  MOVLB  8
0DDB8:  CLRF   xA3
0DDBA:  MOVLB  0
0DDBC:  CALL   A810
....................             break; 
0DDC0:  BRA    DDF6
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0DDC2:  MOVF   48,W
0DDC4:  SUBLW  02
0DDC6:  BNZ   DDEA
0DDC8:  MOVF   49,F
0DDCA:  BNZ   DDEA
0DDCC:  MOVF   4A,F
0DDCE:  BNZ   DDEA
0DDD0:  MOVF   4B,F
0DDD2:  BNZ   DDEA
0DDD4:  MOVF   1F,W
0DDD6:  SUBLW  04
0DDD8:  BNZ   DDEA
0DDDA:  MOVF   20,F
0DDDC:  BNZ   DDEA
....................             { 
....................                motor=0; 
0DDDE:  MOVLB  7
0DDE0:  CLRF   x40
....................                cal_disk(0); 
0DDE2:  MOVLB  8
0DDE4:  CLRF   x66
0DDE6:  MOVLB  0
0DDE8:  BRA    DD24
....................             } 
....................             break; 
0DDEA:  BRA    DDF6
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0DDEC:  CALL   A9B4
....................             break; 
0DDF0:  BRA    DDF6
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0DDF2:  CALL   AF88
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0DDF6:  CALL   ADD0
....................    } 
0DDFA:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E2D4:  DECFSZ 48,W
0E2D6:  BRA    E6F4
0E2D8:  MOVF   49,F
0E2DA:  BTFSS  FD8.2
0E2DC:  BRA    E6F4
0E2DE:  MOVF   4A,F
0E2E0:  BTFSS  FD8.2
0E2E2:  BRA    E6F4
0E2E4:  MOVF   4B,F
0E2E6:  BTFSS  FD8.2
0E2E8:  BRA    E6F4
....................       v_supply = read_supply(); 
0E2EA:  CALL   5090
0E2EE:  MOVFF  02,867
0E2F2:  MOVFF  01,866
....................        
....................       RTC_reset_HT(); 
0E2F6:  CALL   344E
....................       RTC_read(); 
0E2FA:  CALL   32E0
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E2FE:  MOVLW  7C
0E300:  MOVWF  FF6
0E302:  MOVLW  25
0E304:  MOVWF  FF7
0E306:  MOVLW  00
0E308:  MOVWF  FF8
0E30A:  CLRF   1B
0E30C:  BTFSC  FF2.7
0E30E:  BSF    1B.7
0E310:  BCF    FF2.7
0E312:  MOVLW  04
0E314:  MOVLB  A
0E316:  MOVWF  x1C
0E318:  MOVLB  0
0E31A:  CALL   1024
0E31E:  BTFSC  1B.7
0E320:  BSF    FF2.7
0E322:  MOVLW  10
0E324:  MOVWF  FE9
0E326:  CLRF   1B
0E328:  BTFSC  FF2.7
0E32A:  BSF    1B.7
0E32C:  BCF    FF2.7
0E32E:  MOVFF  26,A1D
0E332:  MOVFF  25,A1C
0E336:  CALL   11A6
0E33A:  BTFSC  1B.7
0E33C:  BSF    FF2.7
0E33E:  MOVLW  20
0E340:  BTFSS  F9E.4
0E342:  BRA    E340
0E344:  MOVWF  FAD
0E346:  MOVLW  49
0E348:  BTFSS  F9E.4
0E34A:  BRA    E348
0E34C:  MOVWF  FAD
0E34E:  MOVLW  10
0E350:  MOVWF  FE9
0E352:  CLRF   1B
0E354:  BTFSC  FF2.7
0E356:  BSF    1B.7
0E358:  BCF    FF2.7
0E35A:  MOVFF  24,A1D
0E35E:  MOVFF  23,A1C
0E362:  CALL   11A6
0E366:  BTFSC  1B.7
0E368:  BSF    FF2.7
0E36A:  MOVLW  20
0E36C:  BTFSS  F9E.4
0E36E:  BRA    E36C
0E370:  MOVWF  FAD
0E372:  MOVLW  4E
0E374:  BTFSS  F9E.4
0E376:  BRA    E374
0E378:  MOVWF  FAD
0E37A:  MOVLW  10
0E37C:  MOVWF  FE9
0E37E:  CLRF   1B
0E380:  BTFSC  FF2.7
0E382:  BSF    1B.7
0E384:  BCF    FF2.7
0E386:  MOVFF  22,A1D
0E38A:  MOVFF  21,A1C
0E38E:  CALL   11A6
0E392:  BTFSC  1B.7
0E394:  BSF    FF2.7
0E396:  MOVLW  2F
0E398:  BTFSS  F9E.4
0E39A:  BRA    E398
0E39C:  MOVWF  FAD
0E39E:  MOVLW  10
0E3A0:  MOVWF  FE9
0E3A2:  CLRF   1B
0E3A4:  BTFSC  FF2.7
0E3A6:  BSF    1B.7
0E3A8:  BCF    FF2.7
0E3AA:  MOVFF  28,A1D
0E3AE:  MOVFF  27,A1C
0E3B2:  CALL   11A6
0E3B6:  BTFSC  1B.7
0E3B8:  BSF    FF2.7
0E3BA:  MOVLW  20
0E3BC:  BTFSS  F9E.4
0E3BE:  BRA    E3BC
0E3C0:  MOVWF  FAD
0E3C2:  MOVLW  58
0E3C4:  BTFSS  F9E.4
0E3C6:  BRA    E3C4
0E3C8:  MOVWF  FAD
0E3CA:  MOVLW  10
0E3CC:  MOVWF  FE9
0E3CE:  CLRF   1B
0E3D0:  BTFSC  FF2.7
0E3D2:  BSF    1B.7
0E3D4:  BCF    FF2.7
0E3D6:  MOVFF  20,A1D
0E3DA:  MOVFF  1F,A1C
0E3DE:  CALL   11A6
0E3E2:  BTFSC  1B.7
0E3E4:  BSF    FF2.7
0E3E6:  MOVLW  20
0E3E8:  BTFSS  F9E.4
0E3EA:  BRA    E3E8
0E3EC:  MOVWF  FAD
0E3EE:  MOVLW  55
0E3F0:  BTFSS  F9E.4
0E3F2:  BRA    E3F0
0E3F4:  MOVWF  FAD
0E3F6:  CLRF   1B
0E3F8:  BTFSC  FF2.7
0E3FA:  BSF    1B.7
0E3FC:  BCF    FF2.7
0E3FE:  MOVFF  740,A1C
0E402:  MOVLW  1B
0E404:  MOVLB  A
0E406:  MOVWF  x1D
0E408:  MOVLB  0
0E40A:  CALL   0FA6
0E40E:  BTFSC  1B.7
0E410:  BSF    FF2.7
0E412:  MOVLW  20
0E414:  BTFSS  F9E.4
0E416:  BRA    E414
0E418:  MOVWF  FAD
0E41A:  MOVLW  04
0E41C:  MOVWF  FE9
0E41E:  MOVLB  8
0E420:  CLRF   x6B
0E422:  CLRF   x6A
0E424:  MOVFF  867,869
0E428:  MOVFF  866,868
0E42C:  MOVLW  02
0E42E:  MOVWF  x6C
0E430:  MOVLB  0
0E432:  RCALL  DDFE
0E434:  MOVLW  A0
0E436:  MOVWF  FF6
0E438:  MOVLW  25
0E43A:  MOVWF  FF7
0E43C:  MOVLW  00
0E43E:  MOVWF  FF8
0E440:  CLRF   1B
0E442:  BTFSC  FF2.7
0E444:  BSF    1B.7
0E446:  BCF    FF2.7
0E448:  MOVLW  03
0E44A:  MOVLB  A
0E44C:  MOVWF  x1C
0E44E:  MOVLB  0
0E450:  CALL   1024
0E454:  BTFSC  1B.7
0E456:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E458:  MOVLW  A4
0E45A:  MOVWF  FF6
0E45C:  MOVLW  25
0E45E:  MOVWF  FF7
0E460:  MOVLW  00
0E462:  MOVWF  FF8
0E464:  CLRF   1B
0E466:  BTFSC  FF2.7
0E468:  BSF    1B.7
0E46A:  BCF    FF2.7
0E46C:  MOVLW  09
0E46E:  MOVLB  A
0E470:  MOVWF  x1C
0E472:  MOVLB  0
0E474:  CALL   1024
0E478:  BTFSC  1B.7
0E47A:  BSF    FF2.7
0E47C:  MOVLW  10
0E47E:  MOVWF  FE9
0E480:  CLRF   1B
0E482:  BTFSC  FF2.7
0E484:  BSF    1B.7
0E486:  BCF    FF2.7
0E488:  MOVFF  7C4,A1D
0E48C:  MOVFF  7C3,A1C
0E490:  CALL   11A6
0E494:  BTFSC  1B.7
0E496:  BSF    FF2.7
0E498:  MOVLW  B0
0E49A:  MOVWF  FF6
0E49C:  MOVLW  25
0E49E:  MOVWF  FF7
0E4A0:  MOVLW  00
0E4A2:  MOVWF  FF8
0E4A4:  CLRF   1B
0E4A6:  BTFSC  FF2.7
0E4A8:  BSF    1B.7
0E4AA:  BCF    FF2.7
0E4AC:  MOVLW  05
0E4AE:  MOVLB  A
0E4B0:  MOVWF  x1C
0E4B2:  MOVLB  0
0E4B4:  CALL   1024
0E4B8:  BTFSC  1B.7
0E4BA:  BSF    FF2.7
0E4BC:  MOVLW  10
0E4BE:  MOVWF  FE9
0E4C0:  MOVFF  7B6,8D2
0E4C4:  MOVFF  7B5,8D1
0E4C8:  CALL   8F40
0E4CC:  MOVLW  0D
0E4CE:  BTFSS  F9E.4
0E4D0:  BRA    E4CE
0E4D2:  MOVWF  FAD
0E4D4:  MOVLW  0A
0E4D6:  BTFSS  F9E.4
0E4D8:  BRA    E4D6
0E4DA:  MOVWF  FAD
....................       RTC_display(); 
0E4DC:  RCALL  DEFA
....................       if (RTCfmt == 0) 
0E4DE:  MOVF   4F,F
0E4E0:  BTFSS  FD8.2
0E4E2:  BRA    E5E8
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E4E4:  MOVLW  BC
0E4E6:  MOVWF  FF6
0E4E8:  MOVLW  25
0E4EA:  MOVWF  FF7
0E4EC:  MOVLW  00
0E4EE:  MOVWF  FF8
0E4F0:  CLRF   1B
0E4F2:  BTFSC  FF2.7
0E4F4:  BSF    1B.7
0E4F6:  BCF    FF2.7
0E4F8:  MOVLW  05
0E4FA:  MOVLB  A
0E4FC:  MOVWF  x1C
0E4FE:  MOVLB  0
0E500:  CALL   1024
0E504:  BTFSC  1B.7
0E506:  BSF    FF2.7
0E508:  CLRF   1B
0E50A:  BTFSC  FF2.7
0E50C:  BSF    1B.7
0E50E:  BCF    FF2.7
0E510:  MOVFF  73A,A1C
0E514:  MOVLW  01
0E516:  MOVLB  A
0E518:  MOVWF  x1D
0E51A:  MOVLB  0
0E51C:  CALL   0FA6
0E520:  BTFSC  1B.7
0E522:  BSF    FF2.7
0E524:  MOVLW  2F
0E526:  BTFSS  F9E.4
0E528:  BRA    E526
0E52A:  MOVWF  FAD
0E52C:  CLRF   1B
0E52E:  BTFSC  FF2.7
0E530:  BSF    1B.7
0E532:  BCF    FF2.7
0E534:  MOVFF  73B,A1C
0E538:  MOVLW  01
0E53A:  MOVLB  A
0E53C:  MOVWF  x1D
0E53E:  MOVLB  0
0E540:  CALL   0FA6
0E544:  BTFSC  1B.7
0E546:  BSF    FF2.7
0E548:  MOVLW  2F
0E54A:  BTFSS  F9E.4
0E54C:  BRA    E54A
0E54E:  MOVWF  FAD
0E550:  CLRF   1B
0E552:  BTFSC  FF2.7
0E554:  BSF    1B.7
0E556:  BCF    FF2.7
0E558:  MOVFF  73C,A1C
0E55C:  MOVLW  01
0E55E:  MOVLB  A
0E560:  MOVWF  x1D
0E562:  MOVLB  0
0E564:  CALL   0FA6
0E568:  BTFSC  1B.7
0E56A:  BSF    FF2.7
0E56C:  MOVLW  20
0E56E:  BTFSS  F9E.4
0E570:  BRA    E56E
0E572:  MOVWF  FAD
0E574:  CLRF   1B
0E576:  BTFSC  FF2.7
0E578:  BSF    1B.7
0E57A:  BCF    FF2.7
0E57C:  MOVFF  73D,A1C
0E580:  MOVLW  01
0E582:  MOVLB  A
0E584:  MOVWF  x1D
0E586:  MOVLB  0
0E588:  CALL   0FA6
0E58C:  BTFSC  1B.7
0E58E:  BSF    FF2.7
0E590:  MOVLW  3A
0E592:  BTFSS  F9E.4
0E594:  BRA    E592
0E596:  MOVWF  FAD
0E598:  CLRF   1B
0E59A:  BTFSC  FF2.7
0E59C:  BSF    1B.7
0E59E:  BCF    FF2.7
0E5A0:  MOVFF  73E,A1C
0E5A4:  MOVLW  01
0E5A6:  MOVLB  A
0E5A8:  MOVWF  x1D
0E5AA:  MOVLB  0
0E5AC:  CALL   0FA6
0E5B0:  BTFSC  1B.7
0E5B2:  BSF    FF2.7
0E5B4:  MOVLW  3A
0E5B6:  BTFSS  F9E.4
0E5B8:  BRA    E5B6
0E5BA:  MOVWF  FAD
0E5BC:  CLRF   1B
0E5BE:  BTFSC  FF2.7
0E5C0:  BSF    1B.7
0E5C2:  BCF    FF2.7
0E5C4:  MOVFF  73F,A1C
0E5C8:  MOVLW  01
0E5CA:  MOVLB  A
0E5CC:  MOVWF  x1D
0E5CE:  MOVLB  0
0E5D0:  CALL   0FA6
0E5D4:  BTFSC  1B.7
0E5D6:  BSF    FF2.7
0E5D8:  MOVLW  0D
0E5DA:  BTFSS  F9E.4
0E5DC:  BRA    E5DA
0E5DE:  MOVWF  FAD
0E5E0:  MOVLW  0A
0E5E2:  BTFSS  F9E.4
0E5E4:  BRA    E5E2
0E5E6:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E5E8:  DECFSZ 4F,W
0E5EA:  BRA    E6F0
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E5EC:  MOVLW  E2
0E5EE:  MOVWF  FF6
0E5F0:  MOVLW  25
0E5F2:  MOVWF  FF7
0E5F4:  MOVLW  00
0E5F6:  MOVWF  FF8
0E5F8:  CLRF   1B
0E5FA:  BTFSC  FF2.7
0E5FC:  BSF    1B.7
0E5FE:  BCF    FF2.7
0E600:  MOVLW  05
0E602:  MOVLB  A
0E604:  MOVWF  x1C
0E606:  MOVLB  0
0E608:  CALL   1024
0E60C:  BTFSC  1B.7
0E60E:  BSF    FF2.7
0E610:  CLRF   1B
0E612:  BTFSC  FF2.7
0E614:  BSF    1B.7
0E616:  BCF    FF2.7
0E618:  MOVFF  73B,A1C
0E61C:  MOVLW  01
0E61E:  MOVLB  A
0E620:  MOVWF  x1D
0E622:  MOVLB  0
0E624:  CALL   0FA6
0E628:  BTFSC  1B.7
0E62A:  BSF    FF2.7
0E62C:  MOVLW  2F
0E62E:  BTFSS  F9E.4
0E630:  BRA    E62E
0E632:  MOVWF  FAD
0E634:  CLRF   1B
0E636:  BTFSC  FF2.7
0E638:  BSF    1B.7
0E63A:  BCF    FF2.7
0E63C:  MOVFF  73A,A1C
0E640:  MOVLW  01
0E642:  MOVLB  A
0E644:  MOVWF  x1D
0E646:  MOVLB  0
0E648:  CALL   0FA6
0E64C:  BTFSC  1B.7
0E64E:  BSF    FF2.7
0E650:  MOVLW  2F
0E652:  BTFSS  F9E.4
0E654:  BRA    E652
0E656:  MOVWF  FAD
0E658:  CLRF   1B
0E65A:  BTFSC  FF2.7
0E65C:  BSF    1B.7
0E65E:  BCF    FF2.7
0E660:  MOVFF  73C,A1C
0E664:  MOVLW  01
0E666:  MOVLB  A
0E668:  MOVWF  x1D
0E66A:  MOVLB  0
0E66C:  CALL   0FA6
0E670:  BTFSC  1B.7
0E672:  BSF    FF2.7
0E674:  MOVLW  20
0E676:  BTFSS  F9E.4
0E678:  BRA    E676
0E67A:  MOVWF  FAD
0E67C:  CLRF   1B
0E67E:  BTFSC  FF2.7
0E680:  BSF    1B.7
0E682:  BCF    FF2.7
0E684:  MOVFF  73D,A1C
0E688:  MOVLW  01
0E68A:  MOVLB  A
0E68C:  MOVWF  x1D
0E68E:  MOVLB  0
0E690:  CALL   0FA6
0E694:  BTFSC  1B.7
0E696:  BSF    FF2.7
0E698:  MOVLW  3A
0E69A:  BTFSS  F9E.4
0E69C:  BRA    E69A
0E69E:  MOVWF  FAD
0E6A0:  CLRF   1B
0E6A2:  BTFSC  FF2.7
0E6A4:  BSF    1B.7
0E6A6:  BCF    FF2.7
0E6A8:  MOVFF  73E,A1C
0E6AC:  MOVLW  01
0E6AE:  MOVLB  A
0E6B0:  MOVWF  x1D
0E6B2:  MOVLB  0
0E6B4:  CALL   0FA6
0E6B8:  BTFSC  1B.7
0E6BA:  BSF    FF2.7
0E6BC:  MOVLW  3A
0E6BE:  BTFSS  F9E.4
0E6C0:  BRA    E6BE
0E6C2:  MOVWF  FAD
0E6C4:  CLRF   1B
0E6C6:  BTFSC  FF2.7
0E6C8:  BSF    1B.7
0E6CA:  BCF    FF2.7
0E6CC:  MOVFF  73F,A1C
0E6D0:  MOVLW  01
0E6D2:  MOVLB  A
0E6D4:  MOVWF  x1D
0E6D6:  MOVLB  0
0E6D8:  CALL   0FA6
0E6DC:  BTFSC  1B.7
0E6DE:  BSF    FF2.7
0E6E0:  MOVLW  0D
0E6E2:  BTFSS  F9E.4
0E6E4:  BRA    E6E2
0E6E6:  MOVWF  FAD
0E6E8:  MOVLW  0A
0E6EA:  BTFSS  F9E.4
0E6EC:  BRA    E6EA
0E6EE:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0E6F0:  RCALL  E084
....................       RTC_display_alarm(); 
0E6F2:  RCALL  E15A
....................    } 
0E6F4:  GOTO   EF08 (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0E6F8:  DECFSZ 48,W
0E6FA:  BRA    E9D2
0E6FC:  MOVF   49,F
0E6FE:  BTFSS  FD8.2
0E700:  BRA    E9D2
0E702:  MOVF   4A,F
0E704:  BTFSS  FD8.2
0E706:  BRA    E9D2
0E708:  MOVF   4B,F
0E70A:  BTFSS  FD8.2
0E70C:  BRA    E9D2
....................       v_supply = read_supply(); 
0E70E:  CALL   5090
0E712:  MOVFF  02,867
0E716:  MOVFF  01,866
....................        
....................       RTC_reset_HT(); 
0E71A:  CALL   344E
....................       RTC_read(); 
0E71E:  CALL   32E0
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0E722:  MOVLW  41
0E724:  BTFSS  F9E.4
0E726:  BRA    E724
0E728:  MOVWF  FAD
0E72A:  MOVLW  10
0E72C:  MOVWF  FE9
0E72E:  CLRF   1B
0E730:  BTFSC  FF2.7
0E732:  BSF    1B.7
0E734:  BCF    FF2.7
0E736:  MOVFF  2A,A1D
0E73A:  MOVFF  29,A1C
0E73E:  CALL   11A6
0E742:  BTFSC  1B.7
0E744:  BSF    FF2.7
0E746:  MOVLW  20
0E748:  BTFSS  F9E.4
0E74A:  BRA    E748
0E74C:  MOVWF  FAD
0E74E:  MOVLW  49
0E750:  BTFSS  F9E.4
0E752:  BRA    E750
0E754:  MOVWF  FAD
0E756:  MOVLW  10
0E758:  MOVWF  FE9
0E75A:  CLRF   1B
0E75C:  BTFSC  FF2.7
0E75E:  BSF    1B.7
0E760:  BCF    FF2.7
0E762:  MOVFF  24,A1D
0E766:  MOVFF  23,A1C
0E76A:  CALL   11A6
0E76E:  BTFSC  1B.7
0E770:  BSF    FF2.7
0E772:  MOVLW  20
0E774:  BTFSS  F9E.4
0E776:  BRA    E774
0E778:  MOVWF  FAD
0E77A:  MOVLW  4C
0E77C:  BTFSS  F9E.4
0E77E:  BRA    E77C
0E780:  MOVWF  FAD
0E782:  MOVLW  10
0E784:  MOVWF  FE9
0E786:  CLRF   1B
0E788:  BTFSC  FF2.7
0E78A:  BSF    1B.7
0E78C:  BCF    FF2.7
0E78E:  MOVFF  2C,A1D
0E792:  MOVFF  2B,A1C
0E796:  CALL   11A6
0E79A:  BTFSC  1B.7
0E79C:  BSF    FF2.7
0E79E:  MOVLW  20
0E7A0:  BTFSS  F9E.4
0E7A2:  BRA    E7A0
0E7A4:  MOVWF  FAD
0E7A6:  MOVLW  51
0E7A8:  BTFSS  F9E.4
0E7AA:  BRA    E7A8
0E7AC:  MOVWF  FAD
0E7AE:  MOVLW  10
0E7B0:  MOVWF  FE9
0E7B2:  CLRF   1B
0E7B4:  BTFSC  FF2.7
0E7B6:  BSF    1B.7
0E7B8:  BCF    FF2.7
0E7BA:  MOVFF  2E,A1D
0E7BE:  MOVFF  2D,A1C
0E7C2:  CALL   11A6
0E7C6:  BTFSC  1B.7
0E7C8:  BSF    FF2.7
0E7CA:  MOVLW  20
0E7CC:  BTFSS  F9E.4
0E7CE:  BRA    E7CC
0E7D0:  MOVWF  FAD
0E7D2:  MOVLW  53
0E7D4:  BTFSS  F9E.4
0E7D6:  BRA    E7D4
0E7D8:  MOVWF  FAD
0E7DA:  MOVLW  10
0E7DC:  MOVWF  FE9
0E7DE:  CLRF   1B
0E7E0:  BTFSC  FF2.7
0E7E2:  BSF    1B.7
0E7E4:  BCF    FF2.7
0E7E6:  MOVFF  22,A1D
0E7EA:  MOVFF  21,A1C
0E7EE:  CALL   11A6
0E7F2:  BTFSC  1B.7
0E7F4:  BSF    FF2.7
0E7F6:  MOVLW  20
0E7F8:  BTFSS  F9E.4
0E7FA:  BRA    E7F8
0E7FC:  MOVWF  FAD
0E7FE:  MOVLW  04
0E800:  MOVWF  FE9
0E802:  MOVLB  8
0E804:  CLRF   x6B
0E806:  CLRF   x6A
0E808:  MOVFF  867,869
0E80C:  MOVFF  866,868
0E810:  MOVLW  02
0E812:  MOVWF  x6C
0E814:  MOVLB  0
0E816:  CALL   DDFE
0E81A:  MOVLW  26
0E81C:  MOVWF  FF6
0E81E:  MOVLW  26
0E820:  MOVWF  FF7
0E822:  MOVLW  00
0E824:  MOVWF  FF8
0E826:  CLRF   1B
0E828:  BTFSC  FF2.7
0E82A:  BSF    1B.7
0E82C:  BCF    FF2.7
0E82E:  MOVLW  03
0E830:  MOVLB  A
0E832:  MOVWF  x1C
0E834:  MOVLB  0
0E836:  CALL   1024
0E83A:  BTFSC  1B.7
0E83C:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E83E:  MOVLW  2A
0E840:  MOVWF  FF6
0E842:  MOVLW  26
0E844:  MOVWF  FF7
0E846:  MOVLW  00
0E848:  MOVWF  FF8
0E84A:  CLRF   1B
0E84C:  BTFSC  FF2.7
0E84E:  BSF    1B.7
0E850:  BCF    FF2.7
0E852:  MOVLW  09
0E854:  MOVLB  A
0E856:  MOVWF  x1C
0E858:  MOVLB  0
0E85A:  CALL   1024
0E85E:  BTFSC  1B.7
0E860:  BSF    FF2.7
0E862:  MOVLW  10
0E864:  MOVWF  FE9
0E866:  CLRF   1B
0E868:  BTFSC  FF2.7
0E86A:  BSF    1B.7
0E86C:  BCF    FF2.7
0E86E:  MOVFF  7C4,A1D
0E872:  MOVFF  7C3,A1C
0E876:  CALL   11A6
0E87A:  BTFSC  1B.7
0E87C:  BSF    FF2.7
0E87E:  MOVLW  36
0E880:  MOVWF  FF6
0E882:  MOVLW  26
0E884:  MOVWF  FF7
0E886:  MOVLW  00
0E888:  MOVWF  FF8
0E88A:  CLRF   1B
0E88C:  BTFSC  FF2.7
0E88E:  BSF    1B.7
0E890:  BCF    FF2.7
0E892:  MOVLW  05
0E894:  MOVLB  A
0E896:  MOVWF  x1C
0E898:  MOVLB  0
0E89A:  CALL   1024
0E89E:  BTFSC  1B.7
0E8A0:  BSF    FF2.7
0E8A2:  MOVLW  10
0E8A4:  MOVWF  FE9
0E8A6:  MOVFF  7B6,8D2
0E8AA:  MOVFF  7B5,8D1
0E8AE:  CALL   8F40
0E8B2:  MOVLW  0D
0E8B4:  BTFSS  F9E.4
0E8B6:  BRA    E8B4
0E8B8:  MOVWF  FAD
0E8BA:  MOVLW  0A
0E8BC:  BTFSS  F9E.4
0E8BE:  BRA    E8BC
0E8C0:  MOVWF  FAD
....................       RTC_display(); 
0E8C2:  CALL   DEFA
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E8C6:  MOVLW  42
0E8C8:  MOVWF  FF6
0E8CA:  MOVLW  26
0E8CC:  MOVWF  FF7
0E8CE:  MOVLW  00
0E8D0:  MOVWF  FF8
0E8D2:  CLRF   1B
0E8D4:  BTFSC  FF2.7
0E8D6:  BSF    1B.7
0E8D8:  BCF    FF2.7
0E8DA:  MOVLW  05
0E8DC:  MOVLB  A
0E8DE:  MOVWF  x1C
0E8E0:  MOVLB  0
0E8E2:  CALL   1024
0E8E6:  BTFSC  1B.7
0E8E8:  BSF    FF2.7
0E8EA:  CLRF   1B
0E8EC:  BTFSC  FF2.7
0E8EE:  BSF    1B.7
0E8F0:  BCF    FF2.7
0E8F2:  MOVFF  73A,A1C
0E8F6:  MOVLW  01
0E8F8:  MOVLB  A
0E8FA:  MOVWF  x1D
0E8FC:  MOVLB  0
0E8FE:  CALL   0FA6
0E902:  BTFSC  1B.7
0E904:  BSF    FF2.7
0E906:  MOVLW  2F
0E908:  BTFSS  F9E.4
0E90A:  BRA    E908
0E90C:  MOVWF  FAD
0E90E:  CLRF   1B
0E910:  BTFSC  FF2.7
0E912:  BSF    1B.7
0E914:  BCF    FF2.7
0E916:  MOVFF  73B,A1C
0E91A:  MOVLW  01
0E91C:  MOVLB  A
0E91E:  MOVWF  x1D
0E920:  MOVLB  0
0E922:  CALL   0FA6
0E926:  BTFSC  1B.7
0E928:  BSF    FF2.7
0E92A:  MOVLW  2F
0E92C:  BTFSS  F9E.4
0E92E:  BRA    E92C
0E930:  MOVWF  FAD
0E932:  CLRF   1B
0E934:  BTFSC  FF2.7
0E936:  BSF    1B.7
0E938:  BCF    FF2.7
0E93A:  MOVFF  73C,A1C
0E93E:  MOVLW  01
0E940:  MOVLB  A
0E942:  MOVWF  x1D
0E944:  MOVLB  0
0E946:  CALL   0FA6
0E94A:  BTFSC  1B.7
0E94C:  BSF    FF2.7
0E94E:  MOVLW  20
0E950:  BTFSS  F9E.4
0E952:  BRA    E950
0E954:  MOVWF  FAD
0E956:  CLRF   1B
0E958:  BTFSC  FF2.7
0E95A:  BSF    1B.7
0E95C:  BCF    FF2.7
0E95E:  MOVFF  73D,A1C
0E962:  MOVLW  01
0E964:  MOVLB  A
0E966:  MOVWF  x1D
0E968:  MOVLB  0
0E96A:  CALL   0FA6
0E96E:  BTFSC  1B.7
0E970:  BSF    FF2.7
0E972:  MOVLW  3A
0E974:  BTFSS  F9E.4
0E976:  BRA    E974
0E978:  MOVWF  FAD
0E97A:  CLRF   1B
0E97C:  BTFSC  FF2.7
0E97E:  BSF    1B.7
0E980:  BCF    FF2.7
0E982:  MOVFF  73E,A1C
0E986:  MOVLW  01
0E988:  MOVLB  A
0E98A:  MOVWF  x1D
0E98C:  MOVLB  0
0E98E:  CALL   0FA6
0E992:  BTFSC  1B.7
0E994:  BSF    FF2.7
0E996:  MOVLW  3A
0E998:  BTFSS  F9E.4
0E99A:  BRA    E998
0E99C:  MOVWF  FAD
0E99E:  CLRF   1B
0E9A0:  BTFSC  FF2.7
0E9A2:  BSF    1B.7
0E9A4:  BCF    FF2.7
0E9A6:  MOVFF  73F,A1C
0E9AA:  MOVLW  01
0E9AC:  MOVLB  A
0E9AE:  MOVWF  x1D
0E9B0:  MOVLB  0
0E9B2:  CALL   0FA6
0E9B6:  BTFSC  1B.7
0E9B8:  BSF    FF2.7
0E9BA:  MOVLW  0D
0E9BC:  BTFSS  F9E.4
0E9BE:  BRA    E9BC
0E9C0:  MOVWF  FAD
0E9C2:  MOVLW  0A
0E9C4:  BTFSS  F9E.4
0E9C6:  BRA    E9C4
0E9C8:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0E9CA:  CALL   E084
....................       RTC_display_alarm(); 
0E9CE:  CALL   E15A
....................    } 
0E9D2:  GOTO   EF08 (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0EC60:  DECFSZ 48,W
0EC62:  BRA    EEC8
0EC64:  MOVF   49,F
0EC66:  BTFSS  FD8.2
0EC68:  BRA    EEC8
0EC6A:  MOVF   4A,F
0EC6C:  BTFSS  FD8.2
0EC6E:  BRA    EEC8
0EC70:  MOVF   4B,F
0EC72:  BTFSS  FD8.2
0EC74:  BRA    EEC8
....................       v_supply = read_supply(); 
0EC76:  CALL   5090
0EC7A:  MOVFF  02,867
0EC7E:  MOVFF  01,866
....................        
....................       RTC_reset_HT(); 
0EC82:  CALL   344E
....................       RTC_read(); 
0EC86:  CALL   32E0
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0EC8A:  MOVLW  49
0EC8C:  BTFSS  F9E.4
0EC8E:  BRA    EC8C
0EC90:  MOVWF  FAD
0EC92:  MOVLW  10
0EC94:  MOVWF  FE9
0EC96:  CLRF   1B
0EC98:  BTFSC  FF2.7
0EC9A:  BSF    1B.7
0EC9C:  BCF    FF2.7
0EC9E:  MOVFF  24,A1D
0ECA2:  MOVFF  23,A1C
0ECA6:  CALL   11A6
0ECAA:  BTFSC  1B.7
0ECAC:  BSF    FF2.7
0ECAE:  MOVLW  20
0ECB0:  BTFSS  F9E.4
0ECB2:  BRA    ECB0
0ECB4:  MOVWF  FAD
0ECB6:  MOVLW  4E
0ECB8:  BTFSS  F9E.4
0ECBA:  BRA    ECB8
0ECBC:  MOVWF  FAD
0ECBE:  MOVLW  10
0ECC0:  MOVWF  FE9
0ECC2:  CLRF   1B
0ECC4:  BTFSC  FF2.7
0ECC6:  BSF    1B.7
0ECC8:  BCF    FF2.7
0ECCA:  MOVFF  22,A1D
0ECCE:  MOVFF  21,A1C
0ECD2:  CALL   11A6
0ECD6:  BTFSC  1B.7
0ECD8:  BSF    FF2.7
0ECDA:  MOVLW  2F
0ECDC:  BTFSS  F9E.4
0ECDE:  BRA    ECDC
0ECE0:  MOVWF  FAD
0ECE2:  MOVLW  10
0ECE4:  MOVWF  FE9
0ECE6:  CLRF   1B
0ECE8:  BTFSC  FF2.7
0ECEA:  BSF    1B.7
0ECEC:  BCF    FF2.7
0ECEE:  MOVFF  28,A1D
0ECF2:  MOVFF  27,A1C
0ECF6:  CALL   11A6
0ECFA:  BTFSC  1B.7
0ECFC:  BSF    FF2.7
0ECFE:  MOVLW  20
0ED00:  BTFSS  F9E.4
0ED02:  BRA    ED00
0ED04:  MOVWF  FAD
0ED06:  MOVLW  50
0ED08:  BTFSS  F9E.4
0ED0A:  BRA    ED08
0ED0C:  MOVWF  FAD
0ED0E:  MOVLW  10
0ED10:  MOVWF  FE9
0ED12:  CLRF   1B
0ED14:  BTFSC  FF2.7
0ED16:  BSF    1B.7
0ED18:  BCF    FF2.7
0ED1A:  MOVFF  2E,A1D
0ED1E:  MOVFF  2D,A1C
0ED22:  CALL   11A6
0ED26:  BTFSC  1B.7
0ED28:  BSF    FF2.7
0ED2A:  MOVLW  20
0ED2C:  BTFSS  F9E.4
0ED2E:  BRA    ED2C
0ED30:  MOVWF  FAD
0ED32:  MOVLW  04
0ED34:  MOVWF  FE9
0ED36:  MOVLB  8
0ED38:  CLRF   x6B
0ED3A:  CLRF   x6A
0ED3C:  MOVFF  867,869
0ED40:  MOVFF  866,868
0ED44:  MOVLW  02
0ED46:  MOVWF  x6C
0ED48:  MOVLB  0
0ED4A:  CALL   DDFE
0ED4E:  MOVLW  80
0ED50:  MOVWF  FF6
0ED52:  MOVLW  26
0ED54:  MOVWF  FF7
0ED56:  MOVLW  00
0ED58:  MOVWF  FF8
0ED5A:  CLRF   1B
0ED5C:  BTFSC  FF2.7
0ED5E:  BSF    1B.7
0ED60:  BCF    FF2.7
0ED62:  MOVLW  03
0ED64:  MOVLB  A
0ED66:  MOVWF  x1C
0ED68:  MOVLB  0
0ED6A:  CALL   1024
0ED6E:  BTFSC  1B.7
0ED70:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0ED72:  MOVLW  84
0ED74:  MOVWF  FF6
0ED76:  MOVLW  26
0ED78:  MOVWF  FF7
0ED7A:  MOVLW  00
0ED7C:  MOVWF  FF8
0ED7E:  CLRF   1B
0ED80:  BTFSC  FF2.7
0ED82:  BSF    1B.7
0ED84:  BCF    FF2.7
0ED86:  MOVLW  09
0ED88:  MOVLB  A
0ED8A:  MOVWF  x1C
0ED8C:  MOVLB  0
0ED8E:  CALL   1024
0ED92:  BTFSC  1B.7
0ED94:  BSF    FF2.7
0ED96:  MOVLW  10
0ED98:  MOVWF  FE9
0ED9A:  MOVFF  7B6,8D2
0ED9E:  MOVFF  7B5,8D1
0EDA2:  CALL   8F40
0EDA6:  MOVLW  0D
0EDA8:  BTFSS  F9E.4
0EDAA:  BRA    EDA8
0EDAC:  MOVWF  FAD
0EDAE:  MOVLW  0A
0EDB0:  BTFSS  F9E.4
0EDB2:  BRA    EDB0
0EDB4:  MOVWF  FAD
....................       display_valve_status(); 
0EDB6:  RCALL  E9D6
....................       RTC_display(); 
0EDB8:  CALL   DEFA
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EDBC:  MOVLW  94
0EDBE:  MOVWF  FF6
0EDC0:  MOVLW  26
0EDC2:  MOVWF  FF7
0EDC4:  MOVLW  00
0EDC6:  MOVWF  FF8
0EDC8:  CLRF   1B
0EDCA:  BTFSC  FF2.7
0EDCC:  BSF    1B.7
0EDCE:  BCF    FF2.7
0EDD0:  MOVLW  05
0EDD2:  MOVLB  A
0EDD4:  MOVWF  x1C
0EDD6:  MOVLB  0
0EDD8:  CALL   1024
0EDDC:  BTFSC  1B.7
0EDDE:  BSF    FF2.7
0EDE0:  CLRF   1B
0EDE2:  BTFSC  FF2.7
0EDE4:  BSF    1B.7
0EDE6:  BCF    FF2.7
0EDE8:  MOVFF  73A,A1C
0EDEC:  MOVLW  01
0EDEE:  MOVLB  A
0EDF0:  MOVWF  x1D
0EDF2:  MOVLB  0
0EDF4:  CALL   0FA6
0EDF8:  BTFSC  1B.7
0EDFA:  BSF    FF2.7
0EDFC:  MOVLW  2F
0EDFE:  BTFSS  F9E.4
0EE00:  BRA    EDFE
0EE02:  MOVWF  FAD
0EE04:  CLRF   1B
0EE06:  BTFSC  FF2.7
0EE08:  BSF    1B.7
0EE0A:  BCF    FF2.7
0EE0C:  MOVFF  73B,A1C
0EE10:  MOVLW  01
0EE12:  MOVLB  A
0EE14:  MOVWF  x1D
0EE16:  MOVLB  0
0EE18:  CALL   0FA6
0EE1C:  BTFSC  1B.7
0EE1E:  BSF    FF2.7
0EE20:  MOVLW  2F
0EE22:  BTFSS  F9E.4
0EE24:  BRA    EE22
0EE26:  MOVWF  FAD
0EE28:  CLRF   1B
0EE2A:  BTFSC  FF2.7
0EE2C:  BSF    1B.7
0EE2E:  BCF    FF2.7
0EE30:  MOVFF  73C,A1C
0EE34:  MOVLW  01
0EE36:  MOVLB  A
0EE38:  MOVWF  x1D
0EE3A:  MOVLB  0
0EE3C:  CALL   0FA6
0EE40:  BTFSC  1B.7
0EE42:  BSF    FF2.7
0EE44:  MOVLW  20
0EE46:  BTFSS  F9E.4
0EE48:  BRA    EE46
0EE4A:  MOVWF  FAD
0EE4C:  CLRF   1B
0EE4E:  BTFSC  FF2.7
0EE50:  BSF    1B.7
0EE52:  BCF    FF2.7
0EE54:  MOVFF  73D,A1C
0EE58:  MOVLW  01
0EE5A:  MOVLB  A
0EE5C:  MOVWF  x1D
0EE5E:  MOVLB  0
0EE60:  CALL   0FA6
0EE64:  BTFSC  1B.7
0EE66:  BSF    FF2.7
0EE68:  MOVLW  3A
0EE6A:  BTFSS  F9E.4
0EE6C:  BRA    EE6A
0EE6E:  MOVWF  FAD
0EE70:  CLRF   1B
0EE72:  BTFSC  FF2.7
0EE74:  BSF    1B.7
0EE76:  BCF    FF2.7
0EE78:  MOVFF  73E,A1C
0EE7C:  MOVLW  01
0EE7E:  MOVLB  A
0EE80:  MOVWF  x1D
0EE82:  MOVLB  0
0EE84:  CALL   0FA6
0EE88:  BTFSC  1B.7
0EE8A:  BSF    FF2.7
0EE8C:  MOVLW  3A
0EE8E:  BTFSS  F9E.4
0EE90:  BRA    EE8E
0EE92:  MOVWF  FAD
0EE94:  CLRF   1B
0EE96:  BTFSC  FF2.7
0EE98:  BSF    1B.7
0EE9A:  BCF    FF2.7
0EE9C:  MOVFF  73F,A1C
0EEA0:  MOVLW  01
0EEA2:  MOVLB  A
0EEA4:  MOVWF  x1D
0EEA6:  MOVLB  0
0EEA8:  CALL   0FA6
0EEAC:  BTFSC  1B.7
0EEAE:  BSF    FF2.7
0EEB0:  MOVLW  0D
0EEB2:  BTFSS  F9E.4
0EEB4:  BRA    EEB2
0EEB6:  MOVWF  FAD
0EEB8:  MOVLW  0A
0EEBA:  BTFSS  F9E.4
0EEBC:  BRA    EEBA
0EEBE:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EEC0:  CALL   E084
....................       RTC_display_alarm(); 
0EEC4:  CALL   E15A
....................    } 
0EEC8:  GOTO   EF08 (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0EECC:  MOVF   2F,W
0EECE:  MOVWF  00
0EED0:  MOVF   30,W
0EED2:  MOVWF  03
0EED4:  BNZ   EEDA
0EED6:  MOVF   00,F
0EED8:  BZ    EEFA
0EEDA:  MOVF   03,W
0EEDC:  BNZ   EEE4
0EEDE:  MOVLW  01
0EEE0:  SUBWF  00,W
0EEE2:  BZ    EF00
0EEE4:  MOVF   03,W
0EEE6:  BNZ   EEEE
0EEE8:  MOVLW  03
0EEEA:  SUBWF  00,W
0EEEC:  BZ    EF00
0EEEE:  MOVF   03,W
0EEF0:  BNZ   EEF8
0EEF2:  MOVLW  02
0EEF4:  SUBWF  00,W
0EEF6:  BZ    EF06
0EEF8:  BRA    EF08
....................       case ECO : commandHe(); 
0EEFA:  GOTO   E2D4
....................          break; 
0EEFE:  BRA    EF08
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0EF00:  GOTO   E6F8
....................          break; 
0EF04:  BRA    EF08
....................       case AWS : commandHa(); 
0EF06:  BRA    EC60
....................          break;          
....................    } 
0EF08:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0EF0C:  MOVF   48,F
0EF0E:  BNZ   EF1C
0EF10:  MOVF   49,F
0EF12:  BNZ   EF1C
0EF14:  MOVF   4A,F
0EF16:  BNZ   EF1C
0EF18:  MOVF   4B,F
0EF1A:  BZ    EF50
0EF1C:  MOVF   4B,F
0EF1E:  BNZ   EF50
0EF20:  MOVF   4A,F
0EF22:  BNZ   EF50
0EF24:  MOVF   49,W
0EF26:  SUBLW  FD
0EF28:  BNC   EF50
0EF2A:  BNZ   EF32
0EF2C:  MOVF   48,W
0EF2E:  SUBLW  20
0EF30:  BNC   EF50
....................       nv_interval = arg; 
0EF32:  MOVFF  49,24
0EF36:  MOVFF  48,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0EF3A:  MOVLW  14
0EF3C:  MOVLB  8
0EF3E:  MOVWF  xCF
0EF40:  MOVFF  24,8D1
0EF44:  MOVFF  23,8D0
0EF48:  MOVLB  0
0EF4A:  CALL   4F68
....................    } 
0EF4E:  BRA    EF54
....................    else cmd_arg(); 
0EF50:  CALL   AF88
0EF54:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0EF58:  MOVF   4B,F
0EF5A:  BNZ   EF8A
0EF5C:  MOVF   4A,F
0EF5E:  BNZ   EF8A
0EF60:  MOVF   49,W
0EF62:  SUBLW  27
0EF64:  BNC   EF8A
0EF66:  BNZ   EF6E
0EF68:  MOVF   48,W
0EF6A:  SUBLW  0F
0EF6C:  BNC   EF8A
....................       nv_serial = arg; 
0EF6E:  MOVFF  49,26
0EF72:  MOVFF  48,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0EF76:  MOVLB  8
0EF78:  CLRF   xCF
0EF7A:  MOVFF  26,8D1
0EF7E:  MOVFF  25,8D0
0EF82:  MOVLB  0
0EF84:  CALL   4F68
....................    } 
0EF88:  BRA    EF8E
....................    else cmd_arg(); 
0EF8A:  CALL   AF88
0EF8E:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F1B2:  MOVF   2F,F
0F1B4:  BNZ   F1E4
0F1B6:  MOVF   30,F
0F1B8:  BNZ   F1E4
....................        
....................       if (arg > 0 && arg < 3){ 
0F1BA:  MOVF   48,F
0F1BC:  BNZ   F1CA
0F1BE:  MOVF   49,F
0F1C0:  BNZ   F1CA
0F1C2:  MOVF   4A,F
0F1C4:  BNZ   F1CA
0F1C6:  MOVF   4B,F
0F1C8:  BZ    F1E0
0F1CA:  MOVF   4B,F
0F1CC:  BNZ   F1E0
0F1CE:  MOVF   4A,F
0F1D0:  BNZ   F1E0
0F1D2:  MOVF   49,F
0F1D4:  BNZ   F1E0
0F1D6:  MOVF   48,W
0F1D8:  SUBLW  02
0F1DA:  BNC   F1E0
....................          det_cmd(); 
0F1DC:  RCALL  F072
....................       } 
0F1DE:  BRA    F1E4
....................       else cmd_arg(); 
0F1E0:  CALL   AF88
....................        
....................    } 
0F1E4:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
10096:  MOVF   4B,F
10098:  BNZ   10104
1009A:  MOVF   4A,F
1009C:  BNZ   10104
1009E:  MOVF   49,W
100A0:  SUBLW  0F
100A2:  BNC   10104
....................       switch (nv_det_type){ 
100A4:  MOVFF  45,00
100A8:  MOVF   46,W
100AA:  MOVWF  03
100AC:  BNZ   100B4
100AE:  MOVLW  01
100B0:  SUBWF  00,W
100B2:  BZ    100CA
100B4:  MOVF   03,W
100B6:  BNZ   100BE
100B8:  MOVLW  02
100BA:  SUBWF  00,W
100BC:  BZ    100D0
100BE:  MOVF   03,W
100C0:  BNZ   100C8
100C2:  MOVLW  03
100C4:  SUBWF  00,W
100C6:  BZ    100EE
100C8:  BRA    10102
....................          case 1 : det_cmd(); 
100CA:  CALL   F072
....................             break; 
100CE:  BRA    10102
....................          case 2 : DAC_set(1,arg); 
100D0:  MOVFF  49,867
100D4:  MOVFF  48,866
100D8:  MOVLW  01
100DA:  MOVLB  8
100DC:  MOVWF  xB4
100DE:  MOVFF  49,8B6
100E2:  MOVFF  48,8B5
100E6:  MOVLB  0
100E8:  CALL   F1E8
....................             break; 
100EC:  BRA    10102
....................          case 3 : set_LED(arg); 
100EE:  MOVFF  49,867
100F2:  MOVFF  48,866
100F6:  MOVFF  49,8A7
100FA:  MOVFF  48,8A6
100FE:  CALL   F528
....................             break; 
....................       } 
....................    } 
10102:  BRA    10162
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
10104:  MOVF   4B,F
10106:  BNZ   1011C
10108:  MOVF   4A,F
1010A:  BNZ   1011C
1010C:  MOVF   49,W
1010E:  SUBLW  4D
10110:  BC    10146
10112:  XORLW  FF
10114:  BNZ   1011C
10116:  MOVF   48,W
10118:  SUBLW  20
1011A:  BC    10146
1011C:  MOVF   4B,F
1011E:  BNZ   10146
10120:  MOVF   4A,F
10122:  BNZ   10146
10124:  MOVF   49,W
10126:  SUBLW  4E
10128:  BNC   10146
1012A:  BNZ   10132
1012C:  MOVF   48,W
1012E:  SUBLW  22
10130:  BNC   10146
10132:  MOVFF  49,867
10136:  MOVFF  48,866
1013A:  MOVFF  49,869
1013E:  MOVFF  48,868
10142:  BRA    FEC8
10144:  BRA    10162
....................    else if(arg==30001)set_LED_test(); 
10146:  MOVF   48,W
10148:  SUBLW  31
1014A:  BNZ   1015E
1014C:  MOVF   49,W
1014E:  SUBLW  75
10150:  BNZ   1015E
10152:  MOVF   4A,F
10154:  BNZ   1015E
10156:  MOVF   4B,F
10158:  BNZ   1015E
1015A:  BRA    10000
1015C:  BRA    10162
....................    else cmd_arg(); 
1015E:  CALL   AF88
10162:  GOTO   FFEA (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
*
0FF84:  MOVF   4B,F
0FF86:  BNZ   FFB8
0FF88:  MOVF   4A,F
0FF8A:  BNZ   FFB8
0FF8C:  MOVF   49,W
0FF8E:  SUBLW  57
0FF90:  BNC   FFB8
0FF92:  BNZ   FF9A
0FF94:  MOVF   48,W
0FF96:  SUBLW  E4
0FF98:  BNC   FFB8
....................       nv_volume = arg; 
0FF9A:  MOVFF  49,2C
0FF9E:  MOVFF  48,2B
....................       write16(ADDR_VOLUME, nv_volume); 
0FFA2:  MOVLW  22
0FFA4:  MOVLB  8
0FFA6:  MOVWF  xCF
0FFA8:  MOVFF  2C,8D1
0FFAC:  MOVFF  2B,8D0
0FFB0:  MOVLB  0
0FFB2:  CALL   4F68
....................    } 
0FFB6:  BRA    FFBC
....................    else cmd_arg(); 
0FFB8:  CALL   AF88
0FFBC:  GOTO   FFEA (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
0FFC0:  MOVF   2F,W
0FFC2:  MOVWF  00
0FFC4:  MOVF   30,W
0FFC6:  MOVWF  03
0FFC8:  BNZ   FFCE
0FFCA:  MOVF   00,F
0FFCC:  BZ    FFE4
0FFCE:  MOVF   03,W
0FFD0:  BNZ   FFD8
0FFD2:  MOVLW  01
0FFD4:  SUBWF  00,W
0FFD6:  BZ    FFE8
0FFD8:  MOVF   03,W
0FFDA:  BNZ   FFE2
0FFDC:  MOVLW  03
0FFDE:  SUBWF  00,W
0FFE0:  BZ    FFE8
0FFE2:  BRA    FFEA
....................       case ECO : commandLe(); 
0FFE4:  BRA    10096
....................          break; 
0FFE6:  BRA    FFEA
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
0FFE8:  BRA    FF84
....................          break; 
....................    } 
0FFEA:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
1692E:  CALL   295C
....................     
....................    user_quit = FALSE; 
16932:  CLRF   50
....................     
....................    if(arg > 0 && arg < 21) 
16934:  MOVF   48,F
16936:  BNZ   16944
16938:  MOVF   49,F
1693A:  BNZ   16944
1693C:  MOVF   4A,F
1693E:  BNZ   16944
16940:  MOVF   4B,F
16942:  BZ    169C0
16944:  MOVF   4B,F
16946:  BNZ   169C0
16948:  MOVF   4A,F
1694A:  BNZ   169C0
1694C:  MOVF   49,F
1694E:  BNZ   169C0
16950:  MOVF   48,W
16952:  SUBLW  14
16954:  BNC   169C0
....................    { 
....................       macro = arg; 
16956:  MOVFF  48,867
....................       switch(nv_product){ 
1695A:  MOVFF  2F,00
1695E:  MOVF   30,W
16960:  MOVWF  03
16962:  BNZ   16968
16964:  MOVF   00,F
16966:  BZ    16988
16968:  MOVF   03,W
1696A:  BNZ   16972
1696C:  MOVLW  01
1696E:  SUBWF  00,W
16970:  BZ    16988
16972:  MOVF   03,W
16974:  BNZ   1697C
16976:  MOVLW  03
16978:  SUBWF  00,W
1697A:  BZ    16988
1697C:  MOVF   03,W
1697E:  BNZ   16986
16980:  MOVLW  02
16982:  SUBWF  00,W
16984:  BZ    169AE
16986:  BRA    169BE
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
16988:  MOVLW  01
1698A:  MOVLB  7
1698C:  ADDWF  xC3,W
1698E:  MOVLB  8
16990:  MOVWF  x68
16992:  MOVLW  00
16994:  MOVLB  7
16996:  ADDWFC xC4,W
16998:  MOVLB  8
1699A:  MOVWF  x69
1699C:  MOVFF  867,878
169A0:  MOVWF  x7A
169A2:  MOVFF  868,879
169A6:  MOVLB  0
169A8:  CALL   14F50
....................             break; 
169AC:  BRA    169BE
....................          case AWS : play_macro(macro,nv_port); 
169AE:  MOVFF  867,878
169B2:  MOVFF  2E,87A
169B6:  MOVFF  2D,879
169BA:  CALL   14F50
....................             break; 
....................       } 
....................    }    
169BE:  BRA    16A46
....................    else if (arg == 0) 
169C0:  MOVF   48,F
169C2:  BNZ   16A42
169C4:  MOVF   49,F
169C6:  BNZ   16A42
169C8:  MOVF   4A,F
169CA:  BNZ   16A42
169CC:  MOVF   4B,F
169CE:  BNZ   16A42
....................    { 
....................       //start watchdog at beginning of logging mode 
....................       //RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
169D0:  BCF    F91.0
....................       spi_write(0x89); 
169D2:  MOVF   FC9,W
169D4:  MOVLW  89
169D6:  MOVWF  FC9
169D8:  RRCF   FC7,W
169DA:  BNC   169D8
....................       spi_write(0b11111111); 
169DC:  MOVF   FC9,W
169DE:  SETF   FC9
169E0:  RRCF   FC7,W
169E2:  BNC   169E0
....................       spi_read(0x00); 
169E4:  MOVF   FC9,W
169E6:  CLRF   FC9
169E8:  RRCF   FC7,W
169EA:  BNC   169E8
....................       output_bit(RTC_CS, DISABLE); 
169EC:  BSF    F91.0
....................        
....................       MaxSamples=FALSE; 
169EE:  CLRF   34
169F0:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
169F2:  MOVLW  28
169F4:  MOVLB  8
169F6:  MOVWF  x6A
169F8:  MOVFF  33,86B
169FC:  MOVLB  0
169FE:  CALL   33AE
....................       if (LoggingReentry != TRUE) 
16A02:  MOVLB  8
16A04:  DECFSZ x66,W
16A06:  BRA    16A0A
16A08:  BRA    16A22
....................       { 
....................          nv_sample = 0; 
16A0A:  CLRF   22
16A0C:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
16A0E:  MOVLW  16
16A10:  MOVWF  xCF
16A12:  MOVFF  22,8D1
16A16:  MOVFF  21,8D0
16A1A:  MOVLB  0
16A1C:  CALL   4F68
16A20:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
16A22:  CLRF   x66
....................       nv_macro_step = 0; 
16A24:  CLRF   38
16A26:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
16A28:  MOVLW  3A
16A2A:  MOVWF  xCF
16A2C:  MOVFF  38,8D1
16A30:  MOVFF  37,8D0
16A34:  MOVLB  0
16A36:  CALL   4F68
....................       user_quit = auto_sample_ready(); 
16A3A:  BRA    1672C
16A3C:  MOVFF  01,50
....................    } 
16A40:  BRA    16A46
....................    else cmd_arg(); 
16A42:  CALL   AF88
....................     
....................    busy_clear(); 
16A46:  CALL   ADD0
16A4A:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
16A4C:  MOVF   48,F
16A4E:  BNZ   16A5C
16A50:  MOVF   49,F
16A52:  BNZ   16A5C
16A54:  MOVF   4A,F
16A56:  BNZ   16A5C
16A58:  MOVF   4B,F
16A5A:  BZ    16A90
16A5C:  MOVF   4B,F
16A5E:  BNZ   16A90
16A60:  MOVF   4A,F
16A62:  BNZ   16A90
16A64:  MOVF   49,W
16A66:  SUBLW  0D
16A68:  BNC   16A90
16A6A:  BNZ   16A72
16A6C:  MOVF   48,W
16A6E:  SUBLW  AC
16A70:  BNC   16A90
....................       nv_max_samples = arg; 
16A72:  MOVFF  49,28
16A76:  MOVFF  48,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
16A7A:  MOVLW  18
16A7C:  MOVLB  8
16A7E:  MOVWF  xCF
16A80:  MOVFF  28,8D1
16A84:  MOVFF  27,8D0
16A88:  MOVLB  0
16A8A:  CALL   4F68
....................    } 
16A8E:  BRA    16AD6
....................    else if(arg == 0) { 
16A90:  MOVF   48,F
16A92:  BNZ   16AD2
16A94:  MOVF   49,F
16A96:  BNZ   16AD2
16A98:  MOVF   4A,F
16A9A:  BNZ   16AD2
16A9C:  MOVF   4B,F
16A9E:  BNZ   16AD2
....................       nv_sample = 0; 
16AA0:  CLRF   22
16AA2:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
16AA4:  MOVLW  16
16AA6:  MOVLB  8
16AA8:  MOVWF  xCF
16AAA:  MOVFF  22,8D1
16AAE:  MOVFF  21,8D0
16AB2:  MOVLB  0
16AB4:  CALL   4F68
....................       nv_macro_step = 0; 
16AB8:  CLRF   38
16ABA:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16ABC:  MOVLW  3A
16ABE:  MOVLB  8
16AC0:  MOVWF  xCF
16AC2:  MOVFF  38,8D1
16AC6:  MOVFF  37,8D0
16ACA:  MOVLB  0
16ACC:  CALL   4F68
....................    } 
16AD0:  BRA    16AD6
....................    else cmd_arg(); 
16AD2:  CALL   AF88
16AD6:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
16BFC:  DECFSZ 48,W
16BFE:  BRA    16C18
16C00:  MOVF   49,F
16C02:  BNZ   16C18
16C04:  MOVF   4A,F
16C06:  BNZ   16C18
16C08:  MOVF   4B,F
16C0A:  BNZ   16C18
....................    { 
....................       bus_on(); 
16C0C:  CALL   CFE0
....................       open_pipe(); 
16C10:  BRA    16AF2
....................       bus_off(); 
16C12:  CALL   D004
....................    } 
16C16:  BRA    16C1C
....................    else cmd_arg(); 
16C18:  CALL   AF88
16C1C:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
16CDA:  MOVLB  7
16CDC:  DECFSZ x41,W
16CDE:  BRA    16CE2
16CE0:  CLRF   x40
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
16CE2:  MOVF   48,F
16CE4:  BNZ   16CF4
16CE6:  MOVF   49,F
16CE8:  BNZ   16CF4
16CEA:  MOVF   4A,F
16CEC:  BNZ   16CF4
16CEE:  MOVF   4B,F
16CF0:  BTFSC  FD8.2
16CF2:  BRA    16DBC
16CF4:  BCF    FD8.0
16CF6:  RLCF   x40,W
16CF8:  CLRF   03
16CFA:  ADDLW  62
16CFC:  MOVWF  FE9
16CFE:  MOVLW  07
16D00:  ADDWFC 03,W
16D02:  MOVWF  FEA
16D04:  MOVFF  FEC,03
16D08:  MOVF   FED,F
16D0A:  MOVFF  FEF,01
16D0E:  MOVF   4B,F
16D10:  BNZ   16DBC
16D12:  MOVF   4A,F
16D14:  BNZ   16DBC
16D16:  MOVF   49,W
16D18:  SUBWF  03,W
16D1A:  BNC   16DBC
16D1C:  BNZ   16D24
16D1E:  MOVF   48,W
16D20:  SUBWF  01,W
16D22:  BNC   16DBC
....................       if(e_mode[motor]==2){     // if port mode then move 
16D24:  BCF    FD8.0
16D26:  RLCF   x40,W
16D28:  CLRF   03
16D2A:  ADDLW  66
16D2C:  MOVWF  FE9
16D2E:  MOVLW  07
16D30:  ADDWFC 03,W
16D32:  MOVWF  FEA
16D34:  MOVFF  FEC,867
16D38:  MOVF   FED,F
16D3A:  MOVFF  FEF,866
16D3E:  MOVLB  8
16D40:  MOVF   x66,W
16D42:  SUBLW  02
16D44:  BNZ   16DB2
16D46:  MOVF   x67,F
16D48:  BNZ   16DB2
....................          switch (nv_product){ 
16D4A:  MOVF   2F,W
16D4C:  MOVWF  00
16D4E:  MOVF   30,W
16D50:  MOVWF  03
16D52:  MOVF   03,W
16D54:  BNZ   16D5E
16D56:  MOVF   00,F
16D58:  MOVLB  0
16D5A:  BZ    16D7C
16D5C:  MOVLB  8
16D5E:  MOVF   03,W
16D60:  BNZ   16D6C
16D62:  MOVLW  01
16D64:  SUBWF  00,W
16D66:  MOVLB  0
16D68:  BZ    16D8E
16D6A:  MOVLB  8
16D6C:  MOVF   03,W
16D6E:  BNZ   16D7A
16D70:  MOVLW  03
16D72:  SUBWF  00,W
16D74:  MOVLB  0
16D76:  BZ    16DA0
16D78:  MOVLB  8
16D7A:  BRA    16DB0
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
16D7C:  MOVLW  01
16D7E:  MOVLB  8
16D80:  MOVWF  x66
16D82:  CLRF   x67
16D84:  MOVWF  x68
16D86:  MOVLB  0
16D88:  RCALL  16C20
....................                break;             
16D8A:  MOVLB  8
16D8C:  BRA    16DB0
....................             case WMS4: command_move(0,0,1); 
16D8E:  MOVLB  8
16D90:  CLRF   x66
16D92:  CLRF   x67
16D94:  MOVLW  01
16D96:  MOVWF  x68
16D98:  MOVLB  0
16D9A:  RCALL  16C20
....................                break; 
16D9C:  MOVLB  8
16D9E:  BRA    16DB0
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
16DA0:  MOVLB  8
16DA2:  CLRF   x66
16DA4:  CLRF   x67
16DA6:  MOVLW  01
16DA8:  MOVWF  x68
16DAA:  MOVLB  0
16DAC:  RCALL  16C20
....................                break; 
16DAE:  MOVLB  8
....................          } 
....................       } 
16DB0:  BRA    16DBA
....................       else cmd_err();                           // else error 
16DB2:  MOVLB  0
16DB4:  CALL   BC4A
16DB8:  MOVLB  8
....................    } 
16DBA:  BRA    16DC4
....................    else cmd_arg(); 
16DBC:  MOVLB  0
16DBE:  CALL   AF88
16DC2:  MOVLB  8
16DC4:  MOVLB  0
16DC6:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
16DC8:  MOVF   4B,F
16DCA:  BNZ   16DF8
16DCC:  MOVF   4A,F
16DCE:  BNZ   16DF8
16DD0:  MOVF   49,F
16DD2:  BNZ   16DF8
16DD4:  MOVF   48,W
16DD6:  SUBLW  30
16DD8:  BNC   16DF8
....................       nv_port = arg; 
16DDA:  MOVFF  49,2E
16DDE:  MOVFF  48,2D
....................       write16(ADDR_PORT, nv_port); 
16DE2:  MOVLW  24
16DE4:  MOVLB  8
16DE6:  MOVWF  xCF
16DE8:  MOVFF  2E,8D1
16DEC:  MOVFF  2D,8D0
16DF0:  MOVLB  0
16DF2:  CALL   4F68
....................    } 
16DF6:  BRA    16DFC
....................    else cmd_arg(); 
16DF8:  CALL   AF88
16DFC:  GOTO   16E38 (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
16E00:  MOVF   2F,W
16E02:  MOVWF  00
16E04:  MOVF   30,W
16E06:  MOVWF  03
16E08:  BNZ   16E0E
16E0A:  MOVF   00,F
16E0C:  BZ    16E2E
16E0E:  MOVF   03,W
16E10:  BNZ   16E18
16E12:  MOVLW  01
16E14:  SUBWF  00,W
16E16:  BZ    16E32
16E18:  MOVF   03,W
16E1A:  BNZ   16E22
16E1C:  MOVLW  03
16E1E:  SUBWF  00,W
16E20:  BZ    16E32
16E22:  MOVF   03,W
16E24:  BNZ   16E2C
16E26:  MOVLW  02
16E28:  SUBWF  00,W
16E2A:  BZ    16E36
16E2C:  BRA    16E38
....................       case ECO : commandPe(); 
16E2E:  RCALL  16CDA
....................          break; 
16E30:  BRA    16E38
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
16E32:  RCALL  16CDA
....................          break; 
16E34:  BRA    16E38
....................       case AWS : commandPa(); 
16E36:  BRA    16DC8
....................          break;          
....................    } 
16E38:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
16E84:  MOVLB  4
16E86:  DECFSZ xB6,W
16E88:  BRA    16EB4
....................     
....................       if(arg<33){ 
16E8A:  MOVF   4B,F
16E8C:  BNZ   16EAC
16E8E:  MOVF   4A,F
16E90:  BNZ   16EAC
16E92:  MOVF   49,F
16E94:  BNZ   16EAC
16E96:  MOVF   48,W
16E98:  SUBLW  20
16E9A:  BNC   16EAC
....................          valve=arg;    
16E9C:  MOVFF  48,866
....................          sol_switch(valve); 
16EA0:  MOVFF  866,896
16EA4:  MOVLB  0
16EA6:  CALL   1411A
....................       }  
16EAA:  BRA    16EB2
....................       else cmd_arg(); 
16EAC:  MOVLB  0
16EAE:  CALL   AF88
....................    } 
16EB2:  BRA    16EBA
....................    else cmd_err(); 
16EB4:  MOVLB  0
16EB6:  CALL   BC4A
16EBA:  GOTO   16EEA (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
16E3C:  MOVF   48,F
16E3E:  BNZ   16E4C
16E40:  MOVF   49,F
16E42:  BNZ   16E4C
16E44:  MOVF   4A,F
16E46:  BNZ   16E4C
16E48:  MOVF   4B,F
16E4A:  BZ    16E7C
16E4C:  MOVF   4B,F
16E4E:  BNZ   16E7C
16E50:  MOVF   4A,F
16E52:  BNZ   16E7C
16E54:  MOVF   49,F
16E56:  BNZ   16E7C
16E58:  MOVF   48,W
16E5A:  SUBLW  32
16E5C:  BNC   16E7C
....................       nv_port = arg; 
16E5E:  MOVFF  49,2E
16E62:  MOVFF  48,2D
....................       write16(ADDR_SAMPLE, nv_port); 
16E66:  MOVLW  16
16E68:  MOVLB  8
16E6A:  MOVWF  xCF
16E6C:  MOVFF  2E,8D1
16E70:  MOVFF  2D,8D0
16E74:  MOVLB  0
16E76:  CALL   4F68
....................    } 
16E7A:  BRA    16E80
....................    else cmd_arg(); 
16E7C:  CALL   AF88
16E80:  GOTO   16EEA (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
16EBE:  MOVF   2F,W
16EC0:  MOVWF  00
16EC2:  MOVF   30,W
16EC4:  MOVWF  03
16EC6:  BNZ   16ECE
16EC8:  MOVLW  01
16ECA:  SUBWF  00,W
16ECC:  BZ    16EE4
16ECE:  MOVF   03,W
16ED0:  BNZ   16ED8
16ED2:  MOVLW  03
16ED4:  SUBWF  00,W
16ED6:  BZ    16EE4
16ED8:  MOVF   03,W
16EDA:  BNZ   16EE2
16EDC:  MOVLW  02
16EDE:  SUBWF  00,W
16EE0:  BZ    16EE8
16EE2:  BRA    16EEA
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
16EE4:  BRA    16E3C
....................          break; 
16EE6:  BRA    16EEA
....................       case AWS : commandQa(); 
16EE8:  BRA    16E84
....................          break;          
....................    } 
16EEA:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
16EEE:  CALL   295C
....................     
....................    nv_macro_step = 0; 
16EF2:  CLRF   38
16EF4:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
16EF6:  MOVLW  3A
16EF8:  MOVLB  8
16EFA:  MOVWF  xCF
16EFC:  MOVFF  38,8D1
16F00:  MOVFF  37,8D0
16F04:  MOVLB  0
16F06:  CALL   4F68
....................     
....................    user_quit = FALSE; 
16F0A:  CLRF   50
....................     
....................    if (arg > 0 && arg < 3501){ 
16F0C:  MOVF   48,F
16F0E:  BNZ   16F1C
16F10:  MOVF   49,F
16F12:  BNZ   16F1C
16F14:  MOVF   4A,F
16F16:  BNZ   16F1C
16F18:  MOVF   4B,F
16F1A:  BZ    16FC8
16F1C:  MOVF   4B,F
16F1E:  BNZ   16FC8
16F20:  MOVF   4A,F
16F22:  BNZ   16FC8
16F24:  MOVF   49,W
16F26:  SUBLW  0D
16F28:  BNC   16FC8
16F2A:  BNZ   16F32
16F2C:  MOVF   48,W
16F2E:  SUBLW  AC
16F30:  BNC   16FC8
....................       samples = arg; 
16F32:  MOVFF  49,868
16F36:  MOVFF  48,867
....................       user_quit = FALSE; 
16F3A:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
16F3C:  MOVLB  8
16F3E:  CLRF   x6A
16F40:  CLRF   x69
16F42:  MOVF   x6A,W
16F44:  SUBWF  x68,W
16F46:  BNC   16FC6
16F48:  BNZ   16F50
16F4A:  MOVF   x67,W
16F4C:  SUBWF  x69,W
16F4E:  BC    16FC6
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
16F50:  MOVLW  01
16F52:  ADDWF  x69,W
16F54:  MOVWF  x6B
16F56:  MOVLW  00
16F58:  ADDWFC x6A,W
16F5A:  MOVWF  x6C
16F5C:  MOVLW  BA
16F5E:  MOVWF  FF6
16F60:  MOVLW  26
16F62:  MOVWF  FF7
16F64:  MOVLW  00
16F66:  MOVWF  FF8
16F68:  CLRF   1B
16F6A:  BTFSC  FF2.7
16F6C:  BSF    1B.7
16F6E:  BCF    FF2.7
16F70:  MOVLW  05
16F72:  MOVLB  A
16F74:  MOVWF  x1C
16F76:  MOVLB  0
16F78:  CALL   1024
16F7C:  BTFSC  1B.7
16F7E:  BSF    FF2.7
16F80:  MOVLW  09
16F82:  MOVWF  FE9
16F84:  CLRF   1B
16F86:  BTFSC  FF2.7
16F88:  BSF    1B.7
16F8A:  BCF    FF2.7
16F8C:  MOVFF  86C,A1D
16F90:  MOVFF  86B,A1C
16F94:  CALL   11A6
16F98:  BTFSC  1B.7
16F9A:  BSF    FF2.7
16F9C:  MOVLW  0D
16F9E:  BTFSS  F9E.4
16FA0:  BRA    16F9E
16FA2:  MOVWF  FAD
16FA4:  MOVLW  0A
16FA6:  BTFSS  F9E.4
16FA8:  BRA    16FA6
16FAA:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
16FAC:  CALL   15B1C
16FB0:  MOVFF  01,866
....................          if (macro_cmd == ';') break; 
16FB4:  MOVLB  8
16FB6:  MOVF   x66,W
16FB8:  SUBLW  3B
16FBA:  BTFSC  FD8.2
16FBC:  BRA    16FC6
16FBE:  INCF   x69,F
16FC0:  BTFSC  FD8.2
16FC2:  INCF   x6A,F
16FC4:  BRA    16F42
16FC6:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
16FC8:  CALL   ADD0
16FCC:  GOTO   1718C (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
16FD0:  MOVF   48,F
16FD2:  BNZ   16FE0
16FD4:  MOVF   49,F
16FD6:  BNZ   16FE0
16FD8:  MOVF   4A,F
16FDA:  BNZ   16FE0
16FDC:  MOVF   4B,F
16FDE:  BZ    17024
16FE0:  MOVF   4B,F
16FE2:  BNZ   17024
16FE4:  MOVF   4A,F
16FE6:  BNZ   17024
16FE8:  MOVF   49,F
16FEA:  BNZ   17024
16FEC:  MOVF   48,W
16FEE:  SUBLW  2F
16FF0:  BNC   17024
....................       n=arg; 
16FF2:  MOVFF  48,869
....................       port=2; 
16FF6:  MOVLB  8
16FF8:  CLRF   x67
16FFA:  MOVLW  02
16FFC:  MOVWF  x66
....................       for(i=0;i<n;++i){ 
16FFE:  CLRF   x68
17000:  MOVF   x69,W
17002:  SUBWF  x68,W
17004:  BC    17020
....................          play_wms_hard_macro(port); 
17006:  MOVFF  867,86B
1700A:  MOVFF  866,86A
1700E:  MOVLB  0
17010:  CALL   D470
....................          ++port; 
17014:  MOVLB  8
17016:  INCF   x66,F
17018:  BTFSC  FD8.2
1701A:  INCF   x67,F
1701C:  INCF   x68,F
1701E:  BRA    17000
....................       } 
....................    } 
17020:  BRA    1702A
17022:  MOVLB  0
....................    else cmd_arg(); 
17024:  CALL   AF88
17028:  MOVLB  8
1702A:  MOVLB  0
1702C:  GOTO   1718C (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
17030:  CALL   295C
....................     
....................    nv_macro_step = 0; 
17034:  CLRF   38
17036:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
17038:  MOVLW  3A
1703A:  MOVLB  8
1703C:  MOVWF  xCF
1703E:  MOVFF  38,8D1
17042:  MOVFF  37,8D0
17046:  MOVLB  0
17048:  CALL   4F68
....................     
....................    user_quit = FALSE; 
1704C:  CLRF   50
....................     
....................    if (arg > 0 && arg < 241){ 
1704E:  MOVF   48,F
17050:  BNZ   17060
17052:  MOVF   49,F
17054:  BNZ   17060
17056:  MOVF   4A,F
17058:  BNZ   17060
1705A:  MOVF   4B,F
1705C:  BTFSC  FD8.2
1705E:  BRA    1714C
17060:  MOVF   4B,F
17062:  BTFSS  FD8.2
17064:  BRA    1714C
17066:  MOVF   4A,F
17068:  BTFSS  FD8.2
1706A:  BRA    1714C
1706C:  MOVF   49,F
1706E:  BTFSS  FD8.2
17070:  BRA    1714C
17072:  MOVF   48,W
17074:  SUBLW  F0
17076:  BNC   1714C
....................       samples = arg; 
17078:  MOVFF  49,868
1707C:  MOVFF  48,867
....................       user_quit = FALSE; 
17080:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
17082:  MOVLB  8
17084:  CLRF   x6A
17086:  CLRF   x69
17088:  MOVF   x6A,W
1708A:  SUBWF  x68,W
1708C:  BNC   1714A
1708E:  BNZ   17096
17090:  MOVF   x67,W
17092:  SUBWF  x69,W
17094:  BC    1714A
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
17096:  MOVLW  01
17098:  ADDWF  x69,W
1709A:  MOVWF  x6B
1709C:  MOVLW  00
1709E:  ADDWFC x6A,W
170A0:  MOVWF  x6C
170A2:  MOVLW  C8
170A4:  MOVWF  FF6
170A6:  MOVLW  26
170A8:  MOVWF  FF7
170AA:  MOVLW  00
170AC:  MOVWF  FF8
170AE:  CLRF   1B
170B0:  BTFSC  FF2.7
170B2:  BSF    1B.7
170B4:  BCF    FF2.7
170B6:  MOVLW  05
170B8:  MOVLB  A
170BA:  MOVWF  x1C
170BC:  MOVLB  0
170BE:  CALL   1024
170C2:  BTFSC  1B.7
170C4:  BSF    FF2.7
170C6:  MOVLW  09
170C8:  MOVWF  FE9
170CA:  CLRF   1B
170CC:  BTFSC  FF2.7
170CE:  BSF    1B.7
170D0:  BCF    FF2.7
170D2:  MOVFF  86C,A1D
170D6:  MOVFF  86B,A1C
170DA:  CALL   11A6
170DE:  BTFSC  1B.7
170E0:  BSF    FF2.7
170E2:  MOVLW  0D
170E4:  BTFSS  F9E.4
170E6:  BRA    170E4
170E8:  MOVWF  FAD
170EA:  MOVLW  0A
170EC:  BTFSS  F9E.4
170EE:  BRA    170EC
170F0:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
170F2:  MOVLW  01
170F4:  MOVLB  8
170F6:  ADDWF  x69,W
170F8:  MOVWF  x6B
170FA:  MOVLW  00
170FC:  ADDWFC x6A,W
170FE:  MOVWF  x6C
17100:  MOVWF  x6E
17102:  MOVFF  86B,86D
17106:  MOVLB  0
17108:  CALL   163D2
1710C:  MOVFF  01,866
....................          ++nv_sample;                     // increment sample number 
17110:  INCF   21,F
17112:  BTFSC  FD8.2
17114:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
17116:  MOVLW  16
17118:  MOVLB  8
1711A:  MOVWF  xCF
1711C:  MOVFF  22,8D1
17120:  MOVFF  21,8D0
17124:  MOVLB  0
17126:  CALL   4F68
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
1712A:  MOVF   27,W
1712C:  SUBWF  21,W
1712E:  BNZ   17136
17130:  MOVF   28,W
17132:  SUBWF  22,W
17134:  BZ    1713E
17136:  MOVLB  8
17138:  MOVF   x66,W
1713A:  SUBLW  3B
1713C:  BNZ   17142
1713E:  MOVLB  8
17140:  BRA    1714A
17142:  INCF   x69,F
17144:  BTFSC  FD8.2
17146:  INCF   x6A,F
17148:  BRA    17088
1714A:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
1714C:  CALL   ADD0
17150:  GOTO   1718C (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
17154:  MOVF   2F,W
17156:  MOVWF  00
17158:  MOVF   30,W
1715A:  MOVWF  03
1715C:  BNZ   17162
1715E:  MOVF   00,F
17160:  BZ    17182
17162:  MOVF   03,W
17164:  BNZ   1716C
17166:  MOVLW  01
17168:  SUBWF  00,W
1716A:  BZ    17186
1716C:  MOVF   03,W
1716E:  BNZ   17176
17170:  MOVLW  03
17172:  SUBWF  00,W
17174:  BZ    17186
17176:  MOVF   03,W
17178:  BNZ   17180
1717A:  MOVLW  02
1717C:  SUBWF  00,W
1717E:  BZ    1718A
17180:  BRA    1718C
....................       case ECO : commandRe(); 
17182:  BRA    16EEE
....................          break; 
17184:  BRA    1718C
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
17186:  BRA    16FD0
....................          break; 
17188:  BRA    1718C
....................       case AWS : commandRa(); 
1718A:  BRA    17030
....................          break;          
....................    } 
1718C:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
17190:  CALL   295C
....................     
....................    switch(arg){ 
17194:  MOVFF  48,00
17198:  MOVF   49,W
1719A:  MOVWF  03
1719C:  BNZ   171A4
1719E:  MOVLW  01
171A0:  SUBWF  00,W
171A2:  BZ    171B0
171A4:  MOVF   03,W
171A6:  BNZ   171AE
171A8:  MOVLW  02
171AA:  SUBWF  00,W
171AC:  BZ    171F4
171AE:  BRA    17204
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
171B0:  DECFSZ 45,W
171B2:  BRA    171C8
171B4:  MOVF   46,F
171B6:  BNZ   171C8
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
171B8:  MOVLB  8
171BA:  CLRF   xA3
171BC:  MOVLW  01
171BE:  MOVWF  xA4
171C0:  MOVLB  0
171C2:  CALL   13372
....................       } 
171C6:  BRA    171F2
....................       else if(nv_det_type==2 || nv_det_type==3) 
171C8:  MOVF   45,W
171CA:  SUBLW  02
171CC:  BNZ   171D2
171CE:  MOVF   46,F
171D0:  BZ    171DC
171D2:  MOVF   45,W
171D4:  SUBLW  03
171D6:  BNZ   171F2
171D8:  MOVF   46,F
171DA:  BNZ   171F2
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
171DC:  MOVLB  8
171DE:  CLRF   xA4
171E0:  MOVLW  C8
171E2:  MOVWF  xA3
171E4:  CLRF   xA5
171E6:  MOVLW  01
171E8:  MOVWF  xA6
171EA:  CLRF   xA7
171EC:  MOVLB  0
171EE:  CALL   FC6A
....................       } 
....................       break;                                                        //200 scans,don't store,display 
171F2:  BRA    17208
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
171F4:  MOVLB  8
171F6:  CLRF   xA3
171F8:  MOVLW  01
171FA:  MOVWF  xA4
171FC:  MOVLB  0
171FE:  CALL   13674
....................       break; 
17202:  BRA    17208
....................    default: cmd_arg(); 
17204:  CALL   AF88
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
17208:  CALL   ADD0
1720C:  GOTO   172B8 (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
17210:  MOVF   4B,F
17212:  BNZ   17244
17214:  MOVF   4A,F
17216:  BNZ   17244
17218:  MOVF   49,W
1721A:  SUBLW  04
1721C:  BNC   17244
1721E:  BNZ   17226
17220:  MOVF   48,W
17222:  SUBLW  00
17224:  BNC   17244
....................       nv_sample = arg; 
17226:  MOVFF  49,22
1722A:  MOVFF  48,21
....................       write16(ADDR_SAMPLE, nv_sample); 
1722E:  MOVLW  16
17230:  MOVLB  8
17232:  MOVWF  xCF
17234:  MOVFF  22,8D1
17238:  MOVFF  21,8D0
1723C:  MOVLB  0
1723E:  CALL   4F68
....................    } 
17242:  BRA    17248
....................    else cmd_arg(); 
17244:  CALL   AF88
17248:  GOTO   172B8 (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
1724C:  MOVF   4B,F
1724E:  BNZ   17278
17250:  MOVF   4A,F
17252:  BNZ   17278
17254:  MOVF   49,W
17256:  SUBLW  01
17258:  BNC   17278
1725A:  BNZ   17262
1725C:  MOVF   48,W
1725E:  SUBLW  02
17260:  BNC   17278
....................       setting = arg; 
17262:  MOVFF  49,867
17266:  MOVFF  48,866
....................       sol_switch_cmd(setting); 
1726A:  MOVFF  867,898
1726E:  MOVFF  866,897
17272:  CALL   14064
....................    } 
17276:  BRA    1727C
....................    else cmd_arg(); 
17278:  CALL   AF88
1727C:  GOTO   172B8 (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
17280:  MOVF   2F,W
17282:  MOVWF  00
17284:  MOVF   30,W
17286:  MOVWF  03
17288:  BNZ   1728E
1728A:  MOVF   00,F
1728C:  BZ    172AE
1728E:  MOVF   03,W
17290:  BNZ   17298
17292:  MOVLW  01
17294:  SUBWF  00,W
17296:  BZ    172B2
17298:  MOVF   03,W
1729A:  BNZ   172A2
1729C:  MOVLW  03
1729E:  SUBWF  00,W
172A0:  BZ    172B2
172A2:  MOVF   03,W
172A4:  BNZ   172AC
172A6:  MOVLW  02
172A8:  SUBWF  00,W
172AA:  BZ    172B6
172AC:  BRA    172B8
....................       case ECO : commandSe(); 
172AE:  BRA    17190
....................          break; 
172B0:  BRA    172B8
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
172B2:  BRA    17210
....................          break; 
172B4:  BRA    172B8
....................       case AWS : commandSa(); 
172B6:  BRA    1724C
....................          break;          
....................    } 
172B8:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
1781E:  MOVLW  D6
17820:  MOVWF  FF6
17822:  MOVLW  26
17824:  MOVWF  FF7
17826:  MOVLW  00
17828:  MOVWF  FF8
1782A:  CLRF   1B
1782C:  BTFSC  FF2.7
1782E:  BSF    1B.7
17830:  BCF    FF2.7
17832:  CALL   0E4E
17836:  BTFSC  1B.7
17838:  BSF    FF2.7
....................    fputc('>',COM_A); 
1783A:  MOVLW  3E
1783C:  CALL   ADD8
....................    RTCfmt=fgetc(COM_A); 
17840:  CALL   0E38
17844:  MOVFF  01,4F
....................    if (com_echo == TRUE) 
17848:  DECFSZ 4C,W
1784A:  BRA    17852
....................       { 
....................       fputc(RTCfmt,COM_A); 
1784C:  MOVF   4F,W
1784E:  CALL   ADD8
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
17852:  MOVLW  30
17854:  SUBWF  4F,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
17856:  MOVF   4F,W
17858:  SUBLW  01
1785A:  BNC   17890
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
1785C:  MOVLW  02
1785E:  MOVWF  FF6
17860:  MOVLW  27
17862:  MOVWF  FF7
17864:  MOVLW  00
17866:  MOVWF  FF8
17868:  CALL   ADA6
1786C:  MOVLW  0D
1786E:  BTFSS  F9E.4
17870:  BRA    1786E
17872:  MOVWF  FAD
17874:  MOVLW  0A
17876:  BTFSS  F9E.4
17878:  BRA    17876
1787A:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
1787C:  MOVLW  1A
1787E:  MOVLB  8
17880:  MOVWF  xCF
17882:  CLRF   xD1
17884:  MOVFF  4F,8D0
17888:  MOVLB  0
1788A:  CALL   4F68
....................       }  
1788E:  BRA    17894
....................    else cmd_arg(); 
17890:  CALL   AF88
....................     
....................    if(arg == 1) 
17894:  DECFSZ 48,W
17896:  BRA    178A8
17898:  MOVF   49,F
1789A:  BNZ   178A8
1789C:  MOVF   4A,F
1789E:  BNZ   178A8
178A0:  MOVF   4B,F
178A2:  BNZ   178A8
....................    { 
....................       RTC_Set(); 
178A4:  BRA    176D4
....................    } 
178A6:  BRA    178AC
....................    else cmd_arg(); 
178A8:  CALL   AF88
178AC:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
18220:  MOVF   4B,F
18222:  BNZ   1823E
18224:  MOVF   4A,F
18226:  BNZ   1823E
18228:  MOVF   49,F
1822A:  BNZ   1823E
1822C:  MOVF   48,W
1822E:  SUBLW  14
18230:  BNC   1823E
....................       macro = arg; 
18232:  MOVFF  48,866
....................       upload_macro(macro);    
18236:  MOVFF  866,867
1823A:  BRA    17F6E
....................    }    
1823C:  BRA    1825A
....................    else if (arg == 5525){ 
1823E:  MOVF   48,W
18240:  SUBLW  95
18242:  BNZ   18256
18244:  MOVF   49,W
18246:  SUBLW  15
18248:  BNZ   18256
1824A:  MOVF   4A,F
1824C:  BNZ   18256
1824E:  MOVF   4B,F
18250:  BNZ   18256
....................       write_blank_macros(); 
18252:  BRA    180A4
....................    } 
18254:  BRA    1825A
....................    else cmd_arg(); 
18256:  CALL   AF88
1825A:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
18378:  MOVF   4B,F
1837A:  BNZ   18396
1837C:  MOVF   4A,F
1837E:  BNZ   18396
18380:  MOVF   49,F
18382:  BNZ   18396
18384:  MOVF   48,W
18386:  SUBLW  14
18388:  BNC   18396
....................       macro = arg;  
1838A:  MOVFF  48,866
....................       read_macro(macro); 
1838E:  MOVFF  866,867
18392:  BRA    18312
....................    }    
18394:  BRA    1839A
....................    else cmd_arg(); 
18396:  CALL   AF88
1839A:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
1860E:  DECFSZ 48,W
18610:  BRA    1862A
18612:  MOVF   49,F
18614:  BNZ   1862A
18616:  MOVF   4A,F
18618:  BNZ   1862A
1861A:  MOVF   4B,F
1861C:  BNZ   1862A
....................       //fprintf(COM_A,"1\r\n"); 
....................       RTC_alarm(); 
1861E:  BRA    1847E
....................       //fprintf(COM_A,"2\r\n"); 
....................       RTC_late(); 
18620:  CALL   1530E
....................       //fprintf(COM_A,"3\r\n"); 
....................       RTC_alarm_status(); 
18624:  CALL   157C8
....................       //fprintf(COM_A,"4\r\n"); 
....................    } 
18628:  BRA    1862E
....................    else cmd_arg(); 
1862A:  CALL   AF88
1862E:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
18632:  MOVF   48,W
18634:  MOVWF  00
18636:  MOVF   49,W
18638:  MOVWF  03
1863A:  BNZ   18640
1863C:  MOVF   00,F
1863E:  BZ    18674
18640:  MOVF   03,W
18642:  BNZ   1864A
18644:  MOVLW  02
18646:  SUBWF  00,W
18648:  BZ    18674
1864A:  MOVF   03,W
1864C:  BNZ   18654
1864E:  MOVLW  03
18650:  SUBWF  00,W
18652:  BZ    18674
18654:  MOVF   03,W
18656:  BNZ   1865E
18658:  MOVLW  04
1865A:  SUBWF  00,W
1865C:  BZ    18674
1865E:  MOVF   03,W
18660:  BNZ   18668
18662:  MOVLW  05
18664:  SUBWF  00,W
18666:  BZ    18674
18668:  MOVF   03,W
1866A:  BNZ   18672
1866C:  MOVLW  06
1866E:  SUBWF  00,W
18670:  BZ    18674
18672:  BRA    18692
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
18674:  MOVFF  49,20
18678:  MOVFF  48,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
1867C:  MOVLW  1C
1867E:  MOVLB  8
18680:  MOVWF  xCF
18682:  MOVFF  20,8D1
18686:  MOVFF  1F,8D0
1868A:  MOVLB  0
1868C:  CALL   4F68
....................          break; 
18690:  BRA    18696
....................       default: cmd_arg(); 
18692:  CALL   AF88
....................          break; 
....................    } 
18696:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
1869A:  CALL   295C
....................     
....................    switch(arg){ 
1869E:  MOVFF  48,00
186A2:  MOVF   49,W
186A4:  MOVWF  03
186A6:  BNZ   186AC
186A8:  MOVF   00,F
186AA:  BZ    18730
186AC:  MOVF   03,W
186AE:  BNZ   186B6
186B0:  MOVLW  0A
186B2:  SUBWF  00,W
186B4:  BZ    18730
186B6:  MOVF   03,W
186B8:  BNZ   186C0
186BA:  MOVLW  01
186BC:  SUBWF  00,W
186BE:  BZ    18738
186C0:  MOVF   03,W
186C2:  BNZ   186CA
186C4:  MOVLW  0B
186C6:  SUBWF  00,W
186C8:  BZ    18738
186CA:  MOVF   03,W
186CC:  BNZ   186D4
186CE:  MOVLW  14
186D0:  SUBWF  00,W
186D2:  BZ    18742
186D4:  MOVF   03,W
186D6:  BNZ   186DE
186D8:  MOVLW  15
186DA:  SUBWF  00,W
186DC:  BZ    18748
186DE:  MOVF   03,W
186E0:  BNZ   186E8
186E2:  MOVLW  1E
186E4:  SUBWF  00,W
186E6:  BZ    1874E
186E8:  MOVF   03,W
186EA:  BNZ   186F2
186EC:  MOVLW  1F
186EE:  SUBWF  00,W
186F0:  BZ    18754
186F2:  MOVF   03,W
186F4:  BNZ   186FC
186F6:  MOVLW  28
186F8:  SUBWF  00,W
186FA:  BZ    1875A
186FC:  MOVF   03,W
186FE:  BNZ   18706
18700:  MOVLW  29
18702:  SUBWF  00,W
18704:  BZ    18760
18706:  MOVF   03,W
18708:  BNZ   18710
1870A:  MOVLW  32
1870C:  SUBWF  00,W
1870E:  BZ    18766
18710:  MOVF   03,W
18712:  BNZ   1871A
18714:  MOVLW  33
18716:  SUBWF  00,W
18718:  BZ    1876C
1871A:  MOVF   03,W
1871C:  BNZ   18724
1871E:  MOVLW  3C
18720:  SUBWF  00,W
18722:  BZ    18772
18724:  MOVF   03,W
18726:  BNZ   1872E
18728:  MOVLW  3D
1872A:  SUBWF  00,W
1872C:  BZ    18780
1872E:  BRA    18792
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
18730:  BCF    F90.7
....................                bus_pwr_status=0; 
18732:  MOVLB  4
18734:  CLRF   xB6
....................          break; 
18736:  BRA    18798
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
18738:  BSF    F90.7
....................                bus_pwr_status=1; 
1873A:  MOVLW  01
1873C:  MOVLB  4
1873E:  MOVWF  xB6
....................          break; 
18740:  BRA    18798
....................       case 20: output_bit(VMOT,OFF); 
18742:  BCF    F8E.1
....................          break; 
18744:  MOVLB  4
18746:  BRA    18798
....................       case 21: output_bit(VMOT,ON); 
18748:  BSF    F8E.1
....................          break; 
1874A:  MOVLB  4
1874C:  BRA    18798
....................       case 30: output_bit(VENC1,OFF); 
1874E:  BCF    F8E.6
....................          break; 
18750:  MOVLB  4
18752:  BRA    18798
....................       case 31: output_bit(VENC1,ON); 
18754:  BSF    F8E.6
....................          break; 
18756:  MOVLB  4
18758:  BRA    18798
....................       case 40: output_bit(VENC2,OFF); 
1875A:  BCF    F8E.7
....................          break; 
1875C:  MOVLB  4
1875E:  BRA    18798
....................       case 41: output_bit(VENC2,ON); 
18760:  BSF    F8E.7
....................          break; 
18762:  MOVLB  4
18764:  BRA    18798
....................       case 50: output_bit(VHBRDG,OFF); 
18766:  BCF    F8E.2
....................          break; 
18768:  MOVLB  4
1876A:  BRA    18798
....................       case 51: output_bit(VHBRDG,ON); 
1876C:  BSF    F8E.2
....................          break;          
1876E:  MOVLB  4
18770:  BRA    18798
....................       case 60: set_heaters(0); 
18772:  MOVLB  8
18774:  CLRF   xA6
18776:  MOVLB  0
18778:  CALL   12352
....................          break; 
1877C:  MOVLB  4
1877E:  BRA    18798
....................       case 61: set_heaters(3); 
18780:  MOVLW  03
18782:  MOVLB  8
18784:  MOVWF  xA6
18786:  MOVLB  0
18788:  CALL   12352
....................          break; 
1878C:  MOVLB  4
1878E:  BRA    18798
18790:  MOVLB  0
....................       default : cmd_arg(); 
18792:  CALL   AF88
....................          break;          
18796:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
18798:  MOVLB  0
1879A:  CALL   ADD0
1879E:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
187A2:  MOVF   48,F
187A4:  BNZ   187C0
187A6:  MOVF   49,F
187A8:  BNZ   187C0
187AA:  MOVF   4A,F
187AC:  BNZ   187C0
187AE:  MOVF   4B,F
187B0:  BNZ   187C0
....................       motor_sleep_rdy(); 
187B2:  CALL   2934
....................       shutdown(); 
187B6:  CALL   157EA
....................       go_to_sleep(); 
187BA:  CALL   15A56
....................    } 
187BE:  BRA    187C4
....................    else cmd_arg(); 
187C0:  CALL   AF88
187C4:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
188F2:  DECFSZ 48,W
188F4:  BRA    18906
188F6:  MOVF   49,F
188F8:  BNZ   18906
188FA:  MOVF   4A,F
188FC:  BNZ   18906
188FE:  MOVF   4B,F
18900:  BNZ   18906
18902:  BRA    187EC
18904:  BRA    1890A
....................    else cmd_arg(); 
18906:  CALL   AF88
1890A:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
1890E:  MOVF   4B,F
18910:  BNZ   189A0
18912:  MOVF   4A,F
18914:  BNZ   189A0
18916:  MOVF   49,W
18918:  SUBLW  27
1891A:  BNC   189A0
1891C:  BNZ   18924
1891E:  MOVF   48,W
18920:  SUBLW  10
18922:  BNC   189A0
....................       m_bklsh[motor] = arg; 
18924:  BCF    FD8.0
18926:  MOVLB  7
18928:  RLCF   x40,W
1892A:  CLRF   03
1892C:  ADDLW  72
1892E:  MOVWF  FE9
18930:  MOVLW  07
18932:  ADDWFC 03,W
18934:  MOVWF  FEA
18936:  MOVFF  48,FEF
1893A:  MOVFF  49,FEC
....................       switch(motor){ 
1893E:  MOVF   x40,W
18940:  XORLW  00
18942:  MOVLB  0
18944:  BZ    1894C
18946:  XORLW  01
18948:  BZ    18976
1894A:  BRA    1899E
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
1894C:  BCF    FD8.0
1894E:  MOVLB  7
18950:  RLCF   x40,W
18952:  CLRF   03
18954:  ADDLW  72
18956:  MOVWF  FE9
18958:  MOVLW  07
1895A:  ADDWFC 03,W
1895C:  MOVWF  FEA
1895E:  MOVFF  FEC,8D1
18962:  MOVF   FED,F
18964:  MOVFF  FEF,8D0
18968:  MOVLW  72
1896A:  MOVLB  8
1896C:  MOVWF  xCF
1896E:  MOVLB  0
18970:  CALL   4F68
....................             break; 
18974:  BRA    1899E
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
18976:  BCF    FD8.0
18978:  MOVLB  7
1897A:  RLCF   x40,W
1897C:  CLRF   03
1897E:  ADDLW  72
18980:  MOVWF  FE9
18982:  MOVLW  07
18984:  ADDWFC 03,W
18986:  MOVWF  FEA
18988:  MOVFF  FEC,8D1
1898C:  MOVF   FED,F
1898E:  MOVFF  FEF,8D0
18992:  MOVLW  74
18994:  MOVLB  8
18996:  MOVWF  xCF
18998:  MOVLB  0
1899A:  CALL   4F68
....................             break;             
....................       } 
....................    } 
1899E:  BRA    189A4
....................    else cmd_arg();    
189A0:  CALL   AF88
189A4:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_c(){ 
....................    if(arg == 0){ 
189A8:  MOVF   48,F
189AA:  BNZ   189BC
189AC:  MOVF   49,F
189AE:  BNZ   189BC
189B0:  MOVF   4A,F
189B2:  BNZ   189BC
189B4:  MOVF   4B,F
189B6:  BNZ   189BC
....................       output_bit(PIN_J7,0); 
189B8:  BCF    F91.7
....................    }else if(arg == 1){ 
189BA:  BRA    189EC
189BC:  DECFSZ 48,W
189BE:  BRA    189D0
189C0:  MOVF   49,F
189C2:  BNZ   189D0
189C4:  MOVF   4A,F
189C6:  BNZ   189D0
189C8:  MOVF   4B,F
189CA:  BNZ   189D0
....................       output_bit(PIN_J7,1); 
189CC:  BSF    F91.7
....................    }else{ 
189CE:  BRA    189EC
....................       RTC_reset_HT(); 
189D0:  CALL   344E
....................       output_bit(RTC_CS, ENABLE); 
189D4:  BCF    F91.0
....................       spi_write(0x89); 
189D6:  MOVF   FC9,W
189D8:  MOVLW  89
189DA:  MOVWF  FC9
189DC:  RRCF   FC7,W
189DE:  BNC   189DC
....................       spi_write(arg); 
189E0:  MOVF   FC9,W
189E2:  MOVFF  48,FC9
189E6:  RRCF   FC7,W
189E8:  BNC   189E6
....................       output_bit(RTC_CS, DISABLE); 
189EA:  BSF    F91.0
....................    } 
189EC:  GOTO   1B01E (RETURN)
.................... } 
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
189F0:  MOVF   4B,F
189F2:  BNZ   18A7E
189F4:  MOVF   4A,F
189F6:  BNZ   18A7E
189F8:  MOVF   49,F
189FA:  BNZ   18A7E
189FC:  MOVF   48,W
189FE:  SUBLW  01
18A00:  BNC   18A7E
....................       m_pos_dir[motor] = arg; 
18A02:  BCF    FD8.0
18A04:  MOVLB  7
18A06:  RLCF   x40,W
18A08:  CLRF   03
18A0A:  ADDLW  4E
18A0C:  MOVWF  FE9
18A0E:  MOVLW  07
18A10:  ADDWFC 03,W
18A12:  MOVWF  FEA
18A14:  MOVFF  48,FEF
18A18:  MOVFF  49,FEC
....................       switch(motor){ 
18A1C:  MOVF   x40,W
18A1E:  XORLW  00
18A20:  MOVLB  0
18A22:  BZ    18A2A
18A24:  XORLW  01
18A26:  BZ    18A54
18A28:  BRA    18A7C
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
18A2A:  BCF    FD8.0
18A2C:  MOVLB  7
18A2E:  RLCF   x40,W
18A30:  CLRF   03
18A32:  ADDLW  4E
18A34:  MOVWF  FE9
18A36:  MOVLW  07
18A38:  ADDWFC 03,W
18A3A:  MOVWF  FEA
18A3C:  MOVFF  FEC,8D1
18A40:  MOVF   FED,F
18A42:  MOVFF  FEF,8D0
18A46:  MOVLW  92
18A48:  MOVLB  8
18A4A:  MOVWF  xCF
18A4C:  MOVLB  0
18A4E:  CALL   4F68
....................             break; 
18A52:  BRA    18A7C
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
18A54:  BCF    FD8.0
18A56:  MOVLB  7
18A58:  RLCF   x40,W
18A5A:  CLRF   03
18A5C:  ADDLW  4E
18A5E:  MOVWF  FE9
18A60:  MOVLW  07
18A62:  ADDWFC 03,W
18A64:  MOVWF  FEA
18A66:  MOVFF  FEC,8D1
18A6A:  MOVF   FED,F
18A6C:  MOVFF  FEF,8D0
18A70:  MOVLW  94
18A72:  MOVLB  8
18A74:  MOVWF  xCF
18A76:  MOVLB  0
18A78:  CALL   4F68
....................             break;             
....................       } 
....................    } 
18A7C:  BRA    18A82
....................    else cmd_arg();    
18A7E:  CALL   AF88
18A82:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
18A86:  MOVF   4B,F
18A88:  BNZ   18B18
18A8A:  MOVF   4A,F
18A8C:  BNZ   18B18
18A8E:  MOVF   49,W
18A90:  SUBLW  27
18A92:  BNC   18B18
18A94:  BNZ   18A9C
18A96:  MOVF   48,W
18A98:  SUBLW  10
18A9A:  BNC   18B18
....................       e_cpr[motor] = arg; 
18A9C:  BCF    FD8.0
18A9E:  MOVLB  7
18AA0:  RLCF   x40,W
18AA2:  CLRF   03
18AA4:  ADDLW  5E
18AA6:  MOVWF  FE9
18AA8:  MOVLW  07
18AAA:  ADDWFC 03,W
18AAC:  MOVWF  FEA
18AAE:  MOVFF  48,FEF
18AB2:  MOVFF  49,FEC
....................       switch(motor){ 
18AB6:  MOVF   x40,W
18AB8:  XORLW  00
18ABA:  MOVLB  0
18ABC:  BZ    18AC4
18ABE:  XORLW  01
18AC0:  BZ    18AEE
18AC2:  BRA    18B16
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
18AC4:  BCF    FD8.0
18AC6:  MOVLB  7
18AC8:  RLCF   x40,W
18ACA:  CLRF   03
18ACC:  ADDLW  5E
18ACE:  MOVWF  FE9
18AD0:  MOVLW  07
18AD2:  ADDWFC 03,W
18AD4:  MOVWF  FEA
18AD6:  MOVFF  FEC,8D1
18ADA:  MOVF   FED,F
18ADC:  MOVFF  FEF,8D0
18AE0:  MOVLW  A2
18AE2:  MOVLB  8
18AE4:  MOVWF  xCF
18AE6:  MOVLB  0
18AE8:  CALL   4F68
....................             break; 
18AEC:  BRA    18B16
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
18AEE:  BCF    FD8.0
18AF0:  MOVLB  7
18AF2:  RLCF   x40,W
18AF4:  CLRF   03
18AF6:  ADDLW  5E
18AF8:  MOVWF  FE9
18AFA:  MOVLW  07
18AFC:  ADDWFC 03,W
18AFE:  MOVWF  FEA
18B00:  MOVFF  FEC,8D1
18B04:  MOVF   FED,F
18B06:  MOVFF  FEF,8D0
18B0A:  MOVLW  A4
18B0C:  MOVLB  8
18B0E:  MOVWF  xCF
18B10:  MOVLB  0
18B12:  CALL   4F68
....................             break;             
....................       } 
....................    } 
18B16:  BRA    18B1C
....................    else cmd_arg();    
18B18:  CALL   AF88
18B1C:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
18B20:  MOVF   4B,F
18B22:  BNZ   18B38
18B24:  MOVF   4A,F
18B26:  BNZ   18B38
18B28:  MOVF   49,F
18B2A:  BNZ   18B38
18B2C:  MOVF   48,W
18B2E:  SUBLW  01
18B30:  BNC   18B38
18B32:  MOVFF  48,741
18B36:  BRA    18B3C
....................    else cmd_arg();    
18B38:  CALL   AF88
18B3C:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
18B40:  MOVF   4B,F
18B42:  BNZ   18BD2
18B44:  MOVF   4A,F
18B46:  BNZ   18BD2
18B48:  MOVF   49,W
18B4A:  SUBLW  EA
18B4C:  BNC   18BD2
18B4E:  BNZ   18B56
18B50:  MOVF   48,W
18B52:  SUBLW  60
18B54:  BNC   18BD2
....................       m_gb_err[motor] = arg; 
18B56:  BCF    FD8.0
18B58:  MOVLB  7
18B5A:  RLCF   x40,W
18B5C:  CLRF   03
18B5E:  ADDLW  5A
18B60:  MOVWF  FE9
18B62:  MOVLW  07
18B64:  ADDWFC 03,W
18B66:  MOVWF  FEA
18B68:  MOVFF  48,FEF
18B6C:  MOVFF  49,FEC
....................       switch(motor){ 
18B70:  MOVF   x40,W
18B72:  XORLW  00
18B74:  MOVLB  0
18B76:  BZ    18B7E
18B78:  XORLW  01
18B7A:  BZ    18BA8
18B7C:  BRA    18BD0
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
18B7E:  BCF    FD8.0
18B80:  MOVLB  7
18B82:  RLCF   x40,W
18B84:  CLRF   03
18B86:  ADDLW  5A
18B88:  MOVWF  FE9
18B8A:  MOVLW  07
18B8C:  ADDWFC 03,W
18B8E:  MOVWF  FEA
18B90:  MOVFF  FEC,8D1
18B94:  MOVF   FED,F
18B96:  MOVFF  FEF,8D0
18B9A:  MOVLW  9E
18B9C:  MOVLB  8
18B9E:  MOVWF  xCF
18BA0:  MOVLB  0
18BA2:  CALL   4F68
....................             break; 
18BA6:  BRA    18BD0
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
18BA8:  BCF    FD8.0
18BAA:  MOVLB  7
18BAC:  RLCF   x40,W
18BAE:  CLRF   03
18BB0:  ADDLW  5A
18BB2:  MOVWF  FE9
18BB4:  MOVLW  07
18BB6:  ADDWFC 03,W
18BB8:  MOVWF  FEA
18BBA:  MOVFF  FEC,8D1
18BBE:  MOVF   FED,F
18BC0:  MOVFF  FEF,8D0
18BC4:  MOVLW  A0
18BC6:  MOVLB  8
18BC8:  MOVWF  xCF
18BCA:  MOVLB  0
18BCC:  CALL   4F68
....................             break;             
....................       } 
....................    } 
18BD0:  BRA    18BD6
....................    else cmd_arg();    
18BD2:  CALL   AF88
18BD6:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
18BDA:  MOVF   4B,F
18BDC:  BNZ   18CA6
18BDE:  MOVF   4A,F
18BE0:  BNZ   18CA6
18BE2:  MOVF   49,F
18BE4:  BNZ   18CA6
18BE6:  MOVF   48,W
18BE8:  SUBLW  64
18BEA:  BNC   18CA6
....................       hold_pc=arg; 
18BEC:  MOVFF  49,867
18BF0:  MOVFF  48,866
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
18BF4:  BCF    FD8.0
18BF6:  MOVLB  7
18BF8:  RLCF   x40,W
18BFA:  CLRF   03
18BFC:  ADDLW  52
18BFE:  MOVWF  FE9
18C00:  MOVLW  07
18C02:  ADDWFC 03,W
18C04:  MOVWF  FEA
18C06:  MOVFF  867,9EE
18C0A:  MOVFF  866,9ED
18C0E:  MOVLW  01
18C10:  MOVLB  9
18C12:  MOVWF  xF0
18C14:  SETF   xEF
18C16:  MOVLB  0
18C18:  CALL   5C32
18C1C:  MOVFF  02,86B
18C20:  MOVFF  01,86A
18C24:  MOVFF  02,8BD
18C28:  MOVFF  01,8BC
18C2C:  MOVLB  8
18C2E:  CLRF   xBF
18C30:  MOVLW  64
18C32:  MOVWF  xBE
18C34:  MOVLB  0
18C36:  CALL   2C70
18C3A:  MOVFF  01,FEF
18C3E:  MOVFF  02,FEC
....................       switch(motor){ 
18C42:  MOVLB  7
18C44:  MOVF   x40,W
18C46:  XORLW  00
18C48:  MOVLB  0
18C4A:  BZ    18C52
18C4C:  XORLW  01
18C4E:  BZ    18C7C
18C50:  BRA    18CA4
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
18C52:  BCF    FD8.0
18C54:  MOVLB  7
18C56:  RLCF   x40,W
18C58:  CLRF   03
18C5A:  ADDLW  52
18C5C:  MOVWF  FE9
18C5E:  MOVLW  07
18C60:  ADDWFC 03,W
18C62:  MOVWF  FEA
18C64:  MOVFF  FEC,8D1
18C68:  MOVF   FED,F
18C6A:  MOVFF  FEF,8D0
18C6E:  MOVLW  96
18C70:  MOVLB  8
18C72:  MOVWF  xCF
18C74:  MOVLB  0
18C76:  CALL   4F68
....................             break; 
18C7A:  BRA    18CA4
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
18C7C:  BCF    FD8.0
18C7E:  MOVLB  7
18C80:  RLCF   x40,W
18C82:  CLRF   03
18C84:  ADDLW  52
18C86:  MOVWF  FE9
18C88:  MOVLW  07
18C8A:  ADDWFC 03,W
18C8C:  MOVWF  FEA
18C8E:  MOVFF  FEC,8D1
18C92:  MOVF   FED,F
18C94:  MOVFF  FEF,8D0
18C98:  MOVLW  98
18C9A:  MOVLB  8
18C9C:  MOVWF  xCF
18C9E:  MOVLB  0
18CA0:  CALL   4F68
....................             break;             
....................       } 
....................    } 
18CA4:  BRA    18CAA
....................    else cmd_arg();    
18CA6:  CALL   AF88
18CAA:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
18CAE:  MOVF   4B,F
18CB0:  BNZ   18D82
18CB2:  MOVF   4A,F
18CB4:  BNZ   18D82
18CB6:  MOVF   49,W
18CB8:  SUBLW  EA
18CBA:  BNC   18D82
18CBC:  BNZ   18CC4
18CBE:  MOVF   48,W
18CC0:  SUBLW  60
18CC2:  BNC   18D82
....................       m_stp_int[motor] = (arg/100); 
18CC4:  BCF    FD8.0
18CC6:  MOVLB  7
18CC8:  RLCF   x40,W
18CCA:  CLRF   03
18CCC:  ADDLW  4A
18CCE:  MOVWF  FE9
18CD0:  MOVLW  07
18CD2:  ADDWFC 03,W
18CD4:  MOVWF  FEA
18CD6:  MOVFF  FEA,869
18CDA:  MOVFF  FE9,868
18CDE:  BCF    FD8.1
18CE0:  CLRF   1B
18CE2:  BTFSC  FF2.7
18CE4:  BSF    1B.7
18CE6:  BCF    FF2.7
18CE8:  MOVFF  4B,A2B
18CEC:  MOVFF  4A,A2A
18CF0:  MOVFF  49,A29
18CF4:  MOVFF  48,A28
18CF8:  MOVLB  A
18CFA:  CLRF   x2F
18CFC:  CLRF   x2E
18CFE:  CLRF   x2D
18D00:  MOVLW  64
18D02:  MOVWF  x2C
18D04:  MOVLB  0
18D06:  CALL   1056
18D0A:  BTFSC  1B.7
18D0C:  BSF    FF2.7
18D0E:  MOVFF  869,FEA
18D12:  MOVFF  868,FE9
18D16:  MOVFF  00,FEF
18D1A:  MOVFF  01,FEC
....................       switch(motor){ 
18D1E:  MOVLB  7
18D20:  MOVF   x40,W
18D22:  XORLW  00
18D24:  MOVLB  0
18D26:  BZ    18D2E
18D28:  XORLW  01
18D2A:  BZ    18D58
18D2C:  BRA    18D80
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
18D2E:  BCF    FD8.0
18D30:  MOVLB  7
18D32:  RLCF   x40,W
18D34:  CLRF   03
18D36:  ADDLW  4A
18D38:  MOVWF  FE9
18D3A:  MOVLW  07
18D3C:  ADDWFC 03,W
18D3E:  MOVWF  FEA
18D40:  MOVFF  FEC,8D1
18D44:  MOVF   FED,F
18D46:  MOVFF  FEF,8D0
18D4A:  MOVLW  8E
18D4C:  MOVLB  8
18D4E:  MOVWF  xCF
18D50:  MOVLB  0
18D52:  CALL   4F68
....................             break; 
18D56:  BRA    18D80
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
18D58:  BCF    FD8.0
18D5A:  MOVLB  7
18D5C:  RLCF   x40,W
18D5E:  CLRF   03
18D60:  ADDLW  4A
18D62:  MOVWF  FE9
18D64:  MOVLW  07
18D66:  ADDWFC 03,W
18D68:  MOVWF  FEA
18D6A:  MOVFF  FEC,8D1
18D6E:  MOVF   FED,F
18D70:  MOVFF  FEF,8D0
18D74:  MOVLW  90
18D76:  MOVLB  8
18D78:  MOVWF  xCF
18D7A:  MOVLB  0
18D7C:  CALL   4F68
....................             break;             
....................       } 
....................    } 
18D80:  BRA    18D86
....................    else cmd_arg();    
18D82:  CALL   AF88
18D86:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
18D8A:  MOVF   4B,F
18D8C:  BNZ   18E1C
18D8E:  MOVF   4A,F
18D90:  BNZ   18E1C
18D92:  MOVF   49,W
18D94:  SUBLW  27
18D96:  BNC   18E1C
18D98:  BNZ   18DA0
18D9A:  MOVF   48,W
18D9C:  SUBLW  10
18D9E:  BNC   18E1C
....................       m_run[motor] = arg; 
18DA0:  BCF    FD8.0
18DA2:  MOVLB  7
18DA4:  RLCF   x40,W
18DA6:  CLRF   03
18DA8:  ADDLW  6E
18DAA:  MOVWF  FE9
18DAC:  MOVLW  07
18DAE:  ADDWFC 03,W
18DB0:  MOVWF  FEA
18DB2:  MOVFF  48,FEF
18DB6:  MOVFF  49,FEC
....................       switch(motor){ 
18DBA:  MOVF   x40,W
18DBC:  XORLW  00
18DBE:  MOVLB  0
18DC0:  BZ    18DC8
18DC2:  XORLW  01
18DC4:  BZ    18DF2
18DC6:  BRA    18E1A
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
18DC8:  BCF    FD8.0
18DCA:  MOVLB  7
18DCC:  RLCF   x40,W
18DCE:  CLRF   03
18DD0:  ADDLW  6E
18DD2:  MOVWF  FE9
18DD4:  MOVLW  07
18DD6:  ADDWFC 03,W
18DD8:  MOVWF  FEA
18DDA:  MOVFF  FEC,8D1
18DDE:  MOVF   FED,F
18DE0:  MOVFF  FEF,8D0
18DE4:  MOVLW  76
18DE6:  MOVLB  8
18DE8:  MOVWF  xCF
18DEA:  MOVLB  0
18DEC:  CALL   4F68
....................             break; 
18DF0:  BRA    18E1A
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
18DF2:  BCF    FD8.0
18DF4:  MOVLB  7
18DF6:  RLCF   x40,W
18DF8:  CLRF   03
18DFA:  ADDLW  6E
18DFC:  MOVWF  FE9
18DFE:  MOVLW  07
18E00:  ADDWFC 03,W
18E02:  MOVWF  FEA
18E04:  MOVFF  FEC,8D1
18E08:  MOVF   FED,F
18E0A:  MOVFF  FEF,8D0
18E0E:  MOVLW  78
18E10:  MOVLB  8
18E12:  MOVWF  xCF
18E14:  MOVLB  0
18E16:  CALL   4F68
....................             break;             
....................       } 
....................    } 
18E1A:  BRA    18E20
....................    else cmd_arg();    
18E1C:  CALL   AF88
18E20:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
18E24:  MOVF   4B,F
18E26:  BNZ   18EB2
18E28:  MOVF   4A,F
18E2A:  BNZ   18EB2
18E2C:  MOVF   49,F
18E2E:  BNZ   18EB2
18E30:  MOVF   48,W
18E32:  SUBLW  03
18E34:  BNC   18EB2
....................       e_mode[motor] = arg; 
18E36:  BCF    FD8.0
18E38:  MOVLB  7
18E3A:  RLCF   x40,W
18E3C:  CLRF   03
18E3E:  ADDLW  66
18E40:  MOVWF  FE9
18E42:  MOVLW  07
18E44:  ADDWFC 03,W
18E46:  MOVWF  FEA
18E48:  MOVFF  48,FEF
18E4C:  MOVFF  49,FEC
....................       switch(motor){ 
18E50:  MOVF   x40,W
18E52:  XORLW  00
18E54:  MOVLB  0
18E56:  BZ    18E5E
18E58:  XORLW  01
18E5A:  BZ    18E88
18E5C:  BRA    18EB0
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
18E5E:  BCF    FD8.0
18E60:  MOVLB  7
18E62:  RLCF   x40,W
18E64:  CLRF   03
18E66:  ADDLW  66
18E68:  MOVWF  FE9
18E6A:  MOVLW  07
18E6C:  ADDWFC 03,W
18E6E:  MOVWF  FEA
18E70:  MOVFF  FEC,8D1
18E74:  MOVF   FED,F
18E76:  MOVFF  FEF,8D0
18E7A:  MOVLW  82
18E7C:  MOVLB  8
18E7E:  MOVWF  xCF
18E80:  MOVLB  0
18E82:  CALL   4F68
....................             break; 
18E86:  BRA    18EB0
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
18E88:  BCF    FD8.0
18E8A:  MOVLB  7
18E8C:  RLCF   x40,W
18E8E:  CLRF   03
18E90:  ADDLW  66
18E92:  MOVWF  FE9
18E94:  MOVLW  07
18E96:  ADDWFC 03,W
18E98:  MOVWF  FEA
18E9A:  MOVFF  FEC,8D1
18E9E:  MOVF   FED,F
18EA0:  MOVFF  FEF,8D0
18EA4:  MOVLW  84
18EA6:  MOVLB  8
18EA8:  MOVWF  xCF
18EAA:  MOVLB  0
18EAC:  CALL   4F68
....................             break;             
....................       } 
....................    } 
18EB0:  BRA    18EB6
....................    else cmd_arg();    
18EB2:  CALL   AF88
18EB6:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
19B1A:  MOVF   4B,F
19B1C:  BNZ   19BA8
19B1E:  MOVF   4A,F
19B20:  BNZ   19BA8
19B22:  MOVF   49,F
19B24:  BNZ   19BA8
19B26:  MOVF   48,W
19B28:  SUBLW  01
19B2A:  BNC   19BA8
....................       m_mode[motor] = arg; 
19B2C:  BCF    FD8.0
19B2E:  MOVLB  7
19B30:  RLCF   x40,W
19B32:  CLRF   03
19B34:  ADDLW  46
19B36:  MOVWF  FE9
19B38:  MOVLW  07
19B3A:  ADDWFC 03,W
19B3C:  MOVWF  FEA
19B3E:  MOVFF  48,FEF
19B42:  MOVFF  49,FEC
....................       switch(motor){ 
19B46:  MOVF   x40,W
19B48:  XORLW  00
19B4A:  MOVLB  0
19B4C:  BZ    19B54
19B4E:  XORLW  01
19B50:  BZ    19B7E
19B52:  BRA    19BA6
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
19B54:  BCF    FD8.0
19B56:  MOVLB  7
19B58:  RLCF   x40,W
19B5A:  CLRF   03
19B5C:  ADDLW  46
19B5E:  MOVWF  FE9
19B60:  MOVLW  07
19B62:  ADDWFC 03,W
19B64:  MOVWF  FEA
19B66:  MOVFF  FEC,8D1
19B6A:  MOVF   FED,F
19B6C:  MOVFF  FEF,8D0
19B70:  MOVLW  8A
19B72:  MOVLB  8
19B74:  MOVWF  xCF
19B76:  MOVLB  0
19B78:  CALL   4F68
....................             break; 
19B7C:  BRA    19BA6
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
19B7E:  BCF    FD8.0
19B80:  MOVLB  7
19B82:  RLCF   x40,W
19B84:  CLRF   03
19B86:  ADDLW  46
19B88:  MOVWF  FE9
19B8A:  MOVLW  07
19B8C:  ADDWFC 03,W
19B8E:  MOVWF  FEA
19B90:  MOVFF  FEC,8D1
19B94:  MOVF   FED,F
19B96:  MOVFF  FEF,8D0
19B9A:  MOVLW  8C
19B9C:  MOVLB  8
19B9E:  MOVWF  xCF
19BA0:  MOVLB  0
19BA2:  CALL   4F68
....................             break;             
....................       } 
....................    } 
19BA6:  BRA    19BAC
....................    else cmd_arg();    
19BA8:  CALL   AF88
19BAC:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
19BB0:  MOVF   4B,F
19BB2:  BNZ   19C3E
19BB4:  MOVF   4A,F
19BB6:  BNZ   19C3E
19BB8:  MOVF   49,F
19BBA:  BNZ   19C3E
19BBC:  MOVF   48,W
19BBE:  SUBLW  01
19BC0:  BNC   19C3E
....................       e_index[motor] = arg; 
19BC2:  BCF    FD8.0
19BC4:  MOVLB  7
19BC6:  RLCF   x40,W
19BC8:  CLRF   03
19BCA:  ADDLW  7A
19BCC:  MOVWF  FE9
19BCE:  MOVLW  07
19BD0:  ADDWFC 03,W
19BD2:  MOVWF  FEA
19BD4:  MOVFF  48,FEF
19BD8:  MOVFF  49,FEC
....................       switch(motor){ 
19BDC:  MOVF   x40,W
19BDE:  XORLW  00
19BE0:  MOVLB  0
19BE2:  BZ    19BEA
19BE4:  XORLW  01
19BE6:  BZ    19C14
19BE8:  BRA    19C3C
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
19BEA:  BCF    FD8.0
19BEC:  MOVLB  7
19BEE:  RLCF   x40,W
19BF0:  CLRF   03
19BF2:  ADDLW  7A
19BF4:  MOVWF  FE9
19BF6:  MOVLW  07
19BF8:  ADDWFC 03,W
19BFA:  MOVWF  FEA
19BFC:  MOVFF  FEC,8D1
19C00:  MOVF   FED,F
19C02:  MOVFF  FEF,8D0
19C06:  MOVLW  BA
19C08:  MOVLB  8
19C0A:  MOVWF  xCF
19C0C:  MOVLB  0
19C0E:  CALL   4F68
....................             break; 
19C12:  BRA    19C3C
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
19C14:  BCF    FD8.0
19C16:  MOVLB  7
19C18:  RLCF   x40,W
19C1A:  CLRF   03
19C1C:  ADDLW  7A
19C1E:  MOVWF  FE9
19C20:  MOVLW  07
19C22:  ADDWFC 03,W
19C24:  MOVWF  FEA
19C26:  MOVFF  FEC,8D1
19C2A:  MOVF   FED,F
19C2C:  MOVFF  FEF,8D0
19C30:  MOVLW  BC
19C32:  MOVLB  8
19C34:  MOVWF  xCF
19C36:  MOVLB  0
19C38:  CALL   4F68
....................             break;             
....................       } 
....................    } 
19C3C:  BRA    19C42
....................    else cmd_arg();    
19C3E:  CALL   AF88
19C42:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
19C46:  MOVF   4B,F
19C48:  BNZ   19CD8
19C4A:  MOVF   4A,F
19C4C:  BNZ   19CD8
19C4E:  MOVF   49,W
19C50:  SUBLW  01
19C52:  BNC   19CD8
19C54:  BNZ   19C5C
19C56:  MOVF   48,W
19C58:  SUBLW  0A
19C5A:  BNC   19CD8
....................        evn_so[motor] = arg; 
19C5C:  BCF    FD8.0
19C5E:  MOVLB  7
19C60:  RLCF   x40,W
19C62:  CLRF   03
19C64:  ADDLW  7E
19C66:  MOVWF  FE9
19C68:  MOVLW  07
19C6A:  ADDWFC 03,W
19C6C:  MOVWF  FEA
19C6E:  MOVFF  48,FEF
19C72:  MOVFF  49,FEC
....................        switch(motor){ 
19C76:  MOVF   x40,W
19C78:  XORLW  00
19C7A:  MOVLB  0
19C7C:  BZ    19C84
19C7E:  XORLW  01
19C80:  BZ    19CAE
19C82:  BRA    19CD6
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
19C84:  BCF    FD8.0
19C86:  MOVLB  7
19C88:  RLCF   x40,W
19C8A:  CLRF   03
19C8C:  ADDLW  7E
19C8E:  MOVWF  FE9
19C90:  MOVLW  07
19C92:  ADDWFC 03,W
19C94:  MOVWF  FEA
19C96:  MOVFF  FEC,8D1
19C9A:  MOVF   FED,F
19C9C:  MOVFF  FEF,8D0
19CA0:  MOVLW  BE
19CA2:  MOVLB  8
19CA4:  MOVWF  xCF
19CA6:  MOVLB  0
19CA8:  CALL   4F68
....................             break; 
19CAC:  BRA    19CD6
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
19CAE:  BCF    FD8.0
19CB0:  MOVLB  7
19CB2:  RLCF   x40,W
19CB4:  CLRF   03
19CB6:  ADDLW  7E
19CB8:  MOVWF  FE9
19CBA:  MOVLW  07
19CBC:  ADDWFC 03,W
19CBE:  MOVWF  FEA
19CC0:  MOVFF  FEC,8D1
19CC4:  MOVF   FED,F
19CC6:  MOVFF  FEF,8D0
19CCA:  MOVLW  C0
19CCC:  MOVLB  8
19CCE:  MOVWF  xCF
19CD0:  MOVLB  0
19CD2:  CALL   4F68
....................             break;             
....................       } 
....................    } 
19CD6:  BRA    19CDC
....................    else cmd_arg();    
19CD8:  CALL   AF88
19CDC:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
19CE0:  MOVF   4B,F
19CE2:  BNZ   19D72
19CE4:  MOVF   4A,F
19CE6:  BNZ   19D72
19CE8:  MOVF   49,W
19CEA:  SUBLW  03
19CEC:  BNC   19D72
19CEE:  BNZ   19CF6
19CF0:  MOVF   48,W
19CF2:  SUBLW  E8
19CF4:  BNC   19D72
....................       e_ppr[motor] = arg; 
19CF6:  BCF    FD8.0
19CF8:  MOVLB  7
19CFA:  RLCF   x40,W
19CFC:  CLRF   03
19CFE:  ADDLW  62
19D00:  MOVWF  FE9
19D02:  MOVLW  07
19D04:  ADDWFC 03,W
19D06:  MOVWF  FEA
19D08:  MOVFF  48,FEF
19D0C:  MOVFF  49,FEC
....................       switch(motor){ 
19D10:  MOVF   x40,W
19D12:  XORLW  00
19D14:  MOVLB  0
19D16:  BZ    19D1E
19D18:  XORLW  01
19D1A:  BZ    19D48
19D1C:  BRA    19D70
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
19D1E:  BCF    FD8.0
19D20:  MOVLB  7
19D22:  RLCF   x40,W
19D24:  CLRF   03
19D26:  ADDLW  62
19D28:  MOVWF  FE9
19D2A:  MOVLW  07
19D2C:  ADDWFC 03,W
19D2E:  MOVWF  FEA
19D30:  MOVFF  FEC,8D1
19D34:  MOVF   FED,F
19D36:  MOVFF  FEF,8D0
19D3A:  MOVLW  A6
19D3C:  MOVLB  8
19D3E:  MOVWF  xCF
19D40:  MOVLB  0
19D42:  CALL   4F68
....................             break; 
19D46:  BRA    19D70
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
19D48:  BCF    FD8.0
19D4A:  MOVLB  7
19D4C:  RLCF   x40,W
19D4E:  CLRF   03
19D50:  ADDLW  62
19D52:  MOVWF  FE9
19D54:  MOVLW  07
19D56:  ADDWFC 03,W
19D58:  MOVWF  FEA
19D5A:  MOVFF  FEC,8D1
19D5E:  MOVF   FED,F
19D60:  MOVFF  FEF,8D0
19D64:  MOVLW  A8
19D66:  MOVLB  8
19D68:  MOVWF  xCF
19D6A:  MOVLB  0
19D6C:  CALL   4F68
....................             break;             
....................       } 
....................    } 
19D70:  BRA    19D76
....................    else cmd_arg();    
19D72:  CALL   AF88
19D76:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
19D7A:  MOVF   48,F
19D7C:  BNZ   19D8E
19D7E:  MOVF   49,F
19D80:  BNZ   19D8E
19D82:  MOVF   4A,F
19D84:  BNZ   19D8E
19D86:  MOVF   4B,F
19D88:  BNZ   19D8E
19D8A:  BCF    F8E.1
19D8C:  BRA    19D92
....................    else cmd_arg();    
19D8E:  CALL   AF88
19D92:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1A876:  MOVF   48,F
1A878:  BNZ   1A8C8
1A87A:  MOVF   49,F
1A87C:  BNZ   1A8C8
1A87E:  MOVF   4A,F
1A880:  BNZ   1A8C8
1A882:  MOVF   4B,F
1A884:  BNZ   1A8C8
....................       switch (nv_product) { 
1A886:  MOVFF  2F,00
1A88A:  MOVF   30,W
1A88C:  MOVWF  03
1A88E:  BNZ   1A894
1A890:  MOVF   00,F
1A892:  BZ    1A8B4
1A894:  MOVF   03,W
1A896:  BNZ   1A89E
1A898:  MOVLW  01
1A89A:  SUBWF  00,W
1A89C:  BZ    1A8BA
1A89E:  MOVF   03,W
1A8A0:  BNZ   1A8A8
1A8A2:  MOVLW  02
1A8A4:  SUBWF  00,W
1A8A6:  BZ    1A8C0
1A8A8:  MOVF   03,W
1A8AA:  BNZ   1A8B2
1A8AC:  MOVLW  03
1A8AE:  SUBWF  00,W
1A8B0:  BZ    1A8C4
1A8B2:  BRA    1A8C6
....................          case ECO : rst_step_vars_eco(); 
1A8B4:  GOTO   19D96
....................             break; 
1A8B8:  BRA    1A8C6
....................          case WMS4 : rst_step_vars_wms4(); 
1A8BA:  GOTO   1A080
....................             break; 
1A8BE:  BRA    1A8C6
....................          case AWS : rst_step_vars_aws(); 
1A8C0:  BRA    1A32C
....................             break;             
1A8C2:  BRA    1A8C6
....................          case WMS2 : rst_step_vars_wms2(); 
1A8C4:  BRA    1A5C6
....................             break; 
....................       } 
....................    }  
1A8C6:  BRA    1A8CC
....................    else cmd_arg(); 
1A8C8:  CALL   AF88
1A8CC:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1A8D0:  MOVF   4B,F
1A8D2:  BTFSS  FD8.2
1A8D4:  BRA    1A9D6
1A8D6:  MOVF   4A,W
1A8D8:  SUBLW  00
1A8DA:  BTFSS  FD8.0
1A8DC:  BRA    1A9D6
....................       m_spr[motor] = arg; 
1A8DE:  BCF    FD8.0
1A8E0:  MOVLB  7
1A8E2:  RLCF   x40,W
1A8E4:  CLRF   03
1A8E6:  ADDLW  76
1A8E8:  MOVWF  FE9
1A8EA:  MOVLW  07
1A8EC:  ADDWFC 03,W
1A8EE:  MOVWF  FEA
1A8F0:  MOVFF  48,FEF
1A8F4:  MOVFF  49,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1A8F8:  BCF    FD8.0
1A8FA:  RLCF   x40,W
1A8FC:  CLRF   03
1A8FE:  ADDLW  AB
1A900:  MOVWF  01
1A902:  MOVLW  07
1A904:  ADDWFC 03,F
1A906:  MOVFF  01,866
1A90A:  MOVLB  8
1A90C:  MOVFF  03,867
1A910:  BCF    FD8.0
1A912:  MOVLB  7
1A914:  RLCF   x40,W
1A916:  CLRF   03
1A918:  ADDLW  76
1A91A:  MOVWF  FE9
1A91C:  MOVLW  07
1A91E:  ADDWFC 03,W
1A920:  MOVWF  FEA
1A922:  MOVFF  FEC,8BD
1A926:  MOVF   FED,F
1A928:  MOVFF  FEF,8BC
1A92C:  BCF    FD8.0
1A92E:  RLCF   x40,W
1A930:  CLRF   03
1A932:  ADDLW  62
1A934:  MOVWF  FE9
1A936:  MOVLW  07
1A938:  ADDWFC 03,W
1A93A:  MOVWF  FEA
1A93C:  MOVFF  FEC,03
1A940:  MOVF   FED,F
1A942:  MOVFF  FEF,8BE
1A946:  MOVFF  03,86B
1A94A:  MOVFF  03,8BF
1A94E:  MOVLB  0
1A950:  CALL   2C70
1A954:  MOVFF  02,869
1A958:  BCF    FD8.0
1A95A:  MOVLB  8
1A95C:  RLCF   01,W
1A95E:  MOVWF  02
1A960:  RLCF   x69,W
1A962:  MOVFF  867,FEA
1A966:  MOVFF  866,FE9
1A96A:  MOVWF  FEC
1A96C:  MOVF   FED,F
1A96E:  MOVFF  02,FEF
....................       switch(motor){ 
1A972:  MOVLB  7
1A974:  MOVF   x40,W
1A976:  XORLW  00
1A978:  MOVLB  0
1A97A:  BZ    1A982
1A97C:  XORLW  01
1A97E:  BZ    1A9AC
1A980:  BRA    1A9D4
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1A982:  BCF    FD8.0
1A984:  MOVLB  7
1A986:  RLCF   x40,W
1A988:  CLRF   03
1A98A:  ADDLW  76
1A98C:  MOVWF  FE9
1A98E:  MOVLW  07
1A990:  ADDWFC 03,W
1A992:  MOVWF  FEA
1A994:  MOVFF  FEC,8D1
1A998:  MOVF   FED,F
1A99A:  MOVFF  FEF,8D0
1A99E:  MOVLW  AE
1A9A0:  MOVLB  8
1A9A2:  MOVWF  xCF
1A9A4:  MOVLB  0
1A9A6:  CALL   4F68
....................             break; 
1A9AA:  BRA    1A9D4
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1A9AC:  BCF    FD8.0
1A9AE:  MOVLB  7
1A9B0:  RLCF   x40,W
1A9B2:  CLRF   03
1A9B4:  ADDLW  76
1A9B6:  MOVWF  FE9
1A9B8:  MOVLW  07
1A9BA:  ADDWFC 03,W
1A9BC:  MOVWF  FEA
1A9BE:  MOVFF  FEC,8D1
1A9C2:  MOVF   FED,F
1A9C4:  MOVFF  FEF,8D0
1A9C8:  MOVLW  B0
1A9CA:  MOVLB  8
1A9CC:  MOVWF  xCF
1A9CE:  MOVLB  0
1A9D0:  CALL   4F68
....................             break;             
....................       } 
....................    } 
1A9D4:  BRA    1A9DA
....................    else cmd_arg();    
1A9D6:  CALL   AF88
1A9DA:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1A9DE:  MOVF   4B,F
1A9E0:  BNZ   1AA6C
1A9E2:  MOVF   4A,F
1A9E4:  BNZ   1AA6C
1A9E6:  MOVF   49,F
1A9E8:  BNZ   1AA6C
1A9EA:  MOVF   48,W
1A9EC:  SUBLW  02
1A9EE:  BNC   1AA6C
....................       e_type[motor] = arg; 
1A9F0:  BCF    FD8.0
1A9F2:  MOVLB  7
1A9F4:  RLCF   x40,W
1A9F6:  CLRF   03
1A9F8:  ADDLW  6A
1A9FA:  MOVWF  FE9
1A9FC:  MOVLW  07
1A9FE:  ADDWFC 03,W
1AA00:  MOVWF  FEA
1AA02:  MOVFF  48,FEF
1AA06:  MOVFF  49,FEC
....................       switch(motor){ 
1AA0A:  MOVF   x40,W
1AA0C:  XORLW  00
1AA0E:  MOVLB  0
1AA10:  BZ    1AA18
1AA12:  XORLW  01
1AA14:  BZ    1AA42
1AA16:  BRA    1AA6A
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1AA18:  BCF    FD8.0
1AA1A:  MOVLB  7
1AA1C:  RLCF   x40,W
1AA1E:  CLRF   03
1AA20:  ADDLW  6A
1AA22:  MOVWF  FE9
1AA24:  MOVLW  07
1AA26:  ADDWFC 03,W
1AA28:  MOVWF  FEA
1AA2A:  MOVFF  FEC,8D1
1AA2E:  MOVF   FED,F
1AA30:  MOVFF  FEF,8D0
1AA34:  MOVLW  7A
1AA36:  MOVLB  8
1AA38:  MOVWF  xCF
1AA3A:  MOVLB  0
1AA3C:  CALL   4F68
....................             break; 
1AA40:  BRA    1AA6A
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1AA42:  BCF    FD8.0
1AA44:  MOVLB  7
1AA46:  RLCF   x40,W
1AA48:  CLRF   03
1AA4A:  ADDLW  6A
1AA4C:  MOVWF  FE9
1AA4E:  MOVLW  07
1AA50:  ADDWFC 03,W
1AA52:  MOVWF  FEA
1AA54:  MOVFF  FEC,8D1
1AA58:  MOVF   FED,F
1AA5A:  MOVFF  FEF,8D0
1AA5E:  MOVLW  7C
1AA60:  MOVLB  8
1AA62:  MOVWF  xCF
1AA64:  MOVLB  0
1AA66:  CALL   4F68
....................             break;             
....................       } 
....................    } 
1AA6A:  BRA    1AA70
....................    else cmd_arg();    
1AA6C:  CALL   AF88
1AA70:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... //currently used to test dio pins 
.................... void command_v(){ 
....................    if(arg == 00){ 
*
1AAAC:  MOVF   48,F
1AAAE:  BNZ   1AAC0
1AAB0:  MOVF   49,F
1AAB2:  BNZ   1AAC0
1AAB4:  MOVF   4A,F
1AAB6:  BNZ   1AAC0
1AAB8:  MOVF   4B,F
1AABA:  BNZ   1AAC0
....................       output_bit(PIN_D0,0); 
1AABC:  BCF    F8C.0
....................    }else if(arg == 01){ 
1AABE:  BRA    1AC06
1AAC0:  DECFSZ 48,W
1AAC2:  BRA    1AAD4
1AAC4:  MOVF   49,F
1AAC6:  BNZ   1AAD4
1AAC8:  MOVF   4A,F
1AACA:  BNZ   1AAD4
1AACC:  MOVF   4B,F
1AACE:  BNZ   1AAD4
....................       output_bit(PIN_D0,1); 
1AAD0:  BSF    F8C.0
....................    }else if(arg == 10){ 
1AAD2:  BRA    1AC06
1AAD4:  MOVF   48,W
1AAD6:  SUBLW  0A
1AAD8:  BNZ   1AAEA
1AADA:  MOVF   49,F
1AADC:  BNZ   1AAEA
1AADE:  MOVF   4A,F
1AAE0:  BNZ   1AAEA
1AAE2:  MOVF   4B,F
1AAE4:  BNZ   1AAEA
....................       output_bit(PIN_D1,0); 
1AAE6:  BCF    F8C.1
....................    }else if(arg == 11){ 
1AAE8:  BRA    1AC06
1AAEA:  MOVF   48,W
1AAEC:  SUBLW  0B
1AAEE:  BNZ   1AB00
1AAF0:  MOVF   49,F
1AAF2:  BNZ   1AB00
1AAF4:  MOVF   4A,F
1AAF6:  BNZ   1AB00
1AAF8:  MOVF   4B,F
1AAFA:  BNZ   1AB00
....................       output_bit(PIN_D1,1); 
1AAFC:  BSF    F8C.1
....................    }else if(arg == 20){ 
1AAFE:  BRA    1AC06
1AB00:  MOVF   48,W
1AB02:  SUBLW  14
1AB04:  BNZ   1AB16
1AB06:  MOVF   49,F
1AB08:  BNZ   1AB16
1AB0A:  MOVF   4A,F
1AB0C:  BNZ   1AB16
1AB0E:  MOVF   4B,F
1AB10:  BNZ   1AB16
....................       output_bit(PIN_D2,0); 
1AB12:  BCF    F8C.2
....................    }else if(arg == 21){ 
1AB14:  BRA    1AC06
1AB16:  MOVF   48,W
1AB18:  SUBLW  15
1AB1A:  BNZ   1AB2C
1AB1C:  MOVF   49,F
1AB1E:  BNZ   1AB2C
1AB20:  MOVF   4A,F
1AB22:  BNZ   1AB2C
1AB24:  MOVF   4B,F
1AB26:  BNZ   1AB2C
....................       output_bit(PIN_D2,1); 
1AB28:  BSF    F8C.2
....................    }else if(arg == 30){ 
1AB2A:  BRA    1AC06
1AB2C:  MOVF   48,W
1AB2E:  SUBLW  1E
1AB30:  BNZ   1AB42
1AB32:  MOVF   49,F
1AB34:  BNZ   1AB42
1AB36:  MOVF   4A,F
1AB38:  BNZ   1AB42
1AB3A:  MOVF   4B,F
1AB3C:  BNZ   1AB42
....................       output_bit(PIN_D3,0); 
1AB3E:  BCF    F8C.3
....................    }else if(arg == 31){ 
1AB40:  BRA    1AC06
1AB42:  MOVF   48,W
1AB44:  SUBLW  1F
1AB46:  BNZ   1AB58
1AB48:  MOVF   49,F
1AB4A:  BNZ   1AB58
1AB4C:  MOVF   4A,F
1AB4E:  BNZ   1AB58
1AB50:  MOVF   4B,F
1AB52:  BNZ   1AB58
....................       output_bit(PIN_D3,1); 
1AB54:  BSF    F8C.3
....................    }else if(arg == 40){ 
1AB56:  BRA    1AC06
1AB58:  MOVF   48,W
1AB5A:  SUBLW  28
1AB5C:  BNZ   1AB6E
1AB5E:  MOVF   49,F
1AB60:  BNZ   1AB6E
1AB62:  MOVF   4A,F
1AB64:  BNZ   1AB6E
1AB66:  MOVF   4B,F
1AB68:  BNZ   1AB6E
....................       output_bit(PIN_D4,0); 
1AB6A:  BCF    F8C.4
....................    }else if(arg == 41){ 
1AB6C:  BRA    1AC06
1AB6E:  MOVF   48,W
1AB70:  SUBLW  29
1AB72:  BNZ   1AB84
1AB74:  MOVF   49,F
1AB76:  BNZ   1AB84
1AB78:  MOVF   4A,F
1AB7A:  BNZ   1AB84
1AB7C:  MOVF   4B,F
1AB7E:  BNZ   1AB84
....................       output_bit(PIN_D4,1); 
1AB80:  BSF    F8C.4
....................    }else if(arg == 50){ 
1AB82:  BRA    1AC06
1AB84:  MOVF   48,W
1AB86:  SUBLW  32
1AB88:  BNZ   1AB9A
1AB8A:  MOVF   49,F
1AB8C:  BNZ   1AB9A
1AB8E:  MOVF   4A,F
1AB90:  BNZ   1AB9A
1AB92:  MOVF   4B,F
1AB94:  BNZ   1AB9A
....................       output_bit(PIN_D5,0); 
1AB96:  BCF    F8C.5
....................    }else if(arg == 51){ 
1AB98:  BRA    1AC06
1AB9A:  MOVF   48,W
1AB9C:  SUBLW  33
1AB9E:  BNZ   1ABB0
1ABA0:  MOVF   49,F
1ABA2:  BNZ   1ABB0
1ABA4:  MOVF   4A,F
1ABA6:  BNZ   1ABB0
1ABA8:  MOVF   4B,F
1ABAA:  BNZ   1ABB0
....................       output_bit(PIN_D5,1); 
1ABAC:  BSF    F8C.5
....................    }else if(arg == 60){ 
1ABAE:  BRA    1AC06
1ABB0:  MOVF   48,W
1ABB2:  SUBLW  3C
1ABB4:  BNZ   1ABC6
1ABB6:  MOVF   49,F
1ABB8:  BNZ   1ABC6
1ABBA:  MOVF   4A,F
1ABBC:  BNZ   1ABC6
1ABBE:  MOVF   4B,F
1ABC0:  BNZ   1ABC6
....................       output_bit(PIN_D6,0); 
1ABC2:  BCF    F8C.6
....................    }else if(arg == 61){ 
1ABC4:  BRA    1AC06
1ABC6:  MOVF   48,W
1ABC8:  SUBLW  3D
1ABCA:  BNZ   1ABDC
1ABCC:  MOVF   49,F
1ABCE:  BNZ   1ABDC
1ABD0:  MOVF   4A,F
1ABD2:  BNZ   1ABDC
1ABD4:  MOVF   4B,F
1ABD6:  BNZ   1ABDC
....................       output_bit(PIN_D6,1); 
1ABD8:  BSF    F8C.6
....................    }else if(arg == 70){ 
1ABDA:  BRA    1AC06
1ABDC:  MOVF   48,W
1ABDE:  SUBLW  46
1ABE0:  BNZ   1ABF2
1ABE2:  MOVF   49,F
1ABE4:  BNZ   1ABF2
1ABE6:  MOVF   4A,F
1ABE8:  BNZ   1ABF2
1ABEA:  MOVF   4B,F
1ABEC:  BNZ   1ABF2
....................       output_bit(PIN_D7,0); 
1ABEE:  BCF    F8C.7
....................    }else if(arg == 71){ 
1ABF0:  BRA    1AC06
1ABF2:  MOVF   48,W
1ABF4:  SUBLW  47
1ABF6:  BNZ   1AC06
1ABF8:  MOVF   49,F
1ABFA:  BNZ   1AC06
1ABFC:  MOVF   4A,F
1ABFE:  BNZ   1AC06
1AC00:  MOVF   4B,F
1AC02:  BNZ   1AC06
....................       output_bit(PIN_D7,1); 
1AC04:  BSF    F8C.7
....................    } 
1AC06:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
1AC0A:  MOVF   4B,F
1AC0C:  BNZ   1ACD6
1AC0E:  MOVF   4A,F
1AC10:  BNZ   1ACD6
1AC12:  MOVF   49,F
1AC14:  BNZ   1ACD6
1AC16:  MOVF   48,W
1AC18:  SUBLW  64
1AC1A:  BNC   1ACD6
....................       drive_pc=arg; 
1AC1C:  MOVFF  49,867
1AC20:  MOVFF  48,866
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1AC24:  BCF    FD8.0
1AC26:  MOVLB  7
1AC28:  RLCF   x40,W
1AC2A:  CLRF   03
1AC2C:  ADDLW  56
1AC2E:  MOVWF  FE9
1AC30:  MOVLW  07
1AC32:  ADDWFC 03,W
1AC34:  MOVWF  FEA
1AC36:  MOVFF  867,9EE
1AC3A:  MOVFF  866,9ED
1AC3E:  MOVLW  01
1AC40:  MOVLB  9
1AC42:  MOVWF  xF0
1AC44:  SETF   xEF
1AC46:  MOVLB  0
1AC48:  CALL   5C32
1AC4C:  MOVFF  02,86B
1AC50:  MOVFF  01,86A
1AC54:  MOVFF  02,8BD
1AC58:  MOVFF  01,8BC
1AC5C:  MOVLB  8
1AC5E:  CLRF   xBF
1AC60:  MOVLW  64
1AC62:  MOVWF  xBE
1AC64:  MOVLB  0
1AC66:  CALL   2C70
1AC6A:  MOVFF  01,FEF
1AC6E:  MOVFF  02,FEC
....................       switch(motor){ 
1AC72:  MOVLB  7
1AC74:  MOVF   x40,W
1AC76:  XORLW  00
1AC78:  MOVLB  0
1AC7A:  BZ    1AC82
1AC7C:  XORLW  01
1AC7E:  BZ    1ACAC
1AC80:  BRA    1ACD4
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1AC82:  BCF    FD8.0
1AC84:  MOVLB  7
1AC86:  RLCF   x40,W
1AC88:  CLRF   03
1AC8A:  ADDLW  56
1AC8C:  MOVWF  FE9
1AC8E:  MOVLW  07
1AC90:  ADDWFC 03,W
1AC92:  MOVWF  FEA
1AC94:  MOVFF  FEC,8D1
1AC98:  MOVF   FED,F
1AC9A:  MOVFF  FEF,8D0
1AC9E:  MOVLW  9A
1ACA0:  MOVLB  8
1ACA2:  MOVWF  xCF
1ACA4:  MOVLB  0
1ACA6:  CALL   4F68
....................             break; 
1ACAA:  BRA    1ACD4
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1ACAC:  BCF    FD8.0
1ACAE:  MOVLB  7
1ACB0:  RLCF   x40,W
1ACB2:  CLRF   03
1ACB4:  ADDLW  56
1ACB6:  MOVWF  FE9
1ACB8:  MOVLW  07
1ACBA:  ADDWFC 03,W
1ACBC:  MOVWF  FEA
1ACBE:  MOVFF  FEC,8D1
1ACC2:  MOVF   FED,F
1ACC4:  MOVFF  FEF,8D0
1ACC8:  MOVLW  9C
1ACCA:  MOVLB  8
1ACCC:  MOVWF  xCF
1ACCE:  MOVLB  0
1ACD0:  CALL   4F68
....................             break;             
....................       } 
....................    } 
1ACD4:  BRA    1ACDA
....................    else cmd_arg();    
1ACD6:  CALL   AF88
1ACDA:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1ACDE:  MOVF   4B,F
1ACE0:  BNZ   1AD70
1ACE2:  MOVF   4A,F
1ACE4:  BNZ   1AD70
1ACE6:  MOVF   49,W
1ACE8:  SUBLW  27
1ACEA:  BNC   1AD70
1ACEC:  BNZ   1ACF4
1ACEE:  MOVF   48,W
1ACF0:  SUBLW  0F
1ACF2:  BNC   1AD70
....................        align_os[motor] = arg; 
1ACF4:  BCF    FD8.0
1ACF6:  MOVLB  7
1ACF8:  RLCF   x40,W
1ACFA:  CLRF   03
1ACFC:  ADDLW  82
1ACFE:  MOVWF  FE9
1AD00:  MOVLW  07
1AD02:  ADDWFC 03,W
1AD04:  MOVWF  FEA
1AD06:  MOVFF  48,FEF
1AD0A:  MOVFF  49,FEC
....................        switch(motor){ 
1AD0E:  MOVF   x40,W
1AD10:  XORLW  00
1AD12:  MOVLB  0
1AD14:  BZ    1AD1C
1AD16:  XORLW  01
1AD18:  BZ    1AD46
1AD1A:  BRA    1AD6E
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1AD1C:  BCF    FD8.0
1AD1E:  MOVLB  7
1AD20:  RLCF   x40,W
1AD22:  CLRF   03
1AD24:  ADDLW  82
1AD26:  MOVWF  FE9
1AD28:  MOVLW  07
1AD2A:  ADDWFC 03,W
1AD2C:  MOVWF  FEA
1AD2E:  MOVFF  FEC,8D1
1AD32:  MOVF   FED,F
1AD34:  MOVFF  FEF,8D0
1AD38:  MOVLW  C2
1AD3A:  MOVLB  8
1AD3C:  MOVWF  xCF
1AD3E:  MOVLB  0
1AD40:  CALL   4F68
....................             break; 
1AD44:  BRA    1AD6E
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1AD46:  BCF    FD8.0
1AD48:  MOVLB  7
1AD4A:  RLCF   x40,W
1AD4C:  CLRF   03
1AD4E:  ADDLW  82
1AD50:  MOVWF  FE9
1AD52:  MOVLW  07
1AD54:  ADDWFC 03,W
1AD56:  MOVWF  FEA
1AD58:  MOVFF  FEC,8D1
1AD5C:  MOVF   FED,F
1AD5E:  MOVFF  FEF,8D0
1AD62:  MOVLW  C4
1AD64:  MOVLB  8
1AD66:  MOVWF  xCF
1AD68:  MOVLB  0
1AD6A:  CALL   4F68
....................             break;             
....................       } 
....................    } 
1AD6E:  BRA    1AD74
....................    else cmd_arg();    
1AD70:  CALL   AF88
1AD74:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1AD78:  MOVF   4B,F
1AD7A:  BNZ   1AE06
1AD7C:  MOVF   4A,F
1AD7E:  BNZ   1AE06
1AD80:  MOVF   49,F
1AD82:  BNZ   1AE06
1AD84:  MOVF   48,W
1AD86:  SUBLW  01
1AD88:  BNC   1AE06
....................       m_ctrl[motor] = arg; 
1AD8A:  BCF    FD8.0
1AD8C:  MOVLB  7
1AD8E:  RLCF   x40,W
1AD90:  CLRF   03
1AD92:  ADDLW  42
1AD94:  MOVWF  FE9
1AD96:  MOVLW  07
1AD98:  ADDWFC 03,W
1AD9A:  MOVWF  FEA
1AD9C:  MOVFF  48,FEF
1ADA0:  MOVFF  49,FEC
....................       switch(motor){ 
1ADA4:  MOVF   x40,W
1ADA6:  XORLW  00
1ADA8:  MOVLB  0
1ADAA:  BZ    1ADB2
1ADAC:  XORLW  01
1ADAE:  BZ    1ADDC
1ADB0:  BRA    1AE04
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1ADB2:  BCF    FD8.0
1ADB4:  MOVLB  7
1ADB6:  RLCF   x40,W
1ADB8:  CLRF   03
1ADBA:  ADDLW  42
1ADBC:  MOVWF  FE9
1ADBE:  MOVLW  07
1ADC0:  ADDWFC 03,W
1ADC2:  MOVWF  FEA
1ADC4:  MOVFF  FEC,8D1
1ADC8:  MOVF   FED,F
1ADCA:  MOVFF  FEF,8D0
1ADCE:  MOVLW  86
1ADD0:  MOVLB  8
1ADD2:  MOVWF  xCF
1ADD4:  MOVLB  0
1ADD6:  CALL   4F68
....................             break; 
1ADDA:  BRA    1AE04
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1ADDC:  BCF    FD8.0
1ADDE:  MOVLB  7
1ADE0:  RLCF   x40,W
1ADE2:  CLRF   03
1ADE4:  ADDLW  42
1ADE6:  MOVWF  FE9
1ADE8:  MOVLW  07
1ADEA:  ADDWFC 03,W
1ADEC:  MOVWF  FEA
1ADEE:  MOVFF  FEC,8D1
1ADF2:  MOVF   FED,F
1ADF4:  MOVFF  FEF,8D0
1ADF8:  MOVLW  88
1ADFA:  MOVLB  8
1ADFC:  MOVWF  xCF
1ADFE:  MOVLB  0
1AE00:  CALL   4F68
....................             break;             
....................       } 
....................    } 
1AE04:  BRA    1AE0A
....................    else cmd_arg();    
1AE06:  CALL   AF88
1AE0A:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1AA74:  MOVF   48,W
1AA76:  MOVWF  00
1AA78:  MOVF   49,W
1AA7A:  MOVWF  03
1AA7C:  BNZ   1AA84
1AA7E:  MOVLW  01
1AA80:  SUBWF  00,W
1AA82:  BZ    1AA90
1AA84:  MOVF   03,W
1AA86:  BNZ   1AA8E
1AA88:  MOVLW  02
1AA8A:  SUBWF  00,W
1AA8C:  BZ    1AA96
1AA8E:  BRA    1AAA0
....................       case 1: motor = 0; 
1AA90:  MOVLB  7
1AA92:  CLRF   x40
....................          break; 
1AA94:  BRA    1AAA6
....................       case 2: motor = 1; 
1AA96:  MOVLW  01
1AA98:  MOVLB  7
1AA9A:  MOVWF  x40
....................          break; 
1AA9C:  BRA    1AAA6
1AA9E:  MOVLB  0
....................       default : cmd_arg(); 
1AAA0:  CALL   AF88
....................          break; 
1AAA4:  MOVLB  7
....................    } 
1AAA6:  MOVLB  0
1AAA8:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1AE0E:  MOVF   48,F
1AE10:  BNZ   1AE1E
1AE12:  MOVF   49,F
1AE14:  BNZ   1AE1E
1AE16:  MOVF   4A,F
1AE18:  BNZ   1AE1E
1AE1A:  MOVF   4B,F
1AE1C:  BZ    1AE7C
1AE1E:  MOVF   4B,F
1AE20:  BNZ   1AE7C
1AE22:  MOVF   4A,F
1AE24:  BNZ   1AE7C
1AE26:  MOVF   49,F
1AE28:  BNZ   1AE7C
1AE2A:  MOVF   48,W
1AE2C:  SUBLW  02
1AE2E:  BNC   1AE7C
....................       switch(arg){ 
1AE30:  MOVFF  48,00
1AE34:  MOVF   49,W
1AE36:  MOVWF  03
1AE38:  BNZ   1AE40
1AE3A:  MOVLW  01
1AE3C:  SUBWF  00,W
1AE3E:  BZ    1AE4C
1AE40:  MOVF   03,W
1AE42:  BNZ   1AE4A
1AE44:  MOVLW  02
1AE46:  SUBWF  00,W
1AE48:  BZ    1AE64
1AE4A:  BRA    1AE7A
....................          case 1 : e_pos[0] = 0; 
1AE4C:  MOVLB  7
1AE4E:  CLRF   xC0
1AE50:  CLRF   xBF
....................                   write16(ADDR_E1_POS, 0); 
1AE52:  MOVLW  7E
1AE54:  MOVLB  8
1AE56:  MOVWF  xCF
1AE58:  CLRF   xD1
1AE5A:  CLRF   xD0
1AE5C:  MOVLB  0
1AE5E:  CALL   4F68
....................             break; 
1AE62:  BRA    1AE7A
....................          case 2 : e_pos[1] = 0; 
1AE64:  MOVLB  7
1AE66:  CLRF   xC2
1AE68:  CLRF   xC1
....................                   write16(ADDR_E2_POS, 0); 
1AE6A:  MOVLW  80
1AE6C:  MOVLB  8
1AE6E:  MOVWF  xCF
1AE70:  CLRF   xD1
1AE72:  CLRF   xD0
1AE74:  MOVLB  0
1AE76:  CALL   4F68
....................             break;             
....................       } 
....................    } 
1AE7A:  BRA    1AE80
....................    else cmd_arg();  
1AE7C:  CALL   AF88
1AE80:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
18EBA:  DECFSZ 48,W
18EBC:  GOTO   19B12
18EC0:  MOVF   49,F
18EC2:  BTFSS  FD8.2
18EC4:  GOTO   19B12
18EC8:  MOVF   4A,F
18ECA:  BTFSS  FD8.2
18ECC:  GOTO   19B12
18ED0:  MOVF   4B,F
18ED2:  BTFSS  FD8.2
18ED4:  GOTO   19B12
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18ED8:  MOVFF  753,9EE
18EDC:  MOVFF  752,9ED
18EE0:  MOVLB  9
18EE2:  CLRF   xF0
18EE4:  MOVLW  64
18EE6:  MOVWF  xEF
18EE8:  MOVLB  0
18EEA:  CALL   5C32
18EEE:  MOVFF  02,86D
18EF2:  MOVFF  01,86C
18EF6:  MOVFF  02,8BD
18EFA:  MOVFF  01,8BC
18EFE:  MOVLW  01
18F00:  MOVLB  8
18F02:  MOVWF  xBF
18F04:  SETF   xBE
18F06:  MOVLB  0
18F08:  CALL   2C70
18F0C:  MOVFF  02,867
18F10:  MOVFF  01,866
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18F14:  MOVFF  757,9EE
18F18:  MOVFF  756,9ED
18F1C:  MOVLB  9
18F1E:  CLRF   xF0
18F20:  MOVLW  64
18F22:  MOVWF  xEF
18F24:  MOVLB  0
18F26:  CALL   5C32
18F2A:  MOVFF  02,86D
18F2E:  MOVFF  01,86C
18F32:  MOVFF  02,8BD
18F36:  MOVFF  01,8BC
18F3A:  MOVLW  01
18F3C:  MOVLB  8
18F3E:  MOVWF  xBF
18F40:  SETF   xBE
18F42:  MOVLB  0
18F44:  CALL   2C70
18F48:  MOVFF  02,869
18F4C:  MOVFF  01,868
....................       step_us  =   m_stp_int[0]*100; 
18F50:  MOVFF  74B,9EE
18F54:  MOVFF  74A,9ED
18F58:  MOVLB  9
18F5A:  CLRF   xF0
18F5C:  MOVLW  64
18F5E:  MOVWF  xEF
18F60:  MOVLB  0
18F62:  CALL   5C32
18F66:  MOVFF  02,86B
18F6A:  MOVFF  01,86A
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
18F6E:  MOVLW  1A
18F70:  MOVWF  FF6
18F72:  MOVLW  27
18F74:  MOVWF  FF7
18F76:  MOVLW  00
18F78:  MOVWF  FF8
18F7A:  CLRF   1B
18F7C:  BTFSC  FF2.7
18F7E:  BSF    1B.7
18F80:  BCF    FF2.7
18F82:  CALL   0E4E
18F86:  BTFSC  1B.7
18F88:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
18F8A:  MOVLW  62
18F8C:  BTFSS  F9E.4
18F8E:  BRA    18F8C
18F90:  MOVWF  FAD
18F92:  MOVLW  3A
18F94:  BTFSS  F9E.4
18F96:  BRA    18F94
18F98:  MOVWF  FAD
18F9A:  MOVLW  10
18F9C:  MOVWF  FE9
18F9E:  CLRF   1B
18FA0:  BTFSC  FF2.7
18FA2:  BSF    1B.7
18FA4:  BCF    FF2.7
18FA6:  MOVFF  773,A1D
18FAA:  MOVFF  772,A1C
18FAE:  CALL   11A6
18FB2:  BTFSC  1B.7
18FB4:  BSF    FF2.7
18FB6:  MOVLW  0D
18FB8:  BTFSS  F9E.4
18FBA:  BRA    18FB8
18FBC:  MOVWF  FAD
18FBE:  MOVLW  0A
18FC0:  BTFSS  F9E.4
18FC2:  BRA    18FC0
18FC4:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
18FC6:  MOVLW  63
18FC8:  BTFSS  F9E.4
18FCA:  BRA    18FC8
18FCC:  MOVWF  FAD
18FCE:  MOVLW  3A
18FD0:  BTFSS  F9E.4
18FD2:  BRA    18FD0
18FD4:  MOVWF  FAD
18FD6:  MOVLW  41
18FD8:  MOVWF  FE9
18FDA:  CLRF   1B
18FDC:  BTFSC  FF2.7
18FDE:  BSF    1B.7
18FE0:  BCF    FF2.7
18FE2:  MOVFF  7A5,A1F
18FE6:  MOVFF  7A4,A1E
18FEA:  MOVFF  7A3,A1D
18FEE:  MOVFF  7A2,A1C
18FF2:  CALL   10EA
18FF6:  BTFSC  1B.7
18FF8:  BSF    FF2.7
18FFA:  MOVLW  2F
18FFC:  BTFSS  F9E.4
18FFE:  BRA    18FFC
19000:  MOVWF  FAD
19002:  MOVLW  10
19004:  MOVWF  FE9
19006:  CLRF   1B
19008:  BTFSC  FF2.7
1900A:  BSF    1B.7
1900C:  BCF    FF2.7
1900E:  MOVFF  7BC,A1D
19012:  MOVFF  7BB,A1C
19016:  CALL   11A6
1901A:  BTFSC  1B.7
1901C:  BSF    FF2.7
1901E:  MOVLW  2F
19020:  BTFSS  F9E.4
19022:  BRA    19020
19024:  MOVWF  FAD
19026:  MOVLW  10
19028:  MOVWF  FE9
1902A:  CLRF   1B
1902C:  BTFSC  FF2.7
1902E:  BSF    1B.7
19030:  BCF    FF2.7
19032:  MOVFF  7C0,A1D
19036:  MOVFF  7BF,A1C
1903A:  CALL   11A6
1903E:  BTFSC  1B.7
19040:  BSF    FF2.7
19042:  MOVLW  0D
19044:  BTFSS  F9E.4
19046:  BRA    19044
19048:  MOVWF  FAD
1904A:  MOVLW  0A
1904C:  BTFSS  F9E.4
1904E:  BRA    1904C
19050:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
19052:  MOVLW  64
19054:  BTFSS  F9E.4
19056:  BRA    19054
19058:  MOVWF  FAD
1905A:  MOVLW  3A
1905C:  BTFSS  F9E.4
1905E:  BRA    1905C
19060:  MOVWF  FAD
19062:  MOVLW  10
19064:  MOVWF  FE9
19066:  CLRF   1B
19068:  BTFSC  FF2.7
1906A:  BSF    1B.7
1906C:  BCF    FF2.7
1906E:  MOVFF  74F,A1D
19072:  MOVFF  74E,A1C
19076:  CALL   11A6
1907A:  BTFSC  1B.7
1907C:  BSF    FF2.7
1907E:  MOVLW  0D
19080:  BTFSS  F9E.4
19082:  BRA    19080
19084:  MOVWF  FAD
19086:  MOVLW  0A
19088:  BTFSS  F9E.4
1908A:  BRA    19088
1908C:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
1908E:  MOVLW  65
19090:  BTFSS  F9E.4
19092:  BRA    19090
19094:  MOVWF  FAD
19096:  MOVLW  3A
19098:  BTFSS  F9E.4
1909A:  BRA    19098
1909C:  MOVWF  FAD
1909E:  MOVLW  10
190A0:  MOVWF  FE9
190A2:  CLRF   1B
190A4:  BTFSC  FF2.7
190A6:  BSF    1B.7
190A8:  BCF    FF2.7
190AA:  MOVFF  75F,A1D
190AE:  MOVFF  75E,A1C
190B2:  CALL   11A6
190B6:  BTFSC  1B.7
190B8:  BSF    FF2.7
190BA:  MOVLW  0D
190BC:  BTFSS  F9E.4
190BE:  BRA    190BC
190C0:  MOVWF  FAD
190C2:  MOVLW  0A
190C4:  BTFSS  F9E.4
190C6:  BRA    190C4
190C8:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
190CA:  MOVLW  66
190CC:  BTFSS  F9E.4
190CE:  BRA    190CC
190D0:  MOVWF  FAD
190D2:  MOVLW  3A
190D4:  BTFSS  F9E.4
190D6:  BRA    190D4
190D8:  MOVWF  FAD
190DA:  CLRF   1B
190DC:  BTFSC  FF2.7
190DE:  BSF    1B.7
190E0:  BCF    FF2.7
190E2:  MOVFF  741,A1C
190E6:  MOVLW  1B
190E8:  MOVLB  A
190EA:  MOVWF  x1D
190EC:  MOVLB  0
190EE:  CALL   0FA6
190F2:  BTFSC  1B.7
190F4:  BSF    FF2.7
190F6:  MOVLW  0D
190F8:  BTFSS  F9E.4
190FA:  BRA    190F8
190FC:  MOVWF  FAD
190FE:  MOVLW  0A
19100:  BTFSS  F9E.4
19102:  BRA    19100
19104:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
19106:  MOVLW  67
19108:  BTFSS  F9E.4
1910A:  BRA    19108
1910C:  MOVWF  FAD
1910E:  MOVLW  3A
19110:  BTFSS  F9E.4
19112:  BRA    19110
19114:  MOVWF  FAD
19116:  MOVLW  10
19118:  MOVWF  FE9
1911A:  CLRF   1B
1911C:  BTFSC  FF2.7
1911E:  BSF    1B.7
19120:  BCF    FF2.7
19122:  MOVFF  75B,A1D
19126:  MOVFF  75A,A1C
1912A:  CALL   11A6
1912E:  BTFSC  1B.7
19130:  BSF    FF2.7
19132:  MOVLW  0D
19134:  BTFSS  F9E.4
19136:  BRA    19134
19138:  MOVWF  FAD
1913A:  MOVLW  0A
1913C:  BTFSS  F9E.4
1913E:  BRA    1913C
19140:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19142:  MOVLW  68
19144:  BTFSS  F9E.4
19146:  BRA    19144
19148:  MOVWF  FAD
1914A:  MOVLW  3A
1914C:  BTFSS  F9E.4
1914E:  BRA    1914C
19150:  MOVWF  FAD
19152:  MOVLW  10
19154:  MOVWF  FE9
19156:  CLRF   1B
19158:  BTFSC  FF2.7
1915A:  BSF    1B.7
1915C:  BCF    FF2.7
1915E:  MOVFF  867,A1D
19162:  MOVFF  866,A1C
19166:  CALL   11A6
1916A:  BTFSC  1B.7
1916C:  BSF    FF2.7
1916E:  MOVLW  0D
19170:  BTFSS  F9E.4
19172:  BRA    19170
19174:  MOVWF  FAD
19176:  MOVLW  0A
19178:  BTFSS  F9E.4
1917A:  BRA    19178
1917C:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
1917E:  MOVLW  69
19180:  BTFSS  F9E.4
19182:  BRA    19180
19184:  MOVWF  FAD
19186:  MOVLW  3A
19188:  BTFSS  F9E.4
1918A:  BRA    19188
1918C:  MOVWF  FAD
1918E:  MOVLW  10
19190:  MOVWF  FE9
19192:  CLRF   1B
19194:  BTFSC  FF2.7
19196:  BSF    1B.7
19198:  BCF    FF2.7
1919A:  MOVFF  86B,A1D
1919E:  MOVFF  86A,A1C
191A2:  CALL   11A6
191A6:  BTFSC  1B.7
191A8:  BSF    FF2.7
191AA:  MOVLW  0D
191AC:  BTFSS  F9E.4
191AE:  BRA    191AC
191B0:  MOVWF  FAD
191B2:  MOVLW  0A
191B4:  BTFSS  F9E.4
191B6:  BRA    191B4
191B8:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
191BA:  MOVLW  6A
191BC:  BTFSS  F9E.4
191BE:  BRA    191BC
191C0:  MOVWF  FAD
191C2:  MOVLW  3A
191C4:  BTFSS  F9E.4
191C6:  BRA    191C4
191C8:  MOVWF  FAD
191CA:  MOVLW  10
191CC:  MOVWF  FE9
191CE:  CLRF   1B
191D0:  BTFSC  FF2.7
191D2:  BSF    1B.7
191D4:  BCF    FF2.7
191D6:  MOVFF  76F,A1D
191DA:  MOVFF  76E,A1C
191DE:  CALL   11A6
191E2:  BTFSC  1B.7
191E4:  BSF    FF2.7
191E6:  MOVLW  0D
191E8:  BTFSS  F9E.4
191EA:  BRA    191E8
191EC:  MOVWF  FAD
191EE:  MOVLW  0A
191F0:  BTFSS  F9E.4
191F2:  BRA    191F0
191F4:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
191F6:  MOVLW  6B
191F8:  BTFSS  F9E.4
191FA:  BRA    191F8
191FC:  MOVWF  FAD
191FE:  MOVLW  3A
19200:  BTFSS  F9E.4
19202:  BRA    19200
19204:  MOVWF  FAD
19206:  MOVLW  10
19208:  MOVWF  FE9
1920A:  CLRF   1B
1920C:  BTFSC  FF2.7
1920E:  BSF    1B.7
19210:  BCF    FF2.7
19212:  MOVFF  767,A1D
19216:  MOVFF  766,A1C
1921A:  CALL   11A6
1921E:  BTFSC  1B.7
19220:  BSF    FF2.7
19222:  MOVLW  0D
19224:  BTFSS  F9E.4
19226:  BRA    19224
19228:  MOVWF  FAD
1922A:  MOVLW  0A
1922C:  BTFSS  F9E.4
1922E:  BRA    1922C
19230:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
19232:  MOVLW  6D
19234:  BTFSS  F9E.4
19236:  BRA    19234
19238:  MOVWF  FAD
1923A:  MOVLW  3A
1923C:  BTFSS  F9E.4
1923E:  BRA    1923C
19240:  MOVWF  FAD
19242:  MOVLW  10
19244:  MOVWF  FE9
19246:  CLRF   1B
19248:  BTFSC  FF2.7
1924A:  BSF    1B.7
1924C:  BCF    FF2.7
1924E:  MOVFF  747,A1D
19252:  MOVFF  746,A1C
19256:  CALL   11A6
1925A:  BTFSC  1B.7
1925C:  BSF    FF2.7
1925E:  MOVLW  0D
19260:  BTFSS  F9E.4
19262:  BRA    19260
19264:  MOVWF  FAD
19266:  MOVLW  0A
19268:  BTFSS  F9E.4
1926A:  BRA    19268
1926C:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
1926E:  MOVLW  6E
19270:  BTFSS  F9E.4
19272:  BRA    19270
19274:  MOVWF  FAD
19276:  MOVLW  3A
19278:  BTFSS  F9E.4
1927A:  BRA    19278
1927C:  MOVWF  FAD
1927E:  MOVLW  10
19280:  MOVWF  FE9
19282:  CLRF   1B
19284:  BTFSC  FF2.7
19286:  BSF    1B.7
19288:  BCF    FF2.7
1928A:  MOVFF  77B,A1D
1928E:  MOVFF  77A,A1C
19292:  CALL   11A6
19296:  BTFSC  1B.7
19298:  BSF    FF2.7
1929A:  MOVLW  0D
1929C:  BTFSS  F9E.4
1929E:  BRA    1929C
192A0:  MOVWF  FAD
192A2:  MOVLW  0A
192A4:  BTFSS  F9E.4
192A6:  BRA    192A4
192A8:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
192AA:  MOVLW  6F
192AC:  BTFSS  F9E.4
192AE:  BRA    192AC
192B0:  MOVWF  FAD
192B2:  MOVLW  3A
192B4:  BTFSS  F9E.4
192B6:  BRA    192B4
192B8:  MOVWF  FAD
192BA:  MOVLW  10
192BC:  MOVWF  FE9
192BE:  CLRF   1B
192C0:  BTFSC  FF2.7
192C2:  BSF    1B.7
192C4:  BCF    FF2.7
192C6:  MOVFF  77F,A1D
192CA:  MOVFF  77E,A1C
192CE:  CALL   11A6
192D2:  BTFSC  1B.7
192D4:  BSF    FF2.7
192D6:  MOVLW  0D
192D8:  BTFSS  F9E.4
192DA:  BRA    192D8
192DC:  MOVWF  FAD
192DE:  MOVLW  0A
192E0:  BTFSS  F9E.4
192E2:  BRA    192E0
192E4:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
192E6:  MOVLW  70
192E8:  BTFSS  F9E.4
192EA:  BRA    192E8
192EC:  MOVWF  FAD
192EE:  MOVLW  3A
192F0:  BTFSS  F9E.4
192F2:  BRA    192F0
192F4:  MOVWF  FAD
192F6:  MOVLW  10
192F8:  MOVWF  FE9
192FA:  CLRF   1B
192FC:  BTFSC  FF2.7
192FE:  BSF    1B.7
19300:  BCF    FF2.7
19302:  MOVFF  7C4,A1D
19306:  MOVFF  7C3,A1C
1930A:  CALL   11A6
1930E:  BTFSC  1B.7
19310:  BSF    FF2.7
19312:  MOVLW  2F
19314:  BTFSS  F9E.4
19316:  BRA    19314
19318:  MOVWF  FAD
1931A:  MOVLW  10
1931C:  MOVWF  FE9
1931E:  CLRF   1B
19320:  BTFSC  FF2.7
19322:  BSF    1B.7
19324:  BCF    FF2.7
19326:  MOVFF  763,A1D
1932A:  MOVFF  762,A1C
1932E:  CALL   11A6
19332:  BTFSC  1B.7
19334:  BSF    FF2.7
19336:  MOVLW  0D
19338:  BTFSS  F9E.4
1933A:  BRA    19338
1933C:  MOVWF  FAD
1933E:  MOVLW  0A
19340:  BTFSS  F9E.4
19342:  BRA    19340
19344:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
19346:  MOVLW  71
19348:  BTFSS  F9E.4
1934A:  BRA    19348
1934C:  MOVWF  FAD
1934E:  MOVLW  3A
19350:  BTFSS  F9E.4
19352:  BRA    19350
19354:  MOVWF  FAD
19356:  MOVLW  10
19358:  MOVWF  FE9
1935A:  CLRF   1B
1935C:  BTFSC  FF2.7
1935E:  BSF    1B.7
19360:  BCF    FF2.7
19362:  MOVFF  797,A1D
19366:  MOVFF  796,A1C
1936A:  CALL   11A6
1936E:  BTFSC  1B.7
19370:  BSF    FF2.7
19372:  MOVLW  0D
19374:  BTFSS  F9E.4
19376:  BRA    19374
19378:  MOVWF  FAD
1937A:  MOVLW  0A
1937C:  BTFSS  F9E.4
1937E:  BRA    1937C
19380:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
19382:  MOVLW  73
19384:  BTFSS  F9E.4
19386:  BRA    19384
19388:  MOVWF  FAD
1938A:  MOVLW  3A
1938C:  BTFSS  F9E.4
1938E:  BRA    1938C
19390:  MOVWF  FAD
19392:  MOVLW  10
19394:  MOVWF  FE9
19396:  CLRF   1B
19398:  BTFSC  FF2.7
1939A:  BSF    1B.7
1939C:  BCF    FF2.7
1939E:  MOVFF  777,A1D
193A2:  MOVFF  776,A1C
193A6:  CALL   11A6
193AA:  BTFSC  1B.7
193AC:  BSF    FF2.7
193AE:  MOVLW  0D
193B0:  BTFSS  F9E.4
193B2:  BRA    193B0
193B4:  MOVWF  FAD
193B6:  MOVLW  0A
193B8:  BTFSS  F9E.4
193BA:  BRA    193B8
193BC:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
193BE:  MOVLW  74
193C0:  BTFSS  F9E.4
193C2:  BRA    193C0
193C4:  MOVWF  FAD
193C6:  MOVLW  3A
193C8:  BTFSS  F9E.4
193CA:  BRA    193C8
193CC:  MOVWF  FAD
193CE:  MOVLW  10
193D0:  MOVWF  FE9
193D2:  CLRF   1B
193D4:  BTFSC  FF2.7
193D6:  BSF    1B.7
193D8:  BCF    FF2.7
193DA:  MOVFF  76B,A1D
193DE:  MOVFF  76A,A1C
193E2:  CALL   11A6
193E6:  BTFSC  1B.7
193E8:  BSF    FF2.7
193EA:  MOVLW  0D
193EC:  BTFSS  F9E.4
193EE:  BRA    193EC
193F0:  MOVWF  FAD
193F2:  MOVLW  0A
193F4:  BTFSS  F9E.4
193F6:  BRA    193F4
193F8:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
193FA:  MOVLW  01
193FC:  MOVLB  7
193FE:  ADDWF  x40,W
19400:  MOVLB  8
19402:  MOVWF  x6C
19404:  MOVLW  75
19406:  BTFSS  F9E.4
19408:  BRA    19406
1940A:  MOVWF  FAD
1940C:  MOVLW  3A
1940E:  BTFSS  F9E.4
19410:  BRA    1940E
19412:  MOVWF  FAD
19414:  CLRF   1B
19416:  BTFSC  FF2.7
19418:  BSF    1B.7
1941A:  BCF    FF2.7
1941C:  MOVFF  86C,A1C
19420:  MOVLW  1B
19422:  MOVLB  A
19424:  MOVWF  x1D
19426:  MOVLB  0
19428:  CALL   0FA6
1942C:  BTFSC  1B.7
1942E:  BSF    FF2.7
19430:  MOVLW  0D
19432:  BTFSS  F9E.4
19434:  BRA    19432
19436:  MOVWF  FAD
19438:  MOVLW  0A
1943A:  BTFSS  F9E.4
1943C:  BRA    1943A
1943E:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19440:  MOVLW  77
19442:  BTFSS  F9E.4
19444:  BRA    19442
19446:  MOVWF  FAD
19448:  MOVLW  3A
1944A:  BTFSS  F9E.4
1944C:  BRA    1944A
1944E:  MOVWF  FAD
19450:  MOVLW  10
19452:  MOVWF  FE9
19454:  CLRF   1B
19456:  BTFSC  FF2.7
19458:  BSF    1B.7
1945A:  BCF    FF2.7
1945C:  MOVFF  869,A1D
19460:  MOVFF  868,A1C
19464:  CALL   11A6
19468:  BTFSC  1B.7
1946A:  BSF    FF2.7
1946C:  MOVLW  0D
1946E:  BTFSS  F9E.4
19470:  BRA    1946E
19472:  MOVWF  FAD
19474:  MOVLW  0A
19476:  BTFSS  F9E.4
19478:  BRA    19476
1947A:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
1947C:  MOVLW  78
1947E:  BTFSS  F9E.4
19480:  BRA    1947E
19482:  MOVWF  FAD
19484:  MOVLW  3A
19486:  BTFSS  F9E.4
19488:  BRA    19486
1948A:  MOVWF  FAD
1948C:  MOVLW  10
1948E:  MOVWF  FE9
19490:  CLRF   1B
19492:  BTFSC  FF2.7
19494:  BSF    1B.7
19496:  BCF    FF2.7
19498:  MOVFF  783,A1D
1949C:  MOVFF  782,A1C
194A0:  CALL   11A6
194A4:  BTFSC  1B.7
194A6:  BSF    FF2.7
194A8:  MOVLW  0D
194AA:  BTFSS  F9E.4
194AC:  BRA    194AA
194AE:  MOVWF  FAD
194B0:  MOVLW  0A
194B2:  BTFSS  F9E.4
194B4:  BRA    194B2
194B6:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
194B8:  MOVLW  79
194BA:  BTFSS  F9E.4
194BC:  BRA    194BA
194BE:  MOVWF  FAD
194C0:  MOVLW  3A
194C2:  BTFSS  F9E.4
194C4:  BRA    194C2
194C6:  MOVWF  FAD
194C8:  MOVLW  10
194CA:  MOVWF  FE9
194CC:  CLRF   1B
194CE:  BTFSC  FF2.7
194D0:  BSF    1B.7
194D2:  BCF    FF2.7
194D4:  MOVFF  743,A1D
194D8:  MOVFF  742,A1C
194DC:  CALL   11A6
194E0:  BTFSC  1B.7
194E2:  BSF    FF2.7
194E4:  MOVLW  0D
194E6:  BTFSS  F9E.4
194E8:  BRA    194E6
194EA:  MOVWF  FAD
194EC:  MOVLW  0A
194EE:  BTFSS  F9E.4
194F0:  BRA    194EE
194F2:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
194F4:  MOVFF  755,9EE
194F8:  MOVFF  754,9ED
194FC:  MOVLB  9
194FE:  CLRF   xF0
19500:  MOVLW  64
19502:  MOVWF  xEF
19504:  MOVLB  0
19506:  CALL   5C32
1950A:  MOVFF  02,86D
1950E:  MOVFF  01,86C
19512:  MOVFF  02,8BD
19516:  MOVFF  01,8BC
1951A:  MOVLW  01
1951C:  MOVLB  8
1951E:  MOVWF  xBF
19520:  SETF   xBE
19522:  MOVLB  0
19524:  CALL   2C70
19528:  MOVFF  02,867
1952C:  MOVFF  01,866
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19530:  MOVFF  759,9EE
19534:  MOVFF  758,9ED
19538:  MOVLB  9
1953A:  CLRF   xF0
1953C:  MOVLW  64
1953E:  MOVWF  xEF
19540:  MOVLB  0
19542:  CALL   5C32
19546:  MOVFF  02,86D
1954A:  MOVFF  01,86C
1954E:  MOVFF  02,8BD
19552:  MOVFF  01,8BC
19556:  MOVLW  01
19558:  MOVLB  8
1955A:  MOVWF  xBF
1955C:  SETF   xBE
1955E:  MOVLB  0
19560:  CALL   2C70
19564:  MOVFF  02,869
19568:  MOVFF  01,868
....................       step_us  =   m_stp_int[1]*100; 
1956C:  MOVFF  74D,9EE
19570:  MOVFF  74C,9ED
19574:  MOVLB  9
19576:  CLRF   xF0
19578:  MOVLW  64
1957A:  MOVWF  xEF
1957C:  MOVLB  0
1957E:  CALL   5C32
19582:  MOVFF  02,86B
19586:  MOVFF  01,86A
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
1958A:  MOVLW  26
1958C:  MOVWF  FF6
1958E:  MOVLW  27
19590:  MOVWF  FF7
19592:  MOVLW  00
19594:  MOVWF  FF8
19596:  CLRF   1B
19598:  BTFSC  FF2.7
1959A:  BSF    1B.7
1959C:  BCF    FF2.7
1959E:  CALL   0E4E
195A2:  BTFSC  1B.7
195A4:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
195A6:  MOVLW  62
195A8:  BTFSS  F9E.4
195AA:  BRA    195A8
195AC:  MOVWF  FAD
195AE:  MOVLW  3A
195B0:  BTFSS  F9E.4
195B2:  BRA    195B0
195B4:  MOVWF  FAD
195B6:  MOVLW  10
195B8:  MOVWF  FE9
195BA:  CLRF   1B
195BC:  BTFSC  FF2.7
195BE:  BSF    1B.7
195C0:  BCF    FF2.7
195C2:  MOVFF  775,A1D
195C6:  MOVFF  774,A1C
195CA:  CALL   11A6
195CE:  BTFSC  1B.7
195D0:  BSF    FF2.7
195D2:  MOVLW  0D
195D4:  BTFSS  F9E.4
195D6:  BRA    195D4
195D8:  MOVWF  FAD
195DA:  MOVLW  0A
195DC:  BTFSS  F9E.4
195DE:  BRA    195DC
195E0:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
195E2:  MOVLW  63
195E4:  BTFSS  F9E.4
195E6:  BRA    195E4
195E8:  MOVWF  FAD
195EA:  MOVLW  3A
195EC:  BTFSS  F9E.4
195EE:  BRA    195EC
195F0:  MOVWF  FAD
195F2:  MOVLW  41
195F4:  MOVWF  FE9
195F6:  CLRF   1B
195F8:  BTFSC  FF2.7
195FA:  BSF    1B.7
195FC:  BCF    FF2.7
195FE:  MOVFF  7A9,A1F
19602:  MOVFF  7A8,A1E
19606:  MOVFF  7A7,A1D
1960A:  MOVFF  7A6,A1C
1960E:  CALL   10EA
19612:  BTFSC  1B.7
19614:  BSF    FF2.7
19616:  MOVLW  2F
19618:  BTFSS  F9E.4
1961A:  BRA    19618
1961C:  MOVWF  FAD
1961E:  MOVLW  10
19620:  MOVWF  FE9
19622:  CLRF   1B
19624:  BTFSC  FF2.7
19626:  BSF    1B.7
19628:  BCF    FF2.7
1962A:  MOVFF  7BE,A1D
1962E:  MOVFF  7BD,A1C
19632:  CALL   11A6
19636:  BTFSC  1B.7
19638:  BSF    FF2.7
1963A:  MOVLW  2F
1963C:  BTFSS  F9E.4
1963E:  BRA    1963C
19640:  MOVWF  FAD
19642:  MOVLW  10
19644:  MOVWF  FE9
19646:  CLRF   1B
19648:  BTFSC  FF2.7
1964A:  BSF    1B.7
1964C:  BCF    FF2.7
1964E:  MOVFF  7C2,A1D
19652:  MOVFF  7C1,A1C
19656:  CALL   11A6
1965A:  BTFSC  1B.7
1965C:  BSF    FF2.7
1965E:  MOVLW  0D
19660:  BTFSS  F9E.4
19662:  BRA    19660
19664:  MOVWF  FAD
19666:  MOVLW  0A
19668:  BTFSS  F9E.4
1966A:  BRA    19668
1966C:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
1966E:  MOVLW  64
19670:  BTFSS  F9E.4
19672:  BRA    19670
19674:  MOVWF  FAD
19676:  MOVLW  3A
19678:  BTFSS  F9E.4
1967A:  BRA    19678
1967C:  MOVWF  FAD
1967E:  MOVLW  10
19680:  MOVWF  FE9
19682:  CLRF   1B
19684:  BTFSC  FF2.7
19686:  BSF    1B.7
19688:  BCF    FF2.7
1968A:  MOVFF  751,A1D
1968E:  MOVFF  750,A1C
19692:  CALL   11A6
19696:  BTFSC  1B.7
19698:  BSF    FF2.7
1969A:  MOVLW  0D
1969C:  BTFSS  F9E.4
1969E:  BRA    1969C
196A0:  MOVWF  FAD
196A2:  MOVLW  0A
196A4:  BTFSS  F9E.4
196A6:  BRA    196A4
196A8:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
196AA:  MOVLW  65
196AC:  BTFSS  F9E.4
196AE:  BRA    196AC
196B0:  MOVWF  FAD
196B2:  MOVLW  3A
196B4:  BTFSS  F9E.4
196B6:  BRA    196B4
196B8:  MOVWF  FAD
196BA:  MOVLW  10
196BC:  MOVWF  FE9
196BE:  CLRF   1B
196C0:  BTFSC  FF2.7
196C2:  BSF    1B.7
196C4:  BCF    FF2.7
196C6:  MOVFF  761,A1D
196CA:  MOVFF  760,A1C
196CE:  CALL   11A6
196D2:  BTFSC  1B.7
196D4:  BSF    FF2.7
196D6:  MOVLW  0D
196D8:  BTFSS  F9E.4
196DA:  BRA    196D8
196DC:  MOVWF  FAD
196DE:  MOVLW  0A
196E0:  BTFSS  F9E.4
196E2:  BRA    196E0
196E4:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
196E6:  MOVLW  66
196E8:  BTFSS  F9E.4
196EA:  BRA    196E8
196EC:  MOVWF  FAD
196EE:  MOVLW  3A
196F0:  BTFSS  F9E.4
196F2:  BRA    196F0
196F4:  MOVWF  FAD
196F6:  CLRF   1B
196F8:  BTFSC  FF2.7
196FA:  BSF    1B.7
196FC:  BCF    FF2.7
196FE:  MOVFF  741,A1C
19702:  MOVLW  1B
19704:  MOVLB  A
19706:  MOVWF  x1D
19708:  MOVLB  0
1970A:  CALL   0FA6
1970E:  BTFSC  1B.7
19710:  BSF    FF2.7
19712:  MOVLW  0D
19714:  BTFSS  F9E.4
19716:  BRA    19714
19718:  MOVWF  FAD
1971A:  MOVLW  0A
1971C:  BTFSS  F9E.4
1971E:  BRA    1971C
19720:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
19722:  MOVLW  67
19724:  BTFSS  F9E.4
19726:  BRA    19724
19728:  MOVWF  FAD
1972A:  MOVLW  3A
1972C:  BTFSS  F9E.4
1972E:  BRA    1972C
19730:  MOVWF  FAD
19732:  MOVLW  10
19734:  MOVWF  FE9
19736:  CLRF   1B
19738:  BTFSC  FF2.7
1973A:  BSF    1B.7
1973C:  BCF    FF2.7
1973E:  MOVFF  75D,A1D
19742:  MOVFF  75C,A1C
19746:  CALL   11A6
1974A:  BTFSC  1B.7
1974C:  BSF    FF2.7
1974E:  MOVLW  0D
19750:  BTFSS  F9E.4
19752:  BRA    19750
19754:  MOVWF  FAD
19756:  MOVLW  0A
19758:  BTFSS  F9E.4
1975A:  BRA    19758
1975C:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
1975E:  MOVLW  68
19760:  BTFSS  F9E.4
19762:  BRA    19760
19764:  MOVWF  FAD
19766:  MOVLW  3A
19768:  BTFSS  F9E.4
1976A:  BRA    19768
1976C:  MOVWF  FAD
1976E:  MOVLW  10
19770:  MOVWF  FE9
19772:  CLRF   1B
19774:  BTFSC  FF2.7
19776:  BSF    1B.7
19778:  BCF    FF2.7
1977A:  MOVFF  867,A1D
1977E:  MOVFF  866,A1C
19782:  CALL   11A6
19786:  BTFSC  1B.7
19788:  BSF    FF2.7
1978A:  MOVLW  0D
1978C:  BTFSS  F9E.4
1978E:  BRA    1978C
19790:  MOVWF  FAD
19792:  MOVLW  0A
19794:  BTFSS  F9E.4
19796:  BRA    19794
19798:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
1979A:  MOVLW  69
1979C:  BTFSS  F9E.4
1979E:  BRA    1979C
197A0:  MOVWF  FAD
197A2:  MOVLW  3A
197A4:  BTFSS  F9E.4
197A6:  BRA    197A4
197A8:  MOVWF  FAD
197AA:  MOVLW  10
197AC:  MOVWF  FE9
197AE:  CLRF   1B
197B0:  BTFSC  FF2.7
197B2:  BSF    1B.7
197B4:  BCF    FF2.7
197B6:  MOVFF  86B,A1D
197BA:  MOVFF  86A,A1C
197BE:  CALL   11A6
197C2:  BTFSC  1B.7
197C4:  BSF    FF2.7
197C6:  MOVLW  0D
197C8:  BTFSS  F9E.4
197CA:  BRA    197C8
197CC:  MOVWF  FAD
197CE:  MOVLW  0A
197D0:  BTFSS  F9E.4
197D2:  BRA    197D0
197D4:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
197D6:  MOVLW  6A
197D8:  BTFSS  F9E.4
197DA:  BRA    197D8
197DC:  MOVWF  FAD
197DE:  MOVLW  3A
197E0:  BTFSS  F9E.4
197E2:  BRA    197E0
197E4:  MOVWF  FAD
197E6:  MOVLW  10
197E8:  MOVWF  FE9
197EA:  CLRF   1B
197EC:  BTFSC  FF2.7
197EE:  BSF    1B.7
197F0:  BCF    FF2.7
197F2:  MOVFF  771,A1D
197F6:  MOVFF  770,A1C
197FA:  CALL   11A6
197FE:  BTFSC  1B.7
19800:  BSF    FF2.7
19802:  MOVLW  0D
19804:  BTFSS  F9E.4
19806:  BRA    19804
19808:  MOVWF  FAD
1980A:  MOVLW  0A
1980C:  BTFSS  F9E.4
1980E:  BRA    1980C
19810:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
19812:  MOVLW  6B
19814:  BTFSS  F9E.4
19816:  BRA    19814
19818:  MOVWF  FAD
1981A:  MOVLW  3A
1981C:  BTFSS  F9E.4
1981E:  BRA    1981C
19820:  MOVWF  FAD
19822:  MOVLW  10
19824:  MOVWF  FE9
19826:  CLRF   1B
19828:  BTFSC  FF2.7
1982A:  BSF    1B.7
1982C:  BCF    FF2.7
1982E:  MOVFF  769,A1D
19832:  MOVFF  768,A1C
19836:  CALL   11A6
1983A:  BTFSC  1B.7
1983C:  BSF    FF2.7
1983E:  MOVLW  0D
19840:  BTFSS  F9E.4
19842:  BRA    19840
19844:  MOVWF  FAD
19846:  MOVLW  0A
19848:  BTFSS  F9E.4
1984A:  BRA    19848
1984C:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
1984E:  MOVLW  6D
19850:  BTFSS  F9E.4
19852:  BRA    19850
19854:  MOVWF  FAD
19856:  MOVLW  3A
19858:  BTFSS  F9E.4
1985A:  BRA    19858
1985C:  MOVWF  FAD
1985E:  MOVLW  10
19860:  MOVWF  FE9
19862:  CLRF   1B
19864:  BTFSC  FF2.7
19866:  BSF    1B.7
19868:  BCF    FF2.7
1986A:  MOVFF  749,A1D
1986E:  MOVFF  748,A1C
19872:  CALL   11A6
19876:  BTFSC  1B.7
19878:  BSF    FF2.7
1987A:  MOVLW  0D
1987C:  BTFSS  F9E.4
1987E:  BRA    1987C
19880:  MOVWF  FAD
19882:  MOVLW  0A
19884:  BTFSS  F9E.4
19886:  BRA    19884
19888:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
1988A:  MOVLW  6E
1988C:  BTFSS  F9E.4
1988E:  BRA    1988C
19890:  MOVWF  FAD
19892:  MOVLW  3A
19894:  BTFSS  F9E.4
19896:  BRA    19894
19898:  MOVWF  FAD
1989A:  MOVLW  10
1989C:  MOVWF  FE9
1989E:  CLRF   1B
198A0:  BTFSC  FF2.7
198A2:  BSF    1B.7
198A4:  BCF    FF2.7
198A6:  MOVFF  77D,A1D
198AA:  MOVFF  77C,A1C
198AE:  CALL   11A6
198B2:  BTFSC  1B.7
198B4:  BSF    FF2.7
198B6:  MOVLW  0D
198B8:  BTFSS  F9E.4
198BA:  BRA    198B8
198BC:  MOVWF  FAD
198BE:  MOVLW  0A
198C0:  BTFSS  F9E.4
198C2:  BRA    198C0
198C4:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
198C6:  MOVLW  6F
198C8:  BTFSS  F9E.4
198CA:  BRA    198C8
198CC:  MOVWF  FAD
198CE:  MOVLW  3A
198D0:  BTFSS  F9E.4
198D2:  BRA    198D0
198D4:  MOVWF  FAD
198D6:  MOVLW  10
198D8:  MOVWF  FE9
198DA:  CLRF   1B
198DC:  BTFSC  FF2.7
198DE:  BSF    1B.7
198E0:  BCF    FF2.7
198E2:  MOVFF  781,A1D
198E6:  MOVFF  780,A1C
198EA:  CALL   11A6
198EE:  BTFSC  1B.7
198F0:  BSF    FF2.7
198F2:  MOVLW  0D
198F4:  BTFSS  F9E.4
198F6:  BRA    198F4
198F8:  MOVWF  FAD
198FA:  MOVLW  0A
198FC:  BTFSS  F9E.4
198FE:  BRA    198FC
19900:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
19902:  MOVLW  70
19904:  BTFSS  F9E.4
19906:  BRA    19904
19908:  MOVWF  FAD
1990A:  MOVLW  3A
1990C:  BTFSS  F9E.4
1990E:  BRA    1990C
19910:  MOVWF  FAD
19912:  MOVLW  10
19914:  MOVWF  FE9
19916:  CLRF   1B
19918:  BTFSC  FF2.7
1991A:  BSF    1B.7
1991C:  BCF    FF2.7
1991E:  MOVFF  7C6,A1D
19922:  MOVFF  7C5,A1C
19926:  CALL   11A6
1992A:  BTFSC  1B.7
1992C:  BSF    FF2.7
1992E:  MOVLW  2F
19930:  BTFSS  F9E.4
19932:  BRA    19930
19934:  MOVWF  FAD
19936:  MOVLW  10
19938:  MOVWF  FE9
1993A:  CLRF   1B
1993C:  BTFSC  FF2.7
1993E:  BSF    1B.7
19940:  BCF    FF2.7
19942:  MOVFF  765,A1D
19946:  MOVFF  764,A1C
1994A:  CALL   11A6
1994E:  BTFSC  1B.7
19950:  BSF    FF2.7
19952:  MOVLW  0D
19954:  BTFSS  F9E.4
19956:  BRA    19954
19958:  MOVWF  FAD
1995A:  MOVLW  0A
1995C:  BTFSS  F9E.4
1995E:  BRA    1995C
19960:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
19962:  MOVLW  71
19964:  BTFSS  F9E.4
19966:  BRA    19964
19968:  MOVWF  FAD
1996A:  MOVLW  3A
1996C:  BTFSS  F9E.4
1996E:  BRA    1996C
19970:  MOVWF  FAD
19972:  MOVLW  10
19974:  MOVWF  FE9
19976:  CLRF   1B
19978:  BTFSC  FF2.7
1997A:  BSF    1B.7
1997C:  BCF    FF2.7
1997E:  MOVFF  799,A1D
19982:  MOVFF  798,A1C
19986:  CALL   11A6
1998A:  BTFSC  1B.7
1998C:  BSF    FF2.7
1998E:  MOVLW  0D
19990:  BTFSS  F9E.4
19992:  BRA    19990
19994:  MOVWF  FAD
19996:  MOVLW  0A
19998:  BTFSS  F9E.4
1999A:  BRA    19998
1999C:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
1999E:  MOVLW  73
199A0:  BTFSS  F9E.4
199A2:  BRA    199A0
199A4:  MOVWF  FAD
199A6:  MOVLW  3A
199A8:  BTFSS  F9E.4
199AA:  BRA    199A8
199AC:  MOVWF  FAD
199AE:  MOVLW  10
199B0:  MOVWF  FE9
199B2:  CLRF   1B
199B4:  BTFSC  FF2.7
199B6:  BSF    1B.7
199B8:  BCF    FF2.7
199BA:  MOVFF  779,A1D
199BE:  MOVFF  778,A1C
199C2:  CALL   11A6
199C6:  BTFSC  1B.7
199C8:  BSF    FF2.7
199CA:  MOVLW  0D
199CC:  BTFSS  F9E.4
199CE:  BRA    199CC
199D0:  MOVWF  FAD
199D2:  MOVLW  0A
199D4:  BTFSS  F9E.4
199D6:  BRA    199D4
199D8:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
199DA:  MOVLW  74
199DC:  BTFSS  F9E.4
199DE:  BRA    199DC
199E0:  MOVWF  FAD
199E2:  MOVLW  3A
199E4:  BTFSS  F9E.4
199E6:  BRA    199E4
199E8:  MOVWF  FAD
199EA:  MOVLW  10
199EC:  MOVWF  FE9
199EE:  CLRF   1B
199F0:  BTFSC  FF2.7
199F2:  BSF    1B.7
199F4:  BCF    FF2.7
199F6:  MOVFF  76D,A1D
199FA:  MOVFF  76C,A1C
199FE:  CALL   11A6
19A02:  BTFSC  1B.7
19A04:  BSF    FF2.7
19A06:  MOVLW  0D
19A08:  BTFSS  F9E.4
19A0A:  BRA    19A08
19A0C:  MOVWF  FAD
19A0E:  MOVLW  0A
19A10:  BTFSS  F9E.4
19A12:  BRA    19A10
19A14:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19A16:  MOVLW  01
19A18:  MOVLB  7
19A1A:  ADDWF  x40,W
19A1C:  MOVLB  8
19A1E:  MOVWF  x6C
19A20:  MOVLW  75
19A22:  BTFSS  F9E.4
19A24:  BRA    19A22
19A26:  MOVWF  FAD
19A28:  MOVLW  3A
19A2A:  BTFSS  F9E.4
19A2C:  BRA    19A2A
19A2E:  MOVWF  FAD
19A30:  CLRF   1B
19A32:  BTFSC  FF2.7
19A34:  BSF    1B.7
19A36:  BCF    FF2.7
19A38:  MOVFF  86C,A1C
19A3C:  MOVLW  1B
19A3E:  MOVLB  A
19A40:  MOVWF  x1D
19A42:  MOVLB  0
19A44:  CALL   0FA6
19A48:  BTFSC  1B.7
19A4A:  BSF    FF2.7
19A4C:  MOVLW  0D
19A4E:  BTFSS  F9E.4
19A50:  BRA    19A4E
19A52:  MOVWF  FAD
19A54:  MOVLW  0A
19A56:  BTFSS  F9E.4
19A58:  BRA    19A56
19A5A:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19A5C:  MOVLW  77
19A5E:  BTFSS  F9E.4
19A60:  BRA    19A5E
19A62:  MOVWF  FAD
19A64:  MOVLW  3A
19A66:  BTFSS  F9E.4
19A68:  BRA    19A66
19A6A:  MOVWF  FAD
19A6C:  MOVLW  10
19A6E:  MOVWF  FE9
19A70:  CLRF   1B
19A72:  BTFSC  FF2.7
19A74:  BSF    1B.7
19A76:  BCF    FF2.7
19A78:  MOVFF  869,A1D
19A7C:  MOVFF  868,A1C
19A80:  CALL   11A6
19A84:  BTFSC  1B.7
19A86:  BSF    FF2.7
19A88:  MOVLW  0D
19A8A:  BTFSS  F9E.4
19A8C:  BRA    19A8A
19A8E:  MOVWF  FAD
19A90:  MOVLW  0A
19A92:  BTFSS  F9E.4
19A94:  BRA    19A92
19A96:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
19A98:  MOVLW  78
19A9A:  BTFSS  F9E.4
19A9C:  BRA    19A9A
19A9E:  MOVWF  FAD
19AA0:  MOVLW  3A
19AA2:  BTFSS  F9E.4
19AA4:  BRA    19AA2
19AA6:  MOVWF  FAD
19AA8:  MOVLW  10
19AAA:  MOVWF  FE9
19AAC:  CLRF   1B
19AAE:  BTFSC  FF2.7
19AB0:  BSF    1B.7
19AB2:  BCF    FF2.7
19AB4:  MOVFF  785,A1D
19AB8:  MOVFF  784,A1C
19ABC:  CALL   11A6
19AC0:  BTFSC  1B.7
19AC2:  BSF    FF2.7
19AC4:  MOVLW  0D
19AC6:  BTFSS  F9E.4
19AC8:  BRA    19AC6
19ACA:  MOVWF  FAD
19ACC:  MOVLW  0A
19ACE:  BTFSS  F9E.4
19AD0:  BRA    19ACE
19AD2:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
19AD4:  MOVLW  79
19AD6:  BTFSS  F9E.4
19AD8:  BRA    19AD6
19ADA:  MOVWF  FAD
19ADC:  MOVLW  3A
19ADE:  BTFSS  F9E.4
19AE0:  BRA    19ADE
19AE2:  MOVWF  FAD
19AE4:  MOVLW  10
19AE6:  MOVWF  FE9
19AE8:  CLRF   1B
19AEA:  BTFSC  FF2.7
19AEC:  BSF    1B.7
19AEE:  BCF    FF2.7
19AF0:  MOVFF  745,A1D
19AF4:  MOVFF  744,A1C
19AF8:  CALL   11A6
19AFC:  BTFSC  1B.7
19AFE:  BSF    FF2.7
19B00:  MOVLW  0D
19B02:  BTFSS  F9E.4
19B04:  BRA    19B02
19B06:  MOVWF  FAD
19B08:  MOVLW  0A
19B0A:  BTFSS  F9E.4
19B0C:  BRA    19B0A
19B0E:  MOVWF  FAD
....................    } 
19B10:  BRA    19B16
....................    else cmd_arg(); 
19B12:  CALL   AF88
19B16:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BBD0:  MOVF   48,W
0BBD2:  SUBLW  0D
0BBD4:  BNZ   BBF4
0BBD6:  MOVF   49,W
0BBD8:  SUBLW  07
0BBDA:  BNZ   BBF4
0BBDC:  MOVF   4A,F
0BBDE:  BNZ   BBF4
0BBE0:  MOVF   4B,F
0BBE2:  BNZ   BBF4
0BBE4:  MOVLW  03
0BBE6:  MOVLB  8
0BBE8:  MOVWF  x6B
0BBEA:  MOVLW  15
0BBEC:  MOVWF  x6A
0BBEE:  MOVLB  0
0BBF0:  RCALL  B7AE
0BBF2:  BRA    BC16
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BBF4:  MOVF   48,W
0BBF6:  SUBLW  98
0BBF8:  BNZ   BC16
0BBFA:  MOVF   49,W
0BBFC:  SUBLW  07
0BBFE:  BNZ   BC16
0BC00:  MOVF   4A,F
0BC02:  BNZ   BC16
0BC04:  MOVF   4B,F
0BC06:  BNZ   BC16
0BC08:  MOVLW  03
0BC0A:  MOVLB  8
0BC0C:  MOVWF  x6B
0BC0E:  MOVLW  15
0BC10:  MOVWF  x6A
0BC12:  MOVLB  0
0BC14:  RCALL  B928
0BC16:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0AFE2:  MOVF   48,W
0AFE4:  MOVWF  00
0AFE6:  MOVFF  49,03
0AFEA:  MOVLW  15
0AFEC:  SUBWF  49,W
0AFEE:  BNZ   AFF6
0AFF0:  MOVLW  95
0AFF2:  SUBWF  00,W
0AFF4:  BZ    B01C
0AFF6:  MOVLW  15
0AFF8:  SUBWF  03,W
0AFFA:  BNZ   B002
0AFFC:  MOVLW  96
0AFFE:  SUBWF  00,W
0B000:  BZ    B04E
0B002:  MOVLW  15
0B004:  SUBWF  03,W
0B006:  BNZ   B00E
0B008:  MOVLW  97
0B00A:  SUBWF  00,W
0B00C:  BZ    B084
0B00E:  MOVLW  15
0B010:  SUBWF  03,W
0B012:  BNZ   B01A
0B014:  MOVLW  98
0B016:  SUBWF  00,W
0B018:  BZ    B0BA
0B01A:  BRA    B0EE
....................       case 5525 : nv_product = ECO; 
0B01C:  CLRF   30
0B01E:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0B020:  MOVLW  1E
0B022:  MOVLB  8
0B024:  MOVWF  xCF
0B026:  CLRF   xD1
0B028:  CLRF   xD0
0B02A:  MOVLB  0
0B02C:  CALL   4F68
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B030:  MOVLW  01
0B032:  MOVWF  1E
0B034:  MOVLW  A7
0B036:  MOVWF  1D
0B038:  MOVLW  32
0B03A:  MOVWF  FF6
0B03C:  MOVLW  27
0B03E:  MOVWF  FF7
0B040:  MOVLW  00
0B042:  MOVWF  FF8
0B044:  CALL   5052
....................                   record_event(); 
0B048:  CALL   8436
....................          break; 
0B04C:  BRA    B0EE
....................       case 5526 : nv_product = WMS4; 
0B04E:  CLRF   30
0B050:  MOVLW  01
0B052:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B054:  MOVLW  1E
0B056:  MOVLB  8
0B058:  MOVWF  xCF
0B05A:  CLRF   xD1
0B05C:  MOVLW  01
0B05E:  MOVWF  xD0
0B060:  MOVLB  0
0B062:  CALL   4F68
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B066:  MOVLW  01
0B068:  MOVWF  1E
0B06A:  MOVLW  A7
0B06C:  MOVWF  1D
0B06E:  MOVLW  42
0B070:  MOVWF  FF6
0B072:  MOVLW  27
0B074:  MOVWF  FF7
0B076:  MOVLW  00
0B078:  MOVWF  FF8
0B07A:  CALL   5052
....................                   record_event();                   
0B07E:  CALL   8436
....................          break;    
0B082:  BRA    B0EE
....................       case 5527 : nv_product = AWS; 
0B084:  CLRF   30
0B086:  MOVLW  02
0B088:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B08A:  MOVLW  1E
0B08C:  MOVLB  8
0B08E:  MOVWF  xCF
0B090:  CLRF   xD1
0B092:  MOVLW  02
0B094:  MOVWF  xD0
0B096:  MOVLB  0
0B098:  CALL   4F68
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B09C:  MOVLW  01
0B09E:  MOVWF  1E
0B0A0:  MOVLW  A7
0B0A2:  MOVWF  1D
0B0A4:  MOVLW  58
0B0A6:  MOVWF  FF6
0B0A8:  MOVLW  27
0B0AA:  MOVWF  FF7
0B0AC:  MOVLW  00
0B0AE:  MOVWF  FF8
0B0B0:  CALL   5052
....................                   record_event();                   
0B0B4:  CALL   8436
....................          break;   
0B0B8:  BRA    B0EE
....................       case 5528 : nv_product = WMS2; 
0B0BA:  CLRF   30
0B0BC:  MOVLW  03
0B0BE:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B0C0:  MOVLW  1E
0B0C2:  MOVLB  8
0B0C4:  MOVWF  xCF
0B0C6:  CLRF   xD1
0B0C8:  MOVLW  03
0B0CA:  MOVWF  xD0
0B0CC:  MOVLB  0
0B0CE:  CALL   4F68
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B0D2:  MOVLW  01
0B0D4:  MOVWF  1E
0B0D6:  MOVLW  A7
0B0D8:  MOVWF  1D
0B0DA:  MOVLW  68
0B0DC:  MOVWF  FF6
0B0DE:  MOVLW  27
0B0E0:  MOVWF  FF7
0B0E2:  MOVLW  00
0B0E4:  MOVWF  FF8
0B0E6:  CALL   5052
....................                   record_event();                   
0B0EA:  CALL   8436
....................          break;            
....................    } 
0B0EE:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0AFA6:  MOVF   48,W
0AFA8:  MOVWF  00
0AFAA:  MOVF   49,W
0AFAC:  MOVWF  03
0AFAE:  BNZ   AFB4
0AFB0:  MOVF   00,F
0AFB2:  BZ    AFCA
0AFB4:  MOVF   03,W
0AFB6:  BNZ   AFBE
0AFB8:  MOVLW  01
0AFBA:  SUBWF  00,W
0AFBC:  BZ    AFD0
0AFBE:  MOVF   03,W
0AFC0:  BNZ   AFC8
0AFC2:  MOVLW  02
0AFC4:  SUBWF  00,W
0AFC6:  BZ    AFD6
0AFC8:  BRA    AFDC
....................       case 0 : kill_wd(); 
0AFCA:  CALL   3092
....................          break; 
0AFCE:  BRA    AFDE
....................       case 1 : start_heartbeat(); 
0AFD0:  CALL   289C
....................          break; 
0AFD4:  BRA    AFDE
....................       case 2 : suspend_heartbeat(); 
0AFD6:  CALL   54E4
....................          break; 
0AFDA:  BRA    AFDE
....................       default : cmd_arg(); 
0AFDC:  RCALL  AF88
....................          break; 
....................    } 
0AFDE:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0AEE6:  MOVF   48,W
0AEE8:  MOVWF  00
0AEEA:  MOVF   49,W
0AEEC:  MOVWF  03
0AEEE:  BNZ   AEF4
0AEF0:  MOVF   00,F
0AEF2:  BZ    AF02
0AEF4:  MOVLW  15
0AEF6:  SUBWF  03,W
0AEF8:  BNZ   AF00
0AEFA:  MOVLW  95
0AEFC:  SUBWF  00,W
0AEFE:  BZ    AF60
0AF00:  BRA    AF84
....................       case 0:     signon(); 
0AF02:  CALL   30E4
....................                   fprintf(COM_A, __DATE__); 
0AF06:  MOVLW  7E
0AF08:  MOVWF  FF6
0AF0A:  MOVLW  27
0AF0C:  MOVWF  FF7
0AF0E:  MOVLW  00
0AF10:  MOVWF  FF8
0AF12:  CLRF   1B
0AF14:  BTFSC  FF2.7
0AF16:  BSF    1B.7
0AF18:  BCF    FF2.7
0AF1A:  CALL   0E4E
0AF1E:  BTFSC  1B.7
0AF20:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0AF22:  MOVLW  0D
0AF24:  BTFSS  F9E.4
0AF26:  BRA    AF24
0AF28:  MOVWF  FAD
0AF2A:  MOVLW  0A
0AF2C:  BTFSS  F9E.4
0AF2E:  BRA    AF2C
0AF30:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0AF32:  MOVLW  88
0AF34:  MOVWF  FF6
0AF36:  MOVLW  27
0AF38:  MOVWF  FF7
0AF3A:  MOVLW  00
0AF3C:  MOVWF  FF8
0AF3E:  CLRF   1B
0AF40:  BTFSC  FF2.7
0AF42:  BSF    1B.7
0AF44:  BCF    FF2.7
0AF46:  CALL   0E4E
0AF4A:  BTFSC  1B.7
0AF4C:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0AF4E:  MOVLW  0D
0AF50:  BTFSS  F9E.4
0AF52:  BRA    AF50
0AF54:  MOVWF  FAD
0AF56:  MOVLW  0A
0AF58:  BTFSS  F9E.4
0AF5A:  BRA    AF58
0AF5C:  MOVWF  FAD
....................          break; 
0AF5E:  BRA    AF84
....................       case 5525 : kill_wd(); 
0AF60:  CALL   3092
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0AF64:  MOVLW  92
0AF66:  MOVWF  FF6
0AF68:  MOVLW  27
0AF6A:  MOVWF  FF7
0AF6C:  MOVLW  00
0AF6E:  MOVWF  FF8
0AF70:  CLRF   1B
0AF72:  BTFSC  FF2.7
0AF74:  BSF    1B.7
0AF76:  BCF    FF2.7
0AF78:  CALL   0E4E
0AF7C:  BTFSC  1B.7
0AF7E:  BSF    FF2.7
....................                   load_program(); 
0AF80:  CALL   1F800
....................          break; 
....................    } 
0AF84:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
187C6:  MOVF   48,W
187C8:  MOVWF  00
187CA:  MOVF   49,W
187CC:  MOVWF  03
187CE:  BNZ   187D4
187D0:  MOVF   00,F
187D2:  BZ    187E0
187D4:  MOVF   03,W
187D6:  BNZ   187DE
187D8:  MOVLW  01
187DA:  SUBWF  00,W
187DC:  BZ    187E4
187DE:  BRA    187E8
....................       case 0 : cmd_set=0;  // user 
187E0:  CLRF   51
....................          break; 
187E2:  BRA    187E8
....................       case 1 : cmd_set=1;  // full 
187E4:  MOVLW  01
187E6:  MOVWF  51
....................          break; 
....................    } 
187E8:  GOTO   1B01E (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1AE84:  CALL   ADD0
....................     
....................    switch (cmd) 
1AE88:  MOVLW  23
1AE8A:  SUBWF  47,W
1AE8C:  ADDLW  A8
1AE8E:  BTFSC  FD8.0
1AE90:  BRA    1B01E
1AE92:  ADDLW  58
1AE94:  GOTO   1B022
....................    { 
....................       case '&': commandFW(); 
1AE98:  GOTO   AEE6
....................          break; 
1AE9C:  BRA    1B01E
....................       case '#': command_hash(); 
1AE9E:  GOTO   AFA6
....................          break;          
1AEA2:  BRA    1B01E
....................       case '%': command_prod(); 
1AEA4:  GOTO   AFE2
....................          break; 
1AEA8:  BRA    1B01E
....................       case '*': command_star(); 
1AEAA:  GOTO   BBD0
....................          break;       
1AEAE:  BRA    1B01E
....................       // standard commands 
....................       case '/': command_addr(); 
1AEB0:  GOTO   BC1A
....................          break; 
1AEB4:  BRA    1B01E
....................       case 'A': commandA(); 
1AEB6:  GOTO   BDB4
....................          break; 
1AEBA:  BRA    1B01E
....................       case 'B': commandB(); 
1AEBC:  GOTO   BF20
....................          break; 
1AEC0:  BRA    1B01E
....................       case 'C': commandC(); 
1AEC2:  GOTO   D92A
....................          break; 
1AEC6:  BRA    1B01E
....................       case 'D': commandD(); 
1AEC8:  GOTO   D968
....................          break; 
1AECC:  BRA    1B01E
....................       case 'E': commandE(); 
1AECE:  GOTO   DA06
....................          break;          
1AED2:  BRA    1B01E
....................       case 'F': commandF(); 
1AED4:  GOTO   DD04
....................          break;          
1AED8:  BRA    1B01E
....................       case 'G': commandG(); 
1AEDA:  GOTO   DD6E
....................          break; 
1AEDE:  BRA    1B01E
....................       case 'H': commandH(); 
1AEE0:  GOTO   EECC
....................          break; 
1AEE4:  BRA    1B01E
....................       case 'I': commandI(); 
1AEE6:  GOTO   EF0C
....................          break;    
1AEEA:  BRA    1B01E
....................       case 'J': commandJ(); 
1AEEC:  GOTO   EF58
....................          break;      
1AEF0:  BRA    1B01E
....................       case 'K': commandK(); 
1AEF2:  GOTO   F1B2
....................          break;    
1AEF6:  BRA    1B01E
....................       case 'L': commandL(); 
1AEF8:  GOTO   FFC0
....................          break;             
1AEFC:  BRA    1B01E
....................       case 'M': commandM(FALSE); 
1AEFE:  MOVLB  8
1AF00:  CLRF   x66
1AF02:  MOVLB  0
1AF04:  CALL   1692E
....................          break;   
1AF08:  BRA    1B01E
....................       case 'N': commandN(); 
1AF0A:  GOTO   16A4C
....................          break;          
1AF0E:  BRA    1B01E
....................       case 'O': commandO(); 
1AF10:  GOTO   16BFC
....................          break;    
1AF14:  BRA    1B01E
....................       case 'P': commandP(); 
1AF16:  GOTO   16E00
....................          break;  
1AF1A:  BRA    1B01E
....................       case 'Q': commandQ(); 
1AF1C:  GOTO   16EBE
....................          break;              
1AF20:  BRA    1B01E
....................       case 'R': commandR(); 
1AF22:  GOTO   17154
....................          break;    
1AF26:  BRA    1B01E
....................       case 'S': commandS(); 
1AF28:  GOTO   17280
....................          break;  
1AF2C:  BRA    1B01E
....................       case 'T': commandT(); 
1AF2E:  GOTO   1781E
....................          break;            
1AF32:  BRA    1B01E
....................       case 'U': commandU(); 
1AF34:  GOTO   18220
....................          break;           
1AF38:  BRA    1B01E
....................       case 'V': commandV(); 
1AF3A:  GOTO   18378
....................          break; 
1AF3E:  BRA    1B01E
....................       case 'W': commandW(); 
1AF40:  GOTO   1860E
....................          break; 
1AF44:  BRA    1B01E
....................       case 'X': commandX(); 
1AF46:  GOTO   18632
....................          break; 
1AF4A:  BRA    1B01E
....................       case 'Y': commandY(); 
1AF4C:  GOTO   1869A
....................          break;  
1AF50:  BRA    1B01E
....................       case 'Z': commandZ(); 
1AF52:  CALL   187A2
....................          break;    
1AF56:  BRA    1B01E
....................       // stepper 
....................       case '^': command_set(); 
1AF58:  GOTO   187C6
....................          break;       
1AF5C:  BRA    1B01E
....................       case '+': if(m_fixed==1) motor=1; 
1AF5E:  MOVLB  7
1AF60:  DECFSZ x41,W
1AF62:  BRA    1AF68
1AF64:  MOVLW  01
1AF66:  MOVWF  x40
....................                 command_move(0,0,1); 
1AF68:  MOVLB  8
1AF6A:  CLRF   x66
1AF6C:  CLRF   x67
1AF6E:  MOVLW  01
1AF70:  MOVWF  x68
1AF72:  MOVLB  0
1AF74:  CALL   16C20
....................          break; 
1AF78:  BRA    1B01E
....................       case '-': if(m_fixed==1) motor=1; 
1AF7A:  MOVLB  7
1AF7C:  DECFSZ x41,W
1AF7E:  BRA    1AF84
1AF80:  MOVLW  01
1AF82:  MOVWF  x40
....................                 command_move(0,1,1); 
1AF84:  MOVLB  8
1AF86:  CLRF   x66
1AF88:  MOVLW  01
1AF8A:  MOVWF  x67
1AF8C:  MOVWF  x68
1AF8E:  MOVLB  0
1AF90:  CALL   16C20
....................          break; 
1AF94:  BRA    1B01E
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1AF96:  GOTO   188F2
....................          break;     
1AF9A:  BRA    1B01E
....................       case 'b': command_b(); 
1AF9C:  GOTO   1890E
....................          break; 
1AFA0:  BRA    1B01E
....................       case 'c': command_c(); 
1AFA2:  GOTO   189A8
....................          break; 
1AFA6:  BRA    1B01E
....................       case 'd': command_d(); 
1AFA8:  GOTO   189F0
....................          break;          
1AFAC:  BRA    1B01E
....................       case 'e': command_e(); 
1AFAE:  GOTO   18A86
....................          break;       
1AFB2:  BRA    1B01E
....................       case 'f': command_f(); 
1AFB4:  GOTO   18B20
....................          break; 
1AFB8:  BRA    1B01E
....................       case 'g': command_g(); 
1AFBA:  GOTO   18B40
....................          break;          
1AFBE:  BRA    1B01E
....................       case 'h': command_h(); 
1AFC0:  GOTO   18BDA
....................          break; 
1AFC4:  BRA    1B01E
....................       case 'i': command_i(); 
1AFC6:  GOTO   18CAE
....................          break;   
1AFCA:  BRA    1B01E
....................       case 'j': command_j(); 
1AFCC:  GOTO   18D8A
....................          break;           
1AFD0:  BRA    1B01E
....................       case 'k': command_k(); 
1AFD2:  GOTO   18E24
....................          break;          
1AFD6:  BRA    1B01E
....................       case 'l': step_var_list(); 
1AFD8:  GOTO   18EBA
....................          break;          
1AFDC:  BRA    1B01E
....................       case 'm': command_m(); 
1AFDE:  GOTO   19B1A
....................          break;    
1AFE2:  BRA    1B01E
....................       case 'n': command_n(); 
1AFE4:  GOTO   19BB0
....................          break; 
1AFE8:  BRA    1B01E
....................       case 'o': command_o(); 
1AFEA:  GOTO   19C46
....................          break;    
1AFEE:  BRA    1B01E
....................       case 'p': command_p(); 
1AFF0:  GOTO   19CE0
....................          break;   
1AFF4:  BRA    1B01E
....................       case 'q': command_q(); 
1AFF6:  GOTO   19D7A
....................          break; 
1AFFA:  BRA    1B01E
....................       case 'r': command_r(); 
1AFFC:  BRA    1A876
....................          break;    
1AFFE:  BRA    1B01E
....................       case 's': command_s(); 
1B000:  BRA    1A8D0
....................          break;           
1B002:  BRA    1B01E
....................       case 't': command_t(); 
1B004:  BRA    1A9DE
....................          break;          
1B006:  BRA    1B01E
....................       case 'u': command_u(); 
1B008:  BRA    1AA74
....................          break; 
1B00A:  BRA    1B01E
....................       case 'v': command_v(); 
1B00C:  BRA    1AAAC
....................          break; 
1B00E:  BRA    1B01E
....................       case 'w': command_w(); 
1B010:  BRA    1AC0A
....................          break; 
1B012:  BRA    1B01E
....................       case 'x': command_x(); 
1B014:  BRA    1ACDE
....................          break;    
1B016:  BRA    1B01E
....................       case 'y': command_y(); 
1B018:  BRA    1AD78
....................          break;  
1B01A:  BRA    1B01E
....................       case 'z': command_z(); 
1B01C:  BRA    1AE0E
....................          break;           
....................    } 
1B01E:  GOTO   1B1A6 (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... #define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c" 
.................... #define BYTE_TO_BINARY(byte)  \ 
....................   (byte & 0x80 ? '1' : '0'), \ 
....................   (byte & 0x40 ? '1' : '0'), \ 
....................   (byte & 0x20 ? '1' : '0'), \ 
....................   (byte & 0x10 ? '1' : '0'), \ 
....................   (byte & 0x08 ? '1' : '0'), \ 
....................   (byte & 0x04 ? '1' : '0'), \ 
....................   (byte & 0x02 ? '1' : '0'), \ 
....................   (byte & 0x01 ? '1' : '0')  
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................  
....................   number = 0; 
*
1B0F2:  MOVLB  8
1B0F4:  CLRF   x64
....................   arg = 0; 
1B0F6:  CLRF   4B
1B0F8:  CLRF   4A
1B0FA:  CLRF   49
1B0FC:  CLRF   48
....................   good_arg = FALSE; 
1B0FE:  CLRF   x65
....................    
....................   while (number != CARRIAGE_RET) 
1B100:  MOVF   x64,W
1B102:  SUBLW  0D
1B104:  BZ    1B1D8
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
1B106:  MOVLB  0
1B108:  CALL   0E38
1B10C:  MOVFF  01,864
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
1B110:  MOVLB  8
1B112:  MOVF   x64,W
1B114:  SUBLW  0D
1B116:  BZ    1B122
1B118:  MOVF   x64,W
1B11A:  MOVLB  0
1B11C:  CALL   ADD8
1B120:  MOVLB  8
....................      if (number > 47 && number < 58) 
1B122:  MOVF   x64,W
1B124:  SUBLW  2F
1B126:  BC    1B178
1B128:  MOVF   x64,W
1B12A:  SUBLW  39
1B12C:  BNC   1B178
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
1B12E:  MOVLW  30
1B130:  SUBWF  x64,F
....................         arg = arg * 10;                    // increase significance 
1B132:  MOVFF  4B,9DA
1B136:  MOVFF  4A,9D9
1B13A:  MOVFF  49,9D8
1B13E:  MOVFF  48,9D7
1B142:  MOVLB  9
1B144:  CLRF   xDE
1B146:  CLRF   xDD
1B148:  CLRF   xDC
1B14A:  MOVLW  0A
1B14C:  MOVWF  xDB
1B14E:  MOVLB  0
1B150:  CALL   478E
1B154:  MOVFF  03,4B
1B158:  MOVFF  02,4A
1B15C:  MOVFF  01,49
1B160:  MOVFF  00,48
....................         arg = arg + number;                // for each number 
1B164:  MOVLB  8
1B166:  MOVF   x64,W
1B168:  ADDWF  48,F
1B16A:  MOVLW  00
1B16C:  ADDWFC 49,F
1B16E:  ADDWFC 4A,F
1B170:  ADDWFC 4B,F
....................         good_arg = TRUE; 
1B172:  MOVLW  01
1B174:  MOVWF  x65
....................      } 
1B176:  BRA    1B1D0
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
1B178:  MOVF   x64,W
1B17A:  SUBLW  0D
1B17C:  BNZ   1B1AA
1B17E:  DECFSZ x65,W
1B180:  BRA    1B1AA
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
1B182:  MOVLW  B8
1B184:  MOVWF  FF6
1B186:  MOVLW  27
1B188:  MOVWF  FF7
1B18A:  MOVLW  00
1B18C:  MOVWF  FF8
1B18E:  MOVLB  0
1B190:  CALL   ADA6
1B194:  MOVLW  0D
1B196:  BTFSS  F9E.4
1B198:  BRA    1B196
1B19A:  MOVWF  FAD
1B19C:  MOVLW  0A
1B19E:  BTFSS  F9E.4
1B1A0:  BRA    1B19E
1B1A2:  MOVWF  FAD
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
1B1A4:  BRA    1AE84
....................      } 
1B1A6:  BRA    1B1CE
1B1A8:  MOVLB  8
....................      else 
....................      { 
....................         good_arg = FALSE; 
1B1AA:  CLRF   x65
....................         fputs("@ARG ", COM_A);             // bad input 
1B1AC:  MOVLW  BE
1B1AE:  MOVWF  FF6
1B1B0:  MOVLW  27
1B1B2:  MOVWF  FF7
1B1B4:  MOVLW  00
1B1B6:  MOVWF  FF8
1B1B8:  MOVLB  0
1B1BA:  CALL   ADA6
1B1BE:  MOVLW  0D
1B1C0:  BTFSS  F9E.4
1B1C2:  BRA    1B1C0
1B1C4:  MOVWF  FAD
1B1C6:  MOVLW  0A
1B1C8:  BTFSS  F9E.4
1B1CA:  BRA    1B1C8
1B1CC:  MOVWF  FAD
1B1CE:  MOVLB  8
....................      } 
....................      if (good_arg == FALSE) break; 
1B1D0:  MOVF   x65,F
1B1D2:  BTFSC  FD8.2
1B1D4:  BRA    1B1D8
1B1D6:  BRA    1B100
....................   } 
1B1D8:  MOVLB  0
1B1DA:  GOTO   1B20E (RETURN)
.................... } 
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0AE22:  MOVF   51,F
0AE24:  BNZ   AE76
0AE26:  MOVLB  8
0AE28:  MOVF   x64,W
0AE2A:  SUBLW  24
0AE2C:  BC    AE34
0AE2E:  MOVF   x64,W
0AE30:  SUBLW  26
0AE32:  BC    AE6E
0AE34:  MOVF   x64,W
0AE36:  SUBLW  29
0AE38:  BC    AE40
0AE3A:  MOVF   x64,W
0AE3C:  SUBLW  2B
0AE3E:  BC    AE6E
0AE40:  MOVF   x64,W
0AE42:  SUBLW  2D
0AE44:  BZ    AE6E
0AE46:  MOVF   x64,W
0AE48:  SUBLW  2F
0AE4A:  BZ    AE6E
0AE4C:  MOVF   x64,W
0AE4E:  SUBLW  40
0AE50:  BC    AE58
0AE52:  MOVF   x64,W
0AE54:  SUBLW  42
0AE56:  BC    AE6E
0AE58:  MOVF   x64,W
0AE5A:  SUBLW  43
0AE5C:  BC    AE64
0AE5E:  MOVF   x64,W
0AE60:  SUBLW  5A
0AE62:  BC    AE6E
0AE64:  MOVF   x64,W
0AE66:  SUBLW  5E
0AE68:  BZ    AE6E
0AE6A:  MOVLW  00
0AE6C:  BRA    AE70
0AE6E:  MOVLW  01
0AE70:  MOVWF  x65
0AE72:  BRA    AED8
0AE74:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0AE76:  DECFSZ 51,W
0AE78:  BRA    AEDA
0AE7A:  MOVLB  8
0AE7C:  MOVF   x64,W
0AE7E:  SUBLW  23
0AE80:  BZ    AED4
0AE82:  MOVF   x64,W
0AE84:  SUBLW  24
0AE86:  BC    AE8E
0AE88:  MOVF   x64,W
0AE8A:  SUBLW  26
0AE8C:  BC    AED4
0AE8E:  MOVF   x64,W
0AE90:  SUBLW  29
0AE92:  BC    AE9A
0AE94:  MOVF   x64,W
0AE96:  SUBLW  2B
0AE98:  BC    AED4
0AE9A:  MOVF   x64,W
0AE9C:  SUBLW  2D
0AE9E:  BZ    AED4
0AEA0:  MOVF   x64,W
0AEA2:  SUBLW  2F
0AEA4:  BZ    AED4
0AEA6:  MOVF   x64,W
0AEA8:  SUBLW  40
0AEAA:  BC    AEB2
0AEAC:  MOVF   x64,W
0AEAE:  SUBLW  42
0AEB0:  BC    AED4
0AEB2:  MOVF   x64,W
0AEB4:  SUBLW  43
0AEB6:  BC    AEBE
0AEB8:  MOVF   x64,W
0AEBA:  SUBLW  5A
0AEBC:  BC    AED4
0AEBE:  MOVF   x64,W
0AEC0:  SUBLW  5E
0AEC2:  BZ    AED4
0AEC4:  MOVF   x64,W
0AEC6:  SUBLW  60
0AEC8:  BC    AED0
0AECA:  MOVF   x64,W
0AECC:  SUBLW  7A
0AECE:  BC    AED4
0AED0:  MOVLW  00
0AED2:  BRA    AED6
0AED4:  MOVLW  01
0AED6:  MOVWF  x65
0AED8:  MOVLB  0
....................    return(valid); 
0AEDA:  MOVLB  8
0AEDC:  MOVFF  865,01
0AEE0:  MOVLB  0
0AEE2:  GOTO   1B1E6 (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
*
1B1DE:  MOVFF  47,864
1B1E2:  GOTO   AE22
1B1E6:  MOVF   01,F
1B1E8:  BZ    1B1EE
1B1EA:  BRA    1B0F2
1B1EC:  BRA    1B20E
....................    else fputs("@INV", COM_A); 
1B1EE:  MOVLW  C4
1B1F0:  MOVWF  FF6
1B1F2:  MOVLW  27
1B1F4:  MOVWF  FF7
1B1F6:  MOVLW  00
1B1F8:  MOVWF  FF8
1B1FA:  CALL   ADA6
1B1FE:  MOVLW  0D
1B200:  BTFSS  F9E.4
1B202:  BRA    1B200
1B204:  MOVWF  FAD
1B206:  MOVLW  0A
1B208:  BTFSS  F9E.4
1B20A:  BRA    1B208
1B20C:  MOVWF  FAD
1B20E:  GOTO   1B290 (RETURN)
.................... } 
....................  
.................... void command_prompt() 
.................... { 
....................    //disable_interrupts(INT_EXT); 
....................     
....................    nv_cmd_mode = TRUE; 
1B212:  CLRF   32
1B214:  MOVLW  01
1B216:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1B218:  MOVLW  02
1B21A:  MOVLB  8
1B21C:  MOVWF  x6A
1B21E:  MOVFF  31,86B
1B222:  MOVLB  0
1B224:  CALL   33AE
....................     
....................    fputs("@CMD", COM_A); 
1B228:  MOVLW  CA
1B22A:  MOVWF  FF6
1B22C:  MOVLW  27
1B22E:  MOVWF  FF7
1B230:  MOVLW  00
1B232:  MOVWF  FF8
1B234:  CALL   ADA6
1B238:  MOVLW  0D
1B23A:  BTFSS  F9E.4
1B23C:  BRA    1B23A
1B23E:  MOVWF  FAD
1B240:  MOVLW  0A
1B242:  BTFSS  F9E.4
1B244:  BRA    1B242
1B246:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1B248:  MOVLW  01
1B24A:  MOVWF  1E
1B24C:  MOVLW  A7
1B24E:  MOVWF  1D
1B250:  MOVLW  D0
1B252:  MOVWF  FF6
1B254:  MOVLW  27
1B256:  MOVWF  FF7
1B258:  MOVLW  00
1B25A:  MOVWF  FF8
1B25C:  CALL   5052
....................    record_event(); 
1B260:  CALL   8436
....................     
....................    busy_clear(); 
1B264:  CALL   ADD0
....................     
....................    cmd_set=0; // user 
1B268:  CLRF   51
....................     
....................    do { 
....................       fputc('>',COM_A); 
1B26A:  MOVLW  3E
1B26C:  CALL   ADD8
....................       cmd=fgetc(COM_A); 
1B270:  CALL   0E38
1B274:  MOVFF  01,47
....................       if (com_echo == TRUE) 
1B278:  DECFSZ 4C,W
1B27A:  BRA    1B282
....................       { 
....................          fputc(cmd,COM_A); 
1B27C:  MOVF   47,W
1B27E:  CALL   ADD8
....................       } 
....................       if (cmd == '?') msg_busy(); 
1B282:  MOVF   47,W
1B284:  SUBLW  3F
1B286:  BNZ   1B28E
1B288:  GOTO   ADE0
1B28C:  BRA    1B290
....................       else proc_cmd(); 
1B28E:  BRA    1B1DE
....................       //restart_wdt(); 
....................    } while(nv_cmd_mode == TRUE); 
1B290:  DECFSZ 31,W
1B292:  BRA    1B298
1B294:  MOVF   32,F
1B296:  BZ    1B26A
1B298:  RETURN 0
.................... } 
....................  
....................  
.................... void main() 
1B29A:  CLRF   FF8
1B29C:  BCF    FD0.7
1B29E:  BSF    07.7
1B2A0:  MOVLW  70
1B2A2:  MOVWF  FD3
1B2A4:  MOVLW  40
1B2A6:  MOVWF  F9B
1B2A8:  CLRF   F64
1B2AA:  CLRF   1C
1B2AC:  BSF    F65.3
1B2AE:  MOVWF  FAF
1B2B0:  MOVLW  03
1B2B2:  MOVWF  FD4
1B2B4:  MOVLW  A6
1B2B6:  MOVWF  FAC
1B2B8:  MOVLW  90
1B2BA:  MOVWF  FAB
1B2BC:  MOVLB  F
1B2BE:  BSF    x20.3
1B2C0:  MOVLW  82
1B2C2:  MOVWF  x1E
1B2C4:  MOVLW  06
1B2C6:  MOVWF  x1F
1B2C8:  MOVLW  A6
1B2CA:  MOVWF  x21
1B2CC:  MOVLW  90
1B2CE:  MOVWF  x22
1B2D0:  BSF    F65.3
1B2D2:  MOVLW  40
1B2D4:  MOVWF  FAF
1B2D6:  MOVLW  03
1B2D8:  MOVWF  FD4
1B2DA:  MOVLW  A6
1B2DC:  MOVWF  FAC
1B2DE:  MOVLW  90
1B2E0:  MOVWF  FAB
1B2E2:  CLRF   1E
1B2E4:  CLRF   1D
1B2E6:  SETF   3A
1B2E8:  SETF   39
1B2EA:  SETF   3C
1B2EC:  SETF   3B
1B2EE:  CLRF   46
1B2F0:  MOVLW  01
1B2F2:  MOVWF  45
1B2F4:  MOVWF  4C
1B2F6:  BCF    4D.0
1B2F8:  BCF    4D.1
1B2FA:  BCF    4D.2
1B2FC:  MOVLB  0
1B2FE:  CLRF   x66
1B300:  MOVLB  2
1B302:  MOVWF  xD9
1B304:  MOVLB  3
1B306:  CLRF   x3B
1B308:  MOVLB  4
1B30A:  CLRF   xE7
1B30C:  MOVWF  xED
1B30E:  MOVLW  04
1B310:  MOVLB  7
1B312:  MOVWF  x13
1B314:  MOVLW  EE
1B316:  MOVWF  x12
1B318:  CLRF   xCD
1B31A:  MOVLB  8
1B31C:  CLRF   x58
1B31E:  CLRF   x57
1B320:  CLRF   x5C
1B322:  CLRF   x5B
1B324:  CLRF   x5A
1B326:  CLRF   x59
1B328:  CLRF   x60
1B32A:  CLRF   x5F
1B32C:  CLRF   x5E
1B32E:  CLRF   x5D
1B330:  MOVLW  00
1B332:  MOVLB  F
1B334:  MOVWF  x23
1B336:  MOVWF  x24
1B338:  MOVWF  x25
1B33A:  BCF    FC1.3
1B33C:  BCF    FC1.4
1B33E:  BCF    FC1.5
1B340:  CLRF   x2E
1B342:  CLRF   x2F
1B344:  CLRF   x54
1B346:  BRA    1B408
1B348:  DATA 44,02
1B34A:  DATA DD,20
1B34C:  DATA 64,72
1B34E:  DATA 61,77
1B350:  DATA 5F,61
1B352:  DATA 6C,6C
1B354:  DATA 2E,63
1B356:  DATA 73,76
1B358:  DATA 00,20
1B35A:  DATA 64,72
1B35C:  DATA 61,77
1B35E:  DATA 5F,6E
1B360:  DATA 65,77
1B362:  DATA 2E,63
1B364:  DATA 73,76
1B366:  DATA 00,20
1B368:  DATA 64,72
1B36A:  DATA 65,6C
1B36C:  DATA 5F,61
1B36E:  DATA 6C,6C
1B370:  DATA 2E,63
1B372:  DATA 73,76
1B374:  DATA 00,20
1B376:  DATA 64,72
1B378:  DATA 65,6C
1B37A:  DATA 5F,6E
1B37C:  DATA 65,77
1B37E:  DATA 2E,63
1B380:  DATA 73,76
1B382:  DATA 00,20
1B384:  DATA 65,76
1B386:  DATA 65,6E
1B388:  DATA 74,73
1B38A:  DATA 2E,74
1B38C:  DATA 78,74
1B38E:  DATA 00,02
1B390:  DATA 03,39
1B392:  DATA 2C,00
1B394:  DATA 02,04
1B396:  DATA D8,00
1B398:  DATA 00,10
1B39A:  DATA 07,14
1B39C:  DATA 46,41
1B39E:  DATA 54,31
1B3A0:  DATA 32,46
1B3A2:  DATA 41,54
1B3A4:  DATA 31,36
1B3A6:  DATA 46,41
1B3A8:  DATA 54,33
1B3AA:  DATA 32,00
1B3AC:  DATA 57,07
1B3AE:  DATA CE,0D
1B3B0:  DATA 0A,00
1B3B2:  DATA 00,03
1B3B4:  DATA 00,0F
1B3B6:  DATA 00,1B
1B3B8:  DATA 00,27
1B3BA:  DATA 00,33
1B3BC:  DATA 00,3F
1B3BE:  DATA 00,4B
1B3C0:  DATA 00,57
1B3C2:  DATA 00,63
1B3C4:  DATA 00,6F
1B3C6:  DATA 00,7B
1B3C8:  DATA 00,87
1B3CA:  DATA 00,93
1B3CC:  DATA 00,9F
1B3CE:  DATA 00,AB
1B3D0:  DATA 00,B7
1B3D2:  DATA 00,C3
1B3D4:  DATA 48,B1
1B3D6:  DATA 70,D4
1B3D8:  DATA 98,F7
1B3DA:  DATA C0,1A
1B3DC:  DATA 00,CF
1B3DE:  DATA 28,F2
1B3E0:  DATA 50,15
1B3E2:  DATA 78,38
1B3E4:  DATA A0,5B
1B3E6:  DATA C8,7E
1B3E8:  DATA F0,A1
1B3EA:  DATA 18,C5
1B3EC:  DATA 40,E8
1B3EE:  DATA 68,0B
1B3F0:  DATA 90,2E
1B3F2:  DATA B8,51
1B3F4:  DATA E0,74
1B3F6:  DATA 08,98
1B3F8:  DATA 30,BB
1B3FA:  DATA 58,DE
1B3FC:  DATA 80,01
1B3FE:  DATA A8,24
1B400:  DATA D0,47
1B402:  DATA F8,6A
1B404:  DATA 20,8E
1B406:  DATA 00,00
1B408:  MOVLW  01
1B40A:  MOVWF  FF8
1B40C:  MOVLW  B3
1B40E:  MOVWF  FF7
1B410:  MOVLW  48
1B412:  MOVWF  FF6
1B414:  TBLRD*+
1B416:  MOVF   FF5,W
1B418:  MOVWF  00
1B41A:  XORLW  00
1B41C:  BZ    1B444
1B41E:  TBLRD*+
1B420:  MOVF   FF5,W
1B422:  MOVWF  01
1B424:  BTFSC  FE8.7
1B426:  BRA    1B432
1B428:  ANDLW  0F
1B42A:  MOVWF  FEA
1B42C:  TBLRD*+
1B42E:  MOVFF  FF5,FE9
1B432:  BTFSC  01.6
1B434:  TBLRD*+
1B436:  BTFSS  01.6
1B438:  TBLRD*+
1B43A:  MOVFF  FF5,FEE
1B43E:  DCFSNZ 00,F
1B440:  BRA    1B414
1B442:  BRA    1B436
1B444:  CLRF   FF8
1B446:  MOVLB  8
1B448:  CLRF   x61
1B44A:  CLRF   x63
1B44C:  CLRF   x62
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B44E:  BCF    FF2.6
1B450:  BCF    FF2.7
1B452:  BTFSC  FF2.7
1B454:  BRA    1B450
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B456:  BCF    FC6.5
1B458:  MOVLW  21
1B45A:  MOVWF  FC6
1B45C:  MOVLW  40
1B45E:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B460:  BCF    F67.5
1B462:  MOVLW  21
1B464:  MOVWF  F67
1B466:  MOVLW  40
1B468:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B46A:  MOVLW  00
1B46C:  MOVLB  F
1B46E:  MOVWF  x23
1B470:  MOVWF  x24
1B472:  MOVLW  1F
1B474:  MOVWF  x25
1B476:  BCF    FC1.3
1B478:  BSF    FC1.4
1B47A:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B47C:  MOVF   FC0,W
1B47E:  ANDLW  C0
1B480:  IORLW  07
1B482:  MOVWF  FC0
1B484:  BSF    FC0.7
1B486:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B488:  MOVLW  87
1B48A:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B48C:  MOVLW  37
1B48E:  MOVWF  FCD
1B490:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B492:  MOVLB  0
1B494:  GOTO   2860
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B498:  CLRF   FB0
1B49A:  MOVLW  07
1B49C:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B49E:  MOVLW  04
1B4A0:  MOVLB  F
1B4A2:  MOVWF  x2E
1B4A4:  MOVWF  x2F
1B4A6:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B4A8:  MOVLW  70
1B4AA:  MOVWF  FD3
1B4AC:  MOVLW  40
1B4AE:  MOVWF  F9B
1B4B0:  CLRF   F64
....................     
....................    //setup_wdt(WDT_4S); 
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B4B2:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B4B4:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B4B6:  MOVLB  0
1B4B8:  CALL   289C
....................  
....................    enable_interrupts(GLOBAL); 
1B4BC:  MOVLW  C0
1B4BE:  IORWF  FF2,F
....................     
....................     
....................  
....................    init_hardware(); 
1B4C0:  CALL   28D6
....................    motor_sleep_rdy(); 
1B4C4:  CALL   2934
....................  
....................    sleep_mode = FALSE;    
1B4C8:  BCF    4D.1
....................    busy_set(); 
1B4CA:  CALL   295C
....................     
....................    init_nv_vars(); 
1B4CE:  CALL   2A54
....................    get_step_vars(); 
1B4D2:  CALL   2CB6
....................    init_aws(); 
1B4D6:  GOTO   3078
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B4DA:  CALL   3092
....................    blink(); 
1B4DE:  GOTO   3098
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B4E2:  CALL   30E4
....................     
....................    RTC_read(); 
1B4E6:  CALL   32E0
....................    RTC_last_power(); 
1B4EA:  GOTO   33DE
....................    RTC_reset_HT();   
1B4EE:  CALL   344E
....................    RTC_read(); 
1B4F2:  CALL   32E0
1B4F6:  CLRF   1B
1B4F8:  BTFSC  FF2.7
1B4FA:  BSF    1B.7
1B4FC:  BCF    FF2.7
....................    RTC_read_flags(); 
1B4FE:  CALL   0DD8
1B502:  BTFSC  1B.7
1B504:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B506:  MOVF   3F,F
1B508:  BNZ   1B50E
1B50A:  MOVF   40,F
1B50C:  BZ    1B55E
1B50E:  MOVLW  E2
1B510:  MOVWF  FF6
1B512:  MOVLW  27
1B514:  MOVWF  FF7
1B516:  MOVLW  00
1B518:  MOVWF  FF8
1B51A:  CLRF   1B
1B51C:  BTFSC  FF2.7
1B51E:  BSF    1B.7
1B520:  BCF    FF2.7
1B522:  MOVLW  04
1B524:  MOVLB  A
1B526:  MOVWF  x1C
1B528:  MOVLB  0
1B52A:  CALL   1024
1B52E:  BTFSC  1B.7
1B530:  BSF    FF2.7
1B532:  MOVLW  10
1B534:  MOVWF  FE9
1B536:  CLRF   1B
1B538:  BTFSC  FF2.7
1B53A:  BSF    1B.7
1B53C:  BCF    FF2.7
1B53E:  MOVFF  40,A1D
1B542:  MOVFF  3F,A1C
1B546:  CALL   11A6
1B54A:  BTFSC  1B.7
1B54C:  BSF    FF2.7
1B54E:  MOVLW  0D
1B550:  BTFSS  F9E.4
1B552:  BRA    1B550
1B554:  MOVWF  FAD
1B556:  MOVLW  0A
1B558:  BTFSS  F9E.4
1B55A:  BRA    1B558
1B55C:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B55E:  CALL   34A4
....................    sd_status = init_sdcard(); 
1B562:  CALL   4FCE
1B566:  MOVFF  01,2DC
....................    if(sd_status>0) msg_card_fail(); 
1B56A:  MOVLB  2
1B56C:  MOVF   xDC,F
1B56E:  BZ    1B578
1B570:  MOVLB  0
1B572:  CALL   5014
1B576:  MOVLB  2
....................    
....................     
....................     
....................    reset_event(); 
1B578:  MOVLB  0
1B57A:  GOTO   AB22
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B57E:  MOVLB  7
1B580:  MOVF   x96,F
1B582:  BNZ   1B590
1B584:  MOVF   x97,F
1B586:  BNZ   1B590
1B588:  MOVF   x98,F
1B58A:  BNZ   1B590
1B58C:  MOVF   x99,F
1B58E:  BZ    1B598
1B590:  MOVLB  0
1B592:  CALL   9C5E
1B596:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B598:  MOVF   xAF,F
1B59A:  BNZ   1B61E
1B59C:  MOVF   xB0,F
1B59E:  BNZ   1B61E
....................       e_port[0]=0; 
1B5A0:  CLRF   xC4
1B5A2:  CLRF   xC3
....................       write16(ADDR_E1_PORT,0); 
1B5A4:  MOVLW  AA
1B5A6:  MOVLB  8
1B5A8:  MOVWF  xCF
1B5AA:  CLRF   xD1
1B5AC:  CLRF   xD0
1B5AE:  MOVLB  0
1B5B0:  CALL   4F68
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B5B4:  MOVLW  EC
1B5B6:  MOVWF  FF6
1B5B8:  MOVLW  27
1B5BA:  MOVWF  FF7
1B5BC:  MOVLW  00
1B5BE:  MOVWF  FF8
1B5C0:  CLRF   1B
1B5C2:  BTFSC  FF2.7
1B5C4:  BSF    1B.7
1B5C6:  BCF    FF2.7
1B5C8:  MOVLW  05
1B5CA:  MOVLB  A
1B5CC:  MOVWF  x1C
1B5CE:  MOVLB  0
1B5D0:  CALL   1024
1B5D4:  BTFSC  1B.7
1B5D6:  BSF    FF2.7
1B5D8:  MOVLW  10
1B5DA:  MOVWF  FE9
1B5DC:  CLRF   1B
1B5DE:  BTFSC  FF2.7
1B5E0:  BSF    1B.7
1B5E2:  BCF    FF2.7
1B5E4:  MOVFF  7B0,A1D
1B5E8:  MOVFF  7AF,A1C
1B5EC:  CALL   11A6
1B5F0:  BTFSC  1B.7
1B5F2:  BSF    FF2.7
1B5F4:  MOVLW  2C
1B5F6:  BTFSS  F9E.4
1B5F8:  BRA    1B5F6
1B5FA:  MOVWF  FAD
1B5FC:  MOVLW  10
1B5FE:  MOVWF  FE9
1B600:  MOVFF  7C4,8D2
1B604:  MOVFF  7C3,8D1
1B608:  CALL   8F40
1B60C:  MOVLW  0D
1B60E:  BTFSS  F9E.4
1B610:  BRA    1B60E
1B612:  MOVWF  FAD
1B614:  MOVLW  0A
1B616:  BTFSS  F9E.4
1B618:  BRA    1B616
1B61A:  MOVWF  FAD
1B61C:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B61E:  MOVF   xB1,F
1B620:  BNZ   1B6A4
1B622:  MOVF   xB2,F
1B624:  BNZ   1B6A4
....................       m_lin_pos[1]=-1; 
1B626:  SETF   xB6
1B628:  SETF   xB5
....................       write16(ADDR_M2_LIN_POS, -1); 
1B62A:  MOVLW  B8
1B62C:  MOVLB  8
1B62E:  MOVWF  xCF
1B630:  SETF   xD1
1B632:  SETF   xD0
1B634:  MOVLB  0
1B636:  CALL   4F68
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B63A:  MOVLW  FC
1B63C:  MOVWF  FF6
1B63E:  MOVLW  27
1B640:  MOVWF  FF7
1B642:  MOVLW  00
1B644:  MOVWF  FF8
1B646:  CLRF   1B
1B648:  BTFSC  FF2.7
1B64A:  BSF    1B.7
1B64C:  BCF    FF2.7
1B64E:  MOVLW  05
1B650:  MOVLB  A
1B652:  MOVWF  x1C
1B654:  MOVLB  0
1B656:  CALL   1024
1B65A:  BTFSC  1B.7
1B65C:  BSF    FF2.7
1B65E:  MOVLW  10
1B660:  MOVWF  FE9
1B662:  CLRF   1B
1B664:  BTFSC  FF2.7
1B666:  BSF    1B.7
1B668:  BCF    FF2.7
1B66A:  MOVFF  7B2,A1D
1B66E:  MOVFF  7B1,A1C
1B672:  CALL   11A6
1B676:  BTFSC  1B.7
1B678:  BSF    FF2.7
1B67A:  MOVLW  2C
1B67C:  BTFSS  F9E.4
1B67E:  BRA    1B67C
1B680:  MOVWF  FAD
1B682:  MOVLW  10
1B684:  MOVWF  FE9
1B686:  MOVFF  7B6,8D2
1B68A:  MOVFF  7B5,8D1
1B68E:  CALL   8F40
1B692:  MOVLW  0D
1B694:  BTFSS  F9E.4
1B696:  BRA    1B694
1B698:  MOVWF  FAD
1B69A:  MOVLW  0A
1B69C:  BTFSS  F9E.4
1B69E:  BRA    1B69C
1B6A0:  MOVWF  FAD
1B6A2:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1B6A4:  MOVF   31,F
1B6A6:  BNZ   1B74A
1B6A8:  MOVF   32,F
1B6AA:  BNZ   1B74A
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1B6AC:  MOVLW  0C
1B6AE:  MOVWF  FF6
1B6B0:  MOVLW  28
1B6B2:  MOVWF  FF7
1B6B4:  MOVLW  00
1B6B6:  MOVWF  FF8
1B6B8:  CLRF   1B
1B6BA:  BTFSC  FF2.7
1B6BC:  BSF    1B.7
1B6BE:  BCF    FF2.7
1B6C0:  MOVLB  0
1B6C2:  CALL   0E4E
1B6C6:  BTFSC  1B.7
1B6C8:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1B6CA:  MOVLB  8
1B6CC:  MOVF   x63,F
1B6CE:  BNZ   1B6FC
1B6D0:  MOVF   x62,W
1B6D2:  SUBLW  63
1B6D4:  BNC   1B6FC
1B6D6:  MOVF   x61,W
1B6D8:  SUBLW  1B
1B6DA:  BZ    1B6FC
....................       { 
....................          EscNum=TestForEsc(); 
1B6DC:  MOVLB  0
1B6DE:  GOTO   AD4C
1B6E2:  MOVFF  01,861
....................          if(EscNum == ESCAPE) command_prompt(); 
1B6E6:  MOVLB  8
1B6E8:  MOVF   x61,W
1B6EA:  SUBLW  1B
1B6EC:  BNZ   1B6F4
1B6EE:  MOVLB  0
1B6F0:  RCALL  1B212
1B6F2:  MOVLB  8
....................          EscCount++; 
1B6F4:  INCF   x62,F
1B6F6:  BTFSC  FD8.2
1B6F8:  INCF   x63,F
1B6FA:  BRA    1B6CC
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1B6FC:  DECFSZ 33,W
1B6FE:  BRA    1B714
1B700:  MOVF   34,F
1B702:  BNZ   1B714
....................       { 
....................          arg=0; 
1B704:  CLRF   4B
1B706:  CLRF   4A
1B708:  CLRF   49
1B70A:  CLRF   48
....................          commandZ(); 
1B70C:  MOVLB  0
1B70E:  CALL   187A2
1B712:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1B714:  MOVLW  44
1B716:  MOVWF  FF6
1B718:  MOVLW  28
1B71A:  MOVWF  FF7
1B71C:  MOVLW  00
1B71E:  MOVWF  FF8
1B720:  CLRF   1B
1B722:  BTFSC  FF2.7
1B724:  BSF    1B.7
1B726:  BCF    FF2.7
1B728:  MOVLB  0
1B72A:  CALL   0E4E
1B72E:  BTFSC  1B.7
1B730:  BSF    FF2.7
....................       arg = 0; 
1B732:  CLRF   4B
1B734:  CLRF   4A
1B736:  CLRF   49
1B738:  CLRF   48
....................       commandM(TRUE); 
1B73A:  MOVLW  01
1B73C:  MOVLB  8
1B73E:  MOVWF  x66
1B740:  MOVLB  0
1B742:  CALL   1692E
....................    } 
1B746:  BRA    1B74E
1B748:  MOVLB  7
....................    else 
....................    { 
....................       /*int8 RTC_buffer = 0; 
....................       unsigned int8 a0 = 0; 
....................       unsigned int8 a1 = 0; 
....................       unsigned int8 a2 = 0; 
....................       unsigned int8 a3 = 0; 
....................       unsigned int8 a4 = 0; 
....................       unsigned int8 a5 = 0; 
....................       unsigned int8 a6 = 0; 
....................       unsigned int8 a7 = 0; 
....................       unsigned int8 a8 = 0; 
....................       unsigned int8 a9 = 0; 
....................       unsigned int8 a10 = 0; 
....................       unsigned int8 a11 = 0; 
....................        
....................       RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
....................       spi_write(0x89); 
....................       spi_write(0b11000011); 
....................       output_bit(RTC_CS, DISABLE); 
....................        
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x00); 
....................       a0 = RTC_buffer; 
....................       fprintf(COM_A,"crap: %u\r\n",RTC_buffer); 
....................       a1 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg0: %u\r\n",a1); 
....................       a2 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg1: %u\r\n",a2); 
....................       a3 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg2: %u\r\n",a3); 
....................       a4 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg3: %u\r\n",a4); 
....................       a5 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg4: %u\r\n",a5); 
....................       a6 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg5: %u\r\n",a6); 
....................       a7 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg6: %u\r\n",a7); 
....................       a8 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg7: %u\r\n",a8); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg8: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg9: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regA: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regB: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regC: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regD: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regE: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regF: %u\r\n",a9); 
....................        
....................       output_bit(RTC_CS, DISABLE);*/ 
....................     
....................       command_prompt(); 
1B74A:  MOVLB  0
1B74C:  RCALL  1B212
....................    } 
....................  
....................    reset_cpu(); 
1B74E:  RESET
.................... } 
....................  
1B750:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 2878   PUT NOBROWNOUT BORV18 ZPBORM NOWDT WDT1024
   Word  3: 8BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
