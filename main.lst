CCS PCH C Compiler, Version 5.071d, 1               07-Jul-17 15:23
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   115086 bytes (88%)
                           Largest free fragment is 15620
               RAM used:   2148 (56%) at main() level
                           2649 (69%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1B644
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0F08
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0F32
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   1928
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E34
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   170A
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   1780
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E98
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
....................              /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 0D,0A
00668:  DATA 3F,40
0066A:  DATA 42,53
0066C:  DATA 59,0D
0066E:  DATA 0A,00
00670:  DATA 0D,0A
00672:  DATA 40,52
00674:  DATA 44,59
00676:  DATA 0D,0A
00678:  DATA 00,00
0067A:  DATA 40,46
0067C:  DATA 53,3A
0067E:  DATA 44,69
00680:  DATA 73,63
00682:  DATA 6F,76
00684:  DATA 65,72
00686:  DATA 79,0D
00688:  DATA 0A,00
0068A:  DATA 40,46
0068C:  DATA 53,3A
0068E:  DATA 55,6E
00690:  DATA 61,62
00692:  DATA 6C,65
00694:  DATA 20,74
00696:  DATA 6F,20
00698:  DATA 70,75
0069A:  DATA 74,20
0069C:  DATA 63,61
0069E:  DATA 72,64
006A0:  DATA 20,69
006A2:  DATA 6E,20
006A4:  DATA 69,64
006A6:  DATA 6C,65
006A8:  DATA 20,73
006AA:  DATA 74,61
006AC:  DATA 74,65
006AE:  DATA 2C,20
006B0:  DATA 72,65
006B2:  DATA 73,70
006B4:  DATA 6F,6E
006B6:  DATA 73,65
006B8:  DATA 20,3D
006BA:  DATA 20,25
006BC:  DATA 30,32
006BE:  DATA 78,0D
006C0:  DATA 0A,00
006C2:  DATA 40,46
006C4:  DATA 53,3A
006C6:  DATA 43,61
006C8:  DATA 72,64
006CA:  DATA 20,69
006CC:  DATA 64,6C
006CE:  DATA 65,2C
006D0:  DATA 20,72
006D2:  DATA 65,73
006D4:  DATA 70,6F
006D6:  DATA 6E,73
006D8:  DATA 65,20
006DA:  DATA 3D,20
006DC:  DATA 25,30
006DE:  DATA 32,78
006E0:  DATA 0D,0A
006E2:  DATA 00,00
006E4:  DATA 40,46
006E6:  DATA 53,3A
006E8:  DATA 52,65
006EA:  DATA 73,70
006EC:  DATA 6F,6E
006EE:  DATA 73,65
006F0:  DATA 20,74
006F2:  DATA 6F,20
006F4:  DATA 53,44
006F6:  DATA 20,76
006F8:  DATA 65,72
006FA:  DATA 20,32
006FC:  DATA 20,74
006FE:  DATA 65,73
00700:  DATA 74,20
00702:  DATA 43,4D
00704:  DATA 44,38
00706:  DATA 20,3D
00708:  DATA 20,25
0070A:  DATA 78,0D
0070C:  DATA 0A,00
0070E:  DATA 40,46
00710:  DATA 53,3A
00712:  DATA 50,6F
00714:  DATA 73,73
00716:  DATA 69,62
00718:  DATA 6C,65
0071A:  DATA 20,53
0071C:  DATA 44,76
0071E:  DATA 32,20
00720:  DATA 63,61
00722:  DATA 72,64
00724:  DATA 20,64
00726:  DATA 65,74
00728:  DATA 65,63
0072A:  DATA 74,65
0072C:  DATA 64,0D
0072E:  DATA 0A,00
00730:  DATA 40,46
00732:  DATA 53,3A
00734:  DATA 56,6F
00736:  DATA 6C,74
00738:  DATA 61,67
0073A:  DATA 65,20
0073C:  DATA 72,61
0073E:  DATA 6E,67
00740:  DATA 65,20
00742:  DATA 63,68
00744:  DATA 65,63
00746:  DATA 6B,2C
00748:  DATA 20,6F
0074A:  DATA 63,72
0074C:  DATA 20,3D
0074E:  DATA 20,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,25
0075C:  DATA 30,32
0075E:  DATA 78,0D
00760:  DATA 0A,00
00762:  DATA 40,46
00764:  DATA 53,3A
00766:  DATA 43,61
00768:  DATA 72,64
0076A:  DATA 20,56
0076C:  DATA 64,64
0076E:  DATA 20,72
00770:  DATA 61,6E
00772:  DATA 67,65
00774:  DATA 20,3D
00776:  DATA 20,32
00778:  DATA 2E,37
0077A:  DATA 2D,33
0077C:  DATA 2E,36
0077E:  DATA 20,76
00780:  DATA 6F,6C
00782:  DATA 74,73
00784:  DATA 0D,0A
00786:  DATA 00,00
00788:  DATA 40,46
0078A:  DATA 53,3A
0078C:  DATA 53,65
0078E:  DATA 6E,64
00790:  DATA 69,6E
00792:  DATA 67,20
00794:  DATA 41,43
00796:  DATA 4D,44
00798:  DATA 34,31
0079A:  DATA 20,63
0079C:  DATA 6F,6D
0079E:  DATA 6D,61
007A0:  DATA 6E,64
007A2:  DATA 20,74
007A4:  DATA 6F,20
007A6:  DATA 53,44
007A8:  DATA 20,76
007AA:  DATA 65,72
007AC:  DATA 20,32
007AE:  DATA 20,63
007B0:  DATA 61,72
007B2:  DATA 64,0D
007B4:  DATA 0A,00
007B6:  DATA 40,46
007B8:  DATA 53,3A
007BA:  DATA 52,65
007BC:  DATA 73,70
007BE:  DATA 6F,6E
007C0:  DATA 73,65
007C2:  DATA 20,66
007C4:  DATA 72,6F
007C6:  DATA 6D,20
007C8:  DATA 73,65
007CA:  DATA 6E,64
007CC:  DATA 69,6E
007CE:  DATA 67,20
007D0:  DATA 41,43
007D2:  DATA 4D,44
007D4:  DATA 34,31
007D6:  DATA 20,3D
007D8:  DATA 20,25
007DA:  DATA 30,32
007DC:  DATA 78,2C
007DE:  DATA 20,54
007E0:  DATA 69,6D
007E2:  DATA 65,72
007E4:  DATA 20,3D
007E6:  DATA 20,25
007E8:  DATA 6C,75
007EA:  DATA 0D,0A
007EC:  DATA 00,00
007EE:  DATA 40,46
007F0:  DATA 53,3A
007F2:  DATA 52,65
007F4:  DATA 73,70
007F6:  DATA 6F,6E
007F8:  DATA 73,65
007FA:  DATA 20,74
007FC:  DATA 6F,20
007FE:  DATA 43,4D
00800:  DATA 44,35
00802:  DATA 38,20
00804:  DATA 3D,20
00806:  DATA 25,78
00808:  DATA 0D,0A
0080A:  DATA 00,00
0080C:  DATA 40,46
0080E:  DATA 53,3A
00810:  DATA 53,65
00812:  DATA 6E,74
00814:  DATA 20,43
00816:  DATA 4D,44
00818:  DATA 20,35
0081A:  DATA 38,2C
0081C:  DATA 20,54
0081E:  DATA 69,6D
00820:  DATA 65,72
00822:  DATA 20,76
00824:  DATA 61,6C
00826:  DATA 75,65
00828:  DATA 20,3D
0082A:  DATA 20,25
0082C:  DATA 6C,75
0082E:  DATA 2C,20
00830:  DATA 6F,63
00832:  DATA 72,20
00834:  DATA 3D,20
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 25,30
00844:  DATA 32,78
00846:  DATA 0D,0A
00848:  DATA 00,00
0084A:  DATA 40,46
0084C:  DATA 53,3A
0084E:  DATA 43,61
00850:  DATA 72,64
00852:  DATA 20,43
00854:  DATA 41,4E
00856:  DATA 4E,4F
00858:  DATA 54,20
0085A:  DATA 77,6F
0085C:  DATA 72,6B
0085E:  DATA 20,56
00860:  DATA 64,64
00862:  DATA 20,72
00864:  DATA 61,6E
00866:  DATA 67,65
00868:  DATA 20,6F
0086A:  DATA 66,20
0086C:  DATA 32,2E
0086E:  DATA 37,2D
00870:  DATA 33,2E
00872:  DATA 36,20
00874:  DATA 76,6F
00876:  DATA 6C,74
00878:  DATA 73,0D
0087A:  DATA 0A,00
0087C:  DATA 40,46
0087E:  DATA 53,3A
00880:  DATA 4E,6F
00882:  DATA 74,20
00884:  DATA 61,6E
00886:  DATA 20,53
00888:  DATA 44,53
0088A:  DATA 43,20
0088C:  DATA 6F,72
0088E:  DATA 20,53
00890:  DATA 44,48
00892:  DATA 43,20
00894:  DATA 63,61
00896:  DATA 72,64
00898:  DATA 2C,20
0089A:  DATA 54,65
0089C:  DATA 73,74
0089E:  DATA 69,6E
008A0:  DATA 67,20
008A2:  DATA 66,6F
008A4:  DATA 72,20
008A6:  DATA 53,44
008A8:  DATA 20,56
008AA:  DATA 65,72
008AC:  DATA 31,20
008AE:  DATA 6F,72
008B0:  DATA 20,4D
008B2:  DATA 4D,43
008B4:  DATA 20,43
008B6:  DATA 61,72
008B8:  DATA 64,0D
008BA:  DATA 0A,00
008BC:  DATA 40,46
008BE:  DATA 53,3A
008C0:  DATA 52,65
008C2:  DATA 73,70
008C4:  DATA 6F,6E
008C6:  DATA 73,65
008C8:  DATA 20,66
008CA:  DATA 72,6F
008CC:  DATA 6D,20
008CE:  DATA 47,4F
008D0:  DATA 5F,49
008D2:  DATA 44,4C
008D4:  DATA 45,20
008D6:  DATA 3D,20
008D8:  DATA 25,30
008DA:  DATA 32,78
008DC:  DATA 0D,0A
008DE:  DATA 00,00
008E0:  DATA 40,46
008E2:  DATA 53,3A
008E4:  DATA 52,65
008E6:  DATA 73,70
008E8:  DATA 6F,6E
008EA:  DATA 73,65
008EC:  DATA 20,66
008EE:  DATA 72,6F
008F0:  DATA 6D,20
008F2:  DATA 53,44
008F4:  DATA 5F,43
008F6:  DATA 4D,44
008F8:  DATA 5F,53
008FA:  DATA 45,4E
008FC:  DATA 44,5F
008FE:  DATA 4F,50
00900:  DATA 5F,43
00902:  DATA 4F,4E
00904:  DATA 44,20
00906:  DATA 3D,20
00908:  DATA 25,30
0090A:  DATA 32,78
0090C:  DATA 2C,20
0090E:  DATA 54,69
00910:  DATA 6D,65
00912:  DATA 72,20
00914:  DATA 3D,20
00916:  DATA 25,6C
00918:  DATA 75,0D
0091A:  DATA 0A,00
0091C:  DATA 40,46
0091E:  DATA 53,3A
00920:  DATA 41,74
00922:  DATA 74,65
00924:  DATA 6D,70
00926:  DATA 74,69
00928:  DATA 6E,67
0092A:  DATA 20,53
0092C:  DATA 44,76
0092E:  DATA 31,20
00930:  DATA 76,65
00932:  DATA 72,73
00934:  DATA 75,73
00936:  DATA 20,4D
00938:  DATA 4D,43
0093A:  DATA 20,49
0093C:  DATA 44,2C
0093E:  DATA 20,52
00940:  DATA 65,73
00942:  DATA 70,6F
00944:  DATA 6E,73
00946:  DATA 65,20
00948:  DATA 66,72
0094A:  DATA 6F,6D
0094C:  DATA 20,53
0094E:  DATA 44,5F
00950:  DATA 43,4D
00952:  DATA 44,5F
00954:  DATA 41,50
00956:  DATA 50,4C
00958:  DATA 5F,43
0095A:  DATA 4D,44
0095C:  DATA 20,3D
0095E:  DATA 20,25
00960:  DATA 30,32
00962:  DATA 78,0D
00964:  DATA 0A,00
00966:  DATA 40,46
00968:  DATA 53,3A
0096A:  DATA 49,6E
0096C:  DATA 76,61
0096E:  DATA 6C,69
00970:  DATA 64,20
00972:  DATA 72,65
00974:  DATA 73,70
00976:  DATA 6F,6E
00978:  DATA 73,65
0097A:  DATA 20,74
0097C:  DATA 6F,20
0097E:  DATA 53,44
00980:  DATA 5F,41
00982:  DATA 43,4D
00984:  DATA 44,34
00986:  DATA 31,2C
00988:  DATA 20,72
0098A:  DATA 65,73
0098C:  DATA 70,6F
0098E:  DATA 6E,73
00990:  DATA 65,20
00992:  DATA 3D,20
00994:  DATA 25,30
00996:  DATA 32,58
00998:  DATA 2C,20
0099A:  DATA 72,65
0099C:  DATA 69,6E
0099E:  DATA 69,74
009A0:  DATA 69,61
009A2:  DATA 6C,69
009A4:  DATA 7A,69
009A6:  DATA 6E,67
009A8:  DATA 20,61
009AA:  DATA 73,20
009AC:  DATA 4D,4D
009AE:  DATA 43,0D
009B0:  DATA 0A,00
009B2:  DATA 40,46
009B4:  DATA 53,3A
009B6:  DATA 46,61
009B8:  DATA 69,6C
009BA:  DATA 65,64
009BC:  DATA 20,74
009BE:  DATA 6F,20
009C0:  DATA 69,6E
009C2:  DATA 69,74
009C4:  DATA 69,61
009C6:  DATA 6C,69
009C8:  DATA 7A,65
009CA:  DATA 20,61
009CC:  DATA 73,20
009CE:  DATA 4D,4D
009D0:  DATA 43,2C
009D2:  DATA 20,72
009D4:  DATA 65,73
009D6:  DATA 70,6F
009D8:  DATA 6E,73
009DA:  DATA 65,20
009DC:  DATA 3D,20
009DE:  DATA 25,30
009E0:  DATA 32,58
009E2:  DATA 2C,20
009E4:  DATA 65,78
009E6:  DATA 69,74
009E8:  DATA 69,6E
009EA:  DATA 67,0D
009EC:  DATA 0A,00
009EE:  DATA 40,46
009F0:  DATA 53,3A
009F2:  DATA 43,61
009F4:  DATA 72,64
009F6:  DATA 20,66
009F8:  DATA 61,69
009FA:  DATA 6C,65
009FC:  DATA 64,20
009FE:  DATA 74,6F
00A00:  DATA 20,72
00A02:  DATA 65,73
00A04:  DATA 70,6F
00A06:  DATA 6E,64
00A08:  DATA 20,63
00A0A:  DATA 6F,72
00A0C:  DATA 72,65
00A0E:  DATA 63,6C
00A10:  DATA 79,20
00A12:  DATA 61,66
00A14:  DATA 74,65
00A16:  DATA 72,20
00A18:  DATA 53,44
00A1A:  DATA 5F,43
00A1C:  DATA 4D,44
00A1E:  DATA 5F,53
00A20:  DATA 45,4E
00A22:  DATA 44,5F
00A24:  DATA 4F,50
00A26:  DATA 5F,43
00A28:  DATA 4F,4E
00A2A:  DATA 44,2C
00A2C:  DATA 20,72
00A2E:  DATA 65,73
00A30:  DATA 70,6F
00A32:  DATA 6E,73
00A34:  DATA 65,20
00A36:  DATA 3D,20
00A38:  DATA 25,30
00A3A:  DATA 32,58
00A3C:  DATA 2C,20
00A3E:  DATA 54,69
00A40:  DATA 6D,65
00A42:  DATA 72,20
00A44:  DATA 3D,20
00A46:  DATA 25,6C
00A48:  DATA 75,0D
00A4A:  DATA 0A,00
00A4C:  DATA 40,46
00A4E:  DATA 53,3A
00A50:  DATA 53,65
00A52:  DATA 74,74
00A54:  DATA 69,6E
00A56:  DATA 67,20
00A58:  DATA 62,6C
00A5A:  DATA 6F,63
00A5C:  DATA 6B,20
00A5E:  DATA 6C,65
00A60:  DATA 6E,67
00A62:  DATA 74,68
00A64:  DATA 0D,0A
00A66:  DATA 00,00
00A68:  DATA 40,46
00A6A:  DATA 53,3A
00A6C:  DATA 45,72
00A6E:  DATA 72,6F
00A70:  DATA 72,20
00A72:  DATA 73,65
00A74:  DATA 74,74
00A76:  DATA 69,6E
00A78:  DATA 67,20
00A7A:  DATA 62,6C
00A7C:  DATA 6F,63
00A7E:  DATA 6B,20
00A80:  DATA 6C,65
00A82:  DATA 6E,67
00A84:  DATA 74,68
00A86:  DATA 2C,20
00A88:  DATA 72,65
00A8A:  DATA 73,70
00A8C:  DATA 6F,6E
00A8E:  DATA 73,65
00A90:  DATA 20,3D
00A92:  DATA 20,25
00A94:  DATA 30,32
00A96:  DATA 78,2C
00A98:  DATA 20,74
00A9A:  DATA 69,6D
00A9C:  DATA 65,72
00A9E:  DATA 20,3D
00AA0:  DATA 20,25
00AA2:  DATA 6C,75
00AA4:  DATA 0D,0A
00AA6:  DATA 00,00
00AA8:  DATA 40,46
00AAA:  DATA 53,3A
00AAC:  DATA 43,61
00AAE:  DATA 72,64
00AB0:  DATA 20,54
00AB2:  DATA 79,70
00AB4:  DATA 65,20
00AB6:  DATA 44,69
00AB8:  DATA 73,63
00ABA:  DATA 6F,76
00ABC:  DATA 65,72
00ABE:  DATA 79,20
00AC0:  DATA 45,72
00AC2:  DATA 72,6F
00AC4:  DATA 72,0D
00AC6:  DATA 0A,00
00AC8:  DATA 40,46
00ACA:  DATA 53,3A
00ACC:  DATA 4D,4D
00ACE:  DATA 43,20
00AD0:  DATA 43,61
00AD2:  DATA 72,64
00AD4:  DATA 20,66
00AD6:  DATA 6F,75
00AD8:  DATA 6E,64
00ADA:  DATA 0D,0A
00ADC:  DATA 00,00
00ADE:  DATA 40,46
00AE0:  DATA 53,3A
00AE2:  DATA 53,44
00AE4:  DATA 76,31
00AE6:  DATA 20,43
00AE8:  DATA 61,72
00AEA:  DATA 64,20
00AEC:  DATA 66,6F
00AEE:  DATA 75,6E
00AF0:  DATA 64,0D
00AF2:  DATA 0A,00
00AF4:  DATA 40,46
00AF6:  DATA 53,3A
00AF8:  DATA 53,44
00AFA:  DATA 53,43
00AFC:  DATA 20,43
00AFE:  DATA 61,72
00B00:  DATA 64,20
00B02:  DATA 66,6F
00B04:  DATA 75,6E
00B06:  DATA 64,0D
00B08:  DATA 0A,00
00B0A:  DATA 40,46
00B0C:  DATA 53,3A
00B0E:  DATA 53,44
00B10:  DATA 48,43
00B12:  DATA 20,43
00B14:  DATA 61,72
00B16:  DATA 64,20
00B18:  DATA 66,6F
00B1A:  DATA 75,6E
00B1C:  DATA 64,0D
00B1E:  DATA 0A,00
00B20:  DATA 40,46
00B22:  DATA 53,3A
00B24:  DATA 43,61
00B26:  DATA 72,64
00B28:  DATA 20,54
00B2A:  DATA 79,70
00B2C:  DATA 65,20
00B2E:  DATA 44,69
00B30:  DATA 73,63
00B32:  DATA 6F,76
00B34:  DATA 65,72
00B36:  DATA 79,20
00B38:  DATA 45,72
00B3A:  DATA 72,6F
00B3C:  DATA 72,2C
00B3E:  DATA 20,43
00B40:  DATA 61,72
00B42:  DATA 64,20
00B44:  DATA 3D,20
00B46:  DATA 25,30
00B48:  DATA 32,58
00B4A:  DATA 0D,0A
00B4C:  DATA 00,00
00B4E:  DATA 40,46
00B50:  DATA 53,3A
00B52:  DATA 43,61
00B54:  DATA 72,64
00B56:  DATA 20,72
00B58:  DATA 65,73
00B5A:  DATA 65,74
00B5C:  DATA 20,73
00B5E:  DATA 75,63
00B60:  DATA 63,65
00B62:  DATA 73,73
00B64:  DATA 20,2D
00B66:  DATA 20,43
00B68:  DATA 6D,64
00B6A:  DATA 20,74
00B6C:  DATA 6F,20
00B6E:  DATA 52,65
00B70:  DATA 61,64
00B72:  DATA 79,20
00B74:  DATA 63,6F
00B76:  DATA 75,6E
00B78:  DATA 74,20
00B7A:  DATA 3D,20
00B7C:  DATA 25,6C
00B7E:  DATA 75,0D
00B80:  DATA 0A,00
00B82:  DATA 40,46
00B84:  DATA 53,3A
00B86:  DATA 53,50
00B88:  DATA 49,20
00B8A:  DATA 62,75
00B8C:  DATA 73,20
00B8E:  DATA 73,70
00B90:  DATA 65,65
00B92:  DATA 64,20
00B94:  DATA 73,65
00B96:  DATA 74,20
00B98:  DATA 74,6F
00B9A:  DATA 20,68
00B9C:  DATA 69,67
00B9E:  DATA 68,0D
00BA0:  DATA 0A,00
00BA2:  DATA 40,46
00BA4:  DATA 53,3A
00BA6:  DATA 43,61
00BA8:  DATA 72,64
00BAA:  DATA 20,61
00BAC:  DATA 63,74
00BAE:  DATA 69,76
00BB0:  DATA 61,74
00BB2:  DATA 65,20
00BB4:  DATA 66,61
00BB6:  DATA 69,6C
00BB8:  DATA 75,72
00BBA:  DATA 65,2C
00BBC:  DATA 20,72
00BBE:  DATA 65,73
00BC0:  DATA 70,6F
00BC2:  DATA 6E,73
00BC4:  DATA 65,20
00BC6:  DATA 3D,20
00BC8:  DATA 25,30
00BCA:  DATA 32,58
00BCC:  DATA 2C,20
00BCE:  DATA 54,69
00BD0:  DATA 6D,65
00BD2:  DATA 72,20
00BD4:  DATA 3D,20
00BD6:  DATA 25,6C
00BD8:  DATA 75,0D
00BDA:  DATA 0A,00
00BDC:  DATA 40,46
00BDE:  DATA 53,3A
00BE0:  DATA 43,61
00BE2:  DATA 72,64
00BE4:  DATA 20,61
00BE6:  DATA 63,74
00BE8:  DATA 69,76
00BEA:  DATA 61,74
00BEC:  DATA 65,20
00BEE:  DATA 73,75
00BF0:  DATA 63,63
00BF2:  DATA 65,73
00BF4:  DATA 73,20
00BF6:  DATA 6F,6E
00BF8:  DATA 20,61
00BFA:  DATA 74,74
00BFC:  DATA 65,6D
00BFE:  DATA 70,74
00C00:  DATA 20,25
00C02:  DATA 6C,75
00C04:  DATA 0D,0A
00C06:  DATA 00,00
00C08:  DATA 46,41
00C0A:  DATA 54,20
00C0C:  DATA 61,74
00C0E:  DATA 20,73
00C10:  DATA 65,63
00C12:  DATA 74,6F
00C14:  DATA 72,20
00C16:  DATA 30,0D
00C18:  DATA 0A,00
00C1A:  DATA 54,59
00C1C:  DATA 50,45
00C1E:  DATA 20,63
00C20:  DATA 6F,6D
00C22:  DATA 6D,61
00C24:  DATA 6E,64
00C26:  DATA 20,45
00C28:  DATA 52,52
00C2A:  DATA 4F,52
00C2C:  DATA 0D,0A
00C2E:  DATA 00,00
00C30:  DATA 40,46
00C32:  DATA 53,3A
00C34:  DATA 20,25
00C36:  DATA 73,0D
00C38:  DATA 0A,00
00C3A:  DATA 40,46
00C3C:  DATA 53,3A
00C3E:  DATA 20,25
00C40:  DATA 73,0D
00C42:  DATA 0A,00
00C44:  DATA 2A,2A
00C46:  DATA 20,40
00C48:  DATA 46,53
00C4A:  DATA 3A,20
00C4C:  DATA 45,52
00C4E:  DATA 52,4F
00C50:  DATA 52,0D
00C52:  DATA 0A,00
00C54:  DATA 20,20
00C56:  DATA 20,4E
00C58:  DATA 6F,45
00C5A:  DATA 72,72
00C5C:  DATA 6F,72
00C5E:  DATA 0D,0A
00C60:  DATA 00,00
00C62:  DATA 20,20
00C64:  DATA 20,4D
00C66:  DATA 65,64
00C68:  DATA 69,61
00C6A:  DATA 20,4E
00C6C:  DATA 6F,74
00C6E:  DATA 20,52
00C70:  DATA 65,61
00C72:  DATA 64,79
00C74:  DATA 0D,0A
00C76:  DATA 00,00
00C78:  DATA 20,20
00C7A:  DATA 20,46
00C7C:  DATA 69,6C
00C7E:  DATA 65,20
00C80:  DATA 4E,6F
00C82:  DATA 74,20
00C84:  DATA 46,6F
00C86:  DATA 75,6E
00C88:  DATA 64,0D
00C8A:  DATA 0A,00
00C8C:  DATA 20,20
00C8E:  DATA 20,49
00C90:  DATA 6E,76
00C92:  DATA 61,6C
00C94:  DATA 69,64
00C96:  DATA 20,50
00C98:  DATA 61,74
00C9A:  DATA 68,0D
00C9C:  DATA 0A,00
00C9E:  DATA 20,20
00CA0:  DATA 20,49
00CA2:  DATA 6E,76
00CA4:  DATA 61,6C
00CA6:  DATA 69,64
00CA8:  DATA 20,4E
00CAA:  DATA 61,6D
00CAC:  DATA 65,0D
00CAE:  DATA 0A,00
00CB0:  DATA 20,20
00CB2:  DATA 20,41
00CB4:  DATA 63,63
00CB6:  DATA 65,73
00CB8:  DATA 73,20
00CBA:  DATA 44,65
00CBC:  DATA 6E,69
00CBE:  DATA 65,64
00CC0:  DATA 0D,0A
00CC2:  DATA 00,00
00CC4:  DATA 20,20
00CC6:  DATA 20,44
00CC8:  DATA 69,73
00CCA:  DATA 6B,20
00CCC:  DATA 46,75
00CCE:  DATA 6C,6C
00CD0:  DATA 0D,0A
00CD2:  DATA 00,00
00CD4:  DATA 20,20
00CD6:  DATA 20,52
00CD8:  DATA 65,61
00CDA:  DATA 64,2F
00CDC:  DATA 57,72
00CDE:  DATA 69,74
00CE0:  DATA 65,20
00CE2:  DATA 45,72
00CE4:  DATA 72,6F
00CE6:  DATA 72,0D
00CE8:  DATA 0A,00
00CEA:  DATA 20,20
00CEC:  DATA 20,49
00CEE:  DATA 6E,63
00CF0:  DATA 6F,72
00CF2:  DATA 72,65
00CF4:  DATA 63,74
00CF6:  DATA 20,4D
00CF8:  DATA 65,64
00CFA:  DATA 69,61
00CFC:  DATA 20,43
00CFE:  DATA 68,61
00D00:  DATA 6E,67
00D02:  DATA 65,0D
00D04:  DATA 0A,00
00D06:  DATA 20,20
00D08:  DATA 20,57
00D0A:  DATA 72,69
00D0C:  DATA 74,65
00D0E:  DATA 20,50
00D10:  DATA 72,6F
00D12:  DATA 74,65
00D14:  DATA 63,74
00D16:  DATA 65,64
00D18:  DATA 0D,0A
00D1A:  DATA 00,00
00D1C:  DATA 20,20
00D1E:  DATA 20,4E
00D20:  DATA 6F,74
00D22:  DATA 20,45
00D24:  DATA 6E,61
00D26:  DATA 62,6C
00D28:  DATA 65,64
00D2A:  DATA 0D,0A
00D2C:  DATA 00,00
00D2E:  DATA 20,20
00D30:  DATA 20,4E
00D32:  DATA 6F,20
00D34:  DATA 46,69
00D36:  DATA 6C,65
00D38:  DATA 20,53
00D3A:  DATA 79,73
00D3C:  DATA 74,65
00D3E:  DATA 6D,0D
00D40:  DATA 0A,00
00D42:  DATA 61,70
00D44:  DATA 70,65
00D46:  DATA 6E,64
00D48:  DATA 3A,20
00D4A:  DATA 46,53
00D4C:  DATA 20,45
00D4E:  DATA 52,52
00D50:  DATA 4F,52
00D52:  DATA 20,6F
00D54:  DATA 6E,20
00D56:  DATA 66,69
00D58:  DATA 6C,65
00D5A:  DATA 5F,6F
00D5C:  DATA 70,65
00D5E:  DATA 6E,0D
00D60:  DATA 0A,00
00D62:  DATA 40,46
00D64:  DATA 53,3A
00D66:  DATA 57,72
00D68:  DATA 69,74
00D6A:  DATA 69,6E
00D6C:  DATA 67,0D
00D6E:  DATA 0A,5B
00D70:  DATA 25,73
00D72:  DATA 5D,0D
00D74:  DATA 0A,00
00D76:  DATA 40,46
00D78:  DATA 53,3A
00D7A:  DATA 45,52
00D7C:  DATA 52,4F
00D7E:  DATA 52,5B
00D80:  DATA 61,70
00D82:  DATA 70,65
00D84:  DATA 6E,64
00D86:  DATA 5D,0D
00D88:  DATA 0A,00
00D8A:  DATA 40,46
00D8C:  DATA 53,3A
00D8E:  DATA 43,6C
00D90:  DATA 6F,73
00D92:  DATA 69,6E
00D94:  DATA 67,0D
00D96:  DATA 0A,00
00D98:  DATA 40,52
00D9A:  DATA 54,43
00D9C:  DATA 3A,25
00D9E:  DATA 30,32
00DA0:  DATA 75,2F
00DA2:  DATA 00,00
00DA4:  DATA 40,52
00DA6:  DATA 54,43
00DA8:  DATA 3A,25
00DAA:  DATA 30,32
00DAC:  DATA 75,2F
00DAE:  DATA 00,00
00DB0:  DATA 40,41
00DB2:  DATA 4C,4D
00DB4:  DATA 3A,25
00DB6:  DATA 30,32
00DB8:  DATA 75,2F
00DBA:  DATA 00,00
00DBC:  DATA 40,41
00DBE:  DATA 4C,4D
00DC0:  DATA 3A,25
00DC2:  DATA 30,32
00DC4:  DATA 75,2F
00DC6:  DATA 00,00
00DC8:  DATA 20,20
00DCA:  DATA 20,20
00DCC:  DATA 20,20
00DCE:  DATA 20,20
00DD0:  DATA 20,20
00DD2:  DATA 20,20
00DD4:  DATA 20,20
00DD6:  DATA 20,20
00DD8:  DATA 20,20
00DDA:  DATA 20,20
00DDC:  DATA 20,20
00DDE:  DATA 20,20
00DE0:  DATA 20,20
00DE2:  DATA 20,20
00DE4:  DATA 20,20
00DE6:  DATA 20,20
00DE8:  DATA 20,20
00DEA:  DATA 20,20
00DEC:  DATA 20,20
00DEE:  DATA 20,00
00DF0:  DATA 40,41
00DF2:  DATA 4C,4D
00DF4:  DATA 0D,0A
00DF6:  DATA 00,00
*
00E6E:  TBLRD*+
00E70:  MOVF   FF5,F
00E72:  BZ    0E96
00E74:  MOVFF  FF6,A38
00E78:  MOVFF  FF7,A39
00E7C:  MOVFF  FF8,A3A
00E80:  MOVF   FF5,W
00E82:  BTFSS  F9E.4
00E84:  BRA    0E82
00E86:  MOVWF  FAD
00E88:  MOVFF  A38,FF6
00E8C:  MOVFF  A39,FF7
00E90:  MOVFF  A3A,FF8
00E94:  BRA    0E6E
00E96:  RETURN 0
*
00EF8:  DATA 3F,40
00EFA:  DATA 42,53
00EFC:  DATA 59,0D
00EFE:  DATA 0A,00
00F00:  DATA 40,52
00F02:  DATA 44,59
00F04:  DATA 0D,0A
00F06:  DATA 00,00
*
00F48:  DATA 40,5B
00F4A:  DATA 4F,5D
00F4C:  DATA 0D,0A
00F4E:  DATA 00,00
00F50:  DATA 40,43
00F52:  DATA 4D,44
00F54:  DATA 20,74
00F56:  DATA 6F,6F
00F58:  DATA 20,6C
00F5A:  DATA 6F,6E
00F5C:  DATA 67,0D
00F5E:  DATA 0A,00
00F60:  DATA 40,5B
00F62:  DATA 43,5D
00F64:  DATA 0D,0A
00F66:  DATA 00,00
00F68:  DATA 40,53
00F6A:  DATA 4C,45
00F6C:  DATA 45,50
00F6E:  DATA 0D,0A
00F70:  DATA 00,00
00F72:  DATA 40,4D
00F74:  DATA 45,52
00F76:  DATA 2C,25
00F78:  DATA 4C,75
00F7A:  DATA 2C,25
00F7C:  DATA 4C,75
00F7E:  DATA 0D,0A
00F80:  DATA 00,00
00F82:  DATA 6D,3A
00F84:  DATA 25,75
00F86:  DATA 2C,25
00F88:  DATA 75,20
00F8A:  DATA 63,3A
00F8C:  DATA 25,4C
00F8E:  DATA 75,2C
00F90:  DATA 25,4C
00F92:  DATA 75,2C
00F94:  DATA 25,4C
00F96:  DATA 75,0D
00F98:  DATA 0A,00
00F9A:  MOVLB  A
00F9C:  MOVF   x43,W
00F9E:  CLRF   01
00FA0:  SUBWF  x42,W
00FA2:  BC    0FAA
00FA4:  MOVFF  A42,00
00FA8:  BRA    0FC2
00FAA:  CLRF   00
00FAC:  MOVLW  08
00FAE:  MOVWF  x44
00FB0:  RLCF   x42,F
00FB2:  RLCF   00,F
00FB4:  MOVF   x43,W
00FB6:  SUBWF  00,W
00FB8:  BTFSC  FD8.0
00FBA:  MOVWF  00
00FBC:  RLCF   01,F
00FBE:  DECFSZ x44,F
00FC0:  BRA    0FB0
00FC2:  MOVLB  0
00FC4:  RETURN 0
00FC6:  MOVF   01,W
00FC8:  MOVFF  A40,A42
00FCC:  MOVLW  64
00FCE:  MOVLB  A
00FD0:  MOVWF  x43
00FD2:  MOVLB  0
00FD4:  RCALL  0F9A
00FD6:  MOVFF  00,A40
00FDA:  MOVF   01,W
00FDC:  MOVLW  30
00FDE:  BNZ   0FF0
00FE0:  MOVLB  A
00FE2:  BTFSS  x41.1
00FE4:  BRA    1002
00FE6:  BTFSC  x41.3
00FE8:  BRA    1002
00FEA:  BTFSC  x41.4
00FEC:  MOVLW  20
00FEE:  BRA    0FF8
00FF0:  MOVLB  A
00FF2:  BCF    x41.3
00FF4:  BCF    x41.4
00FF6:  BSF    x41.0
00FF8:  ADDWF  01,F
00FFA:  MOVF   01,W
00FFC:  BTFSS  F9E.4
00FFE:  BRA    0FFC
01000:  MOVWF  FAD
01002:  MOVFF  A40,A42
01006:  MOVLW  0A
01008:  MOVWF  x43
0100A:  MOVLB  0
0100C:  RCALL  0F9A
0100E:  MOVFF  00,A40
01012:  MOVF   01,W
01014:  MOVLW  30
01016:  BNZ   1028
01018:  MOVLB  A
0101A:  BTFSC  x41.3
0101C:  BRA    1034
0101E:  BTFSS  x41.0
01020:  BRA    1034
01022:  BTFSC  x41.4
01024:  MOVLW  20
01026:  MOVLB  0
01028:  ADDWF  01,F
0102A:  MOVF   01,W
0102C:  BTFSS  F9E.4
0102E:  BRA    102C
01030:  MOVWF  FAD
01032:  MOVLB  A
01034:  MOVLW  30
01036:  ADDWF  x40,F
01038:  MOVF   x40,W
0103A:  BTFSS  F9E.4
0103C:  BRA    103A
0103E:  MOVWF  FAD
01040:  MOVLB  0
01042:  RETURN 0
01044:  TBLRD*+
01046:  MOVFF  FF6,A41
0104A:  MOVFF  FF7,A42
0104E:  MOVFF  FF8,A43
01052:  MOVF   FF5,W
01054:  BTFSS  F9E.4
01056:  BRA    1054
01058:  MOVWF  FAD
0105A:  MOVFF  A41,FF6
0105E:  MOVFF  A42,FF7
01062:  MOVFF  A43,FF8
01066:  MOVLB  A
01068:  DECFSZ x40,F
0106A:  BRA    106E
0106C:  BRA    1072
0106E:  MOVLB  0
01070:  BRA    1044
01072:  MOVLB  0
01074:  RETURN 0
01076:  BTFSC  FD8.1
01078:  BRA    1082
0107A:  MOVLW  0A
0107C:  MOVWF  FEA
0107E:  MOVLW  54
01080:  MOVWF  FE9
01082:  CLRF   00
01084:  CLRF   01
01086:  CLRF   02
01088:  CLRF   03
0108A:  MOVLB  A
0108C:  CLRF   x54
0108E:  CLRF   x55
01090:  CLRF   x56
01092:  CLRF   x57
01094:  MOVF   x53,W
01096:  IORWF  x52,W
01098:  IORWF  x51,W
0109A:  IORWF  x50,W
0109C:  BZ    10F6
0109E:  MOVLW  20
010A0:  MOVWF  x58
010A2:  BCF    FD8.0
010A4:  RLCF   x4C,F
010A6:  RLCF   x4D,F
010A8:  RLCF   x4E,F
010AA:  RLCF   x4F,F
010AC:  RLCF   x54,F
010AE:  RLCF   x55,F
010B0:  RLCF   x56,F
010B2:  RLCF   x57,F
010B4:  MOVF   x53,W
010B6:  SUBWF  x57,W
010B8:  BNZ   10CA
010BA:  MOVF   x52,W
010BC:  SUBWF  x56,W
010BE:  BNZ   10CA
010C0:  MOVF   x51,W
010C2:  SUBWF  x55,W
010C4:  BNZ   10CA
010C6:  MOVF   x50,W
010C8:  SUBWF  x54,W
010CA:  BNC   10EA
010CC:  MOVF   x50,W
010CE:  SUBWF  x54,F
010D0:  MOVF   x51,W
010D2:  BTFSS  FD8.0
010D4:  INCFSZ x51,W
010D6:  SUBWF  x55,F
010D8:  MOVF   x52,W
010DA:  BTFSS  FD8.0
010DC:  INCFSZ x52,W
010DE:  SUBWF  x56,F
010E0:  MOVF   x53,W
010E2:  BTFSS  FD8.0
010E4:  INCFSZ x53,W
010E6:  SUBWF  x57,F
010E8:  BSF    FD8.0
010EA:  RLCF   00,F
010EC:  RLCF   01,F
010EE:  RLCF   02,F
010F0:  RLCF   03,F
010F2:  DECFSZ x58,F
010F4:  BRA    10A2
010F6:  MOVFF  A54,FEF
010FA:  MOVFF  A55,FEC
010FE:  MOVFF  A56,FEC
01102:  MOVFF  A57,FEC
01106:  MOVLB  0
01108:  RETURN 0
0110A:  MOVF   FE9,W
0110C:  MOVLB  A
0110E:  MOVWF  x44
01110:  MOVLW  3B
01112:  MOVWF  x4B
01114:  MOVLW  9A
01116:  MOVWF  x4A
01118:  MOVLW  CA
0111A:  MOVWF  x49
0111C:  CLRF   x48
0111E:  MOVLW  0A
01120:  MOVWF  x46
01122:  BSF    FD8.1
01124:  MOVLW  0A
01126:  MOVWF  FEA
01128:  MOVLW  40
0112A:  MOVWF  FE9
0112C:  MOVFF  A43,A4F
01130:  MOVFF  A42,A4E
01134:  MOVFF  A41,A4D
01138:  MOVFF  A40,A4C
0113C:  MOVFF  A4B,A53
01140:  MOVFF  A4A,A52
01144:  MOVFF  A49,A51
01148:  MOVFF  A48,A50
0114C:  MOVLB  0
0114E:  RCALL  1076
01150:  MOVF   01,W
01152:  MOVF   00,F
01154:  BNZ   117C
01156:  MOVLB  A
01158:  MOVF   x46,W
0115A:  XORLW  01
0115C:  BTFSS  FD8.2
0115E:  BRA    1164
01160:  MOVLB  0
01162:  BRA    117C
01164:  MOVF   x44,W
01166:  BZ    1180
01168:  ANDLW  0F
0116A:  SUBWF  x46,W
0116C:  BZ    1170
0116E:  BC    118C
01170:  BTFSC  x44.7
01172:  BRA    118C
01174:  BTFSC  x44.6
01176:  BRA    1180
01178:  MOVLW  20
0117A:  BRA    1182
0117C:  MOVLB  A
0117E:  CLRF   x44
01180:  MOVLW  30
01182:  ADDWF  00,F
01184:  MOVF   00,W
01186:  BTFSS  F9E.4
01188:  BRA    1186
0118A:  MOVWF  FAD
0118C:  BCF    FD8.1
0118E:  MOVFF  A4B,A4F
01192:  MOVFF  A4A,A4E
01196:  MOVFF  A49,A4D
0119A:  MOVFF  A48,A4C
0119E:  CLRF   x53
011A0:  CLRF   x52
011A2:  CLRF   x51
011A4:  MOVLW  0A
011A6:  MOVWF  x50
011A8:  MOVLB  0
011AA:  RCALL  1076
011AC:  MOVFF  03,A4B
011B0:  MOVFF  02,A4A
011B4:  MOVFF  01,A49
011B8:  MOVFF  00,A48
011BC:  MOVLB  A
011BE:  DECFSZ x46,F
011C0:  BRA    1122
011C2:  MOVLB  0
011C4:  RETURN 0
011C6:  MOVFF  FEA,A48
011CA:  MOVFF  FE9,A47
011CE:  MOVLB  A
011D0:  SWAPF  x41,W
011D2:  IORLW  F0
011D4:  MOVWF  x43
011D6:  ADDWF  x43,F
011D8:  ADDLW  E2
011DA:  MOVWF  x44
011DC:  ADDLW  32
011DE:  MOVWF  x46
011E0:  MOVF   x41,W
011E2:  ANDLW  0F
011E4:  ADDWF  x44,F
011E6:  ADDWF  x44,F
011E8:  ADDWF  x46,F
011EA:  ADDLW  E9
011EC:  MOVWF  x45
011EE:  ADDWF  x45,F
011F0:  ADDWF  x45,F
011F2:  SWAPF  x40,W
011F4:  ANDLW  0F
011F6:  ADDWF  x45,F
011F8:  ADDWF  x46,F
011FA:  RLCF   x45,F
011FC:  RLCF   x46,F
011FE:  COMF   x46,F
01200:  RLCF   x46,F
01202:  MOVF   x40,W
01204:  ANDLW  0F
01206:  ADDWF  x46,F
01208:  RLCF   x43,F
0120A:  MOVLW  07
0120C:  MOVWF  x42
0120E:  MOVLW  0A
01210:  DECF   x45,F
01212:  ADDWF  x46,F
01214:  BNC   1210
01216:  DECF   x44,F
01218:  ADDWF  x45,F
0121A:  BNC   1216
0121C:  DECF   x43,F
0121E:  ADDWF  x44,F
01220:  BNC   121C
01222:  DECF   x42,F
01224:  ADDWF  x43,F
01226:  BNC   1222
01228:  MOVLW  0A
0122A:  MOVWF  FEA
0122C:  MOVLW  42
0122E:  MOVWF  FE9
01230:  MOVLW  07
01232:  ANDWF  x47,W
01234:  BCF    x47.6
01236:  ADDWF  FE9,F
01238:  MOVLW  00
0123A:  ADDWFC FEA,F
0123C:  MOVF   FE9,W
0123E:  SUBLW  46
01240:  BNZ   124A
01242:  MOVF   FEA,W
01244:  SUBLW  0A
01246:  BNZ   124A
01248:  BSF    x47.6
0124A:  MOVF   FEF,W
0124C:  MOVWF  00
0124E:  BNZ   1260
01250:  BTFSC  x47.6
01252:  BRA    1260
01254:  BTFSC  x47.4
01256:  BRA    1270
01258:  BTFSC  x47.3
0125A:  BRA    1260
0125C:  MOVLW  20
0125E:  BRA    1266
01260:  BSF    x47.3
01262:  BCF    x47.4
01264:  MOVLW  30
01266:  ADDWF  00,F
01268:  MOVF   00,W
0126A:  BTFSS  F9E.4
0126C:  BRA    126A
0126E:  MOVWF  FAD
01270:  MOVF   FEE,W
01272:  BTFSS  x47.6
01274:  BRA    123C
01276:  MOVLB  0
01278:  RETURN 0
*
01A7E:  DATA 40,4C
01A80:  DATA 50,43
01A82:  DATA 2C,25
01A84:  DATA 4C,75
01A86:  DATA 2C,25
01A88:  DATA 4C,64
01A8A:  DATA 0D,0A
01A8C:  DATA 00,00
01A8E:  DATA 40,4D
01A90:  DATA 4D,45
01A92:  DATA 2C,25
01A94:  DATA 75,2C
01A96:  DATA 25,4C
01A98:  DATA 64,2C
01A9A:  DATA 25,4C
01A9C:  DATA 75,2C
01A9E:  DATA 25,4C
01AA0:  DATA 75,2C
01AA2:  DATA 25,4C
01AA4:  DATA 64,2C
01AA6:  DATA 25,4C
01AA8:  DATA 64,0D
01AAA:  DATA 0A,00
01AAC:  DATA 56,41
01AAE:  DATA 4C,56
01AB0:  DATA 45,20
01AB2:  DATA 53,54
01AB4:  DATA 4F,50
01AB6:  DATA 20,25
01AB8:  DATA 4C,75
01ABA:  DATA 2C,25
01ABC:  DATA 4C,75
01ABE:  DATA 0D,0A
01AC0:  DATA 00,00
01AC2:  DATA 69,6E
01AC4:  DATA 64,3A
01AC6:  DATA 25,75
01AC8:  DATA 20,2F
01ACA:  DATA 20,70
01ACC:  DATA 68,61
01ACE:  DATA 3A,25
01AD0:  DATA 75,0D
01AD2:  DATA 0A,00
01AD4:  DATA 40,52
01AD6:  DATA 45,43
01AD8:  DATA 20,2D
01ADA:  DATA 20,68
01ADC:  DATA 6F,6D
01ADE:  DATA 69,6E
01AE0:  DATA 67,20
01AE2:  DATA 73,79
01AE4:  DATA 72,69
01AE6:  DATA 6E,67
01AE8:  DATA 65,20
01AEA:  DATA 61,6E
01AEC:  DATA 64,20
01AEE:  DATA 61,6C
01AF0:  DATA 69,67
01AF2:  DATA 6E,69
01AF4:  DATA 6E,67
01AF6:  DATA 20,76
01AF8:  DATA 61,6C
01AFA:  DATA 76,65
01AFC:  DATA 20,74
01AFE:  DATA 6F,20
01B00:  DATA 70,6F
01B02:  DATA 72,74
01B04:  DATA 20,31
01B06:  DATA 0D,0A
01B08:  DATA 00,00
01B0A:  DATA 2C,73
01B0C:  DATA 65,72
01B0E:  DATA 69,61
01B10:  DATA 6C,20
01B12:  DATA 77,61
01B14:  DATA 6B,65
01B16:  DATA 2D,75
01B18:  DATA 70,2C
01B1A:  DATA 53,44
01B1C:  DATA 20,69
01B1E:  DATA 6E,69
01B20:  DATA 74,69
01B22:  DATA 61,6C
01B24:  DATA 69,7A
01B26:  DATA 65,64
01B28:  DATA 0D,0A
01B2A:  DATA 00,00
01B2C:  DATA 40,52
01B2E:  DATA 53,54
01B30:  DATA 0D,0A
01B32:  DATA 00,00
01B34:  DATA 40,57
01B36:  DATA 44,54
01B38:  DATA 0D,0A
01B3A:  DATA 00,00
01B3C:  DATA 2C,72
01B3E:  DATA 65,73
01B40:  DATA 74,61
01B42:  DATA 72,74
01B44:  DATA 20,63
01B46:  DATA 61,75
01B48:  DATA 73,65
01B4A:  DATA 2C,57
01B4C:  DATA 44,20
01B4E:  DATA 74,69
01B50:  DATA 6D,65
01B52:  DATA 2D,6F
01B54:  DATA 75,74
01B56:  DATA 0D,0A
01B58:  DATA 00,00
01B5A:  DATA 40,57
01B5C:  DATA 44,53
01B5E:  DATA 0D,0A
01B60:  DATA 00,00
01B62:  DATA 2C,72
01B64:  DATA 65,73
01B66:  DATA 74,61
01B68:  DATA 72,74
01B6A:  DATA 20,63
01B6C:  DATA 61,75
01B6E:  DATA 73,65
01B70:  DATA 2C,57
01B72:  DATA 44,20
01B74:  DATA 66,72
01B76:  DATA 6F,6D
01B78:  DATA 20,73
01B7A:  DATA 6C,65
01B7C:  DATA 65,70
01B7E:  DATA 0D,0A
01B80:  DATA 00,00
01B82:  DATA 40,4E
01B84:  DATA 50,55
01B86:  DATA 0D,0A
01B88:  DATA 00,00
01B8A:  DATA 2C,69
01B8C:  DATA 64,23
01B8E:  DATA 5B,25
01B90:  DATA 4C,75
01B92:  DATA 5D,2C
01B94:  DATA 70,6F
01B96:  DATA 77,65
01B98:  DATA 72,20
01B9A:  DATA 61,70
01B9C:  DATA 70,6C
01B9E:  DATA 69,65
01BA0:  DATA 64,2C
01BA2:  DATA 53,44
01BA4:  DATA 20,69
01BA6:  DATA 6E,69
01BA8:  DATA 74,69
01BAA:  DATA 61,6C
01BAC:  DATA 69,7A
01BAE:  DATA 65,64
01BB0:  DATA 0D,0A
01BB2:  DATA 00,00
01BB4:  DATA 40,52
01BB6:  DATA 53,54
01BB8:  DATA 0D,0A
01BBA:  DATA 00,00
01BBC:  DATA 2C,72
01BBE:  DATA 65,73
01BC0:  DATA 74,61
01BC2:  DATA 72,74
01BC4:  DATA 20,63
01BC6:  DATA 61,75
01BC8:  DATA 73,65
01BCA:  DATA 2C,72
01BCC:  DATA 65,73
01BCE:  DATA 65,74
01BD0:  DATA 20,69
01BD2:  DATA 6E,73
01BD4:  DATA 74,72
01BD6:  DATA 75,63
01BD8:  DATA 74,69
01BDA:  DATA 6F,6E
01BDC:  DATA 0D,0A
01BDE:  DATA 00,00
01BE0:  DATA 40,42
01BE2:  DATA 4F,52
01BE4:  DATA 0D,0A
01BE6:  DATA 00,00
01BE8:  DATA 2C,72
01BEA:  DATA 65,73
01BEC:  DATA 74,61
01BEE:  DATA 72,74
01BF0:  DATA 20,63
01BF2:  DATA 61,75
01BF4:  DATA 73,65
01BF6:  DATA 2C,62
01BF8:  DATA 72,6F
01BFA:  DATA 77,6E
01BFC:  DATA 2D,6F
01BFE:  DATA 75,74
01C00:  DATA 0D,0A
01C02:  DATA 00,00
01C04:  DATA 40,4D
01C06:  DATA 52,53
01C08:  DATA 0D,0A
01C0A:  DATA 00,00
01C0C:  DATA 2C,72
01C0E:  DATA 65,73
01C10:  DATA 74,61
01C12:  DATA 72,74
01C14:  DATA 20,63
01C16:  DATA 61,75
01C18:  DATA 73,65
01C1A:  DATA 2C,4D
01C1C:  DATA 43,4C
01C1E:  DATA 52,20
01C20:  DATA 66,72
01C22:  DATA 6F,6D
01C24:  DATA 20,73
01C26:  DATA 6C,65
01C28:  DATA 65,70
01C2A:  DATA 0D,0A
01C2C:  DATA 00,00
01C2E:  DATA 40,4D
01C30:  DATA 52,52
01C32:  DATA 0D,0A
01C34:  DATA 00,00
01C36:  DATA 2C,72
01C38:  DATA 65,73
01C3A:  DATA 74,61
01C3C:  DATA 72,74
01C3E:  DATA 20,63
01C40:  DATA 61,75
01C42:  DATA 73,65
01C44:  DATA 2C,4D
01C46:  DATA 43,4C
01C48:  DATA 52,20
01C4A:  DATA 77,68
01C4C:  DATA 65,6E
01C4E:  DATA 20,72
01C50:  DATA 75,6E
01C52:  DATA 6E,69
01C54:  DATA 6E,67
01C56:  DATA 0D,0A
01C58:  DATA 00,00
01C5A:  DATA 4E,4F
01C5C:  DATA 33,00
01C5E:  DATA 4E,4F
01C60:  DATA 32,00
01C62:  DATA 50,4F
01C64:  DATA 34,00
01C66:  DATA 4E,48
01C68:  DATA 34,00
01C6A:  DATA 53,69
01C6C:  DATA 4F,00
01C6E:  DATA 00,00
01C70:  DATA 40,44
01C72:  DATA 45,54
01C74:  DATA 5B,2F
01C76:  DATA 25,75
01C78:  DATA 5D,5B
01C7A:  DATA 25,63
01C7C:  DATA 5D,41
01C7E:  DATA 52,47
01C80:  DATA 5B,25
01C82:  DATA 4C,75
01C84:  DATA 5D,0D
01C86:  DATA 0A,00
01C88:  DATA 20,74
01C8A:  DATA 69,6D
01C8C:  DATA 65,2D
01C8E:  DATA 6F,75
01C90:  DATA 74,00
01C92:  DATA 20,64
01C94:  DATA 61,74
01C96:  DATA 61,20
01C98:  DATA 74,6F
01C9A:  DATA 6F,20
01C9C:  DATA 73,68
01C9E:  DATA 6F,72
01CA0:  DATA 74,00
01CA2:  DATA 20,64
01CA4:  DATA 61,74
01CA6:  DATA 61,20
01CA8:  DATA 74,6F
01CAA:  DATA 6F,20
01CAC:  DATA 6C,6F
01CAE:  DATA 6E,67
01CB0:  DATA 00,00
01CB2:  DATA 2C,64
01CB4:  DATA 65,74
01CB6:  DATA 65,63
01CB8:  DATA 74,6F
01CBA:  DATA 72,5B
01CBC:  DATA 25,73
01CBE:  DATA 5D,2C
01CC0:  DATA 6C,65
01CC2:  DATA 6E,5B
01CC4:  DATA 25,75
01CC6:  DATA 5D,00
01CC8:  DATA 40,52
01CCA:  DATA 54,59
01CCC:  DATA 2C,25
01CCE:  DATA 75,0D
01CD0:  DATA 0A,00
01CD2:  DATA 2C,73
01CD4:  DATA 74,61
01CD6:  DATA 72,74
01CD8:  DATA 20,68
01CDA:  DATA 65,61
01CDC:  DATA 74,69
01CDE:  DATA 6E,67
01CE0:  DATA 2C,74
01CE2:  DATA 61,72
01CE4:  DATA 67,65
01CE6:  DATA 74,5B
01CE8:  DATA 25,4C
01CEA:  DATA 75,5D
01CEC:  DATA 2C,61
01CEE:  DATA 63,74
01CF0:  DATA 75,61
01CF2:  DATA 6C,5B
01CF4:  DATA 25,4C
01CF6:  DATA 75,5D
01CF8:  DATA 2C,72
01CFA:  DATA 65,61
01CFC:  DATA 64,69
01CFE:  DATA 6E,67
01D00:  DATA 73,5B
01D02:  DATA 25,4C
01D04:  DATA 75,5D
01D06:  DATA 0D,0A
01D08:  DATA 00,00
01D0A:  DATA 2C,65
01D0C:  DATA 6E,64
01D0E:  DATA 20,68
01D10:  DATA 65,61
01D12:  DATA 74,69
01D14:  DATA 6E,67
01D16:  DATA 2C,74
01D18:  DATA 61,72
01D1A:  DATA 67,65
01D1C:  DATA 74,5B
01D1E:  DATA 25,4C
01D20:  DATA 75,5D
01D22:  DATA 2C,61
01D24:  DATA 63,74
01D26:  DATA 75,61
01D28:  DATA 6C,5B
01D2A:  DATA 25,4C
01D2C:  DATA 75,5D
01D2E:  DATA 2C,72
01D30:  DATA 65,61
01D32:  DATA 64,69
01D34:  DATA 6E,67
01D36:  DATA 73,5B
01D38:  DATA 25,4C
01D3A:  DATA 75,5D
01D3C:  DATA 0D,0A
01D3E:  DATA 00,00
01D40:  DATA 4E,4F
01D42:  DATA 33,00
01D44:  DATA 4E,4F
01D46:  DATA 32,00
01D48:  DATA 50,4F
01D4A:  DATA 34,00
01D4C:  DATA 4E,48
01D4E:  DATA 34,00
01D50:  DATA 53,69
01D52:  DATA 4F,00
01D54:  DATA 00,00
01D56:  DATA 40,44
01D58:  DATA 41,43
01D5A:  DATA 2C,25
01D5C:  DATA 4C,75
01D5E:  DATA 2C,25
01D60:  DATA 4C,75
01D62:  DATA 2C,00
01D64:  DATA 40,53
01D66:  DATA 41,52
01D68:  DATA 2C,31
01D6A:  DATA 2C,25
01D6C:  DATA 4C,75
01D6E:  DATA 2C,00
01D70:  DATA 40,56
01D72:  DATA 41,4C
01D74:  DATA 20,00
01D76:  DATA 40,56
01D78:  DATA 41,4C
01D7A:  DATA 20,00
01D7C:  DATA 40,56
01D7E:  DATA 41,4C
01D80:  DATA 20,00
01D82:  DATA 40,56
01D84:  DATA 41,4C
01D86:  DATA 20,00
01D88:  DATA 40,53
01D8A:  DATA 4F,4C
01D8C:  DATA 5B,2F
01D8E:  DATA 31,5D
01D90:  DATA 5B,73
01D92:  DATA 5D,5B
01D94:  DATA 25,4C
01D96:  DATA 75,5D
01D98:  DATA 0D,0A
01D9A:  DATA 00,00
01D9C:  DATA 2F,31
01D9E:  DATA 73,25
01DA0:  DATA 4C,75
01DA2:  DATA 0D,00
01DA4:  DATA 40,53
01DA6:  DATA 4F,4C
01DA8:  DATA 5B,2F
01DAA:  DATA 31,5D
01DAC:  DATA 5B,63
01DAE:  DATA 5D,5B
01DB0:  DATA 25,75
01DB2:  DATA 5D,0D
01DB4:  DATA 0A,00
01DB6:  DATA 2F,31
01DB8:  DATA 63,25
01DBA:  DATA 75,0D
01DBC:  DATA 00,00
01DBE:  DATA 2F,31
01DC0:  DATA 73,32
01DC2:  DATA 35,36
01DC4:  DATA 0D,00
01DC6:  DATA 28,49
01DC8:  DATA 30,73
01DCA:  DATA 29,2C
01DCC:  DATA 25,4C
01DCE:  DATA 75,2C
01DD0:  DATA 28,49
01DD2:  DATA 31,73
01DD4:  DATA 29,2C
01DD6:  DATA 25,4C
01DD8:  DATA 75,2C
01DDA:  DATA 28,41
01DDC:  DATA 62,73
01DDE:  DATA 2D,73
01DE0:  DATA 29,2C
01DE2:  DATA 25,31
01DE4:  DATA 2E,34
01DE6:  DATA 67,2C
01DE8:  DATA 28,49
01DEA:  DATA 30,74
01DEC:  DATA 29,2C
01DEE:  DATA 25,4C
01DF0:  DATA 75,2C
01DF2:  DATA 28,49
01DF4:  DATA 31,74
01DF6:  DATA 29,2C
01DF8:  DATA 25,4C
01DFA:  DATA 75,2C
01DFC:  DATA 28,41
01DFE:  DATA 62,73
01E00:  DATA 2D,74
01E02:  DATA 29,2C
01E04:  DATA 25,31
01E06:  DATA 2E,34
01E08:  DATA 67,2C
01E0A:  DATA 28,49
01E0C:  DATA 30,72
01E0E:  DATA 29,2C
01E10:  DATA 25,4C
01E12:  DATA 75,2C
01E14:  DATA 28,49
01E16:  DATA 31,72
01E18:  DATA 29,2C
01E1A:  DATA 25,4C
01E1C:  DATA 75,2C
01E1E:  DATA 28,41
01E20:  DATA 62,73
01E22:  DATA 2D,72
01E24:  DATA 29,2C
01E26:  DATA 25,31
01E28:  DATA 2E,34
01E2A:  DATA 67,00
01E2C:  DATA 40,41
01E2E:  DATA 62,73
01E30:  DATA 2C,4E
01E32:  DATA 4F,33
01E34:  DATA 2C,25
01E36:  DATA 73,0D
01E38:  DATA 0A,00
01E3A:  DATA 28,49
01E3C:  DATA 30,73
01E3E:  DATA 29,2C
01E40:  DATA 25,4C
01E42:  DATA 75,2C
01E44:  DATA 28,49
01E46:  DATA 31,73
01E48:  DATA 29,2C
01E4A:  DATA 25,4C
01E4C:  DATA 75,2C
01E4E:  DATA 28,41
01E50:  DATA 62,73
01E52:  DATA 2D,73
01E54:  DATA 29,2C
01E56:  DATA 25,31
01E58:  DATA 2E,34
01E5A:  DATA 67,2C
01E5C:  DATA 28,49
01E5E:  DATA 30,74
01E60:  DATA 29,2C
01E62:  DATA 25,4C
01E64:  DATA 75,2C
01E66:  DATA 28,49
01E68:  DATA 31,74
01E6A:  DATA 29,2C
01E6C:  DATA 25,4C
01E6E:  DATA 75,2C
01E70:  DATA 28,41
01E72:  DATA 62,73
01E74:  DATA 2D,74
01E76:  DATA 29,2C
01E78:  DATA 25,31
01E7A:  DATA 2E,34
01E7C:  DATA 67,2C
01E7E:  DATA 28,49
01E80:  DATA 30,72
01E82:  DATA 29,2C
01E84:  DATA 25,4C
01E86:  DATA 75,2C
01E88:  DATA 28,49
01E8A:  DATA 31,72
01E8C:  DATA 29,2C
01E8E:  DATA 25,4C
01E90:  DATA 75,2C
01E92:  DATA 28,41
01E94:  DATA 62,73
01E96:  DATA 2D,72
01E98:  DATA 29,2C
01E9A:  DATA 25,31
01E9C:  DATA 2E,34
01E9E:  DATA 67,00
01EA0:  DATA 40,41
01EA2:  DATA 62,73
01EA4:  DATA 2C,4E
01EA6:  DATA 4F,32
01EA8:  DATA 2C,25
01EAA:  DATA 73,0D
01EAC:  DATA 0A,00
01EAE:  DATA 28,49
01EB0:  DATA 30,73
01EB2:  DATA 29,2C
01EB4:  DATA 25,4C
01EB6:  DATA 75,2C
01EB8:  DATA 28,49
01EBA:  DATA 31,73
01EBC:  DATA 29,2C
01EBE:  DATA 25,4C
01EC0:  DATA 75,2C
01EC2:  DATA 28,41
01EC4:  DATA 62,73
01EC6:  DATA 2D,73
01EC8:  DATA 29,2C
01ECA:  DATA 25,31
01ECC:  DATA 2E,34
01ECE:  DATA 67,2C
01ED0:  DATA 28,49
01ED2:  DATA 30,74
01ED4:  DATA 29,2C
01ED6:  DATA 25,4C
01ED8:  DATA 75,2C
01EDA:  DATA 28,49
01EDC:  DATA 31,74
01EDE:  DATA 29,2C
01EE0:  DATA 25,4C
01EE2:  DATA 75,2C
01EE4:  DATA 28,41
01EE6:  DATA 62,73
01EE8:  DATA 2D,74
01EEA:  DATA 29,2C
01EEC:  DATA 25,31
01EEE:  DATA 2E,34
01EF0:  DATA 67,2C
01EF2:  DATA 28,49
01EF4:  DATA 30,72
01EF6:  DATA 29,2C
01EF8:  DATA 25,4C
01EFA:  DATA 75,2C
01EFC:  DATA 28,49
01EFE:  DATA 31,72
01F00:  DATA 29,2C
01F02:  DATA 25,4C
01F04:  DATA 75,2C
01F06:  DATA 28,41
01F08:  DATA 62,73
01F0A:  DATA 2D,72
01F0C:  DATA 29,2C
01F0E:  DATA 25,31
01F10:  DATA 2E,34
01F12:  DATA 67,00
01F14:  DATA 40,41
01F16:  DATA 62,73
01F18:  DATA 2C,50
01F1A:  DATA 4F,34
01F1C:  DATA 2C,25
01F1E:  DATA 73,0D
01F20:  DATA 0A,00
01F22:  DATA 28,49
01F24:  DATA 30,73
01F26:  DATA 29,2C
01F28:  DATA 25,4C
01F2A:  DATA 75,2C
01F2C:  DATA 28,49
01F2E:  DATA 31,73
01F30:  DATA 29,2C
01F32:  DATA 25,4C
01F34:  DATA 75,2C
01F36:  DATA 28,41
01F38:  DATA 62,73
01F3A:  DATA 2D,73
01F3C:  DATA 29,2C
01F3E:  DATA 25,31
01F40:  DATA 2E,34
01F42:  DATA 67,2C
01F44:  DATA 28,49
01F46:  DATA 30,74
01F48:  DATA 29,2C
01F4A:  DATA 25,4C
01F4C:  DATA 75,2C
01F4E:  DATA 28,49
01F50:  DATA 31,74
01F52:  DATA 29,2C
01F54:  DATA 25,4C
01F56:  DATA 75,2C
01F58:  DATA 28,41
01F5A:  DATA 62,73
01F5C:  DATA 2D,74
01F5E:  DATA 29,2C
01F60:  DATA 25,31
01F62:  DATA 2E,34
01F64:  DATA 67,2C
01F66:  DATA 28,49
01F68:  DATA 30,72
01F6A:  DATA 29,2C
01F6C:  DATA 25,4C
01F6E:  DATA 75,2C
01F70:  DATA 28,49
01F72:  DATA 31,72
01F74:  DATA 29,2C
01F76:  DATA 25,4C
01F78:  DATA 75,2C
01F7A:  DATA 28,41
01F7C:  DATA 62,73
01F7E:  DATA 2D,72
01F80:  DATA 29,2C
01F82:  DATA 25,31
01F84:  DATA 2E,34
01F86:  DATA 67,00
01F88:  DATA 40,41
01F8A:  DATA 62,73
01F8C:  DATA 2C,4E
01F8E:  DATA 48,34
01F90:  DATA 2C,25
01F92:  DATA 73,0D
01F94:  DATA 0A,00
01F96:  DATA 28,49
01F98:  DATA 30,73
01F9A:  DATA 29,2C
01F9C:  DATA 25,4C
01F9E:  DATA 75,2C
01FA0:  DATA 28,49
01FA2:  DATA 31,73
01FA4:  DATA 29,2C
01FA6:  DATA 25,4C
01FA8:  DATA 75,2C
01FAA:  DATA 28,41
01FAC:  DATA 62,73
01FAE:  DATA 2D,73
01FB0:  DATA 29,2C
01FB2:  DATA 25,31
01FB4:  DATA 2E,34
01FB6:  DATA 67,2C
01FB8:  DATA 28,49
01FBA:  DATA 30,74
01FBC:  DATA 29,2C
01FBE:  DATA 25,4C
01FC0:  DATA 75,2C
01FC2:  DATA 28,49
01FC4:  DATA 31,74
01FC6:  DATA 29,2C
01FC8:  DATA 25,4C
01FCA:  DATA 75,2C
01FCC:  DATA 28,41
01FCE:  DATA 62,73
01FD0:  DATA 2D,74
01FD2:  DATA 29,2C
01FD4:  DATA 25,31
01FD6:  DATA 2E,34
01FD8:  DATA 67,2C
01FDA:  DATA 28,49
01FDC:  DATA 30,72
01FDE:  DATA 29,2C
01FE0:  DATA 25,4C
01FE2:  DATA 75,2C
01FE4:  DATA 28,49
01FE6:  DATA 31,72
01FE8:  DATA 29,2C
01FEA:  DATA 25,4C
01FEC:  DATA 75,2C
01FEE:  DATA 28,41
01FF0:  DATA 62,73
01FF2:  DATA 2D,72
01FF4:  DATA 29,2C
01FF6:  DATA 25,31
01FF8:  DATA 2E,34
01FFA:  DATA 67,00
01FFC:  DATA 40,41
01FFE:  DATA 42,53
02000:  DATA 2C,53
02002:  DATA 69,4F
02004:  DATA 2C,25
02006:  DATA 73,0D
02008:  DATA 0A,00
0200A:  DATA 4E,4F
0200C:  DATA 33,00
0200E:  DATA 4E,4F
02010:  DATA 32,00
02012:  DATA 50,4F
02014:  DATA 34,00
02016:  DATA 4E,48
02018:  DATA 34,00
0201A:  DATA 53,69
0201C:  DATA 4F,00
0201E:  DATA 00,00
02020:  DATA 28,6D
02022:  DATA 29,2C
02024:  DATA 25,33
02026:  DATA 2E,33
02028:  DATA 67,2C
0202A:  DATA 28,63
0202C:  DATA 29,2C
0202E:  DATA 25,33
02030:  DATA 2E,33
02032:  DATA 67,00
02034:  DATA 28,43
02036:  DATA 73,29
02038:  DATA 2C,25
0203A:  DATA 33,2E
0203C:  DATA 33,67
0203E:  DATA 0D,0A
02040:  DATA 00,00
02042:  DATA 40,43
02044:  DATA 4F,4E
02046:  DATA 2C,4E
02048:  DATA 4F,33
0204A:  DATA 2C,25
0204C:  DATA 73,0D
0204E:  DATA 0A,00
02050:  DATA 28,6D
02052:  DATA 29,2C
02054:  DATA 25,33
02056:  DATA 2E,33
02058:  DATA 67,2C
0205A:  DATA 28,63
0205C:  DATA 29,2C
0205E:  DATA 25,33
02060:  DATA 2E,33
02062:  DATA 67,00
02064:  DATA 28,43
02066:  DATA 73,29
02068:  DATA 2C,25
0206A:  DATA 33,2E
0206C:  DATA 33,67
0206E:  DATA 0D,0A
02070:  DATA 00,00
02072:  DATA 40,43
02074:  DATA 4F,4E
02076:  DATA 2C,50
02078:  DATA 4F,34
0207A:  DATA 2C,25
0207C:  DATA 73,0D
0207E:  DATA 0A,00
02080:  DATA 28,6D
02082:  DATA 29,2C
02084:  DATA 25,33
02086:  DATA 2E,33
02088:  DATA 67,2C
0208A:  DATA 28,63
0208C:  DATA 29,2C
0208E:  DATA 25,33
02090:  DATA 2E,33
02092:  DATA 67,00
02094:  DATA 28,43
02096:  DATA 73,29
02098:  DATA 2C,25
0209A:  DATA 33,2E
0209C:  DATA 33,67
0209E:  DATA 0D,0A
020A0:  DATA 00,00
020A2:  DATA 40,43
020A4:  DATA 4F,4E
020A6:  DATA 2C,4E
020A8:  DATA 48,34
020AA:  DATA 2C,25
020AC:  DATA 73,0D
020AE:  DATA 0A,00
020B0:  DATA 28,6D
020B2:  DATA 29,2C
020B4:  DATA 25,33
020B6:  DATA 2E,33
020B8:  DATA 67,2C
020BA:  DATA 28,63
020BC:  DATA 29,2C
020BE:  DATA 25,33
020C0:  DATA 2E,33
020C2:  DATA 67,00
020C4:  DATA 28,43
020C6:  DATA 73,29
020C8:  DATA 2C,25
020CA:  DATA 33,2E
020CC:  DATA 33,67
020CE:  DATA 0D,0A
020D0:  DATA 00,00
020D2:  DATA 40,43
020D4:  DATA 4F,4E
020D6:  DATA 2C,53
020D8:  DATA 69,4F
020DA:  DATA 2C,25
020DC:  DATA 73,0D
020DE:  DATA 0A,00
020E0:  DATA 4E,4F
020E2:  DATA 33,00
020E4:  DATA 50,4F
020E6:  DATA 34,00
020E8:  DATA 4E,48
020EA:  DATA 34,00
020EC:  DATA 53,69
020EE:  DATA 4F,00
020F0:  DATA 00,00
020F2:  DATA 4D,45
020F4:  DATA 4D,4F
020F6:  DATA 52,59
020F8:  DATA 20,4F
020FA:  DATA 56,45
020FC:  DATA 52,46
020FE:  DATA 4C,4F
02100:  DATA 57,20
02102:  DATA 45,52
02104:  DATA 52,4F
02106:  DATA 52,20
02108:  DATA 40,20
0210A:  DATA 4C,69
0210C:  DATA 6E,65
0210E:  DATA 20,3A
02110:  DATA 25,4C
02112:  DATA 75,0A
02114:  DATA 0D,00
02116:  DATA 0D,0A
02118:  DATA 3A,00
0211A:  DATA 0D,0A
0211C:  DATA 57,41
0211E:  DATA 52,4E
02120:  DATA 49,4E
02122:  DATA 47,3A
02124:  DATA 20,49
02126:  DATA 4E,56
02128:  DATA 41,4C
0212A:  DATA 49,44
0212C:  DATA 20,43
0212E:  DATA 4F,4D
02130:  DATA 4D,41
02132:  DATA 4E,44
02134:  DATA 20,49
02136:  DATA 4E,20
02138:  DATA 4D,41
0213A:  DATA 43,52
0213C:  DATA 4F,21
0213E:  DATA 0D,0A
02140:  DATA 00,00
02142:  DATA 42,61
02144:  DATA 64,20
02146:  DATA 63,6F
02148:  DATA 6D,6D
0214A:  DATA 61,6E
0214C:  DATA 64,20
0214E:  DATA 61,74
02150:  DATA 20,6C
02152:  DATA 69,6E
02154:  DATA 65,3A
02156:  DATA 20,25
02158:  DATA 4C,64
0215A:  DATA 20,0D
0215C:  DATA 0A,00
0215E:  DATA 50,6C
02160:  DATA 65,61
02162:  DATA 73,65
02164:  DATA 20,72
02166:  DATA 65,2D
02168:  DATA 75,70
0216A:  DATA 6C,6F
0216C:  DATA 61,64
0216E:  DATA 20,6D
02170:  DATA 61,63
02172:  DATA 72,6F
02174:  DATA 00,00
02176:  DATA 49,74
02178:  DATA 65,72
0217A:  DATA 61,74
0217C:  DATA 69,6F
0217E:  DATA 6E,73
02180:  DATA 20,6C
02182:  DATA 65,66
02184:  DATA 74,3A
02186:  DATA 20,25
02188:  DATA 4C,75
0218A:  DATA 0D,0A
0218C:  DATA 00,00
0218E:  DATA 2C,6D
02190:  DATA 61,63
02192:  DATA 72,6F
02194:  DATA 5B,25
02196:  DATA 75,5D
02198:  DATA 2C,73
0219A:  DATA 74,61
0219C:  DATA 72,74
0219E:  DATA 0D,0A
021A0:  DATA 00,00
021A2:  DATA 40,4D
021A4:  DATA 43,4C
021A6:  DATA 5B,25
021A8:  DATA 63,5D
021AA:  DATA 5B,25
021AC:  DATA 4C,75
021AE:  DATA 5D,0D
021B0:  DATA 0A,00
021B2:  DATA 40,4C
021B4:  DATA 4E,45
021B6:  DATA 0D,0A
021B8:  DATA 00,00
021BA:  DATA 40,52
021BC:  DATA 55,4E
021BE:  DATA 0D,0A
021C0:  DATA 00,00
021C2:  DATA 40,42
021C4:  DATA 41,44
021C6:  DATA 0D,0A
021C8:  DATA 00,00
021CA:  DATA 40,54
021CC:  DATA 2F,4F
021CE:  DATA 0D,0A
021D0:  DATA 00,00
021D2:  DATA 40,45
021D4:  DATA 52,52
021D6:  DATA 0D,0A
021D8:  DATA 00,00
021DA:  DATA 40,45
021DC:  DATA 4E,44
021DE:  DATA 0D,0A
021E0:  DATA 00,00
021E2:  DATA 40,48
021E4:  DATA 4C,54
021E6:  DATA 0D,0A
021E8:  DATA 00,00
021EA:  DATA 2C,6D
021EC:  DATA 61,63
021EE:  DATA 72,6F
021F0:  DATA 5B,25
021F2:  DATA 75,5D
021F4:  DATA 2C,73
021F6:  DATA 74,61
021F8:  DATA 74,75
021FA:  DATA 73,5B
021FC:  DATA 25,63
021FE:  DATA 5D,2C
02200:  DATA 6C,69
02202:  DATA 6E,65
02204:  DATA 5B,25
02206:  DATA 4C,75
02208:  DATA 5D,0D
0220A:  DATA 0A,00
0220C:  DATA 40,52
0220E:  DATA 75,6E
02210:  DATA 6E,69
02212:  DATA 6E,67
02214:  DATA 20,25
02216:  DATA 63,25
02218:  DATA 4C,75
0221A:  DATA 20,0D
0221C:  DATA 0A,00
0221E:  DATA 40,4D
02220:  DATA 61,63
02222:  DATA 72,6F
02224:  DATA 20,25
02226:  DATA 30,34
02228:  DATA 4C,75
0222A:  DATA 20,6F
0222C:  DATA 66,20
0222E:  DATA 25,30
02230:  DATA 34,4C
02232:  DATA 75,0D
02234:  DATA 0A,00
02236:  DATA 40,4C
02238:  DATA 4E,45
0223A:  DATA 0D,0A
0223C:  DATA 00,00
0223E:  DATA 40,52
02240:  DATA 55,4E
02242:  DATA 0D,0A
02244:  DATA 00,00
02246:  DATA 40,42
02248:  DATA 41,44
0224A:  DATA 0D,0A
0224C:  DATA 00,00
0224E:  DATA 40,54
02250:  DATA 2F,4F
02252:  DATA 0D,0A
02254:  DATA 00,00
02256:  DATA 40,45
02258:  DATA 52,52
0225A:  DATA 0D,0A
0225C:  DATA 00,00
0225E:  DATA 40,45
02260:  DATA 4E,44
02262:  DATA 0D,0A
02264:  DATA 00,00
02266:  DATA 2C,61
02268:  DATA 75,74
0226A:  DATA 6F,2D
0226C:  DATA 73,61
0226E:  DATA 6D,70
02270:  DATA 6C,65
02272:  DATA 2C,73
02274:  DATA 61,6D
02276:  DATA 70,6C
02278:  DATA 65,5B
0227A:  DATA 25,4C
0227C:  DATA 75,5D
0227E:  DATA 2C,73
02280:  DATA 74,61
02282:  DATA 72,74
02284:  DATA 0D,0A
02286:  DATA 00,00
02288:  DATA 2C,61
0228A:  DATA 75,74
0228C:  DATA 6F,2D
0228E:  DATA 73,61
02290:  DATA 6D,70
02292:  DATA 6C,65
02294:  DATA 2C,73
02296:  DATA 61,6D
02298:  DATA 70,6C
0229A:  DATA 65,5B
0229C:  DATA 25,4C
0229E:  DATA 75,5D
022A0:  DATA 2C,63
022A2:  DATA 6F,6D
022A4:  DATA 70,6C
022A6:  DATA 65,74
022A8:  DATA 65,0D
022AA:  DATA 0A,00
022AC:  DATA 2C,61
022AE:  DATA 75,74
022B0:  DATA 6F,2D
022B2:  DATA 73,61
022B4:  DATA 6D,70
022B6:  DATA 6C,65
022B8:  DATA 2C,73
022BA:  DATA 61,6D
022BC:  DATA 70,6C
022BE:  DATA 65,5B
022C0:  DATA 25,4C
022C2:  DATA 75,5D
022C4:  DATA 2C,65
022C6:  DATA 72,72
022C8:  DATA 6F,72
022CA:  DATA 0D,0A
022CC:  DATA 00,00
022CE:  DATA 2C,61
022D0:  DATA 75,74
022D2:  DATA 6F,2D
022D4:  DATA 73,61
022D6:  DATA 6D,70
022D8:  DATA 6C,65
022DA:  DATA 2C,73
022DC:  DATA 61,6D
022DE:  DATA 70,6C
022E0:  DATA 65,5B
022E2:  DATA 25,4C
022E4:  DATA 75,5D
022E6:  DATA 2C,6D
022E8:  DATA 61,78
022EA:  DATA 20,73
022EC:  DATA 61,6D
022EE:  DATA 70,6C
022F0:  DATA 65,73
022F2:  DATA 0D,0A
022F4:  DATA 00,00
022F6:  DATA 2C,61
022F8:  DATA 75,74
022FA:  DATA 6F,2D
022FC:  DATA 73,61
022FE:  DATA 6D,70
02300:  DATA 6C,65
02302:  DATA 2C,73
02304:  DATA 61,6D
02306:  DATA 70,6C
02308:  DATA 65,5B
0230A:  DATA 25,4C
0230C:  DATA 75,5D
0230E:  DATA 2C,73
02310:  DATA 74,61
02312:  DATA 72,74
02314:  DATA 0D,0A
02316:  DATA 00,00
02318:  DATA 2C,61
0231A:  DATA 75,74
0231C:  DATA 6F,2D
0231E:  DATA 73,61
02320:  DATA 6D,70
02322:  DATA 6C,65
02324:  DATA 2C,73
02326:  DATA 61,6D
02328:  DATA 70,6C
0232A:  DATA 65,5B
0232C:  DATA 25,4C
0232E:  DATA 75,5D
02330:  DATA 2C,63
02332:  DATA 6F,6D
02334:  DATA 70,6C
02336:  DATA 65,74
02338:  DATA 65,0D
0233A:  DATA 0A,00
0233C:  DATA 2C,61
0233E:  DATA 75,74
02340:  DATA 6F,2D
02342:  DATA 73,61
02344:  DATA 6D,70
02346:  DATA 6C,65
02348:  DATA 2C,73
0234A:  DATA 61,6D
0234C:  DATA 70,6C
0234E:  DATA 65,5B
02350:  DATA 25,4C
02352:  DATA 75,5D
02354:  DATA 2C,73
02356:  DATA 74,61
02358:  DATA 72,74
0235A:  DATA 0D,0A
0235C:  DATA 00,00
0235E:  DATA 2C,61
02360:  DATA 75,74
02362:  DATA 6F,2D
02364:  DATA 73,61
02366:  DATA 6D,70
02368:  DATA 6C,65
0236A:  DATA 2C,73
0236C:  DATA 61,6D
0236E:  DATA 70,6C
02370:  DATA 65,5B
02372:  DATA 25,4C
02374:  DATA 75,5D
02376:  DATA 2C,63
02378:  DATA 6F,6D
0237A:  DATA 70,6C
0237C:  DATA 65,74
0237E:  DATA 65,0D
02380:  DATA 0A,00
02382:  DATA 2C,61
02384:  DATA 75,74
02386:  DATA 6F,2D
02388:  DATA 73,61
0238A:  DATA 6D,70
0238C:  DATA 6C,65
0238E:  DATA 2C,73
02390:  DATA 61,6D
02392:  DATA 70,6C
02394:  DATA 65,5B
02396:  DATA 25,4C
02398:  DATA 75,5D
0239A:  DATA 2C,6D
0239C:  DATA 61,78
0239E:  DATA 20,73
023A0:  DATA 61,6D
023A2:  DATA 70,6C
023A4:  DATA 65,73
023A6:  DATA 0D,0A
023A8:  DATA 00,00
023AA:  DATA 2C,61
023AC:  DATA 75,74
023AE:  DATA 6F,2D
023B0:  DATA 73,61
023B2:  DATA 6D,70
023B4:  DATA 6C,65
023B6:  DATA 2C,69
023B8:  DATA 6E,69
023BA:  DATA 74,69
023BC:  DATA 61,6C
023BE:  DATA 69,7A
023C0:  DATA 65,0D
023C2:  DATA 0A,00
023C4:  DATA 2C,68
023C6:  DATA 65,61
023C8:  DATA 64,65
023CA:  DATA 72,2C
023CC:  DATA 69,64
023CE:  DATA 23,5B
023D0:  DATA 25,4C
023D2:  DATA 75,5D
023D4:  DATA 2C,69
023D6:  DATA 6E,74
023D8:  DATA 5B,25
023DA:  DATA 4C,75
023DC:  DATA 5D,2C
023DE:  DATA 6D,61
023E0:  DATA 78,5B
023E2:  DATA 25,4C
023E4:  DATA 75,5D
023E6:  DATA 0D,0A
023E8:  DATA 00,00
023EA:  DATA 2C,61
023EC:  DATA 75,74
023EE:  DATA 6F,2D
023F0:  DATA 73,61
023F2:  DATA 6D,70
023F4:  DATA 6C,65
023F6:  DATA 2C,73
023F8:  DATA 61,6D
023FA:  DATA 70,6C
023FC:  DATA 65,5B
023FE:  DATA 25,4C
02400:  DATA 75,5D
02402:  DATA 2C,61
02404:  DATA 6C,61
02406:  DATA 72,6D
02408:  DATA 5B,25
0240A:  DATA 75,5D
0240C:  DATA 0D,0A
0240E:  DATA 00,00
02410:  DATA 2C,61
02412:  DATA 75,74
02414:  DATA 6F,2D
02416:  DATA 73,61
02418:  DATA 6D,70
0241A:  DATA 6C,65
0241C:  DATA 2C,73
0241E:  DATA 6C,65
02420:  DATA 65,70
02422:  DATA 0D,0A
02424:  DATA 00,00
02426:  DATA 74,31
02428:  DATA 3A,25
0242A:  DATA 4C,75
0242C:  DATA 20,74
0242E:  DATA 32,3A
02430:  DATA 25,4C
02432:  DATA 75,0D
02434:  DATA 0A,00
02436:  DATA 40,44
02438:  DATA 45,54
0243A:  DATA 2C,25
0243C:  DATA 4C,75
0243E:  DATA 0D,0A
02440:  DATA 00,00
02442:  DATA 4E,4F
02444:  DATA 33,2C
02446:  DATA 25,31
02448:  DATA 2E,35
0244A:  DATA 67,2C
0244C:  DATA 25,31
0244E:  DATA 2E,35
02450:  DATA 67,0D
02452:  DATA 0A,00
02454:  DATA 50,4F
02456:  DATA 34,2C
02458:  DATA 25,31
0245A:  DATA 2E,35
0245C:  DATA 67,2C
0245E:  DATA 25,31
02460:  DATA 2E,35
02462:  DATA 67,0D
02464:  DATA 0A,00
02466:  DATA 4E,48
02468:  DATA 34,2C
0246A:  DATA 25,31
0246C:  DATA 2E,35
0246E:  DATA 67,2C
02470:  DATA 25,31
02472:  DATA 2E,35
02474:  DATA 67,0D
02476:  DATA 0A,00
02478:  DATA 53,69
0247A:  DATA 4F,34
0247C:  DATA 2C,25
0247E:  DATA 31,2E
02480:  DATA 35,67
02482:  DATA 2C,25
02484:  DATA 31,2E
02486:  DATA 35,67
02488:  DATA 0D,0A
0248A:  DATA 00,00
0248C:  DATA 4E,4F
0248E:  DATA 33,28
02490:  DATA 6D,29
02492:  DATA 3A,00
02494:  DATA 4E,4F
02496:  DATA 33,28
02498:  DATA 63,29
0249A:  DATA 3A,00
0249C:  DATA 50,4F
0249E:  DATA 34,28
024A0:  DATA 6D,29
024A2:  DATA 3A,00
024A4:  DATA 50,4F
024A6:  DATA 34,28
024A8:  DATA 63,29
024AA:  DATA 3A,00
024AC:  DATA 4E,48
024AE:  DATA 34,28
024B0:  DATA 6D,29
024B2:  DATA 3A,00
024B4:  DATA 4E,48
024B6:  DATA 34,28
024B8:  DATA 63,29
024BA:  DATA 3A,00
024BC:  DATA 53,69
024BE:  DATA 4F,34
024C0:  DATA 28,6D
024C2:  DATA 29,3A
024C4:  DATA 00,00
024C6:  DATA 53,69
024C8:  DATA 4F,34
024CA:  DATA 28,63
024CC:  DATA 29,3A
024CE:  DATA 00,00
024D0:  DATA 41,72
024D2:  DATA 65,20
024D4:  DATA 79,6F
024D6:  DATA 75,20
024D8:  DATA 73,75
024DA:  DATA 72,65
024DC:  DATA 20,79
024DE:  DATA 6F,75
024E0:  DATA 20,77
024E2:  DATA 61,6E
024E4:  DATA 74,20
024E6:  DATA 74,6F
024E8:  DATA 20,65
024EA:  DATA 72,61
024EC:  DATA 73,65
024EE:  DATA 20,74
024F0:  DATA 68,65
024F2:  DATA 20,72
024F4:  DATA 61,77
024F6:  DATA 20,64
024F8:  DATA 61,74
024FA:  DATA 61,20
024FC:  DATA 66,69
024FE:  DATA 6C,65
02500:  DATA 3F,20
02502:  DATA 59,20
02504:  DATA 6F,72
02506:  DATA 20,4E
02508:  DATA 21,0D
0250A:  DATA 0A,00
0250C:  DATA 46,69
0250E:  DATA 6C,65
02510:  DATA 20,64
02512:  DATA 65,6C
02514:  DATA 65,74
02516:  DATA 65,64
02518:  DATA 21,0A
0251A:  DATA 0D,00
0251C:  DATA 4F,70
0251E:  DATA 65,72
02520:  DATA 61,74
02522:  DATA 69,6F
02524:  DATA 6E,20
02526:  DATA 63,61
02528:  DATA 6E,63
0252A:  DATA 65,6C
0252C:  DATA 65,64
0252E:  DATA 21,0D
02530:  DATA 0A,00
02532:  DATA 41,72
02534:  DATA 65,20
02536:  DATA 79,6F
02538:  DATA 75,20
0253A:  DATA 73,75
0253C:  DATA 72,65
0253E:  DATA 20,79
02540:  DATA 6F,75
02542:  DATA 20,77
02544:  DATA 61,6E
02546:  DATA 74,20
02548:  DATA 74,6F
0254A:  DATA 20,65
0254C:  DATA 72,61
0254E:  DATA 73,65
02550:  DATA 20,74
02552:  DATA 68,65
02554:  DATA 20,63
02556:  DATA 61,6C
02558:  DATA 63,75
0255A:  DATA 6C,61
0255C:  DATA 74,65
0255E:  DATA 64,20
02560:  DATA 64,61
02562:  DATA 74,61
02564:  DATA 20,66
02566:  DATA 69,6C
02568:  DATA 65,3F
0256A:  DATA 20,59
0256C:  DATA 20,6F
0256E:  DATA 72,20
02570:  DATA 4E,21
02572:  DATA 0D,0A
02574:  DATA 00,00
02576:  DATA 46,69
02578:  DATA 6C,65
0257A:  DATA 20,64
0257C:  DATA 65,6C
0257E:  DATA 65,74
02580:  DATA 65,64
02582:  DATA 21,0A
02584:  DATA 0D,00
02586:  DATA 4F,70
02588:  DATA 65,72
0258A:  DATA 61,74
0258C:  DATA 69,6F
0258E:  DATA 6E,20
02590:  DATA 63,61
02592:  DATA 6E,63
02594:  DATA 65,6C
02596:  DATA 65,64
02598:  DATA 21,0D
0259A:  DATA 0A,00
0259C:  DATA 40,49
0259E:  DATA 44,23
025A0:  DATA 25,4C
025A2:  DATA 75,20
025A4:  DATA 49,25
025A6:  DATA 4C,75
025A8:  DATA 20,4E
025AA:  DATA 25,4C
025AC:  DATA 75,2F
025AE:  DATA 25,4C
025B0:  DATA 75,20
025B2:  DATA 58,25
025B4:  DATA 4C,75
025B6:  DATA 20,55
025B8:  DATA 25,75
025BA:  DATA 20,25
025BC:  DATA 34,2E
025BE:  DATA 32,77
025C0:  DATA 56,0D
025C2:  DATA 0A,00
025C4:  DATA 40,4D
025C6:  DATA 4F,54
025C8:  DATA 3A,56
025CA:  DATA 41,4C
025CC:  DATA 3D,25
025CE:  DATA 4C,75
025D0:  DATA 20,53
025D2:  DATA 59,52
025D4:  DATA 3D,25
025D6:  DATA 4C,64
025D8:  DATA 0D,0A
025DA:  DATA 00,00
025DC:  DATA 40,50
025DE:  DATA 57,52
025E0:  DATA 3A,25
025E2:  DATA 30,32
025E4:  DATA 75,2F
025E6:  DATA 25,30
025E8:  DATA 32,75
025EA:  DATA 2F,25
025EC:  DATA 30,32
025EE:  DATA 75,20
025F0:  DATA 25,30
025F2:  DATA 32,75
025F4:  DATA 3A,25
025F6:  DATA 30,32
025F8:  DATA 75,3A
025FA:  DATA 25,30
025FC:  DATA 32,75
025FE:  DATA 0D,0A
02600:  DATA 00,00
02602:  DATA 40,50
02604:  DATA 57,52
02606:  DATA 3A,25
02608:  DATA 30,32
0260A:  DATA 75,2F
0260C:  DATA 25,30
0260E:  DATA 32,75
02610:  DATA 2F,25
02612:  DATA 30,32
02614:  DATA 75,20
02616:  DATA 25,30
02618:  DATA 32,75
0261A:  DATA 3A,25
0261C:  DATA 30,32
0261E:  DATA 75,3A
02620:  DATA 25,30
02622:  DATA 32,75
02624:  DATA 0D,0A
02626:  DATA 00,00
02628:  DATA 41,25
0262A:  DATA 4C,75
0262C:  DATA 20,49
0262E:  DATA 25,4C
02630:  DATA 75,20
02632:  DATA 4C,25
02634:  DATA 4C,75
02636:  DATA 20,51
02638:  DATA 25,4C
0263A:  DATA 75,20
0263C:  DATA 53,25
0263E:  DATA 4C,75
02640:  DATA 20,25
02642:  DATA 34,2E
02644:  DATA 32,77
02646:  DATA 56,0D
02648:  DATA 0A,00
0264A:  DATA 40,4D
0264C:  DATA 4F,54
0264E:  DATA 3A,56
02650:  DATA 41,4C
02652:  DATA 3D,25
02654:  DATA 4C,75
02656:  DATA 20,53
02658:  DATA 59,52
0265A:  DATA 3D,25
0265C:  DATA 4C,64
0265E:  DATA 0D,0A
02660:  DATA 00,00
02662:  DATA 40,50
02664:  DATA 57,52
02666:  DATA 3A,25
02668:  DATA 30,32
0266A:  DATA 75,2F
0266C:  DATA 25,30
0266E:  DATA 32,75
02670:  DATA 2F,25
02672:  DATA 30,32
02674:  DATA 75,20
02676:  DATA 25,30
02678:  DATA 32,75
0267A:  DATA 3A,25
0267C:  DATA 30,32
0267E:  DATA 75,3A
02680:  DATA 25,30
02682:  DATA 32,75
02684:  DATA 0D,0A
02686:  DATA 00,00
02688:  DATA 49,25
0268A:  DATA 4C,75
0268C:  DATA 20,4E
0268E:  DATA 25,4C
02690:  DATA 75,2F
02692:  DATA 25,4C
02694:  DATA 75,20
02696:  DATA 50,25
02698:  DATA 4C,75
0269A:  DATA 20,25
0269C:  DATA 34,2E
0269E:  DATA 32,77
026A0:  DATA 56,0D
026A2:  DATA 0A,00
026A4:  DATA 40,4D
026A6:  DATA 4F,54
026A8:  DATA 3A,53
026AA:  DATA 59,52
026AC:  DATA 3D,25
026AE:  DATA 4C,64
026B0:  DATA 0D,0A
026B2:  DATA 00,00
026B4:  DATA 40,50
026B6:  DATA 57,52
026B8:  DATA 3A,25
026BA:  DATA 30,32
026BC:  DATA 75,2F
026BE:  DATA 25,30
026C0:  DATA 32,75
026C2:  DATA 2F,25
026C4:  DATA 30,32
026C6:  DATA 75,20
026C8:  DATA 25,30
026CA:  DATA 32,75
026CC:  DATA 3A,25
026CE:  DATA 30,32
026D0:  DATA 75,3A
026D2:  DATA 25,30
026D4:  DATA 32,75
026D6:  DATA 0D,0A
026D8:  DATA 00,00
026DA:  DATA 40,53
026DC:  DATA 4D,50
026DE:  DATA 20,25
026E0:  DATA 30,34
026E2:  DATA 4C,75
026E4:  DATA 0D,0A
026E6:  DATA 00,00
026E8:  DATA 40,53
026EA:  DATA 4D,50
026EC:  DATA 20,25
026EE:  DATA 30,34
026F0:  DATA 4C,75
026F2:  DATA 0D,0A
026F4:  DATA 00,00
026F6:  DATA 45,6E
026F8:  DATA 74,65
026FA:  DATA 72,20
026FC:  DATA 64,61
026FE:  DATA 74,65
02700:  DATA 20,66
02702:  DATA 6F,72
02704:  DATA 6D,61
02706:  DATA 74,20
02708:  DATA 30,3D
0270A:  DATA 4D,4D
0270C:  DATA 2F,44
0270E:  DATA 44,2F
02710:  DATA 59,59
02712:  DATA 20,20
02714:  DATA 31,3D
02716:  DATA 44,44
02718:  DATA 2F,4D
0271A:  DATA 4D,2F
0271C:  DATA 59,59
0271E:  DATA 0D,0A
02720:  DATA 00,00
02722:  DATA 40,4F
02724:  DATA 4B,21
02726:  DATA 0D,0A
02728:  DATA 20,00
0272A:  DATA 40,45
0272C:  DATA 52,52
0272E:  DATA 0D,0A
02730:  DATA 00,00
02732:  DATA 40,52
02734:  DATA 55,4E
02736:  DATA 0D,0A
02738:  DATA 00,00
0273A:  DATA 5B,6D
0273C:  DATA 6F,74
0273E:  DATA 6F,72
02740:  DATA 3A,31
02742:  DATA 5D,0D
02744:  DATA 0A,00
02746:  DATA 5B,6D
02748:  DATA 6F,74
0274A:  DATA 6F,72
0274C:  DATA 3A,32
0274E:  DATA 5D,0D
02750:  DATA 0A,00
02752:  DATA 2C,45
02754:  DATA 43,4F
02756:  DATA 20,6D
02758:  DATA 6F,64
0275A:  DATA 65,20
0275C:  DATA 73,65
0275E:  DATA 74,0D
02760:  DATA 0A,00
02762:  DATA 2C,57
02764:  DATA 4D,53
02766:  DATA 2D,34
02768:  DATA 2D,53
0276A:  DATA 44,20
0276C:  DATA 6D,6F
0276E:  DATA 64,65
02770:  DATA 20,73
02772:  DATA 65,74
02774:  DATA 0D,0A
02776:  DATA 00,00
02778:  DATA 2C,41
0277A:  DATA 57,53
0277C:  DATA 20,6D
0277E:  DATA 6F,64
02780:  DATA 65,20
02782:  DATA 73,65
02784:  DATA 74,0D
02786:  DATA 0A,00
02788:  DATA 2C,57
0278A:  DATA 4D,53
0278C:  DATA 2D,34
0278E:  DATA 2D,51
02790:  DATA 45,20
02792:  DATA 6D,6F
02794:  DATA 64,65
02796:  DATA 20,73
02798:  DATA 65,74
0279A:  DATA 0D,0A
0279C:  DATA 00,00
0279E:  DATA 30,37
027A0:  DATA 2D,4A
027A2:  DATA 75,6C
027A4:  DATA 2D,31
027A6:  DATA 37,00
027A8:  DATA 31,35
027AA:  DATA 3A,32
027AC:  DATA 33,3A
027AE:  DATA 30,33
027B0:  DATA 00,00
027B2:  DATA 53,45
027B4:  DATA 4E,44
027B6:  DATA 20,48
027B8:  DATA 45,58
027BA:  DATA 20,46
027BC:  DATA 49,4C
027BE:  DATA 45,20
027C0:  DATA 28,31
027C2:  DATA 39,32
027C4:  DATA 30,30
027C6:  DATA 2C,4E
027C8:  DATA 38,31
027CA:  DATA 2C,58
027CC:  DATA 4F,4E
027CE:  DATA 2D,58
027D0:  DATA 4F,46
027D2:  DATA 46,29
027D4:  DATA 0D,0A
027D6:  DATA 00,00
027D8:  DATA 40,4F
027DA:  DATA 4B,21
027DC:  DATA 20,00
027DE:  DATA 40,41
027E0:  DATA 52,47
027E2:  DATA 20,00
027E4:  DATA 40,4F
027E6:  DATA 4B,21
027E8:  DATA 20,00
027EA:  DATA 40,41
027EC:  DATA 52,47
027EE:  DATA 20,00
027F0:  DATA 0D,0A
027F2:  DATA 40,49
027F4:  DATA 4E,56
027F6:  DATA 00,00
027F8:  DATA 0D,0A
027FA:  DATA 40,4F
027FC:  DATA 4B,21
027FE:  DATA 20,00
02800:  DATA 40,49
02802:  DATA 4E,56
02804:  DATA 00,00
02806:  DATA 40,43
02808:  DATA 4D,44
0280A:  DATA 00,00
0280C:  DATA 2C,63
0280E:  DATA 6F,6D
02810:  DATA 6D,61
02812:  DATA 6E,64
02814:  DATA 20,70
02816:  DATA 72,6F
02818:  DATA 6D,70
0281A:  DATA 74,0D
0281C:  DATA 0A,00
0281E:  DATA 20,20
02820:  DATA 20,20
02822:  DATA 20,20
02824:  DATA 20,20
02826:  DATA 20,20
02828:  DATA 20,20
0282A:  DATA 20,20
0282C:  DATA 20,20
0282E:  DATA 20,20
02830:  DATA 20,20
02832:  DATA 20,20
02834:  DATA 20,20
02836:  DATA 20,20
02838:  DATA 20,20
0283A:  DATA 20,20
0283C:  DATA 20,20
0283E:  DATA 20,20
02840:  DATA 20,20
02842:  DATA 20,20
02844:  DATA 20,00
02846:  DATA 0D,0A
02848:  DATA 40,41
0284A:  DATA 52,47
0284C:  DATA 20,00
0284E:  DATA 0D,0A
02850:  DATA 40,41
02852:  DATA 52,47
02854:  DATA 20,00
02856:  DATA 40,43
02858:  DATA 4D,44
0285A:  DATA 00,00
0285C:  DATA 2C,63
0285E:  DATA 6F,6D
02860:  DATA 6D,61
02862:  DATA 6E,64
02864:  DATA 20,70
02866:  DATA 72,6F
02868:  DATA 6D,70
0286A:  DATA 74,0D
0286C:  DATA 0A,00
0286E:  DATA 40,53
02870:  DATA 44,3D
02872:  DATA 25,4C
02874:  DATA 75,0D
02876:  DATA 0A,00
02878:  DATA 40,4D
0287A:  DATA 43,31
0287C:  DATA 2C,25
0287E:  DATA 4C,75
02880:  DATA 2C,25
02882:  DATA 4C,64
02884:  DATA 0D,0A
02886:  DATA 00,00
02888:  DATA 40,4D
0288A:  DATA 43,32
0288C:  DATA 2C,25
0288E:  DATA 4C,75
02890:  DATA 2C,25
02892:  DATA 4C,64
02894:  DATA 0D,0A
02896:  DATA 00,00
02898:  DATA 50,72
0289A:  DATA 65,73
0289C:  DATA 73,20
0289E:  DATA 61,6E
028A0:  DATA 64,20
028A2:  DATA 68,6F
028A4:  DATA 6C,64
028A6:  DATA 20,74
028A8:  DATA 68,65
028AA:  DATA 20,45
028AC:  DATA 73,63
028AE:  DATA 20,6B
028B0:  DATA 65,79
028B2:  DATA 20,74
028B4:  DATA 6F,20
028B6:  DATA 72,65
028B8:  DATA 74,75
028BA:  DATA 72,6E
028BC:  DATA 20,74
028BE:  DATA 6F,20
028C0:  DATA 43,6F
028C2:  DATA 6D,6D
028C4:  DATA 61,6E
028C6:  DATA 64,20
028C8:  DATA 4D,6F
028CA:  DATA 64,65
028CC:  DATA 0D,0A
028CE:  DATA 00,00
028D0:  DATA 52,65
028D2:  DATA 74,75
028D4:  DATA 72,6E
028D6:  DATA 69,6E
028D8:  DATA 67,20
028DA:  DATA 74,6F
028DC:  DATA 20,4C
028DE:  DATA 6F,67
028E0:  DATA 67,69
028E2:  DATA 6E,67
028E4:  DATA 20,4D
028E6:  DATA 6F,64
028E8:  DATA 65,0D
028EA:  DATA 0A,00
*
02CFC:  CLRF   01
02CFE:  CLRF   02
02D00:  CLRF   00
02D02:  CLRF   03
02D04:  MOVLB  8
02D06:  MOVF   xDE,W
02D08:  BNZ   2D0E
02D0A:  MOVF   xDD,W
02D0C:  BZ    2D3E
02D0E:  MOVLW  10
02D10:  MOVWF  xDF
02D12:  BCF    FD8.0
02D14:  RLCF   xDB,F
02D16:  RLCF   xDC,F
02D18:  RLCF   00,F
02D1A:  RLCF   03,F
02D1C:  MOVF   xDE,W
02D1E:  SUBWF  03,W
02D20:  BNZ   2D26
02D22:  MOVF   xDD,W
02D24:  SUBWF  00,W
02D26:  BNC   2D36
02D28:  MOVF   xDD,W
02D2A:  SUBWF  00,F
02D2C:  BTFSS  FD8.0
02D2E:  DECF   03,F
02D30:  MOVF   xDE,W
02D32:  SUBWF  03,F
02D34:  BSF    FD8.0
02D36:  RLCF   01,F
02D38:  RLCF   02,F
02D3A:  DECFSZ xDF,F
02D3C:  BRA    2D12
02D3E:  MOVLB  0
02D40:  RETURN 0
*
0354E:  TSTFSZ 01
03550:  BRA    3558
03552:  TSTFSZ 02
03554:  BRA    355A
03556:  BRA    3566
03558:  INCF   02,F
0355A:  MOVFF  00,FEE
0355E:  DECFSZ 01,F
03560:  BRA    355A
03562:  DECFSZ 02,F
03564:  BRA    355A
03566:  RETURN 0
*
03638:  MOVLB  9
0363A:  BTFSC  xED.7
0363C:  BRA    365E
0363E:  MOVLW  0F
03640:  MOVWF  00
03642:  SWAPF  xEC,W
03644:  ANDWF  00,F
03646:  MOVLW  0A
03648:  SUBWF  00,W
0364A:  BC    3652
0364C:  MOVLW  30
0364E:  ADDWF  00,F
03650:  BRA    3656
03652:  MOVF   xED,W
03654:  ADDWF  00,F
03656:  MOVF   00,W
03658:  BTFSS  F9E.4
0365A:  BRA    3658
0365C:  MOVWF  FAD
0365E:  MOVLW  0F
03660:  ANDWF  xEC,F
03662:  MOVLW  0A
03664:  SUBWF  xEC,W
03666:  BC    366C
03668:  MOVLW  30
0366A:  BRA    3670
0366C:  BCF    xED.7
0366E:  MOVF   xED,W
03670:  ADDWF  xEC,F
03672:  MOVF   xEC,W
03674:  BTFSS  F9E.4
03676:  BRA    3674
03678:  MOVWF  FAD
0367A:  MOVLB  0
0367C:  RETURN 0
*
04818:  MOVLB  9
0481A:  CLRF   xFE
0481C:  CLRF   xFF
0481E:  MOVLW  01
04820:  MOVLB  A
04822:  MOVWF  x00
04824:  CLRF   FDA
04826:  CLRF   FD9
04828:  MOVLW  09
0482A:  MOVWF  x03
0482C:  MOVLW  F6
0482E:  MOVWF  x02
04830:  MOVLW  09
04832:  MOVWF  FEA
04834:  MOVLW  FA
04836:  MOVWF  FE9
04838:  MOVFF  A03,FE2
0483C:  MOVFF  A02,FE1
04840:  MOVFF  A00,A01
04844:  BCF    FD8.0
04846:  MOVF   FE5,W
04848:  MULWF  FEE
0484A:  MOVF   FF3,W
0484C:  MOVLB  9
0484E:  ADDWFC xFE,F
04850:  MOVF   FF4,W
04852:  ADDWFC xFF,F
04854:  MOVLB  A
04856:  DECFSZ x01,F
04858:  BRA    4844
0485A:  MOVFF  9FE,FDE
0485E:  MOVFF  9FF,9FE
04862:  MOVLB  9
04864:  CLRF   xFF
04866:  BTFSC  FD8.0
04868:  INCF   xFF,F
0486A:  MOVLB  A
0486C:  INCF   x02,F
0486E:  BTFSC  FD8.2
04870:  INCF   x03,F
04872:  INCF   x00,F
04874:  MOVF   x00,W
04876:  SUBLW  05
04878:  BNZ   4830
0487A:  MOVLB  0
0487C:  RETURN 0
*
050C6:  MOVFF  1E,FEA
050CA:  MOVFF  1D,FE9
050CE:  MOVLB  8
050D0:  MOVFF  8FF,FEF
050D4:  INCF   FE9,F
050D6:  BTFSC  FD8.2
050D8:  INCF   FEA,F
050DA:  CLRF   FEF
050DC:  INCF   1D,F
050DE:  BTFSC  FD8.2
050E0:  INCF   1E,F
050E2:  MOVLB  0
050E4:  RETURN 0
050E6:  TBLRD*+
050E8:  MOVF   FF5,F
050EA:  BZ    510C
050EC:  MOVFF  FF6,8EB
050F0:  MOVFF  FF7,8EC
050F4:  MOVFF  FF8,8ED
050F8:  MOVFF  FF5,8FF
050FC:  RCALL  50C6
050FE:  MOVFF  8EB,FF6
05102:  MOVFF  8EC,FF7
05106:  MOVFF  8ED,FF8
0510A:  BRA    50E6
0510C:  RETURN 0
*
052A8:  MOVF   01,W
052AA:  CLRF   1B
052AC:  BTFSC  FF2.7
052AE:  BSF    1B.7
052B0:  BCF    FF2.7
052B2:  MOVFF  8ED,A42
052B6:  MOVLW  64
052B8:  MOVLB  A
052BA:  MOVWF  x43
052BC:  MOVLB  0
052BE:  CALL   0F9A
052C2:  BTFSC  1B.7
052C4:  BSF    FF2.7
052C6:  MOVFF  00,8ED
052CA:  MOVF   01,W
052CC:  MOVLW  30
052CE:  BNZ   52E0
052D0:  MOVLB  8
052D2:  BTFSS  xEE.1
052D4:  BRA    52F4
052D6:  BTFSC  xEE.3
052D8:  BRA    52F4
052DA:  BTFSC  xEE.4
052DC:  MOVLW  20
052DE:  BRA    52E8
052E0:  MOVLB  8
052E2:  BCF    xEE.3
052E4:  BCF    xEE.4
052E6:  BSF    xEE.0
052E8:  ADDWF  01,F
052EA:  MOVFF  01,8FF
052EE:  MOVLB  0
052F0:  RCALL  50C6
052F2:  MOVLB  8
052F4:  CLRF   1B
052F6:  BTFSC  FF2.7
052F8:  BSF    1B.7
052FA:  BCF    FF2.7
052FC:  MOVFF  8ED,A42
05300:  MOVLW  0A
05302:  MOVLB  A
05304:  MOVWF  x43
05306:  MOVLB  0
05308:  CALL   0F9A
0530C:  BTFSC  1B.7
0530E:  BSF    FF2.7
05310:  MOVFF  00,8ED
05314:  MOVF   01,W
05316:  MOVLW  30
05318:  BNZ   532A
0531A:  MOVLB  8
0531C:  BTFSC  xEE.3
0531E:  BRA    5334
05320:  BTFSS  xEE.0
05322:  BRA    5334
05324:  BTFSC  xEE.4
05326:  MOVLW  20
05328:  MOVLB  0
0532A:  ADDWF  01,F
0532C:  MOVFF  01,8FF
05330:  RCALL  50C6
05332:  MOVLB  8
05334:  MOVLW  30
05336:  ADDWF  xED,F
05338:  MOVFF  8ED,8FF
0533C:  MOVLB  0
0533E:  RCALL  50C6
05340:  RETURN 0
05342:  MOVF   FE9,W
05344:  MOVLB  8
05346:  MOVWF  xF2
05348:  MOVLW  3B
0534A:  MOVWF  xF9
0534C:  MOVLW  9A
0534E:  MOVWF  xF8
05350:  MOVLW  CA
05352:  MOVWF  xF7
05354:  CLRF   xF6
05356:  MOVLW  0A
05358:  MOVWF  xF4
0535A:  MOVF   xF1,W
0535C:  BTFSS  FD8.2
0535E:  DECF   xF2,F
05360:  BSF    FD8.1
05362:  MOVLW  08
05364:  MOVWF  FEA
05366:  MOVLW  ED
05368:  MOVWF  FE9
0536A:  CLRF   1B
0536C:  BTFSC  FF2.7
0536E:  BSF    1B.7
05370:  BCF    FF2.7
05372:  MOVFF  8F0,A4F
05376:  MOVFF  8EF,A4E
0537A:  MOVFF  8EE,A4D
0537E:  MOVFF  8ED,A4C
05382:  MOVFF  8F9,A53
05386:  MOVFF  8F8,A52
0538A:  MOVFF  8F7,A51
0538E:  MOVFF  8F6,A50
05392:  MOVLB  0
05394:  CALL   1076
05398:  BTFSC  1B.7
0539A:  BSF    FF2.7
0539C:  MOVF   01,W
0539E:  MOVF   00,F
053A0:  BNZ   53C8
053A2:  MOVLB  8
053A4:  INCF   xF1,W
053A6:  SUBWF  xF4,W
053A8:  BTFSS  FD8.2
053AA:  BRA    53B0
053AC:  MOVLB  0
053AE:  BRA    53C8
053B0:  MOVF   xF2,W
053B2:  BZ    53CC
053B4:  ANDLW  0F
053B6:  SUBWF  xF4,W
053B8:  BZ    53BC
053BA:  BC    53F8
053BC:  BTFSC  xF2.7
053BE:  BRA    53F8
053C0:  BTFSC  xF2.6
053C2:  BRA    53CC
053C4:  MOVLW  20
053C6:  BRA    53EC
053C8:  MOVLB  8
053CA:  CLRF   xF2
053CC:  MOVF   xF1,W
053CE:  SUBWF  xF4,W
053D0:  BNZ   53EA
053D2:  MOVFF  00,8F2
053D6:  MOVLW  2E
053D8:  MOVWF  xFF
053DA:  MOVLB  0
053DC:  RCALL  50C6
053DE:  MOVLB  8
053E0:  MOVFF  8F2,00
053E4:  MOVLW  20
053E6:  ANDWF  xF2,F
053E8:  MOVLW  00
053EA:  MOVLW  30
053EC:  ADDWF  00,F
053EE:  MOVFF  00,8FF
053F2:  MOVLB  0
053F4:  RCALL  50C6
053F6:  MOVLB  8
053F8:  BCF    FD8.1
053FA:  CLRF   1B
053FC:  BTFSC  FF2.7
053FE:  BSF    1B.7
05400:  BCF    FF2.7
05402:  MOVFF  8F9,A4F
05406:  MOVFF  8F8,A4E
0540A:  MOVFF  8F7,A4D
0540E:  MOVFF  8F6,A4C
05412:  MOVLB  A
05414:  CLRF   x53
05416:  CLRF   x52
05418:  CLRF   x51
0541A:  MOVLW  0A
0541C:  MOVWF  x50
0541E:  MOVLB  0
05420:  CALL   1076
05424:  BTFSC  1B.7
05426:  BSF    FF2.7
05428:  MOVFF  03,8F9
0542C:  MOVFF  02,8F8
05430:  MOVFF  01,8F7
05434:  MOVFF  00,8F6
05438:  MOVLB  8
0543A:  DECFSZ xF4,F
0543C:  BRA    5360
0543E:  MOVLB  0
05440:  RETURN 0
*
05CC0:  MOVLB  A
05CC2:  MOVF   x10,W
05CC4:  MULWF  x12
05CC6:  MOVFF  FF3,01
05CCA:  MOVFF  FF4,00
05CCE:  MULWF  x13
05CD0:  MOVF   FF3,W
05CD2:  ADDWF  00,F
05CD4:  MOVF   x11,W
05CD6:  MULWF  x12
05CD8:  MOVF   FF3,W
05CDA:  ADDWFC 00,W
05CDC:  MOVWF  02
05CDE:  MOVLB  0
05CE0:  RETURN 0
*
079BE:  MOVF   FEF,F
079C0:  BZ    79E2
079C2:  MOVFF  FEA,9B1
079C6:  MOVFF  FE9,9B0
079CA:  MOVF   FEF,W
079CC:  BTFSS  F9E.4
079CE:  BRA    79CC
079D0:  MOVWF  FAD
079D2:  MOVFF  9B1,FEA
079D6:  MOVFF  9B0,FE9
079DA:  INCF   FE9,F
079DC:  BTFSC  FD8.2
079DE:  INCF   FEA,F
079E0:  BRA    79BE
079E2:  RETURN 0
*
0900C:  MOVFF  FEA,8F8
09010:  MOVFF  FE9,8F7
09014:  MOVLB  8
09016:  BTFSS  xF1.7
09018:  BRA    902A
0901A:  BSF    xF7.7
0901C:  BTFSS  xF7.4
0901E:  INCF   xF7,F
09020:  COMF   xF0,F
09022:  COMF   xF1,F
09024:  INCF   xF0,F
09026:  BTFSC  FD8.2
09028:  INCF   xF1,F
0902A:  SWAPF  xF1,W
0902C:  IORLW  F0
0902E:  MOVWF  xF3
09030:  ADDWF  xF3,F
09032:  ADDLW  E2
09034:  MOVWF  xF4
09036:  ADDLW  32
09038:  MOVWF  xF6
0903A:  MOVF   xF1,W
0903C:  ANDLW  0F
0903E:  ADDWF  xF4,F
09040:  ADDWF  xF4,F
09042:  ADDWF  xF6,F
09044:  ADDLW  E9
09046:  MOVWF  xF5
09048:  ADDWF  xF5,F
0904A:  ADDWF  xF5,F
0904C:  SWAPF  xF0,W
0904E:  ANDLW  0F
09050:  ADDWF  xF5,F
09052:  ADDWF  xF6,F
09054:  RLCF   xF5,F
09056:  RLCF   xF6,F
09058:  COMF   xF6,F
0905A:  RLCF   xF6,F
0905C:  MOVF   xF0,W
0905E:  ANDLW  0F
09060:  ADDWF  xF6,F
09062:  RLCF   xF3,F
09064:  MOVLW  07
09066:  MOVWF  xF2
09068:  MOVLW  0A
0906A:  DECF   xF5,F
0906C:  ADDWF  xF6,F
0906E:  BNC   906A
09070:  DECF   xF4,F
09072:  ADDWF  xF5,F
09074:  BNC   9070
09076:  DECF   xF3,F
09078:  ADDWF  xF4,F
0907A:  BNC   9076
0907C:  DECF   xF2,F
0907E:  ADDWF  xF3,F
09080:  BNC   907C
09082:  MOVLW  08
09084:  MOVWF  FEA
09086:  MOVLW  F2
09088:  MOVWF  FE9
0908A:  MOVLW  07
0908C:  ANDWF  xF7,W
0908E:  BCF    xF7.6
09090:  MOVF   FED,F
09092:  ANDWF  xF7,W
09094:  BNZ   90A4
09096:  BTFSC  xF7.4
09098:  MOVF   FEE,F
0909A:  BTFSC  xF7.4
0909C:  BRA    90A4
0909E:  MOVLW  20
090A0:  MOVWF  00
090A2:  BRA    90E6
090A4:  ADDWF  FE9,F
090A6:  MOVLW  00
090A8:  ADDWFC FEA,F
090AA:  MOVF   FE9,W
090AC:  SUBLW  F6
090AE:  BNZ   90B8
090B0:  MOVF   FEA,W
090B2:  SUBLW  08
090B4:  BNZ   90B8
090B6:  BSF    xF7.6
090B8:  MOVF   FEF,W
090BA:  MOVWF  00
090BC:  BNZ   90CE
090BE:  BTFSC  xF7.6
090C0:  BRA    90CE
090C2:  BTFSC  xF7.4
090C4:  BRA    90EE
090C6:  BTFSC  xF7.3
090C8:  BRA    90CE
090CA:  MOVLW  20
090CC:  BRA    90E4
090CE:  BTFSS  xF7.7
090D0:  BRA    90DE
090D2:  MOVLW  2D
090D4:  MOVWF  00
090D6:  MOVF   FED,W
090D8:  BCF    xF7.6
090DA:  BCF    xF7.7
090DC:  BRA    90E6
090DE:  BSF    xF7.3
090E0:  BCF    xF7.4
090E2:  MOVLW  30
090E4:  ADDWF  00,F
090E6:  MOVF   00,W
090E8:  BTFSS  F9E.4
090EA:  BRA    90E8
090EC:  MOVWF  FAD
090EE:  MOVF   FEE,W
090F0:  BTFSS  xF7.6
090F2:  BRA    90AA
090F4:  MOVLB  0
090F6:  RETURN 0
*
0958C:  MOVF   FE9,W
0958E:  MOVLB  8
09590:  MOVWF  xF6
09592:  BTFSS  xF5.7
09594:  BRA    95B0
09596:  DECF   xF6,F
09598:  BSF    xF6.5
0959A:  COMF   xF2,F
0959C:  COMF   xF3,F
0959E:  COMF   xF4,F
095A0:  COMF   xF5,F
095A2:  INCF   xF2,F
095A4:  BTFSC  FD8.2
095A6:  INCF   xF3,F
095A8:  BTFSC  FD8.2
095AA:  INCF   xF4,F
095AC:  BTFSC  FD8.2
095AE:  INCF   xF5,F
095B0:  MOVLW  3B
095B2:  MOVWF  xFD
095B4:  MOVLW  9A
095B6:  MOVWF  xFC
095B8:  MOVLW  CA
095BA:  MOVWF  xFB
095BC:  CLRF   xFA
095BE:  MOVLW  0A
095C0:  MOVWF  xF8
095C2:  BSF    FD8.1
095C4:  MOVLW  08
095C6:  MOVWF  FEA
095C8:  MOVLW  F2
095CA:  MOVWF  FE9
095CC:  CLRF   1B
095CE:  BTFSC  FF2.7
095D0:  BSF    1B.7
095D2:  BCF    FF2.7
095D4:  MOVFF  8F5,A4F
095D8:  MOVFF  8F4,A4E
095DC:  MOVFF  8F3,A4D
095E0:  MOVFF  8F2,A4C
095E4:  MOVFF  8FD,A53
095E8:  MOVFF  8FC,A52
095EC:  MOVFF  8FB,A51
095F0:  MOVFF  8FA,A50
095F4:  MOVLB  0
095F6:  CALL   1076
095FA:  BTFSC  1B.7
095FC:  BSF    FF2.7
095FE:  MOVF   01,W
09600:  MOVF   00,F
09602:  BNZ   962A
09604:  MOVLB  8
09606:  MOVF   xF8,W
09608:  XORLW  01
0960A:  BTFSS  FD8.2
0960C:  BRA    9612
0960E:  MOVLB  0
09610:  BRA    962A
09612:  MOVF   xF6,W
09614:  BZ    9630
09616:  ANDLW  0F
09618:  SUBWF  xF8,W
0961A:  BZ    961E
0961C:  BC    966E
0961E:  BTFSC  xF6.7
09620:  BRA    966E
09622:  BTFSC  xF6.6
09624:  BRA    9630
09626:  MOVLW  20
09628:  BRA    9664
0962A:  MOVLW  20
0962C:  MOVLB  8
0962E:  ANDWF  xF6,F
09630:  BTFSS  xF6.5
09632:  BRA    9648
09634:  BCF    xF6.5
09636:  MOVFF  00,8F6
0963A:  MOVLW  2D
0963C:  BTFSS  F9E.4
0963E:  BRA    963C
09640:  MOVWF  FAD
09642:  MOVFF  8F6,00
09646:  CLRF   xF6
09648:  MOVLW  30
0964A:  BTFSS  xF6.5
0964C:  BRA    9664
0964E:  BCF    xF6.5
09650:  MOVFF  00,8F6
09654:  MOVLW  2D
09656:  BTFSS  F9E.4
09658:  BRA    9656
0965A:  MOVWF  FAD
0965C:  MOVFF  8F6,00
09660:  CLRF   xF6
09662:  MOVLW  30
09664:  ADDWF  00,F
09666:  MOVF   00,W
09668:  BTFSS  F9E.4
0966A:  BRA    9668
0966C:  MOVWF  FAD
0966E:  BCF    FD8.1
09670:  CLRF   1B
09672:  BTFSC  FF2.7
09674:  BSF    1B.7
09676:  BCF    FF2.7
09678:  MOVFF  8FD,A4F
0967C:  MOVFF  8FC,A4E
09680:  MOVFF  8FB,A4D
09684:  MOVFF  8FA,A4C
09688:  MOVLB  A
0968A:  CLRF   x53
0968C:  CLRF   x52
0968E:  CLRF   x51
09690:  MOVLW  0A
09692:  MOVWF  x50
09694:  MOVLB  0
09696:  CALL   1076
0969A:  BTFSC  1B.7
0969C:  BSF    FF2.7
0969E:  MOVFF  03,8FD
096A2:  MOVFF  02,8FC
096A6:  MOVFF  01,8FB
096AA:  MOVFF  00,8FA
096AE:  MOVLB  8
096B0:  DECFSZ xF8,F
096B2:  BRA    95C2
096B4:  MOVLB  0
096B6:  RETURN 0
*
0A780:  ADDWF  FE8,W
0A782:  CLRF   FF7
0A784:  RLCF   FF7,F
0A786:  ADDLW  A1
0A788:  MOVWF  FF6
0A78A:  MOVLW  A7
0A78C:  ADDWFC FF7,F
0A78E:  MOVLW  00
0A790:  MOVWF  FF8
0A792:  MOVWF  FFB
0A794:  TBLRD*-
0A796:  MOVF   FF5,W
0A798:  MOVWF  FFA
0A79A:  TBLRD*
0A79C:  MOVF   FF5,W
0A79E:  MOVWF  FF9
0A7A0:  DATA DC,A0
0A7A2:  DATA FC,A0
0A7A4:  DATA 24,A1
0A7A6:  DATA 54,A1
0A7A8:  DATA 7C,A1
*
0AAF4:  TBLRD*+
0AAF6:  MOVFF  FF6,8EC
0AAFA:  MOVFF  FF7,8ED
0AAFE:  MOVFF  FF8,8EE
0AB02:  MOVFF  FF5,8FF
0AB06:  CALL   50C6
0AB0A:  MOVFF  8EC,FF6
0AB0E:  MOVFF  8ED,FF7
0AB12:  MOVFF  8EE,FF8
0AB16:  MOVLB  8
0AB18:  DECFSZ xEB,F
0AB1A:  BRA    AB1E
0AB1C:  BRA    AB22
0AB1E:  MOVLB  0
0AB20:  BRA    AAF4
0AB22:  MOVLB  0
0AB24:  RETURN 0
0AB26:  MOVFF  FEA,8FE
0AB2A:  MOVFF  FE9,8FD
0AB2E:  MOVLB  8
0AB30:  SWAPF  xF7,W
0AB32:  IORLW  F0
0AB34:  MOVWF  xF9
0AB36:  ADDWF  xF9,F
0AB38:  ADDLW  E2
0AB3A:  MOVWF  xFA
0AB3C:  ADDLW  32
0AB3E:  MOVWF  xFC
0AB40:  MOVF   xF7,W
0AB42:  ANDLW  0F
0AB44:  ADDWF  xFA,F
0AB46:  ADDWF  xFA,F
0AB48:  ADDWF  xFC,F
0AB4A:  ADDLW  E9
0AB4C:  MOVWF  xFB
0AB4E:  ADDWF  xFB,F
0AB50:  ADDWF  xFB,F
0AB52:  SWAPF  xF6,W
0AB54:  ANDLW  0F
0AB56:  ADDWF  xFB,F
0AB58:  ADDWF  xFC,F
0AB5A:  RLCF   xFB,F
0AB5C:  RLCF   xFC,F
0AB5E:  COMF   xFC,F
0AB60:  RLCF   xFC,F
0AB62:  MOVF   xF6,W
0AB64:  ANDLW  0F
0AB66:  ADDWF  xFC,F
0AB68:  RLCF   xF9,F
0AB6A:  MOVLW  07
0AB6C:  MOVWF  xF8
0AB6E:  MOVLW  0A
0AB70:  DECF   xFB,F
0AB72:  ADDWF  xFC,F
0AB74:  BNC   AB70
0AB76:  DECF   xFA,F
0AB78:  ADDWF  xFB,F
0AB7A:  BNC   AB76
0AB7C:  DECF   xF9,F
0AB7E:  ADDWF  xFA,F
0AB80:  BNC   AB7C
0AB82:  DECF   xF8,F
0AB84:  ADDWF  xF9,F
0AB86:  BNC   AB82
0AB88:  MOVLW  08
0AB8A:  MOVWF  FEA
0AB8C:  MOVLW  F8
0AB8E:  MOVWF  FE9
0AB90:  MOVLW  07
0AB92:  ANDWF  xFD,W
0AB94:  BCF    xFD.6
0AB96:  ADDWF  FE9,F
0AB98:  MOVLW  00
0AB9A:  ADDWFC FEA,F
0AB9C:  MOVF   FE9,W
0AB9E:  SUBLW  FC
0ABA0:  BNZ   ABAA
0ABA2:  MOVF   FEA,W
0ABA4:  SUBLW  08
0ABA6:  BNZ   ABAA
0ABA8:  BSF    xFD.6
0ABAA:  MOVF   FEF,W
0ABAC:  MOVWF  00
0ABAE:  BNZ   ABC0
0ABB0:  BTFSC  xFD.6
0ABB2:  BRA    ABC0
0ABB4:  BTFSC  xFD.4
0ABB6:  BRA    ABE4
0ABB8:  BTFSC  xFD.3
0ABBA:  BRA    ABC0
0ABBC:  MOVLW  20
0ABBE:  BRA    ABC6
0ABC0:  BSF    xFD.3
0ABC2:  BCF    xFD.4
0ABC4:  MOVLW  30
0ABC6:  ADDWF  00,F
0ABC8:  MOVFF  FEA,8F7
0ABCC:  MOVFF  FE9,8F6
0ABD0:  MOVFF  00,8FF
0ABD4:  MOVLB  0
0ABD6:  CALL   50C6
0ABDA:  MOVFF  8F7,FEA
0ABDE:  MOVFF  8F6,FE9
0ABE2:  MOVLB  8
0ABE4:  MOVF   FEE,W
0ABE6:  BTFSS  xFD.6
0ABE8:  BRA    AB9C
0ABEA:  MOVLB  0
0ABEC:  RETURN 0
*
0AE1C:  ADDWF  FE8,W
0AE1E:  CLRF   FF7
0AE20:  RLCF   FF7,F
0AE22:  ADDLW  3D
0AE24:  MOVWF  FF6
0AE26:  MOVLW  AE
0AE28:  ADDWFC FF7,F
0AE2A:  MOVLW  00
0AE2C:  MOVWF  FF8
0AE2E:  MOVWF  FFB
0AE30:  TBLRD*-
0AE32:  MOVF   FF5,W
0AE34:  MOVWF  FFA
0AE36:  TBLRD*
0AE38:  MOVF   FF5,W
0AE3A:  MOVWF  FF9
0AE3C:  DATA E8,AC
0AE3E:  DATA 18,AE
0AE40:  DATA 18,AE
0AE42:  DATA 48,AC
0AE44:  DATA 18,AE
0AE46:  DATA 18,AE
0AE48:  DATA 18,AE
0AE4A:  DATA 0C,AC
0AE4C:  DATA 18,AE
0AE4E:  DATA 18,AE
0AE50:  DATA 18,AE
0AE52:  DATA 5E,AD
0AE54:  DATA 84,AC
0AE56:  DATA 18,AE
0AE58:  DATA 22,AD
0AE5A:  DATA BC,AD
*
0AEB6:  TBLRD*+
0AEB8:  MOVF   FF5,F
0AEBA:  BZ    AEDE
0AEBC:  MOVFF  FF6,885
0AEC0:  MOVFF  FF7,886
0AEC4:  MOVFF  FF8,887
0AEC8:  MOVF   FF5,W
0AECA:  BTFSS  F9E.4
0AECC:  BRA    AECA
0AECE:  MOVWF  FAD
0AED0:  MOVFF  885,FF6
0AED4:  MOVFF  886,FF7
0AED8:  MOVFF  887,FF8
0AEDC:  BRA    AEB6
0AEDE:  RETURN 0
*
0C2F4:  MOVLB  9
0C2F6:  MOVF   x13,W
0C2F8:  BTFSC  FD8.2
0C2FA:  BRA    C3DE
0C2FC:  MOVWF  00
0C2FE:  MOVF   x17,W
0C300:  BTFSC  FD8.2
0C302:  BRA    C3DE
0C304:  ADDWF  00,F
0C306:  BNC   C310
0C308:  MOVLW  81
0C30A:  ADDWF  00,F
0C30C:  BC    C3DE
0C30E:  BRA    C318
0C310:  MOVLW  7F
0C312:  SUBWF  00,F
0C314:  BNC   C3DE
0C316:  BZ    C3DE
0C318:  MOVFF  914,91B
0C31C:  MOVF   x18,W
0C31E:  XORWF  x1B,F
0C320:  BSF    x14.7
0C322:  BSF    x18.7
0C324:  MOVF   x16,W
0C326:  MULWF  x1A
0C328:  MOVFF  FF4,91D
0C32C:  MOVF   x15,W
0C32E:  MULWF  x19
0C330:  MOVFF  FF4,03
0C334:  MOVFF  FF3,91C
0C338:  MULWF  x1A
0C33A:  MOVF   FF3,W
0C33C:  ADDWF  x1D,F
0C33E:  MOVF   FF4,W
0C340:  ADDWFC x1C,F
0C342:  MOVLW  00
0C344:  ADDWFC 03,F
0C346:  MOVF   x16,W
0C348:  MULWF  x19
0C34A:  MOVF   FF3,W
0C34C:  ADDWF  x1D,F
0C34E:  MOVF   FF4,W
0C350:  ADDWFC x1C,F
0C352:  MOVLW  00
0C354:  CLRF   02
0C356:  ADDWFC 03,F
0C358:  ADDWFC 02,F
0C35A:  MOVF   x14,W
0C35C:  MULWF  x1A
0C35E:  MOVF   FF3,W
0C360:  ADDWF  x1C,F
0C362:  MOVF   FF4,W
0C364:  ADDWFC 03,F
0C366:  MOVLW  00
0C368:  ADDWFC 02,F
0C36A:  MOVF   x14,W
0C36C:  MULWF  x19
0C36E:  MOVF   FF3,W
0C370:  ADDWF  03,F
0C372:  MOVF   FF4,W
0C374:  ADDWFC 02,F
0C376:  MOVLW  00
0C378:  CLRF   01
0C37A:  ADDWFC 01,F
0C37C:  MOVF   x16,W
0C37E:  MULWF  x18
0C380:  MOVF   FF3,W
0C382:  ADDWF  x1C,F
0C384:  MOVF   FF4,W
0C386:  ADDWFC 03,F
0C388:  MOVLW  00
0C38A:  ADDWFC 02,F
0C38C:  ADDWFC 01,F
0C38E:  MOVF   x15,W
0C390:  MULWF  x18
0C392:  MOVF   FF3,W
0C394:  ADDWF  03,F
0C396:  MOVF   FF4,W
0C398:  ADDWFC 02,F
0C39A:  MOVLW  00
0C39C:  ADDWFC 01,F
0C39E:  MOVF   x14,W
0C3A0:  MULWF  x18
0C3A2:  MOVF   FF3,W
0C3A4:  ADDWF  02,F
0C3A6:  MOVF   FF4,W
0C3A8:  ADDWFC 01,F
0C3AA:  INCF   00,F
0C3AC:  BTFSC  01.7
0C3AE:  BRA    C3BA
0C3B0:  RLCF   x1C,F
0C3B2:  RLCF   03,F
0C3B4:  RLCF   02,F
0C3B6:  RLCF   01,F
0C3B8:  DECF   00,F
0C3BA:  MOVLW  00
0C3BC:  BTFSS  x1C.7
0C3BE:  BRA    C3D4
0C3C0:  INCF   03,F
0C3C2:  ADDWFC 02,F
0C3C4:  ADDWFC 01,F
0C3C6:  MOVF   01,W
0C3C8:  BNZ   C3D4
0C3CA:  MOVF   02,W
0C3CC:  BNZ   C3D4
0C3CE:  MOVF   03,W
0C3D0:  BNZ   C3D4
0C3D2:  INCF   00,F
0C3D4:  BTFSC  x1B.7
0C3D6:  BSF    01.7
0C3D8:  BTFSS  x1B.7
0C3DA:  BCF    01.7
0C3DC:  BRA    C3E6
0C3DE:  CLRF   00
0C3E0:  CLRF   01
0C3E2:  CLRF   02
0C3E4:  CLRF   03
0C3E6:  MOVLB  0
0C3E8:  RETURN 0
0C3EA:  MOVLW  80
0C3EC:  BTFSS  FD8.1
0C3EE:  BRA    C3F4
0C3F0:  MOVLB  9
0C3F2:  XORWF  x1C,F
0C3F4:  MOVLB  9
0C3F6:  CLRF   x21
0C3F8:  CLRF   x22
0C3FA:  MOVFF  918,920
0C3FE:  MOVF   x1C,W
0C400:  XORWF  x20,F
0C402:  MOVF   x17,W
0C404:  BTFSC  FD8.2
0C406:  BRA    C5C6
0C408:  MOVWF  x1F
0C40A:  MOVWF  00
0C40C:  MOVF   x1B,W
0C40E:  BTFSC  FD8.2
0C410:  BRA    C5D8
0C412:  SUBWF  x1F,F
0C414:  BTFSC  FD8.2
0C416:  BRA    C51E
0C418:  BNC   C496
0C41A:  MOVFF  91C,925
0C41E:  BSF    x25.7
0C420:  MOVFF  91D,924
0C424:  MOVFF  91E,923
0C428:  CLRF   x22
0C42A:  BCF    FD8.0
0C42C:  RRCF   x25,F
0C42E:  RRCF   x24,F
0C430:  RRCF   x23,F
0C432:  RRCF   x22,F
0C434:  DECFSZ x1F,F
0C436:  BRA    C428
0C438:  BTFSS  x20.7
0C43A:  BRA    C442
0C43C:  BSF    x21.0
0C43E:  BRA    C600
0C440:  BCF    x21.0
0C442:  BCF    x1F.0
0C444:  BSF    x21.4
0C446:  MOVLW  09
0C448:  MOVWF  FEA
0C44A:  MOVLW  1A
0C44C:  MOVWF  FE9
0C44E:  BRA    C626
0C450:  BCF    x21.4
0C452:  BTFSC  x20.7
0C454:  BRA    C46A
0C456:  BTFSS  x1F.0
0C458:  BRA    C480
0C45A:  RRCF   x25,F
0C45C:  RRCF   x24,F
0C45E:  RRCF   x23,F
0C460:  RRCF   x22,F
0C462:  INCF   00,F
0C464:  BTFSC  FD8.2
0C466:  BRA    C5F6
0C468:  BRA    C480
0C46A:  BTFSC  x25.7
0C46C:  BRA    C486
0C46E:  BCF    FD8.0
0C470:  RLCF   x22,F
0C472:  RLCF   x23,F
0C474:  RLCF   x24,F
0C476:  RLCF   x25,F
0C478:  DECF   00,F
0C47A:  BTFSC  FD8.2
0C47C:  BRA    C5F6
0C47E:  BRA    C46A
0C480:  BSF    x21.6
0C482:  BRA    C55E
0C484:  BCF    x21.6
0C486:  MOVFF  918,920
0C48A:  BTFSS  x18.7
0C48C:  BRA    C492
0C48E:  BSF    x25.7
0C490:  BRA    C5E8
0C492:  BCF    x25.7
0C494:  BRA    C5E8
0C496:  MOVFF  91B,91F
0C49A:  MOVFF  91B,00
0C49E:  MOVF   x17,W
0C4A0:  SUBWF  x1F,F
0C4A2:  MOVFF  918,925
0C4A6:  BSF    x25.7
0C4A8:  MOVFF  919,924
0C4AC:  MOVFF  91A,923
0C4B0:  CLRF   x22
0C4B2:  BCF    FD8.0
0C4B4:  RRCF   x25,F
0C4B6:  RRCF   x24,F
0C4B8:  RRCF   x23,F
0C4BA:  RRCF   x22,F
0C4BC:  DECFSZ x1F,F
0C4BE:  BRA    C4B0
0C4C0:  BTFSS  x20.7
0C4C2:  BRA    C4CA
0C4C4:  BSF    x21.1
0C4C6:  BRA    C600
0C4C8:  BCF    x21.1
0C4CA:  BCF    x1F.0
0C4CC:  BSF    x21.5
0C4CE:  MOVLW  09
0C4D0:  MOVWF  FEA
0C4D2:  MOVLW  1E
0C4D4:  MOVWF  FE9
0C4D6:  BRA    C626
0C4D8:  BCF    x21.5
0C4DA:  BTFSC  x20.7
0C4DC:  BRA    C4F2
0C4DE:  BTFSS  x1F.0
0C4E0:  BRA    C508
0C4E2:  RRCF   x25,F
0C4E4:  RRCF   x24,F
0C4E6:  RRCF   x23,F
0C4E8:  RRCF   x22,F
0C4EA:  INCF   00,F
0C4EC:  BTFSC  FD8.2
0C4EE:  BRA    C5F6
0C4F0:  BRA    C508
0C4F2:  BTFSC  x25.7
0C4F4:  BRA    C50E
0C4F6:  BCF    FD8.0
0C4F8:  RLCF   x22,F
0C4FA:  RLCF   x23,F
0C4FC:  RLCF   x24,F
0C4FE:  RLCF   x25,F
0C500:  DECF   00,F
0C502:  BTFSC  FD8.2
0C504:  BRA    C5F6
0C506:  BRA    C4F2
0C508:  BSF    x21.7
0C50A:  BRA    C55E
0C50C:  BCF    x21.7
0C50E:  MOVFF  91C,920
0C512:  BTFSS  x1C.7
0C514:  BRA    C51A
0C516:  BSF    x25.7
0C518:  BRA    C5E8
0C51A:  BCF    x25.7
0C51C:  BRA    C5E8
0C51E:  MOVFF  91C,925
0C522:  BSF    x25.7
0C524:  MOVFF  91D,924
0C528:  MOVFF  91E,923
0C52C:  BTFSS  x20.7
0C52E:  BRA    C538
0C530:  BCF    x25.7
0C532:  BSF    x21.2
0C534:  BRA    C600
0C536:  BCF    x21.2
0C538:  CLRF   x22
0C53A:  BCF    x1F.0
0C53C:  MOVLW  09
0C53E:  MOVWF  FEA
0C540:  MOVLW  1A
0C542:  MOVWF  FE9
0C544:  BRA    C626
0C546:  BTFSC  x20.7
0C548:  BRA    C582
0C54A:  MOVFF  918,920
0C54E:  BTFSS  x1F.0
0C550:  BRA    C55E
0C552:  RRCF   x25,F
0C554:  RRCF   x24,F
0C556:  RRCF   x23,F
0C558:  RRCF   x22,F
0C55A:  INCF   00,F
0C55C:  BZ    C5F6
0C55E:  BTFSS  x22.7
0C560:  BRA    C578
0C562:  INCF   x23,F
0C564:  BNZ   C578
0C566:  INCF   x24,F
0C568:  BNZ   C578
0C56A:  INCF   x25,F
0C56C:  BNZ   C578
0C56E:  RRCF   x25,F
0C570:  RRCF   x24,F
0C572:  RRCF   x23,F
0C574:  INCF   00,F
0C576:  BZ    C5F6
0C578:  BTFSC  x21.6
0C57A:  BRA    C484
0C57C:  BTFSC  x21.7
0C57E:  BRA    C50C
0C580:  BRA    C5BA
0C582:  MOVLW  80
0C584:  XORWF  x25,F
0C586:  BTFSS  x25.7
0C588:  BRA    C592
0C58A:  BRA    C600
0C58C:  MOVFF  91C,920
0C590:  BRA    C5A6
0C592:  MOVFF  918,920
0C596:  MOVF   x25,F
0C598:  BNZ   C5A6
0C59A:  MOVF   x24,F
0C59C:  BNZ   C5A6
0C59E:  MOVF   x23,F
0C5A0:  BNZ   C5A6
0C5A2:  CLRF   00
0C5A4:  BRA    C5E8
0C5A6:  BTFSC  x25.7
0C5A8:  BRA    C5BA
0C5AA:  BCF    FD8.0
0C5AC:  RLCF   x22,F
0C5AE:  RLCF   x23,F
0C5B0:  RLCF   x24,F
0C5B2:  RLCF   x25,F
0C5B4:  DECFSZ 00,F
0C5B6:  BRA    C5A6
0C5B8:  BRA    C5F6
0C5BA:  BTFSS  x20.7
0C5BC:  BRA    C5C2
0C5BE:  BSF    x25.7
0C5C0:  BRA    C5E8
0C5C2:  BCF    x25.7
0C5C4:  BRA    C5E8
0C5C6:  MOVFF  91B,00
0C5CA:  MOVFF  91C,925
0C5CE:  MOVFF  91D,924
0C5D2:  MOVFF  91E,923
0C5D6:  BRA    C5E8
0C5D8:  MOVFF  917,00
0C5DC:  MOVFF  918,925
0C5E0:  MOVFF  919,924
0C5E4:  MOVFF  91A,923
0C5E8:  MOVFF  925,01
0C5EC:  MOVFF  924,02
0C5F0:  MOVFF  923,03
0C5F4:  BRA    C65E
0C5F6:  CLRF   00
0C5F8:  CLRF   01
0C5FA:  CLRF   02
0C5FC:  CLRF   03
0C5FE:  BRA    C65E
0C600:  CLRF   x22
0C602:  COMF   x23,F
0C604:  COMF   x24,F
0C606:  COMF   x25,F
0C608:  COMF   x22,F
0C60A:  INCF   x22,F
0C60C:  BNZ   C618
0C60E:  INCF   x23,F
0C610:  BNZ   C618
0C612:  INCF   x24,F
0C614:  BNZ   C618
0C616:  INCF   x25,F
0C618:  BTFSC  x21.0
0C61A:  BRA    C440
0C61C:  BTFSC  x21.1
0C61E:  BRA    C4C8
0C620:  BTFSC  x21.2
0C622:  BRA    C536
0C624:  BRA    C58C
0C626:  MOVF   FEF,W
0C628:  ADDWF  x23,F
0C62A:  BNC   C636
0C62C:  INCF   x24,F
0C62E:  BNZ   C636
0C630:  INCF   x25,F
0C632:  BTFSC  FD8.2
0C634:  BSF    x1F.0
0C636:  MOVF   FED,F
0C638:  MOVF   FEF,W
0C63A:  ADDWF  x24,F
0C63C:  BNC   C644
0C63E:  INCF   x25,F
0C640:  BTFSC  FD8.2
0C642:  BSF    x1F.0
0C644:  MOVF   FED,F
0C646:  MOVF   FEF,W
0C648:  BTFSC  FEF.7
0C64A:  BRA    C64E
0C64C:  XORLW  80
0C64E:  ADDWF  x25,F
0C650:  BTFSC  FD8.0
0C652:  BSF    x1F.0
0C654:  BTFSC  x21.4
0C656:  BRA    C450
0C658:  BTFSC  x21.5
0C65A:  BRA    C4D8
0C65C:  BRA    C546
0C65E:  MOVLB  0
0C660:  RETURN 0
0C662:  MOVLB  8
0C664:  MOVF   xDC,W
0C666:  SUBLW  B6
0C668:  MOVWF  xDC
0C66A:  CLRF   03
0C66C:  MOVFF  8DD,8E0
0C670:  BSF    xDD.7
0C672:  BCF    FD8.0
0C674:  RRCF   xDD,F
0C676:  RRCF   xDE,F
0C678:  RRCF   xDF,F
0C67A:  RRCF   03,F
0C67C:  RRCF   02,F
0C67E:  RRCF   01,F
0C680:  RRCF   00,F
0C682:  DECFSZ xDC,F
0C684:  BRA    C672
0C686:  BTFSS  xE0.7
0C688:  BRA    C6A0
0C68A:  COMF   00,F
0C68C:  COMF   01,F
0C68E:  COMF   02,F
0C690:  COMF   03,F
0C692:  INCF   00,F
0C694:  BTFSC  FD8.2
0C696:  INCF   01,F
0C698:  BTFSC  FD8.2
0C69A:  INCF   02,F
0C69C:  BTFSC  FD8.2
0C69E:  INCF   03,F
0C6A0:  MOVLB  0
0C6A2:  RETURN 0
0C6A4:  MOVF   FE9,W
0C6A6:  MOVLB  8
0C6A8:  MOVWF  x8A
0C6AA:  MOVF   x89,W
0C6AC:  MOVWF  x8C
0C6AE:  BZ    C6E8
0C6B0:  MOVFF  888,916
0C6B4:  MOVFF  887,915
0C6B8:  MOVFF  886,914
0C6BC:  MOVFF  885,913
0C6C0:  MOVLB  9
0C6C2:  CLRF   x1A
0C6C4:  CLRF   x19
0C6C6:  MOVLW  20
0C6C8:  MOVWF  x18
0C6CA:  MOVLW  82
0C6CC:  MOVWF  x17
0C6CE:  MOVLB  0
0C6D0:  RCALL  C2F4
0C6D2:  MOVFF  03,888
0C6D6:  MOVFF  02,887
0C6DA:  MOVFF  01,886
0C6DE:  MOVFF  00,885
0C6E2:  MOVLB  8
0C6E4:  DECFSZ x8C,F
0C6E6:  BRA    C6B0
0C6E8:  MOVLW  7E
0C6EA:  MOVWF  00
0C6EC:  CLRF   01
0C6EE:  BTFSC  x86.7
0C6F0:  BSF    01.7
0C6F2:  CLRF   02
0C6F4:  CLRF   03
0C6F6:  BCF    FD8.1
0C6F8:  MOVFF  888,91A
0C6FC:  MOVFF  887,919
0C700:  MOVFF  886,918
0C704:  MOVFF  885,917
0C708:  MOVFF  03,91E
0C70C:  MOVFF  02,91D
0C710:  MOVFF  01,91C
0C714:  MOVFF  FE8,91B
0C718:  MOVLB  0
0C71A:  RCALL  C3EA
0C71C:  MOVFF  03,888
0C720:  MOVFF  02,887
0C724:  MOVFF  01,886
0C728:  MOVFF  00,885
0C72C:  MOVFF  888,8DF
0C730:  MOVFF  887,8DE
0C734:  MOVFF  886,8DD
0C738:  MOVFF  885,8DC
0C73C:  RCALL  C662
0C73E:  MOVFF  03,888
0C742:  MOVFF  02,887
0C746:  MOVFF  01,886
0C74A:  MOVFF  00,885
0C74E:  MOVLB  8
0C750:  BTFSS  x88.7
0C752:  BRA    C76E
0C754:  DECF   x8A,F
0C756:  BSF    x8A.5
0C758:  COMF   x85,F
0C75A:  COMF   x86,F
0C75C:  COMF   x87,F
0C75E:  COMF   x88,F
0C760:  INCF   x85,F
0C762:  BTFSC  FD8.2
0C764:  INCF   x86,F
0C766:  BTFSC  FD8.2
0C768:  INCF   x87,F
0C76A:  BTFSC  FD8.2
0C76C:  INCF   x88,F
0C76E:  MOVLW  3B
0C770:  MOVWF  x91
0C772:  MOVLW  9A
0C774:  MOVWF  x90
0C776:  MOVLW  CA
0C778:  MOVWF  x8F
0C77A:  CLRF   x8E
0C77C:  MOVLW  0A
0C77E:  MOVWF  x8C
0C780:  MOVF   x89,W
0C782:  BTFSC  FD8.2
0C784:  INCF   x8A,F
0C786:  BSF    FD8.1
0C788:  MOVLW  08
0C78A:  MOVWF  FEA
0C78C:  MOVLW  85
0C78E:  MOVWF  FE9
0C790:  CLRF   1B
0C792:  BTFSC  FF2.7
0C794:  BSF    1B.7
0C796:  BCF    FF2.7
0C798:  MOVFF  888,A4F
0C79C:  MOVFF  887,A4E
0C7A0:  MOVFF  886,A4D
0C7A4:  MOVFF  885,A4C
0C7A8:  MOVFF  891,A53
0C7AC:  MOVFF  890,A52
0C7B0:  MOVFF  88F,A51
0C7B4:  MOVFF  88E,A50
0C7B8:  MOVLB  0
0C7BA:  CALL   1076
0C7BE:  BTFSC  1B.7
0C7C0:  BSF    FF2.7
0C7C2:  MOVF   01,W
0C7C4:  MOVF   00,F
0C7C6:  BNZ   C7EE
0C7C8:  MOVLB  8
0C7CA:  INCF   x89,W
0C7CC:  SUBWF  x8C,W
0C7CE:  BTFSS  FD8.2
0C7D0:  BRA    C7D6
0C7D2:  MOVLB  0
0C7D4:  BRA    C7EE
0C7D6:  MOVF   x8A,W
0C7D8:  BZ    C7F4
0C7DA:  ANDLW  0F
0C7DC:  SUBWF  x8C,W
0C7DE:  BZ    C7E2
0C7E0:  BC    C85A
0C7E2:  BTFSC  x8A.7
0C7E4:  BRA    C85A
0C7E6:  BTFSC  x8A.6
0C7E8:  BRA    C7F4
0C7EA:  MOVLW  20
0C7EC:  BRA    C850
0C7EE:  MOVLW  20
0C7F0:  MOVLB  8
0C7F2:  ANDWF  x8A,F
0C7F4:  BTFSS  x8A.5
0C7F6:  BRA    C812
0C7F8:  BCF    x8A.5
0C7FA:  MOVF   x89,W
0C7FC:  BTFSS  FD8.2
0C7FE:  DECF   x8A,F
0C800:  MOVF   00,W
0C802:  MOVWF  x8A
0C804:  MOVLW  2D
0C806:  BTFSS  F9E.4
0C808:  BRA    C806
0C80A:  MOVWF  FAD
0C80C:  MOVF   x8A,W
0C80E:  MOVWF  00
0C810:  CLRF   x8A
0C812:  MOVF   x89,W
0C814:  SUBWF  x8C,W
0C816:  BNZ   C82E
0C818:  MOVF   00,W
0C81A:  MOVWF  x8A
0C81C:  MOVLW  2E
0C81E:  BTFSS  F9E.4
0C820:  BRA    C81E
0C822:  MOVWF  FAD
0C824:  MOVF   x8A,W
0C826:  MOVWF  00
0C828:  MOVLW  20
0C82A:  ANDWF  x8A,F
0C82C:  MOVLW  00
0C82E:  MOVLW  30
0C830:  BTFSS  x8A.5
0C832:  BRA    C850
0C834:  BCF    x8A.5
0C836:  MOVF   x89,W
0C838:  BTFSS  FD8.2
0C83A:  DECF   x8A,F
0C83C:  MOVF   00,W
0C83E:  MOVWF  x8A
0C840:  MOVLW  2D
0C842:  BTFSS  F9E.4
0C844:  BRA    C842
0C846:  MOVWF  FAD
0C848:  MOVF   x8A,W
0C84A:  MOVWF  00
0C84C:  CLRF   x8A
0C84E:  MOVLW  30
0C850:  ADDWF  00,F
0C852:  MOVF   00,W
0C854:  BTFSS  F9E.4
0C856:  BRA    C854
0C858:  MOVWF  FAD
0C85A:  BCF    FD8.1
0C85C:  CLRF   1B
0C85E:  BTFSC  FF2.7
0C860:  BSF    1B.7
0C862:  BCF    FF2.7
0C864:  MOVFF  891,A4F
0C868:  MOVFF  890,A4E
0C86C:  MOVFF  88F,A4D
0C870:  MOVFF  88E,A4C
0C874:  MOVLB  A
0C876:  CLRF   x53
0C878:  CLRF   x52
0C87A:  CLRF   x51
0C87C:  MOVLW  0A
0C87E:  MOVWF  x50
0C880:  MOVLB  0
0C882:  CALL   1076
0C886:  BTFSC  1B.7
0C888:  BSF    FF2.7
0C88A:  MOVFF  03,891
0C88E:  MOVFF  02,890
0C892:  MOVFF  01,88F
0C896:  MOVFF  00,88E
0C89A:  MOVLB  8
0C89C:  DECFSZ x8C,F
0C89E:  BRA    C786
0C8A0:  MOVLB  0
0C8A2:  RETURN 0
*
0C926:  MOVLW  8E
0C928:  MOVWF  00
0C92A:  MOVFF  918,01
0C92E:  MOVFF  917,02
0C932:  CLRF   03
0C934:  MOVF   01,F
0C936:  BNZ   C94A
0C938:  MOVFF  02,01
0C93C:  CLRF   02
0C93E:  MOVLW  08
0C940:  SUBWF  00,F
0C942:  MOVF   01,F
0C944:  BNZ   C94A
0C946:  CLRF   00
0C948:  BRA    C95A
0C94A:  BCF    FD8.0
0C94C:  BTFSC  01.7
0C94E:  BRA    C958
0C950:  RLCF   02,F
0C952:  RLCF   01,F
0C954:  DECF   00,F
0C956:  BRA    C94A
0C958:  BCF    01.7
0C95A:  RETURN 0
0C95C:  MOVLB  8
0C95E:  MOVF   xFB,W
0C960:  BTFSC  FD8.2
0C962:  BRA    CACC
0C964:  MOVLB  9
0C966:  MOVWF  x07
0C968:  MOVLB  8
0C96A:  MOVF   xFF,W
0C96C:  BTFSC  FD8.2
0C96E:  BRA    CACC
0C970:  MOVLB  9
0C972:  SUBWF  x07,F
0C974:  BNC   C984
0C976:  MOVLW  7F
0C978:  ADDWF  x07,F
0C97A:  BTFSS  FD8.0
0C97C:  BRA    C982
0C97E:  MOVLB  8
0C980:  BRA    CACC
0C982:  BRA    C998
0C984:  MOVLW  81
0C986:  SUBWF  x07,F
0C988:  BTFSC  FD8.0
0C98A:  BRA    C990
0C98C:  MOVLB  8
0C98E:  BRA    CACC
0C990:  BTFSS  FD8.2
0C992:  BRA    C998
0C994:  MOVLB  8
0C996:  BRA    CACC
0C998:  MOVFF  907,00
0C99C:  CLRF   01
0C99E:  CLRF   02
0C9A0:  CLRF   03
0C9A2:  CLRF   x06
0C9A4:  MOVFF  8FC,905
0C9A8:  BSF    x05.7
0C9AA:  MOVFF  8FD,904
0C9AE:  MOVFF  8FE,903
0C9B2:  MOVLW  19
0C9B4:  MOVWF  x07
0C9B6:  MOVF   x02,W
0C9B8:  SUBWF  x03,F
0C9BA:  BC    C9D6
0C9BC:  MOVLW  01
0C9BE:  SUBWF  x04,F
0C9C0:  BC    C9D6
0C9C2:  SUBWF  x05,F
0C9C4:  BC    C9D6
0C9C6:  SUBWF  x06,F
0C9C8:  BC    C9D6
0C9CA:  INCF   x06,F
0C9CC:  INCF   x05,F
0C9CE:  INCF   x04,F
0C9D0:  MOVF   x02,W
0C9D2:  ADDWF  x03,F
0C9D4:  BRA    CA26
0C9D6:  MOVF   x01,W
0C9D8:  SUBWF  x04,F
0C9DA:  BC    CA00
0C9DC:  MOVLW  01
0C9DE:  SUBWF  x05,F
0C9E0:  BC    CA00
0C9E2:  SUBWF  x06,F
0C9E4:  BC    CA00
0C9E6:  INCF   x06,F
0C9E8:  INCF   x05,F
0C9EA:  MOVF   x01,W
0C9EC:  ADDWF  x04,F
0C9EE:  MOVF   x02,W
0C9F0:  ADDWF  x03,F
0C9F2:  BNC   CA26
0C9F4:  INCF   x04,F
0C9F6:  BNZ   CA26
0C9F8:  INCF   x05,F
0C9FA:  BNZ   CA26
0C9FC:  INCF   x06,F
0C9FE:  BRA    CA26
0CA00:  MOVF   x00,W
0CA02:  IORLW  80
0CA04:  SUBWF  x05,F
0CA06:  BC    CA24
0CA08:  MOVLW  01
0CA0A:  SUBWF  x06,F
0CA0C:  BC    CA24
0CA0E:  INCF   x06,F
0CA10:  MOVF   x00,W
0CA12:  IORLW  80
0CA14:  ADDWF  x05,F
0CA16:  MOVF   x01,W
0CA18:  ADDWF  x04,F
0CA1A:  BNC   C9EE
0CA1C:  INCF   x05,F
0CA1E:  BNZ   C9EE
0CA20:  INCF   x06,F
0CA22:  BRA    C9EE
0CA24:  BSF    03.0
0CA26:  DECFSZ x07,F
0CA28:  BRA    CA2C
0CA2A:  BRA    CA42
0CA2C:  BCF    FD8.0
0CA2E:  RLCF   x03,F
0CA30:  RLCF   x04,F
0CA32:  RLCF   x05,F
0CA34:  RLCF   x06,F
0CA36:  BCF    FD8.0
0CA38:  RLCF   03,F
0CA3A:  RLCF   02,F
0CA3C:  RLCF   01,F
0CA3E:  RLCF   x08,F
0CA40:  BRA    C9B6
0CA42:  BTFSS  x08.0
0CA44:  BRA    CA52
0CA46:  BCF    FD8.0
0CA48:  RRCF   01,F
0CA4A:  RRCF   02,F
0CA4C:  RRCF   03,F
0CA4E:  RRCF   x08,F
0CA50:  BRA    CA5A
0CA52:  DECFSZ 00,F
0CA54:  BRA    CA5A
0CA56:  MOVLB  8
0CA58:  BRA    CACC
0CA5A:  BTFSC  x08.7
0CA5C:  BRA    CA9A
0CA5E:  BCF    FD8.0
0CA60:  RLCF   x03,F
0CA62:  RLCF   x04,F
0CA64:  RLCF   x05,F
0CA66:  RLCF   x06,F
0CA68:  MOVF   x02,W
0CA6A:  SUBWF  x03,F
0CA6C:  BC    CA7C
0CA6E:  MOVLW  01
0CA70:  SUBWF  x04,F
0CA72:  BC    CA7C
0CA74:  SUBWF  x05,F
0CA76:  BC    CA7C
0CA78:  SUBWF  x06,F
0CA7A:  BNC   CAB6
0CA7C:  MOVF   x01,W
0CA7E:  SUBWF  x04,F
0CA80:  BC    CA8C
0CA82:  MOVLW  01
0CA84:  SUBWF  x05,F
0CA86:  BC    CA8C
0CA88:  SUBWF  x06,F
0CA8A:  BNC   CAB6
0CA8C:  MOVF   x00,W
0CA8E:  IORLW  80
0CA90:  SUBWF  x05,F
0CA92:  BC    CA9A
0CA94:  MOVLW  01
0CA96:  SUBWF  x06,F
0CA98:  BNC   CAB6
0CA9A:  INCF   03,F
0CA9C:  BNZ   CAB6
0CA9E:  INCF   02,F
0CAA0:  BNZ   CAB6
0CAA2:  INCF   01,F
0CAA4:  BNZ   CAB6
0CAA6:  INCF   00,F
0CAA8:  BTFSS  FD8.2
0CAAA:  BRA    CAB0
0CAAC:  MOVLB  8
0CAAE:  BRA    CACC
0CAB0:  RRCF   01,F
0CAB2:  RRCF   02,F
0CAB4:  RRCF   03,F
0CAB6:  MOVFF  8FC,907
0CABA:  MOVF   x00,W
0CABC:  XORWF  x07,F
0CABE:  BTFSS  x07.7
0CAC0:  BRA    CAC6
0CAC2:  BSF    01.7
0CAC4:  BRA    CAD6
0CAC6:  BCF    01.7
0CAC8:  BRA    CAD6
0CACA:  MOVLB  8
0CACC:  CLRF   00
0CACE:  CLRF   01
0CAD0:  CLRF   02
0CAD2:  CLRF   03
0CAD4:  MOVLB  9
0CAD6:  MOVLB  0
0CAD8:  RETURN 0
*
0D56C:  MOVFF  FEA,8C9
0D570:  MOVFF  FE9,8C8
0D574:  MOVLB  8
0D576:  BTFSS  xC2.7
0D578:  BRA    D58A
0D57A:  BSF    xC8.7
0D57C:  BTFSS  xC8.4
0D57E:  INCF   xC8,F
0D580:  COMF   xC1,F
0D582:  COMF   xC2,F
0D584:  INCF   xC1,F
0D586:  BTFSC  FD8.2
0D588:  INCF   xC2,F
0D58A:  SWAPF  xC2,W
0D58C:  IORLW  F0
0D58E:  MOVWF  xC4
0D590:  ADDWF  xC4,F
0D592:  ADDLW  E2
0D594:  MOVWF  xC5
0D596:  ADDLW  32
0D598:  MOVWF  xC7
0D59A:  MOVF   xC2,W
0D59C:  ANDLW  0F
0D59E:  ADDWF  xC5,F
0D5A0:  ADDWF  xC5,F
0D5A2:  ADDWF  xC7,F
0D5A4:  ADDLW  E9
0D5A6:  MOVWF  xC6
0D5A8:  ADDWF  xC6,F
0D5AA:  ADDWF  xC6,F
0D5AC:  SWAPF  xC1,W
0D5AE:  ANDLW  0F
0D5B0:  ADDWF  xC6,F
0D5B2:  ADDWF  xC7,F
0D5B4:  RLCF   xC6,F
0D5B6:  RLCF   xC7,F
0D5B8:  COMF   xC7,F
0D5BA:  RLCF   xC7,F
0D5BC:  MOVF   xC1,W
0D5BE:  ANDLW  0F
0D5C0:  ADDWF  xC7,F
0D5C2:  RLCF   xC4,F
0D5C4:  MOVLW  07
0D5C6:  MOVWF  xC3
0D5C8:  MOVLW  0A
0D5CA:  DECF   xC6,F
0D5CC:  ADDWF  xC7,F
0D5CE:  BNC   D5CA
0D5D0:  DECF   xC5,F
0D5D2:  ADDWF  xC6,F
0D5D4:  BNC   D5D0
0D5D6:  DECF   xC4,F
0D5D8:  ADDWF  xC5,F
0D5DA:  BNC   D5D6
0D5DC:  DECF   xC3,F
0D5DE:  ADDWF  xC4,F
0D5E0:  BNC   D5DC
0D5E2:  MOVLW  08
0D5E4:  MOVWF  FEA
0D5E6:  MOVLW  C3
0D5E8:  MOVWF  FE9
0D5EA:  MOVLW  07
0D5EC:  ANDWF  xC8,W
0D5EE:  BCF    xC8.6
0D5F0:  MOVF   FED,F
0D5F2:  ANDWF  xC8,W
0D5F4:  BNZ   D604
0D5F6:  BTFSC  xC8.4
0D5F8:  MOVF   FEE,F
0D5FA:  BTFSC  xC8.4
0D5FC:  BRA    D604
0D5FE:  MOVLW  20
0D600:  MOVWF  00
0D602:  BRA    D646
0D604:  ADDWF  FE9,F
0D606:  MOVLW  00
0D608:  ADDWFC FEA,F
0D60A:  MOVF   FE9,W
0D60C:  SUBLW  C7
0D60E:  BNZ   D618
0D610:  MOVF   FEA,W
0D612:  SUBLW  08
0D614:  BNZ   D618
0D616:  BSF    xC8.6
0D618:  MOVF   FEF,W
0D61A:  MOVWF  00
0D61C:  BNZ   D62E
0D61E:  BTFSC  xC8.6
0D620:  BRA    D62E
0D622:  BTFSC  xC8.4
0D624:  BRA    D662
0D626:  BTFSC  xC8.3
0D628:  BRA    D62E
0D62A:  MOVLW  20
0D62C:  BRA    D644
0D62E:  BTFSS  xC8.7
0D630:  BRA    D63E
0D632:  MOVLW  2D
0D634:  MOVWF  00
0D636:  MOVF   FED,W
0D638:  BCF    xC8.6
0D63A:  BCF    xC8.7
0D63C:  BRA    D646
0D63E:  BSF    xC8.3
0D640:  BCF    xC8.4
0D642:  MOVLW  30
0D644:  ADDWF  00,F
0D646:  MOVFF  FEA,8C2
0D64A:  MOVFF  FE9,8C1
0D64E:  MOVFF  00,8FF
0D652:  MOVLB  0
0D654:  CALL   50C6
0D658:  MOVFF  8C2,FEA
0D65C:  MOVFF  8C1,FE9
0D660:  MOVLB  8
0D662:  MOVF   FEE,W
0D664:  BTFSS  xC8.6
0D666:  BRA    D60A
0D668:  MOVLB  0
0D66A:  GOTO   D78E (RETURN)
*
0DA12:  ADDWF  FE8,W
0DA14:  CLRF   FF7
0DA16:  RLCF   FF7,F
0DA18:  ADDLW  33
0DA1A:  MOVWF  FF6
0DA1C:  MOVLW  DA
0DA1E:  ADDWFC FF7,F
0DA20:  MOVLW  00
0DA22:  MOVWF  FF8
0DA24:  MOVWF  FFB
0DA26:  TBLRD*-
0DA28:  MOVF   FF5,W
0DA2A:  MOVWF  FFA
0DA2C:  TBLRD*
0DA2E:  MOVF   FF5,W
0DA30:  MOVWF  FF9
0DA32:  DATA 44,D9
0DA34:  DATA 6C,D9
0DA36:  DATA 8C,D9
0DA38:  DATA AC,D9
0DA3A:  DATA CC,D9
0DA3C:  DATA EC,D9
*
0DABC:  TBLRD*+
0DABE:  MOVFF  FF6,8B9
0DAC2:  MOVFF  FF7,8BA
0DAC6:  MOVFF  FF8,8BB
0DACA:  MOVF   FF5,W
0DACC:  BTFSS  FA4.4
0DACE:  BRA    DACC
0DAD0:  MOVLB  F
0DAD2:  MOVWF  x1C
0DAD4:  MOVFF  8B9,FF6
0DAD8:  MOVFF  8BA,FF7
0DADC:  MOVFF  8BB,FF8
0DAE0:  MOVLB  8
0DAE2:  DECFSZ xB8,F
0DAE4:  BRA    DAE8
0DAE6:  BRA    DAEC
0DAE8:  MOVLB  0
0DAEA:  BRA    DABC
0DAEC:  MOVLB  0
0DAEE:  RETURN 0
0DAF0:  MOVF   01,W
0DAF2:  CLRF   1B
0DAF4:  BTFSC  FF2.7
0DAF6:  BSF    1B.7
0DAF8:  BCF    FF2.7
0DAFA:  MOVFF  8F3,A42
0DAFE:  MOVLW  64
0DB00:  MOVLB  A
0DB02:  MOVWF  x43
0DB04:  MOVLB  0
0DB06:  CALL   0F9A
0DB0A:  BTFSC  1B.7
0DB0C:  BSF    FF2.7
0DB0E:  MOVFF  00,8F3
0DB12:  MOVF   01,W
0DB14:  MOVLW  30
0DB16:  BNZ   DB28
0DB18:  MOVLB  8
0DB1A:  BTFSS  xF4.1
0DB1C:  BRA    DB3E
0DB1E:  BTFSC  xF4.3
0DB20:  BRA    DB3E
0DB22:  BTFSC  xF4.4
0DB24:  MOVLW  20
0DB26:  BRA    DB30
0DB28:  MOVLB  8
0DB2A:  BCF    xF4.3
0DB2C:  BCF    xF4.4
0DB2E:  BSF    xF4.0
0DB30:  ADDWF  01,F
0DB32:  MOVF   01,W
0DB34:  BTFSS  FA4.4
0DB36:  BRA    DB34
0DB38:  MOVLB  F
0DB3A:  MOVWF  x1C
0DB3C:  MOVLB  8
0DB3E:  CLRF   1B
0DB40:  BTFSC  FF2.7
0DB42:  BSF    1B.7
0DB44:  BCF    FF2.7
0DB46:  MOVFF  8F3,A42
0DB4A:  MOVLW  0A
0DB4C:  MOVLB  A
0DB4E:  MOVWF  x43
0DB50:  MOVLB  0
0DB52:  CALL   0F9A
0DB56:  BTFSC  1B.7
0DB58:  BSF    FF2.7
0DB5A:  MOVFF  00,8F3
0DB5E:  MOVF   01,W
0DB60:  MOVLW  30
0DB62:  BNZ   DB74
0DB64:  MOVLB  8
0DB66:  BTFSC  xF4.3
0DB68:  BRA    DB82
0DB6A:  BTFSS  xF4.0
0DB6C:  BRA    DB82
0DB6E:  BTFSC  xF4.4
0DB70:  MOVLW  20
0DB72:  MOVLB  0
0DB74:  ADDWF  01,F
0DB76:  MOVF   01,W
0DB78:  BTFSS  FA4.4
0DB7A:  BRA    DB78
0DB7C:  MOVLB  F
0DB7E:  MOVWF  x1C
0DB80:  MOVLB  8
0DB82:  MOVLW  30
0DB84:  ADDWF  xF3,F
0DB86:  MOVF   xF3,W
0DB88:  BTFSS  FA4.4
0DB8A:  BRA    DB88
0DB8C:  MOVLB  F
0DB8E:  MOVWF  x1C
0DB90:  MOVLB  0
0DB92:  RETURN 0
*
0DBB6:  TBLRD*+
0DBB8:  MOVF   FF5,F
0DBBA:  BZ    DBE2
0DBBC:  MOVFF  FF6,8B7
0DBC0:  MOVFF  FF7,8B8
0DBC4:  MOVFF  FF8,8B9
0DBC8:  MOVF   FF5,W
0DBCA:  BTFSS  FA4.4
0DBCC:  BRA    DBCA
0DBCE:  MOVLB  F
0DBD0:  MOVWF  x1C
0DBD2:  MOVFF  8B7,FF6
0DBD6:  MOVFF  8B8,FF7
0DBDA:  MOVFF  8B9,FF8
0DBDE:  MOVLB  0
0DBE0:  BRA    DBB6
0DBE2:  GOTO   DCA4 (RETURN)
*
0E1BE:  MOVF   FE9,W
0E1C0:  MOVLB  8
0E1C2:  MOVWF  x8C
0E1C4:  MOVLW  3B
0E1C6:  MOVWF  x93
0E1C8:  MOVLW  9A
0E1CA:  MOVWF  x92
0E1CC:  MOVLW  CA
0E1CE:  MOVWF  x91
0E1D0:  CLRF   x90
0E1D2:  MOVLW  0A
0E1D4:  MOVWF  x8E
0E1D6:  MOVF   x8B,W
0E1D8:  BTFSS  FD8.2
0E1DA:  DECF   x8C,F
0E1DC:  BSF    FD8.1
0E1DE:  MOVLW  08
0E1E0:  MOVWF  FEA
0E1E2:  MOVLW  87
0E1E4:  MOVWF  FE9
0E1E6:  CLRF   1B
0E1E8:  BTFSC  FF2.7
0E1EA:  BSF    1B.7
0E1EC:  BCF    FF2.7
0E1EE:  MOVFF  88A,A4F
0E1F2:  MOVFF  889,A4E
0E1F6:  MOVFF  888,A4D
0E1FA:  MOVFF  887,A4C
0E1FE:  MOVFF  893,A53
0E202:  MOVFF  892,A52
0E206:  MOVFF  891,A51
0E20A:  MOVFF  890,A50
0E20E:  MOVLB  0
0E210:  CALL   1076
0E214:  BTFSC  1B.7
0E216:  BSF    FF2.7
0E218:  MOVF   01,W
0E21A:  MOVF   00,F
0E21C:  BNZ   E244
0E21E:  MOVLB  8
0E220:  INCF   x8B,W
0E222:  SUBWF  x8E,W
0E224:  BTFSS  FD8.2
0E226:  BRA    E22C
0E228:  MOVLB  0
0E22A:  BRA    E244
0E22C:  MOVF   x8C,W
0E22E:  BZ    E248
0E230:  ANDLW  0F
0E232:  SUBWF  x8E,W
0E234:  BZ    E238
0E236:  BC    E270
0E238:  BTFSC  x8C.7
0E23A:  BRA    E270
0E23C:  BTFSC  x8C.6
0E23E:  BRA    E248
0E240:  MOVLW  20
0E242:  BRA    E266
0E244:  MOVLB  8
0E246:  CLRF   x8C
0E248:  MOVF   x8B,W
0E24A:  SUBWF  x8E,W
0E24C:  BNZ   E264
0E24E:  MOVFF  00,88C
0E252:  MOVLW  2E
0E254:  BTFSS  F9E.4
0E256:  BRA    E254
0E258:  MOVWF  FAD
0E25A:  MOVFF  88C,00
0E25E:  MOVLW  20
0E260:  ANDWF  x8C,F
0E262:  MOVLW  00
0E264:  MOVLW  30
0E266:  ADDWF  00,F
0E268:  MOVF   00,W
0E26A:  BTFSS  F9E.4
0E26C:  BRA    E26A
0E26E:  MOVWF  FAD
0E270:  BCF    FD8.1
0E272:  CLRF   1B
0E274:  BTFSC  FF2.7
0E276:  BSF    1B.7
0E278:  BCF    FF2.7
0E27A:  MOVFF  893,A4F
0E27E:  MOVFF  892,A4E
0E282:  MOVFF  891,A4D
0E286:  MOVFF  890,A4C
0E28A:  MOVLB  A
0E28C:  CLRF   x53
0E28E:  CLRF   x52
0E290:  CLRF   x51
0E292:  MOVLW  0A
0E294:  MOVWF  x50
0E296:  MOVLB  0
0E298:  CALL   1076
0E29C:  BTFSC  1B.7
0E29E:  BSF    FF2.7
0E2A0:  MOVFF  03,893
0E2A4:  MOVFF  02,892
0E2A8:  MOVFF  01,891
0E2AC:  MOVFF  00,890
0E2B0:  MOVLB  8
0E2B2:  DECFSZ x8E,F
0E2B4:  BRA    E1DC
0E2B6:  MOVLB  0
0E2B8:  RETURN 0
*
0F352:  MOVF   FE9,W
0F354:  MOVLB  8
0F356:  MOVWF  xF7
0F358:  MOVLW  3B
0F35A:  MOVWF  xFE
0F35C:  MOVLW  9A
0F35E:  MOVWF  xFD
0F360:  MOVLW  CA
0F362:  MOVWF  xFC
0F364:  CLRF   xFB
0F366:  MOVLW  0A
0F368:  MOVWF  xF9
0F36A:  BSF    FD8.1
0F36C:  MOVLW  08
0F36E:  MOVWF  FEA
0F370:  MOVLW  F3
0F372:  MOVWF  FE9
0F374:  CLRF   1B
0F376:  BTFSC  FF2.7
0F378:  BSF    1B.7
0F37A:  BCF    FF2.7
0F37C:  MOVFF  8F6,A4F
0F380:  MOVFF  8F5,A4E
0F384:  MOVFF  8F4,A4D
0F388:  MOVFF  8F3,A4C
0F38C:  MOVFF  8FE,A53
0F390:  MOVFF  8FD,A52
0F394:  MOVFF  8FC,A51
0F398:  MOVFF  8FB,A50
0F39C:  MOVLB  0
0F39E:  CALL   1076
0F3A2:  BTFSC  1B.7
0F3A4:  BSF    FF2.7
0F3A6:  MOVF   01,W
0F3A8:  MOVF   00,F
0F3AA:  BNZ   F3D2
0F3AC:  MOVLB  8
0F3AE:  MOVF   xF9,W
0F3B0:  XORLW  01
0F3B2:  BTFSS  FD8.2
0F3B4:  BRA    F3BA
0F3B6:  MOVLB  0
0F3B8:  BRA    F3D2
0F3BA:  MOVF   xF7,W
0F3BC:  BZ    F3D6
0F3BE:  ANDLW  0F
0F3C0:  SUBWF  xF9,W
0F3C2:  BZ    F3C6
0F3C4:  BC    F3E6
0F3C6:  BTFSC  xF7.7
0F3C8:  BRA    F3E6
0F3CA:  BTFSC  xF7.6
0F3CC:  BRA    F3D6
0F3CE:  MOVLW  20
0F3D0:  BRA    F3D8
0F3D2:  MOVLB  8
0F3D4:  CLRF   xF7
0F3D6:  MOVLW  30
0F3D8:  ADDWF  00,F
0F3DA:  MOVF   00,W
0F3DC:  BTFSS  FA4.4
0F3DE:  BRA    F3DC
0F3E0:  MOVLB  F
0F3E2:  MOVWF  x1C
0F3E4:  MOVLB  8
0F3E6:  BCF    FD8.1
0F3E8:  CLRF   1B
0F3EA:  BTFSC  FF2.7
0F3EC:  BSF    1B.7
0F3EE:  BCF    FF2.7
0F3F0:  MOVFF  8FE,A4F
0F3F4:  MOVFF  8FD,A4E
0F3F8:  MOVFF  8FC,A4D
0F3FC:  MOVFF  8FB,A4C
0F400:  MOVLB  A
0F402:  CLRF   x53
0F404:  CLRF   x52
0F406:  CLRF   x51
0F408:  MOVLW  0A
0F40A:  MOVWF  x50
0F40C:  MOVLB  0
0F40E:  CALL   1076
0F412:  BTFSC  1B.7
0F414:  BSF    FF2.7
0F416:  MOVFF  03,8FE
0F41A:  MOVFF  02,8FD
0F41E:  MOVFF  01,8FC
0F422:  MOVFF  00,8FB
0F426:  MOVLB  8
0F428:  DECFSZ xF9,F
0F42A:  BRA    F36A
0F42C:  MOVLB  0
0F42E:  GOTO   F558 (RETURN)
*
0F628:  ADDWF  FE8,W
0F62A:  CLRF   FF7
0F62C:  RLCF   FF7,F
0F62E:  ADDLW  49
0F630:  MOVWF  FF6
0F632:  MOVLW  F6
0F634:  ADDWFC FF7,F
0F636:  MOVLW  00
0F638:  MOVWF  FF8
0F63A:  MOVWF  FFB
0F63C:  TBLRD*-
0F63E:  MOVF   FF5,W
0F640:  MOVWF  FFA
0F642:  TBLRD*
0F644:  MOVF   FF5,W
0F646:  MOVWF  FF9
0F648:  DATA E8,F5
0F64A:  DATA F0,F5
0F64C:  DATA F8,F5
0F64E:  DATA 00,F6
*
0FE6C:  MOVF   FEF,F
0FE6E:  BZ    FE90
0FE70:  MOVFF  FEA,8EC
0FE74:  MOVFF  FE9,8EB
0FE78:  MOVFF  FEF,8FF
0FE7C:  CALL   50C6
0FE80:  MOVFF  8EC,FEA
0FE84:  MOVFF  8EB,FE9
0FE88:  INCF   FE9,F
0FE8A:  BTFSC  FD8.2
0FE8C:  INCF   FEA,F
0FE8E:  BRA    FE6C
0FE90:  RETURN 0
0FE92:  MOVFF  FEA,FE2
0FE96:  MOVFF  FE9,FE1
0FE9A:  CLRF   01
0FE9C:  BSF    00.0
0FE9E:  TBLRD*+
0FEA0:  MOVF   FF5,W
0FEA2:  BTFSS  00.0
0FEA4:  BRA    FEB0
0FEA6:  SUBWF  FEE,W
0FEA8:  BNZ   FEB0
0FEAA:  MOVF   FF5,F
0FEAC:  BNZ   FE9E
0FEAE:  BRA    FECA
0FEB0:  BCF    00.0
0FEB2:  MOVF   FF5,F
0FEB4:  BNZ   FE9E
0FEB6:  INCF   01,F
0FEB8:  BSF    00.0
0FEBA:  MOVFF  FE2,FEA
0FEBE:  MOVFF  FE1,FE9
0FEC2:  TBLRD*
0FEC4:  MOVF   FF5,F
0FEC6:  BNZ   FE9E
0FEC8:  SETF   01
0FECA:  RETURN 0
*
107B8:  MOVFF  914,91B
107BC:  MOVLB  9
107BE:  MOVF   x18,W
107C0:  XORWF  x1B,F
107C2:  BTFSS  x1B.7
107C4:  BRA    107D0
107C6:  BCF    FD8.2
107C8:  BCF    FD8.0
107CA:  BTFSC  x14.7
107CC:  BSF    FD8.0
107CE:  BRA    1082E
107D0:  MOVFF  914,91B
107D4:  MOVFF  917,91C
107D8:  MOVF   x13,W
107DA:  SUBWF  x1C,F
107DC:  BZ    107EA
107DE:  BTFSS  x1B.7
107E0:  BRA    1082E
107E2:  MOVF   FD8,W
107E4:  XORLW  01
107E6:  MOVWF  FD8
107E8:  BRA    1082E
107EA:  MOVFF  918,91C
107EE:  MOVF   x14,W
107F0:  SUBWF  x1C,F
107F2:  BZ    10800
107F4:  BTFSS  x1B.7
107F6:  BRA    1082E
107F8:  MOVF   FD8,W
107FA:  XORLW  01
107FC:  MOVWF  FD8
107FE:  BRA    1082E
10800:  MOVFF  919,91C
10804:  MOVF   x15,W
10806:  SUBWF  x1C,F
10808:  BZ    10816
1080A:  BTFSS  x1B.7
1080C:  BRA    1082E
1080E:  MOVF   FD8,W
10810:  XORLW  01
10812:  MOVWF  FD8
10814:  BRA    1082E
10816:  MOVFF  91A,91C
1081A:  MOVF   x16,W
1081C:  SUBWF  x1C,F
1081E:  BZ    1082C
10820:  BTFSS  x1B.7
10822:  BRA    1082E
10824:  MOVF   FD8,W
10826:  XORLW  01
10828:  MOVWF  FD8
1082A:  BRA    1082E
1082C:  BCF    FD8.0
1082E:  MOVLB  0
10830:  RETURN 0
10832:  MOVLW  8E
10834:  MOVWF  00
10836:  MOVFF  8ED,01
1083A:  MOVFF  8EC,02
1083E:  CLRF   03
10840:  BTFSS  01.7
10842:  BRA    1084E
10844:  COMF   01,F
10846:  COMF   02,F
10848:  INCF   02,F
1084A:  BNZ   1084E
1084C:  INCF   01,F
1084E:  MOVF   01,F
10850:  BNZ   10864
10852:  MOVFF  02,01
10856:  CLRF   02
10858:  MOVLW  08
1085A:  SUBWF  00,F
1085C:  MOVF   01,F
1085E:  BNZ   10864
10860:  CLRF   00
10862:  BRA    10880
10864:  BCF    FD8.0
10866:  BTFSC  01.7
10868:  BRA    10872
1086A:  RLCF   02,F
1086C:  RLCF   01,F
1086E:  DECF   00,F
10870:  BRA    10864
10872:  MOVLB  8
10874:  BTFSS  xED.7
10876:  BRA    1087C
10878:  MOVLB  0
1087A:  BRA    10880
1087C:  BCF    01.7
1087E:  MOVLB  0
10880:  RETURN 0
*
10C82:  MOVF   FE9,W
10C84:  MOVLB  8
10C86:  MOVWF  xD4
10C88:  MOVF   xD3,W
10C8A:  MOVWF  xD6
10C8C:  BZ    10CC8
10C8E:  MOVFF  8D2,916
10C92:  MOVFF  8D1,915
10C96:  MOVFF  8D0,914
10C9A:  MOVFF  8CF,913
10C9E:  MOVLB  9
10CA0:  CLRF   x1A
10CA2:  CLRF   x19
10CA4:  MOVLW  20
10CA6:  MOVWF  x18
10CA8:  MOVLW  82
10CAA:  MOVWF  x17
10CAC:  MOVLB  0
10CAE:  CALL   C2F4
10CB2:  MOVFF  03,8D2
10CB6:  MOVFF  02,8D1
10CBA:  MOVFF  01,8D0
10CBE:  MOVFF  00,8CF
10CC2:  MOVLB  8
10CC4:  DECFSZ xD6,F
10CC6:  BRA    10C8E
10CC8:  MOVLW  7E
10CCA:  MOVWF  00
10CCC:  CLRF   01
10CCE:  BTFSC  xD0.7
10CD0:  BSF    01.7
10CD2:  CLRF   02
10CD4:  CLRF   03
10CD6:  BCF    FD8.1
10CD8:  MOVFF  8D2,91A
10CDC:  MOVFF  8D1,919
10CE0:  MOVFF  8D0,918
10CE4:  MOVFF  8CF,917
10CE8:  MOVFF  03,91E
10CEC:  MOVFF  02,91D
10CF0:  MOVFF  01,91C
10CF4:  MOVFF  FE8,91B
10CF8:  MOVLB  0
10CFA:  CALL   C3EA
10CFE:  MOVFF  03,8D2
10D02:  MOVFF  02,8D1
10D06:  MOVFF  01,8D0
10D0A:  MOVFF  00,8CF
10D0E:  MOVFF  8D2,8DF
10D12:  MOVFF  8D1,8DE
10D16:  MOVFF  8D0,8DD
10D1A:  MOVFF  8CF,8DC
10D1E:  CALL   C662
10D22:  MOVFF  03,8D2
10D26:  MOVFF  02,8D1
10D2A:  MOVFF  01,8D0
10D2E:  MOVFF  00,8CF
10D32:  MOVLB  8
10D34:  BTFSS  xD2.7
10D36:  BRA    10D52
10D38:  DECF   xD4,F
10D3A:  BSF    xD4.5
10D3C:  COMF   xCF,F
10D3E:  COMF   xD0,F
10D40:  COMF   xD1,F
10D42:  COMF   xD2,F
10D44:  INCF   xCF,F
10D46:  BTFSC  FD8.2
10D48:  INCF   xD0,F
10D4A:  BTFSC  FD8.2
10D4C:  INCF   xD1,F
10D4E:  BTFSC  FD8.2
10D50:  INCF   xD2,F
10D52:  MOVLW  3B
10D54:  MOVWF  xDB
10D56:  MOVLW  9A
10D58:  MOVWF  xDA
10D5A:  MOVLW  CA
10D5C:  MOVWF  xD9
10D5E:  CLRF   xD8
10D60:  MOVLW  0A
10D62:  MOVWF  xD6
10D64:  MOVF   xD3,W
10D66:  BTFSC  FD8.2
10D68:  INCF   xD4,F
10D6A:  BSF    FD8.1
10D6C:  MOVLW  08
10D6E:  MOVWF  FEA
10D70:  MOVLW  CF
10D72:  MOVWF  FE9
10D74:  CLRF   1B
10D76:  BTFSC  FF2.7
10D78:  BSF    1B.7
10D7A:  BCF    FF2.7
10D7C:  MOVFF  8D2,A4F
10D80:  MOVFF  8D1,A4E
10D84:  MOVFF  8D0,A4D
10D88:  MOVFF  8CF,A4C
10D8C:  MOVFF  8DB,A53
10D90:  MOVFF  8DA,A52
10D94:  MOVFF  8D9,A51
10D98:  MOVFF  8D8,A50
10D9C:  MOVLB  0
10D9E:  CALL   1076
10DA2:  BTFSC  1B.7
10DA4:  BSF    FF2.7
10DA6:  MOVF   01,W
10DA8:  MOVF   00,F
10DAA:  BNZ   10DD2
10DAC:  MOVLB  8
10DAE:  INCF   xD3,W
10DB0:  SUBWF  xD6,W
10DB2:  BTFSS  FD8.2
10DB4:  BRA    10DBA
10DB6:  MOVLB  0
10DB8:  BRA    10DD2
10DBA:  MOVF   xD4,W
10DBC:  BZ    10DD8
10DBE:  ANDLW  0F
10DC0:  SUBWF  xD6,W
10DC2:  BZ    10DC6
10DC4:  BC    10E4E
10DC6:  BTFSC  xD4.7
10DC8:  BRA    10E4E
10DCA:  BTFSC  xD4.6
10DCC:  BRA    10DD8
10DCE:  MOVLW  20
10DD0:  BRA    10E40
10DD2:  MOVLW  20
10DD4:  MOVLB  8
10DD6:  ANDWF  xD4,F
10DD8:  BTFSS  xD4.5
10DDA:  BRA    10DFA
10DDC:  BCF    xD4.5
10DDE:  MOVF   xD3,W
10DE0:  BTFSS  FD8.2
10DE2:  DECF   xD4,F
10DE4:  MOVF   00,W
10DE6:  MOVWF  xD4
10DE8:  MOVLW  2D
10DEA:  MOVWF  xFF
10DEC:  MOVLB  0
10DEE:  CALL   50C6
10DF2:  MOVLB  8
10DF4:  MOVF   xD4,W
10DF6:  MOVWF  00
10DF8:  CLRF   xD4
10DFA:  MOVF   xD3,W
10DFC:  SUBWF  xD6,W
10DFE:  BNZ   10E1A
10E00:  MOVF   00,W
10E02:  MOVWF  xD4
10E04:  MOVLW  2E
10E06:  MOVWF  xFF
10E08:  MOVLB  0
10E0A:  CALL   50C6
10E0E:  MOVLB  8
10E10:  MOVF   xD4,W
10E12:  MOVWF  00
10E14:  MOVLW  20
10E16:  ANDWF  xD4,F
10E18:  MOVLW  00
10E1A:  MOVLW  30
10E1C:  BTFSS  xD4.5
10E1E:  BRA    10E40
10E20:  BCF    xD4.5
10E22:  MOVF   xD3,W
10E24:  BTFSS  FD8.2
10E26:  DECF   xD4,F
10E28:  MOVF   00,W
10E2A:  MOVWF  xD4
10E2C:  MOVLW  2D
10E2E:  MOVWF  xFF
10E30:  MOVLB  0
10E32:  CALL   50C6
10E36:  MOVLB  8
10E38:  MOVF   xD4,W
10E3A:  MOVWF  00
10E3C:  CLRF   xD4
10E3E:  MOVLW  30
10E40:  ADDWF  00,F
10E42:  MOVFF  00,8FF
10E46:  MOVLB  0
10E48:  CALL   50C6
10E4C:  MOVLB  8
10E4E:  BCF    FD8.1
10E50:  CLRF   1B
10E52:  BTFSC  FF2.7
10E54:  BSF    1B.7
10E56:  BCF    FF2.7
10E58:  MOVFF  8DB,A4F
10E5C:  MOVFF  8DA,A4E
10E60:  MOVFF  8D9,A4D
10E64:  MOVFF  8D8,A4C
10E68:  MOVLB  A
10E6A:  CLRF   x53
10E6C:  CLRF   x52
10E6E:  CLRF   x51
10E70:  MOVLW  0A
10E72:  MOVWF  x50
10E74:  MOVLB  0
10E76:  CALL   1076
10E7A:  BTFSC  1B.7
10E7C:  BSF    FF2.7
10E7E:  MOVFF  03,8DB
10E82:  MOVFF  02,8DA
10E86:  MOVFF  01,8D9
10E8A:  MOVFF  00,8D8
10E8E:  MOVLB  8
10E90:  DECFSZ xD6,F
10E92:  BRA    10D6A
10E94:  MOVLB  0
10E96:  RETURN 0
*
1279A:  ADDWF  FE8,W
1279C:  CLRF   FF7
1279E:  RLCF   FF7,F
127A0:  ADDLW  BB
127A2:  MOVWF  FF6
127A4:  MOVLW  27
127A6:  ADDWFC FF7,F
127A8:  MOVLW  01
127AA:  MOVWF  FF8
127AC:  MOVWF  FFB
127AE:  TBLRD*-
127B0:  MOVF   FF5,W
127B2:  MOVWF  FFA
127B4:  TBLRD*
127B6:  MOVF   FF5,W
127B8:  MOVWF  FF9
127BA:  DATA 5E,27
127BC:  DATA 66,27
127BE:  DATA 6C,27
127C0:  DATA 72,27
*
1283C:  MOVLW  8E
1283E:  MOVWF  00
12840:  MOVLB  9
12842:  MOVF   x13,W
12844:  SUBWF  00,F
12846:  MOVFF  914,02
1284A:  MOVFF  915,01
1284E:  BSF    02.7
12850:  MOVF   00,F
12852:  BZ    12866
12854:  BCF    FD8.0
12856:  MOVF   02,F
12858:  BNZ   1285E
1285A:  MOVF   01,F
1285C:  BZ    12866
1285E:  RRCF   02,F
12860:  RRCF   01,F
12862:  DECFSZ 00,F
12864:  BRA    12854
12866:  BTFSS  x14.7
12868:  BRA    12874
1286A:  COMF   01,F
1286C:  COMF   02,F
1286E:  INCF   01,F
12870:  BTFSC  FD8.2
12872:  INCF   02,F
12874:  MOVLB  0
12876:  RETURN 0
*
13336:  ADDWF  FE8,W
13338:  CLRF   FF7
1333A:  RLCF   FF7,F
1333C:  ADDLW  57
1333E:  MOVWF  FF6
13340:  MOVLW  33
13342:  ADDWFC FF7,F
13344:  MOVLW  01
13346:  MOVWF  FF8
13348:  MOVWF  FFB
1334A:  TBLRD*-
1334C:  MOVF   FF5,W
1334E:  MOVWF  FFA
13350:  TBLRD*
13352:  MOVF   FF5,W
13354:  MOVWF  FF9
13356:  DATA 72,31
13358:  DATA 78,31
1335A:  DATA 96,31
1335C:  DATA B4,31
*
133CE:  MOVLB  8
133D0:  MOVF   xDD,W
133D2:  XORWF  xDF,W
133D4:  ANDLW  80
133D6:  MOVWF  xE1
133D8:  BTFSS  xDD.7
133DA:  BRA    133E6
133DC:  COMF   xDC,F
133DE:  COMF   xDD,F
133E0:  INCF   xDC,F
133E2:  BTFSC  FD8.2
133E4:  INCF   xDD,F
133E6:  BTFSS  xDF.7
133E8:  BRA    133F4
133EA:  COMF   xDE,F
133EC:  COMF   xDF,F
133EE:  INCF   xDE,F
133F0:  BTFSC  FD8.2
133F2:  INCF   xDF,F
133F4:  MOVF   xDC,W
133F6:  MULWF  xDE
133F8:  MOVFF  FF3,01
133FC:  MOVFF  FF4,00
13400:  MULWF  xDF
13402:  MOVF   FF3,W
13404:  ADDWF  00,F
13406:  MOVF   xDD,W
13408:  MULWF  xDE
1340A:  MOVF   FF3,W
1340C:  ADDWFC 00,W
1340E:  MOVWF  02
13410:  BTFSS  xE1.7
13412:  BRA    1341E
13414:  COMF   01,F
13416:  COMF   02,F
13418:  INCF   01,F
1341A:  BTFSC  FD8.2
1341C:  INCF   02,F
1341E:  MOVLB  0
13420:  GOTO   134FE (RETURN)
*
142BC:  ADDWF  FE8,W
142BE:  CLRF   FF7
142C0:  RLCF   FF7,F
142C2:  ADDLW  DD
142C4:  MOVWF  FF6
142C6:  MOVLW  42
142C8:  ADDWFC FF7,F
142CA:  MOVLW  01
142CC:  MOVWF  FF8
142CE:  MOVWF  FFB
142D0:  TBLRD*-
142D2:  MOVF   FF5,W
142D4:  MOVWF  FFA
142D6:  TBLRD*
142D8:  MOVF   FF5,W
142DA:  MOVWF  FF9
142DC:  DATA 72,41
142DE:  DATA B0,42
142E0:  DATA 9E,41
142E2:  DATA B0,42
142E4:  DATA 68,40
142E6:  DATA B0,42
142E8:  DATA B0,42
142EA:  DATA B0,42
142EC:  DATA B0,42
142EE:  DATA B0,42
142F0:  DATA B0,42
142F2:  DATA B0,42
142F4:  DATA B0,42
142F6:  DATA B0,42
142F8:  DATA B0,42
142FA:  DATA B0,42
142FC:  DATA A8,42
142FE:  DATA B0,42
14300:  DATA B0,42
14302:  DATA B0,42
14304:  DATA B0,42
14306:  DATA B0,42
14308:  DATA 08,40
1430A:  DATA B0,42
1430C:  DATA 3C,40
1430E:  DATA 44,40
14310:  DATA B0,42
14312:  DATA 58,40
14314:  DATA CA,41
14316:  DATA 8C,40
14318:  DATA B0,42
1431A:  DATA B0,42
1431C:  DATA 1E,41
1431E:  DATA 00,41
14320:  DATA B0,42
14322:  DATA B0,42
14324:  DATA B0,42
14326:  DATA E4,41
14328:  DATA 10,42
1432A:  DATA 3C,42
1432C:  DATA 3A,41
1432E:  DATA 68,41
14330:  DATA B0,42
14332:  DATA B0,42
14334:  DATA B0,42
14336:  DATA B0,42
14338:  DATA 68,42
1433A:  DATA B0,42
1433C:  DATA B0,42
1433E:  DATA B0,42
14340:  DATA B0,42
14342:  DATA B0,42
14344:  DATA B0,42
14346:  DATA B0,42
14348:  DATA B0,42
1434A:  DATA B0,42
1434C:  DATA B0,42
1434E:  DATA 74,40
14350:  DATA B0,42
14352:  DATA B0,42
14354:  DATA B0,42
14356:  DATA B0,42
14358:  DATA A4,40
1435A:  DATA B0,42
1435C:  DATA B0,42
1435E:  DATA CA,40
14360:  DATA B0,42
14362:  DATA B0,42
14364:  DATA B0,42
14366:  DATA 18,40
14368:  DATA B0,42
1436A:  DATA B0,42
1436C:  DATA B0,42
1436E:  DATA B0,42
14370:  DATA B0,42
14372:  DATA 92,42
*
14428:  MOVFF  FEA,8C0
1442C:  MOVFF  FE9,8BF
14430:  MOVLB  8
14432:  SWAPF  xB9,W
14434:  IORLW  F0
14436:  MOVWF  xBB
14438:  ADDWF  xBB,F
1443A:  ADDLW  E2
1443C:  MOVWF  xBC
1443E:  ADDLW  32
14440:  MOVWF  xBE
14442:  MOVF   xB9,W
14444:  ANDLW  0F
14446:  ADDWF  xBC,F
14448:  ADDWF  xBC,F
1444A:  ADDWF  xBE,F
1444C:  ADDLW  E9
1444E:  MOVWF  xBD
14450:  ADDWF  xBD,F
14452:  ADDWF  xBD,F
14454:  SWAPF  xB8,W
14456:  ANDLW  0F
14458:  ADDWF  xBD,F
1445A:  ADDWF  xBE,F
1445C:  RLCF   xBD,F
1445E:  RLCF   xBE,F
14460:  COMF   xBE,F
14462:  RLCF   xBE,F
14464:  MOVF   xB8,W
14466:  ANDLW  0F
14468:  ADDWF  xBE,F
1446A:  RLCF   xBB,F
1446C:  MOVLW  07
1446E:  MOVWF  xBA
14470:  MOVLW  0A
14472:  DECF   xBD,F
14474:  ADDWF  xBE,F
14476:  BNC   14472
14478:  DECF   xBC,F
1447A:  ADDWF  xBD,F
1447C:  BNC   14478
1447E:  DECF   xBB,F
14480:  ADDWF  xBC,F
14482:  BNC   1447E
14484:  DECF   xBA,F
14486:  ADDWF  xBB,F
14488:  BNC   14484
1448A:  MOVLW  08
1448C:  MOVWF  FEA
1448E:  MOVLW  BA
14490:  MOVWF  FE9
14492:  MOVLW  07
14494:  ANDWF  xBF,W
14496:  BCF    xBF.6
14498:  ADDWF  FE9,F
1449A:  MOVLW  00
1449C:  ADDWFC FEA,F
1449E:  MOVF   FE9,W
144A0:  SUBLW  BE
144A2:  BNZ   144AC
144A4:  MOVF   FEA,W
144A6:  SUBLW  08
144A8:  BNZ   144AC
144AA:  BSF    xBF.6
144AC:  MOVF   FEF,W
144AE:  MOVWF  00
144B0:  BNZ   144C2
144B2:  BTFSC  xBF.6
144B4:  BRA    144C2
144B6:  BTFSC  xBF.4
144B8:  BRA    144D6
144BA:  BTFSC  xBF.3
144BC:  BRA    144C2
144BE:  MOVLW  20
144C0:  BRA    144C8
144C2:  BSF    xBF.3
144C4:  BCF    xBF.4
144C6:  MOVLW  30
144C8:  ADDWF  00,F
144CA:  MOVF   00,W
144CC:  BTFSS  FA4.4
144CE:  BRA    144CC
144D0:  MOVLB  F
144D2:  MOVWF  x1C
144D4:  MOVLB  8
144D6:  MOVF   FEE,W
144D8:  BTFSS  xBF.6
144DA:  BRA    1449E
144DC:  MOVLB  0
144DE:  GOTO   1457A (RETURN)
*
149BE:  ADDWF  FE8,W
149C0:  CLRF   FF7
149C2:  RLCF   FF7,F
149C4:  ADDLW  DF
149C6:  MOVWF  FF6
149C8:  MOVLW  49
149CA:  ADDWFC FF7,F
149CC:  MOVLW  01
149CE:  MOVWF  FF8
149D0:  MOVWF  FFB
149D2:  TBLRD*-
149D4:  MOVF   FF5,W
149D6:  MOVWF  FFA
149D8:  TBLRD*
149DA:  MOVF   FF5,W
149DC:  MOVWF  FF9
149DE:  DATA AA,45
149E0:  DATA 0A,46
149E2:  DATA 26,46
149E4:  DATA 42,46
149E6:  DATA 5E,46
149E8:  DATA 7A,46
149EA:  DATA 96,46
149EC:  DATA B2,46
149EE:  DATA CE,46
149F0:  DATA EA,46
149F2:  DATA 06,47
149F4:  DATA 22,47
149F6:  DATA 3E,47
149F8:  DATA 5A,47
149FA:  DATA 76,47
149FC:  DATA 92,47
149FE:  DATA AE,47
14A00:  DATA CA,47
14A02:  DATA E6,47
14A04:  DATA 02,48
14A06:  DATA 1E,48
14A08:  DATA 3A,48
14A0A:  DATA 56,48
14A0C:  DATA 72,48
14A0E:  DATA 8E,48
14A10:  DATA AA,48
14A12:  DATA C6,48
14A14:  DATA E2,48
14A16:  DATA FE,48
14A18:  DATA 1A,49
14A1A:  DATA 36,49
14A1C:  DATA 52,49
14A1E:  DATA 6E,49
*
1520C:  ADDWF  FE8,W
1520E:  CLRF   FF7
15210:  RLCF   FF7,F
15212:  ADDLW  2D
15214:  MOVWF  FF6
15216:  MOVLW  52
15218:  ADDWFC FF7,F
1521A:  MOVLW  01
1521C:  MOVWF  FF8
1521E:  MOVWF  FFB
15220:  TBLRD*-
15222:  MOVF   FF5,W
15224:  MOVWF  FFA
15226:  TBLRD*
15228:  MOVF   FF5,W
1522A:  MOVWF  FF9
1522C:  DATA 00,4E
1522E:  DATA 40,4F
15230:  DATA 2C,4E
15232:  DATA 40,4F
15234:  DATA F2,4C
15236:  DATA 40,4F
15238:  DATA 40,4F
1523A:  DATA 40,4F
1523C:  DATA 40,4F
1523E:  DATA 40,4F
15240:  DATA 40,4F
15242:  DATA 40,4F
15244:  DATA 40,4F
15246:  DATA 40,4F
15248:  DATA 40,4F
1524A:  DATA 40,4F
1524C:  DATA 38,4F
1524E:  DATA 40,4F
15250:  DATA 40,4F
15252:  DATA 40,4F
15254:  DATA 40,4F
15256:  DATA 40,4F
15258:  DATA FC,4A
1525A:  DATA 40,4F
1525C:  DATA 30,4B
1525E:  DATA CE,4C
15260:  DATA 40,4F
15262:  DATA E2,4C
15264:  DATA 58,4E
15266:  DATA 16,4D
15268:  DATA 40,4F
1526A:  DATA 40,4F
1526C:  DATA A8,4D
1526E:  DATA 8A,4D
15270:  DATA 40,4F
15272:  DATA 40,4F
15274:  DATA 40,4F
15276:  DATA 72,4E
15278:  DATA 9E,4E
1527A:  DATA CA,4E
1527C:  DATA C4,4D
1527E:  DATA F4,4D
15280:  DATA 40,4F
15282:  DATA 40,4F
15284:  DATA 40,4F
15286:  DATA 40,4F
15288:  DATA F6,4E
1528A:  DATA 40,4F
1528C:  DATA 40,4F
1528E:  DATA 40,4F
15290:  DATA 40,4F
15292:  DATA 40,4F
15294:  DATA 40,4F
15296:  DATA 40,4F
15298:  DATA 40,4F
1529A:  DATA 40,4F
1529C:  DATA 40,4F
1529E:  DATA FE,4C
152A0:  DATA 40,4F
152A2:  DATA 40,4F
152A4:  DATA 40,4F
152A6:  DATA 40,4F
152A8:  DATA 2E,4D
152AA:  DATA 40,4F
152AC:  DATA 40,4F
152AE:  DATA 54,4D
152B0:  DATA 40,4F
152B2:  DATA 40,4F
152B4:  DATA 40,4F
152B6:  DATA 0C,4B
152B8:  DATA 40,4F
152BA:  DATA 38,4B
152BC:  DATA 40,4F
152BE:  DATA 40,4F
152C0:  DATA 40,4F
152C2:  DATA 20,4F
*
15726:  ADDWF  FE8,W
15728:  CLRF   FF7
1572A:  RLCF   FF7,F
1572C:  ADDLW  47
1572E:  MOVWF  FF6
15730:  MOVLW  57
15732:  ADDWFC FF7,F
15734:  MOVLW  01
15736:  MOVWF  FF8
15738:  MOVWF  FFB
1573A:  TBLRD*-
1573C:  MOVF   FF5,W
1573E:  MOVWF  FFA
15740:  TBLRD*
15742:  MOVF   FF5,W
15744:  MOVWF  FF9
15746:  DATA 98,55
15748:  DATA B8,55
1574A:  DATA D8,55
1574C:  DATA F8,55
1574E:  DATA 18,56
15750:  DATA 38,56
15752:  DATA 58,56
*
1B2FC:  ADDWF  FE8,W
1B2FE:  CLRF   FF7
1B300:  RLCF   FF7,F
1B302:  ADDLW  1D
1B304:  MOVWF  FF6
1B306:  MOVLW  B3
1B308:  ADDWFC FF7,F
1B30A:  MOVLW  01
1B30C:  MOVWF  FF8
1B30E:  MOVWF  FFB
1B310:  TBLRD*-
1B312:  MOVF   FF5,W
1B314:  MOVWF  FFA
1B316:  TBLRD*
1B318:  MOVF   FF5,W
1B31A:  MOVWF  FF9
1B31C:  DATA 76,B1
1B31E:  DATA F8,B2
1B320:  DATA 7C,B1
1B322:  DATA 70,B1
1B324:  DATA F8,B2
1B326:  DATA F8,B2
1B328:  DATA F8,B2
1B32A:  DATA 82,B1
1B32C:  DATA 36,B2
1B32E:  DATA F8,B2
1B330:  DATA 52,B2
1B332:  DATA F8,B2
1B334:  DATA 88,B1
1B336:  DATA F8,B2
1B338:  DATA F8,B2
1B33A:  DATA F8,B2
1B33C:  DATA F8,B2
1B33E:  DATA F8,B2
1B340:  DATA F8,B2
1B342:  DATA F8,B2
1B344:  DATA F8,B2
1B346:  DATA F8,B2
1B348:  DATA F8,B2
1B34A:  DATA F8,B2
1B34C:  DATA F8,B2
1B34E:  DATA F8,B2
1B350:  DATA F8,B2
1B352:  DATA F8,B2
1B354:  DATA F8,B2
1B356:  DATA F8,B2
1B358:  DATA 8E,B1
1B35A:  DATA 94,B1
1B35C:  DATA 9A,B1
1B35E:  DATA A0,B1
1B360:  DATA A6,B1
1B362:  DATA AC,B1
1B364:  DATA B2,B1
1B366:  DATA B8,B1
1B368:  DATA BE,B1
1B36A:  DATA C4,B1
1B36C:  DATA CA,B1
1B36E:  DATA D0,B1
1B370:  DATA D6,B1
1B372:  DATA E2,B1
1B374:  DATA E8,B1
1B376:  DATA EE,B1
1B378:  DATA F4,B1
1B37A:  DATA FA,B1
1B37C:  DATA 00,B2
1B37E:  DATA 06,B2
1B380:  DATA 0C,B2
1B382:  DATA 12,B2
1B384:  DATA 18,B2
1B386:  DATA 1E,B2
1B388:  DATA 24,B2
1B38A:  DATA 2A,B2
1B38C:  DATA F8,B2
1B38E:  DATA F8,B2
1B390:  DATA F8,B2
1B392:  DATA 30,B2
1B394:  DATA F8,B2
1B396:  DATA F8,B2
1B398:  DATA 6E,B2
1B39A:  DATA 74,B2
1B39C:  DATA 7A,B2
1B39E:  DATA 80,B2
1B3A0:  DATA 86,B2
1B3A2:  DATA 8C,B2
1B3A4:  DATA 92,B2
1B3A6:  DATA 98,B2
1B3A8:  DATA 9E,B2
1B3AA:  DATA A4,B2
1B3AC:  DATA AA,B2
1B3AE:  DATA B0,B2
1B3B0:  DATA B6,B2
1B3B2:  DATA BC,B2
1B3B4:  DATA C2,B2
1B3B6:  DATA C8,B2
1B3B8:  DATA CE,B2
1B3BA:  DATA D4,B2
1B3BC:  DATA D8,B2
1B3BE:  DATA DC,B2
1B3C0:  DATA E0,B2
1B3C2:  DATA E4,B2
1B3C4:  DATA EA,B2
1B3C6:  DATA EE,B2
1B3C8:  DATA F2,B2
1B3CA:  DATA F6,B2
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8F4
1F8BA:  MOVFF  FF7,8F5
1F8BE:  MOVFF  FF8,8F6
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8F4,FF6
1F8CE:  MOVFF  8F5,FF7
1F8D2:  MOVFF  8F6,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8F5
1F8E0:  MOVFF  FF7,8F6
1F8E4:  MOVFF  FF8,8F7
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8F5,FF6
1F8F4:  MOVFF  8F6,FF7
1F8F8:  MOVFF  8F7,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xF4,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xF5.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xF4,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xF5,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xF4,F
1F936:  MOVLW  0A
1F938:  SUBWF  xF4,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xF5.7
1F942:  MOVF   xF5,W
1F944:  ADDWF  xF4,F
1F946:  MOVF   xF4,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xF7,W
1F956:  CLRF   01
1F958:  SUBWF  xF6,W
1F95A:  BC    1F962
1F95C:  MOVFF  8F6,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xF8
1F968:  RLCF   xF6,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xF7,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xF8,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8F4,8F6
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xF7
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8F4
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xF5.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xF5.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xF5.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xF5.3
1F9AC:  BCF    xF5.4
1F9AE:  BSF    xF5.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8F4,8F6
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xF7
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8F4
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xF5.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xF5.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xF5.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xF4,F
1F9F0:  MOVF   xF4,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8F4,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8F5,01
1FA60:  MOVFF  8F4,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... //#ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... //#else 
....................    //#FUSES NOMCLR 
.................... //#endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... #FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... #FUSES WDT_SW   
.................... //#use delay(clock=2000000) 
....................  
.................... #FUSES NOWDT 
....................  
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
02938:  MOVLW  09
0293A:  MOVWF  FEA
0293C:  MOVLW  EC
0293E:  MOVWF  FE9
02940:  MOVF   FEF,W
02942:  BZ    2960
02944:  MOVLW  14
02946:  MOVWF  01
02948:  CLRF   00
0294A:  DECFSZ 00,F
0294C:  BRA    294A
0294E:  DECFSZ 01,F
02950:  BRA    2948
02952:  MOVLW  BF
02954:  MOVWF  00
02956:  DECFSZ 00,F
02958:  BRA    2956
0295A:  BRA    295C
0295C:  DECFSZ FEF,F
0295E:  BRA    2944
02960:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E58:  BTFSS  F9E.5
00E5A:  BRA    0E58
00E5C:  MOVFF  FAB,1C
00E60:  MOVFF  FAE,01
00E64:  BTFSS  1C.1
00E66:  BRA    0E6C
00E68:  BCF    FAB.4
00E6A:  BSF    FAB.4
00E6C:  RETURN 0
*
0AEE8:  BTFSS  F9E.4
0AEEA:  BRA    AEE8
0AEEC:  MOVWF  FAD
0AEEE:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12E62:  BTFSS  FA4.5
12E64:  BRA    12E62
12E66:  MOVLB  F
12E68:  MOVFF  F22,1C
12E6C:  MOVFF  F1D,01
12E70:  BTFSS  1C.1
12E72:  BRA    12E78
12E74:  BCF    x22.4
12E76:  BSF    x22.4
12E78:  MOVLB  0
12E7A:  RETURN 0
*
16F96:  BTFSS  FA4.4
16F98:  BRA    16F96
16F9A:  MOVLB  F
16F9C:  MOVWF  x1C
16F9E:  MOVLB  0
16FA0:  GOTO   17044 (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xFA
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xFB
1F850:  MOVF   xFB,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8F9,03
1F85A:  MOVFF  8F8,FE9
1F85E:  MOVFF  8F9,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xFA,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8FC
1F870:  MOVFF  8F8,FE9
1F874:  MOVFF  8F9,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xFC,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xFA
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xFA,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8FC
1F88C:  MOVFF  8F8,FE9
1F890:  MOVFF  8F9,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xFC,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xFA
....................       }  
1F89C:  MOVF   xFB,W
1F89E:  INCF   xFB,F
1F8A0:  INCF   xF8,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xF9,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8FA,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xF8,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8F5,03
1FA84:  MOVFF  8F4,FE9
1FA88:  MOVFF  8F5,FEA
1FA8C:  MOVFF  FEF,8F9
1FA90:  MOVFF  8F7,03
1FA94:  MOVFF  8F6,FE9
1FA98:  MOVFF  8F7,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xF9,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8F5,03
1FAA6:  MOVFF  8F4,FE9
1FAAA:  MOVFF  8F5,FEA
1FAAE:  MOVFF  FEF,8F9
1FAB2:  MOVFF  8F7,03
1FAB6:  MOVFF  8F6,FE9
1FABA:  MOVFF  8F7,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xF9,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8F5,03
1FAD4:  MOVFF  8F4,FE9
1FAD8:  MOVFF  8F5,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8F5,03
1FAEA:  MOVF   xF4,W
1FAEC:  INCF   xF4,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xF5,F
1FAF2:  MOVFF  8F7,03
1FAF6:  MOVF   xF6,W
1FAF8:  INCF   xF6,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xF7,F
1FAFE:  DECF   xF8,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x85.1
1FB0E:  CLRF   x8F
1FB10:  CLRF   x8E
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xEC
1FB2A:  MOVLB  0
1FB2C:  CALL   2938
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x85.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x8B
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x8B,W
1FB3C:  ADDLW  B4
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x8B,W
1FB50:  INCF   x8B,F
1FB52:  CLRF   03
1FB54:  ADDLW  B4
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x8B,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x85.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   xB4,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xF9
1FB80:  MOVLW  B5
1FB82:  MOVWF  xF8
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,88A
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xF9
1FB92:  MOVLW  B7
1FB94:  MOVWF  xF8
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8F4
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xF9
1FBA4:  MOVLW  B9
1FBA6:  MOVWF  xF8
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8F4,88D
1FBB0:  MOVFF  01,88C
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xF9
1FBBA:  MOVLW  BB
1FBBC:  MOVWF  xF8
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,887
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  88E,892
1FBCA:  MOVFF  88F,893
1FBCE:  MOVFF  88C,890
1FBD2:  MOVFF  88D,891
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x87,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x85.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x85.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x93,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x92,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x91,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x93,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x92,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x93,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x92,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x86
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x89
1FC26:  MOVLW  03
1FC28:  SUBWF  x8B,W
1FC2A:  SUBWF  x89,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x89,W
1FC32:  ADDLW  B4
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8F4
1FC3E:  MOVFF  03,8F5
1FC42:  MOVFF  03,8F9
1FC46:  MOVFF  01,8F8
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x86,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x89,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x86,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x86
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x8B,W
1FC68:  CLRF   03
1FC6A:  ADDLW  B4
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8F4
1FC76:  MOVFF  03,8F5
1FC7A:  MOVFF  03,8F9
1FC7E:  MOVFF  01,8F8
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x86,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x85.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x87,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x89
1FCAE:  CLRF   x88
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x8B,W
1FCB4:  SUBWF  x89,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x88,W
1FCBA:  INCF   x88,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  94
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8F4
1FCCA:  MOVFF  03,8F5
1FCCE:  CLRF   03
1FCD0:  MOVF   x89,W
1FCD2:  ADDLW  B4
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8F6
1FCDE:  MOVFF  03,8F7
1FCE2:  MOVFF  03,8F9
1FCE6:  MOVFF  01,8F8
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8F5,FEA
1FCF2:  MOVFF  8F4,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x89,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xF4
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  893,8F4
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xF5
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  892,8F4
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xF5
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  891,8F4
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xF5
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  890,8F4
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xF5
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  88A,8F4
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xF5
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  892,FF8
1FD80:  MOVFF  891,FF7
1FD84:  MOVFF  890,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  94
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  88A,8F4
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  892,FF8
1FD9A:  MOVFF  891,FF7
1FD9E:  MOVFF  890,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  B4
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xF5
1FDAE:  MOVFF  88A,8F4
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xF5
1FDBC:  MOVLW  94
1FDBE:  MOVWF  xF4
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xF7
1FDC4:  MOVLW  B4
1FDC6:  MOVWF  xF6
1FDC8:  MOVFF  88A,8F8
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x85.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x87,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xF9
1FE02:  MOVLW  BD
1FE04:  MOVWF  xF8
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8F4
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xF9
1FE14:  MOVLW  BF
1FE16:  MOVWF  xF8
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8F4,88F
1FE20:  MOVFF  01,88E
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xF4
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  88E,8F4
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xF5
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x85.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x85.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xF4
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xEC
1FE8E:  MOVLB  0
1FE90:  CALL   2938
1FE94:  MOVLB  8
1FE96:  DECFSZ xF4,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... int16 valve_align_timeout = -1; 
.................... int16 valve_align_counter = -1; 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
0557C:  BCF    FF2.5
....................    restart_wdt(); 
0557E:  CLRWDT
05580:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
05582:  CLRF   FCF
05584:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
05586:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
05588:  MOVF   2F,W
0558A:  SUBLW  02
0558C:  BNZ   5594
0558E:  MOVF   30,F
05590:  BNZ   5594
05592:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
05594:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
05596:  BSF    F9D.0
05598:  GOTO   55AC (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
0559C:  MOVLW  0B
0559E:  MOVWF  FD7
055A0:  MOVLW  DC
055A2:  MOVWF  FD6
....................    restart_wdt(); 
055A4:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
055A6:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
055A8:  BSF    FF2.5
....................    setup_led_pulse(); 
055AA:  BRA    5582
055AC:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
055AE:  MOVLB  8
055B0:  MOVF   xED,W
055B2:  XORLW  00
055B4:  MOVLB  0
055B6:  BZ    55BE
055B8:  XORLW  01
055BA:  BZ    55C2
055BC:  BRA    55C4
....................       case 0 : suspend_heartbeat(); 
055BE:  RCALL  557C
....................          break; 
055C0:  BRA    55C4
....................       case 1 : restart_heartbeat(); 
055C2:  RCALL  559C
....................          break; 
....................    } 
055C4:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
0311E:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
03120:  BCF    FD1.0
03122:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
02928:  MOVLW  0B
0292A:  MOVWF  FD7
0292C:  MOVLW  DC
0292E:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
02930:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
02932:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
02934:  BSF    FD1.0
02936:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
07930:  MOVFF  9B1,9B7
07934:  MOVFF  9B0,9B6
07938:  MOVLB  9
0793A:  MOVF   xB4,F
0793C:  BNZ   7942
0793E:  MOVF   xB5,F
07940:  BZ    798C
07942:  MOVFF  9B3,03
07946:  MOVFF  9B2,FE9
0794A:  MOVFF  9B3,FEA
0794E:  MOVF   FEF,F
07950:  BZ    798C
....................      *s++ = *s2++; 
07952:  MOVFF  9B7,9B9
07956:  MOVF   xB6,W
07958:  INCF   xB6,F
0795A:  BTFSC  FD8.2
0795C:  INCF   xB7,F
0795E:  MOVWF  xB8
07960:  MOVFF  9B3,03
07964:  MOVF   xB2,W
07966:  INCF   xB2,F
07968:  BTFSC  FD8.2
0796A:  INCF   xB3,F
0796C:  MOVWF  FE9
0796E:  MOVFF  03,FEA
07972:  MOVFF  FEF,9BA
07976:  MOVFF  9B9,FEA
0797A:  MOVFF  9B8,FE9
0797E:  MOVFF  9BA,FEF
07982:  MOVF   xB4,W
07984:  BTFSC  FD8.2
07986:  DECF   xB5,F
07988:  DECF   xB4,F
0798A:  BRA    793A
....................   for (; n > 0; n--) 
0798C:  MOVF   xB4,F
0798E:  BNZ   7994
07990:  MOVF   xB5,F
07992:  BZ    79B2
....................      *s++ = '\0'; 
07994:  MOVFF  9B7,03
07998:  MOVF   xB6,W
0799A:  INCF   xB6,F
0799C:  BTFSC  FD8.2
0799E:  INCF   xB7,F
079A0:  MOVWF  FE9
079A2:  MOVFF  03,FEA
079A6:  CLRF   FEF
079A8:  MOVF   xB4,W
079AA:  BTFSC  FD8.2
079AC:  DECF   xB5,F
079AE:  DECF   xB4,F
079B0:  BRA    798C
....................  
....................   return(s1); 
079B2:  MOVFF  9B0,01
079B6:  MOVFF  9B1,02
079BA:  MOVLB  0
079BC:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
05506:  MOVFF  8F9,8FD
0550A:  MOVFF  8F8,8FC
0550E:  MOVFF  8FD,03
05512:  MOVLB  8
05514:  MOVFF  8FC,FE9
05518:  MOVFF  8FD,FEA
0551C:  MOVF   FEF,F
0551E:  BZ    552C
05520:  INCF   xFC,F
05522:  BTFSC  FD8.2
05524:  INCF   xFD,F
05526:  MOVLB  0
05528:  BRA    550E
0552A:  MOVLB  8
....................    while(*s2 != '\0') 
0552C:  MOVFF  8FB,03
05530:  MOVFF  8FA,FE9
05534:  MOVFF  8FB,FEA
05538:  MOVF   FEF,F
0553A:  BZ    5566
....................    { 
....................       *s = *s2; 
0553C:  MOVFF  8FA,FE9
05540:  MOVFF  8FB,FEA
05544:  MOVFF  FEF,900
05548:  MOVLB  9
0554A:  MOVFF  8FD,FEA
0554E:  MOVFF  8FC,FE9
05552:  MOVFF  900,FEF
....................       ++s; 
05556:  MOVLB  8
05558:  INCF   xFC,F
0555A:  BTFSC  FD8.2
0555C:  INCF   xFD,F
....................       ++s2; 
0555E:  INCF   xFA,F
05560:  BTFSC  FD8.2
05562:  INCF   xFB,F
05564:  BRA    552C
....................    } 
....................  
....................    *s = '\0'; 
05566:  MOVFF  8FC,FE9
0556A:  MOVFF  8FD,FEA
0556E:  CLRF   FEF
....................    return(s1); 
05570:  MOVFF  8F8,01
05574:  MOVFF  8F9,02
05578:  MOVLB  0
0557A:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
12DDE:  MOVFF  8EE,8F4
12DE2:  MOVFF  8ED,8F3
12DE6:  MOVFF  8F4,03
12DEA:  MOVLB  8
12DEC:  MOVFF  8F3,FE9
12DF0:  MOVFF  8F4,FEA
12DF4:  MOVF   FEF,F
12DF6:  BZ    12E04
12DF8:  INCF   xF3,F
12DFA:  BTFSC  FD8.2
12DFC:  INCF   xF4,F
12DFE:  MOVLB  0
12E00:  BRA    12DE6
12E02:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12E04:  MOVFF  8F0,03
12E08:  MOVFF  8EF,FE9
12E0C:  MOVFF  8F0,FEA
12E10:  MOVF   FEF,F
12E12:  BZ    12E4C
12E14:  MOVF   xF2,F
12E16:  BNZ   12E1E
12E18:  MOVF   xF1,W
12E1A:  SUBLW  00
12E1C:  BC    12E4C
....................    { 
....................       *s = *s2; 
12E1E:  MOVFF  8EF,FE9
12E22:  MOVFF  8F0,FEA
12E26:  MOVFF  FEF,8F7
12E2A:  MOVFF  8F4,FEA
12E2E:  MOVFF  8F3,FE9
12E32:  MOVFF  8F7,FEF
....................       ++s; 
12E36:  INCF   xF3,F
12E38:  BTFSC  FD8.2
12E3A:  INCF   xF4,F
....................       ++s2; 
12E3C:  INCF   xEF,F
12E3E:  BTFSC  FD8.2
12E40:  INCF   xF0,F
....................       --n; 
12E42:  MOVF   xF1,W
12E44:  BTFSC  FD8.2
12E46:  DECF   xF2,F
12E48:  DECF   xF1,F
12E4A:  BRA    12E04
....................    } 
....................  
....................    *s = '\0'; 
12E4C:  MOVFF  8F3,FE9
12E50:  MOVFF  8F4,FEA
12E54:  CLRF   FEF
....................    return(s1); 
12E56:  MOVFF  8ED,01
12E5A:  MOVFF  8EE,02
12E5E:  MOVLB  0
12E60:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
04634:  MOVFF  9EA,9F0
04638:  MOVFF  9E9,9EF
0463C:  MOVFF  9EC,9F2
04640:  MOVFF  9EB,9F1
04644:  MOVLB  9
04646:  MOVF   xEE,F
04648:  BNZ   4650
0464A:  MOVF   xED,W
0464C:  SUBLW  00
0464E:  BC    46B0
.................... { 
....................    if(*su1!=*su2) 
04650:  MOVFF  9EF,FE9
04654:  MOVFF  9F0,FEA
04658:  MOVFF  FEF,9F3
0465C:  MOVFF  9F2,03
04660:  MOVFF  9F1,FE9
04664:  MOVFF  9F2,FEA
04668:  MOVF   FEF,W
0466A:  SUBWF  xF3,W
0466C:  BZ    469A
....................       return ((*su1<*su2)?-1:1); 
0466E:  MOVFF  9F0,03
04672:  MOVFF  9EF,FE9
04676:  MOVFF  03,FEA
0467A:  MOVFF  FEF,9F3
0467E:  MOVFF  9F2,03
04682:  MOVFF  9F1,FE9
04686:  MOVFF  9F2,FEA
0468A:  MOVF   FEF,W
0468C:  SUBWF  xF3,W
0468E:  BC    4694
04690:  MOVLW  FF
04692:  BRA    4696
04694:  MOVLW  01
04696:  MOVWF  01
04698:  BRA    46B4
0469A:  INCF   xEF,F
0469C:  BTFSC  FD8.2
0469E:  INCF   xF0,F
046A0:  INCF   xF1,F
046A2:  BTFSC  FD8.2
046A4:  INCF   xF2,F
046A6:  MOVF   xED,W
046A8:  BTFSC  FD8.2
046AA:  DECF   xEE,F
046AC:  DECF   xED,F
046AE:  BRA    4646
.................... } 
.................... return 0; 
046B0:  MOVLW  00
046B2:  MOVWF  01
046B4:  MOVLB  0
046B6:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
12DA2:  MOVFF  8EC,8EE
12DA6:  MOVFF  8EB,8ED
12DAA:  MOVFF  8EE,03
12DAE:  MOVLB  8
12DB0:  MOVFF  8ED,FE9
12DB4:  MOVFF  8EE,FEA
12DB8:  MOVF   FEF,F
12DBA:  BZ    12DC8
12DBC:  INCF   xED,F
12DBE:  BTFSC  FD8.2
12DC0:  INCF   xEE,F
12DC2:  MOVLB  0
12DC4:  BRA    12DAA
12DC6:  MOVLB  8
....................    return(sc - s); 
12DC8:  MOVF   xEB,W
12DCA:  SUBWF  xED,W
12DCC:  MOVWF  00
12DCE:  MOVF   xEC,W
12DD0:  SUBWFB xEE,W
12DD2:  MOVWF  03
12DD4:  MOVFF  00,01
12DD8:  MOVWF  02
12DDA:  MOVLB  0
12DDC:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
13424:  MOVLB  8
13426:  CLRF   xDA
....................    sign = 0; 
13428:  CLRF   xD8
....................    base = 10; 
1342A:  MOVLW  0A
1342C:  MOVWF  xD9
....................    result = 0; 
1342E:  CLRF   xD7
13430:  CLRF   xD6
....................  
....................    if (!s) 
13432:  MOVF   xD4,W
13434:  IORWF  xD5,W
13436:  BNZ   13440
....................       return 0; 
13438:  MOVLW  00
1343A:  MOVWF  01
1343C:  MOVWF  02
1343E:  BRA    13604
....................    c = s[index++]; 
13440:  MOVF   xDA,W
13442:  INCF   xDA,F
13444:  ADDWF  xD4,W
13446:  MOVWF  FE9
13448:  MOVLW  00
1344A:  ADDWFC xD5,W
1344C:  MOVWF  FEA
1344E:  MOVFF  FEF,8DB
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
13452:  MOVF   xDB,W
13454:  SUBLW  2D
13456:  BNZ   13470
....................    { 
....................       sign = 1;         // Set the sign to negative 
13458:  MOVLW  01
1345A:  MOVWF  xD8
....................       c = s[index++]; 
1345C:  MOVF   xDA,W
1345E:  INCF   xDA,F
13460:  ADDWF  xD4,W
13462:  MOVWF  FE9
13464:  MOVLW  00
13466:  ADDWFC xD5,W
13468:  MOVWF  FEA
1346A:  MOVFF  FEF,8DB
....................    } 
1346E:  BRA    13488
....................    else if (c == '+') 
13470:  MOVF   xDB,W
13472:  SUBLW  2B
13474:  BNZ   13488
....................    { 
....................       c = s[index++]; 
13476:  MOVF   xDA,W
13478:  INCF   xDA,F
1347A:  ADDWF  xD4,W
1347C:  MOVWF  FE9
1347E:  MOVLW  00
13480:  ADDWFC xD5,W
13482:  MOVWF  FEA
13484:  MOVFF  FEF,8DB
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
13488:  MOVF   xDB,W
1348A:  SUBLW  2F
1348C:  BTFSC  FD8.0
1348E:  BRA    135E8
13490:  MOVF   xDB,W
13492:  SUBLW  39
13494:  BTFSS  FD8.0
13496:  BRA    135E8
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
13498:  MOVF   xDB,W
1349A:  SUBLW  30
1349C:  BNZ   134DA
1349E:  MOVF   xDA,W
134A0:  ADDWF  xD4,W
134A2:  MOVWF  FE9
134A4:  MOVLW  00
134A6:  ADDWFC xD5,W
134A8:  MOVWF  FEA
134AA:  MOVF   FEF,W
134AC:  SUBLW  78
134AE:  BZ    134C2
134B0:  MOVF   xDA,W
134B2:  ADDWF  xD4,W
134B4:  MOVWF  FE9
134B6:  MOVLW  00
134B8:  ADDWFC xD5,W
134BA:  MOVWF  FEA
134BC:  MOVF   FEF,W
134BE:  SUBLW  58
134C0:  BNZ   134DA
....................       { 
....................          base = 16; 
134C2:  MOVLW  10
134C4:  MOVWF  xD9
....................          index++; 
134C6:  INCF   xDA,F
....................          c = s[index++]; 
134C8:  MOVF   xDA,W
134CA:  INCF   xDA,F
134CC:  ADDWF  xD4,W
134CE:  MOVWF  FE9
134D0:  MOVLW  00
134D2:  ADDWFC xD5,W
134D4:  MOVWF  FEA
134D6:  MOVFF  FEF,8DB
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
134DA:  MOVF   xD9,W
134DC:  SUBLW  0A
134DE:  BNZ   13524
....................       { 
....................          while (c >= '0' && c <= '9') 
134E0:  MOVF   xDB,W
134E2:  SUBLW  2F
134E4:  BC    13522
134E6:  MOVF   xDB,W
134E8:  SUBLW  39
134EA:  BNC   13522
....................          { 
....................             result = 10*result + (c - '0'); 
134EC:  CLRF   xDD
134EE:  MOVLW  0A
134F0:  MOVWF  xDC
134F2:  MOVFF  8D7,8DF
134F6:  MOVFF  8D6,8DE
134FA:  MOVLB  0
134FC:  BRA    133CE
134FE:  MOVLW  30
13500:  MOVLB  8
13502:  SUBWF  xDB,W
13504:  ADDWF  01,W
13506:  MOVWF  xD6
13508:  MOVLW  00
1350A:  ADDWFC 02,W
1350C:  MOVWF  xD7
....................             c = s[index++]; 
1350E:  MOVF   xDA,W
13510:  INCF   xDA,F
13512:  ADDWF  xD4,W
13514:  MOVWF  FE9
13516:  MOVLW  00
13518:  ADDWFC xD5,W
1351A:  MOVWF  FEA
1351C:  MOVFF  FEF,8DB
13520:  BRA    134E0
....................          } 
....................       } 
13522:  BRA    135E8
....................       else if (base == 16)    // The number is a hexa number 
13524:  MOVF   xD9,W
13526:  SUBLW  10
13528:  BNZ   135E8
....................       { 
....................          c = toupper(c); 
1352A:  MOVF   xDB,W
1352C:  SUBLW  60
1352E:  BC    1353C
13530:  MOVF   xDB,W
13532:  SUBLW  7A
13534:  BNC   1353C
13536:  MOVF   xDB,W
13538:  ANDLW  DF
1353A:  BRA    1353E
1353C:  MOVF   xDB,W
1353E:  MOVWF  xDB
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
13540:  MOVF   xDB,W
13542:  SUBLW  2F
13544:  BC    1354C
13546:  MOVF   xDB,W
13548:  SUBLW  39
1354A:  BC    13558
1354C:  MOVF   xDB,W
1354E:  SUBLW  40
13550:  BC    135E8
13552:  MOVF   xDB,W
13554:  SUBLW  46
13556:  BNC   135E8
....................          { 
....................             if (c >= '0' && c <= '9') 
13558:  MOVF   xDB,W
1355A:  SUBLW  2F
1355C:  BC    13592
1355E:  MOVF   xDB,W
13560:  SUBLW  39
13562:  BNC   13592
....................                result = (result << 4) + (c - '0'); 
13564:  RLCF   xD6,W
13566:  MOVWF  xDC
13568:  RLCF   xD7,W
1356A:  MOVWF  xDD
1356C:  RLCF   xDC,F
1356E:  RLCF   xDD,F
13570:  RLCF   xDC,F
13572:  RLCF   xDD,F
13574:  RLCF   xDC,F
13576:  RLCF   xDD,F
13578:  MOVLW  F0
1357A:  ANDWF  xDC,F
1357C:  MOVLW  30
1357E:  SUBWF  xDB,W
13580:  ADDWF  xDC,W
13582:  MOVWF  01
13584:  MOVLW  00
13586:  ADDWFC xDD,W
13588:  MOVWF  03
1358A:  MOVFF  01,8D6
1358E:  MOVWF  xD7
13590:  BRA    135BE
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
13592:  RLCF   xD6,W
13594:  MOVWF  xDC
13596:  RLCF   xD7,W
13598:  MOVWF  xDD
1359A:  RLCF   xDC,F
1359C:  RLCF   xDD,F
1359E:  RLCF   xDC,F
135A0:  RLCF   xDD,F
135A2:  RLCF   xDC,F
135A4:  RLCF   xDD,F
135A6:  MOVLW  F0
135A8:  ANDWF  xDC,F
135AA:  MOVLW  41
135AC:  SUBWF  xDB,W
135AE:  ADDLW  0A
135B0:  ADDWF  xDC,W
135B2:  MOVWF  01
135B4:  MOVLW  00
135B6:  ADDWFC xDD,W
135B8:  MOVFF  01,8D6
135BC:  MOVWF  xD7
....................  
....................             c = s[index++];c = toupper(c); 
135BE:  MOVF   xDA,W
135C0:  INCF   xDA,F
135C2:  ADDWF  xD4,W
135C4:  MOVWF  FE9
135C6:  MOVLW  00
135C8:  ADDWFC xD5,W
135CA:  MOVWF  FEA
135CC:  MOVFF  FEF,8DB
135D0:  MOVF   xDB,W
135D2:  SUBLW  60
135D4:  BC    135E2
135D6:  MOVF   xDB,W
135D8:  SUBLW  7A
135DA:  BNC   135E2
135DC:  MOVF   xDB,W
135DE:  ANDLW  DF
135E0:  BRA    135E4
135E2:  MOVF   xDB,W
135E4:  MOVWF  xDB
135E6:  BRA    13540
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
135E8:  MOVF   xD9,W
135EA:  SUBLW  0A
135EC:  BNZ   135FC
135EE:  DECFSZ xD8,W
135F0:  BRA    135FC
....................       result = -result; 
135F2:  COMF   xD6,F
135F4:  COMF   xD7,F
135F6:  INCF   xD6,F
135F8:  BTFSC  FD8.2
135FA:  INCF   xD7,F
....................  
....................    return(result); 
135FC:  MOVFF  8D6,01
13600:  MOVFF  8D7,02
13604:  MOVLB  0
13606:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0AF32:  MOVLB  8
0AF34:  CLRF   x8D
....................    sign = 0; 
0AF36:  CLRF   x8B
....................    base = 10; 
0AF38:  MOVLW  0A
0AF3A:  MOVWF  x8C
....................    result = 0; 
0AF3C:  CLRF   x8A
0AF3E:  CLRF   x89
0AF40:  CLRF   x88
0AF42:  CLRF   x87
....................  
....................    if (!s) 
0AF44:  MOVF   x85,W
0AF46:  IORWF  x86,W
0AF48:  BNZ   AF54
....................       return 0; 
0AF4A:  CLRF   00
0AF4C:  CLRF   01
0AF4E:  CLRF   02
0AF50:  CLRF   03
0AF52:  BRA    B1C2
....................    c = s[index++]; 
0AF54:  MOVF   x8D,W
0AF56:  INCF   x8D,F
0AF58:  ADDWF  x85,W
0AF5A:  MOVWF  FE9
0AF5C:  MOVLW  00
0AF5E:  ADDWFC x86,W
0AF60:  MOVWF  FEA
0AF62:  MOVFF  FEF,88E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0AF66:  MOVF   x8E,W
0AF68:  SUBLW  2D
0AF6A:  BNZ   AF84
....................    { 
....................       sign = 1;         // Set the sign to negative 
0AF6C:  MOVLW  01
0AF6E:  MOVWF  x8B
....................       c = s[index++]; 
0AF70:  MOVF   x8D,W
0AF72:  INCF   x8D,F
0AF74:  ADDWF  x85,W
0AF76:  MOVWF  FE9
0AF78:  MOVLW  00
0AF7A:  ADDWFC x86,W
0AF7C:  MOVWF  FEA
0AF7E:  MOVFF  FEF,88E
....................    } 
0AF82:  BRA    AF9C
....................    else if (c == '+') 
0AF84:  MOVF   x8E,W
0AF86:  SUBLW  2B
0AF88:  BNZ   AF9C
....................    { 
....................       c = s[index++]; 
0AF8A:  MOVF   x8D,W
0AF8C:  INCF   x8D,F
0AF8E:  ADDWF  x85,W
0AF90:  MOVWF  FE9
0AF92:  MOVLW  00
0AF94:  ADDWFC x86,W
0AF96:  MOVWF  FEA
0AF98:  MOVFF  FEF,88E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0AF9C:  MOVF   x8E,W
0AF9E:  SUBLW  2F
0AFA0:  BTFSC  FD8.0
0AFA2:  BRA    B192
0AFA4:  MOVF   x8E,W
0AFA6:  SUBLW  39
0AFA8:  BTFSS  FD8.0
0AFAA:  BRA    B192
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0AFAC:  MOVF   x8E,W
0AFAE:  SUBLW  30
0AFB0:  BNZ   AFEE
0AFB2:  MOVF   x8D,W
0AFB4:  ADDWF  x85,W
0AFB6:  MOVWF  FE9
0AFB8:  MOVLW  00
0AFBA:  ADDWFC x86,W
0AFBC:  MOVWF  FEA
0AFBE:  MOVF   FEF,W
0AFC0:  SUBLW  78
0AFC2:  BZ    AFD6
0AFC4:  MOVF   x8D,W
0AFC6:  ADDWF  x85,W
0AFC8:  MOVWF  FE9
0AFCA:  MOVLW  00
0AFCC:  ADDWFC x86,W
0AFCE:  MOVWF  FEA
0AFD0:  MOVF   FEF,W
0AFD2:  SUBLW  58
0AFD4:  BNZ   AFEE
....................       { 
....................          base = 16; 
0AFD6:  MOVLW  10
0AFD8:  MOVWF  x8C
....................          index++; 
0AFDA:  INCF   x8D,F
....................          c = s[index++]; 
0AFDC:  MOVF   x8D,W
0AFDE:  INCF   x8D,F
0AFE0:  ADDWF  x85,W
0AFE2:  MOVWF  FE9
0AFE4:  MOVLW  00
0AFE6:  ADDWFC x86,W
0AFE8:  MOVWF  FEA
0AFEA:  MOVFF  FEF,88E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0AFEE:  MOVF   x8C,W
0AFF0:  SUBLW  0A
0AFF2:  BNZ   B07A
....................       { 
....................          while (c >= '0' && c <= '9') { 
0AFF4:  MOVF   x8E,W
0AFF6:  SUBLW  2F
0AFF8:  BC    B078
0AFFA:  MOVF   x8E,W
0AFFC:  SUBLW  39
0AFFE:  BNC   B078
....................             result = (result << 1) + (result << 3);  // result *= 10; 
0B000:  BCF    FD8.0
0B002:  RLCF   x87,W
0B004:  MOVWF  x90
0B006:  RLCF   x88,W
0B008:  MOVWF  x91
0B00A:  RLCF   x89,W
0B00C:  MOVWF  x92
0B00E:  RLCF   x8A,W
0B010:  MOVWF  x93
0B012:  RLCF   x87,W
0B014:  MOVWF  00
0B016:  RLCF   x88,W
0B018:  MOVWF  01
0B01A:  RLCF   x89,W
0B01C:  MOVWF  02
0B01E:  RLCF   x8A,W
0B020:  MOVWF  03
0B022:  RLCF   00,F
0B024:  RLCF   01,F
0B026:  RLCF   02,F
0B028:  RLCF   03,F
0B02A:  RLCF   00,F
0B02C:  RLCF   01,F
0B02E:  RLCF   02,F
0B030:  RLCF   03,F
0B032:  MOVLW  F8
0B034:  ANDWF  00,F
0B036:  MOVF   x90,W
0B038:  ADDWF  00,F
0B03A:  MOVF   x91,W
0B03C:  ADDWFC 01,F
0B03E:  MOVF   x92,W
0B040:  ADDWFC 02,F
0B042:  MOVF   x93,W
0B044:  ADDWFC 03,F
0B046:  MOVFF  03,88A
0B04A:  MOVFF  02,889
0B04E:  MOVFF  01,888
0B052:  MOVFF  00,887
....................             result += (c - '0'); 
0B056:  MOVLW  30
0B058:  SUBWF  x8E,W
0B05A:  ADDWF  x87,F
0B05C:  MOVLW  00
0B05E:  ADDWFC x88,F
0B060:  ADDWFC x89,F
0B062:  ADDWFC x8A,F
....................             c = s[index++]; 
0B064:  MOVF   x8D,W
0B066:  INCF   x8D,F
0B068:  ADDWF  x85,W
0B06A:  MOVWF  FE9
0B06C:  MOVLW  00
0B06E:  ADDWFC x86,W
0B070:  MOVWF  FEA
0B072:  MOVFF  FEF,88E
0B076:  BRA    AFF4
....................          } 
....................       } 
0B078:  BRA    B192
....................       else if (base == 16)    // The number is a hexa number 
0B07A:  MOVF   x8C,W
0B07C:  SUBLW  10
0B07E:  BTFSS  FD8.2
0B080:  BRA    B192
....................       { 
....................          c = toupper(c); 
0B082:  MOVF   x8E,W
0B084:  SUBLW  60
0B086:  BC    B094
0B088:  MOVF   x8E,W
0B08A:  SUBLW  7A
0B08C:  BNC   B094
0B08E:  MOVF   x8E,W
0B090:  ANDLW  DF
0B092:  BRA    B096
0B094:  MOVF   x8E,W
0B096:  MOVWF  x8E
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
0B098:  MOVF   x8E,W
0B09A:  SUBLW  2F
0B09C:  BC    B0A4
0B09E:  MOVF   x8E,W
0B0A0:  SUBLW  39
0B0A2:  BC    B0B2
0B0A4:  MOVF   x8E,W
0B0A6:  SUBLW  40
0B0A8:  BTFSC  FD8.0
0B0AA:  BRA    B192
0B0AC:  MOVF   x8E,W
0B0AE:  SUBLW  46
0B0B0:  BNC   B192
....................          { 
....................             if (c >= '0' && c <= '9') 
0B0B2:  MOVF   x8E,W
0B0B4:  SUBLW  2F
0B0B6:  BC    B114
0B0B8:  MOVF   x8E,W
0B0BA:  SUBLW  39
0B0BC:  BNC   B114
....................                result = (result << 4) + (c - '0'); 
0B0BE:  RLCF   x87,W
0B0C0:  MOVWF  x90
0B0C2:  RLCF   x88,W
0B0C4:  MOVWF  x91
0B0C6:  RLCF   x89,W
0B0C8:  MOVWF  x92
0B0CA:  RLCF   x8A,W
0B0CC:  MOVWF  x93
0B0CE:  RLCF   x90,F
0B0D0:  RLCF   x91,F
0B0D2:  RLCF   x92,F
0B0D4:  RLCF   x93,F
0B0D6:  RLCF   x90,F
0B0D8:  RLCF   x91,F
0B0DA:  RLCF   x92,F
0B0DC:  RLCF   x93,F
0B0DE:  RLCF   x90,F
0B0E0:  RLCF   x91,F
0B0E2:  RLCF   x92,F
0B0E4:  RLCF   x93,F
0B0E6:  MOVLW  F0
0B0E8:  ANDWF  x90,F
0B0EA:  MOVLW  30
0B0EC:  SUBWF  x8E,W
0B0EE:  ADDWF  x90,W
0B0F0:  MOVWF  00
0B0F2:  MOVLW  00
0B0F4:  ADDWFC x91,W
0B0F6:  MOVWF  01
0B0F8:  MOVLW  00
0B0FA:  ADDWFC x92,W
0B0FC:  MOVWF  02
0B0FE:  MOVLW  00
0B100:  ADDWFC x93,W
0B102:  MOVWF  03
0B104:  MOVWF  x8A
0B106:  MOVFF  02,889
0B10A:  MOVFF  01,888
0B10E:  MOVFF  00,887
0B112:  BRA    B168
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B114:  RLCF   x87,W
0B116:  MOVWF  x90
0B118:  RLCF   x88,W
0B11A:  MOVWF  x91
0B11C:  RLCF   x89,W
0B11E:  MOVWF  x92
0B120:  RLCF   x8A,W
0B122:  MOVWF  x93
0B124:  RLCF   x90,F
0B126:  RLCF   x91,F
0B128:  RLCF   x92,F
0B12A:  RLCF   x93,F
0B12C:  RLCF   x90,F
0B12E:  RLCF   x91,F
0B130:  RLCF   x92,F
0B132:  RLCF   x93,F
0B134:  RLCF   x90,F
0B136:  RLCF   x91,F
0B138:  RLCF   x92,F
0B13A:  RLCF   x93,F
0B13C:  MOVLW  F0
0B13E:  ANDWF  x90,F
0B140:  MOVLW  41
0B142:  SUBWF  x8E,W
0B144:  ADDLW  0A
0B146:  ADDWF  x90,W
0B148:  MOVWF  00
0B14A:  MOVLW  00
0B14C:  ADDWFC x91,W
0B14E:  MOVWF  01
0B150:  MOVLW  00
0B152:  ADDWFC x92,W
0B154:  MOVWF  02
0B156:  MOVLW  00
0B158:  ADDWFC x93,W
0B15A:  MOVWF  x8A
0B15C:  MOVFF  02,889
0B160:  MOVFF  01,888
0B164:  MOVFF  00,887
....................  
....................             c = s[index++];c = toupper(c); 
0B168:  MOVF   x8D,W
0B16A:  INCF   x8D,F
0B16C:  ADDWF  x85,W
0B16E:  MOVWF  FE9
0B170:  MOVLW  00
0B172:  ADDWFC x86,W
0B174:  MOVWF  FEA
0B176:  MOVFF  FEF,88E
0B17A:  MOVF   x8E,W
0B17C:  SUBLW  60
0B17E:  BC    B18C
0B180:  MOVF   x8E,W
0B182:  SUBLW  7A
0B184:  BNC   B18C
0B186:  MOVF   x8E,W
0B188:  ANDLW  DF
0B18A:  BRA    B18E
0B18C:  MOVF   x8E,W
0B18E:  MOVWF  x8E
0B190:  BRA    B098
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0B192:  MOVF   x8C,W
0B194:  SUBLW  0A
0B196:  BNZ   B1B2
0B198:  DECFSZ x8B,W
0B19A:  BRA    B1B2
....................       result = -result; 
0B19C:  COMF   x87,F
0B19E:  COMF   x88,F
0B1A0:  COMF   x89,F
0B1A2:  COMF   x8A,F
0B1A4:  INCF   x87,F
0B1A6:  BTFSC  FD8.2
0B1A8:  INCF   x88,F
0B1AA:  BTFSC  FD8.2
0B1AC:  INCF   x89,F
0B1AE:  BTFSC  FD8.2
0B1B0:  INCF   x8A,F
....................  
....................    return(result); 
0B1B2:  MOVFF  887,00
0B1B6:  MOVFF  888,01
0B1BA:  MOVFF  889,02
0B1BE:  MOVFF  88A,03
0B1C2:  MOVLB  0
0B1C4:  GOTO   1B622 (RETURN)
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0CADA:  MOVLB  8
0CADC:  CLRF   xA4
0CADE:  CLRF   xA3
0CAE0:  CLRF   xA2
0CAE2:  MOVLW  7F
0CAE4:  MOVWF  xA1
0CAE6:  CLRF   xA8
0CAE8:  CLRF   xA7
0CAEA:  CLRF   xA6
0CAEC:  CLRF   xA5
0CAEE:  BSF    xA9.0
0CAF0:  BCF    xA9.1
0CAF2:  BCF    xA9.2
0CAF4:  CLRF   xAB
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0CAF6:  MOVF   x9D,W
0CAF8:  IORWF  x9E,W
0CAFA:  BNZ   CB06
....................       return 0; 
0CAFC:  CLRF   00
0CAFE:  CLRF   01
0CB00:  CLRF   02
0CB02:  CLRF   03
0CB04:  BRA    CD30
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0CB06:  MOVF   xAB,W
0CB08:  INCF   xAB,F
0CB0A:  ADDWF  x9D,W
0CB0C:  MOVWF  FE9
0CB0E:  MOVLW  00
0CB10:  ADDWFC x9E,W
0CB12:  MOVWF  FEA
0CB14:  MOVFF  FEF,8AA
0CB18:  MOVF   xAA,F
0CB1A:  BTFSC  FD8.2
0CB1C:  BRA    CCB2
....................    { 
....................       if (skip && !isspace(c)) 
0CB1E:  BTFSS  xA9.0
0CB20:  BRA    CB40
0CB22:  MOVF   xAA,W
0CB24:  SUBLW  20
0CB26:  BZ    CB40
....................       { 
....................          skip = 0; 
0CB28:  BCF    xA9.0
....................          if (c == '+') 
0CB2A:  MOVF   xAA,W
0CB2C:  SUBLW  2B
0CB2E:  BNZ   CB36
....................          { 
....................             sign = 0; 
0CB30:  BCF    xA9.1
....................             continue; 
0CB32:  BRA    CC9A
....................          }             
0CB34:  BRA    CB40
....................          else if (c == '-') 
0CB36:  MOVF   xAA,W
0CB38:  SUBLW  2D
0CB3A:  BNZ   CB40
....................          { 
....................             sign = 1; 
0CB3C:  BSF    xA9.1
....................             continue; 
0CB3E:  BRA    CC9A
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0CB40:  BTFSC  xA9.0
0CB42:  BRA    CB52
0CB44:  MOVF   xAA,W
0CB46:  SUBLW  2E
0CB48:  BNZ   CB52
0CB4A:  BTFSC  xA9.2
0CB4C:  BRA    CB52
....................          point = 1; 
0CB4E:  BSF    xA9.2
0CB50:  BRA    CC9A
....................       else if (!skip && isdigit(c)) 
0CB52:  BTFSC  xA9.0
0CB54:  BRA    CC94
0CB56:  MOVF   xAA,W
0CB58:  SUBLW  2F
0CB5A:  BTFSC  FD8.0
0CB5C:  BRA    CC94
0CB5E:  MOVF   xAA,W
0CB60:  SUBLW  39
0CB62:  BTFSS  FD8.0
0CB64:  BRA    CC94
....................       { 
....................          c -= '0'; 
0CB66:  MOVLW  30
0CB68:  SUBWF  xAA,F
....................          if (point) 
0CB6A:  BTFSS  xA9.2
0CB6C:  BRA    CC1A
....................          { 
....................             pow10 = pow10 * 10.0; 
0CB6E:  MOVFF  8A4,916
0CB72:  MOVFF  8A3,915
0CB76:  MOVFF  8A2,914
0CB7A:  MOVFF  8A1,913
0CB7E:  MOVLB  9
0CB80:  CLRF   x1A
0CB82:  CLRF   x19
0CB84:  MOVLW  20
0CB86:  MOVWF  x18
0CB88:  MOVLW  82
0CB8A:  MOVWF  x17
0CB8C:  MOVLB  0
0CB8E:  CALL   C2F4
0CB92:  MOVFF  03,8A4
0CB96:  MOVFF  02,8A3
0CB9A:  MOVFF  01,8A2
0CB9E:  MOVFF  00,8A1
....................             result += (float)c / pow10;    
0CBA2:  MOVLB  9
0CBA4:  CLRF   x18
0CBA6:  MOVFF  8AA,917
0CBAA:  MOVLB  0
0CBAC:  RCALL  C926
0CBAE:  MOVFF  03,8AF
0CBB2:  MOVFF  02,8AE
0CBB6:  MOVFF  01,8AD
0CBBA:  MOVFF  00,8AC
0CBBE:  MOVFF  03,8FE
0CBC2:  MOVFF  02,8FD
0CBC6:  MOVFF  01,8FC
0CBCA:  MOVFF  00,8FB
0CBCE:  MOVFF  8A4,902
0CBD2:  MOVFF  8A3,901
0CBD6:  MOVFF  8A2,900
0CBDA:  MOVFF  8A1,8FF
0CBDE:  RCALL  C95C
0CBE0:  BCF    FD8.1
0CBE2:  MOVFF  8A8,91A
0CBE6:  MOVFF  8A7,919
0CBEA:  MOVFF  8A6,918
0CBEE:  MOVFF  8A5,917
0CBF2:  MOVFF  03,91E
0CBF6:  MOVFF  02,91D
0CBFA:  MOVFF  01,91C
0CBFE:  MOVFF  00,91B
0CC02:  CALL   C3EA
0CC06:  MOVFF  03,8A8
0CC0A:  MOVFF  02,8A7
0CC0E:  MOVFF  01,8A6
0CC12:  MOVFF  00,8A5
....................          } 
0CC16:  BRA    CC90
0CC18:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0CC1A:  MOVLB  9
0CC1C:  CLRF   x16
0CC1E:  CLRF   x15
0CC20:  MOVLW  20
0CC22:  MOVWF  x14
0CC24:  MOVLW  82
0CC26:  MOVWF  x13
0CC28:  MOVFF  8A8,91A
0CC2C:  MOVFF  8A7,919
0CC30:  MOVFF  8A6,918
0CC34:  MOVFF  8A5,917
0CC38:  MOVLB  0
0CC3A:  CALL   C2F4
0CC3E:  MOVFF  03,8AF
0CC42:  MOVFF  02,8AE
0CC46:  MOVFF  01,8AD
0CC4A:  MOVFF  00,8AC
0CC4E:  MOVLB  9
0CC50:  CLRF   x18
0CC52:  MOVFF  8AA,917
0CC56:  MOVLB  0
0CC58:  RCALL  C926
0CC5A:  BCF    FD8.1
0CC5C:  MOVFF  8AF,91A
0CC60:  MOVFF  8AE,919
0CC64:  MOVFF  8AD,918
0CC68:  MOVFF  8AC,917
0CC6C:  MOVFF  03,91E
0CC70:  MOVFF  02,91D
0CC74:  MOVFF  01,91C
0CC78:  MOVFF  00,91B
0CC7C:  CALL   C3EA
0CC80:  MOVFF  03,8A8
0CC84:  MOVFF  02,8A7
0CC88:  MOVFF  01,8A6
0CC8C:  MOVFF  00,8A5
....................          } 
....................       } 
0CC90:  BRA    CC9C
0CC92:  MOVLB  8
....................       else if (!skip) 
0CC94:  BTFSC  xA9.0
0CC96:  BRA    CC9A
....................          break; 
0CC98:  BRA    CCB2
0CC9A:  MOVLB  0
0CC9C:  MOVLB  8
0CC9E:  MOVF   xAB,W
0CCA0:  INCF   xAB,F
0CCA2:  ADDWF  x9D,W
0CCA4:  MOVWF  FE9
0CCA6:  MOVLW  00
0CCA8:  ADDWFC x9E,W
0CCAA:  MOVWF  FEA
0CCAC:  MOVFF  FEF,8AA
0CCB0:  BRA    CB18
....................    } 
....................  
....................    if (sign) 
0CCB2:  BTFSS  xA9.1
0CCB4:  BRA    CCEC
....................       result = -1*result; 
0CCB6:  MOVLB  9
0CCB8:  CLRF   x16
0CCBA:  CLRF   x15
0CCBC:  MOVLW  80
0CCBE:  MOVWF  x14
0CCC0:  MOVLW  7F
0CCC2:  MOVWF  x13
0CCC4:  MOVFF  8A8,91A
0CCC8:  MOVFF  8A7,919
0CCCC:  MOVFF  8A6,918
0CCD0:  MOVFF  8A5,917
0CCD4:  MOVLB  0
0CCD6:  CALL   C2F4
0CCDA:  MOVFF  03,8A8
0CCDE:  MOVFF  02,8A7
0CCE2:  MOVFF  01,8A6
0CCE6:  MOVFF  00,8A5
0CCEA:  MOVLB  8
....................        
....................    if(endptr) 
0CCEC:  MOVF   x9F,W
0CCEE:  IORWF  xA0,W
0CCF0:  BZ    CD20
....................    { 
....................       if (ptr) { 
0CCF2:  MOVF   xAB,F
0CCF4:  BZ    CD0E
....................          ptr--; 
0CCF6:  DECF   xAB,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0CCF8:  MOVFF  89F,FE9
0CCFC:  MOVFF  8A0,FEA
0CD00:  MOVF   xAB,W
0CD02:  ADDWF  x9D,W
0CD04:  MOVWF  FEF
0CD06:  MOVLW  00
0CD08:  ADDWFC x9E,W
0CD0A:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0CD0C:  BRA    CD20
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0CD0E:  MOVFF  89F,FE9
0CD12:  MOVFF  8A0,FEA
0CD16:  MOVFF  89E,FEC
0CD1A:  MOVF   FED,F
0CD1C:  MOVFF  89D,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0CD20:  MOVFF  8A5,00
0CD24:  MOVFF  8A6,01
0CD28:  MOVFF  8A7,02
0CD2C:  MOVFF  8A8,03
0CD30:  MOVLB  0
0CD32:  GOTO   CD5A (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
12878:  MOVLB  9
1287A:  BCF    x12.0
....................    y = x; 
1287C:  MOVFF  906,90B
12880:  MOVFF  905,90A
12884:  MOVFF  904,909
12888:  MOVFF  903,908
....................  
....................    if (x < 0) 
1288C:  MOVFF  906,916
12890:  MOVFF  905,915
12894:  MOVFF  904,914
12898:  MOVFF  903,913
1289C:  CLRF   x1A
1289E:  CLRF   x19
128A0:  CLRF   x18
128A2:  CLRF   x17
128A4:  MOVLB  0
128A6:  CALL   107B8
128AA:  BNC   128B8
....................    { 
....................       s = 1; 
128AC:  MOVLB  9
128AE:  BSF    x12.0
....................       y = -y; 
128B0:  MOVF   x09,W
128B2:  XORLW  80
128B4:  MOVWF  x09
128B6:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
128B8:  MOVFF  90B,916
128BC:  MOVFF  90A,915
128C0:  MOVFF  909,914
128C4:  MOVFF  908,913
128C8:  MOVLB  9
128CA:  CLRF   x1A
128CC:  CLRF   x19
128CE:  CLRF   x18
128D0:  MOVLW  8E
128D2:  MOVWF  x17
128D4:  MOVLB  0
128D6:  CALL   107B8
128DA:  BC    128DE
128DC:  BNZ   1290E
....................       res = (float32)(unsigned int16)y; 
128DE:  MOVFF  90B,916
128E2:  MOVFF  90A,915
128E6:  MOVFF  909,914
128EA:  MOVFF  908,913
128EE:  RCALL  1283C
128F0:  MOVFF  02,918
128F4:  MOVFF  01,917
128F8:  CALL   C926
128FC:  MOVFF  03,90F
12900:  MOVFF  02,90E
12904:  MOVFF  01,90D
12908:  MOVFF  00,90C
1290C:  BRA    12AB0
....................  
....................  else if (y < 10000000.0) 
1290E:  MOVFF  90B,916
12912:  MOVFF  90A,915
12916:  MOVFF  909,914
1291A:  MOVFF  908,913
1291E:  MOVLW  80
12920:  MOVLB  9
12922:  MOVWF  x1A
12924:  MOVLW  96
12926:  MOVWF  x19
12928:  MOVLW  18
1292A:  MOVWF  x18
1292C:  MOVLW  96
1292E:  MOVWF  x17
12930:  MOVLB  0
12932:  CALL   107B8
12936:  BTFSS  FD8.0
12938:  BRA    12AA0
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
1293A:  MOVFF  90B,916
1293E:  MOVFF  90A,915
12942:  MOVFF  909,914
12946:  MOVFF  908,913
1294A:  MOVLB  9
1294C:  CLRF   x1A
1294E:  CLRF   x19
12950:  CLRF   x18
12952:  MOVLW  70
12954:  MOVWF  x17
12956:  MOVLB  0
12958:  CALL   C2F4
1295C:  MOVFF  03,916
12960:  MOVFF  02,915
12964:  MOVFF  01,914
12968:  MOVFF  00,913
1296C:  RCALL  1283C
1296E:  MOVFF  02,911
12972:  MOVFF  01,910
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
12976:  MOVFF  90B,916
1297A:  MOVFF  90A,915
1297E:  MOVFF  909,914
12982:  MOVFF  908,913
12986:  MOVLB  9
12988:  CLRF   x1A
1298A:  CLRF   x19
1298C:  CLRF   x18
1298E:  MOVLW  70
12990:  MOVWF  x17
12992:  MOVLB  0
12994:  CALL   C2F4
12998:  MOVFF  03,916
1299C:  MOVFF  02,915
129A0:  MOVFF  01,914
129A4:  MOVFF  00,913
129A8:  MOVFF  911,918
129AC:  MOVFF  910,917
129B0:  CALL   C926
129B4:  BSF    FD8.1
129B6:  MOVFF  916,91A
129BA:  MOVFF  915,919
129BE:  MOVFF  914,918
129C2:  MOVFF  913,917
129C6:  MOVFF  03,91E
129CA:  MOVFF  02,91D
129CE:  MOVFF  01,91C
129D2:  MOVFF  00,91B
129D6:  CALL   C3EA
129DA:  MOVLB  9
129DC:  CLRF   x16
129DE:  CLRF   x15
129E0:  CLRF   x14
129E2:  MOVLW  8E
129E4:  MOVWF  x13
129E6:  MOVFF  03,91A
129EA:  MOVFF  02,919
129EE:  MOVFF  01,918
129F2:  MOVFF  00,917
129F6:  MOVLB  0
129F8:  CALL   C2F4
129FC:  MOVFF  03,90B
12A00:  MOVFF  02,90A
12A04:  MOVFF  01,909
12A08:  MOVFF  00,908
....................       res = 32768.0*(float32)l; 
12A0C:  MOVFF  911,918
12A10:  MOVFF  910,917
12A14:  CALL   C926
12A18:  MOVLB  9
12A1A:  CLRF   x16
12A1C:  CLRF   x15
12A1E:  CLRF   x14
12A20:  MOVLW  8E
12A22:  MOVWF  x13
12A24:  MOVFF  03,91A
12A28:  MOVFF  02,919
12A2C:  MOVFF  01,918
12A30:  MOVFF  00,917
12A34:  MOVLB  0
12A36:  CALL   C2F4
12A3A:  MOVFF  03,90F
12A3E:  MOVFF  02,90E
12A42:  MOVFF  01,90D
12A46:  MOVFF  00,90C
....................       res += (float32)(unsigned int16)y; 
12A4A:  MOVFF  90B,916
12A4E:  MOVFF  90A,915
12A52:  MOVFF  909,914
12A56:  MOVFF  908,913
12A5A:  RCALL  1283C
12A5C:  MOVFF  02,918
12A60:  MOVFF  01,917
12A64:  CALL   C926
12A68:  BCF    FD8.1
12A6A:  MOVFF  90F,91A
12A6E:  MOVFF  90E,919
12A72:  MOVFF  90D,918
12A76:  MOVFF  90C,917
12A7A:  MOVFF  03,91E
12A7E:  MOVFF  02,91D
12A82:  MOVFF  01,91C
12A86:  MOVFF  00,91B
12A8A:  CALL   C3EA
12A8E:  MOVFF  03,90F
12A92:  MOVFF  02,90E
12A96:  MOVFF  01,90D
12A9A:  MOVFF  00,90C
....................    } 
12A9E:  BRA    12AB0
....................  
....................  else 
....................   res = y; 
12AA0:  MOVFF  90B,90F
12AA4:  MOVFF  90A,90E
12AA8:  MOVFF  909,90D
12AAC:  MOVFF  908,90C
....................  
....................  y = y - (float32)(unsigned int16)y; 
12AB0:  MOVFF  90B,916
12AB4:  MOVFF  90A,915
12AB8:  MOVFF  909,914
12ABC:  MOVFF  908,913
12AC0:  RCALL  1283C
12AC2:  MOVFF  02,918
12AC6:  MOVFF  01,917
12ACA:  CALL   C926
12ACE:  BSF    FD8.1
12AD0:  MOVFF  90B,91A
12AD4:  MOVFF  90A,919
12AD8:  MOVFF  909,918
12ADC:  MOVFF  908,917
12AE0:  MOVFF  03,91E
12AE4:  MOVFF  02,91D
12AE8:  MOVFF  01,91C
12AEC:  MOVFF  00,91B
12AF0:  CALL   C3EA
12AF4:  MOVFF  03,90B
12AF8:  MOVFF  02,90A
12AFC:  MOVFF  01,909
12B00:  MOVFF  00,908
....................  
....................  if (s) 
12B04:  MOVLB  9
12B06:  BTFSS  x12.0
12B08:  BRA    12B10
....................   res = -res; 
12B0A:  MOVF   x0D,W
12B0C:  XORLW  80
12B0E:  MOVWF  x0D
....................  
....................  if (y != 0) 
12B10:  MOVFF  90B,916
12B14:  MOVFF  90A,915
12B18:  MOVFF  909,914
12B1C:  MOVFF  908,913
12B20:  CLRF   x1A
12B22:  CLRF   x19
12B24:  CLRF   x18
12B26:  CLRF   x17
12B28:  MOVLB  0
12B2A:  CALL   107B8
12B2E:  BZ    12BA8
....................  { 
....................   if (s == 1 && n == 0) 
12B30:  MOVLB  9
12B32:  BTFSS  x12.0
12B34:  BRA    12B6E
12B36:  MOVF   x07,F
12B38:  BNZ   12B6E
....................    res -= 1.0; 
12B3A:  BSF    FD8.1
12B3C:  MOVFF  90F,91A
12B40:  MOVFF  90E,919
12B44:  MOVFF  90D,918
12B48:  MOVFF  90C,917
12B4C:  CLRF   x1E
12B4E:  CLRF   x1D
12B50:  CLRF   x1C
12B52:  MOVLW  7F
12B54:  MOVWF  x1B
12B56:  MOVLB  0
12B58:  CALL   C3EA
12B5C:  MOVFF  03,90F
12B60:  MOVFF  02,90E
12B64:  MOVFF  01,90D
12B68:  MOVFF  00,90C
12B6C:  MOVLB  9
....................  
....................   if (s == 0 && n == 1) 
12B6E:  BTFSC  x12.0
12B70:  BRA    12BAA
12B72:  DECFSZ x07,W
12B74:  BRA    12BAA
....................    res += 1.0; 
12B76:  BCF    FD8.1
12B78:  MOVFF  90F,91A
12B7C:  MOVFF  90E,919
12B80:  MOVFF  90D,918
12B84:  MOVFF  90C,917
12B88:  CLRF   x1E
12B8A:  CLRF   x1D
12B8C:  CLRF   x1C
12B8E:  MOVLW  7F
12B90:  MOVWF  x1B
12B92:  MOVLB  0
12B94:  CALL   C3EA
12B98:  MOVFF  03,90F
12B9C:  MOVFF  02,90E
12BA0:  MOVFF  01,90D
12BA4:  MOVFF  00,90C
12BA8:  MOVLB  9
....................  } 
....................  if (x == 0) 
12BAA:  MOVFF  906,916
12BAE:  MOVFF  905,915
12BB2:  MOVFF  904,914
12BB6:  MOVFF  903,913
12BBA:  CLRF   x1A
12BBC:  CLRF   x19
12BBE:  CLRF   x18
12BC0:  CLRF   x17
12BC2:  MOVLB  0
12BC4:  CALL   107B8
12BC8:  BNZ   12BD6
....................     res = 0; 
12BCA:  MOVLB  9
12BCC:  CLRF   x0F
12BCE:  CLRF   x0E
12BD0:  CLRF   x0D
12BD2:  CLRF   x0C
12BD4:  MOVLB  0
....................  
....................  return (res); 
12BD6:  MOVFF  90C,00
12BDA:  MOVFF  90D,01
12BDE:  MOVFF  90E,02
12BE2:  MOVFF  90F,03
12BE6:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
12C06:  MOVFF  902,906
12C0A:  MOVFF  901,905
12C0E:  MOVFF  900,904
12C12:  MOVFF  8FF,903
12C16:  MOVLB  9
12C18:  CLRF   x07
12C1A:  MOVLB  0
12C1C:  RCALL  12878
12C1E:  GOTO   12D2A (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
12BE8:  MOVFF  902,906
12BEC:  MOVFF  901,905
12BF0:  MOVFF  900,904
12BF4:  MOVFF  8FF,903
12BF8:  MOVLW  01
12BFA:  MOVLB  9
12BFC:  MOVWF  x07
12BFE:  MOVLB  0
12C00:  RCALL  12878
12C02:  GOTO   12CE2 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
12C22:  MOVFF  8F6,916
12C26:  MOVFF  8F5,915
12C2A:  MOVFF  8F4,914
12C2E:  MOVFF  8F3,913
12C32:  MOVLB  9
12C34:  CLRF   x1A
12C36:  CLRF   x19
12C38:  CLRF   x18
12C3A:  CLRF   x17
12C3C:  MOVLB  0
12C3E:  CALL   107B8
12C42:  BTFSC  FD8.2
12C44:  BRA    12D86
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
12C46:  MOVFF  8F2,8FE
12C4A:  MOVFF  8F1,8FD
12C4E:  MOVFF  8F0,8FC
12C52:  MOVFF  8EF,8FB
12C56:  MOVFF  8F6,902
12C5A:  MOVFF  8F5,901
12C5E:  MOVFF  8F4,900
12C62:  MOVFF  8F3,8FF
12C66:  CALL   C95C
12C6A:  MOVFF  03,8FE
12C6E:  MOVFF  02,8FD
12C72:  MOVFF  01,8FC
12C76:  MOVFF  00,8FB
12C7A:  MOVFF  03,916
12C7E:  MOVFF  02,915
12C82:  MOVFF  01,914
12C86:  MOVFF  00,913
12C8A:  MOVLB  9
12C8C:  CLRF   x1A
12C8E:  CLRF   x19
12C90:  CLRF   x18
12C92:  CLRF   x17
12C94:  MOVLB  0
12C96:  CALL   107B8
12C9A:  BNC   12CE4
12C9C:  MOVFF  8F2,8FE
12CA0:  MOVFF  8F1,8FD
12CA4:  MOVFF  8F0,8FC
12CA8:  MOVFF  8EF,8FB
12CAC:  MOVFF  8F6,902
12CB0:  MOVFF  8F5,901
12CB4:  MOVFF  8F4,900
12CB8:  MOVFF  8F3,8FF
12CBC:  CALL   C95C
12CC0:  MOVFF  03,8FE
12CC4:  MOVFF  02,8FD
12CC8:  MOVFF  01,8FC
12CCC:  MOVFF  00,8FB
12CD0:  MOVFF  03,902
12CD4:  MOVFF  02,901
12CD8:  MOVFF  01,900
12CDC:  MOVFF  00,8FF
12CE0:  BRA    12BE8
12CE2:  BRA    12D2A
12CE4:  MOVFF  8F2,8FE
12CE8:  MOVFF  8F1,8FD
12CEC:  MOVFF  8F0,8FC
12CF0:  MOVFF  8EF,8FB
12CF4:  MOVFF  8F6,902
12CF8:  MOVFF  8F5,901
12CFC:  MOVFF  8F4,900
12D00:  MOVFF  8F3,8FF
12D04:  CALL   C95C
12D08:  MOVFF  03,8FE
12D0C:  MOVFF  02,8FD
12D10:  MOVFF  01,8FC
12D14:  MOVFF  00,8FB
12D18:  MOVFF  03,902
12D1C:  MOVFF  02,901
12D20:  MOVFF  01,900
12D24:  MOVFF  00,8FF
12D28:  BRA    12C06
12D2A:  MOVFF  03,8FA
12D2E:  MOVFF  02,8F9
12D32:  MOVFF  01,8F8
12D36:  MOVFF  00,8F7
....................       return(x-(i*y)); 
12D3A:  MOVFF  8FA,916
12D3E:  MOVFF  8F9,915
12D42:  MOVFF  8F8,914
12D46:  MOVFF  8F7,913
12D4A:  MOVFF  8F6,91A
12D4E:  MOVFF  8F5,919
12D52:  MOVFF  8F4,918
12D56:  MOVFF  8F3,917
12D5A:  CALL   C2F4
12D5E:  BSF    FD8.1
12D60:  MOVFF  8F2,91A
12D64:  MOVFF  8F1,919
12D68:  MOVFF  8F0,918
12D6C:  MOVFF  8EF,917
12D70:  MOVFF  03,91E
12D74:  MOVFF  02,91D
12D78:  MOVFF  01,91C
12D7C:  MOVFF  00,91B
12D80:  CALL   C3EA
12D84:  BRA    12D86
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
12D86:  GOTO   13020 (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
10882:  MOVFF  8DA,8DE
10886:  MOVFF  8D9,8DD
1088A:  MOVFF  8D8,8DC
1088E:  MOVFF  8D7,8DB
....................  
....................    if (y != 1.0) 
10892:  MOVFF  8DE,916
10896:  MOVFF  8DD,915
1089A:  MOVFF  8DC,914
1089E:  MOVFF  8DB,913
108A2:  MOVLB  9
108A4:  CLRF   x1A
108A6:  CLRF   x19
108A8:  CLRF   x18
108AA:  MOVLW  7F
108AC:  MOVWF  x17
108AE:  MOVLB  0
108B0:  RCALL  107B8
108B2:  BTFSC  FD8.2
108B4:  BRA    10BF6
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
108B6:  MOVLW  08
108B8:  MOVLB  8
108BA:  MOVWF  xED
108BC:  MOVLW  DB
108BE:  MOVWF  FE9
108C0:  MOVFF  8ED,FEA
108C4:  MOVLW  7E
108C6:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
108C8:  BSF    FD8.1
108CA:  MOVFF  8DE,91A
108CE:  MOVFF  8DD,919
108D2:  MOVFF  8DC,918
108D6:  MOVFF  8DB,917
108DA:  MOVLB  9
108DC:  CLRF   x1E
108DE:  CLRF   x1D
108E0:  CLRF   x1C
108E2:  MOVLW  7F
108E4:  MOVWF  x1B
108E6:  MOVLB  0
108E8:  CALL   C3EA
108EC:  MOVFF  03,8EF
108F0:  MOVFF  02,8EE
108F4:  MOVFF  01,8ED
108F8:  MOVFF  00,8EC
108FC:  BCF    FD8.1
108FE:  MOVFF  8DE,91A
10902:  MOVFF  8DD,919
10906:  MOVFF  8DC,918
1090A:  MOVFF  8DB,917
1090E:  MOVLB  9
10910:  CLRF   x1E
10912:  CLRF   x1D
10914:  CLRF   x1C
10916:  MOVLW  7F
10918:  MOVWF  x1B
1091A:  MOVLB  0
1091C:  CALL   C3EA
10920:  MOVFF  8EF,8FE
10924:  MOVFF  8EE,8FD
10928:  MOVFF  8ED,8FC
1092C:  MOVFF  8EC,8FB
10930:  MOVFF  03,902
10934:  MOVFF  02,901
10938:  MOVFF  01,900
1093C:  MOVFF  00,8FF
10940:  CALL   C95C
10944:  MOVFF  03,8DE
10948:  MOVFF  02,8DD
1094C:  MOVFF  01,8DC
10950:  MOVFF  00,8DB
....................  
....................       y2=y*y; 
10954:  MOVFF  8DE,916
10958:  MOVFF  8DD,915
1095C:  MOVFF  8DC,914
10960:  MOVFF  8DB,913
10964:  MOVFF  8DE,91A
10968:  MOVFF  8DD,919
1096C:  MOVFF  8DC,918
10970:  MOVFF  8DB,917
10974:  CALL   C2F4
10978:  MOVFF  03,8EA
1097C:  MOVFF  02,8E9
10980:  MOVFF  01,8E8
10984:  MOVFF  00,8E7
....................  
....................       res = pl[0]*y2 + pl[1]; 
10988:  MOVLW  99
1098A:  MOVLB  9
1098C:  MOVWF  x16
1098E:  MOVLW  47
10990:  MOVWF  x15
10992:  MOVLW  8A
10994:  MOVWF  x14
10996:  MOVLW  7F
10998:  MOVWF  x13
1099A:  MOVFF  8EA,91A
1099E:  MOVFF  8E9,919
109A2:  MOVFF  8E8,918
109A6:  MOVFF  8E7,917
109AA:  MOVLB  0
109AC:  CALL   C2F4
109B0:  MOVFF  03,8EF
109B4:  MOVFF  02,8EE
109B8:  MOVFF  01,8ED
109BC:  MOVFF  00,8EC
109C0:  BCF    FD8.1
109C2:  MOVFF  03,91A
109C6:  MOVFF  02,919
109CA:  MOVFF  01,918
109CE:  MOVFF  00,917
109D2:  MOVLB  9
109D4:  CLRF   x1E
109D6:  CLRF   x1D
109D8:  CLRF   x1C
109DA:  MOVLW  80
109DC:  MOVWF  x1B
109DE:  MOVLB  0
109E0:  CALL   C3EA
109E4:  MOVFF  03,8E2
109E8:  MOVFF  02,8E1
109EC:  MOVFF  01,8E0
109F0:  MOVFF  00,8DF
....................  
....................       r = ql[0]*y2 + ql[1]; 
109F4:  MOVLW  4C
109F6:  MOVLB  9
109F8:  MOVWF  x16
109FA:  MOVLW  F3
109FC:  MOVWF  x15
109FE:  MOVLW  3A
10A00:  MOVWF  x14
10A02:  MOVLW  7B
10A04:  MOVWF  x13
10A06:  MOVFF  8EA,91A
10A0A:  MOVFF  8E9,919
10A0E:  MOVFF  8E8,918
10A12:  MOVFF  8E7,917
10A16:  MOVLB  0
10A18:  CALL   C2F4
10A1C:  MOVFF  03,8EF
10A20:  MOVFF  02,8EE
10A24:  MOVFF  01,8ED
10A28:  MOVFF  00,8EC
10A2C:  BCF    FD8.1
10A2E:  MOVFF  03,91A
10A32:  MOVFF  02,919
10A36:  MOVFF  01,918
10A3A:  MOVFF  00,917
10A3E:  MOVLW  2B
10A40:  MOVLB  9
10A42:  MOVWF  x1E
10A44:  MOVLW  9D
10A46:  MOVWF  x1D
10A48:  MOVLW  DF
10A4A:  MOVWF  x1C
10A4C:  MOVLW  7E
10A4E:  MOVWF  x1B
10A50:  MOVLB  0
10A52:  CALL   C3EA
10A56:  MOVFF  03,8E6
10A5A:  MOVFF  02,8E5
10A5E:  MOVFF  01,8E4
10A62:  MOVFF  00,8E3
....................       r = r*y2 + 1.0; 
10A66:  MOVFF  8E6,916
10A6A:  MOVFF  8E5,915
10A6E:  MOVFF  8E4,914
10A72:  MOVFF  8E3,913
10A76:  MOVFF  8EA,91A
10A7A:  MOVFF  8E9,919
10A7E:  MOVFF  8E8,918
10A82:  MOVFF  8E7,917
10A86:  CALL   C2F4
10A8A:  MOVFF  03,8EF
10A8E:  MOVFF  02,8EE
10A92:  MOVFF  01,8ED
10A96:  MOVFF  00,8EC
10A9A:  BCF    FD8.1
10A9C:  MOVFF  03,91A
10AA0:  MOVFF  02,919
10AA4:  MOVFF  01,918
10AA8:  MOVFF  00,917
10AAC:  MOVLB  9
10AAE:  CLRF   x1E
10AB0:  CLRF   x1D
10AB2:  CLRF   x1C
10AB4:  MOVLW  7F
10AB6:  MOVWF  x1B
10AB8:  MOVLB  0
10ABA:  CALL   C3EA
10ABE:  MOVFF  03,8E6
10AC2:  MOVFF  02,8E5
10AC6:  MOVFF  01,8E4
10ACA:  MOVFF  00,8E3
....................  
....................       res = y*res/r; 
10ACE:  MOVFF  8DE,916
10AD2:  MOVFF  8DD,915
10AD6:  MOVFF  8DC,914
10ADA:  MOVFF  8DB,913
10ADE:  MOVFF  8E2,91A
10AE2:  MOVFF  8E1,919
10AE6:  MOVFF  8E0,918
10AEA:  MOVFF  8DF,917
10AEE:  CALL   C2F4
10AF2:  MOVFF  03,8EF
10AF6:  MOVFF  02,8EE
10AFA:  MOVFF  01,8ED
10AFE:  MOVFF  00,8EC
10B02:  MOVFF  03,8FE
10B06:  MOVFF  02,8FD
10B0A:  MOVFF  01,8FC
10B0E:  MOVFF  00,8FB
10B12:  MOVFF  8E6,902
10B16:  MOVFF  8E5,901
10B1A:  MOVFF  8E4,900
10B1E:  MOVFF  8E3,8FF
10B22:  CALL   C95C
10B26:  MOVFF  03,8E2
10B2A:  MOVFF  02,8E1
10B2E:  MOVFF  01,8E0
10B32:  MOVFF  00,8DF
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
10B36:  MOVLW  08
10B38:  MOVLB  8
10B3A:  MOVWF  xED
10B3C:  MOVLW  D7
10B3E:  MOVWF  FE9
10B40:  MOVFF  8ED,FEA
10B44:  MOVLW  7E
10B46:  SUBWF  FEF,W
10B48:  MOVWF  xEB
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
10B4A:  BTFSS  xEB.7
10B4C:  BRA    10B76
....................          r = -(float32)-n; 
10B4E:  MOVLW  00
10B50:  BSF    FD8.0
10B52:  SUBFWB xEB,W
10B54:  CLRF   xED
10B56:  MOVWF  xEC
10B58:  BTFSC  xEC.7
10B5A:  DECF   xED,F
10B5C:  MOVLB  0
10B5E:  RCALL  10832
10B60:  MOVFF  00,8E3
10B64:  MOVF   01,W
10B66:  XORLW  80
10B68:  MOVLB  8
10B6A:  MOVWF  xE4
10B6C:  MOVFF  02,8E5
10B70:  MOVFF  03,8E6
10B74:  BRA    10B96
....................       else 
....................          r = (float32)n; 
10B76:  CLRF   xED
10B78:  MOVFF  8EB,8EC
10B7C:  BTFSC  xEC.7
10B7E:  DECF   xED,F
10B80:  MOVLB  0
10B82:  RCALL  10832
10B84:  MOVFF  03,8E6
10B88:  MOVFF  02,8E5
10B8C:  MOVFF  01,8E4
10B90:  MOVFF  00,8E3
10B94:  MOVLB  8
....................  
....................       res += r*LN2; 
10B96:  MOVFF  8E6,916
10B9A:  MOVFF  8E5,915
10B9E:  MOVFF  8E4,914
10BA2:  MOVFF  8E3,913
10BA6:  MOVLW  18
10BA8:  MOVLB  9
10BAA:  MOVWF  x1A
10BAC:  MOVLW  72
10BAE:  MOVWF  x19
10BB0:  MOVLW  31
10BB2:  MOVWF  x18
10BB4:  MOVLW  7E
10BB6:  MOVWF  x17
10BB8:  MOVLB  0
10BBA:  CALL   C2F4
10BBE:  BCF    FD8.1
10BC0:  MOVFF  8E2,91A
10BC4:  MOVFF  8E1,919
10BC8:  MOVFF  8E0,918
10BCC:  MOVFF  8DF,917
10BD0:  MOVFF  03,91E
10BD4:  MOVFF  02,91D
10BD8:  MOVFF  01,91C
10BDC:  MOVFF  00,91B
10BE0:  CALL   C3EA
10BE4:  MOVFF  03,8E2
10BE8:  MOVFF  02,8E1
10BEC:  MOVFF  01,8E0
10BF0:  MOVFF  00,8DF
....................    } 
10BF4:  BRA    10C02
....................  
....................    else 
....................       res = 0.0; 
10BF6:  MOVLB  8
10BF8:  CLRF   xE2
10BFA:  CLRF   xE1
10BFC:  CLRF   xE0
10BFE:  CLRF   xDF
10C00:  MOVLB  0
....................  
....................    return(res); 
10C02:  MOVFF  8DF,00
10C06:  MOVFF  8E0,01
10C0A:  MOVFF  8E1,02
10C0E:  MOVFF  8E2,03
10C12:  GOTO   10C28 (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
10C16:  MOVFF  8D2,8DA
10C1A:  MOVFF  8D1,8D9
10C1E:  MOVFF  8D0,8D8
10C22:  MOVFF  8CF,8D7
10C26:  BRA    10882
10C28:  MOVFF  03,8D6
10C2C:  MOVFF  02,8D5
10C30:  MOVFF  01,8D4
10C34:  MOVFF  00,8D3
....................    r = r*LN10_INV; 
10C38:  MOVFF  8D6,916
10C3C:  MOVFF  8D5,915
10C40:  MOVFF  8D4,914
10C44:  MOVFF  8D3,913
10C48:  MOVLW  D9
10C4A:  MOVLB  9
10C4C:  MOVWF  x1A
10C4E:  MOVLW  5B
10C50:  MOVWF  x19
10C52:  MOVLW  5E
10C54:  MOVWF  x18
10C56:  MOVLW  7D
10C58:  MOVWF  x17
10C5A:  MOVLB  0
10C5C:  CALL   C2F4
10C60:  MOVFF  03,8D6
10C64:  MOVFF  02,8D5
10C68:  MOVFF  01,8D4
10C6C:  MOVFF  00,8D3
....................    return(r); 
10C70:  MOVFF  8D3,00
10C74:  MOVFF  8D4,01
10C78:  MOVFF  8D5,02
10C7C:  MOVFF  8D6,03
10C80:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
0FFD6:  BCF    FC6.5
0FFD8:  MOVLW  21
0FFDA:  MOVWF  FC6
0FFDC:  MOVLW  40
0FFDE:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
0FFE0:  BSF    F91.2
....................    output_high(EEP_WP); 
0FFE2:  BSF    F91.3
0FFE4:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
*
10620:  BCF    F91.2
....................    spi_write(0x05);  
10622:  MOVF   FC9,W
10624:  MOVLW  05
10626:  MOVWF  FC9
10628:  RRCF   FC7,W
1062A:  BNC   10628
....................    data = spi_read(0);  
1062C:  MOVF   FC9,W
1062E:  CLRF   FC9
10630:  RRCF   FC7,W
10632:  BNC   10630
10634:  MOVFF  FC9,8CE
....................    output_high(EEP_CS);  
10638:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
1063A:  MOVLW  00
1063C:  MOVLB  8
1063E:  BTFSS  xCE.0
10640:  MOVLW  01
10642:  MOVWF  01
10644:  MOVLB  0
10646:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
18112:  MOVLB  8
18114:  CLRF   xED
18116:  MOVLB  0
18118:  CALL   55AE
....................       while(!ext_eeprom_ready()); 
1811C:  CALL   10620
18120:  MOVF   01,F
18122:  BZ    1811C
....................     
....................       output_low(EEP_CS);  
18124:  BCF    F91.2
....................       spi_write(0x06);  
18126:  MOVF   FC9,W
18128:  MOVLW  06
1812A:  MOVWF  FC9
1812C:  RRCF   FC7,W
1812E:  BNC   1812C
....................       output_high(EEP_CS);  
18130:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
18132:  BCF    F91.2
....................       spi_write(0x02);  
18134:  MOVF   FC9,W
18136:  MOVLW  02
18138:  MOVWF  FC9
1813A:  RRCF   FC7,W
1813C:  BNC   1813A
....................       spi_write(address >> 8);  
1813E:  MOVFF  8A8,8AA
18142:  MOVLB  8
18144:  CLRF   xAB
18146:  MOVF   FC9,W
18148:  MOVFF  8A8,FC9
1814C:  RRCF   FC7,W
1814E:  BNC   1814C
....................       spi_write(address);  
18150:  MOVF   FC9,W
18152:  MOVFF  8A7,FC9
18156:  RRCF   FC7,W
18158:  BNC   18156
....................       spi_write(data);  
1815A:  MOVF   FC9,W
1815C:  MOVFF  8A9,FC9
18160:  RRCF   FC7,W
18162:  BNC   18160
....................       output_high(EEP_CS);  
18164:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
18166:  MOVLW  01
18168:  MOVWF  xED
1816A:  MOVLB  0
1816C:  CALL   55AE
18170:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
10648:  MOVLB  8
1064A:  CLRF   xED
1064C:  MOVLB  0
1064E:  CALL   55AE
....................     
....................       while(!ext_eeprom_ready()); 
10652:  RCALL  10620
10654:  MOVF   01,F
10656:  BZ    10652
....................        
....................       output_low(EEP_CS);  
10658:  BCF    F91.2
....................       spi_write(0x03);  
1065A:  MOVF   FC9,W
1065C:  MOVLW  03
1065E:  MOVWF  FC9
10660:  RRCF   FC7,W
10662:  BNC   10660
....................       spi_write(address >> 8);  
10664:  MOVFF  8CC,8CE
10668:  MOVLB  8
1066A:  CLRF   xCF
1066C:  MOVF   FC9,W
1066E:  MOVFF  8CC,FC9
10672:  RRCF   FC7,W
10674:  BNC   10672
....................       spi_write(address);  
10676:  MOVF   FC9,W
10678:  MOVFF  8CB,FC9
1067C:  RRCF   FC7,W
1067E:  BNC   1067C
....................        
....................       data = spi_read(0);  
10680:  MOVF   FC9,W
10682:  CLRF   FC9
10684:  RRCF   FC7,W
10686:  BNC   10684
10688:  MOVFF  FC9,8CD
....................       output_high(EEP_CS);  
1068C:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
1068E:  MOVLW  01
10690:  MOVWF  xED
10692:  MOVLB  0
10694:  CALL   55AE
....................     
....................    return(data);  
10698:  MOVLB  8
1069A:  MOVFF  8CD,01
1069E:  MOVLB  0
106A0:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
0343A:  MOVF   FF2,W
0343C:  MOVWF  00
0343E:  BCF    FF2.7
03440:  CLRF   F63
03442:  MOVFF  889,F62
03446:  MOVFF  88A,F61
0344A:  BCF    F7F.6
0344C:  BCF    F7F.7
0344E:  BSF    F7F.2
03450:  MOVLB  F
03452:  MOVLW  55
03454:  MOVWF  F7E
03456:  MOVLW  AA
03458:  MOVWF  F7E
0345A:  BSF    F7F.1
0345C:  BTFSC  F7F.1
0345E:  BRA    345C
03460:  BCF    F7F.2
03462:  MOVF   00,W
03464:  IORWF  FF2,F
03466:  MOVLB  0
03468:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
02A4C:  MOVLB  8
02A4E:  CLRF   xB8
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
02A50:  MOVFF  FF2,8B9
02A54:  BCF    FF2.7
02A56:  CLRF   F63
02A58:  MOVFF  8B7,F62
02A5C:  BCF    F7F.6
02A5E:  BCF    F7F.7
02A60:  BSF    F7F.0
02A62:  MOVF   F61,W
02A64:  BTFSC  xB9.7
02A66:  BSF    FF2.7
02A68:  MOVWF  xB8
....................    return(data); 
02A6A:  MOVFF  8B8,01
02A6E:  MOVLB  0
02A70:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
04FFC:  MOVLB  8
04FFE:  CLRF   xF1
05000:  MOVF   xF1,W
05002:  SUBLW  01
05004:  BNC   505E
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
05006:  MOVF   xEE,W
05008:  ADDWF  xF1,W
0500A:  MOVWF  xF2
0500C:  MOVLW  08
0500E:  MOVWF  xF4
05010:  MOVLW  EF
05012:  MOVWF  xF3
05014:  MOVF   xF1,W
05016:  ADDWF  xF3,W
05018:  MOVWF  01
0501A:  MOVLW  00
0501C:  ADDWFC xF4,W
0501E:  MOVWF  03
05020:  MOVF   01,W
05022:  MOVWF  FE9
05024:  MOVFF  03,FEA
05028:  MOVFF  FEF,8F3
0502C:  MOVF   FF2,W
0502E:  MOVWF  00
05030:  BCF    FF2.7
05032:  CLRF   F63
05034:  MOVFF  8F2,F62
05038:  MOVFF  8F3,F61
0503C:  BCF    F7F.6
0503E:  BCF    F7F.7
05040:  BSF    F7F.2
05042:  MOVLB  F
05044:  MOVLW  55
05046:  MOVWF  F7E
05048:  MOVLW  AA
0504A:  MOVWF  F7E
0504C:  BSF    F7F.1
0504E:  BTFSC  F7F.1
05050:  BRA    504E
05052:  BCF    F7F.2
05054:  MOVF   00,W
05056:  IORWF  FF2,F
05058:  MOVLB  8
0505A:  INCF   xF1,F
0505C:  BRA    5000
....................     }  
0505E:  MOVLB  0
05060:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
029F2:  MOVLB  8
029F4:  CLRF   x9A
029F6:  CLRF   x99
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
029F8:  CLRF   x98
029FA:  MOVF   x98,W
029FC:  SUBLW  01
029FE:  BNC   2A40
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02A00:  MOVLW  08
02A02:  MOVWF  x9C
02A04:  MOVLW  99
02A06:  MOVWF  x9B
02A08:  MOVF   x98,W
02A0A:  ADDWF  x9B,W
02A0C:  MOVWF  01
02A0E:  MOVLW  00
02A10:  ADDWFC x9C,W
02A12:  MOVWF  03
02A14:  MOVF   01,W
02A16:  MOVWF  FE9
02A18:  MOVFF  03,FEA
02A1C:  MOVF   x97,W
02A1E:  ADDWF  x98,W
02A20:  MOVWF  x9D
02A22:  MOVFF  FF2,89E
02A26:  BCF    FF2.7
02A28:  CLRF   F63
02A2A:  MOVFF  89D,F62
02A2E:  BCF    F7F.6
02A30:  BCF    F7F.7
02A32:  BSF    F7F.0
02A34:  MOVF   F61,W
02A36:  BTFSC  x9E.7
02A38:  BSF    FF2.7
02A3A:  MOVWF  FEF
02A3C:  INCF   x98,F
02A3E:  BRA    29FA
....................    } 
....................  
....................    return(data);  
02A40:  MOVFF  899,01
02A44:  MOVFF  89A,02
02A48:  MOVLB  0
02A4A:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0CD7C:  MOVLB  8
0CD7E:  CLRF   x8B
0CD80:  MOVF   x8B,W
0CD82:  SUBLW  03
0CD84:  BNC   CDE6
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0CD86:  MOVF   x8B,W
0CD88:  ADDWF  x85,W
0CD8A:  MOVWF  x8C
0CD8C:  MOVLW  00
0CD8E:  ADDWFC x86,W
0CD90:  MOVWF  x8D
0CD92:  MOVLW  08
0CD94:  MOVWF  x8F
0CD96:  MOVLW  87
0CD98:  MOVWF  x8E
0CD9A:  MOVF   x8B,W
0CD9C:  ADDWF  x8E,W
0CD9E:  MOVWF  01
0CDA0:  MOVLW  00
0CDA2:  ADDWFC x8F,W
0CDA4:  MOVWF  03
0CDA6:  MOVF   01,W
0CDA8:  MOVWF  FE9
0CDAA:  MOVFF  03,FEA
0CDAE:  MOVFF  FEF,88E
0CDB2:  MOVF   FF2,W
0CDB4:  MOVWF  00
0CDB6:  BCF    FF2.7
0CDB8:  MOVFF  88D,F63
0CDBC:  MOVFF  88C,F62
0CDC0:  MOVFF  88E,F61
0CDC4:  BCF    F7F.6
0CDC6:  BCF    F7F.7
0CDC8:  BSF    F7F.2
0CDCA:  MOVLB  F
0CDCC:  MOVLW  55
0CDCE:  MOVWF  F7E
0CDD0:  MOVLW  AA
0CDD2:  MOVWF  F7E
0CDD4:  BSF    F7F.1
0CDD6:  BTFSC  F7F.1
0CDD8:  BRA    CDD6
0CDDA:  BCF    F7F.2
0CDDC:  MOVF   00,W
0CDDE:  IORWF  FF2,F
0CDE0:  MOVLB  8
0CDE2:  INCF   x8B,F
0CDE4:  BRA    CD80
....................    } 
0CDE6:  MOVLB  0
0CDE8:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
02A72:  MOVLB  8
02A74:  CLRF   x8B
02A76:  CLRF   x8A
02A78:  CLRF   x89
02A7A:  CLRF   x88
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
02A7C:  CLRF   x87
02A7E:  MOVF   x87,W
02A80:  SUBLW  03
02A82:  BNC   2ACC
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02A84:  MOVLW  08
02A86:  MOVWF  x8D
02A88:  MOVLW  88
02A8A:  MOVWF  x8C
02A8C:  MOVF   x87,W
02A8E:  ADDWF  x8C,W
02A90:  MOVWF  01
02A92:  MOVLW  00
02A94:  ADDWFC x8D,W
02A96:  MOVWF  03
02A98:  MOVF   01,W
02A9A:  MOVWF  FE9
02A9C:  MOVFF  03,FEA
02AA0:  MOVF   x87,W
02AA2:  ADDWF  x85,W
02AA4:  MOVWF  x8E
02AA6:  MOVLW  00
02AA8:  ADDWFC x86,W
02AAA:  MOVWF  x8F
02AAC:  MOVFF  FF2,890
02AB0:  BCF    FF2.7
02AB2:  MOVFF  88F,F63
02AB6:  MOVFF  88E,F62
02ABA:  BCF    F7F.6
02ABC:  BCF    F7F.7
02ABE:  BSF    F7F.0
02AC0:  MOVF   F61,W
02AC2:  BTFSC  x90.7
02AC4:  BSF    FF2.7
02AC6:  MOVWF  FEF
02AC8:  INCF   x87,F
02ACA:  BRA    2A7E
....................    } 
....................  
....................    return(data);  
02ACC:  MOVFF  888,00
02AD0:  MOVFF  889,01
02AD4:  MOVFF  88A,02
02AD8:  MOVFF  88B,03
02ADC:  MOVLB  0
02ADE:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
18352:  MOVLB  8
18354:  CLRF   xA3
18356:  MOVF   xA3,W
18358:  SUBLW  01
1835A:  BNC   18398
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
1835C:  MOVF   xA3,W
1835E:  ADDWF  x9F,W
18360:  MOVWF  xA4
18362:  MOVLW  00
18364:  ADDWFC xA0,W
18366:  MOVWF  xA5
18368:  MOVLW  08
1836A:  MOVWF  xA7
1836C:  MOVLW  A1
1836E:  MOVWF  xA6
18370:  MOVF   xA3,W
18372:  ADDWF  xA6,W
18374:  MOVWF  01
18376:  MOVLW  00
18378:  ADDWFC xA7,W
1837A:  MOVWF  03
1837C:  MOVFF  01,FE9
18380:  MOVWF  FEA
18382:  MOVFF  FEF,8A9
18386:  MOVFF  8A5,8A8
1838A:  MOVFF  8A4,8A7
1838E:  MOVLB  0
18390:  RCALL  18112
18392:  MOVLB  8
18394:  INCF   xA3,F
18396:  BRA    18356
....................     }  
18398:  MOVLB  0
1839A:  GOTO   1840A (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
1075C:  MOVLB  8
1075E:  CLRF   xC6
10760:  CLRF   xC5
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
10762:  CLRF   xC4
10764:  MOVF   xC4,W
10766:  SUBLW  01
10768:  BNC   107AC
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
1076A:  MOVLW  08
1076C:  MOVWF  xC8
1076E:  MOVLW  C5
10770:  MOVWF  xC7
10772:  MOVF   xC4,W
10774:  ADDWF  xC7,W
10776:  MOVWF  01
10778:  MOVLW  00
1077A:  ADDWFC xC8,W
1077C:  MOVWF  03
1077E:  MOVFF  01,8C7
10782:  MOVWF  xC8
10784:  MOVF   xC4,W
10786:  ADDWF  xC2,W
10788:  MOVWF  xC9
1078A:  MOVLW  00
1078C:  ADDWFC xC3,W
1078E:  MOVWF  xCA
10790:  MOVWF  xCC
10792:  MOVFF  8C9,8CB
10796:  MOVLB  0
10798:  RCALL  10648
1079A:  MOVFF  8C8,FEA
1079E:  MOVFF  8C7,FE9
107A2:  MOVFF  01,FEF
107A6:  MOVLB  8
107A8:  INCF   xC4,F
107AA:  BRA    10764
....................    } 
....................    return(data);  
107AC:  MOVFF  8C5,01
107B0:  MOVFF  8C6,02
107B4:  MOVLB  0
107B6:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
15D30:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
15D32:  MOVF   2F,W
15D34:  SUBLW  02
15D36:  BNZ   15D3E
15D38:  MOVF   30,F
15D3A:  BNZ   15D3E
15D3C:  BSF    F90.6
....................    delay_ms(32); 
15D3E:  MOVLW  20
15D40:  MOVLB  9
15D42:  MOVWF  xEC
15D44:  MOVLB  0
15D46:  CALL   2938
....................    output_bit(BOARD_LED, OFF); 
15D4A:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
15D4C:  MOVF   2F,W
15D4E:  SUBLW  02
15D50:  BNZ   15D58
15D52:  MOVF   30,F
15D54:  BNZ   15D58
15D56:  BCF    F90.6
....................    delay_ms(32); 
15D58:  MOVLW  20
15D5A:  MOVLB  9
15D5C:  MOVWF  xEC
15D5E:  MOVLB  0
15D60:  CALL   2938
15D64:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
03170:  MOVF   2F,W
03172:  MOVWF  00
03174:  MOVF   30,W
03176:  MOVWF  03
03178:  BNZ   317E
0317A:  MOVF   00,F
0317C:  BZ    31A0
0317E:  MOVF   03,W
03180:  BNZ   3188
03182:  MOVLW  01
03184:  SUBWF  00,W
03186:  BZ    31F2
03188:  MOVF   03,W
0318A:  BNZ   3192
0318C:  MOVLW  02
0318E:  SUBWF  00,W
03190:  BZ    3244
03192:  MOVF   03,W
03194:  BNZ   319E
03196:  MOVLW  03
03198:  SUBWF  00,W
0319A:  BTFSC  FD8.2
0319C:  BRA    3296
0319E:  BRA    32E8
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
031A0:  MOVLW  BE
031A2:  MOVWF  FF6
031A4:  MOVLW  05
031A6:  MOVWF  FF7
031A8:  MOVLW  00
031AA:  MOVWF  FF8
031AC:  CLRF   1B
031AE:  BTFSC  FF2.7
031B0:  BSF    1B.7
031B2:  BCF    FF2.7
031B4:  MOVLW  06
031B6:  MOVLB  A
031B8:  MOVWF  x40
031BA:  MOVLB  0
031BC:  CALL   1044
031C0:  BTFSC  1B.7
031C2:  BSF    FF2.7
031C4:  MOVLW  CA
031C6:  MOVWF  FF6
031C8:  MOVLW  05
031CA:  MOVWF  FF7
031CC:  MOVLW  00
031CE:  MOVWF  FF8
031D0:  CLRF   1B
031D2:  BTFSC  FF2.7
031D4:  BSF    1B.7
031D6:  BCF    FF2.7
031D8:  CALL   0E6E
031DC:  BTFSC  1B.7
031DE:  BSF    FF2.7
031E0:  MOVLW  0D
031E2:  BTFSS  F9E.4
031E4:  BRA    31E2
031E6:  MOVWF  FAD
031E8:  MOVLW  0A
031EA:  BTFSS  F9E.4
031EC:  BRA    31EA
031EE:  MOVWF  FAD
....................          break; 
031F0:  BRA    3338
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
031F2:  MOVLW  D2
031F4:  MOVWF  FF6
031F6:  MOVLW  05
031F8:  MOVWF  FF7
031FA:  MOVLW  00
031FC:  MOVWF  FF8
031FE:  CLRF   1B
03200:  BTFSC  FF2.7
03202:  BSF    1B.7
03204:  BCF    FF2.7
03206:  MOVLW  09
03208:  MOVLB  A
0320A:  MOVWF  x40
0320C:  MOVLB  0
0320E:  CALL   1044
03212:  BTFSC  1B.7
03214:  BSF    FF2.7
03216:  MOVLW  E0
03218:  MOVWF  FF6
0321A:  MOVLW  05
0321C:  MOVWF  FF7
0321E:  MOVLW  00
03220:  MOVWF  FF8
03222:  CLRF   1B
03224:  BTFSC  FF2.7
03226:  BSF    1B.7
03228:  BCF    FF2.7
0322A:  CALL   0E6E
0322E:  BTFSC  1B.7
03230:  BSF    FF2.7
03232:  MOVLW  0D
03234:  BTFSS  F9E.4
03236:  BRA    3234
03238:  MOVWF  FAD
0323A:  MOVLW  0A
0323C:  BTFSS  F9E.4
0323E:  BRA    323C
03240:  MOVWF  FAD
....................          break;  
03242:  BRA    3338
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
03244:  MOVLW  E8
03246:  MOVWF  FF6
03248:  MOVLW  05
0324A:  MOVWF  FF7
0324C:  MOVLW  00
0324E:  MOVWF  FF8
03250:  CLRF   1B
03252:  BTFSC  FF2.7
03254:  BSF    1B.7
03256:  BCF    FF2.7
03258:  MOVLW  06
0325A:  MOVLB  A
0325C:  MOVWF  x40
0325E:  MOVLB  0
03260:  CALL   1044
03264:  BTFSC  1B.7
03266:  BSF    FF2.7
03268:  MOVLW  F4
0326A:  MOVWF  FF6
0326C:  MOVLW  05
0326E:  MOVWF  FF7
03270:  MOVLW  00
03272:  MOVWF  FF8
03274:  CLRF   1B
03276:  BTFSC  FF2.7
03278:  BSF    1B.7
0327A:  BCF    FF2.7
0327C:  CALL   0E6E
03280:  BTFSC  1B.7
03282:  BSF    FF2.7
03284:  MOVLW  0D
03286:  BTFSS  F9E.4
03288:  BRA    3286
0328A:  MOVWF  FAD
0328C:  MOVLW  0A
0328E:  BTFSS  F9E.4
03290:  BRA    328E
03292:  MOVWF  FAD
....................          break; 
03294:  BRA    3338
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
03296:  MOVLW  FC
03298:  MOVWF  FF6
0329A:  MOVLW  05
0329C:  MOVWF  FF7
0329E:  MOVLW  00
032A0:  MOVWF  FF8
032A2:  CLRF   1B
032A4:  BTFSC  FF2.7
032A6:  BSF    1B.7
032A8:  BCF    FF2.7
032AA:  MOVLW  09
032AC:  MOVLB  A
032AE:  MOVWF  x40
032B0:  MOVLB  0
032B2:  CALL   1044
032B6:  BTFSC  1B.7
032B8:  BSF    FF2.7
032BA:  MOVLW  0A
032BC:  MOVWF  FF6
032BE:  MOVLW  06
032C0:  MOVWF  FF7
032C2:  MOVLW  00
032C4:  MOVWF  FF8
032C6:  CLRF   1B
032C8:  BTFSC  FF2.7
032CA:  BSF    1B.7
032CC:  BCF    FF2.7
032CE:  CALL   0E6E
032D2:  BTFSC  1B.7
032D4:  BSF    FF2.7
032D6:  MOVLW  0D
032D8:  BTFSS  F9E.4
032DA:  BRA    32D8
032DC:  MOVWF  FAD
032DE:  MOVLW  0A
032E0:  BTFSS  F9E.4
032E2:  BRA    32E0
032E4:  MOVWF  FAD
....................          break;           
032E6:  BRA    3338
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
032E8:  MOVLW  12
032EA:  MOVWF  FF6
032EC:  MOVLW  06
032EE:  MOVWF  FF7
032F0:  MOVLW  00
032F2:  MOVWF  FF8
032F4:  CLRF   1B
032F6:  BTFSC  FF2.7
032F8:  BSF    1B.7
032FA:  BCF    FF2.7
032FC:  MOVLW  06
032FE:  MOVLB  A
03300:  MOVWF  x40
03302:  MOVLB  0
03304:  CALL   1044
03308:  BTFSC  1B.7
0330A:  BSF    FF2.7
0330C:  MOVLW  1E
0330E:  MOVWF  FF6
03310:  MOVLW  06
03312:  MOVWF  FF7
03314:  MOVLW  00
03316:  MOVWF  FF8
03318:  CLRF   1B
0331A:  BTFSC  FF2.7
0331C:  BSF    1B.7
0331E:  BCF    FF2.7
03320:  CALL   0E6E
03324:  BTFSC  1B.7
03326:  BSF    FF2.7
03328:  MOVLW  0D
0332A:  BTFSS  F9E.4
0332C:  BRA    332A
0332E:  MOVWF  FAD
03330:  MOVLW  0A
03332:  BTFSS  F9E.4
03334:  BRA    3332
03336:  MOVWF  FAD
....................          break; 
....................    } 
03338:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
17778:  MOVLW  26
1777A:  MOVWF  FF6
1777C:  MOVLW  06
1777E:  MOVWF  FF7
17780:  MOVLW  00
17782:  MOVWF  FF8
17784:  CLRF   1B
17786:  BTFSC  FF2.7
17788:  BSF    1B.7
1778A:  BCF    FF2.7
1778C:  CALL   0E6E
17790:  BTFSC  1B.7
17792:  BSF    FF2.7
17794:  GOTO   17BC8 (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0B32E:  MOVLW  2E
0B330:  MOVWF  FF6
0B332:  MOVLW  06
0B334:  MOVWF  FF7
0B336:  MOVLW  00
0B338:  MOVWF  FF8
0B33A:  CLRF   1B
0B33C:  BTFSC  FF2.7
0B33E:  BSF    1B.7
0B340:  BCF    FF2.7
0B342:  CALL   0E6E
0B346:  BTFSC  1B.7
0B348:  BSF    FF2.7
0B34A:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BFF0:  MOVLW  36
0BFF2:  MOVWF  FF6
0BFF4:  MOVLW  06
0BFF6:  MOVWF  FF7
0BFF8:  MOVLW  00
0BFFA:  MOVWF  FF8
0BFFC:  CLRF   1B
0BFFE:  BTFSC  FF2.7
0C000:  BSF    1B.7
0C002:  BCF    FF2.7
0C004:  CALL   0E6E
0C008:  BTFSC  1B.7
0C00A:  BSF    FF2.7
0C00C:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
0367E:  MOVLW  4E
03680:  MOVWF  FF6
03682:  MOVLW  06
03684:  MOVWF  FF7
03686:  MOVLW  00
03688:  MOVWF  FF8
0368A:  CLRF   1B
0368C:  BTFSC  FF2.7
0368E:  BSF    1B.7
03690:  BCF    FF2.7
03692:  CALL   0E6E
03696:  BTFSC  1B.7
03698:  BSF    FF2.7
0369A:  GOTO   43F0 (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
050A8:  MOVLW  56
050AA:  MOVWF  FF6
050AC:  MOVLW  06
050AE:  MOVWF  FF7
050B0:  MOVLW  00
050B2:  MOVWF  FF8
050B4:  CLRF   1B
050B6:  BTFSC  FF2.7
050B8:  BSF    1B.7
050BA:  BCF    FF2.7
050BC:  CALL   0E6E
050C0:  BTFSC  1B.7
050C2:  BSF    FF2.7
050C4:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
1626A:  MOVLW  5E
1626C:  MOVWF  FF6
1626E:  MOVLW  06
16270:  MOVWF  FF7
16272:  MOVLW  00
16274:  MOVWF  FF8
16276:  CLRF   1B
16278:  BTFSC  FF2.7
1627A:  BSF    1B.7
1627C:  BCF    FF2.7
1627E:  CALL   0E6E
16282:  BTFSC  1B.7
16284:  BSF    FF2.7
16286:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "\r\n?@BSY\r\n"); 
*
0AEF0:  DECFSZ 4E,W
0AEF2:  BRA    AF12
0AEF4:  MOVLW  66
0AEF6:  MOVWF  FF6
0AEF8:  MOVLW  06
0AEFA:  MOVWF  FF7
0AEFC:  MOVLW  00
0AEFE:  MOVWF  FF8
0AF00:  CLRF   1B
0AF02:  BTFSC  FF2.7
0AF04:  BSF    1B.7
0AF06:  BCF    FF2.7
0AF08:  CALL   0E6E
0AF0C:  BTFSC  1B.7
0AF0E:  BSF    FF2.7
0AF10:  BRA    AF2E
....................    else fprintf(COM_A, "\r\n@RDY\r\n"); 
0AF12:  MOVLW  70
0AF14:  MOVWF  FF6
0AF16:  MOVLW  06
0AF18:  MOVWF  FF7
0AF1A:  MOVLW  00
0AF1C:  MOVWF  FF8
0AF1E:  CLRF   1B
0AF20:  BTFSC  FF2.7
0AF22:  BSF    1B.7
0AF24:  BCF    FF2.7
0AF26:  CALL   0E6E
0AF2A:  BTFSC  1B.7
0AF2C:  BSF    FF2.7
0AF2E:  GOTO   1B578 (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
03568:  MOVLW  0A
0356A:  MOVLB  A
0356C:  MOVWF  x35
0356E:  MOVLW  2C
03570:  MOVFF  A35,A33
03574:  MOVWF  x32
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
03576:  MOVF   FC9,W
03578:  SETF   FC9
0357A:  RRCF   FC7,W
0357C:  BNC   357A
....................    SD_spi_read(sdcmd); 
0357E:  MOVF   FC9,W
03580:  MOVFF  A2B,FC9
03584:  RRCF   FC7,W
03586:  BNC   3584
....................    SD_spi_read(value[3]); 
03588:  MOVLW  03
0358A:  ADDWF  x32,W
0358C:  MOVWF  FE9
0358E:  MOVLW  00
03590:  ADDWFC x33,W
03592:  MOVWF  FEA
03594:  MOVFF  FEF,A34
03598:  MOVF   FC9,W
0359A:  MOVFF  A34,FC9
0359E:  RRCF   FC7,W
035A0:  BNC   359E
....................    SD_spi_read(value[2]); 
035A2:  MOVLW  02
035A4:  ADDWF  x32,W
035A6:  MOVWF  FE9
035A8:  MOVLW  00
035AA:  ADDWFC x33,W
035AC:  MOVWF  FEA
035AE:  MOVFF  FEF,A34
035B2:  MOVF   FC9,W
035B4:  MOVFF  A34,FC9
035B8:  RRCF   FC7,W
035BA:  BNC   35B8
....................    SD_spi_read(value[1]); 
035BC:  MOVLW  01
035BE:  ADDWF  x32,W
035C0:  MOVWF  FE9
035C2:  MOVLW  00
035C4:  ADDWFC x33,W
035C6:  MOVWF  FEA
035C8:  MOVFF  FEF,A34
035CC:  MOVF   FC9,W
035CE:  MOVFF  A34,FC9
035D2:  RRCF   FC7,W
035D4:  BNC   35D2
....................    SD_spi_read(value[0]); 
035D6:  MOVFF  A32,FE9
035DA:  MOVFF  A33,FEA
035DE:  MOVFF  FEF,A34
035E2:  MOVF   FC9,W
035E4:  MOVFF  A34,FC9
035E8:  RRCF   FC7,W
035EA:  BNC   35E8
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
035EC:  MOVF   x2B,W
035EE:  SUBLW  48
035F0:  BNZ   35FE
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
035F2:  MOVF   FC9,W
035F4:  MOVLW  87
035F6:  MOVWF  FC9
035F8:  RRCF   FC7,W
035FA:  BNC   35F8
035FC:  BRA    3608
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
035FE:  MOVF   FC9,W
03600:  MOVLW  95
03602:  MOVWF  FC9
03604:  RRCF   FC7,W
03606:  BNC   3604
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
03608:  CLRF   x30
....................    response = SD_spi_read(0xFF); 
0360A:  MOVF   FC9,W
0360C:  SETF   FC9
0360E:  RRCF   FC7,W
03610:  BNC   360E
03612:  MOVFF  FC9,A31
....................    while ((response == 0xFF) && (i < 100)) 
03616:  INCFSZ x31,W
03618:  BRA    3630
0361A:  MOVF   x30,W
0361C:  SUBLW  63
0361E:  BNC   3630
....................       { 
....................       i++; 
03620:  INCF   x30,F
....................       response = SD_spi_read(0xFF); 
03622:  MOVF   FC9,W
03624:  SETF   FC9
03626:  RRCF   FC7,W
03628:  BNC   3626
0362A:  MOVFF  FC9,A31
0362E:  BRA    3616
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
03630:  MOVFF  A31,01
03634:  MOVLB  0
03636:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
043FC:  MOVLW  50
043FE:  MOVLB  A
04400:  MOVWF  x2B
04402:  MOVFF  A2A,A2F
04406:  MOVFF  A29,A2E
0440A:  MOVFF  A28,A2D
0440E:  MOVFF  A27,A2C
04412:  MOVLB  0
04414:  CALL   3568
04418:  MOVF   01,W
0441A:  BZ    4422
0441C:  XORLW  40
0441E:  BZ    4438
04420:  BRA    443E
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
04422:  MOVFF  A2A,4EC
04426:  MOVFF  A29,4EB
0442A:  MOVFF  A28,4EA
0442E:  MOVFF  A27,4E9
....................          return(TRUE); 
04432:  MOVLW  01
04434:  MOVWF  01
04436:  BRA    4442
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
04438:  MOVLW  00
0443A:  MOVWF  01
0443C:  BRA    4442
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
0443E:  MOVLW  00
04440:  MOVWF  01
....................       } 
04442:  GOTO   4526 (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
04446:  MOVF   FC9,W
04448:  SETF   FC9
0444A:  RRCF   FC7,W
0444C:  BNC   444A
0444E:  MOVFF  FC9,A2F
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
04452:  MOVLB  A
04454:  CLRF   x2E
04456:  CLRF   x2D
04458:  MOVF   x2E,W
0445A:  SUBLW  27
0445C:  BNC   4486
0445E:  BNZ   4466
04460:  MOVF   x2D,W
04462:  SUBLW  0F
04464:  BNC   4486
04466:  INCFSZ x2F,W
04468:  BRA    4486
....................       { 
....................       delay_us(10); 
0446A:  MOVLW  35
0446C:  MOVWF  00
0446E:  DECFSZ 00,F
04470:  BRA    446E
....................       response = SD_spi_read(0xFF);  
04472:  MOVF   FC9,W
04474:  SETF   FC9
04476:  RRCF   FC7,W
04478:  BNC   4476
0447A:  MOVFF  FC9,A2F
0447E:  INCF   x2D,F
04480:  BTFSC  FD8.2
04482:  INCF   x2E,F
04484:  BRA    4458
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
04486:  MOVF   x2F,W
04488:  SUBLW  FE
0448A:  BZ    449A
....................       { 
....................       if (!response) 
0448C:  MOVF   x2F,F
0448E:  BNZ   4494
....................          response = 0xFE; 
04490:  MOVLW  FE
04492:  MOVWF  x2F
....................       return(response); 
04494:  MOVFF  A2F,01
04498:  BRA    44F0
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
0449A:  CLRF   x2E
0449C:  CLRF   x2D
0449E:  MOVF   x2C,F
044A0:  BNZ   44B4
044A2:  MOVF   x2B,F
044A4:  BNZ   44B4
044A6:  MOVF   x2E,W
044A8:  SUBWF  x2A,W
044AA:  BNC   44D4
044AC:  BNZ   44B4
044AE:  MOVF   x29,W
044B0:  SUBWF  x2D,W
044B2:  BC    44D4
....................       ptr[i]=SD_spi_read(0xFF); 
044B4:  MOVF   x27,W
044B6:  ADDWF  x2D,W
044B8:  MOVWF  FE9
044BA:  MOVF   x28,W
044BC:  ADDWFC x2E,W
044BE:  MOVWF  FEA
044C0:  MOVF   FC9,W
044C2:  SETF   FC9
044C4:  RRCF   FC7,W
044C6:  BNC   44C4
044C8:  MOVFF  FC9,FEF
044CC:  INCF   x2D,F
044CE:  BTFSC  FD8.2
044D0:  INCF   x2E,F
044D2:  BRA    449E
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
044D4:  MOVF   FC9,W
044D6:  SETF   FC9
044D8:  RRCF   FC7,W
044DA:  BNC   44D8
....................    SD_spi_read(0xFF); 
044DC:  MOVF   FC9,W
044DE:  SETF   FC9
044E0:  RRCF   FC7,W
044E2:  BNC   44E0
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
044E4:  MOVF   FC9,W
044E6:  SETF   FC9
044E8:  RRCF   FC7,W
044EA:  BNC   44E8
....................    return(0); 
044EC:  MOVLW  00
044EE:  MOVWF  01
044F0:  MOVLB  0
044F2:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
0586E:  MOVLW  C3
05870:  MOVLB  A
05872:  MOVWF  x2F
05874:  MOVLW  50
05876:  MOVWF  x2E
....................    SD_spi_read(0xFF); 
05878:  MOVF   FC9,W
0587A:  SETF   FC9
0587C:  RRCF   FC7,W
0587E:  BNC   587C
....................    do 
....................       { 
....................       delay_us(10); 
05880:  MOVLW  35
05882:  MOVWF  00
05884:  DECFSZ 00,F
05886:  BRA    5884
....................       response = SD_spi_read(0xFF); 
05888:  MOVF   FC9,W
0588A:  SETF   FC9
0588C:  RRCF   FC7,W
0588E:  BNC   588C
05890:  MOVFF  FC9,A2D
....................       Timer--; 
05894:  MOVF   x2E,W
05896:  BTFSC  FD8.2
05898:  DECF   x2F,F
0589A:  DECF   x2E,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
0589C:  INCFSZ x2D,W
0589E:  BRA    58A2
058A0:  BRA    58A8
058A2:  MOVF   x2E,W
058A4:  IORWF  x2F,W
058A6:  BNZ   5880
....................       ; 
....................  
....................    return (response); 
058A8:  MOVFF  A2D,01
058AC:  MOVLB  0
058AE:  GOTO   58BE (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
058B2:  MOVLW  02
058B4:  MOVLB  A
058B6:  MOVWF  x2C
058B8:  CLRF   x2B
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
058BA:  MOVLB  0
058BC:  BRA    586E
058BE:  INCFSZ 01,W
058C0:  BRA    58C4
058C2:  BRA    58CA
....................       return (FALSE); 
058C4:  MOVLW  00
058C6:  MOVWF  01
058C8:  BRA    5964
....................  
....................    SD_spi_write(token);               // transmit data token 
058CA:  MOVF   FC9,W
058CC:  MOVFF  A29,FC9
058D0:  RRCF   FC7,W
058D2:  BNC   58D0
....................    if (token != 0xFD) 
058D4:  MOVLB  A
058D6:  MOVF   x29,W
058D8:  SUBLW  FD
058DA:  BZ    595E
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
058DC:  MOVFF  A2C,03
058E0:  MOVF   x2B,W
058E2:  BTFSC  FD8.2
058E4:  DECF   x2C,F
058E6:  DECF   x2B,F
058E8:  IORWF  03,W
058EA:  BZ    590E
....................          SD_spi_write(*ptr++); 
058EC:  MOVFF  A28,03
058F0:  MOVF   x27,W
058F2:  INCF   x27,F
058F4:  BTFSC  FD8.2
058F6:  INCF   x28,F
058F8:  MOVWF  FE9
058FA:  MOVFF  03,FEA
058FE:  MOVFF  FEF,A2D
05902:  MOVF   FC9,W
05904:  MOVFF  A2D,FC9
05908:  RRCF   FC7,W
0590A:  BNC   5908
0590C:  BRA    58DC
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
0590E:  MOVF   FC9,W
05910:  SETF   FC9
05912:  RRCF   FC7,W
05914:  BNC   5912
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
05916:  MOVF   FC9,W
05918:  SETF   FC9
0591A:  RRCF   FC7,W
0591C:  BNC   591A
....................       response = SD_spi_read(0xFF);      // Receive data response 
0591E:  MOVF   FC9,W
05920:  SETF   FC9
05922:  RRCF   FC7,W
05924:  BNC   5922
05926:  MOVFF  FC9,A2A
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
0592A:  CLRF   x2C
0592C:  CLRF   x2B
0592E:  MOVF   x2C,W
05930:  SUBLW  C3
05932:  BNC   595E
05934:  BNZ   593C
05936:  MOVF   x2B,W
05938:  SUBLW  4F
0593A:  BNC   595E
....................          { 
....................          delay_us(10); 
0593C:  MOVLW  35
0593E:  MOVWF  00
05940:  DECFSZ 00,F
05942:  BRA    5940
....................          response = SD_spi_read(0xFF);   // digest prior operation 
05944:  MOVF   FC9,W
05946:  SETF   FC9
05948:  RRCF   FC7,W
0594A:  BNC   5948
0594C:  MOVFF  FC9,A2A
....................          if (response != 0x00) 
05950:  MOVF   x2A,F
05952:  BZ    5956
....................             break; 
05954:  BRA    595E
05956:  INCF   x2B,F
05958:  BTFSC  FD8.2
0595A:  INCF   x2C,F
0595C:  BRA    592E
....................          } 
....................  
....................       } 
....................    return(TRUE); 
0595E:  MOVLW  01
05960:  MOVWF  01
05962:  MOVLB  0
05964:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
05966:  MOVLB  4
05968:  BTFSS  xED.0
0596A:  BRA    5972
....................       return (RES_NOTRDY); 
0596C:  MOVLW  03
0596E:  MOVWF  01
05970:  BRA    5AA6
....................  
....................    if (Media_Status & STA_PROTECT) 
05972:  BTFSS  xED.2
05974:  BRA    597C
....................       return (RES_WRPRT); 
05976:  MOVLW  02
05978:  MOVWF  01
0597A:  BRA    5AA6
....................  
....................    if (!SectorCount) 
0597C:  MOVLB  A
0597E:  MOVF   x26,F
05980:  BNZ   598C
....................       return (RES_PARERR); 
05982:  MOVLW  04
05984:  MOVWF  01
05986:  MOVLB  4
05988:  BRA    5AA6
0598A:  MOVLB  A
....................  
....................    SelectSD; 
0598C:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
0598E:  MOVLB  4
05990:  MOVF   xE7,W
05992:  SUBLW  05
05994:  BZ    59B0
....................       SectorNumber *= 512; 
05996:  BCF    FD8.0
05998:  MOVFF  A24,A25
0599C:  MOVFF  A23,A24
059A0:  MOVFF  A22,A23
059A4:  MOVLB  A
059A6:  CLRF   x22
059A8:  RLCF   x23,F
059AA:  RLCF   x24,F
059AC:  RLCF   x25,F
059AE:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
059B0:  MOVLB  A
059B2:  DECFSZ x26,W
059B4:  BRA    59F4
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
059B6:  MOVLW  58
059B8:  MOVWF  x2B
059BA:  MOVFF  A25,A2F
059BE:  MOVFF  A24,A2E
059C2:  MOVFF  A23,A2D
059C6:  MOVFF  A22,A2C
059CA:  MOVLB  0
059CC:  CALL   3568
059D0:  MOVF   01,F
059D2:  BNZ   59F0
....................          if (SD_write_data(Buffer, 0xFE)) 
059D4:  MOVFF  A21,A28
059D8:  MOVFF  A20,A27
059DC:  MOVLW  FE
059DE:  MOVLB  A
059E0:  MOVWF  x29
059E2:  MOVLB  0
059E4:  RCALL  58B2
059E6:  MOVF   01,F
059E8:  BZ    59F0
....................             SectorCount = 0; 
059EA:  MOVLB  A
059EC:  CLRF   x26
059EE:  MOVLB  0
....................       } 
059F0:  BRA    5A8C
059F2:  MOVLB  A
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
059F4:  MOVLB  4
059F6:  MOVF   xE7,W
059F8:  ANDLW  03
059FA:  BZ    5A28
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
059FC:  MOVLW  77
059FE:  MOVLB  A
05A00:  MOVWF  x2B
05A02:  CLRF   x2F
05A04:  CLRF   x2E
05A06:  CLRF   x2D
05A08:  CLRF   x2C
05A0A:  MOVLB  0
05A0C:  CALL   3568
....................          SD_cmd(SD_ACMD23, SectorCount); 
05A10:  MOVLW  57
05A12:  MOVLB  A
05A14:  MOVWF  x2B
05A16:  CLRF   x2F
05A18:  CLRF   x2E
05A1A:  CLRF   x2D
05A1C:  MOVFF  A26,A2C
05A20:  MOVLB  0
05A22:  CALL   3568
05A26:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
05A28:  MOVLW  59
05A2A:  MOVLB  A
05A2C:  MOVWF  x2B
05A2E:  MOVFF  A25,A2F
05A32:  MOVFF  A24,A2E
05A36:  MOVFF  A23,A2D
05A3A:  MOVFF  A22,A2C
05A3E:  MOVLB  0
05A40:  CALL   3568
05A44:  MOVF   01,F
05A46:  BNZ   5A8C
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
05A48:  MOVFF  A21,A28
05A4C:  MOVFF  A20,A27
05A50:  MOVLW  FC
05A52:  MOVLB  A
05A54:  MOVWF  x29
05A56:  MOVLB  0
05A58:  RCALL  58B2
05A5A:  MOVF   01,F
05A5C:  BNZ   5A60
....................                break; 
05A5E:  BRA    5A72
....................             Buffer += 512; 
05A60:  MOVLW  02
05A62:  MOVLB  A
05A64:  ADDWF  x21,F
....................             } while (--SectorCount); 
05A66:  DECF   x26,F
05A68:  BTFSC  FD8.2
05A6A:  BRA    5A70
05A6C:  MOVLB  0
05A6E:  BRA    5A48
05A70:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
05A72:  MOVLB  A
05A74:  CLRF   x28
05A76:  CLRF   x27
05A78:  MOVLW  FD
05A7A:  MOVWF  x29
05A7C:  MOVLB  0
05A7E:  RCALL  58B2
05A80:  MOVF   01,F
05A82:  BNZ   5A8C
....................             SectorCount = 1; 
05A84:  MOVLW  01
05A86:  MOVLB  A
05A88:  MOVWF  x26
05A8A:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
05A8C:  BSF    F91.1
....................    SD_spi_read(0xFF); 
05A8E:  MOVF   FC9,W
05A90:  SETF   FC9
05A92:  RRCF   FC7,W
05A94:  BNC   5A92
....................    return SectorCount ? RES_ERROR : RES_OK; 
05A96:  MOVLB  A
05A98:  MOVF   x26,F
05A9A:  BZ    5AA0
05A9C:  MOVLW  01
05A9E:  BRA    5AA2
05AA0:  MOVLW  00
05AA2:  MOVWF  01
05AA4:  MOVLB  4
05AA6:  MOVLB  0
05AA8:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
044F4:  MOVLB  4
044F6:  BTFSS  xED.0
044F8:  BRA    4500
....................       return (RES_NOTRDY); 
044FA:  MOVLW  03
044FC:  MOVWF  01
044FE:  BRA    4630
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
04500:  MOVLB  A
04502:  MOVF   x26,W
04504:  SUBLW  01
04506:  BNC   450C
04508:  MOVF   x26,F
0450A:  BNZ   4516
....................       return(RES_PARERR); 
0450C:  MOVLW  04
0450E:  MOVWF  01
04510:  MOVLB  4
04512:  BRA    4630
04514:  MOVLB  A
....................  
....................    SelectSD; 
04516:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
04518:  CLRF   x2A
0451A:  CLRF   x29
0451C:  MOVLW  02
0451E:  MOVWF  x28
04520:  CLRF   x27
04522:  MOVLB  0
04524:  BRA    43FC
04526:  MOVF   01,F
04528:  BNZ   4536
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
0452A:  BSF    F91.1
....................       return(RES_ERROR); 
0452C:  MOVLW  01
0452E:  MOVWF  01
04530:  MOVLB  4
04532:  BRA    4630
04534:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
04536:  MOVLB  4
04538:  MOVF   xE7,W
0453A:  SUBLW  05
0453C:  BZ    4558
....................       SectorNumber *= 512; 
0453E:  BCF    FD8.0
04540:  MOVFF  A24,A25
04544:  MOVFF  A23,A24
04548:  MOVFF  A22,A23
0454C:  MOVLB  A
0454E:  CLRF   x22
04550:  RLCF   x23,F
04552:  RLCF   x24,F
04554:  RLCF   x25,F
04556:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
04558:  MOVLB  A
0455A:  DECFSZ x26,W
0455C:  BRA    45B4
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
0455E:  MOVLW  51
04560:  MOVWF  x2B
04562:  MOVFF  A25,A2F
04566:  MOVFF  A24,A2E
0456A:  MOVFF  A23,A2D
0456E:  MOVFF  A22,A2C
04572:  MOVLB  0
04574:  CALL   3568
04578:  MOVF   01,F
0457A:  BZ    4588
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
0457C:  BSF    F91.1
....................          return(RES_PARERR); 
0457E:  MOVLW  04
04580:  MOVWF  01
04582:  MOVLB  4
04584:  BRA    4630
04586:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
04588:  MOVFF  A21,A28
0458C:  MOVFF  A20,A27
04590:  MOVLB  A
04592:  CLRF   x2C
04594:  CLRF   x2B
04596:  MOVLW  02
04598:  MOVWF  x2A
0459A:  CLRF   x29
0459C:  MOVLB  0
0459E:  RCALL  4446
045A0:  MOVF   01,F
045A2:  BZ    45B0
....................          { 
....................          DeselectSD; 
045A4:  BSF    F91.1
....................          return(RES_ERROR); 
045A6:  MOVLW  01
045A8:  MOVWF  01
045AA:  MOVLB  4
045AC:  BRA    4630
045AE:  MOVLB  0
....................          } 
....................       } 
045B0:  BRA    4628
045B2:  MOVLB  A
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
045B4:  MOVLW  52
045B6:  MOVWF  x2B
045B8:  MOVFF  A25,A2F
045BC:  MOVFF  A24,A2E
045C0:  MOVFF  A23,A2D
045C4:  MOVFF  A22,A2C
045C8:  MOVLB  0
045CA:  CALL   3568
045CE:  MOVF   01,F
045D0:  BZ    45DE
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
045D2:  BSF    F91.1
....................          return(RES_PARERR); 
045D4:  MOVLW  04
045D6:  MOVWF  01
045D8:  MOVLB  4
045DA:  BRA    4630
045DC:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
045DE:  MOVFF  A21,A28
045E2:  MOVFF  A20,A27
045E6:  MOVLB  A
045E8:  CLRF   x2C
045EA:  CLRF   x2B
045EC:  MOVLW  02
045EE:  MOVWF  x2A
045F0:  CLRF   x29
045F2:  MOVLB  0
045F4:  RCALL  4446
045F6:  MOVF   01,F
045F8:  BZ    4606
....................             { 
....................             DeselectSD; 
045FA:  BSF    F91.1
....................             return(RES_ERROR); 
045FC:  MOVLW  01
045FE:  MOVWF  01
04600:  MOVLB  4
04602:  BRA    4630
04604:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
04606:  MOVLW  02
04608:  MOVLB  A
0460A:  ADDWF  x21,F
....................          } while (--SectorCount); 
0460C:  DECF   x26,F
0460E:  BTFSC  FD8.2
04610:  BRA    4616
04612:  MOVLB  0
04614:  BRA    45DE
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
04616:  MOVLW  4C
04618:  MOVWF  x2B
0461A:  CLRF   x2F
0461C:  CLRF   x2E
0461E:  CLRF   x2D
04620:  CLRF   x2C
04622:  MOVLB  0
04624:  CALL   3568
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
04628:  BSF    F91.1
....................    return(RES_OK); 
0462A:  MOVLW  00
0462C:  MOVWF  01
0462E:  MOVLB  4
04630:  MOVLB  0
04632:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
055C6:  MOVLB  4
055C8:  BCF    xED.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
055CA:  BCF    xED.2
....................  
....................    return(Media_Status); 
055CC:  MOVFF  4ED,01
055D0:  MOVLB  0
055D2:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
0369E:  MOVLB  9
036A0:  CLRF   xEB
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
036A2:  MOVLB  4
036A4:  CLRF   xE7
....................  
....................    DeselectSD; 
036A6:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
036A8:  MOVLW  0A
036AA:  MOVLB  9
036AC:  MOVWF  xEC
036AE:  MOVLB  0
036B0:  CALL   2938
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
036B4:  BCF    FC6.5
036B6:  MOVLW  22
036B8:  MOVWF  FC6
036BA:  MOVLW  40
036BC:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
036BE:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
036C0:  MOVLB  9
036C2:  CLRF   xE3
036C4:  MOVF   xE3,W
036C6:  SUBLW  09
036C8:  BNC   36D6
....................       SD_spi_read(0xFF); 
036CA:  MOVF   FC9,W
036CC:  SETF   FC9
036CE:  RRCF   FC7,W
036D0:  BNC   36CE
036D2:  INCF   xE3,F
036D4:  BRA    36C4
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
036D6:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
036D8:  MOVF   1F,W
036DA:  SUBLW  04
036DC:  BNZ   3702
036DE:  MOVF   20,F
036E0:  BNZ   3702
036E2:  MOVLW  7A
036E4:  MOVWF  FF6
036E6:  MOVLW  06
036E8:  MOVWF  FF7
036EA:  MOVLW  00
036EC:  MOVWF  FF8
036EE:  CLRF   1B
036F0:  BTFSC  FF2.7
036F2:  BSF    1B.7
036F4:  BCF    FF2.7
036F6:  MOVLB  0
036F8:  CALL   0E6E
036FC:  BTFSC  1B.7
036FE:  BSF    FF2.7
03700:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
03702:  MOVLW  40
03704:  MOVLB  A
03706:  MOVWF  x2B
03708:  CLRF   x2F
0370A:  CLRF   x2E
0370C:  CLRF   x2D
0370E:  CLRF   x2C
03710:  MOVLB  0
03712:  RCALL  3568
03714:  MOVFF  01,9E4
....................    if (response > 1 ) 
03718:  MOVLB  9
0371A:  MOVF   xE4,W
0371C:  SUBLW  01
0371E:  BC    3774
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
03720:  MOVF   1F,W
03722:  SUBLW  04
03724:  BNZ   376E
03726:  MOVF   20,F
03728:  BNZ   376E
0372A:  MOVLW  8A
0372C:  MOVWF  FF6
0372E:  MOVLW  06
03730:  MOVWF  FF7
03732:  MOVLW  00
03734:  MOVWF  FF8
03736:  CLRF   1B
03738:  BTFSC  FF2.7
0373A:  BSF    1B.7
0373C:  BCF    FF2.7
0373E:  MOVLW  31
03740:  MOVLB  A
03742:  MOVWF  x40
03744:  MOVLB  0
03746:  CALL   1044
0374A:  BTFSC  1B.7
0374C:  BSF    FF2.7
0374E:  MOVFF  9E4,9EC
03752:  MOVLW  57
03754:  MOVLB  9
03756:  MOVWF  xED
03758:  MOVLB  0
0375A:  RCALL  3638
0375C:  MOVLW  0D
0375E:  BTFSS  F9E.4
03760:  BRA    375E
03762:  MOVWF  FAD
03764:  MOVLW  0A
03766:  BTFSS  F9E.4
03768:  BRA    3766
0376A:  MOVWF  FAD
0376C:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
0376E:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
03770:  GOTO   43F2
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
03774:  MOVF   1F,W
03776:  SUBLW  04
03778:  BNZ   37C2
0377A:  MOVF   20,F
0377C:  BNZ   37C2
0377E:  MOVLW  C2
03780:  MOVWF  FF6
03782:  MOVLW  06
03784:  MOVWF  FF7
03786:  MOVLW  00
03788:  MOVWF  FF8
0378A:  CLRF   1B
0378C:  BTFSC  FF2.7
0378E:  BSF    1B.7
03790:  BCF    FF2.7
03792:  MOVLW  1A
03794:  MOVLB  A
03796:  MOVWF  x40
03798:  MOVLB  0
0379A:  CALL   1044
0379E:  BTFSC  1B.7
037A0:  BSF    FF2.7
037A2:  MOVFF  9E4,9EC
037A6:  MOVLW  57
037A8:  MOVLB  9
037AA:  MOVWF  xED
037AC:  MOVLB  0
037AE:  RCALL  3638
037B0:  MOVLW  0D
037B2:  BTFSS  F9E.4
037B4:  BRA    37B2
037B6:  MOVWF  FAD
037B8:  MOVLW  0A
037BA:  BTFSS  F9E.4
037BC:  BRA    37BA
037BE:  MOVWF  FAD
037C0:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
037C2:  MOVLW  48
037C4:  MOVLB  A
037C6:  MOVWF  x2B
037C8:  CLRF   x2F
037CA:  CLRF   x2E
037CC:  MOVLW  01
037CE:  MOVWF  x2D
037D0:  MOVLW  AA
037D2:  MOVWF  x2C
037D4:  MOVLB  0
037D6:  RCALL  3568
037D8:  MOVFF  01,9E4
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
037DC:  MOVF   1F,W
037DE:  SUBLW  04
037E0:  BNZ   3828
037E2:  MOVF   20,F
037E4:  BNZ   3828
037E6:  MOVLW  E4
037E8:  MOVWF  FF6
037EA:  MOVLW  06
037EC:  MOVWF  FF7
037EE:  MOVLW  00
037F0:  MOVWF  FF8
037F2:  CLRF   1B
037F4:  BTFSC  FF2.7
037F6:  BSF    1B.7
037F8:  BCF    FF2.7
037FA:  MOVLW  25
037FC:  MOVLB  A
037FE:  MOVWF  x40
03800:  MOVLB  0
03802:  CALL   1044
03806:  BTFSC  1B.7
03808:  BSF    FF2.7
0380A:  MOVFF  9E4,9EC
0380E:  MOVLW  57
03810:  MOVLB  9
03812:  MOVWF  xED
03814:  MOVLB  0
03816:  RCALL  3638
03818:  MOVLW  0D
0381A:  BTFSS  F9E.4
0381C:  BRA    381A
0381E:  MOVWF  FAD
03820:  MOVLW  0A
03822:  BTFSS  F9E.4
03824:  BRA    3822
03826:  MOVWF  FAD
....................    if (response == 1)  
03828:  MOVLB  9
0382A:  DECFSZ xE4,W
0382C:  BRA    3BFE
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
0382E:  MOVF   1F,W
03830:  SUBLW  04
03832:  BNZ   3858
03834:  MOVF   20,F
03836:  BNZ   3858
03838:  MOVLW  0E
0383A:  MOVWF  FF6
0383C:  MOVLW  07
0383E:  MOVWF  FF7
03840:  MOVLW  00
03842:  MOVWF  FF8
03844:  CLRF   1B
03846:  BTFSC  FF2.7
03848:  BSF    1B.7
0384A:  BCF    FF2.7
0384C:  MOVLB  0
0384E:  CALL   0E6E
03852:  BTFSC  1B.7
03854:  BSF    FF2.7
03856:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
03858:  CLRF   xE3
0385A:  MOVF   xE3,W
0385C:  SUBLW  03
0385E:  BNC   387E
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
03860:  CLRF   03
03862:  MOVF   xE3,W
03864:  ADDLW  E5
03866:  MOVWF  FE9
03868:  MOVLW  09
0386A:  ADDWFC 03,W
0386C:  MOVWF  FEA
0386E:  MOVF   FC9,W
03870:  SETF   FC9
03872:  RRCF   FC7,W
03874:  BNC   3872
03876:  MOVFF  FC9,FEF
0387A:  INCF   xE3,F
0387C:  BRA    385A
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
0387E:  MOVF   1F,W
03880:  SUBLW  04
03882:  BNZ   38F6
03884:  MOVF   20,F
03886:  BNZ   38F6
03888:  MOVLW  30
0388A:  MOVWF  FF6
0388C:  MOVLW  07
0388E:  MOVWF  FF7
03890:  MOVLW  00
03892:  MOVWF  FF8
03894:  CLRF   1B
03896:  BTFSC  FF2.7
03898:  BSF    1B.7
0389A:  BCF    FF2.7
0389C:  MOVLW  1F
0389E:  MOVLB  A
038A0:  MOVWF  x40
038A2:  MOVLB  0
038A4:  CALL   1044
038A8:  BTFSC  1B.7
038AA:  BSF    FF2.7
038AC:  MOVFF  9E5,9EC
038B0:  MOVLW  57
038B2:  MOVLB  9
038B4:  MOVWF  xED
038B6:  MOVLB  0
038B8:  RCALL  3638
038BA:  MOVFF  9E6,9EC
038BE:  MOVLW  57
038C0:  MOVLB  9
038C2:  MOVWF  xED
038C4:  MOVLB  0
038C6:  RCALL  3638
038C8:  MOVFF  9E7,9EC
038CC:  MOVLW  57
038CE:  MOVLB  9
038D0:  MOVWF  xED
038D2:  MOVLB  0
038D4:  RCALL  3638
038D6:  MOVFF  9E8,9EC
038DA:  MOVLW  57
038DC:  MOVLB  9
038DE:  MOVWF  xED
038E0:  MOVLB  0
038E2:  RCALL  3638
038E4:  MOVLW  0D
038E6:  BTFSS  F9E.4
038E8:  BRA    38E6
038EA:  MOVWF  FAD
038EC:  MOVLW  0A
038EE:  BTFSS  F9E.4
038F0:  BRA    38EE
038F2:  MOVWF  FAD
038F4:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
038F6:  DECFSZ xE7,W
038F8:  BRA    3BD4
038FA:  MOVF   xE8,W
038FC:  SUBLW  AA
038FE:  BTFSS  FD8.2
03900:  BRA    3BD4
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
03902:  MOVF   1F,W
03904:  SUBLW  04
03906:  BNZ   392C
03908:  MOVF   20,F
0390A:  BNZ   392C
0390C:  MOVLW  62
0390E:  MOVWF  FF6
03910:  MOVLW  07
03912:  MOVWF  FF7
03914:  MOVLW  00
03916:  MOVWF  FF8
03918:  CLRF   1B
0391A:  BTFSC  FF2.7
0391C:  BSF    1B.7
0391E:  BCF    FF2.7
03920:  MOVLB  0
03922:  CALL   0E6E
03926:  BTFSC  1B.7
03928:  BSF    FF2.7
0392A:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
0392C:  MOVF   1F,W
0392E:  SUBLW  04
03930:  BNZ   3956
03932:  MOVF   20,F
03934:  BNZ   3956
03936:  MOVLW  88
03938:  MOVWF  FF6
0393A:  MOVLW  07
0393C:  MOVWF  FF7
0393E:  MOVLW  00
03940:  MOVWF  FF8
03942:  CLRF   1B
03944:  BTFSC  FF2.7
03946:  BSF    1B.7
03948:  BCF    FF2.7
0394A:  MOVLB  0
0394C:  CALL   0E6E
03950:  BTFSC  1B.7
03952:  BSF    FF2.7
03954:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
03956:  CLRF   xEA
03958:  CLRF   xE9
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
0395A:  MOVLW  77
0395C:  MOVLB  A
0395E:  MOVWF  x2B
03960:  CLRF   x2F
03962:  CLRF   x2E
03964:  CLRF   x2D
03966:  CLRF   x2C
03968:  MOVLB  0
0396A:  RCALL  3568
0396C:  MOVFF  01,9E4
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
03970:  MOVLW  69
03972:  MOVLB  A
03974:  MOVWF  x2B
03976:  MOVLW  40
03978:  MOVWF  x2F
0397A:  CLRF   x2E
0397C:  CLRF   x2D
0397E:  CLRF   x2C
03980:  MOVLB  0
03982:  RCALL  3568
03984:  MOVFF  01,9E4
....................          while (response && (Timer < 50000)) 
03988:  MOVLB  9
0398A:  MOVF   xE4,F
0398C:  BZ    39DE
0398E:  MOVF   xEA,W
03990:  SUBLW  C3
03992:  BNC   39DE
03994:  BNZ   399C
03996:  MOVF   xE9,W
03998:  SUBLW  4F
0399A:  BNC   39DE
....................          { 
....................             delay_us(20); 
0399C:  MOVLW  6A
0399E:  MOVWF  00
039A0:  DECFSZ 00,F
039A2:  BRA    39A0
039A4:  NOP   
....................             Timer++; 
039A6:  INCF   xE9,F
039A8:  BTFSC  FD8.2
039AA:  INCF   xEA,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
039AC:  MOVLW  77
039AE:  MOVLB  A
039B0:  MOVWF  x2B
039B2:  CLRF   x2F
039B4:  CLRF   x2E
039B6:  CLRF   x2D
039B8:  CLRF   x2C
039BA:  MOVLB  0
039BC:  RCALL  3568
039BE:  MOVFF  01,9E4
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
039C2:  MOVLW  69
039C4:  MOVLB  A
039C6:  MOVWF  x2B
039C8:  MOVLW  40
039CA:  MOVWF  x2F
039CC:  CLRF   x2E
039CE:  CLRF   x2D
039D0:  CLRF   x2C
039D2:  MOVLB  0
039D4:  RCALL  3568
039D6:  MOVFF  01,9E4
039DA:  BRA    3988
039DC:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
039DE:  MOVF   1F,W
039E0:  SUBLW  04
039E2:  BNZ   3A6C
039E4:  MOVF   20,F
039E6:  BNZ   3A6C
039E8:  MOVLW  B6
039EA:  MOVWF  FF6
039EC:  MOVLW  07
039EE:  MOVWF  FF7
039F0:  MOVLW  00
039F2:  MOVWF  FF8
039F4:  CLRF   1B
039F6:  BTFSC  FF2.7
039F8:  BSF    1B.7
039FA:  BCF    FF2.7
039FC:  MOVLW  23
039FE:  MOVLB  A
03A00:  MOVWF  x40
03A02:  MOVLB  0
03A04:  CALL   1044
03A08:  BTFSC  1B.7
03A0A:  BSF    FF2.7
03A0C:  MOVFF  9E4,9EC
03A10:  MOVLW  57
03A12:  MOVLB  9
03A14:  MOVWF  xED
03A16:  MOVLB  0
03A18:  RCALL  3638
03A1A:  MOVLW  DD
03A1C:  MOVWF  FF6
03A1E:  MOVLW  07
03A20:  MOVWF  FF7
03A22:  MOVLW  00
03A24:  MOVWF  FF8
03A26:  CLRF   1B
03A28:  BTFSC  FF2.7
03A2A:  BSF    1B.7
03A2C:  BCF    FF2.7
03A2E:  MOVLW  0A
03A30:  MOVLB  A
03A32:  MOVWF  x40
03A34:  MOVLB  0
03A36:  CALL   1044
03A3A:  BTFSC  1B.7
03A3C:  BSF    FF2.7
03A3E:  MOVLW  10
03A40:  MOVWF  FE9
03A42:  CLRF   1B
03A44:  BTFSC  FF2.7
03A46:  BSF    1B.7
03A48:  BCF    FF2.7
03A4A:  MOVFF  9EA,A41
03A4E:  MOVFF  9E9,A40
03A52:  CALL   11C6
03A56:  BTFSC  1B.7
03A58:  BSF    FF2.7
03A5A:  MOVLW  0D
03A5C:  BTFSS  F9E.4
03A5E:  BRA    3A5C
03A60:  MOVWF  FAD
03A62:  MOVLW  0A
03A64:  BTFSS  F9E.4
03A66:  BRA    3A64
03A68:  MOVWF  FAD
03A6A:  MOVLB  9
....................          if (!response) 
03A6C:  MOVF   xE4,F
03A6E:  BTFSS  FD8.2
03A70:  BRA    3BD2
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
03A72:  MOVLW  7A
03A74:  MOVLB  A
03A76:  MOVWF  x2B
03A78:  MOVLW  40
03A7A:  MOVWF  x2F
03A7C:  CLRF   x2E
03A7E:  CLRF   x2D
03A80:  CLRF   x2C
03A82:  MOVLB  0
03A84:  RCALL  3568
03A86:  MOVFF  01,9E4
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
03A8A:  MOVF   1F,W
03A8C:  SUBLW  04
03A8E:  BNZ   3AD6
03A90:  MOVF   20,F
03A92:  BNZ   3AD6
03A94:  MOVLW  EE
03A96:  MOVWF  FF6
03A98:  MOVLW  07
03A9A:  MOVWF  FF7
03A9C:  MOVLW  00
03A9E:  MOVWF  FF8
03AA0:  CLRF   1B
03AA2:  BTFSC  FF2.7
03AA4:  BSF    1B.7
03AA6:  BCF    FF2.7
03AA8:  MOVLW  18
03AAA:  MOVLB  A
03AAC:  MOVWF  x40
03AAE:  MOVLB  0
03AB0:  CALL   1044
03AB4:  BTFSC  1B.7
03AB6:  BSF    FF2.7
03AB8:  MOVFF  9E4,9EC
03ABC:  MOVLW  57
03ABE:  MOVLB  9
03AC0:  MOVWF  xED
03AC2:  MOVLB  0
03AC4:  RCALL  3638
03AC6:  MOVLW  0D
03AC8:  BTFSS  F9E.4
03ACA:  BRA    3AC8
03ACC:  MOVWF  FAD
03ACE:  MOVLW  0A
03AD0:  BTFSS  F9E.4
03AD2:  BRA    3AD0
03AD4:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03AD6:  MOVLB  9
03AD8:  MOVF   xE4,F
03ADA:  BTFSS  FD8.2
03ADC:  BRA    3BD2
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03ADE:  CLRF   xE3
03AE0:  MOVF   xE3,W
03AE2:  SUBLW  03
03AE4:  BNC   3B04
....................                   ocr[i] = SD_spi_read(0xFF); 
03AE6:  CLRF   03
03AE8:  MOVF   xE3,W
03AEA:  ADDLW  E5
03AEC:  MOVWF  FE9
03AEE:  MOVLW  09
03AF0:  ADDWFC 03,W
03AF2:  MOVWF  FEA
03AF4:  MOVF   FC9,W
03AF6:  SETF   FC9
03AF8:  RRCF   FC7,W
03AFA:  BNC   3AF8
03AFC:  MOVFF  FC9,FEF
03B00:  INCF   xE3,F
03B02:  BRA    3AE0
....................                if (ocr[0] & 0x40) 
03B04:  BTFSS  xE5.6
03B06:  BRA    3B12
....................                   Card = SDHC; 
03B08:  MOVLW  05
03B0A:  MOVLB  4
03B0C:  MOVWF  xE7
03B0E:  BRA    3B18
03B10:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03B12:  MOVLW  04
03B14:  MOVLB  4
03B16:  MOVWF  xE7
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03B18:  MOVF   1F,W
03B1A:  SUBLW  04
03B1C:  BNZ   3BD0
03B1E:  MOVF   20,F
03B20:  BNZ   3BD0
03B22:  MOVLW  0C
03B24:  MOVWF  FF6
03B26:  MOVLW  08
03B28:  MOVWF  FF7
03B2A:  MOVLW  00
03B2C:  MOVWF  FF8
03B2E:  CLRF   1B
03B30:  BTFSC  FF2.7
03B32:  BSF    1B.7
03B34:  BCF    FF2.7
03B36:  MOVLW  1F
03B38:  MOVLB  A
03B3A:  MOVWF  x40
03B3C:  MOVLB  0
03B3E:  CALL   1044
03B42:  BTFSC  1B.7
03B44:  BSF    FF2.7
03B46:  MOVLW  10
03B48:  MOVWF  FE9
03B4A:  CLRF   1B
03B4C:  BTFSC  FF2.7
03B4E:  BSF    1B.7
03B50:  BCF    FF2.7
03B52:  MOVFF  9EA,A41
03B56:  MOVFF  9E9,A40
03B5A:  CALL   11C6
03B5E:  BTFSC  1B.7
03B60:  BSF    FF2.7
03B62:  MOVLW  2E
03B64:  MOVWF  FF6
03B66:  MOVLW  08
03B68:  MOVWF  FF7
03B6A:  MOVLW  00
03B6C:  MOVWF  FF8
03B6E:  CLRF   1B
03B70:  BTFSC  FF2.7
03B72:  BSF    1B.7
03B74:  BCF    FF2.7
03B76:  MOVLW  08
03B78:  MOVLB  A
03B7A:  MOVWF  x40
03B7C:  MOVLB  0
03B7E:  CALL   1044
03B82:  BTFSC  1B.7
03B84:  BSF    FF2.7
03B86:  MOVFF  9E5,9EC
03B8A:  MOVLW  57
03B8C:  MOVLB  9
03B8E:  MOVWF  xED
03B90:  MOVLB  0
03B92:  RCALL  3638
03B94:  MOVFF  9E6,9EC
03B98:  MOVLW  57
03B9A:  MOVLB  9
03B9C:  MOVWF  xED
03B9E:  MOVLB  0
03BA0:  RCALL  3638
03BA2:  MOVFF  9E7,9EC
03BA6:  MOVLW  57
03BA8:  MOVLB  9
03BAA:  MOVWF  xED
03BAC:  MOVLB  0
03BAE:  RCALL  3638
03BB0:  MOVFF  9E8,9EC
03BB4:  MOVLW  57
03BB6:  MOVLB  9
03BB8:  MOVWF  xED
03BBA:  MOVLB  0
03BBC:  RCALL  3638
03BBE:  MOVLW  0D
03BC0:  BTFSS  F9E.4
03BC2:  BRA    3BC0
03BC4:  MOVWF  FAD
03BC6:  MOVLW  0A
03BC8:  BTFSS  F9E.4
03BCA:  BRA    3BC8
03BCC:  MOVWF  FAD
03BCE:  MOVLB  4
03BD0:  MOVLB  9
....................             } 
....................          } 
....................       } 
03BD2:  BRA    3BFE
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03BD4:  MOVF   1F,W
03BD6:  SUBLW  04
03BD8:  BNZ   3BFE
03BDA:  MOVF   20,F
03BDC:  BNZ   3BFE
03BDE:  MOVLW  4A
03BE0:  MOVWF  FF6
03BE2:  MOVLW  08
03BE4:  MOVWF  FF7
03BE6:  MOVLW  00
03BE8:  MOVWF  FF8
03BEA:  CLRF   1B
03BEC:  BTFSC  FF2.7
03BEE:  BSF    1B.7
03BF0:  BCF    FF2.7
03BF2:  MOVLB  0
03BF4:  CALL   0E6E
03BF8:  BTFSC  1B.7
03BFA:  BSF    FF2.7
03BFC:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03BFE:  MOVLB  4
03C00:  MOVF   xE7,F
03C02:  BTFSS  FD8.2
03C04:  BRA    40D4
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03C06:  MOVF   1F,W
03C08:  SUBLW  04
03C0A:  BNZ   3C30
03C0C:  MOVF   20,F
03C0E:  BNZ   3C30
03C10:  MOVLW  7C
03C12:  MOVWF  FF6
03C14:  MOVLW  08
03C16:  MOVWF  FF7
03C18:  MOVLW  00
03C1A:  MOVWF  FF8
03C1C:  CLRF   1B
03C1E:  BTFSC  FF2.7
03C20:  BSF    1B.7
03C22:  BCF    FF2.7
03C24:  MOVLB  0
03C26:  CALL   0E6E
03C2A:  BTFSC  1B.7
03C2C:  BSF    FF2.7
03C2E:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03C30:  MOVLW  40
03C32:  MOVLB  A
03C34:  MOVWF  x2B
03C36:  CLRF   x2F
03C38:  CLRF   x2E
03C3A:  CLRF   x2D
03C3C:  CLRF   x2C
03C3E:  MOVLB  0
03C40:  RCALL  3568
03C42:  MOVFF  01,9E4
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03C46:  MOVF   1F,W
03C48:  SUBLW  04
03C4A:  BNZ   3C92
03C4C:  MOVF   20,F
03C4E:  BNZ   3C92
03C50:  MOVLW  BC
03C52:  MOVWF  FF6
03C54:  MOVLW  08
03C56:  MOVWF  FF7
03C58:  MOVLW  00
03C5A:  MOVWF  FF8
03C5C:  CLRF   1B
03C5E:  BTFSC  FF2.7
03C60:  BSF    1B.7
03C62:  BCF    FF2.7
03C64:  MOVLW  1C
03C66:  MOVLB  A
03C68:  MOVWF  x40
03C6A:  MOVLB  0
03C6C:  CALL   1044
03C70:  BTFSC  1B.7
03C72:  BSF    FF2.7
03C74:  MOVFF  9E4,9EC
03C78:  MOVLW  57
03C7A:  MOVLB  9
03C7C:  MOVWF  xED
03C7E:  MOVLB  0
03C80:  RCALL  3638
03C82:  MOVLW  0D
03C84:  BTFSS  F9E.4
03C86:  BRA    3C84
03C88:  MOVWF  FAD
03C8A:  MOVLW  0A
03C8C:  BTFSS  F9E.4
03C8E:  BRA    3C8C
03C90:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03C92:  MOVLB  9
03C94:  DECFSZ xE4,W
03C96:  BRA    3C9A
03C98:  BRA    3CA4
03C9A:  MOVF   xE4,F
03C9C:  BZ    3CA4
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03C9E:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
03CA0:  GOTO   43F2
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03CA4:  CLRF   xEA
03CA6:  CLRF   xE9
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03CA8:  MOVLW  41
03CAA:  MOVLB  A
03CAC:  MOVWF  x2B
03CAE:  CLRF   x2F
03CB0:  CLRF   x2E
03CB2:  CLRF   x2D
03CB4:  CLRF   x2C
03CB6:  MOVLB  0
03CB8:  RCALL  3568
03CBA:  MOVFF  01,9E4
....................          if (response != 0x00 ) 
03CBE:  MOVLB  9
03CC0:  MOVF   xE4,F
03CC2:  BZ    3CCC
....................             delay_us(10); 
03CC4:  MOVLW  35
03CC6:  MOVWF  00
03CC8:  DECFSZ 00,F
03CCA:  BRA    3CC8
....................          Timer++; 
03CCC:  INCF   xE9,F
03CCE:  BTFSC  FD8.2
03CD0:  INCF   xEA,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03CD2:  MOVF   xE4,F
03CD4:  BZ    3CE4
03CD6:  MOVF   xEA,W
03CD8:  SUBLW  C3
03CDA:  BNC   3CE4
03CDC:  BNZ   3CA8
03CDE:  MOVF   xE9,W
03CE0:  SUBLW  4F
03CE2:  BC    3CA8
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03CE4:  MOVF   1F,W
03CE6:  SUBLW  04
03CE8:  BNZ   3D72
03CEA:  MOVF   20,F
03CEC:  BNZ   3D72
03CEE:  MOVLW  E0
03CF0:  MOVWF  FF6
03CF2:  MOVLW  08
03CF4:  MOVWF  FF7
03CF6:  MOVLW  00
03CF8:  MOVWF  FF8
03CFA:  CLRF   1B
03CFC:  BTFSC  FF2.7
03CFE:  BSF    1B.7
03D00:  BCF    FF2.7
03D02:  MOVLW  28
03D04:  MOVLB  A
03D06:  MOVWF  x40
03D08:  MOVLB  0
03D0A:  CALL   1044
03D0E:  BTFSC  1B.7
03D10:  BSF    FF2.7
03D12:  MOVFF  9E4,9EC
03D16:  MOVLW  57
03D18:  MOVLB  9
03D1A:  MOVWF  xED
03D1C:  MOVLB  0
03D1E:  RCALL  3638
03D20:  MOVLW  0C
03D22:  MOVWF  FF6
03D24:  MOVLW  09
03D26:  MOVWF  FF7
03D28:  MOVLW  00
03D2A:  MOVWF  FF8
03D2C:  CLRF   1B
03D2E:  BTFSC  FF2.7
03D30:  BSF    1B.7
03D32:  BCF    FF2.7
03D34:  MOVLW  0A
03D36:  MOVLB  A
03D38:  MOVWF  x40
03D3A:  MOVLB  0
03D3C:  CALL   1044
03D40:  BTFSC  1B.7
03D42:  BSF    FF2.7
03D44:  MOVLW  10
03D46:  MOVWF  FE9
03D48:  CLRF   1B
03D4A:  BTFSC  FF2.7
03D4C:  BSF    1B.7
03D4E:  BCF    FF2.7
03D50:  MOVFF  9EA,A41
03D54:  MOVFF  9E9,A40
03D58:  CALL   11C6
03D5C:  BTFSC  1B.7
03D5E:  BSF    FF2.7
03D60:  MOVLW  0D
03D62:  BTFSS  F9E.4
03D64:  BRA    3D62
03D66:  MOVWF  FAD
03D68:  MOVLW  0A
03D6A:  BTFSS  F9E.4
03D6C:  BRA    3D6A
03D6E:  MOVWF  FAD
03D70:  MOVLB  9
....................       if(response) 
03D72:  MOVF   xE4,F
03D74:  BZ    3D7A
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03D76:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
03D78:  BRA    43F2
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03D7A:  MOVLW  77
03D7C:  MOVLB  A
03D7E:  MOVWF  x2B
03D80:  CLRF   x2F
03D82:  CLRF   x2E
03D84:  CLRF   x2D
03D86:  CLRF   x2C
03D88:  MOVLB  0
03D8A:  CALL   3568
03D8E:  MOVFF  01,9E4
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03D92:  MOVF   1F,W
03D94:  SUBLW  04
03D96:  BNZ   3DDE
03D98:  MOVF   20,F
03D9A:  BNZ   3DDE
03D9C:  MOVLW  1C
03D9E:  MOVWF  FF6
03DA0:  MOVLW  09
03DA2:  MOVWF  FF7
03DA4:  MOVLW  00
03DA6:  MOVWF  FF8
03DA8:  CLRF   1B
03DAA:  BTFSC  FF2.7
03DAC:  BSF    1B.7
03DAE:  BCF    FF2.7
03DB0:  MOVLW  43
03DB2:  MOVLB  A
03DB4:  MOVWF  x40
03DB6:  MOVLB  0
03DB8:  CALL   1044
03DBC:  BTFSC  1B.7
03DBE:  BSF    FF2.7
03DC0:  MOVFF  9E4,9EC
03DC4:  MOVLW  57
03DC6:  MOVLB  9
03DC8:  MOVWF  xED
03DCA:  MOVLB  0
03DCC:  RCALL  3638
03DCE:  MOVLW  0D
03DD0:  BTFSS  F9E.4
03DD2:  BRA    3DD0
03DD4:  MOVWF  FAD
03DD6:  MOVLW  0A
03DD8:  BTFSS  F9E.4
03DDA:  BRA    3DD8
03DDC:  MOVWF  FAD
....................       if (response) 
03DDE:  MOVLB  9
03DE0:  MOVF   xE4,F
03DE2:  BZ    3DEE
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03DE4:  MOVLW  02
03DE6:  MOVLB  4
03DE8:  MOVWF  xE7
....................          } 
03DEA:  BRA    3FE8
03DEC:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03DEE:  MOVLW  69
03DF0:  MOVLB  A
03DF2:  MOVWF  x2B
03DF4:  CLRF   x2F
03DF6:  CLRF   x2E
03DF8:  CLRF   x2D
03DFA:  CLRF   x2C
03DFC:  MOVLB  0
03DFE:  CALL   3568
03E02:  MOVFF  01,9E4
....................          if (response <= 1 ) 
03E06:  MOVLB  9
03E08:  MOVF   xE4,W
03E0A:  SUBLW  01
03E0C:  BNC   3E18
....................             Card = SDv1; 
03E0E:  MOVLW  03
03E10:  MOVLB  4
03E12:  MOVWF  xE7
03E14:  BRA    3FE8
03E16:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03E18:  MOVF   1F,W
03E1A:  SUBLW  04
03E1C:  BNZ   3E7C
03E1E:  MOVF   20,F
03E20:  BNZ   3E7C
03E22:  MOVLW  66
03E24:  MOVWF  FF6
03E26:  MOVLW  09
03E28:  MOVWF  FF7
03E2A:  MOVLW  00
03E2C:  MOVWF  FF8
03E2E:  CLRF   1B
03E30:  BTFSC  FF2.7
03E32:  BSF    1B.7
03E34:  BCF    FF2.7
03E36:  MOVLW  2E
03E38:  MOVLB  A
03E3A:  MOVWF  x40
03E3C:  MOVLB  0
03E3E:  CALL   1044
03E42:  BTFSC  1B.7
03E44:  BSF    FF2.7
03E46:  MOVFF  9E4,9EC
03E4A:  MOVLW  37
03E4C:  MOVLB  9
03E4E:  MOVWF  xED
03E50:  MOVLB  0
03E52:  CALL   3638
03E56:  MOVLW  98
03E58:  MOVWF  FF6
03E5A:  MOVLW  09
03E5C:  MOVWF  FF7
03E5E:  MOVLW  00
03E60:  MOVWF  FF8
03E62:  CLRF   1B
03E64:  BTFSC  FF2.7
03E66:  BSF    1B.7
03E68:  BCF    FF2.7
03E6A:  MOVLW  19
03E6C:  MOVLB  A
03E6E:  MOVWF  x40
03E70:  MOVLB  0
03E72:  CALL   1044
03E76:  BTFSC  1B.7
03E78:  BSF    FF2.7
03E7A:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03E7C:  MOVLW  40
03E7E:  MOVLB  A
03E80:  MOVWF  x2B
03E82:  CLRF   x2F
03E84:  CLRF   x2E
03E86:  CLRF   x2D
03E88:  CLRF   x2C
03E8A:  MOVLB  0
03E8C:  CALL   3568
03E90:  MOVFF  01,9E4
....................             if ((response !=0x01) && (response != 0)) 
03E94:  MOVLB  9
03E96:  DECFSZ xE4,W
03E98:  BRA    3E9C
03E9A:  BRA    3F08
03E9C:  MOVF   xE4,F
03E9E:  BZ    3F08
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03EA0:  MOVF   1F,W
03EA2:  SUBLW  04
03EA4:  BNZ   3F04
03EA6:  MOVF   20,F
03EA8:  BNZ   3F04
03EAA:  MOVLW  B2
03EAC:  MOVWF  FF6
03EAE:  MOVLW  09
03EB0:  MOVWF  FF7
03EB2:  MOVLW  00
03EB4:  MOVWF  FF8
03EB6:  CLRF   1B
03EB8:  BTFSC  FF2.7
03EBA:  BSF    1B.7
03EBC:  BCF    FF2.7
03EBE:  MOVLW  2C
03EC0:  MOVLB  A
03EC2:  MOVWF  x40
03EC4:  MOVLB  0
03EC6:  CALL   1044
03ECA:  BTFSC  1B.7
03ECC:  BSF    FF2.7
03ECE:  MOVFF  9E4,9EC
03ED2:  MOVLW  37
03ED4:  MOVLB  9
03ED6:  MOVWF  xED
03ED8:  MOVLB  0
03EDA:  CALL   3638
03EDE:  MOVLW  E2
03EE0:  MOVWF  FF6
03EE2:  MOVLW  09
03EE4:  MOVWF  FF7
03EE6:  MOVLW  00
03EE8:  MOVWF  FF8
03EEA:  CLRF   1B
03EEC:  BTFSC  FF2.7
03EEE:  BSF    1B.7
03EF0:  BCF    FF2.7
03EF2:  MOVLW  0B
03EF4:  MOVLB  A
03EF6:  MOVWF  x40
03EF8:  MOVLB  0
03EFA:  CALL   1044
03EFE:  BTFSC  1B.7
03F00:  BSF    FF2.7
03F02:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03F04:  BSF    xEB.0
....................                goto Exit_disk_initialize; 
03F06:  BRA    43F2
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03F08:  CLRF   xEA
03F0A:  CLRF   xE9
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03F0C:  MOVLW  41
03F0E:  MOVLB  A
03F10:  MOVWF  x2B
03F12:  CLRF   x2F
03F14:  CLRF   x2E
03F16:  CLRF   x2D
03F18:  CLRF   x2C
03F1A:  MOVLB  0
03F1C:  CALL   3568
03F20:  MOVFF  01,9E4
....................                if (response != 0x00 ) 
03F24:  MOVLB  9
03F26:  MOVF   xE4,F
03F28:  BZ    3F32
....................                   delay_us(10); 
03F2A:  MOVLW  35
03F2C:  MOVWF  00
03F2E:  DECFSZ 00,F
03F30:  BRA    3F2E
....................                Timer++; 
03F32:  INCF   xE9,F
03F34:  BTFSC  FD8.2
03F36:  INCF   xEA,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03F38:  MOVF   xE4,F
03F3A:  BZ    3F4A
03F3C:  MOVF   xEA,W
03F3E:  SUBLW  C3
03F40:  BNC   3F4A
03F42:  BNZ   3F0C
03F44:  MOVF   xE9,W
03F46:  SUBLW  4F
03F48:  BC    3F0C
....................     
....................             if(response) 
03F4A:  MOVF   xE4,F
03F4C:  BZ    3FE2
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03F4E:  MOVF   1F,W
03F50:  SUBLW  04
03F52:  BNZ   3FDE
03F54:  MOVF   20,F
03F56:  BNZ   3FDE
03F58:  MOVLW  EE
03F5A:  MOVWF  FF6
03F5C:  MOVLW  09
03F5E:  MOVWF  FF7
03F60:  MOVLW  00
03F62:  MOVWF  FF8
03F64:  CLRF   1B
03F66:  BTFSC  FF2.7
03F68:  BSF    1B.7
03F6A:  BCF    FF2.7
03F6C:  MOVLW  4A
03F6E:  MOVLB  A
03F70:  MOVWF  x40
03F72:  MOVLB  0
03F74:  CALL   1044
03F78:  BTFSC  1B.7
03F7A:  BSF    FF2.7
03F7C:  MOVFF  9E4,9EC
03F80:  MOVLW  37
03F82:  MOVLB  9
03F84:  MOVWF  xED
03F86:  MOVLB  0
03F88:  CALL   3638
03F8C:  MOVLW  3C
03F8E:  MOVWF  FF6
03F90:  MOVLW  0A
03F92:  MOVWF  FF7
03F94:  MOVLW  00
03F96:  MOVWF  FF8
03F98:  CLRF   1B
03F9A:  BTFSC  FF2.7
03F9C:  BSF    1B.7
03F9E:  BCF    FF2.7
03FA0:  MOVLW  0A
03FA2:  MOVLB  A
03FA4:  MOVWF  x40
03FA6:  MOVLB  0
03FA8:  CALL   1044
03FAC:  BTFSC  1B.7
03FAE:  BSF    FF2.7
03FB0:  MOVLW  10
03FB2:  MOVWF  FE9
03FB4:  CLRF   1B
03FB6:  BTFSC  FF2.7
03FB8:  BSF    1B.7
03FBA:  BCF    FF2.7
03FBC:  MOVFF  9EA,A41
03FC0:  MOVFF  9E9,A40
03FC4:  CALL   11C6
03FC8:  BTFSC  1B.7
03FCA:  BSF    FF2.7
03FCC:  MOVLW  0D
03FCE:  BTFSS  F9E.4
03FD0:  BRA    3FCE
03FD2:  MOVWF  FAD
03FD4:  MOVLW  0A
03FD6:  BTFSS  F9E.4
03FD8:  BRA    3FD6
03FDA:  MOVWF  FAD
03FDC:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03FDE:  BSF    xEB.0
....................                goto Exit_disk_initialize; 
03FE0:  BRA    43F2
....................                } 
....................  
....................             Card = MMC; 
03FE2:  MOVLW  02
03FE4:  MOVLB  4
03FE6:  MOVWF  xE7
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
03FE8:  MOVF   1F,W
03FEA:  SUBLW  04
03FEC:  BNZ   4012
03FEE:  MOVF   20,F
03FF0:  BNZ   4012
03FF2:  MOVLW  4C
03FF4:  MOVWF  FF6
03FF6:  MOVLW  0A
03FF8:  MOVWF  FF7
03FFA:  MOVLW  00
03FFC:  MOVWF  FF8
03FFE:  CLRF   1B
04000:  BTFSC  FF2.7
04002:  BSF    1B.7
04004:  BCF    FF2.7
04006:  MOVLB  0
04008:  CALL   0E6E
0400C:  BTFSC  1B.7
0400E:  BSF    FF2.7
04010:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
04012:  MOVLW  50
04014:  MOVLB  A
04016:  MOVWF  x2B
04018:  CLRF   x2F
0401A:  CLRF   x2E
0401C:  MOVLW  02
0401E:  MOVWF  x2D
04020:  CLRF   x2C
04022:  MOVLB  0
04024:  CALL   3568
04028:  MOVFF  01,9E4
....................       if ((Timer == 50000) || (response > 1))    
0402C:  MOVLB  9
0402E:  MOVF   xE9,W
04030:  SUBLW  50
04032:  BNZ   403A
04034:  MOVF   xEA,W
04036:  SUBLW  C3
04038:  BZ    4040
0403A:  MOVF   xE4,W
0403C:  SUBLW  01
0403E:  BC    40D6
....................       { 
....................          Card = None; 
04040:  MOVLB  4
04042:  CLRF   xE7
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
04044:  MOVF   1F,W
04046:  SUBLW  04
04048:  BNZ   40D4
0404A:  MOVF   20,F
0404C:  BNZ   40D4
0404E:  MOVLW  68
04050:  MOVWF  FF6
04052:  MOVLW  0A
04054:  MOVWF  FF7
04056:  MOVLW  00
04058:  MOVWF  FF8
0405A:  CLRF   1B
0405C:  BTFSC  FF2.7
0405E:  BSF    1B.7
04060:  BCF    FF2.7
04062:  MOVLW  2B
04064:  MOVLB  A
04066:  MOVWF  x40
04068:  MOVLB  0
0406A:  CALL   1044
0406E:  BTFSC  1B.7
04070:  BSF    FF2.7
04072:  MOVFF  9E4,9EC
04076:  MOVLW  57
04078:  MOVLB  9
0407A:  MOVWF  xED
0407C:  MOVLB  0
0407E:  CALL   3638
04082:  MOVLW  97
04084:  MOVWF  FF6
04086:  MOVLW  0A
04088:  MOVWF  FF7
0408A:  MOVLW  00
0408C:  MOVWF  FF8
0408E:  CLRF   1B
04090:  BTFSC  FF2.7
04092:  BSF    1B.7
04094:  BCF    FF2.7
04096:  MOVLW  0A
04098:  MOVLB  A
0409A:  MOVWF  x40
0409C:  MOVLB  0
0409E:  CALL   1044
040A2:  BTFSC  1B.7
040A4:  BSF    FF2.7
040A6:  MOVLW  10
040A8:  MOVWF  FE9
040AA:  CLRF   1B
040AC:  BTFSC  FF2.7
040AE:  BSF    1B.7
040B0:  BCF    FF2.7
040B2:  MOVFF  9EA,A41
040B6:  MOVFF  9E9,A40
040BA:  CALL   11C6
040BE:  BTFSC  1B.7
040C0:  BSF    FF2.7
040C2:  MOVLW  0D
040C4:  BTFSS  F9E.4
040C6:  BRA    40C4
040C8:  MOVWF  FAD
040CA:  MOVLW  0A
040CC:  BTFSS  F9E.4
040CE:  BRA    40CC
040D0:  MOVWF  FAD
040D2:  MOVLB  4
040D4:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
040D6:  MOVLB  4
040D8:  MOVF   xE7,F
040DA:  BNZ   410E
....................    { 
....................       if (nv_report_mode == 4) 
040DC:  MOVF   1F,W
040DE:  SUBLW  04
040E0:  BNZ   4106
040E2:  MOVF   20,F
040E4:  BNZ   4106
....................          printf("@FS:Card Type Discovery Error\r\n"); 
040E6:  MOVLW  A8
040E8:  MOVWF  FF6
040EA:  MOVLW  0A
040EC:  MOVWF  FF7
040EE:  MOVLW  00
040F0:  MOVWF  FF8
040F2:  CLRF   1B
040F4:  BTFSC  FF2.7
040F6:  BSF    1B.7
040F8:  BCF    FF2.7
040FA:  MOVLB  0
040FC:  CALL   0E6E
04100:  BTFSC  1B.7
04102:  BSF    FF2.7
04104:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
04106:  MOVLB  9
04108:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
0410A:  BRA    43F2
0410C:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
0410E:  MOVF   xE7,W
04110:  XORLW  02
04112:  MOVLB  0
04114:  BZ    4124
04116:  XORLW  01
04118:  BZ    414C
0411A:  XORLW  07
0411C:  BZ    4174
0411E:  XORLW  01
04120:  BZ    419C
04122:  BRA    41C4
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
04124:  MOVF   1F,W
04126:  SUBLW  04
04128:  BNZ   414A
0412A:  MOVF   20,F
0412C:  BNZ   414A
0412E:  MOVLW  C8
04130:  MOVWF  FF6
04132:  MOVLW  0A
04134:  MOVWF  FF7
04136:  MOVLW  00
04138:  MOVWF  FF8
0413A:  CLRF   1B
0413C:  BTFSC  FF2.7
0413E:  BSF    1B.7
04140:  BCF    FF2.7
04142:  CALL   0E6E
04146:  BTFSC  1B.7
04148:  BSF    FF2.7
....................          break; 
0414A:  BRA    421A
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
0414C:  MOVF   1F,W
0414E:  SUBLW  04
04150:  BNZ   4172
04152:  MOVF   20,F
04154:  BNZ   4172
04156:  MOVLW  DE
04158:  MOVWF  FF6
0415A:  MOVLW  0A
0415C:  MOVWF  FF7
0415E:  MOVLW  00
04160:  MOVWF  FF8
04162:  CLRF   1B
04164:  BTFSC  FF2.7
04166:  BSF    1B.7
04168:  BCF    FF2.7
0416A:  CALL   0E6E
0416E:  BTFSC  1B.7
04170:  BSF    FF2.7
....................          break; 
04172:  BRA    421A
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
04174:  MOVF   1F,W
04176:  SUBLW  04
04178:  BNZ   419A
0417A:  MOVF   20,F
0417C:  BNZ   419A
0417E:  MOVLW  F4
04180:  MOVWF  FF6
04182:  MOVLW  0A
04184:  MOVWF  FF7
04186:  MOVLW  00
04188:  MOVWF  FF8
0418A:  CLRF   1B
0418C:  BTFSC  FF2.7
0418E:  BSF    1B.7
04190:  BCF    FF2.7
04192:  CALL   0E6E
04196:  BTFSC  1B.7
04198:  BSF    FF2.7
....................          break; 
0419A:  BRA    421A
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
0419C:  MOVF   1F,W
0419E:  SUBLW  04
041A0:  BNZ   41C2
041A2:  MOVF   20,F
041A4:  BNZ   41C2
041A6:  MOVLW  0A
041A8:  MOVWF  FF6
041AA:  MOVLW  0B
041AC:  MOVWF  FF7
041AE:  MOVLW  00
041B0:  MOVWF  FF8
041B2:  CLRF   1B
041B4:  BTFSC  FF2.7
041B6:  BSF    1B.7
041B8:  BCF    FF2.7
041BA:  CALL   0E6E
041BE:  BTFSC  1B.7
041C0:  BSF    FF2.7
....................          break; 
041C2:  BRA    421A
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
041C4:  MOVF   1F,W
041C6:  SUBLW  04
041C8:  BNZ   4212
041CA:  MOVF   20,F
041CC:  BNZ   4212
041CE:  MOVLW  20
041D0:  MOVWF  FF6
041D2:  MOVLW  0B
041D4:  MOVWF  FF7
041D6:  MOVLW  00
041D8:  MOVWF  FF8
041DA:  CLRF   1B
041DC:  BTFSC  FF2.7
041DE:  BSF    1B.7
041E0:  BCF    FF2.7
041E2:  MOVLW  26
041E4:  MOVLB  A
041E6:  MOVWF  x40
041E8:  MOVLB  0
041EA:  CALL   1044
041EE:  BTFSC  1B.7
041F0:  BSF    FF2.7
041F2:  MOVFF  4E7,9EC
041F6:  MOVLW  37
041F8:  MOVLB  9
041FA:  MOVWF  xED
041FC:  MOVLB  0
041FE:  CALL   3638
04202:  MOVLW  0D
04204:  BTFSS  F9E.4
04206:  BRA    4204
04208:  MOVWF  FAD
0420A:  MOVLW  0A
0420C:  BTFSS  F9E.4
0420E:  BRA    420C
04210:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
04212:  MOVLB  9
04214:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
04216:  BRA    43F2
04218:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
0421A:  MOVLB  9
0421C:  BCF    xEB.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
0421E:  MOVF   1F,W
04220:  SUBLW  04
04222:  BNZ   427A
04224:  MOVF   20,F
04226:  BNZ   427A
04228:  MOVLW  4E
0422A:  MOVWF  FF6
0422C:  MOVLW  0B
0422E:  MOVWF  FF7
04230:  MOVLW  00
04232:  MOVWF  FF8
04234:  CLRF   1B
04236:  BTFSC  FF2.7
04238:  BSF    1B.7
0423A:  BCF    FF2.7
0423C:  MOVLW  2E
0423E:  MOVLB  A
04240:  MOVWF  x40
04242:  MOVLB  0
04244:  CALL   1044
04248:  BTFSC  1B.7
0424A:  BSF    FF2.7
0424C:  MOVLW  10
0424E:  MOVWF  FE9
04250:  CLRF   1B
04252:  BTFSC  FF2.7
04254:  BSF    1B.7
04256:  BCF    FF2.7
04258:  MOVFF  9EA,A41
0425C:  MOVFF  9E9,A40
04260:  CALL   11C6
04264:  BTFSC  1B.7
04266:  BSF    FF2.7
04268:  MOVLW  0D
0426A:  BTFSS  F9E.4
0426C:  BRA    426A
0426E:  MOVWF  FAD
04270:  MOVLW  0A
04272:  BTFSS  F9E.4
04274:  BRA    4272
04276:  MOVWF  FAD
04278:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
0427A:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
0427C:  BCF    FC6.5
0427E:  MOVLW  20
04280:  MOVWF  FC6
04282:  MOVLW  40
04284:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
04286:  BCF    F9E.3
....................    SelectSD; 
04288:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
0428A:  MOVF   1F,W
0428C:  SUBLW  04
0428E:  BNZ   42B4
04290:  MOVF   20,F
04292:  BNZ   42B4
04294:  MOVLW  82
04296:  MOVWF  FF6
04298:  MOVLW  0B
0429A:  MOVWF  FF7
0429C:  MOVLW  00
0429E:  MOVWF  FF8
042A0:  CLRF   1B
042A2:  BTFSC  FF2.7
042A4:  BSF    1B.7
042A6:  BCF    FF2.7
042A8:  MOVLB  0
042AA:  CALL   0E6E
042AE:  BTFSC  1B.7
042B0:  BSF    FF2.7
042B2:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
042B4:  CLRF   xEA
042B6:  CLRF   xE9
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
042B8:  MOVLW  41
042BA:  MOVLB  A
042BC:  MOVWF  x2B
042BE:  CLRF   x2F
042C0:  CLRF   x2E
042C2:  CLRF   x2D
042C4:  CLRF   x2C
042C6:  MOVLB  0
042C8:  CALL   3568
042CC:  MOVFF  01,9E4
....................       if (response != 0x00 ) 
042D0:  MOVLB  9
042D2:  MOVF   xE4,F
042D4:  BZ    42DE
....................          delay_us(10); 
042D6:  MOVLW  35
042D8:  MOVWF  00
042DA:  DECFSZ 00,F
042DC:  BRA    42DA
....................  
....................       Timer++; 
042DE:  INCF   xE9,F
042E0:  BTFSC  FD8.2
042E2:  INCF   xEA,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
042E4:  MOVF   xE4,F
042E6:  BZ    42F6
042E8:  MOVF   xEA,W
042EA:  SUBLW  C3
042EC:  BNC   42F6
042EE:  BNZ   42B8
042F0:  MOVF   xE9,W
042F2:  SUBLW  4F
042F4:  BC    42B8
....................  
....................    if (response != 0x00) 
042F6:  MOVF   xE4,F
042F8:  BZ    438E
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
042FA:  MOVF   1F,W
042FC:  SUBLW  04
042FE:  BNZ   438A
04300:  MOVF   20,F
04302:  BNZ   438A
04304:  MOVLW  A2
04306:  MOVWF  FF6
04308:  MOVLW  0B
0430A:  MOVWF  FF7
0430C:  MOVLW  00
0430E:  MOVWF  FF8
04310:  CLRF   1B
04312:  BTFSC  FF2.7
04314:  BSF    1B.7
04316:  BCF    FF2.7
04318:  MOVLW  26
0431A:  MOVLB  A
0431C:  MOVWF  x40
0431E:  MOVLB  0
04320:  CALL   1044
04324:  BTFSC  1B.7
04326:  BSF    FF2.7
04328:  MOVFF  9E4,9EC
0432C:  MOVLW  37
0432E:  MOVLB  9
04330:  MOVWF  xED
04332:  MOVLB  0
04334:  CALL   3638
04338:  MOVLW  CC
0433A:  MOVWF  FF6
0433C:  MOVLW  0B
0433E:  MOVWF  FF7
04340:  MOVLW  00
04342:  MOVWF  FF8
04344:  CLRF   1B
04346:  BTFSC  FF2.7
04348:  BSF    1B.7
0434A:  BCF    FF2.7
0434C:  MOVLW  0A
0434E:  MOVLB  A
04350:  MOVWF  x40
04352:  MOVLB  0
04354:  CALL   1044
04358:  BTFSC  1B.7
0435A:  BSF    FF2.7
0435C:  MOVLW  10
0435E:  MOVWF  FE9
04360:  CLRF   1B
04362:  BTFSC  FF2.7
04364:  BSF    1B.7
04366:  BCF    FF2.7
04368:  MOVFF  9EA,A41
0436C:  MOVFF  9E9,A40
04370:  CALL   11C6
04374:  BTFSC  1B.7
04376:  BSF    FF2.7
04378:  MOVLW  0D
0437A:  BTFSS  F9E.4
0437C:  BRA    437A
0437E:  MOVWF  FAD
04380:  MOVLW  0A
04382:  BTFSS  F9E.4
04384:  BRA    4382
04386:  MOVWF  FAD
04388:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
0438A:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
0438C:  BRA    43F2
....................    } 
....................  
....................    if (nv_report_mode == 4) 
0438E:  MOVF   1F,W
04390:  SUBLW  04
04392:  BNZ   43EA
04394:  MOVF   20,F
04396:  BNZ   43EA
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
04398:  MOVLW  DC
0439A:  MOVWF  FF6
0439C:  MOVLW  0B
0439E:  MOVWF  FF7
043A0:  MOVLW  00
043A2:  MOVWF  FF8
043A4:  CLRF   1B
043A6:  BTFSC  FF2.7
043A8:  BSF    1B.7
043AA:  BCF    FF2.7
043AC:  MOVLW  25
043AE:  MOVLB  A
043B0:  MOVWF  x40
043B2:  MOVLB  0
043B4:  CALL   1044
043B8:  BTFSC  1B.7
043BA:  BSF    FF2.7
043BC:  MOVLW  10
043BE:  MOVWF  FE9
043C0:  CLRF   1B
043C2:  BTFSC  FF2.7
043C4:  BSF    1B.7
043C6:  BCF    FF2.7
043C8:  MOVFF  9EA,A41
043CC:  MOVFF  9E9,A40
043D0:  CALL   11C6
043D4:  BTFSC  1B.7
043D6:  BSF    FF2.7
043D8:  MOVLW  0D
043DA:  BTFSS  F9E.4
043DC:  BRA    43DA
043DE:  MOVWF  FAD
043E0:  MOVLW  0A
043E2:  BTFSS  F9E.4
043E4:  BRA    43E2
043E6:  MOVWF  FAD
043E8:  MOVLB  9
....................  
....................    msg_card_ok(); 
043EA:  MOVLB  0
043EC:  GOTO   367E
043F0:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
043F2:  BSF    F91.1
....................    return(SDCardStatus); 
043F4:  MOVFF  9EB,01
043F8:  MOVLB  0
043FA:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05AAA:  MOVLW  20
05AAC:  MOVLB  7
05AAE:  ADDWF  x12,W
05AB0:  MOVWF  FE9
05AB2:  MOVLW  00
05AB4:  ADDWFC x13,W
05AB6:  MOVWF  FEA
05AB8:  MOVFF  FEF,A18
05ABC:  MOVFF  FEC,A19
05AC0:  MOVFF  FEC,A1A
05AC4:  MOVFF  FEC,A1B
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05AC8:  MOVLB  A
05ACA:  MOVF   x14,W
05ACC:  SUBWF  x18,W
05ACE:  BNZ   5AE4
05AD0:  MOVF   x15,W
05AD2:  SUBWF  x19,W
05AD4:  BNZ   5AE4
05AD6:  MOVF   x16,W
05AD8:  SUBWF  x1A,W
05ADA:  BNZ   5AE4
05ADC:  MOVF   x17,W
05ADE:  SUBWF  x1B,W
05AE0:  BTFSC  FD8.2
05AE2:  BRA    5CB8
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05AE4:  MOVLW  06
05AE6:  MOVLB  7
05AE8:  ADDWF  x12,W
05AEA:  MOVWF  FE9
05AEC:  MOVLW  00
05AEE:  ADDWFC x13,W
05AF0:  MOVWF  FEA
05AF2:  MOVF   FEF,F
05AF4:  BTFSC  FD8.2
05AF6:  BRA    5C42
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05AF8:  MOVLW  24
05AFA:  ADDWF  x12,W
05AFC:  MOVWF  01
05AFE:  MOVLW  00
05B00:  ADDWFC x13,W
05B02:  MOVWF  03
05B04:  MOVFF  01,A1E
05B08:  MOVLB  A
05B0A:  MOVWF  x1F
05B0C:  MOVWF  x21
05B0E:  MOVFF  01,A20
05B12:  MOVFF  A1B,A25
05B16:  MOVFF  A1A,A24
05B1A:  MOVFF  A19,A23
05B1E:  MOVFF  A18,A22
05B22:  MOVLW  01
05B24:  MOVWF  x26
05B26:  MOVLB  0
05B28:  RCALL  5966
05B2A:  MOVFF  01,A1C
....................             if (response != RES_OK) 
05B2E:  MOVLB  A
05B30:  MOVF   x1C,F
05B32:  BZ    5B3A
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05B34:  MOVLW  00
05B36:  MOVWF  01
05B38:  BRA    5CBC
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05B3A:  MOVLW  06
05B3C:  MOVLB  7
05B3E:  ADDWF  x12,W
05B40:  MOVWF  FE9
05B42:  MOVLW  00
05B44:  ADDWFC x13,W
05B46:  MOVWF  FEA
05B48:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05B4A:  MOVLW  10
05B4C:  ADDWF  x12,W
05B4E:  MOVWF  FE9
05B50:  MOVLW  00
05B52:  ADDWFC x13,W
05B54:  MOVWF  FEA
05B56:  MOVFF  FEF,A1E
05B5A:  MOVFF  FEC,A1F
05B5E:  MOVFF  FEC,A20
05B62:  MOVFF  FEC,A21
05B66:  MOVLW  08
05B68:  ADDWF  x12,W
05B6A:  MOVWF  FE9
05B6C:  MOVLW  00
05B6E:  ADDWFC x13,W
05B70:  MOVWF  FEA
05B72:  MOVFF  FEF,00
05B76:  MOVFF  FEC,01
05B7A:  MOVFF  FEC,02
05B7E:  MOVFF  FEC,03
05B82:  MOVLB  A
05B84:  MOVF   x1E,W
05B86:  ADDWF  00,F
05B88:  MOVF   x1F,W
05B8A:  ADDWFC 01,F
05B8C:  MOVF   x20,W
05B8E:  ADDWFC 02,F
05B90:  MOVF   x21,W
05B92:  ADDWFC 03,F
05B94:  MOVF   x1B,W
05B96:  SUBWF  03,W
05B98:  BNC   5C40
05B9A:  BNZ   5BB2
05B9C:  MOVF   x1A,W
05B9E:  SUBWF  02,W
05BA0:  BNC   5C40
05BA2:  BNZ   5BB2
05BA4:  MOVF   x19,W
05BA6:  SUBWF  01,W
05BA8:  BNC   5C40
05BAA:  BNZ   5BB2
05BAC:  MOVF   00,W
05BAE:  SUBWF  x18,W
05BB0:  BC    5C40
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05BB2:  MOVLW  03
05BB4:  MOVLB  7
05BB6:  ADDWF  x12,W
05BB8:  MOVWF  FE9
05BBA:  MOVLW  00
05BBC:  ADDWFC x13,W
05BBE:  MOVWF  FEA
05BC0:  MOVFF  FEF,A1D
05BC4:  MOVLB  A
05BC6:  MOVF   x1D,W
05BC8:  SUBLW  01
05BCA:  BC    5C40
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05BCC:  MOVLW  08
05BCE:  MOVLB  7
05BD0:  ADDWF  x12,W
05BD2:  MOVWF  FE9
05BD4:  MOVLW  00
05BD6:  ADDWFC x13,W
05BD8:  MOVWF  FEA
05BDA:  MOVFF  FEF,00
05BDE:  MOVFF  FEC,01
05BE2:  MOVFF  FEC,02
05BE6:  MOVFF  FEC,03
05BEA:  MOVF   00,W
05BEC:  MOVLB  A
05BEE:  ADDWF  x18,F
05BF0:  MOVF   01,W
05BF2:  ADDWFC x19,F
05BF4:  MOVF   02,W
05BF6:  ADDWFC x1A,F
05BF8:  MOVF   03,W
05BFA:  ADDWFC x1B,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05BFC:  MOVLW  24
05BFE:  MOVLB  7
05C00:  ADDWF  x12,W
05C02:  MOVWF  01
05C04:  MOVLW  00
05C06:  ADDWFC x13,W
05C08:  MOVWF  03
05C0A:  MOVFF  01,A1E
05C0E:  MOVLB  A
05C10:  MOVWF  x1F
05C12:  MOVWF  x21
05C14:  MOVFF  01,A20
05C18:  MOVFF  A1B,A25
05C1C:  MOVFF  A1A,A24
05C20:  MOVFF  A19,A23
05C24:  MOVFF  A18,A22
05C28:  MOVLW  01
05C2A:  MOVWF  x26
05C2C:  MOVLB  0
05C2E:  RCALL  5966
05C30:  MOVF   01,F
05C32:  BZ    5C3A
....................                      break; 
05C34:  MOVLB  A
05C36:  BRA    5C40
05C38:  MOVLB  0
05C3A:  MOVLB  A
05C3C:  DECF   x1D,F
05C3E:  BRA    5BC6
05C40:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05C42:  MOVLB  A
05C44:  MOVF   x14,F
05C46:  BNZ   5C54
05C48:  MOVF   x15,F
05C4A:  BNZ   5C54
05C4C:  MOVF   x16,F
05C4E:  BNZ   5C54
05C50:  MOVF   x17,F
05C52:  BZ    5CB8
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05C54:  MOVLW  24
05C56:  MOVLB  7
05C58:  ADDWF  x12,W
05C5A:  MOVWF  01
05C5C:  MOVLW  00
05C5E:  ADDWFC x13,W
05C60:  MOVWF  03
05C62:  MOVFF  01,A1E
05C66:  MOVLB  A
05C68:  MOVWF  x1F
05C6A:  MOVWF  x21
05C6C:  MOVFF  01,A20
05C70:  MOVFF  A17,A25
05C74:  MOVFF  A16,A24
05C78:  MOVFF  A15,A23
05C7C:  MOVFF  A14,A22
05C80:  MOVLW  01
05C82:  MOVWF  x26
05C84:  MOVLB  0
05C86:  CALL   44F4
05C8A:  MOVF   01,F
05C8C:  BZ    5C98
....................             return FALSE; 
05C8E:  MOVLW  00
05C90:  MOVWF  01
05C92:  MOVLB  A
05C94:  BRA    5CBC
05C96:  MOVLB  0
....................          fs->winsect = sector; 
05C98:  MOVLW  20
05C9A:  MOVLB  7
05C9C:  ADDWF  x12,W
05C9E:  MOVWF  FE9
05CA0:  MOVLW  00
05CA2:  ADDWFC x13,W
05CA4:  MOVWF  FEA
05CA6:  MOVFF  A14,FEF
05CAA:  MOVFF  A15,FEC
05CAE:  MOVFF  A16,FEC
05CB2:  MOVFF  A17,FEC
05CB6:  MOVLB  A
....................          } 
....................       } 
....................    return (TRUE); 
05CB8:  MOVLW  01
05CBA:  MOVWF  01
05CBC:  MOVLB  0
05CBE:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05CE2:  MOVLB  9
05CE4:  MOVF   xFF,F
05CE6:  BNZ   5CF8
05CE8:  MOVF   xFE,F
05CEA:  BNZ   5CF8
05CEC:  MOVF   xFD,F
05CEE:  BNZ   5CF8
05CF0:  MOVF   xFC,W
05CF2:  SUBLW  01
05CF4:  BTFSC  FD8.0
05CF6:  BRA    6020
05CF8:  MOVLW  0C
05CFA:  MOVLB  7
05CFC:  ADDWF  x12,W
05CFE:  MOVWF  FE9
05D00:  MOVLW  00
05D02:  ADDWFC x13,W
05D04:  MOVWF  FEA
05D06:  MOVFF  FEF,00
05D0A:  MOVFF  FEC,01
05D0E:  MOVFF  FEC,02
05D12:  MOVFF  FEC,03
05D16:  MOVLB  9
05D18:  MOVF   xFF,W
05D1A:  SUBWF  03,W
05D1C:  BTFSS  FD8.0
05D1E:  BRA    6020
05D20:  BNZ   5D3E
05D22:  MOVF   xFE,W
05D24:  SUBWF  02,W
05D26:  BTFSS  FD8.0
05D28:  BRA    6020
05D2A:  BNZ   5D3E
05D2C:  MOVF   xFD,W
05D2E:  SUBWF  01,W
05D30:  BTFSS  FD8.0
05D32:  BRA    6020
05D34:  BNZ   5D3E
05D36:  MOVF   00,W
05D38:  SUBWF  xFC,W
05D3A:  BTFSC  FD8.0
05D3C:  BRA    6020
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05D3E:  MOVLW  10
05D40:  MOVLB  7
05D42:  ADDWF  x12,W
05D44:  MOVWF  FE9
05D46:  MOVLW  00
05D48:  ADDWFC x13,W
05D4A:  MOVWF  FEA
05D4C:  MOVFF  FEF,A04
05D50:  MOVFF  FEC,A05
05D54:  MOVFF  FEC,A06
05D58:  MOVFF  FEC,A07
....................       switch (fs->fs_type)  
05D5C:  MOVF   x12,W
05D5E:  MOVWF  FE9
05D60:  MOVF   x13,W
05D62:  MOVWF  FEA
05D64:  MOVF   FEF,W
05D66:  XORLW  01
05D68:  MOVLB  0
05D6A:  BZ    5D7A
05D6C:  XORLW  03
05D6E:  BTFSC  FD8.2
05D70:  BRA    5EC6
05D72:  XORLW  01
05D74:  BTFSC  FD8.2
05D76:  BRA    5F4E
05D78:  BRA    601E
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05D7A:  MOVFF  9FD,A11
05D7E:  MOVFF  9FC,A10
05D82:  MOVLB  A
05D84:  CLRF   x13
05D86:  MOVLW  03
05D88:  MOVWF  x12
05D8A:  MOVLB  0
05D8C:  RCALL  5CC0
05D8E:  BCF    FD8.0
05D90:  MOVLB  A
05D92:  RRCF   02,W
05D94:  MOVWF  x03
05D96:  RRCF   01,W
05D98:  MOVWF  x02
....................             if (!move_window(fatsect + bc / 512))  
05D9A:  BCF    FD8.0
05D9C:  CLRF   03
05D9E:  RRCF   x03,W
05DA0:  MOVWF  02
05DA2:  ADDWF  x04,W
05DA4:  MOVWF  x08
05DA6:  MOVF   03,W
05DA8:  ADDWFC x05,W
05DAA:  MOVWF  x09
05DAC:  MOVLW  00
05DAE:  ADDWFC x06,W
05DB0:  MOVWF  x0A
05DB2:  MOVLW  00
05DB4:  ADDWFC x07,W
05DB6:  MOVWF  x0B
05DB8:  MOVWF  x17
05DBA:  MOVFF  A0A,A16
05DBE:  MOVFF  A09,A15
05DC2:  MOVFF  A08,A14
05DC6:  MOVLB  0
05DC8:  RCALL  5AAA
05DCA:  MOVF   01,F
05DCC:  BNZ   5DD0
....................                break; 
05DCE:  BRA    601E
....................             wc = fs->win[bc % 512]; 
05DD0:  MOVLB  A
05DD2:  MOVF   x03,W
05DD4:  ANDLW  01
05DD6:  MOVWF  x09
05DD8:  MOVLW  24
05DDA:  ADDWF  x02,W
05DDC:  MOVWF  01
05DDE:  MOVLW  00
05DE0:  ADDWFC x09,W
05DE2:  MOVWF  03
05DE4:  MOVF   01,W
05DE6:  MOVLB  7
05DE8:  ADDWF  x12,W
05DEA:  MOVWF  FE9
05DEC:  MOVF   x13,W
05DEE:  ADDWFC 03,W
05DF0:  MOVWF  FEA
05DF2:  MOVLB  A
05DF4:  CLRF   x01
05DF6:  MOVFF  FEF,A00
....................             bc++; 
05DFA:  INCF   x02,F
05DFC:  BTFSC  FD8.2
05DFE:  INCF   x03,F
....................             if (!move_window(fatsect + bc / 512))  
05E00:  BCF    FD8.0
05E02:  CLRF   03
05E04:  RRCF   x03,W
05E06:  MOVWF  02
05E08:  ADDWF  x04,W
05E0A:  MOVWF  x08
05E0C:  MOVF   03,W
05E0E:  ADDWFC x05,W
05E10:  MOVWF  x09
05E12:  MOVLW  00
05E14:  ADDWFC x06,W
05E16:  MOVWF  x0A
05E18:  MOVLW  00
05E1A:  ADDWFC x07,W
05E1C:  MOVWF  x0B
05E1E:  MOVWF  x17
05E20:  MOVFF  A0A,A16
05E24:  MOVFF  A09,A15
05E28:  MOVFF  A08,A14
05E2C:  MOVLB  0
05E2E:  RCALL  5AAA
05E30:  MOVF   01,F
05E32:  BNZ   5E36
....................                break; 
05E34:  BRA    601E
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05E36:  MOVLB  A
05E38:  MOVF   x03,W
05E3A:  ANDLW  01
05E3C:  MOVWF  x09
05E3E:  MOVLW  24
05E40:  ADDWF  x02,W
05E42:  MOVWF  01
05E44:  MOVLW  00
05E46:  ADDWFC x09,W
05E48:  MOVWF  03
05E4A:  MOVF   01,W
05E4C:  MOVLB  7
05E4E:  ADDWF  x12,W
05E50:  MOVWF  FE9
05E52:  MOVF   x13,W
05E54:  ADDWFC 03,W
05E56:  MOVWF  FEA
05E58:  MOVF   FEF,W
05E5A:  MOVLB  A
05E5C:  MOVWF  x0A
05E5E:  MOVLW  00
05E60:  IORWF  x00,F
05E62:  MOVF   x0A,W
05E64:  IORWF  x01,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05E66:  MOVLB  9
05E68:  MOVF   xFC,W
05E6A:  ANDLW  01
05E6C:  MOVWF  00
05E6E:  CLRF   01
05E70:  CLRF   02
05E72:  CLRF   03
05E74:  MOVF   00,F
05E76:  BNZ   5E84
05E78:  MOVF   01,F
05E7A:  BNZ   5E84
05E7C:  MOVF   02,F
05E7E:  BNZ   5E84
05E80:  MOVF   03,F
05E82:  BZ    5EAC
05E84:  MOVLB  A
05E86:  RRCF   x01,W
05E88:  MOVWF  03
05E8A:  RRCF   x00,W
05E8C:  MOVWF  02
05E8E:  RRCF   03,F
05E90:  RRCF   02,F
05E92:  RRCF   03,F
05E94:  RRCF   02,F
05E96:  RRCF   03,F
05E98:  RRCF   02,F
05E9A:  MOVLW  0F
05E9C:  ANDWF  03,F
05E9E:  MOVFF  02,00
05EA2:  MOVFF  03,01
05EA6:  CLRF   02
05EA8:  CLRF   03
05EAA:  BRA    5EC2
05EAC:  MOVLB  A
05EAE:  MOVFF  A00,00
05EB2:  MOVF   x01,W
05EB4:  ANDLW  0F
05EB6:  MOVWF  03
05EB8:  MOVF   x00,W
05EBA:  MOVFF  03,01
05EBE:  CLRF   02
05EC0:  CLRF   03
05EC2:  BRA    602C
05EC4:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05EC6:  MOVFF  9FD,00
05ECA:  MOVFF  9FE,01
05ECE:  MOVFF  9FF,02
05ED2:  CLRF   03
05ED4:  MOVF   00,W
05ED6:  MOVLB  A
05ED8:  ADDWF  x04,W
05EDA:  MOVWF  x08
05EDC:  MOVF   01,W
05EDE:  ADDWFC x05,W
05EE0:  MOVWF  x09
05EE2:  MOVF   02,W
05EE4:  ADDWFC x06,W
05EE6:  MOVWF  x0A
05EE8:  MOVF   03,W
05EEA:  ADDWFC x07,W
05EEC:  MOVWF  x0B
05EEE:  MOVWF  x17
05EF0:  MOVFF  A0A,A16
05EF4:  MOVFF  A09,A15
05EF8:  MOVFF  A08,A14
05EFC:  MOVLB  0
05EFE:  RCALL  5AAA
05F00:  MOVF   01,F
05F02:  BNZ   5F06
....................                break; 
05F04:  BRA    601E
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05F06:  BCF    FD8.0
05F08:  MOVLB  9
05F0A:  RLCF   xFC,W
05F0C:  MOVLB  A
05F0E:  MOVWF  x08
05F10:  MOVLB  9
05F12:  RLCF   xFD,W
05F14:  MOVLB  A
05F16:  MOVWF  x09
05F18:  MOVLW  01
05F1A:  ANDWF  x09,F
05F1C:  MOVLW  24
05F1E:  ADDWF  x08,W
05F20:  MOVWF  01
05F22:  MOVLW  00
05F24:  ADDWFC x09,W
05F26:  MOVWF  03
05F28:  MOVF   01,W
05F2A:  MOVLB  7
05F2C:  ADDWF  x12,W
05F2E:  MOVWF  01
05F30:  MOVF   x13,W
05F32:  ADDWFC 03,F
05F34:  MOVFF  01,FE9
05F38:  MOVFF  03,FEA
05F3C:  MOVFF  FEF,00
05F40:  MOVFF  FEC,01
05F44:  CLRF   02
05F46:  CLRF   03
05F48:  MOVLB  A
05F4A:  BRA    602C
05F4C:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05F4E:  MOVLB  9
05F50:  RRCF   xFF,W
05F52:  MOVWF  03
05F54:  RRCF   xFE,W
05F56:  MOVWF  02
05F58:  RRCF   xFD,W
05F5A:  MOVWF  01
05F5C:  RRCF   xFC,W
05F5E:  MOVWF  00
05F60:  RRCF   03,F
05F62:  RRCF   02,F
05F64:  RRCF   01,F
05F66:  RRCF   00,F
05F68:  RRCF   03,F
05F6A:  RRCF   02,F
05F6C:  RRCF   01,F
05F6E:  RRCF   00,F
05F70:  RRCF   03,F
05F72:  RRCF   02,F
05F74:  RRCF   01,F
05F76:  RRCF   00,F
05F78:  RRCF   03,F
05F7A:  RRCF   02,F
05F7C:  RRCF   01,F
05F7E:  RRCF   00,F
05F80:  RRCF   03,F
05F82:  RRCF   02,F
05F84:  RRCF   01,F
05F86:  RRCF   00,F
05F88:  RRCF   03,F
05F8A:  RRCF   02,F
05F8C:  RRCF   01,F
05F8E:  RRCF   00,F
05F90:  MOVLW  01
05F92:  ANDWF  03,F
05F94:  MOVF   00,W
05F96:  MOVLB  A
05F98:  ADDWF  x04,W
05F9A:  MOVWF  x08
05F9C:  MOVF   01,W
05F9E:  ADDWFC x05,W
05FA0:  MOVWF  x09
05FA2:  MOVF   02,W
05FA4:  ADDWFC x06,W
05FA6:  MOVWF  x0A
05FA8:  MOVF   03,W
05FAA:  ADDWFC x07,W
05FAC:  MOVWF  x0B
05FAE:  MOVWF  x17
05FB0:  MOVFF  A0A,A16
05FB4:  MOVFF  A09,A15
05FB8:  MOVFF  A08,A14
05FBC:  MOVLB  0
05FBE:  RCALL  5AAA
05FC0:  MOVF   01,F
05FC2:  BNZ   5FC6
....................                break; 
05FC4:  BRA    601E
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05FC6:  MOVLB  9
05FC8:  RLCF   xFC,W
05FCA:  MOVLB  A
05FCC:  MOVWF  x08
05FCE:  MOVLB  9
05FD0:  RLCF   xFD,W
05FD2:  MOVLB  A
05FD4:  MOVWF  x09
05FD6:  RLCF   x08,F
05FD8:  RLCF   x09,F
05FDA:  MOVLW  FC
05FDC:  ANDWF  x08,F
05FDE:  MOVLW  01
05FE0:  ANDWF  x09,F
05FE2:  MOVLW  24
05FE4:  ADDWF  x08,W
05FE6:  MOVWF  01
05FE8:  MOVLW  00
05FEA:  ADDWFC x09,W
05FEC:  MOVWF  03
05FEE:  MOVF   01,W
05FF0:  MOVLB  7
05FF2:  ADDWF  x12,W
05FF4:  MOVWF  01
05FF6:  MOVF   x13,W
05FF8:  ADDWFC 03,F
05FFA:  MOVFF  01,FE9
05FFE:  MOVFF  03,FEA
06002:  MOVFF  FEF,00
06006:  MOVFF  FEC,01
0600A:  MOVFF  FEC,02
0600E:  MOVFF  FEC,A0D
06012:  MOVLB  A
06014:  MOVF   x0D,W
06016:  ANDLW  0F
06018:  MOVWF  03
0601A:  BRA    602C
0601C:  MOVLB  0
0601E:  MOVLB  9
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
06020:  MOVLW  01
06022:  MOVWF  00
06024:  CLRF   01
06026:  CLRF   02
06028:  CLRF   03
0602A:  MOVLB  A
0602C:  MOVLB  0
0602E:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
065F2:  MOVLW  10
065F4:  MOVLB  7
065F6:  ADDWF  x12,W
065F8:  MOVWF  FE9
065FA:  MOVLW  00
065FC:  ADDWFC x13,W
065FE:  MOVWF  FEA
06600:  MOVFF  FEF,A08
06604:  MOVFF  FEC,A09
06608:  MOVFF  FEC,A0A
0660C:  MOVFF  FEC,A0B
....................    switch (fs->fs_type)  
06610:  MOVF   x12,W
06612:  MOVWF  FE9
06614:  MOVF   x13,W
06616:  MOVWF  FEA
06618:  MOVF   FEF,W
0661A:  XORLW  01
0661C:  MOVLB  0
0661E:  BZ    662E
06620:  XORLW  03
06622:  BTFSC  FD8.2
06624:  BRA    6812
06626:  XORLW  01
06628:  BTFSC  FD8.2
0662A:  BRA    689C
0662C:  BRA    696C
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
0662E:  MOVFF  9FD,A11
06632:  MOVFF  9FC,A10
06636:  MOVLB  A
06638:  CLRF   x13
0663A:  MOVLW  03
0663C:  MOVWF  x12
0663E:  MOVLB  0
06640:  CALL   5CC0
06644:  BCF    FD8.0
06646:  MOVLB  A
06648:  RRCF   02,W
0664A:  MOVWF  x05
0664C:  RRCF   01,W
0664E:  MOVWF  x04
....................          if (!move_window(fatsect + bc / 512)) 
06650:  BCF    FD8.0
06652:  CLRF   03
06654:  RRCF   x05,W
06656:  MOVWF  02
06658:  ADDWF  x08,W
0665A:  MOVWF  x0C
0665C:  MOVF   03,W
0665E:  ADDWFC x09,W
06660:  MOVWF  x0D
06662:  MOVLW  00
06664:  ADDWFC x0A,W
06666:  MOVWF  x0E
06668:  MOVLW  00
0666A:  ADDWFC x0B,W
0666C:  MOVWF  x0F
0666E:  MOVWF  x17
06670:  MOVFF  A0E,A16
06674:  MOVFF  A0D,A15
06678:  MOVFF  A0C,A14
0667C:  MOVLB  0
0667E:  CALL   5AAA
06682:  MOVF   01,F
06684:  BNZ   668C
....................             return (FALSE); 
06686:  MOVLW  00
06688:  MOVWF  01
0668A:  BRA    698A
....................          p = &fs->win[bc % 512]; 
0668C:  MOVLB  A
0668E:  MOVF   x05,W
06690:  ANDLW  01
06692:  MOVWF  x0D
06694:  MOVLW  24
06696:  ADDWF  x04,W
06698:  MOVWF  01
0669A:  MOVLW  00
0669C:  ADDWFC x0D,W
0669E:  MOVWF  03
066A0:  MOVF   01,W
066A2:  MOVLB  7
066A4:  ADDWF  x12,W
066A6:  MOVWF  01
066A8:  MOVF   x13,W
066AA:  ADDWFC 03,F
066AC:  MOVFF  01,A06
066B0:  MOVLB  A
066B2:  MOVFF  03,A07
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
066B6:  MOVFF  A06,A0C
066BA:  MOVFF  A07,A0D
066BE:  MOVLB  9
066C0:  MOVF   xFC,W
066C2:  ANDLW  01
066C4:  MOVWF  00
066C6:  CLRF   01
066C8:  CLRF   02
066CA:  CLRF   03
066CC:  MOVF   00,F
066CE:  BNZ   66DC
066D0:  MOVF   01,F
066D2:  BNZ   66DC
066D4:  MOVF   02,F
066D6:  BNZ   66DC
066D8:  MOVF   03,F
066DA:  BZ    66FE
066DC:  MOVFF  A07,03
066E0:  MOVLB  A
066E2:  MOVFF  A06,FE9
066E6:  MOVFF  A07,FEA
066EA:  MOVF   FEF,W
066EC:  ANDLW  0F
066EE:  MOVWF  x0E
066F0:  SWAPF  x00,W
066F2:  MOVWF  00
066F4:  MOVLW  F0
066F6:  ANDWF  00,F
066F8:  MOVF   00,W
066FA:  IORWF  x0E,W
066FC:  BRA    6702
066FE:  MOVLB  A
06700:  MOVF   x00,W
06702:  MOVFF  A0D,FEA
06706:  MOVFF  A0C,FE9
0670A:  MOVWF  FEF
....................          fs->winflag = 1; 
0670C:  MOVLW  06
0670E:  MOVLB  7
06710:  ADDWF  x12,W
06712:  MOVWF  FE9
06714:  MOVLW  00
06716:  ADDWFC x13,W
06718:  MOVWF  FEA
0671A:  MOVLW  01
0671C:  MOVWF  FEF
....................          bc++; 
0671E:  MOVLB  A
06720:  INCF   x04,F
06722:  BTFSC  FD8.2
06724:  INCF   x05,F
....................          if (!move_window(fatsect + bc / 512)) 
06726:  BCF    FD8.0
06728:  CLRF   03
0672A:  RRCF   x05,W
0672C:  MOVWF  02
0672E:  ADDWF  x08,W
06730:  MOVWF  x0C
06732:  MOVF   03,W
06734:  ADDWFC x09,W
06736:  MOVWF  x0D
06738:  MOVLW  00
0673A:  ADDWFC x0A,W
0673C:  MOVWF  x0E
0673E:  MOVLW  00
06740:  ADDWFC x0B,W
06742:  MOVWF  x0F
06744:  MOVWF  x17
06746:  MOVFF  A0E,A16
0674A:  MOVFF  A0D,A15
0674E:  MOVFF  A0C,A14
06752:  MOVLB  0
06754:  CALL   5AAA
06758:  MOVF   01,F
0675A:  BNZ   6762
....................             return (FALSE); 
0675C:  MOVLW  00
0675E:  MOVWF  01
06760:  BRA    698A
....................          p = &fs->win[bc % 512]; 
06762:  MOVLB  A
06764:  MOVF   x05,W
06766:  ANDLW  01
06768:  MOVWF  x0D
0676A:  MOVLW  24
0676C:  ADDWF  x04,W
0676E:  MOVWF  01
06770:  MOVLW  00
06772:  ADDWFC x0D,W
06774:  MOVWF  03
06776:  MOVF   01,W
06778:  MOVLB  7
0677A:  ADDWF  x12,W
0677C:  MOVWF  01
0677E:  MOVF   x13,W
06780:  ADDWFC 03,F
06782:  MOVFF  01,A06
06786:  MOVLB  A
06788:  MOVFF  03,A07
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
0678C:  MOVFF  A06,A0C
06790:  MOVFF  A07,A0D
06794:  MOVLB  9
06796:  MOVF   xFC,W
06798:  ANDLW  01
0679A:  MOVWF  00
0679C:  CLRF   01
0679E:  CLRF   02
067A0:  CLRF   03
067A2:  MOVF   00,F
067A4:  BNZ   67B2
067A6:  MOVF   01,F
067A8:  BNZ   67B2
067AA:  MOVF   02,F
067AC:  BNZ   67B2
067AE:  MOVF   03,F
067B0:  BZ    67E4
067B2:  MOVLB  A
067B4:  RRCF   x03,W
067B6:  MOVWF  03
067B8:  RRCF   x02,W
067BA:  MOVWF  02
067BC:  RRCF   x01,W
067BE:  MOVWF  01
067C0:  RRCF   x00,W
067C2:  MOVWF  00
067C4:  RRCF   03,F
067C6:  RRCF   02,F
067C8:  RRCF   01,F
067CA:  RRCF   00,F
067CC:  RRCF   03,F
067CE:  RRCF   02,F
067D0:  RRCF   01,F
067D2:  RRCF   00,F
067D4:  RRCF   03,F
067D6:  RRCF   02,F
067D8:  RRCF   01,F
067DA:  RRCF   00,F
067DC:  MOVLW  0F
067DE:  ANDWF  03,F
067E0:  MOVF   00,W
067E2:  BRA    6806
067E4:  MOVLB  A
067E6:  MOVFF  A06,FE9
067EA:  MOVFF  A07,FEA
067EE:  MOVF   FEF,W
067F0:  ANDLW  F0
067F2:  MOVWF  x0F
067F4:  MOVFF  A01,00
067F8:  MOVFF  A02,01
067FC:  MOVFF  A03,02
06800:  MOVF   x01,W
06802:  ANDLW  0F
06804:  IORWF  x0F,W
06806:  MOVFF  A0D,FEA
0680A:  MOVFF  A0C,FE9
0680E:  MOVWF  FEF
....................          break; 
06810:  BRA    6974
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
06812:  MOVFF  9FD,00
06816:  MOVFF  9FE,01
0681A:  MOVFF  9FF,02
0681E:  CLRF   03
06820:  MOVF   00,W
06822:  MOVLB  A
06824:  ADDWF  x08,W
06826:  MOVWF  x0C
06828:  MOVF   01,W
0682A:  ADDWFC x09,W
0682C:  MOVWF  x0D
0682E:  MOVF   02,W
06830:  ADDWFC x0A,W
06832:  MOVWF  x0E
06834:  MOVF   03,W
06836:  ADDWFC x0B,W
06838:  MOVWF  x0F
0683A:  MOVWF  x17
0683C:  MOVFF  A0E,A16
06840:  MOVFF  A0D,A15
06844:  MOVFF  A0C,A14
06848:  MOVLB  0
0684A:  CALL   5AAA
0684E:  MOVF   01,F
06850:  BNZ   6858
....................             return (FALSE); 
06852:  MOVLW  00
06854:  MOVWF  01
06856:  BRA    698A
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
06858:  BCF    FD8.0
0685A:  MOVLB  9
0685C:  RLCF   xFC,W
0685E:  MOVLB  A
06860:  MOVWF  x0C
06862:  MOVLB  9
06864:  RLCF   xFD,W
06866:  MOVLB  A
06868:  MOVWF  x0D
0686A:  MOVLW  01
0686C:  ANDWF  x0D,F
0686E:  MOVLW  24
06870:  ADDWF  x0C,W
06872:  MOVWF  01
06874:  MOVLW  00
06876:  ADDWFC x0D,W
06878:  MOVWF  03
0687A:  MOVF   01,W
0687C:  MOVLB  7
0687E:  ADDWF  x12,W
06880:  MOVWF  01
06882:  MOVF   x13,W
06884:  ADDWFC 03,F
06886:  MOVFF  01,FE9
0688A:  MOVFF  03,FEA
0688E:  MOVFF  A01,FEC
06892:  MOVF   FED,F
06894:  MOVFF  A00,FEF
....................          break; 
06898:  MOVLB  A
0689A:  BRA    6974
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
0689C:  MOVLB  9
0689E:  RRCF   xFF,W
068A0:  MOVWF  03
068A2:  RRCF   xFE,W
068A4:  MOVWF  02
068A6:  RRCF   xFD,W
068A8:  MOVWF  01
068AA:  RRCF   xFC,W
068AC:  MOVWF  00
068AE:  RRCF   03,F
068B0:  RRCF   02,F
068B2:  RRCF   01,F
068B4:  RRCF   00,F
068B6:  RRCF   03,F
068B8:  RRCF   02,F
068BA:  RRCF   01,F
068BC:  RRCF   00,F
068BE:  RRCF   03,F
068C0:  RRCF   02,F
068C2:  RRCF   01,F
068C4:  RRCF   00,F
068C6:  RRCF   03,F
068C8:  RRCF   02,F
068CA:  RRCF   01,F
068CC:  RRCF   00,F
068CE:  RRCF   03,F
068D0:  RRCF   02,F
068D2:  RRCF   01,F
068D4:  RRCF   00,F
068D6:  RRCF   03,F
068D8:  RRCF   02,F
068DA:  RRCF   01,F
068DC:  RRCF   00,F
068DE:  MOVLW  01
068E0:  ANDWF  03,F
068E2:  MOVF   00,W
068E4:  MOVLB  A
068E6:  ADDWF  x08,W
068E8:  MOVWF  x0C
068EA:  MOVF   01,W
068EC:  ADDWFC x09,W
068EE:  MOVWF  x0D
068F0:  MOVF   02,W
068F2:  ADDWFC x0A,W
068F4:  MOVWF  x0E
068F6:  MOVF   03,W
068F8:  ADDWFC x0B,W
068FA:  MOVWF  x0F
068FC:  MOVWF  x17
068FE:  MOVFF  A0E,A16
06902:  MOVFF  A0D,A15
06906:  MOVFF  A0C,A14
0690A:  MOVLB  0
0690C:  CALL   5AAA
06910:  MOVF   01,F
06912:  BNZ   691A
....................             return (FALSE); 
06914:  MOVLW  00
06916:  MOVWF  01
06918:  BRA    698A
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
0691A:  MOVLB  9
0691C:  RLCF   xFC,W
0691E:  MOVLB  A
06920:  MOVWF  x0C
06922:  MOVLB  9
06924:  RLCF   xFD,W
06926:  MOVLB  A
06928:  MOVWF  x0D
0692A:  RLCF   x0C,F
0692C:  RLCF   x0D,F
0692E:  MOVLW  FC
06930:  ANDWF  x0C,F
06932:  MOVLW  01
06934:  ANDWF  x0D,F
06936:  MOVLW  24
06938:  ADDWF  x0C,W
0693A:  MOVWF  01
0693C:  MOVLW  00
0693E:  ADDWFC x0D,W
06940:  MOVWF  03
06942:  MOVF   01,W
06944:  MOVLB  7
06946:  ADDWF  x12,W
06948:  MOVWF  01
0694A:  MOVF   x13,W
0694C:  ADDWFC 03,F
0694E:  MOVFF  01,FE9
06952:  MOVFF  03,FEA
06956:  MOVFF  A00,FEF
0695A:  MOVFF  A01,FEC
0695E:  MOVFF  A02,FEC
06962:  MOVFF  A03,FEC
....................          break; 
06966:  MOVLB  A
06968:  BRA    6974
0696A:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
0696C:  MOVLW  00
0696E:  MOVWF  01
06970:  BRA    698A
06972:  MOVLB  A
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
06974:  MOVLW  06
06976:  MOVLB  7
06978:  ADDWF  x12,W
0697A:  MOVWF  FE9
0697C:  MOVLW  00
0697E:  ADDWFC x13,W
06980:  MOVWF  FEA
06982:  MOVLW  01
06984:  MOVWF  FEF
....................    return (TRUE); 
06986:  MOVWF  01
06988:  MOVLB  0
0698A:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06F6E:  MOVFF  9DE,9FF
06F72:  MOVFF  9DD,9FE
06F76:  MOVFF  9DC,9FD
06F7A:  MOVFF  9DB,9FC
06F7E:  CALL   5CE2
06F82:  MOVFF  03,9E2
06F86:  MOVFF  02,9E1
06F8A:  MOVFF  01,9E0
06F8E:  MOVFF  00,9DF
06F92:  MOVLB  9
06F94:  MOVF   xE2,F
06F96:  BNZ   6FA6
06F98:  MOVF   xE1,F
06F9A:  BNZ   6FA6
06F9C:  MOVF   xE0,F
06F9E:  BNZ   6FA6
06FA0:  MOVF   xDF,W
06FA2:  SUBLW  01
06FA4:  BC    7008
....................       { 
....................       if (!put_cluster(clust, 0)) 
06FA6:  MOVFF  9DE,9FF
06FAA:  MOVFF  9DD,9FE
06FAE:  MOVFF  9DC,9FD
06FB2:  MOVFF  9DB,9FC
06FB6:  MOVLB  A
06FB8:  CLRF   x03
06FBA:  CLRF   x02
06FBC:  CLRF   x01
06FBE:  CLRF   x00
06FC0:  MOVLB  0
06FC2:  CALL   65F2
06FC6:  MOVF   01,F
06FC8:  BNZ   6FD0
....................          return FALSE; 
06FCA:  MOVLW  00
06FCC:  MOVWF  01
06FCE:  BRA    700E
....................       clust = nxt; 
06FD0:  MOVFF  9E2,9DE
06FD4:  MOVFF  9E1,9DD
06FD8:  MOVFF  9E0,9DC
06FDC:  MOVFF  9DF,9DB
06FE0:  MOVFF  9DE,9FF
06FE4:  MOVFF  9DD,9FE
06FE8:  MOVFF  9DC,9FD
06FEC:  MOVFF  9DB,9FC
06FF0:  CALL   5CE2
06FF4:  MOVFF  03,9E2
06FF8:  MOVFF  02,9E1
06FFC:  MOVFF  01,9E0
07000:  MOVFF  00,9DF
07004:  BRA    6F92
07006:  MOVLB  9
....................       } 
....................    return TRUE; 
07008:  MOVLW  01
0700A:  MOVWF  01
0700C:  MOVLB  0
0700E:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
0698C:  MOVLW  0C
0698E:  MOVLB  7
06990:  ADDWF  x12,W
06992:  MOVWF  FE9
06994:  MOVLW  00
06996:  ADDWFC x13,W
06998:  MOVWF  FEA
0699A:  MOVFF  FEF,9F8
0699E:  MOVFF  FEC,9F9
069A2:  MOVFF  FEC,9FA
069A6:  MOVFF  FEC,9FB
....................    if (clust == 0)  
069AA:  MOVLB  9
069AC:  MOVF   xE8,F
069AE:  BNZ   6A18
069B0:  MOVF   xE9,F
069B2:  BNZ   6A18
069B4:  MOVF   xEA,F
069B6:  BNZ   6A18
069B8:  MOVF   xEB,F
069BA:  BNZ   6A18
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
069BC:  MOVLW  1C
069BE:  MOVLB  7
069C0:  ADDWF  x12,W
069C2:  MOVWF  FE9
069C4:  MOVLW  00
069C6:  ADDWFC x13,W
069C8:  MOVWF  FEA
069CA:  MOVFF  FEF,9F4
069CE:  MOVFF  FEC,9F5
069D2:  MOVFF  FEC,9F6
069D6:  MOVFF  FEC,9F7
....................       if (scl < 2 || scl >= mcl) scl = 1; 
069DA:  MOVLB  9
069DC:  MOVF   xF7,F
069DE:  BNZ   69EE
069E0:  MOVF   xF6,F
069E2:  BNZ   69EE
069E4:  MOVF   xF5,F
069E6:  BNZ   69EE
069E8:  MOVF   xF4,W
069EA:  SUBLW  01
069EC:  BC    6A0C
069EE:  MOVF   xFB,W
069F0:  SUBWF  xF7,W
069F2:  BNC   6A16
069F4:  BNZ   6A0C
069F6:  MOVF   xFA,W
069F8:  SUBWF  xF6,W
069FA:  BNC   6A16
069FC:  BNZ   6A0C
069FE:  MOVF   xF9,W
06A00:  SUBWF  xF5,W
06A02:  BNC   6A16
06A04:  BNZ   6A0C
06A06:  MOVF   xF8,W
06A08:  SUBWF  xF4,W
06A0A:  BNC   6A16
06A0C:  CLRF   xF7
06A0E:  CLRF   xF6
06A10:  CLRF   xF5
06A12:  MOVLW  01
06A14:  MOVWF  xF4
....................       } 
06A16:  BRA    6A9C
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
06A18:  MOVFF  9EB,9FF
06A1C:  MOVFF  9EA,9FE
06A20:  MOVFF  9E9,9FD
06A24:  MOVFF  9E8,9FC
06A28:  MOVLB  0
06A2A:  CALL   5CE2
06A2E:  MOVFF  03,9EF
06A32:  MOVFF  02,9EE
06A36:  MOVFF  01,9ED
06A3A:  MOVFF  00,9EC
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
06A3E:  MOVLB  9
06A40:  MOVF   xEF,F
06A42:  BNZ   6A5C
06A44:  MOVF   xEE,F
06A46:  BNZ   6A5C
06A48:  MOVF   xED,F
06A4A:  BNZ   6A5C
06A4C:  MOVF   xEC,W
06A4E:  SUBLW  01
06A50:  BNC   6A5C
06A52:  CLRF   00
06A54:  CLRF   01
06A56:  CLRF   02
06A58:  CLRF   03
06A5A:  BRA    6C20
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
06A5C:  MOVF   xEF,W
06A5E:  SUBWF  xFB,W
06A60:  BNC   6A8C
06A62:  BNZ   6A7A
06A64:  MOVF   xEE,W
06A66:  SUBWF  xFA,W
06A68:  BNC   6A8C
06A6A:  BNZ   6A7A
06A6C:  MOVF   xED,W
06A6E:  SUBWF  xF9,W
06A70:  BNC   6A8C
06A72:  BNZ   6A7A
06A74:  MOVF   xF8,W
06A76:  SUBWF  xEC,W
06A78:  BC    6A8C
06A7A:  MOVFF  9EC,00
06A7E:  MOVFF  9ED,01
06A82:  MOVFF  9EE,02
06A86:  MOVFF  9EF,03
06A8A:  BRA    6C20
....................       scl = clust; 
06A8C:  MOVFF  9EB,9F7
06A90:  MOVFF  9EA,9F6
06A94:  MOVFF  9E9,9F5
06A98:  MOVFF  9E8,9F4
....................       } 
....................       ncl = scl;                  // Scan start cluster 
06A9C:  MOVFF  9F7,9F3
06AA0:  MOVFF  9F6,9F2
06AA4:  MOVFF  9F5,9F1
06AA8:  MOVFF  9F4,9F0
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
06AAC:  MOVLW  01
06AAE:  ADDWF  xF0,F
06AB0:  BTFSC  FD8.0
06AB2:  INCF   xF1,F
06AB4:  BTFSC  FD8.2
06AB6:  INCF   xF2,F
06AB8:  BTFSC  FD8.2
06ABA:  INCF   xF3,F
....................       if (ncl >= mcl)  
06ABC:  MOVF   xFB,W
06ABE:  SUBWF  xF3,W
06AC0:  BNC   6AFE
06AC2:  BNZ   6ADA
06AC4:  MOVF   xFA,W
06AC6:  SUBWF  xF2,W
06AC8:  BNC   6AFE
06ACA:  BNZ   6ADA
06ACC:  MOVF   xF9,W
06ACE:  SUBWF  xF1,W
06AD0:  BNC   6AFE
06AD2:  BNZ   6ADA
06AD4:  MOVF   xF8,W
06AD6:  SUBWF  xF0,W
06AD8:  BNC   6AFE
....................          {         // Wrap around 
....................          ncl = 2; 
06ADA:  CLRF   xF3
06ADC:  CLRF   xF2
06ADE:  CLRF   xF1
06AE0:  MOVLW  02
06AE2:  MOVWF  xF0
....................          if (scl == 1) return 0;      // No free custer was found 
06AE4:  DECFSZ xF4,W
06AE6:  BRA    6AFE
06AE8:  MOVF   xF5,F
06AEA:  BNZ   6AFE
06AEC:  MOVF   xF6,F
06AEE:  BNZ   6AFE
06AF0:  MOVF   xF7,F
06AF2:  BNZ   6AFE
06AF4:  CLRF   00
06AF6:  CLRF   01
06AF8:  CLRF   02
06AFA:  CLRF   03
06AFC:  BRA    6C20
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06AFE:  MOVF   xF4,W
06B00:  SUBWF  xF0,W
06B02:  BNZ   6B20
06B04:  MOVF   xF5,W
06B06:  SUBWF  xF1,W
06B08:  BNZ   6B20
06B0A:  MOVF   xF6,W
06B0C:  SUBWF  xF2,W
06B0E:  BNZ   6B20
06B10:  MOVF   xF7,W
06B12:  SUBWF  xF3,W
06B14:  BNZ   6B20
06B16:  CLRF   00
06B18:  CLRF   01
06B1A:  CLRF   02
06B1C:  CLRF   03
06B1E:  BRA    6C20
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06B20:  MOVFF  9F3,9FF
06B24:  MOVFF  9F2,9FE
06B28:  MOVFF  9F1,9FD
06B2C:  MOVFF  9F0,9FC
06B30:  MOVLB  0
06B32:  CALL   5CE2
06B36:  MOVFF  03,9EF
06B3A:  MOVFF  02,9EE
06B3E:  MOVFF  01,9ED
06B42:  MOVFF  00,9EC
....................       if (cstat == 1) return 0;      // Any error occured 
06B46:  MOVLB  9
06B48:  DECFSZ xEC,W
06B4A:  BRA    6B62
06B4C:  MOVF   xED,F
06B4E:  BNZ   6B62
06B50:  MOVF   xEE,F
06B52:  BNZ   6B62
06B54:  MOVF   xEF,F
06B56:  BNZ   6B62
06B58:  CLRF   00
06B5A:  CLRF   01
06B5C:  CLRF   02
06B5E:  CLRF   03
06B60:  BRA    6C20
....................       } while (cstat);            // Repeat until find a free cluster 
06B62:  MOVF   xEC,F
06B64:  BNZ   6AAC
06B66:  MOVF   xED,F
06B68:  BNZ   6AAC
06B6A:  MOVF   xEE,F
06B6C:  BNZ   6AAC
06B6E:  MOVF   xEF,F
06B70:  BNZ   6AAC
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06B72:  MOVFF  9F3,9FF
06B76:  MOVFF  9F2,9FE
06B7A:  MOVFF  9F1,9FD
06B7E:  MOVFF  9F0,9FC
06B82:  MOVLW  0F
06B84:  MOVLB  A
06B86:  MOVWF  x03
06B88:  SETF   x02
06B8A:  SETF   x01
06B8C:  SETF   x00
06B8E:  MOVLB  0
06B90:  RCALL  65F2
06B92:  MOVF   01,F
06B94:  BNZ   6BA4
06B96:  CLRF   00
06B98:  CLRF   01
06B9A:  CLRF   02
06B9C:  CLRF   03
06B9E:  MOVLB  9
06BA0:  BRA    6C20
06BA2:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06BA4:  MOVLB  9
06BA6:  MOVF   xE8,F
06BA8:  BNZ   6BB6
06BAA:  MOVF   xE9,F
06BAC:  BNZ   6BB6
06BAE:  MOVF   xEA,F
06BB0:  BNZ   6BB6
06BB2:  MOVF   xEB,F
06BB4:  BZ    6BF0
06BB6:  MOVFF  9EB,9FF
06BBA:  MOVFF  9EA,9FE
06BBE:  MOVFF  9E9,9FD
06BC2:  MOVFF  9E8,9FC
06BC6:  MOVFF  9F3,A03
06BCA:  MOVFF  9F2,A02
06BCE:  MOVFF  9F1,A01
06BD2:  MOVFF  9F0,A00
06BD6:  MOVLB  0
06BD8:  RCALL  65F2
06BDA:  MOVF   01,F
06BDC:  BTFSC  FD8.2
06BDE:  BRA    6BE4
06BE0:  MOVLB  9
06BE2:  BRA    6BF0
06BE4:  CLRF   00
06BE6:  CLRF   01
06BE8:  CLRF   02
06BEA:  CLRF   03
06BEC:  MOVLB  9
06BEE:  BRA    6C20
....................    fs->last_clust = ncl; 
06BF0:  MOVLW  1C
06BF2:  MOVLB  7
06BF4:  ADDWF  x12,W
06BF6:  MOVWF  FE9
06BF8:  MOVLW  00
06BFA:  ADDWFC x13,W
06BFC:  MOVWF  FEA
06BFE:  MOVFF  9F0,FEF
06C02:  MOVFF  9F1,FEC
06C06:  MOVFF  9F2,FEC
06C0A:  MOVFF  9F3,FEC
....................  
....................    return ncl;      // Return new cluster number 
06C0E:  MOVFF  9F0,00
06C12:  MOVFF  9F1,01
06C16:  MOVFF  9F2,02
06C1A:  MOVFF  9F3,03
06C1E:  MOVLB  9
06C20:  MOVLB  0
06C22:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
05636:  MOVLW  02
05638:  MOVLB  9
0563A:  SUBWF  xEF,F
0563C:  MOVLW  00
0563E:  SUBWFB xF0,F
05640:  SUBWFB xF1,F
05642:  SUBWFB xF2,F
....................    if (clust >= fs->max_clust)  
05644:  MOVLW  0C
05646:  MOVLB  7
05648:  ADDWF  x12,W
0564A:  MOVWF  FE9
0564C:  MOVLW  00
0564E:  ADDWFC x13,W
05650:  MOVWF  FEA
05652:  MOVFF  FEF,00
05656:  MOVFF  FEC,01
0565A:  MOVFF  FEC,02
0565E:  MOVFF  FEC,03
05662:  MOVF   03,W
05664:  MOVLB  9
05666:  SUBWF  xF2,W
05668:  BNC   568C
0566A:  BNZ   5682
0566C:  MOVF   02,W
0566E:  SUBWF  xF1,W
05670:  BNC   568C
05672:  BNZ   5682
05674:  MOVF   01,W
05676:  SUBWF  xF0,W
05678:  BNC   568C
0567A:  BNZ   5682
0567C:  MOVF   00,W
0567E:  SUBWF  xEF,W
05680:  BNC   568C
....................       return 0;      // Invalid cluster#  
05682:  CLRF   00
05684:  CLRF   01
05686:  CLRF   02
05688:  CLRF   03
0568A:  BRA    570C
....................    return (clust * fs->sects_clust + fs->database); 
0568C:  MOVLW  02
0568E:  MOVLB  7
05690:  ADDWF  x12,W
05692:  MOVWF  FE9
05694:  MOVLW  00
05696:  ADDWFC x13,W
05698:  MOVWF  FEA
0569A:  MOVFF  FEF,9FA
0569E:  MOVLB  9
056A0:  MOVFF  FEA,9F5
056A4:  MOVFF  FE9,9F4
056A8:  MOVFF  9F2,9F9
056AC:  MOVFF  9F1,9F8
056B0:  MOVFF  9F0,9F7
056B4:  MOVFF  9EF,9F6
056B8:  CLRF   xFD
056BA:  CLRF   xFC
056BC:  CLRF   xFB
056BE:  MOVLB  0
056C0:  CALL   4818
056C4:  MOVFF  9F5,FEA
056C8:  MOVFF  9F4,FE9
056CC:  MOVFF  03,9F6
056D0:  MOVFF  02,9F5
056D4:  MOVFF  01,9F4
056D8:  MOVFF  00,9F3
056DC:  MOVLW  18
056DE:  MOVLB  7
056E0:  ADDWF  x12,W
056E2:  MOVWF  FE9
056E4:  MOVLW  00
056E6:  ADDWFC x13,W
056E8:  MOVWF  FEA
056EA:  MOVFF  FEF,00
056EE:  MOVFF  FEC,01
056F2:  MOVFF  FEC,02
056F6:  MOVFF  FEC,03
056FA:  MOVLB  9
056FC:  MOVF   xF3,W
056FE:  ADDWF  00,F
05700:  MOVF   xF4,W
05702:  ADDWFC 01,F
05704:  MOVF   xF5,W
05706:  ADDWFC 02,F
05708:  MOVF   xF6,W
0570A:  ADDWFC 03,F
0570C:  MOVLB  0
0570E:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
046B8:  MOVLW  24
046BA:  MOVLB  7
046BC:  ADDWF  x12,W
046BE:  MOVWF  01
046C0:  MOVLW  00
046C2:  ADDWFC x13,W
046C4:  MOVWF  03
046C6:  MOVFF  01,9E7
046CA:  MOVLB  9
046CC:  MOVWF  xE8
046CE:  MOVWF  FEA
046D0:  MOVFF  01,FE9
046D4:  CLRF   00
046D6:  MOVLW  02
046D8:  MOVWF  02
046DA:  CLRF   01
046DC:  MOVLB  0
046DE:  CALL   354E
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
046E2:  MOVLW  24
046E4:  MOVLB  7
046E6:  ADDWF  x12,W
046E8:  MOVWF  01
046EA:  MOVLW  00
046EC:  ADDWFC x13,W
046EE:  MOVWF  03
046F0:  MOVFF  01,9E7
046F4:  MOVLB  9
046F6:  MOVWF  xE8
046F8:  MOVFF  FE8,A21
046FC:  MOVFF  01,A20
04700:  MOVFF  9E6,A25
04704:  MOVFF  9E5,A24
04708:  MOVFF  9E4,A23
0470C:  MOVFF  9E3,A22
04710:  MOVLW  01
04712:  MOVLB  A
04714:  MOVWF  x26
04716:  MOVLB  0
04718:  RCALL  44F4
0471A:  MOVF   01,F
0471C:  BTFSS  FD8.2
0471E:  BRA    480E
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
04720:  MOVLW  22
04722:  MOVLB  7
04724:  ADDWF  x12,W
04726:  MOVWF  01
04728:  MOVLW  02
0472A:  ADDWFC x13,W
0472C:  MOVWF  03
0472E:  MOVFF  01,FE9
04732:  MOVWF  FEA
04734:  MOVFF  FEC,9E8
04738:  MOVF   FED,F
0473A:  MOVFF  FEF,9E7
0473E:  MOVLB  9
04740:  MOVF   xE7,W
04742:  SUBLW  55
04744:  BNZ   4810
04746:  MOVF   xE8,W
04748:  SUBLW  AA
0474A:  BNZ   4810
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
0474C:  MOVLW  5A
0474E:  MOVLB  7
04750:  ADDWF  x12,W
04752:  MOVWF  01
04754:  MOVLW  00
04756:  ADDWFC x13,W
04758:  MOVWF  03
0475A:  MOVFF  01,9E7
0475E:  MOVLB  9
04760:  MOVWF  xE8
04762:  MOVWF  xEA
04764:  MOVFF  01,9E9
04768:  MOVLW  07
0476A:  MOVWF  xEC
0476C:  MOVLW  14
0476E:  MOVWF  xEB
04770:  CLRF   xEE
04772:  MOVLW  05
04774:  MOVWF  xED
04776:  MOVLB  0
04778:  RCALL  4634
0477A:  MOVF   01,F
0477C:  BNZ   4784
....................             return (FS_FAT12); 
0477E:  MOVLW  01
04780:  MOVWF  01
04782:  BRA    4816
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
04784:  MOVLW  5A
04786:  MOVLB  7
04788:  ADDWF  x12,W
0478A:  MOVWF  01
0478C:  MOVLW  00
0478E:  ADDWFC x13,W
04790:  MOVWF  03
04792:  MOVFF  01,9E7
04796:  MOVLB  9
04798:  MOVWF  xE8
0479A:  MOVWF  xEA
0479C:  MOVFF  01,9E9
047A0:  MOVLW  07
047A2:  MOVWF  xEC
047A4:  MOVLW  19
047A6:  MOVWF  xEB
047A8:  CLRF   xEE
047AA:  MOVLW  05
047AC:  MOVWF  xED
047AE:  MOVLB  0
047B0:  RCALL  4634
047B2:  MOVF   01,F
047B4:  BNZ   47BC
....................             return (FS_FAT16); 
047B6:  MOVLW  02
047B8:  MOVWF  01
047BA:  BRA    4816
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
047BC:  MOVLW  76
047BE:  MOVLB  7
047C0:  ADDWF  x12,W
047C2:  MOVWF  01
047C4:  MOVLW  00
047C6:  ADDWFC x13,W
047C8:  MOVWF  03
047CA:  MOVFF  01,9E7
047CE:  MOVLB  9
047D0:  MOVWF  xE8
047D2:  MOVWF  xEA
047D4:  MOVFF  01,9E9
047D8:  MOVLW  07
047DA:  MOVWF  xEC
047DC:  MOVLW  1E
047DE:  MOVWF  xEB
047E0:  CLRF   xEE
047E2:  MOVLW  05
047E4:  MOVWF  xED
047E6:  MOVLB  0
047E8:  RCALL  4634
047EA:  MOVF   01,F
047EC:  BNZ   480E
047EE:  MOVLW  4C
047F0:  MOVLB  7
047F2:  ADDWF  x12,W
047F4:  MOVWF  FE9
047F6:  MOVLW  00
047F8:  ADDWFC x13,W
047FA:  MOVWF  FEA
047FC:  MOVF   FEF,F
047FE:  BTFSC  FD8.2
04800:  BRA    4806
04802:  MOVLB  0
04804:  BRA    480E
....................             return (FS_FAT32); 
04806:  MOVLW  03
04808:  MOVWF  01
0480A:  MOVLB  0
0480C:  BRA    4816
0480E:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
04810:  MOVLW  00
04812:  MOVWF  01
04814:  MOVLB  0
04816:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
06030:  MOVLW  0C
06032:  MOVLB  9
06034:  ADDWF  xE5,W
06036:  MOVWF  FE9
06038:  MOVLW  00
0603A:  ADDWFC xE6,W
0603C:  MOVWF  FEA
0603E:  MOVFF  FEC,9EE
06042:  MOVF   FED,F
06044:  MOVFF  FEF,9ED
06048:  MOVLW  01
0604A:  ADDWF  xED,W
0604C:  MOVWF  xEB
0604E:  MOVLW  00
06050:  ADDWFC xEE,W
06052:  MOVWF  xEC
....................    if ((idx & 15) == 0)  
06054:  MOVF   xEB,W
06056:  ANDLW  0F
06058:  MOVWF  xED
0605A:  CLRF   xEE
0605C:  MOVF   xED,F
0605E:  BTFSS  FD8.2
06060:  BRA    61EC
06062:  MOVF   xEE,F
06064:  BTFSS  FD8.2
06066:  BRA    61EC
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
06068:  MOVLW  08
0606A:  ADDWF  xE5,W
0606C:  MOVWF  FE9
0606E:  MOVLW  00
06070:  ADDWFC xE6,W
06072:  MOVWF  FEA
06074:  MOVLW  01
06076:  ADDWF  FEE,F
06078:  MOVLW  00
0607A:  ADDWFC FEE,F
0607C:  ADDWFC FEE,F
0607E:  ADDWFC FED,F
....................       if (!scan->clust)  
06080:  MOVLW  04
06082:  ADDWF  xE5,W
06084:  MOVWF  FE9
06086:  MOVLW  00
06088:  ADDWFC xE6,W
0608A:  MOVWF  FEA
0608C:  MOVF   FEF,F
0608E:  BNZ   60CC
06090:  MOVF   FEC,F
06092:  BNZ   60CC
06094:  MOVF   FEC,F
06096:  BNZ   60CC
06098:  MOVF   FEC,F
0609A:  BNZ   60CC
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
0609C:  MOVLW  04
0609E:  MOVLB  7
060A0:  ADDWF  x12,W
060A2:  MOVWF  FE9
060A4:  MOVLW  00
060A6:  ADDWFC x13,W
060A8:  MOVWF  FEA
060AA:  MOVFF  FEC,03
060AE:  MOVF   FED,F
060B0:  MOVFF  FEF,01
060B4:  MOVF   03,W
060B6:  MOVLB  9
060B8:  SUBWF  xEC,W
060BA:  BNC   60CA
060BC:  BNZ   60C4
060BE:  MOVF   01,W
060C0:  SUBWF  xEB,W
060C2:  BNC   60CA
....................             return (FALSE);   // Reached to end of table  
060C4:  MOVLW  00
060C6:  MOVWF  01
060C8:  BRA    6206
....................          }  
060CA:  BRA    61EC
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
060CC:  RRCF   xEC,W
060CE:  MOVWF  xEE
060D0:  RRCF   xEB,W
060D2:  MOVWF  xED
060D4:  RRCF   xEE,F
060D6:  RRCF   xED,F
060D8:  RRCF   xEE,F
060DA:  RRCF   xED,F
060DC:  RRCF   xEE,F
060DE:  RRCF   xED,F
060E0:  MOVLW  0F
060E2:  ANDWF  xEE,F
060E4:  MOVLW  02
060E6:  MOVLB  7
060E8:  ADDWF  x12,W
060EA:  MOVWF  FE9
060EC:  MOVLW  00
060EE:  ADDWFC x13,W
060F0:  MOVWF  FEA
060F2:  MOVLW  01
060F4:  SUBWF  FEF,W
060F6:  MOVLB  9
060F8:  ANDWF  xED,F
060FA:  CLRF   xEE
060FC:  MOVF   xED,F
060FE:  BTFSS  FD8.2
06100:  BRA    61EC
06102:  MOVF   xEE,F
06104:  BTFSS  FD8.2
06106:  BRA    61EC
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
06108:  MOVLW  04
0610A:  ADDWF  xE5,W
0610C:  MOVWF  FE9
0610E:  MOVLW  00
06110:  ADDWFC xE6,W
06112:  MOVWF  FEA
06114:  MOVFF  FEF,9FC
06118:  MOVFF  FEC,9FD
0611C:  MOVFF  FEC,9FE
06120:  MOVFF  FEC,9FF
06124:  MOVLB  0
06126:  RCALL  5CE2
06128:  MOVFF  03,9EA
0612C:  MOVFF  02,9E9
06130:  MOVFF  01,9E8
06134:  MOVFF  00,9E7
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
06138:  MOVLW  0C
0613A:  MOVLB  7
0613C:  ADDWF  x12,W
0613E:  MOVWF  FE9
06140:  MOVLW  00
06142:  ADDWFC x13,W
06144:  MOVWF  FEA
06146:  MOVFF  FEF,00
0614A:  MOVFF  FEC,01
0614E:  MOVFF  FEC,02
06152:  MOVFF  FEC,03
06156:  MOVF   03,W
06158:  MOVLB  9
0615A:  SUBWF  xEA,W
0615C:  BNC   6176
0615E:  BNZ   6188
06160:  MOVF   02,W
06162:  SUBWF  xE9,W
06164:  BNC   6176
06166:  BNZ   6188
06168:  MOVF   01,W
0616A:  SUBWF  xE8,W
0616C:  BNC   6176
0616E:  BNZ   6188
06170:  MOVF   00,W
06172:  SUBWF  xE7,W
06174:  BC    6188
06176:  MOVF   xEA,F
06178:  BNZ   618E
0617A:  MOVF   xE9,F
0617C:  BNZ   618E
0617E:  MOVF   xE8,F
06180:  BNZ   618E
06182:  MOVF   xE7,W
06184:  SUBLW  01
06186:  BNC   618E
....................                return (FALSE); 
06188:  MOVLW  00
0618A:  MOVWF  01
0618C:  BRA    6206
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
0618E:  MOVLW  04
06190:  ADDWF  xE5,W
06192:  MOVWF  FE9
06194:  MOVLW  00
06196:  ADDWFC xE6,W
06198:  MOVWF  FEA
0619A:  MOVFF  9E7,FEF
0619E:  MOVFF  9E8,FEC
061A2:  MOVFF  9E9,FEC
061A6:  MOVFF  9EA,FEC
....................             scan->sect = clust2sect(clust); 
061AA:  MOVLW  08
061AC:  ADDWF  xE5,W
061AE:  MOVWF  01
061B0:  MOVLW  00
061B2:  ADDWFC xE6,W
061B4:  MOVWF  03
061B6:  MOVFF  01,9ED
061BA:  MOVWF  xEE
061BC:  MOVFF  9EA,9F2
061C0:  MOVFF  9E9,9F1
061C4:  MOVFF  9E8,9F0
061C8:  MOVFF  9E7,9EF
061CC:  MOVLB  0
061CE:  CALL   5636
061D2:  MOVFF  9EE,FEA
061D6:  MOVFF  9ED,FE9
061DA:  MOVFF  00,FEF
061DE:  MOVFF  01,FEC
061E2:  MOVFF  02,FEC
061E6:  MOVFF  03,FEC
061EA:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
061EC:  MOVLW  0C
061EE:  ADDWF  xE5,W
061F0:  MOVWF  FE9
061F2:  MOVLW  00
061F4:  ADDWFC xE6,W
061F6:  MOVWF  FEA
061F8:  MOVFF  9EC,FEC
061FC:  MOVF   FED,F
061FE:  MOVFF  9EB,FEF
....................    return (TRUE); 
06202:  MOVLW  01
06204:  MOVWF  01
06206:  MOVLB  0
06208:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
05710:  MOVFF  9E8,FEA
05714:  MOVFF  9E7,FE9
05718:  MOVLW  20
0571A:  MOVWF  00
0571C:  CLRF   02
0571E:  MOVLW  0B
05720:  MOVWF  01
05722:  CALL   354E
....................    a = 0; b = 0x18;            // NT flag 
05726:  MOVLB  9
05728:  CLRF   xEC
0572A:  MOVLW  18
0572C:  MOVWF  xED
....................    n = 0; t = 8; 
0572E:  CLRF   xE9
05730:  MOVLW  08
05732:  MOVWF  xEA
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
05734:  MOVFF  9E5,FE9
05738:  MOVFF  9E6,FEA
0573C:  MOVFF  FEC,9EF
05740:  MOVF   FED,F
05742:  MOVFF  FEF,9EE
....................       c = *ptr; 
05746:  MOVFF  9EE,FE9
0574A:  MOVFF  9EF,FEA
0574E:  MOVFF  FEF,9EB
....................       (*path)++; 
05752:  MOVFF  9E6,03
05756:  MOVFF  9E5,FE9
0575A:  MOVFF  9E6,FEA
0575E:  MOVLW  01
05760:  ADDWF  FEE,F
05762:  BNC   5766
05764:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
05766:  MOVF   xEB,W
05768:  SUBLW  20
0576A:  BNC   576E
....................          c = 0; 
0576C:  CLRF   xEB
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
0576E:  MOVF   xEB,F
05770:  BZ    577E
05772:  MOVF   xEB,W
05774:  SUBLW  2F
05776:  BZ    577E
05778:  MOVF   xEB,W
0577A:  SUBLW  5C
0577C:  BNZ   579C
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
0577E:  MOVF   xE9,F
05780:  BNZ   5784
....................             break; 
05782:  BRA    5864
....................          dirname[11] = a & b;  
05784:  MOVLW  0B
05786:  ADDWF  xE7,W
05788:  MOVWF  FE9
0578A:  MOVLW  00
0578C:  ADDWFC xE8,W
0578E:  MOVWF  FEA
05790:  MOVF   xEC,W
05792:  ANDWF  xED,W
05794:  MOVWF  FEF
....................             return (c); 
05796:  MOVFF  9EB,01
0579A:  BRA    5868
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
0579C:  MOVF   xEB,W
0579E:  SUBLW  20
057A0:  BC    57A8
057A2:  MOVF   xEB,W
057A4:  SUBLW  7F
057A6:  BNZ   57AA
....................          break;   // reject invisible characters 
057A8:  BRA    5864
....................       if (c == '.')  
057AA:  MOVF   xEB,W
057AC:  SUBLW  2E
057AE:  BNZ   57CC
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
057B0:  BTFSC  xEC.0
057B2:  BRA    57CA
057B4:  MOVF   xE9,W
057B6:  SUBLW  00
057B8:  BC    57CA
057BA:  MOVF   xE9,W
057BC:  SUBLW  08
057BE:  BNC   57CA
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
057C0:  MOVLW  08
057C2:  MOVWF  xE9
057C4:  MOVLW  0B
057C6:  MOVWF  xEA
....................             continue; 
057C8:  BRA    5862
....................             } 
....................          break; 
057CA:  BRA    5864
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
057CC:  MOVF   xEB,W
057CE:  SUBLW  22
057D0:  BNZ   57D4
....................          break;               // Reject "  
057D2:  BRA    5864
....................  
....................       if (c <= ')')  
057D4:  MOVF   xEB,W
057D6:  SUBLW  29
057D8:  BNC   57DC
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
057DA:  BRA    5846
....................  
....................       if (c <= ',') 
057DC:  MOVF   xEB,W
057DE:  SUBLW  2C
057E0:  BNC   57E4
....................          break;               // Reject * + ,  
057E2:  BRA    5864
....................  
....................       if (c <= '9')  
057E4:  MOVF   xEB,W
057E6:  SUBLW  39
057E8:  BNC   57EC
....................          goto md_l1;            // Accept - 0-9  
057EA:  BRA    5846
....................  
....................       if (c <= '?')  
057EC:  MOVF   xEB,W
057EE:  SUBLW  3F
057F0:  BNC   57F4
....................          break;               // Reject : ; < = > ?  
057F2:  BRA    5864
....................  
....................       if (!(a & 1))  
057F4:  BTFSC  xEC.0
057F6:  BRA    5846
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
057F8:  MOVF   xEB,W
057FA:  SUBLW  7C
057FC:  BNZ   5800
....................             break;            // Reject |  
057FE:  BRA    5864
....................  
....................          if ((c >= '[') && (c <= ']')) 
05800:  MOVF   xEB,W
05802:  SUBLW  5A
05804:  BC    580E
05806:  MOVF   xEB,W
05808:  SUBLW  5D
0580A:  BNC   580E
....................             break;// Reject [ \ ]  
0580C:  BRA    5864
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
0580E:  MOVF   xEB,W
05810:  SUBLW  40
05812:  BC    5828
05814:  MOVF   xEB,W
05816:  SUBLW  5A
05818:  BNC   5828
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
0581A:  MOVF   xEA,W
0581C:  SUBLW  08
0581E:  BNZ   5826
05820:  BCF    xED.3
05822:  MOVF   xED,W
05824:  BRA    5828
05826:  BCF    xED.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
05828:  MOVF   xEB,W
0582A:  SUBLW  60
0582C:  BC    5846
0582E:  MOVF   xEB,W
05830:  SUBLW  7A
05832:  BNC   5846
....................             {      // Convert to upper case  
....................             c -= 0x20; 
05834:  MOVLW  20
05836:  SUBWF  xEB,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
05838:  MOVF   xEA,W
0583A:  SUBLW  08
0583C:  BNZ   5844
0583E:  BSF    xEC.3
05840:  MOVF   xEC,W
05842:  BRA    5846
05844:  BSF    xEC.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
05846:  BCF    xEC.0
....................    md_l2: 
....................       if (n >= t)  
05848:  MOVF   xEA,W
0584A:  SUBWF  xE9,W
0584C:  BNC   5850
....................          break; 
0584E:  BRA    5864
....................       dirname[n++] = c; 
05850:  MOVF   xE9,W
05852:  INCF   xE9,F
05854:  ADDWF  xE7,W
05856:  MOVWF  FE9
05858:  MOVLW  00
0585A:  ADDWFC xE8,W
0585C:  MOVWF  FEA
0585E:  MOVFF  9EB,FEF
05862:  BRA    5734
....................       } 
....................    return 1; 
05864:  MOVLW  01
05866:  MOVWF  01
05868:  MOVLB  0
0586A:  GOTO   63AC (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
0620A:  MOVLB  9
0620C:  CLRF   xE4
0620E:  CLRF   xE3
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
06210:  MOVLW  14
06212:  MOVLB  7
06214:  ADDWF  x12,W
06216:  MOVWF  FE9
06218:  MOVLW  00
0621A:  ADDWFC x13,W
0621C:  MOVWF  FEA
0621E:  MOVFF  FEF,9DE
06222:  MOVFF  FEC,9DF
06226:  MOVFF  FEC,9E0
0622A:  MOVFF  FEC,9E1
....................    if (fs->fs_type == FS_FAT32)  
0622E:  MOVFF  712,FE9
06232:  MOVFF  713,FEA
06236:  MOVF   FEF,W
06238:  SUBLW  03
0623A:  BNZ   62BE
....................       { 
....................       scan->clust = scan->sclust = clust; 
0623C:  MOVLW  04
0623E:  MOVLB  9
06240:  ADDWF  xD6,W
06242:  MOVWF  01
06244:  MOVLW  00
06246:  ADDWFC xD7,W
06248:  MOVFF  01,9E5
0624C:  MOVFF  9D6,FE9
06250:  MOVFF  9D7,FEA
06254:  MOVFF  9DE,FEF
06258:  MOVFF  9DF,FEC
0625C:  MOVFF  9E0,FEC
06260:  MOVFF  9E1,FEC
06264:  MOVWF  FEA
06266:  MOVFF  9E5,FE9
0626A:  MOVFF  9DE,FEF
0626E:  MOVFF  9DF,FEC
06272:  MOVFF  9E0,FEC
06276:  MOVFF  9E1,FEC
....................       scan->sect = clust2sect(clust); 
0627A:  MOVLW  08
0627C:  ADDWF  xD6,W
0627E:  MOVWF  01
06280:  MOVLW  00
06282:  ADDWFC xD7,W
06284:  MOVWF  03
06286:  MOVFF  01,9E5
0628A:  MOVWF  xE6
0628C:  MOVFF  9E1,9F2
06290:  MOVFF  9E0,9F1
06294:  MOVFF  9DF,9F0
06298:  MOVFF  9DE,9EF
0629C:  MOVLB  0
0629E:  CALL   5636
062A2:  MOVFF  9E6,FEA
062A6:  MOVFF  9E5,FE9
062AA:  MOVFF  00,FEF
062AE:  MOVFF  01,FEC
062B2:  MOVFF  02,FEC
062B6:  MOVFF  03,FEC
....................       } 
062BA:  BRA    631E
062BC:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
062BE:  MOVLW  04
062C0:  MOVLB  9
062C2:  ADDWF  xD6,W
062C4:  MOVWF  01
062C6:  MOVLW  00
062C8:  ADDWFC xD7,W
062CA:  MOVWF  03
062CC:  MOVFF  9D6,FE9
062D0:  MOVFF  9D7,FEA
062D4:  MOVF   FEE,F
062D6:  MOVF   FEE,F
062D8:  CLRF   FEC
062DA:  MOVF   FED,F
062DC:  CLRF   FEF
062DE:  MOVF   FED,F
062E0:  CLRF   FEF
062E2:  MOVF   FED,F
062E4:  CLRF   FEF
062E6:  MOVLW  00
062E8:  MOVFF  03,FEA
062EC:  MOVFF  01,FE9
062F0:  MOVFF  00,FEF
062F4:  MOVFF  01,FEC
062F8:  MOVFF  02,FEC
062FC:  MOVFF  03,FEC
....................       scan->sect = clust; 
06300:  MOVLW  08
06302:  ADDWF  xD6,W
06304:  MOVWF  FE9
06306:  MOVLW  00
06308:  ADDWFC xD7,W
0630A:  MOVWF  FEA
0630C:  MOVFF  9DE,FEF
06310:  MOVFF  9DF,FEC
06314:  MOVFF  9E0,FEC
06318:  MOVFF  9E1,FEC
0631C:  MOVLB  0
....................       } 
....................    scan->index = 0; 
0631E:  MOVLW  0C
06320:  MOVLB  9
06322:  ADDWF  xD6,W
06324:  MOVWF  FE9
06326:  MOVLW  00
06328:  ADDWFC xD7,W
0632A:  MOVWF  FEA
0632C:  CLRF   FEC
0632E:  MOVF   FED,F
06330:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
06332:  MOVFF  9DB,03
06336:  MOVFF  9DA,FE9
0633A:  MOVFF  9DB,FEA
0633E:  MOVF   FEF,W
06340:  SUBLW  20
06342:  BZ    6368
06344:  MOVFF  9DB,03
06348:  MOVFF  9DA,FE9
0634C:  MOVFF  9DB,FEA
06350:  MOVF   FEF,W
06352:  SUBLW  2F
06354:  BZ    6368
06356:  MOVFF  9DB,03
0635A:  MOVFF  9DA,FE9
0635E:  MOVFF  9DB,FEA
06362:  MOVF   FEF,W
06364:  SUBLW  5C
06366:  BNZ   6370
....................        path++; 
06368:  INCF   xDA,F
0636A:  BTFSC  FD8.2
0636C:  INCF   xDB,F
0636E:  BRA    6332
....................  
....................    if ((BYTE)*path < ' ')  
06370:  MOVFF  9DB,03
06374:  MOVFF  9DA,FE9
06378:  MOVFF  9DB,FEA
0637C:  MOVF   FEF,W
0637E:  SUBLW  1F
06380:  BNC   6396
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
06382:  MOVFF  9DC,FE9
06386:  MOVFF  9DD,FEA
0638A:  CLRF   FEC
0638C:  MOVF   FED,F
0638E:  CLRF   FEF
....................       return (FR_OK); 
06390:  MOVLW  00
06392:  MOVWF  01
06394:  BRA    65EE
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
06396:  MOVLW  09
06398:  MOVWF  xE6
0639A:  MOVLW  DA
0639C:  MOVWF  xE5
0639E:  MOVFF  9D9,9E8
063A2:  MOVFF  9D8,9E7
063A6:  MOVLB  0
063A8:  GOTO   5710
063AC:  MOVFF  01,9E2
....................       if (ds == 1)  
063B0:  MOVLB  9
063B2:  DECFSZ xE2,W
063B4:  BRA    63BC
....................          return (FR_INVALID_NAME); 
063B6:  MOVLW  04
063B8:  MOVWF  01
063BA:  BRA    65EE
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
063BC:  MOVLW  08
063BE:  ADDWF  xD6,W
063C0:  MOVWF  FE9
063C2:  MOVLW  00
063C4:  ADDWFC xD7,W
063C6:  MOVWF  FEA
063C8:  MOVFF  FEF,A14
063CC:  MOVFF  FEC,A15
063D0:  MOVFF  FEC,A16
063D4:  MOVFF  FEC,A17
063D8:  MOVLB  0
063DA:  CALL   5AAA
063DE:  MOVF   01,F
063E0:  BNZ   63EC
....................             return (FR_RW_ERROR); 
063E2:  MOVLW  07
063E4:  MOVWF  01
063E6:  MOVLB  9
063E8:  BRA    65EE
063EA:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
063EC:  MOVLW  0C
063EE:  MOVLB  9
063F0:  ADDWF  xD6,W
063F2:  MOVWF  FE9
063F4:  MOVLW  00
063F6:  ADDWFC xD7,W
063F8:  MOVWF  FEA
063FA:  MOVFF  FEC,9E6
063FE:  MOVF   FED,F
06400:  MOVFF  FEF,9E5
06404:  MOVLW  0F
06406:  ANDWF  xE5,F
06408:  CLRF   xE6
0640A:  RLCF   xE5,F
0640C:  RLCF   xE6,F
0640E:  RLCF   xE5,F
06410:  RLCF   xE6,F
06412:  RLCF   xE5,F
06414:  RLCF   xE6,F
06416:  RLCF   xE5,F
06418:  RLCF   xE6,F
0641A:  RLCF   xE5,F
0641C:  RLCF   xE6,F
0641E:  MOVLW  E0
06420:  ANDWF  xE5,F
06422:  MOVLW  24
06424:  ADDWF  xE5,W
06426:  MOVWF  01
06428:  MOVLW  00
0642A:  ADDWFC xE6,W
0642C:  MOVWF  03
0642E:  MOVF   01,W
06430:  MOVLB  7
06432:  ADDWF  x12,W
06434:  MOVWF  01
06436:  MOVF   x13,W
06438:  ADDWFC 03,F
0643A:  MOVFF  01,9E3
0643E:  MOVLB  9
06440:  MOVFF  03,9E4
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
06444:  MOVFF  9E4,03
06448:  MOVFF  9E3,FE9
0644C:  MOVFF  9E4,FEA
06450:  MOVF   FEF,F
06452:  BNZ   6462
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06454:  MOVF   xE2,F
06456:  BNZ   645C
06458:  MOVLW  02
0645A:  BRA    645E
0645C:  MOVLW  03
0645E:  MOVWF  01
06460:  BRA    65EE
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
06462:  MOVFF  9E4,03
06466:  MOVFF  9E3,FE9
0646A:  MOVFF  9E4,FEA
0646E:  MOVF   FEF,W
06470:  SUBLW  E5
06472:  BZ    64B4
06474:  MOVLW  0B
06476:  ADDWF  xE3,W
06478:  MOVWF  01
0647A:  MOVLW  00
0647C:  ADDWFC xE4,W
0647E:  MOVWF  03
06480:  MOVFF  01,FE9
06484:  MOVWF  FEA
06486:  BTFSC  FEF.3
06488:  BRA    64B4
0648A:  MOVFF  9E4,9EA
0648E:  MOVFF  9E3,9E9
06492:  MOVFF  9D9,9EC
06496:  MOVFF  9D8,9EB
0649A:  CLRF   xEE
0649C:  MOVLW  0B
0649E:  MOVWF  xED
064A0:  MOVLB  0
064A2:  CALL   4634
064A6:  MOVF   01,F
064A8:  BTFSC  FD8.2
064AA:  BRA    64B0
064AC:  MOVLB  9
064AE:  BRA    64B4
....................              break; 
064B0:  BRA    64DC
064B2:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
064B4:  MOVFF  9D7,9E6
064B8:  MOVFF  9D6,9E5
064BC:  MOVLB  0
064BE:  RCALL  6030
064C0:  MOVF   01,F
064C2:  BNZ   64D6
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
064C4:  MOVLB  9
064C6:  MOVF   xE2,F
064C8:  BNZ   64CE
064CA:  MOVLW  02
064CC:  BRA    64D0
064CE:  MOVLW  03
064D0:  MOVWF  01
064D2:  BRA    65EE
064D4:  MOVLB  0
064D6:  MOVLB  9
064D8:  BRA    63BC
064DA:  MOVLB  0
....................          } 
....................       if (!ds)  
064DC:  MOVLB  9
064DE:  MOVF   xE2,F
064E0:  BNZ   64FA
....................          {  
....................          *win_dir = dptr;  
064E2:  MOVFF  9DC,FE9
064E6:  MOVFF  9DD,FEA
064EA:  MOVFF  9E4,FEC
064EE:  MOVF   FED,F
064F0:  MOVFF  9E3,FEF
....................          return (FR_OK); 
064F4:  MOVLW  00
064F6:  MOVWF  01
064F8:  BRA    65EE
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
064FA:  MOVLW  0B
064FC:  ADDWF  xE3,W
064FE:  MOVWF  01
06500:  MOVLW  00
06502:  ADDWFC xE4,W
06504:  MOVWF  03
06506:  MOVFF  01,FE9
0650A:  MOVWF  FEA
0650C:  BTFSC  FEF.4
0650E:  BRA    6516
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
06510:  MOVLW  03
06512:  MOVWF  01
06514:  BRA    65EE
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
06516:  MOVLW  14
06518:  ADDWF  xE3,W
0651A:  MOVWF  01
0651C:  MOVLW  00
0651E:  ADDWFC xE4,W
06520:  MOVWF  03
06522:  MOVFF  01,FE9
06526:  MOVWF  FEA
06528:  MOVFF  FEC,9E1
0652C:  MOVF   FED,F
0652E:  MOVFF  FEF,9E5
06532:  MOVFF  9E5,9E0
06536:  CLRF   xE5
06538:  CLRF   xE6
0653A:  MOVLW  1A
0653C:  ADDWF  xE3,W
0653E:  MOVWF  01
06540:  MOVLW  00
06542:  ADDWFC xE4,W
06544:  MOVFF  01,FE9
06548:  MOVWF  FEA
0654A:  MOVFF  FEC,03
0654E:  MOVF   FED,F
06550:  MOVF   FEF,W
06552:  IORWF  xE5,W
06554:  MOVWF  xDE
06556:  MOVF   03,W
06558:  IORWF  xE6,W
0655A:  MOVWF  xDF
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
0655C:  MOVLW  04
0655E:  ADDWF  xD6,W
06560:  MOVWF  01
06562:  MOVLW  00
06564:  ADDWFC xD7,W
06566:  MOVFF  01,9E5
0656A:  MOVFF  9D6,FE9
0656E:  MOVFF  9D7,FEA
06572:  MOVFF  9DE,FEF
06576:  MOVFF  9DF,FEC
0657A:  MOVFF  9E0,FEC
0657E:  MOVFF  9E1,FEC
06582:  MOVWF  FEA
06584:  MOVFF  9E5,FE9
06588:  MOVFF  9DE,FEF
0658C:  MOVFF  9DF,FEC
06590:  MOVFF  9E0,FEC
06594:  MOVFF  9E1,FEC
....................       scan->sect = clust2sect(clust); 
06598:  MOVLW  08
0659A:  ADDWF  xD6,W
0659C:  MOVWF  01
0659E:  MOVLW  00
065A0:  ADDWFC xD7,W
065A2:  MOVWF  03
065A4:  MOVFF  01,9E5
065A8:  MOVWF  xE6
065AA:  MOVFF  9E1,9F2
065AE:  MOVFF  9E0,9F1
065B2:  MOVFF  9DF,9F0
065B6:  MOVFF  9DE,9EF
065BA:  MOVLB  0
065BC:  CALL   5636
065C0:  MOVFF  9E6,FEA
065C4:  MOVFF  9E5,FE9
065C8:  MOVFF  00,FEF
065CC:  MOVFF  01,FEC
065D0:  MOVFF  02,FEC
065D4:  MOVFF  03,FEC
....................       scan->index = 0; 
065D8:  MOVLW  0C
065DA:  MOVLB  9
065DC:  ADDWF  xD6,W
065DE:  MOVWF  FE9
065E0:  MOVLW  00
065E2:  ADDWFC xD7,W
065E4:  MOVWF  FEA
065E6:  CLRF   FEC
065E8:  MOVF   FED,F
065EA:  CLRF   FEF
065EC:  BRA    6396
....................       } 
065EE:  MOVLB  0
065F0:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06C24:  MOVLB  9
06C26:  MOVFF  9D6,FE9
06C2A:  MOVFF  9D7,FEA
06C2E:  MOVFF  FEF,9D8
06C32:  MOVFF  FEC,9D9
06C36:  MOVFF  FEC,9DA
06C3A:  MOVFF  FEC,9DB
....................    if (clust) {   // Dyanmic directory table  
06C3E:  MOVF   xD8,F
06C40:  BNZ   6C4E
06C42:  MOVF   xD9,F
06C44:  BNZ   6C4E
06C46:  MOVF   xDA,F
06C48:  BNZ   6C4E
06C4A:  MOVF   xDB,F
06C4C:  BZ    6CAE
....................       scan->clust = clust; 
06C4E:  MOVLW  04
06C50:  ADDWF  xD6,W
06C52:  MOVWF  FE9
06C54:  MOVLW  00
06C56:  ADDWFC xD7,W
06C58:  MOVWF  FEA
06C5A:  MOVFF  9D8,FEF
06C5E:  MOVFF  9D9,FEC
06C62:  MOVFF  9DA,FEC
06C66:  MOVFF  9DB,FEC
....................       scan->sect = clust2sect(clust); 
06C6A:  MOVLW  08
06C6C:  ADDWF  xD6,W
06C6E:  MOVWF  01
06C70:  MOVLW  00
06C72:  ADDWFC xD7,W
06C74:  MOVWF  03
06C76:  MOVFF  01,9E4
06C7A:  MOVWF  xE5
06C7C:  MOVFF  9DB,9F2
06C80:  MOVFF  9DA,9F1
06C84:  MOVFF  9D9,9F0
06C88:  MOVFF  9D8,9EF
06C8C:  MOVLB  0
06C8E:  CALL   5636
06C92:  MOVFF  9E5,FEA
06C96:  MOVFF  9E4,FE9
06C9A:  MOVFF  00,FEF
06C9E:  MOVFF  01,FEC
06CA2:  MOVFF  02,FEC
06CA6:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06CAA:  BRA    6CF8
06CAC:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06CAE:  MOVLW  08
06CB0:  ADDWF  xD6,W
06CB2:  MOVWF  01
06CB4:  MOVLW  00
06CB6:  ADDWFC xD7,W
06CB8:  MOVWF  03
06CBA:  MOVFF  01,9E4
06CBE:  MOVWF  xE5
06CC0:  MOVLW  14
06CC2:  MOVLB  7
06CC4:  ADDWF  x12,W
06CC6:  MOVWF  FE9
06CC8:  MOVLW  00
06CCA:  ADDWFC x13,W
06CCC:  MOVWF  FEA
06CCE:  MOVFF  FEF,00
06CD2:  MOVFF  FEC,01
06CD6:  MOVFF  FEC,02
06CDA:  MOVFF  FEC,03
06CDE:  MOVFF  9E5,FEA
06CE2:  MOVFF  9E4,FE9
06CE6:  MOVFF  00,FEF
06CEA:  MOVFF  01,FEC
06CEE:  MOVFF  02,FEC
06CF2:  MOVFF  03,FEC
06CF6:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06CF8:  MOVLW  0C
06CFA:  MOVLB  9
06CFC:  ADDWF  xD6,W
06CFE:  MOVWF  FE9
06D00:  MOVLW  00
06D02:  ADDWFC xD7,W
06D04:  MOVWF  FEA
06D06:  CLRF   FEC
06D08:  MOVF   FED,F
06D0A:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06D0C:  MOVLW  08
06D0E:  ADDWF  xD6,W
06D10:  MOVWF  FE9
06D12:  MOVLW  00
06D14:  ADDWFC xD7,W
06D16:  MOVWF  FEA
06D18:  MOVFF  FEF,A14
06D1C:  MOVFF  FEC,A15
06D20:  MOVFF  FEC,A16
06D24:  MOVFF  FEC,A17
06D28:  MOVLB  0
06D2A:  CALL   5AAA
06D2E:  MOVF   01,F
06D30:  BNZ   6D3A
....................          return (NULL); 
06D32:  MOVLW  00
06D34:  MOVWF  01
06D36:  MOVWF  02
06D38:  BRA    6F68
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06D3A:  MOVLW  0C
06D3C:  MOVLB  9
06D3E:  ADDWF  xD6,W
06D40:  MOVWF  FE9
06D42:  MOVLW  00
06D44:  ADDWFC xD7,W
06D46:  MOVWF  FEA
06D48:  MOVFF  FEC,9E5
06D4C:  MOVF   FED,F
06D4E:  MOVFF  FEF,9E4
06D52:  MOVLW  0F
06D54:  ANDWF  xE4,F
06D56:  CLRF   xE5
06D58:  RLCF   xE4,F
06D5A:  RLCF   xE5,F
06D5C:  RLCF   xE4,F
06D5E:  RLCF   xE5,F
06D60:  RLCF   xE4,F
06D62:  RLCF   xE5,F
06D64:  RLCF   xE4,F
06D66:  RLCF   xE5,F
06D68:  RLCF   xE4,F
06D6A:  RLCF   xE5,F
06D6C:  MOVLW  E0
06D6E:  ANDWF  xE4,F
06D70:  MOVLW  24
06D72:  ADDWF  xE4,W
06D74:  MOVWF  01
06D76:  MOVLW  00
06D78:  ADDWFC xE5,W
06D7A:  MOVWF  03
06D7C:  MOVF   01,W
06D7E:  MOVLB  7
06D80:  ADDWF  x12,W
06D82:  MOVWF  01
06D84:  MOVF   x13,W
06D86:  ADDWFC 03,F
06D88:  MOVFF  01,9E2
06D8C:  MOVLB  9
06D8E:  MOVFF  03,9E3
....................       c = *dptr; 
06D92:  MOVFF  9E2,FE9
06D96:  MOVFF  9E3,FEA
06D9A:  MOVFF  FEF,9E0
....................       if ((c == 0) || (c == 0xE5))  
06D9E:  MOVF   xE0,F
06DA0:  BZ    6DA8
06DA2:  MOVF   xE0,W
06DA4:  SUBLW  E5
06DA6:  BNZ   6DB6
....................          return (dptr);      // Found an empty entry!  
06DA8:  MOVFF  9E2,01
06DAC:  MOVFF  9E3,02
06DB0:  MOVLB  0
06DB2:  BRA    6F68
06DB4:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06DB6:  MOVFF  9D7,9E6
06DBA:  MOVFF  9D6,9E5
06DBE:  MOVLB  0
06DC0:  CALL   6030
06DC4:  MOVF   01,F
06DC6:  BTFSC  FD8.2
06DC8:  BRA    6DCE
06DCA:  MOVLB  9
06DCC:  BRA    6D0C
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06DCE:  MOVLB  9
06DD0:  MOVF   xD8,F
06DD2:  BNZ   6DEC
06DD4:  MOVF   xD9,F
06DD6:  BNZ   6DEC
06DD8:  MOVF   xDA,F
06DDA:  BNZ   6DEC
06DDC:  MOVF   xDB,F
06DDE:  BNZ   6DEC
....................        return (NULL); 
06DE0:  MOVLW  00
06DE2:  MOVWF  01
06DE4:  MOVWF  02
06DE6:  MOVLB  0
06DE8:  BRA    6F68
06DEA:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06DEC:  MOVLW  04
06DEE:  ADDWF  xD6,W
06DF0:  MOVWF  FE9
06DF2:  MOVLW  00
06DF4:  ADDWFC xD7,W
06DF6:  MOVWF  FEA
06DF8:  MOVFF  FEF,9E8
06DFC:  MOVFF  FEC,9E9
06E00:  MOVFF  FEC,9EA
06E04:  MOVFF  FEC,9EB
06E08:  MOVLB  0
06E0A:  RCALL  698C
06E0C:  MOVFF  03,9DB
06E10:  MOVFF  02,9DA
06E14:  MOVFF  01,9D9
06E18:  MOVFF  00,9D8
....................    if (!(clust))  
06E1C:  MOVLB  9
06E1E:  MOVF   xD8,F
06E20:  BNZ   6E3A
06E22:  MOVF   xD9,F
06E24:  BNZ   6E3A
06E26:  MOVF   xDA,F
06E28:  BNZ   6E3A
06E2A:  MOVF   xDB,F
06E2C:  BNZ   6E3A
....................       return (NULL); 
06E2E:  MOVLW  00
06E30:  MOVWF  01
06E32:  MOVWF  02
06E34:  MOVLB  0
06E36:  BRA    6F68
06E38:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06E3A:  MOVLB  A
06E3C:  CLRF   x17
06E3E:  CLRF   x16
06E40:  CLRF   x15
06E42:  CLRF   x14
06E44:  MOVLB  0
06E46:  CALL   5AAA
06E4A:  MOVF   01,F
06E4C:  BNZ   6E56
....................       return (0); 
06E4E:  MOVLW  00
06E50:  MOVWF  01
06E52:  MOVWF  02
06E54:  BRA    6F68
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06E56:  MOVLW  20
06E58:  MOVLB  7
06E5A:  ADDWF  x12,W
06E5C:  MOVWF  01
06E5E:  MOVLW  00
06E60:  ADDWFC x13,W
06E62:  MOVWF  03
06E64:  MOVFF  01,9E4
06E68:  MOVLB  9
06E6A:  MOVWF  xE5
06E6C:  MOVFF  9DB,9F2
06E70:  MOVFF  9DA,9F1
06E74:  MOVFF  9D9,9F0
06E78:  MOVFF  9D8,9EF
06E7C:  MOVLB  0
06E7E:  CALL   5636
06E82:  MOVFF  03,9DF
06E86:  MOVFF  02,9DE
06E8A:  MOVFF  01,9DD
06E8E:  MOVFF  00,9DC
06E92:  MOVFF  9E5,FEA
06E96:  MOVFF  9E4,FE9
06E9A:  MOVFF  9DC,FEF
06E9E:  MOVFF  9DD,FEC
06EA2:  MOVFF  9DE,FEC
06EA6:  MOVFF  9DF,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06EAA:  MOVLW  24
06EAC:  MOVLB  7
06EAE:  ADDWF  x12,W
06EB0:  MOVWF  01
06EB2:  MOVLW  00
06EB4:  ADDWFC x13,W
06EB6:  MOVWF  03
06EB8:  MOVFF  01,9E4
06EBC:  MOVLB  9
06EBE:  MOVWF  xE5
06EC0:  MOVWF  FEA
06EC2:  MOVFF  01,FE9
06EC6:  CLRF   00
06EC8:  MOVLW  02
06ECA:  MOVWF  02
06ECC:  CLRF   01
06ECE:  MOVLB  0
06ED0:  CALL   354E
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06ED4:  MOVLW  02
06ED6:  MOVLB  7
06ED8:  ADDWF  x12,W
06EDA:  MOVWF  FE9
06EDC:  MOVLW  00
06EDE:  ADDWFC x13,W
06EE0:  MOVWF  FEA
06EE2:  MOVFF  FEF,9E1
06EE6:  MOVLB  9
06EE8:  MOVF   xE1,F
06EEA:  BZ    6F48
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06EEC:  MOVLW  24
06EEE:  MOVLB  7
06EF0:  ADDWF  x12,W
06EF2:  MOVWF  01
06EF4:  MOVLW  00
06EF6:  ADDWFC x13,W
06EF8:  MOVWF  03
06EFA:  MOVFF  01,9E4
06EFE:  MOVLB  9
06F00:  MOVWF  xE5
06F02:  MOVFF  FE8,A21
06F06:  MOVFF  01,A20
06F0A:  MOVFF  9DF,A25
06F0E:  MOVFF  9DE,A24
06F12:  MOVFF  9DD,A23
06F16:  MOVFF  9DC,A22
06F1A:  MOVLW  01
06F1C:  MOVLB  A
06F1E:  MOVWF  x26
06F20:  MOVLB  0
06F22:  CALL   5966
06F26:  MOVF   01,F
06F28:  BZ    6F32
....................          return (NULL); 
06F2A:  MOVLW  00
06F2C:  MOVWF  01
06F2E:  MOVWF  02
06F30:  BRA    6F68
....................       sector++; 
06F32:  MOVLW  01
06F34:  MOVLB  9
06F36:  ADDWF  xDC,F
06F38:  BTFSC  FD8.0
06F3A:  INCF   xDD,F
06F3C:  BTFSC  FD8.2
06F3E:  INCF   xDE,F
06F40:  BTFSC  FD8.2
06F42:  INCF   xDF,F
06F44:  DECF   xE1,F
06F46:  BRA    6EE8
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06F48:  MOVLW  06
06F4A:  MOVLB  7
06F4C:  ADDWF  x12,W
06F4E:  MOVWF  FE9
06F50:  MOVLW  00
06F52:  ADDWFC x13,W
06F54:  MOVWF  FEA
06F56:  MOVLW  01
06F58:  MOVWF  FEF
....................    return (fs->win); 
06F5A:  MOVLW  24
06F5C:  ADDWF  x12,W
06F5E:  MOVWF  01
06F60:  MOVLW  00
06F62:  ADDWFC x13,W
06F64:  MOVWF  03
06F66:  MOVWF  02
06F68:  MOVLB  0
06F6A:  GOTO   7202 (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
055D4:  MOVLB  7
055D6:  MOVF   x12,W
055D8:  IORWF  x13,W
055DA:  BNZ   55E2
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
055DC:  MOVLW  0B
055DE:  MOVWF  01
055E0:  BRA    5632
....................  
....................    if (disk_status() & STA_NOINIT)  
055E2:  MOVLB  0
055E4:  RCALL  55C6
055E6:  BTFSS  01.0
055E8:  BRA    5614
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
055EA:  MOVLW  01
055EC:  MOVLB  7
055EE:  ADDWF  x12,W
055F0:  MOVWF  FE9
055F2:  MOVLW  00
055F4:  ADDWFC x13,W
055F6:  MOVWF  FEA
055F8:  MOVF   FEF,F
055FA:  BZ    5604
....................          return (FR_INCORRECT_DISK_CHANGE); 
055FC:  MOVLW  09
055FE:  MOVWF  01
05600:  BRA    5632
05602:  BRA    5610
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
05604:  MOVLB  0
05606:  CALL   487E
0560A:  MOVF   01,W
0560C:  MOVLB  7
0560E:  BRA    5632
....................       }  
05610:  BRA    562E
05612:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
05614:  MOVLB  7
05616:  MOVFF  712,FE9
0561A:  MOVFF  713,FEA
0561E:  MOVF   FEF,F
05620:  BNZ   562E
....................          return (f_mountdrv());      // Initialize file system and return resulut  
05622:  MOVLB  0
05624:  CALL   487E
05628:  MOVF   01,W
0562A:  MOVLB  7
0562C:  BRA    5632
....................       } 
....................    return FR_OK;                  // File system is valid  
0562E:  MOVLW  00
05630:  MOVWF  01
05632:  MOVLB  0
05634:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B9A6:  MOVLB  8
0B9A8:  MOVF   xCC,W
0B9AA:  XORLW  00
0B9AC:  MOVLB  0
0B9AE:  BZ    B9E8
0B9B0:  XORLW  04
0B9B2:  BZ    BA04
0B9B4:  XORLW  05
0B9B6:  BZ    BA20
0B9B8:  XORLW  03
0B9BA:  BZ    BA3C
0B9BC:  XORLW  01
0B9BE:  BZ    BA58
0B9C0:  XORLW  06
0B9C2:  BZ    BA74
0B9C4:  XORLW  03
0B9C6:  BZ    BA90
0B9C8:  XORLW  01
0B9CA:  BTFSC  FD8.2
0B9CC:  BRA    BAAC
0B9CE:  XORLW  0E
0B9D0:  BTFSC  FD8.2
0B9D2:  BRA    BAC8
0B9D4:  XORLW  03
0B9D6:  BTFSC  FD8.2
0B9D8:  BRA    BAE4
0B9DA:  XORLW  01
0B9DC:  BTFSC  FD8.2
0B9DE:  BRA    BB00
0B9E0:  XORLW  07
0B9E2:  BTFSC  FD8.2
0B9E4:  BRA    BB1C
0B9E6:  BRA    BB38
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B9E8:  MOVFF  8CE,FEA
0B9EC:  MOVFF  8CD,FE9
0B9F0:  MOVLW  00
0B9F2:  CALL   0106
0B9F6:  TBLRD*-
0B9F8:  TBLRD*+
0B9FA:  MOVF   FF5,W
0B9FC:  MOVWF  FEE
0B9FE:  IORLW  00
0BA00:  BNZ   B9F8
....................          break; 
0BA02:  BRA    BB52
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0BA04:  MOVFF  8CE,FEA
0BA08:  MOVFF  8CD,FE9
0BA0C:  MOVLW  00
0BA0E:  CALL   0124
0BA12:  TBLRD*-
0BA14:  TBLRD*+
0BA16:  MOVF   FF5,W
0BA18:  MOVWF  FEE
0BA1A:  IORLW  00
0BA1C:  BNZ   BA14
....................          break; 
0BA1E:  BRA    BB52
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0BA20:  MOVFF  8CE,FEA
0BA24:  MOVFF  8CD,FE9
0BA28:  MOVLW  00
0BA2A:  CALL   014A
0BA2E:  TBLRD*-
0BA30:  TBLRD*+
0BA32:  MOVF   FF5,W
0BA34:  MOVWF  FEE
0BA36:  IORLW  00
0BA38:  BNZ   BA30
....................          break; 
0BA3A:  BRA    BB52
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0BA3C:  MOVFF  8CE,FEA
0BA40:  MOVFF  8CD,FE9
0BA44:  MOVLW  00
0BA46:  CALL   016E
0BA4A:  TBLRD*-
0BA4C:  TBLRD*+
0BA4E:  MOVF   FF5,W
0BA50:  MOVWF  FEE
0BA52:  IORLW  00
0BA54:  BNZ   BA4C
....................          break; 
0BA56:  BRA    BB52
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0BA58:  MOVFF  8CE,FEA
0BA5C:  MOVFF  8CD,FE9
0BA60:  MOVLW  00
0BA62:  CALL   0192
0BA66:  TBLRD*-
0BA68:  TBLRD*+
0BA6A:  MOVF   FF5,W
0BA6C:  MOVWF  FEE
0BA6E:  IORLW  00
0BA70:  BNZ   BA68
....................          break; 
0BA72:  BRA    BB52
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0BA74:  MOVFF  8CE,FEA
0BA78:  MOVFF  8CD,FE9
0BA7C:  MOVLW  00
0BA7E:  CALL   01B6
0BA82:  TBLRD*-
0BA84:  TBLRD*+
0BA86:  MOVF   FF5,W
0BA88:  MOVWF  FEE
0BA8A:  IORLW  00
0BA8C:  BNZ   BA84
....................          break; 
0BA8E:  BRA    BB52
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0BA90:  MOVFF  8CE,FEA
0BA94:  MOVFF  8CD,FE9
0BA98:  MOVLW  00
0BA9A:  CALL   01D8
0BA9E:  TBLRD*-
0BAA0:  TBLRD*+
0BAA2:  MOVF   FF5,W
0BAA4:  MOVWF  FEE
0BAA6:  IORLW  00
0BAA8:  BNZ   BAA0
....................          break; 
0BAAA:  BRA    BB52
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0BAAC:  MOVFF  8CE,FEA
0BAB0:  MOVFF  8CD,FE9
0BAB4:  MOVLW  00
0BAB6:  CALL   01F8
0BABA:  TBLRD*-
0BABC:  TBLRD*+
0BABE:  MOVF   FF5,W
0BAC0:  MOVWF  FEE
0BAC2:  IORLW  00
0BAC4:  BNZ   BABC
....................          break; 
0BAC6:  BRA    BB52
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0BAC8:  MOVFF  8CE,FEA
0BACC:  MOVFF  8CD,FE9
0BAD0:  MOVLW  00
0BAD2:  CALL   0216
0BAD6:  TBLRD*-
0BAD8:  TBLRD*+
0BADA:  MOVF   FF5,W
0BADC:  MOVWF  FEE
0BADE:  IORLW  00
0BAE0:  BNZ   BAD8
....................          break; 
0BAE2:  BRA    BB52
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0BAE4:  MOVFF  8CE,FEA
0BAE8:  MOVFF  8CD,FE9
0BAEC:  MOVLW  00
0BAEE:  CALL   0242
0BAF2:  TBLRD*-
0BAF4:  TBLRD*+
0BAF6:  MOVF   FF5,W
0BAF8:  MOVWF  FEE
0BAFA:  IORLW  00
0BAFC:  BNZ   BAF4
....................          break; 
0BAFE:  BRA    BB52
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0BB00:  MOVFF  8CE,FEA
0BB04:  MOVFF  8CD,FE9
0BB08:  MOVLW  00
0BB0A:  CALL   0266
0BB0E:  TBLRD*-
0BB10:  TBLRD*+
0BB12:  MOVF   FF5,W
0BB14:  MOVWF  FEE
0BB16:  IORLW  00
0BB18:  BNZ   BB10
....................          break; 
0BB1A:  BRA    BB52
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0BB1C:  MOVFF  8CE,FEA
0BB20:  MOVFF  8CD,FE9
0BB24:  MOVLW  00
0BB26:  CALL   028A
0BB2A:  TBLRD*-
0BB2C:  TBLRD*+
0BB2E:  MOVF   FF5,W
0BB30:  MOVWF  FEE
0BB32:  IORLW  00
0BB34:  BNZ   BB2C
....................          break; 
0BB36:  BRA    BB52
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0BB38:  MOVFF  8CE,FEA
0BB3C:  MOVFF  8CD,FE9
0BB40:  MOVLW  00
0BB42:  CALL   02AC
0BB46:  TBLRD*-
0BB48:  TBLRD*+
0BB4A:  MOVF   FF5,W
0BB4C:  MOVWF  FEE
0BB4E:  IORLW  00
0BB50:  BNZ   BB48
....................       } 
0BB52:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
0487E:  MOVLB  7
04880:  MOVF   x12,W
04882:  IORWF  x13,W
04884:  BNZ   488C
....................       return (FR_NOT_ENABLED); 
04886:  MOVLW  0B
04888:  MOVWF  01
0488A:  BRA    4E18
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
0488C:  MOVFF  713,FEA
04890:  MOVFF  712,FE9
04894:  CLRF   00
04896:  MOVLW  02
04898:  MOVWF  02
0489A:  MOVLW  24
0489C:  MOVWF  01
0489E:  MOVLB  0
048A0:  CALL   354E
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
048A4:  CALL   369E
048A8:  MOVFF  01,4ED
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
048AC:  MOVLB  4
048AE:  BTFSS  xED.0
048B0:  BRA    48BE
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
048B2:  MOVLB  0
048B4:  CALL   369E
048B8:  MOVFF  01,4ED
048BC:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
048BE:  BTFSS  xED.0
048C0:  BRA    48CC
048C2:  MOVLW  01
048C4:  MOVWF  01
048C6:  MOVLB  7
048C8:  BRA    4E18
048CA:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
048CC:  MOVLB  9
048CE:  CLRF   xDA
048D0:  CLRF   xD9
048D2:  CLRF   xD8
048D4:  CLRF   xD7
048D6:  MOVFF  9DA,9E6
048DA:  MOVFF  9D9,9E5
048DE:  MOVFF  9D8,9E4
048E2:  MOVFF  9D7,9E3
048E6:  MOVLB  0
048E8:  RCALL  46B8
048EA:  MOVFF  01,9D6
....................    if (!fat)  
048EE:  MOVLB  9
048F0:  MOVF   xD6,F
048F2:  BNZ   4962
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
048F4:  MOVLW  E6
048F6:  MOVLB  7
048F8:  ADDWF  x12,W
048FA:  MOVWF  FE9
048FC:  MOVLW  01
048FE:  ADDWFC x13,W
04900:  MOVWF  FEA
04902:  MOVF   FEF,F
04904:  BZ    4942
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
04906:  MOVLW  EA
04908:  ADDWF  x12,W
0490A:  MOVWF  01
0490C:  MOVLW  01
0490E:  ADDWFC x13,W
04910:  MOVFF  01,FE9
04914:  MOVWF  FEA
04916:  MOVFF  FEF,9D7
0491A:  MOVFF  FEC,9D8
0491E:  MOVFF  FEC,9D9
04922:  MOVFF  FEC,9DA
....................          fat = check_fs(sect);            // Check the partition  
04926:  MOVFF  9DA,9E6
0492A:  MOVFF  9D9,9E5
0492E:  MOVFF  9D8,9E4
04932:  MOVFF  9D7,9E3
04936:  MOVLB  0
04938:  RCALL  46B8
0493A:  MOVFF  01,9D6
....................          } 
0493E:  BRA    4960
04940:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
04942:  MOVLW  08
04944:  MOVWF  FF6
04946:  MOVLW  0C
04948:  MOVWF  FF7
0494A:  MOVLW  00
0494C:  MOVWF  FF8
0494E:  CLRF   1B
04950:  BTFSC  FF2.7
04952:  BSF    1B.7
04954:  BCF    FF2.7
04956:  MOVLB  0
04958:  CALL   0E6E
0495C:  BTFSC  1B.7
0495E:  BSF    FF2.7
04960:  MOVLB  9
....................       } 
....................    if (!fat)  
04962:  MOVF   xD6,F
04964:  BNZ   4970
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
04966:  MOVLW  0C
04968:  MOVWF  01
0496A:  MOVLB  7
0496C:  BRA    4E18
0496E:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
04970:  MOVLB  7
04972:  MOVFF  712,FE9
04976:  MOVFF  713,FEA
0497A:  MOVFF  9D6,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
0497E:  MOVLB  9
04980:  MOVF   xD6,W
04982:  SUBLW  03
04984:  BNZ   49EA
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
04986:  MOVLW  08
04988:  MOVLB  7
0498A:  ADDWF  x12,W
0498C:  MOVWF  01
0498E:  MOVLW  00
04990:  ADDWFC x13,W
04992:  MOVWF  03
04994:  MOVFF  01,9E3
04998:  MOVLB  9
0499A:  MOVWF  xE4
0499C:  MOVLW  48
0499E:  MOVLB  7
049A0:  ADDWF  x12,W
049A2:  MOVWF  01
049A4:  MOVLW  00
049A6:  ADDWFC x13,W
049A8:  MOVFF  01,FE9
049AC:  MOVWF  FEA
049AE:  MOVFF  FEF,00
049B2:  MOVFF  FEC,01
049B6:  MOVFF  FEC,02
049BA:  MOVFF  FEC,03
049BE:  MOVFF  03,9E8
049C2:  MOVFF  02,9E7
049C6:  MOVFF  01,9E6
049CA:  MOVFF  00,9E5
049CE:  MOVFF  9E4,FEA
049D2:  MOVFF  9E3,FE9
049D6:  MOVFF  00,FEF
049DA:  MOVFF  01,FEC
049DE:  MOVFF  02,FEC
049E2:  MOVFF  03,FEC
049E6:  BRA    4A42
049E8:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
049EA:  MOVLW  08
049EC:  MOVLB  7
049EE:  ADDWF  x12,W
049F0:  MOVWF  01
049F2:  MOVLW  00
049F4:  ADDWFC x13,W
049F6:  MOVWF  03
049F8:  MOVFF  01,9E3
049FC:  MOVLB  9
049FE:  MOVWF  xE4
04A00:  MOVLW  3A
04A02:  MOVLB  7
04A04:  ADDWF  x12,W
04A06:  MOVWF  01
04A08:  MOVLW  00
04A0A:  ADDWFC x13,W
04A0C:  MOVFF  01,FE9
04A10:  MOVWF  FEA
04A12:  MOVFF  FEC,03
04A16:  MOVF   FED,F
04A18:  MOVFF  FEF,9E5
04A1C:  MOVLB  9
04A1E:  MOVFF  03,9E6
04A22:  MOVFF  9E4,FEA
04A26:  MOVFF  9E3,FE9
04A2A:  MOVF   FEE,F
04A2C:  MOVF   FEE,F
04A2E:  CLRF   FEC
04A30:  MOVF   FED,F
04A32:  CLRF   FEF
04A34:  MOVF   FED,F
04A36:  MOVFF  03,FEF
04A3A:  MOVF   FED,F
04A3C:  MOVFF  9E5,FEF
04A40:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
04A42:  MOVLW  02
04A44:  ADDWF  x12,W
04A46:  MOVWF  01
04A48:  MOVLW  00
04A4A:  ADDWFC x13,W
04A4C:  MOVWF  03
04A4E:  MOVLW  31
04A50:  MOVLB  7
04A52:  ADDWF  x12,W
04A54:  MOVWF  FE9
04A56:  MOVLW  00
04A58:  ADDWFC x13,W
04A5A:  MOVWF  FEA
04A5C:  MOVFF  FEF,9E5
04A60:  MOVLB  9
04A62:  MOVFF  03,FEA
04A66:  MOVFF  01,FE9
04A6A:  MOVFF  9E5,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
04A6E:  MOVLW  03
04A70:  MOVLB  7
04A72:  ADDWF  x12,W
04A74:  MOVWF  01
04A76:  MOVLW  00
04A78:  ADDWFC x13,W
04A7A:  MOVWF  03
04A7C:  MOVLW  34
04A7E:  MOVLB  7
04A80:  ADDWF  x12,W
04A82:  MOVWF  FE9
04A84:  MOVLW  00
04A86:  ADDWFC x13,W
04A88:  MOVWF  FEA
04A8A:  MOVFF  FEF,9E5
04A8E:  MOVLB  9
04A90:  MOVFF  03,FEA
04A94:  MOVFF  01,FE9
04A98:  MOVFF  9E5,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
04A9C:  MOVLW  10
04A9E:  MOVLB  7
04AA0:  ADDWF  x12,W
04AA2:  MOVWF  01
04AA4:  MOVLW  00
04AA6:  ADDWFC x13,W
04AA8:  MOVWF  03
04AAA:  MOVFF  01,9E3
04AAE:  MOVLB  9
04AB0:  MOVWF  xE4
04AB2:  MOVLW  32
04AB4:  MOVLB  7
04AB6:  ADDWF  x12,W
04AB8:  MOVWF  01
04ABA:  MOVLW  00
04ABC:  ADDWFC x13,W
04ABE:  MOVFF  01,FE9
04AC2:  MOVWF  FEA
04AC4:  MOVFF  FEC,03
04AC8:  MOVF   FED,F
04ACA:  MOVF   FEF,W
04ACC:  MOVLB  9
04ACE:  ADDWF  xD7,W
04AD0:  MOVWF  00
04AD2:  MOVF   03,W
04AD4:  ADDWFC xD8,W
04AD6:  MOVWF  01
04AD8:  MOVLW  00
04ADA:  ADDWFC xD9,W
04ADC:  MOVWF  02
04ADE:  MOVLW  00
04AE0:  ADDWFC xDA,W
04AE2:  MOVFF  9E4,FEA
04AE6:  MOVFF  9E3,FE9
04AEA:  MOVFF  00,FEF
04AEE:  MOVFF  01,FEC
04AF2:  MOVFF  02,FEC
04AF6:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04AF8:  MOVLW  04
04AFA:  MOVLB  7
04AFC:  ADDWF  x12,W
04AFE:  MOVWF  01
04B00:  MOVLW  00
04B02:  ADDWFC x13,W
04B04:  MOVWF  03
04B06:  MOVFF  01,9E3
04B0A:  MOVLB  9
04B0C:  MOVWF  xE4
04B0E:  MOVLW  35
04B10:  MOVLB  7
04B12:  ADDWF  x12,W
04B14:  MOVWF  01
04B16:  MOVLW  00
04B18:  ADDWFC x13,W
04B1A:  MOVFF  01,FE9
04B1E:  MOVWF  FEA
04B20:  MOVFF  FEC,03
04B24:  MOVF   FED,F
04B26:  MOVFF  FEF,9E5
04B2A:  MOVLB  9
04B2C:  MOVFF  9E4,FEA
04B30:  MOVFF  9E3,FE9
04B34:  MOVFF  03,FEC
04B38:  MOVF   FED,F
04B3A:  MOVFF  9E5,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04B3E:  MOVLW  08
04B40:  MOVLB  7
04B42:  ADDWF  x12,W
04B44:  MOVWF  FE9
04B46:  MOVLW  00
04B48:  ADDWFC x13,W
04B4A:  MOVWF  FEA
04B4C:  MOVFF  FEF,9F6
04B50:  MOVFF  FEC,9F7
04B54:  MOVFF  FEC,9F8
04B58:  MOVFF  FEC,9F9
04B5C:  MOVLW  03
04B5E:  ADDWF  x12,W
04B60:  MOVWF  FE9
04B62:  MOVLW  00
04B64:  ADDWFC x13,W
04B66:  MOVWF  FEA
04B68:  MOVFF  FEF,9FA
04B6C:  MOVLB  9
04B6E:  MOVFF  FEA,9E9
04B72:  MOVFF  FE9,9E8
04B76:  CLRF   xFD
04B78:  CLRF   xFC
04B7A:  CLRF   xFB
04B7C:  MOVLB  0
04B7E:  RCALL  4818
04B80:  MOVFF  9E9,FEA
04B84:  MOVFF  9E8,FE9
04B88:  MOVFF  03,9E6
04B8C:  MOVFF  02,9E5
04B90:  MOVFF  01,9E4
04B94:  MOVFF  00,9E3
04B98:  MOVLW  10
04B9A:  MOVLB  7
04B9C:  ADDWF  x12,W
04B9E:  MOVWF  FE9
04BA0:  MOVLW  00
04BA2:  ADDWFC x13,W
04BA4:  MOVWF  FEA
04BA6:  MOVFF  FEF,00
04BAA:  MOVFF  FEC,01
04BAE:  MOVFF  FEC,02
04BB2:  MOVFF  FEC,03
04BB6:  MOVF   00,W
04BB8:  MOVLB  9
04BBA:  ADDWF  xE3,W
04BBC:  MOVWF  xDB
04BBE:  MOVF   01,W
04BC0:  ADDWFC xE4,W
04BC2:  MOVWF  xDC
04BC4:  MOVF   02,W
04BC6:  ADDWFC xE5,W
04BC8:  MOVWF  xDD
04BCA:  MOVF   03,W
04BCC:  ADDWFC xE6,W
04BCE:  MOVWF  xDE
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04BD0:  MOVF   xD6,W
04BD2:  SUBLW  03
04BD4:  BNZ   4C46
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04BD6:  MOVLW  14
04BD8:  MOVLB  7
04BDA:  ADDWF  x12,W
04BDC:  MOVWF  01
04BDE:  MOVLW  00
04BE0:  ADDWFC x13,W
04BE2:  MOVWF  03
04BE4:  MOVFF  01,9E3
04BE8:  MOVLB  9
04BEA:  MOVWF  xE4
04BEC:  MOVLW  50
04BEE:  MOVLB  7
04BF0:  ADDWF  x12,W
04BF2:  MOVWF  01
04BF4:  MOVLW  00
04BF6:  ADDWFC x13,W
04BF8:  MOVFF  01,FE9
04BFC:  MOVWF  FEA
04BFE:  MOVFF  FEF,00
04C02:  MOVFF  FEC,01
04C06:  MOVFF  FEC,02
04C0A:  MOVFF  FEC,03
04C0E:  MOVFF  9E4,FEA
04C12:  MOVFF  9E3,FE9
04C16:  MOVFF  00,FEF
04C1A:  MOVFF  01,FEC
04C1E:  MOVFF  02,FEC
04C22:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04C26:  MOVLW  18
04C28:  ADDWF  x12,W
04C2A:  MOVWF  FE9
04C2C:  MOVLW  00
04C2E:  ADDWFC x13,W
04C30:  MOVWF  FEA
04C32:  MOVFF  9DB,FEF
04C36:  MOVFF  9DC,FEC
04C3A:  MOVFF  9DD,FEC
04C3E:  MOVFF  9DE,FEC
....................       }  
04C42:  BRA    4CD2
04C44:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04C46:  MOVLW  14
04C48:  MOVLB  7
04C4A:  ADDWF  x12,W
04C4C:  MOVWF  FE9
04C4E:  MOVLW  00
04C50:  ADDWFC x13,W
04C52:  MOVWF  FEA
04C54:  MOVFF  9DB,FEF
04C58:  MOVFF  9DC,FEC
04C5C:  MOVFF  9DD,FEC
04C60:  MOVFF  9DE,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04C64:  MOVLW  18
04C66:  ADDWF  x12,W
04C68:  MOVWF  01
04C6A:  MOVLW  00
04C6C:  ADDWFC x13,W
04C6E:  MOVFF  01,9E3
04C72:  MOVLB  9
04C74:  MOVWF  xE4
04C76:  MOVLW  04
04C78:  MOVLB  7
04C7A:  ADDWF  x12,W
04C7C:  MOVWF  FE9
04C7E:  MOVLW  00
04C80:  ADDWFC x13,W
04C82:  MOVWF  FEA
04C84:  MOVFF  FEC,9E6
04C88:  MOVF   FED,F
04C8A:  MOVFF  FEF,9E5
04C8E:  MOVLB  9
04C90:  RRCF   xE6,F
04C92:  RRCF   xE5,F
04C94:  RRCF   xE6,F
04C96:  RRCF   xE5,F
04C98:  RRCF   xE6,F
04C9A:  RRCF   xE5,F
04C9C:  RRCF   xE6,F
04C9E:  RRCF   xE5,F
04CA0:  MOVLW  0F
04CA2:  ANDWF  xE6,F
04CA4:  MOVF   xE5,W
04CA6:  ADDWF  xDB,W
04CA8:  MOVWF  00
04CAA:  MOVF   xE6,W
04CAC:  ADDWFC xDC,W
04CAE:  MOVWF  01
04CB0:  MOVLW  00
04CB2:  ADDWFC xDD,W
04CB4:  MOVWF  02
04CB6:  MOVLW  00
04CB8:  ADDWFC xDE,W
04CBA:  MOVFF  9E4,FEA
04CBE:  MOVFF  9E3,FE9
04CC2:  MOVFF  00,FEF
04CC6:  MOVFF  01,FEC
04CCA:  MOVFF  02,FEC
04CCE:  MOVWF  FEC
04CD0:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04CD2:  MOVLW  44
04CD4:  ADDWF  x12,W
04CD6:  MOVWF  01
04CD8:  MOVLW  00
04CDA:  ADDWFC x13,W
04CDC:  MOVFF  01,FE9
04CE0:  MOVWF  FEA
04CE2:  MOVFF  FEF,9DF
04CE6:  MOVFF  FEC,9E0
04CEA:  MOVFF  FEC,9E1
04CEE:  MOVFF  FEC,9E2
....................    if (!maxsect)  
04CF2:  MOVLB  9
04CF4:  MOVF   xDF,F
04CF6:  BNZ   4D26
04CF8:  MOVF   xE0,F
04CFA:  BNZ   4D26
04CFC:  MOVF   xE1,F
04CFE:  BNZ   4D26
04D00:  MOVF   xE2,F
04D02:  BNZ   4D26
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04D04:  MOVLW  37
04D06:  MOVLB  7
04D08:  ADDWF  x12,W
04D0A:  MOVWF  01
04D0C:  MOVLW  00
04D0E:  ADDWFC x13,W
04D10:  MOVFF  01,FE9
04D14:  MOVWF  FEA
04D16:  MOVLB  9
04D18:  CLRF   xE2
04D1A:  CLRF   xE1
04D1C:  MOVFF  FEC,9E0
04D20:  MOVF   FED,F
04D22:  MOVFF  FEF,9DF
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04D26:  MOVLW  0C
04D28:  MOVLB  7
04D2A:  ADDWF  x12,W
04D2C:  MOVWF  01
04D2E:  MOVLW  00
04D30:  ADDWFC x13,W
04D32:  MOVWF  03
04D34:  MOVFF  01,9E3
04D38:  MOVLB  9
04D3A:  MOVWF  xE4
04D3C:  MOVLW  18
04D3E:  MOVLB  7
04D40:  ADDWF  x12,W
04D42:  MOVWF  FE9
04D44:  MOVLW  00
04D46:  ADDWFC x13,W
04D48:  MOVWF  FEA
04D4A:  MOVFF  FEF,00
04D4E:  MOVFF  FEC,01
04D52:  MOVFF  FEC,02
04D56:  MOVFF  FEC,03
04D5A:  MOVF   00,W
04D5C:  MOVLB  9
04D5E:  SUBWF  xDF,W
04D60:  MOVWF  xE5
04D62:  MOVF   01,W
04D64:  SUBWFB xE0,W
04D66:  MOVWF  xE6
04D68:  MOVF   02,W
04D6A:  SUBWFB xE1,W
04D6C:  MOVWF  xE7
04D6E:  MOVF   03,W
04D70:  SUBWFB xE2,W
04D72:  MOVWF  xE8
04D74:  MOVF   xD7,W
04D76:  ADDWF  xE5,F
04D78:  MOVF   xD8,W
04D7A:  ADDWFC xE6,F
04D7C:  MOVF   xD9,W
04D7E:  ADDWFC xE7,F
04D80:  MOVF   xDA,W
04D82:  ADDWFC xE8,F
04D84:  MOVLW  02
04D86:  MOVLB  7
04D88:  ADDWF  x12,W
04D8A:  MOVWF  FE9
04D8C:  MOVLW  00
04D8E:  ADDWFC x13,W
04D90:  MOVWF  FEA
04D92:  MOVFF  FEF,A50
04D96:  MOVLB  9
04D98:  MOVFF  FEA,9EB
04D9C:  MOVFF  FE9,9EA
04DA0:  BCF    FD8.1
04DA2:  CLRF   1B
04DA4:  BTFSC  FF2.7
04DA6:  BSF    1B.7
04DA8:  BCF    FF2.7
04DAA:  MOVFF  9E8,A4F
04DAE:  MOVFF  9E7,A4E
04DB2:  MOVFF  9E6,A4D
04DB6:  MOVFF  9E5,A4C
04DBA:  MOVLB  A
04DBC:  CLRF   x53
04DBE:  CLRF   x52
04DC0:  CLRF   x51
04DC2:  MOVLB  0
04DC4:  CALL   1076
04DC8:  BTFSC  1B.7
04DCA:  BSF    FF2.7
04DCC:  MOVFF  9EB,FEA
04DD0:  MOVFF  9EA,FE9
04DD4:  MOVFF  03,9E8
04DD8:  MOVFF  02,9E7
04DDC:  MOVFF  01,9E6
04DE0:  MOVFF  00,9E5
04DE4:  MOVLW  02
04DE6:  MOVLB  9
04DE8:  ADDWF  00,W
04DEA:  MOVWF  00
04DEC:  MOVLW  00
04DEE:  ADDWFC 01,W
04DF0:  MOVWF  01
04DF2:  MOVLW  00
04DF4:  ADDWFC 02,W
04DF6:  MOVWF  02
04DF8:  MOVLW  00
04DFA:  ADDWFC 03,W
04DFC:  MOVFF  9E4,FEA
04E00:  MOVFF  9E3,FE9
04E04:  MOVFF  00,FEF
04E08:  MOVFF  01,FEC
04E0C:  MOVFF  02,FEC
04E10:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04E12:  MOVLW  00
04E14:  MOVWF  01
04E16:  MOVLB  7
04E18:  MOVLB  0
04E1A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
07180:  CALL   55D4
07184:  MOVFF  01,9C3
....................    if (result != FR_OK)  
07188:  MOVLB  9
0718A:  MOVF   xC3,F
0718C:  BZ    7194
....................       return (result); 
0718E:  MOVFF  9C3,01
07192:  BRA    75C4
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
07194:  MOVF   xB4,W
07196:  ANDLW  0A
07198:  BZ    71B0
0719A:  MOVLB  0
0719C:  CALL   55C6
071A0:  BTFSC  01.2
071A2:  BRA    71A8
071A4:  MOVLB  9
071A6:  BRA    71B0
....................          return (FR_WRITE_PROTECTED); 
071A8:  MOVLW  0A
071AA:  MOVWF  01
071AC:  MOVLB  9
071AE:  BRA    75C4
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
071B0:  MOVLW  09
071B2:  MOVWF  xD7
071B4:  MOVLW  B5
071B6:  MOVWF  xD6
071B8:  MOVLW  09
071BA:  MOVWF  xD9
071BC:  MOVLW  C6
071BE:  MOVWF  xD8
071C0:  MOVFF  9B3,9DB
071C4:  MOVFF  9B2,9DA
071C8:  MOVLW  09
071CA:  MOVWF  xDD
071CC:  MOVLW  C4
071CE:  MOVWF  xDC
071D0:  MOVLB  0
071D2:  CALL   620A
071D6:  MOVFF  01,9C3
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
071DA:  MOVLB  9
071DC:  MOVF   xB4,W
071DE:  ANDLW  18
071E0:  BTFSC  FD8.2
071E2:  BRA    7406
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
071E4:  MOVF   xC3,F
071E6:  BZ    726E
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
071E8:  BSF    xB4.3
....................          if (result != FR_NO_FILE) 
071EA:  MOVF   xC3,W
071EC:  SUBLW  02
071EE:  BZ    71F6
....................             return (result); 
071F0:  MOVFF  9C3,01
071F4:  BRA    75C4
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
071F6:  MOVLW  09
071F8:  MOVWF  xD7
071FA:  MOVLW  B5
071FC:  MOVWF  xD6
071FE:  MOVLB  0
07200:  BRA    6C24
07202:  MOVFF  02,9C5
07206:  MOVFF  01,9C4
....................          if (dir_ptr == NULL) 
0720A:  MOVLB  9
0720C:  MOVF   xC4,F
0720E:  BNZ   721A
07210:  MOVF   xC5,F
07212:  BNZ   721A
....................             return (FR_DENIED); 
07214:  MOVLW  05
07216:  MOVWF  01
07218:  BRA    75C4
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
0721A:  MOVFF  9C5,FEA
0721E:  MOVFF  9C4,FE9
07222:  MOVLW  09
07224:  MOVWF  FE2
07226:  MOVLW  C6
07228:  MOVWF  FE1
0722A:  MOVLW  0B
0722C:  MOVWF  01
0722E:  MOVFF  FE6,FEE
07232:  DECFSZ 01,F
07234:  BRA    722E
....................          *(dir_ptr+12) = fn[11]; 
07236:  MOVLW  0C
07238:  ADDWF  xC4,W
0723A:  MOVWF  01
0723C:  MOVLW  00
0723E:  ADDWFC xC5,W
07240:  MOVFF  01,FE9
07244:  MOVWF  FEA
07246:  MOVFF  9D1,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
0724A:  MOVLW  0D
0724C:  ADDWF  xC4,W
0724E:  MOVWF  xD6
07250:  MOVLW  00
07252:  ADDWFC xC5,W
07254:  MOVWF  xD7
07256:  MOVWF  FEA
07258:  MOVFF  9D6,FE9
0725C:  CLRF   00
0725E:  CLRF   02
07260:  MOVLW  13
07262:  MOVWF  01
07264:  MOVLB  0
07266:  CALL   354E
....................       }  
0726A:  BRA    7380
0726C:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
0726E:  MOVF   xC4,F
07270:  BNZ   7276
07272:  MOVF   xC5,F
07274:  BZ    728E
07276:  MOVLW  0B
07278:  ADDWF  xC4,W
0727A:  MOVWF  01
0727C:  MOVLW  00
0727E:  ADDWFC xC5,W
07280:  MOVWF  03
07282:  MOVFF  01,FE9
07286:  MOVWF  FEA
07288:  MOVF   FEF,W
0728A:  ANDLW  11
0728C:  BZ    7294
....................             return (FR_DENIED); 
0728E:  MOVLW  05
07290:  MOVWF  01
07292:  BRA    75C4
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
07294:  BTFSS  xB4.3
07296:  BRA    737E
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
07298:  MOVLW  20
0729A:  MOVLB  7
0729C:  ADDWF  x12,W
0729E:  MOVWF  FE9
072A0:  MOVLW  00
072A2:  ADDWFC x13,W
072A4:  MOVWF  FEA
072A6:  MOVFF  FEF,9D2
072AA:  MOVFF  FEC,9D3
072AE:  MOVFF  FEC,9D4
072B2:  MOVFF  FEC,9D5
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
072B6:  MOVLW  14
072B8:  MOVLB  9
072BA:  ADDWF  xC4,W
072BC:  MOVWF  01
072BE:  MOVLW  00
072C0:  ADDWFC xC5,W
072C2:  MOVWF  03
072C4:  MOVFF  01,FE9
072C8:  MOVWF  FEA
072CA:  MOVFF  FEC,9DE
072CE:  MOVF   FED,F
072D0:  MOVFF  FEF,9D6
072D4:  CLRF   xD8
072D6:  MOVFF  9D6,9DD
072DA:  CLRF   xD6
072DC:  CLRF   xD7
072DE:  MOVLW  1A
072E0:  ADDWF  xC4,W
072E2:  MOVWF  01
072E4:  MOVLW  00
072E6:  ADDWFC xC5,W
072E8:  MOVFF  01,FE9
072EC:  MOVWF  FEA
072EE:  MOVFF  FEC,03
072F2:  MOVF   FED,F
072F4:  MOVF   FEF,W
072F6:  IORWF  xD6,F
072F8:  MOVF   03,W
072FA:  IORWF  xD7,F
072FC:  MOVFF  9D7,9DC
07300:  MOVFF  9D6,9DB
07304:  MOVLB  0
07306:  RCALL  6F6E
07308:  MOVF   01,F
0730A:  BZ    7324
0730C:  MOVFF  9D5,A17
07310:  MOVFF  9D4,A16
07314:  MOVFF  9D3,A15
07318:  MOVFF  9D2,A14
0731C:  CALL   5AAA
07320:  MOVF   01,F
07322:  BNZ   732E
....................                return (FR_RW_ERROR); 
07324:  MOVLW  07
07326:  MOVWF  01
07328:  MOVLB  9
0732A:  BRA    75C4
0732C:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
0732E:  MOVLW  14
07330:  MOVLB  9
07332:  ADDWF  xC4,W
07334:  MOVWF  01
07336:  MOVLW  00
07338:  ADDWFC xC5,W
0733A:  MOVFF  01,FE9
0733E:  MOVWF  FEA
07340:  CLRF   FEC
07342:  MOVF   FED,F
07344:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
07346:  MOVLW  1A
07348:  ADDWF  xC4,W
0734A:  MOVWF  01
0734C:  MOVLW  00
0734E:  ADDWFC xC5,W
07350:  MOVFF  01,FE9
07354:  MOVWF  FEA
07356:  CLRF   FEC
07358:  MOVF   FED,F
0735A:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
0735C:  MOVLW  1C
0735E:  ADDWF  xC4,W
07360:  MOVWF  01
07362:  MOVLW  00
07364:  ADDWFC xC5,W
07366:  MOVFF  01,FE9
0736A:  MOVWF  FEA
0736C:  MOVF   FEE,F
0736E:  MOVF   FEE,F
07370:  CLRF   FEC
07372:  MOVF   FED,F
07374:  CLRF   FEF
07376:  MOVF   FED,F
07378:  CLRF   FEF
0737A:  MOVF   FED,F
0737C:  CLRF   FEF
0737E:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
07380:  MOVLB  9
07382:  BTFSS  xB4.3
07384:  BRA    7404
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
07386:  MOVLW  0B
07388:  ADDWF  xC4,W
0738A:  MOVWF  01
0738C:  MOVLW  00
0738E:  ADDWFC xC5,W
07390:  MOVFF  01,FE9
07394:  MOVWF  FEA
07396:  MOVLW  20
07398:  MOVWF  FEF
....................          dw = get_fattime(); 
0739A:  MOVLB  0
0739C:  RCALL  7010
0739E:  MOVFF  03,9D5
073A2:  MOVFF  02,9D4
073A6:  MOVFF  01,9D3
073AA:  MOVFF  00,9D2
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
073AE:  MOVLW  0E
073B0:  MOVLB  9
073B2:  ADDWF  xC4,W
073B4:  MOVWF  01
073B6:  MOVLW  00
073B8:  ADDWFC xC5,W
073BA:  MOVFF  01,FE9
073BE:  MOVWF  FEA
073C0:  MOVFF  9D2,FEF
073C4:  MOVFF  9D3,FEC
073C8:  MOVFF  9D4,FEC
073CC:  MOVFF  9D5,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
073D0:  MOVLW  16
073D2:  ADDWF  xC4,W
073D4:  MOVWF  01
073D6:  MOVLW  00
073D8:  ADDWFC xC5,W
073DA:  MOVFF  01,FE9
073DE:  MOVWF  FEA
073E0:  MOVFF  9D2,FEF
073E4:  MOVFF  9D3,FEC
073E8:  MOVFF  9D4,FEC
073EC:  MOVFF  9D5,FEC
....................          fs->winflag = 1; 
073F0:  MOVLW  06
073F2:  MOVLB  7
073F4:  ADDWF  x12,W
073F6:  MOVWF  FE9
073F8:  MOVLW  00
073FA:  ADDWFC x13,W
073FC:  MOVWF  FEA
073FE:  MOVLW  01
07400:  MOVWF  FEF
07402:  MOVLB  9
....................       } 
....................    } 
07404:  BRA    7454
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
07406:  MOVF   xC3,F
07408:  BZ    7410
....................          return (result);      // Trace failed  
0740A:  MOVFF  9C3,01
0740E:  BRA    75C4
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
07410:  MOVF   xC4,F
07412:  BNZ   7418
07414:  MOVF   xC5,F
07416:  BZ    742E
07418:  MOVLW  0B
0741A:  ADDWF  xC4,W
0741C:  MOVWF  01
0741E:  MOVLW  00
07420:  ADDWFC xC5,W
07422:  MOVWF  03
07424:  MOVFF  01,FE9
07428:  MOVWF  FEA
0742A:  BTFSS  FEF.4
0742C:  BRA    7434
....................          return (FR_NO_FILE); 
0742E:  MOVLW  02
07430:  MOVWF  01
07432:  BRA    75C4
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
07434:  BTFSS  xB4.1
07436:  BRA    7454
07438:  MOVLW  0B
0743A:  ADDWF  xC4,W
0743C:  MOVWF  01
0743E:  MOVLW  00
07440:  ADDWFC xC5,W
07442:  MOVWF  03
07444:  MOVFF  01,FE9
07448:  MOVWF  FEA
0744A:  BTFSS  FEF.0
0744C:  BRA    7454
....................          return (FR_DENIED); 
0744E:  MOVLW  05
07450:  MOVWF  01
07452:  BRA    75C4
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
07454:  MOVLW  1A
07456:  ADDWF  xB0,W
07458:  MOVWF  FE9
0745A:  MOVLW  00
0745C:  ADDWFC xB1,W
0745E:  MOVWF  FEA
07460:  MOVF   xB4,W
07462:  ANDLW  03
07464:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
07466:  MOVLW  14
07468:  ADDWF  xB0,W
0746A:  MOVWF  01
0746C:  MOVLW  00
0746E:  ADDWFC xB1,W
07470:  MOVWF  03
07472:  MOVFF  01,9D6
07476:  MOVWF  xD7
07478:  MOVLW  20
0747A:  MOVLB  7
0747C:  ADDWF  x12,W
0747E:  MOVWF  FE9
07480:  MOVLW  00
07482:  ADDWFC x13,W
07484:  MOVWF  FEA
07486:  MOVFF  FEF,00
0748A:  MOVFF  FEC,01
0748E:  MOVFF  FEC,02
07492:  MOVFF  FEC,03
07496:  MOVFF  9D7,FEA
0749A:  MOVFF  9D6,FE9
0749E:  MOVFF  00,FEF
074A2:  MOVFF  01,FEC
074A6:  MOVFF  02,FEC
074AA:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
074AE:  MOVLW  18
074B0:  MOVLB  9
074B2:  ADDWF  xB0,W
074B4:  MOVWF  FE9
074B6:  MOVLW  00
074B8:  ADDWFC xB1,W
074BA:  MOVWF  FEA
074BC:  MOVFF  9C5,FEC
074C0:  MOVF   FED,F
074C2:  MOVFF  9C4,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
074C6:  MOVLW  08
074C8:  ADDWF  xB0,W
074CA:  MOVWF  01
074CC:  MOVLW  00
074CE:  ADDWFC xB1,W
074D0:  MOVWF  03
074D2:  MOVFF  01,9D6
074D6:  MOVWF  xD7
074D8:  MOVLW  14
074DA:  ADDWF  xC4,W
074DC:  MOVWF  01
074DE:  MOVLW  00
074E0:  ADDWFC xC5,W
074E2:  MOVWF  03
074E4:  MOVFF  01,FE9
074E8:  MOVWF  FEA
074EA:  MOVFF  FEC,9DB
074EE:  MOVF   FED,F
074F0:  MOVFF  FEF,9D8
074F4:  CLRF   xDA
074F6:  MOVFF  9D8,9DA
074FA:  CLRF   xD8
074FC:  CLRF   xD9
074FE:  MOVLW  1A
07500:  ADDWF  xC4,W
07502:  MOVWF  01
07504:  MOVLW  00
07506:  ADDWFC xC5,W
07508:  MOVFF  01,FE9
0750C:  MOVWF  FEA
0750E:  MOVFF  FEC,03
07512:  MOVF   FED,F
07514:  MOVF   FEF,W
07516:  IORWF  xD8,W
07518:  MOVWF  00
0751A:  MOVF   03,W
0751C:  IORWF  xD9,W
0751E:  MOVFF  9DA,02
07522:  MOVFF  9DB,03
07526:  MOVFF  9D7,FEA
0752A:  MOVFF  9D6,FE9
0752E:  MOVFF  00,FEF
07532:  MOVWF  FEC
07534:  MOVFF  9DA,FEC
07538:  MOVFF  9DB,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
0753C:  MOVLW  04
0753E:  ADDWF  xB0,W
07540:  MOVWF  01
07542:  MOVLW  00
07544:  ADDWFC xB1,W
07546:  MOVWF  03
07548:  MOVFF  01,9D6
0754C:  MOVWF  xD7
0754E:  MOVLW  1C
07550:  ADDWF  xC4,W
07552:  MOVWF  01
07554:  MOVLW  00
07556:  ADDWFC xC5,W
07558:  MOVFF  01,FE9
0755C:  MOVWF  FEA
0755E:  MOVFF  FEF,00
07562:  MOVFF  FEC,01
07566:  MOVFF  FEC,02
0756A:  MOVFF  FEC,03
0756E:  MOVFF  9D7,FEA
07572:  MOVFF  9D6,FE9
07576:  MOVFF  00,FEF
0757A:  MOVFF  01,FEC
0757E:  MOVFF  02,FEC
07582:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
07586:  MOVFF  9B0,FE9
0758A:  MOVFF  9B1,FEA
0758E:  MOVF   FEE,F
07590:  MOVF   FEE,F
07592:  CLRF   FEC
07594:  MOVF   FED,F
07596:  CLRF   FEF
07598:  MOVF   FED,F
0759A:  CLRF   FEF
0759C:  MOVF   FED,F
0759E:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
075A0:  MOVLW  1B
075A2:  ADDWF  xB0,W
075A4:  MOVWF  FE9
075A6:  MOVLW  00
075A8:  ADDWFC xB1,W
075AA:  MOVWF  FEA
075AC:  MOVLW  01
075AE:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
075B0:  MOVLB  7
075B2:  ADDWF  x12,W
075B4:  MOVWF  FE9
075B6:  MOVLW  00
075B8:  ADDWFC x13,W
075BA:  MOVWF  FEA
075BC:  INCF   FEF,F
....................    return (FR_OK); 
075BE:  MOVLW  00
075C0:  MOVWF  01
075C2:  MOVLB  9
075C4:  MOVLB  0
075C6:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B498:  MOVFF  8CF,8E4
0B49C:  MOVFF  8CE,8E3
....................       *br = 0; 
0B4A0:  MOVLB  8
0B4A2:  MOVFF  8D2,FE9
0B4A6:  MOVFF  8D3,FEA
0B4AA:  CLRF   FEC
0B4AC:  MOVF   FED,F
0B4AE:  CLRF   FEF
....................       if (!fs)  
0B4B0:  MOVLB  7
0B4B2:  MOVF   x12,W
0B4B4:  IORWF  x13,W
0B4B6:  BNZ   B4BE
....................          return (FR_NOT_ENABLED); 
0B4B8:  MOVLW  0B
0B4BA:  MOVWF  01
0B4BC:  BRA    B9A0
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B4BE:  MOVLB  0
0B4C0:  CALL   55C6
0B4C4:  BTFSC  01.0
0B4C6:  BRA    B4D8
0B4C8:  MOVLB  7
0B4CA:  MOVFF  712,FE9
0B4CE:  MOVFF  713,FEA
0B4D2:  MOVF   FEF,F
0B4D4:  BNZ   B4E0
0B4D6:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B4D8:  MOVLW  01
0B4DA:  MOVWF  01
0B4DC:  MOVLB  7
0B4DE:  BRA    B9A0
....................     
....................       if (fp->flag & FA__ERROR) 
0B4E0:  MOVLW  1A
0B4E2:  MOVLB  8
0B4E4:  ADDWF  xCC,W
0B4E6:  MOVWF  FE9
0B4E8:  MOVLW  00
0B4EA:  ADDWFC xCD,W
0B4EC:  MOVWF  FEA
0B4EE:  BTFSS  FEF.7
0B4F0:  BRA    B4FC
....................          return (FR_RW_ERROR);   // Check error flag  
0B4F2:  MOVLW  07
0B4F4:  MOVWF  01
0B4F6:  MOVLB  7
0B4F8:  BRA    B9A0
0B4FA:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B4FC:  MOVLW  1A
0B4FE:  ADDWF  xCC,W
0B500:  MOVWF  FE9
0B502:  MOVLW  00
0B504:  ADDWFC xCD,W
0B506:  MOVWF  FEA
0B508:  BTFSC  FEF.0
0B50A:  BRA    B516
....................          return (FR_DENIED);      // Check access mode  
0B50C:  MOVLW  05
0B50E:  MOVWF  01
0B510:  MOVLB  7
0B512:  BRA    B9A0
0B514:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B516:  MOVLW  04
0B518:  ADDWF  xCC,W
0B51A:  MOVWF  FE9
0B51C:  MOVLW  00
0B51E:  ADDWFC xCD,W
0B520:  MOVWF  FEA
0B522:  MOVFF  FEF,8E5
0B526:  MOVFF  FEC,8E6
0B52A:  MOVFF  FEC,8E7
0B52E:  MOVFF  FEC,8E8
0B532:  MOVFF  8CC,FE9
0B536:  MOVFF  8CD,FEA
0B53A:  MOVFF  FEF,00
0B53E:  MOVFF  FEC,01
0B542:  MOVFF  FEC,02
0B546:  MOVFF  FEC,03
0B54A:  MOVF   00,W
0B54C:  SUBWF  xE5,W
0B54E:  MOVWF  xDC
0B550:  MOVF   01,W
0B552:  SUBWFB xE6,W
0B554:  MOVWF  xDD
0B556:  MOVF   02,W
0B558:  SUBWFB xE7,W
0B55A:  MOVWF  xDE
0B55C:  MOVF   03,W
0B55E:  SUBWFB xE8,W
0B560:  MOVWF  xDF
....................       if (btr > ln) 
0B562:  MOVF   xDF,F
0B564:  BNZ   B580
0B566:  MOVF   xDE,F
0B568:  BNZ   B580
0B56A:  MOVF   xDD,W
0B56C:  SUBWF  xD1,W
0B56E:  BNC   B580
0B570:  BNZ   B578
0B572:  MOVF   xD0,W
0B574:  SUBWF  xDC,W
0B576:  BC    B580
....................          btr = ln;            // Truncate read count by number of bytes left  
0B578:  MOVFF  8DD,8D1
0B57C:  MOVFF  8DC,8D0
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B580:  MOVF   xD0,W
0B582:  IORWF  xD1,W
0B584:  BTFSC  FD8.2
0B586:  BRA    B97E
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B588:  MOVFF  8CC,FE9
0B58C:  MOVFF  8CD,FEA
0B590:  MOVFF  FEF,8E5
0B594:  MOVFF  FEC,8E6
0B598:  MOVFF  FEC,8E7
0B59C:  MOVFF  FEC,8E8
0B5A0:  MOVLW  01
0B5A2:  ANDWF  xE6,F
0B5A4:  CLRF   xE7
0B5A6:  CLRF   xE8
0B5A8:  MOVF   xE5,F
0B5AA:  BTFSS  FD8.2
0B5AC:  BRA    B826
0B5AE:  MOVF   xE6,F
0B5B0:  BTFSS  FD8.2
0B5B2:  BRA    B826
0B5B4:  MOVF   xE7,F
0B5B6:  BTFSS  FD8.2
0B5B8:  BRA    B826
0B5BA:  MOVF   xE8,F
0B5BC:  BTFSS  FD8.2
0B5BE:  BRA    B826
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B5C0:  MOVLW  1B
0B5C2:  ADDWF  xCC,W
0B5C4:  MOVWF  FE9
0B5C6:  MOVLW  00
0B5C8:  ADDWFC xCD,W
0B5CA:  MOVWF  FEA
0B5CC:  DECF   FEF,F
0B5CE:  BZ    B606
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B5D0:  MOVLW  10
0B5D2:  ADDWF  xCC,W
0B5D4:  MOVWF  FE9
0B5D6:  MOVLW  00
0B5D8:  ADDWFC xCD,W
0B5DA:  MOVWF  FEA
0B5DC:  MOVFF  FEF,8E5
0B5E0:  MOVFF  FEC,8E6
0B5E4:  MOVFF  FEC,8E7
0B5E8:  MOVFF  FEC,8E8
0B5EC:  MOVLW  01
0B5EE:  ADDWF  xE5,W
0B5F0:  MOVWF  xD8
0B5F2:  MOVLW  00
0B5F4:  ADDWFC xE6,W
0B5F6:  MOVWF  xD9
0B5F8:  MOVLW  00
0B5FA:  ADDWFC xE7,W
0B5FC:  MOVWF  xDA
0B5FE:  MOVLW  00
0B600:  ADDWFC xE8,W
0B602:  MOVWF  xDB
....................                }  
0B604:  BRA    B742
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B606:  MOVFF  8CC,FE9
0B60A:  MOVFF  8CD,FEA
0B60E:  MOVFF  FEF,8E5
0B612:  MOVFF  FEC,8E6
0B616:  MOVFF  FEC,8E7
0B61A:  MOVFF  FEC,8E8
0B61E:  MOVF   xE5,F
0B620:  BNZ   B64C
0B622:  MOVF   xE6,F
0B624:  BNZ   B64C
0B626:  MOVF   xE7,F
0B628:  BNZ   B64C
0B62A:  MOVF   xE8,F
0B62C:  BNZ   B64C
0B62E:  MOVLW  08
0B630:  ADDWF  xCC,W
0B632:  MOVWF  FE9
0B634:  MOVLW  00
0B636:  ADDWFC xCD,W
0B638:  MOVWF  FEA
0B63A:  MOVFF  FEF,00
0B63E:  MOVFF  FEC,01
0B642:  MOVFF  FEC,02
0B646:  MOVFF  FEC,03
0B64A:  BRA    B670
0B64C:  MOVLW  0C
0B64E:  ADDWF  xCC,W
0B650:  MOVWF  FE9
0B652:  MOVLW  00
0B654:  ADDWFC xCD,W
0B656:  MOVWF  FEA
0B658:  MOVFF  FEF,9FC
0B65C:  MOVFF  FEC,9FD
0B660:  MOVFF  FEC,9FE
0B664:  MOVFF  FEC,9FF
0B668:  MOVLB  0
0B66A:  CALL   5CE2
0B66E:  MOVLB  8
0B670:  MOVFF  03,8D7
0B674:  MOVFF  02,8D6
0B678:  MOVFF  01,8D5
0B67C:  MOVFF  00,8D4
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B680:  MOVF   xD7,F
0B682:  BNZ   B692
0B684:  MOVF   xD6,F
0B686:  BNZ   B692
0B688:  MOVF   xD5,F
0B68A:  BNZ   B692
0B68C:  MOVF   xD4,W
0B68E:  SUBLW  01
0B690:  BC    B6D0
0B692:  MOVLW  0C
0B694:  MOVLB  7
0B696:  ADDWF  x12,W
0B698:  MOVWF  FE9
0B69A:  MOVLW  00
0B69C:  ADDWFC x13,W
0B69E:  MOVWF  FEA
0B6A0:  MOVFF  FEF,00
0B6A4:  MOVFF  FEC,01
0B6A8:  MOVFF  FEC,02
0B6AC:  MOVFF  FEC,03
0B6B0:  MOVF   03,W
0B6B2:  MOVLB  8
0B6B4:  SUBWF  xD7,W
0B6B6:  BNC   B6D2
0B6B8:  BNZ   B6D0
0B6BA:  MOVF   02,W
0B6BC:  SUBWF  xD6,W
0B6BE:  BNC   B6D2
0B6C0:  BNZ   B6D0
0B6C2:  MOVF   01,W
0B6C4:  SUBWF  xD5,W
0B6C6:  BNC   B6D2
0B6C8:  BNZ   B6D0
0B6CA:  MOVF   00,W
0B6CC:  SUBWF  xD4,W
0B6CE:  BNC   B6D2
....................                   goto fr_error; 
0B6D0:  BRA    B988
....................                fp->curr_clust = clust;            // Current cluster  
0B6D2:  MOVLW  0C
0B6D4:  ADDWF  xCC,W
0B6D6:  MOVWF  FE9
0B6D8:  MOVLW  00
0B6DA:  ADDWFC xCD,W
0B6DC:  MOVWF  FEA
0B6DE:  MOVFF  8D4,FEF
0B6E2:  MOVFF  8D5,FEC
0B6E6:  MOVFF  8D6,FEC
0B6EA:  MOVFF  8D7,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B6EE:  MOVFF  8D7,9F2
0B6F2:  MOVFF  8D6,9F1
0B6F6:  MOVFF  8D5,9F0
0B6FA:  MOVFF  8D4,9EF
0B6FE:  MOVLB  0
0B700:  CALL   5636
0B704:  MOVFF  03,8DB
0B708:  MOVFF  02,8DA
0B70C:  MOVFF  01,8D9
0B710:  MOVFF  00,8D8
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B714:  MOVLW  1B
0B716:  MOVLB  8
0B718:  ADDWF  xCC,W
0B71A:  MOVWF  01
0B71C:  MOVLW  00
0B71E:  ADDWFC xCD,W
0B720:  MOVWF  03
0B722:  MOVLW  02
0B724:  MOVLB  7
0B726:  ADDWF  x12,W
0B728:  MOVWF  FE9
0B72A:  MOVLW  00
0B72C:  ADDWFC x13,W
0B72E:  MOVWF  FEA
0B730:  MOVFF  FEF,8E7
0B734:  MOVLB  8
0B736:  MOVFF  03,FEA
0B73A:  MOVFF  01,FE9
0B73E:  MOVFF  8E7,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B742:  MOVLW  10
0B744:  ADDWF  xCC,W
0B746:  MOVWF  FE9
0B748:  MOVLW  00
0B74A:  ADDWFC xCD,W
0B74C:  MOVWF  FEA
0B74E:  MOVFF  8D8,FEF
0B752:  MOVFF  8D9,FEC
0B756:  MOVFF  8DA,FEC
0B75A:  MOVFF  8DB,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B75E:  BCF    FD8.0
0B760:  RRCF   xD1,W
0B762:  MOVWF  xE2
....................             if (cc)  
0B764:  MOVF   xE2,F
0B766:  BZ    B826
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B768:  MOVLW  1B
0B76A:  ADDWF  xCC,W
0B76C:  MOVWF  FE9
0B76E:  MOVLW  00
0B770:  ADDWFC xCD,W
0B772:  MOVWF  FEA
0B774:  MOVF   FEF,W
0B776:  SUBWF  xE2,W
0B778:  BZ    B78C
0B77A:  BNC   B78C
....................                   cc = fp->sect_clust; 
0B77C:  MOVLW  1B
0B77E:  ADDWF  xCC,W
0B780:  MOVWF  FE9
0B782:  MOVLW  00
0B784:  ADDWFC xCD,W
0B786:  MOVWF  FEA
0B788:  MOVFF  FEF,8E2
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B78C:  MOVFF  8E4,A21
0B790:  MOVFF  8E3,A20
0B794:  MOVFF  8DB,A25
0B798:  MOVFF  8DA,A24
0B79C:  MOVFF  8D9,A23
0B7A0:  MOVFF  8D8,A22
0B7A4:  MOVFF  8E2,A26
0B7A8:  MOVLB  0
0B7AA:  CALL   44F4
0B7AE:  MOVF   01,F
0B7B0:  BZ    B7B8
....................                   goto fr_error; 
0B7B2:  MOVLB  8
0B7B4:  BRA    B988
0B7B6:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B7B8:  MOVLW  1B
0B7BA:  MOVLB  8
0B7BC:  ADDWF  xCC,W
0B7BE:  MOVWF  FE9
0B7C0:  MOVLW  00
0B7C2:  ADDWFC xCD,W
0B7C4:  MOVWF  FEA
0B7C6:  MOVLW  01
0B7C8:  SUBWF  xE2,W
0B7CA:  SUBWF  FEF,W
0B7CC:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B7CE:  MOVLW  10
0B7D0:  ADDWF  xCC,W
0B7D2:  MOVWF  FE9
0B7D4:  MOVLW  00
0B7D6:  ADDWFC xCD,W
0B7D8:  MOVWF  FEA
0B7DA:  MOVLW  01
0B7DC:  SUBWF  xE2,W
0B7DE:  ADDWF  FEF,W
0B7E0:  MOVWF  00
0B7E2:  MOVLW  00
0B7E4:  ADDWFC FEC,W
0B7E6:  MOVWF  01
0B7E8:  MOVLW  00
0B7EA:  ADDWFC FEC,W
0B7EC:  MOVWF  02
0B7EE:  MOVLW  00
0B7F0:  ADDWFC FEC,W
0B7F2:  MOVF   FED,F
0B7F4:  MOVF   FED,F
0B7F6:  MOVF   FED,F
0B7F8:  MOVFF  00,FEF
0B7FC:  MOVFF  01,FEC
0B800:  MOVFF  02,FEC
0B804:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B806:  MOVLB  A
0B808:  CLRF   x11
0B80A:  MOVFF  8E2,A10
0B80E:  MOVLW  02
0B810:  MOVWF  x13
0B812:  CLRF   x12
0B814:  MOVLB  0
0B816:  CALL   5CC0
0B81A:  MOVFF  02,8E1
0B81E:  MOVFF  01,8E0
....................                continue; 
0B822:  BRA    B91A
0B824:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B826:  MOVLW  10
0B828:  ADDWF  xCC,W
0B82A:  MOVWF  FE9
0B82C:  MOVLW  00
0B82E:  ADDWFC xCD,W
0B830:  MOVWF  FEA
0B832:  MOVFF  FEF,A14
0B836:  MOVFF  FEC,A15
0B83A:  MOVFF  FEC,A16
0B83E:  MOVFF  FEC,A17
0B842:  MOVLB  0
0B844:  CALL   5AAA
0B848:  MOVF   01,F
0B84A:  BNZ   B852
....................                goto fr_error; 
0B84C:  MOVLB  8
0B84E:  BRA    B988
0B850:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B852:  MOVLB  8
0B854:  MOVFF  8CC,FE9
0B858:  MOVFF  8CD,FEA
0B85C:  MOVFF  FEF,8E5
0B860:  MOVFF  FEC,8E6
0B864:  MOVFF  FEC,8E7
0B868:  MOVFF  FEC,8E8
0B86C:  MOVF   xE6,W
0B86E:  ANDLW  01
0B870:  MOVWF  01
0B872:  MOVLW  00
0B874:  BSF    FD8.0
0B876:  SUBFWB xE5,W
0B878:  MOVWF  xE0
0B87A:  MOVLW  02
0B87C:  SUBFWB 01,W
0B87E:  MOVWF  xE1
....................          if (rcnt > btr) 
0B880:  MOVF   xD1,W
0B882:  SUBWF  xE1,W
0B884:  BNC   B896
0B886:  BNZ   B88E
0B888:  MOVF   xE0,W
0B88A:  SUBWF  xD0,W
0B88C:  BC    B896
....................             rcnt = btr; 
0B88E:  MOVFF  8D1,8E1
0B892:  MOVFF  8D0,8E0
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B896:  MOVFF  8CC,FE9
0B89A:  MOVFF  8CD,FEA
0B89E:  MOVFF  FEF,8E5
0B8A2:  MOVFF  FEC,8E6
0B8A6:  MOVFF  FEC,8E7
0B8AA:  MOVFF  FEC,8E8
0B8AE:  MOVLW  01
0B8B0:  ANDWF  xE6,F
0B8B2:  CLRF   xE7
0B8B4:  CLRF   xE8
0B8B6:  MOVLW  24
0B8B8:  ADDWF  xE5,W
0B8BA:  MOVWF  00
0B8BC:  MOVLW  00
0B8BE:  ADDWFC xE6,W
0B8C0:  MOVWF  01
0B8C2:  MOVLW  00
0B8C4:  ADDWFC xE7,W
0B8C6:  MOVWF  02
0B8C8:  MOVLW  00
0B8CA:  ADDWFC xE8,W
0B8CC:  MOVWF  03
0B8CE:  MOVFF  01,03
0B8D2:  MOVF   00,W
0B8D4:  MOVLB  7
0B8D6:  ADDWF  x12,W
0B8D8:  MOVWF  01
0B8DA:  MOVF   x13,W
0B8DC:  ADDWFC 03,F
0B8DE:  MOVFF  01,8E9
0B8E2:  MOVLB  8
0B8E4:  MOVFF  03,8EA
0B8E8:  MOVFF  8E4,FEA
0B8EC:  MOVFF  8E3,FE9
0B8F0:  MOVFF  03,FE2
0B8F4:  MOVFF  01,FE1
0B8F8:  MOVFF  8E1,02
0B8FC:  MOVFF  8E0,01
0B900:  MOVF   01,F
0B902:  BZ    B908
0B904:  INCF   02,F
0B906:  BRA    B90C
0B908:  MOVF   02,F
0B90A:  BZ    B918
0B90C:  MOVFF  FE6,FEE
0B910:  DECFSZ 01,F
0B912:  BRA    B90C
0B914:  DECFSZ 02,F
0B916:  BRA    B90C
0B918:  MOVLB  0
0B91A:  MOVLB  8
0B91C:  MOVF   xE0,W
0B91E:  ADDWF  xE3,F
0B920:  MOVF   xE1,W
0B922:  ADDWFC xE4,F
0B924:  MOVFF  8CC,FE9
0B928:  MOVFF  8CD,FEA
0B92C:  MOVF   xE0,W
0B92E:  ADDWF  FEF,W
0B930:  MOVWF  00
0B932:  MOVF   xE1,W
0B934:  ADDWFC FEC,W
0B936:  MOVWF  01
0B938:  MOVLW  00
0B93A:  ADDWFC FEC,W
0B93C:  MOVWF  02
0B93E:  MOVLW  00
0B940:  ADDWFC FEC,W
0B942:  MOVWF  03
0B944:  MOVF   FED,F
0B946:  MOVF   FED,F
0B948:  MOVF   FED,F
0B94A:  MOVFF  00,FEF
0B94E:  MOVFF  01,FEC
0B952:  MOVFF  02,FEC
0B956:  MOVWF  FEC
0B958:  MOVFF  8D2,FE9
0B95C:  MOVFF  8D3,FEA
0B960:  MOVF   xE0,W
0B962:  ADDWF  FEF,W
0B964:  MOVWF  01
0B966:  MOVF   xE1,W
0B968:  ADDWFC FEC,W
0B96A:  MOVWF  03
0B96C:  MOVF   FED,F
0B96E:  MOVFF  01,FEF
0B972:  MOVWF  FEC
0B974:  MOVF   xE0,W
0B976:  SUBWF  xD0,F
0B978:  MOVF   xE1,W
0B97A:  SUBWFB xD1,F
0B97C:  BRA    B580
....................          } 
....................       return (FR_OK); 
0B97E:  MOVLW  00
0B980:  MOVWF  01
0B982:  MOVLB  7
0B984:  BRA    B9A0
0B986:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B988:  MOVLW  1A
0B98A:  ADDWF  xCC,W
0B98C:  MOVWF  FE9
0B98E:  MOVLW  00
0B990:  ADDWFC xCD,W
0B992:  MOVWF  FEA
0B994:  MOVF   FEF,W
0B996:  IORLW  80
0B998:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B99A:  MOVLW  07
0B99C:  MOVWF  01
0B99E:  MOVLB  7
0B9A0:  MOVLB  0
0B9A2:  GOTO   BB9E (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
07A22:  MOVFF  9B3,9C4
07A26:  MOVFF  9B2,9C3
....................       *bw = 0; 
07A2A:  MOVLB  9
07A2C:  MOVFF  9B6,FE9
07A30:  MOVFF  9B7,FEA
07A34:  CLRF   FEC
07A36:  MOVF   FED,F
07A38:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
07A3A:  CLRF   xC1
07A3C:  CLRF   xC0
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
07A3E:  MOVLB  7
07A40:  MOVF   x12,W
07A42:  IORWF  x13,W
07A44:  BNZ   7A4C
....................          return (FR_NOT_ENABLED); 
07A46:  MOVLW  0B
07A48:  MOVWF  01
07A4A:  BRA    80EC
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
07A4C:  MOVLB  0
07A4E:  CALL   55C6
07A52:  BTFSC  01.0
07A54:  BRA    7A66
07A56:  MOVLB  7
07A58:  MOVFF  712,FE9
07A5C:  MOVFF  713,FEA
07A60:  MOVF   FEF,F
07A62:  BNZ   7A6E
07A64:  MOVLB  0
....................          return (FR_NOT_READY); 
07A66:  MOVLW  01
07A68:  MOVWF  01
07A6A:  MOVLB  7
07A6C:  BRA    80EC
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
07A6E:  MOVLW  1A
07A70:  MOVLB  9
07A72:  ADDWF  xB0,W
07A74:  MOVWF  FE9
07A76:  MOVLW  00
07A78:  ADDWFC xB1,W
07A7A:  MOVWF  FEA
07A7C:  BTFSS  FEF.7
07A7E:  BRA    7A8A
....................          return (FR_RW_ERROR);         // Check error flag  
07A80:  MOVLW  07
07A82:  MOVWF  01
07A84:  MOVLB  7
07A86:  BRA    80EC
07A88:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
07A8A:  MOVLW  1A
07A8C:  ADDWF  xB0,W
07A8E:  MOVWF  FE9
07A90:  MOVLW  00
07A92:  ADDWFC xB1,W
07A94:  MOVWF  FEA
07A96:  BTFSC  FEF.1
07A98:  BRA    7AA4
....................          return (FR_DENIED);            // Check access mode  
07A9A:  MOVLW  05
07A9C:  MOVWF  01
07A9E:  MOVLB  7
07AA0:  BRA    80EC
07AA2:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
07AA4:  MOVLW  04
07AA6:  ADDWF  xB0,W
07AA8:  MOVWF  FE9
07AAA:  MOVLW  00
07AAC:  ADDWFC xB1,W
07AAE:  MOVWF  FEA
07AB0:  MOVFF  FEF,9C5
07AB4:  MOVFF  FEC,9C6
07AB8:  MOVFF  FEC,9C7
07ABC:  MOVFF  FEC,9C8
07AC0:  MOVF   xB4,W
07AC2:  ADDWF  xC5,F
07AC4:  MOVF   xB5,W
07AC6:  ADDWFC xC6,F
07AC8:  MOVLW  00
07ACA:  ADDWFC xC7,F
07ACC:  ADDWFC xC8,F
07ACE:  MOVLW  04
07AD0:  ADDWF  xB0,W
07AD2:  MOVWF  FE9
07AD4:  MOVLW  00
07AD6:  ADDWFC xB1,W
07AD8:  MOVWF  FEA
07ADA:  MOVFF  FEF,00
07ADE:  MOVFF  FEC,01
07AE2:  MOVFF  FEC,02
07AE6:  MOVFF  FEC,03
07AEA:  MOVF   xC8,W
07AEC:  SUBWF  03,W
07AEE:  BNC   7B0C
07AF0:  BNZ   7B08
07AF2:  MOVF   xC7,W
07AF4:  SUBWF  02,W
07AF6:  BNC   7B0C
07AF8:  BNZ   7B08
07AFA:  MOVF   xC6,W
07AFC:  SUBWF  01,W
07AFE:  BNC   7B0C
07B00:  BNZ   7B08
07B02:  MOVF   00,W
07B04:  SUBWF  xC5,W
07B06:  BC    7B0C
....................          btw = 0;                  // File size cannot reach 4GB  
07B08:  CLRF   xB5
07B0A:  CLRF   xB4
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07B0C:  MOVF   xB4,W
07B0E:  IORWF  xB5,W
07B10:  BTFSC  FD8.2
07B12:  BRA    8020
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07B14:  MOVFF  9B0,FE9
07B18:  MOVFF  9B1,FEA
07B1C:  MOVFF  FEF,9C5
07B20:  MOVFF  FEC,9C6
07B24:  MOVFF  FEC,9C7
07B28:  MOVFF  FEC,9C8
07B2C:  MOVLW  01
07B2E:  ANDWF  xC6,F
07B30:  CLRF   xC7
07B32:  CLRF   xC8
07B34:  MOVF   xC5,F
07B36:  BTFSS  FD8.2
07B38:  BRA    7EBA
07B3A:  MOVF   xC6,F
07B3C:  BTFSS  FD8.2
07B3E:  BRA    7EBA
07B40:  MOVF   xC7,F
07B42:  BTFSS  FD8.2
07B44:  BRA    7EBA
07B46:  MOVF   xC8,F
07B48:  BTFSS  FD8.2
07B4A:  BRA    7EBA
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07B4C:  MOVLW  1B
07B4E:  ADDWF  xB0,W
07B50:  MOVWF  FE9
07B52:  MOVLW  00
07B54:  ADDWFC xB1,W
07B56:  MOVWF  FEA
07B58:  DECF   FEF,F
07B5A:  BZ    7B92
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07B5C:  MOVLW  10
07B5E:  ADDWF  xB0,W
07B60:  MOVWF  FE9
07B62:  MOVLW  00
07B64:  ADDWFC xB1,W
07B66:  MOVWF  FEA
07B68:  MOVFF  FEF,9C5
07B6C:  MOVFF  FEC,9C6
07B70:  MOVFF  FEC,9C7
07B74:  MOVFF  FEC,9C8
07B78:  MOVLW  01
07B7A:  ADDWF  xC5,W
07B7C:  MOVWF  xBC
07B7E:  MOVLW  00
07B80:  ADDWFC xC6,W
07B82:  MOVWF  xBD
07B84:  MOVLW  00
07B86:  ADDWFC xC7,W
07B88:  MOVWF  xBE
07B8A:  MOVLW  00
07B8C:  ADDWFC xC8,W
07B8E:  MOVWF  xBF
....................                }  
07B90:  BRA    7D28
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07B92:  MOVFF  9B0,FE9
07B96:  MOVFF  9B1,FEA
07B9A:  MOVFF  FEF,9C5
07B9E:  MOVFF  FEC,9C6
07BA2:  MOVFF  FEC,9C7
07BA6:  MOVFF  FEC,9C8
07BAA:  MOVF   xC5,F
07BAC:  BNZ   7C32
07BAE:  MOVF   xC6,F
07BB0:  BNZ   7C32
07BB2:  MOVF   xC7,F
07BB4:  BNZ   7C32
07BB6:  MOVF   xC8,F
07BB8:  BNZ   7C32
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07BBA:  MOVLW  08
07BBC:  ADDWF  xB0,W
07BBE:  MOVWF  FE9
07BC0:  MOVLW  00
07BC2:  ADDWFC xB1,W
07BC4:  MOVWF  FEA
07BC6:  MOVFF  FEF,9B8
07BCA:  MOVFF  FEC,9B9
07BCE:  MOVFF  FEC,9BA
07BD2:  MOVFF  FEC,9BB
....................                   if (clust == 0)            // No cluster is created  
07BD6:  MOVF   xB8,F
07BD8:  BNZ   7C30
07BDA:  MOVF   xB9,F
07BDC:  BNZ   7C30
07BDE:  MOVF   xBA,F
07BE0:  BNZ   7C30
07BE2:  MOVF   xBB,F
07BE4:  BNZ   7C30
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07BE6:  MOVLW  08
07BE8:  ADDWF  xB0,W
07BEA:  MOVWF  01
07BEC:  MOVLW  00
07BEE:  ADDWFC xB1,W
07BF0:  MOVWF  03
07BF2:  MOVFF  01,9C5
07BF6:  MOVWF  xC6
07BF8:  CLRF   xEB
07BFA:  CLRF   xEA
07BFC:  CLRF   xE9
07BFE:  CLRF   xE8
07C00:  MOVLB  0
07C02:  CALL   698C
07C06:  MOVFF  03,9BB
07C0A:  MOVFF  02,9BA
07C0E:  MOVFF  01,9B9
07C12:  MOVFF  00,9B8
07C16:  MOVFF  9C6,FEA
07C1A:  MOVFF  9C5,FE9
07C1E:  MOVFF  9B8,FEF
07C22:  MOVFF  9B9,FEC
07C26:  MOVFF  9BA,FEC
07C2A:  MOVFF  9BB,FEC
07C2E:  MOVLB  9
....................                   } 
07C30:  BRA    7C66
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07C32:  MOVLW  0C
07C34:  ADDWF  xB0,W
07C36:  MOVWF  FE9
07C38:  MOVLW  00
07C3A:  ADDWFC xB1,W
07C3C:  MOVWF  FEA
07C3E:  MOVFF  FEF,9E8
07C42:  MOVFF  FEC,9E9
07C46:  MOVFF  FEC,9EA
07C4A:  MOVFF  FEC,9EB
07C4E:  MOVLB  0
07C50:  CALL   698C
07C54:  MOVFF  03,9BB
07C58:  MOVFF  02,9BA
07C5C:  MOVFF  01,9B9
07C60:  MOVFF  00,9B8
07C64:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07C66:  MOVF   xBB,F
07C68:  BNZ   7C78
07C6A:  MOVF   xBA,F
07C6C:  BNZ   7C78
07C6E:  MOVF   xB9,F
07C70:  BNZ   7C78
07C72:  MOVF   xB8,W
07C74:  SUBLW  01
07C76:  BC    7CB6
07C78:  MOVLW  0C
07C7A:  MOVLB  7
07C7C:  ADDWF  x12,W
07C7E:  MOVWF  FE9
07C80:  MOVLW  00
07C82:  ADDWFC x13,W
07C84:  MOVWF  FEA
07C86:  MOVFF  FEF,00
07C8A:  MOVFF  FEC,01
07C8E:  MOVFF  FEC,02
07C92:  MOVFF  FEC,03
07C96:  MOVF   03,W
07C98:  MOVLB  9
07C9A:  SUBWF  xBB,W
07C9C:  BNC   7CB8
07C9E:  BNZ   7CB6
07CA0:  MOVF   02,W
07CA2:  SUBWF  xBA,W
07CA4:  BNC   7CB8
07CA6:  BNZ   7CB6
07CA8:  MOVF   01,W
07CAA:  SUBWF  xB9,W
07CAC:  BNC   7CB8
07CAE:  BNZ   7CB6
07CB0:  MOVF   00,W
07CB2:  SUBWF  xB8,W
07CB4:  BNC   7CB8
....................                   break; 
07CB6:  BRA    8020
....................                fp->curr_clust = clust;            // Current cluster  
07CB8:  MOVLW  0C
07CBA:  ADDWF  xB0,W
07CBC:  MOVWF  FE9
07CBE:  MOVLW  00
07CC0:  ADDWFC xB1,W
07CC2:  MOVWF  FEA
07CC4:  MOVFF  9B8,FEF
07CC8:  MOVFF  9B9,FEC
07CCC:  MOVFF  9BA,FEC
07CD0:  MOVFF  9BB,FEC
....................                sect = clust2sect(clust);         // Current sector  
07CD4:  MOVFF  9BB,9F2
07CD8:  MOVFF  9BA,9F1
07CDC:  MOVFF  9B9,9F0
07CE0:  MOVFF  9B8,9EF
07CE4:  MOVLB  0
07CE6:  CALL   5636
07CEA:  MOVFF  03,9BF
07CEE:  MOVFF  02,9BE
07CF2:  MOVFF  01,9BD
07CF6:  MOVFF  00,9BC
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07CFA:  MOVLW  1B
07CFC:  MOVLB  9
07CFE:  ADDWF  xB0,W
07D00:  MOVWF  01
07D02:  MOVLW  00
07D04:  ADDWFC xB1,W
07D06:  MOVWF  03
07D08:  MOVLW  02
07D0A:  MOVLB  7
07D0C:  ADDWF  x12,W
07D0E:  MOVWF  FE9
07D10:  MOVLW  00
07D12:  ADDWFC x13,W
07D14:  MOVWF  FEA
07D16:  MOVFF  FEF,9C7
07D1A:  MOVLB  9
07D1C:  MOVFF  03,FEA
07D20:  MOVFF  01,FE9
07D24:  MOVFF  9C7,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07D28:  MOVLW  10
07D2A:  ADDWF  xB0,W
07D2C:  MOVWF  FE9
07D2E:  MOVLW  00
07D30:  ADDWFC xB1,W
07D32:  MOVWF  FEA
07D34:  MOVFF  9BC,FEF
07D38:  MOVFF  9BD,FEC
07D3C:  MOVFF  9BE,FEC
07D40:  MOVFF  9BF,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07D44:  BCF    FD8.0
07D46:  RRCF   xB5,W
07D48:  MOVWF  xC2
....................             if (cc)  
07D4A:  MOVF   xC2,F
07D4C:  BZ    7E08
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07D4E:  MOVLW  1B
07D50:  ADDWF  xB0,W
07D52:  MOVWF  FE9
07D54:  MOVLW  00
07D56:  ADDWFC xB1,W
07D58:  MOVWF  FEA
07D5A:  MOVF   FEF,W
07D5C:  SUBWF  xC2,W
07D5E:  BZ    7D72
07D60:  BNC   7D72
....................                   cc = fp->sect_clust; 
07D62:  MOVLW  1B
07D64:  ADDWF  xB0,W
07D66:  MOVWF  FE9
07D68:  MOVLW  00
07D6A:  ADDWFC xB1,W
07D6C:  MOVWF  FEA
07D6E:  MOVFF  FEF,9C2
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07D72:  MOVFF  9C4,A21
07D76:  MOVFF  9C3,A20
07D7A:  MOVFF  9BF,A25
07D7E:  MOVFF  9BE,A24
07D82:  MOVFF  9BD,A23
07D86:  MOVFF  9BC,A22
07D8A:  MOVFF  9C2,A26
07D8E:  MOVLB  0
07D90:  CALL   5966
07D94:  MOVF   01,F
07D96:  BZ    7D9A
....................                   goto fw_error; 
07D98:  BRA    80D2
....................                fp->sect_clust -= cc - 1; 
07D9A:  MOVLW  1B
07D9C:  MOVLB  9
07D9E:  ADDWF  xB0,W
07DA0:  MOVWF  FE9
07DA2:  MOVLW  00
07DA4:  ADDWFC xB1,W
07DA6:  MOVWF  FEA
07DA8:  MOVLW  01
07DAA:  SUBWF  xC2,W
07DAC:  SUBWF  FEF,W
07DAE:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07DB0:  MOVLW  10
07DB2:  ADDWF  xB0,W
07DB4:  MOVWF  FE9
07DB6:  MOVLW  00
07DB8:  ADDWFC xB1,W
07DBA:  MOVWF  FEA
07DBC:  MOVLW  01
07DBE:  SUBWF  xC2,W
07DC0:  ADDWF  FEF,W
07DC2:  MOVWF  00
07DC4:  MOVLW  00
07DC6:  ADDWFC FEC,W
07DC8:  MOVWF  01
07DCA:  MOVLW  00
07DCC:  ADDWFC FEC,W
07DCE:  MOVWF  02
07DD0:  MOVLW  00
07DD2:  ADDWFC FEC,W
07DD4:  MOVF   FED,F
07DD6:  MOVF   FED,F
07DD8:  MOVF   FED,F
07DDA:  MOVFF  00,FEF
07DDE:  MOVFF  01,FEC
07DE2:  MOVFF  02,FEC
07DE6:  MOVWF  FEC
....................                wcnt = cc * 512; 
07DE8:  MOVLB  A
07DEA:  CLRF   x11
07DEC:  MOVFF  9C2,A10
07DF0:  MOVLW  02
07DF2:  MOVWF  x13
07DF4:  CLRF   x12
07DF6:  MOVLB  0
07DF8:  CALL   5CC0
07DFC:  MOVFF  02,9C1
07E00:  MOVFF  01,9C0
....................                continue; 
07E04:  BRA    7FBC
07E06:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07E08:  MOVFF  9B0,FE9
07E0C:  MOVFF  9B1,FEA
07E10:  MOVFF  FEF,9C5
07E14:  MOVFF  FEC,9C6
07E18:  MOVFF  FEC,9C7
07E1C:  MOVFF  FEC,9C8
07E20:  MOVLW  04
07E22:  ADDWF  xB0,W
07E24:  MOVWF  FE9
07E26:  MOVLW  00
07E28:  ADDWFC xB1,W
07E2A:  MOVWF  FEA
07E2C:  MOVFF  FEF,00
07E30:  MOVFF  FEC,01
07E34:  MOVFF  FEC,02
07E38:  MOVFF  FEC,03
07E3C:  MOVF   03,W
07E3E:  SUBWF  xC8,W
07E40:  BNC   7EBA
07E42:  BNZ   7E5A
07E44:  MOVF   02,W
07E46:  SUBWF  xC7,W
07E48:  BNC   7EBA
07E4A:  BNZ   7E5A
07E4C:  MOVF   01,W
07E4E:  SUBWF  xC6,W
07E50:  BNC   7EBA
07E52:  BNZ   7E5A
07E54:  MOVF   00,W
07E56:  SUBWF  xC5,W
07E58:  BNC   7EBA
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07E5A:  MOVLB  A
07E5C:  CLRF   x17
07E5E:  CLRF   x16
07E60:  CLRF   x15
07E62:  CLRF   x14
07E64:  MOVLB  0
07E66:  CALL   5AAA
07E6A:  MOVF   01,F
07E6C:  BNZ   7E70
....................                   goto fw_error; 
07E6E:  BRA    80D2
....................                fs->winsect = fp->curr_sect; 
07E70:  MOVLW  20
07E72:  MOVLB  7
07E74:  ADDWF  x12,W
07E76:  MOVWF  01
07E78:  MOVLW  00
07E7A:  ADDWFC x13,W
07E7C:  MOVWF  03
07E7E:  MOVFF  01,9C5
07E82:  MOVLB  9
07E84:  MOVWF  xC6
07E86:  MOVLW  10
07E88:  ADDWF  xB0,W
07E8A:  MOVWF  FE9
07E8C:  MOVLW  00
07E8E:  ADDWFC xB1,W
07E90:  MOVWF  FEA
07E92:  MOVFF  FEF,00
07E96:  MOVFF  FEC,01
07E9A:  MOVFF  FEC,02
07E9E:  MOVFF  FEC,03
07EA2:  MOVFF  9C6,FEA
07EA6:  MOVFF  9C5,FE9
07EAA:  MOVFF  00,FEF
07EAE:  MOVFF  01,FEC
07EB2:  MOVFF  02,FEC
07EB6:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07EBA:  MOVLW  10
07EBC:  ADDWF  xB0,W
07EBE:  MOVWF  FE9
07EC0:  MOVLW  00
07EC2:  ADDWFC xB1,W
07EC4:  MOVWF  FEA
07EC6:  MOVFF  FEF,A14
07ECA:  MOVFF  FEC,A15
07ECE:  MOVFF  FEC,A16
07ED2:  MOVFF  FEC,A17
07ED6:  MOVLB  0
07ED8:  CALL   5AAA
07EDC:  MOVF   01,F
07EDE:  BNZ   7EE2
....................             goto fw_error;               // Move sector window 
07EE0:  BRA    80D2
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07EE2:  MOVLB  9
07EE4:  MOVFF  9B0,FE9
07EE8:  MOVFF  9B1,FEA
07EEC:  MOVFF  FEF,9C5
07EF0:  MOVFF  FEC,9C6
07EF4:  MOVFF  FEC,9C7
07EF8:  MOVFF  FEC,9C8
07EFC:  MOVF   xC6,W
07EFE:  ANDLW  01
07F00:  MOVWF  01
07F02:  MOVLW  00
07F04:  BSF    FD8.0
07F06:  SUBFWB xC5,W
07F08:  MOVWF  xC0
07F0A:  MOVLW  02
07F0C:  SUBFWB 01,W
07F0E:  MOVWF  xC1
....................          if (wcnt > btw) 
07F10:  MOVF   xB5,W
07F12:  SUBWF  xC1,W
07F14:  BNC   7F26
07F16:  BNZ   7F1E
07F18:  MOVF   xC0,W
07F1A:  SUBWF  xB4,W
07F1C:  BC    7F26
....................             wcnt = btw; 
07F1E:  MOVFF  9B5,9C1
07F22:  MOVFF  9B4,9C0
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07F26:  MOVFF  9B0,FE9
07F2A:  MOVFF  9B1,FEA
07F2E:  MOVFF  FEF,9C5
07F32:  MOVFF  FEC,9C6
07F36:  MOVFF  FEC,9C7
07F3A:  MOVFF  FEC,9C8
07F3E:  MOVLW  01
07F40:  ANDWF  xC6,F
07F42:  CLRF   xC7
07F44:  CLRF   xC8
07F46:  MOVLW  24
07F48:  ADDWF  xC5,W
07F4A:  MOVWF  00
07F4C:  MOVLW  00
07F4E:  ADDWFC xC6,W
07F50:  MOVWF  01
07F52:  MOVLW  00
07F54:  ADDWFC xC7,W
07F56:  MOVWF  02
07F58:  MOVLW  00
07F5A:  ADDWFC xC8,W
07F5C:  MOVWF  03
07F5E:  MOVFF  01,03
07F62:  MOVF   00,W
07F64:  MOVLB  7
07F66:  ADDWF  x12,W
07F68:  MOVWF  01
07F6A:  MOVF   x13,W
07F6C:  ADDWFC 03,F
07F6E:  MOVFF  01,9C9
07F72:  MOVLB  9
07F74:  MOVFF  03,9CA
07F78:  MOVFF  03,FEA
07F7C:  MOVFF  01,FE9
07F80:  MOVFF  9C4,FE2
07F84:  MOVFF  9C3,FE1
07F88:  MOVFF  9C1,02
07F8C:  MOVFF  9C0,01
07F90:  MOVF   01,F
07F92:  BZ    7F98
07F94:  INCF   02,F
07F96:  BRA    7F9C
07F98:  MOVF   02,F
07F9A:  BZ    7FA8
07F9C:  MOVFF  FE6,FEE
07FA0:  DECFSZ 01,F
07FA2:  BRA    7F9C
07FA4:  DECFSZ 02,F
07FA6:  BRA    7F9C
....................          fs->winflag = 1; 
07FA8:  MOVLW  06
07FAA:  MOVLB  7
07FAC:  ADDWF  x12,W
07FAE:  MOVWF  FE9
07FB0:  MOVLW  00
07FB2:  ADDWFC x13,W
07FB4:  MOVWF  FEA
07FB6:  MOVLW  01
07FB8:  MOVWF  FEF
07FBA:  MOVLB  0
07FBC:  MOVLB  9
07FBE:  MOVF   xC0,W
07FC0:  ADDWF  xC3,F
07FC2:  MOVF   xC1,W
07FC4:  ADDWFC xC4,F
07FC6:  MOVFF  9B0,FE9
07FCA:  MOVFF  9B1,FEA
07FCE:  MOVF   xC0,W
07FD0:  ADDWF  FEF,W
07FD2:  MOVWF  00
07FD4:  MOVF   xC1,W
07FD6:  ADDWFC FEC,W
07FD8:  MOVWF  01
07FDA:  MOVLW  00
07FDC:  ADDWFC FEC,W
07FDE:  MOVWF  02
07FE0:  MOVLW  00
07FE2:  ADDWFC FEC,W
07FE4:  MOVWF  03
07FE6:  MOVF   FED,F
07FE8:  MOVF   FED,F
07FEA:  MOVF   FED,F
07FEC:  MOVFF  00,FEF
07FF0:  MOVFF  01,FEC
07FF4:  MOVFF  02,FEC
07FF8:  MOVWF  FEC
07FFA:  MOVFF  9B6,FE9
07FFE:  MOVFF  9B7,FEA
08002:  MOVF   xC0,W
08004:  ADDWF  FEF,W
08006:  MOVWF  01
08008:  MOVF   xC1,W
0800A:  ADDWFC FEC,W
0800C:  MOVWF  03
0800E:  MOVF   FED,F
08010:  MOVFF  01,FEF
08014:  MOVWF  FEC
08016:  MOVF   xC0,W
08018:  SUBWF  xB4,F
0801A:  MOVF   xC1,W
0801C:  SUBWFB xB5,F
0801E:  BRA    7B0C
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
08020:  MOVFF  9B0,FE9
08024:  MOVFF  9B1,FEA
08028:  MOVFF  FEF,9C5
0802C:  MOVFF  FEC,9C6
08030:  MOVFF  FEC,9C7
08034:  MOVFF  FEC,9C8
08038:  MOVLW  04
0803A:  ADDWF  xB0,W
0803C:  MOVWF  FE9
0803E:  MOVLW  00
08040:  ADDWFC xB1,W
08042:  MOVWF  FEA
08044:  MOVFF  FEF,00
08048:  MOVFF  FEC,01
0804C:  MOVFF  FEC,02
08050:  MOVFF  FEC,03
08054:  MOVF   03,W
08056:  SUBWF  xC8,W
08058:  BNC   80B6
0805A:  BNZ   8072
0805C:  MOVF   02,W
0805E:  SUBWF  xC7,W
08060:  BNC   80B6
08062:  BNZ   8072
08064:  MOVF   01,W
08066:  SUBWF  xC6,W
08068:  BNC   80B6
0806A:  BNZ   8072
0806C:  MOVF   xC5,W
0806E:  SUBWF  00,W
08070:  BC    80B6
....................          fp->fsize = fp->fptr;      // Update file size if needed  
08072:  MOVLW  04
08074:  ADDWF  xB0,W
08076:  MOVWF  01
08078:  MOVLW  00
0807A:  ADDWFC xB1,W
0807C:  MOVWF  03
0807E:  MOVFF  01,9C5
08082:  MOVFF  03,9C6
08086:  MOVFF  9B0,FE9
0808A:  MOVFF  9B1,FEA
0808E:  MOVFF  FEF,00
08092:  MOVFF  FEC,01
08096:  MOVFF  FEC,02
0809A:  MOVFF  FEC,03
0809E:  MOVFF  9C6,FEA
080A2:  MOVFF  9C5,FE9
080A6:  MOVFF  00,FEF
080AA:  MOVFF  01,FEC
080AE:  MOVFF  02,FEC
080B2:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
080B6:  MOVLW  1A
080B8:  ADDWF  xB0,W
080BA:  MOVWF  FE9
080BC:  MOVLW  00
080BE:  ADDWFC xB1,W
080C0:  MOVWF  FEA
080C2:  MOVF   FEF,W
080C4:  IORLW  20
080C6:  MOVWF  FEF
....................       return (FR_OK); 
080C8:  MOVLW  00
080CA:  MOVWF  01
080CC:  MOVLB  7
080CE:  BRA    80EC
080D0:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
080D2:  MOVLW  1A
080D4:  MOVLB  9
080D6:  ADDWF  xB0,W
080D8:  MOVWF  FE9
080DA:  MOVLW  00
080DC:  ADDWFC xB1,W
080DE:  MOVWF  FEA
080E0:  MOVF   FEF,W
080E2:  IORLW  80
080E4:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
080E6:  MOVLW  07
080E8:  MOVWF  01
080EA:  MOVLB  7
080EC:  MOVLB  0
080EE:  GOTO   8496 (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
075C8:  MOVLB  7
075CA:  MOVF   x12,W
075CC:  IORWF  x13,W
075CE:  BNZ   75D6
....................          return (FR_NOT_ENABLED); 
075D0:  MOVLW  0B
075D2:  MOVWF  01
075D4:  BRA    792A
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
075D6:  MOVLB  0
075D8:  CALL   55C6
075DC:  BTFSC  01.0
075DE:  BRA    75F0
075E0:  MOVLB  7
075E2:  MOVFF  712,FE9
075E6:  MOVFF  713,FEA
075EA:  MOVF   FEF,F
075EC:  BNZ   75F8
075EE:  MOVLB  0
....................          return (FR_NOT_READY); 
075F0:  MOVLW  01
075F2:  MOVWF  01
075F4:  MOVLB  7
075F6:  BRA    792A
....................     
....................       if (fp->flag & FA__ERROR) 
075F8:  MOVLW  1A
075FA:  MOVLB  9
075FC:  ADDWF  xB0,W
075FE:  MOVWF  FE9
07600:  MOVLW  00
07602:  ADDWFC xB1,W
07604:  MOVWF  FEA
07606:  BTFSS  FEF.7
07608:  BRA    7614
....................          return (FR_RW_ERROR); 
0760A:  MOVLW  07
0760C:  MOVWF  01
0760E:  MOVLB  7
07610:  BRA    792A
07612:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
07614:  MOVLW  04
07616:  ADDWF  xB0,W
07618:  MOVWF  FE9
0761A:  MOVLW  00
0761C:  ADDWFC xB1,W
0761E:  MOVWF  FEA
07620:  MOVFF  FEF,00
07624:  MOVFF  FEC,01
07628:  MOVFF  FEC,02
0762C:  MOVFF  FEC,03
07630:  MOVF   03,W
07632:  SUBWF  xB5,W
07634:  BNC   766A
07636:  BNZ   764E
07638:  MOVF   02,W
0763A:  SUBWF  xB4,W
0763C:  BNC   766A
0763E:  BNZ   764E
07640:  MOVF   01,W
07642:  SUBWF  xB3,W
07644:  BNC   766A
07646:  BNZ   764E
07648:  MOVF   xB2,W
0764A:  SUBWF  00,W
0764C:  BC    766A
....................          ofs = fp->fsize;               // Clip offset by file size  
0764E:  MOVLW  04
07650:  ADDWF  xB0,W
07652:  MOVWF  FE9
07654:  MOVLW  00
07656:  ADDWFC xB1,W
07658:  MOVWF  FEA
0765A:  MOVFF  FEF,9B2
0765E:  MOVFF  FEC,9B3
07662:  MOVFF  FEC,9B4
07666:  MOVFF  FEC,9B5
....................       fp->fptr = ofs;  
0766A:  MOVFF  9B0,FE9
0766E:  MOVF   xB1,W
07670:  MOVWF  FEA
07672:  MOVFF  9B2,FEF
07676:  MOVFF  9B3,FEC
0767A:  MOVFF  9B4,FEC
0767E:  MOVFF  9B5,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
07682:  MOVLW  1B
07684:  ADDWF  xB0,W
07686:  MOVWF  FE9
07688:  MOVLW  00
0768A:  ADDWFC xB1,W
0768C:  MOVWF  FEA
0768E:  MOVLW  01
07690:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
07692:  MOVF   xB2,F
07694:  BNZ   76A4
07696:  MOVF   xB3,F
07698:  BNZ   76A4
0769A:  MOVF   xB4,F
0769C:  BNZ   76A4
0769E:  MOVF   xB5,F
076A0:  BTFSC  FD8.2
076A2:  BRA    7908
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
076A4:  MOVLW  01
076A6:  SUBWF  xB2,W
076A8:  MOVLW  00
076AA:  SUBWFB xB3,W
076AC:  MOVWF  xBC
076AE:  MOVLW  00
076B0:  SUBWFB xB4,W
076B2:  MOVWF  xBD
076B4:  MOVLW  00
076B6:  SUBWFB xB5,W
076B8:  MOVWF  xBE
076BA:  BCF    FD8.0
076BC:  CLRF   xB5
076BE:  RRCF   xBE,W
076C0:  MOVWF  xB4
076C2:  RRCF   xBD,W
076C4:  MOVWF  xB3
076C6:  RRCF   xBC,W
076C8:  MOVWF  xB2
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
076CA:  MOVLW  02
076CC:  MOVLB  7
076CE:  ADDWF  x12,W
076D0:  MOVWF  FE9
076D2:  MOVLW  00
076D4:  ADDWFC x13,W
076D6:  MOVWF  FEA
076D8:  MOVFF  FEF,9BA
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
076DC:  MOVLW  1B
076DE:  MOVLB  9
076E0:  ADDWF  xB0,W
076E2:  MOVWF  01
076E4:  MOVLW  00
076E6:  ADDWFC xB1,W
076E8:  MOVWF  03
076EA:  MOVFF  01,9BB
076EE:  MOVWF  xBC
076F0:  MOVFF  FEA,9BE
076F4:  MOVFF  FE9,9BD
076F8:  BSF    FD8.1
076FA:  MOVLW  09
076FC:  MOVWF  FEA
076FE:  MOVLW  BF
07700:  MOVWF  FE9
07702:  CLRF   1B
07704:  BTFSC  FF2.7
07706:  BSF    1B.7
07708:  BCF    FF2.7
0770A:  MOVFF  9B5,A4F
0770E:  MOVFF  9B4,A4E
07712:  MOVFF  9B3,A4D
07716:  MOVFF  9B2,A4C
0771A:  MOVLB  A
0771C:  CLRF   x53
0771E:  CLRF   x52
07720:  CLRF   x51
07722:  MOVFF  9BA,A50
07726:  MOVLB  0
07728:  CALL   1076
0772C:  BTFSC  1B.7
0772E:  BSF    FF2.7
07730:  MOVFF  9BF,00
07734:  MOVFF  9C0,01
07738:  MOVFF  9C1,02
0773C:  MOVFF  9C2,03
07740:  MOVFF  9BE,FEA
07744:  MOVFF  9BD,FE9
07748:  MOVF   00,W
0774A:  MOVLB  9
0774C:  SUBWF  xBA,W
0774E:  MOVWF  00
07750:  MOVLW  00
07752:  SUBFWB 01,F
07754:  SUBFWB 02,F
07756:  SUBFWB 03,F
07758:  MOVFF  9BC,FEA
0775C:  MOVFF  9BB,FE9
07760:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
07764:  BCF    FD8.1
07766:  CLRF   1B
07768:  BTFSC  FF2.7
0776A:  BSF    1B.7
0776C:  BCF    FF2.7
0776E:  MOVFF  9B5,A4F
07772:  MOVFF  9B4,A4E
07776:  MOVFF  9B3,A4D
0777A:  MOVFF  9B2,A4C
0777E:  MOVLB  A
07780:  CLRF   x53
07782:  CLRF   x52
07784:  CLRF   x51
07786:  MOVFF  9BA,A50
0778A:  MOVLB  0
0778C:  CALL   1076
07790:  BTFSC  1B.7
07792:  BSF    FF2.7
07794:  MOVFF  03,9B5
07798:  MOVFF  02,9B4
0779C:  MOVFF  01,9B3
077A0:  MOVFF  00,9B2
....................          clust = fp->org_clust;            // Seek to current cluster  
077A4:  MOVLW  08
077A6:  MOVLB  9
077A8:  ADDWF  xB0,W
077AA:  MOVWF  FE9
077AC:  MOVLW  00
077AE:  ADDWFC xB1,W
077B0:  MOVWF  FEA
077B2:  MOVFF  FEF,9B6
077B6:  MOVFF  FEC,9B7
077BA:  MOVFF  FEC,9B8
077BE:  MOVFF  FEC,9B9
....................     
....................          while (ofs--) 
077C2:  MOVFF  9B5,03
077C6:  MOVFF  9B4,02
077CA:  MOVFF  9B3,01
077CE:  MOVFF  9B2,00
077D2:  MOVLW  FF
077D4:  ADDWF  xB2,F
077D6:  BTFSS  FD8.0
077D8:  ADDWF  xB3,F
077DA:  BTFSS  FD8.0
077DC:  ADDWF  xB4,F
077DE:  BTFSS  FD8.0
077E0:  ADDWF  xB5,F
077E2:  MOVF   00,F
077E4:  BNZ   77F2
077E6:  MOVF   01,F
077E8:  BNZ   77F2
077EA:  MOVF   02,F
077EC:  BNZ   77F2
077EE:  MOVF   03,F
077F0:  BZ    781C
....................             clust = get_cluster(clust); 
077F2:  MOVFF  9B9,9FF
077F6:  MOVFF  9B8,9FE
077FA:  MOVFF  9B7,9FD
077FE:  MOVFF  9B6,9FC
07802:  MOVLB  0
07804:  CALL   5CE2
07808:  MOVFF  03,9B9
0780C:  MOVFF  02,9B8
07810:  MOVFF  01,9B7
07814:  MOVFF  00,9B6
07818:  MOVLB  9
0781A:  BRA    77C2
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
0781C:  MOVF   xB9,F
0781E:  BNZ   782E
07820:  MOVF   xB8,F
07822:  BNZ   782E
07824:  MOVF   xB7,F
07826:  BNZ   782E
07828:  MOVF   xB6,W
0782A:  SUBLW  01
0782C:  BC    786C
0782E:  MOVLW  0C
07830:  MOVLB  7
07832:  ADDWF  x12,W
07834:  MOVWF  FE9
07836:  MOVLW  00
07838:  ADDWFC x13,W
0783A:  MOVWF  FEA
0783C:  MOVFF  FEF,00
07840:  MOVFF  FEC,01
07844:  MOVFF  FEC,02
07848:  MOVFF  FEC,03
0784C:  MOVF   03,W
0784E:  MOVLB  9
07850:  SUBWF  xB9,W
07852:  BNC   786E
07854:  BNZ   786C
07856:  MOVF   02,W
07858:  SUBWF  xB8,W
0785A:  BNC   786E
0785C:  BNZ   786C
0785E:  MOVF   01,W
07860:  SUBWF  xB7,W
07862:  BNC   786E
07864:  BNZ   786C
07866:  MOVF   00,W
07868:  SUBWF  xB6,W
0786A:  BNC   786E
....................             goto fk_error; 
0786C:  BRA    7912
....................     
....................          fp->curr_clust = clust; 
0786E:  MOVLW  0C
07870:  ADDWF  xB0,W
07872:  MOVWF  FE9
07874:  MOVLW  00
07876:  ADDWFC xB1,W
07878:  MOVWF  FEA
0787A:  MOVFF  9B6,FEF
0787E:  MOVFF  9B7,FEC
07882:  MOVFF  9B8,FEC
07886:  MOVFF  9B9,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
0788A:  MOVLW  10
0788C:  ADDWF  xB0,W
0788E:  MOVWF  01
07890:  MOVLW  00
07892:  ADDWFC xB1,W
07894:  MOVWF  03
07896:  MOVFF  01,9BB
0789A:  MOVWF  xBC
0789C:  MOVFF  9B9,9F2
078A0:  MOVFF  9B8,9F1
078A4:  MOVFF  9B7,9F0
078A8:  MOVFF  9B6,9EF
078AC:  MOVLB  0
078AE:  CALL   5636
078B2:  MOVFF  03,9C0
078B6:  MOVFF  02,9BF
078BA:  MOVFF  01,9BE
078BE:  MOVFF  00,9BD
078C2:  MOVLB  9
078C4:  MOVF   xBA,W
078C6:  ADDWF  xBD,F
078C8:  MOVLW  00
078CA:  ADDWFC xBE,F
078CC:  ADDWFC xBF,F
078CE:  ADDWFC xC0,F
078D0:  MOVLW  1B
078D2:  ADDWF  xB0,W
078D4:  MOVWF  FE9
078D6:  MOVLW  00
078D8:  ADDWFC xB1,W
078DA:  MOVWF  FEA
078DC:  MOVF   FEF,W
078DE:  SUBWF  xBD,W
078E0:  MOVWF  00
078E2:  MOVLW  00
078E4:  SUBWFB xBE,W
078E6:  MOVWF  01
078E8:  MOVLW  00
078EA:  SUBWFB xBF,W
078EC:  MOVWF  02
078EE:  MOVLW  00
078F0:  SUBWFB xC0,W
078F2:  MOVFF  9BC,FEA
078F6:  MOVFF  9BB,FE9
078FA:  MOVFF  00,FEF
078FE:  MOVFF  01,FEC
07902:  MOVFF  02,FEC
07906:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
07908:  MOVLW  00
0790A:  MOVWF  01
0790C:  MOVLB  7
0790E:  BRA    792A
07910:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
07912:  MOVLW  1A
07914:  ADDWF  xB0,W
07916:  MOVWF  FE9
07918:  MOVLW  00
0791A:  ADDWFC xB1,W
0791C:  MOVWF  FEA
0791E:  MOVF   FEF,W
07920:  IORLW  80
07922:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
07924:  MOVLW  07
07926:  MOVWF  01
07928:  MOVLB  7
0792A:  MOVLB  0
0792C:  GOTO   83AE (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
080F2:  MOVLB  7
080F4:  MOVF   x12,W
080F6:  IORWF  x13,W
080F8:  BNZ   8100
....................       return (FR_NOT_ENABLED); 
080FA:  MOVLW  0B
080FC:  MOVWF  01
080FE:  BRA    82CE
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
08100:  MOVLB  0
08102:  CALL   55C6
08106:  BTFSC  01.0
08108:  BRA    811A
0810A:  MOVLB  7
0810C:  MOVFF  712,FE9
08110:  MOVFF  713,FEA
08114:  MOVF   FEF,F
08116:  BNZ   8122
08118:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
0811A:  MOVLW  09
0811C:  MOVWF  01
0811E:  MOVLB  7
08120:  BRA    82CE
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
08122:  MOVLW  1A
08124:  MOVLB  9
08126:  ADDWF  xB3,W
08128:  MOVWF  FE9
0812A:  MOVLW  00
0812C:  ADDWFC xB4,W
0812E:  MOVWF  FEA
08130:  BTFSS  FEF.5
08132:  BRA    82AA
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
08134:  MOVLW  14
08136:  ADDWF  xB3,W
08138:  MOVWF  FE9
0813A:  MOVLW  00
0813C:  ADDWFC xB4,W
0813E:  MOVWF  FEA
08140:  MOVFF  FEF,A14
08144:  MOVFF  FEC,A15
08148:  MOVFF  FEC,A16
0814C:  MOVFF  FEC,A17
08150:  MOVLB  0
08152:  CALL   5AAA
08156:  MOVF   01,F
08158:  BNZ   8164
....................          return (FR_RW_ERROR); 
0815A:  MOVLW  07
0815C:  MOVWF  01
0815E:  MOVLB  7
08160:  BRA    82CE
08162:  MOVLB  0
....................       ptr = fp->dir_ptr; 
08164:  MOVLW  18
08166:  MOVLB  9
08168:  ADDWF  xB3,W
0816A:  MOVWF  FE9
0816C:  MOVLW  00
0816E:  ADDWFC xB4,W
08170:  MOVWF  FEA
08172:  MOVFF  FEC,9B6
08176:  MOVF   FED,F
08178:  MOVFF  FEF,9B5
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
0817C:  MOVLW  0B
0817E:  ADDWF  xB5,W
08180:  MOVWF  01
08182:  MOVLW  00
08184:  ADDWFC xB6,W
08186:  MOVFF  01,FE9
0818A:  MOVWF  FEA
0818C:  MOVF   FEF,W
0818E:  IORLW  20
08190:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
08192:  MOVLW  1C
08194:  ADDWF  xB5,W
08196:  MOVWF  01
08198:  MOVLW  00
0819A:  ADDWFC xB6,W
0819C:  MOVWF  03
0819E:  MOVFF  01,9B7
081A2:  MOVWF  xB8
081A4:  MOVLW  04
081A6:  ADDWF  xB3,W
081A8:  MOVWF  FE9
081AA:  MOVLW  00
081AC:  ADDWFC xB4,W
081AE:  MOVWF  FEA
081B0:  MOVFF  FEF,00
081B4:  MOVFF  FEC,01
081B8:  MOVFF  FEC,02
081BC:  MOVFF  FEC,03
081C0:  MOVFF  9B8,FEA
081C4:  MOVFF  9B7,FE9
081C8:  MOVFF  00,FEF
081CC:  MOVFF  01,FEC
081D0:  MOVFF  02,FEC
081D4:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
081D8:  MOVLW  1A
081DA:  ADDWF  xB5,W
081DC:  MOVWF  01
081DE:  MOVLW  00
081E0:  ADDWFC xB6,W
081E2:  MOVWF  03
081E4:  MOVFF  01,9B7
081E8:  MOVWF  xB8
081EA:  MOVLW  08
081EC:  ADDWF  xB3,W
081EE:  MOVWF  FE9
081F0:  MOVLW  00
081F2:  ADDWFC xB4,W
081F4:  MOVWF  FEA
081F6:  MOVFF  FEF,00
081FA:  MOVFF  FEC,01
081FE:  MOVFF  FEC,02
08202:  MOVFF  FEC,03
08206:  MOVFF  9B8,FEA
0820A:  MOVFF  9B7,FE9
0820E:  MOVFF  00,FEF
08212:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
08216:  MOVLW  14
08218:  ADDWF  xB5,W
0821A:  MOVWF  01
0821C:  MOVLW  00
0821E:  ADDWFC xB6,W
08220:  MOVWF  03
08222:  MOVFF  01,9B7
08226:  MOVWF  xB8
08228:  MOVLW  08
0822A:  ADDWF  xB3,W
0822C:  MOVWF  FE9
0822E:  MOVLW  00
08230:  ADDWFC xB4,W
08232:  MOVWF  FEA
08234:  MOVFF  FEF,9B9
08238:  MOVFF  FEC,9BA
0823C:  MOVFF  FEC,00
08240:  MOVFF  FEC,01
08244:  MOVFF  9B8,FEA
08248:  MOVFF  9B7,FE9
0824C:  MOVFF  00,FEF
08250:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
08254:  MOVLW  16
08256:  ADDWF  xB5,W
08258:  MOVWF  01
0825A:  MOVLW  00
0825C:  ADDWFC xB6,W
0825E:  MOVWF  03
08260:  MOVFF  01,9B7
08264:  MOVWF  xB8
08266:  MOVLB  0
08268:  CALL   7010
0826C:  MOVFF  9B8,FEA
08270:  MOVFF  9B7,FE9
08274:  MOVFF  00,FEF
08278:  MOVFF  01,FEC
0827C:  MOVFF  02,FEC
08280:  MOVFF  03,FEC
....................       fs->winflag = 1; 
08284:  MOVLW  06
08286:  MOVLB  7
08288:  ADDWF  x12,W
0828A:  MOVWF  FE9
0828C:  MOVLW  00
0828E:  ADDWFC x13,W
08290:  MOVWF  FEA
08292:  MOVLW  01
08294:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
08296:  MOVLW  1A
08298:  MOVLB  9
0829A:  ADDWF  xB3,W
0829C:  MOVWF  FE9
0829E:  MOVLW  00
082A0:  ADDWFC xB4,W
082A2:  MOVWF  FEA
082A4:  MOVF   FEF,W
082A6:  ANDLW  DF
082A8:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
082AA:  MOVLB  A
082AC:  CLRF   x17
082AE:  CLRF   x16
082B0:  CLRF   x15
082B2:  CLRF   x14
082B4:  MOVLB  0
082B6:  CALL   5AAA
082BA:  MOVF   01,F
082BC:  BNZ   82C8
....................       return (FR_RW_ERROR); 
082BE:  MOVLW  07
082C0:  MOVWF  01
082C2:  MOVLB  7
082C4:  BRA    82CE
082C6:  MOVLB  0
....................  
....................    return (FR_OK); 
082C8:  MOVLW  00
082CA:  MOVWF  01
082CC:  MOVLB  7
082CE:  MOVLB  0
082D0:  GOTO   82DE (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
082D4:  MOVFF  9B1,9B4
082D8:  MOVFF  9B0,9B3
082DC:  BRA    80F2
082DE:  MOVFF  01,9B2
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
082E2:  MOVLB  9
082E4:  MOVF   xB2,F
082E6:  BNZ   8318
....................       { 
....................       fp->flag = 0; 
082E8:  MOVLW  1A
082EA:  ADDWF  xB0,W
082EC:  MOVWF  FE9
082EE:  MOVLW  00
082F0:  ADDWFC xB1,W
082F2:  MOVWF  FEA
082F4:  CLRF   FEF
....................       if (fs->files) 
082F6:  MOVLW  01
082F8:  MOVLB  7
082FA:  ADDWF  x12,W
082FC:  MOVWF  FE9
082FE:  MOVLW  00
08300:  ADDWFC x13,W
08302:  MOVWF  FEA
08304:  MOVF   FEF,F
08306:  BZ    8316
....................          fs->files--; 
08308:  MOVLW  01
0830A:  ADDWF  x12,W
0830C:  MOVWF  FE9
0830E:  MOVLW  00
08310:  ADDWFC x13,W
08312:  MOVWF  FEA
08314:  DECF   FEF,F
08316:  MOVLB  9
....................       } 
....................    return (res); 
08318:  MOVFF  9B2,01
0831C:  MOVLB  0
0831E:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0BCCE:  CALL   55D4
0BCD2:  MOVFF  01,88B
....................    if (res != FR_OK)  
0BCD6:  MOVLB  8
0BCD8:  MOVF   x8B,F
0BCDA:  BZ    BCE2
....................       return (res); 
0BCDC:  MOVFF  88B,01
0BCE0:  BRA    BF72
....................  
....................    if (disk_status() & STA_PROTECT) 
0BCE2:  MOVLB  0
0BCE4:  CALL   55C6
0BCE8:  BTFSS  01.2
0BCEA:  BRA    BCF6
....................       return (FR_WRITE_PROTECTED); 
0BCEC:  MOVLW  0A
0BCEE:  MOVWF  01
0BCF0:  MOVLB  8
0BCF2:  BRA    BF72
0BCF4:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0BCF6:  MOVLW  08
0BCF8:  MOVLB  9
0BCFA:  MOVWF  xD7
0BCFC:  MOVLW  98
0BCFE:  MOVWF  xD6
0BD00:  MOVLW  08
0BD02:  MOVWF  xD9
0BD04:  MOVLW  A6
0BD06:  MOVWF  xD8
0BD08:  MOVFF  88A,9DB
0BD0C:  MOVFF  889,9DA
0BD10:  MOVLW  08
0BD12:  MOVWF  xDD
0BD14:  MOVLW  8C
0BD16:  MOVWF  xDC
0BD18:  MOVLB  0
0BD1A:  CALL   620A
0BD1E:  MOVFF  01,88B
....................  
....................    if (res != FR_OK)  
0BD22:  MOVLB  8
0BD24:  MOVF   x8B,F
0BD26:  BZ    BD2E
....................       return (res);            // Trace failed  
0BD28:  MOVFF  88B,01
0BD2C:  BRA    BF72
....................  
....................    if (dir_ptr == NULL)  
0BD2E:  MOVF   x8C,F
0BD30:  BNZ   BD3C
0BD32:  MOVF   x8D,F
0BD34:  BNZ   BD3C
....................       return (FR_NO_FILE);      // It is a root directory  
0BD36:  MOVLW  02
0BD38:  MOVWF  01
0BD3A:  BRA    BF72
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0BD3C:  MOVLW  0B
0BD3E:  ADDWF  x8C,W
0BD40:  MOVWF  01
0BD42:  MOVLW  00
0BD44:  ADDWFC x8D,W
0BD46:  MOVWF  03
0BD48:  MOVFF  01,FE9
0BD4C:  MOVWF  FEA
0BD4E:  BTFSS  FEF.0
0BD50:  BRA    BD58
....................       return (FR_DENIED);         // It is a R/O item  
0BD52:  MOVLW  05
0BD54:  MOVWF  01
0BD56:  BRA    BF72
....................  
....................    dsect = fs->winsect; 
0BD58:  MOVLW  20
0BD5A:  MOVLB  7
0BD5C:  ADDWF  x12,W
0BD5E:  MOVWF  FE9
0BD60:  MOVLW  00
0BD62:  ADDWFC x13,W
0BD64:  MOVWF  FEA
0BD66:  MOVFF  FEF,894
0BD6A:  MOVFF  FEC,895
0BD6E:  MOVFF  FEC,896
0BD72:  MOVFF  FEC,897
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0BD76:  MOVLW  14
0BD78:  MOVLB  8
0BD7A:  ADDWF  x8C,W
0BD7C:  MOVWF  01
0BD7E:  MOVLW  00
0BD80:  ADDWFC x8D,W
0BD82:  MOVWF  03
0BD84:  MOVFF  01,FE9
0BD88:  MOVWF  FEA
0BD8A:  MOVFF  FEC,893
0BD8E:  MOVF   FED,F
0BD90:  MOVFF  FEF,8B2
0BD94:  MOVFF  8B2,892
0BD98:  CLRF   xB2
0BD9A:  CLRF   xB3
0BD9C:  MOVLW  1A
0BD9E:  ADDWF  x8C,W
0BDA0:  MOVWF  01
0BDA2:  MOVLW  00
0BDA4:  ADDWFC x8D,W
0BDA6:  MOVFF  01,FE9
0BDAA:  MOVWF  FEA
0BDAC:  MOVFF  FEC,03
0BDB0:  MOVF   FED,F
0BDB2:  MOVF   FEF,W
0BDB4:  IORWF  xB2,W
0BDB6:  MOVWF  x90
0BDB8:  MOVF   03,W
0BDBA:  IORWF  xB3,W
0BDBC:  MOVWF  x91
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BDBE:  MOVLW  0B
0BDC0:  ADDWF  x8C,W
0BDC2:  MOVWF  01
0BDC4:  MOVLW  00
0BDC6:  ADDWFC x8D,W
0BDC8:  MOVWF  03
0BDCA:  MOVFF  01,FE9
0BDCE:  MOVWF  FEA
0BDD0:  BTFSS  FEF.4
0BDD2:  BRA    BEE6
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BDD4:  MOVFF  893,89F
0BDD8:  MOVFF  892,89E
0BDDC:  MOVFF  891,89D
0BDE0:  MOVFF  890,89C
....................       dirscan.sect = clust2sect(dclust); 
0BDE4:  MOVFF  893,9F2
0BDE8:  MOVFF  892,9F1
0BDEC:  MOVFF  891,9F0
0BDF0:  MOVFF  890,9EF
0BDF4:  MOVLB  0
0BDF6:  CALL   5636
0BDFA:  MOVFF  03,8A3
0BDFE:  MOVFF  02,8A2
0BE02:  MOVFF  01,8A1
0BE06:  MOVFF  00,8A0
....................       dirscan.index = 0; 
0BE0A:  MOVLB  8
0BE0C:  CLRF   xA5
0BE0E:  CLRF   xA4
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BE10:  MOVFF  8A3,A17
0BE14:  MOVFF  8A2,A16
0BE18:  MOVFF  8A1,A15
0BE1C:  MOVFF  8A0,A14
0BE20:  MOVLB  0
0BE22:  CALL   5AAA
0BE26:  MOVF   01,F
0BE28:  BNZ   BE34
....................             return (FR_RW_ERROR); 
0BE2A:  MOVLW  07
0BE2C:  MOVWF  01
0BE2E:  MOVLB  8
0BE30:  BRA    BF72
0BE32:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BE34:  MOVLB  8
0BE36:  MOVF   xA4,W
0BE38:  ANDLW  0F
0BE3A:  MOVWF  xB2
0BE3C:  CLRF   xB3
0BE3E:  RLCF   xB2,F
0BE40:  RLCF   xB3,F
0BE42:  RLCF   xB2,F
0BE44:  RLCF   xB3,F
0BE46:  RLCF   xB2,F
0BE48:  RLCF   xB3,F
0BE4A:  RLCF   xB2,F
0BE4C:  RLCF   xB3,F
0BE4E:  RLCF   xB2,F
0BE50:  RLCF   xB3,F
0BE52:  MOVLW  E0
0BE54:  ANDWF  xB2,F
0BE56:  MOVLW  24
0BE58:  ADDWF  xB2,W
0BE5A:  MOVWF  01
0BE5C:  MOVLW  00
0BE5E:  ADDWFC xB3,W
0BE60:  MOVWF  03
0BE62:  MOVF   01,W
0BE64:  MOVLB  7
0BE66:  ADDWF  x12,W
0BE68:  MOVWF  01
0BE6A:  MOVF   x13,W
0BE6C:  ADDWFC 03,F
0BE6E:  MOVFF  01,88E
0BE72:  MOVLB  8
0BE74:  MOVFF  03,88F
....................          if (*sdir == 0) 
0BE78:  MOVFF  88F,03
0BE7C:  MOVFF  88E,FE9
0BE80:  MOVFF  88F,FEA
0BE84:  MOVF   FEF,F
0BE86:  BNZ   BE8A
....................             break; 
0BE88:  BRA    BEE6
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BE8A:  MOVFF  88F,03
0BE8E:  MOVFF  88E,FE9
0BE92:  MOVFF  88F,FEA
0BE96:  MOVF   FEF,W
0BE98:  SUBLW  E5
0BE9A:  BZ    BECA
0BE9C:  MOVFF  88F,03
0BEA0:  MOVFF  88E,FE9
0BEA4:  MOVFF  88F,FEA
0BEA8:  MOVF   FEF,W
0BEAA:  SUBLW  2E
0BEAC:  BZ    BECA
0BEAE:  MOVLW  0B
0BEB0:  ADDWF  x8E,W
0BEB2:  MOVWF  01
0BEB4:  MOVLW  00
0BEB6:  ADDWFC x8F,W
0BEB8:  MOVWF  03
0BEBA:  MOVFF  01,FE9
0BEBE:  MOVWF  FEA
0BEC0:  BTFSC  FEF.3
0BEC2:  BRA    BECA
....................             return (FR_DENIED);   // The directory is not empty  
0BEC4:  MOVLW  05
0BEC6:  MOVWF  01
0BEC8:  BRA    BF72
....................          } while (next_dir_ptr(&dirscan)); 
0BECA:  MOVLW  08
0BECC:  MOVLB  9
0BECE:  MOVWF  xE6
0BED0:  MOVLW  98
0BED2:  MOVWF  xE5
0BED4:  MOVLB  0
0BED6:  CALL   6030
0BEDA:  MOVF   01,F
0BEDC:  BTFSC  FD8.2
0BEDE:  BRA    BEE4
0BEE0:  MOVLB  8
0BEE2:  BRA    BE10
0BEE4:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BEE6:  MOVFF  897,A17
0BEEA:  MOVFF  896,A16
0BEEE:  MOVFF  895,A15
0BEF2:  MOVFF  894,A14
0BEF6:  MOVLB  0
0BEF8:  CALL   5AAA
0BEFC:  MOVF   01,F
0BEFE:  BNZ   BF0A
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BF00:  MOVLW  07
0BF02:  MOVWF  01
0BF04:  MOVLB  8
0BF06:  BRA    BF72
0BF08:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BF0A:  MOVLB  8
0BF0C:  MOVFF  88C,FE9
0BF10:  MOVFF  88D,FEA
0BF14:  MOVLW  E5
0BF16:  MOVWF  FEF
....................    fs->winflag = 1; 
0BF18:  MOVLW  06
0BF1A:  MOVLB  7
0BF1C:  ADDWF  x12,W
0BF1E:  MOVWF  FE9
0BF20:  MOVLW  00
0BF22:  ADDWFC x13,W
0BF24:  MOVWF  FEA
0BF26:  MOVLW  01
0BF28:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BF2A:  MOVFF  893,9DE
0BF2E:  MOVFF  892,9DD
0BF32:  MOVFF  891,9DC
0BF36:  MOVFF  890,9DB
0BF3A:  MOVLB  0
0BF3C:  CALL   6F6E
0BF40:  MOVF   01,F
0BF42:  BNZ   BF4E
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BF44:  MOVLW  07
0BF46:  MOVWF  01
0BF48:  MOVLB  8
0BF4A:  BRA    BF72
0BF4C:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BF4E:  MOVLB  A
0BF50:  CLRF   x17
0BF52:  CLRF   x16
0BF54:  CLRF   x15
0BF56:  CLRF   x14
0BF58:  MOVLB  0
0BF5A:  CALL   5AAA
0BF5E:  MOVF   01,F
0BF60:  BNZ   BF6C
....................       return (FR_RW_ERROR); 
0BF62:  MOVLW  07
0BF64:  MOVWF  01
0BF66:  MOVLB  8
0BF68:  BRA    BF72
0BF6A:  MOVLB  0
....................  
....................    return (FR_OK); 
0BF6C:  MOVLW  00
0BF6E:  MOVWF  01
0BF70:  MOVLB  8
0BF72:  MOVLB  0
0BF74:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
079E4:  MOVFF  9B1,9B3
079E8:  MOVFF  9B0,9B2
079EC:  MOVFF  9B3,03
079F0:  MOVLB  9
079F2:  MOVFF  9B2,FE9
079F6:  MOVFF  9B3,FEA
079FA:  MOVF   FEF,F
079FC:  BZ    7A0A
079FE:  INCF   xB2,F
07A00:  BTFSC  FD8.2
07A02:  INCF   xB3,F
07A04:  MOVLB  0
07A06:  BRA    79EC
07A08:  MOVLB  9
....................    return(sc - s); 
07A0A:  MOVF   xB0,W
07A0C:  SUBWF  xB2,W
07A0E:  MOVWF  00
07A10:  MOVF   xB1,W
07A12:  SUBWFB xB3,W
07A14:  MOVWF  03
07A16:  MOVFF  00,01
07A1A:  MOVWF  02
07A1C:  MOVLB  0
07A1E:  GOTO   8466 (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
03530:  MOVLB  4
03532:  CLRF   xE6
03534:  MOVLW  01
03536:  MOVWF  xE5
....................    rtc.year=10; 
03538:  MOVLW  0A
0353A:  MOVWF  xE4
....................    rtc.month=1; 
0353C:  MOVLW  01
0353E:  MOVWF  xE3
....................    rtc.day=1; 
03540:  MOVWF  xE2
....................    rtc.hour=0; 
03542:  CLRF   xE1
....................    rtc.min=0; 
03544:  CLRF   xE0
....................    rtc.sec=0; 
03546:  CLRF   xDF
....................    rtc.ms100=0; 
03548:  CLRF   xDE
0354A:  MOVLB  0
0354C:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
07010:  MOVLB  9
07012:  CLRF   xDD
07014:  CLRF   xDC
07016:  CLRF   xDB
07018:  MOVFF  4E4,9DA
0701C:  MOVLW  14
0701E:  ADDWF  xDA,F
07020:  MOVLW  00
07022:  ADDWFC xDB,F
07024:  ADDWFC xDC,F
07026:  ADDWFC xDD,F
07028:  BCF    FD8.0
0702A:  CLRF   xD6
0702C:  CLRF   xD7
0702E:  CLRF   xD8
07030:  RLCF   xDA,W
07032:  MOVWF  xD9
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
07034:  CLRF   xDD
07036:  CLRF   xDC
07038:  CLRF   xDB
0703A:  MOVFF  4E3,9DA
0703E:  MOVLW  0F
07040:  ANDWF  xDA,F
07042:  CLRF   xDB
07044:  CLRF   xDC
07046:  CLRF   xDD
07048:  CLRF   00
0704A:  CLRF   01
0704C:  RLCF   xDA,W
0704E:  MOVWF  02
07050:  RLCF   xDB,W
07052:  MOVWF  03
07054:  RLCF   02,F
07056:  RLCF   03,F
07058:  RLCF   02,F
0705A:  RLCF   03,F
0705C:  RLCF   02,F
0705E:  RLCF   03,F
07060:  RLCF   02,F
07062:  RLCF   03,F
07064:  MOVLW  E0
07066:  ANDWF  02,F
07068:  MOVF   00,W
0706A:  IORWF  xD6,F
0706C:  MOVF   01,W
0706E:  IORWF  xD7,F
07070:  MOVF   02,W
07072:  IORWF  xD8,F
07074:  MOVF   03,W
07076:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
07078:  CLRF   xDD
0707A:  CLRF   xDC
0707C:  CLRF   xDB
0707E:  MOVFF  4E2,9DA
07082:  MOVLW  1F
07084:  ANDWF  xDA,F
07086:  CLRF   xDB
07088:  CLRF   xDC
0708A:  CLRF   xDD
0708C:  CLRF   00
0708E:  CLRF   01
07090:  MOVF   00,W
07092:  IORWF  xD6,F
07094:  MOVF   01,W
07096:  IORWF  xD7,F
07098:  MOVF   xDA,W
0709A:  IORWF  xD8,F
0709C:  MOVF   xDB,W
0709E:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
070A0:  CLRF   xDD
070A2:  CLRF   xDC
070A4:  CLRF   xDB
070A6:  MOVFF  4E1,9DA
070AA:  MOVLW  1F
070AC:  ANDWF  xDA,F
070AE:  CLRF   xDB
070B0:  CLRF   xDC
070B2:  CLRF   xDD
070B4:  CLRF   00
070B6:  RLCF   xDA,W
070B8:  MOVWF  01
070BA:  RLCF   xDB,W
070BC:  MOVWF  02
070BE:  RLCF   xDC,W
070C0:  MOVWF  03
070C2:  RLCF   01,F
070C4:  RLCF   02,F
070C6:  RLCF   03,F
070C8:  RLCF   01,F
070CA:  RLCF   02,F
070CC:  RLCF   03,F
070CE:  MOVLW  F8
070D0:  ANDWF  01,F
070D2:  MOVF   00,W
070D4:  IORWF  xD6,F
070D6:  MOVF   01,W
070D8:  IORWF  xD7,F
070DA:  MOVF   02,W
070DC:  IORWF  xD8,F
070DE:  MOVF   03,W
070E0:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
070E2:  CLRF   xDD
070E4:  CLRF   xDC
070E6:  CLRF   xDB
070E8:  MOVFF  4E0,9DA
070EC:  MOVLW  3F
070EE:  ANDWF  xDA,F
070F0:  CLRF   xDB
070F2:  CLRF   xDC
070F4:  CLRF   xDD
070F6:  RLCF   xDA,W
070F8:  MOVWF  00
070FA:  RLCF   xDB,W
070FC:  MOVWF  01
070FE:  RLCF   xDC,W
07100:  MOVWF  02
07102:  RLCF   xDD,W
07104:  MOVWF  03
07106:  RLCF   00,F
07108:  RLCF   01,F
0710A:  RLCF   02,F
0710C:  RLCF   03,F
0710E:  RLCF   00,F
07110:  RLCF   01,F
07112:  RLCF   02,F
07114:  RLCF   03,F
07116:  RLCF   00,F
07118:  RLCF   01,F
0711A:  RLCF   02,F
0711C:  RLCF   03,F
0711E:  RLCF   00,F
07120:  RLCF   01,F
07122:  RLCF   02,F
07124:  RLCF   03,F
07126:  MOVLW  E0
07128:  ANDWF  00,F
0712A:  MOVF   00,W
0712C:  IORWF  xD6,F
0712E:  MOVF   01,W
07130:  IORWF  xD7,F
07132:  MOVF   02,W
07134:  IORWF  xD8,F
07136:  MOVF   03,W
07138:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
0713A:  CLRF   xDD
0713C:  CLRF   xDC
0713E:  CLRF   xDB
07140:  MOVFF  4DF,9DA
07144:  MOVLW  3F
07146:  ANDWF  xDA,F
07148:  CLRF   xDB
0714A:  CLRF   xDC
0714C:  CLRF   xDD
0714E:  BCF    FD8.0
07150:  RRCF   xDD,W
07152:  MOVWF  03
07154:  RRCF   xDC,W
07156:  MOVWF  02
07158:  RRCF   xDB,W
0715A:  MOVWF  01
0715C:  RRCF   xDA,W
0715E:  IORWF  xD6,F
07160:  MOVF   01,W
07162:  IORWF  xD7,F
07164:  MOVF   02,W
07166:  IORWF  xD8,F
07168:  MOVF   03,W
0716A:  IORWF  xD9,F
....................    return (work); 
0716C:  MOVFF  9D6,00
07170:  MOVFF  9D7,01
07174:  MOVFF  9D8,02
07178:  MOVFF  9D9,03
0717C:  MOVLB  0
0717E:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0BB54:  MOVLW  08
0BB56:  MOVLB  9
0BB58:  MOVWF  xB1
0BB5A:  MOVLW  8B
0BB5C:  MOVWF  xB0
0BB5E:  MOVFF  88A,9B3
0BB62:  MOVFF  889,9B2
0BB66:  MOVLW  01
0BB68:  MOVWF  xB4
0BB6A:  MOVLB  0
0BB6C:  CALL   7180
0BB70:  MOVFF  01,8A7
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0BB74:  MOVLB  8
0BB76:  MOVF   xA7,F
0BB78:  BTFSS  FD8.2
0BB7A:  BRA    BC7C
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0BB7C:  MOVLW  08
0BB7E:  MOVWF  xCD
0BB80:  MOVLW  8B
0BB82:  MOVWF  xCC
0BB84:  MOVLW  08
0BB86:  MOVWF  xCF
0BB88:  MOVLW  A8
0BB8A:  MOVWF  xCE
0BB8C:  CLRF   xD1
0BB8E:  MOVLW  20
0BB90:  MOVWF  xD0
0BB92:  MOVLW  08
0BB94:  MOVWF  xD3
0BB96:  MOVLW  CA
0BB98:  MOVWF  xD2
0BB9A:  MOVLB  0
0BB9C:  BRA    B498
0BB9E:  MOVFF  01,8A7
....................          for (i = 0; i < br; i++) 
0BBA2:  MOVLB  8
0BBA4:  CLRF   xC9
0BBA6:  CLRF   xC8
0BBA8:  MOVF   xC9,W
0BBAA:  SUBWF  xCB,W
0BBAC:  BNC   BBD8
0BBAE:  BNZ   BBB6
0BBB0:  MOVF   xCA,W
0BBB2:  SUBWF  xC8,W
0BBB4:  BC    BBD8
....................          { 
....................             putc(mesg[i]); 
0BBB6:  MOVLW  A8
0BBB8:  ADDWF  xC8,W
0BBBA:  MOVWF  FE9
0BBBC:  MOVLW  08
0BBBE:  ADDWFC xC9,W
0BBC0:  MOVWF  FEA
0BBC2:  MOVFF  FEF,8CC
0BBC6:  MOVF   xCC,W
0BBC8:  MOVLB  0
0BBCA:  CALL   AEE8
0BBCE:  MOVLB  8
0BBD0:  INCF   xC8,F
0BBD2:  BTFSC  FD8.2
0BBD4:  INCF   xC9,F
0BBD6:  BRA    BBA8
....................          } 
....................       } while ((result == FR_OK) && br); 
0BBD8:  MOVF   xA7,F
0BBDA:  BNZ   BBE2
0BBDC:  MOVF   xCA,W
0BBDE:  IORWF  xCB,W
0BBE0:  BNZ   BB7C
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0BBE2:  MOVF   xA7,F
0BBE4:  BZ    BC58
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0BBE6:  MOVLW  1A
0BBE8:  MOVWF  FF6
0BBEA:  MOVLW  0C
0BBEC:  MOVWF  FF7
0BBEE:  MOVLW  00
0BBF0:  MOVWF  FF8
0BBF2:  CLRF   1B
0BBF4:  BTFSC  FF2.7
0BBF6:  BSF    1B.7
0BBF8:  BCF    FF2.7
0BBFA:  MOVLB  0
0BBFC:  CALL   0E6E
0BC00:  BTFSC  1B.7
0BC02:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0BC04:  MOVFF  8A7,8CC
0BC08:  MOVLW  08
0BC0A:  MOVLB  8
0BC0C:  MOVWF  xCE
0BC0E:  MOVLW  A8
0BC10:  MOVWF  xCD
0BC12:  MOVLB  0
0BC14:  RCALL  B9A6
....................          printf("@FS: %s\r\n",mesg); 
0BC16:  MOVLW  30
0BC18:  MOVWF  FF6
0BC1A:  MOVLW  0C
0BC1C:  MOVWF  FF7
0BC1E:  MOVLW  00
0BC20:  MOVWF  FF8
0BC22:  CLRF   1B
0BC24:  BTFSC  FF2.7
0BC26:  BSF    1B.7
0BC28:  BCF    FF2.7
0BC2A:  MOVLW  05
0BC2C:  MOVLB  A
0BC2E:  MOVWF  x40
0BC30:  MOVLB  0
0BC32:  CALL   1044
0BC36:  BTFSC  1B.7
0BC38:  BSF    FF2.7
0BC3A:  MOVLW  08
0BC3C:  MOVWF  FEA
0BC3E:  MOVLW  A8
0BC40:  MOVWF  FE9
0BC42:  CALL   79BE
0BC46:  MOVLW  0D
0BC48:  BTFSS  F9E.4
0BC4A:  BRA    BC48
0BC4C:  MOVWF  FAD
0BC4E:  MOVLW  0A
0BC50:  BTFSS  F9E.4
0BC52:  BRA    BC50
0BC54:  MOVWF  FAD
0BC56:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0BC58:  MOVLW  08
0BC5A:  MOVLB  9
0BC5C:  MOVWF  xB1
0BC5E:  MOVLW  8B
0BC60:  MOVWF  xB0
0BC62:  MOVLB  0
0BC64:  CALL   82D4
....................       printf("\r\n");       
0BC68:  MOVLW  0D
0BC6A:  BTFSS  F9E.4
0BC6C:  BRA    BC6A
0BC6E:  MOVWF  FAD
0BC70:  MOVLW  0A
0BC72:  BTFSS  F9E.4
0BC74:  BRA    BC72
0BC76:  MOVWF  FAD
....................    } 
0BC78:  BRA    BCCC
0BC7A:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0BC7C:  MOVFF  8A7,8CC
0BC80:  MOVLW  08
0BC82:  MOVWF  xCE
0BC84:  MOVLW  A8
0BC86:  MOVWF  xCD
0BC88:  MOVLB  0
0BC8A:  RCALL  B9A6
....................       printf("@FS: %s\r\n",mesg); 
0BC8C:  MOVLW  3A
0BC8E:  MOVWF  FF6
0BC90:  MOVLW  0C
0BC92:  MOVWF  FF7
0BC94:  MOVLW  00
0BC96:  MOVWF  FF8
0BC98:  CLRF   1B
0BC9A:  BTFSC  FF2.7
0BC9C:  BSF    1B.7
0BC9E:  BCF    FF2.7
0BCA0:  MOVLW  05
0BCA2:  MOVLB  A
0BCA4:  MOVWF  x40
0BCA6:  MOVLB  0
0BCA8:  CALL   1044
0BCAC:  BTFSC  1B.7
0BCAE:  BSF    FF2.7
0BCB0:  MOVLW  08
0BCB2:  MOVWF  FEA
0BCB4:  MOVLW  A8
0BCB6:  MOVWF  FE9
0BCB8:  CALL   79BE
0BCBC:  MOVLW  0D
0BCBE:  BTFSS  F9E.4
0BCC0:  BRA    BCBE
0BCC2:  MOVWF  FAD
0BCC4:  MOVLW  0A
0BCC6:  BTFSS  F9E.4
0BCC8:  BRA    BCC6
0BCCA:  MOVWF  FAD
....................    } 
0BCCC:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04E1C:  MOVLW  44
04E1E:  MOVWF  FF6
04E20:  MOVLW  0C
04E22:  MOVWF  FF7
04E24:  MOVLW  00
04E26:  MOVWF  FF8
04E28:  CLRF   1B
04E2A:  BTFSC  FF2.7
04E2C:  BSF    1B.7
04E2E:  BCF    FF2.7
04E30:  CALL   0E6E
04E34:  BTFSC  1B.7
04E36:  BSF    FF2.7
....................    if (status & FR_OK) 
04E38:  ANDLW  00
04E3A:  BZ    4E58
....................       printf("   NoError\r\n"); 
04E3C:  MOVLW  54
04E3E:  MOVWF  FF6
04E40:  MOVLW  0C
04E42:  MOVWF  FF7
04E44:  MOVLW  00
04E46:  MOVWF  FF8
04E48:  CLRF   1B
04E4A:  BTFSC  FF2.7
04E4C:  BSF    1B.7
04E4E:  BCF    FF2.7
04E50:  CALL   0E6E
04E54:  BTFSC  1B.7
04E56:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04E58:  MOVLB  8
04E5A:  BTFSS  x8A.0
04E5C:  BRA    4E7E
....................       printf("   Media Not Ready\r\n"); 
04E5E:  MOVLW  62
04E60:  MOVWF  FF6
04E62:  MOVLW  0C
04E64:  MOVWF  FF7
04E66:  MOVLW  00
04E68:  MOVWF  FF8
04E6A:  CLRF   1B
04E6C:  BTFSC  FF2.7
04E6E:  BSF    1B.7
04E70:  BCF    FF2.7
04E72:  MOVLB  0
04E74:  CALL   0E6E
04E78:  BTFSC  1B.7
04E7A:  BSF    FF2.7
04E7C:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04E7E:  BTFSS  x8A.1
04E80:  BRA    4EA2
....................       printf("   File Not Found\r\n"); 
04E82:  MOVLW  78
04E84:  MOVWF  FF6
04E86:  MOVLW  0C
04E88:  MOVWF  FF7
04E8A:  MOVLW  00
04E8C:  MOVWF  FF8
04E8E:  CLRF   1B
04E90:  BTFSC  FF2.7
04E92:  BSF    1B.7
04E94:  BCF    FF2.7
04E96:  MOVLB  0
04E98:  CALL   0E6E
04E9C:  BTFSC  1B.7
04E9E:  BSF    FF2.7
04EA0:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04EA2:  MOVF   x8A,W
04EA4:  ANDLW  03
04EA6:  BZ    4EC8
....................       printf("   Invalid Path\r\n"); 
04EA8:  MOVLW  8C
04EAA:  MOVWF  FF6
04EAC:  MOVLW  0C
04EAE:  MOVWF  FF7
04EB0:  MOVLW  00
04EB2:  MOVWF  FF8
04EB4:  CLRF   1B
04EB6:  BTFSC  FF2.7
04EB8:  BSF    1B.7
04EBA:  BCF    FF2.7
04EBC:  MOVLB  0
04EBE:  CALL   0E6E
04EC2:  BTFSC  1B.7
04EC4:  BSF    FF2.7
04EC6:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04EC8:  BTFSS  x8A.2
04ECA:  BRA    4EEC
....................       printf("   Invalid Name\r\n"); 
04ECC:  MOVLW  9E
04ECE:  MOVWF  FF6
04ED0:  MOVLW  0C
04ED2:  MOVWF  FF7
04ED4:  MOVLW  00
04ED6:  MOVWF  FF8
04ED8:  CLRF   1B
04EDA:  BTFSC  FF2.7
04EDC:  BSF    1B.7
04EDE:  BCF    FF2.7
04EE0:  MOVLB  0
04EE2:  CALL   0E6E
04EE6:  BTFSC  1B.7
04EE8:  BSF    FF2.7
04EEA:  MOVLB  8
....................    if (status & FR_DENIED) 
04EEC:  MOVF   x8A,W
04EEE:  ANDLW  05
04EF0:  BZ    4F12
....................       printf("   Access Denied\r\n"); 
04EF2:  MOVLW  B0
04EF4:  MOVWF  FF6
04EF6:  MOVLW  0C
04EF8:  MOVWF  FF7
04EFA:  MOVLW  00
04EFC:  MOVWF  FF8
04EFE:  CLRF   1B
04F00:  BTFSC  FF2.7
04F02:  BSF    1B.7
04F04:  BCF    FF2.7
04F06:  MOVLB  0
04F08:  CALL   0E6E
04F0C:  BTFSC  1B.7
04F0E:  BSF    FF2.7
04F10:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04F12:  MOVF   x8A,W
04F14:  ANDLW  06
04F16:  BZ    4F38
....................       printf("   Disk Full\r\n"); 
04F18:  MOVLW  C4
04F1A:  MOVWF  FF6
04F1C:  MOVLW  0C
04F1E:  MOVWF  FF7
04F20:  MOVLW  00
04F22:  MOVWF  FF8
04F24:  CLRF   1B
04F26:  BTFSC  FF2.7
04F28:  BSF    1B.7
04F2A:  BCF    FF2.7
04F2C:  MOVLB  0
04F2E:  CALL   0E6E
04F32:  BTFSC  1B.7
04F34:  BSF    FF2.7
04F36:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04F38:  MOVF   x8A,W
04F3A:  ANDLW  07
04F3C:  BZ    4F5E
....................       printf("   Read/Write Error\r\n"); 
04F3E:  MOVLW  D4
04F40:  MOVWF  FF6
04F42:  MOVLW  0C
04F44:  MOVWF  FF7
04F46:  MOVLW  00
04F48:  MOVWF  FF8
04F4A:  CLRF   1B
04F4C:  BTFSC  FF2.7
04F4E:  BSF    1B.7
04F50:  BCF    FF2.7
04F52:  MOVLB  0
04F54:  CALL   0E6E
04F58:  BTFSC  1B.7
04F5A:  BSF    FF2.7
04F5C:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04F5E:  MOVF   x8A,W
04F60:  ANDLW  09
04F62:  BZ    4F84
....................       printf("   Incorrect Media Change\r\n"); 
04F64:  MOVLW  EA
04F66:  MOVWF  FF6
04F68:  MOVLW  0C
04F6A:  MOVWF  FF7
04F6C:  MOVLW  00
04F6E:  MOVWF  FF8
04F70:  CLRF   1B
04F72:  BTFSC  FF2.7
04F74:  BSF    1B.7
04F76:  BCF    FF2.7
04F78:  MOVLB  0
04F7A:  CALL   0E6E
04F7E:  BTFSC  1B.7
04F80:  BSF    FF2.7
04F82:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04F84:  MOVF   x8A,W
04F86:  ANDLW  0A
04F88:  BZ    4FAA
....................       printf("   Write Protected\r\n"); 
04F8A:  MOVLW  06
04F8C:  MOVWF  FF6
04F8E:  MOVLW  0D
04F90:  MOVWF  FF7
04F92:  MOVLW  00
04F94:  MOVWF  FF8
04F96:  CLRF   1B
04F98:  BTFSC  FF2.7
04F9A:  BSF    1B.7
04F9C:  BCF    FF2.7
04F9E:  MOVLB  0
04FA0:  CALL   0E6E
04FA4:  BTFSC  1B.7
04FA6:  BSF    FF2.7
04FA8:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04FAA:  MOVF   x8A,W
04FAC:  ANDLW  0B
04FAE:  BZ    4FD0
....................       printf("   Not Enabled\r\n"); 
04FB0:  MOVLW  1C
04FB2:  MOVWF  FF6
04FB4:  MOVLW  0D
04FB6:  MOVWF  FF7
04FB8:  MOVLW  00
04FBA:  MOVWF  FF8
04FBC:  CLRF   1B
04FBE:  BTFSC  FF2.7
04FC0:  BSF    1B.7
04FC2:  BCF    FF2.7
04FC4:  MOVLB  0
04FC6:  CALL   0E6E
04FCA:  BTFSC  1B.7
04FCC:  BSF    FF2.7
04FCE:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04FD0:  MOVF   x8A,W
04FD2:  ANDLW  0C
04FD4:  BZ    4FF6
....................       printf("   No File System\r\n"); 
04FD6:  MOVLW  2E
04FD8:  MOVWF  FF6
04FDA:  MOVLW  0D
04FDC:  MOVWF  FF7
04FDE:  MOVLW  00
04FE0:  MOVWF  FF8
04FE2:  CLRF   1B
04FE4:  BTFSC  FF2.7
04FE6:  BSF    1B.7
04FE8:  BCF    FF2.7
04FEA:  MOVLB  0
04FEC:  CALL   0E6E
04FF0:  BTFSC  1B.7
04FF2:  BSF    FF2.7
04FF4:  MOVLB  8
04FF6:  MOVLB  0
04FF8:  GOTO   5082 (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
08320:  MOVLW  09
08322:  MOVWF  FEA
08324:  MOVLW  10
08326:  MOVWF  FE9
08328:  CLRF   00
0832A:  CLRF   02
0832C:  MOVLW  A0
0832E:  MOVWF  01
08330:  CALL   354E
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
08334:  MOVLW  08
08336:  MOVLB  9
08338:  MOVWF  xB1
0833A:  MOVLW  EF
0833C:  MOVWF  xB0
0833E:  MOVFF  8EE,9B3
08342:  MOVFF  8ED,9B2
08346:  MOVLW  12
08348:  MOVWF  xB4
0834A:  MOVLB  0
0834C:  CALL   7180
08350:  MOVFF  01,90B
....................    if (result) 
08354:  MOVLB  9
08356:  MOVF   x0B,F
08358:  BZ    837C
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
0835A:  MOVLW  42
0835C:  MOVWF  FF6
0835E:  MOVLW  0D
08360:  MOVWF  FF7
08362:  MOVLW  00
08364:  MOVWF  FF8
08366:  CLRF   1B
08368:  BTFSC  FF2.7
0836A:  BSF    1B.7
0836C:  BCF    FF2.7
0836E:  MOVLB  0
08370:  CALL   0E6E
08374:  BTFSC  1B.7
08376:  BSF    FF2.7
....................    } 
08378:  BRA    84F8
0837A:  MOVLB  9
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
0837C:  MOVLB  8
0837E:  MOVF   xF3,F
08380:  BNZ   838E
08382:  MOVF   xF4,F
08384:  BNZ   838E
08386:  MOVF   xF5,F
08388:  BNZ   838E
0838A:  MOVF   xF6,F
0838C:  BZ    83B4
....................          result = f_lseek(&fdst, fdst.fsize);  
0838E:  MOVLW  08
08390:  MOVLB  9
08392:  MOVWF  xB1
08394:  MOVLW  EF
08396:  MOVWF  xB0
08398:  MOVFF  8F6,9B5
0839C:  MOVFF  8F5,9B4
083A0:  MOVFF  8F4,9B3
083A4:  MOVFF  8F3,9B2
083A8:  MOVLB  0
083AA:  GOTO   75C8
083AE:  MOVFF  01,90B
083B2:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
083B4:  MOVLB  0
083B6:  MOVF   x66,F
083B8:  BNZ   83D6
083BA:  MOVLW  09
083BC:  MOVLB  9
083BE:  MOVWF  xB1
083C0:  MOVLW  10
083C2:  MOVWF  xB0
083C4:  CLRF   xB3
083C6:  MOVLW  67
083C8:  MOVWF  xB2
083CA:  CLRF   xB5
083CC:  MOVLW  9F
083CE:  MOVWF  xB4
083D0:  MOVLB  0
083D2:  CALL   7930
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
083D6:  DECFSZ x66,W
083D8:  BRA    83F8
083DA:  MOVLW  09
083DC:  MOVLB  9
083DE:  MOVWF  xB1
083E0:  MOVLW  10
083E2:  MOVWF  xB0
083E4:  MOVLW  01
083E6:  MOVWF  xB3
083E8:  MOVLW  07
083EA:  MOVWF  xB2
083EC:  CLRF   xB5
083EE:  MOVLW  9F
083F0:  MOVWF  xB4
083F2:  MOVLB  0
083F4:  CALL   7930
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
083F8:  MOVF   20,F
083FA:  BNZ   8402
083FC:  MOVF   1F,W
083FE:  SUBLW  04
08400:  BC    8456
08402:  MOVLW  62
08404:  MOVWF  FF6
08406:  MOVLW  0D
08408:  MOVWF  FF7
0840A:  MOVLW  00
0840C:  MOVWF  FF8
0840E:  CLRF   1B
08410:  BTFSC  FF2.7
08412:  BSF    1B.7
08414:  BCF    FF2.7
08416:  MOVLW  0E
08418:  MOVLB  A
0841A:  MOVWF  x40
0841C:  MOVLB  0
0841E:  CALL   1044
08422:  BTFSC  1B.7
08424:  BSF    FF2.7
08426:  MOVLW  09
08428:  MOVWF  FEA
0842A:  MOVLW  10
0842C:  MOVWF  FE9
0842E:  CALL   79BE
08432:  MOVLW  72
08434:  MOVWF  FF6
08436:  MOVLW  0D
08438:  MOVWF  FF7
0843A:  MOVLW  00
0843C:  MOVWF  FF8
0843E:  CLRF   1B
08440:  BTFSC  FF2.7
08442:  BSF    1B.7
08444:  BCF    FF2.7
08446:  MOVLW  03
08448:  MOVLB  A
0844A:  MOVWF  x40
0844C:  MOVLB  0
0844E:  CALL   1044
08452:  BTFSC  1B.7
08454:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
08456:  MOVLW  09
08458:  MOVLB  9
0845A:  MOVWF  xB1
0845C:  MOVLW  10
0845E:  MOVWF  xB0
08460:  MOVLB  0
08462:  GOTO   79E4
08466:  MOVFF  02,90D
0846A:  MOVFF  01,90C
....................       result = f_write(&fdst, mesg, btw, &bw); 
0846E:  MOVLW  08
08470:  MOVLB  9
08472:  MOVWF  xB1
08474:  MOVLW  EF
08476:  MOVWF  xB0
08478:  MOVLW  09
0847A:  MOVWF  xB3
0847C:  MOVLW  10
0847E:  MOVWF  xB2
08480:  MOVFF  90D,9B5
08484:  MOVFF  90C,9B4
08488:  MOVLW  09
0848A:  MOVWF  xB7
0848C:  MOVLW  0E
0848E:  MOVWF  xB6
08490:  MOVLB  0
08492:  GOTO   7A22
08496:  MOVFF  01,90B
....................       if (result) 
0849A:  MOVLB  9
0849C:  MOVF   x0B,F
0849E:  BZ    84C2
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
084A0:  MOVLW  76
084A2:  MOVWF  FF6
084A4:  MOVLW  0D
084A6:  MOVWF  FF7
084A8:  MOVLW  00
084AA:  MOVWF  FF8
084AC:  CLRF   1B
084AE:  BTFSC  FF2.7
084B0:  BSF    1B.7
084B2:  BCF    FF2.7
084B4:  MOVLB  0
084B6:  CALL   0E6E
084BA:  BTFSC  1B.7
084BC:  BSF    FF2.7
....................       } 
084BE:  BRA    84EA
084C0:  MOVLB  9
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
084C2:  MOVF   20,F
084C4:  BNZ   84CC
084C6:  MOVF   1F,W
084C8:  SUBLW  04
084CA:  BC    84EC
084CC:  MOVLW  8A
084CE:  MOVWF  FF6
084D0:  MOVLW  0D
084D2:  MOVWF  FF7
084D4:  MOVLW  00
084D6:  MOVWF  FF8
084D8:  CLRF   1B
084DA:  BTFSC  FF2.7
084DC:  BSF    1B.7
084DE:  BCF    FF2.7
084E0:  MOVLB  0
084E2:  CALL   0E6E
084E6:  BTFSC  1B.7
084E8:  BSF    FF2.7
084EA:  MOVLB  9
....................       } 
....................  
....................       f_close(&fdst); 
084EC:  MOVLW  08
084EE:  MOVWF  xB1
084F0:  MOVLW  EF
084F2:  MOVWF  xB0
084F4:  MOVLB  0
084F6:  RCALL  82D4
....................    } 
....................  
....................    return (result); 
084F8:  MOVLB  9
084FA:  MOVFF  90B,01
084FE:  MOVLB  0
08500:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
17BDC:  CLRF   1B
17BDE:  BTFSC  FF2.7
17BE0:  BSF    1B.7
17BE2:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
17BE4:  MOVFF  887,A42
17BE8:  MOVLW  0A
17BEA:  MOVLB  A
17BEC:  MOVWF  x43
17BEE:  MOVLB  0
17BF0:  CALL   0F9A
17BF4:  BTFSC  1B.7
17BF6:  BSF    FF2.7
17BF8:  MOVFF  01,888
....................    nibl=data-(nibh*10); 
17BFC:  MOVLB  8
17BFE:  MOVF   x88,W
17C00:  MULLW  0A
17C02:  MOVF   FF3,W
17C04:  SUBWF  x87,W
17C06:  MOVWF  x89
....................  
....................    return((nibh<<4)|nibl); 
17C08:  SWAPF  x88,W
17C0A:  MOVWF  00
17C0C:  MOVLW  F0
17C0E:  ANDWF  00,F
17C10:  MOVF   00,W
17C12:  IORWF  x89,W
17C14:  MOVWF  01
17C16:  MOVLB  0
17C18:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
0333A:  MOVFF  8EE,8EF
....................    data=(i>>4)*10; 
0333E:  MOVLB  8
03340:  SWAPF  xEF,W
03342:  MOVWF  00
03344:  MOVLW  0F
03346:  ANDWF  00,F
03348:  MOVF   00,W
0334A:  MULLW  0A
0334C:  MOVFF  FF3,8EE
....................    data=data+(i<<4>>4); 
03350:  SWAPF  xEF,W
03352:  MOVWF  00
03354:  MOVLW  F0
03356:  ANDWF  00,F
03358:  MOVF   00,W
0335A:  SWAPF  00,F
0335C:  MOVLW  0F
0335E:  ANDWF  00,F
03360:  MOVF   00,W
03362:  ADDWF  xEE,F
....................  
....................    return data; 
03364:  MOVFF  8EE,01
03368:  MOVLB  0
0336A:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
034DA:  MOVLB  8
034DC:  CLRF   xCB
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
034DE:  BCF    FC6.5
034E0:  MOVLW  21
034E2:  MOVWF  FC6
034E4:  MOVLW  40
034E6:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
034E8:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
034EA:  MOVF   FC9,W
034EC:  MOVLW  0C
034EE:  MOVWF  FC9
034F0:  RRCF   FC7,W
034F2:  BNC   34F0
034F4:  MOVFF  FC9,8CB
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
034F8:  MOVF   FC9,W
034FA:  MOVFF  8CB,FC9
034FE:  RRCF   FC7,W
03500:  BNC   34FE
03502:  MOVFF  FC9,730
....................    output_bit(RTC_CS, DISABLE); 
03506:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
03508:  MOVLB  7
0350A:  BCF    x30.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
0350C:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
0350E:  MOVF   FC9,W
03510:  MOVLW  8C
03512:  MOVWF  FC9
03514:  RRCF   FC7,W
03516:  BNC   3514
03518:  MOVFF  FC9,8CB
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
0351C:  MOVF   FC9,W
0351E:  MOVFF  730,FC9
03522:  RRCF   FC7,W
03524:  BNC   3522
03526:  MOVFF  FC9,8CB
....................    output_bit(RTC_CS, DISABLE); 
0352A:  BSF    F91.0
0352C:  MOVLB  0
0352E:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0E2BA:  MOVLW  1A
0E2BC:  MOVLB  8
0E2BE:  MOVWF  x97
0E2C0:  MOVLB  0
0E2C2:  CALL   29F2
0E2C6:  MOVFF  01,4F
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0E2CA:  MOVF   4F,F
0E2CC:  BNZ   E33A
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0E2CE:  MOVLW  98
0E2D0:  MOVWF  FF6
0E2D2:  MOVLW  0D
0E2D4:  MOVWF  FF7
0E2D6:  MOVLW  00
0E2D8:  MOVWF  FF8
0E2DA:  CLRF   1B
0E2DC:  BTFSC  FF2.7
0E2DE:  BSF    1B.7
0E2E0:  BCF    FF2.7
0E2E2:  MOVLW  05
0E2E4:  MOVLB  A
0E2E6:  MOVWF  x40
0E2E8:  MOVLB  0
0E2EA:  CALL   1044
0E2EE:  BTFSC  1B.7
0E2F0:  BSF    FF2.7
0E2F2:  CLRF   1B
0E2F4:  BTFSC  FF2.7
0E2F6:  BSF    1B.7
0E2F8:  BCF    FF2.7
0E2FA:  MOVFF  72A,A40
0E2FE:  MOVLW  01
0E300:  MOVLB  A
0E302:  MOVWF  x41
0E304:  MOVLB  0
0E306:  CALL   0FC6
0E30A:  BTFSC  1B.7
0E30C:  BSF    FF2.7
0E30E:  MOVLW  2F
0E310:  BTFSS  F9E.4
0E312:  BRA    E310
0E314:  MOVWF  FAD
0E316:  CLRF   1B
0E318:  BTFSC  FF2.7
0E31A:  BSF    1B.7
0E31C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0E31E:  MOVFF  729,A40
0E322:  MOVLW  01
0E324:  MOVLB  A
0E326:  MOVWF  x41
0E328:  MOVLB  0
0E32A:  CALL   0FC6
0E32E:  BTFSC  1B.7
0E330:  BSF    FF2.7
0E332:  MOVLW  2F
0E334:  BTFSS  F9E.4
0E336:  BRA    E334
0E338:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0E33A:  DECFSZ 4F,W
0E33C:  BRA    E3AA
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0E33E:  MOVLW  A4
0E340:  MOVWF  FF6
0E342:  MOVLW  0D
0E344:  MOVWF  FF7
0E346:  MOVLW  00
0E348:  MOVWF  FF8
0E34A:  CLRF   1B
0E34C:  BTFSC  FF2.7
0E34E:  BSF    1B.7
0E350:  BCF    FF2.7
0E352:  MOVLW  05
0E354:  MOVLB  A
0E356:  MOVWF  x40
0E358:  MOVLB  0
0E35A:  CALL   1044
0E35E:  BTFSC  1B.7
0E360:  BSF    FF2.7
0E362:  CLRF   1B
0E364:  BTFSC  FF2.7
0E366:  BSF    1B.7
0E368:  BCF    FF2.7
0E36A:  MOVFF  729,A40
0E36E:  MOVLW  01
0E370:  MOVLB  A
0E372:  MOVWF  x41
0E374:  MOVLB  0
0E376:  CALL   0FC6
0E37A:  BTFSC  1B.7
0E37C:  BSF    FF2.7
0E37E:  MOVLW  2F
0E380:  BTFSS  F9E.4
0E382:  BRA    E380
0E384:  MOVWF  FAD
0E386:  CLRF   1B
0E388:  BTFSC  FF2.7
0E38A:  BSF    1B.7
0E38C:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0E38E:  MOVFF  72A,A40
0E392:  MOVLW  01
0E394:  MOVLB  A
0E396:  MOVWF  x41
0E398:  MOVLB  0
0E39A:  CALL   0FC6
0E39E:  BTFSC  1B.7
0E3A0:  BSF    FF2.7
0E3A2:  MOVLW  2F
0E3A4:  BTFSS  F9E.4
0E3A6:  BRA    E3A4
0E3A8:  MOVWF  FAD
0E3AA:  CLRF   1B
0E3AC:  BTFSC  FF2.7
0E3AE:  BSF    1B.7
0E3B0:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0E3B2:  MOVFF  72B,A40
0E3B6:  MOVLW  01
0E3B8:  MOVLB  A
0E3BA:  MOVWF  x41
0E3BC:  MOVLB  0
0E3BE:  CALL   0FC6
0E3C2:  BTFSC  1B.7
0E3C4:  BSF    FF2.7
0E3C6:  MOVLW  20
0E3C8:  BTFSS  F9E.4
0E3CA:  BRA    E3C8
0E3CC:  MOVWF  FAD
0E3CE:  CLRF   1B
0E3D0:  BTFSC  FF2.7
0E3D2:  BSF    1B.7
0E3D4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E3D6:  MOVFF  727,A40
0E3DA:  MOVLW  01
0E3DC:  MOVLB  A
0E3DE:  MOVWF  x41
0E3E0:  MOVLB  0
0E3E2:  CALL   0FC6
0E3E6:  BTFSC  1B.7
0E3E8:  BSF    FF2.7
0E3EA:  MOVLW  3A
0E3EC:  BTFSS  F9E.4
0E3EE:  BRA    E3EC
0E3F0:  MOVWF  FAD
0E3F2:  CLRF   1B
0E3F4:  BTFSC  FF2.7
0E3F6:  BSF    1B.7
0E3F8:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E3FA:  MOVFF  726,A40
0E3FE:  MOVLW  01
0E400:  MOVLB  A
0E402:  MOVWF  x41
0E404:  MOVLB  0
0E406:  CALL   0FC6
0E40A:  BTFSC  1B.7
0E40C:  BSF    FF2.7
0E40E:  MOVLW  3A
0E410:  BTFSS  F9E.4
0E412:  BRA    E410
0E414:  MOVWF  FAD
0E416:  CLRF   1B
0E418:  BTFSC  FF2.7
0E41A:  BSF    1B.7
0E41C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E41E:  MOVFF  725,A40
0E422:  MOVLW  01
0E424:  MOVLB  A
0E426:  MOVWF  x41
0E428:  MOVLB  0
0E42A:  CALL   0FC6
0E42E:  BTFSC  1B.7
0E430:  BSF    FF2.7
0E432:  MOVLW  0A
0E434:  BTFSS  F9E.4
0E436:  BRA    E434
0E438:  MOVWF  FAD
0E43A:  MOVLW  0D
0E43C:  BTFSS  F9E.4
0E43E:  BRA    E43C
0E440:  MOVWF  FAD
0E442:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0336C:  MOVLB  8
0336E:  CLRF   xED
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
03370:  BCF    FC6.5
03372:  MOVLW  21
03374:  MOVWF  FC6
03376:  MOVLW  40
03378:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0337A:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
0337C:  MOVF   FC9,W
0337E:  CLRF   FC9
03380:  RRCF   FC7,W
03382:  BNC   3380
03384:  MOVFF  FC9,8ED
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
03388:  MOVF   FC9,W
0338A:  MOVFF  8ED,FC9
0338E:  RRCF   FC7,W
03390:  BNC   338E
03392:  MOVFF  FC9,72C
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
03396:  MOVF   FC9,W
03398:  MOVFF  8ED,FC9
0339C:  RRCF   FC7,W
0339E:  BNC   339C
033A0:  MOVFF  FC9,725
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
033A4:  MOVF   FC9,W
033A6:  MOVFF  8ED,FC9
033AA:  RRCF   FC7,W
033AC:  BNC   33AA
033AE:  MOVFF  FC9,726
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
033B2:  MOVF   FC9,W
033B4:  MOVFF  8ED,FC9
033B8:  RRCF   FC7,W
033BA:  BNC   33B8
033BC:  MOVFF  FC9,727
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
033C0:  MOVF   FC9,W
033C2:  MOVFF  8ED,FC9
033C6:  RRCF   FC7,W
033C8:  BNC   33C6
033CA:  MOVFF  FC9,728
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
033CE:  MOVF   FC9,W
033D0:  MOVFF  8ED,FC9
033D4:  RRCF   FC7,W
033D6:  BNC   33D4
033D8:  MOVFF  FC9,729
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
033DC:  MOVF   FC9,W
033DE:  MOVFF  8ED,FC9
033E2:  RRCF   FC7,W
033E4:  BNC   33E2
033E6:  MOVFF  FC9,72A
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
033EA:  MOVF   FC9,W
033EC:  MOVFF  8ED,FC9
033F0:  RRCF   FC7,W
033F2:  BNC   33F0
033F4:  MOVFF  FC9,72B
....................    output_bit(RTC_CS, DISABLE); 
033F8:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
033FA:  MOVFF  725,8EE
033FE:  MOVLB  0
03400:  RCALL  333A
03402:  MOVFF  01,725
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
03406:  MOVFF  726,8EE
0340A:  RCALL  333A
0340C:  MOVFF  01,726
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
03410:  MOVFF  727,8EE
03414:  RCALL  333A
03416:  MOVFF  01,727
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
0341A:  MOVFF  729,8EE
0341E:  RCALL  333A
03420:  MOVFF  01,729
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
03424:  MOVFF  72A,8EE
03428:  RCALL  333A
0342A:  MOVFF  01,72A
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
0342E:  MOVFF  72B,8EE
03432:  RCALL  333A
03434:  MOVFF  01,72B
03438:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DF8:  MOVLB  A
00DFA:  CLRF   x37
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DFC:  BCF    FC6.5
00DFE:  MOVLW  21
00E00:  MOVWF  FC6
00E02:  MOVLW  40
00E04:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00E06:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00E08:  MOVF   FC9,W
00E0A:  MOVLW  0F
00E0C:  MOVWF  FC9
00E0E:  RRCF   FC7,W
00E10:  BNC   0E0E
00E12:  MOVFF  FC9,A37
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00E16:  MOVF   FC9,W
00E18:  MOVFF  A37,FC9
00E1C:  RRCF   FC7,W
00E1E:  BNC   0E1C
00E20:  MOVFF  FC9,733
....................    spi_read(0x00); 
00E24:  MOVF   FC9,W
00E26:  CLRF   FC9
00E28:  RRCF   FC7,W
00E2A:  BNC   0E28
....................    output_bit(RTC_CS, DISABLE); 
00E2C:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00E2E:  BCF    4D.2
00E30:  MOVLB  0
00E32:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E51A:  MOVF   4F,F
0E51C:  BNZ   E58A
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E51E:  MOVLW  B0
0E520:  MOVWF  FF6
0E522:  MOVLW  0D
0E524:  MOVWF  FF7
0E526:  MOVLW  00
0E528:  MOVWF  FF8
0E52A:  CLRF   1B
0E52C:  BTFSC  FF2.7
0E52E:  BSF    1B.7
0E530:  BCF    FF2.7
0E532:  MOVLW  05
0E534:  MOVLB  A
0E536:  MOVWF  x40
0E538:  MOVLB  0
0E53A:  CALL   1044
0E53E:  BTFSC  1B.7
0E540:  BSF    FF2.7
0E542:  CLRF   1B
0E544:  BTFSC  FF2.7
0E546:  BSF    1B.7
0E548:  BCF    FF2.7
0E54A:  MOVFF  72E,A40
0E54E:  MOVLW  01
0E550:  MOVLB  A
0E552:  MOVWF  x41
0E554:  MOVLB  0
0E556:  CALL   0FC6
0E55A:  BTFSC  1B.7
0E55C:  BSF    FF2.7
0E55E:  MOVLW  2F
0E560:  BTFSS  F9E.4
0E562:  BRA    E560
0E564:  MOVWF  FAD
0E566:  CLRF   1B
0E568:  BTFSC  FF2.7
0E56A:  BSF    1B.7
0E56C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E56E:  MOVFF  72F,A40
0E572:  MOVLW  01
0E574:  MOVLB  A
0E576:  MOVWF  x41
0E578:  MOVLB  0
0E57A:  CALL   0FC6
0E57E:  BTFSC  1B.7
0E580:  BSF    FF2.7
0E582:  MOVLW  2F
0E584:  BTFSS  F9E.4
0E586:  BRA    E584
0E588:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E58A:  DECFSZ 4F,W
0E58C:  BRA    E5FA
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E58E:  MOVLW  BC
0E590:  MOVWF  FF6
0E592:  MOVLW  0D
0E594:  MOVWF  FF7
0E596:  MOVLW  00
0E598:  MOVWF  FF8
0E59A:  CLRF   1B
0E59C:  BTFSC  FF2.7
0E59E:  BSF    1B.7
0E5A0:  BCF    FF2.7
0E5A2:  MOVLW  05
0E5A4:  MOVLB  A
0E5A6:  MOVWF  x40
0E5A8:  MOVLB  0
0E5AA:  CALL   1044
0E5AE:  BTFSC  1B.7
0E5B0:  BSF    FF2.7
0E5B2:  CLRF   1B
0E5B4:  BTFSC  FF2.7
0E5B6:  BSF    1B.7
0E5B8:  BCF    FF2.7
0E5BA:  MOVFF  72F,A40
0E5BE:  MOVLW  01
0E5C0:  MOVLB  A
0E5C2:  MOVWF  x41
0E5C4:  MOVLB  0
0E5C6:  CALL   0FC6
0E5CA:  BTFSC  1B.7
0E5CC:  BSF    FF2.7
0E5CE:  MOVLW  2F
0E5D0:  BTFSS  F9E.4
0E5D2:  BRA    E5D0
0E5D4:  MOVWF  FAD
0E5D6:  CLRF   1B
0E5D8:  BTFSC  FF2.7
0E5DA:  BSF    1B.7
0E5DC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E5DE:  MOVFF  72E,A40
0E5E2:  MOVLW  01
0E5E4:  MOVLB  A
0E5E6:  MOVWF  x41
0E5E8:  MOVLB  0
0E5EA:  CALL   0FC6
0E5EE:  BTFSC  1B.7
0E5F0:  BSF    FF2.7
0E5F2:  MOVLW  2F
0E5F4:  BTFSS  F9E.4
0E5F6:  BRA    E5F4
0E5F8:  MOVWF  FAD
0E5FA:  CLRF   1B
0E5FC:  BTFSC  FF2.7
0E5FE:  BSF    1B.7
0E600:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E602:  MOVFF  72D,A40
0E606:  MOVLW  01
0E608:  MOVLB  A
0E60A:  MOVWF  x41
0E60C:  MOVLB  0
0E60E:  CALL   0FC6
0E612:  BTFSC  1B.7
0E614:  BSF    FF2.7
0E616:  MOVLW  20
0E618:  BTFSS  F9E.4
0E61A:  BRA    E618
0E61C:  MOVWF  FAD
0E61E:  CLRF   1B
0E620:  BTFSC  FF2.7
0E622:  BSF    1B.7
0E624:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E626:  MOVFF  730,A40
0E62A:  MOVLW  01
0E62C:  MOVLB  A
0E62E:  MOVWF  x41
0E630:  MOVLB  0
0E632:  CALL   0FC6
0E636:  BTFSC  1B.7
0E638:  BSF    FF2.7
0E63A:  MOVLW  3A
0E63C:  BTFSS  F9E.4
0E63E:  BRA    E63C
0E640:  MOVWF  FAD
0E642:  CLRF   1B
0E644:  BTFSC  FF2.7
0E646:  BSF    1B.7
0E648:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E64A:  MOVFF  731,A40
0E64E:  MOVLW  01
0E650:  MOVLB  A
0E652:  MOVWF  x41
0E654:  MOVLB  0
0E656:  CALL   0FC6
0E65A:  BTFSC  1B.7
0E65C:  BSF    FF2.7
0E65E:  MOVLW  3A
0E660:  BTFSS  F9E.4
0E662:  BRA    E660
0E664:  MOVWF  FAD
0E666:  CLRF   1B
0E668:  BTFSC  FF2.7
0E66A:  BSF    1B.7
0E66C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E66E:  MOVFF  732,A40
0E672:  MOVLW  01
0E674:  MOVLB  A
0E676:  MOVWF  x41
0E678:  MOVLB  0
0E67A:  CALL   0FC6
0E67E:  BTFSC  1B.7
0E680:  BSF    FF2.7
0E682:  MOVLW  0A
0E684:  BTFSS  F9E.4
0E686:  BRA    E684
0E688:  MOVWF  FAD
0E68A:  MOVLW  0D
0E68C:  BTFSS  F9E.4
0E68E:  BRA    E68C
0E690:  MOVWF  FAD
0E692:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E444:  MOVLB  8
0E446:  CLRF   xB7
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E448:  BCF    FC6.5
0E44A:  MOVLW  21
0E44C:  MOVWF  FC6
0E44E:  MOVLW  40
0E450:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E452:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E454:  MOVF   FC9,W
0E456:  MOVLW  0A
0E458:  MOVWF  FC9
0E45A:  RRCF   FC7,W
0E45C:  BNC   E45A
0E45E:  MOVFF  FC9,8B7
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E462:  MOVF   FC9,W
0E464:  MOVFF  8B7,FC9
0E468:  RRCF   FC7,W
0E46A:  BNC   E468
0E46C:  MOVFF  FC9,72E
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E470:  MOVF   FC9,W
0E472:  MOVFF  8B7,FC9
0E476:  RRCF   FC7,W
0E478:  BNC   E476
0E47A:  MOVFF  FC9,72F
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E47E:  MOVF   FC9,W
0E480:  MOVFF  8B7,FC9
0E484:  RRCF   FC7,W
0E486:  BNC   E484
0E488:  MOVFF  FC9,730
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E48C:  MOVF   FC9,W
0E48E:  MOVFF  8B7,FC9
0E492:  RRCF   FC7,W
0E494:  BNC   E492
0E496:  MOVFF  FC9,731
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E49A:  MOVF   FC9,W
0E49C:  MOVFF  8B7,FC9
0E4A0:  RRCF   FC7,W
0E4A2:  BNC   E4A0
0E4A4:  MOVFF  FC9,732
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E4A8:  MOVF   FC9,W
0E4AA:  MOVFF  8B7,FC9
0E4AE:  RRCF   FC7,W
0E4B0:  BNC   E4AE
0E4B2:  MOVFF  FC9,733
....................    output_bit(RTC_CS, DISABLE); 
0E4B6:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E4B8:  MOVLW  1F
0E4BA:  MOVLB  7
0E4BC:  ANDWF  x2E,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E4BE:  MOVFF  72E,8EE
0E4C2:  MOVLB  0
0E4C4:  CALL   333A
0E4C8:  MOVFF  01,72E
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E4CC:  MOVLW  3F
0E4CE:  MOVLB  7
0E4D0:  ANDWF  x2F,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E4D2:  MOVFF  72F,8EE
0E4D6:  MOVLB  0
0E4D8:  CALL   333A
0E4DC:  MOVFF  01,72F
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E4E0:  MOVLW  3F
0E4E2:  MOVLB  7
0E4E4:  ANDWF  x30,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E4E6:  MOVFF  730,8EE
0E4EA:  MOVLB  0
0E4EC:  CALL   333A
0E4F0:  MOVFF  01,730
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E4F4:  MOVLB  7
0E4F6:  BCF    x31.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E4F8:  MOVFF  731,8EE
0E4FC:  MOVLB  0
0E4FE:  CALL   333A
0E502:  MOVFF  01,731
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E506:  MOVLB  7
0E508:  BCF    x32.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E50A:  MOVFF  732,8EE
0E50E:  MOVLB  0
0E510:  CALL   333A
0E514:  MOVFF  01,732
0E518:  RETURN 0
.................... } 
....................  
.................... int8 get_time2() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................    char input_string[30]; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
....................  
....................    time_error = 0; 
....................     
....................    fputc('[', COM_A); 
....................     
....................    for (n=0; n<12; ++n){ 
....................       c = fgetc(COM_A); 
....................       if (com_echo == TRUE) 
....................       { 
....................          fputc(c, COM_A); 
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
....................          break; 
....................       } 
....................    } 
....................     
....................    if (time_error == 0){ 
....................     
....................       fputc(']', COM_A); 
....................        
....................       for (n=0; n<12; ++n){ 
....................          t_entry[n] = (t_entry[n] - 48); 
....................       } 
....................        
....................       if (RTCfmt == 0) 
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
....................       } 
....................        
....................       if (RTCfmt == 1) 
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
....................       if (RTC_Yr_Data > 99) time_error = 2;  
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
....................       if (RTC_Hr_Data > 24) time_error = 2;  
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
....................       if (RTC_Min_Data > 60) time_error = 2;  
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
....................       if (RTC_Sec_Data > 60) time_error = 2; 
....................        
....................       if (RTCfmt == 0) 
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
....................       } 
....................        
....................       if (RTCfmt == 1) 
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
....................       } 
....................       if (time_error == 2) cmd_inv();             
....................  
....................    } 
....................    else cmd_arg(); 
....................     
....................    return time_error; 
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
17798:  MOVLW  08
1779A:  MOVWF  FEA
1779C:  MOVLW  89
1779E:  MOVWF  FE9
177A0:  CLRF   00
177A2:  CLRF   02
177A4:  MOVLW  0C
177A6:  MOVWF  01
177A8:  CALL   354E
....................  
....................    time_error = 0; 
177AC:  MOVLB  8
177AE:  CLRF   x95
....................     
....................    fputc('[', COM_A); 
177B0:  MOVLW  5B
177B2:  MOVLB  0
177B4:  CALL   AEE8
....................     
....................    while(n<12){ 
177B8:  MOVLB  8
177BA:  MOVF   x88,W
177BC:  SUBLW  0B
177BE:  BNC   17850
....................       c = fgetc(COM_A); 
177C0:  MOVLB  0
177C2:  CALL   0E58
177C6:  MOVFF  01,887
....................        
....................       if(c != 8){ 
177CA:  MOVLB  8
177CC:  MOVF   x87,W
177CE:  SUBLW  08
177D0:  BZ    177F6
....................             if (com_echo == TRUE) 
177D2:  DECFSZ 4C,W
177D4:  BRA    177E0
....................             { 
....................                fputc(c,COM_A); 
177D6:  MOVF   x87,W
177D8:  MOVLB  0
177DA:  CALL   AEE8
177DE:  MOVLB  8
....................             } 
....................              
....................             t_entry[n] = c; 
177E0:  CLRF   03
177E2:  MOVF   x88,W
177E4:  ADDLW  89
177E6:  MOVWF  FE9
177E8:  MOVLW  08
177EA:  ADDWFC 03,W
177EC:  MOVWF  FEA
177EE:  MOVFF  887,FEF
....................             n++; 
177F2:  INCF   x88,F
....................      }else{ 
177F4:  BRA    1784E
....................             //backspace code 
....................             if(n != 0){ 
177F6:  MOVF   x88,F
177F8:  BZ    1784E
....................                t_entry[n-1] = 0; 
177FA:  MOVLW  01
177FC:  SUBWF  x88,W
177FE:  CLRF   03
17800:  ADDLW  89
17802:  MOVWF  FE9
17804:  MOVLW  08
17806:  ADDWFC 03,W
17808:  MOVWF  FEA
1780A:  CLRF   FEF
....................                n--; 
1780C:  DECF   x88,F
....................                //Clear buffer and overwrite with previous minus one character 
....................                fputc('\r',COM_A); 
1780E:  MOVLW  0D
17810:  MOVLB  0
17812:  CALL   AEE8
....................                fprintf(COM_A,"                                       "); 
17816:  MOVLW  C8
17818:  MOVWF  FF6
1781A:  MOVLW  0D
1781C:  MOVWF  FF7
1781E:  MOVLW  00
17820:  MOVWF  FF8
17822:  CLRF   1B
17824:  BTFSC  FF2.7
17826:  BSF    1B.7
17828:  BCF    FF2.7
1782A:  CALL   0E6E
1782E:  BTFSC  1B.7
17830:  BSF    FF2.7
....................                fputc('\r',COM_A); 
17832:  MOVLW  0D
17834:  CALL   AEE8
....................                fprintf(COM_A,"["); 
17838:  MOVLW  5B
1783A:  BTFSS  F9E.4
1783C:  BRA    1783A
1783E:  MOVWF  FAD
....................                fprintf(COM_A,t_entry); 
17840:  MOVLW  08
17842:  MOVWF  FEA
17844:  MOVLW  89
17846:  MOVWF  FE9
17848:  CALL   79BE
1784C:  MOVLB  8
....................                 
....................             } 
....................       } 
1784E:  BRA    177BA
....................        
....................    } 
....................    n = 0; 
17850:  CLRF   x88
....................       while(t_entry[n] != 0){ 
17852:  CLRF   03
17854:  MOVF   x88,W
17856:  ADDLW  89
17858:  MOVWF  FE9
1785A:  MOVLW  08
1785C:  ADDWFC 03,W
1785E:  MOVWF  FEA
17860:  MOVF   FEF,F
17862:  BZ    17890
....................       //fputc(input_string[i],COM_A); 
....................          if(!isdigit(t_entry[n])){ 
17864:  CLRF   03
17866:  MOVF   x88,W
17868:  ADDLW  89
1786A:  MOVWF  FE9
1786C:  MOVLW  08
1786E:  ADDWFC 03,W
17870:  MOVWF  FEA
17872:  MOVFF  FEF,896
17876:  MOVF   x96,W
17878:  SUBLW  2F
1787A:  BC    17882
1787C:  MOVF   x96,W
1787E:  SUBLW  39
17880:  BC    1788A
....................             //fputs("\r\n@ARG ", COM_A); 
....................             time_error = 1; 
17882:  MOVLW  01
17884:  MOVWF  x95
....................             break; 
17886:  BRA    17890
....................          }else{ 
17888:  BRA    1788C
....................             time_error = 0; 
1788A:  CLRF   x95
....................          } 
....................          n++; 
1788C:  INCF   x88,F
1788E:  BRA    17852
....................       } 
....................     
....................    if (time_error == 0){ 
17890:  MOVF   x95,F
17892:  BTFSS  FD8.2
17894:  BRA    17BCC
....................     
....................       fputc(']', COM_A); 
17896:  MOVLW  5D
17898:  MOVLB  0
1789A:  CALL   AEE8
....................        
....................       for (n=0; n<12; ++n){ 
1789E:  MOVLB  8
178A0:  CLRF   x88
178A2:  MOVF   x88,W
178A4:  SUBLW  0B
178A6:  BNC   178D8
....................          t_entry[n] = (t_entry[n] - 48); 
178A8:  CLRF   03
178AA:  MOVF   x88,W
178AC:  ADDLW  89
178AE:  MOVWF  01
178B0:  MOVLW  08
178B2:  ADDWFC 03,F
178B4:  MOVFF  03,897
178B8:  CLRF   03
178BA:  MOVF   x88,W
178BC:  ADDLW  89
178BE:  MOVWF  FE9
178C0:  MOVLW  08
178C2:  ADDWFC 03,W
178C4:  MOVWF  FEA
178C6:  MOVLW  30
178C8:  SUBWF  FEF,W
178CA:  MOVFF  897,FEA
178CE:  MOVFF  01,FE9
178D2:  MOVWF  FEF
178D4:  INCF   x88,F
178D6:  BRA    178A2
....................       } 
....................        
....................       if (RTCfmt == 0) 
178D8:  MOVF   4F,F
178DA:  BNZ   17918
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
178DC:  MOVF   x89,W
178DE:  MULLW  0A
178E0:  MOVF   FF3,W
178E2:  ADDWF  x8A,W
178E4:  MOVLB  7
178E6:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
178E8:  MOVF   x38,F
178EA:  BZ    178F2
178EC:  MOVF   x38,W
178EE:  SUBLW  0C
178F0:  BC    178FA
178F2:  MOVLW  02
178F4:  MOVLB  8
178F6:  MOVWF  x95
178F8:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
178FA:  MOVLB  8
178FC:  MOVF   x8B,W
178FE:  MULLW  0A
17900:  MOVF   FF3,W
17902:  ADDWF  x8C,W
17904:  MOVLB  7
17906:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17908:  MOVF   x37,F
1790A:  BZ    17912
1790C:  MOVF   x37,W
1790E:  SUBLW  1F
17910:  BC    1791A
17912:  MOVLW  02
17914:  MOVLB  8
17916:  MOVWF  x95
17918:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
1791A:  DECFSZ 4F,W
1791C:  BRA    1795E
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
1791E:  MOVLB  8
17920:  MOVF   x89,W
17922:  MULLW  0A
17924:  MOVF   FF3,W
17926:  ADDWF  x8A,W
17928:  MOVLB  7
1792A:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
1792C:  MOVF   x37,F
1792E:  BZ    17936
17930:  MOVF   x37,W
17932:  SUBLW  1F
17934:  BC    1793E
17936:  MOVLW  02
17938:  MOVLB  8
1793A:  MOVWF  x95
1793C:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
1793E:  MOVLB  8
17940:  MOVF   x8B,W
17942:  MULLW  0A
17944:  MOVF   FF3,W
17946:  ADDWF  x8C,W
17948:  MOVLB  7
1794A:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
1794C:  MOVF   x38,F
1794E:  BZ    17956
17950:  MOVF   x38,W
17952:  SUBLW  0C
17954:  BC    1795E
17956:  MOVLW  02
17958:  MOVLB  8
1795A:  MOVWF  x95
1795C:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
1795E:  MOVLB  8
17960:  MOVF   x8D,W
17962:  MULLW  0A
17964:  MOVF   FF3,W
17966:  ADDWF  x8E,W
17968:  MOVLB  7
1796A:  MOVWF  x39
....................       if (RTC_Yr_Data > 99) time_error = 2;  
1796C:  MOVF   x39,W
1796E:  SUBLW  63
17970:  BC    1797A
17972:  MOVLW  02
17974:  MOVLB  8
17976:  MOVWF  x95
17978:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
1797A:  MOVLB  8
1797C:  MOVF   x8F,W
1797E:  MULLW  0A
17980:  MOVF   FF3,W
17982:  ADDWF  x90,W
17984:  MOVLB  7
17986:  MOVWF  x36
....................       if (RTC_Hr_Data > 24) time_error = 2;  
17988:  MOVF   x36,W
1798A:  SUBLW  18
1798C:  BC    17996
1798E:  MOVLW  02
17990:  MOVLB  8
17992:  MOVWF  x95
17994:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
17996:  MOVLB  8
17998:  MOVF   x91,W
1799A:  MULLW  0A
1799C:  MOVF   FF3,W
1799E:  ADDWF  x92,W
179A0:  MOVLB  7
179A2:  MOVWF  x35
....................       if (RTC_Min_Data > 60) time_error = 2;  
179A4:  MOVF   x35,W
179A6:  SUBLW  3C
179A8:  BC    179B2
179AA:  MOVLW  02
179AC:  MOVLB  8
179AE:  MOVWF  x95
179B0:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
179B2:  MOVLB  8
179B4:  MOVF   x93,W
179B6:  MULLW  0A
179B8:  MOVF   FF3,W
179BA:  ADDWF  x94,W
179BC:  MOVLB  7
179BE:  MOVWF  x34
....................       if (RTC_Sec_Data > 60) time_error = 2; 
179C0:  MOVF   x34,W
179C2:  SUBLW  3C
179C4:  BC    179CE
179C6:  MOVLW  02
179C8:  MOVLB  8
179CA:  MOVWF  x95
179CC:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
179CE:  MOVF   4F,F
179D0:  BTFSS  FD8.2
179D2:  BRA    17AC6
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
179D4:  MOVLW  0A
179D6:  BTFSS  F9E.4
179D8:  BRA    179D6
179DA:  MOVWF  FAD
179DC:  MOVLW  0D
179DE:  BTFSS  F9E.4
179E0:  BRA    179DE
179E2:  MOVWF  FAD
179E4:  CLRF   1B
179E6:  BTFSC  FF2.7
179E8:  BSF    1B.7
179EA:  BCF    FF2.7
179EC:  MOVFF  738,A40
179F0:  MOVLW  01
179F2:  MOVLB  A
179F4:  MOVWF  x41
179F6:  MOVLB  0
179F8:  CALL   0FC6
179FC:  BTFSC  1B.7
179FE:  BSF    FF2.7
17A00:  MOVLW  2F
17A02:  BTFSS  F9E.4
17A04:  BRA    17A02
17A06:  MOVWF  FAD
17A08:  CLRF   1B
17A0A:  BTFSC  FF2.7
17A0C:  BSF    1B.7
17A0E:  BCF    FF2.7
17A10:  MOVFF  737,A40
17A14:  MOVLW  01
17A16:  MOVLB  A
17A18:  MOVWF  x41
17A1A:  MOVLB  0
17A1C:  CALL   0FC6
17A20:  BTFSC  1B.7
17A22:  BSF    FF2.7
17A24:  MOVLW  2F
17A26:  BTFSS  F9E.4
17A28:  BRA    17A26
17A2A:  MOVWF  FAD
17A2C:  CLRF   1B
17A2E:  BTFSC  FF2.7
17A30:  BSF    1B.7
17A32:  BCF    FF2.7
17A34:  MOVFF  739,A40
17A38:  MOVLW  01
17A3A:  MOVLB  A
17A3C:  MOVWF  x41
17A3E:  MOVLB  0
17A40:  CALL   0FC6
17A44:  BTFSC  1B.7
17A46:  BSF    FF2.7
17A48:  MOVLW  20
17A4A:  BTFSS  F9E.4
17A4C:  BRA    17A4A
17A4E:  MOVWF  FAD
17A50:  CLRF   1B
17A52:  BTFSC  FF2.7
17A54:  BSF    1B.7
17A56:  BCF    FF2.7
17A58:  MOVFF  736,A40
17A5C:  MOVLW  01
17A5E:  MOVLB  A
17A60:  MOVWF  x41
17A62:  MOVLB  0
17A64:  CALL   0FC6
17A68:  BTFSC  1B.7
17A6A:  BSF    FF2.7
17A6C:  MOVLW  3A
17A6E:  BTFSS  F9E.4
17A70:  BRA    17A6E
17A72:  MOVWF  FAD
17A74:  CLRF   1B
17A76:  BTFSC  FF2.7
17A78:  BSF    1B.7
17A7A:  BCF    FF2.7
17A7C:  MOVFF  735,A40
17A80:  MOVLW  01
17A82:  MOVLB  A
17A84:  MOVWF  x41
17A86:  MOVLB  0
17A88:  CALL   0FC6
17A8C:  BTFSC  1B.7
17A8E:  BSF    FF2.7
17A90:  MOVLW  3A
17A92:  BTFSS  F9E.4
17A94:  BRA    17A92
17A96:  MOVWF  FAD
17A98:  CLRF   1B
17A9A:  BTFSC  FF2.7
17A9C:  BSF    1B.7
17A9E:  BCF    FF2.7
17AA0:  MOVFF  734,A40
17AA4:  MOVLW  01
17AA6:  MOVLB  A
17AA8:  MOVWF  x41
17AAA:  MOVLB  0
17AAC:  CALL   0FC6
17AB0:  BTFSC  1B.7
17AB2:  BSF    FF2.7
17AB4:  MOVLW  0A
17AB6:  BTFSS  F9E.4
17AB8:  BRA    17AB6
17ABA:  MOVWF  FAD
17ABC:  MOVLW  0D
17ABE:  BTFSS  F9E.4
17AC0:  BRA    17ABE
17AC2:  MOVWF  FAD
17AC4:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17AC6:  DECFSZ 4F,W
17AC8:  BRA    17BBC
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
17ACA:  MOVLW  0A
17ACC:  BTFSS  F9E.4
17ACE:  BRA    17ACC
17AD0:  MOVWF  FAD
17AD2:  MOVLW  0D
17AD4:  BTFSS  F9E.4
17AD6:  BRA    17AD4
17AD8:  MOVWF  FAD
17ADA:  CLRF   1B
17ADC:  BTFSC  FF2.7
17ADE:  BSF    1B.7
17AE0:  BCF    FF2.7
17AE2:  MOVFF  737,A40
17AE6:  MOVLW  01
17AE8:  MOVLB  A
17AEA:  MOVWF  x41
17AEC:  MOVLB  0
17AEE:  CALL   0FC6
17AF2:  BTFSC  1B.7
17AF4:  BSF    FF2.7
17AF6:  MOVLW  2F
17AF8:  BTFSS  F9E.4
17AFA:  BRA    17AF8
17AFC:  MOVWF  FAD
17AFE:  CLRF   1B
17B00:  BTFSC  FF2.7
17B02:  BSF    1B.7
17B04:  BCF    FF2.7
17B06:  MOVFF  738,A40
17B0A:  MOVLW  01
17B0C:  MOVLB  A
17B0E:  MOVWF  x41
17B10:  MOVLB  0
17B12:  CALL   0FC6
17B16:  BTFSC  1B.7
17B18:  BSF    FF2.7
17B1A:  MOVLW  2F
17B1C:  BTFSS  F9E.4
17B1E:  BRA    17B1C
17B20:  MOVWF  FAD
17B22:  CLRF   1B
17B24:  BTFSC  FF2.7
17B26:  BSF    1B.7
17B28:  BCF    FF2.7
17B2A:  MOVFF  739,A40
17B2E:  MOVLW  01
17B30:  MOVLB  A
17B32:  MOVWF  x41
17B34:  MOVLB  0
17B36:  CALL   0FC6
17B3A:  BTFSC  1B.7
17B3C:  BSF    FF2.7
17B3E:  MOVLW  20
17B40:  BTFSS  F9E.4
17B42:  BRA    17B40
17B44:  MOVWF  FAD
17B46:  CLRF   1B
17B48:  BTFSC  FF2.7
17B4A:  BSF    1B.7
17B4C:  BCF    FF2.7
17B4E:  MOVFF  736,A40
17B52:  MOVLW  01
17B54:  MOVLB  A
17B56:  MOVWF  x41
17B58:  MOVLB  0
17B5A:  CALL   0FC6
17B5E:  BTFSC  1B.7
17B60:  BSF    FF2.7
17B62:  MOVLW  3A
17B64:  BTFSS  F9E.4
17B66:  BRA    17B64
17B68:  MOVWF  FAD
17B6A:  CLRF   1B
17B6C:  BTFSC  FF2.7
17B6E:  BSF    1B.7
17B70:  BCF    FF2.7
17B72:  MOVFF  735,A40
17B76:  MOVLW  01
17B78:  MOVLB  A
17B7A:  MOVWF  x41
17B7C:  MOVLB  0
17B7E:  CALL   0FC6
17B82:  BTFSC  1B.7
17B84:  BSF    FF2.7
17B86:  MOVLW  3A
17B88:  BTFSS  F9E.4
17B8A:  BRA    17B88
17B8C:  MOVWF  FAD
17B8E:  CLRF   1B
17B90:  BTFSC  FF2.7
17B92:  BSF    1B.7
17B94:  BCF    FF2.7
17B96:  MOVFF  734,A40
17B9A:  MOVLW  01
17B9C:  MOVLB  A
17B9E:  MOVWF  x41
17BA0:  MOVLB  0
17BA2:  CALL   0FC6
17BA6:  BTFSC  1B.7
17BA8:  BSF    FF2.7
17BAA:  MOVLW  0A
17BAC:  BTFSS  F9E.4
17BAE:  BRA    17BAC
17BB0:  MOVWF  FAD
17BB2:  MOVLW  0D
17BB4:  BTFSS  F9E.4
17BB6:  BRA    17BB4
17BB8:  MOVWF  FAD
17BBA:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
17BBC:  MOVLB  8
17BBE:  MOVF   x95,W
17BC0:  SUBLW  02
17BC2:  BNZ   17BCA
17BC4:  MOVLB  0
17BC6:  BRA    17778
17BC8:  MOVLB  8
....................  
....................    } 
17BCA:  BRA    17BD4
....................    else cmd_arg(); 
17BCC:  MOVLB  0
17BCE:  CALL   B32E
17BD2:  MOVLB  8
....................     
....................    return time_error; 
17BD4:  MOVFF  895,01
17BD8:  MOVLB  0
17BDA:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
17C1A:  RCALL  17798
17C1C:  MOVFF  01,885
....................     
....................    if (time_error ==0 ){ 
17C20:  MOVLB  8
17C22:  MOVF   x85,F
17C24:  BTFSS  FD8.2
17C26:  BRA    17D5E
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
17C28:  BCF    FC6.5
17C2A:  MOVLW  21
17C2C:  MOVWF  FC6
17C2E:  MOVLW  40
17C30:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
17C32:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
17C34:  MOVF   FC9,W
17C36:  MOVLW  86
17C38:  MOVWF  FC9
17C3A:  RRCF   FC7,W
17C3C:  BNC   17C3A
17C3E:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
17C42:  MOVFF  738,887
17C46:  MOVLB  0
17C48:  RCALL  17BDC
17C4A:  MOVFF  01,887
17C4E:  MOVF   FC9,W
17C50:  MOVFF  01,FC9
17C54:  RRCF   FC7,W
17C56:  BNC   17C54
17C58:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C5C:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C5E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
17C60:  MOVF   FC9,W
17C62:  MOVLW  85
17C64:  MOVWF  FC9
17C66:  RRCF   FC7,W
17C68:  BNC   17C66
17C6A:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
17C6E:  MOVFF  737,887
17C72:  RCALL  17BDC
17C74:  MOVFF  01,887
17C78:  MOVF   FC9,W
17C7A:  MOVFF  01,FC9
17C7E:  RRCF   FC7,W
17C80:  BNC   17C7E
17C82:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C86:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C88:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
17C8A:  MOVF   FC9,W
17C8C:  MOVLW  87
17C8E:  MOVWF  FC9
17C90:  RRCF   FC7,W
17C92:  BNC   17C90
17C94:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
17C98:  MOVFF  739,887
17C9C:  RCALL  17BDC
17C9E:  MOVFF  01,887
17CA2:  MOVF   FC9,W
17CA4:  MOVFF  01,FC9
17CA8:  RRCF   FC7,W
17CAA:  BNC   17CA8
17CAC:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17CB0:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17CB2:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
17CB4:  MOVF   FC9,W
17CB6:  MOVLW  83
17CB8:  MOVWF  FC9
17CBA:  RRCF   FC7,W
17CBC:  BNC   17CBA
17CBE:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
17CC2:  MOVFF  736,887
17CC6:  RCALL  17BDC
17CC8:  MOVFF  01,887
17CCC:  MOVF   FC9,W
17CCE:  MOVFF  01,FC9
17CD2:  RRCF   FC7,W
17CD4:  BNC   17CD2
17CD6:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17CDA:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17CDC:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
17CDE:  MOVF   FC9,W
17CE0:  MOVLW  82
17CE2:  MOVWF  FC9
17CE4:  RRCF   FC7,W
17CE6:  BNC   17CE4
17CE8:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
17CEC:  MOVFF  735,887
17CF0:  RCALL  17BDC
17CF2:  MOVFF  01,887
17CF6:  MOVF   FC9,W
17CF8:  MOVFF  01,FC9
17CFC:  RRCF   FC7,W
17CFE:  BNC   17CFC
17D00:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17D04:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17D06:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
17D08:  MOVF   FC9,W
17D0A:  MOVLW  81
17D0C:  MOVWF  FC9
17D0E:  RRCF   FC7,W
17D10:  BNC   17D0E
17D12:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
17D16:  MOVFF  734,887
17D1A:  RCALL  17BDC
17D1C:  MOVFF  01,887
17D20:  MOVF   FC9,W
17D22:  MOVFF  01,FC9
17D26:  RRCF   FC7,W
17D28:  BNC   17D26
17D2A:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17D2E:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17D30:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
17D32:  MOVF   FC9,W
17D34:  MOVLW  80
17D36:  MOVWF  FC9
17D38:  RRCF   FC7,W
17D3A:  BNC   17D38
17D3C:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
17D40:  MOVLB  8
17D42:  CLRF   x87
17D44:  MOVLB  0
17D46:  RCALL  17BDC
17D48:  MOVFF  01,887
17D4C:  MOVF   FC9,W
17D4E:  MOVFF  01,FC9
17D52:  RRCF   FC7,W
17D54:  BNC   17D52
17D56:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17D5A:  BSF    F91.0
17D5C:  MOVLB  8
....................    } 
17D5E:  MOVLB  0
17D60:  GOTO   17DEC (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
188EA:  CALL   E444
....................     
....................    time_error = get_time(); 
188EE:  CALL   17798
188F2:  MOVFF  01,885
....................     
....................    if (time_error == 0 ){ 
188F6:  MOVLB  8
188F8:  MOVF   x85,F
188FA:  BTFSS  FD8.2
188FC:  BRA    18A32
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
188FE:  MOVFF  739,72D
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
18902:  MOVLW  04
18904:  MOVWF  x89
18906:  MOVFF  72D,88A
1890A:  MOVLB  0
1890C:  CALL   343A
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
18910:  MOVFF  738,887
18914:  CALL   17BDC
18918:  MOVFF  01,738
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
1891C:  MOVLB  7
1891E:  BSF    x38.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
18920:  BCF    FC6.5
18922:  MOVLW  21
18924:  MOVWF  FC6
18926:  MOVLW  40
18928:  MOVWF  FC7
....................       delay_us(10); 
1892A:  MOVLW  35
1892C:  MOVWF  00
1892E:  DECFSZ 00,F
18930:  BRA    1892E
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
18932:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
18934:  MOVF   FC9,W
18936:  MOVLW  8E
18938:  MOVWF  FC9
1893A:  RRCF   FC7,W
1893C:  BNC   1893A
1893E:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
18942:  MOVFF  734,887
18946:  MOVLB  0
18948:  CALL   17BDC
1894C:  MOVFF  01,887
18950:  MOVF   FC9,W
18952:  MOVFF  01,FC9
18956:  RRCF   FC7,W
18958:  BNC   18956
1895A:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
1895E:  BSF    F91.0
....................       delay_us(1); // Delays added 1.020A 
18960:  MOVLW  05
18962:  MOVWF  00
18964:  DECFSZ 00,F
18966:  BRA    18964
....................        
....................       output_bit(RTC_CS, ENABLE); 
18968:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
1896A:  MOVF   FC9,W
1896C:  MOVLW  8D
1896E:  MOVWF  FC9
18970:  RRCF   FC7,W
18972:  BNC   18970
18974:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
18978:  MOVFF  735,887
1897C:  CALL   17BDC
18980:  MOVFF  01,887
18984:  MOVF   FC9,W
18986:  MOVFF  01,FC9
1898A:  RRCF   FC7,W
1898C:  BNC   1898A
1898E:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
18992:  BSF    F91.0
....................       delay_us(1); 
18994:  MOVLW  05
18996:  MOVWF  00
18998:  DECFSZ 00,F
1899A:  BRA    18998
....................        
....................       output_bit(RTC_CS, ENABLE); 
1899C:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
1899E:  MOVF   FC9,W
189A0:  MOVLW  8C
189A2:  MOVWF  FC9
189A4:  RRCF   FC7,W
189A6:  BNC   189A4
189A8:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
189AC:  MOVFF  736,887
189B0:  CALL   17BDC
189B4:  MOVFF  01,887
189B8:  MOVF   FC9,W
189BA:  MOVFF  01,FC9
189BE:  RRCF   FC7,W
189C0:  BNC   189BE
189C2:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
189C6:  BSF    F91.0
....................       delay_us(1);  
189C8:  MOVLW  05
189CA:  MOVWF  00
189CC:  DECFSZ 00,F
189CE:  BRA    189CC
....................        
....................       output_bit(RTC_CS, ENABLE); 
189D0:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
189D2:  MOVF   FC9,W
189D4:  MOVLW  8B
189D6:  MOVWF  FC9
189D8:  RRCF   FC7,W
189DA:  BNC   189D8
189DC:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
189E0:  MOVFF  737,887
189E4:  CALL   17BDC
189E8:  MOVFF  01,887
189EC:  MOVF   FC9,W
189EE:  MOVFF  01,FC9
189F2:  RRCF   FC7,W
189F4:  BNC   189F2
189F6:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE);  
189FA:  BSF    F91.0
....................       delay_us(1); 
189FC:  MOVLW  05
189FE:  MOVWF  00
18A00:  DECFSZ 00,F
18A02:  BRA    18A00
....................        
....................       output_bit(RTC_CS, ENABLE); 
18A04:  BCF    F91.0
....................       //fprintf(COM_A,"test61\r\n"); 
....................       RTC_buffer = spi_read(0x8A);// address - Month 
18A06:  MOVF   FC9,W
18A08:  MOVLW  8A
18A0A:  MOVWF  FC9
18A0C:  RRCF   FC7,W
18A0E:  BNC   18A0C
18A10:  MOVFF  FC9,886
....................       //fprintf(COM_A,"test62\r\n"); 
....................       //fprintf(COM_A,"test6: %d\r\n",RTC_Mon_Data); 
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
18A14:  MOVF   FC9,W
18A16:  MOVFF  738,FC9
18A1A:  RRCF   FC7,W
18A1C:  BNC   18A1A
18A1E:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
18A22:  BSF    F91.0
....................       delay_us(1); 
18A24:  MOVLW  05
18A26:  MOVWF  00
18A28:  DECFSZ 00,F
18A2A:  BRA    18A28
....................       //fprintf(COM_A,"test6\r\n"); 
....................     
....................    RTC_read_alarm(); 
18A2C:  CALL   E444
18A30:  MOVLB  8
....................    } 
18A32:  MOVLB  0
18A34:  GOTO   18A4A (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
15F24:  BCF    FC6.5
15F26:  MOVLW  21
15F28:  MOVWF  FC6
15F2A:  MOVLW  40
15F2C:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
15F2E:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
15F30:  MOVF   FC9,W
15F32:  MOVLW  8E
15F34:  MOVWF  FC9
15F36:  RRCF   FC7,W
15F38:  BNC   15F36
15F3A:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b00000000);  // data 
15F3E:  MOVF   FC9,W
15F40:  CLRF   FC9
15F42:  RRCF   FC7,W
15F44:  BNC   15F42
15F46:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F4A:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F4C:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15F4E:  MOVF   FC9,W
15F50:  MOVLW  8D
15F52:  MOVWF  FC9
15F54:  RRCF   FC7,W
15F56:  BNC   15F54
15F58:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F5C:  MOVF   FC9,W
15F5E:  MOVLW  80
15F60:  MOVWF  FC9
15F62:  RRCF   FC7,W
15F64:  BNC   15F62
15F66:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F6A:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F6C:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15F6E:  MOVF   FC9,W
15F70:  MOVLW  8C
15F72:  MOVWF  FC9
15F74:  RRCF   FC7,W
15F76:  BNC   15F74
15F78:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F7C:  MOVF   FC9,W
15F7E:  MOVLW  80
15F80:  MOVWF  FC9
15F82:  RRCF   FC7,W
15F84:  BNC   15F82
15F86:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F8A:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F8C:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15F8E:  MOVF   FC9,W
15F90:  MOVLW  8B
15F92:  MOVWF  FC9
15F94:  RRCF   FC7,W
15F96:  BNC   15F94
15F98:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b11000000);  // data 
15F9C:  MOVF   FC9,W
15F9E:  MOVLW  C0
15FA0:  MOVWF  FC9
15FA2:  RRCF   FC7,W
15FA4:  BNC   15FA2
15FA6:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE);    
15FAA:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15FAC:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15FAE:  MOVF   FC9,W
15FB0:  MOVLW  8A
15FB2:  MOVWF  FC9
15FB4:  RRCF   FC7,W
15FB6:  BNC   15FB4
15FB8:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15FBC:  MOVF   FC9,W
15FBE:  MOVLW  80
15FC0:  MOVWF  FC9
15FC2:  RRCF   FC7,W
15FC4:  BNC   15FC2
15FC6:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15FCA:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15FCC:  CALL   E444
15FD0:  GOTO   16D90 (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
15754:  MOVLB  8
15756:  CLRF   x87
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
15758:  BCF    FC6.5
1575A:  MOVLW  21
1575C:  MOVWF  FC6
1575E:  MOVLW  40
15760:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15762:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
15764:  MOVF   FC9,W
15766:  MOVLW  0A
15768:  MOVWF  FC9
1576A:  RRCF   FC7,W
1576C:  BNC   1576A
1576E:  MOVFF  FC9,887
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
15772:  MOVF   FC9,W
15774:  MOVFF  887,FC9
15778:  RRCF   FC7,W
1577A:  BNC   15778
1577C:  MOVFF  FC9,72E
....................    output_bit(RTC_CS, DISABLE); 
15780:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
15782:  MOVLB  7
15784:  BSF    x2E.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15786:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15788:  MOVF   FC9,W
1578A:  MOVLW  8A
1578C:  MOVWF  FC9
1578E:  RRCF   FC7,W
15790:  BNC   1578E
15792:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
15796:  MOVF   FC9,W
15798:  MOVFF  72E,FC9
1579C:  RRCF   FC7,W
1579E:  BNC   1579C
157A0:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
157A4:  BSF    F91.0
157A6:  MOVLB  0
157A8:  GOTO   16CBA (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
0346A:  MOVFF  725,73F
....................    rtc_last_min   = RTC_Min_Reg; 
0346E:  MOVFF  726,73E
....................    rtc_last_hour  = RTC_Hr_Reg; 
03472:  MOVFF  727,73D
....................    rtc_last_day   = RTC_DOM_Reg; 
03476:  MOVFF  729,73B
....................    rtc_last_month = RTC_Mon_Reg; 
0347A:  MOVFF  72A,73A
....................    rtc_last_year  = RTC_Yr_Reg; 
0347E:  MOVFF  72B,73C
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
03482:  MOVLW  06
03484:  MOVLB  8
03486:  MOVWF  x89
03488:  MOVFF  73A,88A
0348C:  MOVLB  0
0348E:  RCALL  343A
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
03490:  MOVLW  08
03492:  MOVLB  8
03494:  MOVWF  x89
03496:  MOVFF  73B,88A
0349A:  MOVLB  0
0349C:  RCALL  343A
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
0349E:  MOVLW  0A
034A0:  MOVLB  8
034A2:  MOVWF  x89
034A4:  MOVFF  73C,88A
034A8:  MOVLB  0
034AA:  RCALL  343A
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
034AC:  MOVLW  0C
034AE:  MOVLB  8
034B0:  MOVWF  x89
034B2:  MOVFF  73D,88A
034B6:  MOVLB  0
034B8:  RCALL  343A
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
034BA:  MOVLW  0E
034BC:  MOVLB  8
034BE:  MOVWF  x89
034C0:  MOVFF  73E,88A
034C4:  MOVLB  0
034C6:  RCALL  343A
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
034C8:  MOVLW  10
034CA:  MOVLB  8
034CC:  MOVWF  x89
034CE:  MOVFF  73F,88A
034D2:  MOVLB  0
034D4:  RCALL  343A
034D6:  GOTO   1B898 (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
157AC:  MOVLB  8
157AE:  CLRF   x8A
157B0:  CLRF   x89
157B2:  CLRF   x88
157B4:  CLRF   x87
157B6:  CLRF   x8E
157B8:  CLRF   x8D
157BA:  CLRF   x8C
157BC:  CLRF   x8B
157BE:  CLRF   x92
157C0:  CLRF   x91
157C2:  CLRF   x90
157C4:  CLRF   x8F
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
157C6:  CLRF   x9F
157C8:  CLRF   xA0
157CA:  MOVLW  1F
157CC:  MOVWF  xA1
157CE:  CLRF   xA2
157D0:  MOVLW  3B
157D2:  MOVWF  xA3
157D4:  CLRF   xA4
157D6:  MOVLW  5A
157D8:  MOVWF  xA5
157DA:  CLRF   xA6
157DC:  MOVLW  78
157DE:  MOVWF  xA7
157E0:  CLRF   xA8
157E2:  MOVLW  97
157E4:  MOVWF  xA9
157E6:  CLRF   xAA
157E8:  MOVLW  B5
157EA:  MOVWF  xAB
157EC:  CLRF   xAC
157EE:  MOVLW  D4
157F0:  MOVWF  xAD
157F2:  CLRF   xAE
157F4:  MOVLW  F3
157F6:  MOVWF  xAF
157F8:  CLRF   xB0
157FA:  MOVLW  11
157FC:  MOVWF  xB1
157FE:  MOVLW  01
15800:  MOVWF  xB2
15802:  MOVLW  30
15804:  MOVWF  xB3
15806:  MOVLW  01
15808:  MOVWF  xB4
1580A:  MOVLW  4E
1580C:  MOVWF  xB5
1580E:  MOVLW  01
15810:  MOVWF  xB6
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
15812:  BCF    4D.3
....................     
....................    RTC_read(); 
15814:  MOVLB  0
15816:  CALL   336C
....................    RTC_read_alarm(); 
1581A:  CALL   E444
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
1581E:  MOVLW  04
15820:  MOVLB  8
15822:  MOVWF  xB7
15824:  MOVLB  0
15826:  CALL   2A4C
1582A:  MOVFF  01,72D
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
1582E:  MOVLB  7
15830:  MOVF   x2B,W
15832:  SUBWF  x2D,W
15834:  BC    1583A
15836:  BSF    4D.3
15838:  BRA    15C6E
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
1583A:  MOVF   x2D,W
1583C:  SUBWF  x2B,W
1583E:  BTFSS  FD8.2
15840:  BRA    15C6E
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
15842:  MOVLW  01
15844:  SUBWF  x2A,W
15846:  MOVWF  00
15848:  BCF    FD8.0
1584A:  RLCF   00,F
1584C:  MOVF   00,W
1584E:  CLRF   03
15850:  ADDLW  9F
15852:  MOVWF  FE9
15854:  MOVLW  08
15856:  ADDWFC 03,W
15858:  MOVWF  FEA
1585A:  MOVFF  FEC,03
1585E:  MOVF   FED,F
15860:  MOVFF  FEF,917
15864:  MOVFF  03,918
15868:  MOVLB  0
1586A:  CALL   C926
1586E:  MOVFF  03,88A
15872:  MOVFF  02,889
15876:  MOVFF  01,888
1587A:  MOVFF  00,887
....................          time_now = time_now + RTC_DOM_Reg; 
1587E:  MOVLB  9
15880:  CLRF   x18
15882:  MOVFF  729,917
15886:  MOVLB  0
15888:  CALL   C926
1588C:  BCF    FD8.1
1588E:  MOVFF  88A,91A
15892:  MOVFF  889,919
15896:  MOVFF  888,918
1589A:  MOVFF  887,917
1589E:  MOVFF  03,91E
158A2:  MOVFF  02,91D
158A6:  MOVFF  01,91C
158AA:  MOVFF  00,91B
158AE:  CALL   C3EA
158B2:  MOVFF  03,88A
158B6:  MOVFF  02,889
158BA:  MOVFF  01,888
158BE:  MOVFF  00,887
....................           
....................          hour = RTC_Hr_Reg; 
158C2:  MOVLB  9
158C4:  CLRF   x18
158C6:  MOVFF  727,917
158CA:  MOVLB  0
158CC:  CALL   C926
158D0:  MOVFF  03,896
158D4:  MOVFF  02,895
158D8:  MOVFF  01,894
158DC:  MOVFF  00,893
....................          minute = RTC_Min_Reg; 
158E0:  MOVLB  9
158E2:  CLRF   x18
158E4:  MOVFF  726,917
158E8:  MOVLB  0
158EA:  CALL   C926
158EE:  MOVFF  03,89A
158F2:  MOVFF  02,899
158F6:  MOVFF  01,898
158FA:  MOVFF  00,897
....................          second = RTC_Sec_Reg; 
158FE:  MOVLB  9
15900:  CLRF   x18
15902:  MOVFF  725,917
15906:  MOVLB  0
15908:  CALL   C926
1590C:  MOVFF  03,89E
15910:  MOVFF  02,89D
15914:  MOVFF  01,89C
15918:  MOVFF  00,89B
....................           
....................          fraction_of_day = (hour / 24); 
1591C:  MOVFF  896,8FE
15920:  MOVFF  895,8FD
15924:  MOVFF  894,8FC
15928:  MOVFF  893,8FB
1592C:  MOVLB  9
1592E:  CLRF   x02
15930:  CLRF   x01
15932:  MOVLW  40
15934:  MOVWF  x00
15936:  MOVLW  83
15938:  MOVLB  8
1593A:  MOVWF  xFF
1593C:  MOVLB  0
1593E:  CALL   C95C
15942:  MOVFF  03,892
15946:  MOVFF  02,891
1594A:  MOVFF  01,890
1594E:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15952:  MOVFF  89A,8FE
15956:  MOVFF  899,8FD
1595A:  MOVFF  898,8FC
1595E:  MOVFF  897,8FB
15962:  MOVLB  9
15964:  CLRF   x02
15966:  CLRF   x01
15968:  MOVLW  34
1596A:  MOVWF  x00
1596C:  MOVLW  89
1596E:  MOVLB  8
15970:  MOVWF  xFF
15972:  MOVLB  0
15974:  CALL   C95C
15978:  BCF    FD8.1
1597A:  MOVFF  892,91A
1597E:  MOVFF  891,919
15982:  MOVFF  890,918
15986:  MOVFF  88F,917
1598A:  MOVFF  03,91E
1598E:  MOVFF  02,91D
15992:  MOVFF  01,91C
15996:  MOVFF  00,91B
1599A:  CALL   C3EA
1599E:  MOVFF  03,892
159A2:  MOVFF  02,891
159A6:  MOVFF  01,890
159AA:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
159AE:  MOVFF  89E,8FE
159B2:  MOVFF  89D,8FD
159B6:  MOVFF  89C,8FC
159BA:  MOVFF  89B,8FB
159BE:  MOVLB  9
159C0:  CLRF   x02
159C2:  MOVLW  C0
159C4:  MOVWF  x01
159C6:  MOVLW  28
159C8:  MOVWF  x00
159CA:  MOVLW  8F
159CC:  MOVLB  8
159CE:  MOVWF  xFF
159D0:  MOVLB  0
159D2:  CALL   C95C
159D6:  BCF    FD8.1
159D8:  MOVFF  892,91A
159DC:  MOVFF  891,919
159E0:  MOVFF  890,918
159E4:  MOVFF  88F,917
159E8:  MOVFF  03,91E
159EC:  MOVFF  02,91D
159F0:  MOVFF  01,91C
159F4:  MOVFF  00,91B
159F8:  CALL   C3EA
159FC:  MOVFF  03,892
15A00:  MOVFF  02,891
15A04:  MOVFF  01,890
15A08:  MOVFF  00,88F
....................           
....................          time_now = time_now + fraction_of_day; 
15A0C:  BCF    FD8.1
15A0E:  MOVFF  88A,91A
15A12:  MOVFF  889,919
15A16:  MOVFF  888,918
15A1A:  MOVFF  887,917
15A1E:  MOVFF  892,91E
15A22:  MOVFF  891,91D
15A26:  MOVFF  890,91C
15A2A:  MOVFF  88F,91B
15A2E:  CALL   C3EA
15A32:  MOVFF  03,88A
15A36:  MOVFF  02,889
15A3A:  MOVFF  01,888
15A3E:  MOVFF  00,887
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
15A42:  MOVLB  9
15A44:  CLRF   x18
15A46:  MOVFF  730,917
15A4A:  MOVLB  0
15A4C:  CALL   C926
15A50:  MOVFF  03,896
15A54:  MOVFF  02,895
15A58:  MOVFF  01,894
15A5C:  MOVFF  00,893
....................          minute = RTC_Al_Min_Reg; 
15A60:  MOVLB  9
15A62:  CLRF   x18
15A64:  MOVFF  731,917
15A68:  MOVLB  0
15A6A:  CALL   C926
15A6E:  MOVFF  03,89A
15A72:  MOVFF  02,899
15A76:  MOVFF  01,898
15A7A:  MOVFF  00,897
....................          second = RTC_Al_Sec_Reg; 
15A7E:  MOVLB  9
15A80:  CLRF   x18
15A82:  MOVFF  732,917
15A86:  MOVLB  0
15A88:  CALL   C926
15A8C:  MOVFF  03,89E
15A90:  MOVFF  02,89D
15A94:  MOVFF  01,89C
15A98:  MOVFF  00,89B
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
15A9C:  MOVLW  01
15A9E:  MOVLB  7
15AA0:  SUBWF  x2E,W
15AA2:  MOVWF  00
15AA4:  BCF    FD8.0
15AA6:  RLCF   00,F
15AA8:  MOVF   00,W
15AAA:  CLRF   03
15AAC:  ADDLW  9F
15AAE:  MOVWF  FE9
15AB0:  MOVLW  08
15AB2:  ADDWFC 03,W
15AB4:  MOVWF  FEA
15AB6:  MOVFF  FEC,03
15ABA:  MOVF   FED,F
15ABC:  MOVFF  FEF,917
15AC0:  MOVFF  03,918
15AC4:  MOVLB  0
15AC6:  CALL   C926
15ACA:  MOVFF  03,88E
15ACE:  MOVFF  02,88D
15AD2:  MOVFF  01,88C
15AD6:  MOVFF  00,88B
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
15ADA:  MOVLB  9
15ADC:  CLRF   x18
15ADE:  MOVFF  72F,917
15AE2:  MOVLB  0
15AE4:  CALL   C926
15AE8:  BCF    FD8.1
15AEA:  MOVFF  88E,91A
15AEE:  MOVFF  88D,919
15AF2:  MOVFF  88C,918
15AF6:  MOVFF  88B,917
15AFA:  MOVFF  03,91E
15AFE:  MOVFF  02,91D
15B02:  MOVFF  01,91C
15B06:  MOVFF  00,91B
15B0A:  CALL   C3EA
15B0E:  MOVFF  03,88E
15B12:  MOVFF  02,88D
15B16:  MOVFF  01,88C
15B1A:  MOVFF  00,88B
....................           
....................          fraction_of_day = (hour / 24); 
15B1E:  MOVFF  896,8FE
15B22:  MOVFF  895,8FD
15B26:  MOVFF  894,8FC
15B2A:  MOVFF  893,8FB
15B2E:  MOVLB  9
15B30:  CLRF   x02
15B32:  CLRF   x01
15B34:  MOVLW  40
15B36:  MOVWF  x00
15B38:  MOVLW  83
15B3A:  MOVLB  8
15B3C:  MOVWF  xFF
15B3E:  MOVLB  0
15B40:  CALL   C95C
15B44:  MOVFF  03,892
15B48:  MOVFF  02,891
15B4C:  MOVFF  01,890
15B50:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15B54:  MOVFF  89A,8FE
15B58:  MOVFF  899,8FD
15B5C:  MOVFF  898,8FC
15B60:  MOVFF  897,8FB
15B64:  MOVLB  9
15B66:  CLRF   x02
15B68:  CLRF   x01
15B6A:  MOVLW  34
15B6C:  MOVWF  x00
15B6E:  MOVLW  89
15B70:  MOVLB  8
15B72:  MOVWF  xFF
15B74:  MOVLB  0
15B76:  CALL   C95C
15B7A:  BCF    FD8.1
15B7C:  MOVFF  892,91A
15B80:  MOVFF  891,919
15B84:  MOVFF  890,918
15B88:  MOVFF  88F,917
15B8C:  MOVFF  03,91E
15B90:  MOVFF  02,91D
15B94:  MOVFF  01,91C
15B98:  MOVFF  00,91B
15B9C:  CALL   C3EA
15BA0:  MOVFF  03,892
15BA4:  MOVFF  02,891
15BA8:  MOVFF  01,890
15BAC:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
15BB0:  MOVFF  89E,8FE
15BB4:  MOVFF  89D,8FD
15BB8:  MOVFF  89C,8FC
15BBC:  MOVFF  89B,8FB
15BC0:  MOVLB  9
15BC2:  CLRF   x02
15BC4:  MOVLW  C0
15BC6:  MOVWF  x01
15BC8:  MOVLW  28
15BCA:  MOVWF  x00
15BCC:  MOVLW  8F
15BCE:  MOVLB  8
15BD0:  MOVWF  xFF
15BD2:  MOVLB  0
15BD4:  CALL   C95C
15BD8:  BCF    FD8.1
15BDA:  MOVFF  892,91A
15BDE:  MOVFF  891,919
15BE2:  MOVFF  890,918
15BE6:  MOVFF  88F,917
15BEA:  MOVFF  03,91E
15BEE:  MOVFF  02,91D
15BF2:  MOVFF  01,91C
15BF6:  MOVFF  00,91B
15BFA:  CALL   C3EA
15BFE:  MOVFF  03,892
15C02:  MOVFF  02,891
15C06:  MOVFF  01,890
15C0A:  MOVFF  00,88F
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
15C0E:  BCF    FD8.1
15C10:  MOVFF  88E,91A
15C14:  MOVFF  88D,919
15C18:  MOVFF  88C,918
15C1C:  MOVFF  88B,917
15C20:  MOVFF  892,91E
15C24:  MOVFF  891,91D
15C28:  MOVFF  890,91C
15C2C:  MOVFF  88F,91B
15C30:  CALL   C3EA
15C34:  MOVFF  03,88E
15C38:  MOVFF  02,88D
15C3C:  MOVFF  01,88C
15C40:  MOVFF  00,88B
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
15C44:  MOVFF  88E,916
15C48:  MOVFF  88D,915
15C4C:  MOVFF  88C,914
15C50:  MOVFF  88B,913
15C54:  MOVFF  88A,91A
15C58:  MOVFF  889,919
15C5C:  MOVFF  888,918
15C60:  MOVFF  887,917
15C64:  CALL   107B8
15C68:  BNC   15C6C
15C6A:  BSF    4D.3
15C6C:  MOVLB  7
....................       } 
....................    } 
15C6E:  MOVLB  0
15C70:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
15C72:  BTFSS  4D.3
15C74:  BRA    15C92
15C76:  MOVLW  F0
15C78:  MOVWF  FF6
15C7A:  MOVLW  0D
15C7C:  MOVWF  FF7
15C7E:  MOVLW  00
15C80:  MOVWF  FF8
15C82:  CLRF   1B
15C84:  BTFSC  FF2.7
15C86:  BSF    1B.7
15C88:  BCF    FF2.7
15C8A:  CALL   0E6E
15C8E:  BTFSC  1B.7
15C90:  BSF    FF2.7
15C92:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F5A8:  BCF    F67.5
0F5AA:  MOVLW  32
0F5AC:  MOVWF  F67
0F5AE:  MOVLW  40
0F5B0:  MOVWF  F68
....................     
....................    data = 0; 
0F5B2:  MOVLB  8
0F5B4:  CLRF   xD7
0F5B6:  CLRF   xD6
....................     
....................    DAC_MS_byte = 0; 
0F5B8:  CLRF   xD8
....................    DAC_LS_byte = 0; 
0F5BA:  CLRF   xD9
....................     
....................    data = setting & 0b0000111100000000; 
0F5BC:  CLRF   xD6
0F5BE:  MOVF   xD5,W
0F5C0:  ANDLW  0F
0F5C2:  MOVWF  xD7
....................    data = data >> 8; 
0F5C4:  MOVFF  8D7,8D6
0F5C8:  CLRF   xD7
....................    DAC_MS_byte = data; 
0F5CA:  MOVFF  8D6,8D8
....................     
....................    data = setting & 0b0000000011111111; 
0F5CE:  MOVFF  8D4,8D6
0F5D2:  CLRF   xD7
....................    DAC_LS_byte = data; 
0F5D4:  MOVFF  8D6,8D9
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F5D8:  MOVLW  01
0F5DA:  SUBWF  xD3,W
0F5DC:  ADDLW  FC
0F5DE:  BC    F60A
0F5E0:  ADDLW  04
0F5E2:  MOVLB  0
0F5E4:  GOTO   F628
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F5E8:  MOVLW  30
0F5EA:  MOVLB  8
0F5EC:  IORWF  xD8,F
....................          break; 
0F5EE:  BRA    F60A
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F5F0:  MOVLW  70
0F5F2:  MOVLB  8
0F5F4:  IORWF  xD8,F
....................          break; 
0F5F6:  BRA    F60A
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F5F8:  MOVLW  B0
0F5FA:  MOVLB  8
0F5FC:  IORWF  xD8,F
....................          break; 
0F5FE:  BRA    F60A
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F600:  MOVLW  F0
0F602:  MOVLB  8
0F604:  IORWF  xD8,F
....................          break; 
0F606:  BRA    F60A
0F608:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F60A:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F60C:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F60E:  MOVF   F6A,W
0F610:  MOVFF  8D8,F6A
0F614:  RRCF   F68,W
0F616:  BNC   F614
....................    spi_write2(DAC_LS_byte); 
0F618:  MOVF   F6A,W
0F61A:  MOVFF  8D9,F6A
0F61E:  RRCF   F68,W
0F620:  BNC   F61E
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F622:  BSF    F8C.3
0F624:  MOVLB  0
0F626:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F650:  MOVLB  8
0F652:  CLRF   xD8
0F654:  CLRF   xD9
0F656:  CLRF   xDA
0F658:  CLRF   xDB
0F65A:  CLRF   xDC
0F65C:  CLRF   xDD
0F65E:  CLRF   xDE
0F660:  CLRF   xDF
0F662:  CLRF   xE0
0F664:  CLRF   xE1
0F666:  CLRF   xE2
0F668:  CLRF   xE3
0F66A:  CLRF   xE4
0F66C:  CLRF   xE5
0F66E:  CLRF   xE6
0F670:  CLRF   xE7
0F672:  CLRF   xE8
0F674:  CLRF   xE9
0F676:  CLRF   xEA
0F678:  CLRF   xEB
0F67A:  CLRF   xEC
0F67C:  CLRF   xED
0F67E:  CLRF   xEE
0F680:  CLRF   xEF
0F682:  CLRF   xF0
0F684:  CLRF   xF1
0F686:  CLRF   xF2
0F688:  CLRF   xF3
0F68A:  CLRF   xF4
0F68C:  CLRF   xF5
0F68E:  CLRF   xF6
0F690:  CLRF   xF7
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F692:  CLRF   xF8
0F694:  CLRF   xF9
0F696:  CLRF   xFA
0F698:  CLRF   xFB
0F69A:  CLRF   xFC
0F69C:  CLRF   xFD
0F69E:  CLRF   xFE
0F6A0:  CLRF   xFF
0F6A2:  MOVLB  9
0F6A4:  CLRF   x00
0F6A6:  CLRF   x01
0F6A8:  CLRF   x02
0F6AA:  CLRF   x03
0F6AC:  CLRF   x04
0F6AE:  CLRF   x05
0F6B0:  CLRF   x06
0F6B2:  CLRF   x07
0F6B4:  CLRF   x08
0F6B6:  CLRF   x09
0F6B8:  CLRF   x0A
0F6BA:  CLRF   x0B
0F6BC:  CLRF   x0C
0F6BE:  CLRF   x0D
0F6C0:  CLRF   x0E
0F6C2:  CLRF   x0F
0F6C4:  CLRF   x10
0F6C6:  CLRF   x11
0F6C8:  CLRF   x12
0F6CA:  CLRF   x13
0F6CC:  CLRF   x14
0F6CE:  CLRF   x15
0F6D0:  CLRF   x16
0F6D2:  CLRF   x17
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F6D4:  MOVLB  8
0F6D6:  CLRF   xD7
0F6D8:  MOVLW  01
0F6DA:  MOVWF  xD6
0F6DC:  MOVLW  01
0F6DE:  ADDWF  xD3,W
0F6E0:  MOVWF  01
0F6E2:  MOVLW  00
0F6E4:  ADDWFC xD4,W
0F6E6:  MOVWF  03
0F6E8:  MOVF   xD7,W
0F6EA:  SUBWF  03,W
0F6EC:  BTFSS  FD8.0
0F6EE:  BRA    F7DA
0F6F0:  BNZ   F6F8
0F6F2:  MOVF   01,W
0F6F4:  SUBWF  xD6,W
0F6F6:  BC    F7DA
....................    { 
....................       for (n=1; n<5; ++n) 
0F6F8:  MOVLW  01
0F6FA:  MOVWF  xD5
0F6FC:  MOVF   xD5,W
0F6FE:  SUBLW  04
0F700:  BNC   F7D2
....................       { 
....................          set_adc_channel(n,VSS); 
0F702:  RLCF   xD5,W
0F704:  MOVWF  00
0F706:  RLCF   00,F
0F708:  MOVLW  FC
0F70A:  ANDWF  00,F
0F70C:  MOVF   FC2,W
0F70E:  ANDLW  83
0F710:  IORWF  00,W
0F712:  MOVWF  FC2
0F714:  MOVLW  00
0F716:  MOVWF  01
0F718:  MOVF   FC1,W
0F71A:  ANDLW  F8
0F71C:  IORWF  01,W
0F71E:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F720:  MOVF   xD5,W
0F722:  MULLW  04
0F724:  MOVF   FF3,W
0F726:  CLRF   03
0F728:  ADDLW  F8
0F72A:  MOVWF  FE9
0F72C:  MOVLW  08
0F72E:  ADDWFC 03,W
0F730:  MOVWF  FEA
0F732:  BSF    FC2.1
0F734:  BTFSC  FC2.1
0F736:  BRA    F734
0F738:  MOVFF  FC3,FEF
0F73C:  MOVFF  FC4,FEC
0F740:  CLRF   FEC
0F742:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F744:  MOVF   xD5,W
0F746:  MULLW  04
0F748:  MOVF   FF3,W
0F74A:  CLRF   03
0F74C:  ADDLW  D8
0F74E:  MOVWF  01
0F750:  MOVLW  08
0F752:  ADDWFC 03,F
0F754:  MOVFF  01,918
0F758:  MOVFF  03,919
0F75C:  MOVLB  8
0F75E:  MOVF   xD5,W
0F760:  MULLW  04
0F762:  MOVF   FF3,W
0F764:  CLRF   03
0F766:  ADDLW  D8
0F768:  MOVWF  FE9
0F76A:  MOVLW  08
0F76C:  ADDWFC 03,W
0F76E:  MOVWF  FEA
0F770:  MOVFF  FEF,91A
0F774:  MOVFF  FEC,91B
0F778:  MOVFF  FEC,91C
0F77C:  MOVFF  FEC,91D
0F780:  MOVF   xD5,W
0F782:  MULLW  04
0F784:  MOVF   FF3,W
0F786:  CLRF   03
0F788:  ADDLW  F8
0F78A:  MOVWF  FE9
0F78C:  MOVLW  08
0F78E:  ADDWFC 03,W
0F790:  MOVWF  FEA
0F792:  MOVFF  FEF,00
0F796:  MOVFF  FEC,01
0F79A:  MOVFF  FEC,02
0F79E:  MOVFF  FEC,03
0F7A2:  MOVLB  9
0F7A4:  MOVF   x1A,W
0F7A6:  ADDWF  00,F
0F7A8:  MOVF   x1B,W
0F7AA:  ADDWFC 01,F
0F7AC:  MOVF   x1C,W
0F7AE:  ADDWFC 02,F
0F7B0:  MOVF   x1D,W
0F7B2:  ADDWFC 03,F
0F7B4:  MOVFF  919,FEA
0F7B8:  MOVFF  918,FE9
0F7BC:  MOVFF  00,FEF
0F7C0:  MOVFF  01,FEC
0F7C4:  MOVFF  02,FEC
0F7C8:  MOVFF  03,FEC
0F7CC:  MOVLB  8
0F7CE:  INCF   xD5,F
0F7D0:  BRA    F6FC
....................       } 
0F7D2:  INCF   xD6,F
0F7D4:  BTFSC  FD8.2
0F7D6:  INCF   xD7,F
0F7D8:  BRA    F6DC
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F7DA:  MOVLW  01
0F7DC:  MOVWF  xD5
0F7DE:  MOVF   xD5,W
0F7E0:  SUBLW  04
0F7E2:  BNC   F856
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F7E4:  BCF    FD8.0
0F7E6:  RLCF   xD5,W
0F7E8:  CLRF   03
0F7EA:  ADDLW  A5
0F7EC:  MOVWF  01
0F7EE:  MOVLW  04
0F7F0:  ADDWFC 03,F
0F7F2:  MOVFF  01,918
0F7F6:  MOVFF  03,919
0F7FA:  MOVLB  8
0F7FC:  MOVF   xD5,W
0F7FE:  MULLW  04
0F800:  MOVF   FF3,W
0F802:  CLRF   03
0F804:  ADDLW  D8
0F806:  MOVWF  FE9
0F808:  MOVLW  08
0F80A:  ADDWFC 03,W
0F80C:  MOVWF  FEA
0F80E:  MOVFF  FEF,A4C
0F812:  MOVFF  FEC,A4D
0F816:  MOVFF  FEC,A4E
0F81A:  MOVFF  FEC,A4F
0F81E:  BCF    FD8.1
0F820:  CLRF   1B
0F822:  BTFSC  FF2.7
0F824:  BSF    1B.7
0F826:  BCF    FF2.7
0F828:  MOVLB  A
0F82A:  CLRF   x53
0F82C:  CLRF   x52
0F82E:  MOVFF  8D4,A51
0F832:  MOVFF  8D3,A50
0F836:  MOVLB  0
0F838:  CALL   1076
0F83C:  BTFSC  1B.7
0F83E:  BSF    FF2.7
0F840:  MOVFF  919,FEA
0F844:  MOVFF  918,FE9
0F848:  MOVFF  00,FEF
0F84C:  MOVFF  01,FEC
0F850:  MOVLB  8
0F852:  INCF   xD5,F
0F854:  BRA    F7DE
....................    } 
0F856:  MOVLB  0
0F858:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    //Handle updating variables for the valve timeout 
....................    /*if(valve_align_timeout != -1){ 
....................       fprintf(COM_A,"align_var: %Ld \r\n",valve_align_timeout); 
....................       if(valve_align_timeout >= 2){ 
....................          valve_align_timeout = -1; 
....................          reset_cpu(); 
....................       } 
....................       valve_align_timeout++; 
....................    }*/ 
....................    //Service watchdog 
....................    output_bit(PIN_J7,(!input(PIN_J7))); 
*
00E34:  BTFSS  F88.7
00E36:  BRA    0E3C
00E38:  BCF    F91.7
00E3A:  BRA    0E3E
00E3C:  BSF    F91.7
....................     
....................    rtc_alarm = TRUE; 
00E3E:  BSF    4D.0
....................    sleep_mode = FALSE; 
00E40:  BCF    4D.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E42:  BTFSS  4D.2
00E44:  BRA    0E48
....................    { 
....................       ; 
00E46:  BRA    0E42
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E48:  BSF    4D.2
....................    RTC_read_flags(); 
00E4A:  RCALL  0DF8
....................    ++nv_elapsed; 
00E4C:  INCF   35,F
00E4E:  BTFSC  FD8.2
00E50:  INCF   36,F
.................... } 
....................  
00E52:  BCF    FF2.1
00E54:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E98:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E9A:  BTFSC  4D.1
00E9C:  BRA    0EEE
....................    { 
....................       if (kbhit(COM_A)) 
00E9E:  BTFSS  F9E.5
00EA0:  BRA    0EEC
....................       { 
....................          c = getc(COM_A); 
00EA2:  RCALL  0E58
00EA4:  MOVFF  01,A37
....................          switch (c) 
00EA8:  MOVLB  A
00EAA:  MOVF   x37,W
00EAC:  XORLW  3F
00EAE:  MOVLB  0
00EB0:  BZ    0EBC
00EB2:  XORLW  2E
00EB4:  BZ    0EE0
00EB6:  XORLW  0A
00EB8:  BZ    0EE6
00EBA:  BRA    0EEC
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00EBC:  DECFSZ 4E,W
00EBE:  BRA    0ED0
00EC0:  MOVLW  F8
00EC2:  MOVWF  FF6
00EC4:  MOVLW  0E
00EC6:  MOVWF  FF7
00EC8:  MOVLW  00
00ECA:  MOVWF  FF8
00ECC:  RCALL  0E6E
00ECE:  BRA    0EDE
....................                else fprintf(COM_A, "@RDY\r\n"); 
00ED0:  MOVLW  00
00ED2:  MOVWF  FF6
00ED4:  MOVLW  0F
00ED6:  MOVWF  FF7
00ED8:  MOVLW  00
00EDA:  MOVWF  FF8
00EDC:  RCALL  0E6E
....................                break; 
00EDE:  BRA    0EEC
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EE0:  MOVLW  01
00EE2:  MOVWF  50
....................                break;          
00EE4:  BRA    0EEC
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EE6:  CLRF   32
00EE8:  MOVLW  01
00EEA:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00EEC:  BRA    0EF2
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00EEE:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00EF0:  BCF    F9E.5
....................    } 
00EF2:  BCF    F9E.5
00EF4:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0AEE0:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0AEE2:  MOVF   FAE,W
....................    busy_status = FALSE; 
0AEE4:  CLRF   4E
0AEE6:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
029E8:  MOVLW  01
029EA:  MOVWF  4E
....................    clear_interrupt(INT_RDA); 
029EC:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
029EE:  BSF    F9D.5
029F0:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00F08:  MOVLW  0B
00F0A:  MOVWF  FD7
00F0C:  MOVLW  DC
00F0E:  MOVWF  FD6
....................    restart_wdt(); 
00F10:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00F12:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00F14:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00F16:  CLRF   FCF
00F18:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00F1A:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00F1C:  MOVF   2F,W
00F1E:  SUBLW  02
00F20:  BNZ   0F28
00F22:  MOVF   30,F
00F24:  BNZ   0F28
00F26:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00F28:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00F2A:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00F2C:  BCF    FF2.2
00F2E:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00F32:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00F34:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00F36:  MOVF   2F,W
00F38:  SUBLW  02
00F3A:  BNZ   0F42
00F3C:  MOVF   30,F
00F3E:  BNZ   0F42
00F40:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F42:  BCF    F9E.0
00F44:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
15D66:  MOVLB  8
15D68:  CLRF   x8C
15D6A:  CLRF   x90
15D6C:  CLRF   x8F
15D6E:  CLRF   x8E
15D70:  CLRF   x8D
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
15D72:  MOVLW  01
15D74:  ADDWF  x8D,F
15D76:  BTFSC  FD8.0
15D78:  INCF   x8E,F
15D7A:  BTFSC  FD8.2
15D7C:  INCF   x8F,F
15D7E:  BTFSC  FD8.2
15D80:  INCF   x90,F
15D82:  MOVF   x90,F
15D84:  BNZ   15DC6
15D86:  MOVF   x8F,W
15D88:  SUBLW  04
15D8A:  BNC   15DC6
15D8C:  BNZ   15D9C
15D8E:  MOVF   x8E,W
15D90:  SUBLW  93
15D92:  BNC   15DC6
15D94:  BNZ   15D9C
15D96:  MOVF   x8D,W
15D98:  SUBLW  DF
15D9A:  BNC   15DC6
....................    { 
....................       if(kbhit(COM_A)) 
15D9C:  BTFSS  F9E.5
15D9E:  BRA    15DBC
....................       { 
....................          c = fgetc(COM_A); 
15DA0:  MOVLB  0
15DA2:  CALL   0E58
15DA6:  MOVFF  01,88C
....................          if (com_echo == TRUE) 
15DAA:  DECFSZ 4C,W
15DAC:  BRA    15DB8
....................          { 
....................             fputc(c, COM_A); 
15DAE:  MOVLB  8
15DB0:  MOVF   x8C,W
15DB2:  MOVLB  0
15DB4:  CALL   AEE8
....................          } 
....................          break; 
15DB8:  MOVLB  8
15DBA:  BRA    15DC6
....................       } 
....................  
....................       delay_us(10); 
15DBC:  MOVLW  35
15DBE:  MOVWF  00
15DC0:  DECFSZ 00,F
15DC2:  BRA    15DC0
15DC4:  BRA    15D72
....................    } 
....................  
....................    return(c); 
15DC6:  MOVFF  88C,01
15DCA:  MOVLB  0
15DCC:  GOTO   15DDC (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AE5C:  MOVLW  58
0AE5E:  MOVLB  8
0AE60:  MOVWF  x64
0AE62:  CLRF   x68
0AE64:  CLRF   x67
0AE66:  CLRF   x66
0AE68:  CLRF   x65
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AE6A:  MOVLW  01
0AE6C:  ADDWF  x65,F
0AE6E:  BTFSC  FD8.0
0AE70:  INCF   x66,F
0AE72:  BTFSC  FD8.2
0AE74:  INCF   x67,F
0AE76:  BTFSC  FD8.2
0AE78:  INCF   x68,F
0AE7A:  MOVF   x68,F
0AE7C:  BNZ   AEAC
0AE7E:  MOVF   x67,F
0AE80:  BNZ   AEAC
0AE82:  MOVF   x66,W
0AE84:  SUBLW  C3
0AE86:  BNC   AEAC
0AE88:  BNZ   AE90
0AE8A:  MOVF   x65,W
0AE8C:  SUBLW  4F
0AE8E:  BNC   AEAC
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AE90:  MOVLW  05
0AE92:  MOVWF  00
0AE94:  DECFSZ 00,F
0AE96:  BRA    AE94
....................  
....................       if(kbhit()) 
0AE98:  BTFSS  F9E.5
0AE9A:  BRA    AEAA
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AE9C:  MOVLB  0
0AE9E:  CALL   0E58
0AEA2:  MOVFF  01,864
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AEA6:  MOVLB  8
0AEA8:  BRA    AEAC
....................       } 
0AEAA:  BRA    AE6A
....................    } 
....................  
....................    return(EscChar); 
0AEAC:  MOVFF  864,01
0AEB0:  MOVLB  0
0AEB2:  GOTO   1BA8C (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0DAA8:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0DAAA:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0DAAC:  BSF    F8F.3
....................    delay_ms(10); 
0DAAE:  MOVLW  0A
0DAB0:  MOVLB  9
0DAB2:  MOVWF  xEC
0DAB4:  MOVLB  0
0DAB6:  CALL   2938
0DABA:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0DB94:  MOVLB  8
0DB96:  CLRF   xF4
0DB98:  CLRF   xF3
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0DB9A:  MOVLB  F
0DB9C:  BTFSC  x21.1
0DB9E:  BRA    DBAC
....................       ++c; 
0DBA0:  MOVLB  8
0DBA2:  INCF   xF3,F
0DBA4:  BTFSC  FD8.2
0DBA6:  INCF   xF4,F
0DBA8:  BRA    DB9A
0DBAA:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0DBAC:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0DBAE:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0DBB0:  BCF    F8F.3
0DBB2:  MOVLB  0
0DBB4:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
16FA4:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
16FA6:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
16FA8:  BCF    F8F.3
16FAA:  GOTO   17098 (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
16FAE:  MOVLB  8
16FB0:  CLRF   x85
16FB2:  CLRF   x86
16FB4:  CLRF   xD7
16FB6:  CLRF   xD8
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16FB8:  MOVLW  48
16FBA:  MOVWF  FF6
16FBC:  MOVLW  0F
16FBE:  MOVWF  FF7
16FC0:  MOVLW  00
16FC2:  MOVWF  FF8
16FC4:  CLRF   1B
16FC6:  BTFSC  FF2.7
16FC8:  BSF    1B.7
16FCA:  BCF    FF2.7
16FCC:  MOVLB  0
16FCE:  CALL   0E6E
16FD2:  BTFSC  1B.7
16FD4:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16FD6:  MOVLB  8
16FD8:  MOVF   x86,W
16FDA:  SUBLW  04
16FDC:  BZ    17094
....................    { 
....................        if (kbhit(COM_A)) 
16FDE:  BTFSS  F9E.5
16FE0:  BRA    17078
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16FE2:  MOVLB  0
16FE4:  CALL   0E58
16FE8:  MOVFF  01,885
....................           if (com_echo == TRUE) 
16FEC:  DECFSZ 4C,W
16FEE:  BRA    16FFA
....................           { 
....................              fputc(charFromA, COM_A); 
16FF0:  MOVLB  8
16FF2:  MOVF   x85,W
16FF4:  MOVLB  0
16FF6:  CALL   AEE8
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16FFA:  MOVLB  8
16FFC:  MOVF   xD8,W
16FFE:  SUBLW  4F
17000:  BNC   17056
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
17002:  MOVF   xD8,W
17004:  INCF   xD8,F
17006:  CLRF   03
17008:  ADDLW  87
1700A:  MOVWF  FE9
1700C:  MOVLW  08
1700E:  ADDWFC 03,W
17010:  MOVWF  FEA
17012:  MOVFF  885,FEF
....................              if (CARRIAGE_RET == charFromA) 
17016:  MOVF   x85,W
17018:  SUBLW  0D
1701A:  BNZ   17054
....................              { 
....................                 multidrop_on(); 
1701C:  MOVLB  0
1701E:  CALL   DAA8
....................                 for (index = 0 ; index < charCount; index++) 
17022:  MOVLB  8
17024:  CLRF   xD7
17026:  MOVF   xD8,W
17028:  SUBWF  xD7,W
1702A:  BC    1704A
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
1702C:  CLRF   03
1702E:  MOVF   xD7,W
17030:  ADDLW  87
17032:  MOVWF  FE9
17034:  MOVLW  08
17036:  ADDWFC 03,W
17038:  MOVWF  FEA
1703A:  MOVFF  FEF,8D9
1703E:  MOVF   xD9,W
17040:  MOVLB  0
17042:  BRA    16F96
17044:  MOVLB  8
17046:  INCF   xD7,F
17048:  BRA    17026
....................                 } 
....................                 charCount = 0; 
1704A:  CLRF   xD8
....................                 multidrop_off(); 
1704C:  MOVLB  0
1704E:  CALL   DB94
17052:  MOVLB  8
....................              } 
....................           } 
17054:  BRA    17078
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
17056:  MOVLW  50
17058:  MOVWF  FF6
1705A:  MOVLW  0F
1705C:  MOVWF  FF7
1705E:  MOVLW  00
17060:  MOVWF  FF8
17062:  CLRF   1B
17064:  BTFSC  FF2.7
17066:  BSF    1B.7
17068:  BCF    FF2.7
1706A:  MOVLB  0
1706C:  CALL   0E6E
17070:  BTFSC  1B.7
17072:  BSF    FF2.7
....................              charCount = 0; 
17074:  MOVLB  8
17076:  CLRF   xD8
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
17078:  BTFSS  FA4.5
1707A:  BRA    17092
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
1707C:  MOVLB  0
1707E:  CALL   12E62
17082:  MOVFF  01,886
....................           fputc(charFromB, COM_A);                  // send data via USART 
17086:  MOVLB  8
17088:  MOVF   x86,W
1708A:  MOVLB  0
1708C:  CALL   AEE8
17090:  MOVLB  8
....................        } 
17092:  BRA    16FD8
....................    } 
....................  
....................    multidrop_shdn(); 
17094:  MOVLB  0
17096:  BRA    16FA4
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
17098:  MOVLW  60
1709A:  MOVWF  FF6
1709C:  MOVLW  0F
1709E:  MOVWF  FF7
170A0:  MOVLW  00
170A2:  MOVWF  FF8
170A4:  CLRF   1B
170A6:  BTFSC  FF2.7
170A8:  BSF    1B.7
170AA:  BCF    FF2.7
170AC:  CALL   0E6E
170B0:  BTFSC  1B.7
170B2:  BSF    FF2.7
170B4:  GOTO   170CE (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C8A4:  MOVLB  8
0C8A6:  DECF   x9F,F
....................    len=0; 
0C8A8:  CLRF   xA0
....................    do { 
....................      c=getc(); 
0C8AA:  MOVLB  0
0C8AC:  CALL   0E58
0C8B0:  MOVFF  01,8A1
....................      if(c==8) {  // Backspace 
0C8B4:  MOVLB  8
0C8B6:  MOVF   xA1,W
0C8B8:  SUBLW  08
0C8BA:  BNZ   C8DE
....................         if(len>0) { 
0C8BC:  MOVF   xA0,F
0C8BE:  BZ    C8DC
....................           len--; 
0C8C0:  DECF   xA0,F
....................           putc(c); 
0C8C2:  MOVF   xA1,W
0C8C4:  MOVLB  0
0C8C6:  CALL   AEE8
....................           putc(' '); 
0C8CA:  MOVLW  20
0C8CC:  CALL   AEE8
....................           putc(c); 
0C8D0:  MOVLB  8
0C8D2:  MOVF   xA1,W
0C8D4:  MOVLB  0
0C8D6:  CALL   AEE8
0C8DA:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C8DC:  BRA    C90C
0C8DE:  MOVF   xA1,W
0C8E0:  SUBLW  1F
0C8E2:  BC    C90C
0C8E4:  MOVF   xA1,W
0C8E6:  SUBLW  7E
0C8E8:  BNC   C90C
....................        if(len<=max) { 
0C8EA:  MOVF   xA0,W
0C8EC:  SUBWF  x9F,W
0C8EE:  BNC   C90C
....................          s[len++]=c; 
0C8F0:  MOVF   xA0,W
0C8F2:  INCF   xA0,F
0C8F4:  ADDWF  x9D,W
0C8F6:  MOVWF  FE9
0C8F8:  MOVLW  00
0C8FA:  ADDWFC x9E,W
0C8FC:  MOVWF  FEA
0C8FE:  MOVFF  8A1,FEF
....................          putc(c); 
0C902:  MOVF   xA1,W
0C904:  MOVLB  0
0C906:  CALL   AEE8
0C90A:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C90C:  MOVF   xA1,W
0C90E:  SUBLW  0D
0C910:  BNZ   C8AA
....................    s[len]=0; 
0C912:  MOVF   xA0,W
0C914:  ADDWF  x9D,W
0C916:  MOVWF  FE9
0C918:  MOVLW  00
0C91A:  ADDWFC x9E,W
0C91C:  MOVWF  FEA
0C91E:  CLRF   FEF
0C920:  MOVLB  0
0C922:  GOTO   CD48 (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0CD36:  MOVLW  08
0CD38:  MOVLB  8
0CD3A:  MOVWF  x9E
0CD3C:  MOVLW  85
0CD3E:  MOVWF  x9D
0CD40:  MOVLW  14
0CD42:  MOVWF  x9F
0CD44:  MOVLB  0
0CD46:  BRA    C8A4
....................   f = atof(s); 
0CD48:  MOVLW  08
0CD4A:  MOVLB  8
0CD4C:  MOVWF  x9E
0CD4E:  MOVLW  85
0CD50:  MOVWF  x9D
0CD52:  CLRF   xA0
0CD54:  CLRF   x9F
0CD56:  MOVLB  0
0CD58:  BRA    CADA
0CD5A:  MOVFF  03,89C
0CD5E:  MOVFF  02,89B
0CD62:  MOVFF  01,89A
0CD66:  MOVFF  00,899
....................   return(f); 
0CD6A:  MOVFF  899,00
0CD6E:  MOVFF  89A,01
0CD72:  MOVFF  89B,02
0CD76:  MOVFF  89C,03
0CD7A:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
02962:  MOVLW  2F
02964:  MOVWF  F92
....................    set_tris_b(0b00110111); 
02966:  MOVLW  37
02968:  MOVWF  F93
....................    set_tris_c(0b10010000); 
0296A:  MOVLW  90
0296C:  MOVWF  F94
....................    set_tris_d(0b00100000); 
0296E:  MOVLW  20
02970:  MOVWF  F95
....................    set_tris_e(0b01000000); 
02972:  MOVLW  40
02974:  MOVWF  F96
....................    set_tris_f(0b00000000); 
02976:  MOVLW  00
02978:  MOVWF  F97
....................    set_tris_g(0b11100100); 
0297A:  MOVLW  E4
0297C:  MOVWF  F98
....................    set_tris_h(0b01000000); 
0297E:  MOVLW  40
02980:  MOVWF  F99
....................    set_tris_j(0b00000000); 
02982:  MOVLW  00
02984:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
02986:  BCF    F8E.3
....................    output_low(HB_IN1); 
02988:  BCF    F8E.4
....................    output_low(HB_IN2); 
0298A:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
0298C:  BCF    F91.3
....................    output_high(EEP_CS);        
0298E:  BSF    F91.2
....................    output_high(RTC_CS); 
02990:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
02992:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
02994:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
02996:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
02998:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
0299A:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
0299C:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
0299E:  BCF    F8F.3
....................    delay_ms(20);   
029A0:  MOVLW  14
029A2:  MOVLB  9
029A4:  MOVWF  xEC
029A6:  MOVLB  0
029A8:  RCALL  2938
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
029AA:  BCF    F8E.1
....................    output_low(VDET);     
029AC:  BCF    F90.7
....................    bus_pwr_status=0; 
029AE:  MOVLB  4
029B0:  CLRF   xB6
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
029B2:  BSF    F8C.2
....................    output_high(DAC_CS); 
029B4:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
029B6:  BCF    F8C.0
....................    output_low(HSW2); 
029B8:  BCF    F8C.1
....................    heater_stat=0; 
029BA:  CLRF   xB5
029BC:  MOVLB  0
029BE:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
15C94:  BSF    F91.1
....................    output_low(EEP_WP);        
15C96:  BCF    F91.3
....................    output_high(EEP_CS);        
15C98:  BSF    F91.2
....................    output_high(RTC_CS);  
15C9A:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
15C9C:  BCF    F8E.3
....................    output_low(HB_IN1);        
15C9E:  BCF    F8E.4
....................    output_low(HB_IN2); 
15CA0:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
15CA2:  BCF    F8C.2
....................    output_low(DAC_CS); 
15CA4:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
15CA6:  BCF    F8C.0
....................    output_low(HSW2); 
15CA8:  BCF    F8C.1
....................    heater_stat=0; 
15CAA:  MOVLB  4
15CAC:  CLRF   xB5
....................    // Power switches 
....................    output_low(VMOT);         
15CAE:  BCF    F8E.1
....................    output_low(VDET);  
15CB0:  BCF    F90.7
....................    bus_pwr_status=0; 
15CB2:  CLRF   xB6
....................    output_low(VENC1);         
15CB4:  BCF    F8E.6
....................    output_low(VENC2);         
15CB6:  BCF    F8E.7
....................    output_low(VHBRDG);  
15CB8:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
15CBA:  MOVLW  68
15CBC:  MOVWF  FF6
15CBE:  MOVLW  0F
15CC0:  MOVWF  FF7
15CC2:  MOVLW  00
15CC4:  MOVWF  FF8
15CC6:  CLRF   1B
15CC8:  BTFSC  FF2.7
15CCA:  BSF    1B.7
15CCC:  BCF    FF2.7
15CCE:  MOVLB  0
15CD0:  CALL   0E6E
15CD4:  BTFSC  1B.7
15CD6:  BSF    FF2.7
....................    delay_ms(50); 
15CD8:  MOVLW  32
15CDA:  MOVLB  9
15CDC:  MOVWF  xEC
15CDE:  MOVLB  0
15CE0:  CALL   2938
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
15CE4:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
15CE6:  BSF    F91.6
....................    output_low(MD1_TXEN); 
15CE8:  BCF    F91.5
....................    output_low(MD2_SHDN);    
15CEA:  BCF    F8F.0
....................    output_low(MD2_REN); 
15CEC:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
15CEE:  BCF    F8F.3
....................  
....................    delay_ms(30); 
15CF0:  MOVLW  1E
15CF2:  MOVLB  9
15CF4:  MOVWF  xEC
15CF6:  MOVLB  0
15CF8:  CALL   2938
15CFC:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
05062:  MOVLB  8
05064:  CLRF   x89
05066:  MOVF   x89,W
05068:  SUBLW  02
0506A:  BNC   5090
....................       FS_Status = f_mountdrv(); 
0506C:  MOVLB  0
0506E:  RCALL  487E
05070:  MOVFF  01,724
....................       if (FS_Status) 
05074:  MOVLB  7
05076:  MOVF   x24,F
05078:  BZ    5084
....................          { 
....................          display_file_result(FS_Status); 
0507A:  MOVFF  724,88A
0507E:  MOVLB  0
05080:  BRA    4E1C
....................          } 
05082:  BRA    508A
....................       else break; 
05084:  MOVLB  8
05086:  BRA    5090
05088:  MOVLB  0
0508A:  MOVLB  8
0508C:  INCF   x89,F
0508E:  BRA    5066
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
05090:  MOVLW  3E
05092:  MOVWF  xEE
05094:  CLRF   xF0
05096:  MOVFF  724,8EF
0509A:  MOVLB  0
0509C:  RCALL  4FFC
....................     
....................    return(FS_Status); 
0509E:  MOVLB  7
050A0:  MOVFF  724,01
050A4:  MOVLB  0
050A6:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
03124:  MOVLW  01
03126:  MOVLB  8
03128:  MOVWF  x64
0312A:  MOVF   x64,W
0312C:  SUBLW  03
0312E:  BNC   316A
....................    { 
....................       output_bit(BOARD_LED, ON); 
03130:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
03132:  MOVF   2F,W
03134:  SUBLW  02
03136:  BNZ   313E
03138:  MOVF   30,F
0313A:  BNZ   313E
0313C:  BSF    F90.6
....................       delay_ms(32); 
0313E:  MOVLW  20
03140:  MOVLB  9
03142:  MOVWF  xEC
03144:  MOVLB  0
03146:  CALL   2938
....................       output_bit(BOARD_LED, OFF); 
0314A:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
0314C:  MOVF   2F,W
0314E:  SUBLW  02
03150:  BNZ   3158
03152:  MOVF   30,F
03154:  BNZ   3158
03156:  BCF    F90.6
....................       delay_ms(32); 
03158:  MOVLW  20
0315A:  MOVLB  9
0315C:  MOVWF  xEC
0315E:  MOVLB  0
03160:  CALL   2938
03164:  MOVLB  8
03166:  INCF   x64,F
03168:  BRA    312A
....................    } 
0316A:  MOVLB  0
0316C:  GOTO   1B88C (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
05124:  MOVLB  8
05126:  CLRF   xF3
05128:  CLRF   xF2
0512A:  CLRF   xF1
0512C:  CLRF   xF0
....................    set_adc_channel(0,VSS); 
0512E:  MOVLW  00
05130:  MOVWF  01
05132:  MOVF   FC2,W
05134:  ANDLW  83
05136:  IORWF  01,W
05138:  MOVWF  FC2
0513A:  MOVLW  00
0513C:  MOVWF  01
0513E:  MOVF   FC1,W
05140:  ANDLW  F8
05142:  IORWF  01,W
05144:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
05146:  MOVLW  01
05148:  MOVWF  xED
0514A:  MOVF   xED,W
0514C:  SUBLW  32
0514E:  BNC   5174
....................       reading=read_adc(); 
05150:  BSF    FC2.1
05152:  BTFSC  FC2.1
05154:  BRA    5152
05156:  MOVFF  FC3,8F4
0515A:  MOVFF  FC4,8F5
0515E:  CLRF   xF6
05160:  CLRF   xF7
....................       delay_ms(5); 
05162:  MOVLW  05
05164:  MOVLB  9
05166:  MOVWF  xEC
05168:  MOVLB  0
0516A:  CALL   2938
0516E:  MOVLB  8
05170:  INCF   xED,F
05172:  BRA    514A
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
05174:  MOVLW  01
05176:  MOVWF  xED
05178:  MOVF   xED,W
0517A:  SUBLW  64
0517C:  BNC   522A
....................       reading=read_adc(); 
0517E:  BSF    FC2.1
05180:  BTFSC  FC2.1
05182:  BRA    5180
05184:  MOVFF  FC3,8F4
05188:  MOVFF  FC4,8F5
0518C:  CLRF   xF6
0518E:  CLRF   xF7
....................       result=(((result*(i-1))+reading)/i); 
05190:  MOVLW  01
05192:  SUBWF  xED,W
05194:  MOVWF  xF8
05196:  MOVFF  8F3,9F9
0519A:  MOVFF  8F2,9F8
0519E:  MOVFF  8F1,9F7
051A2:  MOVFF  8F0,9F6
051A6:  MOVLB  9
051A8:  CLRF   xFD
051AA:  CLRF   xFC
051AC:  CLRF   xFB
051AE:  MOVWF  xFA
051B0:  MOVLB  0
051B2:  CALL   4818
051B6:  MOVFF  03,8FB
051BA:  MOVFF  02,8FA
051BE:  MOVFF  01,8F9
051C2:  MOVFF  00,8F8
051C6:  MOVLB  8
051C8:  MOVF   xF4,W
051CA:  ADDWF  xF8,F
051CC:  MOVF   xF5,W
051CE:  ADDWFC xF9,F
051D0:  MOVF   xF6,W
051D2:  ADDWFC xFA,F
051D4:  MOVF   xF7,W
051D6:  ADDWFC xFB,F
051D8:  BCF    FD8.1
051DA:  CLRF   1B
051DC:  BTFSC  FF2.7
051DE:  BSF    1B.7
051E0:  BCF    FF2.7
051E2:  MOVFF  8FB,A4F
051E6:  MOVFF  8FA,A4E
051EA:  MOVFF  8F9,A4D
051EE:  MOVFF  8F8,A4C
051F2:  MOVLB  A
051F4:  CLRF   x53
051F6:  CLRF   x52
051F8:  CLRF   x51
051FA:  MOVFF  8ED,A50
051FE:  MOVLB  0
05200:  CALL   1076
05204:  BTFSC  1B.7
05206:  BSF    FF2.7
05208:  MOVFF  03,8F3
0520C:  MOVFF  02,8F2
05210:  MOVFF  01,8F1
05214:  MOVFF  00,8F0
....................       delay_ms(5); 
05218:  MOVLW  05
0521A:  MOVLB  9
0521C:  MOVWF  xEC
0521E:  MOVLB  0
05220:  CALL   2938
05224:  MOVLB  8
05226:  INCF   xED,F
05228:  BRA    5178
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
0522A:  MOVFF  8F3,9F9
0522E:  MOVFF  8F2,9F8
05232:  MOVFF  8F1,9F7
05236:  MOVFF  8F0,9F6
0523A:  MOVLB  9
0523C:  CLRF   xFD
0523E:  CLRF   xFC
05240:  CLRF   xFB
05242:  MOVLW  64
05244:  MOVWF  xFA
05246:  MOVLB  0
05248:  CALL   4818
0524C:  MOVFF  03,8FB
05250:  MOVFF  02,8FA
05254:  MOVFF  01,8F9
05258:  MOVFF  00,8F8
0525C:  BCF    FD8.1
0525E:  CLRF   1B
05260:  BTFSC  FF2.7
05262:  BSF    1B.7
05264:  BCF    FF2.7
05266:  MOVFF  03,A4F
0526A:  MOVFF  02,A4E
0526E:  MOVFF  01,A4D
05272:  MOVFF  00,A4C
05276:  MOVLB  A
05278:  CLRF   x53
0527A:  CLRF   x52
0527C:  MOVLW  01
0527E:  MOVWF  x51
05280:  MOVLW  10
05282:  MOVWF  x50
05284:  MOVLB  0
05286:  CALL   1076
0528A:  BTFSC  1B.7
0528C:  BSF    FF2.7
0528E:  MOVLW  56
05290:  MOVLB  8
05292:  ADDWF  00,W
05294:  MOVWF  xEE
05296:  MOVLW  00
05298:  ADDWFC 01,W
0529A:  MOVWF  xEF
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
0529C:  MOVFF  8EE,01
052A0:  MOVFF  8EF,02
052A4:  MOVLB  0
052A6:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
0510E:  MOVLW  02
05110:  MOVWF  FEA
05112:  MOVLW  99
05114:  MOVWF  FE9
05116:  CLRF   00
05118:  CLRF   02
0511A:  MOVLW  1E
0511C:  MOVWF  01
0511E:  CALL   354E
05122:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
12D8A:  MOVLW  02
12D8C:  MOVWF  FEA
12D8E:  MOVLW  B7
12D90:  MOVWF  FE9
12D92:  CLRF   00
12D94:  CLRF   02
12D96:  MOVLW  1E
12D98:  MOVWF  01
12D9A:  CALL   354E
12D9E:  GOTO   13048 (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
05442:  RCALL  510E
....................     
....................    v_supply = read_supply(); 
05444:  RCALL  5124
05446:  MOVFF  02,8EC
0544A:  MOVFF  01,8EB
....................    RTC_read(); 
0544E:  CALL   336C
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
05452:  MOVLW  02
05454:  MOVWF  1E
05456:  MOVLW  99
05458:  MOVWF  1D
0545A:  MOVFF  72A,8ED
0545E:  MOVLW  01
05460:  MOVLB  8
05462:  MOVWF  xEE
05464:  MOVLB  0
05466:  RCALL  52A8
05468:  MOVLW  2F
0546A:  MOVLB  8
0546C:  MOVWF  xFF
0546E:  MOVLB  0
05470:  RCALL  50C6
05472:  MOVFF  729,8ED
05476:  MOVLW  01
05478:  MOVLB  8
0547A:  MOVWF  xEE
0547C:  MOVLB  0
0547E:  RCALL  52A8
05480:  MOVLW  2F
05482:  MOVLB  8
05484:  MOVWF  xFF
05486:  MOVLB  0
05488:  RCALL  50C6
0548A:  MOVFF  72B,8ED
0548E:  MOVLW  01
05490:  MOVLB  8
05492:  MOVWF  xEE
05494:  MOVLB  0
05496:  RCALL  52A8
05498:  MOVLW  20
0549A:  MOVLB  8
0549C:  MOVWF  xFF
0549E:  MOVLB  0
054A0:  RCALL  50C6
054A2:  MOVFF  727,8ED
054A6:  MOVLW  01
054A8:  MOVLB  8
054AA:  MOVWF  xEE
054AC:  MOVLB  0
054AE:  RCALL  52A8
054B0:  MOVLW  3A
054B2:  MOVLB  8
054B4:  MOVWF  xFF
054B6:  MOVLB  0
054B8:  RCALL  50C6
054BA:  MOVFF  726,8ED
054BE:  MOVLW  01
054C0:  MOVLB  8
054C2:  MOVWF  xEE
054C4:  MOVLB  0
054C6:  RCALL  52A8
054C8:  MOVLW  3A
054CA:  MOVLB  8
054CC:  MOVWF  xFF
054CE:  MOVLB  0
054D0:  RCALL  50C6
054D2:  MOVFF  725,8ED
054D6:  MOVLW  01
054D8:  MOVLB  8
054DA:  MOVWF  xEE
054DC:  MOVLB  0
054DE:  RCALL  52A8
054E0:  MOVLW  2C
054E2:  MOVLB  8
054E4:  MOVWF  xFF
054E6:  MOVLB  0
054E8:  RCALL  50C6
054EA:  MOVLW  44
054EC:  MOVWF  FE9
054EE:  MOVLB  8
054F0:  CLRF   xF0
054F2:  CLRF   xEF
054F4:  MOVFF  8EC,8EE
054F8:  MOVFF  8EB,8ED
054FC:  MOVLW  02
054FE:  MOVWF  xF1
05500:  MOVLB  0
05502:  RCALL  5342
05504:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
08502:  MOVLB  2
08504:  MOVF   xDC,F
08506:  BNZ   8582
....................    { 
....................       strcopy(event_buffer,""); 
08508:  MOVLW  01
0850A:  MOVWF  FEA
0850C:  MOVLW  07
0850E:  MOVWF  FE9
08510:  MOVLW  00
08512:  MOVLB  0
08514:  CALL   02CE
08518:  TBLRD*-
0851A:  TBLRD*+
0851C:  MOVF   FF5,W
0851E:  MOVWF  FEE
08520:  IORLW  00
08522:  BNZ   851A
....................       time_stamp(); 
08524:  CALL   5442
....................       strcat(event_buffer, time_stmp_str); 
08528:  MOVLW  01
0852A:  MOVLB  8
0852C:  MOVWF  xF9
0852E:  MOVLW  07
08530:  MOVWF  xF8
08532:  MOVLW  02
08534:  MOVWF  xFB
08536:  MOVLW  99
08538:  MOVWF  xFA
0853A:  MOVLB  0
0853C:  CALL   5506
....................       strcat(event_buffer, event_str); 
08540:  MOVLW  01
08542:  MOVLB  8
08544:  MOVWF  xF9
08546:  MOVLW  07
08548:  MOVWF  xF8
0854A:  MOVLW  01
0854C:  MOVWF  xFB
0854E:  MOVLW  A7
08550:  MOVWF  xFA
08552:  MOVLB  0
08554:  CALL   5506
....................       buffer_select = 1; 
08558:  MOVLW  01
0855A:  MOVWF  x66
....................     
....................       heartbeat(FALSE); 
0855C:  MOVLB  8
0855E:  CLRF   xED
08560:  MOVLB  0
08562:  CALL   55AE
....................          append_data(file_ptr_events); 
08566:  MOVLW  03
08568:  MOVLB  8
0856A:  MOVWF  xEE
0856C:  MOVLW  15
0856E:  MOVWF  xED
08570:  MOVLB  0
08572:  RCALL  8320
....................       heartbeat(TRUE); 
08574:  MOVLW  01
08576:  MOVLB  8
08578:  MOVWF  xED
0857A:  MOVLB  0
0857C:  CALL   55AE
08580:  MOVLB  2
....................    } 
08582:  MOVLB  0
08584:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
028EC:  BCF    F8B.2
028EE:  MOVLW  0C
028F0:  MOVWF  FBB
028F2:  CLRF   FBE
028F4:  CLRF   FBF
028F6:  MOVLW  01
028F8:  MOVWF  F9C
028FA:  MOVLW  F8
028FC:  MOVLB  F
028FE:  ANDWF  x2D,F
02900:  MOVLW  00
02902:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
02904:  BCF    F8B.1
02906:  MOVLW  0C
02908:  MOVWF  x4E
0290A:  CLRF   x51
0290C:  CLRF   x52
0290E:  MOVLW  01
02910:  MOVWF  x1B
02912:  MOVLW  C7
02914:  ANDWF  x2D,F
02916:  MOVLW  00
02918:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
0291A:  IORLW  05
0291C:  MOVWF  FCA
0291E:  MOVLW  7F
02920:  MOVWF  FCB
02922:  MOVLB  0
02924:  GOTO   1B842 (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09D2A:  MOVLW  72
09D2C:  MOVWF  FF6
09D2E:  MOVLW  0F
09D30:  MOVWF  FF7
09D32:  MOVLW  00
09D34:  MOVWF  FF8
09D36:  CLRF   1B
09D38:  BTFSC  FF2.7
09D3A:  BSF    1B.7
09D3C:  BCF    FF2.7
09D3E:  MOVLW  05
09D40:  MOVLB  A
09D42:  MOVWF  x40
09D44:  MOVLB  0
09D46:  CALL   1044
09D4A:  BTFSC  1B.7
09D4C:  BSF    FF2.7
09D4E:  MOVLW  10
09D50:  MOVWF  FE9
09D52:  CLRF   1B
09D54:  BTFSC  FF2.7
09D56:  BSF    1B.7
09D58:  BCF    FF2.7
09D5A:  MOVFF  797,A41
09D5E:  MOVFF  796,A40
09D62:  CALL   11C6
09D66:  BTFSC  1B.7
09D68:  BSF    FF2.7
09D6A:  MOVLW  2C
09D6C:  BTFSS  F9E.4
09D6E:  BRA    9D6C
09D70:  MOVWF  FAD
09D72:  MOVLW  10
09D74:  MOVWF  FE9
09D76:  CLRF   1B
09D78:  BTFSC  FF2.7
09D7A:  BSF    1B.7
09D7C:  BCF    FF2.7
09D7E:  MOVFF  799,A41
09D82:  MOVFF  798,A40
09D86:  CALL   11C6
09D8A:  BTFSC  1B.7
09D8C:  BSF    FF2.7
09D8E:  MOVLW  0D
09D90:  BTFSS  F9E.4
09D92:  BRA    9D90
09D94:  MOVWF  FAD
09D96:  MOVLW  0A
09D98:  BTFSS  F9E.4
09D9A:  BRA    9D98
09D9C:  MOVWF  FAD
09D9E:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02D42:  MOVLW  86
02D44:  MOVLB  8
02D46:  MOVWF  x97
02D48:  MOVLB  0
02D4A:  RCALL  29F2
02D4C:  MOVFF  02,743
02D50:  MOVFF  01,742
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02D54:  MOVLW  8A
02D56:  MOVLB  8
02D58:  MOVWF  x97
02D5A:  MOVLB  0
02D5C:  RCALL  29F2
02D5E:  MOVFF  02,747
02D62:  MOVFF  01,746
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02D66:  MOVLW  8E
02D68:  MOVLB  8
02D6A:  MOVWF  x97
02D6C:  MOVLB  0
02D6E:  RCALL  29F2
02D70:  MOVFF  02,74B
02D74:  MOVFF  01,74A
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02D78:  MOVLW  92
02D7A:  MOVLB  8
02D7C:  MOVWF  x97
02D7E:  MOVLB  0
02D80:  RCALL  29F2
02D82:  MOVFF  02,74F
02D86:  MOVFF  01,74E
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02D8A:  MOVLW  96
02D8C:  MOVLB  8
02D8E:  MOVWF  x97
02D90:  MOVLB  0
02D92:  RCALL  29F2
02D94:  MOVFF  02,753
02D98:  MOVFF  01,752
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02D9C:  MOVLW  9A
02D9E:  MOVLB  8
02DA0:  MOVWF  x97
02DA2:  MOVLB  0
02DA4:  RCALL  29F2
02DA6:  MOVFF  02,757
02DAA:  MOVFF  01,756
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02DAE:  MOVLW  9E
02DB0:  MOVLB  8
02DB2:  MOVWF  x97
02DB4:  MOVLB  0
02DB6:  RCALL  29F2
02DB8:  MOVFF  02,75B
02DBC:  MOVFF  01,75A
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02DC0:  MOVLW  A2
02DC2:  MOVLB  8
02DC4:  MOVWF  x97
02DC6:  MOVLB  0
02DC8:  RCALL  29F2
02DCA:  MOVFF  02,75F
02DCE:  MOVFF  01,75E
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02DD2:  MOVLW  A6
02DD4:  MOVLB  8
02DD6:  MOVWF  x97
02DD8:  MOVLB  0
02DDA:  RCALL  29F2
02DDC:  MOVFF  02,763
02DE0:  MOVFF  01,762
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02DE4:  MOVLW  82
02DE6:  MOVLB  8
02DE8:  MOVWF  x97
02DEA:  MOVLB  0
02DEC:  RCALL  29F2
02DEE:  MOVFF  02,767
02DF2:  MOVFF  01,766
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02DF6:  MOVLW  7E
02DF8:  MOVLB  8
02DFA:  MOVWF  x97
02DFC:  MOVLB  0
02DFE:  RCALL  29F2
02E00:  MOVFF  02,7C0
02E04:  MOVFF  01,7BF
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02E08:  MOVLW  AA
02E0A:  MOVLB  8
02E0C:  MOVWF  x97
02E0E:  MOVLB  0
02E10:  RCALL  29F2
02E12:  MOVFF  02,7C4
02E16:  MOVFF  01,7C3
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02E1A:  MOVLW  7A
02E1C:  MOVLB  8
02E1E:  MOVWF  x97
02E20:  MOVLB  0
02E22:  RCALL  29F2
02E24:  MOVFF  02,76B
02E28:  MOVFF  01,76A
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02E2C:  MOVLW  76
02E2E:  MOVLB  8
02E30:  MOVWF  x97
02E32:  MOVLB  0
02E34:  RCALL  29F2
02E36:  MOVFF  02,76F
02E3A:  MOVFF  01,76E
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02E3E:  MOVLW  72
02E40:  MOVLB  8
02E42:  MOVWF  x97
02E44:  MOVLB  0
02E46:  RCALL  29F2
02E48:  MOVFF  02,773
02E4C:  MOVFF  01,772
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02E50:  MOVLW  6E
02E52:  MOVLB  8
02E54:  MOVWF  x97
02E56:  MOVLB  0
02E58:  RCALL  29F2
02E5A:  MOVFF  02,797
02E5E:  MOVFF  01,796
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02E62:  MOVLW  AE
02E64:  MOVLB  8
02E66:  MOVWF  x97
02E68:  MOVLB  0
02E6A:  RCALL  29F2
02E6C:  MOVFF  02,777
02E70:  MOVFF  01,776
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02E74:  MOVLW  B2
02E76:  MOVLB  8
02E78:  MOVWF  x97
02E7A:  MOVLB  0
02E7C:  RCALL  29F2
02E7E:  MOVFF  02,7B0
02E82:  MOVFF  01,7AF
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02E86:  MOVLW  B6
02E88:  MOVLB  8
02E8A:  MOVWF  x97
02E8C:  MOVLB  0
02E8E:  RCALL  29F2
02E90:  MOVFF  02,7B4
02E94:  MOVFF  01,7B3
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02E98:  MOVLW  BA
02E9A:  MOVLB  8
02E9C:  MOVWF  x97
02E9E:  MOVLB  0
02EA0:  RCALL  29F2
02EA2:  MOVFF  02,77B
02EA6:  MOVFF  01,77A
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02EAA:  MOVLW  BE
02EAC:  MOVLB  8
02EAE:  MOVWF  x97
02EB0:  MOVLB  0
02EB2:  RCALL  29F2
02EB4:  MOVFF  02,77F
02EB8:  MOVFF  01,77E
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02EBC:  MOVLW  C2
02EBE:  MOVLB  8
02EC0:  MOVWF  x97
02EC2:  MOVLB  0
02EC4:  RCALL  29F2
02EC6:  MOVFF  02,783
02ECA:  MOVFF  01,782
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02ECE:  MOVLW  88
02ED0:  MOVLB  8
02ED2:  MOVWF  x97
02ED4:  MOVLB  0
02ED6:  RCALL  29F2
02ED8:  MOVFF  02,745
02EDC:  MOVFF  01,744
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02EE0:  MOVLW  8C
02EE2:  MOVLB  8
02EE4:  MOVWF  x97
02EE6:  MOVLB  0
02EE8:  RCALL  29F2
02EEA:  MOVFF  02,749
02EEE:  MOVFF  01,748
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02EF2:  MOVLW  90
02EF4:  MOVLB  8
02EF6:  MOVWF  x97
02EF8:  MOVLB  0
02EFA:  RCALL  29F2
02EFC:  MOVFF  02,74D
02F00:  MOVFF  01,74C
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02F04:  MOVLW  94
02F06:  MOVLB  8
02F08:  MOVWF  x97
02F0A:  MOVLB  0
02F0C:  RCALL  29F2
02F0E:  MOVFF  02,751
02F12:  MOVFF  01,750
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02F16:  MOVLW  98
02F18:  MOVLB  8
02F1A:  MOVWF  x97
02F1C:  MOVLB  0
02F1E:  RCALL  29F2
02F20:  MOVFF  02,755
02F24:  MOVFF  01,754
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02F28:  MOVLW  9C
02F2A:  MOVLB  8
02F2C:  MOVWF  x97
02F2E:  MOVLB  0
02F30:  RCALL  29F2
02F32:  MOVFF  02,759
02F36:  MOVFF  01,758
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02F3A:  MOVLW  A0
02F3C:  MOVLB  8
02F3E:  MOVWF  x97
02F40:  MOVLB  0
02F42:  RCALL  29F2
02F44:  MOVFF  02,75D
02F48:  MOVFF  01,75C
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02F4C:  MOVLW  A4
02F4E:  MOVLB  8
02F50:  MOVWF  x97
02F52:  MOVLB  0
02F54:  RCALL  29F2
02F56:  MOVFF  02,761
02F5A:  MOVFF  01,760
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02F5E:  MOVLW  A8
02F60:  MOVLB  8
02F62:  MOVWF  x97
02F64:  MOVLB  0
02F66:  RCALL  29F2
02F68:  MOVFF  02,765
02F6C:  MOVFF  01,764
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02F70:  MOVLW  84
02F72:  MOVLB  8
02F74:  MOVWF  x97
02F76:  MOVLB  0
02F78:  RCALL  29F2
02F7A:  MOVFF  02,769
02F7E:  MOVFF  01,768
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02F82:  MOVLW  80
02F84:  MOVLB  8
02F86:  MOVWF  x97
02F88:  MOVLB  0
02F8A:  RCALL  29F2
02F8C:  MOVFF  02,7C2
02F90:  MOVFF  01,7C1
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02F94:  MOVLW  AC
02F96:  MOVLB  8
02F98:  MOVWF  x97
02F9A:  MOVLB  0
02F9C:  RCALL  29F2
02F9E:  MOVFF  02,7C6
02FA2:  MOVFF  01,7C5
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02FA6:  MOVLW  7C
02FA8:  MOVLB  8
02FAA:  MOVWF  x97
02FAC:  MOVLB  0
02FAE:  RCALL  29F2
02FB0:  MOVFF  02,76D
02FB4:  MOVFF  01,76C
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02FB8:  MOVLW  78
02FBA:  MOVLB  8
02FBC:  MOVWF  x97
02FBE:  MOVLB  0
02FC0:  RCALL  29F2
02FC2:  MOVFF  02,771
02FC6:  MOVFF  01,770
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02FCA:  MOVLW  74
02FCC:  MOVLB  8
02FCE:  MOVWF  x97
02FD0:  MOVLB  0
02FD2:  RCALL  29F2
02FD4:  MOVFF  02,775
02FD8:  MOVFF  01,774
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
02FDC:  MOVLW  70
02FDE:  MOVLB  8
02FE0:  MOVWF  x97
02FE2:  MOVLB  0
02FE4:  RCALL  29F2
02FE6:  MOVFF  02,799
02FEA:  MOVFF  01,798
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
02FEE:  MOVLW  B0
02FF0:  MOVLB  8
02FF2:  MOVWF  x97
02FF4:  MOVLB  0
02FF6:  RCALL  29F2
02FF8:  MOVFF  02,779
02FFC:  MOVFF  01,778
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
03000:  MOVLW  B4
03002:  MOVLB  8
03004:  MOVWF  x97
03006:  MOVLB  0
03008:  RCALL  29F2
0300A:  MOVFF  02,7B2
0300E:  MOVFF  01,7B1
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
03012:  MOVLW  B8
03014:  MOVLB  8
03016:  MOVWF  x97
03018:  MOVLB  0
0301A:  RCALL  29F2
0301C:  MOVFF  02,7B6
03020:  MOVFF  01,7B5
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
03024:  MOVLW  BC
03026:  MOVLB  8
03028:  MOVWF  x97
0302A:  MOVLB  0
0302C:  RCALL  29F2
0302E:  MOVFF  02,77D
03032:  MOVFF  01,77C
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
03036:  MOVLW  C0
03038:  MOVLB  8
0303A:  MOVWF  x97
0303C:  MOVLB  0
0303E:  RCALL  29F2
03040:  MOVFF  02,781
03044:  MOVFF  01,780
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
03048:  MOVLW  C4
0304A:  MOVLB  8
0304C:  MOVWF  x97
0304E:  MOVLB  0
03050:  RCALL  29F2
03052:  MOVFF  02,785
03056:  MOVFF  01,784
....................     
....................    motor=0; 
0305A:  MOVLB  7
0305C:  CLRF   x40
....................    m_fixed=1; 
0305E:  MOVLW  01
03060:  MOVWF  x41
....................    m_step_cnt[0]=0; 
03062:  CLRF   xA5
03064:  CLRF   xA4
03066:  CLRF   xA3
03068:  CLRF   xA2
....................    m_step_cnt[1]=0; 
0306A:  CLRF   xA9
0306C:  CLRF   xA8
0306E:  CLRF   xA7
03070:  CLRF   xA6
....................    e_cha_cnt[0]=0; 
03072:  CLRF   xBC
03074:  CLRF   xBB
....................    e_cha_cnt[1]=0;  
03076:  CLRF   xBE
03078:  CLRF   xBD
....................    m_gb_cnt[0]=0; 
0307A:  CLRF   x9B
0307C:  CLRF   x9A
....................    m_gb_cnt[1]=0; 
0307E:  CLRF   x9D
03080:  CLRF   x9C
....................    e_mode_rst[0]=0; 
03082:  CLRF   x9F
03084:  CLRF   x9E
....................    e_mode_rst[1]=0;    
03086:  CLRF   xA1
03088:  CLRF   xA0
....................    e_port_dist[0]=0; 
0308A:  CLRF   xB8
0308C:  CLRF   xB7
....................    e_port_dist[1]=0; 
0308E:  CLRF   xBA
03090:  CLRF   xB9
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
03092:  MOVFF  777,8DC
03096:  MOVFF  776,8DB
0309A:  MOVFF  763,8DE
0309E:  MOVFF  762,8DD
030A2:  MOVLB  0
030A4:  RCALL  2CFC
030A6:  BCF    FD8.0
030A8:  MOVLB  8
030AA:  RLCF   01,W
030AC:  MOVLB  7
030AE:  MOVWF  xAB
030B0:  MOVLB  8
030B2:  RLCF   02,W
030B4:  MOVLB  7
030B6:  MOVWF  xAC
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
030B8:  MOVFF  779,8DC
030BC:  MOVFF  778,8DB
030C0:  MOVFF  765,8DE
030C4:  MOVFF  764,8DD
030C8:  MOVLB  0
030CA:  RCALL  2CFC
030CC:  BCF    FD8.0
030CE:  MOVLB  8
030D0:  RLCF   01,W
030D2:  MOVLB  7
030D4:  MOVWF  xAD
030D6:  MOVLB  8
030D8:  RLCF   02,W
030DA:  MOVLB  7
030DC:  MOVWF  xAE
030DE:  MOVLB  0
030E0:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
1A1CC:  MOVLW  86
1A1CE:  MOVLB  8
1A1D0:  MOVWF  xEE
1A1D2:  CLRF   xF0
1A1D4:  MOVLW  01
1A1D6:  MOVWF  xEF
1A1D8:  MOVLB  0
1A1DA:  CALL   4FFC
....................    write16(ADDR_M1_MODE,FULL); 
1A1DE:  MOVLW  8A
1A1E0:  MOVLB  8
1A1E2:  MOVWF  xEE
1A1E4:  CLRF   xF0
1A1E6:  CLRF   xEF
1A1E8:  MOVLB  0
1A1EA:  CALL   4FFC
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A1EE:  MOVLW  8E
1A1F0:  MOVLB  8
1A1F2:  MOVWF  xEE
1A1F4:  CLRF   xF0
1A1F6:  MOVLW  0A
1A1F8:  MOVWF  xEF
1A1FA:  MOVLB  0
1A1FC:  CALL   4FFC
....................    write16(ADDR_M1_POS_DIR,0); 
1A200:  MOVLW  92
1A202:  MOVLB  8
1A204:  MOVWF  xEE
1A206:  CLRF   xF0
1A208:  CLRF   xEF
1A20A:  MOVLB  0
1A20C:  CALL   4FFC
....................    write16(ADDR_M1_PWM_HLD,0); 
1A210:  MOVLW  96
1A212:  MOVLB  8
1A214:  MOVWF  xEE
1A216:  CLRF   xF0
1A218:  CLRF   xEF
1A21A:  MOVLB  0
1A21C:  CALL   4FFC
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A220:  MOVLW  9A
1A222:  MOVLB  8
1A224:  MOVWF  xEE
1A226:  CLRF   xF0
1A228:  MOVLW  7F
1A22A:  MOVWF  xEF
1A22C:  MOVLB  0
1A22E:  CALL   4FFC
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A232:  MOVLW  9E
1A234:  MOVLB  8
1A236:  MOVWF  xEE
1A238:  MOVLW  17
1A23A:  MOVWF  xF0
1A23C:  MOVLW  70
1A23E:  MOVWF  xEF
1A240:  MOVLB  0
1A242:  CALL   4FFC
....................    write16(ADDR_E1_CPR,16); 
1A246:  MOVLW  A2
1A248:  MOVLB  8
1A24A:  MOVWF  xEE
1A24C:  CLRF   xF0
1A24E:  MOVLW  10
1A250:  MOVWF  xEF
1A252:  MOVLB  0
1A254:  CALL   4FFC
....................    write16(ADDR_E1_PPR,16); 
1A258:  MOVLW  A6
1A25A:  MOVLB  8
1A25C:  MOVWF  xEE
1A25E:  CLRF   xF0
1A260:  MOVLW  10
1A262:  MOVWF  xEF
1A264:  MOVLB  0
1A266:  CALL   4FFC
....................    write16(ADDR_E1_MODE,2); 
1A26A:  MOVLW  82
1A26C:  MOVLB  8
1A26E:  MOVWF  xEE
1A270:  CLRF   xF0
1A272:  MOVLW  02
1A274:  MOVWF  xEF
1A276:  MOVLB  0
1A278:  CALL   4FFC
....................    write16(ADDR_E1_POS,0); 
1A27C:  MOVLW  7E
1A27E:  MOVLB  8
1A280:  MOVWF  xEE
1A282:  CLRF   xF0
1A284:  CLRF   xEF
1A286:  MOVLB  0
1A288:  CALL   4FFC
....................    write16(ADDR_E1_PORT,0); 
1A28C:  MOVLW  AA
1A28E:  MOVLB  8
1A290:  MOVWF  xEE
1A292:  CLRF   xF0
1A294:  CLRF   xEF
1A296:  MOVLB  0
1A298:  CALL   4FFC
....................    write16(ADDR_E1_TYPE,2); 
1A29C:  MOVLW  7A
1A29E:  MOVLB  8
1A2A0:  MOVWF  xEE
1A2A2:  CLRF   xF0
1A2A4:  MOVLW  02
1A2A6:  MOVWF  xEF
1A2A8:  MOVLB  0
1A2AA:  CALL   4FFC
....................    write16(ADDR_M1_RUN,270); 
1A2AE:  MOVLW  76
1A2B0:  MOVLB  8
1A2B2:  MOVWF  xEE
1A2B4:  MOVLW  01
1A2B6:  MOVWF  xF0
1A2B8:  MOVLW  0E
1A2BA:  MOVWF  xEF
1A2BC:  MOVLB  0
1A2BE:  CALL   4FFC
....................    write16(ADDR_M1_BKLSH,0); 
1A2C2:  MOVLW  72
1A2C4:  MOVLB  8
1A2C6:  MOVWF  xEE
1A2C8:  CLRF   xF0
1A2CA:  CLRF   xEF
1A2CC:  MOVLB  0
1A2CE:  CALL   4FFC
....................    write16(ADDR_M1_ERROR,0);   
1A2D2:  MOVLW  6E
1A2D4:  MOVLB  8
1A2D6:  MOVWF  xEE
1A2D8:  CLRF   xF0
1A2DA:  CLRF   xEF
1A2DC:  MOVLB  0
1A2DE:  CALL   4FFC
....................    write16(ADDR_M1_SPR,38400); 
1A2E2:  MOVLW  AE
1A2E4:  MOVLB  8
1A2E6:  MOVWF  xEE
1A2E8:  MOVLW  96
1A2EA:  MOVWF  xF0
1A2EC:  CLRF   xEF
1A2EE:  MOVLB  0
1A2F0:  CALL   4FFC
....................    write16(ADDR_M1_COMP,0); 
1A2F4:  MOVLW  B2
1A2F6:  MOVLB  8
1A2F8:  MOVWF  xEE
1A2FA:  CLRF   xF0
1A2FC:  CLRF   xEF
1A2FE:  MOVLB  0
1A300:  CALL   4FFC
....................    write16(ADDR_M1_LIN_POS,0); 
1A304:  MOVLW  B6
1A306:  MOVLB  8
1A308:  MOVWF  xEE
1A30A:  CLRF   xF0
1A30C:  CLRF   xEF
1A30E:  MOVLB  0
1A310:  CALL   4FFC
....................    write16(ADDR_E1_INDEX,1); 
1A314:  MOVLW  BA
1A316:  MOVLB  8
1A318:  MOVWF  xEE
1A31A:  CLRF   xF0
1A31C:  MOVLW  01
1A31E:  MOVWF  xEF
1A320:  MOVLB  0
1A322:  CALL   4FFC
....................    write16(ADDR_M1_EVN_SO,0); 
1A326:  MOVLW  BE
1A328:  MOVLB  8
1A32A:  MOVWF  xEE
1A32C:  CLRF   xF0
1A32E:  CLRF   xEF
1A330:  MOVLB  0
1A332:  CALL   4FFC
....................    write16(ADDR_M1_ALIGN_OS,0); 
1A336:  MOVLW  C2
1A338:  MOVLB  8
1A33A:  MOVWF  xEE
1A33C:  CLRF   xF0
1A33E:  CLRF   xEF
1A340:  MOVLB  0
1A342:  CALL   4FFC
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A346:  MOVLW  88
1A348:  MOVLB  8
1A34A:  MOVWF  xEE
1A34C:  CLRF   xF0
1A34E:  MOVLW  01
1A350:  MOVWF  xEF
1A352:  MOVLB  0
1A354:  CALL   4FFC
....................    write16(ADDR_M2_MODE,HALF); 
1A358:  MOVLW  8C
1A35A:  MOVLB  8
1A35C:  MOVWF  xEE
1A35E:  CLRF   xF0
1A360:  MOVLW  01
1A362:  MOVWF  xEF
1A364:  MOVLB  0
1A366:  CALL   4FFC
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
1A36A:  MOVLW  90
1A36C:  MOVLB  8
1A36E:  MOVWF  xEE
1A370:  CLRF   xF0
1A372:  MOVLW  05
1A374:  MOVWF  xEF
1A376:  MOVLB  0
1A378:  CALL   4FFC
....................    write16(ADDR_M2_POS_DIR,0); 
1A37C:  MOVLW  94
1A37E:  MOVLB  8
1A380:  MOVWF  xEE
1A382:  CLRF   xF0
1A384:  CLRF   xEF
1A386:  MOVLB  0
1A388:  CALL   4FFC
....................    write16(ADDR_M2_PWM_HLD,0); 
1A38C:  MOVLW  98
1A38E:  MOVLB  8
1A390:  MOVWF  xEE
1A392:  CLRF   xF0
1A394:  CLRF   xEF
1A396:  MOVLB  0
1A398:  CALL   4FFC
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A39C:  MOVLW  9C
1A39E:  MOVLB  8
1A3A0:  MOVWF  xEE
1A3A2:  CLRF   xF0
1A3A4:  MOVLW  7F
1A3A6:  MOVWF  xEF
1A3A8:  MOVLB  0
1A3AA:  CALL   4FFC
....................    write16(ADDR_M2_GB_ERR,0); 
1A3AE:  MOVLW  A0
1A3B0:  MOVLB  8
1A3B2:  MOVWF  xEE
1A3B4:  CLRF   xF0
1A3B6:  CLRF   xEF
1A3B8:  MOVLB  0
1A3BA:  CALL   4FFC
....................    write16(ADDR_E2_CPR,0); 
1A3BE:  MOVLW  A4
1A3C0:  MOVLB  8
1A3C2:  MOVWF  xEE
1A3C4:  CLRF   xF0
1A3C6:  CLRF   xEF
1A3C8:  MOVLB  0
1A3CA:  CALL   4FFC
....................    write16(ADDR_E2_PPR,0);   
1A3CE:  MOVLW  A8
1A3D0:  MOVLB  8
1A3D2:  MOVWF  xEE
1A3D4:  CLRF   xF0
1A3D6:  CLRF   xEF
1A3D8:  MOVLB  0
1A3DA:  CALL   4FFC
....................    write16(ADDR_E2_MODE,0); 
1A3DE:  MOVLW  84
1A3E0:  MOVLB  8
1A3E2:  MOVWF  xEE
1A3E4:  CLRF   xF0
1A3E6:  CLRF   xEF
1A3E8:  MOVLB  0
1A3EA:  CALL   4FFC
....................    write16(ADDR_E2_POS,0); 
1A3EE:  MOVLW  80
1A3F0:  MOVLB  8
1A3F2:  MOVWF  xEE
1A3F4:  CLRF   xF0
1A3F6:  CLRF   xEF
1A3F8:  MOVLB  0
1A3FA:  CALL   4FFC
....................    write16(ADDR_E2_PORT,0); 
1A3FE:  MOVLW  AC
1A400:  MOVLB  8
1A402:  MOVWF  xEE
1A404:  CLRF   xF0
1A406:  CLRF   xEF
1A408:  MOVLB  0
1A40A:  CALL   4FFC
....................    write16(ADDR_E2_TYPE,0); 
1A40E:  MOVLW  7C
1A410:  MOVLB  8
1A412:  MOVWF  xEE
1A414:  CLRF   xF0
1A416:  CLRF   xEF
1A418:  MOVLB  0
1A41A:  CALL   4FFC
....................    write16(ADDR_M2_RUN,0); 
1A41E:  MOVLW  78
1A420:  MOVLB  8
1A422:  MOVWF  xEE
1A424:  CLRF   xF0
1A426:  CLRF   xEF
1A428:  MOVLB  0
1A42A:  CALL   4FFC
....................    write16(ADDR_M2_BKLSH,0); 
1A42E:  MOVLW  74
1A430:  MOVLB  8
1A432:  MOVWF  xEE
1A434:  CLRF   xF0
1A436:  CLRF   xEF
1A438:  MOVLB  0
1A43A:  CALL   4FFC
....................    write16(ADDR_M2_ERROR,0);   
1A43E:  MOVLW  70
1A440:  MOVLB  8
1A442:  MOVWF  xEE
1A444:  CLRF   xF0
1A446:  CLRF   xEF
1A448:  MOVLB  0
1A44A:  CALL   4FFC
....................    write16(ADDR_M2_SPR,0); 
1A44E:  MOVLW  B0
1A450:  MOVLB  8
1A452:  MOVWF  xEE
1A454:  CLRF   xF0
1A456:  CLRF   xEF
1A458:  MOVLB  0
1A45A:  CALL   4FFC
....................    write16(ADDR_M2_COMP,0); 
1A45E:  MOVLW  B4
1A460:  MOVLB  8
1A462:  MOVWF  xEE
1A464:  CLRF   xF0
1A466:  CLRF   xEF
1A468:  MOVLB  0
1A46A:  CALL   4FFC
....................    write16(ADDR_M2_LIN_POS,0);    
1A46E:  MOVLW  B8
1A470:  MOVLB  8
1A472:  MOVWF  xEE
1A474:  CLRF   xF0
1A476:  CLRF   xEF
1A478:  MOVLB  0
1A47A:  CALL   4FFC
....................    write16(ADDR_E2_INDEX,0); 
1A47E:  MOVLW  BC
1A480:  MOVLB  8
1A482:  MOVWF  xEE
1A484:  CLRF   xF0
1A486:  CLRF   xEF
1A488:  MOVLB  0
1A48A:  CALL   4FFC
....................    write16(ADDR_M2_EVN_SO,0); 
1A48E:  MOVLW  C0
1A490:  MOVLB  8
1A492:  MOVWF  xEE
1A494:  CLRF   xF0
1A496:  CLRF   xEF
1A498:  MOVLB  0
1A49A:  CALL   4FFC
....................    write16(ADDR_M2_ALIGN_OS,0); 
1A49E:  MOVLW  C4
1A4A0:  MOVLB  8
1A4A2:  MOVWF  xEE
1A4A4:  CLRF   xF0
1A4A6:  CLRF   xEF
1A4A8:  MOVLB  0
1A4AA:  CALL   4FFC
....................     
....................    get_step_vars(); 
1A4AE:  CALL   2D42
1A4B2:  GOTO   1ACFC (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A4B6:  MOVLW  86
1A4B8:  MOVLB  8
1A4BA:  MOVWF  xEE
1A4BC:  CLRF   xF0
1A4BE:  MOVLW  01
1A4C0:  MOVWF  xEF
1A4C2:  MOVLB  0
1A4C4:  CALL   4FFC
....................    write16(ADDR_M1_MODE,FULL); 
1A4C8:  MOVLW  8A
1A4CA:  MOVLB  8
1A4CC:  MOVWF  xEE
1A4CE:  CLRF   xF0
1A4D0:  CLRF   xEF
1A4D2:  MOVLB  0
1A4D4:  CALL   4FFC
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
1A4D8:  MOVLW  8E
1A4DA:  MOVLB  8
1A4DC:  MOVWF  xEE
1A4DE:  CLRF   xF0
1A4E0:  MOVLW  14
1A4E2:  MOVWF  xEF
1A4E4:  MOVLB  0
1A4E6:  CALL   4FFC
....................    write16(ADDR_M1_POS_DIR,1); 
1A4EA:  MOVLW  92
1A4EC:  MOVLB  8
1A4EE:  MOVWF  xEE
1A4F0:  CLRF   xF0
1A4F2:  MOVLW  01
1A4F4:  MOVWF  xEF
1A4F6:  MOVLB  0
1A4F8:  CALL   4FFC
....................    write16(ADDR_M1_PWM_HLD,51); 
1A4FC:  MOVLW  96
1A4FE:  MOVLB  8
1A500:  MOVWF  xEE
1A502:  CLRF   xF0
1A504:  MOVLW  33
1A506:  MOVWF  xEF
1A508:  MOVLB  0
1A50A:  CALL   4FFC
....................    write16(ADDR_M1_PWM_DRV,511); 
1A50E:  MOVLW  9A
1A510:  MOVLB  8
1A512:  MOVWF  xEE
1A514:  MOVLW  01
1A516:  MOVWF  xF0
1A518:  SETF   xEF
1A51A:  MOVLB  0
1A51C:  CALL   4FFC
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
1A520:  MOVLW  9E
1A522:  MOVLB  8
1A524:  MOVWF  xEE
1A526:  MOVLW  02
1A528:  MOVWF  xF0
1A52A:  MOVLW  9E
1A52C:  MOVWF  xEF
1A52E:  MOVLB  0
1A530:  CALL   4FFC
....................    write16(ADDR_E1_CPR,24); 
1A534:  MOVLW  A2
1A536:  MOVLB  8
1A538:  MOVWF  xEE
1A53A:  CLRF   xF0
1A53C:  MOVLW  18
1A53E:  MOVWF  xEF
1A540:  MOVLB  0
1A542:  CALL   4FFC
....................    write16(ADDR_E1_PPR,48); 
1A546:  MOVLW  A6
1A548:  MOVLB  8
1A54A:  MOVWF  xEE
1A54C:  CLRF   xF0
1A54E:  MOVLW  30
1A550:  MOVWF  xEF
1A552:  MOVLB  0
1A554:  CALL   4FFC
....................    write16(ADDR_E1_MODE,2); 
1A558:  MOVLW  82
1A55A:  MOVLB  8
1A55C:  MOVWF  xEE
1A55E:  CLRF   xF0
1A560:  MOVLW  02
1A562:  MOVWF  xEF
1A564:  MOVLB  0
1A566:  CALL   4FFC
....................    write16(ADDR_E1_POS,0); 
1A56A:  MOVLW  7E
1A56C:  MOVLB  8
1A56E:  MOVWF  xEE
1A570:  CLRF   xF0
1A572:  CLRF   xEF
1A574:  MOVLB  0
1A576:  CALL   4FFC
....................    write16(ADDR_E1_PORT,0); 
1A57A:  MOVLW  AA
1A57C:  MOVLB  8
1A57E:  MOVWF  xEE
1A580:  CLRF   xF0
1A582:  CLRF   xEF
1A584:  MOVLB  0
1A586:  CALL   4FFC
....................    write16(ADDR_E1_TYPE,2); 
1A58A:  MOVLW  7A
1A58C:  MOVLB  8
1A58E:  MOVWF  xEE
1A590:  CLRF   xF0
1A592:  MOVLW  02
1A594:  MOVWF  xEF
1A596:  MOVLB  0
1A598:  CALL   4FFC
....................    write16(ADDR_M1_RUN,34); 
1A59C:  MOVLW  76
1A59E:  MOVLB  8
1A5A0:  MOVWF  xEE
1A5A2:  CLRF   xF0
1A5A4:  MOVLW  22
1A5A6:  MOVWF  xEF
1A5A8:  MOVLB  0
1A5AA:  CALL   4FFC
....................    write16(ADDR_M1_BKLSH,0); 
1A5AE:  MOVLW  72
1A5B0:  MOVLB  8
1A5B2:  MOVWF  xEE
1A5B4:  CLRF   xF0
1A5B6:  CLRF   xEF
1A5B8:  MOVLB  0
1A5BA:  CALL   4FFC
....................    write16(ADDR_M1_ERROR,0);   
1A5BE:  MOVLW  6E
1A5C0:  MOVLB  8
1A5C2:  MOVWF  xEE
1A5C4:  CLRF   xF0
1A5C6:  CLRF   xEF
1A5C8:  MOVLB  0
1A5CA:  CALL   4FFC
....................    write16(ADDR_M1_SPR,6400); 
1A5CE:  MOVLW  AE
1A5D0:  MOVLB  8
1A5D2:  MOVWF  xEE
1A5D4:  MOVLW  19
1A5D6:  MOVWF  xF0
1A5D8:  CLRF   xEF
1A5DA:  MOVLB  0
1A5DC:  CALL   4FFC
....................    write16(ADDR_M1_COMP,0); 
1A5E0:  MOVLW  B2
1A5E2:  MOVLB  8
1A5E4:  MOVWF  xEE
1A5E6:  CLRF   xF0
1A5E8:  CLRF   xEF
1A5EA:  MOVLB  0
1A5EC:  CALL   4FFC
....................    write16(ADDR_M1_LIN_POS,0); 
1A5F0:  MOVLW  B6
1A5F2:  MOVLB  8
1A5F4:  MOVWF  xEE
1A5F6:  CLRF   xF0
1A5F8:  CLRF   xEF
1A5FA:  MOVLB  0
1A5FC:  CALL   4FFC
....................    write16(ADDR_E1_INDEX,1);    
1A600:  MOVLW  BA
1A602:  MOVLB  8
1A604:  MOVWF  xEE
1A606:  CLRF   xF0
1A608:  MOVLW  01
1A60A:  MOVWF  xEF
1A60C:  MOVLB  0
1A60E:  CALL   4FFC
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A612:  MOVLW  88
1A614:  MOVLB  8
1A616:  MOVWF  xEE
1A618:  CLRF   xF0
1A61A:  MOVLW  01
1A61C:  MOVWF  xEF
1A61E:  MOVLB  0
1A620:  CALL   4FFC
....................    write16(ADDR_M2_MODE,HALF); 
1A624:  MOVLW  8C
1A626:  MOVLB  8
1A628:  MOVWF  xEE
1A62A:  CLRF   xF0
1A62C:  MOVLW  01
1A62E:  MOVWF  xEF
1A630:  MOVLB  0
1A632:  CALL   4FFC
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A636:  MOVLW  90
1A638:  MOVLB  8
1A63A:  MOVWF  xEE
1A63C:  CLRF   xF0
1A63E:  MOVLW  28
1A640:  MOVWF  xEF
1A642:  MOVLB  0
1A644:  CALL   4FFC
....................    write16(ADDR_M2_POS_DIR,0); 
1A648:  MOVLW  94
1A64A:  MOVLB  8
1A64C:  MOVWF  xEE
1A64E:  CLRF   xF0
1A650:  CLRF   xEF
1A652:  MOVLB  0
1A654:  CALL   4FFC
....................    write16(ADDR_M2_PWM_HLD,0); 
1A658:  MOVLW  98
1A65A:  MOVLB  8
1A65C:  MOVWF  xEE
1A65E:  CLRF   xF0
1A660:  CLRF   xEF
1A662:  MOVLB  0
1A664:  CALL   4FFC
....................    write16(ADDR_M2_PWM_DRV,511); 
1A668:  MOVLW  9C
1A66A:  MOVLB  8
1A66C:  MOVWF  xEE
1A66E:  MOVLW  01
1A670:  MOVWF  xF0
1A672:  SETF   xEF
1A674:  MOVLB  0
1A676:  CALL   4FFC
....................    write16(ADDR_M2_GB_ERR,0); 
1A67A:  MOVLW  A0
1A67C:  MOVLB  8
1A67E:  MOVWF  xEE
1A680:  CLRF   xF0
1A682:  CLRF   xEF
1A684:  MOVLB  0
1A686:  CALL   4FFC
....................    write16(ADDR_E2_CPR,0); 
1A68A:  MOVLW  A4
1A68C:  MOVLB  8
1A68E:  MOVWF  xEE
1A690:  CLRF   xF0
1A692:  CLRF   xEF
1A694:  MOVLB  0
1A696:  CALL   4FFC
....................    write16(ADDR_E2_PPR,0);   
1A69A:  MOVLW  A8
1A69C:  MOVLB  8
1A69E:  MOVWF  xEE
1A6A0:  CLRF   xF0
1A6A2:  CLRF   xEF
1A6A4:  MOVLB  0
1A6A6:  CALL   4FFC
....................    write16(ADDR_E2_MODE,0); 
1A6AA:  MOVLW  84
1A6AC:  MOVLB  8
1A6AE:  MOVWF  xEE
1A6B0:  CLRF   xF0
1A6B2:  CLRF   xEF
1A6B4:  MOVLB  0
1A6B6:  CALL   4FFC
....................    write16(ADDR_E2_POS,0); 
1A6BA:  MOVLW  80
1A6BC:  MOVLB  8
1A6BE:  MOVWF  xEE
1A6C0:  CLRF   xF0
1A6C2:  CLRF   xEF
1A6C4:  MOVLB  0
1A6C6:  CALL   4FFC
....................    write16(ADDR_E2_PORT,0); 
1A6CA:  MOVLW  AC
1A6CC:  MOVLB  8
1A6CE:  MOVWF  xEE
1A6D0:  CLRF   xF0
1A6D2:  CLRF   xEF
1A6D4:  MOVLB  0
1A6D6:  CALL   4FFC
....................    write16(ADDR_E2_TYPE,0); 
1A6DA:  MOVLW  7C
1A6DC:  MOVLB  8
1A6DE:  MOVWF  xEE
1A6E0:  CLRF   xF0
1A6E2:  CLRF   xEF
1A6E4:  MOVLB  0
1A6E6:  CALL   4FFC
....................    write16(ADDR_M2_RUN,0); 
1A6EA:  MOVLW  78
1A6EC:  MOVLB  8
1A6EE:  MOVWF  xEE
1A6F0:  CLRF   xF0
1A6F2:  CLRF   xEF
1A6F4:  MOVLB  0
1A6F6:  CALL   4FFC
....................    write16(ADDR_M2_BKLSH,0); 
1A6FA:  MOVLW  74
1A6FC:  MOVLB  8
1A6FE:  MOVWF  xEE
1A700:  CLRF   xF0
1A702:  CLRF   xEF
1A704:  MOVLB  0
1A706:  CALL   4FFC
....................    write16(ADDR_M2_ERROR,0);   
1A70A:  MOVLW  70
1A70C:  MOVLB  8
1A70E:  MOVWF  xEE
1A710:  CLRF   xF0
1A712:  CLRF   xEF
1A714:  MOVLB  0
1A716:  CALL   4FFC
....................    write16(ADDR_M2_SPR,0); 
1A71A:  MOVLW  B0
1A71C:  MOVLB  8
1A71E:  MOVWF  xEE
1A720:  CLRF   xF0
1A722:  CLRF   xEF
1A724:  MOVLB  0
1A726:  CALL   4FFC
....................    write16(ADDR_M2_COMP,0); 
1A72A:  MOVLW  B4
1A72C:  MOVLB  8
1A72E:  MOVWF  xEE
1A730:  CLRF   xF0
1A732:  CLRF   xEF
1A734:  MOVLB  0
1A736:  CALL   4FFC
....................    write16(ADDR_M2_LIN_POS,0);   
1A73A:  MOVLW  B8
1A73C:  MOVLB  8
1A73E:  MOVWF  xEE
1A740:  CLRF   xF0
1A742:  CLRF   xEF
1A744:  MOVLB  0
1A746:  CALL   4FFC
....................    write16(ADDR_E2_INDEX,0);    
1A74A:  MOVLW  BC
1A74C:  MOVLB  8
1A74E:  MOVWF  xEE
1A750:  CLRF   xF0
1A752:  CLRF   xEF
1A754:  MOVLB  0
1A756:  CALL   4FFC
....................     
....................    get_step_vars(); 
1A75A:  CALL   2D42
1A75E:  GOTO   1ACFC (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A762:  MOVLW  86
1A764:  MOVLB  8
1A766:  MOVWF  xEE
1A768:  CLRF   xF0
1A76A:  MOVLW  01
1A76C:  MOVWF  xEF
1A76E:  MOVLB  0
1A770:  CALL   4FFC
....................    write16(ADDR_M1_MODE,FULL); 
1A774:  MOVLW  8A
1A776:  MOVLB  8
1A778:  MOVWF  xEE
1A77A:  CLRF   xF0
1A77C:  CLRF   xEF
1A77E:  MOVLB  0
1A780:  CALL   4FFC
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A784:  MOVLW  8E
1A786:  MOVLB  8
1A788:  MOVWF  xEE
1A78A:  CLRF   xF0
1A78C:  MOVLW  0A
1A78E:  MOVWF  xEF
1A790:  MOVLB  0
1A792:  CALL   4FFC
....................    write16(ADDR_M1_POS_DIR,0); 
1A796:  MOVLW  92
1A798:  MOVLB  8
1A79A:  MOVWF  xEE
1A79C:  CLRF   xF0
1A79E:  CLRF   xEF
1A7A0:  MOVLB  0
1A7A2:  CALL   4FFC
....................    write16(ADDR_M1_PWM_HLD,0); 
1A7A6:  MOVLW  96
1A7A8:  MOVLB  8
1A7AA:  MOVWF  xEE
1A7AC:  CLRF   xF0
1A7AE:  CLRF   xEF
1A7B0:  MOVLB  0
1A7B2:  CALL   4FFC
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A7B6:  MOVLW  9A
1A7B8:  MOVLB  8
1A7BA:  MOVWF  xEE
1A7BC:  CLRF   xF0
1A7BE:  MOVLW  7F
1A7C0:  MOVWF  xEF
1A7C2:  MOVLB  0
1A7C4:  CALL   4FFC
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A7C8:  MOVLW  9E
1A7CA:  MOVLB  8
1A7CC:  MOVWF  xEE
1A7CE:  MOVLW  17
1A7D0:  MOVWF  xF0
1A7D2:  MOVLW  70
1A7D4:  MOVWF  xEF
1A7D6:  MOVLB  0
1A7D8:  CALL   4FFC
....................    write16(ADDR_E1_CPR,16); 
1A7DC:  MOVLW  A2
1A7DE:  MOVLB  8
1A7E0:  MOVWF  xEE
1A7E2:  CLRF   xF0
1A7E4:  MOVLW  10
1A7E6:  MOVWF  xEF
1A7E8:  MOVLB  0
1A7EA:  CALL   4FFC
....................    write16(ADDR_E1_PPR,16); 
1A7EE:  MOVLW  A6
1A7F0:  MOVLB  8
1A7F2:  MOVWF  xEE
1A7F4:  CLRF   xF0
1A7F6:  MOVLW  10
1A7F8:  MOVWF  xEF
1A7FA:  MOVLB  0
1A7FC:  CALL   4FFC
....................    write16(ADDR_E1_MODE,2); 
1A800:  MOVLW  82
1A802:  MOVLB  8
1A804:  MOVWF  xEE
1A806:  CLRF   xF0
1A808:  MOVLW  02
1A80A:  MOVWF  xEF
1A80C:  MOVLB  0
1A80E:  CALL   4FFC
....................    write16(ADDR_E1_POS,0); 
1A812:  MOVLW  7E
1A814:  MOVLB  8
1A816:  MOVWF  xEE
1A818:  CLRF   xF0
1A81A:  CLRF   xEF
1A81C:  MOVLB  0
1A81E:  CALL   4FFC
....................    write16(ADDR_E1_PORT,0); 
1A822:  MOVLW  AA
1A824:  MOVLB  8
1A826:  MOVWF  xEE
1A828:  CLRF   xF0
1A82A:  CLRF   xEF
1A82C:  MOVLB  0
1A82E:  CALL   4FFC
....................    write16(ADDR_E1_TYPE,2); 
1A832:  MOVLW  7A
1A834:  MOVLB  8
1A836:  MOVWF  xEE
1A838:  CLRF   xF0
1A83A:  MOVLW  02
1A83C:  MOVWF  xEF
1A83E:  MOVLB  0
1A840:  CALL   4FFC
....................    write16(ADDR_M1_RUN,270); 
1A844:  MOVLW  76
1A846:  MOVLB  8
1A848:  MOVWF  xEE
1A84A:  MOVLW  01
1A84C:  MOVWF  xF0
1A84E:  MOVLW  0E
1A850:  MOVWF  xEF
1A852:  MOVLB  0
1A854:  CALL   4FFC
....................    write16(ADDR_M1_BKLSH,0); 
1A858:  MOVLW  72
1A85A:  MOVLB  8
1A85C:  MOVWF  xEE
1A85E:  CLRF   xF0
1A860:  CLRF   xEF
1A862:  MOVLB  0
1A864:  CALL   4FFC
....................    write16(ADDR_M1_ERROR,0);   
1A868:  MOVLW  6E
1A86A:  MOVLB  8
1A86C:  MOVWF  xEE
1A86E:  CLRF   xF0
1A870:  CLRF   xEF
1A872:  MOVLB  0
1A874:  CALL   4FFC
....................    write16(ADDR_M1_SPR,38400); 
1A878:  MOVLW  AE
1A87A:  MOVLB  8
1A87C:  MOVWF  xEE
1A87E:  MOVLW  96
1A880:  MOVWF  xF0
1A882:  CLRF   xEF
1A884:  MOVLB  0
1A886:  CALL   4FFC
....................    write16(ADDR_M1_COMP,0); 
1A88A:  MOVLW  B2
1A88C:  MOVLB  8
1A88E:  MOVWF  xEE
1A890:  CLRF   xF0
1A892:  CLRF   xEF
1A894:  MOVLB  0
1A896:  CALL   4FFC
....................    write16(ADDR_M1_LIN_POS,0); 
1A89A:  MOVLW  B6
1A89C:  MOVLB  8
1A89E:  MOVWF  xEE
1A8A0:  CLRF   xF0
1A8A2:  CLRF   xEF
1A8A4:  MOVLB  0
1A8A6:  CALL   4FFC
....................    write16(ADDR_E1_INDEX,1); 
1A8AA:  MOVLW  BA
1A8AC:  MOVLB  8
1A8AE:  MOVWF  xEE
1A8B0:  CLRF   xF0
1A8B2:  MOVLW  01
1A8B4:  MOVWF  xEF
1A8B6:  MOVLB  0
1A8B8:  CALL   4FFC
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A8BC:  MOVLW  88
1A8BE:  MOVLB  8
1A8C0:  MOVWF  xEE
1A8C2:  CLRF   xF0
1A8C4:  MOVLW  01
1A8C6:  MOVWF  xEF
1A8C8:  MOVLB  0
1A8CA:  CALL   4FFC
....................    write16(ADDR_M2_MODE,HALF); 
1A8CE:  MOVLW  8C
1A8D0:  MOVLB  8
1A8D2:  MOVWF  xEE
1A8D4:  CLRF   xF0
1A8D6:  MOVLW  01
1A8D8:  MOVWF  xEF
1A8DA:  MOVLB  0
1A8DC:  CALL   4FFC
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A8E0:  MOVLW  90
1A8E2:  MOVLB  8
1A8E4:  MOVWF  xEE
1A8E6:  CLRF   xF0
1A8E8:  MOVLW  64
1A8EA:  MOVWF  xEF
1A8EC:  MOVLB  0
1A8EE:  CALL   4FFC
....................    write16(ADDR_M2_POS_DIR,0); 
1A8F2:  MOVLW  94
1A8F4:  MOVLB  8
1A8F6:  MOVWF  xEE
1A8F8:  CLRF   xF0
1A8FA:  CLRF   xEF
1A8FC:  MOVLB  0
1A8FE:  CALL   4FFC
....................    write16(ADDR_M2_PWM_HLD,0); 
1A902:  MOVLW  98
1A904:  MOVLB  8
1A906:  MOVWF  xEE
1A908:  CLRF   xF0
1A90A:  CLRF   xEF
1A90C:  MOVLB  0
1A90E:  CALL   4FFC
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A912:  MOVLW  9C
1A914:  MOVLB  8
1A916:  MOVWF  xEE
1A918:  CLRF   xF0
1A91A:  MOVLW  7F
1A91C:  MOVWF  xEF
1A91E:  MOVLB  0
1A920:  CALL   4FFC
....................    write16(ADDR_M2_GB_ERR,0); 
1A924:  MOVLW  A0
1A926:  MOVLB  8
1A928:  MOVWF  xEE
1A92A:  CLRF   xF0
1A92C:  CLRF   xEF
1A92E:  MOVLB  0
1A930:  CALL   4FFC
....................    write16(ADDR_E2_CPR,0); 
1A934:  MOVLW  A4
1A936:  MOVLB  8
1A938:  MOVWF  xEE
1A93A:  CLRF   xF0
1A93C:  CLRF   xEF
1A93E:  MOVLB  0
1A940:  CALL   4FFC
....................    write16(ADDR_E2_PPR,0);   
1A944:  MOVLW  A8
1A946:  MOVLB  8
1A948:  MOVWF  xEE
1A94A:  CLRF   xF0
1A94C:  CLRF   xEF
1A94E:  MOVLB  0
1A950:  CALL   4FFC
....................    write16(ADDR_E2_MODE,0); 
1A954:  MOVLW  84
1A956:  MOVLB  8
1A958:  MOVWF  xEE
1A95A:  CLRF   xF0
1A95C:  CLRF   xEF
1A95E:  MOVLB  0
1A960:  CALL   4FFC
....................    write16(ADDR_E2_POS,0); 
1A964:  MOVLW  80
1A966:  MOVLB  8
1A968:  MOVWF  xEE
1A96A:  CLRF   xF0
1A96C:  CLRF   xEF
1A96E:  MOVLB  0
1A970:  CALL   4FFC
....................    write16(ADDR_E2_PORT,0); 
1A974:  MOVLW  AC
1A976:  MOVLB  8
1A978:  MOVWF  xEE
1A97A:  CLRF   xF0
1A97C:  CLRF   xEF
1A97E:  MOVLB  0
1A980:  CALL   4FFC
....................    write16(ADDR_E2_TYPE,0); 
1A984:  MOVLW  7C
1A986:  MOVLB  8
1A988:  MOVWF  xEE
1A98A:  CLRF   xF0
1A98C:  CLRF   xEF
1A98E:  MOVLB  0
1A990:  CALL   4FFC
....................    write16(ADDR_M2_RUN,0); 
1A994:  MOVLW  78
1A996:  MOVLB  8
1A998:  MOVWF  xEE
1A99A:  CLRF   xF0
1A99C:  CLRF   xEF
1A99E:  MOVLB  0
1A9A0:  CALL   4FFC
....................    write16(ADDR_M2_BKLSH,0); 
1A9A4:  MOVLW  74
1A9A6:  MOVLB  8
1A9A8:  MOVWF  xEE
1A9AA:  CLRF   xF0
1A9AC:  CLRF   xEF
1A9AE:  MOVLB  0
1A9B0:  CALL   4FFC
....................    write16(ADDR_M2_ERROR,0);   
1A9B4:  MOVLW  70
1A9B6:  MOVLB  8
1A9B8:  MOVWF  xEE
1A9BA:  CLRF   xF0
1A9BC:  CLRF   xEF
1A9BE:  MOVLB  0
1A9C0:  CALL   4FFC
....................    write16(ADDR_M2_SPR,0); 
1A9C4:  MOVLW  B0
1A9C6:  MOVLB  8
1A9C8:  MOVWF  xEE
1A9CA:  CLRF   xF0
1A9CC:  CLRF   xEF
1A9CE:  MOVLB  0
1A9D0:  CALL   4FFC
....................    write16(ADDR_M2_COMP,0); 
1A9D4:  MOVLW  B4
1A9D6:  MOVLB  8
1A9D8:  MOVWF  xEE
1A9DA:  CLRF   xF0
1A9DC:  CLRF   xEF
1A9DE:  MOVLB  0
1A9E0:  CALL   4FFC
....................    write16(ADDR_M2_LIN_POS,0);    
1A9E4:  MOVLW  B8
1A9E6:  MOVLB  8
1A9E8:  MOVWF  xEE
1A9EA:  CLRF   xF0
1A9EC:  CLRF   xEF
1A9EE:  MOVLB  0
1A9F0:  CALL   4FFC
....................     
....................    get_step_vars(); 
1A9F4:  CALL   2D42
1A9F8:  GOTO   1ACFC (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A9FC:  MOVLW  86
1A9FE:  MOVLB  8
1AA00:  MOVWF  xEE
1AA02:  CLRF   xF0
1AA04:  MOVLW  01
1AA06:  MOVWF  xEF
1AA08:  MOVLB  0
1AA0A:  CALL   4FFC
....................    write16(ADDR_M1_MODE,FULL); 
1AA0E:  MOVLW  8A
1AA10:  MOVLB  8
1AA12:  MOVWF  xEE
1AA14:  CLRF   xF0
1AA16:  CLRF   xEF
1AA18:  MOVLB  0
1AA1A:  CALL   4FFC
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1AA1E:  MOVLW  8E
1AA20:  MOVLB  8
1AA22:  MOVWF  xEE
1AA24:  CLRF   xF0
1AA26:  MOVLW  28
1AA28:  MOVWF  xEF
1AA2A:  MOVLB  0
1AA2C:  CALL   4FFC
....................    write16(ADDR_M1_POS_DIR,1); 
1AA30:  MOVLW  92
1AA32:  MOVLB  8
1AA34:  MOVWF  xEE
1AA36:  CLRF   xF0
1AA38:  MOVLW  01
1AA3A:  MOVWF  xEF
1AA3C:  MOVLB  0
1AA3E:  CALL   4FFC
....................    write16(ADDR_M1_PWM_HLD,0); 
1AA42:  MOVLW  96
1AA44:  MOVLB  8
1AA46:  MOVWF  xEE
1AA48:  CLRF   xF0
1AA4A:  CLRF   xEF
1AA4C:  MOVLB  0
1AA4E:  CALL   4FFC
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1AA52:  MOVLW  9A
1AA54:  MOVLB  8
1AA56:  MOVWF  xEE
1AA58:  CLRF   xF0
1AA5A:  MOVLW  7F
1AA5C:  MOVWF  xEF
1AA5E:  MOVLB  0
1AA60:  CALL   4FFC
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1AA64:  MOVLW  9E
1AA66:  MOVLB  8
1AA68:  MOVWF  xEE
1AA6A:  MOVLW  02
1AA6C:  MOVWF  xF0
1AA6E:  MOVLW  9E
1AA70:  MOVWF  xEF
1AA72:  MOVLB  0
1AA74:  CALL   4FFC
....................    write16(ADDR_E1_CPR,500); 
1AA78:  MOVLW  A2
1AA7A:  MOVLB  8
1AA7C:  MOVWF  xEE
1AA7E:  MOVLW  01
1AA80:  MOVWF  xF0
1AA82:  MOVLW  F4
1AA84:  MOVWF  xEF
1AA86:  MOVLB  0
1AA88:  CALL   4FFC
....................    write16(ADDR_E1_PPR,50); 
1AA8C:  MOVLW  A6
1AA8E:  MOVLB  8
1AA90:  MOVWF  xEE
1AA92:  CLRF   xF0
1AA94:  MOVLW  32
1AA96:  MOVWF  xEF
1AA98:  MOVLB  0
1AA9A:  CALL   4FFC
....................    write16(ADDR_E1_MODE,2); 
1AA9E:  MOVLW  82
1AAA0:  MOVLB  8
1AAA2:  MOVWF  xEE
1AAA4:  CLRF   xF0
1AAA6:  MOVLW  02
1AAA8:  MOVWF  xEF
1AAAA:  MOVLB  0
1AAAC:  CALL   4FFC
....................    write16(ADDR_E1_POS,0); 
1AAB0:  MOVLW  7E
1AAB2:  MOVLB  8
1AAB4:  MOVWF  xEE
1AAB6:  CLRF   xF0
1AAB8:  CLRF   xEF
1AABA:  MOVLB  0
1AABC:  CALL   4FFC
....................    write16(ADDR_E1_PORT,0); 
1AAC0:  MOVLW  AA
1AAC2:  MOVLB  8
1AAC4:  MOVWF  xEE
1AAC6:  CLRF   xF0
1AAC8:  CLRF   xEF
1AACA:  MOVLB  0
1AACC:  CALL   4FFC
....................    write16(ADDR_E1_TYPE,1); 
1AAD0:  MOVLW  7A
1AAD2:  MOVLB  8
1AAD4:  MOVWF  xEE
1AAD6:  CLRF   xF0
1AAD8:  MOVLW  01
1AADA:  MOVWF  xEF
1AADC:  MOVLB  0
1AADE:  CALL   4FFC
....................    write16(ADDR_M1_RUN,0); 
1AAE2:  MOVLW  76
1AAE4:  MOVLB  8
1AAE6:  MOVWF  xEE
1AAE8:  CLRF   xF0
1AAEA:  CLRF   xEF
1AAEC:  MOVLB  0
1AAEE:  CALL   4FFC
....................    write16(ADDR_M1_BKLSH,1300); 
1AAF2:  MOVLW  72
1AAF4:  MOVLB  8
1AAF6:  MOVWF  xEE
1AAF8:  MOVLW  05
1AAFA:  MOVWF  xF0
1AAFC:  MOVLW  14
1AAFE:  MOVWF  xEF
1AB00:  MOVLB  0
1AB02:  CALL   4FFC
....................    write16(ADDR_M1_ERROR,0);   
1AB06:  MOVLW  6E
1AB08:  MOVLB  8
1AB0A:  MOVWF  xEE
1AB0C:  CLRF   xF0
1AB0E:  CLRF   xEF
1AB10:  MOVLB  0
1AB12:  CALL   4FFC
....................    write16(ADDR_M1_SPR,20000); 
1AB16:  MOVLW  AE
1AB18:  MOVLB  8
1AB1A:  MOVWF  xEE
1AB1C:  MOVLW  4E
1AB1E:  MOVWF  xF0
1AB20:  MOVLW  20
1AB22:  MOVWF  xEF
1AB24:  MOVLB  0
1AB26:  CALL   4FFC
....................    write16(ADDR_M1_COMP,0); 
1AB2A:  MOVLW  B2
1AB2C:  MOVLB  8
1AB2E:  MOVWF  xEE
1AB30:  CLRF   xF0
1AB32:  CLRF   xEF
1AB34:  MOVLB  0
1AB36:  CALL   4FFC
....................    write16(ADDR_M1_LIN_POS,0); 
1AB3A:  MOVLW  B6
1AB3C:  MOVLB  8
1AB3E:  MOVWF  xEE
1AB40:  CLRF   xF0
1AB42:  CLRF   xEF
1AB44:  MOVLB  0
1AB46:  CALL   4FFC
....................    write16(ADDR_E1_INDEX,0); 
1AB4A:  MOVLW  BA
1AB4C:  MOVLB  8
1AB4E:  MOVWF  xEE
1AB50:  CLRF   xF0
1AB52:  CLRF   xEF
1AB54:  MOVLB  0
1AB56:  CALL   4FFC
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1AB5A:  MOVLW  88
1AB5C:  MOVLB  8
1AB5E:  MOVWF  xEE
1AB60:  CLRF   xF0
1AB62:  MOVLW  01
1AB64:  MOVWF  xEF
1AB66:  MOVLB  0
1AB68:  CALL   4FFC
....................    write16(ADDR_M2_MODE,HALF); 
1AB6C:  MOVLW  8C
1AB6E:  MOVLB  8
1AB70:  MOVWF  xEE
1AB72:  CLRF   xF0
1AB74:  MOVLW  01
1AB76:  MOVWF  xEF
1AB78:  MOVLB  0
1AB7A:  CALL   4FFC
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1AB7E:  MOVLW  90
1AB80:  MOVLB  8
1AB82:  MOVWF  xEE
1AB84:  CLRF   xF0
1AB86:  MOVLW  28
1AB88:  MOVWF  xEF
1AB8A:  MOVLB  0
1AB8C:  CALL   4FFC
....................    write16(ADDR_M2_POS_DIR,1); 
1AB90:  MOVLW  94
1AB92:  MOVLB  8
1AB94:  MOVWF  xEE
1AB96:  CLRF   xF0
1AB98:  MOVLW  01
1AB9A:  MOVWF  xEF
1AB9C:  MOVLB  0
1AB9E:  CALL   4FFC
....................    write16(ADDR_M2_PWM_HLD,0); 
1ABA2:  MOVLW  98
1ABA4:  MOVLB  8
1ABA6:  MOVWF  xEE
1ABA8:  CLRF   xF0
1ABAA:  CLRF   xEF
1ABAC:  MOVLB  0
1ABAE:  CALL   4FFC
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1ABB2:  MOVLW  9C
1ABB4:  MOVLB  8
1ABB6:  MOVWF  xEE
1ABB8:  CLRF   xF0
1ABBA:  MOVLW  7F
1ABBC:  MOVWF  xEF
1ABBE:  MOVLB  0
1ABC0:  CALL   4FFC
....................    write16(ADDR_M2_GB_ERR,0); 
1ABC4:  MOVLW  A0
1ABC6:  MOVLB  8
1ABC8:  MOVWF  xEE
1ABCA:  CLRF   xF0
1ABCC:  CLRF   xEF
1ABCE:  MOVLB  0
1ABD0:  CALL   4FFC
....................    write16(ADDR_E2_CPR,0); 
1ABD4:  MOVLW  A4
1ABD6:  MOVLB  8
1ABD8:  MOVWF  xEE
1ABDA:  CLRF   xF0
1ABDC:  CLRF   xEF
1ABDE:  MOVLB  0
1ABE0:  CALL   4FFC
....................    write16(ADDR_E2_PPR,0);   
1ABE4:  MOVLW  A8
1ABE6:  MOVLB  8
1ABE8:  MOVWF  xEE
1ABEA:  CLRF   xF0
1ABEC:  CLRF   xEF
1ABEE:  MOVLB  0
1ABF0:  CALL   4FFC
....................    write16(ADDR_E2_MODE,0); 
1ABF4:  MOVLW  84
1ABF6:  MOVLB  8
1ABF8:  MOVWF  xEE
1ABFA:  CLRF   xF0
1ABFC:  CLRF   xEF
1ABFE:  MOVLB  0
1AC00:  CALL   4FFC
....................    write16(ADDR_E2_POS,0); 
1AC04:  MOVLW  80
1AC06:  MOVLB  8
1AC08:  MOVWF  xEE
1AC0A:  CLRF   xF0
1AC0C:  CLRF   xEF
1AC0E:  MOVLB  0
1AC10:  CALL   4FFC
....................    write16(ADDR_E2_PORT,0); 
1AC14:  MOVLW  AC
1AC16:  MOVLB  8
1AC18:  MOVWF  xEE
1AC1A:  CLRF   xF0
1AC1C:  CLRF   xEF
1AC1E:  MOVLB  0
1AC20:  CALL   4FFC
....................    write16(ADDR_E2_TYPE,0); 
1AC24:  MOVLW  7C
1AC26:  MOVLB  8
1AC28:  MOVWF  xEE
1AC2A:  CLRF   xF0
1AC2C:  CLRF   xEF
1AC2E:  MOVLB  0
1AC30:  CALL   4FFC
....................    write16(ADDR_M2_RUN,0); 
1AC34:  MOVLW  78
1AC36:  MOVLB  8
1AC38:  MOVWF  xEE
1AC3A:  CLRF   xF0
1AC3C:  CLRF   xEF
1AC3E:  MOVLB  0
1AC40:  CALL   4FFC
....................    write16(ADDR_M2_BKLSH,0); 
1AC44:  MOVLW  74
1AC46:  MOVLB  8
1AC48:  MOVWF  xEE
1AC4A:  CLRF   xF0
1AC4C:  CLRF   xEF
1AC4E:  MOVLB  0
1AC50:  CALL   4FFC
....................    write16(ADDR_M2_ERROR,0);   
1AC54:  MOVLW  70
1AC56:  MOVLB  8
1AC58:  MOVWF  xEE
1AC5A:  CLRF   xF0
1AC5C:  CLRF   xEF
1AC5E:  MOVLB  0
1AC60:  CALL   4FFC
....................    write16(ADDR_M2_SPR,0); 
1AC64:  MOVLW  B0
1AC66:  MOVLB  8
1AC68:  MOVWF  xEE
1AC6A:  CLRF   xF0
1AC6C:  CLRF   xEF
1AC6E:  MOVLB  0
1AC70:  CALL   4FFC
....................    write16(ADDR_M2_COMP,0); 
1AC74:  MOVLW  B4
1AC76:  MOVLB  8
1AC78:  MOVWF  xEE
1AC7A:  CLRF   xF0
1AC7C:  CLRF   xEF
1AC7E:  MOVLB  0
1AC80:  CALL   4FFC
....................    write16(ADDR_M2_LIN_POS,0);    
1AC84:  MOVLW  B8
1AC86:  MOVLB  8
1AC88:  MOVWF  xEE
1AC8A:  CLRF   xF0
1AC8C:  CLRF   xEF
1AC8E:  MOVLB  0
1AC90:  CALL   4FFC
....................    write16(ADDR_E2_INDEX,0); 
1AC94:  MOVLW  BC
1AC96:  MOVLB  8
1AC98:  MOVWF  xEE
1AC9A:  CLRF   xF0
1AC9C:  CLRF   xEF
1AC9E:  MOVLB  0
1ACA0:  CALL   4FFC
....................     
....................    get_step_vars(); 
1ACA4:  CALL   2D42
1ACA8:  GOTO   1ACFC (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
029C0:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
029C2:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
029C4:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
029C6:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
029C8:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
029CA:  BCF    F90.5
....................    set_pwm1_duty(0);    
029CC:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
029CE:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
029D0:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
029D2:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
029D4:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
029D6:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
029D8:  BCF    F8D.5
....................    set_pwm2_duty(0);  
029DA:  MOVLB  F
029DC:  CLRF   x4F
....................  
....................    output_low(VENC1); 
029DE:  BCF    F8E.6
....................    output_low(VENC2);         
029E0:  BCF    F8E.7
....................    output_low(VHBRDG); 
029E2:  BCF    F8E.2
029E4:  MOVLB  0
029E6:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
0127A:  BCF    FD8.0
0127C:  MOVLB  7
0127E:  RLCF   x40,W
01280:  CLRF   03
01282:  ADDLW  4E
01284:  MOVWF  FE9
01286:  MOVLW  07
01288:  ADDWFC 03,W
0128A:  MOVWF  FEA
0128C:  MOVFF  FEC,A38
01290:  MOVF   FED,F
01292:  MOVFF  FEF,A37
01296:  MOVLB  A
01298:  MOVF   x37,F
0129A:  BTFSS  FD8.2
0129C:  BRA    1424
0129E:  MOVF   x38,F
012A0:  BTFSS  FD8.2
012A2:  BRA    1424
....................       if(m_way[motor]==POS) { 
012A4:  BCF    FD8.0
012A6:  MOVLB  7
012A8:  RLCF   x40,W
012AA:  CLRF   03
012AC:  ADDLW  86
012AE:  MOVWF  FE9
012B0:  MOVLW  07
012B2:  ADDWFC 03,W
012B4:  MOVWF  FEA
012B6:  MOVFF  FEC,A38
012BA:  MOVF   FED,F
012BC:  MOVFF  FEF,A37
012C0:  MOVLB  A
012C2:  MOVF   x37,F
012C4:  BNZ   135E
012C6:  MOVF   x38,F
012C8:  BNZ   135E
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
012CA:  BCF    FD8.0
012CC:  MOVLB  7
012CE:  RLCF   x40,W
012D0:  CLRF   03
012D2:  ADDLW  BF
012D4:  MOVWF  FE9
012D6:  MOVLW  07
012D8:  ADDWFC 03,W
012DA:  MOVWF  FEA
012DC:  MOVFF  FEC,A38
012E0:  MOVF   FED,F
012E2:  MOVFF  FEF,A37
012E6:  BCF    FD8.0
012E8:  RLCF   x40,W
012EA:  CLRF   03
012EC:  ADDLW  5E
012EE:  MOVWF  FE9
012F0:  MOVLW  07
012F2:  ADDWFC 03,W
012F4:  MOVWF  FEA
012F6:  MOVFF  FEC,03
012FA:  MOVF   FED,F
012FC:  MOVFF  FEF,01
01300:  MOVF   03,W
01302:  MOVLB  A
01304:  SUBWF  x38,W
01306:  BNC   132A
01308:  BNZ   1310
0130A:  MOVF   01,W
0130C:  SUBWF  x37,W
0130E:  BNC   132A
01310:  BCF    FD8.0
01312:  MOVLB  7
01314:  RLCF   x40,W
01316:  CLRF   03
01318:  ADDLW  BF
0131A:  MOVWF  FE9
0131C:  MOVLW  07
0131E:  ADDWFC 03,W
01320:  MOVWF  FEA
01322:  CLRF   FEC
01324:  MOVF   FED,F
01326:  CLRF   FEF
01328:  MOVLB  A
....................          e_pos[motor]++; 
0132A:  BCF    FD8.0
0132C:  MOVLB  7
0132E:  RLCF   x40,W
01330:  CLRF   03
01332:  ADDLW  BF
01334:  MOVWF  FE9
01336:  MOVLW  07
01338:  ADDWFC 03,W
0133A:  MOVWF  FEA
0133C:  MOVLW  01
0133E:  ADDWF  FEE,F
01340:  BNC   1344
01342:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
01344:  BCF    FD8.0
01346:  RLCF   x40,W
01348:  CLRF   03
0134A:  ADDLW  9A
0134C:  MOVWF  FE9
0134E:  MOVLW  07
01350:  ADDWFC 03,W
01352:  MOVWF  FEA
01354:  CLRF   FEC
01356:  MOVF   FED,F
01358:  CLRF   FEF
....................       } 
0135A:  BRA    1422
0135C:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
0135E:  BCF    FD8.0
01360:  MOVLB  7
01362:  RLCF   x40,W
01364:  CLRF   03
01366:  ADDLW  86
01368:  MOVWF  FE9
0136A:  MOVLW  07
0136C:  ADDWFC 03,W
0136E:  MOVWF  FEA
01370:  MOVFF  FEC,A38
01374:  MOVF   FED,F
01376:  MOVFF  FEF,A37
0137A:  MOVLB  A
0137C:  DECFSZ x37,W
0137E:  BRA    1424
01380:  MOVF   x38,F
01382:  BNZ   1424
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01384:  BCF    FD8.0
01386:  MOVLB  7
01388:  RLCF   x40,W
0138A:  CLRF   03
0138C:  ADDLW  BF
0138E:  MOVWF  FE9
01390:  MOVLW  07
01392:  ADDWFC 03,W
01394:  MOVWF  FEA
01396:  MOVFF  FEC,A38
0139A:  MOVF   FED,F
0139C:  MOVFF  FEF,A37
013A0:  MOVLB  A
013A2:  MOVF   x37,F
013A4:  BNZ   13F0
013A6:  MOVF   x38,F
013A8:  BNZ   13F0
013AA:  BCF    FD8.0
013AC:  MOVLB  7
013AE:  RLCF   x40,W
013B0:  CLRF   03
013B2:  ADDLW  BF
013B4:  MOVWF  01
013B6:  MOVLW  07
013B8:  ADDWFC 03,F
013BA:  MOVLB  A
013BC:  MOVFF  03,A38
013C0:  BCF    FD8.0
013C2:  MOVLB  7
013C4:  RLCF   x40,W
013C6:  CLRF   03
013C8:  ADDLW  5E
013CA:  MOVWF  FE9
013CC:  MOVLW  07
013CE:  ADDWFC 03,W
013D0:  MOVWF  FEA
013D2:  MOVFF  FEC,03
013D6:  MOVF   FED,F
013D8:  MOVFF  FEF,A39
013DC:  MOVLB  A
013DE:  MOVFF  A38,FEA
013E2:  MOVFF  01,FE9
013E6:  MOVFF  03,FEC
013EA:  MOVF   FED,F
013EC:  MOVFF  A39,FEF
....................          e_pos[motor]--; 
013F0:  BCF    FD8.0
013F2:  MOVLB  7
013F4:  RLCF   x40,W
013F6:  CLRF   03
013F8:  ADDLW  BF
013FA:  MOVWF  FE9
013FC:  MOVLW  07
013FE:  ADDWFC 03,W
01400:  MOVWF  FEA
01402:  MOVLW  FF
01404:  ADDWF  FEF,F
01406:  BC    140C
01408:  MOVF   FEE,F
0140A:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
0140C:  BCF    FD8.0
0140E:  RLCF   x40,W
01410:  CLRF   03
01412:  ADDLW  9A
01414:  MOVWF  FE9
01416:  MOVLW  07
01418:  ADDWFC 03,W
0141A:  MOVWF  FEA
0141C:  CLRF   FEC
0141E:  MOVF   FED,F
01420:  CLRF   FEF
01422:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
01424:  BCF    FD8.0
01426:  MOVLB  7
01428:  RLCF   x40,W
0142A:  CLRF   03
0142C:  ADDLW  4E
0142E:  MOVWF  FE9
01430:  MOVLW  07
01432:  ADDWFC 03,W
01434:  MOVWF  FEA
01436:  MOVFF  FEC,A38
0143A:  MOVF   FED,F
0143C:  MOVFF  FEF,A37
01440:  MOVLB  A
01442:  DECFSZ x37,W
01444:  BRA    15CC
01446:  MOVF   x38,F
01448:  BTFSS  FD8.2
0144A:  BRA    15CC
....................       if(m_way[motor]==NEG) { 
0144C:  BCF    FD8.0
0144E:  MOVLB  7
01450:  RLCF   x40,W
01452:  CLRF   03
01454:  ADDLW  86
01456:  MOVWF  FE9
01458:  MOVLW  07
0145A:  ADDWFC 03,W
0145C:  MOVWF  FEA
0145E:  MOVFF  FEC,A38
01462:  MOVF   FED,F
01464:  MOVFF  FEF,A37
01468:  MOVLB  A
0146A:  DECFSZ x37,W
0146C:  BRA    1506
0146E:  MOVF   x38,F
01470:  BNZ   1506
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
01472:  BCF    FD8.0
01474:  MOVLB  7
01476:  RLCF   x40,W
01478:  CLRF   03
0147A:  ADDLW  BF
0147C:  MOVWF  FE9
0147E:  MOVLW  07
01480:  ADDWFC 03,W
01482:  MOVWF  FEA
01484:  MOVFF  FEC,A38
01488:  MOVF   FED,F
0148A:  MOVFF  FEF,A37
0148E:  BCF    FD8.0
01490:  RLCF   x40,W
01492:  CLRF   03
01494:  ADDLW  5E
01496:  MOVWF  FE9
01498:  MOVLW  07
0149A:  ADDWFC 03,W
0149C:  MOVWF  FEA
0149E:  MOVFF  FEC,03
014A2:  MOVF   FED,F
014A4:  MOVFF  FEF,01
014A8:  MOVF   03,W
014AA:  MOVLB  A
014AC:  SUBWF  x38,W
014AE:  BNC   14D2
014B0:  BNZ   14B8
014B2:  MOVF   01,W
014B4:  SUBWF  x37,W
014B6:  BNC   14D2
014B8:  BCF    FD8.0
014BA:  MOVLB  7
014BC:  RLCF   x40,W
014BE:  CLRF   03
014C0:  ADDLW  BF
014C2:  MOVWF  FE9
014C4:  MOVLW  07
014C6:  ADDWFC 03,W
014C8:  MOVWF  FEA
014CA:  CLRF   FEC
014CC:  MOVF   FED,F
014CE:  CLRF   FEF
014D0:  MOVLB  A
....................          e_pos[motor]++; 
014D2:  BCF    FD8.0
014D4:  MOVLB  7
014D6:  RLCF   x40,W
014D8:  CLRF   03
014DA:  ADDLW  BF
014DC:  MOVWF  FE9
014DE:  MOVLW  07
014E0:  ADDWFC 03,W
014E2:  MOVWF  FEA
014E4:  MOVLW  01
014E6:  ADDWF  FEE,F
014E8:  BNC   14EC
014EA:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014EC:  BCF    FD8.0
014EE:  RLCF   x40,W
014F0:  CLRF   03
014F2:  ADDLW  9A
014F4:  MOVWF  FE9
014F6:  MOVLW  07
014F8:  ADDWFC 03,W
014FA:  MOVWF  FEA
014FC:  CLRF   FEC
014FE:  MOVF   FED,F
01500:  CLRF   FEF
....................       } 
01502:  BRA    15CA
01504:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
01506:  BCF    FD8.0
01508:  MOVLB  7
0150A:  RLCF   x40,W
0150C:  CLRF   03
0150E:  ADDLW  86
01510:  MOVWF  FE9
01512:  MOVLW  07
01514:  ADDWFC 03,W
01516:  MOVWF  FEA
01518:  MOVFF  FEC,A38
0151C:  MOVF   FED,F
0151E:  MOVFF  FEF,A37
01522:  MOVLB  A
01524:  MOVF   x37,F
01526:  BNZ   15CC
01528:  MOVF   x38,F
0152A:  BNZ   15CC
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
0152C:  BCF    FD8.0
0152E:  MOVLB  7
01530:  RLCF   x40,W
01532:  CLRF   03
01534:  ADDLW  BF
01536:  MOVWF  FE9
01538:  MOVLW  07
0153A:  ADDWFC 03,W
0153C:  MOVWF  FEA
0153E:  MOVFF  FEC,A38
01542:  MOVF   FED,F
01544:  MOVFF  FEF,A37
01548:  MOVLB  A
0154A:  MOVF   x37,F
0154C:  BNZ   1598
0154E:  MOVF   x38,F
01550:  BNZ   1598
01552:  BCF    FD8.0
01554:  MOVLB  7
01556:  RLCF   x40,W
01558:  CLRF   03
0155A:  ADDLW  BF
0155C:  MOVWF  01
0155E:  MOVLW  07
01560:  ADDWFC 03,F
01562:  MOVLB  A
01564:  MOVFF  03,A38
01568:  BCF    FD8.0
0156A:  MOVLB  7
0156C:  RLCF   x40,W
0156E:  CLRF   03
01570:  ADDLW  5E
01572:  MOVWF  FE9
01574:  MOVLW  07
01576:  ADDWFC 03,W
01578:  MOVWF  FEA
0157A:  MOVFF  FEC,03
0157E:  MOVF   FED,F
01580:  MOVFF  FEF,A39
01584:  MOVLB  A
01586:  MOVFF  A38,FEA
0158A:  MOVFF  01,FE9
0158E:  MOVFF  03,FEC
01592:  MOVF   FED,F
01594:  MOVFF  A39,FEF
....................          e_pos[motor]--; 
01598:  BCF    FD8.0
0159A:  MOVLB  7
0159C:  RLCF   x40,W
0159E:  CLRF   03
015A0:  ADDLW  BF
015A2:  MOVWF  FE9
015A4:  MOVLW  07
015A6:  ADDWFC 03,W
015A8:  MOVWF  FEA
015AA:  MOVLW  FF
015AC:  ADDWF  FEF,F
015AE:  BC    15B4
015B0:  MOVF   FEE,F
015B2:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
015B4:  BCF    FD8.0
015B6:  RLCF   x40,W
015B8:  CLRF   03
015BA:  ADDLW  9A
015BC:  MOVWF  FE9
015BE:  MOVLW  07
015C0:  ADDWFC 03,W
015C2:  MOVWF  FEA
015C4:  CLRF   FEC
015C6:  MOVF   FED,F
015C8:  CLRF   FEF
015CA:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
015CC:  MOVF   1F,W
015CE:  SUBLW  04
015D0:  BTFSS  FD8.2
015D2:  BRA    1706
015D4:  MOVF   20,F
015D6:  BTFSS  FD8.2
015D8:  BRA    1706
015DA:  BCF    FD8.0
015DC:  MOVLB  7
015DE:  RLCF   x40,W
015E0:  CLRF   03
015E2:  ADDLW  6A
015E4:  MOVWF  FE9
015E6:  MOVLW  07
015E8:  ADDWFC 03,W
015EA:  MOVWF  FEA
015EC:  MOVFF  FEC,A38
015F0:  MOVF   FED,F
015F2:  MOVFF  FEF,A37
015F6:  MOVLB  A
015F8:  MOVF   x37,W
015FA:  SUBLW  02
015FC:  BTFSS  FD8.2
015FE:  BRA    1706
01600:  MOVF   x38,F
01602:  BTFSS  FD8.2
01604:  BRA    1706
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
01606:  MOVLW  01
01608:  MOVLB  7
0160A:  ADDWF  x40,W
0160C:  MOVLB  A
0160E:  MOVWF  x37
01610:  MOVLB  7
01612:  MOVF   x40,W
01614:  MULLW  04
01616:  MOVF   FF3,W
01618:  CLRF   03
0161A:  ADDLW  A2
0161C:  MOVWF  FE9
0161E:  MOVLW  07
01620:  ADDWFC 03,W
01622:  MOVWF  FEA
01624:  MOVFF  FEF,A38
01628:  MOVFF  FEC,A39
0162C:  MOVFF  FEC,A3A
01630:  MOVFF  FEC,A3B
01634:  BCF    FD8.0
01636:  RLCF   x40,W
01638:  CLRF   03
0163A:  ADDLW  BB
0163C:  MOVWF  FE9
0163E:  MOVLW  07
01640:  ADDWFC 03,W
01642:  MOVWF  FEA
01644:  MOVFF  FEC,A3D
01648:  MOVF   FED,F
0164A:  MOVFF  FEF,A3C
0164E:  BCF    FD8.0
01650:  RLCF   x40,W
01652:  CLRF   03
01654:  ADDLW  BF
01656:  MOVWF  FE9
01658:  MOVLW  07
0165A:  ADDWFC 03,W
0165C:  MOVWF  FEA
0165E:  MOVFF  FEC,A3F
01662:  MOVF   FED,F
01664:  MOVFF  FEF,A3E
01668:  MOVLW  6D
0166A:  BTFSS  F9E.4
0166C:  BRA    166A
0166E:  MOVWF  FAD
01670:  MOVLW  3A
01672:  BTFSS  F9E.4
01674:  BRA    1672
01676:  MOVWF  FAD
01678:  MOVFF  A37,A40
0167C:  MOVLW  1B
0167E:  MOVLB  A
01680:  MOVWF  x41
01682:  MOVLB  0
01684:  RCALL  0FC6
01686:  MOVLW  2C
01688:  BTFSS  F9E.4
0168A:  BRA    1688
0168C:  MOVWF  FAD
0168E:  MOVFF  7AA,A40
01692:  MOVLW  1B
01694:  MOVLB  A
01696:  MOVWF  x41
01698:  MOVLB  0
0169A:  RCALL  0FC6
0169C:  MOVLW  89
0169E:  MOVWF  FF6
016A0:  MOVLW  0F
016A2:  MOVWF  FF7
016A4:  MOVLW  00
016A6:  MOVWF  FF8
016A8:  MOVLW  03
016AA:  MOVLB  A
016AC:  MOVWF  x40
016AE:  MOVLB  0
016B0:  RCALL  1044
016B2:  MOVLW  41
016B4:  MOVWF  FE9
016B6:  MOVFF  A3B,A43
016BA:  MOVFF  A3A,A42
016BE:  MOVFF  A39,A41
016C2:  MOVFF  A38,A40
016C6:  RCALL  110A
016C8:  MOVLW  2C
016CA:  BTFSS  F9E.4
016CC:  BRA    16CA
016CE:  MOVWF  FAD
016D0:  MOVLW  10
016D2:  MOVWF  FE9
016D4:  MOVFF  A3D,A41
016D8:  MOVFF  A3C,A40
016DC:  RCALL  11C6
016DE:  MOVLW  2C
016E0:  BTFSS  F9E.4
016E2:  BRA    16E0
016E4:  MOVWF  FAD
016E6:  MOVLW  10
016E8:  MOVWF  FE9
016EA:  MOVFF  A3F,A41
016EE:  MOVFF  A3E,A40
016F2:  RCALL  11C6
016F4:  MOVLW  0D
016F6:  BTFSS  F9E.4
016F8:  BRA    16F6
016FA:  MOVWF  FAD
016FC:  MOVLW  0A
016FE:  BTFSS  F9E.4
01700:  BRA    16FE
01702:  MOVWF  FAD
01704:  MOVLB  A
....................    }    
01706:  MOVLB  0
01708:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A7AA:  MOVLB  7
0A7AC:  MOVF   x40,W
0A7AE:  XORLW  00
0A7B0:  MOVLB  0
0A7B2:  BZ    A7BA
0A7B4:  XORLW  01
0A7B6:  BZ    A84A
0A7B8:  BRA    A8D8
....................       case 0 : if (e_type[motor]==1) { 
0A7BA:  BCF    FD8.0
0A7BC:  MOVLB  7
0A7BE:  RLCF   x40,W
0A7C0:  CLRF   03
0A7C2:  ADDLW  6A
0A7C4:  MOVWF  FE9
0A7C6:  MOVLW  07
0A7C8:  ADDWFC 03,W
0A7CA:  MOVWF  FEA
0A7CC:  MOVFF  FEC,8C8
0A7D0:  MOVF   FED,F
0A7D2:  MOVFF  FEF,8C7
0A7D6:  MOVLB  8
0A7D8:  DECFSZ xC7,W
0A7DA:  BRA    A7FA
0A7DC:  MOVF   xC8,F
0A7DE:  BNZ   A7FA
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A7E0:  CLRF   03
0A7E2:  MOVLB  7
0A7E4:  MOVF   x40,W
0A7E6:  ADDLW  CB
0A7E8:  MOVWF  FE9
0A7EA:  MOVLW  07
0A7EC:  ADDWFC 03,W
0A7EE:  MOVWF  FEA
0A7F0:  MOVLW  00
0A7F2:  BTFSC  F81.4
0A7F4:  MOVLW  01
0A7F6:  MOVWF  FEF
0A7F8:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A7FA:  BCF    FD8.0
0A7FC:  MOVLB  7
0A7FE:  RLCF   x40,W
0A800:  CLRF   03
0A802:  ADDLW  6A
0A804:  MOVWF  FE9
0A806:  MOVLW  07
0A808:  ADDWFC 03,W
0A80A:  MOVWF  FEA
0A80C:  MOVFF  FEC,8C8
0A810:  MOVF   FED,F
0A812:  MOVFF  FEF,8C7
0A816:  MOVLB  8
0A818:  MOVF   xC7,W
0A81A:  SUBLW  02
0A81C:  BNZ   A846
0A81E:  MOVF   xC8,F
0A820:  BNZ   A846
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A822:  CLRF   03
0A824:  MOVLB  7
0A826:  MOVF   x40,W
0A828:  ADDLW  CB
0A82A:  MOVWF  FE9
0A82C:  MOVLW  07
0A82E:  ADDWFC 03,W
0A830:  MOVWF  FEA
0A832:  MOVLW  00
0A834:  BTFSC  F81.4
0A836:  MOVLW  01
0A838:  MOVLB  8
0A83A:  MOVWF  xC9
0A83C:  MOVLW  00
0A83E:  BTFSC  F81.1
0A840:  MOVLW  01
0A842:  ANDWF  xC9,W
0A844:  MOVWF  FEF
....................                } 
....................          break; 
0A846:  MOVLB  0
0A848:  BRA    A8D8
....................       case 1 : if (e_type[motor]==1) { 
0A84A:  BCF    FD8.0
0A84C:  MOVLB  7
0A84E:  RLCF   x40,W
0A850:  CLRF   03
0A852:  ADDLW  6A
0A854:  MOVWF  FE9
0A856:  MOVLW  07
0A858:  ADDWFC 03,W
0A85A:  MOVWF  FEA
0A85C:  MOVFF  FEC,8C8
0A860:  MOVF   FED,F
0A862:  MOVFF  FEF,8C7
0A866:  MOVLB  8
0A868:  DECFSZ xC7,W
0A86A:  BRA    A88A
0A86C:  MOVF   xC8,F
0A86E:  BNZ   A88A
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A870:  CLRF   03
0A872:  MOVLB  7
0A874:  MOVF   x40,W
0A876:  ADDLW  CB
0A878:  MOVWF  FE9
0A87A:  MOVLW  07
0A87C:  ADDWFC 03,W
0A87E:  MOVWF  FEA
0A880:  MOVLW  00
0A882:  BTFSC  F81.5
0A884:  MOVLW  01
0A886:  MOVWF  FEF
0A888:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A88A:  BCF    FD8.0
0A88C:  MOVLB  7
0A88E:  RLCF   x40,W
0A890:  CLRF   03
0A892:  ADDLW  6A
0A894:  MOVWF  FE9
0A896:  MOVLW  07
0A898:  ADDWFC 03,W
0A89A:  MOVWF  FEA
0A89C:  MOVFF  FEC,8C8
0A8A0:  MOVF   FED,F
0A8A2:  MOVFF  FEF,8C7
0A8A6:  MOVLB  8
0A8A8:  MOVF   xC7,W
0A8AA:  SUBLW  02
0A8AC:  BNZ   A8D6
0A8AE:  MOVF   xC8,F
0A8B0:  BNZ   A8D6
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A8B2:  CLRF   03
0A8B4:  MOVLB  7
0A8B6:  MOVF   x40,W
0A8B8:  ADDLW  CB
0A8BA:  MOVWF  FE9
0A8BC:  MOVLW  07
0A8BE:  ADDWFC 03,W
0A8C0:  MOVWF  FEA
0A8C2:  MOVLW  00
0A8C4:  BTFSC  F81.5
0A8C6:  MOVLW  01
0A8C8:  MOVLB  8
0A8CA:  MOVWF  xC9
0A8CC:  MOVLW  00
0A8CE:  BTFSC  F81.2
0A8D0:  MOVLW  01
0A8D2:  ANDWF  xC9,W
0A8D4:  MOVWF  FEF
....................                } 
....................          break; 
0A8D6:  MOVLB  0
....................    } 
0A8D8:  GOTO   A992 (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017F6:  MOVLB  7
017F8:  MOVF   x40,W
017FA:  XORLW  00
017FC:  MOVLB  0
017FE:  BZ    1806
01800:  XORLW  01
01802:  BZ    1896
01804:  BRA    1924
....................       case 0 : if (e_type[motor]==1) { 
01806:  BCF    FD8.0
01808:  MOVLB  7
0180A:  RLCF   x40,W
0180C:  CLRF   03
0180E:  ADDLW  6A
01810:  MOVWF  FE9
01812:  MOVLW  07
01814:  ADDWFC 03,W
01816:  MOVWF  FEA
01818:  MOVFF  FEC,A38
0181C:  MOVF   FED,F
0181E:  MOVFF  FEF,A37
01822:  MOVLB  A
01824:  DECFSZ x37,W
01826:  BRA    1846
01828:  MOVF   x38,F
0182A:  BNZ   1846
....................                   e_ch_n[motor]=input(ENC1_IND); 
0182C:  CLRF   03
0182E:  MOVLB  7
01830:  MOVF   x40,W
01832:  ADDLW  CB
01834:  MOVWF  FE9
01836:  MOVLW  07
01838:  ADDWFC 03,W
0183A:  MOVWF  FEA
0183C:  MOVLW  00
0183E:  BTFSC  F81.4
01840:  MOVLW  01
01842:  MOVWF  FEF
01844:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01846:  BCF    FD8.0
01848:  MOVLB  7
0184A:  RLCF   x40,W
0184C:  CLRF   03
0184E:  ADDLW  6A
01850:  MOVWF  FE9
01852:  MOVLW  07
01854:  ADDWFC 03,W
01856:  MOVWF  FEA
01858:  MOVFF  FEC,A38
0185C:  MOVF   FED,F
0185E:  MOVFF  FEF,A37
01862:  MOVLB  A
01864:  MOVF   x37,W
01866:  SUBLW  02
01868:  BNZ   1892
0186A:  MOVF   x38,F
0186C:  BNZ   1892
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0186E:  CLRF   03
01870:  MOVLB  7
01872:  MOVF   x40,W
01874:  ADDLW  CB
01876:  MOVWF  FE9
01878:  MOVLW  07
0187A:  ADDWFC 03,W
0187C:  MOVWF  FEA
0187E:  MOVLW  00
01880:  BTFSC  F81.4
01882:  MOVLW  01
01884:  MOVLB  A
01886:  MOVWF  x39
01888:  MOVLW  00
0188A:  BTFSC  F81.1
0188C:  MOVLW  01
0188E:  ANDWF  x39,W
01890:  MOVWF  FEF
....................                } 
....................          break; 
01892:  MOVLB  0
01894:  BRA    1924
....................       case 1 : if (e_type[motor]==1) { 
01896:  BCF    FD8.0
01898:  MOVLB  7
0189A:  RLCF   x40,W
0189C:  CLRF   03
0189E:  ADDLW  6A
018A0:  MOVWF  FE9
018A2:  MOVLW  07
018A4:  ADDWFC 03,W
018A6:  MOVWF  FEA
018A8:  MOVFF  FEC,A38
018AC:  MOVF   FED,F
018AE:  MOVFF  FEF,A37
018B2:  MOVLB  A
018B4:  DECFSZ x37,W
018B6:  BRA    18D6
018B8:  MOVF   x38,F
018BA:  BNZ   18D6
....................                   e_ch_n[motor]=input(ENC2_IND); 
018BC:  CLRF   03
018BE:  MOVLB  7
018C0:  MOVF   x40,W
018C2:  ADDLW  CB
018C4:  MOVWF  FE9
018C6:  MOVLW  07
018C8:  ADDWFC 03,W
018CA:  MOVWF  FEA
018CC:  MOVLW  00
018CE:  BTFSC  F81.5
018D0:  MOVLW  01
018D2:  MOVWF  FEF
018D4:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
018D6:  BCF    FD8.0
018D8:  MOVLB  7
018DA:  RLCF   x40,W
018DC:  CLRF   03
018DE:  ADDLW  6A
018E0:  MOVWF  FE9
018E2:  MOVLW  07
018E4:  ADDWFC 03,W
018E6:  MOVWF  FEA
018E8:  MOVFF  FEC,A38
018EC:  MOVF   FED,F
018EE:  MOVFF  FEF,A37
018F2:  MOVLB  A
018F4:  MOVF   x37,W
018F6:  SUBLW  02
018F8:  BNZ   1922
018FA:  MOVF   x38,F
018FC:  BNZ   1922
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018FE:  CLRF   03
01900:  MOVLB  7
01902:  MOVF   x40,W
01904:  ADDLW  CB
01906:  MOVWF  FE9
01908:  MOVLW  07
0190A:  ADDWFC 03,W
0190C:  MOVWF  FEA
0190E:  MOVLW  00
01910:  BTFSC  F81.5
01912:  MOVLW  01
01914:  MOVLB  A
01916:  MOVWF  x39
01918:  MOVLW  00
0191A:  BTFSC  F81.2
0191C:  MOVLW  01
0191E:  ANDWF  x39,W
01920:  MOVWF  FEF
....................                } 
....................          break; 
01922:  MOVLB  0
....................    } 
01924:  GOTO   1A72 (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
0170A:  BCF    FD8.0
0170C:  MOVLB  7
0170E:  RLCF   x40,W
01710:  CLRF   03
01712:  ADDLW  BB
01714:  MOVWF  FE9
01716:  MOVLW  07
01718:  ADDWFC 03,W
0171A:  MOVWF  FEA
0171C:  MOVLW  01
0171E:  ADDWF  FEE,F
01720:  BNC   1724
01722:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
01724:  MOVF   xAA,W
01726:  XORLW  00
01728:  MOVLB  0
0172A:  BZ    1736
0172C:  XORLW  01
0172E:  BZ    173C
01730:  XORLW  03
01732:  BZ    174E
01734:  BRA    1778
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
01736:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
01738:  BCF    FF0.0
....................          break; 
0173A:  BRA    1778
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
0173C:  MOVLW  02
0173E:  MOVLB  7
01740:  MOVWF  xAA
....................                disable_interrupts(INT_EXT1_L2H); 
01742:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
01744:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
01746:  BSF    FF0.3
01748:  BCF    FF1.5
....................          break; 
0174A:  MOVLB  0
0174C:  BRA    1778
....................       case 2 : edge_mode=1; 
0174E:  MOVLW  01
01750:  MOVLB  7
01752:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01754:  BCF    FD8.0
01756:  RLCF   x40,W
01758:  CLRF   03
0175A:  ADDLW  BB
0175C:  MOVWF  FE9
0175E:  MOVLW  07
01760:  ADDWFC 03,W
01762:  MOVWF  FEA
01764:  MOVLW  FF
01766:  ADDWF  FEF,F
01768:  BC    176E
0176A:  MOVF   FEE,F
0176C:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
0176E:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
01770:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
01772:  BSF    FF0.3
01774:  BSF    FF1.5
....................          break; 
01776:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
01778:  RCALL  127A
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
0177A:  BCF    FF0.0
0177C:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
01780:  BCF    FD8.0
01782:  MOVLB  7
01784:  RLCF   x40,W
01786:  CLRF   03
01788:  ADDLW  BB
0178A:  MOVWF  FE9
0178C:  MOVLW  07
0178E:  ADDWFC 03,W
01790:  MOVWF  FEA
01792:  MOVLW  01
01794:  ADDWF  FEE,F
01796:  BNC   179A
01798:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
0179A:  MOVF   xAA,W
0179C:  XORLW  00
0179E:  MOVLB  0
017A0:  BZ    17AC
017A2:  XORLW  01
017A4:  BZ    17B2
017A6:  XORLW  03
017A8:  BZ    17C4
017AA:  BRA    17EE
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
017AC:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
017AE:  BCF    FF0.1
....................          break; 
017B0:  BRA    17EE
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
017B2:  MOVLW  02
017B4:  MOVLB  7
017B6:  MOVWF  xAA
....................                disable_interrupts(INT_EXT2_L2H); 
017B8:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
017BA:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
017BC:  BSF    FF0.4
017BE:  BCF    FF1.4
....................          break; 
017C0:  MOVLB  0
017C2:  BRA    17EE
....................       case 2 : edge_mode=1; 
017C4:  MOVLW  01
017C6:  MOVLB  7
017C8:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
017CA:  BCF    FD8.0
017CC:  RLCF   x40,W
017CE:  CLRF   03
017D0:  ADDLW  BB
017D2:  MOVWF  FE9
017D4:  MOVLW  07
017D6:  ADDWFC 03,W
017D8:  MOVWF  FEA
017DA:  MOVLW  FF
017DC:  ADDWF  FEF,F
017DE:  BC    17E4
017E0:  MOVF   FEE,F
017E2:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017E4:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017E6:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017E8:  BSF    FF0.4
017EA:  BSF    FF1.4
....................          break; 
017EC:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017EE:  RCALL  127A
.................... } 
....................  
.................... // motor step timer interrupt 
017F0:  BCF    FF0.1
017F2:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
01928:  MOVLW  F9
0192A:  MOVWF  FB3
0192C:  MOVLW  C0
0192E:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
01930:  BCF    FD8.0
01932:  MOVLB  7
01934:  RLCF   x40,W
01936:  CLRF   03
01938:  ADDLW  8E
0193A:  MOVWF  FE9
0193C:  MOVLW  07
0193E:  ADDWFC 03,W
01940:  MOVWF  FEA
01942:  MOVLW  01
01944:  ADDWF  FEE,F
01946:  BNC   194A
01948:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
0194A:  BCF    FD8.0
0194C:  RLCF   x40,W
0194E:  CLRF   03
01950:  ADDLW  8E
01952:  MOVWF  FE9
01954:  MOVLW  07
01956:  ADDWFC 03,W
01958:  MOVWF  FEA
0195A:  MOVFF  FEC,A38
0195E:  MOVF   FED,F
01960:  MOVFF  FEF,A37
01964:  BCF    FD8.0
01966:  RLCF   x40,W
01968:  CLRF   03
0196A:  ADDLW  4A
0196C:  MOVWF  FE9
0196E:  MOVLW  07
01970:  ADDWFC 03,W
01972:  MOVWF  FEA
01974:  MOVFF  FEC,03
01978:  MOVF   FED,F
0197A:  MOVFF  FEF,01
0197E:  MOVF   03,W
01980:  MOVLB  A
01982:  SUBWF  x38,W
01984:  BTFSS  FD8.0
01986:  BRA    1A74
01988:  BNZ   1992
0198A:  MOVF   01,W
0198C:  SUBWF  x37,W
0198E:  BTFSS  FD8.0
01990:  BRA    1A74
....................    { 
....................       m_step_cnt[motor]++; 
01992:  MOVLB  7
01994:  MOVF   x40,W
01996:  MULLW  04
01998:  MOVF   FF3,W
0199A:  CLRF   03
0199C:  ADDLW  A2
0199E:  MOVWF  FE9
019A0:  MOVLW  07
019A2:  ADDWFC 03,W
019A4:  MOVWF  FEA
019A6:  MOVLW  01
019A8:  ADDWF  FEE,F
019AA:  MOVLW  00
019AC:  ADDWFC FEE,F
019AE:  ADDWFC FEE,F
019B0:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
019B2:  BCF    FD8.0
019B4:  RLCF   x40,W
019B6:  CLRF   03
019B8:  ADDLW  9A
019BA:  MOVWF  FE9
019BC:  MOVLW  07
019BE:  ADDWFC 03,W
019C0:  MOVWF  FEA
019C2:  MOVLW  01
019C4:  ADDWF  FEE,F
019C6:  BNC   19CA
019C8:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
019CA:  BCF    FD8.0
019CC:  RLCF   x40,W
019CE:  CLRF   03
019D0:  ADDLW  8E
019D2:  MOVWF  FE9
019D4:  MOVLW  07
019D6:  ADDWFC 03,W
019D8:  MOVWF  FEA
019DA:  CLRF   FEC
019DC:  MOVF   FED,F
019DE:  CLRF   FEF
....................  
....................       if (motor==0) 
019E0:  MOVF   x40,F
019E2:  BNZ   19E8
....................       { 
....................          output_toggle(M1_CLOCK); 
019E4:  BTG    F90.4
....................       } 
019E6:  BRA    1A48
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019E8:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019EA:  BCF    FD8.0
019EC:  RLCF   x40,W
019EE:  CLRF   03
019F0:  ADDLW  86
019F2:  MOVWF  FE9
019F4:  MOVLW  07
019F6:  ADDWFC 03,W
019F8:  MOVWF  FEA
019FA:  MOVFF  FEC,A38
019FE:  MOVF   FED,F
01A00:  MOVFF  FEF,A37
01A04:  MOVLB  A
01A06:  MOVF   x37,F
01A08:  BNZ   1A2E
01A0A:  MOVF   x38,F
01A0C:  BNZ   1A2E
01A0E:  BCF    FD8.0
01A10:  MOVLB  7
01A12:  RLCF   x40,W
01A14:  CLRF   03
01A16:  ADDLW  B3
01A18:  MOVWF  FE9
01A1A:  MOVLW  07
01A1C:  ADDWFC 03,W
01A1E:  MOVWF  FEA
01A20:  MOVLW  FF
01A22:  ADDWF  FEF,F
01A24:  BC    1A2A
01A26:  MOVF   FEE,F
01A28:  DECF   FED,F
01A2A:  BRA    1A48
01A2C:  MOVLB  A
....................          else m_lin_pos[motor]++;          
01A2E:  BCF    FD8.0
01A30:  MOVLB  7
01A32:  RLCF   x40,W
01A34:  CLRF   03
01A36:  ADDLW  B3
01A38:  MOVWF  FE9
01A3A:  MOVLW  07
01A3C:  ADDWFC 03,W
01A3E:  MOVWF  FEA
01A40:  MOVLW  01
01A42:  ADDWF  FEE,F
01A44:  BNC   1A48
01A46:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A48:  BCF    FD8.0
01A4A:  RLCF   x40,W
01A4C:  CLRF   03
01A4E:  ADDLW  66
01A50:  MOVWF  FE9
01A52:  MOVLW  07
01A54:  ADDWFC 03,W
01A56:  MOVWF  FEA
01A58:  MOVFF  FEC,A38
01A5C:  MOVF   FED,F
01A5E:  MOVFF  FEF,A37
01A62:  MOVLB  A
01A64:  MOVF   x37,W
01A66:  SUBLW  03
01A68:  BNZ   1A74
01A6A:  MOVF   x38,F
01A6C:  BNZ   1A74
01A6E:  MOVLB  0
01A70:  BRA    17F6
01A72:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A74:  BCF    FA1.1
01A76:  BCF    FA1.1
01A78:  MOVLB  0
01A7A:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
08A0C:  BCF    FD8.0
08A0E:  MOVLB  7
08A10:  RLCF   x40,W
08A12:  CLRF   03
08A14:  ADDLW  4E
08A16:  MOVWF  FE9
08A18:  MOVLW  07
08A1A:  ADDWFC 03,W
08A1C:  MOVWF  FEA
08A1E:  MOVFF  FEC,8D9
08A22:  MOVF   FED,F
08A24:  MOVFF  FEF,8D8
08A28:  MOVLB  8
08A2A:  DECFSZ xD8,W
08A2C:  BRA    8A7C
08A2E:  MOVF   xD9,F
08A30:  BNZ   8A7C
08A32:  BCF    FD8.0
08A34:  MOVLB  7
08A36:  RLCF   x40,W
08A38:  CLRF   03
08A3A:  ADDLW  86
08A3C:  MOVWF  01
08A3E:  MOVLW  07
08A40:  ADDWFC 03,F
08A42:  MOVFF  01,8D8
08A46:  MOVLB  8
08A48:  MOVFF  03,8D9
08A4C:  BCF    FD8.0
08A4E:  MOVLB  7
08A50:  RLCF   x40,W
08A52:  CLRF   03
08A54:  ADDLW  86
08A56:  MOVWF  FE9
08A58:  MOVLW  07
08A5A:  ADDWFC 03,W
08A5C:  MOVWF  FEA
08A5E:  MOVF   FEF,F
08A60:  BNZ   8A66
08A62:  MOVF   FEC,F
08A64:  BZ    8A6A
08A66:  MOVLW  00
08A68:  BRA    8A6C
08A6A:  MOVLW  01
08A6C:  MOVLB  8
08A6E:  MOVFF  8D9,FEA
08A72:  MOVFF  8D8,FE9
08A76:  CLRF   FEC
08A78:  MOVF   FED,F
08A7A:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
08A7C:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
08A7E:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
08A80:  BCF    FD8.0
08A82:  MOVLB  7
08A84:  RLCF   x40,W
08A86:  CLRF   03
08A88:  ADDLW  42
08A8A:  MOVWF  FE9
08A8C:  MOVLW  07
08A8E:  ADDWFC 03,W
08A90:  MOVWF  FEA
08A92:  MOVF   FEF,F
08A94:  BNZ   8A9E
08A96:  MOVF   FEC,F
08A98:  BNZ   8A9E
08A9A:  BCF    F90.2
08A9C:  BRA    8AA0
08A9E:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
08AA0:  BCF    FD8.0
08AA2:  RLCF   x40,W
08AA4:  CLRF   03
08AA6:  ADDLW  46
08AA8:  MOVWF  FE9
08AAA:  MOVLW  07
08AAC:  ADDWFC 03,W
08AAE:  MOVWF  FEA
08AB0:  MOVF   FEF,F
08AB2:  BNZ   8ABC
08AB4:  MOVF   FEC,F
08AB6:  BNZ   8ABC
08AB8:  BCF    F90.3
08ABA:  BRA    8ABE
08ABC:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
08ABE:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
08AC0:  BCF    FD8.0
08AC2:  RLCF   x40,W
08AC4:  CLRF   03
08AC6:  ADDLW  86
08AC8:  MOVWF  FE9
08ACA:  MOVLW  07
08ACC:  ADDWFC 03,W
08ACE:  MOVWF  FEA
08AD0:  MOVF   FEF,F
08AD2:  BNZ   8ADC
08AD4:  MOVF   FEC,F
08AD6:  BNZ   8ADC
08AD8:  BCF    F90.5
08ADA:  BRA    8ADE
08ADC:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
08ADE:  BCF    FD8.0
08AE0:  RLCF   x40,W
08AE2:  CLRF   03
08AE4:  ADDLW  56
08AE6:  MOVWF  FE9
08AE8:  MOVLW  07
08AEA:  ADDWFC 03,W
08AEC:  MOVWF  FEA
08AEE:  MOVFF  FEC,8D9
08AF2:  MOVF   FED,F
08AF4:  MOVFF  FEF,8D8
08AF8:  MOVLB  8
08AFA:  RRCF   xD9,F
08AFC:  RRCF   xD8,F
08AFE:  RRCF   xD9,F
08B00:  RRCF   xD8,F
08B02:  RRCF   xD9,F
08B04:  MOVFF  8D8,FBC
08B08:  RRCF   xD9,F
08B0A:  RRCF   xD9,W
08B0C:  ANDLW  30
08B0E:  MOVWF  00
08B10:  MOVF   FBB,W
08B12:  ANDLW  CF
08B14:  IORWF  00,W
08B16:  MOVWF  FBB
08B18:  MOVLB  0
08B1A:  GOTO   8CA4 (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08B1E:  BCF    FD8.0
08B20:  MOVLB  7
08B22:  RLCF   x40,W
08B24:  CLRF   03
08B26:  ADDLW  4E
08B28:  MOVWF  FE9
08B2A:  MOVLW  07
08B2C:  ADDWFC 03,W
08B2E:  MOVWF  FEA
08B30:  MOVFF  FEC,8D9
08B34:  MOVF   FED,F
08B36:  MOVFF  FEF,8D8
08B3A:  MOVLB  8
08B3C:  DECFSZ xD8,W
08B3E:  BRA    8B8E
08B40:  MOVF   xD9,F
08B42:  BNZ   8B8E
08B44:  BCF    FD8.0
08B46:  MOVLB  7
08B48:  RLCF   x40,W
08B4A:  CLRF   03
08B4C:  ADDLW  86
08B4E:  MOVWF  01
08B50:  MOVLW  07
08B52:  ADDWFC 03,F
08B54:  MOVFF  01,8D8
08B58:  MOVLB  8
08B5A:  MOVFF  03,8D9
08B5E:  BCF    FD8.0
08B60:  MOVLB  7
08B62:  RLCF   x40,W
08B64:  CLRF   03
08B66:  ADDLW  86
08B68:  MOVWF  FE9
08B6A:  MOVLW  07
08B6C:  ADDWFC 03,W
08B6E:  MOVWF  FEA
08B70:  MOVF   FEF,F
08B72:  BNZ   8B78
08B74:  MOVF   FEC,F
08B76:  BZ    8B7C
08B78:  MOVLW  00
08B7A:  BRA    8B7E
08B7C:  MOVLW  01
08B7E:  MOVLB  8
08B80:  MOVFF  8D9,FEA
08B84:  MOVFF  8D8,FE9
08B88:  CLRF   FEC
08B8A:  MOVF   FED,F
08B8C:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08B8E:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08B90:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08B92:  BCF    FD8.0
08B94:  MOVLB  7
08B96:  RLCF   x40,W
08B98:  CLRF   03
08B9A:  ADDLW  42
08B9C:  MOVWF  FE9
08B9E:  MOVLW  07
08BA0:  ADDWFC 03,W
08BA2:  MOVWF  FEA
08BA4:  MOVF   FEF,F
08BA6:  BNZ   8BB0
08BA8:  MOVF   FEC,F
08BAA:  BNZ   8BB0
08BAC:  BCF    F8D.2
08BAE:  BRA    8BB2
08BB0:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08BB2:  BCF    FD8.0
08BB4:  RLCF   x40,W
08BB6:  CLRF   03
08BB8:  ADDLW  46
08BBA:  MOVWF  FE9
08BBC:  MOVLW  07
08BBE:  ADDWFC 03,W
08BC0:  MOVWF  FEA
08BC2:  MOVF   FEF,F
08BC4:  BNZ   8BCE
08BC6:  MOVF   FEC,F
08BC8:  BNZ   8BCE
08BCA:  BCF    F8D.3
08BCC:  BRA    8BD0
08BCE:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08BD0:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08BD2:  BCF    FD8.0
08BD4:  RLCF   x40,W
08BD6:  CLRF   03
08BD8:  ADDLW  86
08BDA:  MOVWF  FE9
08BDC:  MOVLW  07
08BDE:  ADDWFC 03,W
08BE0:  MOVWF  FEA
08BE2:  MOVF   FEF,F
08BE4:  BNZ   8BEE
08BE6:  MOVF   FEC,F
08BE8:  BNZ   8BEE
08BEA:  BCF    F8D.5
08BEC:  BRA    8BF0
08BEE:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08BF0:  BCF    FD8.0
08BF2:  RLCF   x40,W
08BF4:  CLRF   03
08BF6:  ADDLW  56
08BF8:  MOVWF  FE9
08BFA:  MOVLW  07
08BFC:  ADDWFC 03,W
08BFE:  MOVWF  FEA
08C00:  MOVFF  FEC,8D9
08C04:  MOVF   FED,F
08C06:  MOVFF  FEF,8D8
08C0A:  MOVLB  8
08C0C:  RRCF   xD9,F
08C0E:  RRCF   xD8,F
08C10:  RRCF   xD9,F
08C12:  RRCF   xD8,F
08C14:  RRCF   xD9,F
08C16:  MOVFF  8D8,F4F
08C1A:  RRCF   xD9,F
08C1C:  RRCF   xD9,W
08C1E:  ANDLW  30
08C20:  MOVWF  00
08C22:  MOVLB  F
08C24:  MOVF   x4E,W
08C26:  ANDLW  CF
08C28:  IORWF  00,W
08C2A:  MOVWF  x4E
08C2C:  MOVLB  0
08C2E:  GOTO   8CA4 (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
089F8:  MOVLB  8
089FA:  MOVF   xEC,F
089FC:  BZ    8A04
....................       output_bit(VENC1,ON); 
089FE:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
08A00:  BSF    F8E.7
....................    } 
08A02:  BRA    8A08
....................    else {       
....................       output_bit(VENC1,OFF); 
08A04:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
08A06:  BCF    F8E.7
....................    } 
08A08:  MOVLB  0
08A0A:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08D92:  MOVLB  8
08D94:  MOVF   xED,F
08D96:  BNZ   8DBE
08D98:  MOVF   xEE,F
08D9A:  BNZ   8DBE
....................       edge_mode=0; 
08D9C:  MOVLB  7
08D9E:  CLRF   xAA
....................       switch (motor){ 
08DA0:  MOVF   x40,W
08DA2:  XORLW  00
08DA4:  MOVLB  0
08DA6:  BZ    8DAE
08DA8:  XORLW  01
08DAA:  BZ    8DB6
08DAC:  BRA    8DBC
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08DAE:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08DB0:  BSF    FF0.3
08DB2:  BCF    FF1.5
....................             break; 
08DB4:  BRA    8DBC
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08DB6:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08DB8:  BSF    FF0.4
08DBA:  BCF    FF1.4
....................             break; 
08DBC:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08DBE:  DECFSZ xED,W
08DC0:  BRA    8DE8
08DC2:  MOVF   xEE,F
08DC4:  BNZ   8DE8
....................       edge_mode=0; 
08DC6:  MOVLB  7
08DC8:  CLRF   xAA
....................       switch (motor){ 
08DCA:  MOVF   x40,W
08DCC:  XORLW  00
08DCE:  MOVLB  0
08DD0:  BZ    8DD8
08DD2:  XORLW  01
08DD4:  BZ    8DE0
08DD6:  BRA    8DE6
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08DD8:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08DDA:  BSF    FF0.3
08DDC:  BSF    FF1.5
....................             break; 
08DDE:  BRA    8DE6
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08DE0:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08DE2:  BSF    FF0.4
08DE4:  BSF    FF1.4
....................             break; 
08DE6:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08DE8:  MOVF   xED,W
08DEA:  SUBLW  02
08DEC:  BNZ   8E3E
08DEE:  MOVF   xEE,F
08DF0:  BNZ   8E3E
08DF2:  BCF    FD8.0
08DF4:  MOVLB  7
08DF6:  RLCF   x40,W
08DF8:  CLRF   03
08DFA:  ADDLW  6A
08DFC:  MOVWF  FE9
08DFE:  MOVLW  07
08E00:  ADDWFC 03,W
08E02:  MOVWF  FEA
08E04:  MOVFF  FEC,8F0
08E08:  MOVF   FED,F
08E0A:  MOVFF  FEF,8EF
08E0E:  MOVLB  8
08E10:  MOVF   xEF,W
08E12:  SUBLW  02
08E14:  BNZ   8E3E
08E16:  MOVF   xF0,F
08E18:  BNZ   8E3E
....................       edge_mode=1; 
08E1A:  MOVLW  01
08E1C:  MOVLB  7
08E1E:  MOVWF  xAA
....................       switch (motor){ 
08E20:  MOVF   x40,W
08E22:  XORLW  00
08E24:  MOVLB  0
08E26:  BZ    8E2E
08E28:  XORLW  01
08E2A:  BZ    8E36
08E2C:  BRA    8E3C
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08E2E:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08E30:  BSF    FF0.3
08E32:  BSF    FF1.5
....................             break; 
08E34:  BRA    8E3C
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08E36:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08E38:  BSF    FF0.4
08E3A:  BSF    FF1.4
....................             break; 
08E3C:  MOVLB  8
....................       }  
....................    }     
08E3E:  MOVLB  0
08E40:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08FA8:  MOVLB  7
08FAA:  MOVF   x40,W
08FAC:  XORLW  00
08FAE:  MOVLB  0
08FB0:  BZ    8FB8
08FB2:  XORLW  01
08FB4:  BZ    8FE2
08FB6:  BRA    900A
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08FB8:  BCF    FD8.0
08FBA:  MOVLB  7
08FBC:  RLCF   x40,W
08FBE:  CLRF   03
08FC0:  ADDLW  96
08FC2:  MOVWF  FE9
08FC4:  MOVLW  07
08FC6:  ADDWFC 03,W
08FC8:  MOVWF  FEA
08FCA:  MOVFF  FEC,8F0
08FCE:  MOVF   FED,F
08FD0:  MOVFF  FEF,8EF
08FD4:  MOVLW  6E
08FD6:  MOVLB  8
08FD8:  MOVWF  xEE
08FDA:  MOVLB  0
08FDC:  CALL   4FFC
....................          break; 
08FE0:  BRA    900A
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08FE2:  BCF    FD8.0
08FE4:  MOVLB  7
08FE6:  RLCF   x40,W
08FE8:  CLRF   03
08FEA:  ADDLW  96
08FEC:  MOVWF  FE9
08FEE:  MOVLW  07
08FF0:  ADDWFC 03,W
08FF2:  MOVWF  FEA
08FF4:  MOVFF  FEC,8F0
08FF8:  MOVF   FED,F
08FFA:  MOVFF  FEF,8EF
08FFE:  MOVLW  70
09000:  MOVLB  8
09002:  MOVWF  xEE
09004:  MOVLB  0
09006:  CALL   4FFC
....................          break;          
....................    } 
0900A:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08E42:  MOVLB  8
08E44:  MOVF   xEC,F
08E46:  BNZ   8E64
....................    { 
....................       switch (motor) 
08E48:  MOVLB  7
08E4A:  MOVF   x40,W
08E4C:  XORLW  00
08E4E:  MOVLB  0
08E50:  BZ    8E58
08E52:  XORLW  01
08E54:  BZ    8E5E
08E56:  BRA    8E62
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08E58:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08E5A:  BCF    FF0.3
....................             break; 
08E5C:  BRA    8E62
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08E5E:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08E60:  BCF    FF0.4
....................             break; 
08E62:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08E64:  DECFSZ xEC,W
08E66:  BRA    8ECC
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08E68:  BCF    FD8.0
08E6A:  MOVLB  7
08E6C:  RLCF   x40,W
08E6E:  CLRF   03
08E70:  ADDLW  6A
08E72:  MOVWF  FE9
08E74:  MOVLW  07
08E76:  ADDWFC 03,W
08E78:  MOVWF  FEA
08E7A:  MOVFF  FEC,8EE
08E7E:  MOVF   FED,F
08E80:  MOVFF  FEF,8ED
08E84:  MOVLB  8
08E86:  DECFSZ xED,W
08E88:  BRA    8E98
08E8A:  MOVF   xEE,F
08E8C:  BNZ   8E98
08E8E:  CLRF   xEE
08E90:  CLRF   xED
08E92:  MOVLB  0
08E94:  RCALL  8D92
08E96:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08E98:  BCF    FD8.0
08E9A:  MOVLB  7
08E9C:  RLCF   x40,W
08E9E:  CLRF   03
08EA0:  ADDLW  6A
08EA2:  MOVWF  FE9
08EA4:  MOVLW  07
08EA6:  ADDWFC 03,W
08EA8:  MOVWF  FEA
08EAA:  MOVFF  FEC,8EE
08EAE:  MOVF   FED,F
08EB0:  MOVFF  FEF,8ED
08EB4:  MOVLB  8
08EB6:  MOVF   xED,W
08EB8:  SUBLW  02
08EBA:  BNZ   8ECC
08EBC:  MOVF   xEE,F
08EBE:  BNZ   8ECC
08EC0:  CLRF   xEE
08EC2:  MOVLW  01
08EC4:  MOVWF  xED
08EC6:  MOVLB  0
08EC8:  RCALL  8D92
08ECA:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08ECC:  MOVF   xEC,W
08ECE:  SUBLW  02
08ED0:  BNZ   8F06
08ED2:  BCF    FD8.0
08ED4:  MOVLB  7
08ED6:  RLCF   x40,W
08ED8:  CLRF   03
08EDA:  ADDLW  6A
08EDC:  MOVWF  FE9
08EDE:  MOVLW  07
08EE0:  ADDWFC 03,W
08EE2:  MOVWF  FEA
08EE4:  MOVFF  FEC,8EE
08EE8:  MOVF   FED,F
08EEA:  MOVFF  FEF,8ED
08EEE:  MOVLB  8
08EF0:  MOVF   xED,W
08EF2:  SUBLW  02
08EF4:  BNZ   8F06
08EF6:  MOVF   xEE,F
08EF8:  BNZ   8F06
....................    { 
....................       enable_enc_isr(2);   
08EFA:  CLRF   xEE
08EFC:  MOVLW  02
08EFE:  MOVWF  xED
08F00:  MOVLB  0
08F02:  RCALL  8D92
08F04:  MOVLB  8
....................    } 
08F06:  MOVLB  0
08F08:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08C32:  BCF    FD8.0
08C34:  MOVLB  7
08C36:  RLCF   x40,W
08C38:  CLRF   03
08C3A:  ADDLW  8E
08C3C:  MOVWF  FE9
08C3E:  MOVLW  07
08C40:  ADDWFC 03,W
08C42:  MOVWF  FEA
08C44:  CLRF   FEC
08C46:  MOVF   FED,F
08C48:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08C4A:  BCF    FD8.0
08C4C:  RLCF   x40,W
08C4E:  CLRF   03
08C50:  ADDLW  BB
08C52:  MOVWF  FE9
08C54:  MOVLW  07
08C56:  ADDWFC 03,W
08C58:  MOVWF  FEA
08C5A:  CLRF   FEC
08C5C:  MOVF   FED,F
08C5E:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08C60:  BCF    FD8.0
08C62:  RLCF   x40,W
08C64:  CLRF   03
08C66:  ADDLW  9A
08C68:  MOVWF  FE9
08C6A:  MOVLW  07
08C6C:  ADDWFC 03,W
08C6E:  MOVWF  FEA
08C70:  CLRF   FEC
08C72:  MOVF   FED,F
08C74:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08C76:  BSF    F8E.1
....................    enc_pwr(ON); 
08C78:  MOVLW  01
08C7A:  MOVLB  8
08C7C:  MOVWF  xEC
08C7E:  MOVLB  0
08C80:  RCALL  89F8
....................    delay_ms(100); 
08C82:  MOVLW  64
08C84:  MOVLB  9
08C86:  MOVWF  xEC
08C88:  MOVLB  0
08C8A:  CALL   2938
....................     
....................    switch (motor){ 
08C8E:  MOVLB  7
08C90:  MOVF   x40,W
08C92:  XORLW  00
08C94:  MOVLB  0
08C96:  BZ    8C9E
08C98:  XORLW  01
08C9A:  BZ    8CA2
08C9C:  BRA    8CA4
....................       case 0 : motor_setup1(); 
08C9E:  BRA    8A0C
....................          break; 
08CA0:  BRA    8CA4
....................       case 1 : motor_setup2(); 
08CA2:  BRA    8B1E
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08CA4:  BCF    FD8.0
08CA6:  MOVLB  7
08CA8:  RLCF   x40,W
08CAA:  CLRF   03
08CAC:  ADDLW  8A
08CAE:  MOVWF  FE9
08CB0:  MOVLW  07
08CB2:  ADDWFC 03,W
08CB4:  MOVWF  FEA
08CB6:  MOVFF  FEC,8D9
08CBA:  MOVF   FED,F
08CBC:  MOVFF  FEF,8D8
08CC0:  BCF    FD8.0
08CC2:  RLCF   x40,W
08CC4:  CLRF   03
08CC6:  ADDLW  86
08CC8:  MOVWF  FE9
08CCA:  MOVLW  07
08CCC:  ADDWFC 03,W
08CCE:  MOVWF  FEA
08CD0:  MOVFF  FEC,03
08CD4:  MOVF   FED,F
08CD6:  MOVF   FEF,W
08CD8:  MOVLB  8
08CDA:  SUBWF  xD8,W
08CDC:  BNZ   8CE4
08CDE:  MOVF   03,W
08CE0:  SUBWF  xD9,W
08CE2:  BZ    8D8C
....................       m_way_rst[motor]=m_way[motor]; 
08CE4:  BCF    FD8.0
08CE6:  MOVLB  7
08CE8:  RLCF   x40,W
08CEA:  CLRF   03
08CEC:  ADDLW  8A
08CEE:  MOVWF  01
08CF0:  MOVLW  07
08CF2:  ADDWFC 03,F
08CF4:  MOVLB  8
08CF6:  MOVFF  03,8D9
08CFA:  BCF    FD8.0
08CFC:  MOVLB  7
08CFE:  RLCF   x40,W
08D00:  CLRF   03
08D02:  ADDLW  86
08D04:  MOVWF  FE9
08D06:  MOVLW  07
08D08:  ADDWFC 03,W
08D0A:  MOVWF  FEA
08D0C:  MOVFF  FEC,03
08D10:  MOVF   FED,F
08D12:  MOVFF  FEF,8DA
08D16:  MOVLB  8
08D18:  MOVFF  8D9,FEA
08D1C:  MOVFF  01,FE9
08D20:  MOVFF  03,FEC
08D24:  MOVF   FED,F
08D26:  MOVFF  8DA,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08D2A:  BCF    FD8.0
08D2C:  MOVLB  7
08D2E:  RLCF   x40,W
08D30:  CLRF   03
08D32:  ADDLW  9E
08D34:  MOVWF  01
08D36:  MOVLW  07
08D38:  ADDWFC 03,F
08D3A:  MOVLB  8
08D3C:  MOVFF  03,8D9
08D40:  BCF    FD8.0
08D42:  MOVLB  7
08D44:  RLCF   x40,W
08D46:  CLRF   03
08D48:  ADDLW  66
08D4A:  MOVWF  FE9
08D4C:  MOVLW  07
08D4E:  ADDWFC 03,W
08D50:  MOVWF  FEA
08D52:  MOVFF  FEC,03
08D56:  MOVF   FED,F
08D58:  MOVFF  FEF,8DA
08D5C:  MOVLB  8
08D5E:  MOVFF  8D9,FEA
08D62:  MOVFF  01,FE9
08D66:  MOVFF  03,FEC
08D6A:  MOVF   FED,F
08D6C:  MOVFF  8DA,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08D70:  BCF    FD8.0
08D72:  MOVLB  7
08D74:  RLCF   x40,W
08D76:  CLRF   03
08D78:  ADDLW  66
08D7A:  MOVWF  FE9
08D7C:  MOVLW  07
08D7E:  ADDWFC 03,W
08D80:  MOVWF  FEA
08D82:  CLRF   FEC
08D84:  MOVF   FED,F
08D86:  MOVLW  05
08D88:  MOVWF  FEF
08D8A:  MOVLB  8
....................    } 
08D8C:  MOVLB  0
08D8E:  GOTO   8F0C (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08F0A:  BRA    8C32
....................     
....................    m_comp[motor]=FALSE; 
08F0C:  BCF    FD8.0
08F0E:  MOVLB  7
08F10:  RLCF   x40,W
08F12:  CLRF   03
08F14:  ADDLW  AF
08F16:  MOVWF  FE9
08F18:  MOVLW  07
08F1A:  ADDWFC 03,W
08F1C:  MOVWF  FEA
08F1E:  CLRF   FEC
08F20:  MOVF   FED,F
08F22:  CLRF   FEF
....................     
....................    switch (motor){ 
08F24:  MOVF   x40,W
08F26:  XORLW  00
08F28:  MOVLB  0
08F2A:  BZ    8F32
08F2C:  XORLW  01
08F2E:  BZ    8F44
08F30:  BRA    8F54
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08F32:  MOVLW  B2
08F34:  MOVLB  8
08F36:  MOVWF  xEE
08F38:  CLRF   xF0
08F3A:  CLRF   xEF
08F3C:  MOVLB  0
08F3E:  CALL   4FFC
....................          break; 
08F42:  BRA    8F54
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08F44:  MOVLW  B4
08F46:  MOVLB  8
08F48:  MOVWF  xEE
08F4A:  CLRF   xF0
08F4C:  CLRF   xEF
08F4E:  MOVLB  0
08F50:  CALL   4FFC
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08F54:  MOVLB  7
08F56:  MOVF   x40,W
08F58:  XORLW  00
08F5A:  MOVLB  0
08F5C:  BZ    8F64
08F5E:  XORLW  01
08F60:  BZ    8F68
08F62:  BRA    8F6A
....................       case 0 : output_bit(M1_ENABLE, ON); 
08F64:  BSF    F90.1
....................          break; 
08F66:  BRA    8F6A
....................       case 1 : output_bit(M2_ENABLE, ON); 
08F68:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08F6A:  MOVLW  32
08F6C:  MOVLB  9
08F6E:  MOVWF  xEC
08F70:  MOVLB  0
08F72:  CALL   2938
....................     
....................    set_timer3(STEP_INTERVAL); 
08F76:  MOVLW  F9
08F78:  MOVWF  FB3
08F7A:  MOVLW  C0
08F7C:  MOVWF  FB2
....................    enc_isr(int_mode); 
08F7E:  MOVFF  8D7,8EC
08F82:  RCALL  8E42
....................    clear_interrupt(INT_TIMER3); 
08F84:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08F86:  BCF    FD8.0
08F88:  MOVLB  7
08F8A:  RLCF   x40,W
08F8C:  CLRF   03
08F8E:  ADDLW  92
08F90:  MOVWF  FE9
08F92:  MOVLW  07
08F94:  ADDWFC 03,W
08F96:  MOVWF  FEA
08F98:  CLRF   FEC
08F9A:  MOVF   FED,F
08F9C:  MOVLW  01
08F9E:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08FA0:  BSF    FA0.1
08FA2:  MOVLB  0
08FA4:  GOTO   A21C (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
0862E:  MOVFF  8DA,8E2
08632:  MOVFF  8D9,8E1
08636:  MOVFF  8D8,8E0
0863A:  MOVFF  8D7,8DF
....................    enc_res    = e_cpr[motor]; 
0863E:  BCF    FD8.0
08640:  MOVLB  7
08642:  RLCF   x40,W
08644:  CLRF   03
08646:  ADDLW  5E
08648:  MOVWF  FE9
0864A:  MOVLW  07
0864C:  ADDWFC 03,W
0864E:  MOVWF  FEA
08650:  MOVLB  8
08652:  CLRF   xE6
08654:  CLRF   xE5
08656:  MOVFF  FEC,8E4
0865A:  MOVF   FED,F
0865C:  MOVFF  FEF,8E3
....................    ports      = e_ppr[motor]; 
08660:  BCF    FD8.0
08662:  MOVLB  7
08664:  RLCF   x40,W
08666:  CLRF   03
08668:  ADDLW  62
0866A:  MOVWF  FE9
0866C:  MOVLW  07
0866E:  ADDWFC 03,W
08670:  MOVWF  FEA
08672:  MOVLB  8
08674:  CLRF   xEE
08676:  CLRF   xED
08678:  MOVFF  FEC,8EC
0867C:  MOVF   FED,F
0867E:  MOVFF  FEF,8EB
....................     
....................    enc_res = enc_res * 1000; 
08682:  MOVFF  8E6,9F9
08686:  MOVFF  8E5,9F8
0868A:  MOVFF  8E4,9F7
0868E:  MOVFF  8E3,9F6
08692:  MOVLB  9
08694:  CLRF   xFD
08696:  CLRF   xFC
08698:  MOVLW  03
0869A:  MOVWF  xFB
0869C:  MOVLW  E8
0869E:  MOVWF  xFA
086A0:  MOVLB  0
086A2:  CALL   4818
086A6:  MOVFF  03,8E6
086AA:  MOVFF  02,8E5
086AE:  MOVFF  01,8E4
086B2:  MOVFF  00,8E3
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
086B6:  BCF    FD8.1
086B8:  CLRF   1B
086BA:  BTFSC  FF2.7
086BC:  BSF    1B.7
086BE:  BCF    FF2.7
086C0:  MOVFF  8E6,A4F
086C4:  MOVFF  8E5,A4E
086C8:  MOVFF  8E4,A4D
086CC:  MOVFF  8E3,A4C
086D0:  MOVFF  8EE,A53
086D4:  MOVFF  8ED,A52
086D8:  MOVFF  8EC,A51
086DC:  MOVFF  8EB,A50
086E0:  CALL   1076
086E4:  BTFSC  1B.7
086E6:  BSF    FF2.7
086E8:  MOVFF  03,8DE
086EC:  MOVFF  02,8DD
086F0:  MOVFF  01,8DC
086F4:  MOVFF  00,8DB
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
086F8:  MOVFF  8DA,9F9
086FC:  MOVFF  8D9,9F8
08700:  MOVFF  8D8,9F7
08704:  MOVFF  8D7,9F6
08708:  MOVFF  8DE,9FD
0870C:  MOVFF  8DD,9FC
08710:  MOVFF  8DC,9FB
08714:  MOVFF  8DB,9FA
08718:  CALL   4818
0871C:  MOVLB  8
0871E:  MOVF   xDB,W
08720:  SUBWF  00,W
08722:  MOVWF  xDF
08724:  MOVF   xDC,W
08726:  SUBWFB 01,W
08728:  MOVWF  xE0
0872A:  MOVF   xDD,W
0872C:  SUBWFB 02,W
0872E:  MOVWF  xE1
08730:  MOVF   xDE,W
08732:  SUBWFB 03,W
08734:  MOVWF  xE2
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
08736:  BCF    FD8.1
08738:  CLRF   1B
0873A:  BTFSC  FF2.7
0873C:  BSF    1B.7
0873E:  BCF    FF2.7
08740:  MOVFF  8E2,A4F
08744:  MOVFF  8E1,A4E
08748:  MOVFF  8E0,A4D
0874C:  MOVFF  8DF,A4C
08750:  MOVLB  A
08752:  CLRF   x53
08754:  CLRF   x52
08756:  MOVLW  03
08758:  MOVWF  x51
0875A:  MOVLW  E8
0875C:  MOVWF  x50
0875E:  MOVLB  0
08760:  CALL   1076
08764:  BTFSC  1B.7
08766:  BSF    FF2.7
08768:  MOVFF  03,8EA
0876C:  MOVFF  02,8E9
08770:  MOVFF  01,8E8
08774:  MOVFF  00,8E7
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
08778:  MOVFF  8EA,9F9
0877C:  MOVFF  8E9,9F8
08780:  MOVFF  8E8,9F7
08784:  MOVFF  8E7,9F6
08788:  MOVLB  9
0878A:  CLRF   xFD
0878C:  CLRF   xFC
0878E:  MOVLW  03
08790:  MOVWF  xFB
08792:  MOVLW  E8
08794:  MOVWF  xFA
08796:  MOVLB  0
08798:  CALL   4818
0879C:  MOVFF  03,8EA
087A0:  MOVFF  02,8E9
087A4:  MOVFF  01,8E8
087A8:  MOVFF  00,8E7
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
087AC:  MOVLB  8
087AE:  MOVF   xE7,W
087B0:  SUBWF  xDF,F
087B2:  MOVF   xE8,W
087B4:  SUBWFB xE0,F
087B6:  MOVF   xE9,W
087B8:  SUBWFB xE1,F
087BA:  MOVF   xEA,W
087BC:  SUBWFB xE2,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
087BE:  BCF    FD8.1
087C0:  CLRF   1B
087C2:  BTFSC  FF2.7
087C4:  BSF    1B.7
087C6:  BCF    FF2.7
087C8:  MOVFF  8EA,A4F
087CC:  MOVFF  8E9,A4E
087D0:  MOVFF  8E8,A4D
087D4:  MOVFF  8E7,A4C
087D8:  MOVLB  A
087DA:  CLRF   x53
087DC:  CLRF   x52
087DE:  MOVLW  03
087E0:  MOVWF  x51
087E2:  MOVLW  E8
087E4:  MOVWF  x50
087E6:  MOVLB  0
087E8:  CALL   1076
087EC:  BTFSC  1B.7
087EE:  BSF    FF2.7
087F0:  MOVFF  03,8EA
087F4:  MOVFF  02,8E9
087F8:  MOVFF  01,8E8
087FC:  MOVFF  00,8E7
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
08800:  MOVLB  8
08802:  MOVF   xE2,F
08804:  BNZ   881A
08806:  MOVF   xE1,F
08808:  BNZ   881A
0880A:  MOVF   xE0,W
0880C:  SUBLW  00
0880E:  BC    882A
08810:  XORLW  FF
08812:  BNZ   881A
08814:  MOVF   xDF,W
08816:  SUBLW  F3
08818:  BC    882A
0881A:  MOVLW  01
0881C:  ADDWF  xE7,F
0881E:  BTFSC  FD8.0
08820:  INCF   xE8,F
08822:  BTFSC  FD8.2
08824:  INCF   xE9,F
08826:  BTFSC  FD8.2
08828:  INCF   xEA,F
....................    return(enc_pos); 
0882A:  MOVFF  8E7,00
0882E:  MOVFF  8E8,01
08832:  MOVFF  8E9,02
08836:  MOVFF  8EA,03
0883A:  MOVLB  0
0883C:  GOTO   A1A4 (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
08840:  BCF    FD8.0
08842:  MOVLB  7
08844:  RLCF   x40,W
08846:  CLRF   03
08848:  ADDLW  BF
0884A:  MOVWF  FE9
0884C:  MOVLW  07
0884E:  ADDWFC 03,W
08850:  MOVWF  FEA
08852:  MOVFF  FEC,03
08856:  MOVF   FED,F
08858:  MOVFF  FEF,01
0885C:  MOVF   03,W
0885E:  MOVLB  8
08860:  SUBWF  xDA,W
08862:  BNC   892A
08864:  BNZ   886C
08866:  MOVF   xD9,W
08868:  SUBWF  01,W
0886A:  BC    892A
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
0886C:  BCF    FD8.0
0886E:  MOVLB  7
08870:  RLCF   x40,W
08872:  CLRF   03
08874:  ADDLW  BF
08876:  MOVWF  FE9
08878:  MOVLW  07
0887A:  ADDWFC 03,W
0887C:  MOVWF  FEA
0887E:  MOVFF  FEC,03
08882:  MOVF   FED,F
08884:  MOVF   FEF,W
08886:  MOVLB  8
08888:  SUBWF  xD9,W
0888A:  MOVWF  xDB
0888C:  MOVF   03,W
0888E:  SUBWFB xDA,W
08890:  MOVWF  xDC
....................       if (e_pos_r > (e_cpr[motor]/2)) 
08892:  BCF    FD8.0
08894:  MOVLB  7
08896:  RLCF   x40,W
08898:  CLRF   03
0889A:  ADDLW  5E
0889C:  MOVWF  FE9
0889E:  MOVLW  07
088A0:  ADDWFC 03,W
088A2:  MOVWF  FEA
088A4:  MOVFF  FEC,8DE
088A8:  MOVF   FED,F
088AA:  MOVFF  FEF,8DD
088AE:  BCF    FD8.0
088B0:  MOVLB  8
088B2:  RRCF   xDE,W
088B4:  MOVWF  03
088B6:  RRCF   xDD,W
088B8:  MOVWF  02
088BA:  MOVWF  01
088BC:  MOVF   03,W
088BE:  SUBWF  xDC,W
088C0:  BNC   890E
088C2:  BNZ   88CA
088C4:  MOVF   xDB,W
088C6:  SUBWF  01,W
088C8:  BC    890E
....................       { 
....................          m_way[motor] = NEG; 
088CA:  BCF    FD8.0
088CC:  MOVLB  7
088CE:  RLCF   x40,W
088D0:  CLRF   03
088D2:  ADDLW  86
088D4:  MOVWF  FE9
088D6:  MOVLW  07
088D8:  ADDWFC 03,W
088DA:  MOVWF  FEA
088DC:  CLRF   FEC
088DE:  MOVF   FED,F
088E0:  MOVLW  01
088E2:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088E4:  BCF    FD8.0
088E6:  RLCF   x40,W
088E8:  CLRF   03
088EA:  ADDLW  5E
088EC:  MOVWF  FE9
088EE:  MOVLW  07
088F0:  ADDWFC 03,W
088F2:  MOVWF  FEA
088F4:  MOVFF  FEC,8DE
088F8:  MOVF   FED,F
088FA:  MOVFF  FEF,8DD
088FE:  MOVLB  8
08900:  MOVF   xDB,W
08902:  SUBWF  xDD,W
08904:  MOVWF  xDB
08906:  MOVF   xDC,W
08908:  SUBWFB xDE,W
0890A:  MOVWF  xDC
....................       } 
0890C:  BRA    8928
....................       else 
....................       { 
....................          m_way[motor] = POS; 
0890E:  BCF    FD8.0
08910:  MOVLB  7
08912:  RLCF   x40,W
08914:  CLRF   03
08916:  ADDLW  86
08918:  MOVWF  FE9
0891A:  MOVLW  07
0891C:  ADDWFC 03,W
0891E:  MOVWF  FEA
08920:  CLRF   FEC
08922:  MOVF   FED,F
08924:  CLRF   FEF
08926:  MOVLB  8
....................       } 
....................    } 
08928:  BRA    89EA
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
0892A:  BCF    FD8.0
0892C:  MOVLB  7
0892E:  RLCF   x40,W
08930:  CLRF   03
08932:  ADDLW  BF
08934:  MOVWF  FE9
08936:  MOVLW  07
08938:  ADDWFC 03,W
0893A:  MOVWF  FEA
0893C:  MOVFF  FEC,8DE
08940:  MOVF   FED,F
08942:  MOVFF  FEF,8DD
08946:  MOVLB  8
08948:  MOVF   xD9,W
0894A:  SUBWF  xDD,W
0894C:  MOVWF  xDB
0894E:  MOVF   xDA,W
08950:  SUBWFB xDE,W
08952:  MOVWF  xDC
....................       if (e_pos_r > (e_cpr[motor]/2)) 
08954:  BCF    FD8.0
08956:  MOVLB  7
08958:  RLCF   x40,W
0895A:  CLRF   03
0895C:  ADDLW  5E
0895E:  MOVWF  FE9
08960:  MOVLW  07
08962:  ADDWFC 03,W
08964:  MOVWF  FEA
08966:  MOVFF  FEC,8DE
0896A:  MOVF   FED,F
0896C:  MOVFF  FEF,8DD
08970:  BCF    FD8.0
08972:  MOVLB  8
08974:  RRCF   xDE,W
08976:  MOVWF  03
08978:  RRCF   xDD,W
0897A:  MOVWF  02
0897C:  MOVWF  01
0897E:  MOVF   03,W
08980:  SUBWF  xDC,W
08982:  BNC   89CE
08984:  BNZ   898C
08986:  MOVF   xDB,W
08988:  SUBWF  01,W
0898A:  BC    89CE
....................       { 
....................          m_way[motor] = POS; 
0898C:  BCF    FD8.0
0898E:  MOVLB  7
08990:  RLCF   x40,W
08992:  CLRF   03
08994:  ADDLW  86
08996:  MOVWF  FE9
08998:  MOVLW  07
0899A:  ADDWFC 03,W
0899C:  MOVWF  FEA
0899E:  CLRF   FEC
089A0:  MOVF   FED,F
089A2:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
089A4:  BCF    FD8.0
089A6:  RLCF   x40,W
089A8:  CLRF   03
089AA:  ADDLW  5E
089AC:  MOVWF  FE9
089AE:  MOVLW  07
089B0:  ADDWFC 03,W
089B2:  MOVWF  FEA
089B4:  MOVFF  FEC,8DE
089B8:  MOVF   FED,F
089BA:  MOVFF  FEF,8DD
089BE:  MOVLB  8
089C0:  MOVF   xDB,W
089C2:  SUBWF  xDD,W
089C4:  MOVWF  xDB
089C6:  MOVF   xDC,W
089C8:  SUBWFB xDE,W
089CA:  MOVWF  xDC
....................       } 
089CC:  BRA    89EA
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
089CE:  BCF    FD8.0
089D0:  MOVLB  7
089D2:  RLCF   x40,W
089D4:  CLRF   03
089D6:  ADDLW  86
089D8:  MOVWF  FE9
089DA:  MOVLW  07
089DC:  ADDWFC 03,W
089DE:  MOVWF  FEA
089E0:  CLRF   FEC
089E2:  MOVF   FED,F
089E4:  MOVLW  01
089E6:  MOVWF  FEF
089E8:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
089EA:  MOVFF  8DB,01
089EE:  MOVFF  8DC,02
089F2:  MOVLB  0
089F4:  GOTO   A1D0 (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
090F8:  BCF    FD8.0
090FA:  MOVLB  7
090FC:  RLCF   x40,W
090FE:  CLRF   03
09100:  ADDLW  92
09102:  MOVWF  FE9
09104:  MOVLW  07
09106:  ADDWFC 03,W
09108:  MOVWF  FEA
0910A:  CLRF   FEC
0910C:  MOVF   FED,F
0910E:  CLRF   FEF
....................           
....................    switch (motor){ 
09110:  MOVF   x40,W
09112:  XORLW  00
09114:  MOVLB  0
09116:  BZ    911E
09118:  XORLW  01
0911A:  BZ    9188
0911C:  BRA    91F6
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
0911E:  BCF    FD8.0
09120:  MOVLB  7
09122:  RLCF   x40,W
09124:  CLRF   03
09126:  ADDLW  52
09128:  MOVWF  FE9
0912A:  MOVLW  07
0912C:  ADDWFC 03,W
0912E:  MOVWF  FEA
09130:  MOVFF  FEC,8ED
09134:  MOVF   FED,F
09136:  MOVFF  FEF,8EC
0913A:  MOVLB  8
0913C:  MOVF   xEC,F
0913E:  BNZ   9144
09140:  MOVF   xED,F
09142:  BZ    9182
09144:  BCF    FD8.0
09146:  MOVLB  7
09148:  RLCF   x40,W
0914A:  CLRF   03
0914C:  ADDLW  52
0914E:  MOVWF  FE9
09150:  MOVLW  07
09152:  ADDWFC 03,W
09154:  MOVWF  FEA
09156:  MOVFF  FEC,8ED
0915A:  MOVF   FED,F
0915C:  MOVFF  FEF,8EC
09160:  MOVLB  8
09162:  RRCF   xED,F
09164:  RRCF   xEC,F
09166:  RRCF   xED,F
09168:  RRCF   xEC,F
0916A:  RRCF   xED,F
0916C:  MOVFF  8EC,FBC
09170:  RRCF   xED,F
09172:  RRCF   xED,W
09174:  ANDLW  30
09176:  MOVWF  00
09178:  MOVF   FBB,W
0917A:  ANDLW  CF
0917C:  IORWF  00,W
0917E:  MOVWF  FBB
09180:  BRA    9184
....................                else output_bit(M1_ENABLE, OFF); 
09182:  BCF    F90.1
....................          break;   
09184:  MOVLB  0
09186:  BRA    91F6
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
09188:  BCF    FD8.0
0918A:  MOVLB  7
0918C:  RLCF   x40,W
0918E:  CLRF   03
09190:  ADDLW  52
09192:  MOVWF  FE9
09194:  MOVLW  07
09196:  ADDWFC 03,W
09198:  MOVWF  FEA
0919A:  MOVFF  FEC,8ED
0919E:  MOVF   FED,F
091A0:  MOVFF  FEF,8EC
091A4:  MOVLB  8
091A6:  MOVF   xEC,F
091A8:  BNZ   91AE
091AA:  MOVF   xED,F
091AC:  BZ    91F0
091AE:  BCF    FD8.0
091B0:  MOVLB  7
091B2:  RLCF   x40,W
091B4:  CLRF   03
091B6:  ADDLW  52
091B8:  MOVWF  FE9
091BA:  MOVLW  07
091BC:  ADDWFC 03,W
091BE:  MOVWF  FEA
091C0:  MOVFF  FEC,8ED
091C4:  MOVF   FED,F
091C6:  MOVFF  FEF,8EC
091CA:  MOVLB  8
091CC:  RRCF   xED,F
091CE:  RRCF   xEC,F
091D0:  RRCF   xED,F
091D2:  RRCF   xEC,F
091D4:  RRCF   xED,F
091D6:  MOVFF  8EC,F4F
091DA:  RRCF   xED,F
091DC:  RRCF   xED,W
091DE:  ANDLW  30
091E0:  MOVWF  00
091E2:  MOVLB  F
091E4:  MOVF   x4E,W
091E6:  ANDLW  CF
091E8:  IORWF  00,W
091EA:  MOVWF  x4E
091EC:  BRA    91F4
091EE:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
091F0:  BCF    F8D.1
091F2:  MOVLB  F
....................          break; 
091F4:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
091F6:  BCF    FA0.1
....................    enc_isr(OFF); 
091F8:  MOVLB  8
091FA:  CLRF   xEC
091FC:  MOVLB  0
091FE:  RCALL  8E42
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
09200:  MOVLB  7
09202:  MOVF   x52,F
09204:  BNZ   9214
09206:  MOVF   x53,F
09208:  BNZ   9214
0920A:  MOVF   x54,F
0920C:  BNZ   9214
0920E:  MOVF   x55,F
09210:  BNZ   9214
....................    { 
....................       output_bit(VMOT,OFF); 
09212:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
09214:  MOVLB  8
09216:  CLRF   xEC
09218:  MOVLB  0
0921A:  CALL   89F8
....................  
....................    if(success==TRUE) 
0921E:  MOVLB  8
09220:  DECFSZ xEB,W
09222:  BRA    93BE
....................    { 
....................       m_error[motor]=FALSE; 
09224:  BCF    FD8.0
09226:  MOVLB  7
09228:  RLCF   x40,W
0922A:  CLRF   03
0922C:  ADDLW  96
0922E:  MOVWF  FE9
09230:  MOVLW  07
09232:  ADDWFC 03,W
09234:  MOVWF  FEA
09236:  CLRF   FEC
09238:  MOVF   FED,F
0923A:  CLRF   FEF
....................       wrt_m_error(); 
0923C:  MOVLB  0
0923E:  RCALL  8FA8
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
09240:  BCF    FD8.0
09242:  MOVLB  7
09244:  RLCF   x40,W
09246:  CLRF   03
09248:  ADDLW  66
0924A:  MOVWF  FE9
0924C:  MOVLW  07
0924E:  ADDWFC 03,W
09250:  MOVWF  FEA
09252:  MOVFF  FEC,8ED
09256:  MOVF   FED,F
09258:  MOVFF  FEF,8EC
0925C:  MOVLB  8
0925E:  MOVF   xEC,W
09260:  SUBLW  03
09262:  BNZ   929A
09264:  MOVF   xED,F
09266:  BNZ   929A
....................       { 
....................          e_pos[motor] = 0; 
09268:  BCF    FD8.0
0926A:  MOVLB  7
0926C:  RLCF   x40,W
0926E:  CLRF   03
09270:  ADDLW  BF
09272:  MOVWF  FE9
09274:  MOVLW  07
09276:  ADDWFC 03,W
09278:  MOVWF  FEA
0927A:  CLRF   FEC
0927C:  MOVF   FED,F
0927E:  CLRF   FEF
....................          e_port[motor] = 1; 
09280:  BCF    FD8.0
09282:  RLCF   x40,W
09284:  CLRF   03
09286:  ADDLW  C3
09288:  MOVWF  FE9
0928A:  MOVLW  07
0928C:  ADDWFC 03,W
0928E:  MOVWF  FEA
09290:  CLRF   FEC
09292:  MOVF   FED,F
09294:  MOVLW  01
09296:  MOVWF  FEF
09298:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
0929A:  BCF    FD8.0
0929C:  MOVLB  7
0929E:  RLCF   x40,W
092A0:  CLRF   03
092A2:  ADDLW  66
092A4:  MOVWF  FE9
092A6:  MOVLW  07
092A8:  ADDWFC 03,W
092AA:  MOVWF  FEA
092AC:  MOVFF  FEC,8ED
092B0:  MOVF   FED,F
092B2:  MOVFF  FEF,8EC
092B6:  MOVLB  8
092B8:  MOVF   xEC,W
092BA:  SUBLW  02
092BC:  BNZ   9308
092BE:  MOVF   xED,F
092C0:  BNZ   9308
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
092C2:  BCF    FD8.0
092C4:  MOVLB  7
092C6:  RLCF   x40,W
092C8:  CLRF   03
092CA:  ADDLW  C3
092CC:  MOVWF  01
092CE:  MOVLW  07
092D0:  ADDWFC 03,F
092D2:  MOVLB  8
092D4:  MOVFF  03,8ED
092D8:  BCF    FD8.0
092DA:  MOVLB  7
092DC:  RLCF   x40,W
092DE:  CLRF   03
092E0:  ADDLW  C7
092E2:  MOVWF  FE9
092E4:  MOVLW  07
092E6:  ADDWFC 03,W
092E8:  MOVWF  FEA
092EA:  MOVFF  FEC,03
092EE:  MOVF   FED,F
092F0:  MOVFF  FEF,8EE
092F4:  MOVLB  8
092F6:  MOVFF  8ED,FEA
092FA:  MOVFF  01,FE9
092FE:  MOVFF  03,FEC
09302:  MOVF   FED,F
09304:  MOVFF  8EE,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
09308:  BCF    FD8.0
0930A:  MOVLB  7
0930C:  RLCF   x40,W
0930E:  CLRF   03
09310:  ADDLW  66
09312:  MOVWF  FE9
09314:  MOVLW  07
09316:  ADDWFC 03,W
09318:  MOVWF  FEA
0931A:  MOVFF  FEC,8ED
0931E:  MOVF   FED,F
09320:  MOVFF  FEF,8EC
09324:  MOVLB  8
09326:  MOVF   xEC,W
09328:  SUBLW  02
0932A:  BNZ   9330
0932C:  MOVF   xED,F
0932E:  BZ    9358
09330:  BCF    FD8.0
09332:  MOVLB  7
09334:  RLCF   x40,W
09336:  CLRF   03
09338:  ADDLW  66
0933A:  MOVWF  FE9
0933C:  MOVLW  07
0933E:  ADDWFC 03,W
09340:  MOVWF  FEA
09342:  MOVFF  FEC,8ED
09346:  MOVF   FED,F
09348:  MOVFF  FEF,8EC
0934C:  MOVLB  8
0934E:  MOVF   xEC,W
09350:  SUBLW  03
09352:  BNZ   93BC
09354:  MOVF   xED,F
09356:  BNZ   93BC
....................       { 
....................          switch(motor) 
09358:  MOVLB  7
0935A:  MOVF   x40,W
0935C:  XORLW  00
0935E:  MOVLB  0
09360:  BZ    9368
09362:  XORLW  01
09364:  BZ    9392
09366:  BRA    93BA
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09368:  MOVLW  7E
0936A:  MOVLB  8
0936C:  MOVWF  xEE
0936E:  MOVFF  7C0,8F0
09372:  MOVFF  7BF,8EF
09376:  MOVLB  0
09378:  CALL   4FFC
....................                      write16(ADDR_E1_PORT,e_port[0]); 
0937C:  MOVLW  AA
0937E:  MOVLB  8
09380:  MOVWF  xEE
09382:  MOVFF  7C4,8F0
09386:  MOVFF  7C3,8EF
0938A:  MOVLB  0
0938C:  CALL   4FFC
....................                break; 
09390:  BRA    93BA
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
09392:  MOVLW  80
09394:  MOVLB  8
09396:  MOVWF  xEE
09398:  MOVFF  7C2,8F0
0939C:  MOVFF  7C1,8EF
093A0:  MOVLB  0
093A2:  CALL   4FFC
....................                      write16(ADDR_E2_PORT,e_port[1]); 
093A6:  MOVLW  AC
093A8:  MOVLB  8
093AA:  MOVWF  xEE
093AC:  MOVFF  7C6,8F0
093B0:  MOVFF  7C5,8EF
093B4:  MOVLB  0
093B6:  CALL   4FFC
....................                break;             
093BA:  MOVLB  8
....................          } 
....................       } 
....................    } 
093BC:  BRA    9466
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
093BE:  BCF    FD8.0
093C0:  MOVLB  7
093C2:  RLCF   x40,W
093C4:  CLRF   03
093C6:  ADDLW  96
093C8:  MOVWF  FE9
093CA:  MOVLW  07
093CC:  ADDWFC 03,W
093CE:  MOVWF  FEA
093D0:  CLRF   FEC
093D2:  MOVF   FED,F
093D4:  MOVLW  01
093D6:  MOVWF  FEF
....................       e_pos[motor] = 0; 
093D8:  BCF    FD8.0
093DA:  RLCF   x40,W
093DC:  CLRF   03
093DE:  ADDLW  BF
093E0:  MOVWF  FE9
093E2:  MOVLW  07
093E4:  ADDWFC 03,W
093E6:  MOVWF  FEA
093E8:  CLRF   FEC
093EA:  MOVF   FED,F
093EC:  CLRF   FEF
....................       e_port[motor] = 0; 
093EE:  BCF    FD8.0
093F0:  RLCF   x40,W
093F2:  CLRF   03
093F4:  ADDLW  C3
093F6:  MOVWF  FE9
093F8:  MOVLW  07
093FA:  ADDWFC 03,W
093FC:  MOVWF  FEA
093FE:  CLRF   FEC
09400:  MOVF   FED,F
09402:  CLRF   FEF
....................       switch(motor) 
09404:  MOVF   x40,W
09406:  XORLW  00
09408:  MOVLB  0
0940A:  BZ    9412
0940C:  XORLW  01
0940E:  BZ    943C
09410:  BRA    9464
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09412:  MOVLW  7E
09414:  MOVLB  8
09416:  MOVWF  xEE
09418:  MOVFF  7C0,8F0
0941C:  MOVFF  7BF,8EF
09420:  MOVLB  0
09422:  CALL   4FFC
....................                   write16(ADDR_E1_PORT,e_port[0]); 
09426:  MOVLW  AA
09428:  MOVLB  8
0942A:  MOVWF  xEE
0942C:  MOVFF  7C4,8F0
09430:  MOVFF  7C3,8EF
09434:  MOVLB  0
09436:  CALL   4FFC
....................             break; 
0943A:  BRA    9464
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
0943C:  MOVLW  80
0943E:  MOVLB  8
09440:  MOVWF  xEE
09442:  MOVFF  7C2,8F0
09446:  MOVFF  7C1,8EF
0944A:  MOVLB  0
0944C:  CALL   4FFC
....................                   write16(ADDR_E2_PORT,e_port[1]); 
09450:  MOVLW  AC
09452:  MOVLB  8
09454:  MOVWF  xEE
09456:  MOVFF  7C6,8F0
0945A:  MOVFF  7C5,8EF
0945E:  MOVLB  0
09460:  CALL   4FFC
....................             break;             
09464:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
09466:  BCF    FD8.0
09468:  MOVLB  7
0946A:  RLCF   x40,W
0946C:  CLRF   03
0946E:  ADDLW  AF
09470:  MOVWF  FE9
09472:  MOVLW  07
09474:  ADDWFC 03,W
09476:  MOVWF  FEA
09478:  CLRF   FEC
0947A:  MOVF   FED,F
0947C:  MOVLW  01
0947E:  MOVWF  FEF
....................     
....................    switch (motor) 
09480:  MOVF   x40,W
09482:  XORLW  00
09484:  MOVLB  0
09486:  BZ    948E
09488:  XORLW  01
0948A:  BZ    94B6
0948C:  BRA    94DC
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
0948E:  MOVLW  B2
09490:  MOVLB  8
09492:  MOVWF  xEE
09494:  CLRF   xF0
09496:  MOVLW  01
09498:  MOVWF  xEF
0949A:  MOVLB  0
0949C:  CALL   4FFC
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
094A0:  MOVLW  B6
094A2:  MOVLB  8
094A4:  MOVWF  xEE
094A6:  MOVFF  7B4,8F0
094AA:  MOVFF  7B3,8EF
094AE:  MOVLB  0
094B0:  CALL   4FFC
....................          break; 
094B4:  BRA    94DC
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
094B6:  MOVLW  B4
094B8:  MOVLB  8
094BA:  MOVWF  xEE
094BC:  CLRF   xF0
094BE:  MOVLW  01
094C0:  MOVWF  xEF
094C2:  MOVLB  0
094C4:  CALL   4FFC
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
094C8:  MOVLW  B8
094CA:  MOVLB  8
094CC:  MOVWF  xEE
094CE:  MOVFF  7B6,8F0
094D2:  MOVFF  7B5,8EF
094D6:  MOVLB  0
094D8:  CALL   4FFC
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
094DC:  MOVF   1F,W
094DE:  SUBLW  04
094E0:  BNZ   9586
094E2:  MOVF   20,F
094E4:  BNZ   9586
....................    { 
....................       if(motor==1) 
094E6:  MOVLB  7
094E8:  DECFSZ x40,W
094EA:  BRA    9588
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
094EC:  BCF    FD8.0
094EE:  RLCF   x40,W
094F0:  CLRF   03
094F2:  ADDLW  AF
094F4:  MOVWF  FE9
094F6:  MOVLW  07
094F8:  ADDWFC 03,W
094FA:  MOVWF  FEA
094FC:  MOVFF  FEC,8ED
09500:  MOVF   FED,F
09502:  MOVFF  FEF,8EC
09506:  BCF    FD8.0
09508:  RLCF   x40,W
0950A:  CLRF   03
0950C:  ADDLW  B3
0950E:  MOVWF  FE9
09510:  MOVLW  07
09512:  ADDWFC 03,W
09514:  MOVWF  FEA
09516:  MOVFF  FEC,8EF
0951A:  MOVF   FED,F
0951C:  MOVFF  FEF,8EE
09520:  MOVLW  7E
09522:  MOVWF  FF6
09524:  MOVLW  1A
09526:  MOVWF  FF7
09528:  MOVLW  00
0952A:  MOVWF  FF8
0952C:  CLRF   1B
0952E:  BTFSC  FF2.7
09530:  BSF    1B.7
09532:  BCF    FF2.7
09534:  MOVLW  05
09536:  MOVLB  A
09538:  MOVWF  x40
0953A:  MOVLB  0
0953C:  CALL   1044
09540:  BTFSC  1B.7
09542:  BSF    FF2.7
09544:  MOVLW  10
09546:  MOVWF  FE9
09548:  CLRF   1B
0954A:  BTFSC  FF2.7
0954C:  BSF    1B.7
0954E:  BCF    FF2.7
09550:  MOVFF  8ED,A41
09554:  MOVFF  8EC,A40
09558:  CALL   11C6
0955C:  BTFSC  1B.7
0955E:  BSF    FF2.7
09560:  MOVLW  2C
09562:  BTFSS  F9E.4
09564:  BRA    9562
09566:  MOVWF  FAD
09568:  MOVLW  10
0956A:  MOVWF  FE9
0956C:  MOVFF  8EF,8F1
09570:  MOVFF  8EE,8F0
09574:  RCALL  900C
09576:  MOVLW  0D
09578:  BTFSS  F9E.4
0957A:  BRA    9578
0957C:  MOVWF  FAD
0957E:  MOVLW  0A
09580:  BTFSS  F9E.4
09582:  BRA    9580
09584:  MOVWF  FAD
09586:  MOVLB  7
....................       } 
....................    } 
09588:  MOVLB  0
0958A:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
096B8:  BCF    FD8.0
096BA:  MOVLB  7
096BC:  RLCF   x40,W
096BE:  CLRF   03
096C0:  ADDLW  6A
096C2:  MOVWF  FE9
096C4:  MOVLW  07
096C6:  ADDWFC 03,W
096C8:  MOVWF  FEA
096CA:  MOVFF  FEC,8EC
096CE:  MOVF   FED,F
096D0:  MOVFF  FEF,8EB
096D4:  MOVLB  8
096D6:  DECFSZ xEB,W
096D8:  BRA    96E8
096DA:  MOVF   xEC,F
096DC:  BNZ   96E8
096DE:  MOVLW  01
096E0:  MOVWF  xEB
096E2:  MOVLB  0
096E4:  RCALL  90F8
096E6:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
096E8:  BCF    FD8.0
096EA:  MOVLB  7
096EC:  RLCF   x40,W
096EE:  CLRF   03
096F0:  ADDLW  6A
096F2:  MOVWF  FE9
096F4:  MOVLW  07
096F6:  ADDWFC 03,W
096F8:  MOVWF  FEA
096FA:  MOVFF  FEC,8EC
096FE:  MOVF   FED,F
09700:  MOVFF  FEF,8EB
09704:  MOVLB  8
09706:  MOVF   xEB,W
09708:  SUBLW  02
0970A:  BTFSS  FD8.2
0970C:  BRA    9D16
0970E:  MOVF   xEC,F
09710:  BTFSS  FD8.2
09712:  BRA    9D16
....................       if (e_mode[motor]==2){ 
09714:  BCF    FD8.0
09716:  MOVLB  7
09718:  RLCF   x40,W
0971A:  CLRF   03
0971C:  ADDLW  66
0971E:  MOVWF  FE9
09720:  MOVLW  07
09722:  ADDWFC 03,W
09724:  MOVWF  FEA
09726:  MOVFF  FEC,8EC
0972A:  MOVF   FED,F
0972C:  MOVFF  FEF,8EB
09730:  MOVLB  8
09732:  MOVF   xEB,W
09734:  SUBLW  02
09736:  BTFSS  FD8.2
09738:  BRA    9C92
0973A:  MOVF   xEC,F
0973C:  BTFSS  FD8.2
0973E:  BRA    9C92
....................          if(nv_product==ECO || nv_product==WMS2){ 
09740:  MOVF   2F,F
09742:  BNZ   9748
09744:  MOVF   30,F
09746:  BZ    9756
09748:  MOVF   2F,W
0974A:  SUBLW  03
0974C:  BTFSS  FD8.2
0974E:  BRA    989A
09750:  MOVF   30,F
09752:  BTFSS  FD8.2
09754:  BRA    989A
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
09756:  BCF    FD8.0
09758:  MOVLB  7
0975A:  RLCF   x40,W
0975C:  CLRF   03
0975E:  ADDLW  AB
09760:  MOVWF  FE9
09762:  MOVLW  07
09764:  ADDWFC 03,W
09766:  MOVWF  FEA
09768:  MOVFF  FEC,9F7
0976C:  MOVF   FED,F
0976E:  MOVFF  FEF,9F6
09772:  MOVFF  FEA,8EE
09776:  MOVFF  FE9,8ED
0977A:  MOVLB  9
0977C:  CLRF   xF9
0977E:  CLRF   xF8
09780:  MOVFF  8DC,9FD
09784:  MOVFF  8DB,9FC
09788:  MOVFF  8DA,9FB
0978C:  MOVFF  8D9,9FA
09790:  MOVLB  0
09792:  CALL   4818
09796:  MOVFF  8EE,FEA
0979A:  MOVFF  8ED,FE9
0979E:  MOVFF  03,8EE
097A2:  MOVFF  02,8ED
097A6:  MOVFF  01,8EC
097AA:  MOVFF  00,8EB
097AE:  BCF    FD8.0
097B0:  MOVLB  7
097B2:  RLCF   x40,W
097B4:  CLRF   03
097B6:  ADDLW  AB
097B8:  MOVWF  FE9
097BA:  MOVLW  07
097BC:  ADDWFC 03,W
097BE:  MOVWF  FEA
097C0:  MOVFF  FEC,8F0
097C4:  MOVF   FED,F
097C6:  MOVFF  FEF,8EF
097CA:  BCF    FD8.0
097CC:  MOVLB  8
097CE:  RRCF   xF0,W
097D0:  MOVWF  03
097D2:  RRCF   xEF,W
097D4:  MOVWF  02
097D6:  ADDWF  00,W
097D8:  MOVWF  00
097DA:  MOVF   03,W
097DC:  ADDWFC 01,W
097DE:  MOVWF  01
097E0:  MOVLW  00
097E2:  ADDWFC xED,W
097E4:  MOVWF  02
097E6:  MOVLW  00
097E8:  ADDWFC xEE,W
097EA:  MOVWF  xE6
097EC:  MOVFF  02,8E5
097F0:  MOVFF  01,8E4
097F4:  MOVFF  00,8E3
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
097F8:  BCF    FD8.0
097FA:  MOVLB  7
097FC:  RLCF   x40,W
097FE:  CLRF   03
09800:  ADDLW  AB
09802:  MOVWF  FE9
09804:  MOVLW  07
09806:  ADDWFC 03,W
09808:  MOVWF  FEA
0980A:  MOVFF  FEC,9F7
0980E:  MOVF   FED,F
09810:  MOVFF  FEF,9F6
09814:  MOVFF  FEA,8EE
09818:  MOVFF  FE9,8ED
0981C:  MOVLB  9
0981E:  CLRF   xF9
09820:  CLRF   xF8
09822:  MOVFF  8DC,9FD
09826:  MOVFF  8DB,9FC
0982A:  MOVFF  8DA,9FB
0982E:  MOVFF  8D9,9FA
09832:  MOVLB  0
09834:  CALL   4818
09838:  MOVFF  8EE,FEA
0983C:  MOVFF  8ED,FE9
09840:  MOVFF  03,8EE
09844:  MOVFF  02,8ED
09848:  MOVFF  01,8EC
0984C:  MOVFF  00,8EB
09850:  BCF    FD8.0
09852:  MOVLB  7
09854:  RLCF   x40,W
09856:  CLRF   03
09858:  ADDLW  AB
0985A:  MOVWF  FE9
0985C:  MOVLW  07
0985E:  ADDWFC 03,W
09860:  MOVWF  FEA
09862:  MOVFF  FEC,8F0
09866:  MOVF   FED,F
09868:  MOVFF  FEF,8EF
0986C:  BCF    FD8.0
0986E:  MOVLB  8
09870:  RRCF   xF0,W
09872:  MOVWF  03
09874:  RRCF   xEF,W
09876:  MOVWF  02
09878:  SUBWF  00,W
0987A:  MOVWF  00
0987C:  MOVF   03,W
0987E:  SUBWFB 01,W
09880:  MOVWF  01
09882:  MOVLW  00
09884:  SUBWFB xED,W
09886:  MOVWF  02
09888:  MOVLW  00
0988A:  SUBWFB xEE,W
0988C:  MOVWF  xEA
0988E:  MOVFF  02,8E9
09892:  MOVFF  01,8E8
09896:  MOVFF  00,8E7
....................          } 
....................          if (nv_product==WMS4){ 
0989A:  DECFSZ 2F,W
0989C:  BRA    9AB4
0989E:  MOVF   30,F
098A0:  BTFSS  FD8.2
098A2:  BRA    9AB4
....................             if (end_even_port==FALSE){ 
098A4:  MOVLB  2
098A6:  MOVF   xDB,F
098A8:  BNZ   999E
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
098AA:  BCF    FD8.0
098AC:  MOVLB  7
098AE:  RLCF   x40,W
098B0:  CLRF   03
098B2:  ADDLW  AB
098B4:  MOVWF  FE9
098B6:  MOVLW  07
098B8:  ADDWFC 03,W
098BA:  MOVWF  FEA
098BC:  MOVFF  FEC,A11
098C0:  MOVF   FED,F
098C2:  MOVFF  FEF,A10
098C6:  MOVFF  8DE,A13
098CA:  MOVFF  8DD,A12
098CE:  MOVLB  0
098D0:  CALL   5CC0
098D4:  MOVFF  02,8EC
098D8:  MOVFF  01,8EB
098DC:  BCF    FD8.0
098DE:  MOVLB  7
098E0:  RLCF   x40,W
098E2:  CLRF   03
098E4:  ADDLW  AB
098E6:  MOVWF  FE9
098E8:  MOVLW  07
098EA:  ADDWFC 03,W
098EC:  MOVWF  FEA
098EE:  MOVFF  FEC,8EE
098F2:  MOVF   FED,F
098F4:  MOVFF  FEF,8ED
098F8:  BCF    FD8.0
098FA:  MOVLB  8
098FC:  RRCF   xEE,W
098FE:  MOVWF  03
09900:  RRCF   xED,W
09902:  MOVWF  02
09904:  ADDWF  01,W
09906:  MOVWF  01
09908:  MOVF   xEC,W
0990A:  ADDWFC 03,F
0990C:  MOVFF  01,8E3
09910:  MOVFF  03,8E4
09914:  CLRF   02
09916:  CLRF   03
09918:  MOVFF  03,8E6
0991C:  MOVFF  02,8E5
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
09920:  BCF    FD8.0
09922:  MOVLB  7
09924:  RLCF   x40,W
09926:  CLRF   03
09928:  ADDLW  AB
0992A:  MOVWF  FE9
0992C:  MOVLW  07
0992E:  ADDWFC 03,W
09930:  MOVWF  FEA
09932:  MOVFF  FEC,A11
09936:  MOVF   FED,F
09938:  MOVFF  FEF,A10
0993C:  MOVFF  8DE,A13
09940:  MOVFF  8DD,A12
09944:  MOVLB  0
09946:  CALL   5CC0
0994A:  MOVFF  02,8EC
0994E:  MOVFF  01,8EB
09952:  BCF    FD8.0
09954:  MOVLB  7
09956:  RLCF   x40,W
09958:  CLRF   03
0995A:  ADDLW  AB
0995C:  MOVWF  FE9
0995E:  MOVLW  07
09960:  ADDWFC 03,W
09962:  MOVWF  FEA
09964:  MOVFF  FEC,8EE
09968:  MOVF   FED,F
0996A:  MOVFF  FEF,8ED
0996E:  BCF    FD8.0
09970:  MOVLB  8
09972:  RRCF   xEE,W
09974:  MOVWF  03
09976:  RRCF   xED,W
09978:  MOVWF  02
0997A:  SUBWF  01,W
0997C:  MOVWF  00
0997E:  MOVF   03,W
09980:  SUBWFB xEC,W
09982:  MOVWF  03
09984:  MOVF   00,W
09986:  MOVFF  03,8E8
0998A:  CLRF   02
0998C:  CLRF   03
0998E:  MOVFF  03,8EA
09992:  MOVFF  02,8E9
09996:  MOVFF  00,8E7
....................             } 
0999A:  BRA    9AB4
0999C:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
0999E:  DECFSZ xDB,W
099A0:  BRA    9AB6
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
099A2:  BCF    FD8.0
099A4:  MOVLB  7
099A6:  RLCF   x40,W
099A8:  CLRF   03
099AA:  ADDLW  AB
099AC:  MOVWF  FE9
099AE:  MOVLW  07
099B0:  ADDWFC 03,W
099B2:  MOVWF  FEA
099B4:  MOVFF  FEC,A11
099B8:  MOVF   FED,F
099BA:  MOVFF  FEF,A10
099BE:  MOVLW  01
099C0:  MOVLB  8
099C2:  SUBWF  xDD,W
099C4:  MOVWF  00
099C6:  MOVLW  00
099C8:  SUBWFB xDE,W
099CA:  MOVWF  03
099CC:  MOVFF  00,8ED
099D0:  MOVWF  xEE
099D2:  MOVFF  FE8,A13
099D6:  MOVFF  00,A12
099DA:  MOVLB  0
099DC:  CALL   5CC0
099E0:  MOVFF  02,8EC
099E4:  MOVFF  01,8EB
099E8:  BCF    FD8.0
099EA:  MOVLB  7
099EC:  RLCF   x40,W
099EE:  CLRF   03
099F0:  ADDLW  AB
099F2:  MOVWF  FE9
099F4:  MOVLW  07
099F6:  ADDWFC 03,W
099F8:  MOVWF  FEA
099FA:  MOVFF  FEC,8EE
099FE:  MOVF   FED,F
09A00:  MOVFF  FEF,8ED
09A04:  BCF    FD8.0
09A06:  MOVLB  8
09A08:  RRCF   xEE,W
09A0A:  MOVWF  03
09A0C:  RRCF   xED,W
09A0E:  MOVWF  02
09A10:  ADDWF  01,W
09A12:  MOVWF  01
09A14:  MOVF   xEC,W
09A16:  ADDWFC 03,F
09A18:  MOVFF  01,8E3
09A1C:  MOVFF  03,8E4
09A20:  CLRF   02
09A22:  CLRF   03
09A24:  MOVFF  03,8E6
09A28:  MOVFF  02,8E5
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
09A2C:  BCF    FD8.0
09A2E:  MOVLB  7
09A30:  RLCF   x40,W
09A32:  CLRF   03
09A34:  ADDLW  AB
09A36:  MOVWF  FE9
09A38:  MOVLW  07
09A3A:  ADDWFC 03,W
09A3C:  MOVWF  FEA
09A3E:  MOVFF  FEC,A11
09A42:  MOVF   FED,F
09A44:  MOVFF  FEF,A10
09A48:  MOVLW  01
09A4A:  MOVLB  8
09A4C:  SUBWF  xDD,W
09A4E:  MOVWF  00
09A50:  MOVLW  00
09A52:  SUBWFB xDE,W
09A54:  MOVWF  03
09A56:  MOVFF  00,8ED
09A5A:  MOVWF  xEE
09A5C:  MOVFF  FE8,A13
09A60:  MOVFF  00,A12
09A64:  MOVLB  0
09A66:  CALL   5CC0
09A6A:  MOVFF  02,03
09A6E:  MOVFF  01,8E7
09A72:  MOVFF  02,8E8
09A76:  CLRF   02
09A78:  CLRF   03
09A7A:  MOVFF  03,8EA
09A7E:  MOVFF  02,8E9
....................                m_pll = m_pll -(m_ppp[motor]/2); 
09A82:  BCF    FD8.0
09A84:  MOVLB  7
09A86:  RLCF   x40,W
09A88:  CLRF   03
09A8A:  ADDLW  AB
09A8C:  MOVWF  FE9
09A8E:  MOVLW  07
09A90:  ADDWFC 03,W
09A92:  MOVWF  FEA
09A94:  MOVFF  FEC,8EC
09A98:  MOVF   FED,F
09A9A:  MOVFF  FEF,8EB
09A9E:  BCF    FD8.0
09AA0:  MOVLB  8
09AA2:  RRCF   xEC,W
09AA4:  MOVWF  03
09AA6:  RRCF   xEB,W
09AA8:  SUBWF  xE7,F
09AAA:  MOVF   03,W
09AAC:  SUBWFB xE8,F
09AAE:  MOVLW  00
09AB0:  SUBWFB xE9,F
09AB2:  SUBWFB xEA,F
09AB4:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
09AB6:  MOVLB  7
09AB8:  MOVF   x40,W
09ABA:  MULLW  04
09ABC:  MOVF   FF3,W
09ABE:  CLRF   03
09AC0:  ADDLW  A2
09AC2:  MOVWF  FE9
09AC4:  MOVLW  07
09AC6:  ADDWFC 03,W
09AC8:  MOVWF  FEA
09ACA:  MOVFF  FEF,8EB
09ACE:  MOVFF  FEC,8EC
09AD2:  MOVFF  FEC,8ED
09AD6:  MOVFF  FEC,8EE
09ADA:  MOVLB  8
09ADC:  BTFSC  xE6.7
09ADE:  BRA    9B4E
09AE0:  MOVF   xE6,W
09AE2:  SUBWF  xEE,W
09AE4:  BNC   9AFE
09AE6:  BNZ   9B4E
09AE8:  MOVF   xE5,W
09AEA:  SUBWF  xED,W
09AEC:  BNC   9AFE
09AEE:  BNZ   9B4E
09AF0:  MOVF   xE4,W
09AF2:  SUBWF  xEC,W
09AF4:  BNC   9AFE
09AF6:  BNZ   9B4E
09AF8:  MOVF   xEB,W
09AFA:  SUBWF  xE3,W
09AFC:  BNC   9B4E
09AFE:  MOVLB  7
09B00:  MOVF   x40,W
09B02:  MULLW  04
09B04:  MOVF   FF3,W
09B06:  CLRF   03
09B08:  ADDLW  A2
09B0A:  MOVWF  FE9
09B0C:  MOVLW  07
09B0E:  ADDWFC 03,W
09B10:  MOVWF  FEA
09B12:  MOVFF  FEF,8EB
09B16:  MOVFF  FEC,8EC
09B1A:  MOVFF  FEC,8ED
09B1E:  MOVFF  FEC,8EE
09B22:  MOVLB  8
09B24:  BTFSC  xEA.7
09B26:  BRA    9C92
09B28:  MOVF   xEE,W
09B2A:  SUBWF  xEA,W
09B2C:  BTFSS  FD8.0
09B2E:  BRA    9C92
09B30:  BNZ   9B4E
09B32:  MOVF   xED,W
09B34:  SUBWF  xE9,W
09B36:  BTFSS  FD8.0
09B38:  BRA    9C92
09B3A:  BNZ   9B4E
09B3C:  MOVF   xEC,W
09B3E:  SUBWF  xE8,W
09B40:  BTFSS  FD8.0
09B42:  BRA    9C92
09B44:  BNZ   9B4E
09B46:  MOVF   xE7,W
09B48:  SUBWF  xEB,W
09B4A:  BTFSC  FD8.0
09B4C:  BRA    9C92
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09B4E:  MOVLW  01
09B50:  MOVLB  7
09B52:  ADDWF  x40,W
09B54:  MOVLB  8
09B56:  MOVWF  xEB
09B58:  BCF    FD8.0
09B5A:  MOVLB  7
09B5C:  RLCF   x40,W
09B5E:  CLRF   03
09B60:  ADDLW  AB
09B62:  MOVWF  FE9
09B64:  MOVLW  07
09B66:  ADDWFC 03,W
09B68:  MOVWF  FEA
09B6A:  MOVFF  FEC,8ED
09B6E:  MOVF   FED,F
09B70:  MOVFF  FEF,8EC
09B74:  MOVF   x40,W
09B76:  MULLW  04
09B78:  MOVF   FF3,W
09B7A:  CLRF   03
09B7C:  ADDLW  A2
09B7E:  MOVWF  FE9
09B80:  MOVLW  07
09B82:  ADDWFC 03,W
09B84:  MOVWF  FEA
09B86:  MOVFF  FEF,8EE
09B8A:  MOVFF  FEC,8EF
09B8E:  MOVFF  FEC,8F0
09B92:  MOVFF  FEC,8F1
09B96:  MOVLW  8E
09B98:  MOVWF  FF6
09B9A:  MOVLW  1A
09B9C:  MOVWF  FF7
09B9E:  MOVLW  00
09BA0:  MOVWF  FF8
09BA2:  CLRF   1B
09BA4:  BTFSC  FF2.7
09BA6:  BSF    1B.7
09BA8:  BCF    FF2.7
09BAA:  MOVLW  05
09BAC:  MOVLB  A
09BAE:  MOVWF  x40
09BB0:  MOVLB  0
09BB2:  CALL   1044
09BB6:  BTFSC  1B.7
09BB8:  BSF    FF2.7
09BBA:  CLRF   1B
09BBC:  BTFSC  FF2.7
09BBE:  BSF    1B.7
09BC0:  BCF    FF2.7
09BC2:  MOVFF  8EB,A40
09BC6:  MOVLW  1B
09BC8:  MOVLB  A
09BCA:  MOVWF  x41
09BCC:  MOVLB  0
09BCE:  CALL   0FC6
09BD2:  BTFSC  1B.7
09BD4:  BSF    FF2.7
09BD6:  MOVLW  2C
09BD8:  BTFSS  F9E.4
09BDA:  BRA    9BD8
09BDC:  MOVWF  FAD
09BDE:  MOVLW  41
09BE0:  MOVWF  FE9
09BE2:  MOVFF  8DC,8F5
09BE6:  MOVFF  8DB,8F4
09BEA:  MOVFF  8DA,8F3
09BEE:  MOVFF  8D9,8F2
09BF2:  RCALL  958C
09BF4:  MOVLW  2C
09BF6:  BTFSS  F9E.4
09BF8:  BRA    9BF6
09BFA:  MOVWF  FAD
09BFC:  MOVLW  10
09BFE:  MOVWF  FE9
09C00:  CLRF   1B
09C02:  BTFSC  FF2.7
09C04:  BSF    1B.7
09C06:  BCF    FF2.7
09C08:  MOVFF  8ED,A41
09C0C:  MOVFF  8EC,A40
09C10:  CALL   11C6
09C14:  BTFSC  1B.7
09C16:  BSF    FF2.7
09C18:  MOVLW  2C
09C1A:  BTFSS  F9E.4
09C1C:  BRA    9C1A
09C1E:  MOVWF  FAD
09C20:  MOVLW  41
09C22:  MOVWF  FE9
09C24:  CLRF   1B
09C26:  BTFSC  FF2.7
09C28:  BSF    1B.7
09C2A:  BCF    FF2.7
09C2C:  MOVFF  8F1,A43
09C30:  MOVFF  8F0,A42
09C34:  MOVFF  8EF,A41
09C38:  MOVFF  8EE,A40
09C3C:  CALL   110A
09C40:  BTFSC  1B.7
09C42:  BSF    FF2.7
09C44:  MOVLW  2C
09C46:  BTFSS  F9E.4
09C48:  BRA    9C46
09C4A:  MOVWF  FAD
09C4C:  MOVLW  41
09C4E:  MOVWF  FE9
09C50:  MOVFF  8E6,8F5
09C54:  MOVFF  8E5,8F4
09C58:  MOVFF  8E4,8F3
09C5C:  MOVFF  8E3,8F2
09C60:  RCALL  958C
09C62:  MOVLW  2C
09C64:  BTFSS  F9E.4
09C66:  BRA    9C64
09C68:  MOVWF  FAD
09C6A:  MOVLW  41
09C6C:  MOVWF  FE9
09C6E:  MOVFF  8EA,8F5
09C72:  MOVFF  8E9,8F4
09C76:  MOVFF  8E8,8F3
09C7A:  MOVFF  8E7,8F2
09C7E:  RCALL  958C
09C80:  MOVLW  0D
09C82:  BTFSS  F9E.4
09C84:  BRA    9C82
09C86:  MOVWF  FAD
09C88:  MOVLW  0A
09C8A:  BTFSS  F9E.4
09C8C:  BRA    9C8A
09C8E:  MOVWF  FAD
09C90:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09C92:  BCF    FD8.0
09C94:  MOVLB  7
09C96:  RLCF   x40,W
09C98:  CLRF   03
09C9A:  ADDLW  9E
09C9C:  MOVWF  01
09C9E:  MOVLW  07
09CA0:  ADDWFC 03,F
09CA2:  MOVLB  8
09CA4:  MOVFF  03,8EC
09CA8:  BCF    FD8.0
09CAA:  MOVLB  7
09CAC:  RLCF   x40,W
09CAE:  CLRF   03
09CB0:  ADDLW  66
09CB2:  MOVWF  FE9
09CB4:  MOVLW  07
09CB6:  ADDWFC 03,W
09CB8:  MOVWF  FEA
09CBA:  MOVFF  FEC,03
09CBE:  MOVF   FED,F
09CC0:  MOVFF  FEF,8ED
09CC4:  MOVLB  8
09CC6:  MOVFF  8EC,FEA
09CCA:  MOVFF  01,FE9
09CCE:  MOVFF  03,FEC
09CD2:  MOVF   FED,F
09CD4:  MOVFF  8ED,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09CD8:  BCF    FD8.0
09CDA:  MOVLB  7
09CDC:  RLCF   x40,W
09CDE:  CLRF   03
09CE0:  ADDLW  66
09CE2:  MOVWF  FE9
09CE4:  MOVLW  07
09CE6:  ADDWFC 03,W
09CE8:  MOVWF  FEA
09CEA:  CLRF   FEC
09CEC:  MOVF   FED,F
09CEE:  MOVLW  04
09CF0:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09CF2:  MOVF   x40,W
09CF4:  MULLW  04
09CF6:  MOVF   FF3,W
09CF8:  CLRF   03
09CFA:  ADDLW  A2
09CFC:  MOVWF  FE9
09CFE:  MOVLW  07
09D00:  ADDWFC 03,W
09D02:  MOVWF  FEA
09D04:  MOVFF  FEF,8DF
09D08:  MOVFF  FEC,8E0
09D0C:  MOVFF  FEC,8E1
09D10:  MOVFF  FEC,8E2
09D14:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09D16:  MOVFF  8DF,00
09D1A:  MOVFF  8E0,01
09D1E:  MOVFF  8E1,02
09D22:  MOVFF  8E2,03
09D26:  MOVLB  0
09D28:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
08586:  MOVLB  2
08588:  CLRF   xDB
....................    start_even_port = FALSE; 
0858A:  CLRF   xDA
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
0858C:  BCF    FD8.0
0858E:  MOVLB  7
08590:  RLCF   x40,W
08592:  CLRF   03
08594:  ADDLW  C7
08596:  MOVWF  FE9
08598:  MOVLW  07
0859A:  ADDWFC 03,W
0859C:  MOVWF  FEA
0859E:  MOVFF  FEC,8D9
085A2:  MOVF   FED,F
085A4:  MOVFF  FEF,8D8
085A8:  MOVLW  01
085AA:  MOVLB  8
085AC:  ANDWF  xD8,F
085AE:  CLRF   xD9
085B0:  MOVF   xD8,F
085B2:  BNZ   85C0
085B4:  MOVF   xD9,F
085B6:  BNZ   85C0
....................    { 
....................       end_even_port = TRUE; 
085B8:  MOVLW  01
085BA:  MOVLB  2
085BC:  MOVWF  xDB
085BE:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
085C0:  BCF    FD8.0
085C2:  MOVLB  7
085C4:  RLCF   x40,W
085C6:  CLRF   03
085C8:  ADDLW  C3
085CA:  MOVWF  FE9
085CC:  MOVLW  07
085CE:  ADDWFC 03,W
085D0:  MOVWF  FEA
085D2:  MOVFF  FEC,8D9
085D6:  MOVF   FED,F
085D8:  MOVFF  FEF,8D8
085DC:  MOVLW  01
085DE:  MOVLB  8
085E0:  ANDWF  xD8,F
085E2:  CLRF   xD9
085E4:  MOVF   xD8,F
085E6:  BNZ   85F4
085E8:  MOVF   xD9,F
085EA:  BNZ   85F4
....................    { 
....................       start_even_port = TRUE; 
085EC:  MOVLW  01
085EE:  MOVLB  2
085F0:  MOVWF  xDA
085F2:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
085F4:  MOVLB  2
085F6:  MOVF   xDA,F
085F8:  BNZ   860E
....................    { 
....................       evenOdd = 0; 
085FA:  MOVLB  8
085FC:  CLRF   xD7
....................       if (TRUE == end_even_port) 
085FE:  MOVLB  2
08600:  DECFSZ xDB,W
08602:  BRA    860C
....................       { 
....................          evenOdd = 1; 
08604:  MOVLW  01
08606:  MOVLB  8
08608:  MOVWF  xD7
0860A:  MOVLB  2
....................       } 
....................    } 
0860C:  BRA    8622
....................    else 
....................    { 
....................       evenOdd = 2; 
0860E:  MOVLW  02
08610:  MOVLB  8
08612:  MOVWF  xD7
....................       if (TRUE == end_even_port) 
08614:  MOVLB  2
08616:  DECFSZ xDB,W
08618:  BRA    8622
....................       { 
....................          evenOdd = 3; 
0861A:  MOVLW  03
0861C:  MOVLB  8
0861E:  MOVWF  xD7
08620:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
08622:  MOVLB  8
08624:  MOVFF  8D7,01
08628:  MOVLB  0
0862A:  GOTO   A078 (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09DA0:  BCF    FD8.0
09DA2:  MOVLB  7
09DA4:  RLCF   x40,W
09DA6:  CLRF   03
09DA8:  ADDLW  86
09DAA:  MOVWF  FE9
09DAC:  MOVLW  07
09DAE:  ADDWFC 03,W
09DB0:  MOVWF  FEA
09DB2:  CLRF   FEC
09DB4:  MOVF   FED,F
09DB6:  MOVFF  8C8,FEF
....................    m_step_cnt[motor] = 0; 
09DBA:  MOVF   x40,W
09DBC:  MULLW  04
09DBE:  MOVF   FF3,W
09DC0:  CLRF   03
09DC2:  ADDLW  A2
09DC4:  MOVWF  FE9
09DC6:  MOVLW  07
09DC8:  ADDWFC 03,W
09DCA:  MOVWF  FEA
09DCC:  MOVF   FEE,F
09DCE:  MOVF   FEE,F
09DD0:  CLRF   FEC
09DD2:  MOVF   FED,F
09DD4:  CLRF   FEF
09DD6:  MOVF   FED,F
09DD8:  CLRF   FEF
09DDA:  MOVF   FED,F
09DDC:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09DDE:  BCF    FD8.0
09DE0:  RLCF   x40,W
09DE2:  CLRF   03
09DE4:  ADDLW  6E
09DE6:  MOVWF  FE9
09DE8:  MOVLW  07
09DEA:  ADDWFC 03,W
09DEC:  MOVWF  FEA
09DEE:  MOVFF  FEC,8D5
09DF2:  MOVF   FED,F
09DF4:  MOVFF  FEF,8D4
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09DF8:  BCF    FD8.0
09DFA:  RLCF   x40,W
09DFC:  CLRF   03
09DFE:  ADDLW  76
09E00:  MOVWF  FE9
09E02:  MOVLW  07
09E04:  ADDWFC 03,W
09E06:  MOVWF  FEA
09E08:  MOVFF  FEC,8DC
09E0C:  MOVF   FED,F
09E0E:  MOVFF  FEF,8DB
09E12:  BCF    FD8.0
09E14:  RLCF   x40,W
09E16:  CLRF   03
09E18:  ADDLW  5E
09E1A:  MOVWF  FE9
09E1C:  MOVLW  07
09E1E:  ADDWFC 03,W
09E20:  MOVWF  FEA
09E22:  MOVFF  FEC,03
09E26:  MOVF   FED,F
09E28:  MOVFF  FEF,8DD
09E2C:  MOVFF  03,8DA
09E30:  MOVFF  03,8DE
09E34:  MOVLB  0
09E36:  CALL   2CFC
09E3A:  MOVFF  02,8D3
09E3E:  MOVFF  01,8D2
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09E42:  BCF    FD8.0
09E44:  MOVLB  7
09E46:  RLCF   x40,W
09E48:  CLRF   03
09E4A:  ADDLW  66
09E4C:  MOVWF  FE9
09E4E:  MOVLW  07
09E50:  ADDWFC 03,W
09E52:  MOVWF  FEA
09E54:  MOVFF  FEC,8D8
09E58:  MOVF   FED,F
09E5A:  MOVFF  FEF,8D7
09E5E:  MOVLB  8
09E60:  MOVF   xD7,W
09E62:  SUBLW  02
09E64:  BNZ   9E94
09E66:  MOVF   xD8,F
09E68:  BNZ   9E94
09E6A:  BCF    FD8.0
09E6C:  MOVLB  7
09E6E:  RLCF   x40,W
09E70:  CLRF   03
09E72:  ADDLW  C3
09E74:  MOVWF  FE9
09E76:  MOVLW  07
09E78:  ADDWFC 03,W
09E7A:  MOVWF  FEA
09E7C:  MOVFF  FEC,8D8
09E80:  MOVF   FED,F
09E82:  MOVFF  FEF,8D7
09E86:  MOVLB  8
09E88:  MOVF   xD7,F
09E8A:  BNZ   9E94
09E8C:  MOVF   xD8,F
09E8E:  BTFSC  FD8.2
09E90:  GOTO   A732
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09E94:  BCF    FD8.0
09E96:  MOVLB  7
09E98:  RLCF   x40,W
09E9A:  CLRF   03
09E9C:  ADDLW  66
09E9E:  MOVWF  FE9
09EA0:  MOVLW  07
09EA2:  ADDWFC 03,W
09EA4:  MOVWF  FEA
09EA6:  MOVFF  FEC,8D8
09EAA:  MOVF   FED,F
09EAC:  MOVFF  FEF,8D7
09EB0:  MOVLB  8
09EB2:  MOVF   xD7,W
09EB4:  SUBLW  02
09EB6:  BTFSS  FD8.2
09EB8:  BRA    A212
09EBA:  MOVF   xD8,F
09EBC:  BTFSS  FD8.2
09EBE:  BRA    A212
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09EC0:  BCF    FD8.0
09EC2:  MOVLB  7
09EC4:  RLCF   x40,W
09EC6:  CLRF   03
09EC8:  ADDLW  C7
09ECA:  MOVWF  FE9
09ECC:  MOVLW  07
09ECE:  ADDWFC 03,W
09ED0:  MOVWF  FEA
09ED2:  MOVFF  8C9,FEF
09ED6:  MOVFF  8CA,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09EDA:  DECFSZ 2F,W
09EDC:  BRA    A18E
09EDE:  MOVF   30,F
09EE0:  BTFSS  FD8.2
09EE2:  BRA    A18E
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09EE4:  BCF    FD8.0
09EE6:  RLCF   x40,W
09EE8:  CLRF   03
09EEA:  ADDLW  C7
09EEC:  MOVWF  FE9
09EEE:  MOVLW  07
09EF0:  ADDWFC 03,W
09EF2:  MOVWF  FEA
09EF4:  MOVFF  FEC,8D8
09EF8:  MOVF   FED,F
09EFA:  MOVFF  FEF,8D7
09EFE:  BCF    FD8.0
09F00:  RLCF   x40,W
09F02:  CLRF   03
09F04:  ADDLW  C3
09F06:  MOVWF  FE9
09F08:  MOVLW  07
09F0A:  ADDWFC 03,W
09F0C:  MOVWF  FEA
09F0E:  MOVFF  FEC,03
09F12:  MOVF   FED,F
09F14:  MOVFF  FEF,01
09F18:  MOVF   03,W
09F1A:  MOVLB  8
09F1C:  SUBWF  xD8,W
09F1E:  BNC   9FBA
09F20:  BNZ   9F28
09F22:  MOVF   xD7,W
09F24:  SUBWF  01,W
09F26:  BC    9FBA
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09F28:  BCF    FD8.0
09F2A:  MOVLB  7
09F2C:  RLCF   x40,W
09F2E:  CLRF   03
09F30:  ADDLW  B7
09F32:  MOVWF  01
09F34:  MOVLW  07
09F36:  ADDWFC 03,F
09F38:  MOVLB  8
09F3A:  MOVFF  03,8D8
09F3E:  BCF    FD8.0
09F40:  MOVLB  7
09F42:  RLCF   x40,W
09F44:  CLRF   03
09F46:  ADDLW  C7
09F48:  MOVWF  FE9
09F4A:  MOVLW  07
09F4C:  ADDWFC 03,W
09F4E:  MOVWF  FEA
09F50:  MOVFF  FEC,8DA
09F54:  MOVF   FED,F
09F56:  MOVFF  FEF,8D9
09F5A:  BCF    FD8.0
09F5C:  RLCF   x40,W
09F5E:  CLRF   03
09F60:  ADDLW  C3
09F62:  MOVWF  FE9
09F64:  MOVLW  07
09F66:  ADDWFC 03,W
09F68:  MOVWF  FEA
09F6A:  MOVFF  FEC,03
09F6E:  MOVF   FED,F
09F70:  MOVF   FEF,W
09F72:  MOVLB  8
09F74:  SUBWF  xD9,W
09F76:  MOVWF  00
09F78:  MOVF   03,W
09F7A:  SUBWFB xDA,W
09F7C:  MOVFF  8D8,FEA
09F80:  MOVFF  01,FE9
09F84:  MOVWF  FEC
09F86:  MOVF   FED,F
09F88:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F8C:  BCF    FD8.0
09F8E:  MOVLB  7
09F90:  RLCF   x40,W
09F92:  CLRF   03
09F94:  ADDLW  B7
09F96:  MOVWF  FE9
09F98:  MOVLW  07
09F9A:  ADDWFC 03,W
09F9C:  MOVWF  FEA
09F9E:  MOVFF  FEC,8D8
09FA2:  MOVF   FED,F
09FA4:  MOVFF  FEF,8D7
09FA8:  BCF    FD8.0
09FAA:  MOVLB  8
09FAC:  CLRF   xCC
09FAE:  CLRF   xCB
09FB0:  RRCF   xD8,W
09FB2:  MOVWF  xCA
09FB4:  RRCF   xD7,W
09FB6:  MOVWF  xC9
....................             } 
09FB8:  BRA    A072
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09FBA:  BCF    FD8.0
09FBC:  MOVLB  7
09FBE:  RLCF   x40,W
09FC0:  CLRF   03
09FC2:  ADDLW  B7
09FC4:  MOVWF  01
09FC6:  MOVLW  07
09FC8:  ADDWFC 03,F
09FCA:  MOVFF  01,8D7
09FCE:  MOVLB  8
09FD0:  MOVFF  03,8D8
09FD4:  BCF    FD8.0
09FD6:  MOVLB  7
09FD8:  RLCF   x40,W
09FDA:  CLRF   03
09FDC:  ADDLW  62
09FDE:  MOVWF  FE9
09FE0:  MOVLW  07
09FE2:  ADDWFC 03,W
09FE4:  MOVWF  FEA
09FE6:  MOVFF  FEC,8DA
09FEA:  MOVF   FED,F
09FEC:  MOVFF  FEF,8D9
09FF0:  BCF    FD8.0
09FF2:  RLCF   x40,W
09FF4:  CLRF   03
09FF6:  ADDLW  C3
09FF8:  MOVWF  FE9
09FFA:  MOVLW  07
09FFC:  ADDWFC 03,W
09FFE:  MOVWF  FEA
0A000:  MOVFF  FEC,03
0A004:  MOVF   FED,F
0A006:  MOVF   FEF,W
0A008:  MOVLB  8
0A00A:  SUBWF  xD9,F
0A00C:  MOVF   03,W
0A00E:  SUBWFB xDA,F
0A010:  BCF    FD8.0
0A012:  MOVLB  7
0A014:  RLCF   x40,W
0A016:  CLRF   03
0A018:  ADDLW  C7
0A01A:  MOVWF  FE9
0A01C:  MOVLW  07
0A01E:  ADDWFC 03,W
0A020:  MOVWF  FEA
0A022:  MOVFF  FEC,03
0A026:  MOVF   FED,F
0A028:  MOVF   FEF,W
0A02A:  MOVLB  8
0A02C:  ADDWF  xD9,W
0A02E:  MOVWF  01
0A030:  MOVF   xDA,W
0A032:  ADDWFC 03,F
0A034:  MOVFF  8D8,FEA
0A038:  MOVFF  8D7,FE9
0A03C:  MOVFF  03,FEC
0A040:  MOVF   FED,F
0A042:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
0A046:  BCF    FD8.0
0A048:  MOVLB  7
0A04A:  RLCF   x40,W
0A04C:  CLRF   03
0A04E:  ADDLW  B7
0A050:  MOVWF  FE9
0A052:  MOVLW  07
0A054:  ADDWFC 03,W
0A056:  MOVWF  FEA
0A058:  MOVFF  FEC,8D8
0A05C:  MOVF   FED,F
0A05E:  MOVFF  FEF,8D7
0A062:  BCF    FD8.0
0A064:  MOVLB  8
0A066:  CLRF   xCC
0A068:  CLRF   xCB
0A06A:  RRCF   xD8,W
0A06C:  MOVWF  xCA
0A06E:  RRCF   xD7,W
0A070:  MOVWF  xC9
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
0A072:  MOVLB  0
0A074:  GOTO   8586
0A078:  MOVFF  01,8D6
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
0A07C:  BCF    FD8.0
0A07E:  MOVLB  7
0A080:  RLCF   x40,W
0A082:  CLRF   03
0A084:  ADDLW  C7
0A086:  MOVWF  FE9
0A088:  MOVLW  07
0A08A:  ADDWFC 03,W
0A08C:  MOVWF  FEA
0A08E:  MOVFF  FEC,8D8
0A092:  MOVF   FED,F
0A094:  MOVFF  FEF,8D7
0A098:  MOVLB  8
0A09A:  MOVF   xD7,W
0A09C:  SUBLW  02
0A09E:  BNZ   A0CE
0A0A0:  MOVF   xD8,F
0A0A2:  BNZ   A0CE
0A0A4:  BCF    FD8.0
0A0A6:  MOVLB  7
0A0A8:  RLCF   x40,W
0A0AA:  CLRF   03
0A0AC:  ADDLW  C3
0A0AE:  MOVWF  FE9
0A0B0:  MOVLW  07
0A0B2:  ADDWFC 03,W
0A0B4:  MOVWF  FEA
0A0B6:  MOVFF  FEC,8D8
0A0BA:  MOVF   FED,F
0A0BC:  MOVFF  FEF,8D7
0A0C0:  MOVLB  8
0A0C2:  DECFSZ xD7,W
0A0C4:  BRA    A0CE
0A0C6:  MOVF   xD8,F
0A0C8:  BNZ   A0CE
....................             { 
....................                port_port=4; 
0A0CA:  MOVLW  04
0A0CC:  MOVWF  xD6
....................             } 
....................              
....................             switch(port_port){ 
0A0CE:  MOVF   xD6,W
0A0D0:  ADDLW  FB
0A0D2:  BC    A18A
0A0D4:  ADDLW  05
0A0D6:  MOVLB  0
0A0D8:  GOTO   A780
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
0A0DC:  BCF    FD8.0
0A0DE:  MOVLB  7
0A0E0:  RLCF   x40,W
0A0E2:  CLRF   03
0A0E4:  ADDLW  6E
0A0E6:  MOVWF  FE9
0A0E8:  MOVLW  07
0A0EA:  ADDWFC 03,W
0A0EC:  MOVWF  FEA
0A0EE:  MOVFF  FEC,8D5
0A0F2:  MOVF   FED,F
0A0F4:  MOVFF  FEF,8D4
....................                   break; 
0A0F8:  MOVLB  8
0A0FA:  BRA    A18A
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A0FC:  BCF    FD8.0
0A0FE:  MOVLB  7
0A100:  RLCF   x40,W
0A102:  CLRF   03
0A104:  ADDLW  7E
0A106:  MOVWF  FE9
0A108:  MOVLW  07
0A10A:  ADDWFC 03,W
0A10C:  MOVWF  FEA
0A10E:  MOVFF  FEC,03
0A112:  MOVF   FED,F
0A114:  MOVF   FEF,W
0A116:  MOVLB  8
0A118:  ADDWF  xD2,W
0A11A:  MOVWF  xD4
0A11C:  MOVF   03,W
0A11E:  ADDWFC xD3,W
0A120:  MOVWF  xD5
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A122:  BRA    A18A
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A124:  BCF    FD8.0
0A126:  MOVLB  7
0A128:  RLCF   x40,W
0A12A:  CLRF   03
0A12C:  ADDLW  6E
0A12E:  MOVWF  FE9
0A130:  MOVLW  07
0A132:  ADDWFC 03,W
0A134:  MOVWF  FEA
0A136:  MOVFF  FEC,8D5
0A13A:  MOVF   FED,F
0A13C:  MOVFF  FEF,8D4
....................                         ++m_steps; 
0A140:  MOVLW  01
0A142:  MOVLB  8
0A144:  ADDWF  xC9,F
0A146:  BTFSC  FD8.0
0A148:  INCF   xCA,F
0A14A:  BTFSC  FD8.2
0A14C:  INCF   xCB,F
0A14E:  BTFSC  FD8.2
0A150:  INCF   xCC,F
....................                   break; 
0A152:  BRA    A18A
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A154:  BCF    FD8.0
0A156:  MOVLB  7
0A158:  RLCF   x40,W
0A15A:  CLRF   03
0A15C:  ADDLW  7E
0A15E:  MOVWF  FE9
0A160:  MOVLW  07
0A162:  ADDWFC 03,W
0A164:  MOVWF  FEA
0A166:  MOVFF  FEC,03
0A16A:  MOVF   FED,F
0A16C:  MOVF   FEF,W
0A16E:  MOVLB  8
0A170:  ADDWF  xD2,W
0A172:  MOVWF  xD4
0A174:  MOVF   03,W
0A176:  ADDWFC xD3,W
0A178:  MOVWF  xD5
....................  
....................                   break; 
0A17A:  BRA    A18A
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A17C:  MOVFF  8D3,8D5
0A180:  MOVFF  8D2,8D4
....................                   break;     
0A184:  MOVLB  8
0A186:  BRA    A18A
0A188:  MOVLB  8
....................             } 
....................          } 
0A18A:  BRA    A1B6
0A18C:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A18E:  MOVFF  8CC,8DA
0A192:  MOVFF  8CB,8D9
0A196:  MOVFF  8CA,8D8
0A19A:  MOVFF  8C9,8D7
0A19E:  MOVLB  0
0A1A0:  GOTO   862E
0A1A4:  MOVFF  03,8CC
0A1A8:  MOVFF  02,8CB
0A1AC:  MOVFF  01,8CA
0A1B0:  MOVFF  00,8C9
0A1B4:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A1B6:  DECFSZ xC7,W
0A1B8:  BRA    A1E0
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A1BA:  MOVFF  8CA,8D8
0A1BE:  MOVFF  8C9,8D7
0A1C2:  MOVFF  8CA,8DA
0A1C6:  MOVFF  8C9,8D9
0A1CA:  MOVLB  0
0A1CC:  GOTO   8840
0A1D0:  MOVLB  8
0A1D2:  CLRF   xCC
0A1D4:  CLRF   xCB
0A1D6:  MOVFF  02,8CA
0A1DA:  MOVFF  01,8C9
....................          } 
0A1DE:  BRA    A212
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A1E0:  MOVF   2F,W
0A1E2:  SUBLW  03
0A1E4:  BNZ   A212
0A1E6:  MOVF   30,F
0A1E8:  BNZ   A212
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A1EA:  BCF    FD8.0
0A1EC:  MOVLB  7
0A1EE:  RLCF   x40,W
0A1F0:  CLRF   03
0A1F2:  ADDLW  BF
0A1F4:  MOVWF  FE9
0A1F6:  MOVLW  07
0A1F8:  ADDWFC 03,W
0A1FA:  MOVWF  FEA
0A1FC:  MOVFF  FEC,03
0A200:  MOVF   FED,F
0A202:  MOVF   FEF,W
0A204:  MOVLB  8
0A206:  SUBWF  xC9,F
0A208:  MOVF   03,W
0A20A:  SUBWFB xCA,F
0A20C:  MOVLW  00
0A20E:  SUBWFB xCB,F
0A210:  SUBWFB xCC,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A212:  MOVFF  8CD,8D7
0A216:  MOVLB  0
0A218:  GOTO   8F0A
....................        
....................       //timeout could be set here!!! 
....................       while (m_running[motor]) 
0A21C:  BCF    FD8.0
0A21E:  MOVLB  7
0A220:  RLCF   x40,W
0A222:  CLRF   03
0A224:  ADDLW  92
0A226:  MOVWF  FE9
0A228:  MOVLW  07
0A22A:  ADDWFC 03,W
0A22C:  MOVWF  FEA
0A22E:  MOVF   FEF,F
0A230:  BNZ   A238
0A232:  MOVF   FEC,F
0A234:  BTFSC  FD8.2
0A236:  BRA    A72E
....................       { 
....................          switch(e_mode[motor]) 
0A238:  BCF    FD8.0
0A23A:  RLCF   x40,W
0A23C:  CLRF   03
0A23E:  ADDLW  66
0A240:  MOVWF  FE9
0A242:  MOVLW  07
0A244:  ADDWFC 03,W
0A246:  MOVWF  FEA
0A248:  MOVF   FEF,W
0A24A:  MOVWF  00
0A24C:  MOVF   FEE,F
0A24E:  MOVF   FED,W
0A250:  MOVWF  03
0A252:  MOVF   03,W
0A254:  BNZ   A25E
0A256:  MOVF   00,F
0A258:  MOVLB  0
0A25A:  BZ    A2AC
0A25C:  MOVLB  7
0A25E:  MOVF   03,W
0A260:  BNZ   A26C
0A262:  MOVLW  01
0A264:  SUBWF  00,W
0A266:  MOVLB  0
0A268:  BZ    A302
0A26A:  MOVLB  7
0A26C:  MOVF   03,W
0A26E:  BNZ   A27A
0A270:  MOVLW  02
0A272:  SUBWF  00,W
0A274:  MOVLB  0
0A276:  BZ    A302
0A278:  MOVLB  7
0A27A:  MOVF   03,W
0A27C:  BNZ   A28A
0A27E:  MOVLW  03
0A280:  SUBWF  00,W
0A282:  MOVLB  0
0A284:  BTFSC  FD8.2
0A286:  BRA    A3D0
0A288:  MOVLB  7
0A28A:  MOVF   03,W
0A28C:  BNZ   A29A
0A28E:  MOVLW  04
0A290:  SUBWF  00,W
0A292:  MOVLB  0
0A294:  BTFSC  FD8.2
0A296:  BRA    A520
0A298:  MOVLB  7
0A29A:  MOVF   03,W
0A29C:  BNZ   A2AA
0A29E:  MOVLW  05
0A2A0:  SUBWF  00,W
0A2A2:  MOVLB  0
0A2A4:  BTFSC  FD8.2
0A2A6:  BRA    A670
0A2A8:  MOVLB  7
0A2AA:  BRA    A728
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A2AC:  MOVLB  7
0A2AE:  MOVF   x40,W
0A2B0:  MULLW  04
0A2B2:  MOVF   FF3,W
0A2B4:  CLRF   03
0A2B6:  ADDLW  A2
0A2B8:  MOVWF  FE9
0A2BA:  MOVLW  07
0A2BC:  ADDWFC 03,W
0A2BE:  MOVWF  FEA
0A2C0:  MOVFF  FEF,8D7
0A2C4:  MOVFF  FEC,8D8
0A2C8:  MOVFF  FEC,8D9
0A2CC:  MOVFF  FEC,8DA
0A2D0:  MOVLB  8
0A2D2:  MOVF   xCC,W
0A2D4:  SUBWF  xDA,W
0A2D6:  BNC   A2FC
0A2D8:  BNZ   A2F0
0A2DA:  MOVF   xCB,W
0A2DC:  SUBWF  xD9,W
0A2DE:  BNC   A2FC
0A2E0:  BNZ   A2F0
0A2E2:  MOVF   xCA,W
0A2E4:  SUBWF  xD8,W
0A2E6:  BNC   A2FC
0A2E8:  BNZ   A2F0
0A2EA:  MOVF   xC9,W
0A2EC:  SUBWF  xD7,W
0A2EE:  BNC   A2FC
....................                { 
....................                   terminate(1); 
0A2F0:  MOVLW  01
0A2F2:  MOVWF  xEB
0A2F4:  MOVLB  0
0A2F6:  CALL   90F8
0A2FA:  MOVLB  8
....................                } 
....................                break; 
0A2FC:  MOVLB  7
0A2FE:  BRA    A728
0A300:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A302:  BCF    FD8.0
0A304:  MOVLB  7
0A306:  RLCF   x40,W
0A308:  CLRF   03
0A30A:  ADDLW  9A
0A30C:  MOVWF  FE9
0A30E:  MOVLW  07
0A310:  ADDWFC 03,W
0A312:  MOVWF  FEA
0A314:  MOVFF  FEC,8D8
0A318:  MOVF   FED,F
0A31A:  MOVFF  FEF,8D7
0A31E:  BCF    FD8.0
0A320:  RLCF   x40,W
0A322:  CLRF   03
0A324:  ADDLW  5A
0A326:  MOVWF  FE9
0A328:  MOVLW  07
0A32A:  ADDWFC 03,W
0A32C:  MOVWF  FEA
0A32E:  MOVFF  FEC,03
0A332:  MOVF   FED,F
0A334:  MOVFF  FEF,01
0A338:  MOVF   03,W
0A33A:  MOVLB  8
0A33C:  SUBWF  xD8,W
0A33E:  BNC   A352
0A340:  BNZ   A348
0A342:  MOVF   01,W
0A344:  SUBWF  xD7,W
0A346:  BNC   A352
....................                { 
....................                   terminate(0); 
0A348:  CLRF   xEB
0A34A:  MOVLB  0
0A34C:  CALL   90F8
0A350:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A352:  BCF    FD8.0
0A354:  MOVLB  7
0A356:  RLCF   x40,W
0A358:  CLRF   03
0A35A:  ADDLW  BB
0A35C:  MOVWF  FE9
0A35E:  MOVLW  07
0A360:  ADDWFC 03,W
0A362:  MOVWF  FEA
0A364:  MOVFF  FEC,8D8
0A368:  MOVF   FED,F
0A36A:  MOVFF  FEF,8D7
0A36E:  MOVLB  8
0A370:  MOVF   xCC,F
0A372:  BNZ   A3CA
0A374:  MOVF   xCB,F
0A376:  BNZ   A3CA
0A378:  MOVF   xCA,W
0A37A:  SUBWF  xD8,W
0A37C:  BNC   A3CA
0A37E:  BNZ   A386
0A380:  MOVF   xC9,W
0A382:  SUBWF  xD7,W
0A384:  BNC   A3CA
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A386:  BCF    FD8.0
0A388:  MOVLB  7
0A38A:  RLCF   x40,W
0A38C:  CLRF   03
0A38E:  ADDLW  B7
0A390:  MOVWF  FE9
0A392:  MOVLW  07
0A394:  ADDWFC 03,W
0A396:  MOVWF  FEA
0A398:  MOVFF  FEC,8DE
0A39C:  MOVF   FED,F
0A39E:  MOVFF  FEF,8DD
0A3A2:  MOVFF  8CC,8DC
0A3A6:  MOVFF  8CB,8DB
0A3AA:  MOVFF  8CA,8DA
0A3AE:  MOVFF  8C9,8D9
0A3B2:  MOVLB  0
0A3B4:  CALL   96B8
0A3B8:  MOVFF  03,8D1
0A3BC:  MOVFF  02,8D0
0A3C0:  MOVFF  01,8CF
0A3C4:  MOVFF  00,8CE
0A3C8:  MOVLB  8
....................                } 
....................                break; 
0A3CA:  MOVLB  7
0A3CC:  BRA    A728
0A3CE:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A3D0:  BCF    FD8.0
0A3D2:  MOVLB  7
0A3D4:  RLCF   x40,W
0A3D6:  CLRF   03
0A3D8:  ADDLW  BB
0A3DA:  MOVWF  FE9
0A3DC:  MOVLW  07
0A3DE:  ADDWFC 03,W
0A3E0:  MOVWF  FEA
0A3E2:  MOVFF  FEC,8D8
0A3E6:  MOVF   FED,F
0A3E8:  MOVFF  FEF,8D7
0A3EC:  MOVLB  8
0A3EE:  MOVF   xCC,F
0A3F0:  BNZ   A40E
0A3F2:  MOVF   xCB,F
0A3F4:  BNZ   A40E
0A3F6:  MOVF   xCA,W
0A3F8:  SUBWF  xD8,W
0A3FA:  BNC   A40E
0A3FC:  BNZ   A404
0A3FE:  MOVF   xC9,W
0A400:  SUBWF  xD7,W
0A402:  BNC   A40E
....................                { 
....................                   terminate(0); 
0A404:  CLRF   xEB
0A406:  MOVLB  0
0A408:  CALL   90F8
0A40C:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A40E:  BCF    FD8.0
0A410:  MOVLB  7
0A412:  RLCF   x40,W
0A414:  CLRF   03
0A416:  ADDLW  7A
0A418:  MOVWF  FE9
0A41A:  MOVLW  07
0A41C:  ADDWFC 03,W
0A41E:  MOVWF  FEA
0A420:  MOVFF  FEC,8D8
0A424:  MOVF   FED,F
0A426:  MOVFF  FEF,8D7
0A42A:  MOVLB  8
0A42C:  MOVF   xD7,F
0A42E:  BNZ   A494
0A430:  MOVF   xD8,F
0A432:  BNZ   A494
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A434:  CLRF   03
0A436:  MOVLB  7
0A438:  MOVF   x40,W
0A43A:  ADDLW  CB
0A43C:  MOVWF  FE9
0A43E:  MOVLW  07
0A440:  ADDWFC 03,W
0A442:  MOVWF  FEA
0A444:  MOVF   FEF,F
0A446:  BNZ   A492
....................                   { 
....................                      wrt_m_error(); 
0A448:  MOVLB  0
0A44A:  CALL   8FA8
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A44E:  BCF    FD8.0
0A450:  MOVLB  7
0A452:  RLCF   x40,W
0A454:  CLRF   03
0A456:  ADDLW  B7
0A458:  MOVWF  FE9
0A45A:  MOVLW  07
0A45C:  ADDWFC 03,W
0A45E:  MOVWF  FEA
0A460:  MOVFF  FEC,8DE
0A464:  MOVF   FED,F
0A466:  MOVFF  FEF,8DD
0A46A:  MOVFF  8CC,8DC
0A46E:  MOVFF  8CB,8DB
0A472:  MOVFF  8CA,8DA
0A476:  MOVFF  8C9,8D9
0A47A:  MOVLB  0
0A47C:  CALL   96B8
0A480:  MOVFF  03,8D1
0A484:  MOVFF  02,8D0
0A488:  MOVFF  01,8CF
0A48C:  MOVFF  00,8CE
0A490:  MOVLB  7
0A492:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A494:  BCF    FD8.0
0A496:  MOVLB  7
0A498:  RLCF   x40,W
0A49A:  CLRF   03
0A49C:  ADDLW  7A
0A49E:  MOVWF  FE9
0A4A0:  MOVLW  07
0A4A2:  ADDWFC 03,W
0A4A4:  MOVWF  FEA
0A4A6:  MOVFF  FEC,8D8
0A4AA:  MOVF   FED,F
0A4AC:  MOVFF  FEF,8D7
0A4B0:  MOVLB  8
0A4B2:  DECFSZ xD7,W
0A4B4:  BRA    A51A
0A4B6:  MOVF   xD8,F
0A4B8:  BNZ   A51A
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A4BA:  CLRF   03
0A4BC:  MOVLB  7
0A4BE:  MOVF   x40,W
0A4C0:  ADDLW  CB
0A4C2:  MOVWF  FE9
0A4C4:  MOVLW  07
0A4C6:  ADDWFC 03,W
0A4C8:  MOVWF  FEA
0A4CA:  DECFSZ FEF,W
0A4CC:  BRA    A518
....................                   { 
....................                      wrt_m_error(); 
0A4CE:  MOVLB  0
0A4D0:  CALL   8FA8
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A4D4:  BCF    FD8.0
0A4D6:  MOVLB  7
0A4D8:  RLCF   x40,W
0A4DA:  CLRF   03
0A4DC:  ADDLW  B7
0A4DE:  MOVWF  FE9
0A4E0:  MOVLW  07
0A4E2:  ADDWFC 03,W
0A4E4:  MOVWF  FEA
0A4E6:  MOVFF  FEC,8DE
0A4EA:  MOVF   FED,F
0A4EC:  MOVFF  FEF,8DD
0A4F0:  MOVFF  8CC,8DC
0A4F4:  MOVFF  8CB,8DB
0A4F8:  MOVFF  8CA,8DA
0A4FC:  MOVFF  8C9,8D9
0A500:  MOVLB  0
0A502:  CALL   96B8
0A506:  MOVFF  03,8D1
0A50A:  MOVFF  02,8D0
0A50E:  MOVFF  01,8CF
0A512:  MOVFF  00,8CE
0A516:  MOVLB  7
0A518:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A51A:  MOVLB  7
0A51C:  BRA    A728
0A51E:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A520:  MOVLB  7
0A522:  MOVF   x40,W
0A524:  MULLW  04
0A526:  MOVF   FF3,W
0A528:  CLRF   03
0A52A:  ADDLW  A2
0A52C:  MOVWF  FE9
0A52E:  MOVLW  07
0A530:  ADDWFC 03,W
0A532:  MOVWF  FEA
0A534:  MOVFF  FEF,8D7
0A538:  MOVFF  FEC,8D8
0A53C:  MOVFF  FEC,8D9
0A540:  MOVFF  FEC,8DA
0A544:  MOVLB  8
0A546:  MOVF   xCE,W
0A548:  SUBWF  xD7,F
0A54A:  MOVF   xCF,W
0A54C:  SUBWFB xD8,F
0A54E:  MOVF   xD0,W
0A550:  SUBWFB xD9,F
0A552:  MOVF   xD1,W
0A554:  SUBWFB xDA,F
0A556:  BNZ   A56E
0A558:  MOVF   xD9,F
0A55A:  BNZ   A56E
0A55C:  MOVF   xD5,W
0A55E:  SUBWF  xD8,W
0A560:  BTFSS  FD8.0
0A562:  BRA    A66A
0A564:  BNZ   A56E
0A566:  MOVF   xD4,W
0A568:  SUBWF  xD7,W
0A56A:  BTFSS  FD8.0
0A56C:  BRA    A66A
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A56E:  BCF    FD8.0
0A570:  MOVLB  7
0A572:  RLCF   x40,W
0A574:  CLRF   03
0A576:  ADDLW  66
0A578:  MOVWF  01
0A57A:  MOVLW  07
0A57C:  ADDWFC 03,F
0A57E:  MOVLB  8
0A580:  MOVFF  03,8D8
0A584:  BCF    FD8.0
0A586:  MOVLB  7
0A588:  RLCF   x40,W
0A58A:  CLRF   03
0A58C:  ADDLW  9E
0A58E:  MOVWF  FE9
0A590:  MOVLW  07
0A592:  ADDWFC 03,W
0A594:  MOVWF  FEA
0A596:  MOVFF  FEC,03
0A59A:  MOVF   FED,F
0A59C:  MOVFF  FEF,8D9
0A5A0:  MOVLB  8
0A5A2:  MOVFF  8D8,FEA
0A5A6:  MOVFF  01,FE9
0A5AA:  MOVFF  03,FEC
0A5AE:  MOVF   FED,F
0A5B0:  MOVFF  8D9,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A5B4:  MOVLB  7
0A5B6:  MOVF   x40,W
0A5B8:  MULLW  04
0A5BA:  MOVF   FF3,W
0A5BC:  CLRF   03
0A5BE:  ADDLW  A2
0A5C0:  MOVWF  FE9
0A5C2:  MOVLW  07
0A5C4:  ADDWFC 03,W
0A5C6:  MOVWF  FEA
0A5C8:  MOVFF  FEF,8D7
0A5CC:  MOVFF  FEC,8D8
0A5D0:  MOVFF  FEC,8D9
0A5D4:  MOVFF  FEC,8DA
0A5D8:  MOVLW  AC
0A5DA:  MOVWF  FF6
0A5DC:  MOVLW  1A
0A5DE:  MOVWF  FF7
0A5E0:  MOVLW  00
0A5E2:  MOVWF  FF8
0A5E4:  CLRF   1B
0A5E6:  BTFSC  FF2.7
0A5E8:  BSF    1B.7
0A5EA:  BCF    FF2.7
0A5EC:  MOVLW  0B
0A5EE:  MOVLB  A
0A5F0:  MOVWF  x40
0A5F2:  MOVLB  0
0A5F4:  CALL   1044
0A5F8:  BTFSC  1B.7
0A5FA:  BSF    FF2.7
0A5FC:  MOVLW  41
0A5FE:  MOVWF  FE9
0A600:  CLRF   1B
0A602:  BTFSC  FF2.7
0A604:  BSF    1B.7
0A606:  BCF    FF2.7
0A608:  MOVFF  8DA,A43
0A60C:  MOVFF  8D9,A42
0A610:  MOVFF  8D8,A41
0A614:  MOVFF  8D7,A40
0A618:  CALL   110A
0A61C:  BTFSC  1B.7
0A61E:  BSF    FF2.7
0A620:  MOVLW  2C
0A622:  BTFSS  F9E.4
0A624:  BRA    A622
0A626:  MOVWF  FAD
0A628:  MOVLW  41
0A62A:  MOVWF  FE9
0A62C:  CLRF   1B
0A62E:  BTFSC  FF2.7
0A630:  BSF    1B.7
0A632:  BCF    FF2.7
0A634:  MOVFF  8D1,A43
0A638:  MOVFF  8D0,A42
0A63C:  MOVFF  8CF,A41
0A640:  MOVFF  8CE,A40
0A644:  CALL   110A
0A648:  BTFSC  1B.7
0A64A:  BSF    FF2.7
0A64C:  MOVLW  0D
0A64E:  BTFSS  F9E.4
0A650:  BRA    A64E
0A652:  MOVWF  FAD
0A654:  MOVLW  0A
0A656:  BTFSS  F9E.4
0A658:  BRA    A656
0A65A:  MOVWF  FAD
....................                   terminate(1); 
0A65C:  MOVLW  01
0A65E:  MOVLB  8
0A660:  MOVWF  xEB
0A662:  MOVLB  0
0A664:  CALL   90F8
0A668:  MOVLB  8
....................                } 
....................                break; 
0A66A:  MOVLB  7
0A66C:  BRA    A728
0A66E:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A670:  MOVLB  7
0A672:  MOVF   x40,W
0A674:  MULLW  04
0A676:  MOVF   FF3,W
0A678:  CLRF   03
0A67A:  ADDLW  A2
0A67C:  MOVWF  FE9
0A67E:  MOVLW  07
0A680:  ADDWFC 03,W
0A682:  MOVWF  FEA
0A684:  MOVFF  FEF,8D7
0A688:  MOVFF  FEC,8D8
0A68C:  MOVFF  FEC,8D9
0A690:  MOVFF  FEC,8DA
0A694:  BCF    FD8.0
0A696:  RLCF   x40,W
0A698:  CLRF   03
0A69A:  ADDLW  72
0A69C:  MOVWF  FE9
0A69E:  MOVLW  07
0A6A0:  ADDWFC 03,W
0A6A2:  MOVWF  FEA
0A6A4:  MOVFF  FEC,03
0A6A8:  MOVF   FED,F
0A6AA:  MOVFF  FEF,01
0A6AE:  MOVLB  8
0A6B0:  MOVF   xDA,F
0A6B2:  BNZ   A6C6
0A6B4:  MOVF   xD9,F
0A6B6:  BNZ   A6C6
0A6B8:  MOVF   03,W
0A6BA:  SUBWF  xD8,W
0A6BC:  BNC   A726
0A6BE:  BNZ   A6C6
0A6C0:  MOVF   01,W
0A6C2:  SUBWF  xD7,W
0A6C4:  BNC   A726
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A6C6:  BCF    FD8.0
0A6C8:  MOVLB  7
0A6CA:  RLCF   x40,W
0A6CC:  CLRF   03
0A6CE:  ADDLW  66
0A6D0:  MOVWF  01
0A6D2:  MOVLW  07
0A6D4:  ADDWFC 03,F
0A6D6:  MOVLB  8
0A6D8:  MOVFF  03,8D8
0A6DC:  BCF    FD8.0
0A6DE:  MOVLB  7
0A6E0:  RLCF   x40,W
0A6E2:  CLRF   03
0A6E4:  ADDLW  9E
0A6E6:  MOVWF  FE9
0A6E8:  MOVLW  07
0A6EA:  ADDWFC 03,W
0A6EC:  MOVWF  FEA
0A6EE:  MOVFF  FEC,03
0A6F2:  MOVF   FED,F
0A6F4:  MOVFF  FEF,8D9
0A6F8:  MOVLB  8
0A6FA:  MOVFF  8D8,FEA
0A6FE:  MOVFF  01,FE9
0A702:  MOVFF  03,FEC
0A706:  MOVF   FED,F
0A708:  MOVFF  8D9,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A70C:  BCF    FD8.0
0A70E:  MOVLB  7
0A710:  RLCF   x40,W
0A712:  CLRF   03
0A714:  ADDLW  BB
0A716:  MOVWF  FE9
0A718:  MOVLW  07
0A71A:  ADDWFC 03,W
0A71C:  MOVWF  FEA
0A71E:  CLRF   FEC
0A720:  MOVF   FED,F
0A722:  CLRF   FEF
0A724:  MOVLB  8
....................                } 
....................                break; 
0A726:  MOVLB  7
....................             } 
....................          } 
0A728:  MOVLB  0
0A72A:  BRA    A21C
0A72C:  MOVLB  7
....................       } 
....................    } 
0A72E:  BRA    A74C
0A730:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A732:  BCF    FD8.0
0A734:  MOVLB  7
0A736:  RLCF   x40,W
0A738:  CLRF   03
0A73A:  ADDLW  96
0A73C:  MOVWF  FE9
0A73E:  MOVLW  07
0A740:  ADDWFC 03,W
0A742:  MOVWF  FEA
0A744:  CLRF   FEC
0A746:  MOVF   FED,F
0A748:  MOVLW  01
0A74A:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A74C:  BCF    FD8.0
0A74E:  RLCF   x40,W
0A750:  CLRF   03
0A752:  ADDLW  96
0A754:  MOVWF  FE9
0A756:  MOVLW  07
0A758:  ADDWFC 03,W
0A75A:  MOVWF  FEA
0A75C:  MOVFF  FEC,8D8
0A760:  MOVF   FED,F
0A762:  MOVFF  FEF,8D7
0A766:  MOVLB  8
0A768:  DECFSZ xD7,W
0A76A:  BRA    A77C
0A76C:  MOVF   xD8,F
0A76E:  BNZ   A77C
....................       wrt_m_error(); 
0A770:  MOVLB  0
0A772:  CALL   8FA8
....................       msg_mer(); 
0A776:  CALL   9D2A
0A77A:  MOVLB  8
....................    } 
0A77C:  MOVLB  0
0A77E:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
170DC:  MOVF   48,F
170DE:  BNZ   170EC
170E0:  MOVF   49,F
170E2:  BNZ   170EC
170E4:  MOVF   4A,F
170E6:  BNZ   170EC
170E8:  MOVF   4B,F
170EA:  BZ    17118
170EC:  MOVF   4B,F
170EE:  BNZ   17118
170F0:  MOVF   4A,W
170F2:  SUBLW  00
170F4:  BNC   17118
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
170F6:  MOVFF  885,8C7
170FA:  MOVFF  886,8C8
170FE:  MOVFF  4B,8CC
17102:  MOVFF  4A,8CB
17106:  MOVFF  49,8CA
1710A:  MOVFF  48,8C9
1710E:  MOVFF  887,8CD
17112:  CALL   9DA0
....................    } 
17116:  BRA    17194
....................    else if(arg==0) 
17118:  MOVF   48,F
1711A:  BNZ   17190
1711C:  MOVF   49,F
1711E:  BNZ   17190
17120:  MOVF   4A,F
17122:  BNZ   17190
17124:  MOVF   4B,F
17126:  BNZ   17190
....................    { 
....................       m_lin_pos[motor]=0; 
17128:  BCF    FD8.0
1712A:  MOVLB  7
1712C:  RLCF   x40,W
1712E:  CLRF   03
17130:  ADDLW  B3
17132:  MOVWF  FE9
17134:  MOVLW  07
17136:  ADDWFC 03,W
17138:  MOVWF  FEA
1713A:  CLRF   FEC
1713C:  MOVF   FED,F
1713E:  CLRF   FEF
....................       switch (motor){ 
17140:  MOVF   x40,W
17142:  XORLW  00
17144:  MOVLB  0
17146:  BZ    1714E
17148:  XORLW  01
1714A:  BZ    17160
1714C:  BRA    17170
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
1714E:  MOVLW  B6
17150:  MOVLB  8
17152:  MOVWF  xEE
17154:  CLRF   xF0
17156:  CLRF   xEF
17158:  MOVLB  0
1715A:  CALL   4FFC
....................             break; 
1715E:  BRA    17170
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
17160:  MOVLW  B8
17162:  MOVLB  8
17164:  MOVWF  xEE
17166:  CLRF   xF0
17168:  CLRF   xEF
1716A:  MOVLB  0
1716C:  CALL   4FFC
....................             break; 
....................       }  
....................       m_error[motor]=0; 
17170:  BCF    FD8.0
17172:  MOVLB  7
17174:  RLCF   x40,W
17176:  CLRF   03
17178:  ADDLW  96
1717A:  MOVWF  FE9
1717C:  MOVLW  07
1717E:  ADDWFC 03,W
17180:  MOVWF  FEA
17182:  CLRF   FEC
17184:  MOVF   FED,F
17186:  CLRF   FEF
....................       wrt_m_error(); 
17188:  MOVLB  0
1718A:  CALL   8FA8
....................    } 
1718E:  BRA    17194
....................    else cmd_arg(); 
17190:  CALL   B32E
17194:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
18C16:  MOVLW  01
18C18:  MOVLB  8
18C1A:  MOVWF  xEC
18C1C:  MOVLB  0
18C1E:  CALL   89F8
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
18C22:  MOVLW  FA
18C24:  MOVLB  9
18C26:  MOVWF  xEC
18C28:  MOVLB  0
18C2A:  CALL   2938
....................       switch(motor) 
18C2E:  MOVLB  7
18C30:  MOVF   x40,W
18C32:  XORLW  00
18C34:  MOVLB  0
18C36:  BZ    18C3E
18C38:  XORLW  01
18C3A:  BZ    18C50
18C3C:  BRA    18C60
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18C3E:  MOVLB  8
18C40:  CLRF   x85
18C42:  BTFSC  F81.4
18C44:  INCF   x85,F
....................             chanA = input(ENC1_PHA); 
18C46:  CLRF   x86
18C48:  BTFSC  F81.1
18C4A:  INCF   x86,F
....................             break; 
18C4C:  MOVLB  0
18C4E:  BRA    18C60
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
18C50:  MOVLB  8
18C52:  CLRF   x85
18C54:  BTFSC  F81.5
18C56:  INCF   x85,F
....................             chanA = input(ENC2_PHA); 
18C58:  CLRF   x86
18C5A:  BTFSC  F81.2
18C5C:  INCF   x86,F
....................             break; 
18C5E:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
18C60:  MOVLW  C2
18C62:  MOVWF  FF6
18C64:  MOVLW  1A
18C66:  MOVWF  FF7
18C68:  MOVLW  00
18C6A:  MOVWF  FF8
18C6C:  CLRF   1B
18C6E:  BTFSC  FF2.7
18C70:  BSF    1B.7
18C72:  BCF    FF2.7
18C74:  MOVLW  04
18C76:  MOVLB  A
18C78:  MOVWF  x40
18C7A:  MOVLB  0
18C7C:  CALL   1044
18C80:  BTFSC  1B.7
18C82:  BSF    FF2.7
18C84:  CLRF   1B
18C86:  BTFSC  FF2.7
18C88:  BSF    1B.7
18C8A:  BCF    FF2.7
18C8C:  MOVFF  885,A40
18C90:  MOVLW  1B
18C92:  MOVLB  A
18C94:  MOVWF  x41
18C96:  MOVLB  0
18C98:  CALL   0FC6
18C9C:  BTFSC  1B.7
18C9E:  BSF    FF2.7
18CA0:  MOVLW  C8
18CA2:  MOVWF  FF6
18CA4:  MOVLW  1A
18CA6:  MOVWF  FF7
18CA8:  MOVLW  00
18CAA:  MOVWF  FF8
18CAC:  CLRF   1B
18CAE:  BTFSC  FF2.7
18CB0:  BSF    1B.7
18CB2:  BCF    FF2.7
18CB4:  MOVLW  07
18CB6:  MOVLB  A
18CB8:  MOVWF  x40
18CBA:  MOVLB  0
18CBC:  CALL   1044
18CC0:  BTFSC  1B.7
18CC2:  BSF    FF2.7
18CC4:  CLRF   1B
18CC6:  BTFSC  FF2.7
18CC8:  BSF    1B.7
18CCA:  BCF    FF2.7
18CCC:  MOVFF  886,A40
18CD0:  MOVLW  1B
18CD2:  MOVLB  A
18CD4:  MOVWF  x41
18CD6:  MOVLB  0
18CD8:  CALL   0FC6
18CDC:  BTFSC  1B.7
18CDE:  BSF    FF2.7
18CE0:  MOVLW  0D
18CE2:  BTFSS  F9E.4
18CE4:  BRA    18CE2
18CE6:  MOVWF  FAD
18CE8:  MOVLW  0A
18CEA:  BTFSS  F9E.4
18CEC:  BRA    18CEA
18CEE:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
18CF0:  BTFSS  F9E.5
18CF2:  BRA    18D00
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
18CF4:  CALL   0E58
18CF8:  MOVF   01,W
18CFA:  SUBLW  1B
18CFC:  BNZ   18D00
....................          { 
....................             break; 
18CFE:  BRA    18D02
....................          } 
....................       } 
18D00:  BRA    18C22
....................    } 
....................  
....................    delay_ms(100); 
18D02:  MOVLW  64
18D04:  MOVLB  9
18D06:  MOVWF  xEC
18D08:  MOVLB  0
18D0A:  CALL   2938
....................    enc_pwr(OFF); 
18D0E:  MOVLB  8
18D10:  CLRF   xEC
18D12:  MOVLB  0
18D14:  CALL   89F8
18D18:  GOTO   18D34 (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A8DC:  BCF    FD8.0
0A8DE:  MOVLB  7
0A8E0:  RLCF   x40,W
0A8E2:  CLRF   03
0A8E4:  ADDLW  66
0A8E6:  MOVWF  FE9
0A8E8:  MOVLW  07
0A8EA:  ADDWFC 03,W
0A8EC:  MOVWF  FEA
0A8EE:  MOVFF  FEC,8C6
0A8F2:  MOVF   FED,F
0A8F4:  MOVFF  FEF,8C5
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A8F8:  BCF    FD8.0
0A8FA:  RLCF   x40,W
0A8FC:  CLRF   03
0A8FE:  ADDLW  76
0A900:  MOVWF  FE9
0A902:  MOVLW  07
0A904:  ADDWFC 03,W
0A906:  MOVWF  FEA
0A908:  MOVFF  FEC,8DC
0A90C:  MOVF   FED,F
0A90E:  MOVFF  FEF,8DB
0A912:  BCF    FD8.0
0A914:  RLCF   x40,W
0A916:  CLRF   03
0A918:  ADDLW  62
0A91A:  MOVWF  FE9
0A91C:  MOVLW  07
0A91E:  ADDWFC 03,W
0A920:  MOVWF  FEA
0A922:  MOVFF  FEC,03
0A926:  MOVF   FED,F
0A928:  MOVFF  FEF,8DD
0A92C:  MOVFF  03,8CA
0A930:  MOVFF  03,8DE
0A934:  MOVLB  0
0A936:  CALL   2CFC
0A93A:  MOVFF  02,8C4
0A93E:  MOVFF  01,8C3
....................    e_mode[motor] = 0;                          // motor steps 
0A942:  BCF    FD8.0
0A944:  MOVLB  7
0A946:  RLCF   x40,W
0A948:  CLRF   03
0A94A:  ADDLW  66
0A94C:  MOVWF  FE9
0A94E:  MOVLW  07
0A950:  ADDWFC 03,W
0A952:  MOVWF  FEA
0A954:  CLRF   FEC
0A956:  MOVF   FED,F
0A958:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A95A:  MOVLB  8
0A95C:  CLRF   xC7
0A95E:  MOVFF  8C2,8C8
0A962:  CLRF   xCC
0A964:  CLRF   xCB
0A966:  MOVFF  8C4,8CA
0A96A:  MOVFF  8C3,8C9
0A96E:  MOVLW  01
0A970:  MOVWF  xCD
0A972:  MOVLB  0
0A974:  CALL   9DA0
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A978:  MOVLW  01
0A97A:  MOVLB  8
0A97C:  MOVWF  xEC
0A97E:  MOVLB  0
0A980:  CALL   89F8
....................    delay_ms(100); 
0A984:  MOVLW  64
0A986:  MOVLB  9
0A988:  MOVWF  xEC
0A98A:  MOVLB  0
0A98C:  CALL   2938
....................    poll_index(); 
0A990:  BRA    A7AA
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A992:  BCF    FD8.0
0A994:  MOVLB  7
0A996:  RLCF   x40,W
0A998:  CLRF   03
0A99A:  ADDLW  5E
0A99C:  MOVWF  FE9
0A99E:  MOVLW  07
0A9A0:  ADDWFC 03,W
0A9A2:  MOVWF  FEA
0A9A4:  MOVFF  FEC,8C8
0A9A8:  MOVF   FED,F
0A9AA:  MOVFF  FEF,8C7
0A9AE:  MOVLW  02
0A9B0:  MOVLB  8
0A9B2:  ADDWF  xC7,W
0A9B4:  MOVWF  xC3
0A9B6:  MOVLW  00
0A9B8:  ADDWFC xC8,W
0A9BA:  MOVWF  xC4
....................    e_mode[motor] = 3; 
0A9BC:  BCF    FD8.0
0A9BE:  MOVLB  7
0A9C0:  RLCF   x40,W
0A9C2:  CLRF   03
0A9C4:  ADDLW  66
0A9C6:  MOVWF  FE9
0A9C8:  MOVLW  07
0A9CA:  ADDWFC 03,W
0A9CC:  MOVWF  FEA
0A9CE:  CLRF   FEC
0A9D0:  MOVF   FED,F
0A9D2:  MOVLW  03
0A9D4:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A9D6:  MOVLB  8
0A9D8:  CLRF   xC7
0A9DA:  MOVFF  8C2,8C8
0A9DE:  CLRF   xCC
0A9E0:  CLRF   xCB
0A9E2:  MOVFF  8C4,8CA
0A9E6:  MOVFF  8C3,8C9
0A9EA:  MOVLW  01
0A9EC:  MOVWF  xCD
0A9EE:  MOVLB  0
0A9F0:  CALL   9DA0
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A9F4:  MOVFF  783,8C4
0A9F8:  MOVFF  782,8C3
....................    e_mode[motor] = 0;                          // motor steps 
0A9FC:  BCF    FD8.0
0A9FE:  MOVLB  7
0AA00:  RLCF   x40,W
0AA02:  CLRF   03
0AA04:  ADDLW  66
0AA06:  MOVWF  FE9
0AA08:  MOVLW  07
0AA0A:  ADDWFC 03,W
0AA0C:  MOVWF  FEA
0AA0E:  CLRF   FEC
0AA10:  MOVF   FED,F
0AA12:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0AA14:  MOVLB  8
0AA16:  CLRF   xC7
0AA18:  MOVFF  8C2,8C8
0AA1C:  CLRF   xCC
0AA1E:  CLRF   xCB
0AA20:  MOVFF  8C4,8CA
0AA24:  MOVFF  8C3,8C9
0AA28:  MOVLW  01
0AA2A:  MOVWF  xCD
0AA2C:  MOVLB  0
0AA2E:  CALL   9DA0
....................  
....................    e_pos[motor] = 0; 
0AA32:  BCF    FD8.0
0AA34:  MOVLB  7
0AA36:  RLCF   x40,W
0AA38:  CLRF   03
0AA3A:  ADDLW  BF
0AA3C:  MOVWF  FE9
0AA3E:  MOVLW  07
0AA40:  ADDWFC 03,W
0AA42:  MOVWF  FEA
0AA44:  CLRF   FEC
0AA46:  MOVF   FED,F
0AA48:  CLRF   FEF
....................    e_port[motor] = 1; 
0AA4A:  BCF    FD8.0
0AA4C:  RLCF   x40,W
0AA4E:  CLRF   03
0AA50:  ADDLW  C3
0AA52:  MOVWF  FE9
0AA54:  MOVLW  07
0AA56:  ADDWFC 03,W
0AA58:  MOVWF  FEA
0AA5A:  CLRF   FEC
0AA5C:  MOVF   FED,F
0AA5E:  MOVLW  01
0AA60:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0AA62:  BCF    FD8.0
0AA64:  RLCF   x40,W
0AA66:  CLRF   03
0AA68:  ADDLW  66
0AA6A:  MOVWF  FE9
0AA6C:  MOVLW  07
0AA6E:  ADDWFC 03,W
0AA70:  MOVWF  FEA
0AA72:  MOVFF  8C6,FEC
0AA76:  MOVF   FED,F
0AA78:  MOVFF  8C5,FEF
0AA7C:  MOVLB  0
0AA7E:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0E0E4:  BCF    FD8.0
0E0E6:  MOVLB  7
0E0E8:  RLCF   x40,W
0E0EA:  CLRF   03
0E0EC:  ADDLW  5E
0E0EE:  MOVWF  FE9
0E0F0:  MOVLW  07
0E0F2:  ADDWFC 03,W
0E0F4:  MOVWF  FEA
0E0F6:  MOVFF  FEC,889
0E0FA:  MOVF   FED,F
0E0FC:  MOVFF  FEF,888
0E100:  MOVLW  02
0E102:  MOVLB  8
0E104:  ADDWF  x88,W
0E106:  MOVWF  x86
0E108:  MOVLW  00
0E10A:  ADDWFC x89,W
0E10C:  MOVWF  x87
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0E10E:  CLRF   xC7
0E110:  MOVFF  885,8C8
0E114:  CLRF   xCC
0E116:  CLRF   xCB
0E118:  MOVFF  887,8CA
0E11C:  MOVFF  886,8C9
0E120:  MOVLW  02
0E122:  MOVWF  xCD
0E124:  MOVLB  0
0E126:  CALL   9DA0
0E12A:  GOTO   E1AA (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0AA80:  MOVF   2F,W
0AA82:  SUBLW  02
0AA84:  BNZ   AA8A
0AA86:  MOVF   30,F
0AA88:  BZ    AAF2
....................    { 
....................       //setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_256); 
....................       //set up valve timeout variable 
....................       /*ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
....................       enable_interrupts(INT_EXT); 
....................  
....................       start_heartbeat(); 
....................  
....................       enable_interrupts(GLOBAL); 
....................       busy_set();*/ 
....................       valve_align_timeout = 0; 
0AA8A:  CLRF   3A
0AA8C:  CLRF   39
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0AA8E:  MOVLW  D4
0AA90:  MOVWF  FF6
0AA92:  MOVLW  1A
0AA94:  MOVWF  FF7
0AA96:  MOVLW  00
0AA98:  MOVWF  FF8
0AA9A:  CLRF   1B
0AA9C:  BTFSC  FF2.7
0AA9E:  BSF    1B.7
0AAA0:  BCF    FF2.7
0AAA2:  CALL   0E6E
0AAA6:  BTFSC  1B.7
0AAA8:  BSF    FF2.7
....................       motor=0; 
0AAAA:  MOVLB  7
0AAAC:  CLRF   x40
....................       align(0); 
0AAAE:  MOVLB  8
0AAB0:  CLRF   xC2
0AAB2:  MOVLB  0
0AAB4:  RCALL  A8DC
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0AAB6:  MOVLW  01
0AAB8:  MOVLB  7
0AABA:  MOVWF  x40
....................       move_motor(0,0,22000,1); 
0AABC:  MOVLB  8
0AABE:  CLRF   xC7
0AAC0:  CLRF   xC8
0AAC2:  CLRF   xCC
0AAC4:  CLRF   xCB
0AAC6:  MOVLW  55
0AAC8:  MOVWF  xCA
0AACA:  MOVLW  F0
0AACC:  MOVWF  xC9
0AACE:  MOVLW  01
0AAD0:  MOVWF  xCD
0AAD2:  MOVLB  0
0AAD4:  CALL   9DA0
....................        
....................       m_lin_pos[1]=0; 
0AAD8:  MOVLB  7
0AADA:  CLRF   xB6
0AADC:  CLRF   xB5
....................       write16(ADDR_M2_LIN_POS,0); 
0AADE:  MOVLW  B8
0AAE0:  MOVLB  8
0AAE2:  MOVWF  xEE
0AAE4:  CLRF   xF0
0AAE6:  CLRF   xEF
0AAE8:  MOVLB  0
0AAEA:  CALL   4FFC
....................       valve_align_timeout = -1; 
0AAEE:  SETF   3A
0AAF0:  SETF   39
....................    } 
0AAF2:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0C232:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0C234:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0C236:  BCF    F8E.3
....................   delay_ms(20); 
0C238:  MOVLW  14
0C23A:  MOVLB  9
0C23C:  MOVWF  xEC
0C23E:  MOVLB  0
0C240:  CALL   2938
....................   output_bit(VMOT,  OFF); 
0C244:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0C246:  BCF    F8E.2
0C248:  GOTO   C29E (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0C24C:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0C24E:  BSF    F8E.1
....................   delay_ms(50); 
0C250:  MOVLW  32
0C252:  MOVLB  9
0C254:  MOVWF  xEC
0C256:  MOVLB  0
0C258:  CALL   2938
....................   output_bit(HB_IN1,ON);           
0C25C:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0C25E:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0C260:  BSF    F8E.3
0C262:  GOTO   C29E (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0C266:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0C268:  BSF    F8E.1
....................   delay_ms(50); 
0C26A:  MOVLW  32
0C26C:  MOVLB  9
0C26E:  MOVWF  xEC
0C270:  MOVLB  0
0C272:  CALL   2938
....................   output_bit(HB_IN1,OFF);           
0C276:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0C278:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0C27A:  BSF    F8E.3
0C27C:  GOTO   C29E (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0C280:  MOVLB  8
0C282:  MOVF   xB5,W
0C284:  XORLW  00
0C286:  MOVLB  0
0C288:  BZ    C294
0C28A:  XORLW  01
0C28C:  BZ    C298
0C28E:  XORLW  03
0C290:  BZ    C29C
0C292:  BRA    C29E
....................       case 0:  HB_all_OFF(); 
0C294:  BRA    C232
....................          break; 
0C296:  BRA    C29E
....................       case 1:  HB_m1_ON(); 
0C298:  BRA    C24C
....................          break; 
0C29A:  BRA    C29E
....................       case 2:  HB_m2_ON(); 
0C29C:  BRA    C266
....................          break; 
....................    } 
0C29E:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
15DD0:  MOVLB  8
15DD2:  CLRF   x89
15DD4:  CLRF   x8A
15DD6:  CLRF   x8B
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
15DD8:  MOVLB  0
15DDA:  BRA    15D66
15DDC:  MOVFF  01,88A
....................       if (serChar) 
15DE0:  MOVLB  8
15DE2:  MOVF   x8A,F
15DE4:  BZ    15E0E
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
15DE6:  MOVF   x8A,W
15DE8:  SUBLW  24
15DEA:  BNZ   15DF4
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
15DEC:  MOVLW  02
15DEE:  MOVWF  x8B
....................             break; 
15DF0:  BRA    15E1A
....................          }else if (serChar == 'D'){ 
15DF2:  BRA    15E0E
15DF4:  MOVF   x8A,W
15DF6:  SUBLW  44
15DF8:  BNZ   15E0A
....................             wakeup_char_is_D = 1; 
15DFA:  MOVLW  01
15DFC:  MOVLB  7
15DFE:  MOVWF  xCD
....................             wakeUpReason = WAKE_UP_GOOD; 
15E00:  MOVLW  02
15E02:  MOVLB  8
15E04:  MOVWF  x8B
....................             break; 
15E06:  BRA    15E1A
....................          }else 
15E08:  BRA    15E0E
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
15E0A:  MOVLW  01
15E0C:  MOVWF  x8B
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
15E0E:  INCF   x89,F
15E10:  MOVF   x89,W
15E12:  SUBLW  02
15E14:  BC    15E18
....................       { 
....................          break; 
15E16:  BRA    15E1A
....................       } 
15E18:  BRA    15DD8
....................    } 
....................  
....................    return (wakeUpReason); 
15E1A:  MOVFF  88B,01
15E1E:  MOVLB  0
15E20:  GOTO   15E34 (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
15CFE:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
15D00:  BSF    4D.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
15D02:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
15D04:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
15D06:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
15D08:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
15D0A:  BSF    FF2.6
15D0C:  GOTO   15D18 (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
15D10:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
15D12:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
15D14:  BCF    4D.0
....................    set_usart_int(); 
15D16:  BRA    15CFE
....................    kill_wd(); 
15D18:  CALL   311E
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
15D1C:  BSF    FF2.4
....................    sleep();  
15D1E:  MOVFF  FD3,00
15D22:  BCF    FD1.7
15D24:  BCF    FD3.7
15D26:  SLEEP 
15D28:  MOVFF  00,FD3
....................    delay_cycles(1); 
15D2C:  NOP   
15D2E:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
15E24:  MOVLB  8
15E26:  CLRF   x88
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
15E28:  MOVLB  0
15E2A:  RCALL  15D30
....................  
....................    if (TRUE != rtc_alarm) 
15E2C:  BTFSC  4D.0
15E2E:  BRA    15EFE
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
15E30:  RCALL  15D30
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
15E32:  BRA    15DD0
15E34:  MOVFF  01,888
....................       if (WAKE_UP_GOOD == serWakeupReason) 
15E38:  MOVLB  8
15E3A:  MOVF   x88,W
15E3C:  SUBLW  02
15E3E:  BNZ   15EF6
....................       { 
....................          sleep_mode = FALSE; 
15E40:  BCF    4D.1
....................          start_heartbeat(); 
15E42:  MOVLB  0
15E44:  CALL   2928
....................          init_hardware(); 
15E48:  CALL   2962
....................          init_rtc();                      // This is the FAT RTC 
15E4C:  CALL   3530
....................          sd_status = init_sdcard(); 
15E50:  CALL   5062
15E54:  MOVFF  01,2DC
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
15E58:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
15E5A:  MOVLW  01
15E5C:  MOVWF  1E
15E5E:  MOVLW  A7
15E60:  MOVWF  1D
15E62:  MOVLW  0A
15E64:  MOVWF  FF6
15E66:  MOVLW  1B
15E68:  MOVWF  FF7
15E6A:  MOVLW  00
15E6C:  MOVWF  FF8
15E6E:  CALL   50E6
....................          record_event(); 
15E72:  CALL   8502
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15E76:  CLRF   32
15E78:  MOVLW  01
15E7A:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
15E7C:  MOVLW  02
15E7E:  MOVLB  8
15E80:  MOVWF  x89
15E82:  MOVFF  31,88A
15E86:  MOVLB  0
15E88:  CALL   343A
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................           
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
15E8C:  MOVLB  7
15E8E:  MOVF   xCD,F
15E90:  BZ    15EB4
....................             file_list(file_ptr_rel_new); 
15E92:  MOVLW  03
15E94:  MOVLB  8
15E96:  MOVWF  x8A
15E98:  MOVLW  07
15E9A:  MOVWF  x89
15E9C:  MOVLB  0
15E9E:  CALL   BB54
....................             f_unlink(file_ptr_rel_new); 
15EA2:  MOVLW  03
15EA4:  MOVLB  8
15EA6:  MOVWF  x8A
15EA8:  MOVLW  07
15EAA:  MOVWF  x89
15EAC:  MOVLB  0
15EAE:  CALL   BCCE
15EB2:  MOVLB  7
....................          } 
....................          if(sd_status>0) 
15EB4:  MOVLB  2
15EB6:  MOVF   xDC,F
15EB8:  BZ    15EC2
....................          { 
....................             msg_card_fail(); 
15EBA:  MOVLB  0
15EBC:  CALL   50A8
15EC0:  MOVLB  2
....................          } 
....................  
....................           
....................          if (!wakeup_char_is_D){ 
15EC2:  MOVLB  7
15EC4:  MOVF   xCD,F
15EC6:  BNZ   15EEC
....................             fprintf(COM_A, "@RST\r\n"); 
15EC8:  MOVLW  2C
15ECA:  MOVWF  FF6
15ECC:  MOVLW  1B
15ECE:  MOVWF  FF7
15ED0:  MOVLW  00
15ED2:  MOVWF  FF8
15ED4:  CLRF   1B
15ED6:  BTFSC  FF2.7
15ED8:  BSF    1B.7
15EDA:  BCF    FF2.7
15EDC:  MOVLB  0
15EDE:  CALL   0E6E
15EE2:  BTFSC  1B.7
15EE4:  BSF    FF2.7
....................             reset_cpu(); 
15EE6:  RESET
....................          }else{ 
15EE8:  BRA    15EF2
15EEA:  MOVLB  7
....................            //go back to sleep 
....................             wakeup_char_is_D = 0; 
15EEC:  CLRF   xCD
....................             initilizeSleepState(); 
15EEE:  MOVLB  0
15EF0:  RCALL  15D10
....................          } 
....................       } 
15EF2:  BRA    15EFE
15EF4:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
15EF6:  DECFSZ x88,W
15EF8:  BRA    15F00
....................          { 
....................              
....................             initilizeSleepState(); 
15EFA:  MOVLB  0
15EFC:  RCALL  15D10
15EFE:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
15F00:  MOVLW  00
15F02:  BTFSC  4D.0
15F04:  MOVLW  01
15F06:  MOVWF  01
15F08:  MOVLB  0
15F0A:  GOTO   15F14 (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
15F0E:  RCALL  15C94
....................    initilizeSleepState(); 
15F10:  RCALL  15D10
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
15F12:  BRA    15E24
15F14:  DECFSZ 01,W
15F16:  BRA    15F1C
....................       { 
....................          rtc_alarm = FALSE; 
15F18:  BCF    4D.0
....................          break; 
15F1A:  BRA    15F22
....................       } 
....................  
....................       blip(); 
15F1C:  RCALL  15D30
....................       blip(); 
15F1E:  RCALL  15D30
15F20:  BRA    15F12
....................    } 
15F22:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0ABEE:  MOVF   FD0,W
0ABF0:  ANDLW  0F
0ABF2:  BTFSS  FD0.4
0ABF4:  MOVLW  00
0ABF6:  BSF    FD0.0
0ABF8:  BSF    FD0.1
0ABFA:  BSF    FD0.4
0ABFC:  BSF    FD8.3
0ABFE:  BSF    FD8.4
0AC00:  ADDLW  F0
0AC02:  BTFSC  FD8.0
0AC04:  BRA    AE18
0AC06:  ADDLW  10
0AC08:  GOTO   AE1C
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0AC0C:  MOVLW  34
0AC0E:  MOVWF  FF6
0AC10:  MOVLW  1B
0AC12:  MOVWF  FF7
0AC14:  MOVLW  00
0AC16:  MOVWF  FF8
0AC18:  CLRF   1B
0AC1A:  BTFSC  FF2.7
0AC1C:  BSF    1B.7
0AC1E:  BCF    FF2.7
0AC20:  CALL   0E6E
0AC24:  BTFSC  1B.7
0AC26:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0AC28:  MOVLW  01
0AC2A:  MOVWF  1E
0AC2C:  MOVLW  A7
0AC2E:  MOVWF  1D
0AC30:  MOVLW  3C
0AC32:  MOVWF  FF6
0AC34:  MOVLW  1B
0AC36:  MOVWF  FF7
0AC38:  MOVLW  00
0AC3A:  MOVWF  FF8
0AC3C:  CALL   50E6
....................          record_event(); 
0AC40:  CALL   8502
....................          recovery(); 
0AC44:  RCALL  AA80
....................          break; 
0AC46:  BRA    AE18
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AC48:  MOVLW  5A
0AC4A:  MOVWF  FF6
0AC4C:  MOVLW  1B
0AC4E:  MOVWF  FF7
0AC50:  MOVLW  00
0AC52:  MOVWF  FF8
0AC54:  CLRF   1B
0AC56:  BTFSC  FF2.7
0AC58:  BSF    1B.7
0AC5A:  BCF    FF2.7
0AC5C:  CALL   0E6E
0AC60:  BTFSC  1B.7
0AC62:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AC64:  MOVLW  01
0AC66:  MOVWF  1E
0AC68:  MOVLW  A7
0AC6A:  MOVWF  1D
0AC6C:  MOVLW  62
0AC6E:  MOVWF  FF6
0AC70:  MOVLW  1B
0AC72:  MOVWF  FF7
0AC74:  MOVLW  00
0AC76:  MOVWF  FF8
0AC78:  CALL   50E6
....................          record_event(); 
0AC7C:  CALL   8502
....................          recovery(); 
0AC80:  RCALL  AA80
....................          break; 
0AC82:  BRA    AE18
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0AC84:  MOVLW  82
0AC86:  MOVWF  FF6
0AC88:  MOVLW  1B
0AC8A:  MOVWF  FF7
0AC8C:  MOVLW  00
0AC8E:  MOVWF  FF8
0AC90:  CLRF   1B
0AC92:  BTFSC  FF2.7
0AC94:  BSF    1B.7
0AC96:  BCF    FF2.7
0AC98:  CALL   0E6E
0AC9C:  BTFSC  1B.7
0AC9E:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0ACA0:  MOVLW  01
0ACA2:  MOVWF  1E
0ACA4:  MOVLW  A7
0ACA6:  MOVWF  1D
0ACA8:  MOVLW  8A
0ACAA:  MOVWF  FF6
0ACAC:  MOVLW  1B
0ACAE:  MOVWF  FF7
0ACB0:  MOVLW  00
0ACB2:  MOVWF  FF8
0ACB4:  MOVLW  05
0ACB6:  MOVLB  8
0ACB8:  MOVWF  xEB
0ACBA:  MOVLB  0
0ACBC:  RCALL  AAF4
0ACBE:  MOVLW  10
0ACC0:  MOVWF  FE9
0ACC2:  MOVFF  26,8F7
0ACC6:  MOVFF  25,8F6
0ACCA:  RCALL  AB26
0ACCC:  MOVLW  92
0ACCE:  MOVWF  FF6
0ACD0:  MOVLW  1B
0ACD2:  MOVWF  FF7
0ACD4:  MOVLW  00
0ACD6:  MOVWF  FF8
0ACD8:  MOVLW  20
0ACDA:  MOVLB  8
0ACDC:  MOVWF  xEB
0ACDE:  MOVLB  0
0ACE0:  RCALL  AAF4
....................          record_event(); 
0ACE2:  CALL   8502
....................          break; 
0ACE6:  BRA    AE18
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0ACE8:  MOVLW  B4
0ACEA:  MOVWF  FF6
0ACEC:  MOVLW  1B
0ACEE:  MOVWF  FF7
0ACF0:  MOVLW  00
0ACF2:  MOVWF  FF8
0ACF4:  CLRF   1B
0ACF6:  BTFSC  FF2.7
0ACF8:  BSF    1B.7
0ACFA:  BCF    FF2.7
0ACFC:  CALL   0E6E
0AD00:  BTFSC  1B.7
0AD02:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0AD04:  MOVLW  01
0AD06:  MOVWF  1E
0AD08:  MOVLW  A7
0AD0A:  MOVWF  1D
0AD0C:  MOVLW  BC
0AD0E:  MOVWF  FF6
0AD10:  MOVLW  1B
0AD12:  MOVWF  FF7
0AD14:  MOVLW  00
0AD16:  MOVWF  FF8
0AD18:  CALL   50E6
....................          record_event(); 
0AD1C:  CALL   8502
....................          break; 
0AD20:  BRA    AE18
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0AD22:  MOVLW  E0
0AD24:  MOVWF  FF6
0AD26:  MOVLW  1B
0AD28:  MOVWF  FF7
0AD2A:  MOVLW  00
0AD2C:  MOVWF  FF8
0AD2E:  CLRF   1B
0AD30:  BTFSC  FF2.7
0AD32:  BSF    1B.7
0AD34:  BCF    FF2.7
0AD36:  CALL   0E6E
0AD3A:  BTFSC  1B.7
0AD3C:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AD3E:  MOVLW  01
0AD40:  MOVWF  1E
0AD42:  MOVLW  A7
0AD44:  MOVWF  1D
0AD46:  MOVLW  E8
0AD48:  MOVWF  FF6
0AD4A:  MOVLW  1B
0AD4C:  MOVWF  FF7
0AD4E:  MOVLW  00
0AD50:  MOVWF  FF8
0AD52:  CALL   50E6
....................          record_event(); 
0AD56:  CALL   8502
....................          recovery(); 
0AD5A:  RCALL  AA80
....................          break; 
0AD5C:  BRA    AE18
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AD5E:  MOVLW  04
0AD60:  MOVWF  FF6
0AD62:  MOVLW  1C
0AD64:  MOVWF  FF7
0AD66:  MOVLW  00
0AD68:  MOVWF  FF8
0AD6A:  CLRF   1B
0AD6C:  BTFSC  FF2.7
0AD6E:  BSF    1B.7
0AD70:  BCF    FF2.7
0AD72:  CALL   0E6E
0AD76:  BTFSC  1B.7
0AD78:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0AD7A:  MOVLW  01
0AD7C:  MOVWF  1E
0AD7E:  MOVLW  A7
0AD80:  MOVWF  1D
0AD82:  MOVLW  0C
0AD84:  MOVWF  FF6
0AD86:  MOVLW  1C
0AD88:  MOVWF  FF7
0AD8A:  MOVLW  00
0AD8C:  MOVWF  FF8
0AD8E:  CALL   50E6
....................          record_event(); 
0AD92:  CALL   8502
....................          output_bit(RTC_CS, ENABLE); 
0AD96:  BCF    F91.0
....................          spi_write(0x89); 
0AD98:  MOVF   FC9,W
0AD9A:  MOVLW  89
0AD9C:  MOVWF  FC9
0AD9E:  RRCF   FC7,W
0ADA0:  BNC   AD9E
....................          spi_write(0b11111111); 
0ADA2:  MOVF   FC9,W
0ADA4:  SETF   FC9
0ADA6:  RRCF   FC7,W
0ADA8:  BNC   ADA6
....................          output_bit(RTC_CS, DISABLE); 
0ADAA:  BSF    F91.0
....................          output_bit(RTC_CS, ENABLE); 
0ADAC:  BCF    F91.0
....................          spi_read(0x00); 
0ADAE:  MOVF   FC9,W
0ADB0:  CLRF   FC9
0ADB2:  RRCF   FC7,W
0ADB4:  BNC   ADB2
....................          output_bit(RTC_CS, DISABLE); 
0ADB6:  BSF    F91.0
....................          recovery(); 
0ADB8:  RCALL  AA80
....................          break; 
0ADBA:  BRA    AE18
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0ADBC:  MOVLW  2E
0ADBE:  MOVWF  FF6
0ADC0:  MOVLW  1C
0ADC2:  MOVWF  FF7
0ADC4:  MOVLW  00
0ADC6:  MOVWF  FF8
0ADC8:  CLRF   1B
0ADCA:  BTFSC  FF2.7
0ADCC:  BSF    1B.7
0ADCE:  BCF    FF2.7
0ADD0:  CALL   0E6E
0ADD4:  BTFSC  1B.7
0ADD6:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0ADD8:  MOVLW  01
0ADDA:  MOVWF  1E
0ADDC:  MOVLW  A7
0ADDE:  MOVWF  1D
0ADE0:  MOVLW  36
0ADE2:  MOVWF  FF6
0ADE4:  MOVLW  1C
0ADE6:  MOVWF  FF7
0ADE8:  MOVLW  00
0ADEA:  MOVWF  FF8
0ADEC:  CALL   50E6
....................          record_event(); 
0ADF0:  CALL   8502
....................          output_bit(RTC_CS, ENABLE); 
0ADF4:  BCF    F91.0
....................          spi_write(0x89); 
0ADF6:  MOVF   FC9,W
0ADF8:  MOVLW  89
0ADFA:  MOVWF  FC9
0ADFC:  RRCF   FC7,W
0ADFE:  BNC   ADFC
....................          spi_write(0b11111111); 
0AE00:  MOVF   FC9,W
0AE02:  SETF   FC9
0AE04:  RRCF   FC7,W
0AE06:  BNC   AE04
....................          output_bit(RTC_CS, DISABLE); 
0AE08:  BSF    F91.0
....................          output_bit(RTC_CS, ENABLE); 
0AE0A:  BCF    F91.0
....................          spi_read(0x00); 
0AE0C:  MOVF   FC9,W
0AE0E:  CLRF   FC9
0AE10:  RRCF   FC7,W
0AE12:  BNC   AE10
....................          output_bit(RTC_CS, DISABLE); 
0AE14:  BSF    F91.0
....................          recovery(); 
0AE16:  RCALL  AA80
....................          break; 
....................       }         
....................    } 
0AE18:  GOTO   1B928 (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02AE0:  MOVLW  1E
02AE2:  MOVLB  8
02AE4:  MOVWF  x97
02AE6:  MOVLB  0
02AE8:  RCALL  29F2
02AEA:  MOVFF  02,30
02AEE:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02AF2:  MOVLW  1C
02AF4:  MOVLB  8
02AF6:  MOVWF  x97
02AF8:  MOVLB  0
02AFA:  RCALL  29F2
02AFC:  MOVFF  02,20
02B00:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02B04:  MOVLW  16
02B06:  MOVLB  8
02B08:  MOVWF  x97
02B0A:  MOVLB  0
02B0C:  RCALL  29F2
02B0E:  MOVFF  02,22
02B12:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02B16:  MOVLW  14
02B18:  MOVLB  8
02B1A:  MOVWF  x97
02B1C:  MOVLB  0
02B1E:  RCALL  29F2
02B20:  MOVFF  02,24
02B24:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02B28:  MOVLB  8
02B2A:  CLRF   x97
02B2C:  MOVLB  0
02B2E:  RCALL  29F2
02B30:  MOVFF  02,26
02B34:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02B38:  MOVLW  18
02B3A:  MOVLB  8
02B3C:  MOVWF  x97
02B3E:  MOVLB  0
02B40:  RCALL  29F2
02B42:  MOVFF  02,28
02B46:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02B4A:  MOVLW  02
02B4C:  MOVLB  8
02B4E:  MOVWF  xB7
02B50:  MOVLB  0
02B52:  RCALL  2A4C
02B54:  CLRF   32
02B56:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02B5A:  MOVLW  28
02B5C:  MOVLB  8
02B5E:  MOVWF  xB7
02B60:  MOVLB  0
02B62:  RCALL  2A4C
02B64:  CLRF   34
02B66:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02B6A:  MOVLW  12
02B6C:  MOVLB  8
02B6E:  MOVWF  x97
02B70:  MOVLB  0
02B72:  RCALL  29F2
02B74:  MOVFF  02,36
02B78:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02B7C:  MOVLW  3A
02B7E:  MOVLB  8
02B80:  MOVWF  x97
02B82:  MOVLB  0
02B84:  RCALL  29F2
02B86:  MOVFF  02,38
02B8A:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02B8E:  MOVLW  3C
02B90:  MOVLB  8
02B92:  MOVWF  x97
02B94:  MOVLB  0
02B96:  RCALL  29F2
02B98:  MOVFF  02,3E
02B9C:  MOVFF  01,3D
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02BA0:  MOVLW  3E
02BA2:  MOVLB  8
02BA4:  MOVWF  x97
02BA6:  MOVLB  0
02BA8:  RCALL  29F2
02BAA:  MOVFF  02,40
02BAE:  MOVFF  01,3F
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02BB2:  MOVLW  40
02BB4:  MOVLB  8
02BB6:  MOVWF  x97
02BB8:  MOVLB  0
02BBA:  RCALL  29F2
02BBC:  MOVFF  02,42
02BC0:  MOVFF  01,41
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02BC4:  MOVLW  42
02BC6:  MOVLB  8
02BC8:  MOVWF  x97
02BCA:  MOVLB  0
02BCC:  RCALL  29F2
02BCE:  MOVFF  02,44
02BD2:  MOVFF  01,43
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02BD6:  MOVLW  04
02BD8:  MOVLB  8
02BDA:  MOVWF  xB7
02BDC:  MOVLB  0
02BDE:  RCALL  2A4C
02BE0:  MOVFF  01,72D
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02BE4:  MOVLB  8
02BE6:  CLRF   x86
02BE8:  MOVLW  44
02BEA:  MOVWF  x85
02BEC:  MOVLB  0
02BEE:  RCALL  2A72
02BF0:  MOVFF  03,3F8
02BF4:  MOVFF  02,3F7
02BF8:  MOVFF  01,3F6
02BFC:  MOVFF  00,3F5
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02C00:  MOVLB  8
02C02:  CLRF   x86
02C04:  MOVLW  48
02C06:  MOVWF  x85
02C08:  MOVLB  0
02C0A:  RCALL  2A72
02C0C:  MOVFF  03,3FC
02C10:  MOVFF  02,3FB
02C14:  MOVFF  01,3FA
02C18:  MOVFF  00,3F9
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02C1C:  MOVLB  8
02C1E:  CLRF   x86
02C20:  MOVLW  4C
02C22:  MOVWF  x85
02C24:  MOVLB  0
02C26:  RCALL  2A72
02C28:  MOVFF  03,400
02C2C:  MOVFF  02,3FF
02C30:  MOVFF  01,3FE
02C34:  MOVFF  00,3FD
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02C38:  MOVLB  8
02C3A:  CLRF   x86
02C3C:  MOVLW  52
02C3E:  MOVWF  x85
02C40:  MOVLB  0
02C42:  RCALL  2A72
02C44:  MOVFF  03,404
02C48:  MOVFF  02,403
02C4C:  MOVFF  01,402
02C50:  MOVFF  00,401
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02C54:  MOVLB  8
02C56:  CLRF   x86
02C58:  MOVLW  56
02C5A:  MOVWF  x85
02C5C:  MOVLB  0
02C5E:  RCALL  2A72
02C60:  MOVFF  03,408
02C64:  MOVFF  02,407
02C68:  MOVFF  01,406
02C6C:  MOVFF  00,405
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02C70:  MOVLB  8
02C72:  CLRF   x86
02C74:  MOVLW  5A
02C76:  MOVWF  x85
02C78:  MOVLB  0
02C7A:  RCALL  2A72
02C7C:  MOVFF  03,40C
02C80:  MOVFF  02,40B
02C84:  MOVFF  01,40A
02C88:  MOVFF  00,409
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02C8C:  MOVLB  8
02C8E:  CLRF   x86
02C90:  MOVLW  5E
02C92:  MOVWF  x85
02C94:  MOVLB  0
02C96:  RCALL  2A72
02C98:  MOVFF  03,410
02C9C:  MOVFF  02,40F
02CA0:  MOVFF  01,40E
02CA4:  MOVFF  00,40D
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02CA8:  MOVLB  8
02CAA:  CLRF   x86
02CAC:  MOVLW  62
02CAE:  MOVWF  x85
02CB0:  MOVLB  0
02CB2:  RCALL  2A72
02CB4:  MOVFF  03,414
02CB8:  MOVFF  02,413
02CBC:  MOVFF  01,412
02CC0:  MOVFF  00,411
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02CC4:  MOVLW  20
02CC6:  MOVLB  8
02CC8:  MOVWF  x97
02CCA:  MOVLB  0
02CCC:  RCALL  29F2
02CCE:  MOVFF  02,2A
02CD2:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02CD6:  MOVLW  22
02CD8:  MOVLB  8
02CDA:  MOVWF  x97
02CDC:  MOVLB  0
02CDE:  RCALL  29F2
02CE0:  MOVFF  02,2C
02CE4:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02CE8:  MOVLW  24
02CEA:  MOVLB  8
02CEC:  MOVWF  x97
02CEE:  MOVLB  0
02CF0:  RCALL  29F2
02CF2:  MOVFF  02,2E
02CF6:  MOVFF  01,2D
02CFA:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DEDC:  MOVLW  1C
0DEDE:  MOVLB  8
0DEE0:  MOVWF  xEE
0DEE2:  CLRF   xF0
0DEE4:  CLRF   xEF
0DEE6:  MOVLB  0
0DEE8:  CALL   4FFC
....................    write16(ADDR_SAMPLE,0); 
0DEEC:  MOVLW  16
0DEEE:  MOVLB  8
0DEF0:  MOVWF  xEE
0DEF2:  CLRF   xF0
0DEF4:  CLRF   xEF
0DEF6:  MOVLB  0
0DEF8:  CALL   4FFC
....................    write16(ADDR_INTERVAL,60); 
0DEFC:  MOVLW  14
0DEFE:  MOVLB  8
0DF00:  MOVWF  xEE
0DF02:  CLRF   xF0
0DF04:  MOVLW  3C
0DF06:  MOVWF  xEF
0DF08:  MOVLB  0
0DF0A:  CALL   4FFC
....................    write16(ADDR_SERIALNO,9999); 
0DF0E:  MOVLB  8
0DF10:  CLRF   xEE
0DF12:  MOVLW  27
0DF14:  MOVWF  xF0
0DF16:  MOVLW  0F
0DF18:  MOVWF  xEF
0DF1A:  MOVLB  0
0DF1C:  CALL   4FFC
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DF20:  MOVLW  18
0DF22:  MOVLB  8
0DF24:  MOVWF  xEE
0DF26:  MOVLW  0D
0DF28:  MOVWF  xF0
0DF2A:  MOVLW  20
0DF2C:  MOVWF  xEF
0DF2E:  MOVLB  0
0DF30:  CALL   4FFC
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DF34:  MOVLW  02
0DF36:  MOVLB  8
0DF38:  MOVWF  x89
0DF3A:  MOVLW  01
0DF3C:  MOVWF  x8A
0DF3E:  MOVLB  0
0DF40:  CALL   343A
....................    write16(ADDR_MACRO_STEP, 0); 
0DF44:  MOVLW  3A
0DF46:  MOVLB  8
0DF48:  MOVWF  xEE
0DF4A:  CLRF   xF0
0DF4C:  CLRF   xEF
0DF4E:  MOVLB  0
0DF50:  CALL   4FFC
....................    write16(ADDR_COM_ERR,3); 
0DF54:  MOVLW  3C
0DF56:  MOVLB  8
0DF58:  MOVWF  xEE
0DF5A:  CLRF   xF0
0DF5C:  MOVLW  03
0DF5E:  MOVWF  xEF
0DF60:  MOVLB  0
0DF62:  CALL   4FFC
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DF66:  MOVLW  04
0DF68:  MOVLB  8
0DF6A:  MOVWF  x89
0DF6C:  MOVLW  0A
0DF6E:  MOVWF  x8A
0DF70:  MOVLB  0
0DF72:  CALL   343A
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DF76:  MOVLB  8
0DF78:  CLRF   x86
0DF7A:  MOVLW  44
0DF7C:  MOVWF  x85
0DF7E:  CLRF   x8A
0DF80:  CLRF   x89
0DF82:  CLRF   x88
0DF84:  MOVLW  7F
0DF86:  MOVWF  x87
0DF88:  MOVLB  0
0DF8A:  CALL   CD7C
....................    write_float(ADDR_CAL_C1,0); 
0DF8E:  MOVLB  8
0DF90:  CLRF   x86
0DF92:  MOVLW  48
0DF94:  MOVWF  x85
0DF96:  CLRF   x8A
0DF98:  CLRF   x89
0DF9A:  CLRF   x88
0DF9C:  CLRF   x87
0DF9E:  MOVLB  0
0DFA0:  CALL   CD7C
....................    write_float(ADDR_CAL_M2,1); 
0DFA4:  MOVLB  8
0DFA6:  CLRF   x86
0DFA8:  MOVLW  4C
0DFAA:  MOVWF  x85
0DFAC:  CLRF   x8A
0DFAE:  CLRF   x89
0DFB0:  CLRF   x88
0DFB2:  MOVLW  7F
0DFB4:  MOVWF  x87
0DFB6:  MOVLB  0
0DFB8:  CALL   CD7C
....................    write_float(ADDR_CAL_C2,0); 
0DFBC:  MOVLB  8
0DFBE:  CLRF   x86
0DFC0:  MOVLW  52
0DFC2:  MOVWF  x85
0DFC4:  CLRF   x8A
0DFC6:  CLRF   x89
0DFC8:  CLRF   x88
0DFCA:  CLRF   x87
0DFCC:  MOVLB  0
0DFCE:  CALL   CD7C
....................    write_float(ADDR_CAL_M3,1); 
0DFD2:  MOVLB  8
0DFD4:  CLRF   x86
0DFD6:  MOVLW  56
0DFD8:  MOVWF  x85
0DFDA:  CLRF   x8A
0DFDC:  CLRF   x89
0DFDE:  CLRF   x88
0DFE0:  MOVLW  7F
0DFE2:  MOVWF  x87
0DFE4:  MOVLB  0
0DFE6:  CALL   CD7C
....................    write_float(ADDR_CAL_C3,0); 
0DFEA:  MOVLB  8
0DFEC:  CLRF   x86
0DFEE:  MOVLW  5A
0DFF0:  MOVWF  x85
0DFF2:  CLRF   x8A
0DFF4:  CLRF   x89
0DFF6:  CLRF   x88
0DFF8:  CLRF   x87
0DFFA:  MOVLB  0
0DFFC:  CALL   CD7C
....................    write_float(ADDR_CAL_M4,1); 
0E000:  MOVLB  8
0E002:  CLRF   x86
0E004:  MOVLW  5E
0E006:  MOVWF  x85
0E008:  CLRF   x8A
0E00A:  CLRF   x89
0E00C:  CLRF   x88
0E00E:  MOVLW  7F
0E010:  MOVWF  x87
0E012:  MOVLB  0
0E014:  CALL   CD7C
....................    write_float(ADDR_CAL_C4,0);  
0E018:  MOVLB  8
0E01A:  CLRF   x86
0E01C:  MOVLW  62
0E01E:  MOVWF  x85
0E020:  CLRF   x8A
0E022:  CLRF   x89
0E024:  CLRF   x88
0E026:  CLRF   x87
0E028:  MOVLB  0
0E02A:  CALL   CD7C
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0E02E:  MOVLW  40
0E030:  MOVLB  8
0E032:  MOVWF  xEE
0E034:  MOVLW  4E
0E036:  MOVWF  xF0
0E038:  MOVLW  20
0E03A:  MOVWF  xEF
0E03C:  MOVLB  0
0E03E:  CALL   4FFC
....................    write16(ADDR_D2_TEMP,20000); 
0E042:  MOVLW  42
0E044:  MOVLB  8
0E046:  MOVWF  xEE
0E048:  MOVLW  4E
0E04A:  MOVWF  xF0
0E04C:  MOVLW  20
0E04E:  MOVWF  xEF
0E050:  MOVLB  0
0E052:  CALL   4FFC
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0E056:  MOVLW  20
0E058:  MOVLB  8
0E05A:  MOVWF  xEE
0E05C:  CLRF   xF0
0E05E:  CLRF   xEF
0E060:  MOVLB  0
0E062:  CALL   4FFC
....................    write16(ADDR_VOLUME,22500);  
0E066:  MOVLW  22
0E068:  MOVLB  8
0E06A:  MOVWF  xEE
0E06C:  MOVLW  57
0E06E:  MOVWF  xF0
0E070:  MOVLW  E4
0E072:  MOVWF  xEF
0E074:  MOVLB  0
0E076:  CALL   4FFC
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0E07A:  MOVF   2F,W
0E07C:  SUBLW  02
0E07E:  BNZ   E084
0E080:  MOVF   30,F
0E082:  BZ    E098
0E084:  MOVLW  24
0E086:  MOVLB  8
0E088:  MOVWF  xEE
0E08A:  CLRF   xF0
0E08C:  MOVLW  02
0E08E:  MOVWF  xEF
0E090:  MOVLB  0
0E092:  CALL   4FFC
0E096:  BRA    E0AA
....................    else write16(ADDR_PORT,1); 
0E098:  MOVLW  24
0E09A:  MOVLB  8
0E09C:  MOVWF  xEE
0E09E:  CLRF   xF0
0E0A0:  MOVLW  01
0E0A2:  MOVWF  xEF
0E0A4:  MOVLB  0
0E0A6:  CALL   4FFC
....................     
....................    write16(ADDR_DET_TYPE,1); 
0E0AA:  MOVLW  26
0E0AC:  MOVLB  8
0E0AE:  MOVWF  xEE
0E0B0:  CLRF   xF0
0E0B2:  MOVLW  01
0E0B4:  MOVWF  xEF
0E0B6:  MOVLB  0
0E0B8:  CALL   4FFC
....................     
....................    init_nv_vars(); 
0E0BC:  CALL   2AE0
0E0C0:  GOTO   E0DA (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
0FFE6:  MOVLW  02
0FFE8:  MOVWF  FEA
0FFEA:  MOVLW  47
0FFEC:  MOVWF  FE9
0FFEE:  CLRF   00
0FFF0:  CLRF   02
0FFF2:  MOVLW  51
0FFF4:  MOVWF  01
0FFF6:  CALL   354E
0FFFA:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F94C:  MOVLW  03
0F94E:  MOVWF  FEA
0F950:  MOVLW  25
0F952:  MOVWF  FE9
0F954:  CLRF   00
0F956:  CLRF   02
0F958:  MOVLW  14
0F95A:  MOVWF  01
0F95C:  CALL   354E
0F960:  GOTO   F980 (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
1335E:  MOVLB  8
13360:  CLRF   xD4
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
13362:  CLRF   FEA
13364:  MOVLW  52
13366:  MOVWF  FE9
13368:  CLRF   00
1336A:  CLRF   02
1336C:  MOVLW  14
1336E:  MOVWF  01
13370:  MOVLB  0
13372:  CALL   354E
....................  
....................    for(n=0; n<20; n++) { 
13376:  MOVLB  8
13378:  CLRF   xD5
1337A:  MOVF   xD5,W
1337C:  SUBLW  13
1337E:  BNC   133C4
....................         c = data_buffer[string_pos];  
13380:  CLRF   03
13382:  MOVLB  2
13384:  MOVF   x98,W
13386:  ADDLW  67
13388:  MOVWF  FE9
1338A:  MOVLW  00
1338C:  ADDWFC 03,W
1338E:  MOVWF  FEA
13390:  MOVFF  FEF,8D4
....................         ++string_pos; 
13394:  INCF   x98,F
....................         if (c == '\0') return(1); // found end 
13396:  MOVLB  8
13398:  MOVF   xD4,F
1339A:  BNZ   133A2
1339C:  MOVLW  01
1339E:  MOVWF  01
133A0:  BRA    133C8
....................         if (c == ',')  return(0); // found seperator  
133A2:  MOVF   xD4,W
133A4:  SUBLW  2C
133A6:  BNZ   133AE
133A8:  MOVLW  00
133AA:  MOVWF  01
133AC:  BRA    133C8
....................         sub_string[n] = c; 
133AE:  CLRF   03
133B0:  MOVF   xD5,W
133B2:  ADDLW  52
133B4:  MOVWF  FE9
133B6:  MOVLW  00
133B8:  ADDWFC 03,W
133BA:  MOVWF  FEA
133BC:  MOVFF  8D4,FEF
133C0:  INCF   xD5,F
133C2:  BRA    1337A
....................    } 
....................     
....................    return(2); // failed = bad string 
133C4:  MOVLW  02
133C6:  MOVWF  01
133C8:  MOVLB  0
133CA:  GOTO   136F4 (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
13608:  MOVLW  5A
1360A:  MOVWF  FF6
1360C:  MOVLW  1C
1360E:  MOVWF  FF7
13610:  MOVLW  00
13612:  MOVWF  FF8
13614:  MOVLW  03
13616:  MOVWF  FEA
13618:  MOVLW  3D
1361A:  MOVWF  FE9
1361C:  CALL   FE92
13620:  MOVF   01,W
13622:  BZ    13636
13624:  XORLW  01
13626:  BZ    13656
13628:  XORLW  03
1362A:  BZ    13676
1362C:  XORLW  01
1362E:  BZ    13696
13630:  XORLW  07
13632:  BZ    136B6
13634:  BRA    136D4
....................       case "NO3" : NO3_array[read_i] = result; 
13636:  BCF    FD8.0
13638:  MOVLB  3
1363A:  RLCF   x4A,W
1363C:  CLRF   03
1363E:  ADDLW  4B
13640:  MOVWF  FE9
13642:  MOVLW  03
13644:  ADDWFC 03,W
13646:  MOVWF  FEA
13648:  MOVFF  8D5,FEC
1364C:  MOVF   FED,F
1364E:  MOVFF  8D4,FEF
....................          break; 
13652:  MOVLB  0
13654:  BRA    136D4
....................       case "NO2" : NO2_array[read_i] = result; 
13656:  BCF    FD8.0
13658:  MOVLB  3
1365A:  RLCF   x4A,W
1365C:  CLRF   03
1365E:  ADDLW  5D
13660:  MOVWF  FE9
13662:  MOVLW  03
13664:  ADDWFC 03,W
13666:  MOVWF  FEA
13668:  MOVFF  8D5,FEC
1366C:  MOVF   FED,F
1366E:  MOVFF  8D4,FEF
....................          break;    
13672:  MOVLB  0
13674:  BRA    136D4
....................       case "PO4" : PO4_array[read_i] = result; 
13676:  BCF    FD8.0
13678:  MOVLB  3
1367A:  RLCF   x4A,W
1367C:  CLRF   03
1367E:  ADDLW  6F
13680:  MOVWF  FE9
13682:  MOVLW  03
13684:  ADDWFC 03,W
13686:  MOVWF  FEA
13688:  MOVFF  8D5,FEC
1368C:  MOVF   FED,F
1368E:  MOVFF  8D4,FEF
....................          break; 
13692:  MOVLB  0
13694:  BRA    136D4
....................       case "NH4" : NH4_array[read_i] = result; 
13696:  BCF    FD8.0
13698:  MOVLB  3
1369A:  RLCF   x4A,W
1369C:  CLRF   03
1369E:  ADDLW  81
136A0:  MOVWF  FE9
136A2:  MOVLW  03
136A4:  ADDWFC 03,W
136A6:  MOVWF  FEA
136A8:  MOVFF  8D5,FEC
136AC:  MOVF   FED,F
136AE:  MOVFF  8D4,FEF
....................          break; 
136B2:  MOVLB  0
136B4:  BRA    136D4
....................       case "SiO" : SiO_array[read_i] = result; 
136B6:  BCF    FD8.0
136B8:  MOVLB  3
136BA:  RLCF   x4A,W
136BC:  CLRF   03
136BE:  ADDLW  93
136C0:  MOVWF  FE9
136C2:  MOVLW  03
136C4:  ADDWFC 03,W
136C6:  MOVWF  FEA
136C8:  MOVFF  8D5,FEC
136CC:  MOVF   FED,F
136CE:  MOVFF  8D4,FEF
....................          break; 
136D2:  MOVLB  0
....................    } 
136D4:  GOTO   1374C (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
136D8:  MOVLB  8
136DA:  CLRF   xCF
136DC:  CLRF   xCE
136DE:  CLRF   xD1
136E0:  CLRF   xD0
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
136E2:  MOVLB  2
136E4:  CLRF   x98
....................     
....................    for (n=0; n<11; ++n){ 
136E6:  MOVLB  8
136E8:  CLRF   xD2
136EA:  MOVF   xD2,W
136EC:  SUBLW  0A
136EE:  BNC   13740
....................       parsed = parse_string(); 
136F0:  MOVLB  0
136F2:  BRA    1335E
136F4:  MOVFF  01,8D3
....................       if (parsed == 2) return(0); 
136F8:  MOVLB  8
136FA:  MOVF   xD3,W
136FC:  SUBLW  02
136FE:  BNZ   13708
13700:  MOVLW  00
13702:  MOVWF  01
13704:  MOVWF  02
13706:  BRA    13756
....................       if (n==8) result = atol(sub_string); 
13708:  MOVF   xD2,W
1370A:  SUBLW  08
1370C:  BNZ   13722
1370E:  CLRF   xD5
13710:  MOVLW  52
13712:  MOVWF  xD4
13714:  MOVLB  0
13716:  RCALL  13424
13718:  MOVFF  02,8CF
1371C:  MOVFF  01,8CE
13720:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
13722:  MOVF   xD2,W
13724:  SUBLW  0A
13726:  BNZ   1373C
13728:  CLRF   xD5
1372A:  MOVLW  52
1372C:  MOVWF  xD4
1372E:  MOVLB  0
13730:  RCALL  13424
13732:  MOVFF  02,8D1
13736:  MOVFF  01,8D0
1373A:  MOVLB  8
1373C:  INCF   xD2,F
1373E:  BRA    136EA
....................    } 
....................    load_parsed_data(result); 
13740:  MOVFF  8CF,8D5
13744:  MOVFF  8CE,8D4
13748:  MOVLB  0
1374A:  BRA    13608
....................    return (temp); 
1374C:  MOVLB  8
1374E:  MOVFF  8D0,01
13752:  MOVFF  8D1,02
13756:  MOVLB  0
13758:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D558:  CLRF   FEA
0D55A:  MOVLW  67
0D55C:  MOVWF  FE9
0D55E:  CLRF   00
0D560:  CLRF   02
0D562:  MOVLW  A0
0D564:  MOVWF  01
0D566:  CALL   354E
0D56A:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F964:  MOVLW  03
0F966:  MOVWF  FEA
0F968:  MOVLW  3D
0F96A:  MOVWF  FE9
0F96C:  MOVLW  00
0F96E:  CALL   02E4
0F972:  TBLRD*-
0F974:  TBLRD*+
0F976:  MOVF   FF5,W
0F978:  MOVWF  FEE
0F97A:  IORLW  00
0F97C:  BNZ   F974
....................  
....................    clear_flag_str(); 
0F97E:  BRA    F94C
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F980:  MOVLW  08
0F982:  MOVWF  1E
0F984:  MOVLW  ED
0F986:  MOVWF  1D
0F988:  MOVLW  10
0F98A:  MOVWF  FE9
0F98C:  MOVFF  324,8F7
0F990:  MOVFF  323,8F6
0F994:  CALL   AB26
....................  
....................    if (macro_flag < 100) { 
0F998:  MOVLB  3
0F99A:  MOVF   x24,F
0F99C:  BNZ   F9B6
0F99E:  MOVF   x23,W
0F9A0:  SUBLW  63
0F9A2:  BNC   F9B6
....................       temp_str[3] = '\0'; 
0F9A4:  MOVLB  8
0F9A6:  CLRF   xF0
....................       temp_str[2] = temp_str[1]; 
0F9A8:  MOVFF  8EE,8EF
....................       temp_str[1] = temp_str[0]; 
0F9AC:  MOVFF  8ED,8EE
....................       temp_str[0] = '0'; 
0F9B0:  MOVLW  30
0F9B2:  MOVWF  xED
0F9B4:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F9B6:  MOVLB  8
0F9B8:  MOVF   xED,W
0F9BA:  XORLW  30
0F9BC:  MOVLB  0
0F9BE:  BZ    F9E2
0F9C0:  XORLW  01
0F9C2:  BZ    FA08
0F9C4:  XORLW  03
0F9C6:  BZ    FA2E
0F9C8:  XORLW  01
0F9CA:  BZ    FA54
0F9CC:  XORLW  07
0F9CE:  BZ    FA7A
0F9D0:  XORLW  01
0F9D2:  BZ    FAA0
0F9D4:  XORLW  03
0F9D6:  BTFSC  FD8.2
0F9D8:  BRA    FAC6
0F9DA:  XORLW  01
0F9DC:  BTFSC  FD8.2
0F9DE:  BRA    FAEC
0F9E0:  BRA    FB14
....................       case '0' : strcopy(chem,"NO3"); 
0F9E2:  MOVLW  03
0F9E4:  MOVWF  FEA
0F9E6:  MOVLW  3D
0F9E8:  MOVWF  FE9
0F9EA:  MOVLW  00
0F9EC:  CALL   02FC
0F9F0:  TBLRD*-
0F9F2:  TBLRD*+
0F9F4:  MOVF   FF5,W
0F9F6:  MOVWF  FEE
0F9F8:  IORLW  00
0F9FA:  BNZ   F9F2
....................                  wave_l=543; 
0F9FC:  MOVLW  02
0F9FE:  MOVLB  8
0FA00:  MOVWF  xEC
0FA02:  MOVLW  1F
0FA04:  MOVWF  xEB
....................          break; 
0FA06:  BRA    FB38
....................       case '1' : strcopy(chem,"PO4"); 
0FA08:  MOVLW  03
0FA0A:  MOVWF  FEA
0FA0C:  MOVLW  3D
0FA0E:  MOVWF  FE9
0FA10:  MOVLW  00
0FA12:  CALL   0314
0FA16:  TBLRD*-
0FA18:  TBLRD*+
0FA1A:  MOVF   FF5,W
0FA1C:  MOVWF  FEE
0FA1E:  IORLW  00
0FA20:  BNZ   FA18
....................                  wave_l=880;       
0FA22:  MOVLW  03
0FA24:  MOVLB  8
0FA26:  MOVWF  xEC
0FA28:  MOVLW  70
0FA2A:  MOVWF  xEB
....................          break; 
0FA2C:  BRA    FB38
....................       case '2' : strcopy(chem,"NH4"); 
0FA2E:  MOVLW  03
0FA30:  MOVWF  FEA
0FA32:  MOVLW  3D
0FA34:  MOVWF  FE9
0FA36:  MOVLW  00
0FA38:  CALL   032C
0FA3C:  TBLRD*-
0FA3E:  TBLRD*+
0FA40:  MOVF   FF5,W
0FA42:  MOVWF  FEE
0FA44:  IORLW  00
0FA46:  BNZ   FA3E
....................                  wave_l=660;       
0FA48:  MOVLW  02
0FA4A:  MOVLB  8
0FA4C:  MOVWF  xEC
0FA4E:  MOVLW  94
0FA50:  MOVWF  xEB
....................          break; 
0FA52:  BRA    FB38
....................       case '3' : strcopy(chem,"SiO"); 
0FA54:  MOVLW  03
0FA56:  MOVWF  FEA
0FA58:  MOVLW  3D
0FA5A:  MOVWF  FE9
0FA5C:  MOVLW  00
0FA5E:  CALL   0344
0FA62:  TBLRD*-
0FA64:  TBLRD*+
0FA66:  MOVF   FF5,W
0FA68:  MOVWF  FEE
0FA6A:  IORLW  00
0FA6C:  BNZ   FA64
....................                  wave_l=810;       
0FA6E:  MOVLW  03
0FA70:  MOVLB  8
0FA72:  MOVWF  xEC
0FA74:  MOVLW  2A
0FA76:  MOVWF  xEB
....................          break; 
0FA78:  BRA    FB38
....................       case '4' : strcopy(chem,"Ure"); 
0FA7A:  MOVLW  03
0FA7C:  MOVWF  FEA
0FA7E:  MOVLW  3D
0FA80:  MOVWF  FE9
0FA82:  MOVLW  00
0FA84:  CALL   035C
0FA88:  TBLRD*-
0FA8A:  TBLRD*+
0FA8C:  MOVF   FF5,W
0FA8E:  MOVWF  FEE
0FA90:  IORLW  00
0FA92:  BNZ   FA8A
....................                  wave_l=525;       
0FA94:  MOVLW  02
0FA96:  MOVLB  8
0FA98:  MOVWF  xEC
0FA9A:  MOVLW  0D
0FA9C:  MOVWF  xEB
....................          break; 
0FA9E:  BRA    FB38
....................       case '5' : strcopy(chem,"NO2"); 
0FAA0:  MOVLW  03
0FAA2:  MOVWF  FEA
0FAA4:  MOVLW  3D
0FAA6:  MOVWF  FE9
0FAA8:  MOVLW  00
0FAAA:  CALL   0374
0FAAE:  TBLRD*-
0FAB0:  TBLRD*+
0FAB2:  MOVF   FF5,W
0FAB4:  MOVWF  FEE
0FAB6:  IORLW  00
0FAB8:  BNZ   FAB0
....................                  wave_l=543;       
0FABA:  MOVLW  02
0FABC:  MOVLB  8
0FABE:  MOVWF  xEC
0FAC0:  MOVLW  1F
0FAC2:  MOVWF  xEB
....................          break; 
0FAC4:  BRA    FB38
....................       case '6' : strcopy(chem,"Fe_"); 
0FAC6:  MOVLW  03
0FAC8:  MOVWF  FEA
0FACA:  MOVLW  3D
0FACC:  MOVWF  FE9
0FACE:  MOVLW  00
0FAD0:  CALL   038C
0FAD4:  TBLRD*-
0FAD6:  TBLRD*+
0FAD8:  MOVF   FF5,W
0FADA:  MOVWF  FEE
0FADC:  IORLW  00
0FADE:  BNZ   FAD6
....................                  wave_l=543;       
0FAE0:  MOVLW  02
0FAE2:  MOVLB  8
0FAE4:  MOVWF  xEC
0FAE6:  MOVLW  1F
0FAE8:  MOVWF  xEB
....................          break; 
0FAEA:  BRA    FB38
....................       case '7' : strcopy(chem,"Cl_"); 
0FAEC:  MOVLW  03
0FAEE:  MOVWF  FEA
0FAF0:  MOVLW  3D
0FAF2:  MOVWF  FE9
0FAF4:  MOVLW  00
0FAF6:  CALL   03A4
0FAFA:  TBLRD*-
0FAFC:  TBLRD*+
0FAFE:  MOVF   FF5,W
0FB00:  MOVWF  FEE
0FB02:  IORLW  00
0FB04:  BNZ   FAFC
....................                  wave_l=560;       
0FB06:  MOVLW  02
0FB08:  MOVLB  8
0FB0A:  MOVWF  xEC
0FB0C:  MOVLW  30
0FB0E:  MOVWF  xEB
....................          break; 
0FB10:  BRA    FB38
0FB12:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0FB14:  MOVLW  03
0FB16:  MOVWF  FEA
0FB18:  MOVLW  3D
0FB1A:  MOVWF  FE9
0FB1C:  MOVLW  00
0FB1E:  CALL   02E4
0FB22:  TBLRD*-
0FB24:  TBLRD*+
0FB26:  MOVF   FF5,W
0FB28:  MOVWF  FEE
0FB2A:  IORLW  00
0FB2C:  BNZ   FB24
....................                  wave_l=999;       
0FB2E:  MOVLW  03
0FB30:  MOVLB  8
0FB32:  MOVWF  xEC
0FB34:  MOVLW  E7
0FB36:  MOVWF  xEB
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0FB38:  MOVF   xEE,W
0FB3A:  XORLW  31
0FB3C:  MOVLB  0
0FB3E:  BZ    FB5E
0FB40:  XORLW  03
0FB42:  BZ    FB7A
0FB44:  XORLW  01
0FB46:  BZ    FB96
0FB48:  XORLW  07
0FB4A:  BZ    FBB2
0FB4C:  XORLW  01
0FB4E:  BZ    FBCE
0FB50:  XORLW  03
0FB52:  BZ    FBEA
0FB54:  XORLW  01
0FB56:  BZ    FC06
0FB58:  XORLW  0F
0FB5A:  BZ    FC22
0FB5C:  BRA    FC3E
....................       case '1' : strcopy(anal,"Smp"); 
0FB5E:  MOVLW  03
0FB60:  MOVWF  FEA
0FB62:  MOVLW  42
0FB64:  MOVWF  FE9
0FB66:  MOVLW  00
0FB68:  CALL   03BC
0FB6C:  TBLRD*-
0FB6E:  TBLRD*+
0FB70:  MOVF   FF5,W
0FB72:  MOVWF  FEE
0FB74:  IORLW  00
0FB76:  BNZ   FB6E
....................          break; 
0FB78:  BRA    FC58
....................       case '2' : strcopy(anal,"Std"); 
0FB7A:  MOVLW  03
0FB7C:  MOVWF  FEA
0FB7E:  MOVLW  42
0FB80:  MOVWF  FE9
0FB82:  MOVLW  00
0FB84:  CALL   03D4
0FB88:  TBLRD*-
0FB8A:  TBLRD*+
0FB8C:  MOVF   FF5,W
0FB8E:  MOVWF  FEE
0FB90:  IORLW  00
0FB92:  BNZ   FB8A
....................          break; 
0FB94:  BRA    FC58
....................       case '3' : strcopy(anal,"Cmb"); 
0FB96:  MOVLW  03
0FB98:  MOVWF  FEA
0FB9A:  MOVLW  42
0FB9C:  MOVWF  FE9
0FB9E:  MOVLW  00
0FBA0:  CALL   03EC
0FBA4:  TBLRD*-
0FBA6:  TBLRD*+
0FBA8:  MOVF   FF5,W
0FBAA:  MOVWF  FEE
0FBAC:  IORLW  00
0FBAE:  BNZ   FBA6
....................          break; 
0FBB0:  BRA    FC58
....................       case '4' : strcopy(anal,"Tst"); 
0FBB2:  MOVLW  03
0FBB4:  MOVWF  FEA
0FBB6:  MOVLW  42
0FBB8:  MOVWF  FE9
0FBBA:  MOVLW  00
0FBBC:  CALL   0404
0FBC0:  TBLRD*-
0FBC2:  TBLRD*+
0FBC4:  MOVF   FF5,W
0FBC6:  MOVWF  FEE
0FBC8:  IORLW  00
0FBCA:  BNZ   FBC2
....................          break; 
0FBCC:  BRA    FC58
....................       case '5' : strcopy(anal,"Rbl"); 
0FBCE:  MOVLW  03
0FBD0:  MOVWF  FEA
0FBD2:  MOVLW  42
0FBD4:  MOVWF  FE9
0FBD6:  MOVLW  00
0FBD8:  CALL   041C
0FBDC:  TBLRD*-
0FBDE:  TBLRD*+
0FBE0:  MOVF   FF5,W
0FBE2:  MOVWF  FEE
0FBE4:  IORLW  00
0FBE6:  BNZ   FBDE
....................          break; 
0FBE8:  BRA    FC58
....................       case '6' : strcopy(anal,"Cal"); 
0FBEA:  MOVLW  03
0FBEC:  MOVWF  FEA
0FBEE:  MOVLW  42
0FBF0:  MOVWF  FE9
0FBF2:  MOVLW  00
0FBF4:  CALL   0434
0FBF8:  TBLRD*-
0FBFA:  TBLRD*+
0FBFC:  MOVF   FF5,W
0FBFE:  MOVWF  FEE
0FC00:  IORLW  00
0FC02:  BNZ   FBFA
....................          break; 
0FC04:  BRA    FC58
....................       case '7' : strcopy(anal,"Fls"); 
0FC06:  MOVLW  03
0FC08:  MOVWF  FEA
0FC0A:  MOVLW  42
0FC0C:  MOVWF  FE9
0FC0E:  MOVLW  00
0FC10:  CALL   044C
0FC14:  TBLRD*-
0FC16:  TBLRD*+
0FC18:  MOVF   FF5,W
0FC1A:  MOVWF  FEE
0FC1C:  IORLW  00
0FC1E:  BNZ   FC16
....................          break; 
0FC20:  BRA    FC58
....................       case '8' : strcopy(anal,"Utl"); 
0FC22:  MOVLW  03
0FC24:  MOVWF  FEA
0FC26:  MOVLW  42
0FC28:  MOVWF  FE9
0FC2A:  MOVLW  00
0FC2C:  CALL   0464
0FC30:  TBLRD*-
0FC32:  TBLRD*+
0FC34:  MOVF   FF5,W
0FC36:  MOVWF  FEE
0FC38:  IORLW  00
0FC3A:  BNZ   FC32
....................          break;     
0FC3C:  BRA    FC58
....................       default  : strcopy(anal,"XXX"); 
0FC3E:  MOVLW  03
0FC40:  MOVWF  FEA
0FC42:  MOVLW  42
0FC44:  MOVWF  FE9
0FC46:  MOVLW  00
0FC48:  CALL   02E4
0FC4C:  TBLRD*-
0FC4E:  TBLRD*+
0FC50:  MOVF   FF5,W
0FC52:  MOVWF  FEE
0FC54:  IORLW  00
0FC56:  BNZ   FC4E
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0FC58:  MOVLB  8
0FC5A:  MOVF   xEF,W
0FC5C:  XORLW  31
0FC5E:  MOVLB  0
0FC60:  BZ    FC8A
0FC62:  XORLW  03
0FC64:  BZ    FCAA
0FC66:  XORLW  01
0FC68:  BZ    FCCC
0FC6A:  XORLW  07
0FC6C:  BZ    FCEE
0FC6E:  XORLW  01
0FC70:  BZ    FD10
0FC72:  XORLW  03
0FC74:  BZ    FD32
0FC76:  XORLW  01
0FC78:  BTFSC  FD8.2
0FC7A:  BRA    FD54
0FC7C:  XORLW  0F
0FC7E:  BTFSC  FD8.2
0FC80:  BRA    FD76
0FC82:  XORLW  01
0FC84:  BTFSC  FD8.2
0FC86:  BRA    FD98
0FC88:  BRA    FDBC
....................       case '1' : strcopy(read_t,"I0s"); 
0FC8A:  MOVLW  03
0FC8C:  MOVWF  FEA
0FC8E:  MOVLW  46
0FC90:  MOVWF  FE9
0FC92:  MOVLW  00
0FC94:  CALL   047C
0FC98:  TBLRD*-
0FC9A:  TBLRD*+
0FC9C:  MOVF   FF5,W
0FC9E:  MOVWF  FEE
0FCA0:  IORLW  00
0FCA2:  BNZ   FC9A
....................                  read_i = 0; 
0FCA4:  MOVLB  3
0FCA6:  CLRF   x4A
....................          break; 
0FCA8:  BRA    FDDA
....................       case '2' : strcopy(read_t,"I1s"); 
0FCAA:  MOVLW  03
0FCAC:  MOVWF  FEA
0FCAE:  MOVLW  46
0FCB0:  MOVWF  FE9
0FCB2:  MOVLW  00
0FCB4:  CALL   0494
0FCB8:  TBLRD*-
0FCBA:  TBLRD*+
0FCBC:  MOVF   FF5,W
0FCBE:  MOVWF  FEE
0FCC0:  IORLW  00
0FCC2:  BNZ   FCBA
....................                  read_i = 1;       
0FCC4:  MOVLW  01
0FCC6:  MOVLB  3
0FCC8:  MOVWF  x4A
....................          break; 
0FCCA:  BRA    FDDA
....................       case '3' : strcopy(read_t,"I0t"); 
0FCCC:  MOVLW  03
0FCCE:  MOVWF  FEA
0FCD0:  MOVLW  46
0FCD2:  MOVWF  FE9
0FCD4:  MOVLW  00
0FCD6:  CALL   04AC
0FCDA:  TBLRD*-
0FCDC:  TBLRD*+
0FCDE:  MOVF   FF5,W
0FCE0:  MOVWF  FEE
0FCE2:  IORLW  00
0FCE4:  BNZ   FCDC
....................                  read_i = 2;       
0FCE6:  MOVLW  02
0FCE8:  MOVLB  3
0FCEA:  MOVWF  x4A
....................          break; 
0FCEC:  BRA    FDDA
....................       case '4' : strcopy(read_t,"I1t"); 
0FCEE:  MOVLW  03
0FCF0:  MOVWF  FEA
0FCF2:  MOVLW  46
0FCF4:  MOVWF  FE9
0FCF6:  MOVLW  00
0FCF8:  CALL   04C4
0FCFC:  TBLRD*-
0FCFE:  TBLRD*+
0FD00:  MOVF   FF5,W
0FD02:  MOVWF  FEE
0FD04:  IORLW  00
0FD06:  BNZ   FCFE
....................                  read_i = 3;       
0FD08:  MOVLW  03
0FD0A:  MOVLB  3
0FD0C:  MOVWF  x4A
....................          break; 
0FD0E:  BRA    FDDA
....................       case '5' : strcopy(read_t,"I0r"); 
0FD10:  MOVLW  03
0FD12:  MOVWF  FEA
0FD14:  MOVLW  46
0FD16:  MOVWF  FE9
0FD18:  MOVLW  00
0FD1A:  CALL   04DC
0FD1E:  TBLRD*-
0FD20:  TBLRD*+
0FD22:  MOVF   FF5,W
0FD24:  MOVWF  FEE
0FD26:  IORLW  00
0FD28:  BNZ   FD20
....................                  read_i = 4;       
0FD2A:  MOVLW  04
0FD2C:  MOVLB  3
0FD2E:  MOVWF  x4A
....................          break; 
0FD30:  BRA    FDDA
....................       case '6' : strcopy(read_t,"I1r"); 
0FD32:  MOVLW  03
0FD34:  MOVWF  FEA
0FD36:  MOVLW  46
0FD38:  MOVWF  FE9
0FD3A:  MOVLW  00
0FD3C:  CALL   04F4
0FD40:  TBLRD*-
0FD42:  TBLRD*+
0FD44:  MOVF   FF5,W
0FD46:  MOVWF  FEE
0FD48:  IORLW  00
0FD4A:  BNZ   FD42
....................                  read_i = 5;       
0FD4C:  MOVLW  05
0FD4E:  MOVLB  3
0FD50:  MOVWF  x4A
....................          break; 
0FD52:  BRA    FDDA
....................       case '7' : strcopy(read_t,"I0u"); 
0FD54:  MOVLW  03
0FD56:  MOVWF  FEA
0FD58:  MOVLW  46
0FD5A:  MOVWF  FE9
0FD5C:  MOVLW  00
0FD5E:  CALL   050C
0FD62:  TBLRD*-
0FD64:  TBLRD*+
0FD66:  MOVF   FF5,W
0FD68:  MOVWF  FEE
0FD6A:  IORLW  00
0FD6C:  BNZ   FD64
....................                  read_i = 6;       
0FD6E:  MOVLW  06
0FD70:  MOVLB  3
0FD72:  MOVWF  x4A
....................          break; 
0FD74:  BRA    FDDA
....................       case '8' : strcopy(read_t,"I1u"); 
0FD76:  MOVLW  03
0FD78:  MOVWF  FEA
0FD7A:  MOVLW  46
0FD7C:  MOVWF  FE9
0FD7E:  MOVLW  00
0FD80:  CALL   0524
0FD84:  TBLRD*-
0FD86:  TBLRD*+
0FD88:  MOVF   FF5,W
0FD8A:  MOVWF  FEE
0FD8C:  IORLW  00
0FD8E:  BNZ   FD86
....................                  read_i = 7;       
0FD90:  MOVLW  07
0FD92:  MOVLB  3
0FD94:  MOVWF  x4A
....................          break; 
0FD96:  BRA    FDDA
....................       case '9' : strcopy(read_t,"Chk"); 
0FD98:  MOVLW  03
0FD9A:  MOVWF  FEA
0FD9C:  MOVLW  46
0FD9E:  MOVWF  FE9
0FDA0:  MOVLW  00
0FDA2:  CALL   053C
0FDA6:  TBLRD*-
0FDA8:  TBLRD*+
0FDAA:  MOVF   FF5,W
0FDAC:  MOVWF  FEE
0FDAE:  IORLW  00
0FDB0:  BNZ   FDA8
....................                  read_i = 8;       
0FDB2:  MOVLW  08
0FDB4:  MOVLB  3
0FDB6:  MOVWF  x4A
....................          break;        
0FDB8:  BRA    FDDA
0FDBA:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0FDBC:  MOVLW  03
0FDBE:  MOVWF  FEA
0FDC0:  MOVLW  46
0FDC2:  MOVWF  FE9
0FDC4:  MOVLW  00
0FDC6:  CALL   0554
0FDCA:  TBLRD*-
0FDCC:  TBLRD*+
0FDCE:  MOVF   FF5,W
0FDD0:  MOVWF  FEE
0FDD2:  IORLW  00
0FDD4:  BNZ   FDCC
....................                  read_i = 0;       
0FDD6:  MOVLB  3
0FDD8:  CLRF   x4A
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FDDA:  MOVLW  03
0FDDC:  MOVLB  8
0FDDE:  MOVWF  xF9
0FDE0:  MOVLW  25
0FDE2:  MOVWF  xF8
0FDE4:  MOVLW  03
0FDE6:  MOVWF  xFB
0FDE8:  MOVLW  3D
0FDEA:  MOVWF  xFA
0FDEC:  MOVLB  0
0FDEE:  CALL   5506
....................    strcat(flag_str, (char *)","); 
0FDF2:  MOVLW  2C
0FDF4:  MOVLB  8
0FDF6:  MOVWF  xF4
0FDF8:  CLRF   xF5
0FDFA:  MOVLW  03
0FDFC:  MOVWF  xF9
0FDFE:  MOVLW  25
0FE00:  MOVWF  xF8
0FE02:  MOVLW  08
0FE04:  MOVWF  xFB
0FE06:  MOVLW  F4
0FE08:  MOVWF  xFA
0FE0A:  MOVLB  0
0FE0C:  CALL   5506
....................    strcat(flag_str, anal); 
0FE10:  MOVLW  03
0FE12:  MOVLB  8
0FE14:  MOVWF  xF9
0FE16:  MOVLW  25
0FE18:  MOVWF  xF8
0FE1A:  MOVLW  03
0FE1C:  MOVWF  xFB
0FE1E:  MOVLW  42
0FE20:  MOVWF  xFA
0FE22:  MOVLB  0
0FE24:  CALL   5506
....................    strcat(flag_str, (char *)","); 
0FE28:  MOVLW  2C
0FE2A:  MOVLB  8
0FE2C:  MOVWF  xF4
0FE2E:  CLRF   xF5
0FE30:  MOVLW  03
0FE32:  MOVWF  xF9
0FE34:  MOVLW  25
0FE36:  MOVWF  xF8
0FE38:  MOVLW  08
0FE3A:  MOVWF  xFB
0FE3C:  MOVLW  F4
0FE3E:  MOVWF  xFA
0FE40:  MOVLB  0
0FE42:  CALL   5506
....................    strcat(flag_str, read_t);   
0FE46:  MOVLW  03
0FE48:  MOVLB  8
0FE4A:  MOVWF  xF9
0FE4C:  MOVLW  25
0FE4E:  MOVWF  xF8
0FE50:  MOVLW  03
0FE52:  MOVWF  xFB
0FE54:  MOVLW  46
0FE56:  MOVWF  xFA
0FE58:  MOVLB  0
0FE5A:  CALL   5506
....................     
....................    return wave_l; 
0FE5E:  MOVLB  8
0FE60:  MOVFF  8EB,01
0FE64:  MOVFF  8EC,02
0FE68:  MOVLB  0
0FE6A:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F432:  MOVF   47,W
0F434:  SUBLW  4B
0F436:  BTFSC  FD8.2
0F438:  MOVFF  48,2D6
....................    if (cmd=='L') detector_li = arg; 
0F43C:  MOVF   47,W
0F43E:  SUBLW  4C
0F440:  BNZ   F44A
0F442:  MOVFF  49,2D8
0F446:  MOVFF  48,2D7
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F44A:  MOVF   1F,W
0F44C:  SUBLW  04
0F44E:  BNZ   F518
0F450:  MOVF   20,F
0F452:  BNZ   F518
0F454:  MOVLW  70
0F456:  MOVWF  FF6
0F458:  MOVLW  1C
0F45A:  MOVWF  FF7
0F45C:  MOVLW  00
0F45E:  MOVWF  FF8
0F460:  CLRF   1B
0F462:  BTFSC  FF2.7
0F464:  BSF    1B.7
0F466:  BCF    FF2.7
0F468:  MOVLW  06
0F46A:  MOVLB  A
0F46C:  MOVWF  x40
0F46E:  MOVLB  0
0F470:  CALL   1044
0F474:  BTFSC  1B.7
0F476:  BSF    FF2.7
0F478:  CLRF   1B
0F47A:  BTFSC  FF2.7
0F47C:  BSF    1B.7
0F47E:  BCF    FF2.7
0F480:  MOVFF  2D5,A40
0F484:  MOVLW  1B
0F486:  MOVLB  A
0F488:  MOVWF  x41
0F48A:  MOVLB  0
0F48C:  CALL   0FC6
0F490:  BTFSC  1B.7
0F492:  BSF    FF2.7
0F494:  MOVLW  5D
0F496:  BTFSS  F9E.4
0F498:  BRA    F496
0F49A:  MOVWF  FAD
0F49C:  MOVLW  5B
0F49E:  BTFSS  F9E.4
0F4A0:  BRA    F49E
0F4A2:  MOVWF  FAD
0F4A4:  MOVF   47,W
0F4A6:  BTFSS  F9E.4
0F4A8:  BRA    F4A6
0F4AA:  MOVWF  FAD
0F4AC:  MOVLW  7C
0F4AE:  MOVWF  FF6
0F4B0:  MOVLW  1C
0F4B2:  MOVWF  FF7
0F4B4:  MOVLW  00
0F4B6:  MOVWF  FF8
0F4B8:  CLRF   1B
0F4BA:  BTFSC  FF2.7
0F4BC:  BSF    1B.7
0F4BE:  BCF    FF2.7
0F4C0:  MOVLW  05
0F4C2:  MOVLB  A
0F4C4:  MOVWF  x40
0F4C6:  MOVLB  0
0F4C8:  CALL   1044
0F4CC:  BTFSC  1B.7
0F4CE:  BSF    FF2.7
0F4D0:  MOVLW  41
0F4D2:  MOVWF  FE9
0F4D4:  CLRF   1B
0F4D6:  BTFSC  FF2.7
0F4D8:  BSF    1B.7
0F4DA:  BCF    FF2.7
0F4DC:  MOVFF  4B,A43
0F4E0:  MOVFF  4A,A42
0F4E4:  MOVFF  49,A41
0F4E8:  MOVFF  48,A40
0F4EC:  CALL   110A
0F4F0:  BTFSC  1B.7
0F4F2:  BSF    FF2.7
0F4F4:  MOVLW  84
0F4F6:  MOVWF  FF6
0F4F8:  MOVLW  1C
0F4FA:  MOVWF  FF7
0F4FC:  MOVLW  00
0F4FE:  MOVWF  FF8
0F500:  CLRF   1B
0F502:  BTFSC  FF2.7
0F504:  BSF    1B.7
0F506:  BCF    FF2.7
0F508:  MOVLW  03
0F50A:  MOVLB  A
0F50C:  MOVWF  x40
0F50E:  MOVLB  0
0F510:  CALL   1044
0F514:  BTFSC  1B.7
0F516:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F518:  CALL   DAA8
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F51C:  MOVLW  2F
0F51E:  BTFSS  FA4.4
0F520:  BRA    F51E
0F522:  MOVLB  F
0F524:  MOVWF  x1C
0F526:  MOVFF  2D5,8F3
0F52A:  MOVLW  1B
0F52C:  MOVLB  8
0F52E:  MOVWF  xF4
0F530:  MOVLB  0
0F532:  CALL   DAF0
0F536:  MOVF   47,W
0F538:  BTFSS  FA4.4
0F53A:  BRA    F538
0F53C:  MOVLB  F
0F53E:  MOVWF  x1C
0F540:  MOVLW  41
0F542:  MOVWF  FE9
0F544:  MOVFF  4B,8F6
0F548:  MOVFF  4A,8F5
0F54C:  MOVFF  49,8F4
0F550:  MOVFF  48,8F3
0F554:  MOVLB  0
0F556:  BRA    F352
0F558:  MOVLW  0D
0F55A:  BTFSS  FA4.4
0F55C:  BRA    F55A
0F55E:  MOVLB  F
0F560:  MOVWF  x1C
0F562:  MOVLW  0A
0F564:  BTFSS  FA4.4
0F566:  BRA    F564
0F568:  MOVWF  x1C
....................    multidrop_off(); 
0F56A:  MOVLB  0
0F56C:  CALL   DB94
0F570:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12E7C:  MOVLB  8
12E7E:  CLRF   xEC
12E80:  BCF    xED.0
12E82:  CLRF   xEE
12E84:  CLRF   xF2
12E86:  CLRF   xF1
12E88:  CLRF   xF0
12E8A:  CLRF   xEF
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12E8C:  MOVLW  02
12E8E:  MOVWF  FEA
12E90:  MOVLW  47
12E92:  MOVWF  FE9
12E94:  CLRF   00
12E96:  CLRF   02
12E98:  MOVLW  51
12E9A:  MOVWF  01
12E9C:  MOVLB  0
12E9E:  CALL   354E
....................  
....................    det_cmd(); 
12EA2:  CALL   F432
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12EA6:  CALL   557C
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12EAA:  MOVLB  8
12EAC:  MOVF   xEE,W
12EAE:  SUBLW  02
12EB0:  BZ    12F44
12EB2:  MOVF   xEE,W
12EB4:  SUBLW  03
12EB6:  BZ    12F44
12EB8:  MOVF   xEC,W
12EBA:  SUBLW  50
12EBC:  BNC   12F44
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12EBE:  BTFSS  FA4.5
12EC0:  BRA    12EF8
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12EC2:  MOVLB  0
12EC4:  RCALL  12E62
12EC6:  MOVFF  01,8EB
....................  
....................          if(startCharacterRcvd) 
12ECA:  MOVLB  8
12ECC:  BTFSS  xED.0
12ECE:  BRA    12EF0
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12ED0:  MOVF   xEC,W
12ED2:  INCF   xEC,F
12ED4:  CLRF   03
12ED6:  ADDLW  47
12ED8:  MOVWF  FE9
12EDA:  MOVLW  02
12EDC:  ADDWFC 03,W
12EDE:  MOVWF  FEA
12EE0:  MOVFF  8EB,FEF
....................             if (CARRIAGE_RET == c) 
12EE4:  MOVF   xEB,W
12EE6:  SUBLW  0D
12EE8:  BNZ   12EEE
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12EEA:  MOVLW  02
12EEC:  MOVWF  xEE
....................             } 
....................          } 
12EEE:  BRA    12EF8
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12EF0:  MOVF   xEB,W
12EF2:  SUBLW  40
12EF4:  BNZ   12EF8
....................             { 
....................                startCharacterRcvd = TRUE; 
12EF6:  BSF    xED.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12EF8:  MOVLW  35
12EFA:  MOVWF  00
12EFC:  DECFSZ 00,F
12EFE:  BRA    12EFC
....................       if (tenMicroSecDelayCounter++ > 500000) 
12F00:  MOVFF  8F2,8F6
12F04:  MOVFF  8F1,8F5
12F08:  MOVFF  8F0,8F4
12F0C:  MOVFF  8EF,8F3
12F10:  MOVLW  01
12F12:  ADDWF  xEF,F
12F14:  BTFSC  FD8.0
12F16:  INCF   xF0,F
12F18:  BTFSC  FD8.2
12F1A:  INCF   xF1,F
12F1C:  BTFSC  FD8.2
12F1E:  INCF   xF2,F
12F20:  MOVF   xF6,F
12F22:  BNZ   12F3E
12F24:  MOVF   xF5,W
12F26:  SUBLW  06
12F28:  BC    12F42
12F2A:  XORLW  FF
12F2C:  BNZ   12F3E
12F2E:  MOVF   xF4,W
12F30:  SUBLW  A0
12F32:  BC    12F42
12F34:  XORLW  FF
12F36:  BNZ   12F3E
12F38:  MOVF   xF3,W
12F3A:  SUBLW  20
12F3C:  BC    12F42
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12F3E:  MOVLW  03
12F40:  MOVWF  xEE
....................       } 
12F42:  BRA    12EAC
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12F44:  MOVF   xEC,W
12F46:  SUBLW  50
12F48:  BC    12F5A
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12F4A:  MOVF   xEE,W
12F4C:  SUBLW  03
12F4E:  BZ    12F5A
12F50:  MOVF   xEE,W
12F52:  SUBLW  02
12F54:  BZ    12F5A
....................       { 
....................          rcvDataType = SOME_DATA; 
12F56:  MOVLW  01
12F58:  MOVWF  xEE
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12F5A:  MOVLB  0
12F5C:  CALL   559C
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12F60:  MOVLB  8
12F62:  MOVFF  8EE,01
12F66:  MOVLB  0
12F68:  GOTO   130E2 (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
10000:  MOVF   1F,F
10002:  BTFSS  FD8.2
10004:  GOTO   1002E
10008:  MOVF   20,F
1000A:  BTFSS  FD8.2
1000C:  GOTO   1002E
10010:  MOVLB  8
10012:  DECFSZ xEC,W
10014:  BRA    10018
10016:  BRA    1001E
10018:  MOVLB  0
1001A:  GOTO   1002E
1001E:  CLRF   FEA
10020:  MOVLW  67
10022:  MOVWF  FE9
10024:  MOVLB  0
10026:  CALL   79BE
1002A:  GOTO   1004A
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
1002E:  MOVF   20,F
10030:  BTFSS  FD8.2
10032:  GOTO   10040
10036:  MOVF   1F,W
10038:  SUBLW  03
1003A:  BTFSC  FD8.0
1003C:  GOTO   1004A
10040:  CLRF   FEA
10042:  MOVLW  67
10044:  MOVWF  FE9
10046:  CALL   79BE
....................  
....................    if (store==TRUE && sd_status==0) { 
1004A:  MOVLB  8
1004C:  DECFSZ xEB,W
1004E:  GOTO   100B2
10052:  MOVLB  2
10054:  MOVF   xDC,F
10056:  BTFSC  FD8.2
10058:  BRA    10060
1005A:  MOVLB  8
1005C:  GOTO   100B2
....................        
....................       buffer_select = 0; 
10060:  MOVLB  0
10062:  CLRF   x66
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
10064:  MOVLB  8
10066:  CLRF   xED
10068:  MOVLB  0
1006A:  CALL   55AE
....................          append_data(file_ptr_raw_all); 
1006E:  MOVLW  02
10070:  MOVLB  8
10072:  MOVWF  xEE
10074:  MOVLW  DD
10076:  MOVWF  xED
10078:  MOVLB  0
1007A:  CALL   8320
....................       heartbeat(TRUE); 
1007E:  MOVLW  01
10080:  MOVLB  8
10082:  MOVWF  xED
10084:  MOVLB  0
10086:  CALL   55AE
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
1008A:  MOVLB  8
1008C:  CLRF   xED
1008E:  MOVLB  0
10090:  CALL   55AE
....................          append_data(file_ptr_raw_new); 
10094:  MOVLW  02
10096:  MOVLB  8
10098:  MOVWF  xEE
1009A:  MOVLW  EB
1009C:  MOVWF  xED
1009E:  MOVLB  0
100A0:  CALL   8320
....................       heartbeat(TRUE); 
100A4:  MOVLW  01
100A6:  MOVLB  8
100A8:  MOVWF  xED
100AA:  MOVLB  0
100AC:  CALL   55AE
100B0:  MOVLB  8
....................    } 
100B2:  MOVLB  0
100B4:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12F78:  CLRF   xE5
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12F6C:  MOVLW  0D
12F6E:  MOVLB  8
12F70:  MOVWF  xCE
12F72:  MOVLW  0A
12F74:  MOVWF  xCF
12F76:  CLRF   xD0
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12F7A:  MOVLB  0
12F7C:  CALL   FFE6
....................    clear_data_buffer(); 
12F80:  CALL   D558
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12F84:  MOVLW  08
12F86:  MOVWF  FEA
12F88:  MOVLW  D1
12F8A:  MOVWF  FE9
12F8C:  CLRF   00
12F8E:  CLRF   02
12F90:  MOVLW  14
12F92:  MOVWF  01
12F94:  CALL   354E
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12F98:  MOVLW  01
12F9A:  MOVWF  FEA
12F9C:  MOVLW  A7
12F9E:  MOVWF  FE9
12FA0:  CLRF   00
12FA2:  CLRF   02
12FA4:  MOVLW  A0
12FA6:  MOVWF  01
12FA8:  CALL   354E
....................  
....................    time_stamp(); 
12FAC:  CALL   5442
....................    strcpy(data_buffer, time_stmp_str); 
12FB0:  CLRF   FEA
12FB2:  MOVLW  67
12FB4:  MOVWF  FE9
12FB6:  MOVLW  02
12FB8:  MOVWF  FE2
12FBA:  MOVLW  99
12FBC:  MOVWF  FE1
12FBE:  MOVF   FE7,F
12FC0:  MOVFF  FE6,FEE
12FC4:  BNZ   12FBE
....................    strcat(data_buffer, (char *)","); 
12FC6:  MOVLW  2C
12FC8:  MOVLB  8
12FCA:  MOVWF  xE9
12FCC:  CLRF   xEA
12FCE:  CLRF   xF9
12FD0:  MOVLW  67
12FD2:  MOVWF  xF8
12FD4:  MOVLW  08
12FD6:  MOVWF  xFB
12FD8:  MOVLW  E9
12FDA:  MOVWF  xFA
12FDC:  MOVLB  0
12FDE:  CALL   5506
....................  
....................    flag_mod=fmod(macro_flag,10); 
12FE2:  MOVFF  324,918
12FE6:  MOVFF  323,917
12FEA:  CALL   C926
12FEE:  MOVFF  03,8EE
12FF2:  MOVFF  02,8ED
12FF6:  MOVFF  01,8EC
12FFA:  MOVFF  00,8EB
12FFE:  MOVFF  03,8F2
13002:  MOVFF  02,8F1
13006:  MOVFF  01,8F0
1300A:  MOVFF  00,8EF
1300E:  MOVLB  8
13010:  CLRF   xF6
13012:  CLRF   xF5
13014:  MOVLW  20
13016:  MOVWF  xF4
13018:  MOVLW  82
1301A:  MOVWF  xF3
1301C:  MOVLB  0
1301E:  BRA    12C22
13020:  MOVFF  03,916
13024:  MOVFF  02,915
13028:  MOVFF  01,914
1302C:  MOVFF  00,913
13030:  RCALL  1283C
13032:  MOVFF  01,8E8
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
13036:  MOVLB  8
13038:  DECFSZ xE8,W
1303A:  BRA    1303E
1303C:  BRA    13044
1303E:  MOVF   xE8,W
13040:  SUBLW  03
13042:  BNZ   13062
....................    { 
....................       clear_proc_time_stmp_str(); 
13044:  MOVLB  0
13046:  BRA    12D8A
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
13048:  MOVLW  02
1304A:  MOVWF  FEA
1304C:  MOVLW  B7
1304E:  MOVWF  FE9
13050:  MOVLW  02
13052:  MOVWF  FE2
13054:  MOVLW  99
13056:  MOVWF  FE1
13058:  MOVF   FE7,F
1305A:  MOVFF  FE6,FEE
1305E:  BNZ   13058
13060:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
13062:  MOVLB  0
13064:  CALL   F964
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13068:  MOVLB  8
1306A:  CLRF   xEC
1306C:  MOVLW  67
1306E:  MOVWF  xEB
13070:  MOVLB  0
13072:  RCALL  12DA2
13074:  MOVFF  02,03
13078:  MOVF   01,W
1307A:  XORLW  FF
1307C:  ADDLW  A1
1307E:  MOVLB  8
13080:  MOVWF  xEB
13082:  MOVLW  00
13084:  SUBFWB 02,W
13086:  MOVWF  xEC
13088:  MOVLW  01
1308A:  SUBWF  xEB,F
1308C:  MOVLW  00
1308E:  SUBWFB xEC,F
13090:  CLRF   xEE
13092:  MOVLW  67
13094:  MOVWF  xED
13096:  MOVLW  03
13098:  MOVWF  xF0
1309A:  MOVLW  25
1309C:  MOVWF  xEF
1309E:  MOVFF  8EC,8F2
130A2:  MOVFF  8EB,8F1
130A6:  MOVLB  0
130A8:  RCALL  12DDE
....................    strcat(data_buffer, (char *)","); 
130AA:  MOVLW  2C
130AC:  MOVLB  8
130AE:  MOVWF  xE9
130B0:  CLRF   xEA
130B2:  CLRF   xF9
130B4:  MOVLW  67
130B6:  MOVWF  xF8
130B8:  MOVLW  08
130BA:  MOVWF  xFB
130BC:  MOVLW  E9
130BE:  MOVWF  xFA
130C0:  MOVLB  0
130C2:  CALL   5506
....................     
....................    cmd = 'S'; 
130C6:  MOVLW  53
130C8:  MOVWF  47
....................    arg = 1; 
130CA:  CLRF   4B
130CC:  CLRF   4A
130CE:  CLRF   49
130D0:  MOVLW  01
130D2:  MOVWF  48
....................  
....................    for(i = 0; i < 6; i++) 
130D4:  MOVLB  8
130D6:  CLRF   xE6
130D8:  MOVF   xE6,W
130DA:  SUBLW  05
130DC:  BNC   130F4
....................    { 
....................       rcvdData = get_slave_data(); 
130DE:  MOVLB  0
130E0:  BRA    12E7C
130E2:  MOVFF  01,8E5
....................       if (DATA_COMPLETE == rcvdData) 
130E6:  MOVLB  8
130E8:  MOVF   xE5,W
130EA:  SUBLW  02
130EC:  BNZ   130F0
....................       { 
....................          break; 
130EE:  BRA    130F4
....................       } 
130F0:  INCF   xE6,F
130F2:  BRA    130D8
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
130F4:  CLRF   xEC
130F6:  MOVLW  67
130F8:  MOVWF  xEB
130FA:  MOVLB  0
130FC:  RCALL  12DA2
130FE:  MOVFF  02,03
13102:  MOVF   01,W
13104:  XORLW  FF
13106:  ADDLW  A1
13108:  MOVLB  8
1310A:  MOVWF  xEB
1310C:  MOVLW  00
1310E:  SUBFWB 02,W
13110:  MOVWF  xEC
13112:  MOVLW  01
13114:  SUBWF  xEB,F
13116:  MOVLW  00
13118:  SUBWFB xEC,F
1311A:  CLRF   xEE
1311C:  MOVLW  67
1311E:  MOVWF  xED
13120:  MOVLW  02
13122:  MOVWF  xF0
13124:  MOVLW  47
13126:  MOVWF  xEF
13128:  MOVFF  8EC,8F2
1312C:  MOVFF  8EB,8F1
13130:  MOVLB  0
13132:  RCALL  12DDE
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
13134:  MOVLW  02
13136:  MOVLB  8
13138:  MOVWF  xEC
1313A:  MOVLW  47
1313C:  MOVWF  xEB
1313E:  MOVLB  0
13140:  RCALL  12DA2
13142:  MOVFF  01,8E7
....................    if (rec_len > 0 && rec_len < 12) 
13146:  MOVLB  8
13148:  MOVF   xE7,F
1314A:  BZ    13158
1314C:  MOVF   xE7,W
1314E:  SUBLW  0B
13150:  BNC   13158
....................    { 
....................       rcvdData = SHORT_DATA; 
13152:  MOVLW  04
13154:  MOVWF  xE5
....................    } 
13156:  BRA    13162
....................    else 
....................    { 
....................       if (rec_len > 30) 
13158:  MOVF   xE7,W
1315A:  SUBLW  1E
1315C:  BC    13162
....................       { 
....................          rcvdData = LONG_DATA; 
1315E:  MOVLW  05
13160:  MOVWF  xE5
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
13162:  MOVLW  02
13164:  SUBWF  xE5,W
13166:  ADDLW  FC
13168:  BC    131D4
1316A:  ADDLW  04
1316C:  MOVLB  0
1316E:  GOTO   13336
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
13172:  MOVLB  8
13174:  BRA    131D4
13176:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
13178:  MOVLW  08
1317A:  MOVWF  1E
1317C:  MOVLW  D1
1317E:  MOVWF  1D
13180:  MOVLW  88
13182:  MOVWF  FF6
13184:  MOVLW  1C
13186:  MOVWF  FF7
13188:  MOVLW  00
1318A:  MOVWF  FF8
1318C:  CALL   50E6
....................          break; 
13190:  MOVLB  8
13192:  BRA    131D4
13194:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
13196:  MOVLW  08
13198:  MOVWF  1E
1319A:  MOVLW  D1
1319C:  MOVWF  1D
1319E:  MOVLW  92
131A0:  MOVWF  FF6
131A2:  MOVLW  1C
131A4:  MOVWF  FF7
131A6:  MOVLW  00
131A8:  MOVWF  FF8
131AA:  CALL   50E6
....................          break; 
131AE:  MOVLB  8
131B0:  BRA    131D4
131B2:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
131B4:  MOVLW  08
131B6:  MOVWF  1E
131B8:  MOVLW  D1
131BA:  MOVWF  1D
131BC:  MOVLW  A2
131BE:  MOVWF  FF6
131C0:  MOVLW  1C
131C2:  MOVWF  FF7
131C4:  MOVLW  00
131C6:  MOVWF  FF8
131C8:  CALL   50E6
....................          break; 
131CC:  MOVLB  8
131CE:  BRA    131D4
131D0:  MOVLB  0
131D2:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
131D4:  CLRF   xEC
131D6:  MOVLW  67
131D8:  MOVWF  xEB
131DA:  MOVLB  0
131DC:  RCALL  12DA2
131DE:  MOVFF  02,03
131E2:  MOVF   01,W
131E4:  XORLW  FF
131E6:  ADDLW  A1
131E8:  MOVLB  8
131EA:  MOVWF  xEB
131EC:  MOVLW  00
131EE:  SUBFWB 02,W
131F0:  MOVWF  xEC
131F2:  MOVLW  01
131F4:  SUBWF  xEB,F
131F6:  MOVLW  00
131F8:  SUBWFB xEC,F
131FA:  CLRF   xEE
131FC:  MOVLW  67
131FE:  MOVWF  xED
13200:  MOVLW  08
13202:  MOVWF  xF0
13204:  MOVLW  D1
13206:  MOVWF  xEF
13208:  MOVFF  8EC,8F2
1320C:  MOVFF  8EB,8F1
13210:  MOVLB  0
13212:  RCALL  12DDE
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13214:  MOVLB  8
13216:  CLRF   xEC
13218:  MOVLW  67
1321A:  MOVWF  xEB
1321C:  MOVLB  0
1321E:  RCALL  12DA2
13220:  MOVFF  02,03
13224:  MOVF   01,W
13226:  XORLW  FF
13228:  ADDLW  A1
1322A:  MOVLB  8
1322C:  MOVWF  xEB
1322E:  MOVLW  00
13230:  SUBFWB 02,W
13232:  MOVWF  xEC
13234:  MOVLW  01
13236:  SUBWF  xEB,F
13238:  MOVLW  00
1323A:  SUBWFB xEC,F
1323C:  CLRF   xEE
1323E:  MOVLW  67
13240:  MOVWF  xED
13242:  MOVLW  08
13244:  MOVWF  xF0
13246:  MOVLW  CE
13248:  MOVWF  xEF
1324A:  MOVFF  8EC,8F2
1324E:  MOVFF  8EB,8F1
13252:  MOVLB  0
13254:  RCALL  12DDE
....................  
....................    if(DATA_COMPLETE != rcvdData) 
13256:  MOVLB  8
13258:  MOVF   xE5,W
1325A:  SUBLW  02
1325C:  BZ    13318
....................    {    //housekeeping 
....................       time_stamp(); 
1325E:  MOVLB  0
13260:  CALL   5442
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
13264:  MOVLW  01
13266:  MOVWF  1E
13268:  MOVLW  A7
1326A:  MOVWF  1D
1326C:  MOVLW  B2
1326E:  MOVWF  FF6
13270:  MOVLW  1C
13272:  MOVWF  FF7
13274:  MOVLW  00
13276:  MOVWF  FF8
13278:  MOVLW  0A
1327A:  MOVLB  8
1327C:  MOVWF  xEB
1327E:  MOVLB  0
13280:  CALL   AAF4
13284:  MOVFF  1E,FEA
13288:  MOVFF  1D,FE9
1328C:  CLRF   FEF
1328E:  MOVLW  08
13290:  MOVWF  FEA
13292:  MOVLW  D1
13294:  MOVWF  FE9
13296:  CALL   FE6C
1329A:  MOVLW  BE
1329C:  MOVWF  FF6
1329E:  MOVLW  1C
132A0:  MOVWF  FF7
132A2:  MOVLW  00
132A4:  MOVWF  FF8
132A6:  MOVLW  06
132A8:  MOVLB  8
132AA:  MOVWF  xEB
132AC:  MOVLB  0
132AE:  CALL   AAF4
132B2:  MOVFF  8E7,8ED
132B6:  MOVLW  1B
132B8:  MOVLB  8
132BA:  MOVWF  xEE
132BC:  MOVLB  0
132BE:  CALL   52A8
132C2:  MOVLW  5D
132C4:  MOVLB  8
132C6:  MOVWF  xFF
132C8:  MOVLB  0
132CA:  CALL   50C6
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
132CE:  MOVLW  01
132D0:  MOVLB  8
132D2:  MOVWF  xEC
132D4:  MOVLW  A7
132D6:  MOVWF  xEB
132D8:  MOVLB  0
132DA:  RCALL  12DA2
132DC:  MOVFF  02,03
132E0:  MOVF   01,W
132E2:  XORLW  FF
132E4:  ADDLW  A1
132E6:  MOVLB  8
132E8:  MOVWF  xEB
132EA:  MOVLW  00
132EC:  SUBFWB 02,W
132EE:  MOVWF  xEC
132F0:  MOVLW  01
132F2:  SUBWF  xEB,F
132F4:  MOVLW  00
132F6:  SUBWFB xEC,F
132F8:  MOVLW  01
132FA:  MOVWF  xEE
132FC:  MOVLW  A7
132FE:  MOVWF  xED
13300:  CLRF   xF0
13302:  MOVLW  67
13304:  MOVWF  xEF
13306:  MOVFF  8EC,8F2
1330A:  MOVFF  8EB,8F1
1330E:  MOVLB  0
13310:  RCALL  12DDE
....................       record_event(); 
13312:  CALL   8502
13316:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
13318:  MOVFF  8CC,8EB
1331C:  MOVFF  8CD,8EC
13320:  MOVLB  0
13322:  CALL   10000
....................  
....................    return (rcvdData); 
13326:  CLRF   03
13328:  MOVLB  8
1332A:  MOVFF  8E5,01
1332E:  MOVFF  03,02
13332:  MOVLB  0
13334:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
1375A:  MOVLB  8
1375C:  CLRF   xC4
1375E:  MOVF   xC4,W
13760:  SUBLW  02
13762:  BTFSS  FD8.0
13764:  BRA    1387A
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
13766:  MOVFF  8C2,8CC
1376A:  MOVFF  8C3,8CD
1376E:  MOVLB  0
13770:  CALL   12F6C
13774:  MOVFF  02,03
13778:  MOVF   01,W
1377A:  SUBLW  02
1377C:  BNZ   1378A
1377E:  MOVF   03,F
13780:  BNZ   1378A
....................       { 
....................          break; 
13782:  MOVLB  8
13784:  BRA    1387A
....................       } 
13786:  BRA    13876
13788:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
1378A:  MOVLW  01
1378C:  MOVLB  8
1378E:  ADDWF  xC4,W
13790:  MOVWF  xC5
13792:  MOVLW  C8
13794:  MOVWF  FF6
13796:  MOVLW  1C
13798:  MOVWF  FF7
1379A:  MOVLW  00
1379C:  MOVWF  FF8
1379E:  CLRF   1B
137A0:  BTFSC  FF2.7
137A2:  BSF    1B.7
137A4:  BCF    FF2.7
137A6:  MOVLW  05
137A8:  MOVLB  A
137AA:  MOVWF  x40
137AC:  MOVLB  0
137AE:  CALL   1044
137B2:  BTFSC  1B.7
137B4:  BSF    FF2.7
137B6:  CLRF   1B
137B8:  BTFSC  FF2.7
137BA:  BSF    1B.7
137BC:  BCF    FF2.7
137BE:  MOVFF  8C5,A40
137C2:  MOVLW  1B
137C4:  MOVLB  A
137C6:  MOVWF  x41
137C8:  MOVLB  0
137CA:  CALL   0FC6
137CE:  BTFSC  1B.7
137D0:  BSF    FF2.7
137D2:  MOVLW  0D
137D4:  BTFSS  F9E.4
137D6:  BRA    137D4
137D8:  MOVWF  FAD
137DA:  MOVLW  0A
137DC:  BTFSS  F9E.4
137DE:  BRA    137DC
137E0:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
137E2:  BCF    F90.7
....................          delay_ms(1000); 
137E4:  MOVLW  04
137E6:  MOVLB  8
137E8:  MOVWF  xC5
137EA:  MOVLW  FA
137EC:  MOVLB  9
137EE:  MOVWF  xEC
137F0:  MOVLB  0
137F2:  CALL   2938
137F6:  MOVLB  8
137F8:  DECFSZ xC5,F
137FA:  BRA    137EA
....................          output_bit(VDET,ON); 
137FC:  BSF    F90.7
....................          delay_ms(1000); 
137FE:  MOVLW  04
13800:  MOVWF  xC5
13802:  MOVLW  FA
13804:  MOVLB  9
13806:  MOVWF  xEC
13808:  MOVLB  0
1380A:  CALL   2938
1380E:  MOVLB  8
13810:  DECFSZ xC5,F
13812:  BRA    13802
....................          if (LightTargetFlag==0) 
13814:  MOVLB  2
13816:  MOVF   xD9,F
13818:  BNZ   13860
....................          { 
....................           cmd='K'; 
1381A:  MOVLW  4B
1381C:  MOVWF  47
....................           arg=detector_ch; 
1381E:  CLRF   4B
13820:  CLRF   4A
13822:  CLRF   49
13824:  MOVFF  2D6,48
....................           det_cmd(); 
13828:  MOVLB  0
1382A:  CALL   F432
....................           delay_ms(1000); 
1382E:  MOVLW  04
13830:  MOVLB  8
13832:  MOVWF  xC5
13834:  MOVLW  FA
13836:  MOVLB  9
13838:  MOVWF  xEC
1383A:  MOVLB  0
1383C:  CALL   2938
13840:  MOVLB  8
13842:  DECFSZ xC5,F
13844:  BRA    13834
....................           cmd='L'; 
13846:  MOVLW  4C
13848:  MOVWF  47
....................           arg=detector_li; 
1384A:  CLRF   4B
1384C:  CLRF   4A
1384E:  MOVFF  2D8,49
13852:  MOVFF  2D7,48
....................           det_cmd(); 
13856:  MOVLB  0
13858:  CALL   F432
....................          }  
1385C:  BRA    13874
1385E:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
13860:  MOVLW  6C
13862:  MOVWF  47
....................           arg=1; 
13864:  CLRF   4B
13866:  CLRF   4A
13868:  CLRF   49
1386A:  MOVLW  01
1386C:  MOVWF  48
....................           det_cmd(); 
1386E:  MOVLB  0
13870:  CALL   F432
13874:  MOVLB  8
....................          }  
....................       } 
13876:  INCF   xC4,F
13878:  BRA    1375E
....................    } 
....................  
....................    parse_data(); 
1387A:  MOVLB  0
1387C:  RCALL  136D8
....................    data_available = TRUE; 
1387E:  MOVLW  01
13880:  MOVLB  3
13882:  MOVWF  x3B
....................    macro_flag = 900; 
13884:  MOVLW  03
13886:  MOVWF  x24
13888:  MOVLW  84
1388A:  MOVWF  x23
....................  
....................    return; 
1388C:  MOVLB  0
1388E:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
13BFA:  MOVLB  8
13BFC:  CLRF   xCD
13BFE:  CLRF   xCC
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
13C00:  MOVLB  0
13C02:  RCALL  136D8
13C04:  MOVFF  02,8CD
13C08:  MOVFF  01,8CC
....................    return (temp); 
13C0C:  MOVLB  8
13C0E:  MOVFF  8CC,01
13C12:  MOVFF  8CD,02
13C16:  MOVLB  0
13C18:  GOTO   13D2A (RETURN)
.................... } 
....................  
.................... void det_temp() 
13C1C:  MOVLB  8
13C1E:  CLRF   xC9
13C20:  CLRF   xC8
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
13C22:  MOVLB  2
13C24:  MOVF   xD5,W
13C26:  XORLW  01
13C28:  MOVLB  0
13C2A:  BZ    13C32
13C2C:  XORLW  03
13C2E:  BZ    13C3C
13C30:  BRA    13C46
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
13C32:  MOVFF  42,8CB
13C36:  MOVFF  41,8CA
....................          break; 
13C3A:  BRA    13C52
....................       case 2 : target_temp = nv_d2_temp; 
13C3C:  MOVFF  44,8CB
13C40:  MOVFF  43,8CA
....................          break; 
13C44:  BRA    13C52
....................       default : target_temp = 20000; 
13C46:  MOVLW  4E
13C48:  MOVLB  8
13C4A:  MOVWF  xCB
13C4C:  MOVLW  20
13C4E:  MOVWF  xCA
....................          break; 
13C50:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
13C52:  MOVLB  8
13C54:  CLRF   xC7
13C56:  MOVLW  3C
13C58:  MOVWF  xC6
....................    n = 0; 
13C5A:  CLRF   xC5
13C5C:  CLRF   xC4
....................    store=FALSE; 
13C5E:  CLRF   xC2
....................    display=FALSE; 
13C60:  CLRF   xC3
....................  
....................    time_stamp(); 
13C62:  MOVLB  0
13C64:  CALL   5442
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
13C68:  MOVLW  01
13C6A:  MOVWF  1E
13C6C:  MOVLW  A7
13C6E:  MOVWF  1D
13C70:  MOVLW  D2
13C72:  MOVWF  FF6
13C74:  MOVLW  1C
13C76:  MOVWF  FF7
13C78:  MOVLW  00
13C7A:  MOVWF  FF8
13C7C:  MOVLW  16
13C7E:  MOVLB  8
13C80:  MOVWF  xEB
13C82:  MOVLB  0
13C84:  CALL   AAF4
13C88:  MOVLW  10
13C8A:  MOVWF  FE9
13C8C:  MOVFF  8CB,8F7
13C90:  MOVFF  8CA,8F6
13C94:  CALL   AB26
13C98:  MOVLW  EB
13C9A:  MOVWF  FF6
13C9C:  MOVLW  1C
13C9E:  MOVWF  FF7
13CA0:  MOVLW  00
13CA2:  MOVWF  FF8
13CA4:  MOVLW  09
13CA6:  MOVLB  8
13CA8:  MOVWF  xEB
13CAA:  MOVLB  0
13CAC:  CALL   AAF4
13CB0:  MOVLW  10
13CB2:  MOVWF  FE9
13CB4:  MOVFF  8C9,8F7
13CB8:  MOVFF  8C8,8F6
13CBC:  CALL   AB26
13CC0:  MOVLW  F7
13CC2:  MOVWF  FF6
13CC4:  MOVLW  1C
13CC6:  MOVWF  FF7
13CC8:  MOVLW  00
13CCA:  MOVWF  FF8
13CCC:  MOVLW  0B
13CCE:  MOVLB  8
13CD0:  MOVWF  xEB
13CD2:  MOVLB  0
13CD4:  CALL   AAF4
13CD8:  MOVLW  10
13CDA:  MOVWF  FE9
13CDC:  MOVFF  8C5,8F7
13CE0:  MOVFF  8C4,8F6
13CE4:  CALL   AB26
13CE8:  MOVLW  05
13CEA:  MOVWF  FF6
13CEC:  MOVLW  1D
13CEE:  MOVWF  FF7
13CF0:  MOVLW  00
13CF2:  MOVWF  FF8
13CF4:  MOVLW  03
13CF6:  MOVLB  8
13CF8:  MOVWF  xEB
13CFA:  MOVLB  0
13CFC:  CALL   AAF4
....................    record_event(); 
13D00:  CALL   8502
....................  
....................    for (n=1; n<t; ++n) 
13D04:  MOVLB  8
13D06:  CLRF   xC5
13D08:  MOVLW  01
13D0A:  MOVWF  xC4
13D0C:  MOVF   xC5,W
13D0E:  SUBWF  xC7,W
13D10:  BNC   13D6C
13D12:  BNZ   13D1A
13D14:  MOVF   xC6,W
13D16:  SUBWF  xC4,W
13D18:  BC    13D6C
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
13D1A:  MOVFF  8C2,8CC
13D1E:  MOVFF  8C3,8CD
13D22:  MOVLB  0
13D24:  CALL   12F6C
....................       current_temp=parse_temp(); 
13D28:  BRA    13BFA
13D2A:  MOVFF  02,8C9
13D2E:  MOVFF  01,8C8
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
13D32:  MOVLB  8
13D34:  MOVF   xCB,W
13D36:  SUBWF  xC9,W
13D38:  BNC   13D42
13D3A:  BNZ   13D4A
13D3C:  MOVF   xCA,W
13D3E:  SUBWF  xC8,W
13D40:  BC    13D4A
13D42:  MOVF   xC8,F
13D44:  BNZ   13D4E
13D46:  MOVF   xC9,F
13D48:  BNZ   13D4E
13D4A:  BRA    13D6C
13D4C:  BRA    13D64
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13D4E:  MOVLW  0A
13D50:  MOVWF  xCC
13D52:  MOVLW  FA
13D54:  MOVLB  9
13D56:  MOVWF  xEC
13D58:  MOVLB  0
13D5A:  CALL   2938
13D5E:  MOVLB  8
13D60:  DECFSZ xCC,F
13D62:  BRA    13D52
13D64:  INCF   xC4,F
13D66:  BTFSC  FD8.2
13D68:  INCF   xC5,F
13D6A:  BRA    13D0C
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13D6C:  MOVLW  01
13D6E:  MOVWF  1E
13D70:  MOVLW  A7
13D72:  MOVWF  1D
13D74:  MOVLW  0A
13D76:  MOVWF  FF6
13D78:  MOVLW  1D
13D7A:  MOVWF  FF7
13D7C:  MOVLW  00
13D7E:  MOVWF  FF8
13D80:  MOVLW  14
13D82:  MOVWF  xEB
13D84:  MOVLB  0
13D86:  CALL   AAF4
13D8A:  MOVLW  10
13D8C:  MOVWF  FE9
13D8E:  MOVFF  8CB,8F7
13D92:  MOVFF  8CA,8F6
13D96:  CALL   AB26
13D9A:  MOVLW  21
13D9C:  MOVWF  FF6
13D9E:  MOVLW  1D
13DA0:  MOVWF  FF7
13DA2:  MOVLW  00
13DA4:  MOVWF  FF8
13DA6:  MOVLW  09
13DA8:  MOVLB  8
13DAA:  MOVWF  xEB
13DAC:  MOVLB  0
13DAE:  CALL   AAF4
13DB2:  MOVLW  10
13DB4:  MOVWF  FE9
13DB6:  MOVFF  8C9,8F7
13DBA:  MOVFF  8C8,8F6
13DBE:  CALL   AB26
13DC2:  MOVLW  2D
13DC4:  MOVWF  FF6
13DC6:  MOVLW  1D
13DC8:  MOVWF  FF7
13DCA:  MOVLW  00
13DCC:  MOVWF  FF8
13DCE:  MOVLW  0B
13DD0:  MOVLB  8
13DD2:  MOVWF  xEB
13DD4:  MOVLB  0
13DD6:  CALL   AAF4
13DDA:  MOVLW  10
13DDC:  MOVWF  FE9
13DDE:  MOVFF  8C5,8F7
13DE2:  MOVFF  8C4,8F6
13DE6:  CALL   AB26
13DEA:  MOVLW  3B
13DEC:  MOVWF  FF6
13DEE:  MOVLW  1D
13DF0:  MOVWF  FF7
13DF2:  MOVLW  00
13DF4:  MOVWF  FF8
13DF6:  MOVLW  03
13DF8:  MOVLB  8
13DFA:  MOVWF  xEB
13DFC:  MOVLB  0
13DFE:  CALL   AAF4
....................    record_event();    
13E02:  CALL   8502
13E06:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
138D2:  MOVLB  8
138D4:  CLRF   xD5
138D6:  CLRF   xD4
138D8:  CLRF   xD3
138DA:  CLRF   xD2
....................    set_adc_channel(1,VSS); 
138DC:  MOVLW  04
138DE:  MOVWF  01
138E0:  MOVF   FC2,W
138E2:  ANDLW  83
138E4:  IORWF  01,W
138E6:  MOVWF  FC2
138E8:  MOVLW  00
138EA:  MOVWF  01
138EC:  MOVF   FC1,W
138EE:  ANDLW  F8
138F0:  IORWF  01,W
138F2:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
138F4:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
138F6:  MOVLW  01
138F8:  MOVWF  xCF
138FA:  MOVF   xCF,W
138FC:  SUBLW  32
138FE:  BNC   13924
....................       reading=read_adc(); 
13900:  BSF    FC2.1
13902:  BTFSC  FC2.1
13904:  BRA    13902
13906:  MOVFF  FC3,8D6
1390A:  MOVFF  FC4,8D7
1390E:  CLRF   xD8
13910:  CLRF   xD9
....................       delay_ms(5); 
13912:  MOVLW  05
13914:  MOVLB  9
13916:  MOVWF  xEC
13918:  MOVLB  0
1391A:  CALL   2938
1391E:  MOVLB  8
13920:  INCF   xCF,F
13922:  BRA    138FA
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
13924:  MOVLW  01
13926:  MOVWF  xCF
13928:  MOVF   xCF,W
1392A:  SUBLW  64
1392C:  BNC   139DA
....................       reading=read_adc(); 
1392E:  BSF    FC2.1
13930:  BTFSC  FC2.1
13932:  BRA    13930
13934:  MOVFF  FC3,8D6
13938:  MOVFF  FC4,8D7
1393C:  CLRF   xD8
1393E:  CLRF   xD9
....................       result=(((result*(i-1))+reading)/i); 
13940:  MOVLW  01
13942:  SUBWF  xCF,W
13944:  MOVWF  xDA
13946:  MOVFF  8D5,9F9
1394A:  MOVFF  8D4,9F8
1394E:  MOVFF  8D3,9F7
13952:  MOVFF  8D2,9F6
13956:  MOVLB  9
13958:  CLRF   xFD
1395A:  CLRF   xFC
1395C:  CLRF   xFB
1395E:  MOVWF  xFA
13960:  MOVLB  0
13962:  CALL   4818
13966:  MOVFF  03,8DD
1396A:  MOVFF  02,8DC
1396E:  MOVFF  01,8DB
13972:  MOVFF  00,8DA
13976:  MOVLB  8
13978:  MOVF   xD6,W
1397A:  ADDWF  xDA,F
1397C:  MOVF   xD7,W
1397E:  ADDWFC xDB,F
13980:  MOVF   xD8,W
13982:  ADDWFC xDC,F
13984:  MOVF   xD9,W
13986:  ADDWFC xDD,F
13988:  BCF    FD8.1
1398A:  CLRF   1B
1398C:  BTFSC  FF2.7
1398E:  BSF    1B.7
13990:  BCF    FF2.7
13992:  MOVFF  8DD,A4F
13996:  MOVFF  8DC,A4E
1399A:  MOVFF  8DB,A4D
1399E:  MOVFF  8DA,A4C
139A2:  MOVLB  A
139A4:  CLRF   x53
139A6:  CLRF   x52
139A8:  CLRF   x51
139AA:  MOVFF  8CF,A50
139AE:  MOVLB  0
139B0:  CALL   1076
139B4:  BTFSC  1B.7
139B6:  BSF    FF2.7
139B8:  MOVFF  03,8D5
139BC:  MOVFF  02,8D4
139C0:  MOVFF  01,8D3
139C4:  MOVFF  00,8D2
....................       delay_ms(5); 
139C8:  MOVLW  05
139CA:  MOVLB  9
139CC:  MOVWF  xEC
139CE:  MOVLB  0
139D0:  CALL   2938
139D4:  MOVLB  8
139D6:  INCF   xCF,F
139D8:  BRA    13928
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
139DA:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
139DC:  MOVFF  8D5,9F9
139E0:  MOVFF  8D4,9F8
139E4:  MOVFF  8D3,9F7
139E8:  MOVFF  8D2,9F6
139EC:  MOVLB  9
139EE:  CLRF   xFD
139F0:  CLRF   xFC
139F2:  MOVLW  10
139F4:  MOVWF  xFB
139F6:  MOVLW  25
139F8:  MOVWF  xFA
139FA:  MOVLB  0
139FC:  CALL   4818
13A00:  MOVFF  03,8DD
13A04:  MOVFF  02,8DC
13A08:  MOVFF  01,8DB
13A0C:  MOVFF  00,8DA
13A10:  BCF    FD8.1
13A12:  CLRF   1B
13A14:  BTFSC  FF2.7
13A16:  BSF    1B.7
13A18:  BCF    FF2.7
13A1A:  MOVFF  03,A4F
13A1E:  MOVFF  02,A4E
13A22:  MOVFF  01,A4D
13A26:  MOVFF  00,A4C
13A2A:  MOVLB  A
13A2C:  CLRF   x53
13A2E:  CLRF   x52
13A30:  CLRF   x51
13A32:  MOVLW  64
13A34:  MOVWF  x50
13A36:  MOVLB  0
13A38:  CALL   1076
13A3C:  BTFSC  1B.7
13A3E:  BSF    FF2.7
13A40:  MOVLW  21
13A42:  MOVLB  8
13A44:  SUBWF  00,W
13A46:  MOVWF  xD0
13A48:  MOVLW  50
13A4A:  SUBWFB 01,W
13A4C:  MOVWF  xD1
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
13A4E:  MOVFF  8D0,01
13A52:  MOVFF  8D1,02
13A56:  MOVLB  0
13A58:  GOTO   13ABE (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
13A68:  CLRF   xC8
13A6A:  CLRF   xC7
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
13A5C:  MOVLW  0D
13A5E:  MOVLB  8
13A60:  MOVWF  xC4
13A62:  MOVLW  0A
13A64:  MOVWF  xC5
13A66:  CLRF   xC6
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
13A6C:  MOVLB  0
13A6E:  CALL   FFE6
....................    clear_data_buffer(); 
13A72:  CALL   D558
....................  
....................    time_stamp(); 
13A76:  CALL   5442
....................    strcpy(data_buffer, time_stmp_str); 
13A7A:  CLRF   FEA
13A7C:  MOVLW  67
13A7E:  MOVWF  FE9
13A80:  MOVLW  02
13A82:  MOVWF  FE2
13A84:  MOVLW  99
13A86:  MOVWF  FE1
13A88:  MOVF   FE7,F
13A8A:  MOVFF  FE6,FEE
13A8E:  BNZ   13A88
....................    strcat(data_buffer, (char *)",Tmp,"); 
13A90:  MOVLW  2C
13A92:  MOVLB  8
13A94:  MOVWF  xC9
13A96:  MOVLW  54
13A98:  MOVWF  xCA
13A9A:  MOVLW  6D
13A9C:  MOVWF  xCB
13A9E:  MOVLW  70
13AA0:  MOVWF  xCC
13AA2:  MOVLW  2C
13AA4:  MOVWF  xCD
13AA6:  CLRF   xCE
13AA8:  CLRF   xF9
13AAA:  MOVLW  67
13AAC:  MOVWF  xF8
13AAE:  MOVLW  08
13AB0:  MOVWF  xFB
13AB2:  MOVLW  C9
13AB4:  MOVWF  xFA
13AB6:  MOVLB  0
13AB8:  CALL   5506
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
13ABC:  BRA    138D2
13ABE:  MOVFF  02,8C8
13AC2:  MOVFF  01,8C7
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
13AC6:  MOVLW  02
13AC8:  MOVWF  1E
13ACA:  MOVLW  47
13ACC:  MOVWF  1D
13ACE:  MOVLW  45
13AD0:  MOVWF  FE9
13AD2:  MOVLB  8
13AD4:  CLRF   xF0
13AD6:  CLRF   xEF
13AD8:  MOVFF  8C8,8EE
13ADC:  MOVFF  8C7,8ED
13AE0:  MOVLW  03
13AE2:  MOVWF  xF1
13AE4:  MOVLB  0
13AE6:  CALL   5342
....................  
....................    strcat(slave_reply, endofline); 
13AEA:  MOVLW  02
13AEC:  MOVLB  8
13AEE:  MOVWF  xF9
13AF0:  MOVLW  47
13AF2:  MOVWF  xF8
13AF4:  MOVLW  08
13AF6:  MOVWF  xFB
13AF8:  MOVLW  C4
13AFA:  MOVWF  xFA
13AFC:  MOVLB  0
13AFE:  CALL   5506
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13B02:  MOVLB  8
13B04:  CLRF   xEC
13B06:  MOVLW  67
13B08:  MOVWF  xEB
13B0A:  MOVLB  0
13B0C:  CALL   12DA2
13B10:  MOVFF  02,03
13B14:  MOVF   01,W
13B16:  XORLW  FF
13B18:  ADDLW  A1
13B1A:  MOVLB  8
13B1C:  MOVWF  xCF
13B1E:  MOVLW  00
13B20:  SUBFWB 02,W
13B22:  MOVWF  xD0
13B24:  MOVLW  01
13B26:  SUBWF  xCF,F
13B28:  MOVLW  00
13B2A:  SUBWFB xD0,F
13B2C:  CLRF   xEE
13B2E:  MOVLW  67
13B30:  MOVWF  xED
13B32:  MOVLW  02
13B34:  MOVWF  xF0
13B36:  MOVLW  47
13B38:  MOVWF  xEF
13B3A:  MOVFF  8D0,8F2
13B3E:  MOVFF  8CF,8F1
13B42:  MOVLB  0
13B44:  CALL   12DDE
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
13B48:  MOVF   1F,F
13B4A:  BNZ   13B6A
13B4C:  MOVF   20,F
13B4E:  BNZ   13B6A
13B50:  MOVLB  8
13B52:  DECFSZ xC3,W
13B54:  BRA    13B58
13B56:  BRA    13B5C
13B58:  MOVLB  0
13B5A:  BRA    13B6A
13B5C:  CLRF   FEA
13B5E:  MOVLW  67
13B60:  MOVWF  FE9
13B62:  MOVLB  0
13B64:  CALL   79BE
13B68:  BRA    13B7E
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
13B6A:  MOVF   20,F
13B6C:  BNZ   13B74
13B6E:  MOVF   1F,W
13B70:  SUBLW  03
13B72:  BC    13B7E
13B74:  CLRF   FEA
13B76:  MOVLW  67
13B78:  MOVWF  FE9
13B7A:  CALL   79BE
....................  
....................    if (store == TRUE && sd_status==0) { 
13B7E:  MOVLB  8
13B80:  DECFSZ xC2,W
13B82:  BRA    13BE2
13B84:  MOVLB  2
13B86:  MOVF   xDC,F
13B88:  BTFSC  FD8.2
13B8A:  BRA    13B90
13B8C:  MOVLB  8
13B8E:  BRA    13BE2
....................       buffer_select = 0; 
13B90:  MOVLB  0
13B92:  CLRF   x66
....................       
....................       heartbeat(FALSE); 
13B94:  MOVLB  8
13B96:  CLRF   xED
13B98:  MOVLB  0
13B9A:  CALL   55AE
....................          append_data(file_ptr_raw_all); 
13B9E:  MOVLW  02
13BA0:  MOVLB  8
13BA2:  MOVWF  xEE
13BA4:  MOVLW  DD
13BA6:  MOVWF  xED
13BA8:  MOVLB  0
13BAA:  CALL   8320
....................       heartbeat(TRUE); 
13BAE:  MOVLW  01
13BB0:  MOVLB  8
13BB2:  MOVWF  xED
13BB4:  MOVLB  0
13BB6:  CALL   55AE
....................        
....................       heartbeat(FALSE); 
13BBA:  MOVLB  8
13BBC:  CLRF   xED
13BBE:  MOVLB  0
13BC0:  CALL   55AE
....................          append_data(file_ptr_raw_new); 
13BC4:  MOVLW  02
13BC6:  MOVLB  8
13BC8:  MOVWF  xEE
13BCA:  MOVLW  EB
13BCC:  MOVWF  xED
13BCE:  MOVLB  0
13BD0:  CALL   8320
....................       heartbeat(TRUE); 
13BD4:  MOVLW  01
13BD6:  MOVLB  8
13BD8:  MOVWF  xED
13BDA:  MOVLB  0
13BDC:  CALL   55AE
13BE0:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
13BE2:  MOVLW  03
13BE4:  MOVLB  3
13BE6:  MOVWF  x24
13BE8:  MOVLW  84
13BEA:  MOVWF  x23
....................     
....................    return (temp); 
13BEC:  MOVLB  8
13BEE:  MOVFF  8C7,01
13BF2:  MOVFF  8C8,02
13BF6:  MOVLB  0
13BF8:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
1274E:  MOVLB  8
12750:  MOVF   xC5,W
12752:  ADDLW  FC
12754:  BC    12792
12756:  ADDLW  04
12758:  MOVLB  0
1275A:  GOTO   1279A
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
1275E:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
12760:  BCF    F8C.1
....................          break; 
12762:  MOVLB  8
12764:  BRA    12792
....................       case 1 :  
....................             output_bit(HSW1, ON); 
12766:  BSF    F8C.0
....................          break; 
12768:  MOVLB  8
1276A:  BRA    12792
....................       case 2 :  
....................             output_bit(HSW2, ON); 
1276C:  BSF    F8C.1
....................          break;  
1276E:  MOVLB  8
12770:  BRA    12792
....................       case 3 :  
....................             output_bit(HSW1, ON); 
12772:  BSF    F8C.0
....................             delay_ms(500); 
12774:  MOVLW  02
12776:  MOVLB  8
12778:  MOVWF  xC6
1277A:  MOVLW  FA
1277C:  MOVLB  9
1277E:  MOVWF  xEC
12780:  MOVLB  0
12782:  CALL   2938
12786:  MOVLB  8
12788:  DECFSZ xC6,F
1278A:  BRA    1277A
....................             output_bit(HSW2, ON); 
1278C:  BSF    F8C.1
....................          break;             
1278E:  BRA    12792
12790:  MOVLB  8
....................    } 
....................    heater_stat=set; 
12792:  MOVFF  8C5,4B5
12796:  MOVLB  0
12798:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F85A:  MOVLW  08
0F85C:  MOVLB  8
0F85E:  MOVWF  xCC
0F860:  CLRF   xCB
....................    LED_level_change=2048; 
0F862:  MOVWF  xCE
0F864:  CLRF   xCD
....................     
....................    for (i=0; i<12; i++){ 
0F866:  CLRF   xCA
0F868:  MOVF   xCA,W
0F86A:  SUBLW  0B
0F86C:  BNC   F8E4
....................       DAC_set(1,LED_level); 
0F86E:  MOVLW  01
0F870:  MOVWF  xD3
0F872:  MOVFF  8CC,8D5
0F876:  MOVFF  8CB,8D4
0F87A:  MOVLB  0
0F87C:  RCALL  F5A8
....................       LED_level_change = LED_level_change/2; 
0F87E:  BCF    FD8.0
0F880:  MOVLB  8
0F882:  RRCF   xCE,F
0F884:  RRCF   xCD,F
....................       ADC_average(200); 
0F886:  CLRF   xD4
0F888:  MOVLW  C8
0F88A:  MOVWF  xD3
0F88C:  MOVLB  0
0F88E:  RCALL  F650
....................       output = ADC_val[2]; 
0F890:  MOVFF  4AA,8D0
0F894:  MOVFF  4A9,8CF
....................       temp = ADC_val[3]; 
0F898:  MOVFF  4AC,8D2
0F89C:  MOVFF  4AB,8D1
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F8A0:  MOVLB  8
0F8A2:  MOVF   xC9,W
0F8A4:  SUBWF  xD0,W
0F8A6:  BNC   F8BA
0F8A8:  BNZ   F8B0
0F8AA:  MOVF   xCF,W
0F8AC:  SUBWF  xC8,W
0F8AE:  BC    F8BA
....................          LED_level=LED_level-LED_level_change; 
0F8B0:  MOVF   xCD,W
0F8B2:  SUBWF  xCB,F
0F8B4:  MOVF   xCE,W
0F8B6:  SUBWFB xCC,F
....................       } 
0F8B8:  BRA    F8E0
....................       else if(output<intensity){ 
0F8BA:  MOVF   xD0,W
0F8BC:  SUBWF  xC9,W
0F8BE:  BNC   F8D2
0F8C0:  BNZ   F8C8
0F8C2:  MOVF   xC8,W
0F8C4:  SUBWF  xCF,W
0F8C6:  BC    F8D2
....................          LED_level=LED_level+LED_level_change; 
0F8C8:  MOVF   xCD,W
0F8CA:  ADDWF  xCB,F
0F8CC:  MOVF   xCE,W
0F8CE:  ADDWFC xCC,F
....................       } 
0F8D0:  BRA    F8E0
....................       else if(output==intensity) break; 
0F8D2:  MOVF   xC8,W
0F8D4:  SUBWF  xCF,W
0F8D6:  BNZ   F8E0
0F8D8:  MOVF   xC9,W
0F8DA:  SUBWF  xD0,W
0F8DC:  BTFSC  FD8.2
0F8DE:  BRA    F8E4
0F8E0:  INCF   xCA,F
0F8E2:  BRA    F868
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F8E4:  MOVLW  01
0F8E6:  MOVWF  xD3
0F8E8:  MOVFF  8CC,8D5
0F8EC:  MOVFF  8CB,8D4
0F8F0:  MOVLB  0
0F8F2:  RCALL  F5A8
0F8F4:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F8F6:  MOVLW  01
0F8F8:  MOVLB  8
0F8FA:  MOVWF  xC7
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F8FC:  MOVF   xC5,F
0F8FE:  BNZ   F904
0F900:  MOVF   xC6,F
0F902:  BZ    F918
0F904:  MOVF   xC6,W
0F906:  SUBLW  0F
0F908:  BNC   F918
0F90A:  MOVFF  8C6,8C9
0F90E:  MOVFF  8C5,8C8
0F912:  MOVLB  0
0F914:  RCALL  F85A
0F916:  MOVLB  8
....................   if(intensity == 0) { 
0F918:  MOVF   xC5,F
0F91A:  BNZ   F93E
0F91C:  MOVF   xC6,F
0F91E:  BNZ   F93E
....................       DAC_set(1, 0); 
0F920:  MOVLW  01
0F922:  MOVWF  xD3
0F924:  CLRF   xD5
0F926:  CLRF   xD4
0F928:  MOVLB  0
0F92A:  RCALL  F5A8
....................       DAC_set(2, 0); 
0F92C:  MOVLW  02
0F92E:  MOVLB  8
0F930:  MOVWF  xD3
0F932:  CLRF   xD5
0F934:  CLRF   xD4
0F936:  MOVLB  0
0F938:  RCALL  F5A8
....................    } 
0F93A:  BRA    F942
0F93C:  MOVLB  8
....................    else valid=FALSE; 
0F93E:  CLRF   xC7
0F940:  MOVLB  0
....................    return(valid); 
0F942:  MOVLB  8
0F944:  MOVFF  8C7,01
0F948:  MOVLB  0
0F94A:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FECC:  MOVLW  40
0FECE:  MOVWF  FF6
0FED0:  MOVLW  1D
0FED2:  MOVWF  FF7
0FED4:  MOVLW  00
0FED6:  MOVWF  FF8
0FED8:  MOVLW  03
0FEDA:  MOVWF  FEA
0FEDC:  MOVLW  3D
0FEDE:  MOVWF  FE9
0FEE0:  RCALL  FE92
0FEE2:  MOVF   01,W
0FEE4:  BZ    FEF8
0FEE6:  XORLW  01
0FEE8:  BZ    FF18
0FEEA:  XORLW  03
0FEEC:  BZ    FF38
0FEEE:  XORLW  01
0FEF0:  BZ    FF58
0FEF2:  XORLW  07
0FEF4:  BZ    FF78
0FEF6:  BRA    FF96
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FEF8:  BCF    FD8.0
0FEFA:  MOVLB  3
0FEFC:  RLCF   x4A,W
0FEFE:  CLRF   03
0FF00:  ADDLW  4B
0FF02:  MOVWF  FE9
0FF04:  MOVLW  03
0FF06:  ADDWFC 03,W
0FF08:  MOVWF  FEA
0FF0A:  MOVFF  4A8,FEC
0FF0E:  MOVF   FED,F
0FF10:  MOVFF  4A7,FEF
....................          break; 
0FF14:  MOVLB  0
0FF16:  BRA    FF96
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FF18:  BCF    FD8.0
0FF1A:  MOVLB  3
0FF1C:  RLCF   x4A,W
0FF1E:  CLRF   03
0FF20:  ADDLW  5D
0FF22:  MOVWF  FE9
0FF24:  MOVLW  03
0FF26:  ADDWFC 03,W
0FF28:  MOVWF  FEA
0FF2A:  MOVFF  4A8,FEC
0FF2E:  MOVF   FED,F
0FF30:  MOVFF  4A7,FEF
....................          break;    
0FF34:  MOVLB  0
0FF36:  BRA    FF96
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FF38:  BCF    FD8.0
0FF3A:  MOVLB  3
0FF3C:  RLCF   x4A,W
0FF3E:  CLRF   03
0FF40:  ADDLW  6F
0FF42:  MOVWF  FE9
0FF44:  MOVLW  03
0FF46:  ADDWFC 03,W
0FF48:  MOVWF  FEA
0FF4A:  MOVFF  4A8,FEC
0FF4E:  MOVF   FED,F
0FF50:  MOVFF  4A7,FEF
....................          break; 
0FF54:  MOVLB  0
0FF56:  BRA    FF96
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FF58:  BCF    FD8.0
0FF5A:  MOVLB  3
0FF5C:  RLCF   x4A,W
0FF5E:  CLRF   03
0FF60:  ADDLW  81
0FF62:  MOVWF  FE9
0FF64:  MOVLW  03
0FF66:  ADDWFC 03,W
0FF68:  MOVWF  FEA
0FF6A:  MOVFF  4A8,FEC
0FF6E:  MOVF   FED,F
0FF70:  MOVFF  4A7,FEF
....................          break; 
0FF74:  MOVLB  0
0FF76:  BRA    FF96
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FF78:  BCF    FD8.0
0FF7A:  MOVLB  3
0FF7C:  RLCF   x4A,W
0FF7E:  CLRF   03
0FF80:  ADDLW  93
0FF82:  MOVWF  FE9
0FF84:  MOVLW  03
0FF86:  ADDWFC 03,W
0FF88:  MOVWF  FEA
0FF8A:  MOVFF  4A8,FEC
0FF8E:  MOVF   FED,F
0FF90:  MOVFF  4A7,FEF
....................          break; 
0FF94:  MOVLB  0
....................    } 
0FF96:  GOTO   102F8 (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
100B6:  MOVFF  8C3,8D4
100BA:  MOVFF  8C2,8D3
100BE:  CALL   F650
....................     
....................    v_supply = read_supply(); 
100C2:  CALL   5124
100C6:  MOVFF  02,8C8
100CA:  MOVFF  01,8C7
....................        
....................    RTC_reset_HT(); 
100CE:  CALL   34DA
....................    RTC_read(); 
100D2:  CALL   336C
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
100D6:  RCALL  F964
100D8:  MOVFF  02,8CA
100DC:  MOVFF  01,8C9
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
100E0:  MOVLB  8
100E2:  DECFSZ xC6,W
100E4:  BRA    1010E
100E6:  MOVLW  10
100E8:  MOVWF  FE9
100EA:  CLRF   1B
100EC:  BTFSC  FF2.7
100EE:  BSF    1B.7
100F0:  BCF    FF2.7
100F2:  MOVFF  4AA,A41
100F6:  MOVFF  4A9,A40
100FA:  MOVLB  0
100FC:  CALL   11C6
10100:  BTFSC  1B.7
10102:  BSF    FF2.7
10104:  MOVLW  2C
10106:  BTFSS  F9E.4
10108:  BRA    10106
1010A:  MOVWF  FAD
1010C:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
1010E:  CLRF   1E
10110:  MOVLW  67
10112:  MOVWF  1D
10114:  MOVFF  72A,8ED
10118:  MOVLW  01
1011A:  MOVWF  xEE
1011C:  MOVLB  0
1011E:  CALL   52A8
10122:  MOVLW  2F
10124:  MOVLB  8
10126:  MOVWF  xFF
10128:  MOVLB  0
1012A:  CALL   50C6
1012E:  MOVFF  729,8ED
10132:  MOVLW  01
10134:  MOVLB  8
10136:  MOVWF  xEE
10138:  MOVLB  0
1013A:  CALL   52A8
1013E:  MOVLW  2F
10140:  MOVLB  8
10142:  MOVWF  xFF
10144:  MOVLB  0
10146:  CALL   50C6
1014A:  MOVFF  72B,8ED
1014E:  MOVLW  01
10150:  MOVLB  8
10152:  MOVWF  xEE
10154:  MOVLB  0
10156:  CALL   52A8
1015A:  MOVLW  20
1015C:  MOVLB  8
1015E:  MOVWF  xFF
10160:  MOVLB  0
10162:  CALL   50C6
10166:  MOVFF  727,8ED
1016A:  MOVLW  01
1016C:  MOVLB  8
1016E:  MOVWF  xEE
10170:  MOVLB  0
10172:  CALL   52A8
10176:  MOVLW  3A
10178:  MOVLB  8
1017A:  MOVWF  xFF
1017C:  MOVLB  0
1017E:  CALL   50C6
10182:  MOVFF  726,8ED
10186:  MOVLW  01
10188:  MOVLB  8
1018A:  MOVWF  xEE
1018C:  MOVLB  0
1018E:  CALL   52A8
10192:  MOVLW  3A
10194:  MOVLB  8
10196:  MOVWF  xFF
10198:  MOVLB  0
1019A:  CALL   50C6
1019E:  MOVFF  725,8ED
101A2:  MOVLW  01
101A4:  MOVLB  8
101A6:  MOVWF  xEE
101A8:  MOVLB  0
101AA:  CALL   52A8
101AE:  MOVLW  2C
101B0:  MOVLB  8
101B2:  MOVWF  xFF
101B4:  MOVLB  0
101B6:  CALL   50C6
101BA:  MOVLW  04
101BC:  MOVWF  FE9
101BE:  MOVLB  8
101C0:  CLRF   xF0
101C2:  CLRF   xEF
101C4:  MOVFF  8C8,8EE
101C8:  MOVFF  8C7,8ED
101CC:  MOVLW  02
101CE:  MOVWF  xF1
101D0:  MOVLB  0
101D2:  CALL   5342
101D6:  MOVLW  2C
101D8:  MOVLB  8
101DA:  MOVWF  xFF
101DC:  MOVLB  0
101DE:  CALL   50C6
101E2:  MOVFF  1E,FEA
101E6:  MOVFF  1D,FE9
101EA:  CLRF   FEF
101EC:  MOVLW  03
101EE:  MOVWF  FEA
101F0:  MOVLW  3D
101F2:  MOVWF  FE9
101F4:  RCALL  FE6C
101F6:  MOVLW  2C
101F8:  MOVLB  8
101FA:  MOVWF  xFF
101FC:  MOVLB  0
101FE:  CALL   50C6
10202:  MOVFF  1E,FEA
10206:  MOVFF  1D,FE9
1020A:  CLRF   FEF
1020C:  MOVLW  03
1020E:  MOVWF  FEA
10210:  MOVLW  42
10212:  MOVWF  FE9
10214:  RCALL  FE6C
10216:  MOVLW  2C
10218:  MOVLB  8
1021A:  MOVWF  xFF
1021C:  MOVLB  0
1021E:  CALL   50C6
10222:  MOVFF  1E,FEA
10226:  MOVFF  1D,FE9
1022A:  CLRF   FEF
1022C:  MOVLW  03
1022E:  MOVWF  FEA
10230:  MOVLW  46
10232:  MOVWF  FE9
10234:  RCALL  FE6C
10236:  MOVLW  2C
10238:  MOVLB  8
1023A:  MOVWF  xFF
1023C:  MOVLB  0
1023E:  CALL   50C6
10242:  MOVLW  10
10244:  MOVWF  FE9
10246:  MOVFF  26,8F7
1024A:  MOVFF  25,8F6
1024E:  CALL   AB26
10252:  MOVLW  2C
10254:  MOVLB  8
10256:  MOVWF  xFF
10258:  MOVLB  0
1025A:  CALL   50C6
1025E:  MOVLW  10
10260:  MOVWF  FE9
10262:  MOVFF  8CA,8F7
10266:  MOVFF  8C9,8F6
1026A:  CALL   AB26
1026E:  MOVLW  2C
10270:  MOVLB  8
10272:  MOVWF  xFF
10274:  MOVLB  0
10276:  CALL   50C6
1027A:  MOVFF  4B5,8ED
1027E:  MOVLW  1B
10280:  MOVLB  8
10282:  MOVWF  xEE
10284:  MOVLB  0
10286:  CALL   52A8
1028A:  MOVLW  2C
1028C:  MOVLB  8
1028E:  MOVWF  xFF
10290:  MOVLB  0
10292:  CALL   50C6
10296:  MOVLW  10
10298:  MOVWF  FE9
1029A:  MOVFF  4A8,8F7
1029E:  MOVFF  4A7,8F6
102A2:  CALL   AB26
102A6:  MOVLW  2C
102A8:  MOVLB  8
102AA:  MOVWF  xFF
102AC:  MOVLB  0
102AE:  CALL   50C6
102B2:  MOVLW  10
102B4:  MOVWF  FE9
102B6:  MOVFF  4AE,8F7
102BA:  MOVFF  4AD,8F6
102BE:  CALL   AB26
102C2:  MOVLW  2C
102C4:  MOVLB  8
102C6:  MOVWF  xFF
102C8:  MOVLB  0
102CA:  CALL   50C6
102CE:  MOVLW  10
102D0:  MOVWF  FE9
102D2:  MOVFF  4AC,8F7
102D6:  MOVFF  4AB,8F6
102DA:  CALL   AB26
102DE:  MOVLW  0D
102E0:  MOVLB  8
102E2:  MOVWF  xFF
102E4:  MOVLB  0
102E6:  CALL   50C6
102EA:  MOVLW  0A
102EC:  MOVLB  8
102EE:  MOVWF  xFF
102F0:  MOVLB  0
102F2:  CALL   50C6
....................  
....................    load_scanned_data();  
102F6:  BRA    FECC
....................  
....................    display_rec(store, display); 
102F8:  MOVFF  8C4,8EB
102FC:  MOVFF  8C5,8EC
10300:  RCALL  10000
....................     
....................    data_available = TRUE; 
10302:  MOVLW  01
10304:  MOVLB  3
10306:  MOVWF  x3B
....................    macro_flag = 900; 
10308:  MOVLW  03
1030A:  MOVWF  x24
1030C:  MOVLW  84
1030E:  MOVWF  x23
10310:  MOVLB  0
10312:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
10314:  MOVLB  8
10316:  CLRF   x8B
10318:  CLRF   x8A
....................    channel=channel-20000; 
1031A:  MOVLW  20
1031C:  SUBWF  x87,F
1031E:  MOVLW  4E
10320:  SUBWFB x88,F
....................     
....................    for (i=0; i<9; i++){ 
10322:  CLRF   x89
10324:  MOVF   x89,W
10326:  SUBLW  08
10328:  BNC   103CA
....................       DAC_set(channel, setting); 
1032A:  MOVFF  887,8D3
1032E:  MOVFF  88B,8D5
10332:  MOVFF  88A,8D4
10336:  MOVLB  0
10338:  CALL   F5A8
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
1033C:  MOVLW  56
1033E:  MOVWF  FF6
10340:  MOVLW  1D
10342:  MOVWF  FF7
10344:  MOVLW  00
10346:  MOVWF  FF8
10348:  CLRF   1B
1034A:  BTFSC  FF2.7
1034C:  BSF    1B.7
1034E:  BCF    FF2.7
10350:  MOVLW  05
10352:  MOVLB  A
10354:  MOVWF  x40
10356:  MOVLB  0
10358:  CALL   1044
1035C:  BTFSC  1B.7
1035E:  BSF    FF2.7
10360:  MOVLW  10
10362:  MOVWF  FE9
10364:  CLRF   1B
10366:  BTFSC  FF2.7
10368:  BSF    1B.7
1036A:  BCF    FF2.7
1036C:  MOVFF  888,A41
10370:  MOVFF  887,A40
10374:  CALL   11C6
10378:  BTFSC  1B.7
1037A:  BSF    FF2.7
1037C:  MOVLW  2C
1037E:  BTFSS  F9E.4
10380:  BRA    1037E
10382:  MOVWF  FAD
10384:  MOVLW  10
10386:  MOVWF  FE9
10388:  CLRF   1B
1038A:  BTFSC  FF2.7
1038C:  BSF    1B.7
1038E:  BCF    FF2.7
10390:  MOVFF  88B,A41
10394:  MOVFF  88A,A40
10398:  CALL   11C6
1039C:  BTFSC  1B.7
1039E:  BSF    FF2.7
103A0:  MOVLW  2C
103A2:  BTFSS  F9E.4
103A4:  BRA    103A2
103A6:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
103A8:  MOVLB  8
103AA:  CLRF   xC3
103AC:  MOVLW  C8
103AE:  MOVWF  xC2
103B0:  CLRF   xC4
103B2:  MOVLW  01
103B4:  MOVWF  xC5
103B6:  MOVWF  xC6
103B8:  MOVLB  0
103BA:  RCALL  100B6
....................       setting = setting+500; 
103BC:  MOVLW  F4
103BE:  MOVLB  8
103C0:  ADDWF  x8A,F
103C2:  MOVLW  01
103C4:  ADDWFC x8B,F
103C6:  INCF   x89,F
103C8:  BRA    10324
....................    } 
103CA:  MOVLB  0
103CC:  GOTO   10528 (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
103D0:  MOVLB  8
103D2:  CLRF   x87
103D4:  CLRF   x86
....................     
....................    for (i=0; i<9; i++){ 
103D6:  CLRF   x85
103D8:  MOVF   x85,W
103DA:  SUBLW  08
103DC:  BNC   10456
....................       LED_SAR(intensity); 
103DE:  MOVFF  887,8C9
103E2:  MOVFF  886,8C8
103E6:  MOVLB  0
103E8:  CALL   F85A
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
103EC:  MOVLW  64
103EE:  MOVWF  FF6
103F0:  MOVLW  1D
103F2:  MOVWF  FF7
103F4:  MOVLW  00
103F6:  MOVWF  FF8
103F8:  CLRF   1B
103FA:  BTFSC  FF2.7
103FC:  BSF    1B.7
103FE:  BCF    FF2.7
10400:  MOVLW  07
10402:  MOVLB  A
10404:  MOVWF  x40
10406:  MOVLB  0
10408:  CALL   1044
1040C:  BTFSC  1B.7
1040E:  BSF    FF2.7
10410:  MOVLW  10
10412:  MOVWF  FE9
10414:  CLRF   1B
10416:  BTFSC  FF2.7
10418:  BSF    1B.7
1041A:  BCF    FF2.7
1041C:  MOVFF  887,A41
10420:  MOVFF  886,A40
10424:  CALL   11C6
10428:  BTFSC  1B.7
1042A:  BSF    FF2.7
1042C:  MOVLW  2C
1042E:  BTFSS  F9E.4
10430:  BRA    1042E
10432:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
10434:  MOVLB  8
10436:  CLRF   xC3
10438:  MOVLW  C8
1043A:  MOVWF  xC2
1043C:  CLRF   xC4
1043E:  MOVLW  01
10440:  MOVWF  xC5
10442:  MOVWF  xC6
10444:  MOVLB  0
10446:  RCALL  100B6
....................       intensity = intensity+500; 
10448:  MOVLW  F4
1044A:  MOVLB  8
1044C:  ADDWF  x86,F
1044E:  MOVLW  01
10450:  ADDWFC x87,F
10452:  INCF   x85,F
10454:  BRA    103D8
....................    } 
10456:  MOVLB  0
10458:  GOTO   10528 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
030E2:  MOVLB  8
030E4:  CLRF   xB6
030E6:  MOVF   xB6,W
030E8:  SUBLW  20
030EA:  BNC   3100
030EC:  CLRF   03
030EE:  MOVF   xB6,W
030F0:  ADDLW  B7
030F2:  MOVWF  FE9
030F4:  MOVLW  04
030F6:  ADDWFC 03,W
030F8:  MOVWF  FEA
030FA:  CLRF   FEF
030FC:  INCF   xB6,F
030FE:  BRA    30E6
03100:  MOVLB  0
03102:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
03104:  MOVF   2F,W
03106:  SUBLW  02
03108:  BNZ   3112
0310A:  MOVF   30,F
0310C:  BNZ   3112
0310E:  MOVLW  00
03110:  MOVWF  F99
....................    init_valve_status(); 
03112:  RCALL  30E2
....................    bus_pwr_status=0; 
03114:  MOVLB  4
03116:  CLRF   xB6
03118:  MOVLB  0
0311A:  GOTO   1B884 (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0ED96:  MOVLW  70
0ED98:  MOVWF  FF6
0ED9A:  MOVLW  1D
0ED9C:  MOVWF  FF7
0ED9E:  MOVLW  00
0EDA0:  MOVWF  FF8
0EDA2:  CLRF   1B
0EDA4:  BTFSC  FF2.7
0EDA6:  BSF    1B.7
0EDA8:  BCF    FF2.7
0EDAA:  CALL   0E6E
0EDAE:  BTFSC  1B.7
0EDB0:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EDB2:  MOVLW  01
0EDB4:  MOVLB  8
0EDB6:  MOVWF  xB6
0EDB8:  MOVF   xB6,W
0EDBA:  SUBLW  08
0EDBC:  BNC   EE26
0EDBE:  CLRF   03
0EDC0:  MOVF   xB6,W
0EDC2:  ADDLW  B7
0EDC4:  MOVWF  FE9
0EDC6:  MOVLW  04
0EDC8:  ADDWFC 03,W
0EDCA:  MOVWF  FEA
0EDCC:  MOVFF  FEF,8B7
0EDD0:  CLRF   1B
0EDD2:  BTFSC  FF2.7
0EDD4:  BSF    1B.7
0EDD6:  BCF    FF2.7
0EDD8:  MOVFF  8B6,A40
0EDDC:  MOVLW  01
0EDDE:  MOVLB  A
0EDE0:  MOVWF  x41
0EDE2:  MOVLB  0
0EDE4:  CALL   0FC6
0EDE8:  BTFSC  1B.7
0EDEA:  BSF    FF2.7
0EDEC:  MOVLW  5B
0EDEE:  BTFSS  F9E.4
0EDF0:  BRA    EDEE
0EDF2:  MOVWF  FAD
0EDF4:  CLRF   1B
0EDF6:  BTFSC  FF2.7
0EDF8:  BSF    1B.7
0EDFA:  BCF    FF2.7
0EDFC:  MOVFF  8B7,A40
0EE00:  MOVLW  1B
0EE02:  MOVLB  A
0EE04:  MOVWF  x41
0EE06:  MOVLB  0
0EE08:  CALL   0FC6
0EE0C:  BTFSC  1B.7
0EE0E:  BSF    FF2.7
0EE10:  MOVLW  5D
0EE12:  BTFSS  F9E.4
0EE14:  BRA    EE12
0EE16:  MOVWF  FAD
0EE18:  MOVLW  20
0EE1A:  BTFSS  F9E.4
0EE1C:  BRA    EE1A
0EE1E:  MOVWF  FAD
0EE20:  MOVLB  8
0EE22:  INCF   xB6,F
0EE24:  BRA    EDB8
....................    fprintf(COM_A, "\r\n"); 
0EE26:  MOVLW  0D
0EE28:  BTFSS  F9E.4
0EE2A:  BRA    EE28
0EE2C:  MOVWF  FAD
0EE2E:  MOVLW  0A
0EE30:  BTFSS  F9E.4
0EE32:  BRA    EE30
0EE34:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EE36:  MOVLW  76
0EE38:  MOVWF  FF6
0EE3A:  MOVLW  1D
0EE3C:  MOVWF  FF7
0EE3E:  MOVLW  00
0EE40:  MOVWF  FF8
0EE42:  CLRF   1B
0EE44:  BTFSC  FF2.7
0EE46:  BSF    1B.7
0EE48:  BCF    FF2.7
0EE4A:  MOVLB  0
0EE4C:  CALL   0E6E
0EE50:  BTFSC  1B.7
0EE52:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EE54:  MOVLW  09
0EE56:  MOVLB  8
0EE58:  MOVWF  xB6
0EE5A:  MOVF   xB6,W
0EE5C:  SUBLW  10
0EE5E:  BNC   EEC8
0EE60:  CLRF   03
0EE62:  MOVF   xB6,W
0EE64:  ADDLW  B7
0EE66:  MOVWF  FE9
0EE68:  MOVLW  04
0EE6A:  ADDWFC 03,W
0EE6C:  MOVWF  FEA
0EE6E:  MOVFF  FEF,8B7
0EE72:  CLRF   1B
0EE74:  BTFSC  FF2.7
0EE76:  BSF    1B.7
0EE78:  BCF    FF2.7
0EE7A:  MOVFF  8B6,A40
0EE7E:  MOVLW  01
0EE80:  MOVLB  A
0EE82:  MOVWF  x41
0EE84:  MOVLB  0
0EE86:  CALL   0FC6
0EE8A:  BTFSC  1B.7
0EE8C:  BSF    FF2.7
0EE8E:  MOVLW  5B
0EE90:  BTFSS  F9E.4
0EE92:  BRA    EE90
0EE94:  MOVWF  FAD
0EE96:  CLRF   1B
0EE98:  BTFSC  FF2.7
0EE9A:  BSF    1B.7
0EE9C:  BCF    FF2.7
0EE9E:  MOVFF  8B7,A40
0EEA2:  MOVLW  1B
0EEA4:  MOVLB  A
0EEA6:  MOVWF  x41
0EEA8:  MOVLB  0
0EEAA:  CALL   0FC6
0EEAE:  BTFSC  1B.7
0EEB0:  BSF    FF2.7
0EEB2:  MOVLW  5D
0EEB4:  BTFSS  F9E.4
0EEB6:  BRA    EEB4
0EEB8:  MOVWF  FAD
0EEBA:  MOVLW  20
0EEBC:  BTFSS  F9E.4
0EEBE:  BRA    EEBC
0EEC0:  MOVWF  FAD
0EEC2:  MOVLB  8
0EEC4:  INCF   xB6,F
0EEC6:  BRA    EE5A
....................    fprintf(COM_A, "\r\n"); 
0EEC8:  MOVLW  0D
0EECA:  BTFSS  F9E.4
0EECC:  BRA    EECA
0EECE:  MOVWF  FAD
0EED0:  MOVLW  0A
0EED2:  BTFSS  F9E.4
0EED4:  BRA    EED2
0EED6:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EED8:  MOVLW  7C
0EEDA:  MOVWF  FF6
0EEDC:  MOVLW  1D
0EEDE:  MOVWF  FF7
0EEE0:  MOVLW  00
0EEE2:  MOVWF  FF8
0EEE4:  CLRF   1B
0EEE6:  BTFSC  FF2.7
0EEE8:  BSF    1B.7
0EEEA:  BCF    FF2.7
0EEEC:  MOVLB  0
0EEEE:  CALL   0E6E
0EEF2:  BTFSC  1B.7
0EEF4:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EEF6:  MOVLW  11
0EEF8:  MOVLB  8
0EEFA:  MOVWF  xB6
0EEFC:  MOVF   xB6,W
0EEFE:  SUBLW  18
0EF00:  BNC   EF6A
0EF02:  CLRF   03
0EF04:  MOVF   xB6,W
0EF06:  ADDLW  B7
0EF08:  MOVWF  FE9
0EF0A:  MOVLW  04
0EF0C:  ADDWFC 03,W
0EF0E:  MOVWF  FEA
0EF10:  MOVFF  FEF,8B7
0EF14:  CLRF   1B
0EF16:  BTFSC  FF2.7
0EF18:  BSF    1B.7
0EF1A:  BCF    FF2.7
0EF1C:  MOVFF  8B6,A40
0EF20:  MOVLW  01
0EF22:  MOVLB  A
0EF24:  MOVWF  x41
0EF26:  MOVLB  0
0EF28:  CALL   0FC6
0EF2C:  BTFSC  1B.7
0EF2E:  BSF    FF2.7
0EF30:  MOVLW  5B
0EF32:  BTFSS  F9E.4
0EF34:  BRA    EF32
0EF36:  MOVWF  FAD
0EF38:  CLRF   1B
0EF3A:  BTFSC  FF2.7
0EF3C:  BSF    1B.7
0EF3E:  BCF    FF2.7
0EF40:  MOVFF  8B7,A40
0EF44:  MOVLW  1B
0EF46:  MOVLB  A
0EF48:  MOVWF  x41
0EF4A:  MOVLB  0
0EF4C:  CALL   0FC6
0EF50:  BTFSC  1B.7
0EF52:  BSF    FF2.7
0EF54:  MOVLW  5D
0EF56:  BTFSS  F9E.4
0EF58:  BRA    EF56
0EF5A:  MOVWF  FAD
0EF5C:  MOVLW  20
0EF5E:  BTFSS  F9E.4
0EF60:  BRA    EF5E
0EF62:  MOVWF  FAD
0EF64:  MOVLB  8
0EF66:  INCF   xB6,F
0EF68:  BRA    EEFC
....................    fprintf(COM_A, "\r\n"); 
0EF6A:  MOVLW  0D
0EF6C:  BTFSS  F9E.4
0EF6E:  BRA    EF6C
0EF70:  MOVWF  FAD
0EF72:  MOVLW  0A
0EF74:  BTFSS  F9E.4
0EF76:  BRA    EF74
0EF78:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EF7A:  MOVLW  82
0EF7C:  MOVWF  FF6
0EF7E:  MOVLW  1D
0EF80:  MOVWF  FF7
0EF82:  MOVLW  00
0EF84:  MOVWF  FF8
0EF86:  CLRF   1B
0EF88:  BTFSC  FF2.7
0EF8A:  BSF    1B.7
0EF8C:  BCF    FF2.7
0EF8E:  MOVLB  0
0EF90:  CALL   0E6E
0EF94:  BTFSC  1B.7
0EF96:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EF98:  MOVLW  19
0EF9A:  MOVLB  8
0EF9C:  MOVWF  xB6
0EF9E:  MOVF   xB6,W
0EFA0:  SUBLW  20
0EFA2:  BNC   F00C
0EFA4:  CLRF   03
0EFA6:  MOVF   xB6,W
0EFA8:  ADDLW  B7
0EFAA:  MOVWF  FE9
0EFAC:  MOVLW  04
0EFAE:  ADDWFC 03,W
0EFB0:  MOVWF  FEA
0EFB2:  MOVFF  FEF,8B7
0EFB6:  CLRF   1B
0EFB8:  BTFSC  FF2.7
0EFBA:  BSF    1B.7
0EFBC:  BCF    FF2.7
0EFBE:  MOVFF  8B6,A40
0EFC2:  MOVLW  01
0EFC4:  MOVLB  A
0EFC6:  MOVWF  x41
0EFC8:  MOVLB  0
0EFCA:  CALL   0FC6
0EFCE:  BTFSC  1B.7
0EFD0:  BSF    FF2.7
0EFD2:  MOVLW  5B
0EFD4:  BTFSS  F9E.4
0EFD6:  BRA    EFD4
0EFD8:  MOVWF  FAD
0EFDA:  CLRF   1B
0EFDC:  BTFSC  FF2.7
0EFDE:  BSF    1B.7
0EFE0:  BCF    FF2.7
0EFE2:  MOVFF  8B7,A40
0EFE6:  MOVLW  1B
0EFE8:  MOVLB  A
0EFEA:  MOVWF  x41
0EFEC:  MOVLB  0
0EFEE:  CALL   0FC6
0EFF2:  BTFSC  1B.7
0EFF4:  BSF    FF2.7
0EFF6:  MOVLW  5D
0EFF8:  BTFSS  F9E.4
0EFFA:  BRA    EFF8
0EFFC:  MOVWF  FAD
0EFFE:  MOVLW  20
0F000:  BTFSS  F9E.4
0F002:  BRA    F000
0F004:  MOVWF  FAD
0F006:  MOVLB  8
0F008:  INCF   xB6,F
0F00A:  BRA    EF9E
....................    fprintf(COM_A, "\r\n");    
0F00C:  MOVLW  0D
0F00E:  BTFSS  F9E.4
0F010:  BRA    F00E
0F012:  MOVWF  FAD
0F014:  MOVLW  0A
0F016:  BTFSS  F9E.4
0F018:  BRA    F016
0F01A:  MOVWF  FAD
0F01C:  MOVLB  0
0F01E:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
144E2:  MOVF   1F,W
144E4:  SUBLW  04
144E6:  BNZ   14550
144E8:  MOVF   20,F
144EA:  BNZ   14550
144EC:  MOVLW  88
144EE:  MOVWF  FF6
144F0:  MOVLW  1D
144F2:  MOVWF  FF7
144F4:  MOVLW  00
144F6:  MOVWF  FF8
144F8:  CLRF   1B
144FA:  BTFSC  FF2.7
144FC:  BSF    1B.7
144FE:  BCF    FF2.7
14500:  MOVLW  0C
14502:  MOVLB  A
14504:  MOVWF  x40
14506:  MOVLB  0
14508:  CALL   1044
1450C:  BTFSC  1B.7
1450E:  BSF    FF2.7
14510:  MOVLW  10
14512:  MOVWF  FE9
14514:  CLRF   1B
14516:  BTFSC  FF2.7
14518:  BSF    1B.7
1451A:  BCF    FF2.7
1451C:  MOVFF  8B7,A41
14520:  MOVFF  8B6,A40
14524:  CALL   11C6
14528:  BTFSC  1B.7
1452A:  BSF    FF2.7
1452C:  MOVLW  97
1452E:  MOVWF  FF6
14530:  MOVLW  1D
14532:  MOVWF  FF7
14534:  MOVLW  00
14536:  MOVWF  FF8
14538:  CLRF   1B
1453A:  BTFSC  FF2.7
1453C:  BSF    1B.7
1453E:  BCF    FF2.7
14540:  MOVLW  03
14542:  MOVLB  A
14544:  MOVWF  x40
14546:  MOVLB  0
14548:  CALL   1044
1454C:  BTFSC  1B.7
1454E:  BSF    FF2.7
....................  
....................    multidrop_on(); 
14550:  CALL   DAA8
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
14554:  MOVLW  9C
14556:  MOVWF  FF6
14558:  MOVLW  1D
1455A:  MOVWF  FF7
1455C:  MOVLW  00
1455E:  MOVWF  FF8
14560:  MOVLW  03
14562:  MOVLB  8
14564:  MOVWF  xB8
14566:  MOVLB  0
14568:  CALL   DABC
1456C:  MOVLW  10
1456E:  MOVWF  FE9
14570:  MOVFF  8B7,8B9
14574:  MOVFF  8B6,8B8
14578:  BRA    14428
1457A:  MOVLW  0D
1457C:  BTFSS  FA4.4
1457E:  BRA    1457C
14580:  MOVLB  F
14582:  MOVWF  x1C
....................    multidrop_off(); 
14584:  MOVLB  0
14586:  CALL   DB94
....................  
....................    delay_ms(100); 
1458A:  MOVLW  64
1458C:  MOVLB  9
1458E:  MOVWF  xEC
14590:  MOVLB  0
14592:  CALL   2938
14596:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0DBE6:  MOVF   1F,W
0DBE8:  SUBLW  04
0DBEA:  BNZ   DC54
0DBEC:  MOVF   20,F
0DBEE:  BNZ   DC54
0DBF0:  MOVLW  A4
0DBF2:  MOVWF  FF6
0DBF4:  MOVLW  1D
0DBF6:  MOVWF  FF7
0DBF8:  MOVLW  00
0DBFA:  MOVWF  FF8
0DBFC:  CLRF   1B
0DBFE:  BTFSC  FF2.7
0DC00:  BSF    1B.7
0DC02:  BCF    FF2.7
0DC04:  MOVLW  0C
0DC06:  MOVLB  A
0DC08:  MOVWF  x40
0DC0A:  MOVLB  0
0DC0C:  CALL   1044
0DC10:  BTFSC  1B.7
0DC12:  BSF    FF2.7
0DC14:  CLRF   1B
0DC16:  BTFSC  FF2.7
0DC18:  BSF    1B.7
0DC1A:  BCF    FF2.7
0DC1C:  MOVFF  8B6,A40
0DC20:  MOVLW  1B
0DC22:  MOVLB  A
0DC24:  MOVWF  x41
0DC26:  MOVLB  0
0DC28:  CALL   0FC6
0DC2C:  BTFSC  1B.7
0DC2E:  BSF    FF2.7
0DC30:  MOVLW  B2
0DC32:  MOVWF  FF6
0DC34:  MOVLW  1D
0DC36:  MOVWF  FF7
0DC38:  MOVLW  00
0DC3A:  MOVWF  FF8
0DC3C:  CLRF   1B
0DC3E:  BTFSC  FF2.7
0DC40:  BSF    1B.7
0DC42:  BCF    FF2.7
0DC44:  MOVLW  03
0DC46:  MOVLB  A
0DC48:  MOVWF  x40
0DC4A:  MOVLB  0
0DC4C:  CALL   1044
0DC50:  BTFSC  1B.7
0DC52:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0DC54:  RCALL  DAA8
....................       fprintf(COM_B, "/1c%u\r",chip); 
0DC56:  MOVLW  B6
0DC58:  MOVWF  FF6
0DC5A:  MOVLW  1D
0DC5C:  MOVWF  FF7
0DC5E:  MOVLW  00
0DC60:  MOVWF  FF8
0DC62:  MOVLW  03
0DC64:  MOVLB  8
0DC66:  MOVWF  xB8
0DC68:  MOVLB  0
0DC6A:  RCALL  DABC
0DC6C:  MOVFF  8B6,8F3
0DC70:  MOVLW  1B
0DC72:  MOVLB  8
0DC74:  MOVWF  xF4
0DC76:  MOVLB  0
0DC78:  RCALL  DAF0
0DC7A:  MOVLW  0D
0DC7C:  BTFSS  FA4.4
0DC7E:  BRA    DC7C
0DC80:  MOVLB  F
0DC82:  MOVWF  x1C
....................    multidrop_off(); 
0DC84:  MOVLB  0
0DC86:  RCALL  DB94
....................    delay_ms(100); 
0DC88:  MOVLW  64
0DC8A:  MOVLB  9
0DC8C:  MOVWF  xEC
0DC8E:  MOVLB  0
0DC90:  CALL   2938
....................  
....................    multidrop_on(); 
0DC94:  RCALL  DAA8
....................      fprintf(COM_B, "/1s256\r"); 
0DC96:  MOVLW  BE
0DC98:  MOVWF  FF6
0DC9A:  MOVLW  1D
0DC9C:  MOVWF  FF7
0DC9E:  MOVLW  00
0DCA0:  MOVWF  FF8
0DCA2:  BRA    DBB6
....................    multidrop_off();  
0DCA4:  RCALL  DB94
....................    delay_ms(100); 
0DCA6:  MOVLW  64
0DCA8:  MOVLB  9
0DCAA:  MOVWF  xEC
0DCAC:  MOVLB  0
0DCAE:  CALL   2938
0DCB2:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
14598:  MOVLB  8
1459A:  MOVF   xB5,W
1459C:  ADDLW  DF
1459E:  BTFSC  FD8.0
145A0:  BRA    1498C
145A2:  ADDLW  21
145A4:  MOVLB  0
145A6:  GOTO   149BE
....................       case 0 : sol_chip_cmd(1); 
145AA:  MOVLW  01
145AC:  MOVLB  8
145AE:  MOVWF  xB6
145B0:  MOVLB  0
145B2:  CALL   DBE6
....................                sol_switch_cmd(0); 
145B6:  MOVLB  8
145B8:  CLRF   xB7
145BA:  CLRF   xB6
145BC:  MOVLB  0
145BE:  RCALL  144E2
....................                sol_chip_cmd(2); 
145C0:  MOVLW  02
145C2:  MOVLB  8
145C4:  MOVWF  xB6
145C6:  MOVLB  0
145C8:  CALL   DBE6
....................                sol_switch_cmd(0); 
145CC:  MOVLB  8
145CE:  CLRF   xB7
145D0:  CLRF   xB6
145D2:  MOVLB  0
145D4:  RCALL  144E2
....................                sol_chip_cmd(3); 
145D6:  MOVLW  03
145D8:  MOVLB  8
145DA:  MOVWF  xB6
145DC:  MOVLB  0
145DE:  CALL   DBE6
....................                sol_switch_cmd(0); 
145E2:  MOVLB  8
145E4:  CLRF   xB7
145E6:  CLRF   xB6
145E8:  MOVLB  0
145EA:  RCALL  144E2
....................                sol_chip_cmd(4); 
145EC:  MOVLW  04
145EE:  MOVLB  8
145F0:  MOVWF  xB6
145F2:  MOVLB  0
145F4:  CALL   DBE6
....................                sol_switch_cmd(0); 
145F8:  MOVLB  8
145FA:  CLRF   xB7
145FC:  CLRF   xB6
145FE:  MOVLB  0
14600:  RCALL  144E2
....................                init_valve_status(); 
14602:  CALL   30E2
....................          break; 
14606:  MOVLB  8
14608:  BRA    1498C
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
1460A:  MOVLW  01
1460C:  MOVLB  8
1460E:  MOVWF  xB6
14610:  MOVLB  0
14612:  CALL   DBE6
....................                sol_switch_cmd(1); 
14616:  MOVLB  8
14618:  CLRF   xB7
1461A:  MOVLW  01
1461C:  MOVWF  xB6
1461E:  MOVLB  0
14620:  RCALL  144E2
....................          break;     
14622:  MOVLB  8
14624:  BRA    1498C
....................       case 2 : sol_chip_cmd(1); 
14626:  MOVLW  01
14628:  MOVLB  8
1462A:  MOVWF  xB6
1462C:  MOVLB  0
1462E:  CALL   DBE6
....................                sol_switch_cmd(2); 
14632:  MOVLB  8
14634:  CLRF   xB7
14636:  MOVLW  02
14638:  MOVWF  xB6
1463A:  MOVLB  0
1463C:  RCALL  144E2
....................          break;           
1463E:  MOVLB  8
14640:  BRA    1498C
....................       case 3 : sol_chip_cmd(1); 
14642:  MOVLW  01
14644:  MOVLB  8
14646:  MOVWF  xB6
14648:  MOVLB  0
1464A:  CALL   DBE6
....................                sol_switch_cmd(4); 
1464E:  MOVLB  8
14650:  CLRF   xB7
14652:  MOVLW  04
14654:  MOVWF  xB6
14656:  MOVLB  0
14658:  RCALL  144E2
....................          break;  
1465A:  MOVLB  8
1465C:  BRA    1498C
....................       case 4 : sol_chip_cmd(1); 
1465E:  MOVLW  01
14660:  MOVLB  8
14662:  MOVWF  xB6
14664:  MOVLB  0
14666:  CALL   DBE6
....................                sol_switch_cmd(8); 
1466A:  MOVLB  8
1466C:  CLRF   xB7
1466E:  MOVLW  08
14670:  MOVWF  xB6
14672:  MOVLB  0
14674:  RCALL  144E2
....................          break;  
14676:  MOVLB  8
14678:  BRA    1498C
....................       case 5 : sol_chip_cmd(1); 
1467A:  MOVLW  01
1467C:  MOVLB  8
1467E:  MOVWF  xB6
14680:  MOVLB  0
14682:  CALL   DBE6
....................                sol_switch_cmd(16); 
14686:  MOVLB  8
14688:  CLRF   xB7
1468A:  MOVLW  10
1468C:  MOVWF  xB6
1468E:  MOVLB  0
14690:  RCALL  144E2
....................          break;  
14692:  MOVLB  8
14694:  BRA    1498C
....................       case 6 : sol_chip_cmd(1); 
14696:  MOVLW  01
14698:  MOVLB  8
1469A:  MOVWF  xB6
1469C:  MOVLB  0
1469E:  CALL   DBE6
....................                sol_switch_cmd(32); 
146A2:  MOVLB  8
146A4:  CLRF   xB7
146A6:  MOVLW  20
146A8:  MOVWF  xB6
146AA:  MOVLB  0
146AC:  RCALL  144E2
....................          break;  
146AE:  MOVLB  8
146B0:  BRA    1498C
....................       case 7 : sol_chip_cmd(1); 
146B2:  MOVLW  01
146B4:  MOVLB  8
146B6:  MOVWF  xB6
146B8:  MOVLB  0
146BA:  CALL   DBE6
....................                sol_switch_cmd(64); 
146BE:  MOVLB  8
146C0:  CLRF   xB7
146C2:  MOVLW  40
146C4:  MOVWF  xB6
146C6:  MOVLB  0
146C8:  RCALL  144E2
....................          break;  
146CA:  MOVLB  8
146CC:  BRA    1498C
....................       case 8 : sol_chip_cmd(1); 
146CE:  MOVLW  01
146D0:  MOVLB  8
146D2:  MOVWF  xB6
146D4:  MOVLB  0
146D6:  CALL   DBE6
....................                sol_switch_cmd(128); 
146DA:  MOVLB  8
146DC:  CLRF   xB7
146DE:  MOVLW  80
146E0:  MOVWF  xB6
146E2:  MOVLB  0
146E4:  RCALL  144E2
....................          break;   
146E6:  MOVLB  8
146E8:  BRA    1498C
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
146EA:  MOVLW  02
146EC:  MOVLB  8
146EE:  MOVWF  xB6
146F0:  MOVLB  0
146F2:  CALL   DBE6
....................                sol_switch_cmd(1); 
146F6:  MOVLB  8
146F8:  CLRF   xB7
146FA:  MOVLW  01
146FC:  MOVWF  xB6
146FE:  MOVLB  0
14700:  RCALL  144E2
....................          break;     
14702:  MOVLB  8
14704:  BRA    1498C
....................       case 10 : sol_chip_cmd(2); 
14706:  MOVLW  02
14708:  MOVLB  8
1470A:  MOVWF  xB6
1470C:  MOVLB  0
1470E:  CALL   DBE6
....................                sol_switch_cmd(2); 
14712:  MOVLB  8
14714:  CLRF   xB7
14716:  MOVLW  02
14718:  MOVWF  xB6
1471A:  MOVLB  0
1471C:  RCALL  144E2
....................          break;           
1471E:  MOVLB  8
14720:  BRA    1498C
....................       case 11 : sol_chip_cmd(2); 
14722:  MOVLW  02
14724:  MOVLB  8
14726:  MOVWF  xB6
14728:  MOVLB  0
1472A:  CALL   DBE6
....................                sol_switch_cmd(4); 
1472E:  MOVLB  8
14730:  CLRF   xB7
14732:  MOVLW  04
14734:  MOVWF  xB6
14736:  MOVLB  0
14738:  RCALL  144E2
....................          break;  
1473A:  MOVLB  8
1473C:  BRA    1498C
....................       case 12 : sol_chip_cmd(2); 
1473E:  MOVLW  02
14740:  MOVLB  8
14742:  MOVWF  xB6
14744:  MOVLB  0
14746:  CALL   DBE6
....................                sol_switch_cmd(8); 
1474A:  MOVLB  8
1474C:  CLRF   xB7
1474E:  MOVLW  08
14750:  MOVWF  xB6
14752:  MOVLB  0
14754:  RCALL  144E2
....................          break;  
14756:  MOVLB  8
14758:  BRA    1498C
....................       case 13 : sol_chip_cmd(2); 
1475A:  MOVLW  02
1475C:  MOVLB  8
1475E:  MOVWF  xB6
14760:  MOVLB  0
14762:  CALL   DBE6
....................                sol_switch_cmd(16); 
14766:  MOVLB  8
14768:  CLRF   xB7
1476A:  MOVLW  10
1476C:  MOVWF  xB6
1476E:  MOVLB  0
14770:  RCALL  144E2
....................          break;  
14772:  MOVLB  8
14774:  BRA    1498C
....................       case 14 : sol_chip_cmd(2); 
14776:  MOVLW  02
14778:  MOVLB  8
1477A:  MOVWF  xB6
1477C:  MOVLB  0
1477E:  CALL   DBE6
....................                sol_switch_cmd(32); 
14782:  MOVLB  8
14784:  CLRF   xB7
14786:  MOVLW  20
14788:  MOVWF  xB6
1478A:  MOVLB  0
1478C:  RCALL  144E2
....................          break;  
1478E:  MOVLB  8
14790:  BRA    1498C
....................       case 15 : sol_chip_cmd(2); 
14792:  MOVLW  02
14794:  MOVLB  8
14796:  MOVWF  xB6
14798:  MOVLB  0
1479A:  CALL   DBE6
....................                sol_switch_cmd(64); 
1479E:  MOVLB  8
147A0:  CLRF   xB7
147A2:  MOVLW  40
147A4:  MOVWF  xB6
147A6:  MOVLB  0
147A8:  RCALL  144E2
....................          break;  
147AA:  MOVLB  8
147AC:  BRA    1498C
....................       case 16 : sol_chip_cmd(2); 
147AE:  MOVLW  02
147B0:  MOVLB  8
147B2:  MOVWF  xB6
147B4:  MOVLB  0
147B6:  CALL   DBE6
....................                sol_switch_cmd(128); 
147BA:  MOVLB  8
147BC:  CLRF   xB7
147BE:  MOVLW  80
147C0:  MOVWF  xB6
147C2:  MOVLB  0
147C4:  RCALL  144E2
....................          break;   
147C6:  MOVLB  8
147C8:  BRA    1498C
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
147CA:  MOVLW  03
147CC:  MOVLB  8
147CE:  MOVWF  xB6
147D0:  MOVLB  0
147D2:  CALL   DBE6
....................                sol_switch_cmd(1); 
147D6:  MOVLB  8
147D8:  CLRF   xB7
147DA:  MOVLW  01
147DC:  MOVWF  xB6
147DE:  MOVLB  0
147E0:  RCALL  144E2
....................          break;     
147E2:  MOVLB  8
147E4:  BRA    1498C
....................       case 18 : sol_chip_cmd(3); 
147E6:  MOVLW  03
147E8:  MOVLB  8
147EA:  MOVWF  xB6
147EC:  MOVLB  0
147EE:  CALL   DBE6
....................                sol_switch_cmd(2); 
147F2:  MOVLB  8
147F4:  CLRF   xB7
147F6:  MOVLW  02
147F8:  MOVWF  xB6
147FA:  MOVLB  0
147FC:  RCALL  144E2
....................          break;           
147FE:  MOVLB  8
14800:  BRA    1498C
....................       case 19 : sol_chip_cmd(3); 
14802:  MOVLW  03
14804:  MOVLB  8
14806:  MOVWF  xB6
14808:  MOVLB  0
1480A:  CALL   DBE6
....................                sol_switch_cmd(4); 
1480E:  MOVLB  8
14810:  CLRF   xB7
14812:  MOVLW  04
14814:  MOVWF  xB6
14816:  MOVLB  0
14818:  RCALL  144E2
....................          break;  
1481A:  MOVLB  8
1481C:  BRA    1498C
....................       case 20 : sol_chip_cmd(3); 
1481E:  MOVLW  03
14820:  MOVLB  8
14822:  MOVWF  xB6
14824:  MOVLB  0
14826:  CALL   DBE6
....................                sol_switch_cmd(8); 
1482A:  MOVLB  8
1482C:  CLRF   xB7
1482E:  MOVLW  08
14830:  MOVWF  xB6
14832:  MOVLB  0
14834:  RCALL  144E2
....................          break;  
14836:  MOVLB  8
14838:  BRA    1498C
....................       case 21 : sol_chip_cmd(3); 
1483A:  MOVLW  03
1483C:  MOVLB  8
1483E:  MOVWF  xB6
14840:  MOVLB  0
14842:  CALL   DBE6
....................                sol_switch_cmd(16); 
14846:  MOVLB  8
14848:  CLRF   xB7
1484A:  MOVLW  10
1484C:  MOVWF  xB6
1484E:  MOVLB  0
14850:  RCALL  144E2
....................          break;  
14852:  MOVLB  8
14854:  BRA    1498C
....................       case 22 : sol_chip_cmd(3); 
14856:  MOVLW  03
14858:  MOVLB  8
1485A:  MOVWF  xB6
1485C:  MOVLB  0
1485E:  CALL   DBE6
....................                sol_switch_cmd(32); 
14862:  MOVLB  8
14864:  CLRF   xB7
14866:  MOVLW  20
14868:  MOVWF  xB6
1486A:  MOVLB  0
1486C:  RCALL  144E2
....................          break;  
1486E:  MOVLB  8
14870:  BRA    1498C
....................       case 23 : sol_chip_cmd(3); 
14872:  MOVLW  03
14874:  MOVLB  8
14876:  MOVWF  xB6
14878:  MOVLB  0
1487A:  CALL   DBE6
....................                sol_switch_cmd(64); 
1487E:  MOVLB  8
14880:  CLRF   xB7
14882:  MOVLW  40
14884:  MOVWF  xB6
14886:  MOVLB  0
14888:  RCALL  144E2
....................          break;  
1488A:  MOVLB  8
1488C:  BRA    1498C
....................       case 24 : sol_chip_cmd(3); 
1488E:  MOVLW  03
14890:  MOVLB  8
14892:  MOVWF  xB6
14894:  MOVLB  0
14896:  CALL   DBE6
....................                sol_switch_cmd(128); 
1489A:  MOVLB  8
1489C:  CLRF   xB7
1489E:  MOVLW  80
148A0:  MOVWF  xB6
148A2:  MOVLB  0
148A4:  RCALL  144E2
....................          break;      
148A6:  MOVLB  8
148A8:  BRA    1498C
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
148AA:  MOVLW  04
148AC:  MOVLB  8
148AE:  MOVWF  xB6
148B0:  MOVLB  0
148B2:  CALL   DBE6
....................                sol_switch_cmd(1); 
148B6:  MOVLB  8
148B8:  CLRF   xB7
148BA:  MOVLW  01
148BC:  MOVWF  xB6
148BE:  MOVLB  0
148C0:  RCALL  144E2
....................          break;     
148C2:  MOVLB  8
148C4:  BRA    1498C
....................       case 26 : sol_chip_cmd(4); 
148C6:  MOVLW  04
148C8:  MOVLB  8
148CA:  MOVWF  xB6
148CC:  MOVLB  0
148CE:  CALL   DBE6
....................                sol_switch_cmd(2); 
148D2:  MOVLB  8
148D4:  CLRF   xB7
148D6:  MOVLW  02
148D8:  MOVWF  xB6
148DA:  MOVLB  0
148DC:  RCALL  144E2
....................          break;           
148DE:  MOVLB  8
148E0:  BRA    1498C
....................       case 27 : sol_chip_cmd(4); 
148E2:  MOVLW  04
148E4:  MOVLB  8
148E6:  MOVWF  xB6
148E8:  MOVLB  0
148EA:  CALL   DBE6
....................                sol_switch_cmd(4); 
148EE:  MOVLB  8
148F0:  CLRF   xB7
148F2:  MOVLW  04
148F4:  MOVWF  xB6
148F6:  MOVLB  0
148F8:  RCALL  144E2
....................          break;  
148FA:  MOVLB  8
148FC:  BRA    1498C
....................       case 28 : sol_chip_cmd(4); 
148FE:  MOVLW  04
14900:  MOVLB  8
14902:  MOVWF  xB6
14904:  MOVLB  0
14906:  CALL   DBE6
....................                sol_switch_cmd(8); 
1490A:  MOVLB  8
1490C:  CLRF   xB7
1490E:  MOVLW  08
14910:  MOVWF  xB6
14912:  MOVLB  0
14914:  RCALL  144E2
....................          break;  
14916:  MOVLB  8
14918:  BRA    1498C
....................       case 29 : sol_chip_cmd(4); 
1491A:  MOVLW  04
1491C:  MOVLB  8
1491E:  MOVWF  xB6
14920:  MOVLB  0
14922:  CALL   DBE6
....................                sol_switch_cmd(16); 
14926:  MOVLB  8
14928:  CLRF   xB7
1492A:  MOVLW  10
1492C:  MOVWF  xB6
1492E:  MOVLB  0
14930:  RCALL  144E2
....................          break;  
14932:  MOVLB  8
14934:  BRA    1498C
....................       case 30 : sol_chip_cmd(4); 
14936:  MOVLW  04
14938:  MOVLB  8
1493A:  MOVWF  xB6
1493C:  MOVLB  0
1493E:  CALL   DBE6
....................                sol_switch_cmd(32); 
14942:  MOVLB  8
14944:  CLRF   xB7
14946:  MOVLW  20
14948:  MOVWF  xB6
1494A:  MOVLB  0
1494C:  RCALL  144E2
....................          break;  
1494E:  MOVLB  8
14950:  BRA    1498C
....................       case 31 : sol_chip_cmd(4); 
14952:  MOVLW  04
14954:  MOVLB  8
14956:  MOVWF  xB6
14958:  MOVLB  0
1495A:  CALL   DBE6
....................                sol_switch_cmd(64); 
1495E:  MOVLB  8
14960:  CLRF   xB7
14962:  MOVLW  40
14964:  MOVWF  xB6
14966:  MOVLB  0
14968:  RCALL  144E2
....................          break;  
1496A:  MOVLB  8
1496C:  BRA    1498C
....................       case 32 : sol_chip_cmd(4); 
1496E:  MOVLW  04
14970:  MOVLB  8
14972:  MOVWF  xB6
14974:  MOVLB  0
14976:  CALL   DBE6
....................                sol_switch_cmd(128); 
1497A:  MOVLB  8
1497C:  CLRF   xB7
1497E:  MOVLW  80
14980:  MOVWF  xB6
14982:  MOVLB  0
14984:  RCALL  144E2
....................          break; 
14986:  MOVLB  8
14988:  BRA    1498C
1498A:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
1498C:  MOVF   xB5,F
1498E:  BZ    149A8
14990:  MOVF   xB5,W
14992:  SUBLW  20
14994:  BNC   149A8
14996:  CLRF   03
14998:  MOVF   xB5,W
1499A:  ADDLW  B7
1499C:  MOVWF  FE9
1499E:  MOVLW  04
149A0:  ADDWFC 03,W
149A2:  MOVWF  FEA
149A4:  MOVLW  01
149A6:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
149A8:  MOVF   1F,W
149AA:  SUBLW  04
149AC:  BNZ   149BA
149AE:  MOVF   20,F
149B0:  BNZ   149BA
149B2:  MOVLB  0
149B4:  CALL   ED96
149B8:  MOVLB  8
149BA:  MOVLB  0
149BC:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
1055A:  MOVLB  8
1055C:  CLRF   x9D
1055E:  MOVF   x9D,W
10560:  SUBLW  07
10562:  BNC   1057E
10564:  BCF    FD8.0
10566:  RLCF   x9D,W
10568:  CLRF   03
1056A:  ADDLW  4B
1056C:  MOVWF  FE9
1056E:  MOVLW  03
10570:  ADDWFC 03,W
10572:  MOVWF  FEA
10574:  CLRF   FEC
10576:  MOVF   FED,F
10578:  CLRF   FEF
1057A:  INCF   x9D,F
1057C:  BRA    1055E
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
1057E:  CLRF   x9D
10580:  MOVF   x9D,W
10582:  SUBLW  07
10584:  BNC   105A0
10586:  BCF    FD8.0
10588:  RLCF   x9D,W
1058A:  CLRF   03
1058C:  ADDLW  5D
1058E:  MOVWF  FE9
10590:  MOVLW  03
10592:  ADDWFC 03,W
10594:  MOVWF  FEA
10596:  CLRF   FEC
10598:  MOVF   FED,F
1059A:  CLRF   FEF
1059C:  INCF   x9D,F
1059E:  BRA    10580
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
105A0:  CLRF   x9D
105A2:  MOVF   x9D,W
105A4:  SUBLW  07
105A6:  BNC   105C2
105A8:  BCF    FD8.0
105AA:  RLCF   x9D,W
105AC:  CLRF   03
105AE:  ADDLW  6F
105B0:  MOVWF  FE9
105B2:  MOVLW  03
105B4:  ADDWFC 03,W
105B6:  MOVWF  FEA
105B8:  CLRF   FEC
105BA:  MOVF   FED,F
105BC:  CLRF   FEF
105BE:  INCF   x9D,F
105C0:  BRA    105A2
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
105C2:  CLRF   x9D
105C4:  MOVF   x9D,W
105C6:  SUBLW  07
105C8:  BNC   105E4
105CA:  BCF    FD8.0
105CC:  RLCF   x9D,W
105CE:  CLRF   03
105D0:  ADDLW  81
105D2:  MOVWF  FE9
105D4:  MOVLW  03
105D6:  ADDWFC 03,W
105D8:  MOVWF  FEA
105DA:  CLRF   FEC
105DC:  MOVF   FED,F
105DE:  CLRF   FEF
105E0:  INCF   x9D,F
105E2:  BRA    105C4
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
105E4:  CLRF   x9D
105E6:  MOVF   x9D,W
105E8:  SUBLW  07
105EA:  BNC   10606
105EC:  BCF    FD8.0
105EE:  RLCF   x9D,W
105F0:  CLRF   03
105F2:  ADDLW  93
105F4:  MOVWF  FE9
105F6:  MOVLW  03
105F8:  ADDWFC 03,W
105FA:  MOVWF  FEA
105FC:  CLRF   FEC
105FE:  MOVF   FED,F
10600:  CLRF   FEF
10602:  INCF   x9D,F
10604:  BRA    105E6
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
10606:  MOVLW  04
10608:  MOVWF  FEA
1060A:  MOVLW  25
1060C:  MOVWF  FE9
1060E:  CLRF   00
10610:  CLRF   02
10612:  MOVLW  44
10614:  MOVWF  01
10616:  MOVLB  0
10618:  CALL   354E
1061C:  GOTO   153FE (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10E98:  MOVLB  8
10E9A:  CLRF   xC2
10E9C:  MOVF   xC2,W
10E9E:  SUBLW  03
10EA0:  BNC   10EC0
10EA2:  MOVF   xC2,W
10EA4:  MULLW  04
10EA6:  MOVF   FF3,W
10EA8:  CLRF   03
10EAA:  ADDLW  A5
10EAC:  MOVWF  FE9
10EAE:  MOVLW  03
10EB0:  ADDWFC 03,W
10EB2:  MOVWF  FEA
10EB4:  CLRF   FEF
10EB6:  CLRF   FEC
10EB8:  CLRF   FEC
10EBA:  CLRF   FEC
10EBC:  INCF   xC2,F
10EBE:  BRA    10E9C
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10EC0:  MOVLB  3
10EC2:  MOVF   x4B,F
10EC4:  BTFSS  FD8.2
10EC6:  BRA    10ECC
10EC8:  MOVF   x4C,F
10ECA:  BZ    10F66
10ECC:  MOVF   x4D,F
10ECE:  BNZ   10ED4
10ED0:  MOVF   x4E,F
10ED2:  BZ    10F66
....................       blank = NO3_array[0]; 
10ED4:  MOVFF  34C,918
10ED8:  MOVFF  34B,917
10EDC:  MOVLB  0
10EDE:  CALL   C926
10EE2:  MOVFF  03,8C6
10EE6:  MOVFF  02,8C5
10EEA:  MOVFF  01,8C4
10EEE:  MOVFF  00,8C3
....................       react = NO3_array[1]; 
10EF2:  MOVFF  34E,918
10EF6:  MOVFF  34D,917
10EFA:  CALL   C926
10EFE:  MOVFF  03,8CA
10F02:  MOVFF  02,8C9
10F06:  MOVFF  01,8C8
10F0A:  MOVFF  00,8C7
....................       ratio = blank / react; 
10F0E:  MOVFF  8C6,8FE
10F12:  MOVFF  8C5,8FD
10F16:  MOVFF  8C4,8FC
10F1A:  MOVFF  8C3,8FB
10F1E:  MOVFF  8CA,902
10F22:  MOVFF  8C9,901
10F26:  MOVFF  8C8,900
10F2A:  MOVFF  8C7,8FF
10F2E:  CALL   C95C
10F32:  MOVFF  03,8CE
10F36:  MOVFF  02,8CD
10F3A:  MOVFF  01,8CC
10F3E:  MOVFF  00,8CB
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10F42:  MOVFF  8CE,8D2
10F46:  MOVFF  8CD,8D1
10F4A:  MOVFF  8CC,8D0
10F4E:  MOVFF  8CB,8CF
10F52:  RCALL  10C16
10F54:  MOVFF  03,3A8
10F58:  MOVFF  02,3A7
10F5C:  MOVFF  01,3A6
10F60:  MOVFF  00,3A5
10F64:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10F66:  MOVF   x4F,F
10F68:  BNZ   10F6E
10F6A:  MOVF   x50,F
10F6C:  BZ    11008
10F6E:  MOVF   x51,F
10F70:  BNZ   10F76
10F72:  MOVF   x52,F
10F74:  BZ    11008
....................       blank = NO3_array[2]; 
10F76:  MOVFF  350,918
10F7A:  MOVFF  34F,917
10F7E:  MOVLB  0
10F80:  CALL   C926
10F84:  MOVFF  03,8C6
10F88:  MOVFF  02,8C5
10F8C:  MOVFF  01,8C4
10F90:  MOVFF  00,8C3
....................       react = NO3_array[3]; 
10F94:  MOVFF  352,918
10F98:  MOVFF  351,917
10F9C:  CALL   C926
10FA0:  MOVFF  03,8CA
10FA4:  MOVFF  02,8C9
10FA8:  MOVFF  01,8C8
10FAC:  MOVFF  00,8C7
....................       ratio = blank / react;    
10FB0:  MOVFF  8C6,8FE
10FB4:  MOVFF  8C5,8FD
10FB8:  MOVFF  8C4,8FC
10FBC:  MOVFF  8C3,8FB
10FC0:  MOVFF  8CA,902
10FC4:  MOVFF  8C9,901
10FC8:  MOVFF  8C8,900
10FCC:  MOVFF  8C7,8FF
10FD0:  CALL   C95C
10FD4:  MOVFF  03,8CE
10FD8:  MOVFF  02,8CD
10FDC:  MOVFF  01,8CC
10FE0:  MOVFF  00,8CB
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10FE4:  MOVFF  8CE,8D2
10FE8:  MOVFF  8CD,8D1
10FEC:  MOVFF  8CC,8D0
10FF0:  MOVFF  8CB,8CF
10FF4:  RCALL  10C16
10FF6:  MOVFF  03,3AC
10FFA:  MOVFF  02,3AB
10FFE:  MOVFF  01,3AA
11002:  MOVFF  00,3A9
11006:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
11008:  MOVF   x53,F
1100A:  BNZ   11010
1100C:  MOVF   x54,F
1100E:  BZ    110AA
11010:  MOVF   x55,F
11012:  BNZ   11018
11014:  MOVF   x56,F
11016:  BZ    110AA
....................       blank = NO3_array[4]; 
11018:  MOVFF  354,918
1101C:  MOVFF  353,917
11020:  MOVLB  0
11022:  CALL   C926
11026:  MOVFF  03,8C6
1102A:  MOVFF  02,8C5
1102E:  MOVFF  01,8C4
11032:  MOVFF  00,8C3
....................       react = NO3_array[5]; 
11036:  MOVFF  356,918
1103A:  MOVFF  355,917
1103E:  CALL   C926
11042:  MOVFF  03,8CA
11046:  MOVFF  02,8C9
1104A:  MOVFF  01,8C8
1104E:  MOVFF  00,8C7
....................       ratio = blank / react; 
11052:  MOVFF  8C6,8FE
11056:  MOVFF  8C5,8FD
1105A:  MOVFF  8C4,8FC
1105E:  MOVFF  8C3,8FB
11062:  MOVFF  8CA,902
11066:  MOVFF  8C9,901
1106A:  MOVFF  8C8,900
1106E:  MOVFF  8C7,8FF
11072:  CALL   C95C
11076:  MOVFF  03,8CE
1107A:  MOVFF  02,8CD
1107E:  MOVFF  01,8CC
11082:  MOVFF  00,8CB
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
11086:  MOVFF  8CE,8D2
1108A:  MOVFF  8CD,8D1
1108E:  MOVFF  8CC,8D0
11092:  MOVFF  8CB,8CF
11096:  RCALL  10C16
11098:  MOVFF  03,3B0
1109C:  MOVFF  02,3AF
110A0:  MOVFF  01,3AE
110A4:  MOVFF  00,3AD
110A8:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
110AA:  MOVF   x57,F
110AC:  BNZ   110B2
110AE:  MOVF   x58,F
110B0:  BZ    1114C
110B2:  MOVF   x59,F
110B4:  BNZ   110BA
110B6:  MOVF   x5A,F
110B8:  BZ    1114C
....................       blank = NO3_array[6]; 
110BA:  MOVFF  358,918
110BE:  MOVFF  357,917
110C2:  MOVLB  0
110C4:  CALL   C926
110C8:  MOVFF  03,8C6
110CC:  MOVFF  02,8C5
110D0:  MOVFF  01,8C4
110D4:  MOVFF  00,8C3
....................       react = NO3_array[7]; 
110D8:  MOVFF  35A,918
110DC:  MOVFF  359,917
110E0:  CALL   C926
110E4:  MOVFF  03,8CA
110E8:  MOVFF  02,8C9
110EC:  MOVFF  01,8C8
110F0:  MOVFF  00,8C7
....................       ratio = blank / react; 
110F4:  MOVFF  8C6,8FE
110F8:  MOVFF  8C5,8FD
110FC:  MOVFF  8C4,8FC
11100:  MOVFF  8C3,8FB
11104:  MOVFF  8CA,902
11108:  MOVFF  8C9,901
1110C:  MOVFF  8C8,900
11110:  MOVFF  8C7,8FF
11114:  CALL   C95C
11118:  MOVFF  03,8CE
1111C:  MOVFF  02,8CD
11120:  MOVFF  01,8CC
11124:  MOVFF  00,8CB
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
11128:  MOVFF  8CE,8D2
1112C:  MOVFF  8CD,8D1
11130:  MOVFF  8CC,8D0
11134:  MOVFF  8CB,8CF
11138:  RCALL  10C16
1113A:  MOVFF  03,3B4
1113E:  MOVFF  02,3B3
11142:  MOVFF  01,3B2
11146:  MOVFF  00,3B1
1114A:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
1114C:  MOVLW  04
1114E:  MOVWF  1E
11150:  MOVLW  25
11152:  MOVWF  1D
11154:  MOVLW  C6
11156:  MOVWF  FF6
11158:  MOVLW  1D
1115A:  MOVWF  FF7
1115C:  MOVLW  00
1115E:  MOVWF  FF8
11160:  MOVLW  06
11162:  MOVLB  8
11164:  MOVWF  xEB
11166:  MOVLB  0
11168:  CALL   AAF4
1116C:  MOVLW  10
1116E:  MOVWF  FE9
11170:  MOVFF  34C,8F7
11174:  MOVFF  34B,8F6
11178:  CALL   AB26
1117C:  MOVLW  CF
1117E:  MOVWF  FF6
11180:  MOVLW  1D
11182:  MOVWF  FF7
11184:  MOVLW  00
11186:  MOVWF  FF8
11188:  MOVLW  07
1118A:  MOVLB  8
1118C:  MOVWF  xEB
1118E:  MOVLB  0
11190:  CALL   AAF4
11194:  MOVLW  10
11196:  MOVWF  FE9
11198:  MOVFF  34E,8F7
1119C:  MOVFF  34D,8F6
111A0:  CALL   AB26
111A4:  MOVLW  D9
111A6:  MOVWF  FF6
111A8:  MOVLW  1D
111AA:  MOVWF  FF7
111AC:  MOVLW  00
111AE:  MOVWF  FF8
111B0:  MOVLW  09
111B2:  MOVLB  8
111B4:  MOVWF  xEB
111B6:  MOVLB  0
111B8:  CALL   AAF4
111BC:  MOVLW  89
111BE:  MOVWF  FE9
111C0:  MOVFF  3A8,8D2
111C4:  MOVFF  3A7,8D1
111C8:  MOVFF  3A6,8D0
111CC:  MOVFF  3A5,8CF
111D0:  MOVLW  04
111D2:  MOVLB  8
111D4:  MOVWF  xD3
111D6:  MOVLB  0
111D8:  RCALL  10C82
111DA:  MOVLW  E7
111DC:  MOVWF  FF6
111DE:  MOVLW  1D
111E0:  MOVWF  FF7
111E2:  MOVLW  00
111E4:  MOVWF  FF8
111E6:  MOVLW  07
111E8:  MOVLB  8
111EA:  MOVWF  xEB
111EC:  MOVLB  0
111EE:  CALL   AAF4
111F2:  MOVLW  10
111F4:  MOVWF  FE9
111F6:  MOVFF  350,8F7
111FA:  MOVFF  34F,8F6
111FE:  CALL   AB26
11202:  MOVLW  F1
11204:  MOVWF  FF6
11206:  MOVLW  1D
11208:  MOVWF  FF7
1120A:  MOVLW  00
1120C:  MOVWF  FF8
1120E:  MOVLW  07
11210:  MOVLB  8
11212:  MOVWF  xEB
11214:  MOVLB  0
11216:  CALL   AAF4
1121A:  MOVLW  10
1121C:  MOVWF  FE9
1121E:  MOVFF  352,8F7
11222:  MOVFF  351,8F6
11226:  CALL   AB26
1122A:  MOVLW  FB
1122C:  MOVWF  FF6
1122E:  MOVLW  1D
11230:  MOVWF  FF7
11232:  MOVLW  00
11234:  MOVWF  FF8
11236:  MOVLW  09
11238:  MOVLB  8
1123A:  MOVWF  xEB
1123C:  MOVLB  0
1123E:  CALL   AAF4
11242:  MOVLW  89
11244:  MOVWF  FE9
11246:  MOVFF  3AC,8D2
1124A:  MOVFF  3AB,8D1
1124E:  MOVFF  3AA,8D0
11252:  MOVFF  3A9,8CF
11256:  MOVLW  04
11258:  MOVLB  8
1125A:  MOVWF  xD3
1125C:  MOVLB  0
1125E:  RCALL  10C82
11260:  MOVLW  09
11262:  MOVWF  FF6
11264:  MOVLW  1E
11266:  MOVWF  FF7
11268:  MOVLW  00
1126A:  MOVWF  FF8
1126C:  MOVLW  07
1126E:  MOVLB  8
11270:  MOVWF  xEB
11272:  MOVLB  0
11274:  CALL   AAF4
11278:  MOVLW  10
1127A:  MOVWF  FE9
1127C:  MOVFF  354,8F7
11280:  MOVFF  353,8F6
11284:  CALL   AB26
11288:  MOVLW  13
1128A:  MOVWF  FF6
1128C:  MOVLW  1E
1128E:  MOVWF  FF7
11290:  MOVLW  00
11292:  MOVWF  FF8
11294:  MOVLW  07
11296:  MOVLB  8
11298:  MOVWF  xEB
1129A:  MOVLB  0
1129C:  CALL   AAF4
112A0:  MOVLW  10
112A2:  MOVWF  FE9
112A4:  MOVFF  356,8F7
112A8:  MOVFF  355,8F6
112AC:  CALL   AB26
112B0:  MOVLW  1D
112B2:  MOVWF  FF6
112B4:  MOVLW  1E
112B6:  MOVWF  FF7
112B8:  MOVLW  00
112BA:  MOVWF  FF8
112BC:  MOVLW  09
112BE:  MOVLB  8
112C0:  MOVWF  xEB
112C2:  MOVLB  0
112C4:  CALL   AAF4
112C8:  MOVLW  89
112CA:  MOVWF  FE9
112CC:  MOVFF  3B0,8D2
112D0:  MOVFF  3AF,8D1
112D4:  MOVFF  3AE,8D0
112D8:  MOVFF  3AD,8CF
112DC:  MOVLW  04
112DE:  MOVLB  8
112E0:  MOVWF  xD3
112E2:  MOVLB  0
112E4:  RCALL  10C82
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
112E6:  MOVF   1F,W
112E8:  SUBLW  02
112EA:  BNZ   112F0
112EC:  MOVF   20,F
112EE:  BZ    11330
112F0:  MOVLW  2C
112F2:  MOVWF  FF6
112F4:  MOVLW  1E
112F6:  MOVWF  FF7
112F8:  MOVLW  00
112FA:  MOVWF  FF8
112FC:  CLRF   1B
112FE:  BTFSC  FF2.7
11300:  BSF    1B.7
11302:  BCF    FF2.7
11304:  MOVLW  09
11306:  MOVLB  A
11308:  MOVWF  x40
1130A:  MOVLB  0
1130C:  CALL   1044
11310:  BTFSC  1B.7
11312:  BSF    FF2.7
11314:  MOVLW  04
11316:  MOVWF  FEA
11318:  MOVLW  25
1131A:  MOVWF  FE9
1131C:  CALL   79BE
11320:  MOVLW  0D
11322:  BTFSS  F9E.4
11324:  BRA    11322
11326:  MOVWF  FAD
11328:  MOVLW  0A
1132A:  BTFSS  F9E.4
1132C:  BRA    1132A
1132E:  MOVWF  FAD
11330:  GOTO   1263C (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
11334:  MOVLB  8
11336:  CLRF   xC2
11338:  MOVF   xC2,W
1133A:  SUBLW  03
1133C:  BNC   1135C
1133E:  MOVF   xC2,W
11340:  MULLW  04
11342:  MOVF   FF3,W
11344:  CLRF   03
11346:  ADDLW  B5
11348:  MOVWF  FE9
1134A:  MOVLW  03
1134C:  ADDWFC 03,W
1134E:  MOVWF  FEA
11350:  CLRF   FEF
11352:  CLRF   FEC
11354:  CLRF   FEC
11356:  CLRF   FEC
11358:  INCF   xC2,F
1135A:  BRA    11338
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
1135C:  MOVLB  3
1135E:  MOVF   x5D,F
11360:  BTFSS  FD8.2
11362:  BRA    11368
11364:  MOVF   x5E,F
11366:  BZ    11402
11368:  MOVF   x5F,F
1136A:  BNZ   11370
1136C:  MOVF   x60,F
1136E:  BZ    11402
....................       blank = NO2_array[0]; 
11370:  MOVFF  35E,918
11374:  MOVFF  35D,917
11378:  MOVLB  0
1137A:  CALL   C926
1137E:  MOVFF  03,8C6
11382:  MOVFF  02,8C5
11386:  MOVFF  01,8C4
1138A:  MOVFF  00,8C3
....................       react = NO2_array[1]; 
1138E:  MOVFF  360,918
11392:  MOVFF  35F,917
11396:  CALL   C926
1139A:  MOVFF  03,8CA
1139E:  MOVFF  02,8C9
113A2:  MOVFF  01,8C8
113A6:  MOVFF  00,8C7
....................       ratio = blank / react; 
113AA:  MOVFF  8C6,8FE
113AE:  MOVFF  8C5,8FD
113B2:  MOVFF  8C4,8FC
113B6:  MOVFF  8C3,8FB
113BA:  MOVFF  8CA,902
113BE:  MOVFF  8C9,901
113C2:  MOVFF  8C8,900
113C6:  MOVFF  8C7,8FF
113CA:  CALL   C95C
113CE:  MOVFF  03,8CE
113D2:  MOVFF  02,8CD
113D6:  MOVFF  01,8CC
113DA:  MOVFF  00,8CB
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
113DE:  MOVFF  8CE,8D2
113E2:  MOVFF  8CD,8D1
113E6:  MOVFF  8CC,8D0
113EA:  MOVFF  8CB,8CF
113EE:  RCALL  10C16
113F0:  MOVFF  03,3B8
113F4:  MOVFF  02,3B7
113F8:  MOVFF  01,3B6
113FC:  MOVFF  00,3B5
11400:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
11402:  MOVF   x61,F
11404:  BNZ   1140A
11406:  MOVF   x62,F
11408:  BZ    114A6
1140A:  MOVF   x63,F
1140C:  BNZ   11412
1140E:  MOVF   x64,F
11410:  BZ    114A6
....................       blank = NO2_array[2]; 
11412:  MOVFF  362,918
11416:  MOVFF  361,917
1141A:  MOVLB  0
1141C:  CALL   C926
11420:  MOVFF  03,8C6
11424:  MOVFF  02,8C5
11428:  MOVFF  01,8C4
1142C:  MOVFF  00,8C3
....................       react = NO2_array[3]; 
11430:  MOVFF  364,918
11434:  MOVFF  363,917
11438:  CALL   C926
1143C:  MOVFF  03,8CA
11440:  MOVFF  02,8C9
11444:  MOVFF  01,8C8
11448:  MOVFF  00,8C7
....................       ratio = blank / react;    
1144C:  MOVFF  8C6,8FE
11450:  MOVFF  8C5,8FD
11454:  MOVFF  8C4,8FC
11458:  MOVFF  8C3,8FB
1145C:  MOVFF  8CA,902
11460:  MOVFF  8C9,901
11464:  MOVFF  8C8,900
11468:  MOVFF  8C7,8FF
1146C:  CALL   C95C
11470:  MOVFF  03,8CE
11474:  MOVFF  02,8CD
11478:  MOVFF  01,8CC
1147C:  MOVFF  00,8CB
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
11480:  MOVFF  8CE,8D2
11484:  MOVFF  8CD,8D1
11488:  MOVFF  8CC,8D0
1148C:  MOVFF  8CB,8CF
11490:  CALL   10C16
11494:  MOVFF  03,3BC
11498:  MOVFF  02,3BB
1149C:  MOVFF  01,3BA
114A0:  MOVFF  00,3B9
114A4:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
114A6:  MOVF   x65,F
114A8:  BNZ   114AE
114AA:  MOVF   x66,F
114AC:  BZ    1154A
114AE:  MOVF   x67,F
114B0:  BNZ   114B6
114B2:  MOVF   x68,F
114B4:  BZ    1154A
....................       blank = NO2_array[4]; 
114B6:  MOVFF  366,918
114BA:  MOVFF  365,917
114BE:  MOVLB  0
114C0:  CALL   C926
114C4:  MOVFF  03,8C6
114C8:  MOVFF  02,8C5
114CC:  MOVFF  01,8C4
114D0:  MOVFF  00,8C3
....................       react = NO2_array[5]; 
114D4:  MOVFF  368,918
114D8:  MOVFF  367,917
114DC:  CALL   C926
114E0:  MOVFF  03,8CA
114E4:  MOVFF  02,8C9
114E8:  MOVFF  01,8C8
114EC:  MOVFF  00,8C7
....................       ratio = blank / react; 
114F0:  MOVFF  8C6,8FE
114F4:  MOVFF  8C5,8FD
114F8:  MOVFF  8C4,8FC
114FC:  MOVFF  8C3,8FB
11500:  MOVFF  8CA,902
11504:  MOVFF  8C9,901
11508:  MOVFF  8C8,900
1150C:  MOVFF  8C7,8FF
11510:  CALL   C95C
11514:  MOVFF  03,8CE
11518:  MOVFF  02,8CD
1151C:  MOVFF  01,8CC
11520:  MOVFF  00,8CB
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
11524:  MOVFF  8CE,8D2
11528:  MOVFF  8CD,8D1
1152C:  MOVFF  8CC,8D0
11530:  MOVFF  8CB,8CF
11534:  CALL   10C16
11538:  MOVFF  03,3C0
1153C:  MOVFF  02,3BF
11540:  MOVFF  01,3BE
11544:  MOVFF  00,3BD
11548:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
1154A:  MOVF   x69,F
1154C:  BNZ   11552
1154E:  MOVF   x6A,F
11550:  BZ    115EE
11552:  MOVF   x6B,F
11554:  BNZ   1155A
11556:  MOVF   x6C,F
11558:  BZ    115EE
....................       blank = NO2_array[6]; 
1155A:  MOVFF  36A,918
1155E:  MOVFF  369,917
11562:  MOVLB  0
11564:  CALL   C926
11568:  MOVFF  03,8C6
1156C:  MOVFF  02,8C5
11570:  MOVFF  01,8C4
11574:  MOVFF  00,8C3
....................       react = NO2_array[7]; 
11578:  MOVFF  36C,918
1157C:  MOVFF  36B,917
11580:  CALL   C926
11584:  MOVFF  03,8CA
11588:  MOVFF  02,8C9
1158C:  MOVFF  01,8C8
11590:  MOVFF  00,8C7
....................       ratio = blank / react; 
11594:  MOVFF  8C6,8FE
11598:  MOVFF  8C5,8FD
1159C:  MOVFF  8C4,8FC
115A0:  MOVFF  8C3,8FB
115A4:  MOVFF  8CA,902
115A8:  MOVFF  8C9,901
115AC:  MOVFF  8C8,900
115B0:  MOVFF  8C7,8FF
115B4:  CALL   C95C
115B8:  MOVFF  03,8CE
115BC:  MOVFF  02,8CD
115C0:  MOVFF  01,8CC
115C4:  MOVFF  00,8CB
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
115C8:  MOVFF  8CE,8D2
115CC:  MOVFF  8CD,8D1
115D0:  MOVFF  8CC,8D0
115D4:  MOVFF  8CB,8CF
115D8:  CALL   10C16
115DC:  MOVFF  03,3C4
115E0:  MOVFF  02,3C3
115E4:  MOVFF  01,3C2
115E8:  MOVFF  00,3C1
115EC:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
115EE:  MOVLW  04
115F0:  MOVWF  1E
115F2:  MOVLW  25
115F4:  MOVWF  1D
115F6:  MOVLW  3A
115F8:  MOVWF  FF6
115FA:  MOVLW  1E
115FC:  MOVWF  FF7
115FE:  MOVLW  00
11600:  MOVWF  FF8
11602:  MOVLW  06
11604:  MOVLB  8
11606:  MOVWF  xEB
11608:  MOVLB  0
1160A:  CALL   AAF4
1160E:  MOVLW  10
11610:  MOVWF  FE9
11612:  MOVFF  35E,8F7
11616:  MOVFF  35D,8F6
1161A:  CALL   AB26
1161E:  MOVLW  43
11620:  MOVWF  FF6
11622:  MOVLW  1E
11624:  MOVWF  FF7
11626:  MOVLW  00
11628:  MOVWF  FF8
1162A:  MOVLW  07
1162C:  MOVLB  8
1162E:  MOVWF  xEB
11630:  MOVLB  0
11632:  CALL   AAF4
11636:  MOVLW  10
11638:  MOVWF  FE9
1163A:  MOVFF  360,8F7
1163E:  MOVFF  35F,8F6
11642:  CALL   AB26
11646:  MOVLW  4D
11648:  MOVWF  FF6
1164A:  MOVLW  1E
1164C:  MOVWF  FF7
1164E:  MOVLW  00
11650:  MOVWF  FF8
11652:  MOVLW  09
11654:  MOVLB  8
11656:  MOVWF  xEB
11658:  MOVLB  0
1165A:  CALL   AAF4
1165E:  MOVLW  89
11660:  MOVWF  FE9
11662:  MOVFF  3B8,8D2
11666:  MOVFF  3B7,8D1
1166A:  MOVFF  3B6,8D0
1166E:  MOVFF  3B5,8CF
11672:  MOVLW  04
11674:  MOVLB  8
11676:  MOVWF  xD3
11678:  MOVLB  0
1167A:  CALL   10C82
1167E:  MOVLW  5B
11680:  MOVWF  FF6
11682:  MOVLW  1E
11684:  MOVWF  FF7
11686:  MOVLW  00
11688:  MOVWF  FF8
1168A:  MOVLW  07
1168C:  MOVLB  8
1168E:  MOVWF  xEB
11690:  MOVLB  0
11692:  CALL   AAF4
11696:  MOVLW  10
11698:  MOVWF  FE9
1169A:  MOVFF  362,8F7
1169E:  MOVFF  361,8F6
116A2:  CALL   AB26
116A6:  MOVLW  65
116A8:  MOVWF  FF6
116AA:  MOVLW  1E
116AC:  MOVWF  FF7
116AE:  MOVLW  00
116B0:  MOVWF  FF8
116B2:  MOVLW  07
116B4:  MOVLB  8
116B6:  MOVWF  xEB
116B8:  MOVLB  0
116BA:  CALL   AAF4
116BE:  MOVLW  10
116C0:  MOVWF  FE9
116C2:  MOVFF  364,8F7
116C6:  MOVFF  363,8F6
116CA:  CALL   AB26
116CE:  MOVLW  6F
116D0:  MOVWF  FF6
116D2:  MOVLW  1E
116D4:  MOVWF  FF7
116D6:  MOVLW  00
116D8:  MOVWF  FF8
116DA:  MOVLW  09
116DC:  MOVLB  8
116DE:  MOVWF  xEB
116E0:  MOVLB  0
116E2:  CALL   AAF4
116E6:  MOVLW  89
116E8:  MOVWF  FE9
116EA:  MOVFF  3BC,8D2
116EE:  MOVFF  3BB,8D1
116F2:  MOVFF  3BA,8D0
116F6:  MOVFF  3B9,8CF
116FA:  MOVLW  04
116FC:  MOVLB  8
116FE:  MOVWF  xD3
11700:  MOVLB  0
11702:  CALL   10C82
11706:  MOVLW  7D
11708:  MOVWF  FF6
1170A:  MOVLW  1E
1170C:  MOVWF  FF7
1170E:  MOVLW  00
11710:  MOVWF  FF8
11712:  MOVLW  07
11714:  MOVLB  8
11716:  MOVWF  xEB
11718:  MOVLB  0
1171A:  CALL   AAF4
1171E:  MOVLW  10
11720:  MOVWF  FE9
11722:  MOVFF  366,8F7
11726:  MOVFF  365,8F6
1172A:  CALL   AB26
1172E:  MOVLW  87
11730:  MOVWF  FF6
11732:  MOVLW  1E
11734:  MOVWF  FF7
11736:  MOVLW  00
11738:  MOVWF  FF8
1173A:  MOVLW  07
1173C:  MOVLB  8
1173E:  MOVWF  xEB
11740:  MOVLB  0
11742:  CALL   AAF4
11746:  MOVLW  10
11748:  MOVWF  FE9
1174A:  MOVFF  368,8F7
1174E:  MOVFF  367,8F6
11752:  CALL   AB26
11756:  MOVLW  91
11758:  MOVWF  FF6
1175A:  MOVLW  1E
1175C:  MOVWF  FF7
1175E:  MOVLW  00
11760:  MOVWF  FF8
11762:  MOVLW  09
11764:  MOVLB  8
11766:  MOVWF  xEB
11768:  MOVLB  0
1176A:  CALL   AAF4
1176E:  MOVLW  89
11770:  MOVWF  FE9
11772:  MOVFF  3C0,8D2
11776:  MOVFF  3BF,8D1
1177A:  MOVFF  3BE,8D0
1177E:  MOVFF  3BD,8CF
11782:  MOVLW  04
11784:  MOVLB  8
11786:  MOVWF  xD3
11788:  MOVLB  0
1178A:  CALL   10C82
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
1178E:  MOVF   1F,W
11790:  SUBLW  02
11792:  BNZ   11798
11794:  MOVF   20,F
11796:  BZ    117D8
11798:  MOVLW  A0
1179A:  MOVWF  FF6
1179C:  MOVLW  1E
1179E:  MOVWF  FF7
117A0:  MOVLW  00
117A2:  MOVWF  FF8
117A4:  CLRF   1B
117A6:  BTFSC  FF2.7
117A8:  BSF    1B.7
117AA:  BCF    FF2.7
117AC:  MOVLW  09
117AE:  MOVLB  A
117B0:  MOVWF  x40
117B2:  MOVLB  0
117B4:  CALL   1044
117B8:  BTFSC  1B.7
117BA:  BSF    FF2.7
117BC:  MOVLW  04
117BE:  MOVWF  FEA
117C0:  MOVLW  25
117C2:  MOVWF  FE9
117C4:  CALL   79BE
117C8:  MOVLW  0D
117CA:  BTFSS  F9E.4
117CC:  BRA    117CA
117CE:  MOVWF  FAD
117D0:  MOVLW  0A
117D2:  BTFSS  F9E.4
117D4:  BRA    117D2
117D6:  MOVWF  FAD
117D8:  GOTO   1263C (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
117DC:  MOVLB  8
117DE:  CLRF   xC2
117E0:  MOVF   xC2,W
117E2:  SUBLW  03
117E4:  BNC   11804
117E6:  MOVF   xC2,W
117E8:  MULLW  04
117EA:  MOVF   FF3,W
117EC:  CLRF   03
117EE:  ADDLW  C5
117F0:  MOVWF  FE9
117F2:  MOVLW  03
117F4:  ADDWFC 03,W
117F6:  MOVWF  FEA
117F8:  CLRF   FEF
117FA:  CLRF   FEC
117FC:  CLRF   FEC
117FE:  CLRF   FEC
11800:  INCF   xC2,F
11802:  BRA    117E0
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
11804:  MOVLB  3
11806:  MOVF   x6F,F
11808:  BTFSS  FD8.2
1180A:  BRA    11810
1180C:  MOVF   x70,F
1180E:  BZ    118AC
11810:  MOVF   x71,F
11812:  BNZ   11818
11814:  MOVF   x72,F
11816:  BZ    118AC
....................       blank = PO4_array[0]; 
11818:  MOVFF  370,918
1181C:  MOVFF  36F,917
11820:  MOVLB  0
11822:  CALL   C926
11826:  MOVFF  03,8C6
1182A:  MOVFF  02,8C5
1182E:  MOVFF  01,8C4
11832:  MOVFF  00,8C3
....................       react = PO4_array[1]; 
11836:  MOVFF  372,918
1183A:  MOVFF  371,917
1183E:  CALL   C926
11842:  MOVFF  03,8CA
11846:  MOVFF  02,8C9
1184A:  MOVFF  01,8C8
1184E:  MOVFF  00,8C7
....................       ratio = blank / react; 
11852:  MOVFF  8C6,8FE
11856:  MOVFF  8C5,8FD
1185A:  MOVFF  8C4,8FC
1185E:  MOVFF  8C3,8FB
11862:  MOVFF  8CA,902
11866:  MOVFF  8C9,901
1186A:  MOVFF  8C8,900
1186E:  MOVFF  8C7,8FF
11872:  CALL   C95C
11876:  MOVFF  03,8CE
1187A:  MOVFF  02,8CD
1187E:  MOVFF  01,8CC
11882:  MOVFF  00,8CB
....................       PO4_abs_array[0] = log10(ratio); 
11886:  MOVFF  8CE,8D2
1188A:  MOVFF  8CD,8D1
1188E:  MOVFF  8CC,8D0
11892:  MOVFF  8CB,8CF
11896:  CALL   10C16
1189A:  MOVFF  03,3C8
1189E:  MOVFF  02,3C7
118A2:  MOVFF  01,3C6
118A6:  MOVFF  00,3C5
118AA:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
118AC:  MOVF   x73,F
118AE:  BNZ   118B4
118B0:  MOVF   x74,F
118B2:  BZ    11950
118B4:  MOVF   x75,F
118B6:  BNZ   118BC
118B8:  MOVF   x76,F
118BA:  BZ    11950
....................       blank = PO4_array[2]; 
118BC:  MOVFF  374,918
118C0:  MOVFF  373,917
118C4:  MOVLB  0
118C6:  CALL   C926
118CA:  MOVFF  03,8C6
118CE:  MOVFF  02,8C5
118D2:  MOVFF  01,8C4
118D6:  MOVFF  00,8C3
....................       react = PO4_array[3]; 
118DA:  MOVFF  376,918
118DE:  MOVFF  375,917
118E2:  CALL   C926
118E6:  MOVFF  03,8CA
118EA:  MOVFF  02,8C9
118EE:  MOVFF  01,8C8
118F2:  MOVFF  00,8C7
....................       ratio = blank / react;    
118F6:  MOVFF  8C6,8FE
118FA:  MOVFF  8C5,8FD
118FE:  MOVFF  8C4,8FC
11902:  MOVFF  8C3,8FB
11906:  MOVFF  8CA,902
1190A:  MOVFF  8C9,901
1190E:  MOVFF  8C8,900
11912:  MOVFF  8C7,8FF
11916:  CALL   C95C
1191A:  MOVFF  03,8CE
1191E:  MOVFF  02,8CD
11922:  MOVFF  01,8CC
11926:  MOVFF  00,8CB
....................       PO4_abs_array[1] = log10(ratio); 
1192A:  MOVFF  8CE,8D2
1192E:  MOVFF  8CD,8D1
11932:  MOVFF  8CC,8D0
11936:  MOVFF  8CB,8CF
1193A:  CALL   10C16
1193E:  MOVFF  03,3CC
11942:  MOVFF  02,3CB
11946:  MOVFF  01,3CA
1194A:  MOVFF  00,3C9
1194E:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
11950:  MOVF   x77,F
11952:  BNZ   11958
11954:  MOVF   x78,F
11956:  BZ    119F4
11958:  MOVF   x79,F
1195A:  BNZ   11960
1195C:  MOVF   x7A,F
1195E:  BZ    119F4
....................       blank = PO4_array[4]; 
11960:  MOVFF  378,918
11964:  MOVFF  377,917
11968:  MOVLB  0
1196A:  CALL   C926
1196E:  MOVFF  03,8C6
11972:  MOVFF  02,8C5
11976:  MOVFF  01,8C4
1197A:  MOVFF  00,8C3
....................       react = PO4_array[5]; 
1197E:  MOVFF  37A,918
11982:  MOVFF  379,917
11986:  CALL   C926
1198A:  MOVFF  03,8CA
1198E:  MOVFF  02,8C9
11992:  MOVFF  01,8C8
11996:  MOVFF  00,8C7
....................       ratio = blank / react; 
1199A:  MOVFF  8C6,8FE
1199E:  MOVFF  8C5,8FD
119A2:  MOVFF  8C4,8FC
119A6:  MOVFF  8C3,8FB
119AA:  MOVFF  8CA,902
119AE:  MOVFF  8C9,901
119B2:  MOVFF  8C8,900
119B6:  MOVFF  8C7,8FF
119BA:  CALL   C95C
119BE:  MOVFF  03,8CE
119C2:  MOVFF  02,8CD
119C6:  MOVFF  01,8CC
119CA:  MOVFF  00,8CB
....................       PO4_abs_array[2] = log10(ratio); 
119CE:  MOVFF  8CE,8D2
119D2:  MOVFF  8CD,8D1
119D6:  MOVFF  8CC,8D0
119DA:  MOVFF  8CB,8CF
119DE:  CALL   10C16
119E2:  MOVFF  03,3D0
119E6:  MOVFF  02,3CF
119EA:  MOVFF  01,3CE
119EE:  MOVFF  00,3CD
119F2:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
119F4:  MOVF   x7B,F
119F6:  BNZ   119FC
119F8:  MOVF   x7C,F
119FA:  BZ    11A98
119FC:  MOVF   x7D,F
119FE:  BNZ   11A04
11A00:  MOVF   x7E,F
11A02:  BZ    11A98
....................       blank = PO4_array[6]; 
11A04:  MOVFF  37C,918
11A08:  MOVFF  37B,917
11A0C:  MOVLB  0
11A0E:  CALL   C926
11A12:  MOVFF  03,8C6
11A16:  MOVFF  02,8C5
11A1A:  MOVFF  01,8C4
11A1E:  MOVFF  00,8C3
....................       react = PO4_array[7]; 
11A22:  MOVFF  37E,918
11A26:  MOVFF  37D,917
11A2A:  CALL   C926
11A2E:  MOVFF  03,8CA
11A32:  MOVFF  02,8C9
11A36:  MOVFF  01,8C8
11A3A:  MOVFF  00,8C7
....................       ratio = blank / react; 
11A3E:  MOVFF  8C6,8FE
11A42:  MOVFF  8C5,8FD
11A46:  MOVFF  8C4,8FC
11A4A:  MOVFF  8C3,8FB
11A4E:  MOVFF  8CA,902
11A52:  MOVFF  8C9,901
11A56:  MOVFF  8C8,900
11A5A:  MOVFF  8C7,8FF
11A5E:  CALL   C95C
11A62:  MOVFF  03,8CE
11A66:  MOVFF  02,8CD
11A6A:  MOVFF  01,8CC
11A6E:  MOVFF  00,8CB
....................       PO4_abs_array[3] = log10(ratio); 
11A72:  MOVFF  8CE,8D2
11A76:  MOVFF  8CD,8D1
11A7A:  MOVFF  8CC,8D0
11A7E:  MOVFF  8CB,8CF
11A82:  CALL   10C16
11A86:  MOVFF  03,3D4
11A8A:  MOVFF  02,3D3
11A8E:  MOVFF  01,3D2
11A92:  MOVFF  00,3D1
11A96:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
11A98:  MOVLW  04
11A9A:  MOVWF  1E
11A9C:  MOVLW  25
11A9E:  MOVWF  1D
11AA0:  MOVLW  AE
11AA2:  MOVWF  FF6
11AA4:  MOVLW  1E
11AA6:  MOVWF  FF7
11AA8:  MOVLW  00
11AAA:  MOVWF  FF8
11AAC:  MOVLW  06
11AAE:  MOVLB  8
11AB0:  MOVWF  xEB
11AB2:  MOVLB  0
11AB4:  CALL   AAF4
11AB8:  MOVLW  10
11ABA:  MOVWF  FE9
11ABC:  MOVFF  370,8F7
11AC0:  MOVFF  36F,8F6
11AC4:  CALL   AB26
11AC8:  MOVLW  B7
11ACA:  MOVWF  FF6
11ACC:  MOVLW  1E
11ACE:  MOVWF  FF7
11AD0:  MOVLW  00
11AD2:  MOVWF  FF8
11AD4:  MOVLW  07
11AD6:  MOVLB  8
11AD8:  MOVWF  xEB
11ADA:  MOVLB  0
11ADC:  CALL   AAF4
11AE0:  MOVLW  10
11AE2:  MOVWF  FE9
11AE4:  MOVFF  372,8F7
11AE8:  MOVFF  371,8F6
11AEC:  CALL   AB26
11AF0:  MOVLW  C1
11AF2:  MOVWF  FF6
11AF4:  MOVLW  1E
11AF6:  MOVWF  FF7
11AF8:  MOVLW  00
11AFA:  MOVWF  FF8
11AFC:  MOVLW  09
11AFE:  MOVLB  8
11B00:  MOVWF  xEB
11B02:  MOVLB  0
11B04:  CALL   AAF4
11B08:  MOVLW  89
11B0A:  MOVWF  FE9
11B0C:  MOVFF  3C8,8D2
11B10:  MOVFF  3C7,8D1
11B14:  MOVFF  3C6,8D0
11B18:  MOVFF  3C5,8CF
11B1C:  MOVLW  04
11B1E:  MOVLB  8
11B20:  MOVWF  xD3
11B22:  MOVLB  0
11B24:  CALL   10C82
11B28:  MOVLW  CF
11B2A:  MOVWF  FF6
11B2C:  MOVLW  1E
11B2E:  MOVWF  FF7
11B30:  MOVLW  00
11B32:  MOVWF  FF8
11B34:  MOVLW  07
11B36:  MOVLB  8
11B38:  MOVWF  xEB
11B3A:  MOVLB  0
11B3C:  CALL   AAF4
11B40:  MOVLW  10
11B42:  MOVWF  FE9
11B44:  MOVFF  374,8F7
11B48:  MOVFF  373,8F6
11B4C:  CALL   AB26
11B50:  MOVLW  D9
11B52:  MOVWF  FF6
11B54:  MOVLW  1E
11B56:  MOVWF  FF7
11B58:  MOVLW  00
11B5A:  MOVWF  FF8
11B5C:  MOVLW  07
11B5E:  MOVLB  8
11B60:  MOVWF  xEB
11B62:  MOVLB  0
11B64:  CALL   AAF4
11B68:  MOVLW  10
11B6A:  MOVWF  FE9
11B6C:  MOVFF  376,8F7
11B70:  MOVFF  375,8F6
11B74:  CALL   AB26
11B78:  MOVLW  E3
11B7A:  MOVWF  FF6
11B7C:  MOVLW  1E
11B7E:  MOVWF  FF7
11B80:  MOVLW  00
11B82:  MOVWF  FF8
11B84:  MOVLW  09
11B86:  MOVLB  8
11B88:  MOVWF  xEB
11B8A:  MOVLB  0
11B8C:  CALL   AAF4
11B90:  MOVLW  89
11B92:  MOVWF  FE9
11B94:  MOVFF  3CC,8D2
11B98:  MOVFF  3CB,8D1
11B9C:  MOVFF  3CA,8D0
11BA0:  MOVFF  3C9,8CF
11BA4:  MOVLW  04
11BA6:  MOVLB  8
11BA8:  MOVWF  xD3
11BAA:  MOVLB  0
11BAC:  CALL   10C82
11BB0:  MOVLW  F1
11BB2:  MOVWF  FF6
11BB4:  MOVLW  1E
11BB6:  MOVWF  FF7
11BB8:  MOVLW  00
11BBA:  MOVWF  FF8
11BBC:  MOVLW  07
11BBE:  MOVLB  8
11BC0:  MOVWF  xEB
11BC2:  MOVLB  0
11BC4:  CALL   AAF4
11BC8:  MOVLW  10
11BCA:  MOVWF  FE9
11BCC:  MOVFF  378,8F7
11BD0:  MOVFF  377,8F6
11BD4:  CALL   AB26
11BD8:  MOVLW  FB
11BDA:  MOVWF  FF6
11BDC:  MOVLW  1E
11BDE:  MOVWF  FF7
11BE0:  MOVLW  00
11BE2:  MOVWF  FF8
11BE4:  MOVLW  07
11BE6:  MOVLB  8
11BE8:  MOVWF  xEB
11BEA:  MOVLB  0
11BEC:  CALL   AAF4
11BF0:  MOVLW  10
11BF2:  MOVWF  FE9
11BF4:  MOVFF  37A,8F7
11BF8:  MOVFF  379,8F6
11BFC:  CALL   AB26
11C00:  MOVLW  05
11C02:  MOVWF  FF6
11C04:  MOVLW  1F
11C06:  MOVWF  FF7
11C08:  MOVLW  00
11C0A:  MOVWF  FF8
11C0C:  MOVLW  09
11C0E:  MOVLB  8
11C10:  MOVWF  xEB
11C12:  MOVLB  0
11C14:  CALL   AAF4
11C18:  MOVLW  89
11C1A:  MOVWF  FE9
11C1C:  MOVFF  3D0,8D2
11C20:  MOVFF  3CF,8D1
11C24:  MOVFF  3CE,8D0
11C28:  MOVFF  3CD,8CF
11C2C:  MOVLW  04
11C2E:  MOVLB  8
11C30:  MOVWF  xD3
11C32:  MOVLB  0
11C34:  CALL   10C82
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
11C38:  MOVF   1F,W
11C3A:  SUBLW  02
11C3C:  BNZ   11C42
11C3E:  MOVF   20,F
11C40:  BZ    11C82
11C42:  MOVLW  14
11C44:  MOVWF  FF6
11C46:  MOVLW  1F
11C48:  MOVWF  FF7
11C4A:  MOVLW  00
11C4C:  MOVWF  FF8
11C4E:  CLRF   1B
11C50:  BTFSC  FF2.7
11C52:  BSF    1B.7
11C54:  BCF    FF2.7
11C56:  MOVLW  09
11C58:  MOVLB  A
11C5A:  MOVWF  x40
11C5C:  MOVLB  0
11C5E:  CALL   1044
11C62:  BTFSC  1B.7
11C64:  BSF    FF2.7
11C66:  MOVLW  04
11C68:  MOVWF  FEA
11C6A:  MOVLW  25
11C6C:  MOVWF  FE9
11C6E:  CALL   79BE
11C72:  MOVLW  0D
11C74:  BTFSS  F9E.4
11C76:  BRA    11C74
11C78:  MOVWF  FAD
11C7A:  MOVLW  0A
11C7C:  BTFSS  F9E.4
11C7E:  BRA    11C7C
11C80:  MOVWF  FAD
11C82:  GOTO   1263C (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
11C86:  MOVLB  8
11C88:  CLRF   xC2
11C8A:  MOVF   xC2,W
11C8C:  SUBLW  03
11C8E:  BNC   11CAE
11C90:  MOVF   xC2,W
11C92:  MULLW  04
11C94:  MOVF   FF3,W
11C96:  CLRF   03
11C98:  ADDLW  D5
11C9A:  MOVWF  FE9
11C9C:  MOVLW  03
11C9E:  ADDWFC 03,W
11CA0:  MOVWF  FEA
11CA2:  CLRF   FEF
11CA4:  CLRF   FEC
11CA6:  CLRF   FEC
11CA8:  CLRF   FEC
11CAA:  INCF   xC2,F
11CAC:  BRA    11C8A
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
11CAE:  MOVLB  3
11CB0:  MOVF   x81,F
11CB2:  BTFSS  FD8.2
11CB4:  BRA    11CBA
11CB6:  MOVF   x82,F
11CB8:  BZ    11D56
11CBA:  MOVF   x83,F
11CBC:  BNZ   11CC2
11CBE:  MOVF   x84,F
11CC0:  BZ    11D56
....................       blank = NH4_array[0]; 
11CC2:  MOVFF  382,918
11CC6:  MOVFF  381,917
11CCA:  MOVLB  0
11CCC:  CALL   C926
11CD0:  MOVFF  03,8C6
11CD4:  MOVFF  02,8C5
11CD8:  MOVFF  01,8C4
11CDC:  MOVFF  00,8C3
....................       react = NH4_array[1]; 
11CE0:  MOVFF  384,918
11CE4:  MOVFF  383,917
11CE8:  CALL   C926
11CEC:  MOVFF  03,8CA
11CF0:  MOVFF  02,8C9
11CF4:  MOVFF  01,8C8
11CF8:  MOVFF  00,8C7
....................       ratio = blank / react; 
11CFC:  MOVFF  8C6,8FE
11D00:  MOVFF  8C5,8FD
11D04:  MOVFF  8C4,8FC
11D08:  MOVFF  8C3,8FB
11D0C:  MOVFF  8CA,902
11D10:  MOVFF  8C9,901
11D14:  MOVFF  8C8,900
11D18:  MOVFF  8C7,8FF
11D1C:  CALL   C95C
11D20:  MOVFF  03,8CE
11D24:  MOVFF  02,8CD
11D28:  MOVFF  01,8CC
11D2C:  MOVFF  00,8CB
....................       NH4_abs_array[0] = log10(ratio); 
11D30:  MOVFF  8CE,8D2
11D34:  MOVFF  8CD,8D1
11D38:  MOVFF  8CC,8D0
11D3C:  MOVFF  8CB,8CF
11D40:  CALL   10C16
11D44:  MOVFF  03,3D8
11D48:  MOVFF  02,3D7
11D4C:  MOVFF  01,3D6
11D50:  MOVFF  00,3D5
11D54:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
11D56:  MOVF   x85,F
11D58:  BNZ   11D5E
11D5A:  MOVF   x86,F
11D5C:  BZ    11DFA
11D5E:  MOVF   x87,F
11D60:  BNZ   11D66
11D62:  MOVF   x88,F
11D64:  BZ    11DFA
....................       blank = NH4_array[2]; 
11D66:  MOVFF  386,918
11D6A:  MOVFF  385,917
11D6E:  MOVLB  0
11D70:  CALL   C926
11D74:  MOVFF  03,8C6
11D78:  MOVFF  02,8C5
11D7C:  MOVFF  01,8C4
11D80:  MOVFF  00,8C3
....................       react = NH4_array[3]; 
11D84:  MOVFF  388,918
11D88:  MOVFF  387,917
11D8C:  CALL   C926
11D90:  MOVFF  03,8CA
11D94:  MOVFF  02,8C9
11D98:  MOVFF  01,8C8
11D9C:  MOVFF  00,8C7
....................       ratio = blank / react;    
11DA0:  MOVFF  8C6,8FE
11DA4:  MOVFF  8C5,8FD
11DA8:  MOVFF  8C4,8FC
11DAC:  MOVFF  8C3,8FB
11DB0:  MOVFF  8CA,902
11DB4:  MOVFF  8C9,901
11DB8:  MOVFF  8C8,900
11DBC:  MOVFF  8C7,8FF
11DC0:  CALL   C95C
11DC4:  MOVFF  03,8CE
11DC8:  MOVFF  02,8CD
11DCC:  MOVFF  01,8CC
11DD0:  MOVFF  00,8CB
....................       NH4_abs_array[1] = log10(ratio); 
11DD4:  MOVFF  8CE,8D2
11DD8:  MOVFF  8CD,8D1
11DDC:  MOVFF  8CC,8D0
11DE0:  MOVFF  8CB,8CF
11DE4:  CALL   10C16
11DE8:  MOVFF  03,3DC
11DEC:  MOVFF  02,3DB
11DF0:  MOVFF  01,3DA
11DF4:  MOVFF  00,3D9
11DF8:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
11DFA:  MOVF   x89,F
11DFC:  BNZ   11E02
11DFE:  MOVF   x8A,F
11E00:  BZ    11E9E
11E02:  MOVF   x8B,F
11E04:  BNZ   11E0A
11E06:  MOVF   x8C,F
11E08:  BZ    11E9E
....................       blank = NH4_array[4]; 
11E0A:  MOVFF  38A,918
11E0E:  MOVFF  389,917
11E12:  MOVLB  0
11E14:  CALL   C926
11E18:  MOVFF  03,8C6
11E1C:  MOVFF  02,8C5
11E20:  MOVFF  01,8C4
11E24:  MOVFF  00,8C3
....................       react = NH4_array[5]; 
11E28:  MOVFF  38C,918
11E2C:  MOVFF  38B,917
11E30:  CALL   C926
11E34:  MOVFF  03,8CA
11E38:  MOVFF  02,8C9
11E3C:  MOVFF  01,8C8
11E40:  MOVFF  00,8C7
....................       ratio = blank / react; 
11E44:  MOVFF  8C6,8FE
11E48:  MOVFF  8C5,8FD
11E4C:  MOVFF  8C4,8FC
11E50:  MOVFF  8C3,8FB
11E54:  MOVFF  8CA,902
11E58:  MOVFF  8C9,901
11E5C:  MOVFF  8C8,900
11E60:  MOVFF  8C7,8FF
11E64:  CALL   C95C
11E68:  MOVFF  03,8CE
11E6C:  MOVFF  02,8CD
11E70:  MOVFF  01,8CC
11E74:  MOVFF  00,8CB
....................       NH4_abs_array[2] = log10(ratio); 
11E78:  MOVFF  8CE,8D2
11E7C:  MOVFF  8CD,8D1
11E80:  MOVFF  8CC,8D0
11E84:  MOVFF  8CB,8CF
11E88:  CALL   10C16
11E8C:  MOVFF  03,3E0
11E90:  MOVFF  02,3DF
11E94:  MOVFF  01,3DE
11E98:  MOVFF  00,3DD
11E9C:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11E9E:  MOVF   x8D,F
11EA0:  BNZ   11EA6
11EA2:  MOVF   x8E,F
11EA4:  BZ    11F42
11EA6:  MOVF   x8F,F
11EA8:  BNZ   11EAE
11EAA:  MOVF   x90,F
11EAC:  BZ    11F42
....................       blank = NH4_array[6]; 
11EAE:  MOVFF  38E,918
11EB2:  MOVFF  38D,917
11EB6:  MOVLB  0
11EB8:  CALL   C926
11EBC:  MOVFF  03,8C6
11EC0:  MOVFF  02,8C5
11EC4:  MOVFF  01,8C4
11EC8:  MOVFF  00,8C3
....................       react = NH4_array[7]; 
11ECC:  MOVFF  390,918
11ED0:  MOVFF  38F,917
11ED4:  CALL   C926
11ED8:  MOVFF  03,8CA
11EDC:  MOVFF  02,8C9
11EE0:  MOVFF  01,8C8
11EE4:  MOVFF  00,8C7
....................       ratio = blank / react; 
11EE8:  MOVFF  8C6,8FE
11EEC:  MOVFF  8C5,8FD
11EF0:  MOVFF  8C4,8FC
11EF4:  MOVFF  8C3,8FB
11EF8:  MOVFF  8CA,902
11EFC:  MOVFF  8C9,901
11F00:  MOVFF  8C8,900
11F04:  MOVFF  8C7,8FF
11F08:  CALL   C95C
11F0C:  MOVFF  03,8CE
11F10:  MOVFF  02,8CD
11F14:  MOVFF  01,8CC
11F18:  MOVFF  00,8CB
....................       NH4_abs_array[3] = log10(ratio); 
11F1C:  MOVFF  8CE,8D2
11F20:  MOVFF  8CD,8D1
11F24:  MOVFF  8CC,8D0
11F28:  MOVFF  8CB,8CF
11F2C:  CALL   10C16
11F30:  MOVFF  03,3E4
11F34:  MOVFF  02,3E3
11F38:  MOVFF  01,3E2
11F3C:  MOVFF  00,3E1
11F40:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11F42:  MOVLW  04
11F44:  MOVWF  1E
11F46:  MOVLW  25
11F48:  MOVWF  1D
11F4A:  MOVLW  22
11F4C:  MOVWF  FF6
11F4E:  MOVLW  1F
11F50:  MOVWF  FF7
11F52:  MOVLW  00
11F54:  MOVWF  FF8
11F56:  MOVLW  06
11F58:  MOVLB  8
11F5A:  MOVWF  xEB
11F5C:  MOVLB  0
11F5E:  CALL   AAF4
11F62:  MOVLW  10
11F64:  MOVWF  FE9
11F66:  MOVFF  382,8F7
11F6A:  MOVFF  381,8F6
11F6E:  CALL   AB26
11F72:  MOVLW  2B
11F74:  MOVWF  FF6
11F76:  MOVLW  1F
11F78:  MOVWF  FF7
11F7A:  MOVLW  00
11F7C:  MOVWF  FF8
11F7E:  MOVLW  07
11F80:  MOVLB  8
11F82:  MOVWF  xEB
11F84:  MOVLB  0
11F86:  CALL   AAF4
11F8A:  MOVLW  10
11F8C:  MOVWF  FE9
11F8E:  MOVFF  384,8F7
11F92:  MOVFF  383,8F6
11F96:  CALL   AB26
11F9A:  MOVLW  35
11F9C:  MOVWF  FF6
11F9E:  MOVLW  1F
11FA0:  MOVWF  FF7
11FA2:  MOVLW  00
11FA4:  MOVWF  FF8
11FA6:  MOVLW  09
11FA8:  MOVLB  8
11FAA:  MOVWF  xEB
11FAC:  MOVLB  0
11FAE:  CALL   AAF4
11FB2:  MOVLW  89
11FB4:  MOVWF  FE9
11FB6:  MOVFF  3D8,8D2
11FBA:  MOVFF  3D7,8D1
11FBE:  MOVFF  3D6,8D0
11FC2:  MOVFF  3D5,8CF
11FC6:  MOVLW  04
11FC8:  MOVLB  8
11FCA:  MOVWF  xD3
11FCC:  MOVLB  0
11FCE:  CALL   10C82
11FD2:  MOVLW  43
11FD4:  MOVWF  FF6
11FD6:  MOVLW  1F
11FD8:  MOVWF  FF7
11FDA:  MOVLW  00
11FDC:  MOVWF  FF8
11FDE:  MOVLW  07
11FE0:  MOVLB  8
11FE2:  MOVWF  xEB
11FE4:  MOVLB  0
11FE6:  CALL   AAF4
11FEA:  MOVLW  10
11FEC:  MOVWF  FE9
11FEE:  MOVFF  386,8F7
11FF2:  MOVFF  385,8F6
11FF6:  CALL   AB26
11FFA:  MOVLW  4D
11FFC:  MOVWF  FF6
11FFE:  MOVLW  1F
12000:  MOVWF  FF7
12002:  MOVLW  00
12004:  MOVWF  FF8
12006:  MOVLW  07
12008:  MOVLB  8
1200A:  MOVWF  xEB
1200C:  MOVLB  0
1200E:  CALL   AAF4
12012:  MOVLW  10
12014:  MOVWF  FE9
12016:  MOVFF  388,8F7
1201A:  MOVFF  387,8F6
1201E:  CALL   AB26
12022:  MOVLW  57
12024:  MOVWF  FF6
12026:  MOVLW  1F
12028:  MOVWF  FF7
1202A:  MOVLW  00
1202C:  MOVWF  FF8
1202E:  MOVLW  09
12030:  MOVLB  8
12032:  MOVWF  xEB
12034:  MOVLB  0
12036:  CALL   AAF4
1203A:  MOVLW  89
1203C:  MOVWF  FE9
1203E:  MOVFF  3DC,8D2
12042:  MOVFF  3DB,8D1
12046:  MOVFF  3DA,8D0
1204A:  MOVFF  3D9,8CF
1204E:  MOVLW  04
12050:  MOVLB  8
12052:  MOVWF  xD3
12054:  MOVLB  0
12056:  CALL   10C82
1205A:  MOVLW  65
1205C:  MOVWF  FF6
1205E:  MOVLW  1F
12060:  MOVWF  FF7
12062:  MOVLW  00
12064:  MOVWF  FF8
12066:  MOVLW  07
12068:  MOVLB  8
1206A:  MOVWF  xEB
1206C:  MOVLB  0
1206E:  CALL   AAF4
12072:  MOVLW  10
12074:  MOVWF  FE9
12076:  MOVFF  38A,8F7
1207A:  MOVFF  389,8F6
1207E:  CALL   AB26
12082:  MOVLW  6F
12084:  MOVWF  FF6
12086:  MOVLW  1F
12088:  MOVWF  FF7
1208A:  MOVLW  00
1208C:  MOVWF  FF8
1208E:  MOVLW  07
12090:  MOVLB  8
12092:  MOVWF  xEB
12094:  MOVLB  0
12096:  CALL   AAF4
1209A:  MOVLW  10
1209C:  MOVWF  FE9
1209E:  MOVFF  38C,8F7
120A2:  MOVFF  38B,8F6
120A6:  CALL   AB26
120AA:  MOVLW  79
120AC:  MOVWF  FF6
120AE:  MOVLW  1F
120B0:  MOVWF  FF7
120B2:  MOVLW  00
120B4:  MOVWF  FF8
120B6:  MOVLW  09
120B8:  MOVLB  8
120BA:  MOVWF  xEB
120BC:  MOVLB  0
120BE:  CALL   AAF4
120C2:  MOVLW  89
120C4:  MOVWF  FE9
120C6:  MOVFF  3E0,8D2
120CA:  MOVFF  3DF,8D1
120CE:  MOVFF  3DE,8D0
120D2:  MOVFF  3DD,8CF
120D6:  MOVLW  04
120D8:  MOVLB  8
120DA:  MOVWF  xD3
120DC:  MOVLB  0
120DE:  CALL   10C82
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
120E2:  MOVF   1F,W
120E4:  SUBLW  02
120E6:  BNZ   120EC
120E8:  MOVF   20,F
120EA:  BZ    1212C
120EC:  MOVLW  88
120EE:  MOVWF  FF6
120F0:  MOVLW  1F
120F2:  MOVWF  FF7
120F4:  MOVLW  00
120F6:  MOVWF  FF8
120F8:  CLRF   1B
120FA:  BTFSC  FF2.7
120FC:  BSF    1B.7
120FE:  BCF    FF2.7
12100:  MOVLW  09
12102:  MOVLB  A
12104:  MOVWF  x40
12106:  MOVLB  0
12108:  CALL   1044
1210C:  BTFSC  1B.7
1210E:  BSF    FF2.7
12110:  MOVLW  04
12112:  MOVWF  FEA
12114:  MOVLW  25
12116:  MOVWF  FE9
12118:  CALL   79BE
1211C:  MOVLW  0D
1211E:  BTFSS  F9E.4
12120:  BRA    1211E
12122:  MOVWF  FAD
12124:  MOVLW  0A
12126:  BTFSS  F9E.4
12128:  BRA    12126
1212A:  MOVWF  FAD
1212C:  GOTO   1263C (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
12130:  MOVLB  8
12132:  CLRF   xC2
12134:  MOVF   xC2,W
12136:  SUBLW  03
12138:  BNC   12158
1213A:  MOVF   xC2,W
1213C:  MULLW  04
1213E:  MOVF   FF3,W
12140:  CLRF   03
12142:  ADDLW  E5
12144:  MOVWF  FE9
12146:  MOVLW  03
12148:  ADDWFC 03,W
1214A:  MOVWF  FEA
1214C:  CLRF   FEF
1214E:  CLRF   FEC
12150:  CLRF   FEC
12152:  CLRF   FEC
12154:  INCF   xC2,F
12156:  BRA    12134
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
12158:  MOVLB  3
1215A:  MOVF   x93,F
1215C:  BTFSS  FD8.2
1215E:  BRA    12164
12160:  MOVF   x94,F
12162:  BZ    12200
12164:  MOVF   x95,F
12166:  BNZ   1216C
12168:  MOVF   x96,F
1216A:  BZ    12200
....................       blank = SiO_array[0]; 
1216C:  MOVFF  394,918
12170:  MOVFF  393,917
12174:  MOVLB  0
12176:  CALL   C926
1217A:  MOVFF  03,8C6
1217E:  MOVFF  02,8C5
12182:  MOVFF  01,8C4
12186:  MOVFF  00,8C3
....................       react = SiO_array[1]; 
1218A:  MOVFF  396,918
1218E:  MOVFF  395,917
12192:  CALL   C926
12196:  MOVFF  03,8CA
1219A:  MOVFF  02,8C9
1219E:  MOVFF  01,8C8
121A2:  MOVFF  00,8C7
....................       ratio = blank / react; 
121A6:  MOVFF  8C6,8FE
121AA:  MOVFF  8C5,8FD
121AE:  MOVFF  8C4,8FC
121B2:  MOVFF  8C3,8FB
121B6:  MOVFF  8CA,902
121BA:  MOVFF  8C9,901
121BE:  MOVFF  8C8,900
121C2:  MOVFF  8C7,8FF
121C6:  CALL   C95C
121CA:  MOVFF  03,8CE
121CE:  MOVFF  02,8CD
121D2:  MOVFF  01,8CC
121D6:  MOVFF  00,8CB
....................       SiO_abs_array[0] = log10(ratio); 
121DA:  MOVFF  8CE,8D2
121DE:  MOVFF  8CD,8D1
121E2:  MOVFF  8CC,8D0
121E6:  MOVFF  8CB,8CF
121EA:  CALL   10C16
121EE:  MOVFF  03,3E8
121F2:  MOVFF  02,3E7
121F6:  MOVFF  01,3E6
121FA:  MOVFF  00,3E5
121FE:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
12200:  MOVF   x97,F
12202:  BNZ   12208
12204:  MOVF   x98,F
12206:  BZ    122A4
12208:  MOVF   x99,F
1220A:  BNZ   12210
1220C:  MOVF   x9A,F
1220E:  BZ    122A4
....................       blank = SiO_array[2]; 
12210:  MOVFF  398,918
12214:  MOVFF  397,917
12218:  MOVLB  0
1221A:  CALL   C926
1221E:  MOVFF  03,8C6
12222:  MOVFF  02,8C5
12226:  MOVFF  01,8C4
1222A:  MOVFF  00,8C3
....................       react = SiO_array[3]; 
1222E:  MOVFF  39A,918
12232:  MOVFF  399,917
12236:  CALL   C926
1223A:  MOVFF  03,8CA
1223E:  MOVFF  02,8C9
12242:  MOVFF  01,8C8
12246:  MOVFF  00,8C7
....................       ratio = blank / react;    
1224A:  MOVFF  8C6,8FE
1224E:  MOVFF  8C5,8FD
12252:  MOVFF  8C4,8FC
12256:  MOVFF  8C3,8FB
1225A:  MOVFF  8CA,902
1225E:  MOVFF  8C9,901
12262:  MOVFF  8C8,900
12266:  MOVFF  8C7,8FF
1226A:  CALL   C95C
1226E:  MOVFF  03,8CE
12272:  MOVFF  02,8CD
12276:  MOVFF  01,8CC
1227A:  MOVFF  00,8CB
....................       SiO_abs_array[1] = log10(ratio); 
1227E:  MOVFF  8CE,8D2
12282:  MOVFF  8CD,8D1
12286:  MOVFF  8CC,8D0
1228A:  MOVFF  8CB,8CF
1228E:  CALL   10C16
12292:  MOVFF  03,3EC
12296:  MOVFF  02,3EB
1229A:  MOVFF  01,3EA
1229E:  MOVFF  00,3E9
122A2:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
122A4:  MOVF   x9B,F
122A6:  BNZ   122AC
122A8:  MOVF   x9C,F
122AA:  BZ    12348
122AC:  MOVF   x9D,F
122AE:  BNZ   122B4
122B0:  MOVF   x9E,F
122B2:  BZ    12348
....................       blank = SiO_array[4]; 
122B4:  MOVFF  39C,918
122B8:  MOVFF  39B,917
122BC:  MOVLB  0
122BE:  CALL   C926
122C2:  MOVFF  03,8C6
122C6:  MOVFF  02,8C5
122CA:  MOVFF  01,8C4
122CE:  MOVFF  00,8C3
....................       react = SiO_array[5]; 
122D2:  MOVFF  39E,918
122D6:  MOVFF  39D,917
122DA:  CALL   C926
122DE:  MOVFF  03,8CA
122E2:  MOVFF  02,8C9
122E6:  MOVFF  01,8C8
122EA:  MOVFF  00,8C7
....................       ratio = blank / react; 
122EE:  MOVFF  8C6,8FE
122F2:  MOVFF  8C5,8FD
122F6:  MOVFF  8C4,8FC
122FA:  MOVFF  8C3,8FB
122FE:  MOVFF  8CA,902
12302:  MOVFF  8C9,901
12306:  MOVFF  8C8,900
1230A:  MOVFF  8C7,8FF
1230E:  CALL   C95C
12312:  MOVFF  03,8CE
12316:  MOVFF  02,8CD
1231A:  MOVFF  01,8CC
1231E:  MOVFF  00,8CB
....................       SiO_abs_array[2] = log10(ratio); 
12322:  MOVFF  8CE,8D2
12326:  MOVFF  8CD,8D1
1232A:  MOVFF  8CC,8D0
1232E:  MOVFF  8CB,8CF
12332:  CALL   10C16
12336:  MOVFF  03,3F0
1233A:  MOVFF  02,3EF
1233E:  MOVFF  01,3EE
12342:  MOVFF  00,3ED
12346:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
12348:  MOVF   x9F,F
1234A:  BNZ   12350
1234C:  MOVF   xA0,F
1234E:  BZ    123EC
12350:  MOVF   xA1,F
12352:  BNZ   12358
12354:  MOVF   xA2,F
12356:  BZ    123EC
....................       blank = SiO_array[6]; 
12358:  MOVFF  3A0,918
1235C:  MOVFF  39F,917
12360:  MOVLB  0
12362:  CALL   C926
12366:  MOVFF  03,8C6
1236A:  MOVFF  02,8C5
1236E:  MOVFF  01,8C4
12372:  MOVFF  00,8C3
....................       react = SiO_array[7]; 
12376:  MOVFF  3A2,918
1237A:  MOVFF  3A1,917
1237E:  CALL   C926
12382:  MOVFF  03,8CA
12386:  MOVFF  02,8C9
1238A:  MOVFF  01,8C8
1238E:  MOVFF  00,8C7
....................       ratio = blank / react; 
12392:  MOVFF  8C6,8FE
12396:  MOVFF  8C5,8FD
1239A:  MOVFF  8C4,8FC
1239E:  MOVFF  8C3,8FB
123A2:  MOVFF  8CA,902
123A6:  MOVFF  8C9,901
123AA:  MOVFF  8C8,900
123AE:  MOVFF  8C7,8FF
123B2:  CALL   C95C
123B6:  MOVFF  03,8CE
123BA:  MOVFF  02,8CD
123BE:  MOVFF  01,8CC
123C2:  MOVFF  00,8CB
....................       SiO_abs_array[3] = log10(ratio); 
123C6:  MOVFF  8CE,8D2
123CA:  MOVFF  8CD,8D1
123CE:  MOVFF  8CC,8D0
123D2:  MOVFF  8CB,8CF
123D6:  CALL   10C16
123DA:  MOVFF  03,3F4
123DE:  MOVFF  02,3F3
123E2:  MOVFF  01,3F2
123E6:  MOVFF  00,3F1
123EA:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
123EC:  MOVLW  04
123EE:  MOVWF  1E
123F0:  MOVLW  25
123F2:  MOVWF  1D
123F4:  MOVLW  96
123F6:  MOVWF  FF6
123F8:  MOVLW  1F
123FA:  MOVWF  FF7
123FC:  MOVLW  00
123FE:  MOVWF  FF8
12400:  MOVLW  06
12402:  MOVLB  8
12404:  MOVWF  xEB
12406:  MOVLB  0
12408:  CALL   AAF4
1240C:  MOVLW  10
1240E:  MOVWF  FE9
12410:  MOVFF  394,8F7
12414:  MOVFF  393,8F6
12418:  CALL   AB26
1241C:  MOVLW  9F
1241E:  MOVWF  FF6
12420:  MOVLW  1F
12422:  MOVWF  FF7
12424:  MOVLW  00
12426:  MOVWF  FF8
12428:  MOVLW  07
1242A:  MOVLB  8
1242C:  MOVWF  xEB
1242E:  MOVLB  0
12430:  CALL   AAF4
12434:  MOVLW  10
12436:  MOVWF  FE9
12438:  MOVFF  396,8F7
1243C:  MOVFF  395,8F6
12440:  CALL   AB26
12444:  MOVLW  A9
12446:  MOVWF  FF6
12448:  MOVLW  1F
1244A:  MOVWF  FF7
1244C:  MOVLW  00
1244E:  MOVWF  FF8
12450:  MOVLW  09
12452:  MOVLB  8
12454:  MOVWF  xEB
12456:  MOVLB  0
12458:  CALL   AAF4
1245C:  MOVLW  89
1245E:  MOVWF  FE9
12460:  MOVFF  3E8,8D2
12464:  MOVFF  3E7,8D1
12468:  MOVFF  3E6,8D0
1246C:  MOVFF  3E5,8CF
12470:  MOVLW  04
12472:  MOVLB  8
12474:  MOVWF  xD3
12476:  MOVLB  0
12478:  CALL   10C82
1247C:  MOVLW  B7
1247E:  MOVWF  FF6
12480:  MOVLW  1F
12482:  MOVWF  FF7
12484:  MOVLW  00
12486:  MOVWF  FF8
12488:  MOVLW  07
1248A:  MOVLB  8
1248C:  MOVWF  xEB
1248E:  MOVLB  0
12490:  CALL   AAF4
12494:  MOVLW  10
12496:  MOVWF  FE9
12498:  MOVFF  398,8F7
1249C:  MOVFF  397,8F6
124A0:  CALL   AB26
124A4:  MOVLW  C1
124A6:  MOVWF  FF6
124A8:  MOVLW  1F
124AA:  MOVWF  FF7
124AC:  MOVLW  00
124AE:  MOVWF  FF8
124B0:  MOVLW  07
124B2:  MOVLB  8
124B4:  MOVWF  xEB
124B6:  MOVLB  0
124B8:  CALL   AAF4
124BC:  MOVLW  10
124BE:  MOVWF  FE9
124C0:  MOVFF  39A,8F7
124C4:  MOVFF  399,8F6
124C8:  CALL   AB26
124CC:  MOVLW  CB
124CE:  MOVWF  FF6
124D0:  MOVLW  1F
124D2:  MOVWF  FF7
124D4:  MOVLW  00
124D6:  MOVWF  FF8
124D8:  MOVLW  09
124DA:  MOVLB  8
124DC:  MOVWF  xEB
124DE:  MOVLB  0
124E0:  CALL   AAF4
124E4:  MOVLW  89
124E6:  MOVWF  FE9
124E8:  MOVFF  3EC,8D2
124EC:  MOVFF  3EB,8D1
124F0:  MOVFF  3EA,8D0
124F4:  MOVFF  3E9,8CF
124F8:  MOVLW  04
124FA:  MOVLB  8
124FC:  MOVWF  xD3
124FE:  MOVLB  0
12500:  CALL   10C82
12504:  MOVLW  D9
12506:  MOVWF  FF6
12508:  MOVLW  1F
1250A:  MOVWF  FF7
1250C:  MOVLW  00
1250E:  MOVWF  FF8
12510:  MOVLW  07
12512:  MOVLB  8
12514:  MOVWF  xEB
12516:  MOVLB  0
12518:  CALL   AAF4
1251C:  MOVLW  10
1251E:  MOVWF  FE9
12520:  MOVFF  39C,8F7
12524:  MOVFF  39B,8F6
12528:  CALL   AB26
1252C:  MOVLW  E3
1252E:  MOVWF  FF6
12530:  MOVLW  1F
12532:  MOVWF  FF7
12534:  MOVLW  00
12536:  MOVWF  FF8
12538:  MOVLW  07
1253A:  MOVLB  8
1253C:  MOVWF  xEB
1253E:  MOVLB  0
12540:  CALL   AAF4
12544:  MOVLW  10
12546:  MOVWF  FE9
12548:  MOVFF  39E,8F7
1254C:  MOVFF  39D,8F6
12550:  CALL   AB26
12554:  MOVLW  ED
12556:  MOVWF  FF6
12558:  MOVLW  1F
1255A:  MOVWF  FF7
1255C:  MOVLW  00
1255E:  MOVWF  FF8
12560:  MOVLW  09
12562:  MOVLB  8
12564:  MOVWF  xEB
12566:  MOVLB  0
12568:  CALL   AAF4
1256C:  MOVLW  89
1256E:  MOVWF  FE9
12570:  MOVFF  3F0,8D2
12574:  MOVFF  3EF,8D1
12578:  MOVFF  3EE,8D0
1257C:  MOVFF  3ED,8CF
12580:  MOVLW  04
12582:  MOVLB  8
12584:  MOVWF  xD3
12586:  MOVLB  0
12588:  CALL   10C82
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
1258C:  MOVF   1F,W
1258E:  SUBLW  02
12590:  BNZ   12596
12592:  MOVF   20,F
12594:  BZ    125D6
12596:  MOVLW  FC
12598:  MOVWF  FF6
1259A:  MOVLW  1F
1259C:  MOVWF  FF7
1259E:  MOVLW  00
125A0:  MOVWF  FF8
125A2:  CLRF   1B
125A4:  BTFSC  FF2.7
125A6:  BSF    1B.7
125A8:  BCF    FF2.7
125AA:  MOVLW  09
125AC:  MOVLB  A
125AE:  MOVWF  x40
125B0:  MOVLB  0
125B2:  CALL   1044
125B6:  BTFSC  1B.7
125B8:  BSF    FF2.7
125BA:  MOVLW  04
125BC:  MOVWF  FEA
125BE:  MOVLW  25
125C0:  MOVWF  FE9
125C2:  CALL   79BE
125C6:  MOVLW  0D
125C8:  BTFSS  F9E.4
125CA:  BRA    125C8
125CC:  MOVWF  FAD
125CE:  MOVLW  0A
125D0:  BTFSS  F9E.4
125D2:  BRA    125D0
125D4:  MOVWF  FAD
125D6:  GOTO   1263C (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
125DA:  MOVLW  04
125DC:  MOVWF  FEA
125DE:  MOVLW  25
125E0:  MOVWF  FE9
125E2:  MOVLW  00
125E4:  CALL   056C
125E8:  TBLRD*-
125EA:  TBLRD*+
125EC:  MOVF   FF5,W
125EE:  MOVWF  FEE
125F0:  IORLW  00
125F2:  BNZ   125EA
....................     
....................    switch (chem){ 
125F4:  MOVLW  0A
125F6:  MOVWF  FF6
125F8:  MOVLW  20
125FA:  MOVWF  FF7
125FC:  MOVLW  00
125FE:  MOVWF  FF8
12600:  MOVLW  03
12602:  MOVWF  FEA
12604:  MOVLW  3D
12606:  MOVWF  FE9
12608:  CALL   FE92
1260C:  MOVF   01,W
1260E:  BZ    12622
12610:  XORLW  01
12612:  BZ    12628
12614:  XORLW  03
12616:  BZ    1262E
12618:  XORLW  01
1261A:  BZ    12634
1261C:  XORLW  07
1261E:  BZ    1263A
12620:  BRA    1263C
....................       case "NO3" : calc_abs_NO3(); 
12622:  GOTO   10E98
....................          break; 
12626:  BRA    1263C
....................       case "NO2" : calc_abs_NO2 (); 
12628:  GOTO   11334
....................          break;    
1262C:  BRA    1263C
....................       case "PO4" : calc_abs_PO4(); 
1262E:  GOTO   117DC
....................          break; 
12632:  BRA    1263C
....................       case "NH4" : calc_abs_NH4(); 
12634:  GOTO   11C86
....................          break; 
12638:  BRA    1263C
....................       case "SiO" : calc_abs_SiO(); 
1263A:  BRA    12130
....................          break; 
....................    } 
1263C:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
1263E:  CALL   D558
....................     
....................    if (data_available == TRUE) { 
12642:  MOVLB  3
12644:  DECFSZ x3B,W
12646:  BRA    1274A
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
12648:  MOVLB  8
1264A:  CLRF   xF9
1264C:  MOVLW  67
1264E:  MOVWF  xF8
12650:  MOVLW  02
12652:  MOVWF  xFB
12654:  MOVLW  B7
12656:  MOVWF  xFA
12658:  MOVLB  0
1265A:  CALL   5506
....................       strcat(data_buffer, comma); 
1265E:  MOVLB  8
12660:  CLRF   xF9
12662:  MOVLW  67
12664:  MOVWF  xF8
12666:  MOVLW  03
12668:  MOVWF  xFB
1266A:  MOVLW  39
1266C:  MOVWF  xFA
1266E:  MOVLB  0
12670:  CALL   5506
....................       strcat(data_buffer, chem); 
12674:  MOVLB  8
12676:  CLRF   xF9
12678:  MOVLW  67
1267A:  MOVWF  xF8
1267C:  MOVLW  03
1267E:  MOVWF  xFB
12680:  MOVLW  3D
12682:  MOVWF  xFA
12684:  MOVLB  0
12686:  CALL   5506
....................       strcat(data_buffer, comma); 
1268A:  MOVLB  8
1268C:  CLRF   xF9
1268E:  MOVLW  67
12690:  MOVWF  xF8
12692:  MOVLW  03
12694:  MOVWF  xFB
12696:  MOVLW  39
12698:  MOVWF  xFA
1269A:  MOVLB  0
1269C:  CALL   5506
....................       strcat(data_buffer, abs_str); 
126A0:  MOVLB  8
126A2:  CLRF   xF9
126A4:  MOVLW  67
126A6:  MOVWF  xF8
126A8:  MOVLW  04
126AA:  MOVWF  xFB
126AC:  MOVLW  25
126AE:  MOVWF  xFA
126B0:  MOVLB  0
126B2:  CALL   5506
....................       strcat(data_buffer, endofline); 
126B6:  MOVLB  8
126B8:  CLRF   xF9
126BA:  MOVLW  67
126BC:  MOVWF  xF8
126BE:  MOVLW  07
126C0:  MOVWF  xFB
126C2:  MOVLW  CE
126C4:  MOVWF  xFA
126C6:  MOVLB  0
126C8:  CALL   5506
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
126CC:  MOVF   1F,W
126CE:  SUBLW  04
126D0:  BNZ   126F0
126D2:  MOVF   20,F
126D4:  BNZ   126F0
126D6:  CLRF   FEA
126D8:  MOVLW  67
126DA:  MOVWF  FE9
126DC:  CALL   79BE
126E0:  MOVLW  0D
126E2:  BTFSS  F9E.4
126E4:  BRA    126E2
126E6:  MOVWF  FAD
126E8:  MOVLW  0A
126EA:  BTFSS  F9E.4
126EC:  BRA    126EA
126EE:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
126F0:  MOVLB  2
126F2:  MOVF   xDC,F
126F4:  BNZ   12748
....................        
....................          buffer_select = 0; 
126F6:  MOVLB  0
126F8:  CLRF   x66
....................           
....................          heartbeat(FALSE); 
126FA:  MOVLB  8
126FC:  CLRF   xED
126FE:  MOVLB  0
12700:  CALL   55AE
....................             append_data(file_ptr_rel_all); 
12704:  MOVLW  02
12706:  MOVLB  8
12708:  MOVWF  xEE
1270A:  MOVLW  F9
1270C:  MOVWF  xED
1270E:  MOVLB  0
12710:  CALL   8320
....................          heartbeat(TRUE);          
12714:  MOVLW  01
12716:  MOVLB  8
12718:  MOVWF  xED
1271A:  MOVLB  0
1271C:  CALL   55AE
....................           
....................          heartbeat(FALSE); 
12720:  MOVLB  8
12722:  CLRF   xED
12724:  MOVLB  0
12726:  CALL   55AE
....................             append_data(file_ptr_rel_new);    
1272A:  MOVLW  03
1272C:  MOVLB  8
1272E:  MOVWF  xEE
12730:  MOVLW  07
12732:  MOVWF  xED
12734:  MOVLB  0
12736:  CALL   8320
....................          heartbeat(TRUE); 
1273A:  MOVLW  01
1273C:  MOVLB  8
1273E:  MOVWF  xED
12740:  MOVLB  0
12742:  CALL   55AE
12746:  MOVLB  2
12748:  MOVLB  3
....................       } 
....................    } 
1274A:  MOVLB  0
1274C:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D66E:  MOVLW  2C
0D670:  MOVLB  8
0D672:  MOVWF  x9E
0D674:  CLRF   x9F
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D676:  MOVLW  0D
0D678:  MOVWF  xA0
0D67A:  MOVLW  0A
0D67C:  MOVWF  xA1
0D67E:  CLRF   xA2
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D680:  MOVLB  0
0D682:  RCALL  D558
....................    time_stamp(); 
0D684:  CALL   5442
....................    strcat(data_buffer, time_stmp_str); 
0D688:  MOVLB  8
0D68A:  CLRF   xF9
0D68C:  MOVLW  67
0D68E:  MOVWF  xF8
0D690:  MOVLW  02
0D692:  MOVWF  xFB
0D694:  MOVLW  99
0D696:  MOVWF  xFA
0D698:  MOVLB  0
0D69A:  CALL   5506
....................    strcat(data_buffer, comma); 
0D69E:  MOVLB  8
0D6A0:  CLRF   xF9
0D6A2:  MOVLW  67
0D6A4:  MOVWF  xF8
0D6A6:  MOVLW  08
0D6A8:  MOVWF  xFB
0D6AA:  MOVLW  9E
0D6AC:  MOVWF  xFA
0D6AE:  MOVLB  0
0D6B0:  CALL   5506
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D6B4:  MOVLW  08
0D6B6:  MOVWF  1E
0D6B8:  MOVLW  A3
0D6BA:  MOVWF  1D
0D6BC:  MOVFF  89D,8ED
0D6C0:  MOVLW  1B
0D6C2:  MOVLB  8
0D6C4:  MOVWF  xEE
0D6C6:  MOVLB  0
0D6C8:  CALL   52A8
0D6CC:  MOVLW  2C
0D6CE:  MOVLB  8
0D6D0:  MOVWF  xFF
0D6D2:  MOVLB  0
0D6D4:  CALL   50C6
0D6D8:  MOVLW  10
0D6DA:  MOVWF  FE9
0D6DC:  MOVFF  2A,8F7
0D6E0:  MOVFF  29,8F6
0D6E4:  CALL   AB26
0D6E8:  MOVLW  2C
0D6EA:  MOVLB  8
0D6EC:  MOVWF  xFF
0D6EE:  MOVLB  0
0D6F0:  CALL   50C6
0D6F4:  MOVLW  10
0D6F6:  MOVWF  FE9
0D6F8:  MOVFF  24,8F7
0D6FC:  MOVFF  23,8F6
0D700:  CALL   AB26
0D704:  MOVLW  2C
0D706:  MOVLB  8
0D708:  MOVWF  xFF
0D70A:  MOVLB  0
0D70C:  CALL   50C6
0D710:  MOVLW  10
0D712:  MOVWF  FE9
0D714:  MOVFF  2C,8F7
0D718:  MOVFF  2B,8F6
0D71C:  CALL   AB26
0D720:  MOVLW  2C
0D722:  MOVLB  8
0D724:  MOVWF  xFF
0D726:  MOVLB  0
0D728:  CALL   50C6
0D72C:  MOVLW  10
0D72E:  MOVWF  FE9
0D730:  MOVFF  2E,8F7
0D734:  MOVFF  2D,8F6
0D738:  CALL   AB26
0D73C:  MOVLW  2C
0D73E:  MOVLB  8
0D740:  MOVWF  xFF
0D742:  MOVLB  0
0D744:  CALL   50C6
0D748:  MOVLW  10
0D74A:  MOVWF  FE9
0D74C:  MOVFF  22,8F7
0D750:  MOVFF  21,8F6
0D754:  CALL   AB26
0D758:  MOVLW  2C
0D75A:  MOVLB  8
0D75C:  MOVWF  xFF
0D75E:  MOVLB  0
0D760:  CALL   50C6
0D764:  MOVLW  10
0D766:  MOVWF  FE9
0D768:  MOVFF  7C8,8F7
0D76C:  MOVFF  7C7,8F6
0D770:  CALL   AB26
0D774:  MOVLW  2C
0D776:  MOVLB  8
0D778:  MOVWF  xFF
0D77A:  MOVLB  0
0D77C:  CALL   50C6
0D780:  MOVLW  10
0D782:  MOVWF  FE9
0D784:  MOVFF  7B6,8C2
0D788:  MOVFF  7B5,8C1
0D78C:  BRA    D56C
....................    strcat(data_buffer, config_str); 
0D78E:  MOVLB  8
0D790:  CLRF   xF9
0D792:  MOVLW  67
0D794:  MOVWF  xF8
0D796:  MOVLW  08
0D798:  MOVWF  xFB
0D79A:  MOVLW  A3
0D79C:  MOVWF  xFA
0D79E:  MOVLB  0
0D7A0:  CALL   5506
....................    strcat(data_buffer, endofline); 
0D7A4:  MOVLB  8
0D7A6:  CLRF   xF9
0D7A8:  MOVLW  67
0D7AA:  MOVWF  xF8
0D7AC:  MOVLW  08
0D7AE:  MOVWF  xFB
0D7B0:  MOVLW  A0
0D7B2:  MOVWF  xFA
0D7B4:  MOVLB  0
0D7B6:  CALL   5506
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D7BA:  CLRF   FEA
0D7BC:  MOVLW  67
0D7BE:  MOVWF  FE9
0D7C0:  CALL   79BE
0D7C4:  MOVLW  0D
0D7C6:  BTFSS  F9E.4
0D7C8:  BRA    D7C6
0D7CA:  MOVWF  FAD
0D7CC:  MOVLW  0A
0D7CE:  BTFSS  F9E.4
0D7D0:  BRA    D7CE
0D7D2:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D7D4:  MOVLB  2
0D7D6:  MOVF   xDC,F
0D7D8:  BNZ   D82C
....................     
....................       buffer_select = 0; 
0D7DA:  MOVLB  0
0D7DC:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
0D7DE:  MOVLB  8
0D7E0:  CLRF   xED
0D7E2:  MOVLB  0
0D7E4:  CALL   55AE
....................          append_data(file_ptr_raw_all); 
0D7E8:  MOVLW  02
0D7EA:  MOVLB  8
0D7EC:  MOVWF  xEE
0D7EE:  MOVLW  DD
0D7F0:  MOVWF  xED
0D7F2:  MOVLB  0
0D7F4:  CALL   8320
....................       heartbeat(TRUE);          
0D7F8:  MOVLW  01
0D7FA:  MOVLB  8
0D7FC:  MOVWF  xED
0D7FE:  MOVLB  0
0D800:  CALL   55AE
....................        
....................       heartbeat(FALSE); 
0D804:  MOVLB  8
0D806:  CLRF   xED
0D808:  MOVLB  0
0D80A:  CALL   55AE
....................          append_data(file_ptr_raw_new);    
0D80E:  MOVLW  02
0D810:  MOVLB  8
0D812:  MOVWF  xEE
0D814:  MOVLW  EB
0D816:  MOVWF  xED
0D818:  MOVLB  0
0D81A:  CALL   8320
....................       heartbeat(TRUE); 
0D81E:  MOVLW  01
0D820:  MOVLB  8
0D822:  MOVWF  xED
0D824:  MOVLB  0
0D826:  CALL   55AE
0D82A:  MOVLB  2
....................    } 
0D82C:  MOVLB  0
0D82E:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
152C4:  MOVLW  2C
152C6:  MOVLB  8
152C8:  MOVWF  xA0
152CA:  CLRF   xA1
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
152CC:  MOVLW  0D
152CE:  MOVWF  xA2
152D0:  MOVLW  0A
152D2:  MOVWF  xA3
152D4:  CLRF   xA4
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
152D6:  MOVLB  0
152D8:  CALL   D558
....................    time_stamp(); 
152DC:  CALL   5442
....................    strcat(data_buffer, time_stmp_str); 
152E0:  MOVLB  8
152E2:  CLRF   xF9
152E4:  MOVLW  67
152E6:  MOVWF  xF8
152E8:  MOVLW  02
152EA:  MOVWF  xFB
152EC:  MOVLW  99
152EE:  MOVWF  xFA
152F0:  MOVLB  0
152F2:  CALL   5506
....................    strcat(data_buffer, comma); 
152F6:  MOVLB  8
152F8:  CLRF   xF9
152FA:  MOVLW  67
152FC:  MOVWF  xF8
152FE:  MOVLW  08
15300:  MOVWF  xFB
15302:  MOVLW  A0
15304:  MOVWF  xFA
15306:  MOVLB  0
15308:  CALL   5506
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
1530C:  MOVLW  08
1530E:  MOVWF  1E
15310:  MOVLW  A5
15312:  MOVWF  1D
15314:  MOVFF  89D,8ED
15318:  MOVLW  1B
1531A:  MOVLB  8
1531C:  MOVWF  xEE
1531E:  MOVLB  0
15320:  CALL   52A8
15324:  MOVLW  2C
15326:  MOVLB  8
15328:  MOVWF  xFF
1532A:  MOVLB  0
1532C:  CALL   50C6
15330:  MOVLW  10
15332:  MOVWF  FE9
15334:  MOVFF  89F,8F7
15338:  MOVFF  89E,8F6
1533C:  CALL   AB26
....................    strcat(data_buffer, config_str); 
15340:  MOVLB  8
15342:  CLRF   xF9
15344:  MOVLW  67
15346:  MOVWF  xF8
15348:  MOVLW  08
1534A:  MOVWF  xFB
1534C:  MOVLW  A5
1534E:  MOVWF  xFA
15350:  MOVLB  0
15352:  CALL   5506
....................    strcat(data_buffer, endofline); 
15356:  MOVLB  8
15358:  CLRF   xF9
1535A:  MOVLW  67
1535C:  MOVWF  xF8
1535E:  MOVLW  08
15360:  MOVWF  xFB
15362:  MOVLW  A2
15364:  MOVWF  xFA
15366:  MOVLB  0
15368:  CALL   5506
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
1536C:  MOVF   1F,W
1536E:  SUBLW  04
15370:  BNZ   15390
15372:  MOVF   20,F
15374:  BNZ   15390
15376:  CLRF   FEA
15378:  MOVLW  67
1537A:  MOVWF  FE9
1537C:  CALL   79BE
15380:  MOVLW  0D
15382:  BTFSS  F9E.4
15384:  BRA    15382
15386:  MOVWF  FAD
15388:  MOVLW  0A
1538A:  BTFSS  F9E.4
1538C:  BRA    1538A
1538E:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
15390:  MOVLB  2
15392:  MOVF   xDC,F
15394:  BNZ   153E8
....................     
....................       buffer_select = 0; 
15396:  MOVLB  0
15398:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
1539A:  MOVLB  8
1539C:  CLRF   xED
1539E:  MOVLB  0
153A0:  CALL   55AE
....................          append_data(file_ptr_raw_all); 
153A4:  MOVLW  02
153A6:  MOVLB  8
153A8:  MOVWF  xEE
153AA:  MOVLW  DD
153AC:  MOVWF  xED
153AE:  MOVLB  0
153B0:  CALL   8320
....................       heartbeat(TRUE);          
153B4:  MOVLW  01
153B6:  MOVLB  8
153B8:  MOVWF  xED
153BA:  MOVLB  0
153BC:  CALL   55AE
....................        
....................       heartbeat(FALSE); 
153C0:  MOVLB  8
153C2:  CLRF   xED
153C4:  MOVLB  0
153C6:  CALL   55AE
....................          append_data(file_ptr_raw_new);    
153CA:  MOVLW  02
153CC:  MOVLB  8
153CE:  MOVWF  xEE
153D0:  MOVLW  EB
153D2:  MOVWF  xED
153D4:  MOVLB  0
153D6:  CALL   8320
....................       heartbeat(TRUE); 
153DA:  MOVLW  01
153DC:  MOVLB  8
153DE:  MOVWF  xED
153E0:  MOVLB  0
153E2:  CALL   55AE
153E6:  MOVLB  2
....................    } 
153E8:  MOVLB  0
153EA:  GOTO   15586 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUvY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0D3A0:  BSF    F90.7
....................    delay_ms(500); 
0D3A2:  MOVLW  02
0D3A4:  MOVLB  8
0D3A6:  MOVWF  xC2
0D3A8:  MOVLW  FA
0D3AA:  MOVLB  9
0D3AC:  MOVWF  xEC
0D3AE:  MOVLB  0
0D3B0:  CALL   2938
0D3B4:  MOVLB  8
0D3B6:  DECFSZ xC2,F
0D3B8:  BRA    D3A8
....................    bus_pwr_status=1; 
0D3BA:  MOVLW  01
0D3BC:  MOVLB  4
0D3BE:  MOVWF  xB6
0D3C0:  MOVLB  0
0D3C2:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D3C4:  BCF    F90.7
....................    delay_ms(100); 
0D3C6:  MOVLW  64
0D3C8:  MOVLB  9
0D3CA:  MOVWF  xEC
0D3CC:  MOVLB  0
0D3CE:  CALL   2938
....................    bus_pwr_status=0; 
0D3D2:  MOVLB  4
0D3D4:  CLRF   xB6
0D3D6:  MOVLB  0
0D3D8:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
1806C:  MOVLB  8
1806E:  CLRF   x97
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
18070:  CLRF   x97
18072:  MOVF   x97,W
18074:  SUBLW  31
18076:  BNC   1808C
....................       string_arg[i] = 0; 
18078:  CLRF   03
1807A:  MOVF   x97,W
1807C:  ADDLW  25
1807E:  MOVWF  FE9
18080:  MOVLW  08
18082:  ADDWFC 03,W
18084:  MOVWF  FEA
18086:  CLRF   FEF
18088:  INCF   x97,F
1808A:  BRA    18072
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
1808C:  CLRF   x97
1808E:  MOVF   x97,W
18090:  SUBLW  31
18092:  BNC   1810C
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
18094:  CLRF   03
18096:  MOVF   x97,W
18098:  ADDLW  25
1809A:  MOVWF  FE9
1809C:  MOVLW  08
1809E:  ADDWFC 03,W
180A0:  MOVWF  FEA
180A2:  MOVFF  FEA,89B
180A6:  MOVFF  FE9,89A
180AA:  MOVLB  0
180AC:  CALL   0E58
180B0:  MOVFF  89B,FEA
180B4:  MOVFF  89A,FE9
180B8:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
180BC:  DECFSZ 4C,W
180BE:  BRA    180DC
....................       { 
....................          fputc(string_arg[i],COM_A); 
180C0:  CLRF   03
180C2:  MOVLB  8
180C4:  MOVF   x97,W
180C6:  ADDLW  25
180C8:  MOVWF  FE9
180CA:  MOVLW  08
180CC:  ADDWFC 03,W
180CE:  MOVWF  FEA
180D0:  MOVFF  FEF,898
180D4:  MOVF   x98,W
180D6:  MOVLB  0
180D8:  CALL   AEE8
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
180DC:  CLRF   03
180DE:  MOVLB  8
180E0:  MOVF   x97,W
180E2:  ADDLW  25
180E4:  MOVWF  FE9
180E6:  MOVLW  08
180E8:  ADDWFC 03,W
180EA:  MOVWF  FEA
180EC:  MOVF   FEF,W
180EE:  SUBLW  0D
180F0:  BZ    18106
180F2:  CLRF   03
180F4:  MOVF   x97,W
180F6:  ADDLW  25
180F8:  MOVWF  FE9
180FA:  MOVLW  08
180FC:  ADDWFC 03,W
180FE:  MOVWF  FEA
18100:  MOVF   FEF,W
18102:  SUBLW  0A
18104:  BNZ   18108
....................       { 
....................          break; 
18106:  BRA    1810C
....................       } 
18108:  INCF   x97,F
1810A:  BRA    1808E
....................    } 
1810C:  MOVLB  0
1810E:  GOTO   18436 (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
182B4:  MOVLB  8
182B6:  CLRF   x97
....................    macro_arg = 0; 
182B8:  CLRF   x99
182BA:  CLRF   x98
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
182BC:  MOVF   x97,W
182BE:  SUBLW  0D
182C0:  BZ    1834C
....................       number = fgetc(COM_A); 
182C2:  MOVLB  0
182C4:  CALL   0E58
182C8:  MOVFF  01,897
....................       if (com_echo == TRUE) 
182CC:  DECFSZ 4C,W
182CE:  BRA    182E0
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
182D0:  MOVLB  8
182D2:  MOVF   x97,W
182D4:  SUBLW  0D
182D6:  BZ    182E2
182D8:  MOVF   x97,W
182DA:  MOVLB  0
182DC:  CALL   AEE8
182E0:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
182E2:  MOVF   x97,W
182E4:  SUBLW  2F
182E6:  BC    1831C
182E8:  MOVF   x97,W
182EA:  SUBLW  39
182EC:  BNC   1831C
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
182EE:  MOVLW  30
182F0:  SUBWF  x97,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
182F2:  MOVFF  899,A11
182F6:  MOVFF  898,A10
182FA:  MOVLB  A
182FC:  CLRF   x13
182FE:  MOVLW  0A
18300:  MOVWF  x12
18302:  MOVLB  0
18304:  CALL   5CC0
18308:  MOVFF  02,899
1830C:  MOVFF  01,898
....................          macro_arg = macro_arg + number;                // for each number 
18310:  MOVLB  8
18312:  MOVF   x97,W
18314:  ADDWF  x98,F
18316:  MOVLW  00
18318:  ADDWFC x99,F
....................       } 
1831A:  BRA    1834A
....................       else if (number == CARRIAGE_RET) 
1831C:  MOVF   x97,W
1831E:  SUBLW  0D
18320:  BNZ   18342
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
18322:  INCFSZ x98,W
18324:  BRA    1832C
18326:  INCFSZ x99,W
18328:  BRA    1832C
1832A:  BRA    18338
1832C:  MOVFF  898,01
18330:  MOVFF  899,02
18334:  BRA    1834C
18336:  BRA    18340
....................          else return(65535); 
18338:  MOVLW  FF
1833A:  MOVWF  01
1833C:  MOVWF  02
1833E:  BRA    1834C
....................       } 
18340:  BRA    1834A
....................       else 
....................       { 
....................          return(65535); 
18342:  MOVLW  FF
18344:  MOVWF  01
18346:  MOVWF  02
18348:  BRA    1834C
....................       } 
1834A:  BRA    182BC
....................    } 
1834C:  MOVLB  0
1834E:  GOTO   18460 (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
17DF6:  MOVF   2F,W
17DF8:  MOVWF  00
17DFA:  MOVF   30,W
17DFC:  MOVWF  03
17DFE:  BNZ   17E04
17E00:  MOVF   00,F
17E02:  BZ    17E2A
17E04:  MOVF   03,W
17E06:  BNZ   17E10
17E08:  MOVLW  03
17E0A:  SUBWF  00,W
17E0C:  BTFSC  FD8.2
17E0E:  BRA    17EEE
17E10:  MOVF   03,W
17E12:  BNZ   17E1C
17E14:  MOVLW  01
17E16:  SUBWF  00,W
17E18:  BTFSC  FD8.2
17E1A:  BRA    17EEE
17E1C:  MOVF   03,W
17E1E:  BNZ   17E28
17E20:  MOVLW  02
17E22:  SUBWF  00,W
17E24:  BTFSC  FD8.2
17E26:  BRA    17F64
17E28:  BRA    17FD2
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
17E2A:  MOVLB  8
17E2C:  MOVF   x9B,F
17E2E:  BNZ   17E5E
17E30:  MOVF   x9A,W
17E32:  SUBLW  23
17E34:  BZ    17E58
17E36:  MOVF   x9A,W
17E38:  SUBLW  25
17E3A:  BZ    17E58
17E3C:  MOVF   x9A,W
17E3E:  SUBLW  3B
17E40:  BZ    17E58
17E42:  MOVF   x9A,W
17E44:  SUBLW  4D
17E46:  BZ    17E58
17E48:  MOVF   x9A,W
17E4A:  SUBLW  5A
17E4C:  BZ    17E58
17E4E:  MOVF   x9A,W
17E50:  SUBLW  72
17E52:  BZ    17E58
17E54:  MOVLW  00
17E56:  BRA    17E5A
17E58:  MOVLW  01
17E5A:  MOVWF  x9C
17E5C:  BRA    17EEA
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
17E5E:  MOVF   x9A,W
17E60:  SUBLW  23
17E62:  BZ    17EE6
17E64:  MOVF   x9A,W
17E66:  SUBLW  25
17E68:  BZ    17EE6
17E6A:  MOVF   x9A,W
17E6C:  SUBLW  2B
17E6E:  BZ    17EE6
17E70:  MOVF   x9A,W
17E72:  SUBLW  2D
17E74:  BZ    17EE6
17E76:  MOVF   x9A,W
17E78:  SUBLW  2F
17E7A:  BZ    17EE6
17E7C:  MOVF   x9A,W
17E7E:  SUBLW  3B
17E80:  BZ    17EE6
17E82:  MOVF   x9A,W
17E84:  SUBLW  41
17E86:  BZ    17EE6
17E88:  MOVF   x9A,W
17E8A:  SUBLW  42
17E8C:  BC    17E94
17E8E:  MOVF   x9A,W
17E90:  SUBLW  44
17E92:  BC    17EE6
17E94:  MOVF   x9A,W
17E96:  SUBLW  45
17E98:  BC    17EA0
17E9A:  MOVF   x9A,W
17E9C:  SUBLW  48
17E9E:  BC    17EE6
17EA0:  MOVF   x9A,W
17EA2:  SUBLW  4A
17EA4:  BC    17EAC
17EA6:  MOVF   x9A,W
17EA8:  SUBLW  4C
17EAA:  BC    17EE6
17EAC:  MOVF   x9A,W
17EAE:  SUBLW  4F
17EB0:  BC    17EB8
17EB2:  MOVF   x9A,W
17EB4:  SUBLW  55
17EB6:  BC    17EE6
17EB8:  MOVF   x9A,W
17EBA:  SUBLW  59
17EBC:  BZ    17EE6
17EBE:  MOVF   x9A,W
17EC0:  SUBLW  64
17EC2:  BZ    17EE6
17EC4:  MOVF   x9A,W
17EC6:  SUBLW  69
17EC8:  BZ    17EE6
17ECA:  MOVF   x9A,W
17ECC:  SUBLW  6C
17ECE:  BZ    17EE6
17ED0:  MOVF   x9A,W
17ED2:  SUBLW  70
17ED4:  BZ    17EE6
17ED6:  MOVF   x9A,W
17ED8:  SUBLW  72
17EDA:  BZ    17EE6
17EDC:  MOVF   x9A,W
17EDE:  SUBLW  76
17EE0:  BZ    17EE6
17EE2:  MOVLW  00
17EE4:  BRA    17EE8
17EE6:  MOVLW  01
17EE8:  MOVWF  x9C
....................          break; 
17EEA:  MOVLB  0
17EEC:  BRA    17FD2
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
17EEE:  MOVLB  8
17EF0:  MOVF   x9B,F
17EF2:  BNZ   17F1C
17EF4:  MOVF   x9A,W
17EF6:  SUBLW  23
17EF8:  BZ    17F16
17EFA:  MOVF   x9A,W
17EFC:  SUBLW  3B
17EFE:  BZ    17F16
17F00:  MOVF   x9A,W
17F02:  SUBLW  4A
17F04:  BZ    17F16
17F06:  MOVF   x9A,W
17F08:  SUBLW  4D
17F0A:  BZ    17F16
17F0C:  MOVF   x9A,W
17F0E:  SUBLW  50
17F10:  BZ    17F16
17F12:  MOVLW  00
17F14:  BRA    17F18
17F16:  MOVLW  01
17F18:  MOVWF  x9C
17F1A:  BRA    17F60
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
17F1C:  MOVF   x9A,W
17F1E:  SUBLW  23
17F20:  BZ    17F5C
17F22:  MOVF   x9A,W
17F24:  SUBLW  2B
17F26:  BZ    17F5C
17F28:  MOVF   x9A,W
17F2A:  SUBLW  2D
17F2C:  BZ    17F5C
17F2E:  MOVF   x9A,W
17F30:  SUBLW  3B
17F32:  BZ    17F5C
17F34:  MOVF   x9A,W
17F36:  SUBLW  42
17F38:  BZ    17F5C
17F3A:  MOVF   x9A,W
17F3C:  SUBLW  47
17F3E:  BZ    17F5C
17F40:  MOVF   x9A,W
17F42:  SUBLW  4F
17F44:  BC    17F4C
17F46:  MOVF   x9A,W
17F48:  SUBLW  52
17F4A:  BC    17F5C
17F4C:  MOVF   x9A,W
17F4E:  SUBLW  54
17F50:  BZ    17F5C
17F52:  MOVF   x9A,W
17F54:  SUBLW  59
17F56:  BZ    17F5C
17F58:  MOVLW  00
17F5A:  BRA    17F5E
17F5C:  MOVLW  01
17F5E:  MOVWF  x9C
....................          break;   
17F60:  MOVLB  0
17F62:  BRA    17FD2
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
17F64:  MOVLB  8
17F66:  MOVF   x9B,F
17F68:  BNZ   17F8C
17F6A:  MOVF   x9A,W
17F6C:  SUBLW  23
17F6E:  BZ    17F86
17F70:  MOVF   x9A,W
17F72:  SUBLW  3B
17F74:  BZ    17F86
17F76:  MOVF   x9A,W
17F78:  SUBLW  4D
17F7A:  BZ    17F86
17F7C:  MOVF   x9A,W
17F7E:  SUBLW  50
17F80:  BZ    17F86
17F82:  MOVLW  00
17F84:  BRA    17F88
17F86:  MOVLW  01
17F88:  MOVWF  x9C
17F8A:  BRA    17FD0
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
17F8C:  MOVF   x9A,W
17F8E:  SUBLW  23
17F90:  BZ    17FCC
17F92:  MOVF   x9A,W
17F94:  SUBLW  2B
17F96:  BZ    17FCC
17F98:  MOVF   x9A,W
17F9A:  SUBLW  2D
17F9C:  BZ    17FCC
17F9E:  MOVF   x9A,W
17FA0:  SUBLW  3B
17FA2:  BZ    17FCC
17FA4:  MOVF   x9A,W
17FA6:  SUBLW  42
17FA8:  BC    17FB0
17FAA:  MOVF   x9A,W
17FAC:  SUBLW  44
17FAE:  BC    17FCC
17FB0:  MOVF   x9A,W
17FB2:  SUBLW  4F
17FB4:  BC    17FBC
17FB6:  MOVF   x9A,W
17FB8:  SUBLW  51
17FBA:  BC    17FCC
17FBC:  MOVF   x9A,W
17FBE:  SUBLW  53
17FC0:  BZ    17FCC
17FC2:  MOVF   x9A,W
17FC4:  SUBLW  59
17FC6:  BZ    17FCC
17FC8:  MOVLW  00
17FCA:  BRA    17FCE
17FCC:  MOVLW  01
17FCE:  MOVWF  x9C
....................          break;   
17FD0:  MOVLB  0
....................    } 
....................    return(valid_macro); 
17FD2:  MOVLB  8
17FD4:  MOVFF  89C,01
17FD8:  MOVLB  0
17FDA:  GOTO   18006 (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
17FDE:  MOVLW  01
17FE0:  MOVLB  8
17FE2:  MOVWF  x99
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
17FE4:  MOVLB  0
17FE6:  CALL   0E58
17FEA:  MOVFF  01,898
....................       if (com_echo == TRUE) fputc(e,COM_A); 
17FEE:  DECFSZ 4C,W
17FF0:  BRA    17FFC
17FF2:  MOVLB  8
17FF4:  MOVF   x98,W
17FF6:  MOVLB  0
17FF8:  CALL   AEE8
....................          valid_macro = check_macro(e, macro); 
17FFC:  MOVFF  898,89A
18000:  MOVFF  897,89B
18004:  BRA    17DF6
18006:  MOVFF  01,899
....................       if (valid_macro == TRUE) { 
1800A:  MOVLB  8
1800C:  DECFSZ x99,W
1800E:  BRA    18018
....................          return(e); 
18010:  MOVFF  898,01
18014:  BRA    18024
....................       } 
18016:  BRA    1801E
....................       else return(0); 
18018:  MOVLW  00
1801A:  MOVWF  01
1801C:  BRA    18024
....................    } while (valid_macro == TRUE); 
1801E:  DECFSZ x99,W
18020:  BRA    18024
18022:  BRA    17FE4
18024:  MOVLB  0
18026:  GOTO   18418 (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
1839E:  BCF    FD8.0
183A0:  MOVLB  8
183A2:  RLCF   x9A,W
183A4:  CLRF   03
183A6:  ADDLW  D1
183A8:  MOVWF  FE9
183AA:  MOVLW  07
183AC:  ADDWFC 03,W
183AE:  MOVWF  FEA
183B0:  MOVFF  FEC,8A0
183B4:  MOVF   FED,F
183B6:  MOVFF  FEF,89F
183BA:  MOVFF  89C,A11
183BE:  MOVFF  89B,A10
183C2:  MOVLB  A
183C4:  CLRF   x13
183C6:  MOVLW  03
183C8:  MOVWF  x12
183CA:  MOVLB  0
183CC:  CALL   5CC0
183D0:  MOVF   01,W
183D2:  MOVLB  8
183D4:  ADDWF  x9F,W
183D6:  MOVWF  x9D
183D8:  MOVF   02,W
183DA:  ADDWFC xA0,W
183DC:  MOVWF  x9E
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
183DE:  MOVFF  89E,8A8
183E2:  MOVFF  89D,8A7
183E6:  MOVFF  897,8A9
183EA:  MOVLB  0
183EC:  RCALL  18112
....................     
....................    ++addr; 
183EE:  MOVLB  8
183F0:  INCF   x9D,F
183F2:  BTFSC  FD8.2
183F4:  INCF   x9E,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
183F6:  MOVFF  89E,8A0
183FA:  MOVFF  89D,89F
183FE:  MOVFF  899,8A2
18402:  MOVFF  898,8A1
18406:  MOVLB  0
18408:  BRA    18352
1840A:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
18172:  BCF    FD8.0
18174:  MOVLB  8
18176:  RLCF   x98,W
18178:  CLRF   03
1817A:  ADDLW  D1
1817C:  MOVWF  FE9
1817E:  MOVLW  07
18180:  ADDWFC 03,W
18182:  MOVWF  FEA
18184:  MOVFF  FEC,8A1
18188:  MOVF   FED,F
1818A:  MOVFF  FEF,8A0
1818E:  MOVFF  89A,A11
18192:  MOVFF  899,A10
18196:  MOVLB  A
18198:  CLRF   x13
1819A:  MOVLW  03
1819C:  MOVWF  x12
1819E:  MOVLB  0
181A0:  CALL   5CC0
181A4:  MOVF   01,W
181A6:  MOVLB  8
181A8:  ADDWF  xA0,W
181AA:  MOVWF  x9D
181AC:  MOVF   02,W
181AE:  ADDWFC xA1,W
181B0:  MOVWF  x9E
....................    write_ext_eeprom(addr, macro_cmd); 
181B2:  MOVFF  89E,8A8
181B6:  MOVFF  89D,8A7
181BA:  MOVFF  897,8A9
181BE:  MOVLB  0
181C0:  RCALL  18112
....................     
....................    int i = 0; 
181C2:  MOVLB  8
181C4:  CLRF   x9F
....................    addr = string_address[macro] + (count*50); 
181C6:  BCF    FD8.0
181C8:  RLCF   x98,W
181CA:  CLRF   03
181CC:  ADDLW  FB
181CE:  MOVWF  FE9
181D0:  MOVLW  07
181D2:  ADDWFC 03,W
181D4:  MOVWF  FEA
181D6:  MOVFF  FEC,8A1
181DA:  MOVF   FED,F
181DC:  MOVFF  FEF,8A0
181E0:  MOVFF  89C,A11
181E4:  MOVFF  89B,A10
181E8:  MOVLB  A
181EA:  CLRF   x13
181EC:  MOVLW  32
181EE:  MOVWF  x12
181F0:  MOVLB  0
181F2:  CALL   5CC0
181F6:  MOVF   01,W
181F8:  MOVLB  8
181FA:  ADDWF  xA0,W
181FC:  MOVWF  x9D
181FE:  MOVF   02,W
18200:  ADDWFC xA1,W
18202:  MOVWF  x9E
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
18204:  MOVF   x9C,F
18206:  BNZ   1825C
18208:  MOVF   x9B,W
1820A:  SUBLW  14
1820C:  BNC   1825C
....................       for(i = 0; i<50; i++) { 
1820E:  CLRF   x9F
18210:  MOVF   x9F,W
18212:  SUBLW  31
18214:  BNC   1825A
....................          write_ext_eeprom(addr + i, string_arg[i]); 
18216:  MOVF   x9F,W
18218:  ADDWF  x9D,W
1821A:  MOVWF  xA0
1821C:  MOVLW  00
1821E:  ADDWFC x9E,W
18220:  MOVWF  xA1
18222:  CLRF   03
18224:  MOVF   x9F,W
18226:  ADDLW  25
18228:  MOVWF  FE9
1822A:  MOVLW  08
1822C:  ADDWFC 03,W
1822E:  MOVWF  FEA
18230:  MOVFF  FEF,8A9
18234:  MOVFF  8A1,8A8
18238:  MOVFF  8A0,8A7
1823C:  MOVLB  0
1823E:  RCALL  18112
....................          if(string_arg[i] == 0){ 
18240:  CLRF   03
18242:  MOVLB  8
18244:  MOVF   x9F,W
18246:  ADDLW  25
18248:  MOVWF  FE9
1824A:  MOVLW  08
1824C:  ADDWFC 03,W
1824E:  MOVWF  FEA
18250:  MOVF   FEF,F
18252:  BNZ   18256
....................             break; 
18254:  BRA    1825A
....................          } 
18256:  INCF   x9F,F
18258:  BRA    18210
....................       
....................       } 
....................    }else{ 
1825A:  BRA    182AE
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
1825C:  MOVLW  F2
1825E:  MOVWF  FF6
18260:  MOVLW  20
18262:  MOVWF  FF7
18264:  MOVLW  00
18266:  MOVWF  FF8
18268:  CLRF   1B
1826A:  BTFSC  FF2.7
1826C:  BSF    1B.7
1826E:  BCF    FF2.7
18270:  MOVLW  1E
18272:  MOVLB  A
18274:  MOVWF  x40
18276:  MOVLB  0
18278:  CALL   1044
1827C:  BTFSC  1B.7
1827E:  BSF    FF2.7
18280:  MOVLW  10
18282:  MOVWF  FE9
18284:  CLRF   1B
18286:  BTFSC  FF2.7
18288:  BSF    1B.7
1828A:  BCF    FF2.7
1828C:  MOVFF  89A,A41
18290:  MOVFF  899,A40
18294:  CALL   11C6
18298:  BTFSC  1B.7
1829A:  BSF    FF2.7
1829C:  MOVLW  0A
1829E:  BTFSS  F9E.4
182A0:  BRA    1829E
182A2:  MOVWF  FAD
182A4:  MOVLW  0D
182A6:  BTFSS  F9E.4
182A8:  BRA    182A6
182AA:  MOVWF  FAD
182AC:  MOVLB  8
....................    } 
182AE:  MOVLB  0
182B0:  GOTO   18450 (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
185F0:  CALL   FFD6
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
185F4:  MOVLW  3B
185F6:  MOVLB  8
185F8:  MOVWF  x97
185FA:  CLRF   x99
185FC:  CLRF   x98
185FE:  CLRF   x9A
18600:  CLRF   x9C
18602:  CLRF   x9B
18604:  MOVLB  0
18606:  RCALL  1839E
....................     
....................    write_macro_line(59, 0, 1, 0); 
18608:  MOVLW  3B
1860A:  MOVLB  8
1860C:  MOVWF  x97
1860E:  CLRF   x99
18610:  CLRF   x98
18612:  MOVLW  01
18614:  MOVWF  x9A
18616:  CLRF   x9C
18618:  CLRF   x9B
1861A:  MOVLB  0
1861C:  RCALL  1839E
....................    write_macro_line(59, 0, 2, 0); 
1861E:  MOVLW  3B
18620:  MOVLB  8
18622:  MOVWF  x97
18624:  CLRF   x99
18626:  CLRF   x98
18628:  MOVLW  02
1862A:  MOVWF  x9A
1862C:  CLRF   x9C
1862E:  CLRF   x9B
18630:  MOVLB  0
18632:  RCALL  1839E
....................    write_macro_line(59, 0, 3, 0); 
18634:  MOVLW  3B
18636:  MOVLB  8
18638:  MOVWF  x97
1863A:  CLRF   x99
1863C:  CLRF   x98
1863E:  MOVLW  03
18640:  MOVWF  x9A
18642:  CLRF   x9C
18644:  CLRF   x9B
18646:  MOVLB  0
18648:  RCALL  1839E
....................    write_macro_line(59, 0, 4, 0); 
1864A:  MOVLW  3B
1864C:  MOVLB  8
1864E:  MOVWF  x97
18650:  CLRF   x99
18652:  CLRF   x98
18654:  MOVLW  04
18656:  MOVWF  x9A
18658:  CLRF   x9C
1865A:  CLRF   x9B
1865C:  MOVLB  0
1865E:  RCALL  1839E
....................    write_macro_line(59, 0, 5, 0); 
18660:  MOVLW  3B
18662:  MOVLB  8
18664:  MOVWF  x97
18666:  CLRF   x99
18668:  CLRF   x98
1866A:  MOVLW  05
1866C:  MOVWF  x9A
1866E:  CLRF   x9C
18670:  CLRF   x9B
18672:  MOVLB  0
18674:  RCALL  1839E
....................    write_macro_line(59, 0, 6, 0); 
18676:  MOVLW  3B
18678:  MOVLB  8
1867A:  MOVWF  x97
1867C:  CLRF   x99
1867E:  CLRF   x98
18680:  MOVLW  06
18682:  MOVWF  x9A
18684:  CLRF   x9C
18686:  CLRF   x9B
18688:  MOVLB  0
1868A:  RCALL  1839E
....................    write_macro_line(59, 0, 7, 0); 
1868C:  MOVLW  3B
1868E:  MOVLB  8
18690:  MOVWF  x97
18692:  CLRF   x99
18694:  CLRF   x98
18696:  MOVLW  07
18698:  MOVWF  x9A
1869A:  CLRF   x9C
1869C:  CLRF   x9B
1869E:  MOVLB  0
186A0:  RCALL  1839E
....................    write_macro_line(59, 0, 8, 0); 
186A2:  MOVLW  3B
186A4:  MOVLB  8
186A6:  MOVWF  x97
186A8:  CLRF   x99
186AA:  CLRF   x98
186AC:  MOVLW  08
186AE:  MOVWF  x9A
186B0:  CLRF   x9C
186B2:  CLRF   x9B
186B4:  MOVLB  0
186B6:  RCALL  1839E
....................     
....................    write_macro_line(59, 0, 9, 0); 
186B8:  MOVLW  3B
186BA:  MOVLB  8
186BC:  MOVWF  x97
186BE:  CLRF   x99
186C0:  CLRF   x98
186C2:  MOVLW  09
186C4:  MOVWF  x9A
186C6:  CLRF   x9C
186C8:  CLRF   x9B
186CA:  MOVLB  0
186CC:  RCALL  1839E
....................    write_macro_line(59, 0, 10, 0); 
186CE:  MOVLW  3B
186D0:  MOVLB  8
186D2:  MOVWF  x97
186D4:  CLRF   x99
186D6:  CLRF   x98
186D8:  MOVLW  0A
186DA:  MOVWF  x9A
186DC:  CLRF   x9C
186DE:  CLRF   x9B
186E0:  MOVLB  0
186E2:  RCALL  1839E
....................    write_macro_line(59, 0, 11, 0); 
186E4:  MOVLW  3B
186E6:  MOVLB  8
186E8:  MOVWF  x97
186EA:  CLRF   x99
186EC:  CLRF   x98
186EE:  MOVLW  0B
186F0:  MOVWF  x9A
186F2:  CLRF   x9C
186F4:  CLRF   x9B
186F6:  MOVLB  0
186F8:  RCALL  1839E
....................    write_macro_line(59, 0, 12, 0); 
186FA:  MOVLW  3B
186FC:  MOVLB  8
186FE:  MOVWF  x97
18700:  CLRF   x99
18702:  CLRF   x98
18704:  MOVLW  0C
18706:  MOVWF  x9A
18708:  CLRF   x9C
1870A:  CLRF   x9B
1870C:  MOVLB  0
1870E:  RCALL  1839E
....................    write_macro_line(59, 0, 13, 0); 
18710:  MOVLW  3B
18712:  MOVLB  8
18714:  MOVWF  x97
18716:  CLRF   x99
18718:  CLRF   x98
1871A:  MOVLW  0D
1871C:  MOVWF  x9A
1871E:  CLRF   x9C
18720:  CLRF   x9B
18722:  MOVLB  0
18724:  RCALL  1839E
....................    write_macro_line(59, 0, 14, 0); 
18726:  MOVLW  3B
18728:  MOVLB  8
1872A:  MOVWF  x97
1872C:  CLRF   x99
1872E:  CLRF   x98
18730:  MOVLW  0E
18732:  MOVWF  x9A
18734:  CLRF   x9C
18736:  CLRF   x9B
18738:  MOVLB  0
1873A:  RCALL  1839E
....................    write_macro_line(59, 0, 15, 0); 
1873C:  MOVLW  3B
1873E:  MOVLB  8
18740:  MOVWF  x97
18742:  CLRF   x99
18744:  CLRF   x98
18746:  MOVLW  0F
18748:  MOVWF  x9A
1874A:  CLRF   x9C
1874C:  CLRF   x9B
1874E:  MOVLB  0
18750:  RCALL  1839E
....................    write_macro_line(59, 0, 16, 0); 
18752:  MOVLW  3B
18754:  MOVLB  8
18756:  MOVWF  x97
18758:  CLRF   x99
1875A:  CLRF   x98
1875C:  MOVLW  10
1875E:  MOVWF  x9A
18760:  CLRF   x9C
18762:  CLRF   x9B
18764:  MOVLB  0
18766:  RCALL  1839E
18768:  GOTO   187A0 (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
1802A:  MOVLB  8
1802C:  CLRF   x97
....................     
....................    heartbeat(FALSE); 
1802E:  CLRF   xED
18030:  MOVLB  0
18032:  CALL   55AE
....................     
....................    while(mcc != CARRIAGE_RET){ 
18036:  MOVLB  8
18038:  MOVF   x97,W
1803A:  SUBLW  0D
1803C:  BZ    1805E
....................       if (kbhit(COM_A)) { 
1803E:  BTFSS  F9E.5
18040:  BRA    1805C
....................          mcc=fgetc(COM_A); 
18042:  MOVLB  0
18044:  CALL   0E58
18048:  MOVFF  01,897
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
1804C:  DECFSZ 4C,W
1804E:  BRA    1805A
18050:  MOVLB  8
18052:  MOVF   x97,W
18054:  MOVLB  0
18056:  CALL   AEE8
1805A:  MOVLB  8
....................       } 
1805C:  BRA    18038
....................    } 
....................     
....................    heartbeat(TRUE); 
1805E:  MOVLW  01
18060:  MOVWF  xED
18062:  MOVLB  0
18064:  CALL   55AE
18068:  GOTO   18428 (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
1840C:  MOVLB  8
1840E:  CLRF   x96
....................     
....................    macro_cmd = get_cmd(macro); 
18410:  MOVFF  88E,897
18414:  MOVLB  0
18416:  BRA    17FDE
18418:  MOVFF  01,893
....................    if (macro_cmd == 35){  
1841C:  MOVLB  8
1841E:  MOVF   x93,W
18420:  SUBLW  23
18422:  BNZ   1842C
....................       macro_comment();        // # = 35 
18424:  MOVLB  0
18426:  BRA    1802A
....................    }else if(macro_cmd == 112){// 112 is p 
18428:  BRA    184AE
1842A:  MOVLB  8
1842C:  MOVF   x93,W
1842E:  SUBLW  70
18430:  BNZ   18458
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
18432:  MOVLB  0
18434:  BRA    1806C
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
18436:  MOVFF  893,897
1843A:  MOVFF  88E,898
1843E:  MOVFF  890,89A
18442:  MOVFF  88F,899
18446:  MOVFF  892,89C
1844A:  MOVFF  891,89B
1844E:  BRA    18172
....................       valid_macro = TRUE; 
18450:  MOVLW  01
18452:  MOVLB  8
18454:  MOVWF  x96
....................    }else{ 
18456:  BRA    184AC
....................       if (macro_cmd != 0) { 
18458:  MOVF   x93,F
1845A:  BZ    18482
....................          macro_arg = get_arg(); 
1845C:  MOVLB  0
1845E:  BRA    182B4
18460:  MOVFF  02,895
18464:  MOVFF  01,894
....................          if (macro_arg != 65535) valid_macro = TRUE; 
18468:  MOVLB  8
1846A:  INCFSZ x94,W
1846C:  BRA    18474
1846E:  INCFSZ x95,W
18470:  BRA    18474
18472:  BRA    1847A
18474:  MOVLW  01
18476:  MOVWF  x96
18478:  BRA    18480
....................          else return(macro_cmd); 
1847A:  MOVFF  893,01
1847E:  BRA    184B4
....................       }else return(macro_cmd); 
18480:  BRA    18488
18482:  MOVFF  893,01
18486:  BRA    184B4
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
18488:  MOVFF  893,897
1848C:  MOVFF  895,899
18490:  MOVFF  894,898
18494:  MOVFF  88E,89A
18498:  MOVFF  890,89C
1849C:  MOVFF  88F,89B
184A0:  MOVLB  0
184A2:  RCALL  1839E
....................       return(macro_cmd); 
184A4:  MOVLB  8
184A6:  MOVFF  893,01
184AA:  BRA    184B4
184AC:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
184AE:  MOVLB  8
184B0:  MOVFF  893,01
184B4:  MOVLB  0
184B6:  GOTO   184FC (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
184BA:  MOVLB  8
184BC:  CLRF   x8D
184BE:  CLRF   x8C
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
184C0:  CLRF   x88
184C2:  CLRF   x87
....................    valid_macro = TRUE; 
184C4:  MOVLW  01
184C6:  MOVWF  x89
....................    macro_cmd = 1; 
184C8:  MOVWF  x8A
....................     
....................    init_ext_eeprom(); 
184CA:  MOVLB  0
184CC:  CALL   FFD6
....................     
....................    fprintf(COM_A, ":"); 
184D0:  MOVLW  3A
184D2:  BTFSS  F9E.4
184D4:  BRA    184D2
184D6:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
184D8:  MOVLB  8
184DA:  MOVF   x8A,W
184DC:  SUBLW  3B
184DE:  BZ    18542
184E0:  MOVF   x8A,F
184E2:  BZ    18542
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
184E4:  MOVFF  886,88E
184E8:  MOVFF  888,890
184EC:  MOVFF  887,88F
184F0:  MOVFF  88D,892
184F4:  MOVFF  88C,891
184F8:  MOVLB  0
184FA:  BRA    1840C
184FC:  MOVFF  01,88A
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
18500:  MOVLB  8
18502:  MOVF   x8A,W
18504:  SUBLW  70
18506:  BNZ   1850E
....................          count++; 
18508:  INCF   x8C,F
1850A:  BTFSC  FD8.2
1850C:  INCF   x8D,F
....................       } 
....................       if (macro_cmd != 35) ++line; 
1850E:  MOVF   x8A,W
18510:  SUBLW  23
18512:  BZ    1851A
18514:  INCF   x87,F
18516:  BTFSC  FD8.2
18518:  INCF   x88,F
....................       if (macro_cmd != 59) printf("\r\n:"); 
1851A:  MOVF   x8A,W
1851C:  SUBLW  3B
1851E:  BZ    18540
18520:  MOVLW  16
18522:  MOVWF  FF6
18524:  MOVLW  21
18526:  MOVWF  FF7
18528:  MOVLW  00
1852A:  MOVWF  FF8
1852C:  CLRF   1B
1852E:  BTFSC  FF2.7
18530:  BSF    1B.7
18532:  BCF    FF2.7
18534:  MOVLB  0
18536:  CALL   0E6E
1853A:  BTFSC  1B.7
1853C:  BSF    FF2.7
1853E:  MOVLB  8
18540:  BRA    184DA
....................    }       
....................    if (macro_cmd == 0){ 
18542:  MOVF   x8A,F
18544:  BNZ   185DA
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
18546:  MOVLW  1A
18548:  MOVWF  FF6
1854A:  MOVLW  21
1854C:  MOVWF  FF7
1854E:  MOVLW  00
18550:  MOVWF  FF8
18552:  CLRF   1B
18554:  BTFSC  FF2.7
18556:  BSF    1B.7
18558:  BCF    FF2.7
1855A:  MOVLB  0
1855C:  CALL   0E6E
18560:  BTFSC  1B.7
18562:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
18564:  MOVLW  42
18566:  MOVWF  FF6
18568:  MOVLW  21
1856A:  MOVWF  FF7
1856C:  MOVLW  00
1856E:  MOVWF  FF8
18570:  CLRF   1B
18572:  BTFSC  FF2.7
18574:  BSF    1B.7
18576:  BCF    FF2.7
18578:  MOVLW  15
1857A:  MOVLB  A
1857C:  MOVWF  x40
1857E:  MOVLB  0
18580:  CALL   1044
18584:  BTFSC  1B.7
18586:  BSF    FF2.7
18588:  MOVLW  10
1858A:  MOVWF  FE9
1858C:  MOVFF  888,8F1
18590:  MOVFF  887,8F0
18594:  CALL   900C
18598:  MOVLW  5A
1859A:  MOVWF  FF6
1859C:  MOVLW  21
1859E:  MOVWF  FF7
185A0:  MOVLW  00
185A2:  MOVWF  FF8
185A4:  CLRF   1B
185A6:  BTFSC  FF2.7
185A8:  BSF    1B.7
185AA:  BCF    FF2.7
185AC:  MOVLW  03
185AE:  MOVLB  A
185B0:  MOVWF  x40
185B2:  MOVLB  0
185B4:  CALL   1044
185B8:  BTFSC  1B.7
185BA:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
185BC:  MOVLW  5E
185BE:  MOVWF  FF6
185C0:  MOVLW  21
185C2:  MOVWF  FF7
185C4:  MOVLW  00
185C6:  MOVWF  FF8
185C8:  CLRF   1B
185CA:  BTFSC  FF2.7
185CC:  BSF    1B.7
185CE:  BCF    FF2.7
185D0:  CALL   0E6E
185D4:  BTFSC  1B.7
185D6:  BSF    FF2.7
185D8:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
185DA:  MOVLW  0D
185DC:  BTFSS  F9E.4
185DE:  BRA    185DC
185E0:  MOVWF  FAD
185E2:  MOVLW  0A
185E4:  BTFSS  F9E.4
185E6:  BRA    185E4
185E8:  MOVWF  FAD
185EA:  MOVLB  0
185EC:  GOTO   18788 (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
187AA:  BCF    FD8.0
187AC:  MOVLB  8
187AE:  RLCF   x8B,W
187B0:  CLRF   03
187B2:  ADDLW  D1
187B4:  MOVWF  FE9
187B6:  MOVLW  07
187B8:  ADDWFC 03,W
187BA:  MOVWF  FEA
187BC:  MOVFF  FEC,894
187C0:  MOVF   FED,F
187C2:  MOVFF  FEF,893
187C6:  MOVFF  88D,A11
187CA:  MOVFF  88C,A10
187CE:  MOVLB  A
187D0:  CLRF   x13
187D2:  MOVLW  03
187D4:  MOVWF  x12
187D6:  MOVLB  0
187D8:  CALL   5CC0
187DC:  MOVF   01,W
187DE:  MOVLB  8
187E0:  ADDWF  x93,W
187E2:  MOVWF  x8E
187E4:  MOVF   02,W
187E6:  ADDWFC x94,W
187E8:  MOVWF  x8F
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
187EA:  MOVFF  88F,8CC
187EE:  MOVFF  88E,8CB
187F2:  MOVLB  0
187F4:  CALL   10648
187F8:  MOVFF  01,890
....................    ++addr; 
187FC:  MOVLB  8
187FE:  INCF   x8E,F
18800:  BTFSC  FD8.2
18802:  INCF   x8F,F
....................    macro_arg = read16_ext_eeprom(addr); 
18804:  MOVFF  88F,8C3
18808:  MOVFF  88E,8C2
1880C:  MOVLB  0
1880E:  CALL   1075C
18812:  MOVFF  02,892
18816:  MOVFF  01,891
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
1881A:  MOVLB  8
1881C:  MOVF   x90,W
1881E:  BTFSS  F9E.4
18820:  BRA    1881E
18822:  MOVWF  FAD
18824:  MOVLW  10
18826:  MOVWF  FE9
18828:  CLRF   1B
1882A:  BTFSC  FF2.7
1882C:  BSF    1B.7
1882E:  BCF    FF2.7
18830:  MOVFF  892,A41
18834:  MOVFF  891,A40
18838:  MOVLB  0
1883A:  CALL   11C6
1883E:  BTFSC  1B.7
18840:  BSF    FF2.7
18842:  MOVLW  0D
18844:  BTFSS  F9E.4
18846:  BRA    18844
18848:  MOVWF  FAD
1884A:  MOVLW  0A
1884C:  BTFSS  F9E.4
1884E:  BRA    1884C
18850:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
18852:  MOVLB  8
18854:  MOVFF  890,01
18858:  MOVLB  0
1885A:  GOTO   1888E (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
14374:  BCF    FD8.0
14376:  MOVLB  8
14378:  RLCF   xB7,W
1437A:  CLRF   03
1437C:  ADDLW  D1
1437E:  MOVWF  FE9
14380:  MOVLW  07
14382:  ADDWFC 03,W
14384:  MOVWF  FEA
14386:  MOVFF  FEC,8C0
1438A:  MOVF   FED,F
1438C:  MOVFF  FEF,8BF
14390:  MOVFF  8B9,A11
14394:  MOVFF  8B8,A10
14398:  MOVLB  A
1439A:  CLRF   x13
1439C:  MOVLW  03
1439E:  MOVWF  x12
143A0:  MOVLB  0
143A2:  CALL   5CC0
143A6:  MOVF   01,W
143A8:  MOVLB  8
143AA:  ADDWF  xBF,W
143AC:  MOVWF  xBA
143AE:  MOVF   02,W
143B0:  ADDWFC xC0,W
143B2:  MOVWF  xBB
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
143B4:  MOVFF  8BB,8CC
143B8:  MOVFF  8BA,8CB
143BC:  MOVLB  0
143BE:  CALL   10648
143C2:  MOVFF  01,8BC
....................    ++addr; 
143C6:  MOVLB  8
143C8:  INCF   xBA,F
143CA:  BTFSC  FD8.2
143CC:  INCF   xBB,F
....................    macro_arg = read16_ext_eeprom(addr); 
143CE:  MOVFF  8BB,8C3
143D2:  MOVFF  8BA,8C2
143D6:  MOVLB  0
143D8:  CALL   1075C
143DC:  MOVFF  02,8BE
143E0:  MOVFF  01,8BD
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
143E4:  MOVLB  8
143E6:  MOVF   xBC,W
143E8:  BTFSS  F9E.4
143EA:  BRA    143E8
143EC:  MOVWF  FAD
143EE:  MOVLW  10
143F0:  MOVWF  FE9
143F2:  CLRF   1B
143F4:  BTFSC  FF2.7
143F6:  BSF    1B.7
143F8:  BCF    FF2.7
143FA:  MOVFF  8BE,A41
143FE:  MOVFF  8BD,A40
14402:  MOVLB  0
14404:  CALL   11C6
14408:  BTFSC  1B.7
1440A:  BSF    FF2.7
1440C:  MOVLW  0D
1440E:  BTFSS  F9E.4
14410:  BRA    1440E
14412:  MOVWF  FAD
14414:  MOVLW  0A
14416:  BTFSS  F9E.4
14418:  BRA    14416
1441A:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
1441C:  MOVLB  8
1441E:  MOVFF  8BC,01
14422:  MOVLB  0
14424:  GOTO   14BFC (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
106A2:  BCF    FD8.0
106A4:  MOVLB  8
106A6:  RLCF   xB5,W
106A8:  CLRF   03
106AA:  ADDLW  FB
106AC:  MOVWF  FE9
106AE:  MOVLW  07
106B0:  ADDWFC 03,W
106B2:  MOVWF  FEA
106B4:  MOVFF  FEC,8BE
106B8:  MOVF   FED,F
106BA:  MOVFF  FEF,8BD
106BE:  MOVFF  8B9,A11
106C2:  MOVFF  8B8,A10
106C6:  MOVLB  A
106C8:  CLRF   x13
106CA:  MOVLW  32
106CC:  MOVWF  x12
106CE:  MOVLB  0
106D0:  CALL   5CC0
106D4:  MOVF   01,W
106D6:  MOVLB  8
106D8:  ADDWF  xBD,W
106DA:  MOVWF  xBA
106DC:  MOVF   02,W
106DE:  ADDWFC xBE,W
106E0:  MOVWF  xBB
....................     
....................    int i = 0; 
106E2:  CLRF   xBC
....................    for(i = 0; i < 50; i++){ 
106E4:  CLRF   xBC
106E6:  MOVF   xBC,W
106E8:  SUBLW  31
106EA:  BNC   10700
....................       string_arg[i] = 0; 
106EC:  CLRF   03
106EE:  MOVF   xBC,W
106F0:  ADDLW  25
106F2:  MOVWF  FE9
106F4:  MOVLW  08
106F6:  ADDWFC 03,W
106F8:  MOVWF  FEA
106FA:  CLRF   FEF
106FC:  INCF   xBC,F
106FE:  BRA    106E6
....................    }  
....................    for(i = 0; i < 50; i++){ 
10700:  CLRF   xBC
10702:  MOVF   xBC,W
10704:  SUBLW  31
10706:  BNC   10758
....................       string_arg[i] = read_ext_eeprom(addr + i); 
10708:  CLRF   03
1070A:  MOVF   xBC,W
1070C:  ADDLW  25
1070E:  MOVWF  01
10710:  MOVLW  08
10712:  ADDWFC 03,F
10714:  MOVFF  01,8BD
10718:  MOVFF  03,8BE
1071C:  MOVF   xBC,W
1071E:  ADDWF  xBA,W
10720:  MOVWF  xBF
10722:  MOVLW  00
10724:  ADDWFC xBB,W
10726:  MOVWF  xC0
10728:  MOVWF  xCC
1072A:  MOVFF  8BF,8CB
1072E:  MOVLB  0
10730:  RCALL  10648
10732:  MOVFF  8BE,FEA
10736:  MOVFF  8BD,FE9
1073A:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
1073E:  CLRF   03
10740:  MOVLB  8
10742:  MOVF   xBC,W
10744:  ADDLW  25
10746:  MOVWF  FE9
10748:  MOVLW  08
1074A:  ADDWFC 03,W
1074C:  MOVWF  FEA
1074E:  MOVF   FEF,F
10750:  BNZ   10754
....................          break; 
10752:  BRA    10758
....................       } 
10754:  INCF   xBC,F
10756:  BRA    10702
....................    }   
10758:  MOVLB  0
1075A:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
1885E:  MOVLB  8
18860:  CLRF   x8A
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
18862:  CLRF   x88
18864:  CLRF   x87
....................    macro_cmd = 1; 
18866:  MOVLW  01
18868:  MOVWF  x89
....................     
....................    init_ext_eeprom(); 
1886A:  MOVLB  0
1886C:  CALL   FFD6
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
18870:  MOVLB  8
18872:  MOVF   x88,W
18874:  SUBLW  03
18876:  BNC   188BE
18878:  MOVF   x89,W
1887A:  SUBLW  3B
1887C:  BZ    188BE
....................       macro_cmd = read_macro_line(macro, line); 
1887E:  MOVFF  886,88B
18882:  MOVFF  888,88D
18886:  MOVFF  887,88C
1888A:  MOVLB  0
1888C:  BRA    187AA
1888E:  MOVFF  01,889
....................       if(macro_cmd == 'p'){ 
18892:  MOVLB  8
18894:  MOVF   x89,W
18896:  SUBLW  70
18898:  BNZ   188B6
....................          read_macro_line_string(macro,line,count); 
1889A:  MOVFF  886,8B5
1889E:  MOVFF  888,8B7
188A2:  MOVFF  887,8B6
188A6:  CLRF   xB9
188A8:  MOVFF  88A,8B8
188AC:  MOVLB  0
188AE:  CALL   106A2
....................          count++; 
188B2:  MOVLB  8
188B4:  INCF   x8A,F
....................       } 
....................       ++line; 
188B6:  INCF   x87,F
188B8:  BTFSC  FD8.2
188BA:  INCF   x88,F
188BC:  BRA    18872
....................    } 
188BE:  MOVLB  0
188C0:  GOTO   188E0 (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0D36A:  MOVLB  8
0D36C:  CLRF   xC5
0D36E:  CLRF   xC4
0D370:  MOVF   xC5,W
0D372:  SUBWF  xC3,W
0D374:  BNC   D39C
0D376:  BNZ   D37E
0D378:  MOVF   xC2,W
0D37A:  SUBWF  xC4,W
0D37C:  BC    D39C
....................       delay_ms(1000); 
0D37E:  MOVLW  04
0D380:  MOVWF  xC6
0D382:  MOVLW  FA
0D384:  MOVLB  9
0D386:  MOVWF  xEC
0D388:  MOVLB  0
0D38A:  CALL   2938
0D38E:  MOVLB  8
0D390:  DECFSZ xC6,F
0D392:  BRA    D382
0D394:  INCF   xC4,F
0D396:  BTFSC  FD8.2
0D398:  INCF   xC5,F
0D39A:  BRA    D370
....................    }  
0D39C:  MOVLB  0
0D39E:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0D332:  BCF    FD8.0
0D334:  MOVLB  7
0D336:  RLCF   x40,W
0D338:  CLRF   03
0D33A:  ADDLW  96
0D33C:  MOVWF  FE9
0D33E:  MOVLW  07
0D340:  ADDWFC 03,W
0D342:  MOVWF  FEA
0D344:  MOVFF  FEC,8C4
0D348:  MOVF   FED,F
0D34A:  MOVFF  FEF,8C3
0D34E:  MOVLB  8
0D350:  DECFSZ xC3,W
0D352:  BRA    D35E
0D354:  MOVF   xC4,F
0D356:  BNZ   D35E
....................    { 
....................       macro_status = 'e'; 
0D358:  MOVLW  65
0D35A:  MOVWF  xC2
....................    } 
0D35C:  BRA    D362
....................    else 
....................    { 
....................       macro_status = 'a'; 
0D35E:  MOVLW  61
0D360:  MOVWF  xC2
....................    } 
....................    return(macro_status); 
0D362:  MOVFF  8C2,01
0D366:  MOVLB  0
0D368:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
13890:  DECFSZ 45,W
13892:  BRA    138A6
13894:  MOVF   46,F
13896:  BNZ   138A6
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
13898:  MOVLW  01
1389A:  MOVLB  8
1389C:  MOVWF  xC2
1389E:  MOVWF  xC3
138A0:  MOVLB  0
138A2:  RCALL  1375A
....................    } 
138A4:  BRA    138D0
....................    else if(nv_det_type==2 || nv_det_type==3) 
138A6:  MOVF   45,W
138A8:  SUBLW  02
138AA:  BNZ   138B0
138AC:  MOVF   46,F
138AE:  BZ    138BA
138B0:  MOVF   45,W
138B2:  SUBLW  03
138B4:  BNZ   138D0
138B6:  MOVF   46,F
138B8:  BNZ   138D0
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
138BA:  MOVLB  8
138BC:  CLRF   xC3
138BE:  MOVLW  C8
138C0:  MOVWF  xC2
138C2:  MOVLW  01
138C4:  MOVWF  xC4
138C6:  MOVWF  xC5
138C8:  CLRF   xC6
138CA:  MOVLB  0
138CC:  CALL   100B6
....................    } 
138D0:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
127C2:  DECFSZ 45,W
127C4:  BRA    127E0
127C6:  MOVF   46,F
127C8:  BNZ   127E0
....................       cmd = macro_cmd; 
127CA:  MOVFF  8C2,47
....................       arg = macro_arg; 
127CE:  CLRF   4B
127D0:  CLRF   4A
127D2:  MOVFF  8C4,49
127D6:  MOVFF  8C3,48
....................       det_cmd(); 
127DA:  CALL   F432
....................    } 
127DE:  BRA    127FA
....................    else if(nv_det_type==2 || nv_det_type==3) { 
127E0:  MOVF   45,W
127E2:  SUBLW  02
127E4:  BNZ   127EA
127E6:  MOVF   46,F
127E8:  BZ    127F4
127EA:  MOVF   45,W
127EC:  SUBLW  03
127EE:  BNZ   127FA
127F0:  MOVF   46,F
127F2:  BNZ   127FA
....................       set_heaters(macro_arg); 
127F4:  MOVFF  8C3,8C5
127F8:  RCALL  1274E
....................    } 
127FA:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
127FC:  DECFSZ 45,W
127FE:  BRA    1281A
12800:  MOVF   46,F
12802:  BNZ   1281A
....................       cmd = macro_cmd; 
12804:  MOVFF  8C2,47
....................       arg = macro_arg; 
12808:  CLRF   4B
1280A:  CLRF   4A
1280C:  MOVFF  8C4,49
12810:  MOVFF  8C3,48
....................       det_cmd(); 
12814:  CALL   F432
....................    } 
12818:  BRA    1283A
....................    else if(nv_det_type==2 || nv_det_type==3) { 
1281A:  MOVF   45,W
1281C:  SUBLW  02
1281E:  BNZ   12824
12820:  MOVF   46,F
12822:  BZ    1282E
12824:  MOVF   45,W
12826:  SUBLW  03
12828:  BNZ   1283A
1282A:  MOVF   46,F
1282C:  BNZ   1283A
....................       set_LED(macro_arg); 
1282E:  MOVFF  8C4,8C6
12832:  MOVFF  8C3,8C5
12836:  CALL   F8F6
....................    } 
1283A:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13F64:  MOVLW  65
13F66:  MOVLB  8
13F68:  MOVWF  xC1
....................     
....................    addr = macro_address[macro] + (line*3); 
13F6A:  BCF    FD8.0
13F6C:  RLCF   xB7,W
13F6E:  CLRF   03
13F70:  ADDLW  D1
13F72:  MOVWF  FE9
13F74:  MOVLW  07
13F76:  ADDWFC 03,W
13F78:  MOVWF  FEA
13F7A:  MOVFF  FEC,8C3
13F7E:  MOVF   FED,F
13F80:  MOVFF  FEF,8C2
13F84:  MOVFF  8B9,A11
13F88:  MOVFF  8B8,A10
13F8C:  MOVLB  A
13F8E:  CLRF   x13
13F90:  MOVLW  03
13F92:  MOVWF  x12
13F94:  MOVLB  0
13F96:  CALL   5CC0
13F9A:  MOVF   01,W
13F9C:  MOVLB  8
13F9E:  ADDWF  xC2,W
13FA0:  MOVWF  xBC
13FA2:  MOVF   02,W
13FA4:  ADDWFC xC3,W
13FA6:  MOVWF  xBD
....................  
....................    init_ext_eeprom(); 
13FA8:  MOVLB  0
13FAA:  CALL   FFD6
....................    macro_cmd = read_ext_eeprom(addr); 
13FAE:  MOVFF  8BD,8CC
13FB2:  MOVFF  8BC,8CB
13FB6:  CALL   10648
13FBA:  MOVFF  01,8BE
....................    ++addr; 
13FBE:  MOVLB  8
13FC0:  INCF   xBC,F
13FC2:  BTFSC  FD8.2
13FC4:  INCF   xBD,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13FC6:  MOVFF  8BD,8C3
13FCA:  MOVFF  8BC,8C2
13FCE:  MOVLB  0
13FD0:  CALL   1075C
13FD4:  MOVFF  02,8C0
13FD8:  MOVFF  01,8BF
....................    //} 
....................    heartbeat(TRUE); 
13FDC:  MOVLW  01
13FDE:  MOVLB  8
13FE0:  MOVWF  xED
13FE2:  MOVLB  0
13FE4:  CALL   55AE
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13FE8:  MOVF   2F,F
13FEA:  BTFSS  FD8.2
13FEC:  BRA    142B0
13FEE:  MOVF   30,F
13FF0:  BTFSS  FD8.2
13FF2:  BRA    142B0
....................       switch(macro_cmd) 
13FF4:  MOVLW  2B
13FF6:  MOVLB  8
13FF8:  SUBWF  xBE,W
13FFA:  ADDLW  B4
13FFC:  BTFSC  FD8.0
13FFE:  BRA    142B2
14000:  ADDLW  4C
14002:  MOVLB  0
14004:  GOTO   142BC
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
14008:  CALL   125DA
....................             store_rel_data(); 
1400C:  CALL   1263E
....................             macro_status = 'a'; 
14010:  MOVLW  61
14012:  MOVLB  8
14014:  MOVWF  xC1
....................             break; 
14016:  BRA    142B2
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
14018:  MOVLW  08
1401A:  MOVWF  FEA
1401C:  MOVLW  25
1401E:  MOVWF  FE9
14020:  CALL   79BE
14024:  MOVLW  0D
14026:  BTFSS  F9E.4
14028:  BRA    14026
1402A:  MOVWF  FAD
1402C:  MOVLW  0A
1402E:  BTFSS  F9E.4
14030:  BRA    1402E
14032:  MOVWF  FAD
....................             macro_status = 'a'; 
14034:  MOVLW  61
14036:  MOVLB  8
14038:  MOVWF  xC1
....................             break; 
1403A:  BRA    142B2
....................          case 'C' : 
....................             calc_abs_data(); 
1403C:  CALL   125DA
....................             break; 
14040:  MOVLB  8
14042:  BRA    142B2
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
14044:  MOVFF  8C0,8C3
14048:  MOVFF  8BF,8C2
1404C:  CALL   D36A
....................             macro_status = 'a'; 
14050:  MOVLW  61
14052:  MOVLB  8
14054:  MOVWF  xC1
....................             break; 
14056:  BRA    142B2
....................          case 'F' : macro_flag = macro_arg; 
14058:  MOVFF  8C0,324
1405C:  MOVFF  8BF,323
....................                     macro_status = 'a'; 
14060:  MOVLW  61
14062:  MOVLB  8
14064:  MOVWF  xC1
....................             break ; 
14066:  BRA    142B2
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14068:  MOVFF  8BF,2D5
....................                     macro_status = 'a'; 
1406C:  MOVLW  61
1406E:  MOVLB  8
14070:  MOVWF  xC1
....................             break ; 
14072:  BRA    142B2
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14074:  MOVFF  8BE,8C2
14078:  MOVFF  8C0,8C4
1407C:  MOVFF  8BF,8C3
14080:  CALL   127C2
....................                     macro_status = 'a'; 
14084:  MOVLW  61
14086:  MOVLB  8
14088:  MOVWF  xC1
....................             break; 
1408A:  BRA    142B2
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
1408C:  MOVFF  8BE,8C2
14090:  MOVFF  8C0,8C4
14094:  MOVFF  8BF,8C3
14098:  CALL   127C2
....................                     macro_status = 'a'; 
1409C:  MOVLW  61
1409E:  MOVLB  8
140A0:  MOVWF  xC1
....................             break; 
140A2:  BRA    142B2
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
140A4:  MOVFF  8C0,8DC
140A8:  MOVFF  8BF,8DB
140AC:  MOVLB  8
140AE:  CLRF   xDE
140B0:  MOVLW  64
140B2:  MOVWF  xDD
140B4:  MOVLB  0
140B6:  CALL   2CFC
140BA:  MOVFF  02,74D
140BE:  MOVFF  01,74C
....................                     macro_status = 'a'; 
140C2:  MOVLW  61
140C4:  MOVLB  8
140C6:  MOVWF  xC1
....................             break;    
140C8:  BRA    142B2
....................          case 'l' : LightTargetFlag = 1; 
140CA:  MOVLW  01
140CC:  MOVLB  2
140CE:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
140D0:  MOVFF  8BE,8C2
140D4:  MOVFF  8C0,8C4
140D8:  MOVFF  8BF,8C3
140DC:  MOVLB  0
140DE:  CALL   127FC
....................                     delay_ms(10000); 
140E2:  MOVLW  28
140E4:  MOVLB  8
140E6:  MOVWF  xC2
140E8:  MOVLW  FA
140EA:  MOVLB  9
140EC:  MOVWF  xEC
140EE:  MOVLB  0
140F0:  CALL   2938
140F4:  MOVLB  8
140F6:  DECFSZ xC2,F
140F8:  BRA    140E8
....................                     macro_status = 'a'; 
140FA:  MOVLW  61
140FC:  MOVWF  xC1
....................             break;        
140FE:  BRA    142B2
....................          case 'L' : LightTargetFlag = 0; 
14100:  MOVLB  2
14102:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
14104:  MOVFF  8BE,8C2
14108:  MOVFF  8C0,8C4
1410C:  MOVFF  8BF,8C3
14110:  MOVLB  0
14112:  CALL   127FC
....................                     macro_status = 'a'; 
14116:  MOVLW  61
14118:  MOVLB  8
1411A:  MOVWF  xC1
....................             break; 
1411C:  BRA    142B2
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
1411E:  MOVFF  8BE,47
....................                     arg = macro_arg; 
14122:  CLRF   4B
14124:  CLRF   4A
14126:  MOVFF  8C0,49
1412A:  MOVFF  8BF,48
....................                     det_cmd(); 
1412E:  CALL   F432
....................                     macro_status = 'a'; 
14132:  MOVLW  61
14134:  MOVLB  8
14136:  MOVWF  xC1
....................             break ; 
14138:  BRA    142B2
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
1413A:  MOVLB  8
1413C:  DECFSZ xBF,W
1413E:  BRA    1414C
14140:  MOVF   xC0,F
14142:  BNZ   1414C
14144:  MOVLB  0
14146:  CALL   13890
1414A:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
1414C:  MOVF   xBF,W
1414E:  SUBLW  02
14150:  BNZ   14162
14152:  MOVF   xC0,F
14154:  BNZ   14162
14156:  MOVLW  01
14158:  MOVWF  xC2
1415A:  MOVWF  xC3
1415C:  MOVLB  0
1415E:  RCALL  13A5C
14160:  MOVLB  8
....................                     macro_status = 'a'; 
14162:  MOVLW  61
14164:  MOVWF  xC1
....................             break ;  
14166:  BRA    142B2
....................          case 'T' : det_temp(); 
14168:  RCALL  13C1C
....................                     macro_status = 'a'; 
1416A:  MOVLW  61
1416C:  MOVLB  8
1416E:  MOVWF  xC1
....................             break; 
14170:  BRA    142B2
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14172:  MOVLW  01
14174:  MOVLB  7
14176:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14178:  MOVLB  8
1417A:  CLRF   xC7
1417C:  CLRF   xC8
1417E:  CLRF   xCC
14180:  CLRF   xCB
14182:  MOVFF  8C0,8CA
14186:  MOVFF  8BF,8C9
1418A:  MOVWF  xCD
1418C:  MOVLB  0
1418E:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14192:  CALL   D332
14196:  MOVFF  01,8C1
....................             break; 
1419A:  MOVLB  8
1419C:  BRA    142B2
....................          case '-' : motor=1; 
1419E:  MOVLW  01
141A0:  MOVLB  7
141A2:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
141A4:  MOVLB  8
141A6:  CLRF   xC7
141A8:  MOVWF  xC8
141AA:  CLRF   xCC
141AC:  CLRF   xCB
141AE:  MOVFF  8C0,8CA
141B2:  MOVFF  8BF,8C9
141B6:  MOVWF  xCD
141B8:  MOVLB  0
141BA:  CALL   9DA0
....................                     macro_status=step_err_status(); 
141BE:  CALL   D332
141C2:  MOVFF  01,8C1
....................             break; 
141C6:  MOVLB  8
141C8:  BRA    142B2
....................          case 'G' : motor=0; 
141CA:  MOVLB  7
141CC:  CLRF   x40
....................                     align(0); 
141CE:  MOVLB  8
141D0:  CLRF   xC2
141D2:  MOVLB  0
141D4:  CALL   A8DC
....................                     macro_status=step_err_status(); 
141D8:  CALL   D332
141DC:  MOVFF  01,8C1
....................             break ;           
141E0:  MOVLB  8
141E2:  BRA    142B2
....................          case 'P' : motor=0; 
141E4:  MOVLB  7
141E6:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
141E8:  MOVLW  01
141EA:  MOVLB  8
141EC:  MOVWF  xC7
141EE:  CLRF   xC8
141F0:  CLRF   xCC
141F2:  CLRF   xCB
141F4:  MOVFF  8C0,8CA
141F8:  MOVFF  8BF,8C9
141FC:  MOVWF  xCD
141FE:  MOVLB  0
14200:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14204:  CALL   D332
14208:  MOVFF  01,8C1
....................             break; 
1420C:  MOVLB  8
1420E:  BRA    142B2
....................          case 'Q' : motor=0; 
14210:  MOVLB  7
14212:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
14214:  MOVLB  8
14216:  CLRF   xC7
14218:  CLRF   xC8
1421A:  CLRF   xCC
1421C:  CLRF   xCB
1421E:  MOVFF  8C0,8CA
14222:  MOVFF  8BF,8C9
14226:  MOVLW  01
14228:  MOVWF  xCD
1422A:  MOVLB  0
1422C:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14230:  CALL   D332
14234:  MOVFF  01,8C1
....................             break; 
14238:  MOVLB  8
1423A:  BRA    142B2
....................          case 'R' : motor=0; 
1423C:  MOVLB  7
1423E:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
14240:  MOVLB  8
14242:  CLRF   xC7
14244:  MOVLW  01
14246:  MOVWF  xC8
14248:  CLRF   xCC
1424A:  CLRF   xCB
1424C:  MOVFF  8C0,8CA
14250:  MOVFF  8BF,8C9
14254:  MOVWF  xCD
14256:  MOVLB  0
14258:  CALL   9DA0
....................                     macro_status=step_err_status(); 
1425C:  CALL   D332
14260:  MOVFF  01,8C1
....................             break; 
14264:  MOVLB  8
14266:  BRA    142B2
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14268:  MOVLB  8
1426A:  DECFSZ xBF,W
1426C:  BRA    1427C
1426E:  MOVF   xC0,F
14270:  BNZ   1427C
14272:  MOVLB  0
14274:  CALL   D3A0
14278:  BRA    1428A
1427A:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
1427C:  MOVF   xBF,F
1427E:  BNZ   1428C
14280:  MOVF   xC0,F
14282:  BNZ   1428C
14284:  MOVLB  0
14286:  CALL   D3C4
1428A:  MOVLB  8
....................                     macro_status = 'a'; 
1428C:  MOVLW  61
1428E:  MOVWF  xC1
....................             break; 
14290:  BRA    142B2
....................          case 'v': 
....................             arg = macro_arg; 
14292:  CLRF   4B
14294:  CLRF   4A
14296:  MOVFF  8C0,49
1429A:  MOVFF  8BF,48
....................             command_v(); 
1429E:  RCALL  13E08
....................             macro_status = 'a'; 
142A0:  MOVLW  61
142A2:  MOVLB  8
142A4:  MOVWF  xC1
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
142A6:  BRA    142B2
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
142A8:  MOVLW  66
142AA:  MOVLB  8
142AC:  MOVWF  xC1
....................             break ; 
142AE:  BRA    142B2
142B0:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
142B2:  MOVFF  8C1,01
142B6:  MOVLB  0
142B8:  GOTO   14BC4 (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
14A20:  MOVLW  65
14A22:  MOVLB  8
14A24:  MOVWF  xA7
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
14A26:  BCF    FD8.0
14A28:  RLCF   x9D,W
14A2A:  CLRF   03
14A2C:  ADDLW  D1
14A2E:  MOVWF  FE9
14A30:  MOVLW  07
14A32:  ADDWFC 03,W
14A34:  MOVWF  FEA
14A36:  MOVFF  FEC,8B6
14A3A:  MOVF   FED,F
14A3C:  MOVFF  FEF,8B5
14A40:  MOVFF  89F,03
14A44:  MOVFF  89E,FE9
14A48:  MOVFF  89F,FEA
14A4C:  MOVFF  FEC,A11
14A50:  MOVF   FED,F
14A52:  MOVFF  FEF,A10
14A56:  MOVLB  A
14A58:  CLRF   x13
14A5A:  MOVLW  03
14A5C:  MOVWF  x12
14A5E:  MOVLB  0
14A60:  CALL   5CC0
14A64:  MOVF   01,W
14A66:  MOVLB  8
14A68:  ADDWF  xB5,W
14A6A:  MOVWF  xA2
14A6C:  MOVF   02,W
14A6E:  ADDWFC xB6,W
14A70:  MOVWF  xA3
....................  
....................    init_ext_eeprom(); 
14A72:  MOVLB  0
14A74:  CALL   FFD6
....................    macro_cmd = read_ext_eeprom(addr); 
14A78:  MOVFF  8A3,8CC
14A7C:  MOVFF  8A2,8CB
14A80:  CALL   10648
14A84:  MOVFF  01,8A4
....................    ++addr; 
14A88:  MOVLB  8
14A8A:  INCF   xA2,F
14A8C:  BTFSC  FD8.2
14A8E:  INCF   xA3,F
....................    if(macro_cmd == 'p'){ 
14A90:  MOVF   xA4,W
14A92:  SUBLW  70
14A94:  BNZ   14ABA
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
14A96:  MOVFF  89D,8B5
14A9A:  MOVFF  89F,8B7
14A9E:  MOVFF  89E,8B6
14AA2:  MOVFF  858,8B9
14AA6:  MOVFF  857,8B8
14AAA:  MOVLB  0
14AAC:  CALL   106A2
....................       count1++; 
14AB0:  MOVLB  8
14AB2:  INCF   x57,F
14AB4:  BTFSC  FD8.2
14AB6:  INCF   x58,F
....................    }else{ 
14AB8:  BRA    14AD2
....................    macro_arg = read16_ext_eeprom(addr); 
14ABA:  MOVFF  8A3,8C3
14ABE:  MOVFF  8A2,8C2
14AC2:  MOVLB  0
14AC4:  CALL   1075C
14AC8:  MOVFF  02,8A6
14ACC:  MOVFF  01,8A5
14AD0:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
14AD2:  MOVLW  01
14AD4:  MOVWF  xED
14AD6:  MOVLB  0
14AD8:  CALL   55AE
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
14ADC:  MOVF   2F,F
14ADE:  BTFSS  FD8.2
14AE0:  BRA    14F46
14AE2:  MOVF   30,F
14AE4:  BTFSS  FD8.2
14AE6:  BRA    14F46
....................       switch(macro_cmd){ 
14AE8:  MOVLW  2B
14AEA:  MOVLB  8
14AEC:  SUBWF  xA4,W
14AEE:  ADDLW  B4
14AF0:  BTFSC  FD8.0
14AF2:  BRA    14F42
14AF4:  ADDLW  4C
14AF6:  MOVLB  0
14AF8:  GOTO   1520C
....................          case 'A' : 
....................             calc_abs_data(); 
14AFC:  CALL   125DA
....................             store_rel_data(); 
14B00:  CALL   1263E
....................             macro_status = 'a'; 
14B04:  MOVLW  61
14B06:  MOVLB  8
14B08:  MOVWF  xA7
....................             break; 
14B0A:  BRA    14F42
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
14B0C:  MOVLW  08
14B0E:  MOVWF  FEA
14B10:  MOVLW  25
14B12:  MOVWF  FE9
14B14:  CALL   79BE
14B18:  MOVLW  0D
14B1A:  BTFSS  F9E.4
14B1C:  BRA    14B1A
14B1E:  MOVWF  FAD
14B20:  MOVLW  0A
14B22:  BTFSS  F9E.4
14B24:  BRA    14B22
14B26:  MOVWF  FAD
....................             macro_status = 'a'; 
14B28:  MOVLW  61
14B2A:  MOVLB  8
14B2C:  MOVWF  xA7
....................             break; 
14B2E:  BRA    14F42
....................          case 'C' : 
....................             calc_abs_data(); 
14B30:  CALL   125DA
....................             break; 
14B34:  MOVLB  8
14B36:  BRA    14F42
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
14B38:  MOVLB  8
14B3A:  CLRF   xAB
14B3C:  CLRF   xAA
14B3E:  CLRF   xA9
14B40:  CLRF   xA8
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
14B42:  MOVFF  89F,03
14B46:  MOVFF  89E,FE9
14B4A:  MOVFF  89F,FEA
14B4E:  MOVLW  01
14B50:  ADDWF  FEE,F
14B52:  BNC   14B56
14B54:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
14B56:  MOVFF  89E,FE9
14B5A:  MOVFF  89F,FEA
14B5E:  CLRF   xAF
14B60:  CLRF   xAE
14B62:  MOVFF  FEC,8AD
14B66:  MOVF   FED,F
14B68:  MOVFF  FEF,8AC
14B6C:  CLRF   xB3
14B6E:  CLRF   xB2
14B70:  CLRF   xB1
14B72:  CLRF   xB0
....................                    
....................                   while(count < macro_arg){ 
14B74:  MOVF   xAB,F
14B76:  BTFSS  FD8.2
14B78:  BRA    14CB4
14B7A:  MOVF   xAA,F
14B7C:  BTFSS  FD8.2
14B7E:  BRA    14CB4
14B80:  MOVF   xA9,W
14B82:  SUBWF  xA6,W
14B84:  BTFSS  FD8.0
14B86:  BRA    14CB4
14B88:  BNZ   14B92
14B8A:  MOVF   xA5,W
14B8C:  SUBWF  xA8,W
14B8E:  BTFSC  FD8.0
14B90:  BRA    14CB4
....................                      char curr = 'A'; 
14B92:  MOVLW  41
14B94:  MOVWF  xB4
....................                      while(curr != '%'){ 
14B96:  MOVF   xB4,W
14B98:  SUBLW  25
14B9A:  BZ    14C06
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
14B9C:  MOVFF  89F,03
14BA0:  MOVFF  89E,FE9
14BA4:  MOVFF  89F,FEA
14BA8:  MOVFF  FEC,8B9
14BAC:  MOVF   FED,F
14BAE:  MOVFF  FEF,8B8
14BB2:  MOVFF  89D,8B7
14BB6:  MOVFF  8A1,8BB
14BBA:  MOVFF  8A0,8BA
14BBE:  MOVLB  0
14BC0:  GOTO   13F64
....................                         (*line)++; 
14BC4:  MOVFF  89F,03
14BC8:  MOVLB  8
14BCA:  MOVF   x9E,W
14BCC:  MOVWF  FE9
14BCE:  MOVFF  03,FEA
14BD2:  MOVLW  01
14BD4:  ADDWF  FEE,F
14BD6:  BNC   14BDA
14BD8:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
14BDA:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
14BDC:  MOVFF  89F,03
14BE0:  MOVFF  89E,FE9
14BE4:  MOVFF  89F,FEA
14BE8:  MOVFF  FEC,8B9
14BEC:  MOVF   FED,F
14BEE:  MOVFF  FEF,8B8
14BF2:  MOVFF  89D,8B7
14BF6:  MOVLB  0
14BF8:  GOTO   14374
14BFC:  MOVFF  01,8B4
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
14C00:  BSF    F91.5
14C02:  MOVLB  8
14C04:  BRA    14B96
....................                      } 
....................                      end_line = (*line); 
14C06:  MOVFF  89E,FE9
14C0A:  MOVFF  89F,FEA
14C0E:  CLRF   xB3
14C10:  CLRF   xB2
14C12:  MOVFF  FEC,8B1
14C16:  MOVF   FED,F
14C18:  MOVFF  FEF,8B0
....................                      count++; 
14C1C:  MOVLW  01
14C1E:  ADDWF  xA8,F
14C20:  BTFSC  FD8.0
14C22:  INCF   xA9,F
14C24:  BTFSC  FD8.2
14C26:  INCF   xAA,F
14C28:  BTFSC  FD8.2
14C2A:  INCF   xAB,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
14C2C:  MOVF   xA8,W
14C2E:  SUBWF  xA5,W
14C30:  MOVWF  xB5
14C32:  MOVF   xA9,W
14C34:  SUBWFB xA6,W
14C36:  MOVWF  xB6
14C38:  MOVLW  00
14C3A:  SUBFWB xAA,W
14C3C:  MOVWF  xB7
14C3E:  MOVLW  00
14C40:  SUBFWB xAB,W
14C42:  MOVWF  xB8
14C44:  MOVLW  76
14C46:  MOVWF  FF6
14C48:  MOVLW  21
14C4A:  MOVWF  FF7
14C4C:  MOVLW  00
14C4E:  MOVWF  FF8
14C50:  CLRF   1B
14C52:  BTFSC  FF2.7
14C54:  BSF    1B.7
14C56:  BCF    FF2.7
14C58:  MOVLW  11
14C5A:  MOVLB  A
14C5C:  MOVWF  x40
14C5E:  MOVLB  0
14C60:  CALL   1044
14C64:  BTFSC  1B.7
14C66:  BSF    FF2.7
14C68:  MOVLW  41
14C6A:  MOVWF  FE9
14C6C:  CLRF   1B
14C6E:  BTFSC  FF2.7
14C70:  BSF    1B.7
14C72:  BCF    FF2.7
14C74:  MOVFF  8B8,A43
14C78:  MOVFF  8B7,A42
14C7C:  MOVFF  8B6,A41
14C80:  MOVFF  8B5,A40
14C84:  CALL   110A
14C88:  BTFSC  1B.7
14C8A:  BSF    FF2.7
14C8C:  MOVLW  0D
14C8E:  BTFSS  F9E.4
14C90:  BRA    14C8E
14C92:  MOVWF  FAD
14C94:  MOVLW  0A
14C96:  BTFSS  F9E.4
14C98:  BRA    14C96
14C9A:  MOVWF  FAD
....................                      (*line) = start_line; 
14C9C:  MOVFF  89F,03
14CA0:  MOVLB  8
14CA2:  MOVFF  89E,FE9
14CA6:  MOVFF  89F,FEA
14CAA:  MOVFF  8AC,FEF
14CAE:  MOVFF  8AD,FEC
14CB2:  BRA    14B74
....................                   } 
....................                   (*line) = end_line + 1; 
14CB4:  MOVFF  89E,FE9
14CB8:  MOVFF  89F,FEA
14CBC:  MOVLW  01
14CBE:  ADDWF  xB0,W
14CC0:  MOVWF  FEF
14CC2:  MOVLW  00
14CC4:  ADDWFC xB1,W
14CC6:  MOVWF  FEC
....................                   macro_status = 'a'; 
14CC8:  MOVLW  61
14CCA:  MOVWF  xA7
....................             break; 
14CCC:  BRA    14F42
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
14CCE:  MOVFF  8A6,8C3
14CD2:  MOVFF  8A5,8C2
14CD6:  CALL   D36A
....................                     macro_status = 'a'; 
14CDA:  MOVLW  61
14CDC:  MOVLB  8
14CDE:  MOVWF  xA7
....................             break; 
14CE0:  BRA    14F42
....................          case 'F' : macro_flag = macro_arg; 
14CE2:  MOVFF  8A6,324
14CE6:  MOVFF  8A5,323
....................                     macro_status = 'a'; 
14CEA:  MOVLW  61
14CEC:  MOVLB  8
14CEE:  MOVWF  xA7
....................             break ; 
14CF0:  BRA    14F42
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14CF2:  MOVFF  8A5,2D5
....................                     macro_status = 'a'; 
14CF6:  MOVLW  61
14CF8:  MOVLB  8
14CFA:  MOVWF  xA7
....................             break ; 
14CFC:  BRA    14F42
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14CFE:  MOVFF  8A4,8C2
14D02:  MOVFF  8A6,8C4
14D06:  MOVFF  8A5,8C3
14D0A:  CALL   127C2
....................                     macro_status = 'a'; 
14D0E:  MOVLW  61
14D10:  MOVLB  8
14D12:  MOVWF  xA7
....................             break; 
14D14:  BRA    14F42
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14D16:  MOVFF  8A4,8C2
14D1A:  MOVFF  8A6,8C4
14D1E:  MOVFF  8A5,8C3
14D22:  CALL   127C2
....................                     macro_status = 'a'; 
14D26:  MOVLW  61
14D28:  MOVLB  8
14D2A:  MOVWF  xA7
....................             break; 
14D2C:  BRA    14F42
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14D2E:  MOVFF  8A6,8DC
14D32:  MOVFF  8A5,8DB
14D36:  MOVLB  8
14D38:  CLRF   xDE
14D3A:  MOVLW  64
14D3C:  MOVWF  xDD
14D3E:  MOVLB  0
14D40:  CALL   2CFC
14D44:  MOVFF  02,74D
14D48:  MOVFF  01,74C
....................                     macro_status = 'a'; 
14D4C:  MOVLW  61
14D4E:  MOVLB  8
14D50:  MOVWF  xA7
....................             break;    
14D52:  BRA    14F42
....................          case 'l' : LightTargetFlag = 1; 
14D54:  MOVLW  01
14D56:  MOVLB  2
14D58:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
14D5A:  MOVFF  8A4,8C2
14D5E:  MOVFF  8A6,8C4
14D62:  MOVFF  8A5,8C3
14D66:  MOVLB  0
14D68:  CALL   127FC
....................                     delay_ms(10000); 
14D6C:  MOVLW  28
14D6E:  MOVLB  8
14D70:  MOVWF  xB5
14D72:  MOVLW  FA
14D74:  MOVLB  9
14D76:  MOVWF  xEC
14D78:  MOVLB  0
14D7A:  CALL   2938
14D7E:  MOVLB  8
14D80:  DECFSZ xB5,F
14D82:  BRA    14D72
....................                     macro_status = 'a'; 
14D84:  MOVLW  61
14D86:  MOVWF  xA7
....................             break;        
14D88:  BRA    14F42
....................          case 'L' : LightTargetFlag = 0; 
14D8A:  MOVLB  2
14D8C:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
14D8E:  MOVFF  8A4,8C2
14D92:  MOVFF  8A6,8C4
14D96:  MOVFF  8A5,8C3
14D9A:  MOVLB  0
14D9C:  CALL   127FC
....................                     macro_status = 'a'; 
14DA0:  MOVLW  61
14DA2:  MOVLB  8
14DA4:  MOVWF  xA7
....................             break; 
14DA6:  BRA    14F42
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
14DA8:  MOVFF  8A4,47
....................                     arg = macro_arg; 
14DAC:  CLRF   4B
14DAE:  CLRF   4A
14DB0:  MOVFF  8A6,49
14DB4:  MOVFF  8A5,48
....................                     det_cmd(); 
14DB8:  CALL   F432
....................                     macro_status = 'a'; 
14DBC:  MOVLW  61
14DBE:  MOVLB  8
14DC0:  MOVWF  xA7
....................             break ; 
14DC2:  BRA    14F42
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
14DC4:  MOVLB  8
14DC6:  DECFSZ xA5,W
14DC8:  BRA    14DD6
14DCA:  MOVF   xA6,F
14DCC:  BNZ   14DD6
14DCE:  MOVLB  0
14DD0:  CALL   13890
14DD4:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14DD6:  MOVF   xA5,W
14DD8:  SUBLW  02
14DDA:  BNZ   14DEE
14DDC:  MOVF   xA6,F
14DDE:  BNZ   14DEE
14DE0:  MOVLW  01
14DE2:  MOVWF  xC2
14DE4:  MOVWF  xC3
14DE6:  MOVLB  0
14DE8:  CALL   13A5C
14DEC:  MOVLB  8
....................                     macro_status = 'a'; 
14DEE:  MOVLW  61
14DF0:  MOVWF  xA7
....................             break ;  
14DF2:  BRA    14F42
....................          case 'T' : det_temp(); 
14DF4:  CALL   13C1C
....................                     macro_status = 'a'; 
14DF8:  MOVLW  61
14DFA:  MOVLB  8
14DFC:  MOVWF  xA7
....................             break; 
14DFE:  BRA    14F42
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14E00:  MOVLW  01
14E02:  MOVLB  7
14E04:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14E06:  MOVLB  8
14E08:  CLRF   xC7
14E0A:  CLRF   xC8
14E0C:  CLRF   xCC
14E0E:  CLRF   xCB
14E10:  MOVFF  8A6,8CA
14E14:  MOVFF  8A5,8C9
14E18:  MOVWF  xCD
14E1A:  MOVLB  0
14E1C:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14E20:  CALL   D332
14E24:  MOVFF  01,8A7
....................             break; 
14E28:  MOVLB  8
14E2A:  BRA    14F42
....................          case '-' : motor=1; 
14E2C:  MOVLW  01
14E2E:  MOVLB  7
14E30:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14E32:  MOVLB  8
14E34:  CLRF   xC7
14E36:  MOVWF  xC8
14E38:  CLRF   xCC
14E3A:  CLRF   xCB
14E3C:  MOVFF  8A6,8CA
14E40:  MOVFF  8A5,8C9
14E44:  MOVWF  xCD
14E46:  MOVLB  0
14E48:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14E4C:  CALL   D332
14E50:  MOVFF  01,8A7
....................             break; 
14E54:  MOVLB  8
14E56:  BRA    14F42
....................          case 'G' : motor=0; 
14E58:  MOVLB  7
14E5A:  CLRF   x40
....................                     align(0); 
14E5C:  MOVLB  8
14E5E:  CLRF   xC2
14E60:  MOVLB  0
14E62:  CALL   A8DC
....................                     macro_status=step_err_status(); 
14E66:  CALL   D332
14E6A:  MOVFF  01,8A7
....................             break ;           
14E6E:  MOVLB  8
14E70:  BRA    14F42
....................          case 'P' : motor=0; 
14E72:  MOVLB  7
14E74:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
14E76:  MOVLW  01
14E78:  MOVLB  8
14E7A:  MOVWF  xC7
14E7C:  CLRF   xC8
14E7E:  CLRF   xCC
14E80:  CLRF   xCB
14E82:  MOVFF  8A6,8CA
14E86:  MOVFF  8A5,8C9
14E8A:  MOVWF  xCD
14E8C:  MOVLB  0
14E8E:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14E92:  CALL   D332
14E96:  MOVFF  01,8A7
....................             break; 
14E9A:  MOVLB  8
14E9C:  BRA    14F42
....................          case 'Q' : motor=0; 
14E9E:  MOVLB  7
14EA0:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
14EA2:  MOVLB  8
14EA4:  CLRF   xC7
14EA6:  CLRF   xC8
14EA8:  CLRF   xCC
14EAA:  CLRF   xCB
14EAC:  MOVFF  8A6,8CA
14EB0:  MOVFF  8A5,8C9
14EB4:  MOVLW  01
14EB6:  MOVWF  xCD
14EB8:  MOVLB  0
14EBA:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14EBE:  CALL   D332
14EC2:  MOVFF  01,8A7
....................             break; 
14EC6:  MOVLB  8
14EC8:  BRA    14F42
....................          case 'R' : motor=0; 
14ECA:  MOVLB  7
14ECC:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
14ECE:  MOVLB  8
14ED0:  CLRF   xC7
14ED2:  MOVLW  01
14ED4:  MOVWF  xC8
14ED6:  CLRF   xCC
14ED8:  CLRF   xCB
14EDA:  MOVFF  8A6,8CA
14EDE:  MOVFF  8A5,8C9
14EE2:  MOVWF  xCD
14EE4:  MOVLB  0
14EE6:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14EEA:  CALL   D332
14EEE:  MOVFF  01,8A7
....................             break; 
14EF2:  MOVLB  8
14EF4:  BRA    14F42
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14EF6:  MOVLB  8
14EF8:  DECFSZ xA5,W
14EFA:  BRA    14F0A
14EFC:  MOVF   xA6,F
14EFE:  BNZ   14F0A
14F00:  MOVLB  0
14F02:  CALL   D3A0
14F06:  BRA    14F18
14F08:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14F0A:  MOVF   xA5,F
14F0C:  BNZ   14F1A
14F0E:  MOVF   xA6,F
14F10:  BNZ   14F1A
14F12:  MOVLB  0
14F14:  CALL   D3C4
14F18:  MOVLB  8
....................                     macro_status = 'a'; 
14F1A:  MOVLW  61
14F1C:  MOVWF  xA7
....................             break; 
14F1E:  BRA    14F42
....................          case 'v':  
....................             arg = macro_arg; 
14F20:  CLRF   4B
14F22:  CLRF   4A
14F24:  MOVFF  8A6,49
14F28:  MOVFF  8A5,48
....................             command_v(); 
14F2C:  CALL   13E08
....................             macro_status = 'a'; 
14F30:  MOVLW  61
14F32:  MOVLB  8
14F34:  MOVWF  xA7
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
14F36:  BRA    14F42
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14F38:  MOVLW  66
14F3A:  MOVLB  8
14F3C:  MOVWF  xA7
....................             break ; 
14F3E:  BRA    14F42
14F40:  MOVLB  8
....................       } 
....................    } 
14F42:  BRA    15202
14F44:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14F46:  DECFSZ 2F,W
14F48:  BRA    14F4E
14F4A:  MOVF   30,F
14F4C:  BZ    14F5C
14F4E:  MOVF   2F,W
14F50:  SUBLW  03
14F52:  BTFSS  FD8.2
14F54:  BRA    150DA
14F56:  MOVF   30,F
14F58:  BTFSS  FD8.2
14F5A:  BRA    150DA
....................       switch(macro_cmd){ 
14F5C:  MOVLB  8
14F5E:  MOVF   xA4,W
14F60:  XORLW  2B
14F62:  MOVLB  0
14F64:  BZ    14F92
14F66:  XORLW  06
14F68:  BZ    14FBC
14F6A:  XORLW  6F
14F6C:  BZ    14FE6
14F6E:  XORLW  05
14F70:  BZ    14FF8
14F72:  XORLW  17
14F74:  BZ    15010
14F76:  XORLW  01
14F78:  BZ    1503A
14F7A:  XORLW  03
14F7C:  BZ    15064
14F7E:  XORLW  06
14F80:  BTFSC  FD8.2
14F82:  BRA    1508E
14F84:  XORLW  0D
14F86:  BTFSC  FD8.2
14F88:  BRA    150A4
14F8A:  XORLW  62
14F8C:  BTFSC  FD8.2
14F8E:  BRA    150D0
14F90:  BRA    150D8
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14F92:  MOVLW  01
14F94:  MOVLB  7
14F96:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14F98:  MOVLB  8
14F9A:  CLRF   xC7
14F9C:  CLRF   xC8
14F9E:  CLRF   xCC
14FA0:  CLRF   xCB
14FA2:  MOVFF  8A6,8CA
14FA6:  MOVFF  8A5,8C9
14FAA:  MOVWF  xCD
14FAC:  MOVLB  0
14FAE:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14FB2:  CALL   D332
14FB6:  MOVFF  01,8A7
....................             break; 
14FBA:  BRA    150D8
....................          case '-' : motor=1; 
14FBC:  MOVLW  01
14FBE:  MOVLB  7
14FC0:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14FC2:  MOVLB  8
14FC4:  CLRF   xC7
14FC6:  MOVWF  xC8
14FC8:  CLRF   xCC
14FCA:  CLRF   xCB
14FCC:  MOVFF  8A6,8CA
14FD0:  MOVFF  8A5,8C9
14FD4:  MOVWF  xCD
14FD6:  MOVLB  0
14FD8:  CALL   9DA0
....................                     macro_status=step_err_status(); 
14FDC:  CALL   D332
14FE0:  MOVFF  01,8A7
....................             break; 
14FE4:  BRA    150D8
....................          case 'B' : h_bridge(macro_arg); 
14FE6:  MOVFF  8A5,8B5
14FEA:  CALL   C280
....................                     macro_status = 'a'; 
14FEE:  MOVLW  61
14FF0:  MOVLB  8
14FF2:  MOVWF  xA7
....................             break;             
14FF4:  MOVLB  0
14FF6:  BRA    150D8
....................          case 'G' : motor=0; 
14FF8:  MOVLB  7
14FFA:  CLRF   x40
....................                     align(0); 
14FFC:  MOVLB  8
14FFE:  CLRF   xC2
15000:  MOVLB  0
15002:  CALL   A8DC
....................                     macro_status=step_err_status(); 
15006:  CALL   D332
1500A:  MOVFF  01,8A7
....................             break ;           
1500E:  BRA    150D8
....................          case 'P' : motor=0; 
15010:  MOVLB  7
15012:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1);   
15014:  MOVLB  8
15016:  CLRF   xC7
15018:  CLRF   xC8
1501A:  CLRF   xCC
1501C:  CLRF   xCB
1501E:  MOVFF  8A1,8CA
15022:  MOVFF  8A0,8C9
15026:  MOVLW  01
15028:  MOVWF  xCD
1502A:  MOVLB  0
1502C:  CALL   9DA0
....................                     macro_status=step_err_status(); 
15030:  CALL   D332
15034:  MOVFF  01,8A7
....................             break; 
15038:  BRA    150D8
....................          case 'Q' : motor=0; 
1503A:  MOVLB  7
1503C:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1); 
1503E:  MOVLB  8
15040:  CLRF   xC7
15042:  CLRF   xC8
15044:  CLRF   xCC
15046:  CLRF   xCB
15048:  MOVFF  8A1,8CA
1504C:  MOVFF  8A0,8C9
15050:  MOVLW  01
15052:  MOVWF  xCD
15054:  MOVLB  0
15056:  CALL   9DA0
....................                     macro_status=step_err_status(); 
1505A:  CALL   D332
1505E:  MOVFF  01,8A7
....................             break; 
15062:  BRA    150D8
....................          case 'R' : motor=0; 
15064:  MOVLB  7
15066:  CLRF   x40
....................                     move_motor(0,1,mmacro_var,1); 
15068:  MOVLB  8
1506A:  CLRF   xC7
1506C:  MOVLW  01
1506E:  MOVWF  xC8
15070:  CLRF   xCC
15072:  CLRF   xCB
15074:  MOVFF  8A1,8CA
15078:  MOVFF  8A0,8C9
1507C:  MOVWF  xCD
1507E:  MOVLB  0
15080:  CALL   9DA0
....................                     macro_status=step_err_status(); 
15084:  CALL   D332
15088:  MOVFF  01,8A7
....................             break; 
1508C:  BRA    150D8
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
1508E:  MOVFF  8A6,8C3
15092:  MOVFF  8A5,8C2
15096:  CALL   D36A
....................                     macro_status = 'a'; 
1509A:  MOVLW  61
1509C:  MOVLB  8
1509E:  MOVWF  xA7
....................             break; 
150A0:  MOVLB  0
150A2:  BRA    150D8
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
150A4:  MOVLB  8
150A6:  DECFSZ xA5,W
150A8:  BRA    150B8
150AA:  MOVF   xA6,F
150AC:  BNZ   150B8
150AE:  MOVLB  0
150B0:  CALL   D3A0
150B4:  BRA    150C6
150B6:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
150B8:  MOVF   xA5,F
150BA:  BNZ   150C8
150BC:  MOVF   xA6,F
150BE:  BNZ   150C8
150C0:  MOVLB  0
150C2:  CALL   D3C4
150C6:  MOVLB  8
....................                     macro_status = 'a'; 
150C8:  MOVLW  61
150CA:  MOVWF  xA7
....................             break; 
150CC:  MOVLB  0
150CE:  BRA    150D8
....................          case ';' : macro_status = 'f'; 
150D0:  MOVLW  66
150D2:  MOVLB  8
150D4:  MOVWF  xA7
....................             break;            
150D6:  MOVLB  0
....................       } 
....................    } 
150D8:  BRA    15200
....................    else if (nv_product==AWS){ 
150DA:  MOVF   2F,W
150DC:  SUBLW  02
150DE:  BTFSS  FD8.2
150E0:  BRA    15200
150E2:  MOVF   30,F
150E4:  BTFSS  FD8.2
150E6:  BRA    15200
....................       switch(macro_cmd){ 
150E8:  MOVLB  8
150EA:  MOVF   xA4,W
150EC:  XORLW  2B
150EE:  MOVLB  0
150F0:  BZ    15116
150F2:  XORLW  06
150F4:  BZ    15140
150F6:  XORLW  6E
150F8:  BZ    1516A
150FA:  XORLW  07
150FC:  BZ    1517C
150FE:  XORLW  14
15100:  BZ    15192
15102:  XORLW  01
15104:  BZ    151A4
15106:  XORLW  02
15108:  BZ    151B6
1510A:  XORLW  0A
1510C:  BZ    151CC
1510E:  XORLW  62
15110:  BTFSC  FD8.2
15112:  BRA    151F8
15114:  BRA    15200
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
15116:  MOVLW  01
15118:  MOVLB  7
1511A:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
1511C:  MOVLB  8
1511E:  CLRF   xC7
15120:  CLRF   xC8
15122:  CLRF   xCC
15124:  CLRF   xCB
15126:  MOVFF  8A6,8CA
1512A:  MOVFF  8A5,8C9
1512E:  MOVWF  xCD
15130:  MOVLB  0
15132:  CALL   9DA0
....................                     macro_status=step_err_status(); 
15136:  CALL   D332
1513A:  MOVFF  01,8A7
....................             break; 
1513E:  BRA    15200
....................          case '-' : motor=1; 
15140:  MOVLW  01
15142:  MOVLB  7
15144:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
15146:  MOVLB  8
15148:  CLRF   xC7
1514A:  MOVWF  xC8
1514C:  CLRF   xCC
1514E:  CLRF   xCB
15150:  MOVFF  8A6,8CA
15154:  MOVFF  8A5,8C9
15158:  MOVWF  xCD
1515A:  MOVLB  0
1515C:  CALL   9DA0
....................                     macro_status=step_err_status(); 
15160:  CALL   D332
15164:  MOVFF  01,8A7
....................             break; 
15168:  BRA    15200
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
1516A:  MOVFF  8A5,8B6
1516E:  CALL   DBE6
....................                     macro_status = 'a';  
15172:  MOVLW  61
15174:  MOVLB  8
15176:  MOVWF  xA7
....................             break;          
15178:  MOVLB  0
1517A:  BRA    15200
....................          case 'D' : delay_sec(macro_arg); 
1517C:  MOVFF  8A6,8C3
15180:  MOVFF  8A5,8C2
15184:  CALL   D36A
....................                     macro_status = 'a'; 
15188:  MOVLW  61
1518A:  MOVLB  8
1518C:  MOVWF  xA7
....................             break; 
1518E:  MOVLB  0
15190:  BRA    15200
....................          case 'P' : sol_switch(mmacro_var); 
15192:  MOVFF  8A0,8B5
15196:  CALL   14598
....................                     macro_status = 'a'; 
1519A:  MOVLW  61
1519C:  MOVLB  8
1519E:  MOVWF  xA7
....................             break;              
151A0:  MOVLB  0
151A2:  BRA    15200
....................          case 'Q' : sol_switch(macro_arg); 
151A4:  MOVFF  8A5,8B5
151A8:  CALL   14598
....................                     macro_status = 'a'; 
151AC:  MOVLW  61
151AE:  MOVLB  8
151B0:  MOVWF  xA7
....................             break;             
151B2:  MOVLB  0
151B4:  BRA    15200
....................          case 'S' : sol_switch_cmd(macro_arg); 
151B6:  MOVFF  8A6,8B7
151BA:  MOVFF  8A5,8B6
151BE:  CALL   144E2
....................                     macro_status = 'a'; 
151C2:  MOVLW  61
151C4:  MOVLB  8
151C6:  MOVWF  xA7
....................             break; 
151C8:  MOVLB  0
151CA:  BRA    15200
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
151CC:  MOVLB  8
151CE:  DECFSZ xA5,W
151D0:  BRA    151E0
151D2:  MOVF   xA6,F
151D4:  BNZ   151E0
151D6:  MOVLB  0
151D8:  CALL   D3A0
151DC:  BRA    151EE
151DE:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
151E0:  MOVF   xA5,F
151E2:  BNZ   151F0
151E4:  MOVF   xA6,F
151E6:  BNZ   151F0
151E8:  MOVLB  0
151EA:  CALL   D3C4
151EE:  MOVLB  8
....................                     macro_status = 'a'; 
151F0:  MOVLW  61
151F2:  MOVWF  xA7
....................             break;               
151F4:  MOVLB  0
151F6:  BRA    15200
....................          case ';' : macro_status = 'f'; 
151F8:  MOVLW  66
151FA:  MOVLB  8
151FC:  MOVWF  xA7
....................             break;            
151FE:  MOVLB  0
15200:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
15202:  MOVFF  8A7,01
15206:  MOVLB  0
15208:  GOTO   15520 (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
153EE:  MOVLB  8
153F0:  CLRF   x58
153F2:  CLRF   x57
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
153F4:  MOVLB  0
153F6:  CALL   510E
....................    clear_data_arrays(); 
153FA:  GOTO   1055A
....................     
....................    line = 0;  
153FE:  MOVLB  8
15400:  CLRF   x9B
15402:  CLRF   x9A
....................    macro_status = 'a'; 
15404:  MOVLW  61
15406:  MOVWF  x9C
....................    data_available = FALSE; 
15408:  MOVLB  3
1540A:  CLRF   x3B
....................    macro_flag = 900; 
1540C:  MOVLW  03
1540E:  MOVWF  x24
15410:  MOVLW  84
15412:  MOVWF  x23
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
15414:  MOVLW  01
15416:  MOVWF  1E
15418:  MOVLW  A7
1541A:  MOVWF  1D
1541C:  MOVLW  8E
1541E:  MOVWF  FF6
15420:  MOVLW  21
15422:  MOVWF  FF7
15424:  MOVLW  00
15426:  MOVWF  FF8
15428:  MOVLW  07
1542A:  MOVLB  8
1542C:  MOVWF  xEB
1542E:  MOVLB  0
15430:  CALL   AAF4
15434:  MOVFF  897,8ED
15438:  MOVLW  1B
1543A:  MOVLB  8
1543C:  MOVWF  xEE
1543E:  MOVLB  0
15440:  CALL   52A8
15444:  MOVLW  97
15446:  MOVWF  FF6
15448:  MOVLW  21
1544A:  MOVWF  FF7
1544C:  MOVLW  00
1544E:  MOVWF  FF8
15450:  MOVLW  09
15452:  MOVLB  8
15454:  MOVWF  xEB
15456:  MOVLB  0
15458:  CALL   AAF4
....................    record_event();    
1545C:  CALL   8502
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
15460:  MOVLB  8
15462:  MOVF   x9B,W
15464:  SUBLW  03
15466:  BNC   15538
15468:  MOVF   x9C,W
1546A:  SUBLW  61
1546C:  BNZ   15538
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
1546E:  MOVF   1F,W
15470:  SUBLW  04
15472:  BNZ   15506
15474:  MOVF   20,F
15476:  BNZ   15506
....................                                                macro_status, (line + 1)); 
15478:  MOVLW  01
1547A:  ADDWF  x9A,W
1547C:  MOVWF  x9D
1547E:  MOVLW  00
15480:  ADDWFC x9B,W
15482:  MOVWF  x9E
15484:  MOVLW  A2
15486:  MOVWF  FF6
15488:  MOVLW  21
1548A:  MOVWF  FF7
1548C:  MOVLW  00
1548E:  MOVWF  FF8
15490:  CLRF   1B
15492:  BTFSC  FF2.7
15494:  BSF    1B.7
15496:  BCF    FF2.7
15498:  MOVLW  05
1549A:  MOVLB  A
1549C:  MOVWF  x40
1549E:  MOVLB  0
154A0:  CALL   1044
154A4:  BTFSC  1B.7
154A6:  BSF    FF2.7
154A8:  MOVLB  8
154AA:  MOVF   x9C,W
154AC:  BTFSS  F9E.4
154AE:  BRA    154AC
154B0:  MOVWF  FAD
154B2:  MOVLW  5D
154B4:  BTFSS  F9E.4
154B6:  BRA    154B4
154B8:  MOVWF  FAD
154BA:  MOVLW  5B
154BC:  BTFSS  F9E.4
154BE:  BRA    154BC
154C0:  MOVWF  FAD
154C2:  MOVLW  10
154C4:  MOVWF  FE9
154C6:  CLRF   1B
154C8:  BTFSC  FF2.7
154CA:  BSF    1B.7
154CC:  BCF    FF2.7
154CE:  MOVFF  89E,A41
154D2:  MOVFF  89D,A40
154D6:  MOVLB  0
154D8:  CALL   11C6
154DC:  BTFSC  1B.7
154DE:  BSF    FF2.7
154E0:  MOVLW  AE
154E2:  MOVWF  FF6
154E4:  MOVLW  21
154E6:  MOVWF  FF7
154E8:  MOVLW  00
154EA:  MOVWF  FF8
154EC:  CLRF   1B
154EE:  BTFSC  FF2.7
154F0:  BSF    1B.7
154F2:  BCF    FF2.7
154F4:  MOVLW  03
154F6:  MOVLB  A
154F8:  MOVWF  x40
154FA:  MOVLB  0
154FC:  CALL   1044
15500:  BTFSC  1B.7
15502:  BSF    FF2.7
15504:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
15506:  MOVFF  897,89D
1550A:  MOVLW  08
1550C:  MOVWF  x9F
1550E:  MOVLW  9A
15510:  MOVWF  x9E
15512:  MOVFF  899,8A1
15516:  MOVFF  898,8A0
1551A:  MOVLB  0
1551C:  GOTO   14A20
15520:  MOVFF  01,89C
....................       ++line; 
15524:  MOVLB  8
15526:  INCF   x9A,F
15528:  BTFSC  FD8.2
1552A:  INCF   x9B,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
1552C:  DECFSZ 50,W
1552E:  BRA    15536
....................          macro_status = 'g'; 
15530:  MOVLW  67
15532:  MOVWF  x9C
....................          break;    
15534:  BRA    15538
....................       } 
15536:  BRA    15462
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
15538:  MOVF   2F,W
1553A:  MOVWF  00
1553C:  MOVF   30,W
1553E:  MOVWF  03
15540:  MOVF   03,W
15542:  BNZ   1554E
15544:  MOVLW  01
15546:  SUBWF  00,W
15548:  MOVLB  0
1554A:  BZ    1556C
1554C:  MOVLB  8
1554E:  MOVF   03,W
15550:  BNZ   1555C
15552:  MOVLW  03
15554:  SUBWF  00,W
15556:  MOVLB  0
15558:  BZ    1556C
1555A:  MOVLB  8
1555C:  MOVF   03,W
1555E:  BNZ   1556A
15560:  MOVLW  02
15562:  SUBWF  00,W
15564:  MOVLB  0
15566:  BZ    15578
15568:  MOVLB  8
1556A:  BRA    15588
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
1556C:  MOVFF  897,89D
15570:  CALL   D66E
....................          break; 
15574:  MOVLB  8
15576:  BRA    15588
....................       case AWS : store_aws_data(macro,mmacro_var); 
15578:  MOVFF  897,89D
1557C:  MOVFF  899,89F
15580:  MOVFF  898,89E
15584:  BRA    152C4
....................          break; 
15586:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
15588:  MOVLW  61
1558A:  SUBWF  x9C,W
1558C:  ADDLW  F9
1558E:  BC    1567A
15590:  ADDLW  07
15592:  MOVLB  0
15594:  GOTO   15726
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
15598:  MOVLW  B2
1559A:  MOVWF  FF6
1559C:  MOVLW  21
1559E:  MOVWF  FF7
155A0:  MOVLW  00
155A2:  MOVWF  FF8
155A4:  CLRF   1B
155A6:  BTFSC  FF2.7
155A8:  BSF    1B.7
155AA:  BCF    FF2.7
155AC:  CALL   0E6E
155B0:  BTFSC  1B.7
155B2:  BSF    FF2.7
....................          break; 
155B4:  MOVLB  8
155B6:  BRA    1567A
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
155B8:  MOVLW  BA
155BA:  MOVWF  FF6
155BC:  MOVLW  21
155BE:  MOVWF  FF7
155C0:  MOVLW  00
155C2:  MOVWF  FF8
155C4:  CLRF   1B
155C6:  BTFSC  FF2.7
155C8:  BSF    1B.7
155CA:  BCF    FF2.7
155CC:  CALL   0E6E
155D0:  BTFSC  1B.7
155D2:  BSF    FF2.7
....................          break; 
155D4:  MOVLB  8
155D6:  BRA    1567A
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
155D8:  MOVLW  C2
155DA:  MOVWF  FF6
155DC:  MOVLW  21
155DE:  MOVWF  FF7
155E0:  MOVLW  00
155E2:  MOVWF  FF8
155E4:  CLRF   1B
155E6:  BTFSC  FF2.7
155E8:  BSF    1B.7
155EA:  BCF    FF2.7
155EC:  CALL   0E6E
155F0:  BTFSC  1B.7
155F2:  BSF    FF2.7
....................          break; 
155F4:  MOVLB  8
155F6:  BRA    1567A
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
155F8:  MOVLW  CA
155FA:  MOVWF  FF6
155FC:  MOVLW  21
155FE:  MOVWF  FF7
15600:  MOVLW  00
15602:  MOVWF  FF8
15604:  CLRF   1B
15606:  BTFSC  FF2.7
15608:  BSF    1B.7
1560A:  BCF    FF2.7
1560C:  CALL   0E6E
15610:  BTFSC  1B.7
15612:  BSF    FF2.7
....................          break; 
15614:  MOVLB  8
15616:  BRA    1567A
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
15618:  MOVLW  D2
1561A:  MOVWF  FF6
1561C:  MOVLW  21
1561E:  MOVWF  FF7
15620:  MOVLW  00
15622:  MOVWF  FF8
15624:  CLRF   1B
15626:  BTFSC  FF2.7
15628:  BSF    1B.7
1562A:  BCF    FF2.7
1562C:  CALL   0E6E
15630:  BTFSC  1B.7
15632:  BSF    FF2.7
....................          break;    
15634:  MOVLB  8
15636:  BRA    1567A
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
15638:  MOVLW  DA
1563A:  MOVWF  FF6
1563C:  MOVLW  21
1563E:  MOVWF  FF7
15640:  MOVLW  00
15642:  MOVWF  FF8
15644:  CLRF   1B
15646:  BTFSC  FF2.7
15648:  BSF    1B.7
1564A:  BCF    FF2.7
1564C:  CALL   0E6E
15650:  BTFSC  1B.7
15652:  BSF    FF2.7
....................          break;    
15654:  MOVLB  8
15656:  BRA    1567A
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
15658:  MOVLW  E2
1565A:  MOVWF  FF6
1565C:  MOVLW  21
1565E:  MOVWF  FF7
15660:  MOVLW  00
15662:  MOVWF  FF8
15664:  CLRF   1B
15666:  BTFSC  FF2.7
15668:  BSF    1B.7
1566A:  BCF    FF2.7
1566C:  CALL   0E6E
15670:  BTFSC  1B.7
15672:  BSF    FF2.7
....................          break;           
15674:  MOVLB  8
15676:  BRA    1567A
15678:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
1567A:  MOVLW  01
1567C:  MOVWF  1E
1567E:  MOVLW  A7
15680:  MOVWF  1D
15682:  MOVLW  EA
15684:  MOVWF  FF6
15686:  MOVLW  21
15688:  MOVWF  FF7
1568A:  MOVLW  00
1568C:  MOVWF  FF8
1568E:  MOVLW  07
15690:  MOVWF  xEB
15692:  MOVLB  0
15694:  CALL   AAF4
15698:  MOVFF  897,8ED
1569C:  MOVLW  1B
1569E:  MOVLB  8
156A0:  MOVWF  xEE
156A2:  MOVLB  0
156A4:  CALL   52A8
156A8:  MOVLW  F3
156AA:  MOVWF  FF6
156AC:  MOVLW  21
156AE:  MOVWF  FF7
156B0:  MOVLW  00
156B2:  MOVWF  FF8
156B4:  MOVLW  09
156B6:  MOVLB  8
156B8:  MOVWF  xEB
156BA:  MOVLB  0
156BC:  CALL   AAF4
156C0:  MOVFF  89C,8FF
156C4:  CALL   50C6
156C8:  MOVLW  FE
156CA:  MOVWF  FF6
156CC:  MOVLW  21
156CE:  MOVWF  FF7
156D0:  MOVLW  00
156D2:  MOVWF  FF8
156D4:  MOVLW  07
156D6:  MOVLB  8
156D8:  MOVWF  xEB
156DA:  MOVLB  0
156DC:  CALL   AAF4
156E0:  MOVLW  10
156E2:  MOVWF  FE9
156E4:  MOVFF  89B,8F7
156E8:  MOVFF  89A,8F6
156EC:  CALL   AB26
156F0:  MOVLW  08
156F2:  MOVWF  FF6
156F4:  MOVLW  22
156F6:  MOVWF  FF7
156F8:  MOVLW  00
156FA:  MOVWF  FF8
156FC:  MOVLW  03
156FE:  MOVLB  8
15700:  MOVWF  xEB
15702:  MOVLB  0
15704:  CALL   AAF4
....................    record_event(); 
15708:  CALL   8502
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
1570C:  MOVLB  8
1570E:  MOVF   x9C,W
15710:  SUBLW  66
15712:  BZ    15722
15714:  MOVF   x9C,W
15716:  SUBLW  67
15718:  BZ    15722
1571A:  MOVLB  0
1571C:  CALL   AA80
15720:  MOVLB  8
15722:  MOVLB  0
15724:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15FD4:  MOVLW  01
15FD6:  MOVLB  8
15FD8:  MOVWF  x8F
....................    while (macro_batch == TRUE){ 
15FDA:  DECFSZ x8F,W
15FDC:  BRA    16262
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15FDE:  MOVFF  38,A11
15FE2:  MOVFF  37,A10
15FE6:  MOVLB  A
15FE8:  CLRF   x13
15FEA:  MOVLW  03
15FEC:  MOVWF  x12
15FEE:  MOVLB  0
15FF0:  CALL   5CC0
15FF4:  MOVF   01,W
15FF6:  MOVLB  7
15FF8:  ADDWF  xD1,W
15FFA:  MOVLB  8
15FFC:  MOVWF  x8A
15FFE:  MOVF   02,W
16000:  MOVLB  7
16002:  ADDWFC xD2,W
16004:  MOVLB  8
16006:  MOVWF  x8B
....................       init_ext_eeprom(); 
16008:  MOVLB  0
1600A:  CALL   FFD6
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
1600E:  MOVFF  88B,8CC
16012:  MOVFF  88A,8CB
16016:  CALL   10648
1601A:  MOVFF  01,88C
....................       ++addr; 
1601E:  MOVLB  8
16020:  INCF   x8A,F
16022:  BTFSC  FD8.2
16024:  INCF   x8B,F
....................       macro_arg = read16_ext_eeprom(addr); 
16026:  MOVFF  88B,8C3
1602A:  MOVFF  88A,8C2
1602E:  MOVLB  0
16030:  CALL   1075C
16034:  MOVFF  02,88E
16038:  MOVFF  01,88D
....................       ++addr; 
1603C:  MOVLB  8
1603E:  INCF   x8A,F
16040:  BTFSC  FD8.2
16042:  INCF   x8B,F
....................       ++addr;      
16044:  INCF   x8A,F
16046:  BTFSC  FD8.2
16048:  INCF   x8B,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
1604A:  MOVF   x8C,W
1604C:  SUBLW  4D
1604E:  BTFSS  FD8.2
16050:  BRA    1617A
16052:  MOVF   x8D,F
16054:  BNZ   1605C
16056:  MOVF   x8E,F
16058:  BTFSC  FD8.2
1605A:  BRA    1617A
....................          { 
....................          RTC_reset_HT(); 
1605C:  MOVLB  0
1605E:  CALL   34DA
....................          RTC_read(); 
16062:  CALL   336C
....................          RTC_display(); 
16066:  CALL   E2BA
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
1606A:  MOVLW  0C
1606C:  MOVWF  FF6
1606E:  MOVLW  22
16070:  MOVWF  FF7
16072:  MOVLW  00
16074:  MOVWF  FF8
16076:  CLRF   1B
16078:  BTFSC  FF2.7
1607A:  BSF    1B.7
1607C:  BCF    FF2.7
1607E:  MOVLW  09
16080:  MOVLB  A
16082:  MOVWF  x40
16084:  MOVLB  0
16086:  CALL   1044
1608A:  BTFSC  1B.7
1608C:  BSF    FF2.7
1608E:  MOVLB  8
16090:  MOVF   x8C,W
16092:  BTFSS  F9E.4
16094:  BRA    16092
16096:  MOVWF  FAD
16098:  MOVLW  10
1609A:  MOVWF  FE9
1609C:  CLRF   1B
1609E:  BTFSC  FF2.7
160A0:  BSF    1B.7
160A2:  BCF    FF2.7
160A4:  MOVFF  88E,A41
160A8:  MOVFF  88D,A40
160AC:  MOVLB  0
160AE:  CALL   11C6
160B2:  BTFSC  1B.7
160B4:  BSF    FF2.7
160B6:  MOVLW  1A
160B8:  MOVWF  FF6
160BA:  MOVLW  22
160BC:  MOVWF  FF7
160BE:  MOVLW  00
160C0:  MOVWF  FF8
160C2:  CLRF   1B
160C4:  BTFSC  FF2.7
160C6:  BSF    1B.7
160C8:  BCF    FF2.7
160CA:  MOVLW  03
160CC:  MOVLB  A
160CE:  MOVWF  x40
160D0:  MOVLB  0
160D2:  CALL   1044
160D6:  BTFSC  1B.7
160D8:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
160DA:  MOVLW  01
160DC:  ADDWF  21,W
160DE:  MOVLB  8
160E0:  MOVWF  x90
160E2:  MOVLW  00
160E4:  ADDWFC 22,W
160E6:  MOVWF  x91
160E8:  MOVLW  1E
160EA:  MOVWF  FF6
160EC:  MOVLW  22
160EE:  MOVWF  FF7
160F0:  MOVLW  00
160F2:  MOVWF  FF8
160F4:  CLRF   1B
160F6:  BTFSC  FF2.7
160F8:  BSF    1B.7
160FA:  BCF    FF2.7
160FC:  MOVLW  07
160FE:  MOVLB  A
16100:  MOVWF  x40
16102:  MOVLB  0
16104:  CALL   1044
16108:  BTFSC  1B.7
1610A:  BSF    FF2.7
1610C:  MOVLW  09
1610E:  MOVWF  FE9
16110:  CLRF   1B
16112:  BTFSC  FF2.7
16114:  BSF    1B.7
16116:  BCF    FF2.7
16118:  MOVFF  891,A41
1611C:  MOVFF  890,A40
16120:  CALL   11C6
16124:  BTFSC  1B.7
16126:  BSF    FF2.7
16128:  MOVLW  2A
1612A:  MOVWF  FF6
1612C:  MOVLW  22
1612E:  MOVWF  FF7
16130:  MOVLW  00
16132:  MOVWF  FF8
16134:  CLRF   1B
16136:  BTFSC  FF2.7
16138:  BSF    1B.7
1613A:  BCF    FF2.7
1613C:  MOVLW  04
1613E:  MOVLB  A
16140:  MOVWF  x40
16142:  MOVLB  0
16144:  CALL   1044
16148:  BTFSC  1B.7
1614A:  BSF    FF2.7
1614C:  MOVLW  09
1614E:  MOVWF  FE9
16150:  CLRF   1B
16152:  BTFSC  FF2.7
16154:  BSF    1B.7
16156:  BCF    FF2.7
16158:  MOVFF  28,A41
1615C:  MOVFF  27,A40
16160:  CALL   11C6
16164:  BTFSC  1B.7
16166:  BSF    FF2.7
16168:  MOVLW  0D
1616A:  BTFSS  F9E.4
1616C:  BRA    1616A
1616E:  MOVWF  FAD
16170:  MOVLW  0A
16172:  BTFSS  F9E.4
16174:  BRA    16172
16176:  MOVWF  FAD
16178:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
1617A:  MOVF   28,W
1617C:  SUBWF  22,W
1617E:  BNC   1618C
16180:  BNZ   16188
16182:  MOVF   27,W
16184:  SUBWF  21,W
16186:  BNC   1618C
....................          {macro_cmd = 'Z';} 
16188:  MOVLW  5A
1618A:  MOVWF  x8C
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
1618C:  MOVF   x8C,W
1618E:  XORLW  72
16190:  MOVLB  0
16192:  BZ    161A6
16194:  XORLW  57
16196:  BZ    161C8
16198:  XORLW  68
1619A:  BZ    161FE
1619C:  XORLW  17
1619E:  BZ    16234
161A0:  XORLW  61
161A2:  BZ    16240
161A4:  BRA    1624A
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
161A6:  INCF   37,F
161A8:  BTFSC  FD8.2
161AA:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
161AC:  MOVLB  8
161AE:  CLRF   x60
161B0:  CLRF   x5F
161B2:  MOVFF  38,85E
161B6:  MOVFF  37,85D
....................                master_macro_loop_count = macro_arg; 
161BA:  CLRF   x5C
161BC:  CLRF   x5B
161BE:  MOVFF  88E,85A
161C2:  MOVFF  88D,859
....................             break; 
161C6:  BRA    16256
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
161C8:  MOVLB  8
161CA:  MOVF   x5C,F
161CC:  BNZ   161DC
161CE:  MOVF   x5B,F
161D0:  BNZ   161DC
161D2:  MOVF   x5A,F
161D4:  BNZ   161DC
161D6:  MOVF   x59,W
161D8:  SUBLW  01
161DA:  BC    161F6
....................                   nv_macro_step = master_macro_loop_start; 
161DC:  MOVFF  85E,38
161E0:  MOVFF  85D,37
....................                   master_macro_loop_count--; 
161E4:  MOVLW  FF
161E6:  ADDWF  x59,F
161E8:  BTFSS  FD8.0
161EA:  ADDWF  x5A,F
161EC:  BTFSS  FD8.0
161EE:  ADDWF  x5B,F
161F0:  BTFSS  FD8.0
161F2:  ADDWF  x5C,F
....................                }else{ 
161F4:  BRA    161FC
....................                   nv_macro_step++; 
161F6:  INCF   37,F
161F8:  BTFSC  FD8.2
161FA:  INCF   38,F
....................                } 
....................             break; 
161FC:  BRA    16256
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
161FE:  MOVLB  8
16200:  MOVF   x8E,F
16202:  BNZ   16232
16204:  MOVF   x8D,W
16206:  SUBLW  14
16208:  BNC   16232
....................                   play_macro(macro_arg,0);     // casts to int8 
1620A:  MOVFF  88D,897
1620E:  CLRF   x99
16210:  CLRF   x98
16212:  MOVLB  0
16214:  CALL   153EE
....................                   delay_ms(100); 
16218:  MOVLW  64
1621A:  MOVLB  9
1621C:  MOVWF  xEC
1621E:  MOVLB  0
16220:  CALL   2938
....................                   ++nv_sample; 
16224:  INCF   21,F
16226:  BTFSC  FD8.2
16228:  INCF   22,F
....................                   ++nv_macro_step; 
1622A:  INCF   37,F
1622C:  BTFSC  FD8.2
1622E:  INCF   38,F
16230:  MOVLB  8
....................                } 
....................                break; 
16232:  BRA    16256
....................             case 'Z' : ++nv_macro_step; 
16234:  INCF   37,F
16236:  BTFSC  FD8.2
16238:  INCF   38,F
....................                        macro_batch = FALSE; 
1623A:  MOVLB  8
1623C:  CLRF   x8F
....................                break; 
1623E:  BRA    16256
....................             case ';' : nv_macro_step = 0; 
16240:  CLRF   38
16242:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
16244:  MOVLB  8
16246:  BRA    16256
16248:  MOVLB  0
....................             default  : cmd_err(); 
1624A:  CALL   BFF0
....................                        macro_cmd = 'e'; 
1624E:  MOVLW  65
16250:  MOVLB  8
16252:  MOVWF  x8C
....................                        macro_batch = FALSE; 
16254:  CLRF   x8F
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
16256:  DECFSZ 50,W
16258:  BRA    16260
....................             macro_cmd = ';'; 
1625A:  MOVLW  3B
1625C:  MOVWF  x8C
....................             break;         // 17 = CTRL-Q (quit) 
1625E:  BRA    16262
....................          } 
16260:  BRA    15FDA
....................    } 
....................    return (macro_cmd); 
16262:  MOVFF  88C,01
16266:  MOVLB  0
16268:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D3DA:  MOVLB  8
0D3DC:  MOVF   x8C,W
0D3DE:  XORLW  2B
0D3E0:  MOVLB  0
0D3E2:  BZ    D412
0D3E4:  XORLW  06
0D3E6:  BZ    D43A
0D3E8:  XORLW  6F
0D3EA:  BZ    D462
0D3EC:  XORLW  05
0D3EE:  BZ    D474
0D3F0:  XORLW  17
0D3F2:  BZ    D48A
0D3F4:  XORLW  01
0D3F6:  BZ    D4BA
0D3F8:  XORLW  03
0D3FA:  BTFSC  FD8.2
0D3FC:  BRA    D4E2
0D3FE:  XORLW  06
0D400:  BTFSC  FD8.2
0D402:  BRA    D50A
0D404:  XORLW  0D
0D406:  BTFSC  FD8.2
0D408:  BRA    D51E
0D40A:  XORLW  62
0D40C:  BTFSC  FD8.2
0D40E:  BRA    D546
0D410:  BRA    D54E
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D412:  MOVLW  01
0D414:  MOVLB  7
0D416:  MOVWF  x40
....................                  move_motor(0,0,macro_arg,1); 
0D418:  MOVLB  8
0D41A:  CLRF   xC7
0D41C:  CLRF   xC8
0D41E:  CLRF   xCC
0D420:  CLRF   xCB
0D422:  MOVFF  88E,8CA
0D426:  MOVFF  88D,8C9
0D42A:  MOVWF  xCD
0D42C:  MOVLB  0
0D42E:  CALL   9DA0
....................                  macro_status=step_err_status(); 
0D432:  RCALL  D332
0D434:  MOVFF  01,88F
....................          break; 
0D438:  BRA    D54E
....................       case '-' : motor=1; 
0D43A:  MOVLW  01
0D43C:  MOVLB  7
0D43E:  MOVWF  x40
....................                  move_motor(0,1,macro_arg,1); 
0D440:  MOVLB  8
0D442:  CLRF   xC7
0D444:  MOVWF  xC8
0D446:  CLRF   xCC
0D448:  CLRF   xCB
0D44A:  MOVFF  88E,8CA
0D44E:  MOVFF  88D,8C9
0D452:  MOVWF  xCD
0D454:  MOVLB  0
0D456:  CALL   9DA0
....................                  macro_status=step_err_status(); 
0D45A:  RCALL  D332
0D45C:  MOVFF  01,88F
....................          break; 
0D460:  BRA    D54E
....................       case 'B' : h_bridge(macro_arg); 
0D462:  MOVFF  88D,8B5
0D466:  CALL   C280
....................                  macro_status = 'a'; 
0D46A:  MOVLW  61
0D46C:  MOVLB  8
0D46E:  MOVWF  x8F
....................          break; 
0D470:  MOVLB  0
0D472:  BRA    D54E
....................       case 'G' : motor=0; 
0D474:  MOVLB  7
0D476:  CLRF   x40
....................                  align(0); 
0D478:  MOVLB  8
0D47A:  CLRF   xC2
0D47C:  MOVLB  0
0D47E:  CALL   A8DC
....................                  macro_status=step_err_status(); 
0D482:  RCALL  D332
0D484:  MOVFF  01,88F
....................          break ;           
0D488:  BRA    D54E
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D48A:  MOVFF  88E,2E
0D48E:  MOVFF  88D,2D
....................                  motor=0; 
0D492:  MOVLB  7
0D494:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1);   
0D496:  MOVLB  8
0D498:  CLRF   xC7
0D49A:  CLRF   xC8
0D49C:  CLRF   xCC
0D49E:  CLRF   xCB
0D4A0:  MOVFF  88E,8CA
0D4A4:  MOVFF  88D,8C9
0D4A8:  MOVLW  01
0D4AA:  MOVWF  xCD
0D4AC:  MOVLB  0
0D4AE:  CALL   9DA0
....................                  macro_status=step_err_status(); 
0D4B2:  RCALL  D332
0D4B4:  MOVFF  01,88F
....................          break; 
0D4B8:  BRA    D54E
....................       case 'Q' : motor=0; 
0D4BA:  MOVLB  7
0D4BC:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1); 
0D4BE:  MOVLB  8
0D4C0:  CLRF   xC7
0D4C2:  CLRF   xC8
0D4C4:  CLRF   xCC
0D4C6:  CLRF   xCB
0D4C8:  MOVFF  88E,8CA
0D4CC:  MOVFF  88D,8C9
0D4D0:  MOVLW  01
0D4D2:  MOVWF  xCD
0D4D4:  MOVLB  0
0D4D6:  CALL   9DA0
....................                  macro_status=step_err_status(); 
0D4DA:  RCALL  D332
0D4DC:  MOVFF  01,88F
....................          break; 
0D4E0:  BRA    D54E
....................       case 'R' : motor=0; 
0D4E2:  MOVLB  7
0D4E4:  CLRF   x40
....................                  move_motor(0,1,macro_arg,1); 
0D4E6:  MOVLB  8
0D4E8:  CLRF   xC7
0D4EA:  MOVLW  01
0D4EC:  MOVWF  xC8
0D4EE:  CLRF   xCC
0D4F0:  CLRF   xCB
0D4F2:  MOVFF  88E,8CA
0D4F6:  MOVFF  88D,8C9
0D4FA:  MOVWF  xCD
0D4FC:  MOVLB  0
0D4FE:  CALL   9DA0
....................                  macro_status=step_err_status(); 
0D502:  RCALL  D332
0D504:  MOVFF  01,88F
....................          break; 
0D508:  BRA    D54E
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D50A:  MOVFF  88E,8C3
0D50E:  MOVFF  88D,8C2
0D512:  RCALL  D36A
....................                  macro_status = 'a'; 
0D514:  MOVLW  61
0D516:  MOVLB  8
0D518:  MOVWF  x8F
....................          break; 
0D51A:  MOVLB  0
0D51C:  BRA    D54E
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D51E:  MOVLB  8
0D520:  DECFSZ x8D,W
0D522:  BRA    D530
0D524:  MOVF   x8E,F
0D526:  BNZ   D530
0D528:  MOVLB  0
0D52A:  RCALL  D3A0
0D52C:  BRA    D53C
0D52E:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D530:  MOVF   x8D,F
0D532:  BNZ   D53E
0D534:  MOVF   x8E,F
0D536:  BNZ   D53E
0D538:  MOVLB  0
0D53A:  RCALL  D3C4
0D53C:  MOVLB  8
....................                  macro_status = 'a'; 
0D53E:  MOVLW  61
0D540:  MOVWF  x8F
....................          break;           
0D542:  MOVLB  0
0D544:  BRA    D54E
....................       case ';' : macro_status = 'f'; 
0D546:  MOVLW  66
0D548:  MOVLB  8
0D54A:  MOVWF  x8F
....................          break;            
0D54C:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D54E:  MOVLB  8
0D550:  MOVFF  88F,01
0D554:  MOVLB  0
0D556:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D830:  MOVF   2E,F
0D832:  BNZ   D83A
0D834:  MOVF   2D,W
0D836:  SUBLW  01
0D838:  BC    D84C
0D83A:  MOVF   2E,F
0D83C:  BNZ   D84C
0D83E:  MOVF   2D,W
0D840:  SUBLW  30
0D842:  BNC   D84C
0D844:  DECFSZ 2F,W
0D846:  BRA    D84C
0D848:  MOVF   30,F
0D84A:  BZ    D86A
0D84C:  MOVF   2E,F
0D84E:  BNZ   D856
0D850:  MOVF   2D,W
0D852:  SUBLW  01
0D854:  BC    D874
0D856:  MOVF   2E,F
0D858:  BNZ   D874
0D85A:  MOVF   2D,W
0D85C:  SUBLW  32
0D85E:  BNC   D874
0D860:  MOVF   2F,W
0D862:  SUBLW  03
0D864:  BNZ   D874
0D866:  MOVF   30,F
0D868:  BNZ   D874
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D86A:  MOVLW  61
0D86C:  MOVLB  8
0D86E:  MOVWF  x8B
....................    } 
0D870:  BRA    D87C
0D872:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D874:  MOVLW  65
0D876:  MOVLB  8
0D878:  MOVWF  x8B
....................       goto end_macro;       
0D87A:  BRA    D92C
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D87C:  MOVLW  59
0D87E:  MOVWF  x8C
0D880:  CLRF   x8E
0D882:  MOVLW  01
0D884:  MOVWF  x8D
0D886:  MOVLB  0
0D888:  RCALL  D3DA
0D88A:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D88E:  MOVLB  8
0D890:  MOVF   x8B,W
0D892:  SUBLW  61
0D894:  BTFSS  FD8.2
0D896:  BRA    D92C
....................    macro_status = play_wms_macro_cmd('G',1); 
0D898:  MOVLW  47
0D89A:  MOVWF  x8C
0D89C:  CLRF   x8E
0D89E:  MOVLW  01
0D8A0:  MOVWF  x8D
0D8A2:  MOVLB  0
0D8A4:  RCALL  D3DA
0D8A6:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D8AA:  MOVLB  8
0D8AC:  MOVF   x8B,W
0D8AE:  SUBLW  61
0D8B0:  BTFSS  FD8.2
0D8B2:  BRA    D92C
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D8B4:  MOVLW  2D
0D8B6:  MOVWF  x8C
0D8B8:  MOVFF  2C,88E
0D8BC:  MOVFF  2B,88D
0D8C0:  MOVLB  0
0D8C2:  RCALL  D3DA
0D8C4:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D8C8:  MOVLB  8
0D8CA:  MOVF   x8B,W
0D8CC:  SUBLW  61
0D8CE:  BTFSS  FD8.2
0D8D0:  BRA    D92C
....................    macro_status = play_wms_macro_cmd('P',port); 
0D8D2:  MOVLW  50
0D8D4:  MOVWF  x8C
0D8D6:  MOVFF  88A,88E
0D8DA:  MOVFF  889,88D
0D8DE:  MOVLB  0
0D8E0:  RCALL  D3DA
0D8E2:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro;    
0D8E6:  MOVLB  8
0D8E8:  MOVF   x8B,W
0D8EA:  SUBLW  61
0D8EC:  BTFSS  FD8.2
0D8EE:  BRA    D92C
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D8F0:  MOVLW  2B
0D8F2:  MOVWF  x8C
0D8F4:  MOVFF  2C,88E
0D8F8:  MOVFF  2B,88D
0D8FC:  MOVLB  0
0D8FE:  RCALL  D3DA
0D900:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D904:  MOVLB  8
0D906:  MOVF   x8B,W
0D908:  SUBLW  61
0D90A:  BTFSS  FD8.2
0D90C:  BRA    D92C
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D90E:  MOVLW  59
0D910:  MOVWF  x8C
0D912:  CLRF   x8E
0D914:  CLRF   x8D
0D916:  MOVLB  0
0D918:  RCALL  D3DA
0D91A:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D91E:  MOVLB  8
0D920:  MOVF   x8B,W
0D922:  SUBLW  61
0D924:  BTFSS  FD8.2
0D926:  BRA    D92C
....................    macro_status='f';  
0D928:  MOVLW  66
0D92A:  MOVWF  x8B
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D92C:  CLRF   x9D
0D92E:  MOVLB  0
0D930:  RCALL  D66E
....................    
....................    switch(macro_status){ 
0D932:  MOVLW  61
0D934:  MOVLB  8
0D936:  SUBWF  x8B,W
0D938:  ADDLW  FA
0D93A:  BC    DA0E
0D93C:  ADDLW  06
0D93E:  MOVLB  0
0D940:  GOTO   DA12
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D944:  MOVF   1F,F
0D946:  BNZ   D94C
0D948:  MOVF   20,F
0D94A:  BZ    D968
0D94C:  MOVLW  36
0D94E:  MOVWF  FF6
0D950:  MOVLW  22
0D952:  MOVWF  FF7
0D954:  MOVLW  00
0D956:  MOVWF  FF8
0D958:  CLRF   1B
0D95A:  BTFSC  FF2.7
0D95C:  BSF    1B.7
0D95E:  BCF    FF2.7
0D960:  CALL   0E6E
0D964:  BTFSC  1B.7
0D966:  BSF    FF2.7
....................          break; 
0D968:  MOVLB  8
0D96A:  BRA    DA0E
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D96C:  MOVLW  3E
0D96E:  MOVWF  FF6
0D970:  MOVLW  22
0D972:  MOVWF  FF7
0D974:  MOVLW  00
0D976:  MOVWF  FF8
0D978:  CLRF   1B
0D97A:  BTFSC  FF2.7
0D97C:  BSF    1B.7
0D97E:  BCF    FF2.7
0D980:  CALL   0E6E
0D984:  BTFSC  1B.7
0D986:  BSF    FF2.7
....................          break; 
0D988:  MOVLB  8
0D98A:  BRA    DA0E
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D98C:  MOVLW  46
0D98E:  MOVWF  FF6
0D990:  MOVLW  22
0D992:  MOVWF  FF7
0D994:  MOVLW  00
0D996:  MOVWF  FF8
0D998:  CLRF   1B
0D99A:  BTFSC  FF2.7
0D99C:  BSF    1B.7
0D99E:  BCF    FF2.7
0D9A0:  CALL   0E6E
0D9A4:  BTFSC  1B.7
0D9A6:  BSF    FF2.7
....................          break; 
0D9A8:  MOVLB  8
0D9AA:  BRA    DA0E
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D9AC:  MOVLW  4E
0D9AE:  MOVWF  FF6
0D9B0:  MOVLW  22
0D9B2:  MOVWF  FF7
0D9B4:  MOVLW  00
0D9B6:  MOVWF  FF8
0D9B8:  CLRF   1B
0D9BA:  BTFSC  FF2.7
0D9BC:  BSF    1B.7
0D9BE:  BCF    FF2.7
0D9C0:  CALL   0E6E
0D9C4:  BTFSC  1B.7
0D9C6:  BSF    FF2.7
....................          break; 
0D9C8:  MOVLB  8
0D9CA:  BRA    DA0E
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D9CC:  MOVLW  56
0D9CE:  MOVWF  FF6
0D9D0:  MOVLW  22
0D9D2:  MOVWF  FF7
0D9D4:  MOVLW  00
0D9D6:  MOVWF  FF8
0D9D8:  CLRF   1B
0D9DA:  BTFSC  FF2.7
0D9DC:  BSF    1B.7
0D9DE:  BCF    FF2.7
0D9E0:  CALL   0E6E
0D9E4:  BTFSC  1B.7
0D9E6:  BSF    FF2.7
....................          break;    
0D9E8:  MOVLB  8
0D9EA:  BRA    DA0E
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D9EC:  MOVLW  5E
0D9EE:  MOVWF  FF6
0D9F0:  MOVLW  22
0D9F2:  MOVWF  FF7
0D9F4:  MOVLW  00
0D9F6:  MOVWF  FF8
0D9F8:  CLRF   1B
0D9FA:  BTFSC  FF2.7
0D9FC:  BSF    1B.7
0D9FE:  BCF    FF2.7
0DA00:  CALL   0E6E
0DA04:  BTFSC  1B.7
0DA06:  BSF    FF2.7
....................          break;           
0DA08:  MOVLB  8
0DA0A:  BRA    DA0E
0DA0C:  MOVLB  8
....................    } 
0DA0E:  MOVLB  0
0DA10:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
164AA:  MOVLB  8
164AC:  MOVF   x88,W
164AE:  BTFSC  FD8.2
164B0:  DECF   x89,F
164B2:  DECF   x88,F
....................    addr = macro_address[0] + (step*9); 
164B4:  MOVFF  889,A11
164B8:  MOVFF  888,A10
164BC:  MOVLB  A
164BE:  CLRF   x13
164C0:  MOVLW  09
164C2:  MOVWF  x12
164C4:  MOVLB  0
164C6:  CALL   5CC0
164CA:  MOVF   01,W
164CC:  MOVLB  7
164CE:  ADDWF  xD1,W
164D0:  MOVLB  8
164D2:  MOVWF  x8A
164D4:  MOVF   02,W
164D6:  MOVLB  7
164D8:  ADDWFC xD2,W
164DA:  MOVLB  8
164DC:  MOVWF  x8B
....................     
....................    init_ext_eeprom(); 
164DE:  MOVLB  0
164E0:  CALL   FFD6
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
164E4:  MOVFF  88B,8CC
164E8:  MOVFF  88A,8CB
164EC:  CALL   10648
164F0:  MOVFF  01,88C
....................    ++addr; 
164F4:  MOVLB  8
164F6:  INCF   x8A,F
164F8:  BTFSC  FD8.2
164FA:  INCF   x8B,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
164FC:  MOVFF  88B,8C3
16500:  MOVFF  88A,8C2
16504:  MOVLB  0
16506:  CALL   1075C
1650A:  MOVFF  02,890
1650E:  MOVFF  01,88F
....................    ++addr; 
16512:  MOVLB  8
16514:  INCF   x8A,F
16516:  BTFSC  FD8.2
16518:  INCF   x8B,F
....................    ++addr; 
1651A:  INCF   x8A,F
1651C:  BTFSC  FD8.2
1651E:  INCF   x8B,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
16520:  MOVFF  88B,8CC
16524:  MOVFF  88A,8CB
16528:  MOVLB  0
1652A:  CALL   10648
1652E:  MOVFF  01,88D
....................    ++addr; 
16532:  MOVLB  8
16534:  INCF   x8A,F
16536:  BTFSC  FD8.2
16538:  INCF   x8B,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
1653A:  MOVFF  88B,8C3
1653E:  MOVFF  88A,8C2
16542:  MOVLB  0
16544:  CALL   1075C
16548:  MOVFF  02,892
1654C:  MOVFF  01,891
....................    ++addr; 
16550:  MOVLB  8
16552:  INCF   x8A,F
16554:  BTFSC  FD8.2
16556:  INCF   x8B,F
....................    ++addr; 
16558:  INCF   x8A,F
1655A:  BTFSC  FD8.2
1655C:  INCF   x8B,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
1655E:  MOVFF  88B,8CC
16562:  MOVFF  88A,8CB
16566:  MOVLB  0
16568:  CALL   10648
1656C:  MOVFF  01,88E
....................    ++addr; 
16570:  MOVLB  8
16572:  INCF   x8A,F
16574:  BTFSC  FD8.2
16576:  INCF   x8B,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
16578:  MOVFF  88B,8C3
1657C:  MOVFF  88A,8C2
16580:  MOVLB  0
16582:  CALL   1075C
16586:  MOVFF  02,894
1658A:  MOVFF  01,893
....................    ++addr; 
1658E:  MOVLB  8
16590:  INCF   x8A,F
16592:  BTFSC  FD8.2
16594:  INCF   x8B,F
....................    ++addr; 
16596:  INCF   x8A,F
16598:  BTFSC  FD8.2
1659A:  INCF   x8B,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
1659C:  MOVFF  88B,8CC
165A0:  MOVFF  88A,8CB
165A4:  MOVLB  0
165A6:  CALL   10648
165AA:  MOVFF  01,895
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
165AE:  MOVLB  8
165B0:  MOVF   x8C,W
165B2:  SUBLW  4A
165B4:  BTFSS  FD8.2
165B6:  BRA    1668C
165B8:  MOVF   x8D,W
165BA:  SUBLW  50
165BC:  BNZ   1668C
165BE:  MOVF   x8E,W
165C0:  SUBLW  4D
165C2:  BNZ   1668C
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
165C4:  MOVF   x8C,W
165C6:  BTFSS  F9E.4
165C8:  BRA    165C6
165CA:  MOVWF  FAD
165CC:  MOVLW  10
165CE:  MOVWF  FE9
165D0:  CLRF   1B
165D2:  BTFSC  FF2.7
165D4:  BSF    1B.7
165D6:  BCF    FF2.7
165D8:  MOVFF  890,A41
165DC:  MOVFF  88F,A40
165E0:  MOVLB  0
165E2:  CALL   11C6
165E6:  BTFSC  1B.7
165E8:  BSF    FF2.7
165EA:  MOVLW  2C
165EC:  BTFSS  F9E.4
165EE:  BRA    165EC
165F0:  MOVWF  FAD
165F2:  MOVLB  8
165F4:  MOVF   x8D,W
165F6:  BTFSS  F9E.4
165F8:  BRA    165F6
165FA:  MOVWF  FAD
165FC:  MOVLW  10
165FE:  MOVWF  FE9
16600:  CLRF   1B
16602:  BTFSC  FF2.7
16604:  BSF    1B.7
16606:  BCF    FF2.7
16608:  MOVFF  892,A41
1660C:  MOVFF  891,A40
16610:  MOVLB  0
16612:  CALL   11C6
16616:  BTFSC  1B.7
16618:  BSF    FF2.7
1661A:  MOVLW  2C
1661C:  BTFSS  F9E.4
1661E:  BRA    1661C
16620:  MOVWF  FAD
16622:  MOVLB  8
16624:  MOVF   x8E,W
16626:  BTFSS  F9E.4
16628:  BRA    16626
1662A:  MOVWF  FAD
1662C:  MOVLW  10
1662E:  MOVWF  FE9
16630:  CLRF   1B
16632:  BTFSC  FF2.7
16634:  BSF    1B.7
16636:  BCF    FF2.7
16638:  MOVFF  894,A41
1663C:  MOVFF  893,A40
16640:  MOVLB  0
16642:  CALL   11C6
16646:  BTFSC  1B.7
16648:  BSF    FF2.7
1664A:  MOVLW  0D
1664C:  BTFSS  F9E.4
1664E:  BRA    1664C
16650:  MOVWF  FAD
16652:  MOVLW  0A
16654:  BTFSS  F9E.4
16656:  BRA    16654
16658:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
1665A:  MOVFF  890,24
1665E:  MOVFF  88F,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
16662:  MOVLB  8
16664:  MOVF   x93,F
16666:  BNZ   1666C
16668:  MOVF   x94,F
1666A:  BZ    1668A
1666C:  MOVF   x94,F
1666E:  BNZ   1668A
16670:  MOVF   x93,W
16672:  SUBLW  10
16674:  BNC   1668A
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
16676:  MOVFF  893,897
1667A:  MOVFF  892,899
1667E:  MOVFF  891,898
16682:  MOVLB  0
16684:  CALL   153EE
16688:  MOVLB  8
....................       } 
....................    } 
1668A:  BRA    16698
....................    else { 
....................       cmd_err(); 
1668C:  MOVLB  0
1668E:  CALL   BFF0
....................       macro_end = 59; 
16692:  MOVLW  3B
16694:  MOVLB  8
16696:  MOVWF  x95
....................    } 
....................     
....................    return (macro_end); 
16698:  MOVFF  895,01
1669C:  MOVLB  0
1669E:  GOTO   16788 (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
1688A:  MOVLB  8
1688C:  MOVF   x8C,W
1688E:  BTFSC  FD8.2
16890:  DECF   x8D,F
16892:  DECF   x8C,F
....................    addr = macro_address[0] + (step*6); 
16894:  MOVFF  88D,A11
16898:  MOVFF  88C,A10
1689C:  MOVLB  A
1689E:  CLRF   x13
168A0:  MOVLW  06
168A2:  MOVWF  x12
168A4:  MOVLB  0
168A6:  CALL   5CC0
168AA:  MOVF   01,W
168AC:  MOVLB  7
168AE:  ADDWF  xD1,W
168B0:  MOVLB  8
168B2:  MOVWF  x8E
168B4:  MOVF   02,W
168B6:  MOVLB  7
168B8:  ADDWFC xD2,W
168BA:  MOVLB  8
168BC:  MOVWF  x8F
....................     
....................    init_ext_eeprom(); 
168BE:  MOVLB  0
168C0:  CALL   FFD6
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
168C4:  MOVFF  88F,8CC
168C8:  MOVFF  88E,8CB
168CC:  CALL   10648
168D0:  MOVFF  01,890
....................    ++addr; 
168D4:  MOVLB  8
168D6:  INCF   x8E,F
168D8:  BTFSC  FD8.2
168DA:  INCF   x8F,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
168DC:  MOVFF  88F,8C3
168E0:  MOVFF  88E,8C2
168E4:  MOVLB  0
168E6:  CALL   1075C
168EA:  MOVFF  02,893
168EE:  MOVFF  01,892
....................    ++addr; 
168F2:  MOVLB  8
168F4:  INCF   x8E,F
168F6:  BTFSC  FD8.2
168F8:  INCF   x8F,F
....................    ++addr; 
168FA:  INCF   x8E,F
168FC:  BTFSC  FD8.2
168FE:  INCF   x8F,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
16900:  MOVFF  88F,8CC
16904:  MOVFF  88E,8CB
16908:  MOVLB  0
1690A:  CALL   10648
1690E:  MOVFF  01,891
....................    ++addr; 
16912:  MOVLB  8
16914:  INCF   x8E,F
16916:  BTFSC  FD8.2
16918:  INCF   x8F,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
1691A:  MOVFF  88F,8C3
1691E:  MOVFF  88E,8C2
16922:  MOVLB  0
16924:  CALL   1075C
16928:  MOVFF  02,895
1692C:  MOVFF  01,894
....................    ++addr; 
16930:  MOVLB  8
16932:  INCF   x8E,F
16934:  BTFSC  FD8.2
16936:  INCF   x8F,F
....................    ++addr; 
16938:  INCF   x8E,F
1693A:  BTFSC  FD8.2
1693C:  INCF   x8F,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
1693E:  MOVFF  88F,8CC
16942:  MOVFF  88E,8CB
16946:  MOVLB  0
16948:  CALL   10648
1694C:  MOVFF  01,896
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
16950:  MOVLB  8
16952:  MOVF   x90,W
16954:  SUBLW  50
16956:  BNZ   169FA
16958:  MOVF   x91,W
1695A:  SUBLW  4D
1695C:  BNZ   169FA
....................        
....................       RTC_read(); 
1695E:  MOVLB  0
16960:  CALL   336C
....................       RTC_display(); 
16964:  CALL   E2BA
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
16968:  MOVLB  8
1696A:  MOVF   x90,W
1696C:  BTFSS  F9E.4
1696E:  BRA    1696C
16970:  MOVWF  FAD
16972:  MOVLW  10
16974:  MOVWF  FE9
16976:  CLRF   1B
16978:  BTFSC  FF2.7
1697A:  BSF    1B.7
1697C:  BCF    FF2.7
1697E:  MOVFF  893,A41
16982:  MOVFF  892,A40
16986:  MOVLB  0
16988:  CALL   11C6
1698C:  BTFSC  1B.7
1698E:  BSF    FF2.7
16990:  MOVLW  2C
16992:  BTFSS  F9E.4
16994:  BRA    16992
16996:  MOVWF  FAD
16998:  MOVLB  8
1699A:  MOVF   x91,W
1699C:  BTFSS  F9E.4
1699E:  BRA    1699C
169A0:  MOVWF  FAD
169A2:  MOVLW  10
169A4:  MOVWF  FE9
169A6:  CLRF   1B
169A8:  BTFSC  FF2.7
169AA:  BSF    1B.7
169AC:  BCF    FF2.7
169AE:  MOVFF  895,A41
169B2:  MOVFF  894,A40
169B6:  MOVLB  0
169B8:  CALL   11C6
169BC:  BTFSC  1B.7
169BE:  BSF    FF2.7
169C0:  MOVLW  0D
169C2:  BTFSS  F9E.4
169C4:  BRA    169C2
169C6:  MOVWF  FAD
169C8:  MOVLW  0A
169CA:  BTFSS  F9E.4
169CC:  BRA    169CA
169CE:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
169D0:  MOVLB  8
169D2:  MOVF   x94,F
169D4:  BNZ   169DA
169D6:  MOVF   x95,F
169D8:  BZ    169F8
169DA:  MOVF   x95,F
169DC:  BNZ   169F8
169DE:  MOVF   x94,W
169E0:  SUBLW  10
169E2:  BNC   169F8
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
169E4:  MOVFF  894,897
169E8:  MOVFF  893,899
169EC:  MOVFF  892,898
169F0:  MOVLB  0
169F2:  CALL   153EE
169F6:  MOVLB  8
....................       } 
....................    } 
169F8:  BRA    16A06
....................    else { 
....................       cmd_err(); 
169FA:  MOVLB  0
169FC:  CALL   BFF0
....................       macro_end = 59; 
16A00:  MOVLW  3B
16A02:  MOVLB  8
16A04:  MOVWF  x96
....................    } 
....................     
....................    return (macro_end); 
16A06:  MOVFF  896,01
16A0A:  MOVLB  0
16A0C:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
16288:  MOVF   24,W
1628A:  SUBWF  36,W
1628C:  BTFSS  FD8.0
1628E:  BRA    16496
16290:  BNZ   1629A
16292:  MOVF   23,W
16294:  SUBWF  35,W
16296:  BTFSS  FD8.0
16298:  BRA    16496
1629A:  MOVF   33,F
1629C:  BTFSS  FD8.2
1629E:  BRA    16496
162A0:  MOVF   34,F
162A2:  BTFSS  FD8.2
162A4:  BRA    16496
....................       { 
....................          nv_elapsed = 0; 
162A6:  CLRF   36
162A8:  CLRF   35
....................  
....................          init_hardware(); 
162AA:  CALL   2962
....................          sd_status = init_sdcard(); 
162AE:  CALL   5062
162B2:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
162B6:  MOVLB  2
162B8:  MOVF   xDC,F
162BA:  BZ    162C4
162BC:  MOVLB  0
162BE:  CALL   50A8
162C2:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
162C4:  MOVLW  01
162C6:  MOVWF  1E
162C8:  MOVLW  A7
162CA:  MOVWF  1D
162CC:  MOVLW  66
162CE:  MOVWF  FF6
162D0:  MOVLW  22
162D2:  MOVWF  FF7
162D4:  MOVLW  00
162D6:  MOVWF  FF8
162D8:  MOVLW  14
162DA:  MOVLB  8
162DC:  MOVWF  xEB
162DE:  MOVLB  0
162E0:  CALL   AAF4
162E4:  MOVLW  10
162E6:  MOVWF  FE9
162E8:  MOVFF  22,8F7
162EC:  MOVFF  21,8F6
162F0:  CALL   AB26
162F4:  MOVLW  7D
162F6:  MOVWF  FF6
162F8:  MOVLW  22
162FA:  MOVWF  FF7
162FC:  MOVLW  00
162FE:  MOVWF  FF8
16300:  MOVLW  09
16302:  MOVLB  8
16304:  MOVWF  xEB
16306:  MOVLB  0
16308:  CALL   AAF4
....................          record_event();          
1630C:  CALL   8502
....................              
....................          macro_cmd = master_macro_eco(); 
16310:  RCALL  15FD4
16312:  MOVFF  01,887
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
16316:  MOVLW  16
16318:  MOVLB  8
1631A:  MOVWF  xEE
1631C:  MOVFF  22,8F0
16320:  MOVFF  21,8EF
16324:  MOVLB  0
16326:  CALL   4FFC
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
1632A:  MOVLW  3A
1632C:  MOVLB  8
1632E:  MOVWF  xEE
16330:  MOVFF  38,8F0
16334:  MOVFF  37,8EF
16338:  MOVLB  0
1633A:  CALL   4FFC
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
1633E:  DECFSZ 50,W
16340:  BRA    16364
....................          { 
....................             disable_interrupts (INT_EXT); 
16342:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
16344:  CLRF   32
16346:  MOVLW  01
16348:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
1634A:  MOVLW  02
1634C:  MOVLB  8
1634E:  MOVWF  x89
16350:  MOVFF  31,88A
16354:  MOVLB  0
16356:  CALL   343A
....................             busy_clear(); 
1635A:  CALL   AEE0
....................             return (user_quit); 
1635E:  MOVFF  50,01
16362:  BRA    164A6
....................          } 
....................  
....................          motor_sleep_rdy(); 
16364:  CALL   29C0
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16368:  MOVLW  01
1636A:  MOVWF  1E
1636C:  MOVLW  A7
1636E:  MOVWF  1D
16370:  MOVLW  88
16372:  MOVWF  FF6
16374:  MOVLW  22
16376:  MOVWF  FF7
16378:  MOVLW  00
1637A:  MOVWF  FF8
1637C:  MOVLW  14
1637E:  MOVLB  8
16380:  MOVWF  xEB
16382:  MOVLB  0
16384:  CALL   AAF4
16388:  MOVLW  10
1638A:  MOVWF  FE9
1638C:  MOVFF  22,8F7
16390:  MOVFF  21,8F6
16394:  CALL   AB26
16398:  MOVLW  9F
1639A:  MOVWF  FF6
1639C:  MOVLW  22
1639E:  MOVWF  FF7
163A0:  MOVLW  00
163A2:  MOVWF  FF8
163A4:  MOVLW  0C
163A6:  MOVLB  8
163A8:  MOVWF  xEB
163AA:  MOVLB  0
163AC:  CALL   AAF4
....................          record_event();  
163B0:  CALL   8502
....................           
....................          if (macro_cmd == 'e') 
163B4:  MOVLB  8
163B6:  MOVF   x87,W
163B8:  SUBLW  65
163BA:  BNZ   1640E
....................          { 
....................             disable_interrupts (INT_EXT); 
163BC:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
163BE:  MOVLW  01
163C0:  MOVWF  1E
163C2:  MOVLW  A7
163C4:  MOVWF  1D
163C6:  MOVLW  AC
163C8:  MOVWF  FF6
163CA:  MOVLW  22
163CC:  MOVWF  FF7
163CE:  MOVLW  00
163D0:  MOVWF  FF8
163D2:  MOVLW  14
163D4:  MOVWF  xEB
163D6:  MOVLB  0
163D8:  CALL   AAF4
163DC:  MOVLW  10
163DE:  MOVWF  FE9
163E0:  MOVFF  22,8F7
163E4:  MOVFF  21,8F6
163E8:  CALL   AB26
163EC:  MOVLW  C3
163EE:  MOVWF  FF6
163F0:  MOVLW  22
163F2:  MOVWF  FF7
163F4:  MOVLW  00
163F6:  MOVWF  FF8
163F8:  MOVLW  09
163FA:  MOVLB  8
163FC:  MOVWF  xEB
163FE:  MOVLB  0
16400:  CALL   AAF4
....................             record_event();  
16404:  CALL   8502
....................             cmd_err(); 
16408:  CALL   BFF0
1640C:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
1640E:  MOVF   28,W
16410:  SUBWF  22,W
16412:  BNC   16498
16414:  BNZ   1641C
16416:  MOVF   27,W
16418:  SUBWF  21,W
1641A:  BNC   16498
....................          { 
....................             disable_interrupts (INT_EXT); 
1641C:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
1641E:  MOVLW  01
16420:  MOVWF  1E
16422:  MOVLW  A7
16424:  MOVWF  1D
16426:  MOVLW  CE
16428:  MOVWF  FF6
1642A:  MOVLW  22
1642C:  MOVWF  FF7
1642E:  MOVLW  00
16430:  MOVWF  FF8
16432:  MOVLW  14
16434:  MOVWF  xEB
16436:  MOVLB  0
16438:  CALL   AAF4
1643C:  MOVLW  10
1643E:  MOVWF  FE9
16440:  MOVFF  22,8F7
16444:  MOVFF  21,8F6
16448:  CALL   AB26
1644C:  MOVLW  E5
1644E:  MOVWF  FF6
16450:  MOVLW  22
16452:  MOVWF  FF7
16454:  MOVLW  00
16456:  MOVWF  FF8
16458:  MOVLW  0F
1645A:  MOVLB  8
1645C:  MOVWF  xEB
1645E:  MOVLB  0
16460:  CALL   AAF4
....................             record_event();   
16464:  CALL   8502
....................             msg_max(); 
16468:  RCALL  1626A
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
1646A:  CLRF   34
1646C:  MOVLW  01
1646E:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
16470:  MOVLW  28
16472:  MOVLB  8
16474:  MOVWF  x89
16476:  MOVFF  33,88A
1647A:  MOVLB  0
1647C:  CALL   343A
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
16480:  CLRF   32
16482:  MOVLW  01
16484:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16486:  MOVLW  02
16488:  MOVLB  8
1648A:  MOVWF  x89
1648C:  MOVFF  31,88A
16490:  MOVLB  0
16492:  CALL   343A
16496:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
16498:  MOVLB  0
1649A:  RCALL  15F0E
1649C:  BRA    16288
....................    } 
....................     
....................    busy_clear(); 
1649E:  CALL   AEE0
....................    return (user_quit); 
164A2:  MOVFF  50,01
164A6:  GOTO   16DCA (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
166A2:  MOVF   24,W
166A4:  SUBWF  36,W
166A6:  BTFSS  FD8.0
166A8:  BRA    16878
166AA:  BNZ   166B4
166AC:  MOVF   23,W
166AE:  SUBWF  35,W
166B0:  BTFSS  FD8.0
166B2:  BRA    16878
....................       { 
....................          nv_elapsed = 0; 
166B4:  CLRF   36
166B6:  CLRF   35
....................  
....................          init_hardware(); 
166B8:  CALL   2962
....................          sd_status = init_sdcard(); 
166BC:  CALL   5062
166C0:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
166C4:  MOVLB  2
166C6:  MOVF   xDC,F
166C8:  BZ    166D2
166CA:  MOVLB  0
166CC:  CALL   50A8
166D0:  MOVLB  2
....................  
....................          ++nv_sample; 
166D2:  INCF   21,F
166D4:  BTFSC  FD8.2
166D6:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
166D8:  MOVLW  40
166DA:  BTFSS  F9E.4
166DC:  BRA    166DA
166DE:  MOVWF  FAD
166E0:  MOVLW  53
166E2:  BTFSS  F9E.4
166E4:  BRA    166E2
166E6:  MOVWF  FAD
166E8:  MOVLW  09
166EA:  MOVWF  FE9
166EC:  CLRF   1B
166EE:  BTFSC  FF2.7
166F0:  BSF    1B.7
166F2:  BCF    FF2.7
166F4:  MOVFF  22,A41
166F8:  MOVFF  21,A40
166FC:  MOVLB  0
166FE:  CALL   11C6
16702:  BTFSC  1B.7
16704:  BSF    FF2.7
16706:  MOVLW  0D
16708:  BTFSS  F9E.4
1670A:  BRA    16708
1670C:  MOVWF  FAD
1670E:  MOVLW  0A
16710:  BTFSS  F9E.4
16712:  BRA    16710
16714:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16716:  MOVLW  01
16718:  MOVWF  1E
1671A:  MOVLW  A7
1671C:  MOVWF  1D
1671E:  MOVLW  F6
16720:  MOVWF  FF6
16722:  MOVLW  22
16724:  MOVWF  FF7
16726:  MOVLW  00
16728:  MOVWF  FF8
1672A:  MOVLW  14
1672C:  MOVLB  8
1672E:  MOVWF  xEB
16730:  MOVLB  0
16732:  CALL   AAF4
16736:  MOVLW  10
16738:  MOVWF  FE9
1673A:  MOVFF  22,8F7
1673E:  MOVFF  21,8F6
16742:  CALL   AB26
16746:  MOVLW  0D
16748:  MOVWF  FF6
1674A:  MOVLW  23
1674C:  MOVWF  FF7
1674E:  MOVLW  00
16750:  MOVWF  FF8
16752:  MOVLW  09
16754:  MOVLB  8
16756:  MOVWF  xEB
16758:  MOVLB  0
1675A:  CALL   AAF4
....................          record_event();   
1675E:  CALL   8502
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16762:  MOVLW  16
16764:  MOVLB  8
16766:  MOVWF  xEE
16768:  MOVFF  22,8F0
1676C:  MOVFF  21,8EF
16770:  MOVLB  0
16772:  CALL   4FFC
....................  
....................          if (nv_macro_mode==TRUE) 
16776:  DECFSZ 29,W
16778:  BRA    1678E
1677A:  MOVF   2A,F
1677C:  BNZ   1678E
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
1677E:  MOVFF  22,889
16782:  MOVFF  21,888
16786:  BRA    164AA
16788:  MOVFF  01,887
....................          } 
1678C:  BRA    167F6
....................          else 
....................          { 
....................             time_stamp(); 
1678E:  CALL   5442
....................             play_wms_hard_macro(nv_port); 
16792:  MOVFF  2E,88A
16796:  MOVFF  2D,889
1679A:  CALL   D830
....................             ++nv_port; 
1679E:  INCF   2D,F
167A0:  BTFSC  FD8.2
167A2:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
167A4:  MOVF   2E,F
167A6:  BNZ   167AE
167A8:  MOVF   2D,W
167AA:  SUBLW  01
167AC:  BC    167C0
167AE:  MOVF   2E,F
167B0:  BNZ   167C0
167B2:  MOVF   2D,W
167B4:  SUBLW  30
167B6:  BNC   167C0
167B8:  DECFSZ 2F,W
167BA:  BRA    167C0
167BC:  MOVF   30,F
167BE:  BZ    167DE
167C0:  MOVF   2E,F
167C2:  BNZ   167CA
167C4:  MOVF   2D,W
167C6:  SUBLW  01
167C8:  BC    167F4
167CA:  MOVF   2E,F
167CC:  BNZ   167F4
167CE:  MOVF   2D,W
167D0:  SUBLW  32
167D2:  BNC   167F4
167D4:  MOVF   2F,W
167D6:  SUBLW  03
167D8:  BNZ   167F4
167DA:  MOVF   30,F
167DC:  BNZ   167F4
....................             { 
....................                write16(ADDR_PORT, nv_port);             
167DE:  MOVLW  24
167E0:  MOVLB  8
167E2:  MOVWF  xEE
167E4:  MOVFF  2E,8F0
167E8:  MOVFF  2D,8EF
167EC:  MOVLB  0
167EE:  CALL   4FFC
....................             } 
167F2:  BRA    167F6
....................             else disable_interrupts (INT_EXT); 
167F4:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
167F6:  DECFSZ 50,W
167F8:  BRA    1681C
....................          { 
....................             disable_interrupts (INT_EXT); 
167FA:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
167FC:  CLRF   32
167FE:  MOVLW  01
16800:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16802:  MOVLW  02
16804:  MOVLB  8
16806:  MOVWF  x89
16808:  MOVFF  31,88A
1680C:  MOVLB  0
1680E:  CALL   343A
....................             busy_clear(); 
16812:  CALL   AEE0
....................             return (user_quit); 
16816:  MOVFF  50,01
1681A:  BRA    16886
....................          } 
....................           
....................          motor_sleep_rdy(); 
1681C:  CALL   29C0
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16820:  MOVLW  01
16822:  MOVWF  1E
16824:  MOVLW  A7
16826:  MOVWF  1D
16828:  MOVLW  18
1682A:  MOVWF  FF6
1682C:  MOVLW  23
1682E:  MOVWF  FF7
16830:  MOVLW  00
16832:  MOVWF  FF8
16834:  MOVLW  14
16836:  MOVLB  8
16838:  MOVWF  xEB
1683A:  MOVLB  0
1683C:  CALL   AAF4
16840:  MOVLW  10
16842:  MOVWF  FE9
16844:  MOVFF  22,8F7
16848:  MOVFF  21,8F6
1684C:  CALL   AB26
16850:  MOVLW  2F
16852:  MOVWF  FF6
16854:  MOVLW  23
16856:  MOVWF  FF7
16858:  MOVLW  00
1685A:  MOVWF  FF8
1685C:  MOVLW  0C
1685E:  MOVLB  8
16860:  MOVWF  xEB
16862:  MOVLB  0
16864:  CALL   AAF4
....................          record_event();  
16868:  CALL   8502
....................           
....................          if (macro_end == ';') 
1686C:  MOVLB  8
1686E:  MOVF   x87,W
16870:  SUBLW  3B
16872:  BNZ   16876
....................          { 
....................             disable_interrupts (INT_EXT); 
16874:  BCF    FF2.4
16876:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
16878:  CALL   15F0E
1687C:  BRA    166A2
....................    } 
....................    busy_clear(); 
1687E:  CALL   AEE0
....................    return (user_quit); 
16882:  MOVFF  50,01
16886:  GOTO   16DD2 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
16A0E:  MOVF   24,W
16A10:  SUBWF  36,W
16A12:  BTFSS  FD8.0
16A14:  BRA    16BCE
16A16:  BNZ   16A20
16A18:  MOVF   23,W
16A1A:  SUBWF  35,W
16A1C:  BTFSS  FD8.0
16A1E:  BRA    16BCE
....................       { 
....................          nv_elapsed = 0; 
16A20:  CLRF   36
16A22:  CLRF   35
....................  
....................          init_hardware(); 
16A24:  CALL   2962
....................          sd_status = init_sdcard(); 
16A28:  CALL   5062
16A2C:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
16A30:  MOVLB  2
16A32:  MOVF   xDC,F
16A34:  BZ    16A3E
16A36:  MOVLB  0
16A38:  CALL   50A8
16A3C:  MOVLB  2
....................  
....................          ++nv_sample; 
16A3E:  INCF   21,F
16A40:  BTFSC  FD8.2
16A42:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
16A44:  MOVLW  40
16A46:  BTFSS  F9E.4
16A48:  BRA    16A46
16A4A:  MOVWF  FAD
16A4C:  MOVLW  53
16A4E:  BTFSS  F9E.4
16A50:  BRA    16A4E
16A52:  MOVWF  FAD
16A54:  MOVLW  09
16A56:  MOVWF  FE9
16A58:  CLRF   1B
16A5A:  BTFSC  FF2.7
16A5C:  BSF    1B.7
16A5E:  BCF    FF2.7
16A60:  MOVFF  22,A41
16A64:  MOVFF  21,A40
16A68:  MOVLB  0
16A6A:  CALL   11C6
16A6E:  BTFSC  1B.7
16A70:  BSF    FF2.7
16A72:  MOVLW  0D
16A74:  BTFSS  F9E.4
16A76:  BRA    16A74
16A78:  MOVWF  FAD
16A7A:  MOVLW  0A
16A7C:  BTFSS  F9E.4
16A7E:  BRA    16A7C
16A80:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16A82:  MOVLW  01
16A84:  MOVWF  1E
16A86:  MOVLW  A7
16A88:  MOVWF  1D
16A8A:  MOVLW  3C
16A8C:  MOVWF  FF6
16A8E:  MOVLW  23
16A90:  MOVWF  FF7
16A92:  MOVLW  00
16A94:  MOVWF  FF8
16A96:  MOVLW  14
16A98:  MOVLB  8
16A9A:  MOVWF  xEB
16A9C:  MOVLB  0
16A9E:  CALL   AAF4
16AA2:  MOVLW  10
16AA4:  MOVWF  FE9
16AA6:  MOVFF  22,8F7
16AAA:  MOVFF  21,8F6
16AAE:  CALL   AB26
16AB2:  MOVLW  53
16AB4:  MOVWF  FF6
16AB6:  MOVLW  23
16AB8:  MOVWF  FF7
16ABA:  MOVLW  00
16ABC:  MOVWF  FF8
16ABE:  MOVLW  09
16AC0:  MOVLB  8
16AC2:  MOVWF  xEB
16AC4:  MOVLB  0
16AC6:  CALL   AAF4
....................          record_event();   
16ACA:  CALL   8502
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16ACE:  MOVLW  16
16AD0:  MOVLB  8
16AD2:  MOVWF  xEE
16AD4:  MOVFF  22,8F0
16AD8:  MOVFF  21,8EF
16ADC:  MOVLB  0
16ADE:  CALL   4FFC
....................  
....................          macro_end = master_macro_aws(nv_sample); 
16AE2:  MOVFF  22,88D
16AE6:  MOVFF  21,88C
16AEA:  RCALL  1688A
16AEC:  MOVFF  01,887
....................           
....................          if (user_quit == TRUE) 
16AF0:  DECFSZ 50,W
16AF2:  BRA    16B16
....................          { 
....................             disable_interrupts (INT_EXT); 
16AF4:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
16AF6:  CLRF   32
16AF8:  MOVLW  01
16AFA:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16AFC:  MOVLW  02
16AFE:  MOVLB  8
16B00:  MOVWF  x89
16B02:  MOVFF  31,88A
16B06:  MOVLB  0
16B08:  CALL   343A
....................             busy_clear(); 
16B0C:  CALL   AEE0
....................             return (user_quit); 
16B10:  MOVFF  50,01
16B14:  BRA    16BE0
....................          } 
....................           
....................          motor_sleep_rdy(); 
16B16:  CALL   29C0
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16B1A:  MOVLW  01
16B1C:  MOVWF  1E
16B1E:  MOVLW  A7
16B20:  MOVWF  1D
16B22:  MOVLW  5E
16B24:  MOVWF  FF6
16B26:  MOVLW  23
16B28:  MOVWF  FF7
16B2A:  MOVLW  00
16B2C:  MOVWF  FF8
16B2E:  MOVLW  14
16B30:  MOVLB  8
16B32:  MOVWF  xEB
16B34:  MOVLB  0
16B36:  CALL   AAF4
16B3A:  MOVLW  10
16B3C:  MOVWF  FE9
16B3E:  MOVFF  22,8F7
16B42:  MOVFF  21,8F6
16B46:  CALL   AB26
16B4A:  MOVLW  75
16B4C:  MOVWF  FF6
16B4E:  MOVLW  23
16B50:  MOVWF  FF7
16B52:  MOVLW  00
16B54:  MOVWF  FF8
16B56:  MOVLW  0C
16B58:  MOVLB  8
16B5A:  MOVWF  xEB
16B5C:  MOVLB  0
16B5E:  CALL   AAF4
....................          record_event();  
16B62:  CALL   8502
....................           
....................          if (macro_end == ';') 
16B66:  MOVLB  8
16B68:  MOVF   x87,W
16B6A:  SUBLW  3B
16B6C:  BNZ   16B70
....................          { 
....................             disable_interrupts (INT_EXT); 
16B6E:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16B70:  MOVF   28,W
16B72:  SUBWF  22,W
16B74:  BNC   16BD0
16B76:  BNZ   16B7E
16B78:  MOVF   27,W
16B7A:  SUBWF  21,W
16B7C:  BNC   16BD0
....................          { 
....................             disable_interrupts (INT_EXT); 
16B7E:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16B80:  MOVLW  01
16B82:  MOVWF  1E
16B84:  MOVLW  A7
16B86:  MOVWF  1D
16B88:  MOVLW  82
16B8A:  MOVWF  FF6
16B8C:  MOVLW  23
16B8E:  MOVWF  FF7
16B90:  MOVLW  00
16B92:  MOVWF  FF8
16B94:  MOVLW  14
16B96:  MOVWF  xEB
16B98:  MOVLB  0
16B9A:  CALL   AAF4
16B9E:  MOVLW  10
16BA0:  MOVWF  FE9
16BA2:  MOVFF  22,8F7
16BA6:  MOVFF  21,8F6
16BAA:  CALL   AB26
16BAE:  MOVLW  99
16BB0:  MOVWF  FF6
16BB2:  MOVLW  23
16BB4:  MOVWF  FF7
16BB6:  MOVLW  00
16BB8:  MOVWF  FF8
16BBA:  MOVLW  0F
16BBC:  MOVLB  8
16BBE:  MOVWF  xEB
16BC0:  MOVLB  0
16BC2:  CALL   AAF4
....................             record_event();   
16BC6:  CALL   8502
....................             msg_max(); 
16BCA:  CALL   1626A
16BCE:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
16BD0:  MOVLB  0
16BD2:  CALL   15F0E
16BD6:  BRA    16A0E
....................    } 
....................    busy_clear(); 
16BD8:  CALL   AEE0
....................    return (user_quit); 
16BDC:  MOVFF  50,01
16BE0:  GOTO   16DDA (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
16BE4:  CALL   29E8
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
16BE8:  MOVLW  01
16BEA:  MOVWF  1E
16BEC:  MOVLW  A7
16BEE:  MOVWF  1D
16BF0:  MOVLW  AA
16BF2:  MOVWF  FF6
16BF4:  MOVLW  23
16BF6:  MOVWF  FF7
16BF8:  MOVLW  00
16BFA:  MOVWF  FF8
16BFC:  CALL   50E6
....................    record_event(); 
16C00:  CALL   8502
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
16C04:  MOVLW  01
16C06:  MOVWF  1E
16C08:  MOVLW  A7
16C0A:  MOVWF  1D
16C0C:  MOVLW  C4
16C0E:  MOVWF  FF6
16C10:  MOVLW  23
16C12:  MOVWF  FF7
16C14:  MOVLW  00
16C16:  MOVWF  FF8
16C18:  MOVLW  0C
16C1A:  MOVLB  8
16C1C:  MOVWF  xEB
16C1E:  MOVLB  0
16C20:  CALL   AAF4
16C24:  MOVLW  10
16C26:  MOVWF  FE9
16C28:  MOVFF  26,8F7
16C2C:  MOVFF  25,8F6
16C30:  CALL   AB26
16C34:  MOVLW  D3
16C36:  MOVWF  FF6
16C38:  MOVLW  23
16C3A:  MOVWF  FF7
16C3C:  MOVLW  00
16C3E:  MOVWF  FF8
16C40:  MOVLW  06
16C42:  MOVLB  8
16C44:  MOVWF  xEB
16C46:  MOVLB  0
16C48:  CALL   AAF4
16C4C:  MOVLW  10
16C4E:  MOVWF  FE9
16C50:  MOVFF  24,8F7
16C54:  MOVFF  23,8F6
16C58:  CALL   AB26
16C5C:  MOVLW  DC
16C5E:  MOVWF  FF6
16C60:  MOVLW  23
16C62:  MOVWF  FF7
16C64:  MOVLW  00
16C66:  MOVWF  FF8
16C68:  MOVLW  06
16C6A:  MOVLB  8
16C6C:  MOVWF  xEB
16C6E:  MOVLB  0
16C70:  CALL   AAF4
16C74:  MOVLW  10
16C76:  MOVWF  FE9
16C78:  MOVFF  28,8F7
16C7C:  MOVFF  27,8F6
16C80:  CALL   AB26
16C84:  MOVLW  E5
16C86:  MOVWF  FF6
16C88:  MOVLW  23
16C8A:  MOVWF  FF7
16C8C:  MOVLW  00
16C8E:  MOVWF  FF8
16C90:  MOVLW  03
16C92:  MOVLB  8
16C94:  MOVWF  xEB
16C96:  MOVLB  0
16C98:  CALL   AAF4
....................    record_event(); 
16C9C:  CALL   8502
....................     
....................    user_quit = FALSE; 
16CA0:  CLRF   50
....................     
....................    nv_cmd_mode = FALSE; 
16CA2:  CLRF   32
16CA4:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
16CA6:  MOVLW  02
16CA8:  MOVLB  8
16CAA:  MOVWF  x89
16CAC:  MOVFF  31,88A
16CB0:  MOVLB  0
16CB2:  CALL   343A
....................  
....................    RTC_set_AFE(); 
16CB6:  GOTO   15754
....................    // check if start is earlier than now 
....................    RTC_late(); 
16CBA:  CALL   157AC
....................    // show clock 
....................    RTC_display(); 
16CBE:  CALL   E2BA
....................    // show alarm 
....................    RTC_display_alarm(); 
16CC2:  CALL   E51A
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
16CC6:  CALL   15C72
....................  
....................    if (alarm_passed == FALSE){ 
16CCA:  BTFSC  4D.3
16CCC:  BRA    16CCE
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
16CCE:  MOVLW  00
16CD0:  BTFSC  4D.3
16CD2:  MOVLW  01
16CD4:  MOVLB  8
16CD6:  MOVWF  x87
16CD8:  MOVLW  01
16CDA:  MOVWF  1E
16CDC:  MOVLW  A7
16CDE:  MOVWF  1D
16CE0:  MOVLW  EA
16CE2:  MOVWF  FF6
16CE4:  MOVLW  23
16CE6:  MOVWF  FF7
16CE8:  MOVLW  00
16CEA:  MOVWF  FF8
16CEC:  MOVLW  14
16CEE:  MOVWF  xEB
16CF0:  MOVLB  0
16CF2:  CALL   AAF4
16CF6:  MOVLW  10
16CF8:  MOVWF  FE9
16CFA:  MOVFF  22,8F7
16CFE:  MOVFF  21,8F6
16D02:  CALL   AB26
16D06:  MOVLW  01
16D08:  MOVWF  FF6
16D0A:  MOVLW  24
16D0C:  MOVWF  FF7
16D0E:  MOVLW  00
16D10:  MOVWF  FF8
16D12:  MOVLW  08
16D14:  MOVLB  8
16D16:  MOVWF  xEB
16D18:  MOVLB  0
16D1A:  CALL   AAF4
16D1E:  MOVFF  887,8ED
16D22:  MOVLW  1B
16D24:  MOVLB  8
16D26:  MOVWF  xEE
16D28:  MOVLB  0
16D2A:  CALL   52A8
16D2E:  MOVLW  0B
16D30:  MOVWF  FF6
16D32:  MOVLW  24
16D34:  MOVWF  FF7
16D36:  MOVLW  00
16D38:  MOVWF  FF8
16D3A:  MOVLW  03
16D3C:  MOVLB  8
16D3E:  MOVWF  xEB
16D40:  MOVLB  0
16D42:  CALL   AAF4
....................    record_event();  
16D46:  CALL   8502
....................  
....................    while (TRUE == RTC_read_flags_running) 
16D4A:  BTFSS  4D.2
16D4C:  BRA    16D50
....................    { 
....................       ; 
16D4E:  BRA    16D4A
....................    } 
....................    RTC_read_flags_running = TRUE; 
16D50:  BSF    4D.2
16D52:  CLRF   1B
16D54:  BTFSC  FF2.7
16D56:  BSF    1B.7
16D58:  BCF    FF2.7
....................    RTC_read_flags(); 
16D5A:  CALL   0DF8
16D5E:  BTFSC  1B.7
16D60:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
16D62:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
16D64:  CALL   29C0
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
16D68:  BTFSC  4D.3
16D6A:  BRA    16D8C
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
16D6C:  MOVLW  01
16D6E:  MOVWF  1E
16D70:  MOVLW  A7
16D72:  MOVWF  1D
16D74:  MOVLW  10
16D76:  MOVWF  FF6
16D78:  MOVLW  24
16D7A:  MOVWF  FF7
16D7C:  MOVLW  00
16D7E:  MOVWF  FF8
16D80:  CALL   50E6
....................       record_event(); 
16D84:  CALL   8502
....................       go_to_sleep(); 
16D88:  CALL   15F0E
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
16D8C:  GOTO   15F24
....................    nv_elapsed = nv_interval; 
16D90:  MOVFF  24,36
16D94:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
16D98:  MOVFF  2F,00
16D9C:  MOVF   30,W
16D9E:  MOVWF  03
16DA0:  BNZ   16DA6
16DA2:  MOVF   00,F
16DA4:  BZ    16DC6
16DA6:  MOVF   03,W
16DA8:  BNZ   16DB0
16DAA:  MOVLW  01
16DAC:  SUBWF  00,W
16DAE:  BZ    16DD0
16DB0:  MOVF   03,W
16DB2:  BNZ   16DBA
16DB4:  MOVLW  03
16DB6:  SUBWF  00,W
16DB8:  BZ    16DD0
16DBA:  MOVF   03,W
16DBC:  BNZ   16DC4
16DBE:  MOVLW  02
16DC0:  SUBWF  00,W
16DC2:  BZ    16DD8
16DC4:  BRA    16DDE
....................       case ECO: user_quit = auto_sample_eco(); 
16DC6:  GOTO   16288
16DCA:  MOVFF  01,50
....................          break; 
16DCE:  BRA    16DDE
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
16DD0:  BRA    166A2
16DD2:  MOVFF  01,50
....................          break; 
16DD6:  BRA    16DDE
....................       case AWS: user_quit = auto_sample_aws(); 
16DD8:  BRA    16A0E
16DDA:  MOVFF  01,50
....................          break;          
....................    } 
....................    return(user_quit); 
16DDE:  MOVFF  50,01
16DE2:  GOTO   16EF8 (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BFC0:  MOVF   48,F
0BFC2:  BNZ   BFD0
0BFC4:  MOVF   49,F
0BFC6:  BNZ   BFD0
0BFC8:  MOVF   4A,F
0BFCA:  BNZ   BFD0
0BFCC:  MOVF   4B,F
0BFCE:  BZ    BFE8
0BFD0:  MOVF   4B,F
0BFD2:  BNZ   BFE8
0BFD4:  MOVF   4A,F
0BFD6:  BNZ   BFE8
0BFD8:  MOVF   49,F
0BFDA:  BNZ   BFE8
0BFDC:  MOVF   48,W
0BFDE:  SUBLW  02
0BFE0:  BNC   BFE8
....................       detector = arg; 
0BFE2:  MOVFF  48,2D5
....................    } 
0BFE6:  BRA    BFEC
....................    else cmd_arg(); 
0BFE8:  CALL   B32E
0BFEC:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0C00E:  MOVF   48,F
0C010:  BNZ   C01E
0C012:  MOVF   49,F
0C014:  BNZ   C01E
0C016:  MOVF   4A,F
0C018:  BNZ   C01E
0C01A:  MOVF   4B,F
0C01C:  BZ    C078
0C01E:  MOVF   4B,F
0C020:  BNZ   C078
0C022:  MOVF   4A,W
0C024:  SUBLW  00
0C026:  BNC   C078
....................       switch (detector){ 
0C028:  MOVLB  2
0C02A:  MOVF   xD5,W
0C02C:  XORLW  01
0C02E:  MOVLB  0
0C030:  BZ    C038
0C032:  XORLW  03
0C034:  BZ    C056
0C036:  BRA    C074
....................          case 1 : nv_d1_temp = arg; 
0C038:  MOVFF  49,42
0C03C:  MOVFF  48,41
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0C040:  MOVLW  40
0C042:  MOVLB  8
0C044:  MOVWF  xEE
0C046:  MOVFF  42,8F0
0C04A:  MOVFF  41,8EF
0C04E:  MOVLB  0
0C050:  CALL   4FFC
....................             break; 
0C054:  BRA    C076
....................          case 2 : nv_d2_temp = arg; 
0C056:  MOVFF  49,44
0C05A:  MOVFF  48,43
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0C05E:  MOVLW  42
0C060:  MOVLB  8
0C062:  MOVWF  xEE
0C064:  MOVFF  44,8F0
0C068:  MOVFF  43,8EF
0C06C:  MOVLB  0
0C06E:  CALL   4FFC
....................             break; 
0C072:  BRA    C076
....................          default : cmd_err(); 
0C074:  RCALL  BFF0
....................             break; 
....................       } 
....................    } 
0C076:  BRA    C11E
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0C078:  MOVF   48,F
0C07A:  BNZ   C11A
0C07C:  MOVF   49,F
0C07E:  BNZ   C11A
0C080:  MOVF   4A,F
0C082:  BNZ   C11A
0C084:  MOVF   4B,F
0C086:  BNZ   C11A
0C088:  MOVLW  26
0C08A:  MOVWF  FF6
0C08C:  MOVLW  24
0C08E:  MOVWF  FF7
0C090:  MOVLW  00
0C092:  MOVWF  FF8
0C094:  CLRF   1B
0C096:  BTFSC  FF2.7
0C098:  BSF    1B.7
0C09A:  BCF    FF2.7
0C09C:  MOVLW  03
0C09E:  MOVLB  A
0C0A0:  MOVWF  x40
0C0A2:  MOVLB  0
0C0A4:  CALL   1044
0C0A8:  BTFSC  1B.7
0C0AA:  BSF    FF2.7
0C0AC:  MOVLW  10
0C0AE:  MOVWF  FE9
0C0B0:  CLRF   1B
0C0B2:  BTFSC  FF2.7
0C0B4:  BSF    1B.7
0C0B6:  BCF    FF2.7
0C0B8:  MOVFF  42,A41
0C0BC:  MOVFF  41,A40
0C0C0:  CALL   11C6
0C0C4:  BTFSC  1B.7
0C0C6:  BSF    FF2.7
0C0C8:  MOVLW  2C
0C0CA:  MOVWF  FF6
0C0CC:  MOVLW  24
0C0CE:  MOVWF  FF7
0C0D0:  MOVLW  00
0C0D2:  MOVWF  FF8
0C0D4:  CLRF   1B
0C0D6:  BTFSC  FF2.7
0C0D8:  BSF    1B.7
0C0DA:  BCF    FF2.7
0C0DC:  MOVLW  04
0C0DE:  MOVLB  A
0C0E0:  MOVWF  x40
0C0E2:  MOVLB  0
0C0E4:  CALL   1044
0C0E8:  BTFSC  1B.7
0C0EA:  BSF    FF2.7
0C0EC:  MOVLW  10
0C0EE:  MOVWF  FE9
0C0F0:  CLRF   1B
0C0F2:  BTFSC  FF2.7
0C0F4:  BSF    1B.7
0C0F6:  BCF    FF2.7
0C0F8:  MOVFF  44,A41
0C0FC:  MOVFF  43,A40
0C100:  CALL   11C6
0C104:  BTFSC  1B.7
0C106:  BSF    FF2.7
0C108:  MOVLW  0D
0C10A:  BTFSS  F9E.4
0C10C:  BRA    C10A
0C10E:  MOVWF  FAD
0C110:  MOVLW  0A
0C112:  BTFSS  F9E.4
0C114:  BRA    C112
0C116:  MOVWF  FAD
0C118:  BRA    C11E
....................    else cmd_arg(); 
0C11A:  CALL   B32E
0C11E:  GOTO   C184 (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0C122:  MOVF   4B,F
0C124:  BNZ   C152
0C126:  MOVF   4A,F
0C128:  BNZ   C152
0C12A:  MOVF   49,F
0C12C:  BNZ   C152
0C12E:  MOVF   48,W
0C130:  SUBLW  01
0C132:  BNC   C152
....................       nv_macro_mode = arg; 
0C134:  MOVFF  49,2A
0C138:  MOVFF  48,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0C13C:  MOVLW  20
0C13E:  MOVLB  8
0C140:  MOVWF  xEE
0C142:  MOVFF  2A,8F0
0C146:  MOVFF  29,8EF
0C14A:  MOVLB  0
0C14C:  CALL   4FFC
....................    } 
0C150:  BRA    C156
....................    else cmd_arg(); 
0C152:  CALL   B32E
0C156:  GOTO   C184 (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0C15A:  MOVF   2F,W
0C15C:  MOVWF  00
0C15E:  MOVF   30,W
0C160:  MOVWF  03
0C162:  BNZ   C168
0C164:  MOVF   00,F
0C166:  BZ    C17E
0C168:  MOVF   03,W
0C16A:  BNZ   C172
0C16C:  MOVLW  01
0C16E:  SUBWF  00,W
0C170:  BZ    C182
0C172:  MOVF   03,W
0C174:  BNZ   C17C
0C176:  MOVLW  03
0C178:  SUBWF  00,W
0C17A:  BZ    C182
0C17C:  BRA    C184
....................       case ECO : commandAe(); 
0C17E:  BRA    C00E
....................          break; 
0C180:  BRA    C184
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0C182:  BRA    C122
....................          break; 
....................    } 
0C184:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0C188:  MOVF   48,F
0C18A:  BNZ   C198
0C18C:  MOVF   49,F
0C18E:  BNZ   C198
0C190:  MOVF   4A,F
0C192:  BNZ   C198
0C194:  MOVF   4B,F
0C196:  BZ    C1C8
0C198:  MOVF   4B,F
0C19A:  BNZ   C1C8
0C19C:  MOVF   4A,F
0C19E:  BNZ   C1C8
0C1A0:  MOVF   49,F
0C1A2:  BNZ   C1C8
0C1A4:  MOVF   48,W
0C1A6:  SUBLW  03
0C1A8:  BNC   C1C8
....................       nv_det_type = arg; 
0C1AA:  MOVFF  49,46
0C1AE:  MOVFF  48,45
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0C1B2:  MOVLW  26
0C1B4:  MOVLB  8
0C1B6:  MOVWF  xEE
0C1B8:  MOVFF  46,8F0
0C1BC:  MOVFF  45,8EF
0C1C0:  MOVLB  0
0C1C2:  CALL   4FFC
....................    } 
0C1C6:  BRA    C22E
....................    else if(arg==0) { 
0C1C8:  MOVF   48,F
0C1CA:  BNZ   C22A
0C1CC:  MOVF   49,F
0C1CE:  BNZ   C22A
0C1D0:  MOVF   4A,F
0C1D2:  BNZ   C22A
0C1D4:  MOVF   4B,F
0C1D6:  BNZ   C22A
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0C1D8:  MOVLW  36
0C1DA:  MOVWF  FF6
0C1DC:  MOVLW  24
0C1DE:  MOVWF  FF7
0C1E0:  MOVLW  00
0C1E2:  MOVWF  FF8
0C1E4:  CLRF   1B
0C1E6:  BTFSC  FF2.7
0C1E8:  BSF    1B.7
0C1EA:  BCF    FF2.7
0C1EC:  MOVLW  05
0C1EE:  MOVLB  A
0C1F0:  MOVWF  x40
0C1F2:  MOVLB  0
0C1F4:  CALL   1044
0C1F8:  BTFSC  1B.7
0C1FA:  BSF    FF2.7
0C1FC:  MOVLW  10
0C1FE:  MOVWF  FE9
0C200:  CLRF   1B
0C202:  BTFSC  FF2.7
0C204:  BSF    1B.7
0C206:  BCF    FF2.7
0C208:  MOVFF  46,A41
0C20C:  MOVFF  45,A40
0C210:  CALL   11C6
0C214:  BTFSC  1B.7
0C216:  BSF    FF2.7
0C218:  MOVLW  0D
0C21A:  BTFSS  F9E.4
0C21C:  BRA    C21A
0C21E:  MOVWF  FAD
0C220:  MOVLW  0A
0C222:  BTFSS  F9E.4
0C224:  BRA    C222
0C226:  MOVWF  FAD
....................    } 
0C228:  BRA    C22E
....................    else cmd_arg(); 
0C22A:  CALL   B32E
0C22E:  GOTO   C2F0 (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0C2A0:  MOVF   4B,F
0C2A2:  BNZ   C2BE
0C2A4:  MOVF   4A,F
0C2A6:  BNZ   C2BE
0C2A8:  MOVF   49,F
0C2AA:  BNZ   C2BE
0C2AC:  MOVF   48,W
0C2AE:  SUBLW  03
0C2B0:  BNC   C2BE
....................       hb_cmd=arg; 
0C2B2:  MOVFF  48,885
....................       h_bridge(hb_cmd); 
0C2B6:  MOVFF  885,8B5
0C2BA:  RCALL  C280
....................    } 
0C2BC:  BRA    C2C2
....................    else cmd_arg(); 
0C2BE:  CALL   B32E
0C2C2:  GOTO   C2F0 (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0C2C6:  MOVF   2F,W
0C2C8:  MOVWF  00
0C2CA:  MOVF   30,W
0C2CC:  MOVWF  03
0C2CE:  BNZ   C2D4
0C2D0:  MOVF   00,F
0C2D2:  BZ    C2EA
0C2D4:  MOVF   03,W
0C2D6:  BNZ   C2DE
0C2D8:  MOVLW  01
0C2DA:  SUBWF  00,W
0C2DC:  BZ    C2EE
0C2DE:  MOVF   03,W
0C2E0:  BNZ   C2E8
0C2E2:  MOVLW  03
0C2E4:  SUBWF  00,W
0C2E6:  BZ    C2EE
0C2E8:  BRA    C2F0
....................       case ECO : commandBe(); 
0C2EA:  BRA    C188
....................          break; 
0C2EC:  BRA    C2F0
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0C2EE:  BRA    C2A0
....................          break; 
....................    } 
0C2F0:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CDEA:  MOVF   48,W
0CDEC:  MOVWF  00
0CDEE:  MOVF   49,W
0CDF0:  MOVWF  03
0CDF2:  BNZ   CDF8
0CDF4:  MOVF   00,F
0CDF6:  BZ    CE5A
0CDF8:  MOVF   03,W
0CDFA:  BNZ   CE04
0CDFC:  MOVLW  01
0CDFE:  SUBWF  00,W
0CE00:  BTFSC  FD8.2
0CE02:  BRA    D04A
0CE04:  MOVF   03,W
0CE06:  BNZ   CE10
0CE08:  MOVLW  02
0CE0A:  SUBWF  00,W
0CE0C:  BTFSC  FD8.2
0CE0E:  BRA    D0A6
0CE10:  MOVF   03,W
0CE12:  BNZ   CE1C
0CE14:  MOVLW  03
0CE16:  SUBWF  00,W
0CE18:  BTFSC  FD8.2
0CE1A:  BRA    D102
0CE1C:  MOVF   03,W
0CE1E:  BNZ   CE28
0CE20:  MOVLW  04
0CE22:  SUBWF  00,W
0CE24:  BTFSC  FD8.2
0CE26:  BRA    D15E
0CE28:  MOVF   03,W
0CE2A:  BNZ   CE34
0CE2C:  MOVLW  05
0CE2E:  SUBWF  00,W
0CE30:  BTFSC  FD8.2
0CE32:  BRA    D1BA
0CE34:  MOVF   03,W
0CE36:  BNZ   CE40
0CE38:  MOVLW  06
0CE3A:  SUBWF  00,W
0CE3C:  BTFSC  FD8.2
0CE3E:  BRA    D216
0CE40:  MOVF   03,W
0CE42:  BNZ   CE4C
0CE44:  MOVLW  07
0CE46:  SUBWF  00,W
0CE48:  BTFSC  FD8.2
0CE4A:  BRA    D272
0CE4C:  MOVF   03,W
0CE4E:  BNZ   CE58
0CE50:  MOVLW  08
0CE52:  SUBWF  00,W
0CE54:  BTFSC  FD8.2
0CE56:  BRA    D2CE
0CE58:  BRA    D32A
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CE5A:  MOVLW  42
0CE5C:  MOVWF  FF6
0CE5E:  MOVLW  24
0CE60:  MOVWF  FF7
0CE62:  MOVLW  00
0CE64:  MOVWF  FF8
0CE66:  CLRF   1B
0CE68:  BTFSC  FF2.7
0CE6A:  BSF    1B.7
0CE6C:  BCF    FF2.7
0CE6E:  MOVLW  04
0CE70:  MOVLB  A
0CE72:  MOVWF  x40
0CE74:  MOVLB  0
0CE76:  CALL   1044
0CE7A:  BTFSC  1B.7
0CE7C:  BSF    FF2.7
0CE7E:  MOVLW  89
0CE80:  MOVWF  FE9
0CE82:  MOVFF  3F8,888
0CE86:  MOVFF  3F7,887
0CE8A:  MOVFF  3F6,886
0CE8E:  MOVFF  3F5,885
0CE92:  MOVLW  05
0CE94:  MOVLB  8
0CE96:  MOVWF  x89
0CE98:  MOVLB  0
0CE9A:  RCALL  C6A4
0CE9C:  MOVLW  2C
0CE9E:  BTFSS  F9E.4
0CEA0:  BRA    CE9E
0CEA2:  MOVWF  FAD
0CEA4:  MOVLW  89
0CEA6:  MOVWF  FE9
0CEA8:  MOVFF  3FC,888
0CEAC:  MOVFF  3FB,887
0CEB0:  MOVFF  3FA,886
0CEB4:  MOVFF  3F9,885
0CEB8:  MOVLW  05
0CEBA:  MOVLB  8
0CEBC:  MOVWF  x89
0CEBE:  MOVLB  0
0CEC0:  CALL   C6A4
0CEC4:  MOVLW  0D
0CEC6:  BTFSS  F9E.4
0CEC8:  BRA    CEC6
0CECA:  MOVWF  FAD
0CECC:  MOVLW  0A
0CECE:  BTFSS  F9E.4
0CED0:  BRA    CECE
0CED2:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CED4:  MOVLW  54
0CED6:  MOVWF  FF6
0CED8:  MOVLW  24
0CEDA:  MOVWF  FF7
0CEDC:  MOVLW  00
0CEDE:  MOVWF  FF8
0CEE0:  CLRF   1B
0CEE2:  BTFSC  FF2.7
0CEE4:  BSF    1B.7
0CEE6:  BCF    FF2.7
0CEE8:  MOVLW  04
0CEEA:  MOVLB  A
0CEEC:  MOVWF  x40
0CEEE:  MOVLB  0
0CEF0:  CALL   1044
0CEF4:  BTFSC  1B.7
0CEF6:  BSF    FF2.7
0CEF8:  MOVLW  89
0CEFA:  MOVWF  FE9
0CEFC:  MOVFF  400,888
0CF00:  MOVFF  3FF,887
0CF04:  MOVFF  3FE,886
0CF08:  MOVFF  3FD,885
0CF0C:  MOVLW  05
0CF0E:  MOVLB  8
0CF10:  MOVWF  x89
0CF12:  MOVLB  0
0CF14:  CALL   C6A4
0CF18:  MOVLW  2C
0CF1A:  BTFSS  F9E.4
0CF1C:  BRA    CF1A
0CF1E:  MOVWF  FAD
0CF20:  MOVLW  89
0CF22:  MOVWF  FE9
0CF24:  MOVFF  404,888
0CF28:  MOVFF  403,887
0CF2C:  MOVFF  402,886
0CF30:  MOVFF  401,885
0CF34:  MOVLW  05
0CF36:  MOVLB  8
0CF38:  MOVWF  x89
0CF3A:  MOVLB  0
0CF3C:  CALL   C6A4
0CF40:  MOVLW  0D
0CF42:  BTFSS  F9E.4
0CF44:  BRA    CF42
0CF46:  MOVWF  FAD
0CF48:  MOVLW  0A
0CF4A:  BTFSS  F9E.4
0CF4C:  BRA    CF4A
0CF4E:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CF50:  MOVLW  66
0CF52:  MOVWF  FF6
0CF54:  MOVLW  24
0CF56:  MOVWF  FF7
0CF58:  MOVLW  00
0CF5A:  MOVWF  FF8
0CF5C:  CLRF   1B
0CF5E:  BTFSC  FF2.7
0CF60:  BSF    1B.7
0CF62:  BCF    FF2.7
0CF64:  MOVLW  04
0CF66:  MOVLB  A
0CF68:  MOVWF  x40
0CF6A:  MOVLB  0
0CF6C:  CALL   1044
0CF70:  BTFSC  1B.7
0CF72:  BSF    FF2.7
0CF74:  MOVLW  89
0CF76:  MOVWF  FE9
0CF78:  MOVFF  408,888
0CF7C:  MOVFF  407,887
0CF80:  MOVFF  406,886
0CF84:  MOVFF  405,885
0CF88:  MOVLW  05
0CF8A:  MOVLB  8
0CF8C:  MOVWF  x89
0CF8E:  MOVLB  0
0CF90:  CALL   C6A4
0CF94:  MOVLW  2C
0CF96:  BTFSS  F9E.4
0CF98:  BRA    CF96
0CF9A:  MOVWF  FAD
0CF9C:  MOVLW  89
0CF9E:  MOVWF  FE9
0CFA0:  MOVFF  40C,888
0CFA4:  MOVFF  40B,887
0CFA8:  MOVFF  40A,886
0CFAC:  MOVFF  409,885
0CFB0:  MOVLW  05
0CFB2:  MOVLB  8
0CFB4:  MOVWF  x89
0CFB6:  MOVLB  0
0CFB8:  CALL   C6A4
0CFBC:  MOVLW  0D
0CFBE:  BTFSS  F9E.4
0CFC0:  BRA    CFBE
0CFC2:  MOVWF  FAD
0CFC4:  MOVLW  0A
0CFC6:  BTFSS  F9E.4
0CFC8:  BRA    CFC6
0CFCA:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CFCC:  MOVLW  78
0CFCE:  MOVWF  FF6
0CFD0:  MOVLW  24
0CFD2:  MOVWF  FF7
0CFD4:  MOVLW  00
0CFD6:  MOVWF  FF8
0CFD8:  CLRF   1B
0CFDA:  BTFSC  FF2.7
0CFDC:  BSF    1B.7
0CFDE:  BCF    FF2.7
0CFE0:  MOVLW  05
0CFE2:  MOVLB  A
0CFE4:  MOVWF  x40
0CFE6:  MOVLB  0
0CFE8:  CALL   1044
0CFEC:  BTFSC  1B.7
0CFEE:  BSF    FF2.7
0CFF0:  MOVLW  89
0CFF2:  MOVWF  FE9
0CFF4:  MOVFF  410,888
0CFF8:  MOVFF  40F,887
0CFFC:  MOVFF  40E,886
0D000:  MOVFF  40D,885
0D004:  MOVLW  05
0D006:  MOVLB  8
0D008:  MOVWF  x89
0D00A:  MOVLB  0
0D00C:  CALL   C6A4
0D010:  MOVLW  2C
0D012:  BTFSS  F9E.4
0D014:  BRA    D012
0D016:  MOVWF  FAD
0D018:  MOVLW  89
0D01A:  MOVWF  FE9
0D01C:  MOVFF  414,888
0D020:  MOVFF  413,887
0D024:  MOVFF  412,886
0D028:  MOVFF  411,885
0D02C:  MOVLW  05
0D02E:  MOVLB  8
0D030:  MOVWF  x89
0D032:  MOVLB  0
0D034:  CALL   C6A4
0D038:  MOVLW  0D
0D03A:  BTFSS  F9E.4
0D03C:  BRA    D03A
0D03E:  MOVWF  FAD
0D040:  MOVLW  0A
0D042:  BTFSS  F9E.4
0D044:  BRA    D042
0D046:  MOVWF  FAD
....................                   break; 
0D048:  BRA    D32E
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0D04A:  MOVLW  8C
0D04C:  MOVWF  FF6
0D04E:  MOVLW  24
0D050:  MOVWF  FF7
0D052:  MOVLW  00
0D054:  MOVWF  FF8
0D056:  CLRF   1B
0D058:  BTFSC  FF2.7
0D05A:  BSF    1B.7
0D05C:  BCF    FF2.7
0D05E:  CALL   0E6E
0D062:  BTFSC  1B.7
0D064:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0D066:  RCALL  CD36
0D068:  MOVFF  03,3F8
0D06C:  MOVFF  02,3F7
0D070:  MOVFF  01,3F6
0D074:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");   
0D078:  MOVLW  0D
0D07A:  BTFSS  F9E.4
0D07C:  BRA    D07A
0D07E:  MOVWF  FAD
0D080:  MOVLW  0A
0D082:  BTFSS  F9E.4
0D084:  BRA    D082
0D086:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0D088:  MOVLB  8
0D08A:  CLRF   x86
0D08C:  MOVLW  44
0D08E:  MOVWF  x85
0D090:  MOVFF  3F8,88A
0D094:  MOVFF  3F7,889
0D098:  MOVFF  3F6,888
0D09C:  MOVFF  3F5,887
0D0A0:  MOVLB  0
0D0A2:  RCALL  CD7C
....................          break; 
0D0A4:  BRA    D32E
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0D0A6:  MOVLW  94
0D0A8:  MOVWF  FF6
0D0AA:  MOVLW  24
0D0AC:  MOVWF  FF7
0D0AE:  MOVLW  00
0D0B0:  MOVWF  FF8
0D0B2:  CLRF   1B
0D0B4:  BTFSC  FF2.7
0D0B6:  BSF    1B.7
0D0B8:  BCF    FF2.7
0D0BA:  CALL   0E6E
0D0BE:  BTFSC  1B.7
0D0C0:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0D0C2:  RCALL  CD36
0D0C4:  MOVFF  03,3FC
0D0C8:  MOVFF  02,3FB
0D0CC:  MOVFF  01,3FA
0D0D0:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n");  
0D0D4:  MOVLW  0D
0D0D6:  BTFSS  F9E.4
0D0D8:  BRA    D0D6
0D0DA:  MOVWF  FAD
0D0DC:  MOVLW  0A
0D0DE:  BTFSS  F9E.4
0D0E0:  BRA    D0DE
0D0E2:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0D0E4:  MOVLB  8
0D0E6:  CLRF   x86
0D0E8:  MOVLW  48
0D0EA:  MOVWF  x85
0D0EC:  MOVFF  3FC,88A
0D0F0:  MOVFF  3FB,889
0D0F4:  MOVFF  3FA,888
0D0F8:  MOVFF  3F9,887
0D0FC:  MOVLB  0
0D0FE:  RCALL  CD7C
....................          break; 
0D100:  BRA    D32E
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0D102:  MOVLW  9C
0D104:  MOVWF  FF6
0D106:  MOVLW  24
0D108:  MOVWF  FF7
0D10A:  MOVLW  00
0D10C:  MOVWF  FF8
0D10E:  CLRF   1B
0D110:  BTFSC  FF2.7
0D112:  BSF    1B.7
0D114:  BCF    FF2.7
0D116:  CALL   0E6E
0D11A:  BTFSC  1B.7
0D11C:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0D11E:  RCALL  CD36
0D120:  MOVFF  03,400
0D124:  MOVFF  02,3FF
0D128:  MOVFF  01,3FE
0D12C:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n"); 
0D130:  MOVLW  0D
0D132:  BTFSS  F9E.4
0D134:  BRA    D132
0D136:  MOVWF  FAD
0D138:  MOVLW  0A
0D13A:  BTFSS  F9E.4
0D13C:  BRA    D13A
0D13E:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0D140:  MOVLB  8
0D142:  CLRF   x86
0D144:  MOVLW  4C
0D146:  MOVWF  x85
0D148:  MOVFF  400,88A
0D14C:  MOVFF  3FF,889
0D150:  MOVFF  3FE,888
0D154:  MOVFF  3FD,887
0D158:  MOVLB  0
0D15A:  RCALL  CD7C
....................          break; 
0D15C:  BRA    D32E
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0D15E:  MOVLW  A4
0D160:  MOVWF  FF6
0D162:  MOVLW  24
0D164:  MOVWF  FF7
0D166:  MOVLW  00
0D168:  MOVWF  FF8
0D16A:  CLRF   1B
0D16C:  BTFSC  FF2.7
0D16E:  BSF    1B.7
0D170:  BCF    FF2.7
0D172:  CALL   0E6E
0D176:  BTFSC  1B.7
0D178:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0D17A:  RCALL  CD36
0D17C:  MOVFF  03,404
0D180:  MOVFF  02,403
0D184:  MOVFF  01,402
0D188:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");  
0D18C:  MOVLW  0D
0D18E:  BTFSS  F9E.4
0D190:  BRA    D18E
0D192:  MOVWF  FAD
0D194:  MOVLW  0A
0D196:  BTFSS  F9E.4
0D198:  BRA    D196
0D19A:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0D19C:  MOVLB  8
0D19E:  CLRF   x86
0D1A0:  MOVLW  52
0D1A2:  MOVWF  x85
0D1A4:  MOVFF  3FC,88A
0D1A8:  MOVFF  3FB,889
0D1AC:  MOVFF  3FA,888
0D1B0:  MOVFF  3F9,887
0D1B4:  MOVLB  0
0D1B6:  RCALL  CD7C
....................          break; 
0D1B8:  BRA    D32E
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0D1BA:  MOVLW  AC
0D1BC:  MOVWF  FF6
0D1BE:  MOVLW  24
0D1C0:  MOVWF  FF7
0D1C2:  MOVLW  00
0D1C4:  MOVWF  FF8
0D1C6:  CLRF   1B
0D1C8:  BTFSC  FF2.7
0D1CA:  BSF    1B.7
0D1CC:  BCF    FF2.7
0D1CE:  CALL   0E6E
0D1D2:  BTFSC  1B.7
0D1D4:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0D1D6:  RCALL  CD36
0D1D8:  MOVFF  03,408
0D1DC:  MOVFF  02,407
0D1E0:  MOVFF  01,406
0D1E4:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");   
0D1E8:  MOVLW  0D
0D1EA:  BTFSS  F9E.4
0D1EC:  BRA    D1EA
0D1EE:  MOVWF  FAD
0D1F0:  MOVLW  0A
0D1F2:  BTFSS  F9E.4
0D1F4:  BRA    D1F2
0D1F6:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0D1F8:  MOVLB  8
0D1FA:  CLRF   x86
0D1FC:  MOVLW  56
0D1FE:  MOVWF  x85
0D200:  MOVFF  408,88A
0D204:  MOVFF  407,889
0D208:  MOVFF  406,888
0D20C:  MOVFF  405,887
0D210:  MOVLB  0
0D212:  RCALL  CD7C
....................          break; 
0D214:  BRA    D32E
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0D216:  MOVLW  B4
0D218:  MOVWF  FF6
0D21A:  MOVLW  24
0D21C:  MOVWF  FF7
0D21E:  MOVLW  00
0D220:  MOVWF  FF8
0D222:  CLRF   1B
0D224:  BTFSC  FF2.7
0D226:  BSF    1B.7
0D228:  BCF    FF2.7
0D22A:  CALL   0E6E
0D22E:  BTFSC  1B.7
0D230:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0D232:  RCALL  CD36
0D234:  MOVFF  03,40C
0D238:  MOVFF  02,40B
0D23C:  MOVFF  01,40A
0D240:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");  
0D244:  MOVLW  0D
0D246:  BTFSS  F9E.4
0D248:  BRA    D246
0D24A:  MOVWF  FAD
0D24C:  MOVLW  0A
0D24E:  BTFSS  F9E.4
0D250:  BRA    D24E
0D252:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0D254:  MOVLB  8
0D256:  CLRF   x86
0D258:  MOVLW  5A
0D25A:  MOVWF  x85
0D25C:  MOVFF  40C,88A
0D260:  MOVFF  40B,889
0D264:  MOVFF  40A,888
0D268:  MOVFF  409,887
0D26C:  MOVLB  0
0D26E:  RCALL  CD7C
....................          break; 
0D270:  BRA    D32E
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0D272:  MOVLW  BC
0D274:  MOVWF  FF6
0D276:  MOVLW  24
0D278:  MOVWF  FF7
0D27A:  MOVLW  00
0D27C:  MOVWF  FF8
0D27E:  CLRF   1B
0D280:  BTFSC  FF2.7
0D282:  BSF    1B.7
0D284:  BCF    FF2.7
0D286:  CALL   0E6E
0D28A:  BTFSC  1B.7
0D28C:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0D28E:  RCALL  CD36
0D290:  MOVFF  03,410
0D294:  MOVFF  02,40F
0D298:  MOVFF  01,40E
0D29C:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");   
0D2A0:  MOVLW  0D
0D2A2:  BTFSS  F9E.4
0D2A4:  BRA    D2A2
0D2A6:  MOVWF  FAD
0D2A8:  MOVLW  0A
0D2AA:  BTFSS  F9E.4
0D2AC:  BRA    D2AA
0D2AE:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0D2B0:  MOVLB  8
0D2B2:  CLRF   x86
0D2B4:  MOVLW  5E
0D2B6:  MOVWF  x85
0D2B8:  MOVFF  410,88A
0D2BC:  MOVFF  40F,889
0D2C0:  MOVFF  40E,888
0D2C4:  MOVFF  40D,887
0D2C8:  MOVLB  0
0D2CA:  RCALL  CD7C
....................          break; 
0D2CC:  BRA    D32E
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0D2CE:  MOVLW  C6
0D2D0:  MOVWF  FF6
0D2D2:  MOVLW  24
0D2D4:  MOVWF  FF7
0D2D6:  MOVLW  00
0D2D8:  MOVWF  FF8
0D2DA:  CLRF   1B
0D2DC:  BTFSC  FF2.7
0D2DE:  BSF    1B.7
0D2E0:  BCF    FF2.7
0D2E2:  CALL   0E6E
0D2E6:  BTFSC  1B.7
0D2E8:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0D2EA:  RCALL  CD36
0D2EC:  MOVFF  03,414
0D2F0:  MOVFF  02,413
0D2F4:  MOVFF  01,412
0D2F8:  MOVFF  00,411
....................                fprintf(COM_A,"\r\n");  
0D2FC:  MOVLW  0D
0D2FE:  BTFSS  F9E.4
0D300:  BRA    D2FE
0D302:  MOVWF  FAD
0D304:  MOVLW  0A
0D306:  BTFSS  F9E.4
0D308:  BRA    D306
0D30A:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0D30C:  MOVLB  8
0D30E:  CLRF   x86
0D310:  MOVLW  62
0D312:  MOVWF  x85
0D314:  MOVFF  414,88A
0D318:  MOVFF  413,889
0D31C:  MOVFF  412,888
0D320:  MOVFF  411,887
0D324:  MOVLB  0
0D326:  RCALL  CD7C
....................          break;         
0D328:  BRA    D32E
....................       default: cmd_arg(); 
0D32A:  CALL   B32E
....................          break; 
....................    } 
0D32E:  GOTO   DD24 (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0DA3E:  MOVF   4B,F
0DA40:  BNZ   DA50
0DA42:  MOVF   4A,F
0DA44:  BNZ   DA50
0DA46:  MOVF   49,F
0DA48:  BNZ   DA50
0DA4A:  MOVF   48,W
0DA4C:  SUBLW  01
0DA4E:  BC    DAA0
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0DA50:  MOVF   4B,F
0DA52:  BNZ   DA6A
0DA54:  MOVF   4A,F
0DA56:  BNZ   DA6A
0DA58:  MOVF   49,F
0DA5A:  BNZ   DA6A
0DA5C:  MOVF   48,W
0DA5E:  SUBLW  30
0DA60:  BNC   DA6A
0DA62:  DECFSZ 2F,W
0DA64:  BRA    DA6A
0DA66:  MOVF   30,F
0DA68:  BZ    DA86
0DA6A:  MOVF   4B,F
0DA6C:  BNZ   DA9A
0DA6E:  MOVF   4A,F
0DA70:  BNZ   DA9A
0DA72:  MOVF   49,F
0DA74:  BNZ   DA9A
0DA76:  MOVF   48,W
0DA78:  SUBLW  32
0DA7A:  BNC   DA9A
0DA7C:  MOVF   2F,W
0DA7E:  SUBLW  03
0DA80:  BNZ   DA9A
0DA82:  MOVF   30,F
0DA84:  BNZ   DA9A
....................          port=arg; 
0DA86:  MOVFF  49,886
0DA8A:  MOVFF  48,885
....................          play_wms_hard_macro(port);    
0DA8E:  MOVFF  886,88A
0DA92:  MOVFF  885,889
0DA96:  RCALL  D830
....................       } 
0DA98:  BRA    DA9E
....................       else cmd_arg(); 
0DA9A:  CALL   B32E
....................    } 
0DA9E:  BRA    DAA4
....................    else cmd_arg(); 
0DAA0:  CALL   B32E
0DAA4:  GOTO   DD24 (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0DCB4:  MOVF   48,F
0DCB6:  BNZ   DCC4
0DCB8:  MOVF   49,F
0DCBA:  BNZ   DCC4
0DCBC:  MOVF   4A,F
0DCBE:  BNZ   DCC4
0DCC0:  MOVF   4B,F
0DCC2:  BZ    DCE2
0DCC4:  MOVF   4B,F
0DCC6:  BNZ   DCE2
0DCC8:  MOVF   4A,F
0DCCA:  BNZ   DCE2
0DCCC:  MOVF   49,F
0DCCE:  BNZ   DCE2
0DCD0:  MOVF   48,W
0DCD2:  SUBLW  04
0DCD4:  BNC   DCE2
....................       chip=arg; 
0DCD6:  MOVFF  48,885
....................       sol_chip_cmd(chip); 
0DCDA:  MOVFF  885,8B6
0DCDE:  RCALL  DBE6
....................    } 
0DCE0:  BRA    DCE6
....................    else cmd_arg();    
0DCE2:  CALL   B32E
0DCE6:  GOTO   DD24 (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0DCEA:  MOVF   2F,W
0DCEC:  MOVWF  00
0DCEE:  MOVF   30,W
0DCF0:  MOVWF  03
0DCF2:  BNZ   DCF8
0DCF4:  MOVF   00,F
0DCF6:  BZ    DD18
0DCF8:  MOVF   03,W
0DCFA:  BNZ   DD02
0DCFC:  MOVLW  01
0DCFE:  SUBWF  00,W
0DD00:  BZ    DD1E
0DD02:  MOVF   03,W
0DD04:  BNZ   DD0C
0DD06:  MOVLW  03
0DD08:  SUBWF  00,W
0DD0A:  BZ    DD1E
0DD0C:  MOVF   03,W
0DD0E:  BNZ   DD16
0DD10:  MOVLW  02
0DD12:  SUBWF  00,W
0DD14:  BZ    DD22
0DD16:  BRA    DD24
....................       case ECO : commandCe(); 
0DD18:  GOTO   CDEA
....................          break; 
0DD1C:  BRA    DD24
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0DD1E:  BRA    DA3E
....................          break; 
0DD20:  BRA    DD24
....................       case AWS : commandCa(); 
0DD22:  BRA    DCB4
....................          break;          
....................    } 
0DD24:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0DD28:  MOVF   48,W
0DD2A:  MOVWF  00
0DD2C:  MOVF   49,W
0DD2E:  MOVWF  03
0DD30:  BNZ   DD36
0DD32:  MOVF   00,F
0DD34:  BZ    DD56
0DD36:  MOVF   03,W
0DD38:  BNZ   DD40
0DD3A:  MOVLW  01
0DD3C:  SUBWF  00,W
0DD3E:  BZ    DD68
0DD40:  MOVF   03,W
0DD42:  BNZ   DD4A
0DD44:  MOVLW  02
0DD46:  SUBWF  00,W
0DD48:  BZ    DD8A
0DD4A:  MOVF   03,W
0DD4C:  BNZ   DD54
0DD4E:  MOVLW  03
0DD50:  SUBWF  00,W
0DD52:  BZ    DD9C
0DD54:  BRA    DDBE
....................       case 0 : file_list(file_ptr_raw_all); 
0DD56:  MOVLW  02
0DD58:  MOVLB  8
0DD5A:  MOVWF  x8A
0DD5C:  MOVLW  DD
0DD5E:  MOVWF  x89
0DD60:  MOVLB  0
0DD62:  CALL   BB54
....................          break; 
0DD66:  BRA    DDC2
....................       case 1 : file_list(file_ptr_raw_new); 
0DD68:  MOVLW  02
0DD6A:  MOVLB  8
0DD6C:  MOVWF  x8A
0DD6E:  MOVLW  EB
0DD70:  MOVWF  x89
0DD72:  MOVLB  0
0DD74:  CALL   BB54
....................                f_unlink(file_ptr_raw_new); 
0DD78:  MOVLW  02
0DD7A:  MOVLB  8
0DD7C:  MOVWF  x8A
0DD7E:  MOVLW  EB
0DD80:  MOVWF  x89
0DD82:  MOVLB  0
0DD84:  CALL   BCCE
....................          break; 
0DD88:  BRA    DDC2
....................       case 2 : file_list(file_ptr_rel_all); 
0DD8A:  MOVLW  02
0DD8C:  MOVLB  8
0DD8E:  MOVWF  x8A
0DD90:  MOVLW  F9
0DD92:  MOVWF  x89
0DD94:  MOVLB  0
0DD96:  CALL   BB54
....................          break; 
0DD9A:  BRA    DDC2
....................       case 3 : file_list(file_ptr_rel_new); 
0DD9C:  MOVLW  03
0DD9E:  MOVLB  8
0DDA0:  MOVWF  x8A
0DDA2:  MOVLW  07
0DDA4:  MOVWF  x89
0DDA6:  MOVLB  0
0DDA8:  CALL   BB54
....................                f_unlink(file_ptr_rel_new); 
0DDAC:  MOVLW  03
0DDAE:  MOVLB  8
0DDB0:  MOVWF  x8A
0DDB2:  MOVLW  07
0DDB4:  MOVWF  x89
0DDB6:  MOVLB  0
0DDB8:  CALL   BCCE
....................          break;  
0DDBC:  BRA    DDC2
....................       default : cmd_arg(); 
0DDBE:  CALL   B32E
....................          break; 
....................    } 
0DDC2:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DDC6:  MOVF   48,W
0DDC8:  MOVWF  00
0DDCA:  MOVF   49,W
0DDCC:  MOVWF  03
0DDCE:  BNZ   DDD4
0DDD0:  MOVF   00,F
0DDD2:  BZ    DDE0
0DDD4:  MOVF   03,W
0DDD6:  BNZ   DDDE
0DDD8:  MOVLW  02
0DDDA:  SUBWF  00,W
0DDDC:  BZ    DE5A
0DDDE:  BRA    DED4
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DDE0:  MOVLW  D0
0DDE2:  MOVWF  FF6
0DDE4:  MOVLW  24
0DDE6:  MOVWF  FF7
0DDE8:  MOVLW  00
0DDEA:  MOVWF  FF8
0DDEC:  CLRF   1B
0DDEE:  BTFSC  FF2.7
0DDF0:  BSF    1B.7
0DDF2:  BCF    FF2.7
0DDF4:  CALL   0E6E
0DDF8:  BTFSC  1B.7
0DDFA:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DDFC:  CALL   0E58
0DE00:  MOVFF  01,885
....................       if(result == 'Y'){ 
0DE04:  MOVLB  8
0DE06:  MOVF   x85,W
0DE08:  SUBLW  59
0DE0A:  BNZ   DE3A
....................       f_unlink(file_ptr_raw_all); 
0DE0C:  MOVLW  02
0DE0E:  MOVWF  x8A
0DE10:  MOVLW  DD
0DE12:  MOVWF  x89
0DE14:  MOVLB  0
0DE16:  CALL   BCCE
....................       printf("File deleted!\n\r"); 
0DE1A:  MOVLW  0C
0DE1C:  MOVWF  FF6
0DE1E:  MOVLW  25
0DE20:  MOVWF  FF7
0DE22:  MOVLW  00
0DE24:  MOVWF  FF8
0DE26:  CLRF   1B
0DE28:  BTFSC  FF2.7
0DE2A:  BSF    1B.7
0DE2C:  BCF    FF2.7
0DE2E:  CALL   0E6E
0DE32:  BTFSC  1B.7
0DE34:  BSF    FF2.7
....................       }else{ 
0DE36:  BRA    DE58
0DE38:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DE3A:  MOVLW  1C
0DE3C:  MOVWF  FF6
0DE3E:  MOVLW  25
0DE40:  MOVWF  FF7
0DE42:  MOVLW  00
0DE44:  MOVWF  FF8
0DE46:  CLRF   1B
0DE48:  BTFSC  FF2.7
0DE4A:  BSF    1B.7
0DE4C:  BCF    FF2.7
0DE4E:  MOVLB  0
0DE50:  CALL   0E6E
0DE54:  BTFSC  1B.7
0DE56:  BSF    FF2.7
....................       } 
....................          break; 
0DE58:  BRA    DED8
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DE5A:  MOVLW  32
0DE5C:  MOVWF  FF6
0DE5E:  MOVLW  25
0DE60:  MOVWF  FF7
0DE62:  MOVLW  00
0DE64:  MOVWF  FF8
0DE66:  CLRF   1B
0DE68:  BTFSC  FF2.7
0DE6A:  BSF    1B.7
0DE6C:  BCF    FF2.7
0DE6E:  CALL   0E6E
0DE72:  BTFSC  1B.7
0DE74:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DE76:  CALL   0E58
0DE7A:  MOVFF  01,885
....................          if(result == 'Y'){ 
0DE7E:  MOVLB  8
0DE80:  MOVF   x85,W
0DE82:  SUBLW  59
0DE84:  BNZ   DEB4
....................             f_unlink(file_ptr_rel_all); 
0DE86:  MOVLW  02
0DE88:  MOVWF  x8A
0DE8A:  MOVLW  F9
0DE8C:  MOVWF  x89
0DE8E:  MOVLB  0
0DE90:  CALL   BCCE
....................             printf("File deleted!\n\r"); 
0DE94:  MOVLW  76
0DE96:  MOVWF  FF6
0DE98:  MOVLW  25
0DE9A:  MOVWF  FF7
0DE9C:  MOVLW  00
0DE9E:  MOVWF  FF8
0DEA0:  CLRF   1B
0DEA2:  BTFSC  FF2.7
0DEA4:  BSF    1B.7
0DEA6:  BCF    FF2.7
0DEA8:  CALL   0E6E
0DEAC:  BTFSC  1B.7
0DEAE:  BSF    FF2.7
....................          }else{ 
0DEB0:  BRA    DED2
0DEB2:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DEB4:  MOVLW  86
0DEB6:  MOVWF  FF6
0DEB8:  MOVLW  25
0DEBA:  MOVWF  FF7
0DEBC:  MOVLW  00
0DEBE:  MOVWF  FF8
0DEC0:  CLRF   1B
0DEC2:  BTFSC  FF2.7
0DEC4:  BSF    1B.7
0DEC6:  BCF    FF2.7
0DEC8:  MOVLB  0
0DECA:  CALL   0E6E
0DECE:  BTFSC  1B.7
0DED0:  BSF    FF2.7
....................          } 
....................          break; 
0DED2:  BRA    DED8
....................       default : cmd_arg(); 
0DED4:  CALL   B32E
....................          break;          
....................    } 
0DED8:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0E0C4:  MOVF   48,W
0E0C6:  SUBLW  95
0E0C8:  BNZ   E0DC
0E0CA:  MOVF   49,W
0E0CC:  SUBLW  15
0E0CE:  BNZ   E0DC
0E0D0:  MOVF   4A,F
0E0D2:  BNZ   E0DC
0E0D4:  MOVF   4B,F
0E0D6:  BNZ   E0DC
....................       reset_nv_vars(); 
0E0D8:  BRA    DEDC
....................    } 
0E0DA:  BRA    E0E0
....................    else cmd_arg(); 
0E0DC:  CALL   B32E
0E0E0:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0E12E:  MOVF   2F,F
0E130:  BNZ   E136
0E132:  MOVF   30,F
0E134:  BZ    E148
0E136:  DECFSZ 2F,W
0E138:  BRA    E13E
0E13A:  MOVF   30,F
0E13C:  BZ    E148
0E13E:  MOVF   2F,W
0E140:  SUBLW  03
0E142:  BNZ   E1BA
0E144:  MOVF   30,F
0E146:  BNZ   E1BA
....................    { 
....................       busy_set(); 
0E148:  CALL   29E8
....................  
....................       switch(arg) 
0E14C:  MOVFF  48,00
0E150:  MOVF   49,W
0E152:  MOVWF  03
0E154:  BNZ   E15C
0E156:  MOVLW  01
0E158:  SUBWF  00,W
0E15A:  BZ    E172
0E15C:  MOVF   03,W
0E15E:  BNZ   E166
0E160:  MOVLW  02
0E162:  SUBWF  00,W
0E164:  BZ    E182
0E166:  MOVF   03,W
0E168:  BNZ   E170
0E16A:  MOVLW  03
0E16C:  SUBWF  00,W
0E16E:  BZ    E1AC
0E170:  BRA    E1B2
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0E172:  MOVLB  7
0E174:  CLRF   x40
....................             align(0); 
0E176:  MOVLB  8
0E178:  CLRF   xC2
0E17A:  MOVLB  0
0E17C:  CALL   A8DC
....................             break; 
0E180:  BRA    E1B6
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0E182:  MOVF   48,W
0E184:  SUBLW  02
0E186:  BNZ   E1AA
0E188:  MOVF   49,F
0E18A:  BNZ   E1AA
0E18C:  MOVF   4A,F
0E18E:  BNZ   E1AA
0E190:  MOVF   4B,F
0E192:  BNZ   E1AA
0E194:  MOVF   1F,W
0E196:  SUBLW  04
0E198:  BNZ   E1AA
0E19A:  MOVF   20,F
0E19C:  BNZ   E1AA
....................             { 
....................                motor=0; 
0E19E:  MOVLB  7
0E1A0:  CLRF   x40
....................                cal_disk(0); 
0E1A2:  MOVLB  8
0E1A4:  CLRF   x85
0E1A6:  MOVLB  0
0E1A8:  BRA    E0E4
....................             } 
....................             break; 
0E1AA:  BRA    E1B6
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0E1AC:  CALL   AA80
....................             break; 
0E1B0:  BRA    E1B6
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0E1B2:  CALL   B32E
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0E1B6:  CALL   AEE0
....................    } 
0E1BA:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E694:  DECFSZ 48,W
0E696:  BRA    EAB4
0E698:  MOVF   49,F
0E69A:  BTFSS  FD8.2
0E69C:  BRA    EAB4
0E69E:  MOVF   4A,F
0E6A0:  BTFSS  FD8.2
0E6A2:  BRA    EAB4
0E6A4:  MOVF   4B,F
0E6A6:  BTFSS  FD8.2
0E6A8:  BRA    EAB4
....................       v_supply = read_supply(); 
0E6AA:  CALL   5124
0E6AE:  MOVFF  02,886
0E6B2:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0E6B6:  CALL   34DA
....................       RTC_read(); 
0E6BA:  CALL   336C
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E6BE:  MOVLW  9C
0E6C0:  MOVWF  FF6
0E6C2:  MOVLW  25
0E6C4:  MOVWF  FF7
0E6C6:  MOVLW  00
0E6C8:  MOVWF  FF8
0E6CA:  CLRF   1B
0E6CC:  BTFSC  FF2.7
0E6CE:  BSF    1B.7
0E6D0:  BCF    FF2.7
0E6D2:  MOVLW  04
0E6D4:  MOVLB  A
0E6D6:  MOVWF  x40
0E6D8:  MOVLB  0
0E6DA:  CALL   1044
0E6DE:  BTFSC  1B.7
0E6E0:  BSF    FF2.7
0E6E2:  MOVLW  10
0E6E4:  MOVWF  FE9
0E6E6:  CLRF   1B
0E6E8:  BTFSC  FF2.7
0E6EA:  BSF    1B.7
0E6EC:  BCF    FF2.7
0E6EE:  MOVFF  26,A41
0E6F2:  MOVFF  25,A40
0E6F6:  CALL   11C6
0E6FA:  BTFSC  1B.7
0E6FC:  BSF    FF2.7
0E6FE:  MOVLW  20
0E700:  BTFSS  F9E.4
0E702:  BRA    E700
0E704:  MOVWF  FAD
0E706:  MOVLW  49
0E708:  BTFSS  F9E.4
0E70A:  BRA    E708
0E70C:  MOVWF  FAD
0E70E:  MOVLW  10
0E710:  MOVWF  FE9
0E712:  CLRF   1B
0E714:  BTFSC  FF2.7
0E716:  BSF    1B.7
0E718:  BCF    FF2.7
0E71A:  MOVFF  24,A41
0E71E:  MOVFF  23,A40
0E722:  CALL   11C6
0E726:  BTFSC  1B.7
0E728:  BSF    FF2.7
0E72A:  MOVLW  20
0E72C:  BTFSS  F9E.4
0E72E:  BRA    E72C
0E730:  MOVWF  FAD
0E732:  MOVLW  4E
0E734:  BTFSS  F9E.4
0E736:  BRA    E734
0E738:  MOVWF  FAD
0E73A:  MOVLW  10
0E73C:  MOVWF  FE9
0E73E:  CLRF   1B
0E740:  BTFSC  FF2.7
0E742:  BSF    1B.7
0E744:  BCF    FF2.7
0E746:  MOVFF  22,A41
0E74A:  MOVFF  21,A40
0E74E:  CALL   11C6
0E752:  BTFSC  1B.7
0E754:  BSF    FF2.7
0E756:  MOVLW  2F
0E758:  BTFSS  F9E.4
0E75A:  BRA    E758
0E75C:  MOVWF  FAD
0E75E:  MOVLW  10
0E760:  MOVWF  FE9
0E762:  CLRF   1B
0E764:  BTFSC  FF2.7
0E766:  BSF    1B.7
0E768:  BCF    FF2.7
0E76A:  MOVFF  28,A41
0E76E:  MOVFF  27,A40
0E772:  CALL   11C6
0E776:  BTFSC  1B.7
0E778:  BSF    FF2.7
0E77A:  MOVLW  20
0E77C:  BTFSS  F9E.4
0E77E:  BRA    E77C
0E780:  MOVWF  FAD
0E782:  MOVLW  58
0E784:  BTFSS  F9E.4
0E786:  BRA    E784
0E788:  MOVWF  FAD
0E78A:  MOVLW  10
0E78C:  MOVWF  FE9
0E78E:  CLRF   1B
0E790:  BTFSC  FF2.7
0E792:  BSF    1B.7
0E794:  BCF    FF2.7
0E796:  MOVFF  20,A41
0E79A:  MOVFF  1F,A40
0E79E:  CALL   11C6
0E7A2:  BTFSC  1B.7
0E7A4:  BSF    FF2.7
0E7A6:  MOVLW  20
0E7A8:  BTFSS  F9E.4
0E7AA:  BRA    E7A8
0E7AC:  MOVWF  FAD
0E7AE:  MOVLW  55
0E7B0:  BTFSS  F9E.4
0E7B2:  BRA    E7B0
0E7B4:  MOVWF  FAD
0E7B6:  CLRF   1B
0E7B8:  BTFSC  FF2.7
0E7BA:  BSF    1B.7
0E7BC:  BCF    FF2.7
0E7BE:  MOVFF  740,A40
0E7C2:  MOVLW  1B
0E7C4:  MOVLB  A
0E7C6:  MOVWF  x41
0E7C8:  MOVLB  0
0E7CA:  CALL   0FC6
0E7CE:  BTFSC  1B.7
0E7D0:  BSF    FF2.7
0E7D2:  MOVLW  20
0E7D4:  BTFSS  F9E.4
0E7D6:  BRA    E7D4
0E7D8:  MOVWF  FAD
0E7DA:  MOVLW  04
0E7DC:  MOVWF  FE9
0E7DE:  MOVLB  8
0E7E0:  CLRF   x8A
0E7E2:  CLRF   x89
0E7E4:  MOVFF  886,888
0E7E8:  MOVFF  885,887
0E7EC:  MOVLW  02
0E7EE:  MOVWF  x8B
0E7F0:  MOVLB  0
0E7F2:  RCALL  E1BE
0E7F4:  MOVLW  C0
0E7F6:  MOVWF  FF6
0E7F8:  MOVLW  25
0E7FA:  MOVWF  FF7
0E7FC:  MOVLW  00
0E7FE:  MOVWF  FF8
0E800:  CLRF   1B
0E802:  BTFSC  FF2.7
0E804:  BSF    1B.7
0E806:  BCF    FF2.7
0E808:  MOVLW  03
0E80A:  MOVLB  A
0E80C:  MOVWF  x40
0E80E:  MOVLB  0
0E810:  CALL   1044
0E814:  BTFSC  1B.7
0E816:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E818:  MOVLW  C4
0E81A:  MOVWF  FF6
0E81C:  MOVLW  25
0E81E:  MOVWF  FF7
0E820:  MOVLW  00
0E822:  MOVWF  FF8
0E824:  CLRF   1B
0E826:  BTFSC  FF2.7
0E828:  BSF    1B.7
0E82A:  BCF    FF2.7
0E82C:  MOVLW  09
0E82E:  MOVLB  A
0E830:  MOVWF  x40
0E832:  MOVLB  0
0E834:  CALL   1044
0E838:  BTFSC  1B.7
0E83A:  BSF    FF2.7
0E83C:  MOVLW  10
0E83E:  MOVWF  FE9
0E840:  CLRF   1B
0E842:  BTFSC  FF2.7
0E844:  BSF    1B.7
0E846:  BCF    FF2.7
0E848:  MOVFF  7C4,A41
0E84C:  MOVFF  7C3,A40
0E850:  CALL   11C6
0E854:  BTFSC  1B.7
0E856:  BSF    FF2.7
0E858:  MOVLW  D0
0E85A:  MOVWF  FF6
0E85C:  MOVLW  25
0E85E:  MOVWF  FF7
0E860:  MOVLW  00
0E862:  MOVWF  FF8
0E864:  CLRF   1B
0E866:  BTFSC  FF2.7
0E868:  BSF    1B.7
0E86A:  BCF    FF2.7
0E86C:  MOVLW  05
0E86E:  MOVLB  A
0E870:  MOVWF  x40
0E872:  MOVLB  0
0E874:  CALL   1044
0E878:  BTFSC  1B.7
0E87A:  BSF    FF2.7
0E87C:  MOVLW  10
0E87E:  MOVWF  FE9
0E880:  MOVFF  7B6,8F1
0E884:  MOVFF  7B5,8F0
0E888:  CALL   900C
0E88C:  MOVLW  0D
0E88E:  BTFSS  F9E.4
0E890:  BRA    E88E
0E892:  MOVWF  FAD
0E894:  MOVLW  0A
0E896:  BTFSS  F9E.4
0E898:  BRA    E896
0E89A:  MOVWF  FAD
....................       RTC_display(); 
0E89C:  RCALL  E2BA
....................       if (RTCfmt == 0) 
0E89E:  MOVF   4F,F
0E8A0:  BTFSS  FD8.2
0E8A2:  BRA    E9A8
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E8A4:  MOVLW  DC
0E8A6:  MOVWF  FF6
0E8A8:  MOVLW  25
0E8AA:  MOVWF  FF7
0E8AC:  MOVLW  00
0E8AE:  MOVWF  FF8
0E8B0:  CLRF   1B
0E8B2:  BTFSC  FF2.7
0E8B4:  BSF    1B.7
0E8B6:  BCF    FF2.7
0E8B8:  MOVLW  05
0E8BA:  MOVLB  A
0E8BC:  MOVWF  x40
0E8BE:  MOVLB  0
0E8C0:  CALL   1044
0E8C4:  BTFSC  1B.7
0E8C6:  BSF    FF2.7
0E8C8:  CLRF   1B
0E8CA:  BTFSC  FF2.7
0E8CC:  BSF    1B.7
0E8CE:  BCF    FF2.7
0E8D0:  MOVFF  73A,A40
0E8D4:  MOVLW  01
0E8D6:  MOVLB  A
0E8D8:  MOVWF  x41
0E8DA:  MOVLB  0
0E8DC:  CALL   0FC6
0E8E0:  BTFSC  1B.7
0E8E2:  BSF    FF2.7
0E8E4:  MOVLW  2F
0E8E6:  BTFSS  F9E.4
0E8E8:  BRA    E8E6
0E8EA:  MOVWF  FAD
0E8EC:  CLRF   1B
0E8EE:  BTFSC  FF2.7
0E8F0:  BSF    1B.7
0E8F2:  BCF    FF2.7
0E8F4:  MOVFF  73B,A40
0E8F8:  MOVLW  01
0E8FA:  MOVLB  A
0E8FC:  MOVWF  x41
0E8FE:  MOVLB  0
0E900:  CALL   0FC6
0E904:  BTFSC  1B.7
0E906:  BSF    FF2.7
0E908:  MOVLW  2F
0E90A:  BTFSS  F9E.4
0E90C:  BRA    E90A
0E90E:  MOVWF  FAD
0E910:  CLRF   1B
0E912:  BTFSC  FF2.7
0E914:  BSF    1B.7
0E916:  BCF    FF2.7
0E918:  MOVFF  73C,A40
0E91C:  MOVLW  01
0E91E:  MOVLB  A
0E920:  MOVWF  x41
0E922:  MOVLB  0
0E924:  CALL   0FC6
0E928:  BTFSC  1B.7
0E92A:  BSF    FF2.7
0E92C:  MOVLW  20
0E92E:  BTFSS  F9E.4
0E930:  BRA    E92E
0E932:  MOVWF  FAD
0E934:  CLRF   1B
0E936:  BTFSC  FF2.7
0E938:  BSF    1B.7
0E93A:  BCF    FF2.7
0E93C:  MOVFF  73D,A40
0E940:  MOVLW  01
0E942:  MOVLB  A
0E944:  MOVWF  x41
0E946:  MOVLB  0
0E948:  CALL   0FC6
0E94C:  BTFSC  1B.7
0E94E:  BSF    FF2.7
0E950:  MOVLW  3A
0E952:  BTFSS  F9E.4
0E954:  BRA    E952
0E956:  MOVWF  FAD
0E958:  CLRF   1B
0E95A:  BTFSC  FF2.7
0E95C:  BSF    1B.7
0E95E:  BCF    FF2.7
0E960:  MOVFF  73E,A40
0E964:  MOVLW  01
0E966:  MOVLB  A
0E968:  MOVWF  x41
0E96A:  MOVLB  0
0E96C:  CALL   0FC6
0E970:  BTFSC  1B.7
0E972:  BSF    FF2.7
0E974:  MOVLW  3A
0E976:  BTFSS  F9E.4
0E978:  BRA    E976
0E97A:  MOVWF  FAD
0E97C:  CLRF   1B
0E97E:  BTFSC  FF2.7
0E980:  BSF    1B.7
0E982:  BCF    FF2.7
0E984:  MOVFF  73F,A40
0E988:  MOVLW  01
0E98A:  MOVLB  A
0E98C:  MOVWF  x41
0E98E:  MOVLB  0
0E990:  CALL   0FC6
0E994:  BTFSC  1B.7
0E996:  BSF    FF2.7
0E998:  MOVLW  0D
0E99A:  BTFSS  F9E.4
0E99C:  BRA    E99A
0E99E:  MOVWF  FAD
0E9A0:  MOVLW  0A
0E9A2:  BTFSS  F9E.4
0E9A4:  BRA    E9A2
0E9A6:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E9A8:  DECFSZ 4F,W
0E9AA:  BRA    EAB0
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E9AC:  MOVLW  02
0E9AE:  MOVWF  FF6
0E9B0:  MOVLW  26
0E9B2:  MOVWF  FF7
0E9B4:  MOVLW  00
0E9B6:  MOVWF  FF8
0E9B8:  CLRF   1B
0E9BA:  BTFSC  FF2.7
0E9BC:  BSF    1B.7
0E9BE:  BCF    FF2.7
0E9C0:  MOVLW  05
0E9C2:  MOVLB  A
0E9C4:  MOVWF  x40
0E9C6:  MOVLB  0
0E9C8:  CALL   1044
0E9CC:  BTFSC  1B.7
0E9CE:  BSF    FF2.7
0E9D0:  CLRF   1B
0E9D2:  BTFSC  FF2.7
0E9D4:  BSF    1B.7
0E9D6:  BCF    FF2.7
0E9D8:  MOVFF  73B,A40
0E9DC:  MOVLW  01
0E9DE:  MOVLB  A
0E9E0:  MOVWF  x41
0E9E2:  MOVLB  0
0E9E4:  CALL   0FC6
0E9E8:  BTFSC  1B.7
0E9EA:  BSF    FF2.7
0E9EC:  MOVLW  2F
0E9EE:  BTFSS  F9E.4
0E9F0:  BRA    E9EE
0E9F2:  MOVWF  FAD
0E9F4:  CLRF   1B
0E9F6:  BTFSC  FF2.7
0E9F8:  BSF    1B.7
0E9FA:  BCF    FF2.7
0E9FC:  MOVFF  73A,A40
0EA00:  MOVLW  01
0EA02:  MOVLB  A
0EA04:  MOVWF  x41
0EA06:  MOVLB  0
0EA08:  CALL   0FC6
0EA0C:  BTFSC  1B.7
0EA0E:  BSF    FF2.7
0EA10:  MOVLW  2F
0EA12:  BTFSS  F9E.4
0EA14:  BRA    EA12
0EA16:  MOVWF  FAD
0EA18:  CLRF   1B
0EA1A:  BTFSC  FF2.7
0EA1C:  BSF    1B.7
0EA1E:  BCF    FF2.7
0EA20:  MOVFF  73C,A40
0EA24:  MOVLW  01
0EA26:  MOVLB  A
0EA28:  MOVWF  x41
0EA2A:  MOVLB  0
0EA2C:  CALL   0FC6
0EA30:  BTFSC  1B.7
0EA32:  BSF    FF2.7
0EA34:  MOVLW  20
0EA36:  BTFSS  F9E.4
0EA38:  BRA    EA36
0EA3A:  MOVWF  FAD
0EA3C:  CLRF   1B
0EA3E:  BTFSC  FF2.7
0EA40:  BSF    1B.7
0EA42:  BCF    FF2.7
0EA44:  MOVFF  73D,A40
0EA48:  MOVLW  01
0EA4A:  MOVLB  A
0EA4C:  MOVWF  x41
0EA4E:  MOVLB  0
0EA50:  CALL   0FC6
0EA54:  BTFSC  1B.7
0EA56:  BSF    FF2.7
0EA58:  MOVLW  3A
0EA5A:  BTFSS  F9E.4
0EA5C:  BRA    EA5A
0EA5E:  MOVWF  FAD
0EA60:  CLRF   1B
0EA62:  BTFSC  FF2.7
0EA64:  BSF    1B.7
0EA66:  BCF    FF2.7
0EA68:  MOVFF  73E,A40
0EA6C:  MOVLW  01
0EA6E:  MOVLB  A
0EA70:  MOVWF  x41
0EA72:  MOVLB  0
0EA74:  CALL   0FC6
0EA78:  BTFSC  1B.7
0EA7A:  BSF    FF2.7
0EA7C:  MOVLW  3A
0EA7E:  BTFSS  F9E.4
0EA80:  BRA    EA7E
0EA82:  MOVWF  FAD
0EA84:  CLRF   1B
0EA86:  BTFSC  FF2.7
0EA88:  BSF    1B.7
0EA8A:  BCF    FF2.7
0EA8C:  MOVFF  73F,A40
0EA90:  MOVLW  01
0EA92:  MOVLB  A
0EA94:  MOVWF  x41
0EA96:  MOVLB  0
0EA98:  CALL   0FC6
0EA9C:  BTFSC  1B.7
0EA9E:  BSF    FF2.7
0EAA0:  MOVLW  0D
0EAA2:  BTFSS  F9E.4
0EAA4:  BRA    EAA2
0EAA6:  MOVWF  FAD
0EAA8:  MOVLW  0A
0EAAA:  BTFSS  F9E.4
0EAAC:  BRA    EAAA
0EAAE:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0EAB0:  RCALL  E444
....................       RTC_display_alarm(); 
0EAB2:  RCALL  E51A
....................    } 
0EAB4:  GOTO   F2C8 (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0EAB8:  DECFSZ 48,W
0EABA:  BRA    ED92
0EABC:  MOVF   49,F
0EABE:  BTFSS  FD8.2
0EAC0:  BRA    ED92
0EAC2:  MOVF   4A,F
0EAC4:  BTFSS  FD8.2
0EAC6:  BRA    ED92
0EAC8:  MOVF   4B,F
0EACA:  BTFSS  FD8.2
0EACC:  BRA    ED92
....................       v_supply = read_supply(); 
0EACE:  CALL   5124
0EAD2:  MOVFF  02,886
0EAD6:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0EADA:  CALL   34DA
....................       RTC_read(); 
0EADE:  CALL   336C
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0EAE2:  MOVLW  41
0EAE4:  BTFSS  F9E.4
0EAE6:  BRA    EAE4
0EAE8:  MOVWF  FAD
0EAEA:  MOVLW  10
0EAEC:  MOVWF  FE9
0EAEE:  CLRF   1B
0EAF0:  BTFSC  FF2.7
0EAF2:  BSF    1B.7
0EAF4:  BCF    FF2.7
0EAF6:  MOVFF  2A,A41
0EAFA:  MOVFF  29,A40
0EAFE:  CALL   11C6
0EB02:  BTFSC  1B.7
0EB04:  BSF    FF2.7
0EB06:  MOVLW  20
0EB08:  BTFSS  F9E.4
0EB0A:  BRA    EB08
0EB0C:  MOVWF  FAD
0EB0E:  MOVLW  49
0EB10:  BTFSS  F9E.4
0EB12:  BRA    EB10
0EB14:  MOVWF  FAD
0EB16:  MOVLW  10
0EB18:  MOVWF  FE9
0EB1A:  CLRF   1B
0EB1C:  BTFSC  FF2.7
0EB1E:  BSF    1B.7
0EB20:  BCF    FF2.7
0EB22:  MOVFF  24,A41
0EB26:  MOVFF  23,A40
0EB2A:  CALL   11C6
0EB2E:  BTFSC  1B.7
0EB30:  BSF    FF2.7
0EB32:  MOVLW  20
0EB34:  BTFSS  F9E.4
0EB36:  BRA    EB34
0EB38:  MOVWF  FAD
0EB3A:  MOVLW  4C
0EB3C:  BTFSS  F9E.4
0EB3E:  BRA    EB3C
0EB40:  MOVWF  FAD
0EB42:  MOVLW  10
0EB44:  MOVWF  FE9
0EB46:  CLRF   1B
0EB48:  BTFSC  FF2.7
0EB4A:  BSF    1B.7
0EB4C:  BCF    FF2.7
0EB4E:  MOVFF  2C,A41
0EB52:  MOVFF  2B,A40
0EB56:  CALL   11C6
0EB5A:  BTFSC  1B.7
0EB5C:  BSF    FF2.7
0EB5E:  MOVLW  20
0EB60:  BTFSS  F9E.4
0EB62:  BRA    EB60
0EB64:  MOVWF  FAD
0EB66:  MOVLW  51
0EB68:  BTFSS  F9E.4
0EB6A:  BRA    EB68
0EB6C:  MOVWF  FAD
0EB6E:  MOVLW  10
0EB70:  MOVWF  FE9
0EB72:  CLRF   1B
0EB74:  BTFSC  FF2.7
0EB76:  BSF    1B.7
0EB78:  BCF    FF2.7
0EB7A:  MOVFF  2E,A41
0EB7E:  MOVFF  2D,A40
0EB82:  CALL   11C6
0EB86:  BTFSC  1B.7
0EB88:  BSF    FF2.7
0EB8A:  MOVLW  20
0EB8C:  BTFSS  F9E.4
0EB8E:  BRA    EB8C
0EB90:  MOVWF  FAD
0EB92:  MOVLW  53
0EB94:  BTFSS  F9E.4
0EB96:  BRA    EB94
0EB98:  MOVWF  FAD
0EB9A:  MOVLW  10
0EB9C:  MOVWF  FE9
0EB9E:  CLRF   1B
0EBA0:  BTFSC  FF2.7
0EBA2:  BSF    1B.7
0EBA4:  BCF    FF2.7
0EBA6:  MOVFF  22,A41
0EBAA:  MOVFF  21,A40
0EBAE:  CALL   11C6
0EBB2:  BTFSC  1B.7
0EBB4:  BSF    FF2.7
0EBB6:  MOVLW  20
0EBB8:  BTFSS  F9E.4
0EBBA:  BRA    EBB8
0EBBC:  MOVWF  FAD
0EBBE:  MOVLW  04
0EBC0:  MOVWF  FE9
0EBC2:  MOVLB  8
0EBC4:  CLRF   x8A
0EBC6:  CLRF   x89
0EBC8:  MOVFF  886,888
0EBCC:  MOVFF  885,887
0EBD0:  MOVLW  02
0EBD2:  MOVWF  x8B
0EBD4:  MOVLB  0
0EBD6:  CALL   E1BE
0EBDA:  MOVLW  46
0EBDC:  MOVWF  FF6
0EBDE:  MOVLW  26
0EBE0:  MOVWF  FF7
0EBE2:  MOVLW  00
0EBE4:  MOVWF  FF8
0EBE6:  CLRF   1B
0EBE8:  BTFSC  FF2.7
0EBEA:  BSF    1B.7
0EBEC:  BCF    FF2.7
0EBEE:  MOVLW  03
0EBF0:  MOVLB  A
0EBF2:  MOVWF  x40
0EBF4:  MOVLB  0
0EBF6:  CALL   1044
0EBFA:  BTFSC  1B.7
0EBFC:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0EBFE:  MOVLW  4A
0EC00:  MOVWF  FF6
0EC02:  MOVLW  26
0EC04:  MOVWF  FF7
0EC06:  MOVLW  00
0EC08:  MOVWF  FF8
0EC0A:  CLRF   1B
0EC0C:  BTFSC  FF2.7
0EC0E:  BSF    1B.7
0EC10:  BCF    FF2.7
0EC12:  MOVLW  09
0EC14:  MOVLB  A
0EC16:  MOVWF  x40
0EC18:  MOVLB  0
0EC1A:  CALL   1044
0EC1E:  BTFSC  1B.7
0EC20:  BSF    FF2.7
0EC22:  MOVLW  10
0EC24:  MOVWF  FE9
0EC26:  CLRF   1B
0EC28:  BTFSC  FF2.7
0EC2A:  BSF    1B.7
0EC2C:  BCF    FF2.7
0EC2E:  MOVFF  7C4,A41
0EC32:  MOVFF  7C3,A40
0EC36:  CALL   11C6
0EC3A:  BTFSC  1B.7
0EC3C:  BSF    FF2.7
0EC3E:  MOVLW  56
0EC40:  MOVWF  FF6
0EC42:  MOVLW  26
0EC44:  MOVWF  FF7
0EC46:  MOVLW  00
0EC48:  MOVWF  FF8
0EC4A:  CLRF   1B
0EC4C:  BTFSC  FF2.7
0EC4E:  BSF    1B.7
0EC50:  BCF    FF2.7
0EC52:  MOVLW  05
0EC54:  MOVLB  A
0EC56:  MOVWF  x40
0EC58:  MOVLB  0
0EC5A:  CALL   1044
0EC5E:  BTFSC  1B.7
0EC60:  BSF    FF2.7
0EC62:  MOVLW  10
0EC64:  MOVWF  FE9
0EC66:  MOVFF  7B6,8F1
0EC6A:  MOVFF  7B5,8F0
0EC6E:  CALL   900C
0EC72:  MOVLW  0D
0EC74:  BTFSS  F9E.4
0EC76:  BRA    EC74
0EC78:  MOVWF  FAD
0EC7A:  MOVLW  0A
0EC7C:  BTFSS  F9E.4
0EC7E:  BRA    EC7C
0EC80:  MOVWF  FAD
....................       RTC_display(); 
0EC82:  CALL   E2BA
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EC86:  MOVLW  62
0EC88:  MOVWF  FF6
0EC8A:  MOVLW  26
0EC8C:  MOVWF  FF7
0EC8E:  MOVLW  00
0EC90:  MOVWF  FF8
0EC92:  CLRF   1B
0EC94:  BTFSC  FF2.7
0EC96:  BSF    1B.7
0EC98:  BCF    FF2.7
0EC9A:  MOVLW  05
0EC9C:  MOVLB  A
0EC9E:  MOVWF  x40
0ECA0:  MOVLB  0
0ECA2:  CALL   1044
0ECA6:  BTFSC  1B.7
0ECA8:  BSF    FF2.7
0ECAA:  CLRF   1B
0ECAC:  BTFSC  FF2.7
0ECAE:  BSF    1B.7
0ECB0:  BCF    FF2.7
0ECB2:  MOVFF  73A,A40
0ECB6:  MOVLW  01
0ECB8:  MOVLB  A
0ECBA:  MOVWF  x41
0ECBC:  MOVLB  0
0ECBE:  CALL   0FC6
0ECC2:  BTFSC  1B.7
0ECC4:  BSF    FF2.7
0ECC6:  MOVLW  2F
0ECC8:  BTFSS  F9E.4
0ECCA:  BRA    ECC8
0ECCC:  MOVWF  FAD
0ECCE:  CLRF   1B
0ECD0:  BTFSC  FF2.7
0ECD2:  BSF    1B.7
0ECD4:  BCF    FF2.7
0ECD6:  MOVFF  73B,A40
0ECDA:  MOVLW  01
0ECDC:  MOVLB  A
0ECDE:  MOVWF  x41
0ECE0:  MOVLB  0
0ECE2:  CALL   0FC6
0ECE6:  BTFSC  1B.7
0ECE8:  BSF    FF2.7
0ECEA:  MOVLW  2F
0ECEC:  BTFSS  F9E.4
0ECEE:  BRA    ECEC
0ECF0:  MOVWF  FAD
0ECF2:  CLRF   1B
0ECF4:  BTFSC  FF2.7
0ECF6:  BSF    1B.7
0ECF8:  BCF    FF2.7
0ECFA:  MOVFF  73C,A40
0ECFE:  MOVLW  01
0ED00:  MOVLB  A
0ED02:  MOVWF  x41
0ED04:  MOVLB  0
0ED06:  CALL   0FC6
0ED0A:  BTFSC  1B.7
0ED0C:  BSF    FF2.7
0ED0E:  MOVLW  20
0ED10:  BTFSS  F9E.4
0ED12:  BRA    ED10
0ED14:  MOVWF  FAD
0ED16:  CLRF   1B
0ED18:  BTFSC  FF2.7
0ED1A:  BSF    1B.7
0ED1C:  BCF    FF2.7
0ED1E:  MOVFF  73D,A40
0ED22:  MOVLW  01
0ED24:  MOVLB  A
0ED26:  MOVWF  x41
0ED28:  MOVLB  0
0ED2A:  CALL   0FC6
0ED2E:  BTFSC  1B.7
0ED30:  BSF    FF2.7
0ED32:  MOVLW  3A
0ED34:  BTFSS  F9E.4
0ED36:  BRA    ED34
0ED38:  MOVWF  FAD
0ED3A:  CLRF   1B
0ED3C:  BTFSC  FF2.7
0ED3E:  BSF    1B.7
0ED40:  BCF    FF2.7
0ED42:  MOVFF  73E,A40
0ED46:  MOVLW  01
0ED48:  MOVLB  A
0ED4A:  MOVWF  x41
0ED4C:  MOVLB  0
0ED4E:  CALL   0FC6
0ED52:  BTFSC  1B.7
0ED54:  BSF    FF2.7
0ED56:  MOVLW  3A
0ED58:  BTFSS  F9E.4
0ED5A:  BRA    ED58
0ED5C:  MOVWF  FAD
0ED5E:  CLRF   1B
0ED60:  BTFSC  FF2.7
0ED62:  BSF    1B.7
0ED64:  BCF    FF2.7
0ED66:  MOVFF  73F,A40
0ED6A:  MOVLW  01
0ED6C:  MOVLB  A
0ED6E:  MOVWF  x41
0ED70:  MOVLB  0
0ED72:  CALL   0FC6
0ED76:  BTFSC  1B.7
0ED78:  BSF    FF2.7
0ED7A:  MOVLW  0D
0ED7C:  BTFSS  F9E.4
0ED7E:  BRA    ED7C
0ED80:  MOVWF  FAD
0ED82:  MOVLW  0A
0ED84:  BTFSS  F9E.4
0ED86:  BRA    ED84
0ED88:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0ED8A:  CALL   E444
....................       RTC_display_alarm(); 
0ED8E:  CALL   E51A
....................    } 
0ED92:  GOTO   F2C8 (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0F020:  DECFSZ 48,W
0F022:  BRA    F288
0F024:  MOVF   49,F
0F026:  BTFSS  FD8.2
0F028:  BRA    F288
0F02A:  MOVF   4A,F
0F02C:  BTFSS  FD8.2
0F02E:  BRA    F288
0F030:  MOVF   4B,F
0F032:  BTFSS  FD8.2
0F034:  BRA    F288
....................       v_supply = read_supply(); 
0F036:  CALL   5124
0F03A:  MOVFF  02,886
0F03E:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0F042:  CALL   34DA
....................       RTC_read(); 
0F046:  CALL   336C
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0F04A:  MOVLW  49
0F04C:  BTFSS  F9E.4
0F04E:  BRA    F04C
0F050:  MOVWF  FAD
0F052:  MOVLW  10
0F054:  MOVWF  FE9
0F056:  CLRF   1B
0F058:  BTFSC  FF2.7
0F05A:  BSF    1B.7
0F05C:  BCF    FF2.7
0F05E:  MOVFF  24,A41
0F062:  MOVFF  23,A40
0F066:  CALL   11C6
0F06A:  BTFSC  1B.7
0F06C:  BSF    FF2.7
0F06E:  MOVLW  20
0F070:  BTFSS  F9E.4
0F072:  BRA    F070
0F074:  MOVWF  FAD
0F076:  MOVLW  4E
0F078:  BTFSS  F9E.4
0F07A:  BRA    F078
0F07C:  MOVWF  FAD
0F07E:  MOVLW  10
0F080:  MOVWF  FE9
0F082:  CLRF   1B
0F084:  BTFSC  FF2.7
0F086:  BSF    1B.7
0F088:  BCF    FF2.7
0F08A:  MOVFF  22,A41
0F08E:  MOVFF  21,A40
0F092:  CALL   11C6
0F096:  BTFSC  1B.7
0F098:  BSF    FF2.7
0F09A:  MOVLW  2F
0F09C:  BTFSS  F9E.4
0F09E:  BRA    F09C
0F0A0:  MOVWF  FAD
0F0A2:  MOVLW  10
0F0A4:  MOVWF  FE9
0F0A6:  CLRF   1B
0F0A8:  BTFSC  FF2.7
0F0AA:  BSF    1B.7
0F0AC:  BCF    FF2.7
0F0AE:  MOVFF  28,A41
0F0B2:  MOVFF  27,A40
0F0B6:  CALL   11C6
0F0BA:  BTFSC  1B.7
0F0BC:  BSF    FF2.7
0F0BE:  MOVLW  20
0F0C0:  BTFSS  F9E.4
0F0C2:  BRA    F0C0
0F0C4:  MOVWF  FAD
0F0C6:  MOVLW  50
0F0C8:  BTFSS  F9E.4
0F0CA:  BRA    F0C8
0F0CC:  MOVWF  FAD
0F0CE:  MOVLW  10
0F0D0:  MOVWF  FE9
0F0D2:  CLRF   1B
0F0D4:  BTFSC  FF2.7
0F0D6:  BSF    1B.7
0F0D8:  BCF    FF2.7
0F0DA:  MOVFF  2E,A41
0F0DE:  MOVFF  2D,A40
0F0E2:  CALL   11C6
0F0E6:  BTFSC  1B.7
0F0E8:  BSF    FF2.7
0F0EA:  MOVLW  20
0F0EC:  BTFSS  F9E.4
0F0EE:  BRA    F0EC
0F0F0:  MOVWF  FAD
0F0F2:  MOVLW  04
0F0F4:  MOVWF  FE9
0F0F6:  MOVLB  8
0F0F8:  CLRF   x8A
0F0FA:  CLRF   x89
0F0FC:  MOVFF  886,888
0F100:  MOVFF  885,887
0F104:  MOVLW  02
0F106:  MOVWF  x8B
0F108:  MOVLB  0
0F10A:  CALL   E1BE
0F10E:  MOVLW  A0
0F110:  MOVWF  FF6
0F112:  MOVLW  26
0F114:  MOVWF  FF7
0F116:  MOVLW  00
0F118:  MOVWF  FF8
0F11A:  CLRF   1B
0F11C:  BTFSC  FF2.7
0F11E:  BSF    1B.7
0F120:  BCF    FF2.7
0F122:  MOVLW  03
0F124:  MOVLB  A
0F126:  MOVWF  x40
0F128:  MOVLB  0
0F12A:  CALL   1044
0F12E:  BTFSC  1B.7
0F130:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0F132:  MOVLW  A4
0F134:  MOVWF  FF6
0F136:  MOVLW  26
0F138:  MOVWF  FF7
0F13A:  MOVLW  00
0F13C:  MOVWF  FF8
0F13E:  CLRF   1B
0F140:  BTFSC  FF2.7
0F142:  BSF    1B.7
0F144:  BCF    FF2.7
0F146:  MOVLW  09
0F148:  MOVLB  A
0F14A:  MOVWF  x40
0F14C:  MOVLB  0
0F14E:  CALL   1044
0F152:  BTFSC  1B.7
0F154:  BSF    FF2.7
0F156:  MOVLW  10
0F158:  MOVWF  FE9
0F15A:  MOVFF  7B6,8F1
0F15E:  MOVFF  7B5,8F0
0F162:  CALL   900C
0F166:  MOVLW  0D
0F168:  BTFSS  F9E.4
0F16A:  BRA    F168
0F16C:  MOVWF  FAD
0F16E:  MOVLW  0A
0F170:  BTFSS  F9E.4
0F172:  BRA    F170
0F174:  MOVWF  FAD
....................       display_valve_status(); 
0F176:  RCALL  ED96
....................       RTC_display(); 
0F178:  CALL   E2BA
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0F17C:  MOVLW  B4
0F17E:  MOVWF  FF6
0F180:  MOVLW  26
0F182:  MOVWF  FF7
0F184:  MOVLW  00
0F186:  MOVWF  FF8
0F188:  CLRF   1B
0F18A:  BTFSC  FF2.7
0F18C:  BSF    1B.7
0F18E:  BCF    FF2.7
0F190:  MOVLW  05
0F192:  MOVLB  A
0F194:  MOVWF  x40
0F196:  MOVLB  0
0F198:  CALL   1044
0F19C:  BTFSC  1B.7
0F19E:  BSF    FF2.7
0F1A0:  CLRF   1B
0F1A2:  BTFSC  FF2.7
0F1A4:  BSF    1B.7
0F1A6:  BCF    FF2.7
0F1A8:  MOVFF  73A,A40
0F1AC:  MOVLW  01
0F1AE:  MOVLB  A
0F1B0:  MOVWF  x41
0F1B2:  MOVLB  0
0F1B4:  CALL   0FC6
0F1B8:  BTFSC  1B.7
0F1BA:  BSF    FF2.7
0F1BC:  MOVLW  2F
0F1BE:  BTFSS  F9E.4
0F1C0:  BRA    F1BE
0F1C2:  MOVWF  FAD
0F1C4:  CLRF   1B
0F1C6:  BTFSC  FF2.7
0F1C8:  BSF    1B.7
0F1CA:  BCF    FF2.7
0F1CC:  MOVFF  73B,A40
0F1D0:  MOVLW  01
0F1D2:  MOVLB  A
0F1D4:  MOVWF  x41
0F1D6:  MOVLB  0
0F1D8:  CALL   0FC6
0F1DC:  BTFSC  1B.7
0F1DE:  BSF    FF2.7
0F1E0:  MOVLW  2F
0F1E2:  BTFSS  F9E.4
0F1E4:  BRA    F1E2
0F1E6:  MOVWF  FAD
0F1E8:  CLRF   1B
0F1EA:  BTFSC  FF2.7
0F1EC:  BSF    1B.7
0F1EE:  BCF    FF2.7
0F1F0:  MOVFF  73C,A40
0F1F4:  MOVLW  01
0F1F6:  MOVLB  A
0F1F8:  MOVWF  x41
0F1FA:  MOVLB  0
0F1FC:  CALL   0FC6
0F200:  BTFSC  1B.7
0F202:  BSF    FF2.7
0F204:  MOVLW  20
0F206:  BTFSS  F9E.4
0F208:  BRA    F206
0F20A:  MOVWF  FAD
0F20C:  CLRF   1B
0F20E:  BTFSC  FF2.7
0F210:  BSF    1B.7
0F212:  BCF    FF2.7
0F214:  MOVFF  73D,A40
0F218:  MOVLW  01
0F21A:  MOVLB  A
0F21C:  MOVWF  x41
0F21E:  MOVLB  0
0F220:  CALL   0FC6
0F224:  BTFSC  1B.7
0F226:  BSF    FF2.7
0F228:  MOVLW  3A
0F22A:  BTFSS  F9E.4
0F22C:  BRA    F22A
0F22E:  MOVWF  FAD
0F230:  CLRF   1B
0F232:  BTFSC  FF2.7
0F234:  BSF    1B.7
0F236:  BCF    FF2.7
0F238:  MOVFF  73E,A40
0F23C:  MOVLW  01
0F23E:  MOVLB  A
0F240:  MOVWF  x41
0F242:  MOVLB  0
0F244:  CALL   0FC6
0F248:  BTFSC  1B.7
0F24A:  BSF    FF2.7
0F24C:  MOVLW  3A
0F24E:  BTFSS  F9E.4
0F250:  BRA    F24E
0F252:  MOVWF  FAD
0F254:  CLRF   1B
0F256:  BTFSC  FF2.7
0F258:  BSF    1B.7
0F25A:  BCF    FF2.7
0F25C:  MOVFF  73F,A40
0F260:  MOVLW  01
0F262:  MOVLB  A
0F264:  MOVWF  x41
0F266:  MOVLB  0
0F268:  CALL   0FC6
0F26C:  BTFSC  1B.7
0F26E:  BSF    FF2.7
0F270:  MOVLW  0D
0F272:  BTFSS  F9E.4
0F274:  BRA    F272
0F276:  MOVWF  FAD
0F278:  MOVLW  0A
0F27A:  BTFSS  F9E.4
0F27C:  BRA    F27A
0F27E:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0F280:  CALL   E444
....................       RTC_display_alarm(); 
0F284:  CALL   E51A
....................    } 
0F288:  GOTO   F2C8 (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0F28C:  MOVF   2F,W
0F28E:  MOVWF  00
0F290:  MOVF   30,W
0F292:  MOVWF  03
0F294:  BNZ   F29A
0F296:  MOVF   00,F
0F298:  BZ    F2BA
0F29A:  MOVF   03,W
0F29C:  BNZ   F2A4
0F29E:  MOVLW  01
0F2A0:  SUBWF  00,W
0F2A2:  BZ    F2C0
0F2A4:  MOVF   03,W
0F2A6:  BNZ   F2AE
0F2A8:  MOVLW  03
0F2AA:  SUBWF  00,W
0F2AC:  BZ    F2C0
0F2AE:  MOVF   03,W
0F2B0:  BNZ   F2B8
0F2B2:  MOVLW  02
0F2B4:  SUBWF  00,W
0F2B6:  BZ    F2C6
0F2B8:  BRA    F2C8
....................       case ECO : commandHe(); 
0F2BA:  GOTO   E694
....................          break; 
0F2BE:  BRA    F2C8
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0F2C0:  GOTO   EAB8
....................          break; 
0F2C4:  BRA    F2C8
....................       case AWS : commandHa(); 
0F2C6:  BRA    F020
....................          break;          
....................    } 
0F2C8:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0F2CC:  MOVF   48,F
0F2CE:  BNZ   F2DC
0F2D0:  MOVF   49,F
0F2D2:  BNZ   F2DC
0F2D4:  MOVF   4A,F
0F2D6:  BNZ   F2DC
0F2D8:  MOVF   4B,F
0F2DA:  BZ    F310
0F2DC:  MOVF   4B,F
0F2DE:  BNZ   F310
0F2E0:  MOVF   4A,F
0F2E2:  BNZ   F310
0F2E4:  MOVF   49,W
0F2E6:  SUBLW  FD
0F2E8:  BNC   F310
0F2EA:  BNZ   F2F2
0F2EC:  MOVF   48,W
0F2EE:  SUBLW  20
0F2F0:  BNC   F310
....................       nv_interval = arg; 
0F2F2:  MOVFF  49,24
0F2F6:  MOVFF  48,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0F2FA:  MOVLW  14
0F2FC:  MOVLB  8
0F2FE:  MOVWF  xEE
0F300:  MOVFF  24,8F0
0F304:  MOVFF  23,8EF
0F308:  MOVLB  0
0F30A:  CALL   4FFC
....................    } 
0F30E:  BRA    F314
....................    else cmd_arg(); 
0F310:  CALL   B32E
0F314:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0F318:  MOVF   4B,F
0F31A:  BNZ   F34A
0F31C:  MOVF   4A,F
0F31E:  BNZ   F34A
0F320:  MOVF   49,W
0F322:  SUBLW  27
0F324:  BNC   F34A
0F326:  BNZ   F32E
0F328:  MOVF   48,W
0F32A:  SUBLW  0F
0F32C:  BNC   F34A
....................       nv_serial = arg; 
0F32E:  MOVFF  49,26
0F332:  MOVFF  48,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0F336:  MOVLB  8
0F338:  CLRF   xEE
0F33A:  MOVFF  26,8F0
0F33E:  MOVFF  25,8EF
0F342:  MOVLB  0
0F344:  CALL   4FFC
....................    } 
0F348:  BRA    F34E
....................    else cmd_arg(); 
0F34A:  CALL   B32E
0F34E:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F572:  MOVF   2F,F
0F574:  BNZ   F5A4
0F576:  MOVF   30,F
0F578:  BNZ   F5A4
....................        
....................       if (arg > 0 && arg < 3){ 
0F57A:  MOVF   48,F
0F57C:  BNZ   F58A
0F57E:  MOVF   49,F
0F580:  BNZ   F58A
0F582:  MOVF   4A,F
0F584:  BNZ   F58A
0F586:  MOVF   4B,F
0F588:  BZ    F5A0
0F58A:  MOVF   4B,F
0F58C:  BNZ   F5A0
0F58E:  MOVF   4A,F
0F590:  BNZ   F5A0
0F592:  MOVF   49,F
0F594:  BNZ   F5A0
0F596:  MOVF   48,W
0F598:  SUBLW  02
0F59A:  BNC   F5A0
....................          det_cmd(); 
0F59C:  RCALL  F432
....................       } 
0F59E:  BRA    F5A4
....................       else cmd_arg(); 
0F5A0:  CALL   B32E
....................        
....................    } 
0F5A4:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
1045C:  MOVF   4B,F
1045E:  BNZ   104CA
10460:  MOVF   4A,F
10462:  BNZ   104CA
10464:  MOVF   49,W
10466:  SUBLW  0F
10468:  BNC   104CA
....................       switch (nv_det_type){ 
1046A:  MOVFF  45,00
1046E:  MOVF   46,W
10470:  MOVWF  03
10472:  BNZ   1047A
10474:  MOVLW  01
10476:  SUBWF  00,W
10478:  BZ    10490
1047A:  MOVF   03,W
1047C:  BNZ   10484
1047E:  MOVLW  02
10480:  SUBWF  00,W
10482:  BZ    10496
10484:  MOVF   03,W
10486:  BNZ   1048E
10488:  MOVLW  03
1048A:  SUBWF  00,W
1048C:  BZ    104B4
1048E:  BRA    104C8
....................          case 1 : det_cmd(); 
10490:  CALL   F432
....................             break; 
10494:  BRA    104C8
....................          case 2 : DAC_set(1,arg); 
10496:  MOVFF  49,886
1049A:  MOVFF  48,885
1049E:  MOVLW  01
104A0:  MOVLB  8
104A2:  MOVWF  xD3
104A4:  MOVFF  49,8D5
104A8:  MOVFF  48,8D4
104AC:  MOVLB  0
104AE:  CALL   F5A8
....................             break; 
104B2:  BRA    104C8
....................          case 3 : set_LED(arg); 
104B4:  MOVFF  49,886
104B8:  MOVFF  48,885
104BC:  MOVFF  49,8C6
104C0:  MOVFF  48,8C5
104C4:  CALL   F8F6
....................             break; 
....................       } 
....................    } 
104C8:  BRA    10528
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
104CA:  MOVF   4B,F
104CC:  BNZ   104E2
104CE:  MOVF   4A,F
104D0:  BNZ   104E2
104D2:  MOVF   49,W
104D4:  SUBLW  4D
104D6:  BC    1050C
104D8:  XORLW  FF
104DA:  BNZ   104E2
104DC:  MOVF   48,W
104DE:  SUBLW  20
104E0:  BC    1050C
104E2:  MOVF   4B,F
104E4:  BNZ   1050C
104E6:  MOVF   4A,F
104E8:  BNZ   1050C
104EA:  MOVF   49,W
104EC:  SUBLW  4E
104EE:  BNC   1050C
104F0:  BNZ   104F8
104F2:  MOVF   48,W
104F4:  SUBLW  22
104F6:  BNC   1050C
104F8:  MOVFF  49,886
104FC:  MOVFF  48,885
10500:  MOVFF  49,888
10504:  MOVFF  48,887
10508:  BRA    10314
1050A:  BRA    10528
....................    else if(arg==30001)set_LED_test(); 
1050C:  MOVF   48,W
1050E:  SUBLW  31
10510:  BNZ   10524
10512:  MOVF   49,W
10514:  SUBLW  75
10516:  BNZ   10524
10518:  MOVF   4A,F
1051A:  BNZ   10524
1051C:  MOVF   4B,F
1051E:  BNZ   10524
10520:  BRA    103D0
10522:  BRA    10528
....................    else cmd_arg(); 
10524:  CALL   B32E
10528:  GOTO   10556 (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
*
0FF9A:  MOVF   4B,F
0FF9C:  BNZ   FFCE
0FF9E:  MOVF   4A,F
0FFA0:  BNZ   FFCE
0FFA2:  MOVF   49,W
0FFA4:  SUBLW  57
0FFA6:  BNC   FFCE
0FFA8:  BNZ   FFB0
0FFAA:  MOVF   48,W
0FFAC:  SUBLW  E4
0FFAE:  BNC   FFCE
....................       nv_volume = arg; 
0FFB0:  MOVFF  49,2C
0FFB4:  MOVFF  48,2B
....................       write16(ADDR_VOLUME, nv_volume); 
0FFB8:  MOVLW  22
0FFBA:  MOVLB  8
0FFBC:  MOVWF  xEE
0FFBE:  MOVFF  2C,8F0
0FFC2:  MOVFF  2B,8EF
0FFC6:  MOVLB  0
0FFC8:  CALL   4FFC
....................    } 
0FFCC:  BRA    FFD2
....................    else cmd_arg(); 
0FFCE:  CALL   B32E
0FFD2:  GOTO   10556 (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
*
1052C:  MOVF   2F,W
1052E:  MOVWF  00
10530:  MOVF   30,W
10532:  MOVWF  03
10534:  BNZ   1053A
10536:  MOVF   00,F
10538:  BZ    10550
1053A:  MOVF   03,W
1053C:  BNZ   10544
1053E:  MOVLW  01
10540:  SUBWF  00,W
10542:  BZ    10554
10544:  MOVF   03,W
10546:  BNZ   1054E
10548:  MOVLW  03
1054A:  SUBWF  00,W
1054C:  BZ    10554
1054E:  BRA    10556
....................       case ECO : commandLe(); 
10550:  BRA    1045C
....................          break; 
10552:  BRA    10556
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
10554:  BRA    FF9A
....................          break; 
....................    } 
10556:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
16DE6:  CALL   29E8
....................     
....................    user_quit = FALSE; 
16DEA:  CLRF   50
....................     
....................    if(arg > 0 && arg < 21) 
16DEC:  MOVF   48,F
16DEE:  BNZ   16DFC
16DF0:  MOVF   49,F
16DF2:  BNZ   16DFC
16DF4:  MOVF   4A,F
16DF6:  BNZ   16DFC
16DF8:  MOVF   4B,F
16DFA:  BZ    16E78
16DFC:  MOVF   4B,F
16DFE:  BNZ   16E78
16E00:  MOVF   4A,F
16E02:  BNZ   16E78
16E04:  MOVF   49,F
16E06:  BNZ   16E78
16E08:  MOVF   48,W
16E0A:  SUBLW  14
16E0C:  BNC   16E78
....................    { 
....................       macro = arg; 
16E0E:  MOVFF  48,886
....................       switch(nv_product){ 
16E12:  MOVFF  2F,00
16E16:  MOVF   30,W
16E18:  MOVWF  03
16E1A:  BNZ   16E20
16E1C:  MOVF   00,F
16E1E:  BZ    16E40
16E20:  MOVF   03,W
16E22:  BNZ   16E2A
16E24:  MOVLW  01
16E26:  SUBWF  00,W
16E28:  BZ    16E40
16E2A:  MOVF   03,W
16E2C:  BNZ   16E34
16E2E:  MOVLW  03
16E30:  SUBWF  00,W
16E32:  BZ    16E40
16E34:  MOVF   03,W
16E36:  BNZ   16E3E
16E38:  MOVLW  02
16E3A:  SUBWF  00,W
16E3C:  BZ    16E66
16E3E:  BRA    16E76
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
16E40:  MOVLW  01
16E42:  MOVLB  7
16E44:  ADDWF  xC3,W
16E46:  MOVLB  8
16E48:  MOVWF  x87
16E4A:  MOVLW  00
16E4C:  MOVLB  7
16E4E:  ADDWFC xC4,W
16E50:  MOVLB  8
16E52:  MOVWF  x88
16E54:  MOVFF  886,897
16E58:  MOVWF  x99
16E5A:  MOVFF  887,898
16E5E:  MOVLB  0
16E60:  CALL   153EE
....................             break; 
16E64:  BRA    16E76
....................          case AWS : play_macro(macro,nv_port); 
16E66:  MOVFF  886,897
16E6A:  MOVFF  2E,899
16E6E:  MOVFF  2D,898
16E72:  CALL   153EE
....................             break; 
....................       } 
....................    }    
16E76:  BRA    16F02
....................    else if (arg == 0) 
16E78:  MOVF   48,F
16E7A:  BNZ   16EFE
16E7C:  MOVF   49,F
16E7E:  BNZ   16EFE
16E80:  MOVF   4A,F
16E82:  BNZ   16EFE
16E84:  MOVF   4B,F
16E86:  BNZ   16EFE
....................    { 
....................       //start watchdog at beginning of logging mode 
....................       //RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
16E88:  BCF    F91.0
....................       spi_write(0x89); 
16E8A:  MOVF   FC9,W
16E8C:  MOVLW  89
16E8E:  MOVWF  FC9
16E90:  RRCF   FC7,W
16E92:  BNC   16E90
....................       spi_write(0b11111111); 
16E94:  MOVF   FC9,W
16E96:  SETF   FC9
16E98:  RRCF   FC7,W
16E9A:  BNC   16E98
....................       output_bit(RTC_CS, DISABLE); 
16E9C:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
16E9E:  BCF    F91.0
....................       spi_read(0x00); 
16EA0:  MOVF   FC9,W
16EA2:  CLRF   FC9
16EA4:  RRCF   FC7,W
16EA6:  BNC   16EA4
....................       output_bit(RTC_CS, DISABLE); 
16EA8:  BSF    F91.0
....................        
....................       MaxSamples=FALSE; 
16EAA:  CLRF   34
16EAC:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
16EAE:  MOVLW  28
16EB0:  MOVLB  8
16EB2:  MOVWF  x89
16EB4:  MOVFF  33,88A
16EB8:  MOVLB  0
16EBA:  CALL   343A
....................       if (LoggingReentry != TRUE) 
16EBE:  MOVLB  8
16EC0:  DECFSZ x85,W
16EC2:  BRA    16EC6
16EC4:  BRA    16EDE
....................       { 
....................          nv_sample = 0; 
16EC6:  CLRF   22
16EC8:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
16ECA:  MOVLW  16
16ECC:  MOVWF  xEE
16ECE:  MOVFF  22,8F0
16ED2:  MOVFF  21,8EF
16ED6:  MOVLB  0
16ED8:  CALL   4FFC
16EDC:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
16EDE:  CLRF   x85
....................       nv_macro_step = 0; 
16EE0:  CLRF   38
16EE2:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
16EE4:  MOVLW  3A
16EE6:  MOVWF  xEE
16EE8:  MOVFF  38,8F0
16EEC:  MOVFF  37,8EF
16EF0:  MOVLB  0
16EF2:  CALL   4FFC
....................       user_quit = auto_sample_ready(); 
16EF6:  BRA    16BE4
16EF8:  MOVFF  01,50
....................    } 
16EFC:  BRA    16F02
....................    else cmd_arg(); 
16EFE:  CALL   B32E
....................     
....................    busy_clear(); 
16F02:  CALL   AEE0
16F06:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
16F08:  MOVF   48,F
16F0A:  BNZ   16F18
16F0C:  MOVF   49,F
16F0E:  BNZ   16F18
16F10:  MOVF   4A,F
16F12:  BNZ   16F18
16F14:  MOVF   4B,F
16F16:  BZ    16F4C
16F18:  MOVF   4B,F
16F1A:  BNZ   16F4C
16F1C:  MOVF   4A,F
16F1E:  BNZ   16F4C
16F20:  MOVF   49,W
16F22:  SUBLW  0D
16F24:  BNC   16F4C
16F26:  BNZ   16F2E
16F28:  MOVF   48,W
16F2A:  SUBLW  AC
16F2C:  BNC   16F4C
....................       nv_max_samples = arg; 
16F2E:  MOVFF  49,28
16F32:  MOVFF  48,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
16F36:  MOVLW  18
16F38:  MOVLB  8
16F3A:  MOVWF  xEE
16F3C:  MOVFF  28,8F0
16F40:  MOVFF  27,8EF
16F44:  MOVLB  0
16F46:  CALL   4FFC
....................    } 
16F4A:  BRA    16F92
....................    else if(arg == 0) { 
16F4C:  MOVF   48,F
16F4E:  BNZ   16F8E
16F50:  MOVF   49,F
16F52:  BNZ   16F8E
16F54:  MOVF   4A,F
16F56:  BNZ   16F8E
16F58:  MOVF   4B,F
16F5A:  BNZ   16F8E
....................       nv_sample = 0; 
16F5C:  CLRF   22
16F5E:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
16F60:  MOVLW  16
16F62:  MOVLB  8
16F64:  MOVWF  xEE
16F66:  MOVFF  22,8F0
16F6A:  MOVFF  21,8EF
16F6E:  MOVLB  0
16F70:  CALL   4FFC
....................       nv_macro_step = 0; 
16F74:  CLRF   38
16F76:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16F78:  MOVLW  3A
16F7A:  MOVLB  8
16F7C:  MOVWF  xEE
16F7E:  MOVFF  38,8F0
16F82:  MOVFF  37,8EF
16F86:  MOVLB  0
16F88:  CALL   4FFC
....................    } 
16F8C:  BRA    16F92
....................    else cmd_arg(); 
16F8E:  CALL   B32E
16F92:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
170B8:  DECFSZ 48,W
170BA:  BRA    170D4
170BC:  MOVF   49,F
170BE:  BNZ   170D4
170C0:  MOVF   4A,F
170C2:  BNZ   170D4
170C4:  MOVF   4B,F
170C6:  BNZ   170D4
....................    { 
....................       bus_on(); 
170C8:  CALL   D3A0
....................       open_pipe(); 
170CC:  BRA    16FAE
....................       bus_off(); 
170CE:  CALL   D3C4
....................    } 
170D2:  BRA    170D8
....................    else cmd_arg(); 
170D4:  CALL   B32E
170D8:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
17196:  MOVLB  7
17198:  DECFSZ x41,W
1719A:  BRA    1719E
1719C:  CLRF   x40
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
1719E:  MOVF   48,F
171A0:  BNZ   171B0
171A2:  MOVF   49,F
171A4:  BNZ   171B0
171A6:  MOVF   4A,F
171A8:  BNZ   171B0
171AA:  MOVF   4B,F
171AC:  BTFSC  FD8.2
171AE:  BRA    17278
171B0:  BCF    FD8.0
171B2:  RLCF   x40,W
171B4:  CLRF   03
171B6:  ADDLW  62
171B8:  MOVWF  FE9
171BA:  MOVLW  07
171BC:  ADDWFC 03,W
171BE:  MOVWF  FEA
171C0:  MOVFF  FEC,03
171C4:  MOVF   FED,F
171C6:  MOVFF  FEF,01
171CA:  MOVF   4B,F
171CC:  BNZ   17278
171CE:  MOVF   4A,F
171D0:  BNZ   17278
171D2:  MOVF   49,W
171D4:  SUBWF  03,W
171D6:  BNC   17278
171D8:  BNZ   171E0
171DA:  MOVF   48,W
171DC:  SUBWF  01,W
171DE:  BNC   17278
....................       if(e_mode[motor]==2){     // if port mode then move 
171E0:  BCF    FD8.0
171E2:  RLCF   x40,W
171E4:  CLRF   03
171E6:  ADDLW  66
171E8:  MOVWF  FE9
171EA:  MOVLW  07
171EC:  ADDWFC 03,W
171EE:  MOVWF  FEA
171F0:  MOVFF  FEC,886
171F4:  MOVF   FED,F
171F6:  MOVFF  FEF,885
171FA:  MOVLB  8
171FC:  MOVF   x85,W
171FE:  SUBLW  02
17200:  BNZ   1726E
17202:  MOVF   x86,F
17204:  BNZ   1726E
....................          switch (nv_product){ 
17206:  MOVF   2F,W
17208:  MOVWF  00
1720A:  MOVF   30,W
1720C:  MOVWF  03
1720E:  MOVF   03,W
17210:  BNZ   1721A
17212:  MOVF   00,F
17214:  MOVLB  0
17216:  BZ    17238
17218:  MOVLB  8
1721A:  MOVF   03,W
1721C:  BNZ   17228
1721E:  MOVLW  01
17220:  SUBWF  00,W
17222:  MOVLB  0
17224:  BZ    1724A
17226:  MOVLB  8
17228:  MOVF   03,W
1722A:  BNZ   17236
1722C:  MOVLW  03
1722E:  SUBWF  00,W
17230:  MOVLB  0
17232:  BZ    1725C
17234:  MOVLB  8
17236:  BRA    1726C
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
17238:  MOVLW  01
1723A:  MOVLB  8
1723C:  MOVWF  x85
1723E:  CLRF   x86
17240:  MOVWF  x87
17242:  MOVLB  0
17244:  RCALL  170DC
....................                break;             
17246:  MOVLB  8
17248:  BRA    1726C
....................             case WMS4: command_move(0,0,1); 
1724A:  MOVLB  8
1724C:  CLRF   x85
1724E:  CLRF   x86
17250:  MOVLW  01
17252:  MOVWF  x87
17254:  MOVLB  0
17256:  RCALL  170DC
....................                break; 
17258:  MOVLB  8
1725A:  BRA    1726C
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
1725C:  MOVLB  8
1725E:  CLRF   x85
17260:  CLRF   x86
17262:  MOVLW  01
17264:  MOVWF  x87
17266:  MOVLB  0
17268:  RCALL  170DC
....................                break; 
1726A:  MOVLB  8
....................          } 
....................       } 
1726C:  BRA    17276
....................       else cmd_err();                           // else error 
1726E:  MOVLB  0
17270:  CALL   BFF0
17274:  MOVLB  8
....................    } 
17276:  BRA    17280
....................    else cmd_arg(); 
17278:  MOVLB  0
1727A:  CALL   B32E
1727E:  MOVLB  8
17280:  MOVLB  0
17282:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
17284:  MOVF   4B,F
17286:  BNZ   172B4
17288:  MOVF   4A,F
1728A:  BNZ   172B4
1728C:  MOVF   49,F
1728E:  BNZ   172B4
17290:  MOVF   48,W
17292:  SUBLW  30
17294:  BNC   172B4
....................       nv_port = arg; 
17296:  MOVFF  49,2E
1729A:  MOVFF  48,2D
....................       write16(ADDR_PORT, nv_port); 
1729E:  MOVLW  24
172A0:  MOVLB  8
172A2:  MOVWF  xEE
172A4:  MOVFF  2E,8F0
172A8:  MOVFF  2D,8EF
172AC:  MOVLB  0
172AE:  CALL   4FFC
....................    } 
172B2:  BRA    172B8
....................    else cmd_arg(); 
172B4:  CALL   B32E
172B8:  GOTO   172F4 (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
172BC:  MOVF   2F,W
172BE:  MOVWF  00
172C0:  MOVF   30,W
172C2:  MOVWF  03
172C4:  BNZ   172CA
172C6:  MOVF   00,F
172C8:  BZ    172EA
172CA:  MOVF   03,W
172CC:  BNZ   172D4
172CE:  MOVLW  01
172D0:  SUBWF  00,W
172D2:  BZ    172EE
172D4:  MOVF   03,W
172D6:  BNZ   172DE
172D8:  MOVLW  03
172DA:  SUBWF  00,W
172DC:  BZ    172EE
172DE:  MOVF   03,W
172E0:  BNZ   172E8
172E2:  MOVLW  02
172E4:  SUBWF  00,W
172E6:  BZ    172F2
172E8:  BRA    172F4
....................       case ECO : commandPe(); 
172EA:  RCALL  17196
....................          break; 
172EC:  BRA    172F4
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
172EE:  RCALL  17196
....................          break; 
172F0:  BRA    172F4
....................       case AWS : commandPa(); 
172F2:  BRA    17284
....................          break;          
....................    } 
172F4:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
17340:  MOVLB  4
17342:  DECFSZ xB6,W
17344:  BRA    17370
....................     
....................       if(arg<33){ 
17346:  MOVF   4B,F
17348:  BNZ   17368
1734A:  MOVF   4A,F
1734C:  BNZ   17368
1734E:  MOVF   49,F
17350:  BNZ   17368
17352:  MOVF   48,W
17354:  SUBLW  20
17356:  BNC   17368
....................          valve=arg;    
17358:  MOVFF  48,885
....................          sol_switch(valve); 
1735C:  MOVFF  885,8B5
17360:  MOVLB  0
17362:  CALL   14598
....................       }  
17366:  BRA    1736E
....................       else cmd_arg(); 
17368:  MOVLB  0
1736A:  CALL   B32E
....................    } 
1736E:  BRA    17376
....................    else cmd_err(); 
17370:  MOVLB  0
17372:  CALL   BFF0
17376:  GOTO   173A6 (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
172F8:  MOVF   48,F
172FA:  BNZ   17308
172FC:  MOVF   49,F
172FE:  BNZ   17308
17300:  MOVF   4A,F
17302:  BNZ   17308
17304:  MOVF   4B,F
17306:  BZ    17338
17308:  MOVF   4B,F
1730A:  BNZ   17338
1730C:  MOVF   4A,F
1730E:  BNZ   17338
17310:  MOVF   49,F
17312:  BNZ   17338
17314:  MOVF   48,W
17316:  SUBLW  32
17318:  BNC   17338
....................       nv_port = arg; 
1731A:  MOVFF  49,2E
1731E:  MOVFF  48,2D
....................       write16(ADDR_SAMPLE, nv_port); 
17322:  MOVLW  16
17324:  MOVLB  8
17326:  MOVWF  xEE
17328:  MOVFF  2E,8F0
1732C:  MOVFF  2D,8EF
17330:  MOVLB  0
17332:  CALL   4FFC
....................    } 
17336:  BRA    1733C
....................    else cmd_arg(); 
17338:  CALL   B32E
1733C:  GOTO   173A6 (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
1737A:  MOVF   2F,W
1737C:  MOVWF  00
1737E:  MOVF   30,W
17380:  MOVWF  03
17382:  BNZ   1738A
17384:  MOVLW  01
17386:  SUBWF  00,W
17388:  BZ    173A0
1738A:  MOVF   03,W
1738C:  BNZ   17394
1738E:  MOVLW  03
17390:  SUBWF  00,W
17392:  BZ    173A0
17394:  MOVF   03,W
17396:  BNZ   1739E
17398:  MOVLW  02
1739A:  SUBWF  00,W
1739C:  BZ    173A4
1739E:  BRA    173A6
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
173A0:  BRA    172F8
....................          break; 
173A2:  BRA    173A6
....................       case AWS : commandQa(); 
173A4:  BRA    17340
....................          break;          
....................    } 
173A6:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
173AA:  CALL   29E8
....................     
....................    nv_macro_step = 0; 
173AE:  CLRF   38
173B0:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
173B2:  MOVLW  3A
173B4:  MOVLB  8
173B6:  MOVWF  xEE
173B8:  MOVFF  38,8F0
173BC:  MOVFF  37,8EF
173C0:  MOVLB  0
173C2:  CALL   4FFC
....................     
....................    user_quit = FALSE; 
173C6:  CLRF   50
....................     
....................    if (arg > 0 && arg < 3501){ 
173C8:  MOVF   48,F
173CA:  BNZ   173D8
173CC:  MOVF   49,F
173CE:  BNZ   173D8
173D0:  MOVF   4A,F
173D2:  BNZ   173D8
173D4:  MOVF   4B,F
173D6:  BZ    17484
173D8:  MOVF   4B,F
173DA:  BNZ   17484
173DC:  MOVF   4A,F
173DE:  BNZ   17484
173E0:  MOVF   49,W
173E2:  SUBLW  0D
173E4:  BNC   17484
173E6:  BNZ   173EE
173E8:  MOVF   48,W
173EA:  SUBLW  AC
173EC:  BNC   17484
....................       samples = arg; 
173EE:  MOVFF  49,887
173F2:  MOVFF  48,886
....................       user_quit = FALSE; 
173F6:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
173F8:  MOVLB  8
173FA:  CLRF   x89
173FC:  CLRF   x88
173FE:  MOVF   x89,W
17400:  SUBWF  x87,W
17402:  BNC   17482
17404:  BNZ   1740C
17406:  MOVF   x86,W
17408:  SUBWF  x88,W
1740A:  BC    17482
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
1740C:  MOVLW  01
1740E:  ADDWF  x88,W
17410:  MOVWF  x8A
17412:  MOVLW  00
17414:  ADDWFC x89,W
17416:  MOVWF  x8B
17418:  MOVLW  DA
1741A:  MOVWF  FF6
1741C:  MOVLW  26
1741E:  MOVWF  FF7
17420:  MOVLW  00
17422:  MOVWF  FF8
17424:  CLRF   1B
17426:  BTFSC  FF2.7
17428:  BSF    1B.7
1742A:  BCF    FF2.7
1742C:  MOVLW  05
1742E:  MOVLB  A
17430:  MOVWF  x40
17432:  MOVLB  0
17434:  CALL   1044
17438:  BTFSC  1B.7
1743A:  BSF    FF2.7
1743C:  MOVLW  09
1743E:  MOVWF  FE9
17440:  CLRF   1B
17442:  BTFSC  FF2.7
17444:  BSF    1B.7
17446:  BCF    FF2.7
17448:  MOVFF  88B,A41
1744C:  MOVFF  88A,A40
17450:  CALL   11C6
17454:  BTFSC  1B.7
17456:  BSF    FF2.7
17458:  MOVLW  0D
1745A:  BTFSS  F9E.4
1745C:  BRA    1745A
1745E:  MOVWF  FAD
17460:  MOVLW  0A
17462:  BTFSS  F9E.4
17464:  BRA    17462
17466:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
17468:  CALL   15FD4
1746C:  MOVFF  01,885
....................          if (macro_cmd == ';') break; 
17470:  MOVLB  8
17472:  MOVF   x85,W
17474:  SUBLW  3B
17476:  BTFSC  FD8.2
17478:  BRA    17482
1747A:  INCF   x88,F
1747C:  BTFSC  FD8.2
1747E:  INCF   x89,F
17480:  BRA    173FE
17482:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
17484:  CALL   AEE0
17488:  GOTO   17648 (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
1748C:  MOVF   48,F
1748E:  BNZ   1749C
17490:  MOVF   49,F
17492:  BNZ   1749C
17494:  MOVF   4A,F
17496:  BNZ   1749C
17498:  MOVF   4B,F
1749A:  BZ    174E0
1749C:  MOVF   4B,F
1749E:  BNZ   174E0
174A0:  MOVF   4A,F
174A2:  BNZ   174E0
174A4:  MOVF   49,F
174A6:  BNZ   174E0
174A8:  MOVF   48,W
174AA:  SUBLW  2F
174AC:  BNC   174E0
....................       n=arg; 
174AE:  MOVFF  48,888
....................       port=2; 
174B2:  MOVLB  8
174B4:  CLRF   x86
174B6:  MOVLW  02
174B8:  MOVWF  x85
....................       for(i=0;i<n;++i){ 
174BA:  CLRF   x87
174BC:  MOVF   x88,W
174BE:  SUBWF  x87,W
174C0:  BC    174DC
....................          play_wms_hard_macro(port); 
174C2:  MOVFF  886,88A
174C6:  MOVFF  885,889
174CA:  MOVLB  0
174CC:  CALL   D830
....................          ++port; 
174D0:  MOVLB  8
174D2:  INCF   x85,F
174D4:  BTFSC  FD8.2
174D6:  INCF   x86,F
174D8:  INCF   x87,F
174DA:  BRA    174BC
....................       } 
....................    } 
174DC:  BRA    174E6
174DE:  MOVLB  0
....................    else cmd_arg(); 
174E0:  CALL   B32E
174E4:  MOVLB  8
174E6:  MOVLB  0
174E8:  GOTO   17648 (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
174EC:  CALL   29E8
....................     
....................    nv_macro_step = 0; 
174F0:  CLRF   38
174F2:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
174F4:  MOVLW  3A
174F6:  MOVLB  8
174F8:  MOVWF  xEE
174FA:  MOVFF  38,8F0
174FE:  MOVFF  37,8EF
17502:  MOVLB  0
17504:  CALL   4FFC
....................     
....................    user_quit = FALSE; 
17508:  CLRF   50
....................     
....................    if (arg > 0 && arg < 241){ 
1750A:  MOVF   48,F
1750C:  BNZ   1751C
1750E:  MOVF   49,F
17510:  BNZ   1751C
17512:  MOVF   4A,F
17514:  BNZ   1751C
17516:  MOVF   4B,F
17518:  BTFSC  FD8.2
1751A:  BRA    17608
1751C:  MOVF   4B,F
1751E:  BTFSS  FD8.2
17520:  BRA    17608
17522:  MOVF   4A,F
17524:  BTFSS  FD8.2
17526:  BRA    17608
17528:  MOVF   49,F
1752A:  BTFSS  FD8.2
1752C:  BRA    17608
1752E:  MOVF   48,W
17530:  SUBLW  F0
17532:  BNC   17608
....................       samples = arg; 
17534:  MOVFF  49,887
17538:  MOVFF  48,886
....................       user_quit = FALSE; 
1753C:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
1753E:  MOVLB  8
17540:  CLRF   x89
17542:  CLRF   x88
17544:  MOVF   x89,W
17546:  SUBWF  x87,W
17548:  BNC   17606
1754A:  BNZ   17552
1754C:  MOVF   x86,W
1754E:  SUBWF  x88,W
17550:  BC    17606
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
17552:  MOVLW  01
17554:  ADDWF  x88,W
17556:  MOVWF  x8A
17558:  MOVLW  00
1755A:  ADDWFC x89,W
1755C:  MOVWF  x8B
1755E:  MOVLW  E8
17560:  MOVWF  FF6
17562:  MOVLW  26
17564:  MOVWF  FF7
17566:  MOVLW  00
17568:  MOVWF  FF8
1756A:  CLRF   1B
1756C:  BTFSC  FF2.7
1756E:  BSF    1B.7
17570:  BCF    FF2.7
17572:  MOVLW  05
17574:  MOVLB  A
17576:  MOVWF  x40
17578:  MOVLB  0
1757A:  CALL   1044
1757E:  BTFSC  1B.7
17580:  BSF    FF2.7
17582:  MOVLW  09
17584:  MOVWF  FE9
17586:  CLRF   1B
17588:  BTFSC  FF2.7
1758A:  BSF    1B.7
1758C:  BCF    FF2.7
1758E:  MOVFF  88B,A41
17592:  MOVFF  88A,A40
17596:  CALL   11C6
1759A:  BTFSC  1B.7
1759C:  BSF    FF2.7
1759E:  MOVLW  0D
175A0:  BTFSS  F9E.4
175A2:  BRA    175A0
175A4:  MOVWF  FAD
175A6:  MOVLW  0A
175A8:  BTFSS  F9E.4
175AA:  BRA    175A8
175AC:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
175AE:  MOVLW  01
175B0:  MOVLB  8
175B2:  ADDWF  x88,W
175B4:  MOVWF  x8A
175B6:  MOVLW  00
175B8:  ADDWFC x89,W
175BA:  MOVWF  x8B
175BC:  MOVWF  x8D
175BE:  MOVFF  88A,88C
175C2:  MOVLB  0
175C4:  CALL   1688A
175C8:  MOVFF  01,885
....................          ++nv_sample;                     // increment sample number 
175CC:  INCF   21,F
175CE:  BTFSC  FD8.2
175D0:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
175D2:  MOVLW  16
175D4:  MOVLB  8
175D6:  MOVWF  xEE
175D8:  MOVFF  22,8F0
175DC:  MOVFF  21,8EF
175E0:  MOVLB  0
175E2:  CALL   4FFC
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
175E6:  MOVF   27,W
175E8:  SUBWF  21,W
175EA:  BNZ   175F2
175EC:  MOVF   28,W
175EE:  SUBWF  22,W
175F0:  BZ    175FA
175F2:  MOVLB  8
175F4:  MOVF   x85,W
175F6:  SUBLW  3B
175F8:  BNZ   175FE
175FA:  MOVLB  8
175FC:  BRA    17606
175FE:  INCF   x88,F
17600:  BTFSC  FD8.2
17602:  INCF   x89,F
17604:  BRA    17544
17606:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
17608:  CALL   AEE0
1760C:  GOTO   17648 (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
17610:  MOVF   2F,W
17612:  MOVWF  00
17614:  MOVF   30,W
17616:  MOVWF  03
17618:  BNZ   1761E
1761A:  MOVF   00,F
1761C:  BZ    1763E
1761E:  MOVF   03,W
17620:  BNZ   17628
17622:  MOVLW  01
17624:  SUBWF  00,W
17626:  BZ    17642
17628:  MOVF   03,W
1762A:  BNZ   17632
1762C:  MOVLW  03
1762E:  SUBWF  00,W
17630:  BZ    17642
17632:  MOVF   03,W
17634:  BNZ   1763C
17636:  MOVLW  02
17638:  SUBWF  00,W
1763A:  BZ    17646
1763C:  BRA    17648
....................       case ECO : commandRe(); 
1763E:  BRA    173AA
....................          break; 
17640:  BRA    17648
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
17642:  BRA    1748C
....................          break; 
17644:  BRA    17648
....................       case AWS : commandRa(); 
17646:  BRA    174EC
....................          break;          
....................    } 
17648:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
1764C:  CALL   29E8
....................     
....................    switch(arg){ 
17650:  MOVFF  48,00
17654:  MOVF   49,W
17656:  MOVWF  03
17658:  BNZ   17660
1765A:  MOVLW  01
1765C:  SUBWF  00,W
1765E:  BZ    1766C
17660:  MOVF   03,W
17662:  BNZ   1766A
17664:  MOVLW  02
17666:  SUBWF  00,W
17668:  BZ    176B0
1766A:  BRA    176C0
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
1766C:  DECFSZ 45,W
1766E:  BRA    17684
17670:  MOVF   46,F
17672:  BNZ   17684
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
17674:  MOVLB  8
17676:  CLRF   xC2
17678:  MOVLW  01
1767A:  MOVWF  xC3
1767C:  MOVLB  0
1767E:  CALL   1375A
....................       } 
17682:  BRA    176AE
....................       else if(nv_det_type==2 || nv_det_type==3) 
17684:  MOVF   45,W
17686:  SUBLW  02
17688:  BNZ   1768E
1768A:  MOVF   46,F
1768C:  BZ    17698
1768E:  MOVF   45,W
17690:  SUBLW  03
17692:  BNZ   176AE
17694:  MOVF   46,F
17696:  BNZ   176AE
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
17698:  MOVLB  8
1769A:  CLRF   xC3
1769C:  MOVLW  C8
1769E:  MOVWF  xC2
176A0:  CLRF   xC4
176A2:  MOVLW  01
176A4:  MOVWF  xC5
176A6:  CLRF   xC6
176A8:  MOVLB  0
176AA:  CALL   100B6
....................       } 
....................       break;                                                        //200 scans,don't store,display 
176AE:  BRA    176C4
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
176B0:  MOVLB  8
176B2:  CLRF   xC2
176B4:  MOVLW  01
176B6:  MOVWF  xC3
176B8:  MOVLB  0
176BA:  CALL   13A5C
....................       break; 
176BE:  BRA    176C4
....................    default: cmd_arg(); 
176C0:  CALL   B32E
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
176C4:  CALL   AEE0
176C8:  GOTO   17774 (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
176CC:  MOVF   4B,F
176CE:  BNZ   17700
176D0:  MOVF   4A,F
176D2:  BNZ   17700
176D4:  MOVF   49,W
176D6:  SUBLW  04
176D8:  BNC   17700
176DA:  BNZ   176E2
176DC:  MOVF   48,W
176DE:  SUBLW  00
176E0:  BNC   17700
....................       nv_sample = arg; 
176E2:  MOVFF  49,22
176E6:  MOVFF  48,21
....................       write16(ADDR_SAMPLE, nv_sample); 
176EA:  MOVLW  16
176EC:  MOVLB  8
176EE:  MOVWF  xEE
176F0:  MOVFF  22,8F0
176F4:  MOVFF  21,8EF
176F8:  MOVLB  0
176FA:  CALL   4FFC
....................    } 
176FE:  BRA    17704
....................    else cmd_arg(); 
17700:  CALL   B32E
17704:  GOTO   17774 (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
17708:  MOVF   4B,F
1770A:  BNZ   17734
1770C:  MOVF   4A,F
1770E:  BNZ   17734
17710:  MOVF   49,W
17712:  SUBLW  01
17714:  BNC   17734
17716:  BNZ   1771E
17718:  MOVF   48,W
1771A:  SUBLW  02
1771C:  BNC   17734
....................       setting = arg; 
1771E:  MOVFF  49,886
17722:  MOVFF  48,885
....................       sol_switch_cmd(setting); 
17726:  MOVFF  886,8B7
1772A:  MOVFF  885,8B6
1772E:  CALL   144E2
....................    } 
17732:  BRA    17738
....................    else cmd_arg(); 
17734:  CALL   B32E
17738:  GOTO   17774 (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
1773C:  MOVF   2F,W
1773E:  MOVWF  00
17740:  MOVF   30,W
17742:  MOVWF  03
17744:  BNZ   1774A
17746:  MOVF   00,F
17748:  BZ    1776A
1774A:  MOVF   03,W
1774C:  BNZ   17754
1774E:  MOVLW  01
17750:  SUBWF  00,W
17752:  BZ    1776E
17754:  MOVF   03,W
17756:  BNZ   1775E
17758:  MOVLW  03
1775A:  SUBWF  00,W
1775C:  BZ    1776E
1775E:  MOVF   03,W
17760:  BNZ   17768
17762:  MOVLW  02
17764:  SUBWF  00,W
17766:  BZ    17772
17768:  BRA    17774
....................       case ECO : commandSe(); 
1776A:  BRA    1764C
....................          break; 
1776C:  BRA    17774
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
1776E:  BRA    176CC
....................          break; 
17770:  BRA    17774
....................       case AWS : commandSa(); 
17772:  BRA    17708
....................          break;          
....................    } 
17774:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
17D64:  MOVLW  F6
17D66:  MOVWF  FF6
17D68:  MOVLW  26
17D6A:  MOVWF  FF7
17D6C:  MOVLW  00
17D6E:  MOVWF  FF8
17D70:  CLRF   1B
17D72:  BTFSC  FF2.7
17D74:  BSF    1B.7
17D76:  BCF    FF2.7
17D78:  CALL   0E6E
17D7C:  BTFSC  1B.7
17D7E:  BSF    FF2.7
....................    fputc('>',COM_A); 
17D80:  MOVLW  3E
17D82:  CALL   AEE8
....................    RTCfmt=fgetc(COM_A); 
17D86:  CALL   0E58
17D8A:  MOVFF  01,4F
....................    if (com_echo == TRUE) 
17D8E:  DECFSZ 4C,W
17D90:  BRA    17D98
....................       { 
....................       fputc(RTCfmt,COM_A); 
17D92:  MOVF   4F,W
17D94:  CALL   AEE8
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
17D98:  MOVLW  30
17D9A:  SUBWF  4F,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
17D9C:  MOVF   4F,W
17D9E:  SUBLW  01
17DA0:  BNC   17DD6
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
17DA2:  MOVLW  22
17DA4:  MOVWF  FF6
17DA6:  MOVLW  27
17DA8:  MOVWF  FF7
17DAA:  MOVLW  00
17DAC:  MOVWF  FF8
17DAE:  CALL   AEB6
17DB2:  MOVLW  0D
17DB4:  BTFSS  F9E.4
17DB6:  BRA    17DB4
17DB8:  MOVWF  FAD
17DBA:  MOVLW  0A
17DBC:  BTFSS  F9E.4
17DBE:  BRA    17DBC
17DC0:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
17DC2:  MOVLW  1A
17DC4:  MOVLB  8
17DC6:  MOVWF  xEE
17DC8:  CLRF   xF0
17DCA:  MOVFF  4F,8EF
17DCE:  MOVLB  0
17DD0:  CALL   4FFC
....................       }  
17DD4:  BRA    17DDA
....................    else cmd_arg(); 
17DD6:  CALL   B32E
....................     
....................    if(arg == 1) 
17DDA:  DECFSZ 48,W
17DDC:  BRA    17DEE
17DDE:  MOVF   49,F
17DE0:  BNZ   17DEE
17DE2:  MOVF   4A,F
17DE4:  BNZ   17DEE
17DE6:  MOVF   4B,F
17DE8:  BNZ   17DEE
....................    { 
....................       RTC_Set(); 
17DEA:  BRA    17C1A
....................    } 
17DEC:  BRA    17DF2
....................    else cmd_arg(); 
17DEE:  CALL   B32E
17DF2:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
1876C:  MOVF   4B,F
1876E:  BNZ   1878A
18770:  MOVF   4A,F
18772:  BNZ   1878A
18774:  MOVF   49,F
18776:  BNZ   1878A
18778:  MOVF   48,W
1877A:  SUBLW  14
1877C:  BNC   1878A
....................       macro = arg; 
1877E:  MOVFF  48,885
....................       upload_macro(macro);    
18782:  MOVFF  885,886
18786:  BRA    184BA
....................    }    
18788:  BRA    187A6
....................    else if (arg == 5525){ 
1878A:  MOVF   48,W
1878C:  SUBLW  95
1878E:  BNZ   187A2
18790:  MOVF   49,W
18792:  SUBLW  15
18794:  BNZ   187A2
18796:  MOVF   4A,F
18798:  BNZ   187A2
1879A:  MOVF   4B,F
1879C:  BNZ   187A2
....................       write_blank_macros(); 
1879E:  BRA    185F0
....................    } 
187A0:  BRA    187A6
....................    else cmd_arg(); 
187A2:  CALL   B32E
187A6:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
188C4:  MOVF   4B,F
188C6:  BNZ   188E2
188C8:  MOVF   4A,F
188CA:  BNZ   188E2
188CC:  MOVF   49,F
188CE:  BNZ   188E2
188D0:  MOVF   48,W
188D2:  SUBLW  14
188D4:  BNC   188E2
....................       macro = arg;  
188D6:  MOVFF  48,885
....................       read_macro(macro); 
188DA:  MOVFF  885,886
188DE:  BRA    1885E
....................    }    
188E0:  BRA    188E6
....................    else cmd_arg(); 
188E2:  CALL   B32E
188E6:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
18A38:  DECFSZ 48,W
18A3A:  BRA    18A54
18A3C:  MOVF   49,F
18A3E:  BNZ   18A54
18A40:  MOVF   4A,F
18A42:  BNZ   18A54
18A44:  MOVF   4B,F
18A46:  BNZ   18A54
....................       //fprintf(COM_A,"1\r\n"); 
....................       RTC_alarm(); 
18A48:  BRA    188EA
....................       //fprintf(COM_A,"2\r\n"); 
....................       RTC_late(); 
18A4A:  CALL   157AC
....................       //fprintf(COM_A,"3\r\n"); 
....................       RTC_alarm_status(); 
18A4E:  CALL   15C72
....................       //fprintf(COM_A,"4\r\n"); 
....................    } 
18A52:  BRA    18A58
....................    else cmd_arg(); 
18A54:  CALL   B32E
18A58:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
18A5C:  MOVF   48,W
18A5E:  MOVWF  00
18A60:  MOVF   49,W
18A62:  MOVWF  03
18A64:  BNZ   18A6A
18A66:  MOVF   00,F
18A68:  BZ    18A9E
18A6A:  MOVF   03,W
18A6C:  BNZ   18A74
18A6E:  MOVLW  02
18A70:  SUBWF  00,W
18A72:  BZ    18A9E
18A74:  MOVF   03,W
18A76:  BNZ   18A7E
18A78:  MOVLW  03
18A7A:  SUBWF  00,W
18A7C:  BZ    18A9E
18A7E:  MOVF   03,W
18A80:  BNZ   18A88
18A82:  MOVLW  04
18A84:  SUBWF  00,W
18A86:  BZ    18A9E
18A88:  MOVF   03,W
18A8A:  BNZ   18A92
18A8C:  MOVLW  05
18A8E:  SUBWF  00,W
18A90:  BZ    18A9E
18A92:  MOVF   03,W
18A94:  BNZ   18A9C
18A96:  MOVLW  06
18A98:  SUBWF  00,W
18A9A:  BZ    18A9E
18A9C:  BRA    18ABC
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
18A9E:  MOVFF  49,20
18AA2:  MOVFF  48,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
18AA6:  MOVLW  1C
18AA8:  MOVLB  8
18AAA:  MOVWF  xEE
18AAC:  MOVFF  20,8F0
18AB0:  MOVFF  1F,8EF
18AB4:  MOVLB  0
18AB6:  CALL   4FFC
....................          break; 
18ABA:  BRA    18AC0
....................       default: cmd_arg(); 
18ABC:  CALL   B32E
....................          break; 
....................    } 
18AC0:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
18AC4:  CALL   29E8
....................     
....................    switch(arg){ 
18AC8:  MOVFF  48,00
18ACC:  MOVF   49,W
18ACE:  MOVWF  03
18AD0:  BNZ   18AD6
18AD2:  MOVF   00,F
18AD4:  BZ    18B5A
18AD6:  MOVF   03,W
18AD8:  BNZ   18AE0
18ADA:  MOVLW  0A
18ADC:  SUBWF  00,W
18ADE:  BZ    18B5A
18AE0:  MOVF   03,W
18AE2:  BNZ   18AEA
18AE4:  MOVLW  01
18AE6:  SUBWF  00,W
18AE8:  BZ    18B62
18AEA:  MOVF   03,W
18AEC:  BNZ   18AF4
18AEE:  MOVLW  0B
18AF0:  SUBWF  00,W
18AF2:  BZ    18B62
18AF4:  MOVF   03,W
18AF6:  BNZ   18AFE
18AF8:  MOVLW  14
18AFA:  SUBWF  00,W
18AFC:  BZ    18B6C
18AFE:  MOVF   03,W
18B00:  BNZ   18B08
18B02:  MOVLW  15
18B04:  SUBWF  00,W
18B06:  BZ    18B72
18B08:  MOVF   03,W
18B0A:  BNZ   18B12
18B0C:  MOVLW  1E
18B0E:  SUBWF  00,W
18B10:  BZ    18B78
18B12:  MOVF   03,W
18B14:  BNZ   18B1C
18B16:  MOVLW  1F
18B18:  SUBWF  00,W
18B1A:  BZ    18B7E
18B1C:  MOVF   03,W
18B1E:  BNZ   18B26
18B20:  MOVLW  28
18B22:  SUBWF  00,W
18B24:  BZ    18B84
18B26:  MOVF   03,W
18B28:  BNZ   18B30
18B2A:  MOVLW  29
18B2C:  SUBWF  00,W
18B2E:  BZ    18B8A
18B30:  MOVF   03,W
18B32:  BNZ   18B3A
18B34:  MOVLW  32
18B36:  SUBWF  00,W
18B38:  BZ    18B90
18B3A:  MOVF   03,W
18B3C:  BNZ   18B44
18B3E:  MOVLW  33
18B40:  SUBWF  00,W
18B42:  BZ    18B96
18B44:  MOVF   03,W
18B46:  BNZ   18B4E
18B48:  MOVLW  3C
18B4A:  SUBWF  00,W
18B4C:  BZ    18B9C
18B4E:  MOVF   03,W
18B50:  BNZ   18B58
18B52:  MOVLW  3D
18B54:  SUBWF  00,W
18B56:  BZ    18BAA
18B58:  BRA    18BBC
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
18B5A:  BCF    F90.7
....................                bus_pwr_status=0; 
18B5C:  MOVLB  4
18B5E:  CLRF   xB6
....................          break; 
18B60:  BRA    18BC2
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
18B62:  BSF    F90.7
....................                bus_pwr_status=1; 
18B64:  MOVLW  01
18B66:  MOVLB  4
18B68:  MOVWF  xB6
....................          break; 
18B6A:  BRA    18BC2
....................       case 20: output_bit(VMOT,OFF); 
18B6C:  BCF    F8E.1
....................          break; 
18B6E:  MOVLB  4
18B70:  BRA    18BC2
....................       case 21: output_bit(VMOT,ON); 
18B72:  BSF    F8E.1
....................          break; 
18B74:  MOVLB  4
18B76:  BRA    18BC2
....................       case 30: output_bit(VENC1,OFF); 
18B78:  BCF    F8E.6
....................          break; 
18B7A:  MOVLB  4
18B7C:  BRA    18BC2
....................       case 31: output_bit(VENC1,ON); 
18B7E:  BSF    F8E.6
....................          break; 
18B80:  MOVLB  4
18B82:  BRA    18BC2
....................       case 40: output_bit(VENC2,OFF); 
18B84:  BCF    F8E.7
....................          break; 
18B86:  MOVLB  4
18B88:  BRA    18BC2
....................       case 41: output_bit(VENC2,ON); 
18B8A:  BSF    F8E.7
....................          break; 
18B8C:  MOVLB  4
18B8E:  BRA    18BC2
....................       case 50: output_bit(VHBRDG,OFF); 
18B90:  BCF    F8E.2
....................          break; 
18B92:  MOVLB  4
18B94:  BRA    18BC2
....................       case 51: output_bit(VHBRDG,ON); 
18B96:  BSF    F8E.2
....................          break;          
18B98:  MOVLB  4
18B9A:  BRA    18BC2
....................       case 60: set_heaters(0); 
18B9C:  MOVLB  8
18B9E:  CLRF   xC5
18BA0:  MOVLB  0
18BA2:  CALL   1274E
....................          break; 
18BA6:  MOVLB  4
18BA8:  BRA    18BC2
....................       case 61: set_heaters(3); 
18BAA:  MOVLW  03
18BAC:  MOVLB  8
18BAE:  MOVWF  xC5
18BB0:  MOVLB  0
18BB2:  CALL   1274E
....................          break; 
18BB6:  MOVLB  4
18BB8:  BRA    18BC2
18BBA:  MOVLB  0
....................       default : cmd_arg(); 
18BBC:  CALL   B32E
....................          break;          
18BC0:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
18BC2:  MOVLB  0
18BC4:  CALL   AEE0
18BC8:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
18BCC:  MOVF   48,F
18BCE:  BNZ   18BEA
18BD0:  MOVF   49,F
18BD2:  BNZ   18BEA
18BD4:  MOVF   4A,F
18BD6:  BNZ   18BEA
18BD8:  MOVF   4B,F
18BDA:  BNZ   18BEA
....................       motor_sleep_rdy(); 
18BDC:  CALL   29C0
....................       shutdown(); 
18BE0:  CALL   15C94
....................       go_to_sleep(); 
18BE4:  CALL   15F0E
....................    } 
18BE8:  BRA    18BEE
....................    else cmd_arg(); 
18BEA:  CALL   B32E
18BEE:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
18D1C:  DECFSZ 48,W
18D1E:  BRA    18D30
18D20:  MOVF   49,F
18D22:  BNZ   18D30
18D24:  MOVF   4A,F
18D26:  BNZ   18D30
18D28:  MOVF   4B,F
18D2A:  BNZ   18D30
18D2C:  BRA    18C16
18D2E:  BRA    18D34
....................    else cmd_arg(); 
18D30:  CALL   B32E
18D34:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
18D38:  MOVF   4B,F
18D3A:  BNZ   18DCA
18D3C:  MOVF   4A,F
18D3E:  BNZ   18DCA
18D40:  MOVF   49,W
18D42:  SUBLW  27
18D44:  BNC   18DCA
18D46:  BNZ   18D4E
18D48:  MOVF   48,W
18D4A:  SUBLW  10
18D4C:  BNC   18DCA
....................       m_bklsh[motor] = arg; 
18D4E:  BCF    FD8.0
18D50:  MOVLB  7
18D52:  RLCF   x40,W
18D54:  CLRF   03
18D56:  ADDLW  72
18D58:  MOVWF  FE9
18D5A:  MOVLW  07
18D5C:  ADDWFC 03,W
18D5E:  MOVWF  FEA
18D60:  MOVFF  48,FEF
18D64:  MOVFF  49,FEC
....................       switch(motor){ 
18D68:  MOVF   x40,W
18D6A:  XORLW  00
18D6C:  MOVLB  0
18D6E:  BZ    18D76
18D70:  XORLW  01
18D72:  BZ    18DA0
18D74:  BRA    18DC8
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
18D76:  BCF    FD8.0
18D78:  MOVLB  7
18D7A:  RLCF   x40,W
18D7C:  CLRF   03
18D7E:  ADDLW  72
18D80:  MOVWF  FE9
18D82:  MOVLW  07
18D84:  ADDWFC 03,W
18D86:  MOVWF  FEA
18D88:  MOVFF  FEC,8F0
18D8C:  MOVF   FED,F
18D8E:  MOVFF  FEF,8EF
18D92:  MOVLW  72
18D94:  MOVLB  8
18D96:  MOVWF  xEE
18D98:  MOVLB  0
18D9A:  CALL   4FFC
....................             break; 
18D9E:  BRA    18DC8
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
18DA0:  BCF    FD8.0
18DA2:  MOVLB  7
18DA4:  RLCF   x40,W
18DA6:  CLRF   03
18DA8:  ADDLW  72
18DAA:  MOVWF  FE9
18DAC:  MOVLW  07
18DAE:  ADDWFC 03,W
18DB0:  MOVWF  FEA
18DB2:  MOVFF  FEC,8F0
18DB6:  MOVF   FED,F
18DB8:  MOVFF  FEF,8EF
18DBC:  MOVLW  74
18DBE:  MOVLB  8
18DC0:  MOVWF  xEE
18DC2:  MOVLB  0
18DC4:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
18DC8:  BRA    18DCE
....................    else cmd_arg();    
18DCA:  CALL   B32E
18DCE:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... //Set watchdog temporarily (arg should be dec equivalent of bcd) 
.................... //c0,c1 services watchdog 
.................... //probably don't use this anyway 
.................... void command_c(){ 
....................    if(arg == 0){ 
18DD2:  MOVF   48,F
18DD4:  BNZ   18DE6
18DD6:  MOVF   49,F
18DD8:  BNZ   18DE6
18DDA:  MOVF   4A,F
18DDC:  BNZ   18DE6
18DDE:  MOVF   4B,F
18DE0:  BNZ   18DE6
....................       output_bit(PIN_J7,0); 
18DE2:  BCF    F91.7
....................    }else if(arg == 1){ 
18DE4:  BRA    18E22
18DE6:  DECFSZ 48,W
18DE8:  BRA    18DFA
18DEA:  MOVF   49,F
18DEC:  BNZ   18DFA
18DEE:  MOVF   4A,F
18DF0:  BNZ   18DFA
18DF2:  MOVF   4B,F
18DF4:  BNZ   18DFA
....................       output_bit(PIN_J7,1); 
18DF6:  BSF    F91.7
....................    }else{ 
18DF8:  BRA    18E22
....................       RTC_reset_HT(); 
18DFA:  CALL   34DA
....................       output_bit(RTC_CS, ENABLE); 
18DFE:  BCF    F91.0
....................       spi_write(0x89); 
18E00:  MOVF   FC9,W
18E02:  MOVLW  89
18E04:  MOVWF  FC9
18E06:  RRCF   FC7,W
18E08:  BNC   18E06
....................       spi_write(arg); 
18E0A:  MOVF   FC9,W
18E0C:  MOVFF  48,FC9
18E10:  RRCF   FC7,W
18E12:  BNC   18E10
....................       output_bit(RTC_CS, DISABLE); 
18E14:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
18E16:  BCF    F91.0
....................       spi_read(0x00); 
18E18:  MOVF   FC9,W
18E1A:  CLRF   FC9
18E1C:  RRCF   FC7,W
18E1E:  BNC   18E1C
....................       output_bit(RTC_CS, DISABLE); 
18E20:  BSF    F91.0
....................    } 
18E22:  GOTO   1B2F8 (RETURN)
.................... } 
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
18E26:  MOVF   4B,F
18E28:  BNZ   18EB4
18E2A:  MOVF   4A,F
18E2C:  BNZ   18EB4
18E2E:  MOVF   49,F
18E30:  BNZ   18EB4
18E32:  MOVF   48,W
18E34:  SUBLW  01
18E36:  BNC   18EB4
....................       m_pos_dir[motor] = arg; 
18E38:  BCF    FD8.0
18E3A:  MOVLB  7
18E3C:  RLCF   x40,W
18E3E:  CLRF   03
18E40:  ADDLW  4E
18E42:  MOVWF  FE9
18E44:  MOVLW  07
18E46:  ADDWFC 03,W
18E48:  MOVWF  FEA
18E4A:  MOVFF  48,FEF
18E4E:  MOVFF  49,FEC
....................       switch(motor){ 
18E52:  MOVF   x40,W
18E54:  XORLW  00
18E56:  MOVLB  0
18E58:  BZ    18E60
18E5A:  XORLW  01
18E5C:  BZ    18E8A
18E5E:  BRA    18EB2
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
18E60:  BCF    FD8.0
18E62:  MOVLB  7
18E64:  RLCF   x40,W
18E66:  CLRF   03
18E68:  ADDLW  4E
18E6A:  MOVWF  FE9
18E6C:  MOVLW  07
18E6E:  ADDWFC 03,W
18E70:  MOVWF  FEA
18E72:  MOVFF  FEC,8F0
18E76:  MOVF   FED,F
18E78:  MOVFF  FEF,8EF
18E7C:  MOVLW  92
18E7E:  MOVLB  8
18E80:  MOVWF  xEE
18E82:  MOVLB  0
18E84:  CALL   4FFC
....................             break; 
18E88:  BRA    18EB2
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
18E8A:  BCF    FD8.0
18E8C:  MOVLB  7
18E8E:  RLCF   x40,W
18E90:  CLRF   03
18E92:  ADDLW  4E
18E94:  MOVWF  FE9
18E96:  MOVLW  07
18E98:  ADDWFC 03,W
18E9A:  MOVWF  FEA
18E9C:  MOVFF  FEC,8F0
18EA0:  MOVF   FED,F
18EA2:  MOVFF  FEF,8EF
18EA6:  MOVLW  94
18EA8:  MOVLB  8
18EAA:  MOVWF  xEE
18EAC:  MOVLB  0
18EAE:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
18EB2:  BRA    18EB8
....................    else cmd_arg();    
18EB4:  CALL   B32E
18EB8:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
18EBC:  MOVF   4B,F
18EBE:  BNZ   18F4E
18EC0:  MOVF   4A,F
18EC2:  BNZ   18F4E
18EC4:  MOVF   49,W
18EC6:  SUBLW  27
18EC8:  BNC   18F4E
18ECA:  BNZ   18ED2
18ECC:  MOVF   48,W
18ECE:  SUBLW  10
18ED0:  BNC   18F4E
....................       e_cpr[motor] = arg; 
18ED2:  BCF    FD8.0
18ED4:  MOVLB  7
18ED6:  RLCF   x40,W
18ED8:  CLRF   03
18EDA:  ADDLW  5E
18EDC:  MOVWF  FE9
18EDE:  MOVLW  07
18EE0:  ADDWFC 03,W
18EE2:  MOVWF  FEA
18EE4:  MOVFF  48,FEF
18EE8:  MOVFF  49,FEC
....................       switch(motor){ 
18EEC:  MOVF   x40,W
18EEE:  XORLW  00
18EF0:  MOVLB  0
18EF2:  BZ    18EFA
18EF4:  XORLW  01
18EF6:  BZ    18F24
18EF8:  BRA    18F4C
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
18EFA:  BCF    FD8.0
18EFC:  MOVLB  7
18EFE:  RLCF   x40,W
18F00:  CLRF   03
18F02:  ADDLW  5E
18F04:  MOVWF  FE9
18F06:  MOVLW  07
18F08:  ADDWFC 03,W
18F0A:  MOVWF  FEA
18F0C:  MOVFF  FEC,8F0
18F10:  MOVF   FED,F
18F12:  MOVFF  FEF,8EF
18F16:  MOVLW  A2
18F18:  MOVLB  8
18F1A:  MOVWF  xEE
18F1C:  MOVLB  0
18F1E:  CALL   4FFC
....................             break; 
18F22:  BRA    18F4C
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
18F24:  BCF    FD8.0
18F26:  MOVLB  7
18F28:  RLCF   x40,W
18F2A:  CLRF   03
18F2C:  ADDLW  5E
18F2E:  MOVWF  FE9
18F30:  MOVLW  07
18F32:  ADDWFC 03,W
18F34:  MOVWF  FEA
18F36:  MOVFF  FEC,8F0
18F3A:  MOVF   FED,F
18F3C:  MOVFF  FEF,8EF
18F40:  MOVLW  A4
18F42:  MOVLB  8
18F44:  MOVWF  xEE
18F46:  MOVLB  0
18F48:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
18F4C:  BRA    18F52
....................    else cmd_arg();    
18F4E:  CALL   B32E
18F52:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
18F56:  MOVF   4B,F
18F58:  BNZ   18F6E
18F5A:  MOVF   4A,F
18F5C:  BNZ   18F6E
18F5E:  MOVF   49,F
18F60:  BNZ   18F6E
18F62:  MOVF   48,W
18F64:  SUBLW  01
18F66:  BNC   18F6E
18F68:  MOVFF  48,741
18F6C:  BRA    18F72
....................    else cmd_arg();    
18F6E:  CALL   B32E
18F72:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
18F76:  MOVF   4B,F
18F78:  BNZ   19008
18F7A:  MOVF   4A,F
18F7C:  BNZ   19008
18F7E:  MOVF   49,W
18F80:  SUBLW  EA
18F82:  BNC   19008
18F84:  BNZ   18F8C
18F86:  MOVF   48,W
18F88:  SUBLW  60
18F8A:  BNC   19008
....................       m_gb_err[motor] = arg; 
18F8C:  BCF    FD8.0
18F8E:  MOVLB  7
18F90:  RLCF   x40,W
18F92:  CLRF   03
18F94:  ADDLW  5A
18F96:  MOVWF  FE9
18F98:  MOVLW  07
18F9A:  ADDWFC 03,W
18F9C:  MOVWF  FEA
18F9E:  MOVFF  48,FEF
18FA2:  MOVFF  49,FEC
....................       switch(motor){ 
18FA6:  MOVF   x40,W
18FA8:  XORLW  00
18FAA:  MOVLB  0
18FAC:  BZ    18FB4
18FAE:  XORLW  01
18FB0:  BZ    18FDE
18FB2:  BRA    19006
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
18FB4:  BCF    FD8.0
18FB6:  MOVLB  7
18FB8:  RLCF   x40,W
18FBA:  CLRF   03
18FBC:  ADDLW  5A
18FBE:  MOVWF  FE9
18FC0:  MOVLW  07
18FC2:  ADDWFC 03,W
18FC4:  MOVWF  FEA
18FC6:  MOVFF  FEC,8F0
18FCA:  MOVF   FED,F
18FCC:  MOVFF  FEF,8EF
18FD0:  MOVLW  9E
18FD2:  MOVLB  8
18FD4:  MOVWF  xEE
18FD6:  MOVLB  0
18FD8:  CALL   4FFC
....................             break; 
18FDC:  BRA    19006
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
18FDE:  BCF    FD8.0
18FE0:  MOVLB  7
18FE2:  RLCF   x40,W
18FE4:  CLRF   03
18FE6:  ADDLW  5A
18FE8:  MOVWF  FE9
18FEA:  MOVLW  07
18FEC:  ADDWFC 03,W
18FEE:  MOVWF  FEA
18FF0:  MOVFF  FEC,8F0
18FF4:  MOVF   FED,F
18FF6:  MOVFF  FEF,8EF
18FFA:  MOVLW  A0
18FFC:  MOVLB  8
18FFE:  MOVWF  xEE
19000:  MOVLB  0
19002:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
19006:  BRA    1900C
....................    else cmd_arg();    
19008:  CALL   B32E
1900C:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
19010:  MOVF   4B,F
19012:  BNZ   190DC
19014:  MOVF   4A,F
19016:  BNZ   190DC
19018:  MOVF   49,F
1901A:  BNZ   190DC
1901C:  MOVF   48,W
1901E:  SUBLW  64
19020:  BNC   190DC
....................       hold_pc=arg; 
19022:  MOVFF  49,886
19026:  MOVFF  48,885
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1902A:  BCF    FD8.0
1902C:  MOVLB  7
1902E:  RLCF   x40,W
19030:  CLRF   03
19032:  ADDLW  52
19034:  MOVWF  FE9
19036:  MOVLW  07
19038:  ADDWFC 03,W
1903A:  MOVWF  FEA
1903C:  MOVFF  886,A11
19040:  MOVFF  885,A10
19044:  MOVLW  01
19046:  MOVLB  A
19048:  MOVWF  x13
1904A:  SETF   x12
1904C:  MOVLB  0
1904E:  CALL   5CC0
19052:  MOVFF  02,88A
19056:  MOVFF  01,889
1905A:  MOVFF  02,8DC
1905E:  MOVFF  01,8DB
19062:  MOVLB  8
19064:  CLRF   xDE
19066:  MOVLW  64
19068:  MOVWF  xDD
1906A:  MOVLB  0
1906C:  CALL   2CFC
19070:  MOVFF  01,FEF
19074:  MOVFF  02,FEC
....................       switch(motor){ 
19078:  MOVLB  7
1907A:  MOVF   x40,W
1907C:  XORLW  00
1907E:  MOVLB  0
19080:  BZ    19088
19082:  XORLW  01
19084:  BZ    190B2
19086:  BRA    190DA
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
19088:  BCF    FD8.0
1908A:  MOVLB  7
1908C:  RLCF   x40,W
1908E:  CLRF   03
19090:  ADDLW  52
19092:  MOVWF  FE9
19094:  MOVLW  07
19096:  ADDWFC 03,W
19098:  MOVWF  FEA
1909A:  MOVFF  FEC,8F0
1909E:  MOVF   FED,F
190A0:  MOVFF  FEF,8EF
190A4:  MOVLW  96
190A6:  MOVLB  8
190A8:  MOVWF  xEE
190AA:  MOVLB  0
190AC:  CALL   4FFC
....................             break; 
190B0:  BRA    190DA
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
190B2:  BCF    FD8.0
190B4:  MOVLB  7
190B6:  RLCF   x40,W
190B8:  CLRF   03
190BA:  ADDLW  52
190BC:  MOVWF  FE9
190BE:  MOVLW  07
190C0:  ADDWFC 03,W
190C2:  MOVWF  FEA
190C4:  MOVFF  FEC,8F0
190C8:  MOVF   FED,F
190CA:  MOVFF  FEF,8EF
190CE:  MOVLW  98
190D0:  MOVLB  8
190D2:  MOVWF  xEE
190D4:  MOVLB  0
190D6:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
190DA:  BRA    190E0
....................    else cmd_arg();    
190DC:  CALL   B32E
190E0:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
190E4:  MOVF   4B,F
190E6:  BNZ   191B8
190E8:  MOVF   4A,F
190EA:  BNZ   191B8
190EC:  MOVF   49,W
190EE:  SUBLW  EA
190F0:  BNC   191B8
190F2:  BNZ   190FA
190F4:  MOVF   48,W
190F6:  SUBLW  60
190F8:  BNC   191B8
....................       m_stp_int[motor] = (arg/100); 
190FA:  BCF    FD8.0
190FC:  MOVLB  7
190FE:  RLCF   x40,W
19100:  CLRF   03
19102:  ADDLW  4A
19104:  MOVWF  FE9
19106:  MOVLW  07
19108:  ADDWFC 03,W
1910A:  MOVWF  FEA
1910C:  MOVFF  FEA,888
19110:  MOVFF  FE9,887
19114:  BCF    FD8.1
19116:  CLRF   1B
19118:  BTFSC  FF2.7
1911A:  BSF    1B.7
1911C:  BCF    FF2.7
1911E:  MOVFF  4B,A4F
19122:  MOVFF  4A,A4E
19126:  MOVFF  49,A4D
1912A:  MOVFF  48,A4C
1912E:  MOVLB  A
19130:  CLRF   x53
19132:  CLRF   x52
19134:  CLRF   x51
19136:  MOVLW  64
19138:  MOVWF  x50
1913A:  MOVLB  0
1913C:  CALL   1076
19140:  BTFSC  1B.7
19142:  BSF    FF2.7
19144:  MOVFF  888,FEA
19148:  MOVFF  887,FE9
1914C:  MOVFF  00,FEF
19150:  MOVFF  01,FEC
....................       switch(motor){ 
19154:  MOVLB  7
19156:  MOVF   x40,W
19158:  XORLW  00
1915A:  MOVLB  0
1915C:  BZ    19164
1915E:  XORLW  01
19160:  BZ    1918E
19162:  BRA    191B6
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
19164:  BCF    FD8.0
19166:  MOVLB  7
19168:  RLCF   x40,W
1916A:  CLRF   03
1916C:  ADDLW  4A
1916E:  MOVWF  FE9
19170:  MOVLW  07
19172:  ADDWFC 03,W
19174:  MOVWF  FEA
19176:  MOVFF  FEC,8F0
1917A:  MOVF   FED,F
1917C:  MOVFF  FEF,8EF
19180:  MOVLW  8E
19182:  MOVLB  8
19184:  MOVWF  xEE
19186:  MOVLB  0
19188:  CALL   4FFC
....................             break; 
1918C:  BRA    191B6
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
1918E:  BCF    FD8.0
19190:  MOVLB  7
19192:  RLCF   x40,W
19194:  CLRF   03
19196:  ADDLW  4A
19198:  MOVWF  FE9
1919A:  MOVLW  07
1919C:  ADDWFC 03,W
1919E:  MOVWF  FEA
191A0:  MOVFF  FEC,8F0
191A4:  MOVF   FED,F
191A6:  MOVFF  FEF,8EF
191AA:  MOVLW  90
191AC:  MOVLB  8
191AE:  MOVWF  xEE
191B0:  MOVLB  0
191B2:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
191B6:  BRA    191BC
....................    else cmd_arg();    
191B8:  CALL   B32E
191BC:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
191C0:  MOVF   4B,F
191C2:  BNZ   19252
191C4:  MOVF   4A,F
191C6:  BNZ   19252
191C8:  MOVF   49,W
191CA:  SUBLW  27
191CC:  BNC   19252
191CE:  BNZ   191D6
191D0:  MOVF   48,W
191D2:  SUBLW  10
191D4:  BNC   19252
....................       m_run[motor] = arg; 
191D6:  BCF    FD8.0
191D8:  MOVLB  7
191DA:  RLCF   x40,W
191DC:  CLRF   03
191DE:  ADDLW  6E
191E0:  MOVWF  FE9
191E2:  MOVLW  07
191E4:  ADDWFC 03,W
191E6:  MOVWF  FEA
191E8:  MOVFF  48,FEF
191EC:  MOVFF  49,FEC
....................       switch(motor){ 
191F0:  MOVF   x40,W
191F2:  XORLW  00
191F4:  MOVLB  0
191F6:  BZ    191FE
191F8:  XORLW  01
191FA:  BZ    19228
191FC:  BRA    19250
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
191FE:  BCF    FD8.0
19200:  MOVLB  7
19202:  RLCF   x40,W
19204:  CLRF   03
19206:  ADDLW  6E
19208:  MOVWF  FE9
1920A:  MOVLW  07
1920C:  ADDWFC 03,W
1920E:  MOVWF  FEA
19210:  MOVFF  FEC,8F0
19214:  MOVF   FED,F
19216:  MOVFF  FEF,8EF
1921A:  MOVLW  76
1921C:  MOVLB  8
1921E:  MOVWF  xEE
19220:  MOVLB  0
19222:  CALL   4FFC
....................             break; 
19226:  BRA    19250
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
19228:  BCF    FD8.0
1922A:  MOVLB  7
1922C:  RLCF   x40,W
1922E:  CLRF   03
19230:  ADDLW  6E
19232:  MOVWF  FE9
19234:  MOVLW  07
19236:  ADDWFC 03,W
19238:  MOVWF  FEA
1923A:  MOVFF  FEC,8F0
1923E:  MOVF   FED,F
19240:  MOVFF  FEF,8EF
19244:  MOVLW  78
19246:  MOVLB  8
19248:  MOVWF  xEE
1924A:  MOVLB  0
1924C:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
19250:  BRA    19256
....................    else cmd_arg();    
19252:  CALL   B32E
19256:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
1925A:  MOVF   4B,F
1925C:  BNZ   192E8
1925E:  MOVF   4A,F
19260:  BNZ   192E8
19262:  MOVF   49,F
19264:  BNZ   192E8
19266:  MOVF   48,W
19268:  SUBLW  03
1926A:  BNC   192E8
....................       e_mode[motor] = arg; 
1926C:  BCF    FD8.0
1926E:  MOVLB  7
19270:  RLCF   x40,W
19272:  CLRF   03
19274:  ADDLW  66
19276:  MOVWF  FE9
19278:  MOVLW  07
1927A:  ADDWFC 03,W
1927C:  MOVWF  FEA
1927E:  MOVFF  48,FEF
19282:  MOVFF  49,FEC
....................       switch(motor){ 
19286:  MOVF   x40,W
19288:  XORLW  00
1928A:  MOVLB  0
1928C:  BZ    19294
1928E:  XORLW  01
19290:  BZ    192BE
19292:  BRA    192E6
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
19294:  BCF    FD8.0
19296:  MOVLB  7
19298:  RLCF   x40,W
1929A:  CLRF   03
1929C:  ADDLW  66
1929E:  MOVWF  FE9
192A0:  MOVLW  07
192A2:  ADDWFC 03,W
192A4:  MOVWF  FEA
192A6:  MOVFF  FEC,8F0
192AA:  MOVF   FED,F
192AC:  MOVFF  FEF,8EF
192B0:  MOVLW  82
192B2:  MOVLB  8
192B4:  MOVWF  xEE
192B6:  MOVLB  0
192B8:  CALL   4FFC
....................             break; 
192BC:  BRA    192E6
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
192BE:  BCF    FD8.0
192C0:  MOVLB  7
192C2:  RLCF   x40,W
192C4:  CLRF   03
192C6:  ADDLW  66
192C8:  MOVWF  FE9
192CA:  MOVLW  07
192CC:  ADDWFC 03,W
192CE:  MOVWF  FEA
192D0:  MOVFF  FEC,8F0
192D4:  MOVF   FED,F
192D6:  MOVFF  FEF,8EF
192DA:  MOVLW  84
192DC:  MOVLB  8
192DE:  MOVWF  xEE
192E0:  MOVLB  0
192E2:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
192E6:  BRA    192EC
....................    else cmd_arg();    
192E8:  CALL   B32E
192EC:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
19F50:  MOVF   4B,F
19F52:  BNZ   19FDE
19F54:  MOVF   4A,F
19F56:  BNZ   19FDE
19F58:  MOVF   49,F
19F5A:  BNZ   19FDE
19F5C:  MOVF   48,W
19F5E:  SUBLW  01
19F60:  BNC   19FDE
....................       m_mode[motor] = arg; 
19F62:  BCF    FD8.0
19F64:  MOVLB  7
19F66:  RLCF   x40,W
19F68:  CLRF   03
19F6A:  ADDLW  46
19F6C:  MOVWF  FE9
19F6E:  MOVLW  07
19F70:  ADDWFC 03,W
19F72:  MOVWF  FEA
19F74:  MOVFF  48,FEF
19F78:  MOVFF  49,FEC
....................       switch(motor){ 
19F7C:  MOVF   x40,W
19F7E:  XORLW  00
19F80:  MOVLB  0
19F82:  BZ    19F8A
19F84:  XORLW  01
19F86:  BZ    19FB4
19F88:  BRA    19FDC
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
19F8A:  BCF    FD8.0
19F8C:  MOVLB  7
19F8E:  RLCF   x40,W
19F90:  CLRF   03
19F92:  ADDLW  46
19F94:  MOVWF  FE9
19F96:  MOVLW  07
19F98:  ADDWFC 03,W
19F9A:  MOVWF  FEA
19F9C:  MOVFF  FEC,8F0
19FA0:  MOVF   FED,F
19FA2:  MOVFF  FEF,8EF
19FA6:  MOVLW  8A
19FA8:  MOVLB  8
19FAA:  MOVWF  xEE
19FAC:  MOVLB  0
19FAE:  CALL   4FFC
....................             break; 
19FB2:  BRA    19FDC
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
19FB4:  BCF    FD8.0
19FB6:  MOVLB  7
19FB8:  RLCF   x40,W
19FBA:  CLRF   03
19FBC:  ADDLW  46
19FBE:  MOVWF  FE9
19FC0:  MOVLW  07
19FC2:  ADDWFC 03,W
19FC4:  MOVWF  FEA
19FC6:  MOVFF  FEC,8F0
19FCA:  MOVF   FED,F
19FCC:  MOVFF  FEF,8EF
19FD0:  MOVLW  8C
19FD2:  MOVLB  8
19FD4:  MOVWF  xEE
19FD6:  MOVLB  0
19FD8:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
19FDC:  BRA    19FE2
....................    else cmd_arg();    
19FDE:  CALL   B32E
19FE2:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
19FE6:  MOVF   4B,F
19FE8:  BNZ   1A074
19FEA:  MOVF   4A,F
19FEC:  BNZ   1A074
19FEE:  MOVF   49,F
19FF0:  BNZ   1A074
19FF2:  MOVF   48,W
19FF4:  SUBLW  01
19FF6:  BNC   1A074
....................       e_index[motor] = arg; 
19FF8:  BCF    FD8.0
19FFA:  MOVLB  7
19FFC:  RLCF   x40,W
19FFE:  CLRF   03
1A000:  ADDLW  7A
1A002:  MOVWF  FE9
1A004:  MOVLW  07
1A006:  ADDWFC 03,W
1A008:  MOVWF  FEA
1A00A:  MOVFF  48,FEF
1A00E:  MOVFF  49,FEC
....................       switch(motor){ 
1A012:  MOVF   x40,W
1A014:  XORLW  00
1A016:  MOVLB  0
1A018:  BZ    1A020
1A01A:  XORLW  01
1A01C:  BZ    1A04A
1A01E:  BRA    1A072
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
1A020:  BCF    FD8.0
1A022:  MOVLB  7
1A024:  RLCF   x40,W
1A026:  CLRF   03
1A028:  ADDLW  7A
1A02A:  MOVWF  FE9
1A02C:  MOVLW  07
1A02E:  ADDWFC 03,W
1A030:  MOVWF  FEA
1A032:  MOVFF  FEC,8F0
1A036:  MOVF   FED,F
1A038:  MOVFF  FEF,8EF
1A03C:  MOVLW  BA
1A03E:  MOVLB  8
1A040:  MOVWF  xEE
1A042:  MOVLB  0
1A044:  CALL   4FFC
....................             break; 
1A048:  BRA    1A072
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
1A04A:  BCF    FD8.0
1A04C:  MOVLB  7
1A04E:  RLCF   x40,W
1A050:  CLRF   03
1A052:  ADDLW  7A
1A054:  MOVWF  FE9
1A056:  MOVLW  07
1A058:  ADDWFC 03,W
1A05A:  MOVWF  FEA
1A05C:  MOVFF  FEC,8F0
1A060:  MOVF   FED,F
1A062:  MOVFF  FEF,8EF
1A066:  MOVLW  BC
1A068:  MOVLB  8
1A06A:  MOVWF  xEE
1A06C:  MOVLB  0
1A06E:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1A072:  BRA    1A078
....................    else cmd_arg();    
1A074:  CALL   B32E
1A078:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
1A07C:  MOVF   4B,F
1A07E:  BNZ   1A10E
1A080:  MOVF   4A,F
1A082:  BNZ   1A10E
1A084:  MOVF   49,W
1A086:  SUBLW  01
1A088:  BNC   1A10E
1A08A:  BNZ   1A092
1A08C:  MOVF   48,W
1A08E:  SUBLW  0A
1A090:  BNC   1A10E
....................        evn_so[motor] = arg; 
1A092:  BCF    FD8.0
1A094:  MOVLB  7
1A096:  RLCF   x40,W
1A098:  CLRF   03
1A09A:  ADDLW  7E
1A09C:  MOVWF  FE9
1A09E:  MOVLW  07
1A0A0:  ADDWFC 03,W
1A0A2:  MOVWF  FEA
1A0A4:  MOVFF  48,FEF
1A0A8:  MOVFF  49,FEC
....................        switch(motor){ 
1A0AC:  MOVF   x40,W
1A0AE:  XORLW  00
1A0B0:  MOVLB  0
1A0B2:  BZ    1A0BA
1A0B4:  XORLW  01
1A0B6:  BZ    1A0E4
1A0B8:  BRA    1A10C
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
1A0BA:  BCF    FD8.0
1A0BC:  MOVLB  7
1A0BE:  RLCF   x40,W
1A0C0:  CLRF   03
1A0C2:  ADDLW  7E
1A0C4:  MOVWF  FE9
1A0C6:  MOVLW  07
1A0C8:  ADDWFC 03,W
1A0CA:  MOVWF  FEA
1A0CC:  MOVFF  FEC,8F0
1A0D0:  MOVF   FED,F
1A0D2:  MOVFF  FEF,8EF
1A0D6:  MOVLW  BE
1A0D8:  MOVLB  8
1A0DA:  MOVWF  xEE
1A0DC:  MOVLB  0
1A0DE:  CALL   4FFC
....................             break; 
1A0E2:  BRA    1A10C
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
1A0E4:  BCF    FD8.0
1A0E6:  MOVLB  7
1A0E8:  RLCF   x40,W
1A0EA:  CLRF   03
1A0EC:  ADDLW  7E
1A0EE:  MOVWF  FE9
1A0F0:  MOVLW  07
1A0F2:  ADDWFC 03,W
1A0F4:  MOVWF  FEA
1A0F6:  MOVFF  FEC,8F0
1A0FA:  MOVF   FED,F
1A0FC:  MOVFF  FEF,8EF
1A100:  MOVLW  C0
1A102:  MOVLB  8
1A104:  MOVWF  xEE
1A106:  MOVLB  0
1A108:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1A10C:  BRA    1A112
....................    else cmd_arg();    
1A10E:  CALL   B32E
1A112:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
1A116:  MOVF   4B,F
1A118:  BNZ   1A1A8
1A11A:  MOVF   4A,F
1A11C:  BNZ   1A1A8
1A11E:  MOVF   49,W
1A120:  SUBLW  03
1A122:  BNC   1A1A8
1A124:  BNZ   1A12C
1A126:  MOVF   48,W
1A128:  SUBLW  E8
1A12A:  BNC   1A1A8
....................       e_ppr[motor] = arg; 
1A12C:  BCF    FD8.0
1A12E:  MOVLB  7
1A130:  RLCF   x40,W
1A132:  CLRF   03
1A134:  ADDLW  62
1A136:  MOVWF  FE9
1A138:  MOVLW  07
1A13A:  ADDWFC 03,W
1A13C:  MOVWF  FEA
1A13E:  MOVFF  48,FEF
1A142:  MOVFF  49,FEC
....................       switch(motor){ 
1A146:  MOVF   x40,W
1A148:  XORLW  00
1A14A:  MOVLB  0
1A14C:  BZ    1A154
1A14E:  XORLW  01
1A150:  BZ    1A17E
1A152:  BRA    1A1A6
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
1A154:  BCF    FD8.0
1A156:  MOVLB  7
1A158:  RLCF   x40,W
1A15A:  CLRF   03
1A15C:  ADDLW  62
1A15E:  MOVWF  FE9
1A160:  MOVLW  07
1A162:  ADDWFC 03,W
1A164:  MOVWF  FEA
1A166:  MOVFF  FEC,8F0
1A16A:  MOVF   FED,F
1A16C:  MOVFF  FEF,8EF
1A170:  MOVLW  A6
1A172:  MOVLB  8
1A174:  MOVWF  xEE
1A176:  MOVLB  0
1A178:  CALL   4FFC
....................             break; 
1A17C:  BRA    1A1A6
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
1A17E:  BCF    FD8.0
1A180:  MOVLB  7
1A182:  RLCF   x40,W
1A184:  CLRF   03
1A186:  ADDLW  62
1A188:  MOVWF  FE9
1A18A:  MOVLW  07
1A18C:  ADDWFC 03,W
1A18E:  MOVWF  FEA
1A190:  MOVFF  FEC,8F0
1A194:  MOVF   FED,F
1A196:  MOVFF  FEF,8EF
1A19A:  MOVLW  A8
1A19C:  MOVLB  8
1A19E:  MOVWF  xEE
1A1A0:  MOVLB  0
1A1A2:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1A1A6:  BRA    1A1AC
....................    else cmd_arg();    
1A1A8:  CALL   B32E
1A1AC:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
1A1B0:  MOVF   48,F
1A1B2:  BNZ   1A1C4
1A1B4:  MOVF   49,F
1A1B6:  BNZ   1A1C4
1A1B8:  MOVF   4A,F
1A1BA:  BNZ   1A1C4
1A1BC:  MOVF   4B,F
1A1BE:  BNZ   1A1C4
1A1C0:  BCF    F8E.1
1A1C2:  BRA    1A1C8
....................    else cmd_arg();    
1A1C4:  CALL   B32E
1A1C8:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1ACAC:  MOVF   48,F
1ACAE:  BNZ   1ACFE
1ACB0:  MOVF   49,F
1ACB2:  BNZ   1ACFE
1ACB4:  MOVF   4A,F
1ACB6:  BNZ   1ACFE
1ACB8:  MOVF   4B,F
1ACBA:  BNZ   1ACFE
....................       switch (nv_product) { 
1ACBC:  MOVFF  2F,00
1ACC0:  MOVF   30,W
1ACC2:  MOVWF  03
1ACC4:  BNZ   1ACCA
1ACC6:  MOVF   00,F
1ACC8:  BZ    1ACEA
1ACCA:  MOVF   03,W
1ACCC:  BNZ   1ACD4
1ACCE:  MOVLW  01
1ACD0:  SUBWF  00,W
1ACD2:  BZ    1ACF0
1ACD4:  MOVF   03,W
1ACD6:  BNZ   1ACDE
1ACD8:  MOVLW  02
1ACDA:  SUBWF  00,W
1ACDC:  BZ    1ACF6
1ACDE:  MOVF   03,W
1ACE0:  BNZ   1ACE8
1ACE2:  MOVLW  03
1ACE4:  SUBWF  00,W
1ACE6:  BZ    1ACFA
1ACE8:  BRA    1ACFC
....................          case ECO : rst_step_vars_eco(); 
1ACEA:  GOTO   1A1CC
....................             break; 
1ACEE:  BRA    1ACFC
....................          case WMS4 : rst_step_vars_wms4(); 
1ACF0:  GOTO   1A4B6
....................             break; 
1ACF4:  BRA    1ACFC
....................          case AWS : rst_step_vars_aws(); 
1ACF6:  BRA    1A762
....................             break;             
1ACF8:  BRA    1ACFC
....................          case WMS2 : rst_step_vars_wms2(); 
1ACFA:  BRA    1A9FC
....................             break; 
....................       } 
....................    }  
1ACFC:  BRA    1AD02
....................    else cmd_arg(); 
1ACFE:  CALL   B32E
1AD02:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1AD06:  MOVF   4B,F
1AD08:  BTFSS  FD8.2
1AD0A:  BRA    1AE0C
1AD0C:  MOVF   4A,W
1AD0E:  SUBLW  00
1AD10:  BTFSS  FD8.0
1AD12:  BRA    1AE0C
....................       m_spr[motor] = arg; 
1AD14:  BCF    FD8.0
1AD16:  MOVLB  7
1AD18:  RLCF   x40,W
1AD1A:  CLRF   03
1AD1C:  ADDLW  76
1AD1E:  MOVWF  FE9
1AD20:  MOVLW  07
1AD22:  ADDWFC 03,W
1AD24:  MOVWF  FEA
1AD26:  MOVFF  48,FEF
1AD2A:  MOVFF  49,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1AD2E:  BCF    FD8.0
1AD30:  RLCF   x40,W
1AD32:  CLRF   03
1AD34:  ADDLW  AB
1AD36:  MOVWF  01
1AD38:  MOVLW  07
1AD3A:  ADDWFC 03,F
1AD3C:  MOVFF  01,885
1AD40:  MOVLB  8
1AD42:  MOVFF  03,886
1AD46:  BCF    FD8.0
1AD48:  MOVLB  7
1AD4A:  RLCF   x40,W
1AD4C:  CLRF   03
1AD4E:  ADDLW  76
1AD50:  MOVWF  FE9
1AD52:  MOVLW  07
1AD54:  ADDWFC 03,W
1AD56:  MOVWF  FEA
1AD58:  MOVFF  FEC,8DC
1AD5C:  MOVF   FED,F
1AD5E:  MOVFF  FEF,8DB
1AD62:  BCF    FD8.0
1AD64:  RLCF   x40,W
1AD66:  CLRF   03
1AD68:  ADDLW  62
1AD6A:  MOVWF  FE9
1AD6C:  MOVLW  07
1AD6E:  ADDWFC 03,W
1AD70:  MOVWF  FEA
1AD72:  MOVFF  FEC,03
1AD76:  MOVF   FED,F
1AD78:  MOVFF  FEF,8DD
1AD7C:  MOVFF  03,88A
1AD80:  MOVFF  03,8DE
1AD84:  MOVLB  0
1AD86:  CALL   2CFC
1AD8A:  MOVFF  02,888
1AD8E:  BCF    FD8.0
1AD90:  MOVLB  8
1AD92:  RLCF   01,W
1AD94:  MOVWF  02
1AD96:  RLCF   x88,W
1AD98:  MOVFF  886,FEA
1AD9C:  MOVFF  885,FE9
1ADA0:  MOVWF  FEC
1ADA2:  MOVF   FED,F
1ADA4:  MOVFF  02,FEF
....................       switch(motor){ 
1ADA8:  MOVLB  7
1ADAA:  MOVF   x40,W
1ADAC:  XORLW  00
1ADAE:  MOVLB  0
1ADB0:  BZ    1ADB8
1ADB2:  XORLW  01
1ADB4:  BZ    1ADE2
1ADB6:  BRA    1AE0A
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1ADB8:  BCF    FD8.0
1ADBA:  MOVLB  7
1ADBC:  RLCF   x40,W
1ADBE:  CLRF   03
1ADC0:  ADDLW  76
1ADC2:  MOVWF  FE9
1ADC4:  MOVLW  07
1ADC6:  ADDWFC 03,W
1ADC8:  MOVWF  FEA
1ADCA:  MOVFF  FEC,8F0
1ADCE:  MOVF   FED,F
1ADD0:  MOVFF  FEF,8EF
1ADD4:  MOVLW  AE
1ADD6:  MOVLB  8
1ADD8:  MOVWF  xEE
1ADDA:  MOVLB  0
1ADDC:  CALL   4FFC
....................             break; 
1ADE0:  BRA    1AE0A
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1ADE2:  BCF    FD8.0
1ADE4:  MOVLB  7
1ADE6:  RLCF   x40,W
1ADE8:  CLRF   03
1ADEA:  ADDLW  76
1ADEC:  MOVWF  FE9
1ADEE:  MOVLW  07
1ADF0:  ADDWFC 03,W
1ADF2:  MOVWF  FEA
1ADF4:  MOVFF  FEC,8F0
1ADF8:  MOVF   FED,F
1ADFA:  MOVFF  FEF,8EF
1ADFE:  MOVLW  B0
1AE00:  MOVLB  8
1AE02:  MOVWF  xEE
1AE04:  MOVLB  0
1AE06:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1AE0A:  BRA    1AE10
....................    else cmd_arg();    
1AE0C:  CALL   B32E
1AE10:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1AE14:  MOVF   4B,F
1AE16:  BNZ   1AEA2
1AE18:  MOVF   4A,F
1AE1A:  BNZ   1AEA2
1AE1C:  MOVF   49,F
1AE1E:  BNZ   1AEA2
1AE20:  MOVF   48,W
1AE22:  SUBLW  02
1AE24:  BNC   1AEA2
....................       e_type[motor] = arg; 
1AE26:  BCF    FD8.0
1AE28:  MOVLB  7
1AE2A:  RLCF   x40,W
1AE2C:  CLRF   03
1AE2E:  ADDLW  6A
1AE30:  MOVWF  FE9
1AE32:  MOVLW  07
1AE34:  ADDWFC 03,W
1AE36:  MOVWF  FEA
1AE38:  MOVFF  48,FEF
1AE3C:  MOVFF  49,FEC
....................       switch(motor){ 
1AE40:  MOVF   x40,W
1AE42:  XORLW  00
1AE44:  MOVLB  0
1AE46:  BZ    1AE4E
1AE48:  XORLW  01
1AE4A:  BZ    1AE78
1AE4C:  BRA    1AEA0
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1AE4E:  BCF    FD8.0
1AE50:  MOVLB  7
1AE52:  RLCF   x40,W
1AE54:  CLRF   03
1AE56:  ADDLW  6A
1AE58:  MOVWF  FE9
1AE5A:  MOVLW  07
1AE5C:  ADDWFC 03,W
1AE5E:  MOVWF  FEA
1AE60:  MOVFF  FEC,8F0
1AE64:  MOVF   FED,F
1AE66:  MOVFF  FEF,8EF
1AE6A:  MOVLW  7A
1AE6C:  MOVLB  8
1AE6E:  MOVWF  xEE
1AE70:  MOVLB  0
1AE72:  CALL   4FFC
....................             break; 
1AE76:  BRA    1AEA0
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1AE78:  BCF    FD8.0
1AE7A:  MOVLB  7
1AE7C:  RLCF   x40,W
1AE7E:  CLRF   03
1AE80:  ADDLW  6A
1AE82:  MOVWF  FE9
1AE84:  MOVLW  07
1AE86:  ADDWFC 03,W
1AE88:  MOVWF  FEA
1AE8A:  MOVFF  FEC,8F0
1AE8E:  MOVF   FED,F
1AE90:  MOVFF  FEF,8EF
1AE94:  MOVLW  7C
1AE96:  MOVLB  8
1AE98:  MOVWF  xEE
1AE9A:  MOVLB  0
1AE9C:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1AEA0:  BRA    1AEA6
....................    else cmd_arg();    
1AEA2:  CALL   B32E
1AEA6:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... //currently used to test dio pins 
.................... void command_v(){ 
....................    if(arg == 00){ 
*
13E08:  MOVF   48,F
13E0A:  BNZ   13E1C
13E0C:  MOVF   49,F
13E0E:  BNZ   13E1C
13E10:  MOVF   4A,F
13E12:  BNZ   13E1C
13E14:  MOVF   4B,F
13E16:  BNZ   13E1C
....................       output_bit(PIN_D0,0); 
13E18:  BCF    F8C.0
....................    }else if(arg == 01){ 
13E1A:  BRA    13F62
13E1C:  DECFSZ 48,W
13E1E:  BRA    13E30
13E20:  MOVF   49,F
13E22:  BNZ   13E30
13E24:  MOVF   4A,F
13E26:  BNZ   13E30
13E28:  MOVF   4B,F
13E2A:  BNZ   13E30
....................       output_bit(PIN_D0,1); 
13E2C:  BSF    F8C.0
....................    }else if(arg == 10){ 
13E2E:  BRA    13F62
13E30:  MOVF   48,W
13E32:  SUBLW  0A
13E34:  BNZ   13E46
13E36:  MOVF   49,F
13E38:  BNZ   13E46
13E3A:  MOVF   4A,F
13E3C:  BNZ   13E46
13E3E:  MOVF   4B,F
13E40:  BNZ   13E46
....................       output_bit(PIN_D1,0); 
13E42:  BCF    F8C.1
....................    }else if(arg == 11){ 
13E44:  BRA    13F62
13E46:  MOVF   48,W
13E48:  SUBLW  0B
13E4A:  BNZ   13E5C
13E4C:  MOVF   49,F
13E4E:  BNZ   13E5C
13E50:  MOVF   4A,F
13E52:  BNZ   13E5C
13E54:  MOVF   4B,F
13E56:  BNZ   13E5C
....................       output_bit(PIN_D1,1); 
13E58:  BSF    F8C.1
....................    }else if(arg == 20){ 
13E5A:  BRA    13F62
13E5C:  MOVF   48,W
13E5E:  SUBLW  14
13E60:  BNZ   13E72
13E62:  MOVF   49,F
13E64:  BNZ   13E72
13E66:  MOVF   4A,F
13E68:  BNZ   13E72
13E6A:  MOVF   4B,F
13E6C:  BNZ   13E72
....................       output_bit(PIN_D2,0); 
13E6E:  BCF    F8C.2
....................    }else if(arg == 21){ 
13E70:  BRA    13F62
13E72:  MOVF   48,W
13E74:  SUBLW  15
13E76:  BNZ   13E88
13E78:  MOVF   49,F
13E7A:  BNZ   13E88
13E7C:  MOVF   4A,F
13E7E:  BNZ   13E88
13E80:  MOVF   4B,F
13E82:  BNZ   13E88
....................       output_bit(PIN_D2,1); 
13E84:  BSF    F8C.2
....................    }else if(arg == 30){ 
13E86:  BRA    13F62
13E88:  MOVF   48,W
13E8A:  SUBLW  1E
13E8C:  BNZ   13E9E
13E8E:  MOVF   49,F
13E90:  BNZ   13E9E
13E92:  MOVF   4A,F
13E94:  BNZ   13E9E
13E96:  MOVF   4B,F
13E98:  BNZ   13E9E
....................       output_bit(PIN_D3,0); 
13E9A:  BCF    F8C.3
....................    }else if(arg == 31){ 
13E9C:  BRA    13F62
13E9E:  MOVF   48,W
13EA0:  SUBLW  1F
13EA2:  BNZ   13EB4
13EA4:  MOVF   49,F
13EA6:  BNZ   13EB4
13EA8:  MOVF   4A,F
13EAA:  BNZ   13EB4
13EAC:  MOVF   4B,F
13EAE:  BNZ   13EB4
....................       output_bit(PIN_D3,1); 
13EB0:  BSF    F8C.3
....................    }else if(arg == 40){ 
13EB2:  BRA    13F62
13EB4:  MOVF   48,W
13EB6:  SUBLW  28
13EB8:  BNZ   13ECA
13EBA:  MOVF   49,F
13EBC:  BNZ   13ECA
13EBE:  MOVF   4A,F
13EC0:  BNZ   13ECA
13EC2:  MOVF   4B,F
13EC4:  BNZ   13ECA
....................       output_bit(PIN_D4,0); 
13EC6:  BCF    F8C.4
....................    }else if(arg == 41){ 
13EC8:  BRA    13F62
13ECA:  MOVF   48,W
13ECC:  SUBLW  29
13ECE:  BNZ   13EE0
13ED0:  MOVF   49,F
13ED2:  BNZ   13EE0
13ED4:  MOVF   4A,F
13ED6:  BNZ   13EE0
13ED8:  MOVF   4B,F
13EDA:  BNZ   13EE0
....................       output_bit(PIN_D4,1); 
13EDC:  BSF    F8C.4
....................    }else if(arg == 50){ 
13EDE:  BRA    13F62
13EE0:  MOVF   48,W
13EE2:  SUBLW  32
13EE4:  BNZ   13EF6
13EE6:  MOVF   49,F
13EE8:  BNZ   13EF6
13EEA:  MOVF   4A,F
13EEC:  BNZ   13EF6
13EEE:  MOVF   4B,F
13EF0:  BNZ   13EF6
....................       output_bit(PIN_D5,0); 
13EF2:  BCF    F8C.5
....................    }else if(arg == 51){ 
13EF4:  BRA    13F62
13EF6:  MOVF   48,W
13EF8:  SUBLW  33
13EFA:  BNZ   13F0C
13EFC:  MOVF   49,F
13EFE:  BNZ   13F0C
13F00:  MOVF   4A,F
13F02:  BNZ   13F0C
13F04:  MOVF   4B,F
13F06:  BNZ   13F0C
....................       output_bit(PIN_D5,1); 
13F08:  BSF    F8C.5
....................    }else if(arg == 60){ 
13F0A:  BRA    13F62
13F0C:  MOVF   48,W
13F0E:  SUBLW  3C
13F10:  BNZ   13F22
13F12:  MOVF   49,F
13F14:  BNZ   13F22
13F16:  MOVF   4A,F
13F18:  BNZ   13F22
13F1A:  MOVF   4B,F
13F1C:  BNZ   13F22
....................       output_bit(PIN_D6,0); 
13F1E:  BCF    F8C.6
....................    }else if(arg == 61){ 
13F20:  BRA    13F62
13F22:  MOVF   48,W
13F24:  SUBLW  3D
13F26:  BNZ   13F38
13F28:  MOVF   49,F
13F2A:  BNZ   13F38
13F2C:  MOVF   4A,F
13F2E:  BNZ   13F38
13F30:  MOVF   4B,F
13F32:  BNZ   13F38
....................       output_bit(PIN_D6,1); 
13F34:  BSF    F8C.6
....................    }else if(arg == 70){ 
13F36:  BRA    13F62
13F38:  MOVF   48,W
13F3A:  SUBLW  46
13F3C:  BNZ   13F4E
13F3E:  MOVF   49,F
13F40:  BNZ   13F4E
13F42:  MOVF   4A,F
13F44:  BNZ   13F4E
13F46:  MOVF   4B,F
13F48:  BNZ   13F4E
....................       output_bit(PIN_D7,0); 
13F4A:  BCF    F8C.7
....................    }else if(arg == 71){ 
13F4C:  BRA    13F62
13F4E:  MOVF   48,W
13F50:  SUBLW  47
13F52:  BNZ   13F62
13F54:  MOVF   49,F
13F56:  BNZ   13F62
13F58:  MOVF   4A,F
13F5A:  BNZ   13F62
13F5C:  MOVF   4B,F
13F5E:  BNZ   13F62
....................       output_bit(PIN_D7,1); 
13F60:  BSF    F8C.7
....................    } 
13F62:  RETURN 0
.................... } 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
*
1AEE2:  MOVF   4B,F
1AEE4:  BNZ   1AFAE
1AEE6:  MOVF   4A,F
1AEE8:  BNZ   1AFAE
1AEEA:  MOVF   49,F
1AEEC:  BNZ   1AFAE
1AEEE:  MOVF   48,W
1AEF0:  SUBLW  64
1AEF2:  BNC   1AFAE
....................       drive_pc=arg; 
1AEF4:  MOVFF  49,886
1AEF8:  MOVFF  48,885
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1AEFC:  BCF    FD8.0
1AEFE:  MOVLB  7
1AF00:  RLCF   x40,W
1AF02:  CLRF   03
1AF04:  ADDLW  56
1AF06:  MOVWF  FE9
1AF08:  MOVLW  07
1AF0A:  ADDWFC 03,W
1AF0C:  MOVWF  FEA
1AF0E:  MOVFF  886,A11
1AF12:  MOVFF  885,A10
1AF16:  MOVLW  01
1AF18:  MOVLB  A
1AF1A:  MOVWF  x13
1AF1C:  SETF   x12
1AF1E:  MOVLB  0
1AF20:  CALL   5CC0
1AF24:  MOVFF  02,88A
1AF28:  MOVFF  01,889
1AF2C:  MOVFF  02,8DC
1AF30:  MOVFF  01,8DB
1AF34:  MOVLB  8
1AF36:  CLRF   xDE
1AF38:  MOVLW  64
1AF3A:  MOVWF  xDD
1AF3C:  MOVLB  0
1AF3E:  CALL   2CFC
1AF42:  MOVFF  01,FEF
1AF46:  MOVFF  02,FEC
....................       switch(motor){ 
1AF4A:  MOVLB  7
1AF4C:  MOVF   x40,W
1AF4E:  XORLW  00
1AF50:  MOVLB  0
1AF52:  BZ    1AF5A
1AF54:  XORLW  01
1AF56:  BZ    1AF84
1AF58:  BRA    1AFAC
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1AF5A:  BCF    FD8.0
1AF5C:  MOVLB  7
1AF5E:  RLCF   x40,W
1AF60:  CLRF   03
1AF62:  ADDLW  56
1AF64:  MOVWF  FE9
1AF66:  MOVLW  07
1AF68:  ADDWFC 03,W
1AF6A:  MOVWF  FEA
1AF6C:  MOVFF  FEC,8F0
1AF70:  MOVF   FED,F
1AF72:  MOVFF  FEF,8EF
1AF76:  MOVLW  9A
1AF78:  MOVLB  8
1AF7A:  MOVWF  xEE
1AF7C:  MOVLB  0
1AF7E:  CALL   4FFC
....................             break; 
1AF82:  BRA    1AFAC
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1AF84:  BCF    FD8.0
1AF86:  MOVLB  7
1AF88:  RLCF   x40,W
1AF8A:  CLRF   03
1AF8C:  ADDLW  56
1AF8E:  MOVWF  FE9
1AF90:  MOVLW  07
1AF92:  ADDWFC 03,W
1AF94:  MOVWF  FEA
1AF96:  MOVFF  FEC,8F0
1AF9A:  MOVF   FED,F
1AF9C:  MOVFF  FEF,8EF
1AFA0:  MOVLW  9C
1AFA2:  MOVLB  8
1AFA4:  MOVWF  xEE
1AFA6:  MOVLB  0
1AFA8:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1AFAC:  BRA    1AFB2
....................    else cmd_arg();    
1AFAE:  CALL   B32E
1AFB2:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1AFB6:  MOVF   4B,F
1AFB8:  BNZ   1B048
1AFBA:  MOVF   4A,F
1AFBC:  BNZ   1B048
1AFBE:  MOVF   49,W
1AFC0:  SUBLW  27
1AFC2:  BNC   1B048
1AFC4:  BNZ   1AFCC
1AFC6:  MOVF   48,W
1AFC8:  SUBLW  0F
1AFCA:  BNC   1B048
....................        align_os[motor] = arg; 
1AFCC:  BCF    FD8.0
1AFCE:  MOVLB  7
1AFD0:  RLCF   x40,W
1AFD2:  CLRF   03
1AFD4:  ADDLW  82
1AFD6:  MOVWF  FE9
1AFD8:  MOVLW  07
1AFDA:  ADDWFC 03,W
1AFDC:  MOVWF  FEA
1AFDE:  MOVFF  48,FEF
1AFE2:  MOVFF  49,FEC
....................        switch(motor){ 
1AFE6:  MOVF   x40,W
1AFE8:  XORLW  00
1AFEA:  MOVLB  0
1AFEC:  BZ    1AFF4
1AFEE:  XORLW  01
1AFF0:  BZ    1B01E
1AFF2:  BRA    1B046
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1AFF4:  BCF    FD8.0
1AFF6:  MOVLB  7
1AFF8:  RLCF   x40,W
1AFFA:  CLRF   03
1AFFC:  ADDLW  82
1AFFE:  MOVWF  FE9
1B000:  MOVLW  07
1B002:  ADDWFC 03,W
1B004:  MOVWF  FEA
1B006:  MOVFF  FEC,8F0
1B00A:  MOVF   FED,F
1B00C:  MOVFF  FEF,8EF
1B010:  MOVLW  C2
1B012:  MOVLB  8
1B014:  MOVWF  xEE
1B016:  MOVLB  0
1B018:  CALL   4FFC
....................             break; 
1B01C:  BRA    1B046
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1B01E:  BCF    FD8.0
1B020:  MOVLB  7
1B022:  RLCF   x40,W
1B024:  CLRF   03
1B026:  ADDLW  82
1B028:  MOVWF  FE9
1B02A:  MOVLW  07
1B02C:  ADDWFC 03,W
1B02E:  MOVWF  FEA
1B030:  MOVFF  FEC,8F0
1B034:  MOVF   FED,F
1B036:  MOVFF  FEF,8EF
1B03A:  MOVLW  C4
1B03C:  MOVLB  8
1B03E:  MOVWF  xEE
1B040:  MOVLB  0
1B042:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1B046:  BRA    1B04C
....................    else cmd_arg();    
1B048:  CALL   B32E
1B04C:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1B050:  MOVF   4B,F
1B052:  BNZ   1B0DE
1B054:  MOVF   4A,F
1B056:  BNZ   1B0DE
1B058:  MOVF   49,F
1B05A:  BNZ   1B0DE
1B05C:  MOVF   48,W
1B05E:  SUBLW  01
1B060:  BNC   1B0DE
....................       m_ctrl[motor] = arg; 
1B062:  BCF    FD8.0
1B064:  MOVLB  7
1B066:  RLCF   x40,W
1B068:  CLRF   03
1B06A:  ADDLW  42
1B06C:  MOVWF  FE9
1B06E:  MOVLW  07
1B070:  ADDWFC 03,W
1B072:  MOVWF  FEA
1B074:  MOVFF  48,FEF
1B078:  MOVFF  49,FEC
....................       switch(motor){ 
1B07C:  MOVF   x40,W
1B07E:  XORLW  00
1B080:  MOVLB  0
1B082:  BZ    1B08A
1B084:  XORLW  01
1B086:  BZ    1B0B4
1B088:  BRA    1B0DC
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1B08A:  BCF    FD8.0
1B08C:  MOVLB  7
1B08E:  RLCF   x40,W
1B090:  CLRF   03
1B092:  ADDLW  42
1B094:  MOVWF  FE9
1B096:  MOVLW  07
1B098:  ADDWFC 03,W
1B09A:  MOVWF  FEA
1B09C:  MOVFF  FEC,8F0
1B0A0:  MOVF   FED,F
1B0A2:  MOVFF  FEF,8EF
1B0A6:  MOVLW  86
1B0A8:  MOVLB  8
1B0AA:  MOVWF  xEE
1B0AC:  MOVLB  0
1B0AE:  CALL   4FFC
....................             break; 
1B0B2:  BRA    1B0DC
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1B0B4:  BCF    FD8.0
1B0B6:  MOVLB  7
1B0B8:  RLCF   x40,W
1B0BA:  CLRF   03
1B0BC:  ADDLW  42
1B0BE:  MOVWF  FE9
1B0C0:  MOVLW  07
1B0C2:  ADDWFC 03,W
1B0C4:  MOVWF  FEA
1B0C6:  MOVFF  FEC,8F0
1B0CA:  MOVF   FED,F
1B0CC:  MOVFF  FEF,8EF
1B0D0:  MOVLW  88
1B0D2:  MOVLB  8
1B0D4:  MOVWF  xEE
1B0D6:  MOVLB  0
1B0D8:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1B0DC:  BRA    1B0E2
....................    else cmd_arg();    
1B0DE:  CALL   B32E
1B0E2:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1AEAA:  MOVF   48,W
1AEAC:  MOVWF  00
1AEAE:  MOVF   49,W
1AEB0:  MOVWF  03
1AEB2:  BNZ   1AEBA
1AEB4:  MOVLW  01
1AEB6:  SUBWF  00,W
1AEB8:  BZ    1AEC6
1AEBA:  MOVF   03,W
1AEBC:  BNZ   1AEC4
1AEBE:  MOVLW  02
1AEC0:  SUBWF  00,W
1AEC2:  BZ    1AECC
1AEC4:  BRA    1AED6
....................       case 1: motor = 0; 
1AEC6:  MOVLB  7
1AEC8:  CLRF   x40
....................          break; 
1AECA:  BRA    1AEDC
....................       case 2: motor = 1; 
1AECC:  MOVLW  01
1AECE:  MOVLB  7
1AED0:  MOVWF  x40
....................          break; 
1AED2:  BRA    1AEDC
1AED4:  MOVLB  0
....................       default : cmd_arg(); 
1AED6:  CALL   B32E
....................          break; 
1AEDA:  MOVLB  7
....................    } 
1AEDC:  MOVLB  0
1AEDE:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1B0E6:  MOVF   48,F
1B0E8:  BNZ   1B0F6
1B0EA:  MOVF   49,F
1B0EC:  BNZ   1B0F6
1B0EE:  MOVF   4A,F
1B0F0:  BNZ   1B0F6
1B0F2:  MOVF   4B,F
1B0F4:  BZ    1B154
1B0F6:  MOVF   4B,F
1B0F8:  BNZ   1B154
1B0FA:  MOVF   4A,F
1B0FC:  BNZ   1B154
1B0FE:  MOVF   49,F
1B100:  BNZ   1B154
1B102:  MOVF   48,W
1B104:  SUBLW  02
1B106:  BNC   1B154
....................       switch(arg){ 
1B108:  MOVFF  48,00
1B10C:  MOVF   49,W
1B10E:  MOVWF  03
1B110:  BNZ   1B118
1B112:  MOVLW  01
1B114:  SUBWF  00,W
1B116:  BZ    1B124
1B118:  MOVF   03,W
1B11A:  BNZ   1B122
1B11C:  MOVLW  02
1B11E:  SUBWF  00,W
1B120:  BZ    1B13C
1B122:  BRA    1B152
....................          case 1 : e_pos[0] = 0; 
1B124:  MOVLB  7
1B126:  CLRF   xC0
1B128:  CLRF   xBF
....................                   write16(ADDR_E1_POS, 0); 
1B12A:  MOVLW  7E
1B12C:  MOVLB  8
1B12E:  MOVWF  xEE
1B130:  CLRF   xF0
1B132:  CLRF   xEF
1B134:  MOVLB  0
1B136:  CALL   4FFC
....................             break; 
1B13A:  BRA    1B152
....................          case 2 : e_pos[1] = 0; 
1B13C:  MOVLB  7
1B13E:  CLRF   xC2
1B140:  CLRF   xC1
....................                   write16(ADDR_E2_POS, 0); 
1B142:  MOVLW  80
1B144:  MOVLB  8
1B146:  MOVWF  xEE
1B148:  CLRF   xF0
1B14A:  CLRF   xEF
1B14C:  MOVLB  0
1B14E:  CALL   4FFC
....................             break;             
....................       } 
....................    } 
1B152:  BRA    1B158
....................    else cmd_arg();  
1B154:  CALL   B32E
1B158:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
192F0:  DECFSZ 48,W
192F2:  GOTO   19F48
192F6:  MOVF   49,F
192F8:  BTFSS  FD8.2
192FA:  GOTO   19F48
192FE:  MOVF   4A,F
19300:  BTFSS  FD8.2
19302:  GOTO   19F48
19306:  MOVF   4B,F
19308:  BTFSS  FD8.2
1930A:  GOTO   19F48
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
1930E:  MOVFF  753,A11
19312:  MOVFF  752,A10
19316:  MOVLB  A
19318:  CLRF   x13
1931A:  MOVLW  64
1931C:  MOVWF  x12
1931E:  MOVLB  0
19320:  CALL   5CC0
19324:  MOVFF  02,88C
19328:  MOVFF  01,88B
1932C:  MOVFF  02,8DC
19330:  MOVFF  01,8DB
19334:  MOVLW  01
19336:  MOVLB  8
19338:  MOVWF  xDE
1933A:  SETF   xDD
1933C:  MOVLB  0
1933E:  CALL   2CFC
19342:  MOVFF  02,886
19346:  MOVFF  01,885
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
1934A:  MOVFF  757,A11
1934E:  MOVFF  756,A10
19352:  MOVLB  A
19354:  CLRF   x13
19356:  MOVLW  64
19358:  MOVWF  x12
1935A:  MOVLB  0
1935C:  CALL   5CC0
19360:  MOVFF  02,88C
19364:  MOVFF  01,88B
19368:  MOVFF  02,8DC
1936C:  MOVFF  01,8DB
19370:  MOVLW  01
19372:  MOVLB  8
19374:  MOVWF  xDE
19376:  SETF   xDD
19378:  MOVLB  0
1937A:  CALL   2CFC
1937E:  MOVFF  02,888
19382:  MOVFF  01,887
....................       step_us  =   m_stp_int[0]*100; 
19386:  MOVFF  74B,A11
1938A:  MOVFF  74A,A10
1938E:  MOVLB  A
19390:  CLRF   x13
19392:  MOVLW  64
19394:  MOVWF  x12
19396:  MOVLB  0
19398:  CALL   5CC0
1939C:  MOVFF  02,88A
193A0:  MOVFF  01,889
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
193A4:  MOVLW  3A
193A6:  MOVWF  FF6
193A8:  MOVLW  27
193AA:  MOVWF  FF7
193AC:  MOVLW  00
193AE:  MOVWF  FF8
193B0:  CLRF   1B
193B2:  BTFSC  FF2.7
193B4:  BSF    1B.7
193B6:  BCF    FF2.7
193B8:  CALL   0E6E
193BC:  BTFSC  1B.7
193BE:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
193C0:  MOVLW  62
193C2:  BTFSS  F9E.4
193C4:  BRA    193C2
193C6:  MOVWF  FAD
193C8:  MOVLW  3A
193CA:  BTFSS  F9E.4
193CC:  BRA    193CA
193CE:  MOVWF  FAD
193D0:  MOVLW  10
193D2:  MOVWF  FE9
193D4:  CLRF   1B
193D6:  BTFSC  FF2.7
193D8:  BSF    1B.7
193DA:  BCF    FF2.7
193DC:  MOVFF  773,A41
193E0:  MOVFF  772,A40
193E4:  CALL   11C6
193E8:  BTFSC  1B.7
193EA:  BSF    FF2.7
193EC:  MOVLW  0D
193EE:  BTFSS  F9E.4
193F0:  BRA    193EE
193F2:  MOVWF  FAD
193F4:  MOVLW  0A
193F6:  BTFSS  F9E.4
193F8:  BRA    193F6
193FA:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
193FC:  MOVLW  63
193FE:  BTFSS  F9E.4
19400:  BRA    193FE
19402:  MOVWF  FAD
19404:  MOVLW  3A
19406:  BTFSS  F9E.4
19408:  BRA    19406
1940A:  MOVWF  FAD
1940C:  MOVLW  41
1940E:  MOVWF  FE9
19410:  CLRF   1B
19412:  BTFSC  FF2.7
19414:  BSF    1B.7
19416:  BCF    FF2.7
19418:  MOVFF  7A5,A43
1941C:  MOVFF  7A4,A42
19420:  MOVFF  7A3,A41
19424:  MOVFF  7A2,A40
19428:  CALL   110A
1942C:  BTFSC  1B.7
1942E:  BSF    FF2.7
19430:  MOVLW  2F
19432:  BTFSS  F9E.4
19434:  BRA    19432
19436:  MOVWF  FAD
19438:  MOVLW  10
1943A:  MOVWF  FE9
1943C:  CLRF   1B
1943E:  BTFSC  FF2.7
19440:  BSF    1B.7
19442:  BCF    FF2.7
19444:  MOVFF  7BC,A41
19448:  MOVFF  7BB,A40
1944C:  CALL   11C6
19450:  BTFSC  1B.7
19452:  BSF    FF2.7
19454:  MOVLW  2F
19456:  BTFSS  F9E.4
19458:  BRA    19456
1945A:  MOVWF  FAD
1945C:  MOVLW  10
1945E:  MOVWF  FE9
19460:  CLRF   1B
19462:  BTFSC  FF2.7
19464:  BSF    1B.7
19466:  BCF    FF2.7
19468:  MOVFF  7C0,A41
1946C:  MOVFF  7BF,A40
19470:  CALL   11C6
19474:  BTFSC  1B.7
19476:  BSF    FF2.7
19478:  MOVLW  0D
1947A:  BTFSS  F9E.4
1947C:  BRA    1947A
1947E:  MOVWF  FAD
19480:  MOVLW  0A
19482:  BTFSS  F9E.4
19484:  BRA    19482
19486:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
19488:  MOVLW  64
1948A:  BTFSS  F9E.4
1948C:  BRA    1948A
1948E:  MOVWF  FAD
19490:  MOVLW  3A
19492:  BTFSS  F9E.4
19494:  BRA    19492
19496:  MOVWF  FAD
19498:  MOVLW  10
1949A:  MOVWF  FE9
1949C:  CLRF   1B
1949E:  BTFSC  FF2.7
194A0:  BSF    1B.7
194A2:  BCF    FF2.7
194A4:  MOVFF  74F,A41
194A8:  MOVFF  74E,A40
194AC:  CALL   11C6
194B0:  BTFSC  1B.7
194B2:  BSF    FF2.7
194B4:  MOVLW  0D
194B6:  BTFSS  F9E.4
194B8:  BRA    194B6
194BA:  MOVWF  FAD
194BC:  MOVLW  0A
194BE:  BTFSS  F9E.4
194C0:  BRA    194BE
194C2:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
194C4:  MOVLW  65
194C6:  BTFSS  F9E.4
194C8:  BRA    194C6
194CA:  MOVWF  FAD
194CC:  MOVLW  3A
194CE:  BTFSS  F9E.4
194D0:  BRA    194CE
194D2:  MOVWF  FAD
194D4:  MOVLW  10
194D6:  MOVWF  FE9
194D8:  CLRF   1B
194DA:  BTFSC  FF2.7
194DC:  BSF    1B.7
194DE:  BCF    FF2.7
194E0:  MOVFF  75F,A41
194E4:  MOVFF  75E,A40
194E8:  CALL   11C6
194EC:  BTFSC  1B.7
194EE:  BSF    FF2.7
194F0:  MOVLW  0D
194F2:  BTFSS  F9E.4
194F4:  BRA    194F2
194F6:  MOVWF  FAD
194F8:  MOVLW  0A
194FA:  BTFSS  F9E.4
194FC:  BRA    194FA
194FE:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19500:  MOVLW  66
19502:  BTFSS  F9E.4
19504:  BRA    19502
19506:  MOVWF  FAD
19508:  MOVLW  3A
1950A:  BTFSS  F9E.4
1950C:  BRA    1950A
1950E:  MOVWF  FAD
19510:  CLRF   1B
19512:  BTFSC  FF2.7
19514:  BSF    1B.7
19516:  BCF    FF2.7
19518:  MOVFF  741,A40
1951C:  MOVLW  1B
1951E:  MOVLB  A
19520:  MOVWF  x41
19522:  MOVLB  0
19524:  CALL   0FC6
19528:  BTFSC  1B.7
1952A:  BSF    FF2.7
1952C:  MOVLW  0D
1952E:  BTFSS  F9E.4
19530:  BRA    1952E
19532:  MOVWF  FAD
19534:  MOVLW  0A
19536:  BTFSS  F9E.4
19538:  BRA    19536
1953A:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
1953C:  MOVLW  67
1953E:  BTFSS  F9E.4
19540:  BRA    1953E
19542:  MOVWF  FAD
19544:  MOVLW  3A
19546:  BTFSS  F9E.4
19548:  BRA    19546
1954A:  MOVWF  FAD
1954C:  MOVLW  10
1954E:  MOVWF  FE9
19550:  CLRF   1B
19552:  BTFSC  FF2.7
19554:  BSF    1B.7
19556:  BCF    FF2.7
19558:  MOVFF  75B,A41
1955C:  MOVFF  75A,A40
19560:  CALL   11C6
19564:  BTFSC  1B.7
19566:  BSF    FF2.7
19568:  MOVLW  0D
1956A:  BTFSS  F9E.4
1956C:  BRA    1956A
1956E:  MOVWF  FAD
19570:  MOVLW  0A
19572:  BTFSS  F9E.4
19574:  BRA    19572
19576:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19578:  MOVLW  68
1957A:  BTFSS  F9E.4
1957C:  BRA    1957A
1957E:  MOVWF  FAD
19580:  MOVLW  3A
19582:  BTFSS  F9E.4
19584:  BRA    19582
19586:  MOVWF  FAD
19588:  MOVLW  10
1958A:  MOVWF  FE9
1958C:  CLRF   1B
1958E:  BTFSC  FF2.7
19590:  BSF    1B.7
19592:  BCF    FF2.7
19594:  MOVFF  886,A41
19598:  MOVFF  885,A40
1959C:  CALL   11C6
195A0:  BTFSC  1B.7
195A2:  BSF    FF2.7
195A4:  MOVLW  0D
195A6:  BTFSS  F9E.4
195A8:  BRA    195A6
195AA:  MOVWF  FAD
195AC:  MOVLW  0A
195AE:  BTFSS  F9E.4
195B0:  BRA    195AE
195B2:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
195B4:  MOVLW  69
195B6:  BTFSS  F9E.4
195B8:  BRA    195B6
195BA:  MOVWF  FAD
195BC:  MOVLW  3A
195BE:  BTFSS  F9E.4
195C0:  BRA    195BE
195C2:  MOVWF  FAD
195C4:  MOVLW  10
195C6:  MOVWF  FE9
195C8:  CLRF   1B
195CA:  BTFSC  FF2.7
195CC:  BSF    1B.7
195CE:  BCF    FF2.7
195D0:  MOVFF  88A,A41
195D4:  MOVFF  889,A40
195D8:  CALL   11C6
195DC:  BTFSC  1B.7
195DE:  BSF    FF2.7
195E0:  MOVLW  0D
195E2:  BTFSS  F9E.4
195E4:  BRA    195E2
195E6:  MOVWF  FAD
195E8:  MOVLW  0A
195EA:  BTFSS  F9E.4
195EC:  BRA    195EA
195EE:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
195F0:  MOVLW  6A
195F2:  BTFSS  F9E.4
195F4:  BRA    195F2
195F6:  MOVWF  FAD
195F8:  MOVLW  3A
195FA:  BTFSS  F9E.4
195FC:  BRA    195FA
195FE:  MOVWF  FAD
19600:  MOVLW  10
19602:  MOVWF  FE9
19604:  CLRF   1B
19606:  BTFSC  FF2.7
19608:  BSF    1B.7
1960A:  BCF    FF2.7
1960C:  MOVFF  76F,A41
19610:  MOVFF  76E,A40
19614:  CALL   11C6
19618:  BTFSC  1B.7
1961A:  BSF    FF2.7
1961C:  MOVLW  0D
1961E:  BTFSS  F9E.4
19620:  BRA    1961E
19622:  MOVWF  FAD
19624:  MOVLW  0A
19626:  BTFSS  F9E.4
19628:  BRA    19626
1962A:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
1962C:  MOVLW  6B
1962E:  BTFSS  F9E.4
19630:  BRA    1962E
19632:  MOVWF  FAD
19634:  MOVLW  3A
19636:  BTFSS  F9E.4
19638:  BRA    19636
1963A:  MOVWF  FAD
1963C:  MOVLW  10
1963E:  MOVWF  FE9
19640:  CLRF   1B
19642:  BTFSC  FF2.7
19644:  BSF    1B.7
19646:  BCF    FF2.7
19648:  MOVFF  767,A41
1964C:  MOVFF  766,A40
19650:  CALL   11C6
19654:  BTFSC  1B.7
19656:  BSF    FF2.7
19658:  MOVLW  0D
1965A:  BTFSS  F9E.4
1965C:  BRA    1965A
1965E:  MOVWF  FAD
19660:  MOVLW  0A
19662:  BTFSS  F9E.4
19664:  BRA    19662
19666:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
19668:  MOVLW  6D
1966A:  BTFSS  F9E.4
1966C:  BRA    1966A
1966E:  MOVWF  FAD
19670:  MOVLW  3A
19672:  BTFSS  F9E.4
19674:  BRA    19672
19676:  MOVWF  FAD
19678:  MOVLW  10
1967A:  MOVWF  FE9
1967C:  CLRF   1B
1967E:  BTFSC  FF2.7
19680:  BSF    1B.7
19682:  BCF    FF2.7
19684:  MOVFF  747,A41
19688:  MOVFF  746,A40
1968C:  CALL   11C6
19690:  BTFSC  1B.7
19692:  BSF    FF2.7
19694:  MOVLW  0D
19696:  BTFSS  F9E.4
19698:  BRA    19696
1969A:  MOVWF  FAD
1969C:  MOVLW  0A
1969E:  BTFSS  F9E.4
196A0:  BRA    1969E
196A2:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
196A4:  MOVLW  6E
196A6:  BTFSS  F9E.4
196A8:  BRA    196A6
196AA:  MOVWF  FAD
196AC:  MOVLW  3A
196AE:  BTFSS  F9E.4
196B0:  BRA    196AE
196B2:  MOVWF  FAD
196B4:  MOVLW  10
196B6:  MOVWF  FE9
196B8:  CLRF   1B
196BA:  BTFSC  FF2.7
196BC:  BSF    1B.7
196BE:  BCF    FF2.7
196C0:  MOVFF  77B,A41
196C4:  MOVFF  77A,A40
196C8:  CALL   11C6
196CC:  BTFSC  1B.7
196CE:  BSF    FF2.7
196D0:  MOVLW  0D
196D2:  BTFSS  F9E.4
196D4:  BRA    196D2
196D6:  MOVWF  FAD
196D8:  MOVLW  0A
196DA:  BTFSS  F9E.4
196DC:  BRA    196DA
196DE:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
196E0:  MOVLW  6F
196E2:  BTFSS  F9E.4
196E4:  BRA    196E2
196E6:  MOVWF  FAD
196E8:  MOVLW  3A
196EA:  BTFSS  F9E.4
196EC:  BRA    196EA
196EE:  MOVWF  FAD
196F0:  MOVLW  10
196F2:  MOVWF  FE9
196F4:  CLRF   1B
196F6:  BTFSC  FF2.7
196F8:  BSF    1B.7
196FA:  BCF    FF2.7
196FC:  MOVFF  77F,A41
19700:  MOVFF  77E,A40
19704:  CALL   11C6
19708:  BTFSC  1B.7
1970A:  BSF    FF2.7
1970C:  MOVLW  0D
1970E:  BTFSS  F9E.4
19710:  BRA    1970E
19712:  MOVWF  FAD
19714:  MOVLW  0A
19716:  BTFSS  F9E.4
19718:  BRA    19716
1971A:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
1971C:  MOVLW  70
1971E:  BTFSS  F9E.4
19720:  BRA    1971E
19722:  MOVWF  FAD
19724:  MOVLW  3A
19726:  BTFSS  F9E.4
19728:  BRA    19726
1972A:  MOVWF  FAD
1972C:  MOVLW  10
1972E:  MOVWF  FE9
19730:  CLRF   1B
19732:  BTFSC  FF2.7
19734:  BSF    1B.7
19736:  BCF    FF2.7
19738:  MOVFF  7C4,A41
1973C:  MOVFF  7C3,A40
19740:  CALL   11C6
19744:  BTFSC  1B.7
19746:  BSF    FF2.7
19748:  MOVLW  2F
1974A:  BTFSS  F9E.4
1974C:  BRA    1974A
1974E:  MOVWF  FAD
19750:  MOVLW  10
19752:  MOVWF  FE9
19754:  CLRF   1B
19756:  BTFSC  FF2.7
19758:  BSF    1B.7
1975A:  BCF    FF2.7
1975C:  MOVFF  763,A41
19760:  MOVFF  762,A40
19764:  CALL   11C6
19768:  BTFSC  1B.7
1976A:  BSF    FF2.7
1976C:  MOVLW  0D
1976E:  BTFSS  F9E.4
19770:  BRA    1976E
19772:  MOVWF  FAD
19774:  MOVLW  0A
19776:  BTFSS  F9E.4
19778:  BRA    19776
1977A:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
1977C:  MOVLW  71
1977E:  BTFSS  F9E.4
19780:  BRA    1977E
19782:  MOVWF  FAD
19784:  MOVLW  3A
19786:  BTFSS  F9E.4
19788:  BRA    19786
1978A:  MOVWF  FAD
1978C:  MOVLW  10
1978E:  MOVWF  FE9
19790:  CLRF   1B
19792:  BTFSC  FF2.7
19794:  BSF    1B.7
19796:  BCF    FF2.7
19798:  MOVFF  797,A41
1979C:  MOVFF  796,A40
197A0:  CALL   11C6
197A4:  BTFSC  1B.7
197A6:  BSF    FF2.7
197A8:  MOVLW  0D
197AA:  BTFSS  F9E.4
197AC:  BRA    197AA
197AE:  MOVWF  FAD
197B0:  MOVLW  0A
197B2:  BTFSS  F9E.4
197B4:  BRA    197B2
197B6:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
197B8:  MOVLW  73
197BA:  BTFSS  F9E.4
197BC:  BRA    197BA
197BE:  MOVWF  FAD
197C0:  MOVLW  3A
197C2:  BTFSS  F9E.4
197C4:  BRA    197C2
197C6:  MOVWF  FAD
197C8:  MOVLW  10
197CA:  MOVWF  FE9
197CC:  CLRF   1B
197CE:  BTFSC  FF2.7
197D0:  BSF    1B.7
197D2:  BCF    FF2.7
197D4:  MOVFF  777,A41
197D8:  MOVFF  776,A40
197DC:  CALL   11C6
197E0:  BTFSC  1B.7
197E2:  BSF    FF2.7
197E4:  MOVLW  0D
197E6:  BTFSS  F9E.4
197E8:  BRA    197E6
197EA:  MOVWF  FAD
197EC:  MOVLW  0A
197EE:  BTFSS  F9E.4
197F0:  BRA    197EE
197F2:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
197F4:  MOVLW  74
197F6:  BTFSS  F9E.4
197F8:  BRA    197F6
197FA:  MOVWF  FAD
197FC:  MOVLW  3A
197FE:  BTFSS  F9E.4
19800:  BRA    197FE
19802:  MOVWF  FAD
19804:  MOVLW  10
19806:  MOVWF  FE9
19808:  CLRF   1B
1980A:  BTFSC  FF2.7
1980C:  BSF    1B.7
1980E:  BCF    FF2.7
19810:  MOVFF  76B,A41
19814:  MOVFF  76A,A40
19818:  CALL   11C6
1981C:  BTFSC  1B.7
1981E:  BSF    FF2.7
19820:  MOVLW  0D
19822:  BTFSS  F9E.4
19824:  BRA    19822
19826:  MOVWF  FAD
19828:  MOVLW  0A
1982A:  BTFSS  F9E.4
1982C:  BRA    1982A
1982E:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19830:  MOVLW  01
19832:  MOVLB  7
19834:  ADDWF  x40,W
19836:  MOVLB  8
19838:  MOVWF  x8B
1983A:  MOVLW  75
1983C:  BTFSS  F9E.4
1983E:  BRA    1983C
19840:  MOVWF  FAD
19842:  MOVLW  3A
19844:  BTFSS  F9E.4
19846:  BRA    19844
19848:  MOVWF  FAD
1984A:  CLRF   1B
1984C:  BTFSC  FF2.7
1984E:  BSF    1B.7
19850:  BCF    FF2.7
19852:  MOVFF  88B,A40
19856:  MOVLW  1B
19858:  MOVLB  A
1985A:  MOVWF  x41
1985C:  MOVLB  0
1985E:  CALL   0FC6
19862:  BTFSC  1B.7
19864:  BSF    FF2.7
19866:  MOVLW  0D
19868:  BTFSS  F9E.4
1986A:  BRA    19868
1986C:  MOVWF  FAD
1986E:  MOVLW  0A
19870:  BTFSS  F9E.4
19872:  BRA    19870
19874:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19876:  MOVLW  77
19878:  BTFSS  F9E.4
1987A:  BRA    19878
1987C:  MOVWF  FAD
1987E:  MOVLW  3A
19880:  BTFSS  F9E.4
19882:  BRA    19880
19884:  MOVWF  FAD
19886:  MOVLW  10
19888:  MOVWF  FE9
1988A:  CLRF   1B
1988C:  BTFSC  FF2.7
1988E:  BSF    1B.7
19890:  BCF    FF2.7
19892:  MOVFF  888,A41
19896:  MOVFF  887,A40
1989A:  CALL   11C6
1989E:  BTFSC  1B.7
198A0:  BSF    FF2.7
198A2:  MOVLW  0D
198A4:  BTFSS  F9E.4
198A6:  BRA    198A4
198A8:  MOVWF  FAD
198AA:  MOVLW  0A
198AC:  BTFSS  F9E.4
198AE:  BRA    198AC
198B0:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
198B2:  MOVLW  78
198B4:  BTFSS  F9E.4
198B6:  BRA    198B4
198B8:  MOVWF  FAD
198BA:  MOVLW  3A
198BC:  BTFSS  F9E.4
198BE:  BRA    198BC
198C0:  MOVWF  FAD
198C2:  MOVLW  10
198C4:  MOVWF  FE9
198C6:  CLRF   1B
198C8:  BTFSC  FF2.7
198CA:  BSF    1B.7
198CC:  BCF    FF2.7
198CE:  MOVFF  783,A41
198D2:  MOVFF  782,A40
198D6:  CALL   11C6
198DA:  BTFSC  1B.7
198DC:  BSF    FF2.7
198DE:  MOVLW  0D
198E0:  BTFSS  F9E.4
198E2:  BRA    198E0
198E4:  MOVWF  FAD
198E6:  MOVLW  0A
198E8:  BTFSS  F9E.4
198EA:  BRA    198E8
198EC:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
198EE:  MOVLW  79
198F0:  BTFSS  F9E.4
198F2:  BRA    198F0
198F4:  MOVWF  FAD
198F6:  MOVLW  3A
198F8:  BTFSS  F9E.4
198FA:  BRA    198F8
198FC:  MOVWF  FAD
198FE:  MOVLW  10
19900:  MOVWF  FE9
19902:  CLRF   1B
19904:  BTFSC  FF2.7
19906:  BSF    1B.7
19908:  BCF    FF2.7
1990A:  MOVFF  743,A41
1990E:  MOVFF  742,A40
19912:  CALL   11C6
19916:  BTFSC  1B.7
19918:  BSF    FF2.7
1991A:  MOVLW  0D
1991C:  BTFSS  F9E.4
1991E:  BRA    1991C
19920:  MOVWF  FAD
19922:  MOVLW  0A
19924:  BTFSS  F9E.4
19926:  BRA    19924
19928:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
1992A:  MOVFF  755,A11
1992E:  MOVFF  754,A10
19932:  MOVLB  A
19934:  CLRF   x13
19936:  MOVLW  64
19938:  MOVWF  x12
1993A:  MOVLB  0
1993C:  CALL   5CC0
19940:  MOVFF  02,88C
19944:  MOVFF  01,88B
19948:  MOVFF  02,8DC
1994C:  MOVFF  01,8DB
19950:  MOVLW  01
19952:  MOVLB  8
19954:  MOVWF  xDE
19956:  SETF   xDD
19958:  MOVLB  0
1995A:  CALL   2CFC
1995E:  MOVFF  02,886
19962:  MOVFF  01,885
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19966:  MOVFF  759,A11
1996A:  MOVFF  758,A10
1996E:  MOVLB  A
19970:  CLRF   x13
19972:  MOVLW  64
19974:  MOVWF  x12
19976:  MOVLB  0
19978:  CALL   5CC0
1997C:  MOVFF  02,88C
19980:  MOVFF  01,88B
19984:  MOVFF  02,8DC
19988:  MOVFF  01,8DB
1998C:  MOVLW  01
1998E:  MOVLB  8
19990:  MOVWF  xDE
19992:  SETF   xDD
19994:  MOVLB  0
19996:  CALL   2CFC
1999A:  MOVFF  02,888
1999E:  MOVFF  01,887
....................       step_us  =   m_stp_int[1]*100; 
199A2:  MOVFF  74D,A11
199A6:  MOVFF  74C,A10
199AA:  MOVLB  A
199AC:  CLRF   x13
199AE:  MOVLW  64
199B0:  MOVWF  x12
199B2:  MOVLB  0
199B4:  CALL   5CC0
199B8:  MOVFF  02,88A
199BC:  MOVFF  01,889
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
199C0:  MOVLW  46
199C2:  MOVWF  FF6
199C4:  MOVLW  27
199C6:  MOVWF  FF7
199C8:  MOVLW  00
199CA:  MOVWF  FF8
199CC:  CLRF   1B
199CE:  BTFSC  FF2.7
199D0:  BSF    1B.7
199D2:  BCF    FF2.7
199D4:  CALL   0E6E
199D8:  BTFSC  1B.7
199DA:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
199DC:  MOVLW  62
199DE:  BTFSS  F9E.4
199E0:  BRA    199DE
199E2:  MOVWF  FAD
199E4:  MOVLW  3A
199E6:  BTFSS  F9E.4
199E8:  BRA    199E6
199EA:  MOVWF  FAD
199EC:  MOVLW  10
199EE:  MOVWF  FE9
199F0:  CLRF   1B
199F2:  BTFSC  FF2.7
199F4:  BSF    1B.7
199F6:  BCF    FF2.7
199F8:  MOVFF  775,A41
199FC:  MOVFF  774,A40
19A00:  CALL   11C6
19A04:  BTFSC  1B.7
19A06:  BSF    FF2.7
19A08:  MOVLW  0D
19A0A:  BTFSS  F9E.4
19A0C:  BRA    19A0A
19A0E:  MOVWF  FAD
19A10:  MOVLW  0A
19A12:  BTFSS  F9E.4
19A14:  BRA    19A12
19A16:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
19A18:  MOVLW  63
19A1A:  BTFSS  F9E.4
19A1C:  BRA    19A1A
19A1E:  MOVWF  FAD
19A20:  MOVLW  3A
19A22:  BTFSS  F9E.4
19A24:  BRA    19A22
19A26:  MOVWF  FAD
19A28:  MOVLW  41
19A2A:  MOVWF  FE9
19A2C:  CLRF   1B
19A2E:  BTFSC  FF2.7
19A30:  BSF    1B.7
19A32:  BCF    FF2.7
19A34:  MOVFF  7A9,A43
19A38:  MOVFF  7A8,A42
19A3C:  MOVFF  7A7,A41
19A40:  MOVFF  7A6,A40
19A44:  CALL   110A
19A48:  BTFSC  1B.7
19A4A:  BSF    FF2.7
19A4C:  MOVLW  2F
19A4E:  BTFSS  F9E.4
19A50:  BRA    19A4E
19A52:  MOVWF  FAD
19A54:  MOVLW  10
19A56:  MOVWF  FE9
19A58:  CLRF   1B
19A5A:  BTFSC  FF2.7
19A5C:  BSF    1B.7
19A5E:  BCF    FF2.7
19A60:  MOVFF  7BE,A41
19A64:  MOVFF  7BD,A40
19A68:  CALL   11C6
19A6C:  BTFSC  1B.7
19A6E:  BSF    FF2.7
19A70:  MOVLW  2F
19A72:  BTFSS  F9E.4
19A74:  BRA    19A72
19A76:  MOVWF  FAD
19A78:  MOVLW  10
19A7A:  MOVWF  FE9
19A7C:  CLRF   1B
19A7E:  BTFSC  FF2.7
19A80:  BSF    1B.7
19A82:  BCF    FF2.7
19A84:  MOVFF  7C2,A41
19A88:  MOVFF  7C1,A40
19A8C:  CALL   11C6
19A90:  BTFSC  1B.7
19A92:  BSF    FF2.7
19A94:  MOVLW  0D
19A96:  BTFSS  F9E.4
19A98:  BRA    19A96
19A9A:  MOVWF  FAD
19A9C:  MOVLW  0A
19A9E:  BTFSS  F9E.4
19AA0:  BRA    19A9E
19AA2:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
19AA4:  MOVLW  64
19AA6:  BTFSS  F9E.4
19AA8:  BRA    19AA6
19AAA:  MOVWF  FAD
19AAC:  MOVLW  3A
19AAE:  BTFSS  F9E.4
19AB0:  BRA    19AAE
19AB2:  MOVWF  FAD
19AB4:  MOVLW  10
19AB6:  MOVWF  FE9
19AB8:  CLRF   1B
19ABA:  BTFSC  FF2.7
19ABC:  BSF    1B.7
19ABE:  BCF    FF2.7
19AC0:  MOVFF  751,A41
19AC4:  MOVFF  750,A40
19AC8:  CALL   11C6
19ACC:  BTFSC  1B.7
19ACE:  BSF    FF2.7
19AD0:  MOVLW  0D
19AD2:  BTFSS  F9E.4
19AD4:  BRA    19AD2
19AD6:  MOVWF  FAD
19AD8:  MOVLW  0A
19ADA:  BTFSS  F9E.4
19ADC:  BRA    19ADA
19ADE:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
19AE0:  MOVLW  65
19AE2:  BTFSS  F9E.4
19AE4:  BRA    19AE2
19AE6:  MOVWF  FAD
19AE8:  MOVLW  3A
19AEA:  BTFSS  F9E.4
19AEC:  BRA    19AEA
19AEE:  MOVWF  FAD
19AF0:  MOVLW  10
19AF2:  MOVWF  FE9
19AF4:  CLRF   1B
19AF6:  BTFSC  FF2.7
19AF8:  BSF    1B.7
19AFA:  BCF    FF2.7
19AFC:  MOVFF  761,A41
19B00:  MOVFF  760,A40
19B04:  CALL   11C6
19B08:  BTFSC  1B.7
19B0A:  BSF    FF2.7
19B0C:  MOVLW  0D
19B0E:  BTFSS  F9E.4
19B10:  BRA    19B0E
19B12:  MOVWF  FAD
19B14:  MOVLW  0A
19B16:  BTFSS  F9E.4
19B18:  BRA    19B16
19B1A:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19B1C:  MOVLW  66
19B1E:  BTFSS  F9E.4
19B20:  BRA    19B1E
19B22:  MOVWF  FAD
19B24:  MOVLW  3A
19B26:  BTFSS  F9E.4
19B28:  BRA    19B26
19B2A:  MOVWF  FAD
19B2C:  CLRF   1B
19B2E:  BTFSC  FF2.7
19B30:  BSF    1B.7
19B32:  BCF    FF2.7
19B34:  MOVFF  741,A40
19B38:  MOVLW  1B
19B3A:  MOVLB  A
19B3C:  MOVWF  x41
19B3E:  MOVLB  0
19B40:  CALL   0FC6
19B44:  BTFSC  1B.7
19B46:  BSF    FF2.7
19B48:  MOVLW  0D
19B4A:  BTFSS  F9E.4
19B4C:  BRA    19B4A
19B4E:  MOVWF  FAD
19B50:  MOVLW  0A
19B52:  BTFSS  F9E.4
19B54:  BRA    19B52
19B56:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
19B58:  MOVLW  67
19B5A:  BTFSS  F9E.4
19B5C:  BRA    19B5A
19B5E:  MOVWF  FAD
19B60:  MOVLW  3A
19B62:  BTFSS  F9E.4
19B64:  BRA    19B62
19B66:  MOVWF  FAD
19B68:  MOVLW  10
19B6A:  MOVWF  FE9
19B6C:  CLRF   1B
19B6E:  BTFSC  FF2.7
19B70:  BSF    1B.7
19B72:  BCF    FF2.7
19B74:  MOVFF  75D,A41
19B78:  MOVFF  75C,A40
19B7C:  CALL   11C6
19B80:  BTFSC  1B.7
19B82:  BSF    FF2.7
19B84:  MOVLW  0D
19B86:  BTFSS  F9E.4
19B88:  BRA    19B86
19B8A:  MOVWF  FAD
19B8C:  MOVLW  0A
19B8E:  BTFSS  F9E.4
19B90:  BRA    19B8E
19B92:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19B94:  MOVLW  68
19B96:  BTFSS  F9E.4
19B98:  BRA    19B96
19B9A:  MOVWF  FAD
19B9C:  MOVLW  3A
19B9E:  BTFSS  F9E.4
19BA0:  BRA    19B9E
19BA2:  MOVWF  FAD
19BA4:  MOVLW  10
19BA6:  MOVWF  FE9
19BA8:  CLRF   1B
19BAA:  BTFSC  FF2.7
19BAC:  BSF    1B.7
19BAE:  BCF    FF2.7
19BB0:  MOVFF  886,A41
19BB4:  MOVFF  885,A40
19BB8:  CALL   11C6
19BBC:  BTFSC  1B.7
19BBE:  BSF    FF2.7
19BC0:  MOVLW  0D
19BC2:  BTFSS  F9E.4
19BC4:  BRA    19BC2
19BC6:  MOVWF  FAD
19BC8:  MOVLW  0A
19BCA:  BTFSS  F9E.4
19BCC:  BRA    19BCA
19BCE:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
19BD0:  MOVLW  69
19BD2:  BTFSS  F9E.4
19BD4:  BRA    19BD2
19BD6:  MOVWF  FAD
19BD8:  MOVLW  3A
19BDA:  BTFSS  F9E.4
19BDC:  BRA    19BDA
19BDE:  MOVWF  FAD
19BE0:  MOVLW  10
19BE2:  MOVWF  FE9
19BE4:  CLRF   1B
19BE6:  BTFSC  FF2.7
19BE8:  BSF    1B.7
19BEA:  BCF    FF2.7
19BEC:  MOVFF  88A,A41
19BF0:  MOVFF  889,A40
19BF4:  CALL   11C6
19BF8:  BTFSC  1B.7
19BFA:  BSF    FF2.7
19BFC:  MOVLW  0D
19BFE:  BTFSS  F9E.4
19C00:  BRA    19BFE
19C02:  MOVWF  FAD
19C04:  MOVLW  0A
19C06:  BTFSS  F9E.4
19C08:  BRA    19C06
19C0A:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
19C0C:  MOVLW  6A
19C0E:  BTFSS  F9E.4
19C10:  BRA    19C0E
19C12:  MOVWF  FAD
19C14:  MOVLW  3A
19C16:  BTFSS  F9E.4
19C18:  BRA    19C16
19C1A:  MOVWF  FAD
19C1C:  MOVLW  10
19C1E:  MOVWF  FE9
19C20:  CLRF   1B
19C22:  BTFSC  FF2.7
19C24:  BSF    1B.7
19C26:  BCF    FF2.7
19C28:  MOVFF  771,A41
19C2C:  MOVFF  770,A40
19C30:  CALL   11C6
19C34:  BTFSC  1B.7
19C36:  BSF    FF2.7
19C38:  MOVLW  0D
19C3A:  BTFSS  F9E.4
19C3C:  BRA    19C3A
19C3E:  MOVWF  FAD
19C40:  MOVLW  0A
19C42:  BTFSS  F9E.4
19C44:  BRA    19C42
19C46:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
19C48:  MOVLW  6B
19C4A:  BTFSS  F9E.4
19C4C:  BRA    19C4A
19C4E:  MOVWF  FAD
19C50:  MOVLW  3A
19C52:  BTFSS  F9E.4
19C54:  BRA    19C52
19C56:  MOVWF  FAD
19C58:  MOVLW  10
19C5A:  MOVWF  FE9
19C5C:  CLRF   1B
19C5E:  BTFSC  FF2.7
19C60:  BSF    1B.7
19C62:  BCF    FF2.7
19C64:  MOVFF  769,A41
19C68:  MOVFF  768,A40
19C6C:  CALL   11C6
19C70:  BTFSC  1B.7
19C72:  BSF    FF2.7
19C74:  MOVLW  0D
19C76:  BTFSS  F9E.4
19C78:  BRA    19C76
19C7A:  MOVWF  FAD
19C7C:  MOVLW  0A
19C7E:  BTFSS  F9E.4
19C80:  BRA    19C7E
19C82:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
19C84:  MOVLW  6D
19C86:  BTFSS  F9E.4
19C88:  BRA    19C86
19C8A:  MOVWF  FAD
19C8C:  MOVLW  3A
19C8E:  BTFSS  F9E.4
19C90:  BRA    19C8E
19C92:  MOVWF  FAD
19C94:  MOVLW  10
19C96:  MOVWF  FE9
19C98:  CLRF   1B
19C9A:  BTFSC  FF2.7
19C9C:  BSF    1B.7
19C9E:  BCF    FF2.7
19CA0:  MOVFF  749,A41
19CA4:  MOVFF  748,A40
19CA8:  CALL   11C6
19CAC:  BTFSC  1B.7
19CAE:  BSF    FF2.7
19CB0:  MOVLW  0D
19CB2:  BTFSS  F9E.4
19CB4:  BRA    19CB2
19CB6:  MOVWF  FAD
19CB8:  MOVLW  0A
19CBA:  BTFSS  F9E.4
19CBC:  BRA    19CBA
19CBE:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
19CC0:  MOVLW  6E
19CC2:  BTFSS  F9E.4
19CC4:  BRA    19CC2
19CC6:  MOVWF  FAD
19CC8:  MOVLW  3A
19CCA:  BTFSS  F9E.4
19CCC:  BRA    19CCA
19CCE:  MOVWF  FAD
19CD0:  MOVLW  10
19CD2:  MOVWF  FE9
19CD4:  CLRF   1B
19CD6:  BTFSC  FF2.7
19CD8:  BSF    1B.7
19CDA:  BCF    FF2.7
19CDC:  MOVFF  77D,A41
19CE0:  MOVFF  77C,A40
19CE4:  CALL   11C6
19CE8:  BTFSC  1B.7
19CEA:  BSF    FF2.7
19CEC:  MOVLW  0D
19CEE:  BTFSS  F9E.4
19CF0:  BRA    19CEE
19CF2:  MOVWF  FAD
19CF4:  MOVLW  0A
19CF6:  BTFSS  F9E.4
19CF8:  BRA    19CF6
19CFA:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
19CFC:  MOVLW  6F
19CFE:  BTFSS  F9E.4
19D00:  BRA    19CFE
19D02:  MOVWF  FAD
19D04:  MOVLW  3A
19D06:  BTFSS  F9E.4
19D08:  BRA    19D06
19D0A:  MOVWF  FAD
19D0C:  MOVLW  10
19D0E:  MOVWF  FE9
19D10:  CLRF   1B
19D12:  BTFSC  FF2.7
19D14:  BSF    1B.7
19D16:  BCF    FF2.7
19D18:  MOVFF  781,A41
19D1C:  MOVFF  780,A40
19D20:  CALL   11C6
19D24:  BTFSC  1B.7
19D26:  BSF    FF2.7
19D28:  MOVLW  0D
19D2A:  BTFSS  F9E.4
19D2C:  BRA    19D2A
19D2E:  MOVWF  FAD
19D30:  MOVLW  0A
19D32:  BTFSS  F9E.4
19D34:  BRA    19D32
19D36:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
19D38:  MOVLW  70
19D3A:  BTFSS  F9E.4
19D3C:  BRA    19D3A
19D3E:  MOVWF  FAD
19D40:  MOVLW  3A
19D42:  BTFSS  F9E.4
19D44:  BRA    19D42
19D46:  MOVWF  FAD
19D48:  MOVLW  10
19D4A:  MOVWF  FE9
19D4C:  CLRF   1B
19D4E:  BTFSC  FF2.7
19D50:  BSF    1B.7
19D52:  BCF    FF2.7
19D54:  MOVFF  7C6,A41
19D58:  MOVFF  7C5,A40
19D5C:  CALL   11C6
19D60:  BTFSC  1B.7
19D62:  BSF    FF2.7
19D64:  MOVLW  2F
19D66:  BTFSS  F9E.4
19D68:  BRA    19D66
19D6A:  MOVWF  FAD
19D6C:  MOVLW  10
19D6E:  MOVWF  FE9
19D70:  CLRF   1B
19D72:  BTFSC  FF2.7
19D74:  BSF    1B.7
19D76:  BCF    FF2.7
19D78:  MOVFF  765,A41
19D7C:  MOVFF  764,A40
19D80:  CALL   11C6
19D84:  BTFSC  1B.7
19D86:  BSF    FF2.7
19D88:  MOVLW  0D
19D8A:  BTFSS  F9E.4
19D8C:  BRA    19D8A
19D8E:  MOVWF  FAD
19D90:  MOVLW  0A
19D92:  BTFSS  F9E.4
19D94:  BRA    19D92
19D96:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
19D98:  MOVLW  71
19D9A:  BTFSS  F9E.4
19D9C:  BRA    19D9A
19D9E:  MOVWF  FAD
19DA0:  MOVLW  3A
19DA2:  BTFSS  F9E.4
19DA4:  BRA    19DA2
19DA6:  MOVWF  FAD
19DA8:  MOVLW  10
19DAA:  MOVWF  FE9
19DAC:  CLRF   1B
19DAE:  BTFSC  FF2.7
19DB0:  BSF    1B.7
19DB2:  BCF    FF2.7
19DB4:  MOVFF  799,A41
19DB8:  MOVFF  798,A40
19DBC:  CALL   11C6
19DC0:  BTFSC  1B.7
19DC2:  BSF    FF2.7
19DC4:  MOVLW  0D
19DC6:  BTFSS  F9E.4
19DC8:  BRA    19DC6
19DCA:  MOVWF  FAD
19DCC:  MOVLW  0A
19DCE:  BTFSS  F9E.4
19DD0:  BRA    19DCE
19DD2:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
19DD4:  MOVLW  73
19DD6:  BTFSS  F9E.4
19DD8:  BRA    19DD6
19DDA:  MOVWF  FAD
19DDC:  MOVLW  3A
19DDE:  BTFSS  F9E.4
19DE0:  BRA    19DDE
19DE2:  MOVWF  FAD
19DE4:  MOVLW  10
19DE6:  MOVWF  FE9
19DE8:  CLRF   1B
19DEA:  BTFSC  FF2.7
19DEC:  BSF    1B.7
19DEE:  BCF    FF2.7
19DF0:  MOVFF  779,A41
19DF4:  MOVFF  778,A40
19DF8:  CALL   11C6
19DFC:  BTFSC  1B.7
19DFE:  BSF    FF2.7
19E00:  MOVLW  0D
19E02:  BTFSS  F9E.4
19E04:  BRA    19E02
19E06:  MOVWF  FAD
19E08:  MOVLW  0A
19E0A:  BTFSS  F9E.4
19E0C:  BRA    19E0A
19E0E:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
19E10:  MOVLW  74
19E12:  BTFSS  F9E.4
19E14:  BRA    19E12
19E16:  MOVWF  FAD
19E18:  MOVLW  3A
19E1A:  BTFSS  F9E.4
19E1C:  BRA    19E1A
19E1E:  MOVWF  FAD
19E20:  MOVLW  10
19E22:  MOVWF  FE9
19E24:  CLRF   1B
19E26:  BTFSC  FF2.7
19E28:  BSF    1B.7
19E2A:  BCF    FF2.7
19E2C:  MOVFF  76D,A41
19E30:  MOVFF  76C,A40
19E34:  CALL   11C6
19E38:  BTFSC  1B.7
19E3A:  BSF    FF2.7
19E3C:  MOVLW  0D
19E3E:  BTFSS  F9E.4
19E40:  BRA    19E3E
19E42:  MOVWF  FAD
19E44:  MOVLW  0A
19E46:  BTFSS  F9E.4
19E48:  BRA    19E46
19E4A:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19E4C:  MOVLW  01
19E4E:  MOVLB  7
19E50:  ADDWF  x40,W
19E52:  MOVLB  8
19E54:  MOVWF  x8B
19E56:  MOVLW  75
19E58:  BTFSS  F9E.4
19E5A:  BRA    19E58
19E5C:  MOVWF  FAD
19E5E:  MOVLW  3A
19E60:  BTFSS  F9E.4
19E62:  BRA    19E60
19E64:  MOVWF  FAD
19E66:  CLRF   1B
19E68:  BTFSC  FF2.7
19E6A:  BSF    1B.7
19E6C:  BCF    FF2.7
19E6E:  MOVFF  88B,A40
19E72:  MOVLW  1B
19E74:  MOVLB  A
19E76:  MOVWF  x41
19E78:  MOVLB  0
19E7A:  CALL   0FC6
19E7E:  BTFSC  1B.7
19E80:  BSF    FF2.7
19E82:  MOVLW  0D
19E84:  BTFSS  F9E.4
19E86:  BRA    19E84
19E88:  MOVWF  FAD
19E8A:  MOVLW  0A
19E8C:  BTFSS  F9E.4
19E8E:  BRA    19E8C
19E90:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19E92:  MOVLW  77
19E94:  BTFSS  F9E.4
19E96:  BRA    19E94
19E98:  MOVWF  FAD
19E9A:  MOVLW  3A
19E9C:  BTFSS  F9E.4
19E9E:  BRA    19E9C
19EA0:  MOVWF  FAD
19EA2:  MOVLW  10
19EA4:  MOVWF  FE9
19EA6:  CLRF   1B
19EA8:  BTFSC  FF2.7
19EAA:  BSF    1B.7
19EAC:  BCF    FF2.7
19EAE:  MOVFF  888,A41
19EB2:  MOVFF  887,A40
19EB6:  CALL   11C6
19EBA:  BTFSC  1B.7
19EBC:  BSF    FF2.7
19EBE:  MOVLW  0D
19EC0:  BTFSS  F9E.4
19EC2:  BRA    19EC0
19EC4:  MOVWF  FAD
19EC6:  MOVLW  0A
19EC8:  BTFSS  F9E.4
19ECA:  BRA    19EC8
19ECC:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
19ECE:  MOVLW  78
19ED0:  BTFSS  F9E.4
19ED2:  BRA    19ED0
19ED4:  MOVWF  FAD
19ED6:  MOVLW  3A
19ED8:  BTFSS  F9E.4
19EDA:  BRA    19ED8
19EDC:  MOVWF  FAD
19EDE:  MOVLW  10
19EE0:  MOVWF  FE9
19EE2:  CLRF   1B
19EE4:  BTFSC  FF2.7
19EE6:  BSF    1B.7
19EE8:  BCF    FF2.7
19EEA:  MOVFF  785,A41
19EEE:  MOVFF  784,A40
19EF2:  CALL   11C6
19EF6:  BTFSC  1B.7
19EF8:  BSF    FF2.7
19EFA:  MOVLW  0D
19EFC:  BTFSS  F9E.4
19EFE:  BRA    19EFC
19F00:  MOVWF  FAD
19F02:  MOVLW  0A
19F04:  BTFSS  F9E.4
19F06:  BRA    19F04
19F08:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
19F0A:  MOVLW  79
19F0C:  BTFSS  F9E.4
19F0E:  BRA    19F0C
19F10:  MOVWF  FAD
19F12:  MOVLW  3A
19F14:  BTFSS  F9E.4
19F16:  BRA    19F14
19F18:  MOVWF  FAD
19F1A:  MOVLW  10
19F1C:  MOVWF  FE9
19F1E:  CLRF   1B
19F20:  BTFSC  FF2.7
19F22:  BSF    1B.7
19F24:  BCF    FF2.7
19F26:  MOVFF  745,A41
19F2A:  MOVFF  744,A40
19F2E:  CALL   11C6
19F32:  BTFSC  1B.7
19F34:  BSF    FF2.7
19F36:  MOVLW  0D
19F38:  BTFSS  F9E.4
19F3A:  BRA    19F38
19F3C:  MOVWF  FAD
19F3E:  MOVLW  0A
19F40:  BTFSS  F9E.4
19F42:  BRA    19F40
19F44:  MOVWF  FAD
....................    } 
19F46:  BRA    19F4C
....................    else cmd_arg(); 
19F48:  CALL   B32E
19F4C:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BF76:  MOVF   48,W
0BF78:  SUBLW  0D
0BF7A:  BNZ   BF9A
0BF7C:  MOVF   49,W
0BF7E:  SUBLW  07
0BF80:  BNZ   BF9A
0BF82:  MOVF   4A,F
0BF84:  BNZ   BF9A
0BF86:  MOVF   4B,F
0BF88:  BNZ   BF9A
0BF8A:  MOVLW  03
0BF8C:  MOVLB  8
0BF8E:  MOVWF  x8A
0BF90:  MOVLW  15
0BF92:  MOVWF  x89
0BF94:  MOVLB  0
0BF96:  RCALL  BB54
0BF98:  BRA    BFBC
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BF9A:  MOVF   48,W
0BF9C:  SUBLW  98
0BF9E:  BNZ   BFBC
0BFA0:  MOVF   49,W
0BFA2:  SUBLW  07
0BFA4:  BNZ   BFBC
0BFA6:  MOVF   4A,F
0BFA8:  BNZ   BFBC
0BFAA:  MOVF   4B,F
0BFAC:  BNZ   BFBC
0BFAE:  MOVLW  03
0BFB0:  MOVLB  8
0BFB2:  MOVWF  x8A
0BFB4:  MOVLW  15
0BFB6:  MOVWF  x89
0BFB8:  MOVLB  0
0BFBA:  RCALL  BCCE
0BFBC:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0B388:  MOVF   48,W
0B38A:  MOVWF  00
0B38C:  MOVFF  49,03
0B390:  MOVLW  15
0B392:  SUBWF  49,W
0B394:  BNZ   B39C
0B396:  MOVLW  95
0B398:  SUBWF  00,W
0B39A:  BZ    B3C2
0B39C:  MOVLW  15
0B39E:  SUBWF  03,W
0B3A0:  BNZ   B3A8
0B3A2:  MOVLW  96
0B3A4:  SUBWF  00,W
0B3A6:  BZ    B3F4
0B3A8:  MOVLW  15
0B3AA:  SUBWF  03,W
0B3AC:  BNZ   B3B4
0B3AE:  MOVLW  97
0B3B0:  SUBWF  00,W
0B3B2:  BZ    B42A
0B3B4:  MOVLW  15
0B3B6:  SUBWF  03,W
0B3B8:  BNZ   B3C0
0B3BA:  MOVLW  98
0B3BC:  SUBWF  00,W
0B3BE:  BZ    B460
0B3C0:  BRA    B494
....................       case 5525 : nv_product = ECO; 
0B3C2:  CLRF   30
0B3C4:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0B3C6:  MOVLW  1E
0B3C8:  MOVLB  8
0B3CA:  MOVWF  xEE
0B3CC:  CLRF   xF0
0B3CE:  CLRF   xEF
0B3D0:  MOVLB  0
0B3D2:  CALL   4FFC
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B3D6:  MOVLW  01
0B3D8:  MOVWF  1E
0B3DA:  MOVLW  A7
0B3DC:  MOVWF  1D
0B3DE:  MOVLW  52
0B3E0:  MOVWF  FF6
0B3E2:  MOVLW  27
0B3E4:  MOVWF  FF7
0B3E6:  MOVLW  00
0B3E8:  MOVWF  FF8
0B3EA:  CALL   50E6
....................                   record_event(); 
0B3EE:  CALL   8502
....................          break; 
0B3F2:  BRA    B494
....................       case 5526 : nv_product = WMS4; 
0B3F4:  CLRF   30
0B3F6:  MOVLW  01
0B3F8:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B3FA:  MOVLW  1E
0B3FC:  MOVLB  8
0B3FE:  MOVWF  xEE
0B400:  CLRF   xF0
0B402:  MOVLW  01
0B404:  MOVWF  xEF
0B406:  MOVLB  0
0B408:  CALL   4FFC
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B40C:  MOVLW  01
0B40E:  MOVWF  1E
0B410:  MOVLW  A7
0B412:  MOVWF  1D
0B414:  MOVLW  62
0B416:  MOVWF  FF6
0B418:  MOVLW  27
0B41A:  MOVWF  FF7
0B41C:  MOVLW  00
0B41E:  MOVWF  FF8
0B420:  CALL   50E6
....................                   record_event();                   
0B424:  CALL   8502
....................          break;    
0B428:  BRA    B494
....................       case 5527 : nv_product = AWS; 
0B42A:  CLRF   30
0B42C:  MOVLW  02
0B42E:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B430:  MOVLW  1E
0B432:  MOVLB  8
0B434:  MOVWF  xEE
0B436:  CLRF   xF0
0B438:  MOVLW  02
0B43A:  MOVWF  xEF
0B43C:  MOVLB  0
0B43E:  CALL   4FFC
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B442:  MOVLW  01
0B444:  MOVWF  1E
0B446:  MOVLW  A7
0B448:  MOVWF  1D
0B44A:  MOVLW  78
0B44C:  MOVWF  FF6
0B44E:  MOVLW  27
0B450:  MOVWF  FF7
0B452:  MOVLW  00
0B454:  MOVWF  FF8
0B456:  CALL   50E6
....................                   record_event();                   
0B45A:  CALL   8502
....................          break;   
0B45E:  BRA    B494
....................       case 5528 : nv_product = WMS2; 
0B460:  CLRF   30
0B462:  MOVLW  03
0B464:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B466:  MOVLW  1E
0B468:  MOVLB  8
0B46A:  MOVWF  xEE
0B46C:  CLRF   xF0
0B46E:  MOVLW  03
0B470:  MOVWF  xEF
0B472:  MOVLB  0
0B474:  CALL   4FFC
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B478:  MOVLW  01
0B47A:  MOVWF  1E
0B47C:  MOVLW  A7
0B47E:  MOVWF  1D
0B480:  MOVLW  88
0B482:  MOVWF  FF6
0B484:  MOVLW  27
0B486:  MOVWF  FF7
0B488:  MOVLW  00
0B48A:  MOVWF  FF8
0B48C:  CALL   50E6
....................                   record_event();                   
0B490:  CALL   8502
....................          break;            
....................    } 
0B494:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0B34C:  MOVF   48,W
0B34E:  MOVWF  00
0B350:  MOVF   49,W
0B352:  MOVWF  03
0B354:  BNZ   B35A
0B356:  MOVF   00,F
0B358:  BZ    B370
0B35A:  MOVF   03,W
0B35C:  BNZ   B364
0B35E:  MOVLW  01
0B360:  SUBWF  00,W
0B362:  BZ    B376
0B364:  MOVF   03,W
0B366:  BNZ   B36E
0B368:  MOVLW  02
0B36A:  SUBWF  00,W
0B36C:  BZ    B37C
0B36E:  BRA    B382
....................       case 0 : kill_wd(); 
0B370:  CALL   311E
....................          break; 
0B374:  BRA    B384
....................       case 1 : start_heartbeat(); 
0B376:  CALL   2928
....................          break; 
0B37A:  BRA    B384
....................       case 2 : suspend_heartbeat(); 
0B37C:  CALL   557C
....................          break; 
0B380:  BRA    B384
....................       default : cmd_arg(); 
0B382:  RCALL  B32E
....................          break; 
....................    } 
0B384:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0B28C:  MOVF   48,W
0B28E:  MOVWF  00
0B290:  MOVF   49,W
0B292:  MOVWF  03
0B294:  BNZ   B29A
0B296:  MOVF   00,F
0B298:  BZ    B2A8
0B29A:  MOVLW  15
0B29C:  SUBWF  03,W
0B29E:  BNZ   B2A6
0B2A0:  MOVLW  95
0B2A2:  SUBWF  00,W
0B2A4:  BZ    B306
0B2A6:  BRA    B32A
....................       case 0:     signon(); 
0B2A8:  CALL   3170
....................                   fprintf(COM_A, __DATE__); 
0B2AC:  MOVLW  9E
0B2AE:  MOVWF  FF6
0B2B0:  MOVLW  27
0B2B2:  MOVWF  FF7
0B2B4:  MOVLW  00
0B2B6:  MOVWF  FF8
0B2B8:  CLRF   1B
0B2BA:  BTFSC  FF2.7
0B2BC:  BSF    1B.7
0B2BE:  BCF    FF2.7
0B2C0:  CALL   0E6E
0B2C4:  BTFSC  1B.7
0B2C6:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B2C8:  MOVLW  0D
0B2CA:  BTFSS  F9E.4
0B2CC:  BRA    B2CA
0B2CE:  MOVWF  FAD
0B2D0:  MOVLW  0A
0B2D2:  BTFSS  F9E.4
0B2D4:  BRA    B2D2
0B2D6:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0B2D8:  MOVLW  A8
0B2DA:  MOVWF  FF6
0B2DC:  MOVLW  27
0B2DE:  MOVWF  FF7
0B2E0:  MOVLW  00
0B2E2:  MOVWF  FF8
0B2E4:  CLRF   1B
0B2E6:  BTFSC  FF2.7
0B2E8:  BSF    1B.7
0B2EA:  BCF    FF2.7
0B2EC:  CALL   0E6E
0B2F0:  BTFSC  1B.7
0B2F2:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B2F4:  MOVLW  0D
0B2F6:  BTFSS  F9E.4
0B2F8:  BRA    B2F6
0B2FA:  MOVWF  FAD
0B2FC:  MOVLW  0A
0B2FE:  BTFSS  F9E.4
0B300:  BRA    B2FE
0B302:  MOVWF  FAD
....................          break; 
0B304:  BRA    B32A
....................       case 5525 : kill_wd(); 
0B306:  CALL   311E
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0B30A:  MOVLW  B2
0B30C:  MOVWF  FF6
0B30E:  MOVLW  27
0B310:  MOVWF  FF7
0B312:  MOVLW  00
0B314:  MOVWF  FF8
0B316:  CLRF   1B
0B318:  BTFSC  FF2.7
0B31A:  BSF    1B.7
0B31C:  BCF    FF2.7
0B31E:  CALL   0E6E
0B322:  BTFSC  1B.7
0B324:  BSF    FF2.7
....................                   load_program(); 
0B326:  CALL   1F800
....................          break; 
....................    } 
0B32A:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
18BF0:  MOVF   48,W
18BF2:  MOVWF  00
18BF4:  MOVF   49,W
18BF6:  MOVWF  03
18BF8:  BNZ   18BFE
18BFA:  MOVF   00,F
18BFC:  BZ    18C0A
18BFE:  MOVF   03,W
18C00:  BNZ   18C08
18C02:  MOVLW  01
18C04:  SUBWF  00,W
18C06:  BZ    18C0E
18C08:  BRA    18C12
....................       case 0 : cmd_set=0;  // user 
18C0A:  CLRF   51
....................          break; 
18C0C:  BRA    18C12
....................       case 1 : cmd_set=1;  // full 
18C0E:  MOVLW  01
18C10:  MOVWF  51
....................          break; 
....................    } 
18C12:  GOTO   1B2F8 (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1B15C:  CALL   AEE0
....................     
....................    switch (cmd) 
1B160:  MOVLW  23
1B162:  SUBWF  47,W
1B164:  ADDLW  A8
1B166:  BTFSC  FD8.0
1B168:  BRA    1B2F8
1B16A:  ADDLW  58
1B16C:  GOTO   1B2FC
....................    { 
....................       case '&': commandFW(); 
1B170:  GOTO   B28C
....................          break; 
1B174:  BRA    1B2F8
....................       case '#': command_hash(); 
1B176:  GOTO   B34C
....................          break;          
1B17A:  BRA    1B2F8
....................       case '%': command_prod(); 
1B17C:  GOTO   B388
....................          break; 
1B180:  BRA    1B2F8
....................       case '*': command_star(); 
1B182:  GOTO   BF76
....................          break;       
1B186:  BRA    1B2F8
....................       // standard commands 
....................       case '/': command_addr(); 
1B188:  GOTO   BFC0
....................          break; 
1B18C:  BRA    1B2F8
....................       case 'A': commandA(); 
1B18E:  GOTO   C15A
....................          break; 
1B192:  BRA    1B2F8
....................       case 'B': commandB(); 
1B194:  GOTO   C2C6
....................          break; 
1B198:  BRA    1B2F8
....................       case 'C': commandC(); 
1B19A:  GOTO   DCEA
....................          break; 
1B19E:  BRA    1B2F8
....................       case 'D': commandD(); 
1B1A0:  GOTO   DD28
....................          break; 
1B1A4:  BRA    1B2F8
....................       case 'E': commandE(); 
1B1A6:  GOTO   DDC6
....................          break;          
1B1AA:  BRA    1B2F8
....................       case 'F': commandF(); 
1B1AC:  GOTO   E0C4
....................          break;          
1B1B0:  BRA    1B2F8
....................       case 'G': commandG(); 
1B1B2:  GOTO   E12E
....................          break; 
1B1B6:  BRA    1B2F8
....................       case 'H': commandH(); 
1B1B8:  GOTO   F28C
....................          break; 
1B1BC:  BRA    1B2F8
....................       case 'I': commandI(); 
1B1BE:  GOTO   F2CC
....................          break;    
1B1C2:  BRA    1B2F8
....................       case 'J': commandJ(); 
1B1C4:  GOTO   F318
....................          break;      
1B1C8:  BRA    1B2F8
....................       case 'K': commandK(); 
1B1CA:  GOTO   F572
....................          break;    
1B1CE:  BRA    1B2F8
....................       case 'L': commandL(); 
1B1D0:  GOTO   1052C
....................          break;             
1B1D4:  BRA    1B2F8
....................       case 'M': commandM(FALSE); 
1B1D6:  MOVLB  8
1B1D8:  CLRF   x85
1B1DA:  MOVLB  0
1B1DC:  CALL   16DE6
....................          break;   
1B1E0:  BRA    1B2F8
....................       case 'N': commandN(); 
1B1E2:  GOTO   16F08
....................          break;          
1B1E6:  BRA    1B2F8
....................       case 'O': commandO(); 
1B1E8:  GOTO   170B8
....................          break;    
1B1EC:  BRA    1B2F8
....................       case 'P': commandP(); 
1B1EE:  GOTO   172BC
....................          break;  
1B1F2:  BRA    1B2F8
....................       case 'Q': commandQ(); 
1B1F4:  GOTO   1737A
....................          break;              
1B1F8:  BRA    1B2F8
....................       case 'R': commandR(); 
1B1FA:  GOTO   17610
....................          break;    
1B1FE:  BRA    1B2F8
....................       case 'S': commandS(); 
1B200:  GOTO   1773C
....................          break;  
1B204:  BRA    1B2F8
....................       case 'T': commandT(); 
1B206:  GOTO   17D64
....................          break;            
1B20A:  BRA    1B2F8
....................       case 'U': commandU(); 
1B20C:  GOTO   1876C
....................          break;           
1B210:  BRA    1B2F8
....................       case 'V': commandV(); 
1B212:  GOTO   188C4
....................          break; 
1B216:  BRA    1B2F8
....................       case 'W': commandW(); 
1B218:  GOTO   18A38
....................          break; 
1B21C:  BRA    1B2F8
....................       case 'X': commandX(); 
1B21E:  GOTO   18A5C
....................          break; 
1B222:  BRA    1B2F8
....................       case 'Y': commandY(); 
1B224:  GOTO   18AC4
....................          break;  
1B228:  BRA    1B2F8
....................       case 'Z': commandZ(); 
1B22A:  CALL   18BCC
....................          break;    
1B22E:  BRA    1B2F8
....................       // stepper 
....................       case '^': command_set(); 
1B230:  GOTO   18BF0
....................          break;       
1B234:  BRA    1B2F8
....................       case '+': if(m_fixed==1) motor=1; 
1B236:  MOVLB  7
1B238:  DECFSZ x41,W
1B23A:  BRA    1B240
1B23C:  MOVLW  01
1B23E:  MOVWF  x40
....................                 command_move(0,0,1); 
1B240:  MOVLB  8
1B242:  CLRF   x85
1B244:  CLRF   x86
1B246:  MOVLW  01
1B248:  MOVWF  x87
1B24A:  MOVLB  0
1B24C:  CALL   170DC
....................          break; 
1B250:  BRA    1B2F8
....................       case '-': if(m_fixed==1) motor=1; 
1B252:  MOVLB  7
1B254:  DECFSZ x41,W
1B256:  BRA    1B25C
1B258:  MOVLW  01
1B25A:  MOVWF  x40
....................                 command_move(0,1,1); 
1B25C:  MOVLB  8
1B25E:  CLRF   x85
1B260:  MOVLW  01
1B262:  MOVWF  x86
1B264:  MOVWF  x87
1B266:  MOVLB  0
1B268:  CALL   170DC
....................          break; 
1B26C:  BRA    1B2F8
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1B26E:  GOTO   18D1C
....................          break;     
1B272:  BRA    1B2F8
....................       case 'b': command_b(); 
1B274:  GOTO   18D38
....................          break; 
1B278:  BRA    1B2F8
....................       case 'c': command_c(); 
1B27A:  GOTO   18DD2
....................          break; 
1B27E:  BRA    1B2F8
....................       case 'd': command_d(); 
1B280:  GOTO   18E26
....................          break;          
1B284:  BRA    1B2F8
....................       case 'e': command_e(); 
1B286:  GOTO   18EBC
....................          break;       
1B28A:  BRA    1B2F8
....................       case 'f': command_f(); 
1B28C:  GOTO   18F56
....................          break; 
1B290:  BRA    1B2F8
....................       case 'g': command_g(); 
1B292:  GOTO   18F76
....................          break;          
1B296:  BRA    1B2F8
....................       case 'h': command_h(); 
1B298:  GOTO   19010
....................          break; 
1B29C:  BRA    1B2F8
....................       case 'i': command_i(); 
1B29E:  GOTO   190E4
....................          break;   
1B2A2:  BRA    1B2F8
....................       case 'j': command_j(); 
1B2A4:  GOTO   191C0
....................          break;           
1B2A8:  BRA    1B2F8
....................       case 'k': command_k(); 
1B2AA:  GOTO   1925A
....................          break;          
1B2AE:  BRA    1B2F8
....................       case 'l': step_var_list(); 
1B2B0:  GOTO   192F0
....................          break;          
1B2B4:  BRA    1B2F8
....................       case 'm': command_m(); 
1B2B6:  GOTO   19F50
....................          break;    
1B2BA:  BRA    1B2F8
....................       case 'n': command_n(); 
1B2BC:  GOTO   19FE6
....................          break; 
1B2C0:  BRA    1B2F8
....................       case 'o': command_o(); 
1B2C2:  GOTO   1A07C
....................          break;    
1B2C6:  BRA    1B2F8
....................       case 'p': command_p(); 
1B2C8:  GOTO   1A116
....................          break;   
1B2CC:  BRA    1B2F8
....................       case 'q': command_q(); 
1B2CE:  GOTO   1A1B0
....................          break; 
1B2D2:  BRA    1B2F8
....................       case 'r': command_r(); 
1B2D4:  BRA    1ACAC
....................          break;    
1B2D6:  BRA    1B2F8
....................       case 's': command_s(); 
1B2D8:  BRA    1AD06
....................          break;           
1B2DA:  BRA    1B2F8
....................       case 't': command_t(); 
1B2DC:  BRA    1AE14
....................          break;          
1B2DE:  BRA    1B2F8
....................       case 'u': command_u(); 
1B2E0:  BRA    1AEAA
....................          break; 
1B2E2:  BRA    1B2F8
....................       case 'v': command_v(); 
1B2E4:  CALL   13E08
....................          break; 
1B2E8:  BRA    1B2F8
....................       case 'w': command_w(); 
1B2EA:  BRA    1AEE2
....................          break; 
1B2EC:  BRA    1B2F8
....................       case 'x': command_x(); 
1B2EE:  BRA    1AFB6
....................          break;    
1B2F0:  BRA    1B2F8
....................       case 'y': command_y(); 
1B2F2:  BRA    1B050
....................          break;  
1B2F4:  BRA    1B2F8
....................       case 'z': command_z(); 
1B2F6:  BRA    1B0E6
....................          break;           
....................    } 
1B2F8:  GOTO   1B41C (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... #define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c" 
.................... #define BYTE_TO_BINARY(byte)  \ 
....................   (byte & 0x80 ? '1' : '0'), \ 
....................   (byte & 0x40 ? '1' : '0'), \ 
....................   (byte & 0x20 ? '1' : '0'), \ 
....................   (byte & 0x10 ? '1' : '0'), \ 
....................   (byte & 0x08 ? '1' : '0'), \ 
....................   (byte & 0x04 ? '1' : '0'), \ 
....................   (byte & 0x02 ? '1' : '0'), \ 
....................   (byte & 0x01 ? '1' : '0')  
....................  
.................... void proc_arg2() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0B1C8:  MOVF   51,F
0B1CA:  BNZ   B21C
0B1CC:  MOVLB  8
0B1CE:  MOVF   x85,W
0B1D0:  SUBLW  24
0B1D2:  BC    B1DA
0B1D4:  MOVF   x85,W
0B1D6:  SUBLW  26
0B1D8:  BC    B214
0B1DA:  MOVF   x85,W
0B1DC:  SUBLW  29
0B1DE:  BC    B1E6
0B1E0:  MOVF   x85,W
0B1E2:  SUBLW  2B
0B1E4:  BC    B214
0B1E6:  MOVF   x85,W
0B1E8:  SUBLW  2D
0B1EA:  BZ    B214
0B1EC:  MOVF   x85,W
0B1EE:  SUBLW  2F
0B1F0:  BZ    B214
0B1F2:  MOVF   x85,W
0B1F4:  SUBLW  40
0B1F6:  BC    B1FE
0B1F8:  MOVF   x85,W
0B1FA:  SUBLW  42
0B1FC:  BC    B214
0B1FE:  MOVF   x85,W
0B200:  SUBLW  43
0B202:  BC    B20A
0B204:  MOVF   x85,W
0B206:  SUBLW  5A
0B208:  BC    B214
0B20A:  MOVF   x85,W
0B20C:  SUBLW  5E
0B20E:  BZ    B214
0B210:  MOVLW  00
0B212:  BRA    B216
0B214:  MOVLW  01
0B216:  MOVWF  x86
0B218:  BRA    B27E
0B21A:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0B21C:  DECFSZ 51,W
0B21E:  BRA    B280
0B220:  MOVLB  8
0B222:  MOVF   x85,W
0B224:  SUBLW  23
0B226:  BZ    B27A
0B228:  MOVF   x85,W
0B22A:  SUBLW  24
0B22C:  BC    B234
0B22E:  MOVF   x85,W
0B230:  SUBLW  26
0B232:  BC    B27A
0B234:  MOVF   x85,W
0B236:  SUBLW  29
0B238:  BC    B240
0B23A:  MOVF   x85,W
0B23C:  SUBLW  2B
0B23E:  BC    B27A
0B240:  MOVF   x85,W
0B242:  SUBLW  2D
0B244:  BZ    B27A
0B246:  MOVF   x85,W
0B248:  SUBLW  2F
0B24A:  BZ    B27A
0B24C:  MOVF   x85,W
0B24E:  SUBLW  40
0B250:  BC    B258
0B252:  MOVF   x85,W
0B254:  SUBLW  42
0B256:  BC    B27A
0B258:  MOVF   x85,W
0B25A:  SUBLW  43
0B25C:  BC    B264
0B25E:  MOVF   x85,W
0B260:  SUBLW  5A
0B262:  BC    B27A
0B264:  MOVF   x85,W
0B266:  SUBLW  5E
0B268:  BZ    B27A
0B26A:  MOVF   x85,W
0B26C:  SUBLW  60
0B26E:  BC    B276
0B270:  MOVF   x85,W
0B272:  SUBLW  7A
0B274:  BC    B27A
0B276:  MOVLW  00
0B278:  BRA    B27C
0B27A:  MOVLW  01
0B27C:  MOVWF  x86
0B27E:  MOVLB  0
....................    return(valid); 
0B280:  MOVLB  8
0B282:  MOVFF  886,01
0B286:  MOVLB  0
0B288:  GOTO   1B3D4 (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(!check_cmd(cmd)) 
*
1B3CC:  MOVFF  47,885
1B3D0:  GOTO   B1C8
1B3D4:  MOVF   01,F
1B3D6:  BNZ   1B3FA
....................       fputs("\r\n@INV", COM_A); 
1B3D8:  MOVLW  F0
1B3DA:  MOVWF  FF6
1B3DC:  MOVLW  27
1B3DE:  MOVWF  FF7
1B3E0:  MOVLW  00
1B3E2:  MOVWF  FF8
1B3E4:  CALL   AEB6
1B3E8:  MOVLW  0D
1B3EA:  BTFSS  F9E.4
1B3EC:  BRA    1B3EA
1B3EE:  MOVWF  FAD
1B3F0:  MOVLW  0A
1B3F2:  BTFSS  F9E.4
1B3F4:  BRA    1B3F2
1B3F6:  MOVWF  FAD
1B3F8:  BRA    1B41C
....................    else{ 
....................       fputs("\r\n@OK! ", COM_A); 
1B3FA:  MOVLW  F8
1B3FC:  MOVWF  FF6
1B3FE:  MOVLW  27
1B400:  MOVWF  FF7
1B402:  MOVLW  00
1B404:  MOVWF  FF8
1B406:  CALL   AEB6
1B40A:  MOVLW  0D
1B40C:  BTFSS  F9E.4
1B40E:  BRA    1B40C
1B410:  MOVWF  FAD
1B412:  MOVLW  0A
1B414:  BTFSS  F9E.4
1B416:  BRA    1B414
1B418:  MOVWF  FAD
....................       select_cmd(); 
1B41A:  BRA    1B15C
....................    } 
1B41C:  GOTO   1B634 (RETURN)
.................... } 
.................... void proc_cmd2() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
....................    else fputs("@INV", COM_A); 
.................... } 
....................  
.................... void command_prompt(){ 
1B420:  MOVLB  8
1B422:  CLRF   x64
1B424:  CLRF   x65
1B426:  CLRF   x66
....................    int8 good_val = FALSE; 
....................    int8 i = 0; 
....................    char temp = 0; 
....................    char input_string[30]; 
....................     
....................    //Disable rtc watchdog 
....................    output_bit(RTC_CS, ENABLE); 
1B428:  BCF    F91.0
....................    spi_write(0x89); 
1B42A:  MOVF   FC9,W
1B42C:  MOVLW  89
1B42E:  MOVWF  FC9
1B430:  RRCF   FC7,W
1B432:  BNC   1B430
....................    spi_write(0b00000000); 
1B434:  MOVF   FC9,W
1B436:  CLRF   FC9
1B438:  RRCF   FC7,W
1B43A:  BNC   1B438
....................    output_bit(RTC_CS, DISABLE); 
1B43C:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
1B43E:  BCF    F91.0
....................    spi_read(0x00); 
1B440:  MOVF   FC9,W
1B442:  CLRF   FC9
1B444:  RRCF   FC7,W
1B446:  BNC   1B444
....................    output_bit(RTC_CS, DISABLE); 
1B448:  BSF    F91.0
....................     
....................     
....................    nv_cmd_mode = TRUE; 
1B44A:  CLRF   32
1B44C:  MOVLW  01
1B44E:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1B450:  MOVLW  02
1B452:  MOVWF  x89
1B454:  MOVFF  31,88A
1B458:  MOVLB  0
1B45A:  CALL   343A
....................     
....................    fputs("@CMD", COM_A); 
1B45E:  MOVLW  06
1B460:  MOVWF  FF6
1B462:  MOVLW  28
1B464:  MOVWF  FF7
1B466:  MOVLW  00
1B468:  MOVWF  FF8
1B46A:  CALL   AEB6
1B46E:  MOVLW  0D
1B470:  BTFSS  F9E.4
1B472:  BRA    1B470
1B474:  MOVWF  FAD
1B476:  MOVLW  0A
1B478:  BTFSS  F9E.4
1B47A:  BRA    1B478
1B47C:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1B47E:  MOVLW  01
1B480:  MOVWF  1E
1B482:  MOVLW  A7
1B484:  MOVWF  1D
1B486:  MOVLW  0C
1B488:  MOVWF  FF6
1B48A:  MOVLW  28
1B48C:  MOVWF  FF7
1B48E:  MOVLW  00
1B490:  MOVWF  FF8
1B492:  CALL   50E6
....................    record_event(); 
1B496:  CALL   8502
....................     
....................    busy_clear(); 
1B49A:  CALL   AEE0
....................     
....................    cmd_set=0; // user 
1B49E:  CLRF   51
....................     
....................    do { 
....................       for(i = 0; i<30; i++){ 
1B4A0:  MOVLB  8
1B4A2:  CLRF   x65
1B4A4:  MOVF   x65,W
1B4A6:  SUBLW  1D
1B4A8:  BNC   1B4BE
....................          input_string[i] = 0; 
1B4AA:  CLRF   03
1B4AC:  MOVF   x65,W
1B4AE:  ADDLW  67
1B4B0:  MOVWF  FE9
1B4B2:  MOVLW  08
1B4B4:  ADDWFC 03,W
1B4B6:  MOVWF  FEA
1B4B8:  CLRF   FEF
1B4BA:  INCF   x65,F
1B4BC:  BRA    1B4A4
....................    
....................       } 
....................       i = 0; 
1B4BE:  CLRF   x65
....................       fputc('>',COM_A); 
1B4C0:  MOVLW  3E
1B4C2:  MOVLB  0
1B4C4:  CALL   AEE8
....................       temp = 0; 
1B4C8:  MOVLB  8
1B4CA:  CLRF   x66
....................       while(temp != CARRIAGE_RET){ 
1B4CC:  MOVF   x66,W
1B4CE:  SUBLW  0D
1B4D0:  BZ    1B568
....................          temp = fgetc(COM_A); 
1B4D2:  MOVLB  0
1B4D4:  CALL   0E58
1B4D8:  MOVFF  01,866
....................          //Backspace character 
....................          if(temp != 8){ 
1B4DC:  MOVLB  8
1B4DE:  MOVF   x66,W
1B4E0:  SUBLW  08
1B4E2:  BZ    1B50E
....................             if (com_echo == TRUE) 
1B4E4:  DECFSZ 4C,W
1B4E6:  BRA    1B4F2
....................             { 
....................                fputc(temp,COM_A); 
1B4E8:  MOVF   x66,W
1B4EA:  MOVLB  0
1B4EC:  CALL   AEE8
1B4F0:  MOVLB  8
....................             } 
....................             if(temp!= CARRIAGE_RET){ 
1B4F2:  MOVF   x66,W
1B4F4:  SUBLW  0D
1B4F6:  BZ    1B50C
....................                input_string[i] = temp; 
1B4F8:  CLRF   03
1B4FA:  MOVF   x65,W
1B4FC:  ADDLW  67
1B4FE:  MOVWF  FE9
1B500:  MOVLW  08
1B502:  ADDWFC 03,W
1B504:  MOVWF  FEA
1B506:  MOVFF  866,FEF
....................                i++; 
1B50A:  INCF   x65,F
....................             } 
....................          }else{ 
1B50C:  BRA    1B566
....................             //backspace code 
....................             if(i != 0){ 
1B50E:  MOVF   x65,F
1B510:  BZ    1B566
....................                input_string[i-1] = 0; 
1B512:  MOVLW  01
1B514:  SUBWF  x65,W
1B516:  CLRF   03
1B518:  ADDLW  67
1B51A:  MOVWF  FE9
1B51C:  MOVLW  08
1B51E:  ADDWFC 03,W
1B520:  MOVWF  FEA
1B522:  CLRF   FEF
....................                i--; 
1B524:  DECF   x65,F
....................                //Clear buffer and overwrite with previous minus one character 
....................                fputc('\r',COM_A); 
1B526:  MOVLW  0D
1B528:  MOVLB  0
1B52A:  CALL   AEE8
....................                fprintf(COM_A,"                                       "); 
1B52E:  MOVLW  1E
1B530:  MOVWF  FF6
1B532:  MOVLW  28
1B534:  MOVWF  FF7
1B536:  MOVLW  00
1B538:  MOVWF  FF8
1B53A:  CLRF   1B
1B53C:  BTFSC  FF2.7
1B53E:  BSF    1B.7
1B540:  BCF    FF2.7
1B542:  CALL   0E6E
1B546:  BTFSC  1B.7
1B548:  BSF    FF2.7
....................                fputc('\r',COM_A); 
1B54A:  MOVLW  0D
1B54C:  CALL   AEE8
....................                fprintf(COM_A,">"); 
1B550:  MOVLW  3E
1B552:  BTFSS  F9E.4
1B554:  BRA    1B552
1B556:  MOVWF  FAD
....................                fprintf(COM_A,input_string); 
1B558:  MOVLW  08
1B55A:  MOVWF  FEA
1B55C:  MOVLW  67
1B55E:  MOVWF  FE9
1B560:  CALL   79BE
1B564:  MOVLB  8
....................                 
....................             } 
....................          } 
1B566:  BRA    1B4CC
....................       } 
....................       cmd = input_string[0]; 
1B568:  MOVFF  867,47
....................       if (cmd == '?'){ 
1B56C:  MOVF   47,W
1B56E:  SUBLW  3F
1B570:  BNZ   1B57C
....................          msg_busy(); 
1B572:  MOVLB  0
1B574:  GOTO   AEF0
....................       }else if (input_string[1] == 0){ 
1B578:  BRA    1B634
1B57A:  MOVLB  8
1B57C:  MOVF   x68,F
1B57E:  BNZ   1B5A8
....................          fputs("\r\n@ARG ", COM_A); 
1B580:  MOVLW  46
1B582:  MOVWF  FF6
1B584:  MOVLW  28
1B586:  MOVWF  FF7
1B588:  MOVLW  00
1B58A:  MOVWF  FF8
1B58C:  MOVLB  0
1B58E:  CALL   AEB6
1B592:  MOVLW  0D
1B594:  BTFSS  F9E.4
1B596:  BRA    1B594
1B598:  MOVWF  FAD
1B59A:  MOVLW  0A
1B59C:  BTFSS  F9E.4
1B59E:  BRA    1B59C
1B5A0:  MOVWF  FAD
....................          good_val = FALSE; 
1B5A2:  MOVLB  8
1B5A4:  CLRF   x64
....................       }else{ 
1B5A6:  BRA    1B636
....................       i = 1; 
1B5A8:  MOVLW  01
1B5AA:  MOVWF  x65
....................       //fputs("\r\n",COM_A); 
....................       //Check that argument is digits only 
....................       while(input_string[i] != 0){ 
1B5AC:  CLRF   03
1B5AE:  MOVF   x65,W
1B5B0:  ADDLW  67
1B5B2:  MOVWF  FE9
1B5B4:  MOVLW  08
1B5B6:  ADDWFC 03,W
1B5B8:  MOVWF  FEA
1B5BA:  MOVF   FEF,F
1B5BC:  BZ    1B60E
....................       //fputc(input_string[i],COM_A); 
....................          if(!isdigit(input_string[i])){ 
1B5BE:  CLRF   03
1B5C0:  MOVF   x65,W
1B5C2:  ADDLW  67
1B5C4:  MOVWF  FE9
1B5C6:  MOVLW  08
1B5C8:  ADDWFC 03,W
1B5CA:  MOVWF  FEA
1B5CC:  MOVFF  FEF,885
1B5D0:  MOVF   x85,W
1B5D2:  SUBLW  2F
1B5D4:  BC    1B5DC
1B5D6:  MOVF   x85,W
1B5D8:  SUBLW  39
1B5DA:  BC    1B606
....................             fputs("\r\n@ARG ", COM_A); 
1B5DC:  MOVLW  4E
1B5DE:  MOVWF  FF6
1B5E0:  MOVLW  28
1B5E2:  MOVWF  FF7
1B5E4:  MOVLW  00
1B5E6:  MOVWF  FF8
1B5E8:  MOVLB  0
1B5EA:  CALL   AEB6
1B5EE:  MOVLW  0D
1B5F0:  BTFSS  F9E.4
1B5F2:  BRA    1B5F0
1B5F4:  MOVWF  FAD
1B5F6:  MOVLW  0A
1B5F8:  BTFSS  F9E.4
1B5FA:  BRA    1B5F8
1B5FC:  MOVWF  FAD
....................             good_val = FALSE; 
1B5FE:  MOVLB  8
1B600:  CLRF   x64
....................             break; 
1B602:  BRA    1B60E
....................          }else{ 
1B604:  BRA    1B60A
....................             good_val = TRUE; 
1B606:  MOVLW  01
1B608:  MOVWF  x64
....................          } 
....................          i++; 
1B60A:  INCF   x65,F
1B60C:  BRA    1B5AC
....................       } 
....................       if(!good_val){ 
1B60E:  MOVF   x64,F
1B610:  BNZ   1B614
....................          continue; 
1B612:  BRA    1B636
....................       } 
....................       //convert arg from string to int32 
....................       arg = atoi32(input_string+1); 
1B614:  MOVLW  08
1B616:  MOVWF  x86
1B618:  MOVLW  68
1B61A:  MOVWF  x85
1B61C:  MOVLB  0
1B61E:  GOTO   AF32
1B622:  MOVFF  03,4B
1B626:  MOVFF  02,4A
1B62A:  MOVFF  01,49
1B62E:  MOVFF  00,48
....................        
....................       proc_cmd(); 
1B632:  BRA    1B3CC
1B634:  MOVLB  8
....................       } 
....................        
....................       /*if (cmd == '?') msg_busy(); 
....................       else{  
....................             proc_cmd(); 
....................              
....................       }*/ 
....................    } while(nv_cmd_mode == TRUE); 
1B636:  DECFSZ 31,W
1B638:  BRA    1B640
1B63A:  MOVF   32,F
1B63C:  BTFSC  FD8.2
1B63E:  BRA    1B4A2
1B640:  MOVLB  0
1B642:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void command_prompt2() 
.................... { 
....................    //disable_interrupts(INT_EXT); 
....................    char temp_cmd = 0; 
....................    nv_cmd_mode = TRUE; 
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
....................     
....................    fputs("@CMD", COM_A); 
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
....................    record_event(); 
....................     
....................    busy_clear(); 
....................     
....................    cmd_set=0; // user 
....................     
....................    do { 
....................       fputc('>',COM_A); 
....................       cmd=fgetc(COM_A); 
....................          temp_cmd = cmd; 
....................          if (com_echo == TRUE) 
....................          { 
....................             fputc(cmd,COM_A); 
....................          } 
....................          if (cmd == '?') msg_busy(); 
....................          else proc_cmd(); 
....................       //restart_wdt(); 
....................    } while(nv_cmd_mode == TRUE); 
.................... } 
....................  
....................  
.................... void main() 
1B644:  CLRF   FF8
1B646:  BCF    FD0.7
1B648:  BSF    07.7
1B64A:  MOVLW  70
1B64C:  MOVWF  FD3
1B64E:  MOVLW  40
1B650:  MOVWF  F9B
1B652:  CLRF   F64
1B654:  CLRF   1C
1B656:  BSF    F65.3
1B658:  MOVWF  FAF
1B65A:  MOVLW  03
1B65C:  MOVWF  FD4
1B65E:  MOVLW  A6
1B660:  MOVWF  FAC
1B662:  MOVLW  90
1B664:  MOVWF  FAB
1B666:  MOVLB  F
1B668:  BSF    x20.3
1B66A:  MOVLW  82
1B66C:  MOVWF  x1E
1B66E:  MOVLW  06
1B670:  MOVWF  x1F
1B672:  MOVLW  A6
1B674:  MOVWF  x21
1B676:  MOVLW  90
1B678:  MOVWF  x22
1B67A:  BSF    F65.3
1B67C:  MOVLW  40
1B67E:  MOVWF  FAF
1B680:  MOVLW  03
1B682:  MOVWF  FD4
1B684:  MOVLW  A6
1B686:  MOVWF  FAC
1B688:  MOVLW  90
1B68A:  MOVWF  FAB
1B68C:  CLRF   1E
1B68E:  CLRF   1D
1B690:  SETF   3A
1B692:  SETF   39
1B694:  SETF   3C
1B696:  SETF   3B
1B698:  CLRF   46
1B69A:  MOVLW  01
1B69C:  MOVWF  45
1B69E:  MOVWF  4C
1B6A0:  BCF    4D.0
1B6A2:  BCF    4D.1
1B6A4:  BCF    4D.2
1B6A6:  MOVLB  0
1B6A8:  CLRF   x66
1B6AA:  MOVLB  2
1B6AC:  MOVWF  xD9
1B6AE:  MOVLB  3
1B6B0:  CLRF   x3B
1B6B2:  MOVLB  4
1B6B4:  CLRF   xE7
1B6B6:  MOVWF  xED
1B6B8:  MOVLW  04
1B6BA:  MOVLB  7
1B6BC:  MOVWF  x13
1B6BE:  MOVLW  EE
1B6C0:  MOVWF  x12
1B6C2:  CLRF   xCD
1B6C4:  MOVLB  8
1B6C6:  CLRF   x58
1B6C8:  CLRF   x57
1B6CA:  CLRF   x5C
1B6CC:  CLRF   x5B
1B6CE:  CLRF   x5A
1B6D0:  CLRF   x59
1B6D2:  CLRF   x60
1B6D4:  CLRF   x5F
1B6D6:  CLRF   x5E
1B6D8:  CLRF   x5D
1B6DA:  MOVLW  00
1B6DC:  MOVLB  F
1B6DE:  MOVWF  x23
1B6E0:  MOVWF  x24
1B6E2:  MOVWF  x25
1B6E4:  BCF    FC1.3
1B6E6:  BCF    FC1.4
1B6E8:  BCF    FC1.5
1B6EA:  CLRF   x2E
1B6EC:  CLRF   x2F
1B6EE:  CLRF   x54
1B6F0:  BRA    1B7B2
1B6F2:  DATA 44,02
1B6F4:  DATA DD,20
1B6F6:  DATA 64,72
1B6F8:  DATA 61,77
1B6FA:  DATA 5F,61
1B6FC:  DATA 6C,6C
1B6FE:  DATA 2E,63
1B700:  DATA 73,76
1B702:  DATA 00,20
1B704:  DATA 64,72
1B706:  DATA 61,77
1B708:  DATA 5F,6E
1B70A:  DATA 65,77
1B70C:  DATA 2E,63
1B70E:  DATA 73,76
1B710:  DATA 00,20
1B712:  DATA 64,72
1B714:  DATA 65,6C
1B716:  DATA 5F,61
1B718:  DATA 6C,6C
1B71A:  DATA 2E,63
1B71C:  DATA 73,76
1B71E:  DATA 00,20
1B720:  DATA 64,72
1B722:  DATA 65,6C
1B724:  DATA 5F,6E
1B726:  DATA 65,77
1B728:  DATA 2E,63
1B72A:  DATA 73,76
1B72C:  DATA 00,20
1B72E:  DATA 65,76
1B730:  DATA 65,6E
1B732:  DATA 74,73
1B734:  DATA 2E,74
1B736:  DATA 78,74
1B738:  DATA 00,02
1B73A:  DATA 03,39
1B73C:  DATA 2C,00
1B73E:  DATA 02,04
1B740:  DATA D8,00
1B742:  DATA 00,10
1B744:  DATA 07,14
1B746:  DATA 46,41
1B748:  DATA 54,31
1B74A:  DATA 32,46
1B74C:  DATA 41,54
1B74E:  DATA 31,36
1B750:  DATA 46,41
1B752:  DATA 54,33
1B754:  DATA 32,00
1B756:  DATA 57,07
1B758:  DATA CE,0D
1B75A:  DATA 0A,00
1B75C:  DATA 00,03
1B75E:  DATA 00,0F
1B760:  DATA 00,1B
1B762:  DATA 00,27
1B764:  DATA 00,33
1B766:  DATA 00,3F
1B768:  DATA 00,4B
1B76A:  DATA 00,57
1B76C:  DATA 00,63
1B76E:  DATA 00,6F
1B770:  DATA 00,7B
1B772:  DATA 00,87
1B774:  DATA 00,93
1B776:  DATA 00,9F
1B778:  DATA 00,AB
1B77A:  DATA 00,B7
1B77C:  DATA 00,C3
1B77E:  DATA 48,B1
1B780:  DATA 70,D4
1B782:  DATA 98,F7
1B784:  DATA C0,1A
1B786:  DATA 00,CF
1B788:  DATA 28,F2
1B78A:  DATA 50,15
1B78C:  DATA 78,38
1B78E:  DATA A0,5B
1B790:  DATA C8,7E
1B792:  DATA F0,A1
1B794:  DATA 18,C5
1B796:  DATA 40,E8
1B798:  DATA 68,0B
1B79A:  DATA 90,2E
1B79C:  DATA B8,51
1B79E:  DATA E0,74
1B7A0:  DATA 08,98
1B7A2:  DATA 30,BB
1B7A4:  DATA 58,DE
1B7A6:  DATA 80,01
1B7A8:  DATA A8,24
1B7AA:  DATA D0,47
1B7AC:  DATA F8,6A
1B7AE:  DATA 20,8E
1B7B0:  DATA 00,00
1B7B2:  MOVLW  01
1B7B4:  MOVWF  FF8
1B7B6:  MOVLW  B6
1B7B8:  MOVWF  FF7
1B7BA:  MOVLW  F2
1B7BC:  MOVWF  FF6
1B7BE:  TBLRD*+
1B7C0:  MOVF   FF5,W
1B7C2:  MOVWF  00
1B7C4:  XORLW  00
1B7C6:  BZ    1B7EE
1B7C8:  TBLRD*+
1B7CA:  MOVF   FF5,W
1B7CC:  MOVWF  01
1B7CE:  BTFSC  FE8.7
1B7D0:  BRA    1B7DC
1B7D2:  ANDLW  0F
1B7D4:  MOVWF  FEA
1B7D6:  TBLRD*+
1B7D8:  MOVFF  FF5,FE9
1B7DC:  BTFSC  01.6
1B7DE:  TBLRD*+
1B7E0:  BTFSS  01.6
1B7E2:  TBLRD*+
1B7E4:  MOVFF  FF5,FEE
1B7E8:  DCFSNZ 00,F
1B7EA:  BRA    1B7BE
1B7EC:  BRA    1B7E0
1B7EE:  CLRF   FF8
1B7F0:  MOVLB  8
1B7F2:  CLRF   x61
1B7F4:  CLRF   x63
1B7F6:  CLRF   x62
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B7F8:  BCF    FF2.6
1B7FA:  BCF    FF2.7
1B7FC:  BTFSC  FF2.7
1B7FE:  BRA    1B7FA
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B800:  BCF    FC6.5
1B802:  MOVLW  21
1B804:  MOVWF  FC6
1B806:  MOVLW  40
1B808:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B80A:  BCF    F67.5
1B80C:  MOVLW  21
1B80E:  MOVWF  F67
1B810:  MOVLW  40
1B812:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B814:  MOVLW  00
1B816:  MOVLB  F
1B818:  MOVWF  x23
1B81A:  MOVWF  x24
1B81C:  MOVLW  1F
1B81E:  MOVWF  x25
1B820:  BCF    FC1.3
1B822:  BSF    FC1.4
1B824:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B826:  MOVF   FC0,W
1B828:  ANDLW  C0
1B82A:  IORLW  07
1B82C:  MOVWF  FC0
1B82E:  BSF    FC0.7
1B830:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B832:  MOVLW  87
1B834:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B836:  MOVLW  37
1B838:  MOVWF  FCD
1B83A:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B83C:  MOVLB  0
1B83E:  GOTO   28EC
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B842:  CLRF   FB0
1B844:  MOVLW  07
1B846:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B848:  MOVLW  04
1B84A:  MOVLB  F
1B84C:  MOVWF  x2E
1B84E:  MOVWF  x2F
1B850:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B852:  MOVLW  70
1B854:  MOVWF  FD3
1B856:  MOVLW  40
1B858:  MOVWF  F9B
1B85A:  CLRF   F64
....................     
....................    //setup_wdt(WDT_4S); 
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B85C:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B85E:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B860:  MOVLB  0
1B862:  CALL   2928
....................  
....................    enable_interrupts(GLOBAL); 
1B866:  MOVLW  C0
1B868:  IORWF  FF2,F
....................     
....................     
....................  
....................    init_hardware(); 
1B86A:  CALL   2962
....................    motor_sleep_rdy(); 
1B86E:  CALL   29C0
....................  
....................    sleep_mode = FALSE;    
1B872:  BCF    4D.1
....................    busy_set(); 
1B874:  CALL   29E8
....................     
....................    init_nv_vars(); 
1B878:  CALL   2AE0
....................    get_step_vars(); 
1B87C:  CALL   2D42
....................    init_aws(); 
1B880:  GOTO   3104
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B884:  CALL   311E
....................    blink(); 
1B888:  GOTO   3124
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B88C:  CALL   3170
....................     
....................    RTC_read(); 
1B890:  CALL   336C
....................    RTC_last_power(); 
1B894:  GOTO   346A
....................    RTC_reset_HT();   
1B898:  CALL   34DA
....................    RTC_read(); 
1B89C:  CALL   336C
1B8A0:  CLRF   1B
1B8A2:  BTFSC  FF2.7
1B8A4:  BSF    1B.7
1B8A6:  BCF    FF2.7
....................    RTC_read_flags(); 
1B8A8:  CALL   0DF8
1B8AC:  BTFSC  1B.7
1B8AE:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B8B0:  MOVF   3F,F
1B8B2:  BNZ   1B8B8
1B8B4:  MOVF   40,F
1B8B6:  BZ    1B908
1B8B8:  MOVLW  6E
1B8BA:  MOVWF  FF6
1B8BC:  MOVLW  28
1B8BE:  MOVWF  FF7
1B8C0:  MOVLW  00
1B8C2:  MOVWF  FF8
1B8C4:  CLRF   1B
1B8C6:  BTFSC  FF2.7
1B8C8:  BSF    1B.7
1B8CA:  BCF    FF2.7
1B8CC:  MOVLW  04
1B8CE:  MOVLB  A
1B8D0:  MOVWF  x40
1B8D2:  MOVLB  0
1B8D4:  CALL   1044
1B8D8:  BTFSC  1B.7
1B8DA:  BSF    FF2.7
1B8DC:  MOVLW  10
1B8DE:  MOVWF  FE9
1B8E0:  CLRF   1B
1B8E2:  BTFSC  FF2.7
1B8E4:  BSF    1B.7
1B8E6:  BCF    FF2.7
1B8E8:  MOVFF  40,A41
1B8EC:  MOVFF  3F,A40
1B8F0:  CALL   11C6
1B8F4:  BTFSC  1B.7
1B8F6:  BSF    FF2.7
1B8F8:  MOVLW  0D
1B8FA:  BTFSS  F9E.4
1B8FC:  BRA    1B8FA
1B8FE:  MOVWF  FAD
1B900:  MOVLW  0A
1B902:  BTFSS  F9E.4
1B904:  BRA    1B902
1B906:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B908:  CALL   3530
....................    sd_status = init_sdcard(); 
1B90C:  CALL   5062
1B910:  MOVFF  01,2DC
....................    if(sd_status>0) msg_card_fail(); 
1B914:  MOVLB  2
1B916:  MOVF   xDC,F
1B918:  BZ    1B922
1B91A:  MOVLB  0
1B91C:  CALL   50A8
1B920:  MOVLB  2
....................    
....................     
....................     
....................    reset_event(); 
1B922:  MOVLB  0
1B924:  GOTO   ABEE
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B928:  MOVLB  7
1B92A:  MOVF   x96,F
1B92C:  BNZ   1B93A
1B92E:  MOVF   x97,F
1B930:  BNZ   1B93A
1B932:  MOVF   x98,F
1B934:  BNZ   1B93A
1B936:  MOVF   x99,F
1B938:  BZ    1B942
1B93A:  MOVLB  0
1B93C:  CALL   9D2A
1B940:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B942:  MOVF   xAF,F
1B944:  BNZ   1B9C8
1B946:  MOVF   xB0,F
1B948:  BNZ   1B9C8
....................       e_port[0]=0; 
1B94A:  CLRF   xC4
1B94C:  CLRF   xC3
....................       write16(ADDR_E1_PORT,0); 
1B94E:  MOVLW  AA
1B950:  MOVLB  8
1B952:  MOVWF  xEE
1B954:  CLRF   xF0
1B956:  CLRF   xEF
1B958:  MOVLB  0
1B95A:  CALL   4FFC
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B95E:  MOVLW  78
1B960:  MOVWF  FF6
1B962:  MOVLW  28
1B964:  MOVWF  FF7
1B966:  MOVLW  00
1B968:  MOVWF  FF8
1B96A:  CLRF   1B
1B96C:  BTFSC  FF2.7
1B96E:  BSF    1B.7
1B970:  BCF    FF2.7
1B972:  MOVLW  05
1B974:  MOVLB  A
1B976:  MOVWF  x40
1B978:  MOVLB  0
1B97A:  CALL   1044
1B97E:  BTFSC  1B.7
1B980:  BSF    FF2.7
1B982:  MOVLW  10
1B984:  MOVWF  FE9
1B986:  CLRF   1B
1B988:  BTFSC  FF2.7
1B98A:  BSF    1B.7
1B98C:  BCF    FF2.7
1B98E:  MOVFF  7B0,A41
1B992:  MOVFF  7AF,A40
1B996:  CALL   11C6
1B99A:  BTFSC  1B.7
1B99C:  BSF    FF2.7
1B99E:  MOVLW  2C
1B9A0:  BTFSS  F9E.4
1B9A2:  BRA    1B9A0
1B9A4:  MOVWF  FAD
1B9A6:  MOVLW  10
1B9A8:  MOVWF  FE9
1B9AA:  MOVFF  7C4,8F1
1B9AE:  MOVFF  7C3,8F0
1B9B2:  CALL   900C
1B9B6:  MOVLW  0D
1B9B8:  BTFSS  F9E.4
1B9BA:  BRA    1B9B8
1B9BC:  MOVWF  FAD
1B9BE:  MOVLW  0A
1B9C0:  BTFSS  F9E.4
1B9C2:  BRA    1B9C0
1B9C4:  MOVWF  FAD
1B9C6:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B9C8:  MOVF   xB1,F
1B9CA:  BNZ   1BA4E
1B9CC:  MOVF   xB2,F
1B9CE:  BNZ   1BA4E
....................       m_lin_pos[1]=-1; 
1B9D0:  SETF   xB6
1B9D2:  SETF   xB5
....................       write16(ADDR_M2_LIN_POS, -1); 
1B9D4:  MOVLW  B8
1B9D6:  MOVLB  8
1B9D8:  MOVWF  xEE
1B9DA:  SETF   xF0
1B9DC:  SETF   xEF
1B9DE:  MOVLB  0
1B9E0:  CALL   4FFC
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B9E4:  MOVLW  88
1B9E6:  MOVWF  FF6
1B9E8:  MOVLW  28
1B9EA:  MOVWF  FF7
1B9EC:  MOVLW  00
1B9EE:  MOVWF  FF8
1B9F0:  CLRF   1B
1B9F2:  BTFSC  FF2.7
1B9F4:  BSF    1B.7
1B9F6:  BCF    FF2.7
1B9F8:  MOVLW  05
1B9FA:  MOVLB  A
1B9FC:  MOVWF  x40
1B9FE:  MOVLB  0
1BA00:  CALL   1044
1BA04:  BTFSC  1B.7
1BA06:  BSF    FF2.7
1BA08:  MOVLW  10
1BA0A:  MOVWF  FE9
1BA0C:  CLRF   1B
1BA0E:  BTFSC  FF2.7
1BA10:  BSF    1B.7
1BA12:  BCF    FF2.7
1BA14:  MOVFF  7B2,A41
1BA18:  MOVFF  7B1,A40
1BA1C:  CALL   11C6
1BA20:  BTFSC  1B.7
1BA22:  BSF    FF2.7
1BA24:  MOVLW  2C
1BA26:  BTFSS  F9E.4
1BA28:  BRA    1BA26
1BA2A:  MOVWF  FAD
1BA2C:  MOVLW  10
1BA2E:  MOVWF  FE9
1BA30:  MOVFF  7B6,8F1
1BA34:  MOVFF  7B5,8F0
1BA38:  CALL   900C
1BA3C:  MOVLW  0D
1BA3E:  BTFSS  F9E.4
1BA40:  BRA    1BA3E
1BA42:  MOVWF  FAD
1BA44:  MOVLW  0A
1BA46:  BTFSS  F9E.4
1BA48:  BRA    1BA46
1BA4A:  MOVWF  FAD
1BA4C:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1BA4E:  MOVF   31,F
1BA50:  BNZ   1BAF4
1BA52:  MOVF   32,F
1BA54:  BNZ   1BAF4
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1BA56:  MOVLW  98
1BA58:  MOVWF  FF6
1BA5A:  MOVLW  28
1BA5C:  MOVWF  FF7
1BA5E:  MOVLW  00
1BA60:  MOVWF  FF8
1BA62:  CLRF   1B
1BA64:  BTFSC  FF2.7
1BA66:  BSF    1B.7
1BA68:  BCF    FF2.7
1BA6A:  MOVLB  0
1BA6C:  CALL   0E6E
1BA70:  BTFSC  1B.7
1BA72:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1BA74:  MOVLB  8
1BA76:  MOVF   x63,F
1BA78:  BNZ   1BAA6
1BA7A:  MOVF   x62,W
1BA7C:  SUBLW  63
1BA7E:  BNC   1BAA6
1BA80:  MOVF   x61,W
1BA82:  SUBLW  1B
1BA84:  BZ    1BAA6
....................       { 
....................          EscNum=TestForEsc(); 
1BA86:  MOVLB  0
1BA88:  GOTO   AE5C
1BA8C:  MOVFF  01,861
....................          if(EscNum == ESCAPE) command_prompt(); 
1BA90:  MOVLB  8
1BA92:  MOVF   x61,W
1BA94:  SUBLW  1B
1BA96:  BNZ   1BA9E
1BA98:  MOVLB  0
1BA9A:  RCALL  1B420
1BA9C:  MOVLB  8
....................          EscCount++; 
1BA9E:  INCF   x62,F
1BAA0:  BTFSC  FD8.2
1BAA2:  INCF   x63,F
1BAA4:  BRA    1BA76
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1BAA6:  DECFSZ 33,W
1BAA8:  BRA    1BABE
1BAAA:  MOVF   34,F
1BAAC:  BNZ   1BABE
....................       { 
....................          arg=0; 
1BAAE:  CLRF   4B
1BAB0:  CLRF   4A
1BAB2:  CLRF   49
1BAB4:  CLRF   48
....................          commandZ(); 
1BAB6:  MOVLB  0
1BAB8:  CALL   18BCC
1BABC:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1BABE:  MOVLW  D0
1BAC0:  MOVWF  FF6
1BAC2:  MOVLW  28
1BAC4:  MOVWF  FF7
1BAC6:  MOVLW  00
1BAC8:  MOVWF  FF8
1BACA:  CLRF   1B
1BACC:  BTFSC  FF2.7
1BACE:  BSF    1B.7
1BAD0:  BCF    FF2.7
1BAD2:  MOVLB  0
1BAD4:  CALL   0E6E
1BAD8:  BTFSC  1B.7
1BADA:  BSF    FF2.7
....................       arg = 0; 
1BADC:  CLRF   4B
1BADE:  CLRF   4A
1BAE0:  CLRF   49
1BAE2:  CLRF   48
....................       commandM(TRUE); 
1BAE4:  MOVLW  01
1BAE6:  MOVLB  8
1BAE8:  MOVWF  x85
1BAEA:  MOVLB  0
1BAEC:  CALL   16DE6
....................    } 
1BAF0:  BRA    1BAF8
1BAF2:  MOVLB  7
....................    else 
....................    { 
....................       command_prompt(); 
1BAF4:  MOVLB  0
1BAF6:  RCALL  1B420
....................    } 
....................  
....................    reset_cpu(); 
1BAF8:  RESET
.................... } 
....................  
1BAFA:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 2878   PUT NOBROWNOUT BORV18 ZPBORM NOWDT WDT1024
   Word  3: 8BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
