CCS PCH C Compiler, Version 5.071d, 1               23-Jun-17 15:48
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   113292 bytes (86%)
                           Largest free fragment is 17416
               RAM used:   2144 (56%) at main() level
                           2609 (68%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1AF48
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0ECA
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0EF4
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   18EA
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E00
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   16CC
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   1742
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E5A
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
.................... /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 3F,40
00668:  DATA 42,53
0066A:  DATA 59,0D
0066C:  DATA 0A,00
0066E:  DATA 40,52
00670:  DATA 44,59
00672:  DATA 0D,0A
00674:  DATA 00,00
00676:  DATA 40,46
00678:  DATA 53,3A
0067A:  DATA 44,69
0067C:  DATA 73,63
0067E:  DATA 6F,76
00680:  DATA 65,72
00682:  DATA 79,0D
00684:  DATA 0A,00
00686:  DATA 40,46
00688:  DATA 53,3A
0068A:  DATA 55,6E
0068C:  DATA 61,62
0068E:  DATA 6C,65
00690:  DATA 20,74
00692:  DATA 6F,20
00694:  DATA 70,75
00696:  DATA 74,20
00698:  DATA 63,61
0069A:  DATA 72,64
0069C:  DATA 20,69
0069E:  DATA 6E,20
006A0:  DATA 69,64
006A2:  DATA 6C,65
006A4:  DATA 20,73
006A6:  DATA 74,61
006A8:  DATA 74,65
006AA:  DATA 2C,20
006AC:  DATA 72,65
006AE:  DATA 73,70
006B0:  DATA 6F,6E
006B2:  DATA 73,65
006B4:  DATA 20,3D
006B6:  DATA 20,25
006B8:  DATA 30,32
006BA:  DATA 78,0D
006BC:  DATA 0A,00
006BE:  DATA 40,46
006C0:  DATA 53,3A
006C2:  DATA 43,61
006C4:  DATA 72,64
006C6:  DATA 20,69
006C8:  DATA 64,6C
006CA:  DATA 65,2C
006CC:  DATA 20,72
006CE:  DATA 65,73
006D0:  DATA 70,6F
006D2:  DATA 6E,73
006D4:  DATA 65,20
006D6:  DATA 3D,20
006D8:  DATA 25,30
006DA:  DATA 32,78
006DC:  DATA 0D,0A
006DE:  DATA 00,00
006E0:  DATA 40,46
006E2:  DATA 53,3A
006E4:  DATA 52,65
006E6:  DATA 73,70
006E8:  DATA 6F,6E
006EA:  DATA 73,65
006EC:  DATA 20,74
006EE:  DATA 6F,20
006F0:  DATA 53,44
006F2:  DATA 20,76
006F4:  DATA 65,72
006F6:  DATA 20,32
006F8:  DATA 20,74
006FA:  DATA 65,73
006FC:  DATA 74,20
006FE:  DATA 43,4D
00700:  DATA 44,38
00702:  DATA 20,3D
00704:  DATA 20,25
00706:  DATA 78,0D
00708:  DATA 0A,00
0070A:  DATA 40,46
0070C:  DATA 53,3A
0070E:  DATA 50,6F
00710:  DATA 73,73
00712:  DATA 69,62
00714:  DATA 6C,65
00716:  DATA 20,53
00718:  DATA 44,76
0071A:  DATA 32,20
0071C:  DATA 63,61
0071E:  DATA 72,64
00720:  DATA 20,64
00722:  DATA 65,74
00724:  DATA 65,63
00726:  DATA 74,65
00728:  DATA 64,0D
0072A:  DATA 0A,00
0072C:  DATA 40,46
0072E:  DATA 53,3A
00730:  DATA 56,6F
00732:  DATA 6C,74
00734:  DATA 61,67
00736:  DATA 65,20
00738:  DATA 72,61
0073A:  DATA 6E,67
0073C:  DATA 65,20
0073E:  DATA 63,68
00740:  DATA 65,63
00742:  DATA 6B,2C
00744:  DATA 20,6F
00746:  DATA 63,72
00748:  DATA 20,3D
0074A:  DATA 20,25
0074C:  DATA 30,32
0074E:  DATA 78,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,0D
0075C:  DATA 0A,00
0075E:  DATA 40,46
00760:  DATA 53,3A
00762:  DATA 43,61
00764:  DATA 72,64
00766:  DATA 20,56
00768:  DATA 64,64
0076A:  DATA 20,72
0076C:  DATA 61,6E
0076E:  DATA 67,65
00770:  DATA 20,3D
00772:  DATA 20,32
00774:  DATA 2E,37
00776:  DATA 2D,33
00778:  DATA 2E,36
0077A:  DATA 20,76
0077C:  DATA 6F,6C
0077E:  DATA 74,73
00780:  DATA 0D,0A
00782:  DATA 00,00
00784:  DATA 40,46
00786:  DATA 53,3A
00788:  DATA 53,65
0078A:  DATA 6E,64
0078C:  DATA 69,6E
0078E:  DATA 67,20
00790:  DATA 41,43
00792:  DATA 4D,44
00794:  DATA 34,31
00796:  DATA 20,63
00798:  DATA 6F,6D
0079A:  DATA 6D,61
0079C:  DATA 6E,64
0079E:  DATA 20,74
007A0:  DATA 6F,20
007A2:  DATA 53,44
007A4:  DATA 20,76
007A6:  DATA 65,72
007A8:  DATA 20,32
007AA:  DATA 20,63
007AC:  DATA 61,72
007AE:  DATA 64,0D
007B0:  DATA 0A,00
007B2:  DATA 40,46
007B4:  DATA 53,3A
007B6:  DATA 52,65
007B8:  DATA 73,70
007BA:  DATA 6F,6E
007BC:  DATA 73,65
007BE:  DATA 20,66
007C0:  DATA 72,6F
007C2:  DATA 6D,20
007C4:  DATA 73,65
007C6:  DATA 6E,64
007C8:  DATA 69,6E
007CA:  DATA 67,20
007CC:  DATA 41,43
007CE:  DATA 4D,44
007D0:  DATA 34,31
007D2:  DATA 20,3D
007D4:  DATA 20,25
007D6:  DATA 30,32
007D8:  DATA 78,2C
007DA:  DATA 20,54
007DC:  DATA 69,6D
007DE:  DATA 65,72
007E0:  DATA 20,3D
007E2:  DATA 20,25
007E4:  DATA 6C,75
007E6:  DATA 0D,0A
007E8:  DATA 00,00
007EA:  DATA 40,46
007EC:  DATA 53,3A
007EE:  DATA 52,65
007F0:  DATA 73,70
007F2:  DATA 6F,6E
007F4:  DATA 73,65
007F6:  DATA 20,74
007F8:  DATA 6F,20
007FA:  DATA 43,4D
007FC:  DATA 44,35
007FE:  DATA 38,20
00800:  DATA 3D,20
00802:  DATA 25,78
00804:  DATA 0D,0A
00806:  DATA 00,00
00808:  DATA 40,46
0080A:  DATA 53,3A
0080C:  DATA 53,65
0080E:  DATA 6E,74
00810:  DATA 20,43
00812:  DATA 4D,44
00814:  DATA 20,35
00816:  DATA 38,2C
00818:  DATA 20,54
0081A:  DATA 69,6D
0081C:  DATA 65,72
0081E:  DATA 20,76
00820:  DATA 61,6C
00822:  DATA 75,65
00824:  DATA 20,3D
00826:  DATA 20,25
00828:  DATA 6C,75
0082A:  DATA 2C,20
0082C:  DATA 6F,63
0082E:  DATA 72,20
00830:  DATA 3D,20
00832:  DATA 25,30
00834:  DATA 32,78
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 0D,0A
00844:  DATA 00,00
00846:  DATA 40,46
00848:  DATA 53,3A
0084A:  DATA 43,61
0084C:  DATA 72,64
0084E:  DATA 20,43
00850:  DATA 41,4E
00852:  DATA 4E,4F
00854:  DATA 54,20
00856:  DATA 77,6F
00858:  DATA 72,6B
0085A:  DATA 20,56
0085C:  DATA 64,64
0085E:  DATA 20,72
00860:  DATA 61,6E
00862:  DATA 67,65
00864:  DATA 20,6F
00866:  DATA 66,20
00868:  DATA 32,2E
0086A:  DATA 37,2D
0086C:  DATA 33,2E
0086E:  DATA 36,20
00870:  DATA 76,6F
00872:  DATA 6C,74
00874:  DATA 73,0D
00876:  DATA 0A,00
00878:  DATA 40,46
0087A:  DATA 53,3A
0087C:  DATA 4E,6F
0087E:  DATA 74,20
00880:  DATA 61,6E
00882:  DATA 20,53
00884:  DATA 44,53
00886:  DATA 43,20
00888:  DATA 6F,72
0088A:  DATA 20,53
0088C:  DATA 44,48
0088E:  DATA 43,20
00890:  DATA 63,61
00892:  DATA 72,64
00894:  DATA 2C,20
00896:  DATA 54,65
00898:  DATA 73,74
0089A:  DATA 69,6E
0089C:  DATA 67,20
0089E:  DATA 66,6F
008A0:  DATA 72,20
008A2:  DATA 53,44
008A4:  DATA 20,56
008A6:  DATA 65,72
008A8:  DATA 31,20
008AA:  DATA 6F,72
008AC:  DATA 20,4D
008AE:  DATA 4D,43
008B0:  DATA 20,43
008B2:  DATA 61,72
008B4:  DATA 64,0D
008B6:  DATA 0A,00
008B8:  DATA 40,46
008BA:  DATA 53,3A
008BC:  DATA 52,65
008BE:  DATA 73,70
008C0:  DATA 6F,6E
008C2:  DATA 73,65
008C4:  DATA 20,66
008C6:  DATA 72,6F
008C8:  DATA 6D,20
008CA:  DATA 47,4F
008CC:  DATA 5F,49
008CE:  DATA 44,4C
008D0:  DATA 45,20
008D2:  DATA 3D,20
008D4:  DATA 25,30
008D6:  DATA 32,78
008D8:  DATA 0D,0A
008DA:  DATA 00,00
008DC:  DATA 40,46
008DE:  DATA 53,3A
008E0:  DATA 52,65
008E2:  DATA 73,70
008E4:  DATA 6F,6E
008E6:  DATA 73,65
008E8:  DATA 20,66
008EA:  DATA 72,6F
008EC:  DATA 6D,20
008EE:  DATA 53,44
008F0:  DATA 5F,43
008F2:  DATA 4D,44
008F4:  DATA 5F,53
008F6:  DATA 45,4E
008F8:  DATA 44,5F
008FA:  DATA 4F,50
008FC:  DATA 5F,43
008FE:  DATA 4F,4E
00900:  DATA 44,20
00902:  DATA 3D,20
00904:  DATA 25,30
00906:  DATA 32,78
00908:  DATA 2C,20
0090A:  DATA 54,69
0090C:  DATA 6D,65
0090E:  DATA 72,20
00910:  DATA 3D,20
00912:  DATA 25,6C
00914:  DATA 75,0D
00916:  DATA 0A,00
00918:  DATA 40,46
0091A:  DATA 53,3A
0091C:  DATA 41,74
0091E:  DATA 74,65
00920:  DATA 6D,70
00922:  DATA 74,69
00924:  DATA 6E,67
00926:  DATA 20,53
00928:  DATA 44,76
0092A:  DATA 31,20
0092C:  DATA 76,65
0092E:  DATA 72,73
00930:  DATA 75,73
00932:  DATA 20,4D
00934:  DATA 4D,43
00936:  DATA 20,49
00938:  DATA 44,2C
0093A:  DATA 20,52
0093C:  DATA 65,73
0093E:  DATA 70,6F
00940:  DATA 6E,73
00942:  DATA 65,20
00944:  DATA 66,72
00946:  DATA 6F,6D
00948:  DATA 20,53
0094A:  DATA 44,5F
0094C:  DATA 43,4D
0094E:  DATA 44,5F
00950:  DATA 41,50
00952:  DATA 50,4C
00954:  DATA 5F,43
00956:  DATA 4D,44
00958:  DATA 20,3D
0095A:  DATA 20,25
0095C:  DATA 30,32
0095E:  DATA 78,0D
00960:  DATA 0A,00
00962:  DATA 40,46
00964:  DATA 53,3A
00966:  DATA 49,6E
00968:  DATA 76,61
0096A:  DATA 6C,69
0096C:  DATA 64,20
0096E:  DATA 72,65
00970:  DATA 73,70
00972:  DATA 6F,6E
00974:  DATA 73,65
00976:  DATA 20,74
00978:  DATA 6F,20
0097A:  DATA 53,44
0097C:  DATA 5F,41
0097E:  DATA 43,4D
00980:  DATA 44,34
00982:  DATA 31,2C
00984:  DATA 20,72
00986:  DATA 65,73
00988:  DATA 70,6F
0098A:  DATA 6E,73
0098C:  DATA 65,20
0098E:  DATA 3D,20
00990:  DATA 25,30
00992:  DATA 32,58
00994:  DATA 2C,20
00996:  DATA 72,65
00998:  DATA 69,6E
0099A:  DATA 69,74
0099C:  DATA 69,61
0099E:  DATA 6C,69
009A0:  DATA 7A,69
009A2:  DATA 6E,67
009A4:  DATA 20,61
009A6:  DATA 73,20
009A8:  DATA 4D,4D
009AA:  DATA 43,0D
009AC:  DATA 0A,00
009AE:  DATA 40,46
009B0:  DATA 53,3A
009B2:  DATA 46,61
009B4:  DATA 69,6C
009B6:  DATA 65,64
009B8:  DATA 20,74
009BA:  DATA 6F,20
009BC:  DATA 69,6E
009BE:  DATA 69,74
009C0:  DATA 69,61
009C2:  DATA 6C,69
009C4:  DATA 7A,65
009C6:  DATA 20,61
009C8:  DATA 73,20
009CA:  DATA 4D,4D
009CC:  DATA 43,2C
009CE:  DATA 20,72
009D0:  DATA 65,73
009D2:  DATA 70,6F
009D4:  DATA 6E,73
009D6:  DATA 65,20
009D8:  DATA 3D,20
009DA:  DATA 25,30
009DC:  DATA 32,58
009DE:  DATA 2C,20
009E0:  DATA 65,78
009E2:  DATA 69,74
009E4:  DATA 69,6E
009E6:  DATA 67,0D
009E8:  DATA 0A,00
009EA:  DATA 40,46
009EC:  DATA 53,3A
009EE:  DATA 43,61
009F0:  DATA 72,64
009F2:  DATA 20,66
009F4:  DATA 61,69
009F6:  DATA 6C,65
009F8:  DATA 64,20
009FA:  DATA 74,6F
009FC:  DATA 20,72
009FE:  DATA 65,73
00A00:  DATA 70,6F
00A02:  DATA 6E,64
00A04:  DATA 20,63
00A06:  DATA 6F,72
00A08:  DATA 72,65
00A0A:  DATA 63,6C
00A0C:  DATA 79,20
00A0E:  DATA 61,66
00A10:  DATA 74,65
00A12:  DATA 72,20
00A14:  DATA 53,44
00A16:  DATA 5F,43
00A18:  DATA 4D,44
00A1A:  DATA 5F,53
00A1C:  DATA 45,4E
00A1E:  DATA 44,5F
00A20:  DATA 4F,50
00A22:  DATA 5F,43
00A24:  DATA 4F,4E
00A26:  DATA 44,2C
00A28:  DATA 20,72
00A2A:  DATA 65,73
00A2C:  DATA 70,6F
00A2E:  DATA 6E,73
00A30:  DATA 65,20
00A32:  DATA 3D,20
00A34:  DATA 25,30
00A36:  DATA 32,58
00A38:  DATA 2C,20
00A3A:  DATA 54,69
00A3C:  DATA 6D,65
00A3E:  DATA 72,20
00A40:  DATA 3D,20
00A42:  DATA 25,6C
00A44:  DATA 75,0D
00A46:  DATA 0A,00
00A48:  DATA 40,46
00A4A:  DATA 53,3A
00A4C:  DATA 53,65
00A4E:  DATA 74,74
00A50:  DATA 69,6E
00A52:  DATA 67,20
00A54:  DATA 62,6C
00A56:  DATA 6F,63
00A58:  DATA 6B,20
00A5A:  DATA 6C,65
00A5C:  DATA 6E,67
00A5E:  DATA 74,68
00A60:  DATA 0D,0A
00A62:  DATA 00,00
00A64:  DATA 40,46
00A66:  DATA 53,3A
00A68:  DATA 45,72
00A6A:  DATA 72,6F
00A6C:  DATA 72,20
00A6E:  DATA 73,65
00A70:  DATA 74,74
00A72:  DATA 69,6E
00A74:  DATA 67,20
00A76:  DATA 62,6C
00A78:  DATA 6F,63
00A7A:  DATA 6B,20
00A7C:  DATA 6C,65
00A7E:  DATA 6E,67
00A80:  DATA 74,68
00A82:  DATA 2C,20
00A84:  DATA 72,65
00A86:  DATA 73,70
00A88:  DATA 6F,6E
00A8A:  DATA 73,65
00A8C:  DATA 20,3D
00A8E:  DATA 20,25
00A90:  DATA 30,32
00A92:  DATA 78,2C
00A94:  DATA 20,74
00A96:  DATA 69,6D
00A98:  DATA 65,72
00A9A:  DATA 20,3D
00A9C:  DATA 20,25
00A9E:  DATA 6C,75
00AA0:  DATA 0D,0A
00AA2:  DATA 00,00
00AA4:  DATA 40,46
00AA6:  DATA 53,3A
00AA8:  DATA 43,61
00AAA:  DATA 72,64
00AAC:  DATA 20,54
00AAE:  DATA 79,70
00AB0:  DATA 65,20
00AB2:  DATA 44,69
00AB4:  DATA 73,63
00AB6:  DATA 6F,76
00AB8:  DATA 65,72
00ABA:  DATA 79,20
00ABC:  DATA 45,72
00ABE:  DATA 72,6F
00AC0:  DATA 72,0D
00AC2:  DATA 0A,00
00AC4:  DATA 40,46
00AC6:  DATA 53,3A
00AC8:  DATA 4D,4D
00ACA:  DATA 43,20
00ACC:  DATA 43,61
00ACE:  DATA 72,64
00AD0:  DATA 20,66
00AD2:  DATA 6F,75
00AD4:  DATA 6E,64
00AD6:  DATA 0D,0A
00AD8:  DATA 00,00
00ADA:  DATA 40,46
00ADC:  DATA 53,3A
00ADE:  DATA 53,44
00AE0:  DATA 76,31
00AE2:  DATA 20,43
00AE4:  DATA 61,72
00AE6:  DATA 64,20
00AE8:  DATA 66,6F
00AEA:  DATA 75,6E
00AEC:  DATA 64,0D
00AEE:  DATA 0A,00
00AF0:  DATA 40,46
00AF2:  DATA 53,3A
00AF4:  DATA 53,44
00AF6:  DATA 53,43
00AF8:  DATA 20,43
00AFA:  DATA 61,72
00AFC:  DATA 64,20
00AFE:  DATA 66,6F
00B00:  DATA 75,6E
00B02:  DATA 64,0D
00B04:  DATA 0A,00
00B06:  DATA 40,46
00B08:  DATA 53,3A
00B0A:  DATA 53,44
00B0C:  DATA 48,43
00B0E:  DATA 20,43
00B10:  DATA 61,72
00B12:  DATA 64,20
00B14:  DATA 66,6F
00B16:  DATA 75,6E
00B18:  DATA 64,0D
00B1A:  DATA 0A,00
00B1C:  DATA 40,46
00B1E:  DATA 53,3A
00B20:  DATA 43,61
00B22:  DATA 72,64
00B24:  DATA 20,54
00B26:  DATA 79,70
00B28:  DATA 65,20
00B2A:  DATA 44,69
00B2C:  DATA 73,63
00B2E:  DATA 6F,76
00B30:  DATA 65,72
00B32:  DATA 79,20
00B34:  DATA 45,72
00B36:  DATA 72,6F
00B38:  DATA 72,2C
00B3A:  DATA 20,43
00B3C:  DATA 61,72
00B3E:  DATA 64,20
00B40:  DATA 3D,20
00B42:  DATA 25,30
00B44:  DATA 32,58
00B46:  DATA 0D,0A
00B48:  DATA 00,00
00B4A:  DATA 40,46
00B4C:  DATA 53,3A
00B4E:  DATA 43,61
00B50:  DATA 72,64
00B52:  DATA 20,72
00B54:  DATA 65,73
00B56:  DATA 65,74
00B58:  DATA 20,73
00B5A:  DATA 75,63
00B5C:  DATA 63,65
00B5E:  DATA 73,73
00B60:  DATA 20,2D
00B62:  DATA 20,43
00B64:  DATA 6D,64
00B66:  DATA 20,74
00B68:  DATA 6F,20
00B6A:  DATA 52,65
00B6C:  DATA 61,64
00B6E:  DATA 79,20
00B70:  DATA 63,6F
00B72:  DATA 75,6E
00B74:  DATA 74,20
00B76:  DATA 3D,20
00B78:  DATA 25,6C
00B7A:  DATA 75,0D
00B7C:  DATA 0A,00
00B7E:  DATA 40,46
00B80:  DATA 53,3A
00B82:  DATA 53,50
00B84:  DATA 49,20
00B86:  DATA 62,75
00B88:  DATA 73,20
00B8A:  DATA 73,70
00B8C:  DATA 65,65
00B8E:  DATA 64,20
00B90:  DATA 73,65
00B92:  DATA 74,20
00B94:  DATA 74,6F
00B96:  DATA 20,68
00B98:  DATA 69,67
00B9A:  DATA 68,0D
00B9C:  DATA 0A,00
00B9E:  DATA 40,46
00BA0:  DATA 53,3A
00BA2:  DATA 43,61
00BA4:  DATA 72,64
00BA6:  DATA 20,61
00BA8:  DATA 63,74
00BAA:  DATA 69,76
00BAC:  DATA 61,74
00BAE:  DATA 65,20
00BB0:  DATA 66,61
00BB2:  DATA 69,6C
00BB4:  DATA 75,72
00BB6:  DATA 65,2C
00BB8:  DATA 20,72
00BBA:  DATA 65,73
00BBC:  DATA 70,6F
00BBE:  DATA 6E,73
00BC0:  DATA 65,20
00BC2:  DATA 3D,20
00BC4:  DATA 25,30
00BC6:  DATA 32,58
00BC8:  DATA 2C,20
00BCA:  DATA 54,69
00BCC:  DATA 6D,65
00BCE:  DATA 72,20
00BD0:  DATA 3D,20
00BD2:  DATA 25,6C
00BD4:  DATA 75,0D
00BD6:  DATA 0A,00
00BD8:  DATA 40,46
00BDA:  DATA 53,3A
00BDC:  DATA 43,61
00BDE:  DATA 72,64
00BE0:  DATA 20,61
00BE2:  DATA 63,74
00BE4:  DATA 69,76
00BE6:  DATA 61,74
00BE8:  DATA 65,20
00BEA:  DATA 73,75
00BEC:  DATA 63,63
00BEE:  DATA 65,73
00BF0:  DATA 73,20
00BF2:  DATA 6F,6E
00BF4:  DATA 20,61
00BF6:  DATA 74,74
00BF8:  DATA 65,6D
00BFA:  DATA 70,74
00BFC:  DATA 20,25
00BFE:  DATA 6C,75
00C00:  DATA 0D,0A
00C02:  DATA 00,00
00C04:  DATA 46,41
00C06:  DATA 54,20
00C08:  DATA 61,74
00C0A:  DATA 20,73
00C0C:  DATA 65,63
00C0E:  DATA 74,6F
00C10:  DATA 72,20
00C12:  DATA 30,0D
00C14:  DATA 0A,00
00C16:  DATA 54,59
00C18:  DATA 50,45
00C1A:  DATA 20,63
00C1C:  DATA 6F,6D
00C1E:  DATA 6D,61
00C20:  DATA 6E,64
00C22:  DATA 20,45
00C24:  DATA 52,52
00C26:  DATA 4F,52
00C28:  DATA 0D,0A
00C2A:  DATA 00,00
00C2C:  DATA 40,46
00C2E:  DATA 53,3A
00C30:  DATA 20,25
00C32:  DATA 73,0D
00C34:  DATA 0A,00
00C36:  DATA 40,46
00C38:  DATA 53,3A
00C3A:  DATA 20,25
00C3C:  DATA 73,0D
00C3E:  DATA 0A,00
00C40:  DATA 2A,2A
00C42:  DATA 20,40
00C44:  DATA 46,53
00C46:  DATA 3A,20
00C48:  DATA 45,52
00C4A:  DATA 52,4F
00C4C:  DATA 52,0D
00C4E:  DATA 0A,00
00C50:  DATA 20,20
00C52:  DATA 20,4E
00C54:  DATA 6F,45
00C56:  DATA 72,72
00C58:  DATA 6F,72
00C5A:  DATA 0D,0A
00C5C:  DATA 00,00
00C5E:  DATA 20,20
00C60:  DATA 20,4D
00C62:  DATA 65,64
00C64:  DATA 69,61
00C66:  DATA 20,4E
00C68:  DATA 6F,74
00C6A:  DATA 20,52
00C6C:  DATA 65,61
00C6E:  DATA 64,79
00C70:  DATA 0D,0A
00C72:  DATA 00,00
00C74:  DATA 20,20
00C76:  DATA 20,46
00C78:  DATA 69,6C
00C7A:  DATA 65,20
00C7C:  DATA 4E,6F
00C7E:  DATA 74,20
00C80:  DATA 46,6F
00C82:  DATA 75,6E
00C84:  DATA 64,0D
00C86:  DATA 0A,00
00C88:  DATA 20,20
00C8A:  DATA 20,49
00C8C:  DATA 6E,76
00C8E:  DATA 61,6C
00C90:  DATA 69,64
00C92:  DATA 20,50
00C94:  DATA 61,74
00C96:  DATA 68,0D
00C98:  DATA 0A,00
00C9A:  DATA 20,20
00C9C:  DATA 20,49
00C9E:  DATA 6E,76
00CA0:  DATA 61,6C
00CA2:  DATA 69,64
00CA4:  DATA 20,4E
00CA6:  DATA 61,6D
00CA8:  DATA 65,0D
00CAA:  DATA 0A,00
00CAC:  DATA 20,20
00CAE:  DATA 20,41
00CB0:  DATA 63,63
00CB2:  DATA 65,73
00CB4:  DATA 73,20
00CB6:  DATA 44,65
00CB8:  DATA 6E,69
00CBA:  DATA 65,64
00CBC:  DATA 0D,0A
00CBE:  DATA 00,00
00CC0:  DATA 20,20
00CC2:  DATA 20,44
00CC4:  DATA 69,73
00CC6:  DATA 6B,20
00CC8:  DATA 46,75
00CCA:  DATA 6C,6C
00CCC:  DATA 0D,0A
00CCE:  DATA 00,00
00CD0:  DATA 20,20
00CD2:  DATA 20,52
00CD4:  DATA 65,61
00CD6:  DATA 64,2F
00CD8:  DATA 57,72
00CDA:  DATA 69,74
00CDC:  DATA 65,20
00CDE:  DATA 45,72
00CE0:  DATA 72,6F
00CE2:  DATA 72,0D
00CE4:  DATA 0A,00
00CE6:  DATA 20,20
00CE8:  DATA 20,49
00CEA:  DATA 6E,63
00CEC:  DATA 6F,72
00CEE:  DATA 72,65
00CF0:  DATA 63,74
00CF2:  DATA 20,4D
00CF4:  DATA 65,64
00CF6:  DATA 69,61
00CF8:  DATA 20,43
00CFA:  DATA 68,61
00CFC:  DATA 6E,67
00CFE:  DATA 65,0D
00D00:  DATA 0A,00
00D02:  DATA 20,20
00D04:  DATA 20,57
00D06:  DATA 72,69
00D08:  DATA 74,65
00D0A:  DATA 20,50
00D0C:  DATA 72,6F
00D0E:  DATA 74,65
00D10:  DATA 63,74
00D12:  DATA 65,64
00D14:  DATA 0D,0A
00D16:  DATA 00,00
00D18:  DATA 20,20
00D1A:  DATA 20,4E
00D1C:  DATA 6F,74
00D1E:  DATA 20,45
00D20:  DATA 6E,61
00D22:  DATA 62,6C
00D24:  DATA 65,64
00D26:  DATA 0D,0A
00D28:  DATA 00,00
00D2A:  DATA 20,20
00D2C:  DATA 20,4E
00D2E:  DATA 6F,20
00D30:  DATA 46,69
00D32:  DATA 6C,65
00D34:  DATA 20,53
00D36:  DATA 79,73
00D38:  DATA 74,65
00D3A:  DATA 6D,0D
00D3C:  DATA 0A,00
00D3E:  DATA 61,70
00D40:  DATA 70,65
00D42:  DATA 6E,64
00D44:  DATA 3A,20
00D46:  DATA 46,53
00D48:  DATA 20,45
00D4A:  DATA 52,52
00D4C:  DATA 4F,52
00D4E:  DATA 20,6F
00D50:  DATA 6E,20
00D52:  DATA 66,69
00D54:  DATA 6C,65
00D56:  DATA 5F,6F
00D58:  DATA 70,65
00D5A:  DATA 6E,0D
00D5C:  DATA 0A,00
00D5E:  DATA 40,46
00D60:  DATA 53,3A
00D62:  DATA 57,72
00D64:  DATA 69,74
00D66:  DATA 69,6E
00D68:  DATA 67,0D
00D6A:  DATA 0A,5B
00D6C:  DATA 25,73
00D6E:  DATA 5D,0D
00D70:  DATA 0A,00
00D72:  DATA 40,46
00D74:  DATA 53,3A
00D76:  DATA 45,52
00D78:  DATA 52,4F
00D7A:  DATA 52,5B
00D7C:  DATA 61,70
00D7E:  DATA 70,65
00D80:  DATA 6E,64
00D82:  DATA 5D,0D
00D84:  DATA 0A,00
00D86:  DATA 40,46
00D88:  DATA 53,3A
00D8A:  DATA 43,6C
00D8C:  DATA 6F,73
00D8E:  DATA 69,6E
00D90:  DATA 67,0D
00D92:  DATA 0A,00
00D94:  DATA 40,52
00D96:  DATA 54,43
00D98:  DATA 3A,25
00D9A:  DATA 30,32
00D9C:  DATA 75,2F
00D9E:  DATA 00,00
00DA0:  DATA 40,52
00DA2:  DATA 54,43
00DA4:  DATA 3A,25
00DA6:  DATA 30,32
00DA8:  DATA 75,2F
00DAA:  DATA 00,00
00DAC:  DATA 40,41
00DAE:  DATA 4C,4D
00DB0:  DATA 3A,25
00DB2:  DATA 30,32
00DB4:  DATA 75,2F
00DB6:  DATA 00,00
00DB8:  DATA 40,41
00DBA:  DATA 4C,4D
00DBC:  DATA 3A,25
00DBE:  DATA 30,32
00DC0:  DATA 75,2F
00DC2:  DATA 00,00
00DC4:  DATA 40,41
00DC6:  DATA 4C,4D
00DC8:  DATA 0D,0A
00DCA:  DATA 00,00
*
00E30:  TBLRD*+
00E32:  MOVF   FF5,F
00E34:  BZ    0E58
00E36:  MOVFF  FF6,A10
00E3A:  MOVFF  FF7,A11
00E3E:  MOVFF  FF8,A12
00E42:  MOVF   FF5,W
00E44:  BTFSS  F9E.4
00E46:  BRA    0E44
00E48:  MOVWF  FAD
00E4A:  MOVFF  A10,FF6
00E4E:  MOVFF  A11,FF7
00E52:  MOVFF  A12,FF8
00E56:  BRA    0E30
00E58:  RETURN 0
*
00EBA:  DATA 3F,40
00EBC:  DATA 42,53
00EBE:  DATA 59,0D
00EC0:  DATA 0A,00
00EC2:  DATA 40,52
00EC4:  DATA 44,59
00EC6:  DATA 0D,0A
00EC8:  DATA 00,00
*
00F0A:  DATA 40,5B
00F0C:  DATA 4F,5D
00F0E:  DATA 0D,0A
00F10:  DATA 00,00
00F12:  DATA 40,43
00F14:  DATA 4D,44
00F16:  DATA 20,74
00F18:  DATA 6F,6F
00F1A:  DATA 20,6C
00F1C:  DATA 6F,6E
00F1E:  DATA 67,0D
00F20:  DATA 0A,00
00F22:  DATA 40,5B
00F24:  DATA 43,5D
00F26:  DATA 0D,0A
00F28:  DATA 00,00
00F2A:  DATA 40,53
00F2C:  DATA 4C,45
00F2E:  DATA 45,50
00F30:  DATA 0D,0A
00F32:  DATA 00,00
00F34:  DATA 40,4D
00F36:  DATA 45,52
00F38:  DATA 2C,25
00F3A:  DATA 4C,75
00F3C:  DATA 2C,25
00F3E:  DATA 4C,75
00F40:  DATA 0D,0A
00F42:  DATA 00,00
00F44:  DATA 6D,3A
00F46:  DATA 25,75
00F48:  DATA 2C,25
00F4A:  DATA 75,20
00F4C:  DATA 63,3A
00F4E:  DATA 25,4C
00F50:  DATA 75,2C
00F52:  DATA 25,4C
00F54:  DATA 75,2C
00F56:  DATA 25,4C
00F58:  DATA 75,0D
00F5A:  DATA 0A,00
00F5C:  MOVLB  A
00F5E:  MOVF   x1B,W
00F60:  CLRF   01
00F62:  SUBWF  x1A,W
00F64:  BC    0F6C
00F66:  MOVFF  A1A,00
00F6A:  BRA    0F84
00F6C:  CLRF   00
00F6E:  MOVLW  08
00F70:  MOVWF  x1C
00F72:  RLCF   x1A,F
00F74:  RLCF   00,F
00F76:  MOVF   x1B,W
00F78:  SUBWF  00,W
00F7A:  BTFSC  FD8.0
00F7C:  MOVWF  00
00F7E:  RLCF   01,F
00F80:  DECFSZ x1C,F
00F82:  BRA    0F72
00F84:  MOVLB  0
00F86:  RETURN 0
00F88:  MOVF   01,W
00F8A:  MOVFF  A18,A1A
00F8E:  MOVLW  64
00F90:  MOVLB  A
00F92:  MOVWF  x1B
00F94:  MOVLB  0
00F96:  RCALL  0F5C
00F98:  MOVFF  00,A18
00F9C:  MOVF   01,W
00F9E:  MOVLW  30
00FA0:  BNZ   0FB2
00FA2:  MOVLB  A
00FA4:  BTFSS  x19.1
00FA6:  BRA    0FC4
00FA8:  BTFSC  x19.3
00FAA:  BRA    0FC4
00FAC:  BTFSC  x19.4
00FAE:  MOVLW  20
00FB0:  BRA    0FBA
00FB2:  MOVLB  A
00FB4:  BCF    x19.3
00FB6:  BCF    x19.4
00FB8:  BSF    x19.0
00FBA:  ADDWF  01,F
00FBC:  MOVF   01,W
00FBE:  BTFSS  F9E.4
00FC0:  BRA    0FBE
00FC2:  MOVWF  FAD
00FC4:  MOVFF  A18,A1A
00FC8:  MOVLW  0A
00FCA:  MOVWF  x1B
00FCC:  MOVLB  0
00FCE:  RCALL  0F5C
00FD0:  MOVFF  00,A18
00FD4:  MOVF   01,W
00FD6:  MOVLW  30
00FD8:  BNZ   0FEA
00FDA:  MOVLB  A
00FDC:  BTFSC  x19.3
00FDE:  BRA    0FF6
00FE0:  BTFSS  x19.0
00FE2:  BRA    0FF6
00FE4:  BTFSC  x19.4
00FE6:  MOVLW  20
00FE8:  MOVLB  0
00FEA:  ADDWF  01,F
00FEC:  MOVF   01,W
00FEE:  BTFSS  F9E.4
00FF0:  BRA    0FEE
00FF2:  MOVWF  FAD
00FF4:  MOVLB  A
00FF6:  MOVLW  30
00FF8:  ADDWF  x18,F
00FFA:  MOVF   x18,W
00FFC:  BTFSS  F9E.4
00FFE:  BRA    0FFC
01000:  MOVWF  FAD
01002:  MOVLB  0
01004:  RETURN 0
01006:  TBLRD*+
01008:  MOVFF  FF6,A19
0100C:  MOVFF  FF7,A1A
01010:  MOVFF  FF8,A1B
01014:  MOVF   FF5,W
01016:  BTFSS  F9E.4
01018:  BRA    1016
0101A:  MOVWF  FAD
0101C:  MOVFF  A19,FF6
01020:  MOVFF  A1A,FF7
01024:  MOVFF  A1B,FF8
01028:  MOVLB  A
0102A:  DECFSZ x18,F
0102C:  BRA    1030
0102E:  BRA    1034
01030:  MOVLB  0
01032:  BRA    1006
01034:  MOVLB  0
01036:  RETURN 0
01038:  BTFSC  FD8.1
0103A:  BRA    1044
0103C:  MOVLW  0A
0103E:  MOVWF  FEA
01040:  MOVLW  2C
01042:  MOVWF  FE9
01044:  CLRF   00
01046:  CLRF   01
01048:  CLRF   02
0104A:  CLRF   03
0104C:  MOVLB  A
0104E:  CLRF   x2C
01050:  CLRF   x2D
01052:  CLRF   x2E
01054:  CLRF   x2F
01056:  MOVF   x2B,W
01058:  IORWF  x2A,W
0105A:  IORWF  x29,W
0105C:  IORWF  x28,W
0105E:  BZ    10B8
01060:  MOVLW  20
01062:  MOVWF  x30
01064:  BCF    FD8.0
01066:  RLCF   x24,F
01068:  RLCF   x25,F
0106A:  RLCF   x26,F
0106C:  RLCF   x27,F
0106E:  RLCF   x2C,F
01070:  RLCF   x2D,F
01072:  RLCF   x2E,F
01074:  RLCF   x2F,F
01076:  MOVF   x2B,W
01078:  SUBWF  x2F,W
0107A:  BNZ   108C
0107C:  MOVF   x2A,W
0107E:  SUBWF  x2E,W
01080:  BNZ   108C
01082:  MOVF   x29,W
01084:  SUBWF  x2D,W
01086:  BNZ   108C
01088:  MOVF   x28,W
0108A:  SUBWF  x2C,W
0108C:  BNC   10AC
0108E:  MOVF   x28,W
01090:  SUBWF  x2C,F
01092:  MOVF   x29,W
01094:  BTFSS  FD8.0
01096:  INCFSZ x29,W
01098:  SUBWF  x2D,F
0109A:  MOVF   x2A,W
0109C:  BTFSS  FD8.0
0109E:  INCFSZ x2A,W
010A0:  SUBWF  x2E,F
010A2:  MOVF   x2B,W
010A4:  BTFSS  FD8.0
010A6:  INCFSZ x2B,W
010A8:  SUBWF  x2F,F
010AA:  BSF    FD8.0
010AC:  RLCF   00,F
010AE:  RLCF   01,F
010B0:  RLCF   02,F
010B2:  RLCF   03,F
010B4:  DECFSZ x30,F
010B6:  BRA    1064
010B8:  MOVFF  A2C,FEF
010BC:  MOVFF  A2D,FEC
010C0:  MOVFF  A2E,FEC
010C4:  MOVFF  A2F,FEC
010C8:  MOVLB  0
010CA:  RETURN 0
010CC:  MOVF   FE9,W
010CE:  MOVLB  A
010D0:  MOVWF  x1C
010D2:  MOVLW  3B
010D4:  MOVWF  x23
010D6:  MOVLW  9A
010D8:  MOVWF  x22
010DA:  MOVLW  CA
010DC:  MOVWF  x21
010DE:  CLRF   x20
010E0:  MOVLW  0A
010E2:  MOVWF  x1E
010E4:  BSF    FD8.1
010E6:  MOVLW  0A
010E8:  MOVWF  FEA
010EA:  MOVLW  18
010EC:  MOVWF  FE9
010EE:  MOVFF  A1B,A27
010F2:  MOVFF  A1A,A26
010F6:  MOVFF  A19,A25
010FA:  MOVFF  A18,A24
010FE:  MOVFF  A23,A2B
01102:  MOVFF  A22,A2A
01106:  MOVFF  A21,A29
0110A:  MOVFF  A20,A28
0110E:  MOVLB  0
01110:  RCALL  1038
01112:  MOVF   01,W
01114:  MOVF   00,F
01116:  BNZ   113E
01118:  MOVLB  A
0111A:  MOVF   x1E,W
0111C:  XORLW  01
0111E:  BTFSS  FD8.2
01120:  BRA    1126
01122:  MOVLB  0
01124:  BRA    113E
01126:  MOVF   x1C,W
01128:  BZ    1142
0112A:  ANDLW  0F
0112C:  SUBWF  x1E,W
0112E:  BZ    1132
01130:  BC    114E
01132:  BTFSC  x1C.7
01134:  BRA    114E
01136:  BTFSC  x1C.6
01138:  BRA    1142
0113A:  MOVLW  20
0113C:  BRA    1144
0113E:  MOVLB  A
01140:  CLRF   x1C
01142:  MOVLW  30
01144:  ADDWF  00,F
01146:  MOVF   00,W
01148:  BTFSS  F9E.4
0114A:  BRA    1148
0114C:  MOVWF  FAD
0114E:  BCF    FD8.1
01150:  MOVFF  A23,A27
01154:  MOVFF  A22,A26
01158:  MOVFF  A21,A25
0115C:  MOVFF  A20,A24
01160:  CLRF   x2B
01162:  CLRF   x2A
01164:  CLRF   x29
01166:  MOVLW  0A
01168:  MOVWF  x28
0116A:  MOVLB  0
0116C:  RCALL  1038
0116E:  MOVFF  03,A23
01172:  MOVFF  02,A22
01176:  MOVFF  01,A21
0117A:  MOVFF  00,A20
0117E:  MOVLB  A
01180:  DECFSZ x1E,F
01182:  BRA    10E4
01184:  MOVLB  0
01186:  RETURN 0
01188:  MOVFF  FEA,A20
0118C:  MOVFF  FE9,A1F
01190:  MOVLB  A
01192:  SWAPF  x19,W
01194:  IORLW  F0
01196:  MOVWF  x1B
01198:  ADDWF  x1B,F
0119A:  ADDLW  E2
0119C:  MOVWF  x1C
0119E:  ADDLW  32
011A0:  MOVWF  x1E
011A2:  MOVF   x19,W
011A4:  ANDLW  0F
011A6:  ADDWF  x1C,F
011A8:  ADDWF  x1C,F
011AA:  ADDWF  x1E,F
011AC:  ADDLW  E9
011AE:  MOVWF  x1D
011B0:  ADDWF  x1D,F
011B2:  ADDWF  x1D,F
011B4:  SWAPF  x18,W
011B6:  ANDLW  0F
011B8:  ADDWF  x1D,F
011BA:  ADDWF  x1E,F
011BC:  RLCF   x1D,F
011BE:  RLCF   x1E,F
011C0:  COMF   x1E,F
011C2:  RLCF   x1E,F
011C4:  MOVF   x18,W
011C6:  ANDLW  0F
011C8:  ADDWF  x1E,F
011CA:  RLCF   x1B,F
011CC:  MOVLW  07
011CE:  MOVWF  x1A
011D0:  MOVLW  0A
011D2:  DECF   x1D,F
011D4:  ADDWF  x1E,F
011D6:  BNC   11D2
011D8:  DECF   x1C,F
011DA:  ADDWF  x1D,F
011DC:  BNC   11D8
011DE:  DECF   x1B,F
011E0:  ADDWF  x1C,F
011E2:  BNC   11DE
011E4:  DECF   x1A,F
011E6:  ADDWF  x1B,F
011E8:  BNC   11E4
011EA:  MOVLW  0A
011EC:  MOVWF  FEA
011EE:  MOVLW  1A
011F0:  MOVWF  FE9
011F2:  MOVLW  07
011F4:  ANDWF  x1F,W
011F6:  BCF    x1F.6
011F8:  ADDWF  FE9,F
011FA:  MOVLW  00
011FC:  ADDWFC FEA,F
011FE:  MOVF   FE9,W
01200:  SUBLW  1E
01202:  BNZ   120C
01204:  MOVF   FEA,W
01206:  SUBLW  0A
01208:  BNZ   120C
0120A:  BSF    x1F.6
0120C:  MOVF   FEF,W
0120E:  MOVWF  00
01210:  BNZ   1222
01212:  BTFSC  x1F.6
01214:  BRA    1222
01216:  BTFSC  x1F.4
01218:  BRA    1232
0121A:  BTFSC  x1F.3
0121C:  BRA    1222
0121E:  MOVLW  20
01220:  BRA    1228
01222:  BSF    x1F.3
01224:  BCF    x1F.4
01226:  MOVLW  30
01228:  ADDWF  00,F
0122A:  MOVF   00,W
0122C:  BTFSS  F9E.4
0122E:  BRA    122C
01230:  MOVWF  FAD
01232:  MOVF   FEE,W
01234:  BTFSS  x1F.6
01236:  BRA    11FE
01238:  MOVLB  0
0123A:  RETURN 0
*
01A40:  DATA 40,4C
01A42:  DATA 50,43
01A44:  DATA 2C,25
01A46:  DATA 4C,75
01A48:  DATA 2C,25
01A4A:  DATA 4C,64
01A4C:  DATA 0D,0A
01A4E:  DATA 00,00
01A50:  DATA 40,4D
01A52:  DATA 4D,45
01A54:  DATA 2C,25
01A56:  DATA 75,2C
01A58:  DATA 25,4C
01A5A:  DATA 64,2C
01A5C:  DATA 25,4C
01A5E:  DATA 75,2C
01A60:  DATA 25,4C
01A62:  DATA 75,2C
01A64:  DATA 25,4C
01A66:  DATA 64,2C
01A68:  DATA 25,4C
01A6A:  DATA 64,0D
01A6C:  DATA 0A,00
01A6E:  DATA 56,41
01A70:  DATA 4C,56
01A72:  DATA 45,20
01A74:  DATA 53,54
01A76:  DATA 4F,50
01A78:  DATA 20,25
01A7A:  DATA 4C,75
01A7C:  DATA 2C,25
01A7E:  DATA 4C,75
01A80:  DATA 0D,0A
01A82:  DATA 00,00
01A84:  DATA 69,6E
01A86:  DATA 64,3A
01A88:  DATA 25,75
01A8A:  DATA 20,2F
01A8C:  DATA 20,70
01A8E:  DATA 68,61
01A90:  DATA 3A,25
01A92:  DATA 75,0D
01A94:  DATA 0A,00
01A96:  DATA 40,52
01A98:  DATA 45,43
01A9A:  DATA 20,2D
01A9C:  DATA 20,68
01A9E:  DATA 6F,6D
01AA0:  DATA 69,6E
01AA2:  DATA 67,20
01AA4:  DATA 73,79
01AA6:  DATA 72,69
01AA8:  DATA 6E,67
01AAA:  DATA 65,20
01AAC:  DATA 61,6E
01AAE:  DATA 64,20
01AB0:  DATA 61,6C
01AB2:  DATA 69,67
01AB4:  DATA 6E,69
01AB6:  DATA 6E,67
01AB8:  DATA 20,76
01ABA:  DATA 61,6C
01ABC:  DATA 76,65
01ABE:  DATA 20,74
01AC0:  DATA 6F,20
01AC2:  DATA 70,6F
01AC4:  DATA 72,74
01AC6:  DATA 20,31
01AC8:  DATA 0D,0A
01ACA:  DATA 00,00
01ACC:  DATA 2C,73
01ACE:  DATA 65,72
01AD0:  DATA 69,61
01AD2:  DATA 6C,20
01AD4:  DATA 77,61
01AD6:  DATA 6B,65
01AD8:  DATA 2D,75
01ADA:  DATA 70,2C
01ADC:  DATA 53,44
01ADE:  DATA 20,69
01AE0:  DATA 6E,69
01AE2:  DATA 74,69
01AE4:  DATA 61,6C
01AE6:  DATA 69,7A
01AE8:  DATA 65,64
01AEA:  DATA 0D,0A
01AEC:  DATA 00,00
01AEE:  DATA 40,52
01AF0:  DATA 53,54
01AF2:  DATA 0D,0A
01AF4:  DATA 00,00
01AF6:  DATA 40,57
01AF8:  DATA 44,54
01AFA:  DATA 0D,0A
01AFC:  DATA 00,00
01AFE:  DATA 2C,72
01B00:  DATA 65,73
01B02:  DATA 74,61
01B04:  DATA 72,74
01B06:  DATA 20,63
01B08:  DATA 61,75
01B0A:  DATA 73,65
01B0C:  DATA 2C,57
01B0E:  DATA 44,20
01B10:  DATA 74,69
01B12:  DATA 6D,65
01B14:  DATA 2D,6F
01B16:  DATA 75,74
01B18:  DATA 0D,0A
01B1A:  DATA 00,00
01B1C:  DATA 40,57
01B1E:  DATA 44,53
01B20:  DATA 0D,0A
01B22:  DATA 00,00
01B24:  DATA 2C,72
01B26:  DATA 65,73
01B28:  DATA 74,61
01B2A:  DATA 72,74
01B2C:  DATA 20,63
01B2E:  DATA 61,75
01B30:  DATA 73,65
01B32:  DATA 2C,57
01B34:  DATA 44,20
01B36:  DATA 66,72
01B38:  DATA 6F,6D
01B3A:  DATA 20,73
01B3C:  DATA 6C,65
01B3E:  DATA 65,70
01B40:  DATA 0D,0A
01B42:  DATA 00,00
01B44:  DATA 40,4E
01B46:  DATA 50,55
01B48:  DATA 0D,0A
01B4A:  DATA 00,00
01B4C:  DATA 2C,69
01B4E:  DATA 64,23
01B50:  DATA 5B,25
01B52:  DATA 4C,75
01B54:  DATA 5D,2C
01B56:  DATA 70,6F
01B58:  DATA 77,65
01B5A:  DATA 72,20
01B5C:  DATA 61,70
01B5E:  DATA 70,6C
01B60:  DATA 69,65
01B62:  DATA 64,2C
01B64:  DATA 53,44
01B66:  DATA 20,69
01B68:  DATA 6E,69
01B6A:  DATA 74,69
01B6C:  DATA 61,6C
01B6E:  DATA 69,7A
01B70:  DATA 65,64
01B72:  DATA 0D,0A
01B74:  DATA 00,00
01B76:  DATA 40,52
01B78:  DATA 53,54
01B7A:  DATA 0D,0A
01B7C:  DATA 00,00
01B7E:  DATA 2C,72
01B80:  DATA 65,73
01B82:  DATA 74,61
01B84:  DATA 72,74
01B86:  DATA 20,63
01B88:  DATA 61,75
01B8A:  DATA 73,65
01B8C:  DATA 2C,72
01B8E:  DATA 65,73
01B90:  DATA 65,74
01B92:  DATA 20,69
01B94:  DATA 6E,73
01B96:  DATA 74,72
01B98:  DATA 75,63
01B9A:  DATA 74,69
01B9C:  DATA 6F,6E
01B9E:  DATA 0D,0A
01BA0:  DATA 00,00
01BA2:  DATA 40,42
01BA4:  DATA 4F,52
01BA6:  DATA 0D,0A
01BA8:  DATA 00,00
01BAA:  DATA 2C,72
01BAC:  DATA 65,73
01BAE:  DATA 74,61
01BB0:  DATA 72,74
01BB2:  DATA 20,63
01BB4:  DATA 61,75
01BB6:  DATA 73,65
01BB8:  DATA 2C,62
01BBA:  DATA 72,6F
01BBC:  DATA 77,6E
01BBE:  DATA 2D,6F
01BC0:  DATA 75,74
01BC2:  DATA 0D,0A
01BC4:  DATA 00,00
01BC6:  DATA 40,4D
01BC8:  DATA 52,53
01BCA:  DATA 0D,0A
01BCC:  DATA 00,00
01BCE:  DATA 2C,72
01BD0:  DATA 65,73
01BD2:  DATA 74,61
01BD4:  DATA 72,74
01BD6:  DATA 20,63
01BD8:  DATA 61,75
01BDA:  DATA 73,65
01BDC:  DATA 2C,4D
01BDE:  DATA 43,4C
01BE0:  DATA 52,20
01BE2:  DATA 66,72
01BE4:  DATA 6F,6D
01BE6:  DATA 20,73
01BE8:  DATA 6C,65
01BEA:  DATA 65,70
01BEC:  DATA 0D,0A
01BEE:  DATA 00,00
01BF0:  DATA 40,4D
01BF2:  DATA 52,52
01BF4:  DATA 0D,0A
01BF6:  DATA 00,00
01BF8:  DATA 2C,72
01BFA:  DATA 65,73
01BFC:  DATA 74,61
01BFE:  DATA 72,74
01C00:  DATA 20,63
01C02:  DATA 61,75
01C04:  DATA 73,65
01C06:  DATA 2C,4D
01C08:  DATA 43,4C
01C0A:  DATA 52,20
01C0C:  DATA 77,68
01C0E:  DATA 65,6E
01C10:  DATA 20,72
01C12:  DATA 75,6E
01C14:  DATA 6E,69
01C16:  DATA 6E,67
01C18:  DATA 0D,0A
01C1A:  DATA 00,00
01C1C:  DATA 4E,4F
01C1E:  DATA 33,00
01C20:  DATA 4E,4F
01C22:  DATA 32,00
01C24:  DATA 50,4F
01C26:  DATA 34,00
01C28:  DATA 4E,48
01C2A:  DATA 34,00
01C2C:  DATA 53,69
01C2E:  DATA 4F,00
01C30:  DATA 00,00
01C32:  DATA 40,44
01C34:  DATA 45,54
01C36:  DATA 5B,2F
01C38:  DATA 25,75
01C3A:  DATA 5D,5B
01C3C:  DATA 25,63
01C3E:  DATA 5D,41
01C40:  DATA 52,47
01C42:  DATA 5B,25
01C44:  DATA 4C,75
01C46:  DATA 5D,0D
01C48:  DATA 0A,00
01C4A:  DATA 20,74
01C4C:  DATA 69,6D
01C4E:  DATA 65,2D
01C50:  DATA 6F,75
01C52:  DATA 74,00
01C54:  DATA 20,64
01C56:  DATA 61,74
01C58:  DATA 61,20
01C5A:  DATA 74,6F
01C5C:  DATA 6F,20
01C5E:  DATA 73,68
01C60:  DATA 6F,72
01C62:  DATA 74,00
01C64:  DATA 20,64
01C66:  DATA 61,74
01C68:  DATA 61,20
01C6A:  DATA 74,6F
01C6C:  DATA 6F,20
01C6E:  DATA 6C,6F
01C70:  DATA 6E,67
01C72:  DATA 00,00
01C74:  DATA 2C,64
01C76:  DATA 65,74
01C78:  DATA 65,63
01C7A:  DATA 74,6F
01C7C:  DATA 72,5B
01C7E:  DATA 25,73
01C80:  DATA 5D,2C
01C82:  DATA 6C,65
01C84:  DATA 6E,5B
01C86:  DATA 25,75
01C88:  DATA 5D,00
01C8A:  DATA 40,52
01C8C:  DATA 54,59
01C8E:  DATA 2C,25
01C90:  DATA 75,0D
01C92:  DATA 0A,00
01C94:  DATA 2C,73
01C96:  DATA 74,61
01C98:  DATA 72,74
01C9A:  DATA 20,68
01C9C:  DATA 65,61
01C9E:  DATA 74,69
01CA0:  DATA 6E,67
01CA2:  DATA 2C,74
01CA4:  DATA 61,72
01CA6:  DATA 67,65
01CA8:  DATA 74,5B
01CAA:  DATA 25,4C
01CAC:  DATA 75,5D
01CAE:  DATA 2C,61
01CB0:  DATA 63,74
01CB2:  DATA 75,61
01CB4:  DATA 6C,5B
01CB6:  DATA 25,4C
01CB8:  DATA 75,5D
01CBA:  DATA 2C,72
01CBC:  DATA 65,61
01CBE:  DATA 64,69
01CC0:  DATA 6E,67
01CC2:  DATA 73,5B
01CC4:  DATA 25,4C
01CC6:  DATA 75,5D
01CC8:  DATA 0D,0A
01CCA:  DATA 00,00
01CCC:  DATA 2C,65
01CCE:  DATA 6E,64
01CD0:  DATA 20,68
01CD2:  DATA 65,61
01CD4:  DATA 74,69
01CD6:  DATA 6E,67
01CD8:  DATA 2C,74
01CDA:  DATA 61,72
01CDC:  DATA 67,65
01CDE:  DATA 74,5B
01CE0:  DATA 25,4C
01CE2:  DATA 75,5D
01CE4:  DATA 2C,61
01CE6:  DATA 63,74
01CE8:  DATA 75,61
01CEA:  DATA 6C,5B
01CEC:  DATA 25,4C
01CEE:  DATA 75,5D
01CF0:  DATA 2C,72
01CF2:  DATA 65,61
01CF4:  DATA 64,69
01CF6:  DATA 6E,67
01CF8:  DATA 73,5B
01CFA:  DATA 25,4C
01CFC:  DATA 75,5D
01CFE:  DATA 0D,0A
01D00:  DATA 00,00
01D02:  DATA 4E,4F
01D04:  DATA 33,00
01D06:  DATA 4E,4F
01D08:  DATA 32,00
01D0A:  DATA 50,4F
01D0C:  DATA 34,00
01D0E:  DATA 4E,48
01D10:  DATA 34,00
01D12:  DATA 53,69
01D14:  DATA 4F,00
01D16:  DATA 00,00
01D18:  DATA 40,44
01D1A:  DATA 41,43
01D1C:  DATA 2C,25
01D1E:  DATA 4C,75
01D20:  DATA 2C,25
01D22:  DATA 4C,75
01D24:  DATA 2C,00
01D26:  DATA 40,53
01D28:  DATA 41,52
01D2A:  DATA 2C,31
01D2C:  DATA 2C,25
01D2E:  DATA 4C,75
01D30:  DATA 2C,00
01D32:  DATA 40,56
01D34:  DATA 41,4C
01D36:  DATA 20,00
01D38:  DATA 40,56
01D3A:  DATA 41,4C
01D3C:  DATA 20,00
01D3E:  DATA 40,56
01D40:  DATA 41,4C
01D42:  DATA 20,00
01D44:  DATA 40,56
01D46:  DATA 41,4C
01D48:  DATA 20,00
01D4A:  DATA 40,53
01D4C:  DATA 4F,4C
01D4E:  DATA 5B,2F
01D50:  DATA 31,5D
01D52:  DATA 5B,73
01D54:  DATA 5D,5B
01D56:  DATA 25,4C
01D58:  DATA 75,5D
01D5A:  DATA 0D,0A
01D5C:  DATA 00,00
01D5E:  DATA 2F,31
01D60:  DATA 73,25
01D62:  DATA 4C,75
01D64:  DATA 0D,00
01D66:  DATA 40,53
01D68:  DATA 4F,4C
01D6A:  DATA 5B,2F
01D6C:  DATA 31,5D
01D6E:  DATA 5B,63
01D70:  DATA 5D,5B
01D72:  DATA 25,75
01D74:  DATA 5D,0D
01D76:  DATA 0A,00
01D78:  DATA 2F,31
01D7A:  DATA 63,25
01D7C:  DATA 75,0D
01D7E:  DATA 00,00
01D80:  DATA 2F,31
01D82:  DATA 73,32
01D84:  DATA 35,36
01D86:  DATA 0D,00
01D88:  DATA 28,49
01D8A:  DATA 30,73
01D8C:  DATA 29,2C
01D8E:  DATA 25,4C
01D90:  DATA 75,2C
01D92:  DATA 28,49
01D94:  DATA 31,73
01D96:  DATA 29,2C
01D98:  DATA 25,4C
01D9A:  DATA 75,2C
01D9C:  DATA 28,41
01D9E:  DATA 62,73
01DA0:  DATA 2D,73
01DA2:  DATA 29,2C
01DA4:  DATA 25,31
01DA6:  DATA 2E,34
01DA8:  DATA 67,2C
01DAA:  DATA 28,49
01DAC:  DATA 30,74
01DAE:  DATA 29,2C
01DB0:  DATA 25,4C
01DB2:  DATA 75,2C
01DB4:  DATA 28,49
01DB6:  DATA 31,74
01DB8:  DATA 29,2C
01DBA:  DATA 25,4C
01DBC:  DATA 75,2C
01DBE:  DATA 28,41
01DC0:  DATA 62,73
01DC2:  DATA 2D,74
01DC4:  DATA 29,2C
01DC6:  DATA 25,31
01DC8:  DATA 2E,34
01DCA:  DATA 67,2C
01DCC:  DATA 28,49
01DCE:  DATA 30,72
01DD0:  DATA 29,2C
01DD2:  DATA 25,4C
01DD4:  DATA 75,2C
01DD6:  DATA 28,49
01DD8:  DATA 31,72
01DDA:  DATA 29,2C
01DDC:  DATA 25,4C
01DDE:  DATA 75,2C
01DE0:  DATA 28,41
01DE2:  DATA 62,73
01DE4:  DATA 2D,72
01DE6:  DATA 29,2C
01DE8:  DATA 25,31
01DEA:  DATA 2E,34
01DEC:  DATA 67,00
01DEE:  DATA 40,41
01DF0:  DATA 62,73
01DF2:  DATA 2C,4E
01DF4:  DATA 4F,33
01DF6:  DATA 2C,25
01DF8:  DATA 73,0D
01DFA:  DATA 0A,00
01DFC:  DATA 28,49
01DFE:  DATA 30,73
01E00:  DATA 29,2C
01E02:  DATA 25,4C
01E04:  DATA 75,2C
01E06:  DATA 28,49
01E08:  DATA 31,73
01E0A:  DATA 29,2C
01E0C:  DATA 25,4C
01E0E:  DATA 75,2C
01E10:  DATA 28,41
01E12:  DATA 62,73
01E14:  DATA 2D,73
01E16:  DATA 29,2C
01E18:  DATA 25,31
01E1A:  DATA 2E,34
01E1C:  DATA 67,2C
01E1E:  DATA 28,49
01E20:  DATA 30,74
01E22:  DATA 29,2C
01E24:  DATA 25,4C
01E26:  DATA 75,2C
01E28:  DATA 28,49
01E2A:  DATA 31,74
01E2C:  DATA 29,2C
01E2E:  DATA 25,4C
01E30:  DATA 75,2C
01E32:  DATA 28,41
01E34:  DATA 62,73
01E36:  DATA 2D,74
01E38:  DATA 29,2C
01E3A:  DATA 25,31
01E3C:  DATA 2E,34
01E3E:  DATA 67,2C
01E40:  DATA 28,49
01E42:  DATA 30,72
01E44:  DATA 29,2C
01E46:  DATA 25,4C
01E48:  DATA 75,2C
01E4A:  DATA 28,49
01E4C:  DATA 31,72
01E4E:  DATA 29,2C
01E50:  DATA 25,4C
01E52:  DATA 75,2C
01E54:  DATA 28,41
01E56:  DATA 62,73
01E58:  DATA 2D,72
01E5A:  DATA 29,2C
01E5C:  DATA 25,31
01E5E:  DATA 2E,34
01E60:  DATA 67,00
01E62:  DATA 40,41
01E64:  DATA 62,73
01E66:  DATA 2C,4E
01E68:  DATA 4F,32
01E6A:  DATA 2C,25
01E6C:  DATA 73,0D
01E6E:  DATA 0A,00
01E70:  DATA 28,49
01E72:  DATA 30,73
01E74:  DATA 29,2C
01E76:  DATA 25,4C
01E78:  DATA 75,2C
01E7A:  DATA 28,49
01E7C:  DATA 31,73
01E7E:  DATA 29,2C
01E80:  DATA 25,4C
01E82:  DATA 75,2C
01E84:  DATA 28,41
01E86:  DATA 62,73
01E88:  DATA 2D,73
01E8A:  DATA 29,2C
01E8C:  DATA 25,31
01E8E:  DATA 2E,34
01E90:  DATA 67,2C
01E92:  DATA 28,49
01E94:  DATA 30,74
01E96:  DATA 29,2C
01E98:  DATA 25,4C
01E9A:  DATA 75,2C
01E9C:  DATA 28,49
01E9E:  DATA 31,74
01EA0:  DATA 29,2C
01EA2:  DATA 25,4C
01EA4:  DATA 75,2C
01EA6:  DATA 28,41
01EA8:  DATA 62,73
01EAA:  DATA 2D,74
01EAC:  DATA 29,2C
01EAE:  DATA 25,31
01EB0:  DATA 2E,34
01EB2:  DATA 67,2C
01EB4:  DATA 28,49
01EB6:  DATA 30,72
01EB8:  DATA 29,2C
01EBA:  DATA 25,4C
01EBC:  DATA 75,2C
01EBE:  DATA 28,49
01EC0:  DATA 31,72
01EC2:  DATA 29,2C
01EC4:  DATA 25,4C
01EC6:  DATA 75,2C
01EC8:  DATA 28,41
01ECA:  DATA 62,73
01ECC:  DATA 2D,72
01ECE:  DATA 29,2C
01ED0:  DATA 25,31
01ED2:  DATA 2E,34
01ED4:  DATA 67,00
01ED6:  DATA 40,41
01ED8:  DATA 62,73
01EDA:  DATA 2C,50
01EDC:  DATA 4F,34
01EDE:  DATA 2C,25
01EE0:  DATA 73,0D
01EE2:  DATA 0A,00
01EE4:  DATA 28,49
01EE6:  DATA 30,73
01EE8:  DATA 29,2C
01EEA:  DATA 25,4C
01EEC:  DATA 75,2C
01EEE:  DATA 28,49
01EF0:  DATA 31,73
01EF2:  DATA 29,2C
01EF4:  DATA 25,4C
01EF6:  DATA 75,2C
01EF8:  DATA 28,41
01EFA:  DATA 62,73
01EFC:  DATA 2D,73
01EFE:  DATA 29,2C
01F00:  DATA 25,31
01F02:  DATA 2E,34
01F04:  DATA 67,2C
01F06:  DATA 28,49
01F08:  DATA 30,74
01F0A:  DATA 29,2C
01F0C:  DATA 25,4C
01F0E:  DATA 75,2C
01F10:  DATA 28,49
01F12:  DATA 31,74
01F14:  DATA 29,2C
01F16:  DATA 25,4C
01F18:  DATA 75,2C
01F1A:  DATA 28,41
01F1C:  DATA 62,73
01F1E:  DATA 2D,74
01F20:  DATA 29,2C
01F22:  DATA 25,31
01F24:  DATA 2E,34
01F26:  DATA 67,2C
01F28:  DATA 28,49
01F2A:  DATA 30,72
01F2C:  DATA 29,2C
01F2E:  DATA 25,4C
01F30:  DATA 75,2C
01F32:  DATA 28,49
01F34:  DATA 31,72
01F36:  DATA 29,2C
01F38:  DATA 25,4C
01F3A:  DATA 75,2C
01F3C:  DATA 28,41
01F3E:  DATA 62,73
01F40:  DATA 2D,72
01F42:  DATA 29,2C
01F44:  DATA 25,31
01F46:  DATA 2E,34
01F48:  DATA 67,00
01F4A:  DATA 40,41
01F4C:  DATA 62,73
01F4E:  DATA 2C,4E
01F50:  DATA 48,34
01F52:  DATA 2C,25
01F54:  DATA 73,0D
01F56:  DATA 0A,00
01F58:  DATA 28,49
01F5A:  DATA 30,73
01F5C:  DATA 29,2C
01F5E:  DATA 25,4C
01F60:  DATA 75,2C
01F62:  DATA 28,49
01F64:  DATA 31,73
01F66:  DATA 29,2C
01F68:  DATA 25,4C
01F6A:  DATA 75,2C
01F6C:  DATA 28,41
01F6E:  DATA 62,73
01F70:  DATA 2D,73
01F72:  DATA 29,2C
01F74:  DATA 25,31
01F76:  DATA 2E,34
01F78:  DATA 67,2C
01F7A:  DATA 28,49
01F7C:  DATA 30,74
01F7E:  DATA 29,2C
01F80:  DATA 25,4C
01F82:  DATA 75,2C
01F84:  DATA 28,49
01F86:  DATA 31,74
01F88:  DATA 29,2C
01F8A:  DATA 25,4C
01F8C:  DATA 75,2C
01F8E:  DATA 28,41
01F90:  DATA 62,73
01F92:  DATA 2D,74
01F94:  DATA 29,2C
01F96:  DATA 25,31
01F98:  DATA 2E,34
01F9A:  DATA 67,2C
01F9C:  DATA 28,49
01F9E:  DATA 30,72
01FA0:  DATA 29,2C
01FA2:  DATA 25,4C
01FA4:  DATA 75,2C
01FA6:  DATA 28,49
01FA8:  DATA 31,72
01FAA:  DATA 29,2C
01FAC:  DATA 25,4C
01FAE:  DATA 75,2C
01FB0:  DATA 28,41
01FB2:  DATA 62,73
01FB4:  DATA 2D,72
01FB6:  DATA 29,2C
01FB8:  DATA 25,31
01FBA:  DATA 2E,34
01FBC:  DATA 67,00
01FBE:  DATA 40,41
01FC0:  DATA 42,53
01FC2:  DATA 2C,53
01FC4:  DATA 69,4F
01FC6:  DATA 2C,25
01FC8:  DATA 73,0D
01FCA:  DATA 0A,00
01FCC:  DATA 4E,4F
01FCE:  DATA 33,00
01FD0:  DATA 4E,4F
01FD2:  DATA 32,00
01FD4:  DATA 50,4F
01FD6:  DATA 34,00
01FD8:  DATA 4E,48
01FDA:  DATA 34,00
01FDC:  DATA 53,69
01FDE:  DATA 4F,00
01FE0:  DATA 00,00
01FE2:  DATA 28,6D
01FE4:  DATA 29,2C
01FE6:  DATA 25,33
01FE8:  DATA 2E,33
01FEA:  DATA 67,2C
01FEC:  DATA 28,63
01FEE:  DATA 29,2C
01FF0:  DATA 25,33
01FF2:  DATA 2E,33
01FF4:  DATA 67,00
01FF6:  DATA 28,43
01FF8:  DATA 73,29
01FFA:  DATA 2C,25
01FFC:  DATA 33,2E
01FFE:  DATA 33,67
02000:  DATA 0D,0A
02002:  DATA 00,00
02004:  DATA 40,43
02006:  DATA 4F,4E
02008:  DATA 2C,4E
0200A:  DATA 4F,33
0200C:  DATA 2C,25
0200E:  DATA 73,0D
02010:  DATA 0A,00
02012:  DATA 28,6D
02014:  DATA 29,2C
02016:  DATA 25,33
02018:  DATA 2E,33
0201A:  DATA 67,2C
0201C:  DATA 28,63
0201E:  DATA 29,2C
02020:  DATA 25,33
02022:  DATA 2E,33
02024:  DATA 67,00
02026:  DATA 28,43
02028:  DATA 73,29
0202A:  DATA 2C,25
0202C:  DATA 33,2E
0202E:  DATA 33,67
02030:  DATA 0D,0A
02032:  DATA 00,00
02034:  DATA 40,43
02036:  DATA 4F,4E
02038:  DATA 2C,50
0203A:  DATA 4F,34
0203C:  DATA 2C,25
0203E:  DATA 73,0D
02040:  DATA 0A,00
02042:  DATA 28,6D
02044:  DATA 29,2C
02046:  DATA 25,33
02048:  DATA 2E,33
0204A:  DATA 67,2C
0204C:  DATA 28,63
0204E:  DATA 29,2C
02050:  DATA 25,33
02052:  DATA 2E,33
02054:  DATA 67,00
02056:  DATA 28,43
02058:  DATA 73,29
0205A:  DATA 2C,25
0205C:  DATA 33,2E
0205E:  DATA 33,67
02060:  DATA 0D,0A
02062:  DATA 00,00
02064:  DATA 40,43
02066:  DATA 4F,4E
02068:  DATA 2C,4E
0206A:  DATA 48,34
0206C:  DATA 2C,25
0206E:  DATA 73,0D
02070:  DATA 0A,00
02072:  DATA 28,6D
02074:  DATA 29,2C
02076:  DATA 25,33
02078:  DATA 2E,33
0207A:  DATA 67,2C
0207C:  DATA 28,63
0207E:  DATA 29,2C
02080:  DATA 25,33
02082:  DATA 2E,33
02084:  DATA 67,00
02086:  DATA 28,43
02088:  DATA 73,29
0208A:  DATA 2C,25
0208C:  DATA 33,2E
0208E:  DATA 33,67
02090:  DATA 0D,0A
02092:  DATA 00,00
02094:  DATA 40,43
02096:  DATA 4F,4E
02098:  DATA 2C,53
0209A:  DATA 69,4F
0209C:  DATA 2C,25
0209E:  DATA 73,0D
020A0:  DATA 0A,00
020A2:  DATA 4E,4F
020A4:  DATA 33,00
020A6:  DATA 50,4F
020A8:  DATA 34,00
020AA:  DATA 4E,48
020AC:  DATA 34,00
020AE:  DATA 53,69
020B0:  DATA 4F,00
020B2:  DATA 00,00
020B4:  DATA 4D,45
020B6:  DATA 4D,4F
020B8:  DATA 52,59
020BA:  DATA 20,4F
020BC:  DATA 56,45
020BE:  DATA 52,46
020C0:  DATA 4C,4F
020C2:  DATA 57,20
020C4:  DATA 45,52
020C6:  DATA 52,4F
020C8:  DATA 52,20
020CA:  DATA 40,20
020CC:  DATA 4C,69
020CE:  DATA 6E,65
020D0:  DATA 20,3A
020D2:  DATA 25,4C
020D4:  DATA 75,0A
020D6:  DATA 0D,00
020D8:  DATA 0D,0A
020DA:  DATA 3A,00
020DC:  DATA 0D,0A
020DE:  DATA 57,41
020E0:  DATA 52,4E
020E2:  DATA 49,4E
020E4:  DATA 47,3A
020E6:  DATA 20,49
020E8:  DATA 4E,56
020EA:  DATA 41,4C
020EC:  DATA 49,44
020EE:  DATA 20,43
020F0:  DATA 4F,4D
020F2:  DATA 4D,41
020F4:  DATA 4E,44
020F6:  DATA 20,49
020F8:  DATA 4E,20
020FA:  DATA 4D,41
020FC:  DATA 43,52
020FE:  DATA 4F,21
02100:  DATA 0D,0A
02102:  DATA 00,00
02104:  DATA 42,61
02106:  DATA 64,20
02108:  DATA 63,6F
0210A:  DATA 6D,6D
0210C:  DATA 61,6E
0210E:  DATA 64,20
02110:  DATA 61,74
02112:  DATA 20,6C
02114:  DATA 69,6E
02116:  DATA 65,3A
02118:  DATA 20,25
0211A:  DATA 4C,64
0211C:  DATA 20,0D
0211E:  DATA 0A,00
02120:  DATA 50,6C
02122:  DATA 65,61
02124:  DATA 73,65
02126:  DATA 20,72
02128:  DATA 65,2D
0212A:  DATA 75,70
0212C:  DATA 6C,6F
0212E:  DATA 61,64
02130:  DATA 20,6D
02132:  DATA 61,63
02134:  DATA 72,6F
02136:  DATA 00,00
02138:  DATA 49,74
0213A:  DATA 65,72
0213C:  DATA 61,74
0213E:  DATA 69,6F
02140:  DATA 6E,73
02142:  DATA 20,6C
02144:  DATA 65,66
02146:  DATA 74,3A
02148:  DATA 20,25
0214A:  DATA 4C,75
0214C:  DATA 0D,0A
0214E:  DATA 00,00
02150:  DATA 2C,6D
02152:  DATA 61,63
02154:  DATA 72,6F
02156:  DATA 5B,25
02158:  DATA 75,5D
0215A:  DATA 2C,73
0215C:  DATA 74,61
0215E:  DATA 72,74
02160:  DATA 0D,0A
02162:  DATA 00,00
02164:  DATA 40,4D
02166:  DATA 43,4C
02168:  DATA 5B,25
0216A:  DATA 63,5D
0216C:  DATA 5B,25
0216E:  DATA 4C,75
02170:  DATA 5D,0D
02172:  DATA 0A,00
02174:  DATA 40,4C
02176:  DATA 4E,45
02178:  DATA 0D,0A
0217A:  DATA 00,00
0217C:  DATA 40,52
0217E:  DATA 55,4E
02180:  DATA 0D,0A
02182:  DATA 00,00
02184:  DATA 40,42
02186:  DATA 41,44
02188:  DATA 0D,0A
0218A:  DATA 00,00
0218C:  DATA 40,54
0218E:  DATA 2F,4F
02190:  DATA 0D,0A
02192:  DATA 00,00
02194:  DATA 40,45
02196:  DATA 52,52
02198:  DATA 0D,0A
0219A:  DATA 00,00
0219C:  DATA 40,45
0219E:  DATA 4E,44
021A0:  DATA 0D,0A
021A2:  DATA 00,00
021A4:  DATA 40,48
021A6:  DATA 4C,54
021A8:  DATA 0D,0A
021AA:  DATA 00,00
021AC:  DATA 2C,6D
021AE:  DATA 61,63
021B0:  DATA 72,6F
021B2:  DATA 5B,25
021B4:  DATA 75,5D
021B6:  DATA 2C,73
021B8:  DATA 74,61
021BA:  DATA 74,75
021BC:  DATA 73,5B
021BE:  DATA 25,63
021C0:  DATA 5D,2C
021C2:  DATA 6C,69
021C4:  DATA 6E,65
021C6:  DATA 5B,25
021C8:  DATA 4C,75
021CA:  DATA 5D,0D
021CC:  DATA 0A,00
021CE:  DATA 40,52
021D0:  DATA 75,6E
021D2:  DATA 6E,69
021D4:  DATA 6E,67
021D6:  DATA 20,25
021D8:  DATA 63,25
021DA:  DATA 4C,75
021DC:  DATA 20,0D
021DE:  DATA 0A,00
021E0:  DATA 40,4D
021E2:  DATA 61,63
021E4:  DATA 72,6F
021E6:  DATA 20,25
021E8:  DATA 30,34
021EA:  DATA 4C,75
021EC:  DATA 20,6F
021EE:  DATA 66,20
021F0:  DATA 25,30
021F2:  DATA 34,4C
021F4:  DATA 75,0D
021F6:  DATA 0A,00
021F8:  DATA 40,4C
021FA:  DATA 4E,45
021FC:  DATA 0D,0A
021FE:  DATA 00,00
02200:  DATA 40,52
02202:  DATA 55,4E
02204:  DATA 0D,0A
02206:  DATA 00,00
02208:  DATA 40,42
0220A:  DATA 41,44
0220C:  DATA 0D,0A
0220E:  DATA 00,00
02210:  DATA 40,54
02212:  DATA 2F,4F
02214:  DATA 0D,0A
02216:  DATA 00,00
02218:  DATA 40,45
0221A:  DATA 52,52
0221C:  DATA 0D,0A
0221E:  DATA 00,00
02220:  DATA 40,45
02222:  DATA 4E,44
02224:  DATA 0D,0A
02226:  DATA 00,00
02228:  DATA 2C,61
0222A:  DATA 75,74
0222C:  DATA 6F,2D
0222E:  DATA 73,61
02230:  DATA 6D,70
02232:  DATA 6C,65
02234:  DATA 2C,73
02236:  DATA 61,6D
02238:  DATA 70,6C
0223A:  DATA 65,5B
0223C:  DATA 25,4C
0223E:  DATA 75,5D
02240:  DATA 2C,73
02242:  DATA 74,61
02244:  DATA 72,74
02246:  DATA 0D,0A
02248:  DATA 00,00
0224A:  DATA 2C,61
0224C:  DATA 75,74
0224E:  DATA 6F,2D
02250:  DATA 73,61
02252:  DATA 6D,70
02254:  DATA 6C,65
02256:  DATA 2C,73
02258:  DATA 61,6D
0225A:  DATA 70,6C
0225C:  DATA 65,5B
0225E:  DATA 25,4C
02260:  DATA 75,5D
02262:  DATA 2C,63
02264:  DATA 6F,6D
02266:  DATA 70,6C
02268:  DATA 65,74
0226A:  DATA 65,0D
0226C:  DATA 0A,00
0226E:  DATA 2C,61
02270:  DATA 75,74
02272:  DATA 6F,2D
02274:  DATA 73,61
02276:  DATA 6D,70
02278:  DATA 6C,65
0227A:  DATA 2C,73
0227C:  DATA 61,6D
0227E:  DATA 70,6C
02280:  DATA 65,5B
02282:  DATA 25,4C
02284:  DATA 75,5D
02286:  DATA 2C,65
02288:  DATA 72,72
0228A:  DATA 6F,72
0228C:  DATA 0D,0A
0228E:  DATA 00,00
02290:  DATA 2C,61
02292:  DATA 75,74
02294:  DATA 6F,2D
02296:  DATA 73,61
02298:  DATA 6D,70
0229A:  DATA 6C,65
0229C:  DATA 2C,73
0229E:  DATA 61,6D
022A0:  DATA 70,6C
022A2:  DATA 65,5B
022A4:  DATA 25,4C
022A6:  DATA 75,5D
022A8:  DATA 2C,6D
022AA:  DATA 61,78
022AC:  DATA 20,73
022AE:  DATA 61,6D
022B0:  DATA 70,6C
022B2:  DATA 65,73
022B4:  DATA 0D,0A
022B6:  DATA 00,00
022B8:  DATA 2C,61
022BA:  DATA 75,74
022BC:  DATA 6F,2D
022BE:  DATA 73,61
022C0:  DATA 6D,70
022C2:  DATA 6C,65
022C4:  DATA 2C,73
022C6:  DATA 61,6D
022C8:  DATA 70,6C
022CA:  DATA 65,5B
022CC:  DATA 25,4C
022CE:  DATA 75,5D
022D0:  DATA 2C,73
022D2:  DATA 74,61
022D4:  DATA 72,74
022D6:  DATA 0D,0A
022D8:  DATA 00,00
022DA:  DATA 2C,61
022DC:  DATA 75,74
022DE:  DATA 6F,2D
022E0:  DATA 73,61
022E2:  DATA 6D,70
022E4:  DATA 6C,65
022E6:  DATA 2C,73
022E8:  DATA 61,6D
022EA:  DATA 70,6C
022EC:  DATA 65,5B
022EE:  DATA 25,4C
022F0:  DATA 75,5D
022F2:  DATA 2C,63
022F4:  DATA 6F,6D
022F6:  DATA 70,6C
022F8:  DATA 65,74
022FA:  DATA 65,0D
022FC:  DATA 0A,00
022FE:  DATA 2C,61
02300:  DATA 75,74
02302:  DATA 6F,2D
02304:  DATA 73,61
02306:  DATA 6D,70
02308:  DATA 6C,65
0230A:  DATA 2C,73
0230C:  DATA 61,6D
0230E:  DATA 70,6C
02310:  DATA 65,5B
02312:  DATA 25,4C
02314:  DATA 75,5D
02316:  DATA 2C,73
02318:  DATA 74,61
0231A:  DATA 72,74
0231C:  DATA 0D,0A
0231E:  DATA 00,00
02320:  DATA 2C,61
02322:  DATA 75,74
02324:  DATA 6F,2D
02326:  DATA 73,61
02328:  DATA 6D,70
0232A:  DATA 6C,65
0232C:  DATA 2C,73
0232E:  DATA 61,6D
02330:  DATA 70,6C
02332:  DATA 65,5B
02334:  DATA 25,4C
02336:  DATA 75,5D
02338:  DATA 2C,63
0233A:  DATA 6F,6D
0233C:  DATA 70,6C
0233E:  DATA 65,74
02340:  DATA 65,0D
02342:  DATA 0A,00
02344:  DATA 2C,61
02346:  DATA 75,74
02348:  DATA 6F,2D
0234A:  DATA 73,61
0234C:  DATA 6D,70
0234E:  DATA 6C,65
02350:  DATA 2C,73
02352:  DATA 61,6D
02354:  DATA 70,6C
02356:  DATA 65,5B
02358:  DATA 25,4C
0235A:  DATA 75,5D
0235C:  DATA 2C,6D
0235E:  DATA 61,78
02360:  DATA 20,73
02362:  DATA 61,6D
02364:  DATA 70,6C
02366:  DATA 65,73
02368:  DATA 0D,0A
0236A:  DATA 00,00
0236C:  DATA 2C,61
0236E:  DATA 75,74
02370:  DATA 6F,2D
02372:  DATA 73,61
02374:  DATA 6D,70
02376:  DATA 6C,65
02378:  DATA 2C,69
0237A:  DATA 6E,69
0237C:  DATA 74,69
0237E:  DATA 61,6C
02380:  DATA 69,7A
02382:  DATA 65,0D
02384:  DATA 0A,00
02386:  DATA 2C,68
02388:  DATA 65,61
0238A:  DATA 64,65
0238C:  DATA 72,2C
0238E:  DATA 69,64
02390:  DATA 23,5B
02392:  DATA 25,4C
02394:  DATA 75,5D
02396:  DATA 2C,69
02398:  DATA 6E,74
0239A:  DATA 5B,25
0239C:  DATA 4C,75
0239E:  DATA 5D,2C
023A0:  DATA 6D,61
023A2:  DATA 78,5B
023A4:  DATA 25,4C
023A6:  DATA 75,5D
023A8:  DATA 0D,0A
023AA:  DATA 00,00
023AC:  DATA 2C,61
023AE:  DATA 75,74
023B0:  DATA 6F,2D
023B2:  DATA 73,61
023B4:  DATA 6D,70
023B6:  DATA 6C,65
023B8:  DATA 2C,73
023BA:  DATA 61,6D
023BC:  DATA 70,6C
023BE:  DATA 65,5B
023C0:  DATA 25,4C
023C2:  DATA 75,5D
023C4:  DATA 2C,61
023C6:  DATA 6C,61
023C8:  DATA 72,6D
023CA:  DATA 5B,25
023CC:  DATA 75,5D
023CE:  DATA 0D,0A
023D0:  DATA 00,00
023D2:  DATA 2C,61
023D4:  DATA 75,74
023D6:  DATA 6F,2D
023D8:  DATA 73,61
023DA:  DATA 6D,70
023DC:  DATA 6C,65
023DE:  DATA 2C,73
023E0:  DATA 6C,65
023E2:  DATA 65,70
023E4:  DATA 0D,0A
023E6:  DATA 00,00
023E8:  DATA 74,31
023EA:  DATA 3A,25
023EC:  DATA 4C,75
023EE:  DATA 20,74
023F0:  DATA 32,3A
023F2:  DATA 25,4C
023F4:  DATA 75,0D
023F6:  DATA 0A,00
023F8:  DATA 40,44
023FA:  DATA 45,54
023FC:  DATA 2C,25
023FE:  DATA 4C,75
02400:  DATA 0D,0A
02402:  DATA 00,00
02404:  DATA 4E,4F
02406:  DATA 33,2C
02408:  DATA 25,31
0240A:  DATA 2E,35
0240C:  DATA 67,2C
0240E:  DATA 25,31
02410:  DATA 2E,35
02412:  DATA 67,0D
02414:  DATA 0A,00
02416:  DATA 50,4F
02418:  DATA 34,2C
0241A:  DATA 25,31
0241C:  DATA 2E,35
0241E:  DATA 67,2C
02420:  DATA 25,31
02422:  DATA 2E,35
02424:  DATA 67,0D
02426:  DATA 0A,00
02428:  DATA 4E,48
0242A:  DATA 34,2C
0242C:  DATA 25,31
0242E:  DATA 2E,35
02430:  DATA 67,2C
02432:  DATA 25,31
02434:  DATA 2E,35
02436:  DATA 67,0D
02438:  DATA 0A,00
0243A:  DATA 53,69
0243C:  DATA 4F,34
0243E:  DATA 2C,25
02440:  DATA 31,2E
02442:  DATA 35,67
02444:  DATA 2C,25
02446:  DATA 31,2E
02448:  DATA 35,67
0244A:  DATA 0D,0A
0244C:  DATA 00,00
0244E:  DATA 4E,4F
02450:  DATA 33,28
02452:  DATA 6D,29
02454:  DATA 3A,00
02456:  DATA 4E,4F
02458:  DATA 33,28
0245A:  DATA 63,29
0245C:  DATA 3A,00
0245E:  DATA 50,4F
02460:  DATA 34,28
02462:  DATA 6D,29
02464:  DATA 3A,00
02466:  DATA 50,4F
02468:  DATA 34,28
0246A:  DATA 63,29
0246C:  DATA 3A,00
0246E:  DATA 4E,48
02470:  DATA 34,28
02472:  DATA 6D,29
02474:  DATA 3A,00
02476:  DATA 4E,48
02478:  DATA 34,28
0247A:  DATA 63,29
0247C:  DATA 3A,00
0247E:  DATA 53,69
02480:  DATA 4F,34
02482:  DATA 28,6D
02484:  DATA 29,3A
02486:  DATA 00,00
02488:  DATA 53,69
0248A:  DATA 4F,34
0248C:  DATA 28,63
0248E:  DATA 29,3A
02490:  DATA 00,00
02492:  DATA 41,72
02494:  DATA 65,20
02496:  DATA 79,6F
02498:  DATA 75,20
0249A:  DATA 73,75
0249C:  DATA 72,65
0249E:  DATA 20,79
024A0:  DATA 6F,75
024A2:  DATA 20,77
024A4:  DATA 61,6E
024A6:  DATA 74,20
024A8:  DATA 74,6F
024AA:  DATA 20,65
024AC:  DATA 72,61
024AE:  DATA 73,65
024B0:  DATA 20,74
024B2:  DATA 68,65
024B4:  DATA 20,72
024B6:  DATA 61,77
024B8:  DATA 20,64
024BA:  DATA 61,74
024BC:  DATA 61,20
024BE:  DATA 66,69
024C0:  DATA 6C,65
024C2:  DATA 3F,20
024C4:  DATA 59,20
024C6:  DATA 6F,72
024C8:  DATA 20,4E
024CA:  DATA 21,0D
024CC:  DATA 0A,00
024CE:  DATA 46,69
024D0:  DATA 6C,65
024D2:  DATA 20,64
024D4:  DATA 65,6C
024D6:  DATA 65,74
024D8:  DATA 65,64
024DA:  DATA 21,0A
024DC:  DATA 0D,00
024DE:  DATA 4F,70
024E0:  DATA 65,72
024E2:  DATA 61,74
024E4:  DATA 69,6F
024E6:  DATA 6E,20
024E8:  DATA 63,61
024EA:  DATA 6E,63
024EC:  DATA 65,6C
024EE:  DATA 65,64
024F0:  DATA 21,0D
024F2:  DATA 0A,00
024F4:  DATA 41,72
024F6:  DATA 65,20
024F8:  DATA 79,6F
024FA:  DATA 75,20
024FC:  DATA 73,75
024FE:  DATA 72,65
02500:  DATA 20,79
02502:  DATA 6F,75
02504:  DATA 20,77
02506:  DATA 61,6E
02508:  DATA 74,20
0250A:  DATA 74,6F
0250C:  DATA 20,65
0250E:  DATA 72,61
02510:  DATA 73,65
02512:  DATA 20,74
02514:  DATA 68,65
02516:  DATA 20,63
02518:  DATA 61,6C
0251A:  DATA 63,75
0251C:  DATA 6C,61
0251E:  DATA 74,65
02520:  DATA 64,20
02522:  DATA 64,61
02524:  DATA 74,61
02526:  DATA 20,66
02528:  DATA 69,6C
0252A:  DATA 65,3F
0252C:  DATA 20,59
0252E:  DATA 20,6F
02530:  DATA 72,20
02532:  DATA 4E,21
02534:  DATA 0D,0A
02536:  DATA 00,00
02538:  DATA 46,69
0253A:  DATA 6C,65
0253C:  DATA 20,64
0253E:  DATA 65,6C
02540:  DATA 65,74
02542:  DATA 65,64
02544:  DATA 21,0A
02546:  DATA 0D,00
02548:  DATA 4F,70
0254A:  DATA 65,72
0254C:  DATA 61,74
0254E:  DATA 69,6F
02550:  DATA 6E,20
02552:  DATA 63,61
02554:  DATA 6E,63
02556:  DATA 65,6C
02558:  DATA 65,64
0255A:  DATA 21,0D
0255C:  DATA 0A,00
0255E:  DATA 40,49
02560:  DATA 44,23
02562:  DATA 25,4C
02564:  DATA 75,20
02566:  DATA 49,25
02568:  DATA 4C,75
0256A:  DATA 20,4E
0256C:  DATA 25,4C
0256E:  DATA 75,2F
02570:  DATA 25,4C
02572:  DATA 75,20
02574:  DATA 58,25
02576:  DATA 4C,75
02578:  DATA 20,55
0257A:  DATA 25,75
0257C:  DATA 20,25
0257E:  DATA 34,2E
02580:  DATA 32,77
02582:  DATA 56,0D
02584:  DATA 0A,00
02586:  DATA 40,4D
02588:  DATA 4F,54
0258A:  DATA 3A,56
0258C:  DATA 41,4C
0258E:  DATA 3D,25
02590:  DATA 4C,75
02592:  DATA 20,53
02594:  DATA 59,52
02596:  DATA 3D,25
02598:  DATA 4C,64
0259A:  DATA 0D,0A
0259C:  DATA 00,00
0259E:  DATA 40,50
025A0:  DATA 57,52
025A2:  DATA 3A,25
025A4:  DATA 30,32
025A6:  DATA 75,2F
025A8:  DATA 25,30
025AA:  DATA 32,75
025AC:  DATA 2F,25
025AE:  DATA 30,32
025B0:  DATA 75,20
025B2:  DATA 25,30
025B4:  DATA 32,75
025B6:  DATA 3A,25
025B8:  DATA 30,32
025BA:  DATA 75,3A
025BC:  DATA 25,30
025BE:  DATA 32,75
025C0:  DATA 0D,0A
025C2:  DATA 00,00
025C4:  DATA 40,50
025C6:  DATA 57,52
025C8:  DATA 3A,25
025CA:  DATA 30,32
025CC:  DATA 75,2F
025CE:  DATA 25,30
025D0:  DATA 32,75
025D2:  DATA 2F,25
025D4:  DATA 30,32
025D6:  DATA 75,20
025D8:  DATA 25,30
025DA:  DATA 32,75
025DC:  DATA 3A,25
025DE:  DATA 30,32
025E0:  DATA 75,3A
025E2:  DATA 25,30
025E4:  DATA 32,75
025E6:  DATA 0D,0A
025E8:  DATA 00,00
025EA:  DATA 41,25
025EC:  DATA 4C,75
025EE:  DATA 20,49
025F0:  DATA 25,4C
025F2:  DATA 75,20
025F4:  DATA 4C,25
025F6:  DATA 4C,75
025F8:  DATA 20,51
025FA:  DATA 25,4C
025FC:  DATA 75,20
025FE:  DATA 53,25
02600:  DATA 4C,75
02602:  DATA 20,25
02604:  DATA 34,2E
02606:  DATA 32,77
02608:  DATA 56,0D
0260A:  DATA 0A,00
0260C:  DATA 40,4D
0260E:  DATA 4F,54
02610:  DATA 3A,56
02612:  DATA 41,4C
02614:  DATA 3D,25
02616:  DATA 4C,75
02618:  DATA 20,53
0261A:  DATA 59,52
0261C:  DATA 3D,25
0261E:  DATA 4C,64
02620:  DATA 0D,0A
02622:  DATA 00,00
02624:  DATA 40,50
02626:  DATA 57,52
02628:  DATA 3A,25
0262A:  DATA 30,32
0262C:  DATA 75,2F
0262E:  DATA 25,30
02630:  DATA 32,75
02632:  DATA 2F,25
02634:  DATA 30,32
02636:  DATA 75,20
02638:  DATA 25,30
0263A:  DATA 32,75
0263C:  DATA 3A,25
0263E:  DATA 30,32
02640:  DATA 75,3A
02642:  DATA 25,30
02644:  DATA 32,75
02646:  DATA 0D,0A
02648:  DATA 00,00
0264A:  DATA 49,25
0264C:  DATA 4C,75
0264E:  DATA 20,4E
02650:  DATA 25,4C
02652:  DATA 75,2F
02654:  DATA 25,4C
02656:  DATA 75,20
02658:  DATA 50,25
0265A:  DATA 4C,75
0265C:  DATA 20,25
0265E:  DATA 34,2E
02660:  DATA 32,77
02662:  DATA 56,0D
02664:  DATA 0A,00
02666:  DATA 40,4D
02668:  DATA 4F,54
0266A:  DATA 3A,53
0266C:  DATA 59,52
0266E:  DATA 3D,25
02670:  DATA 4C,64
02672:  DATA 0D,0A
02674:  DATA 00,00
02676:  DATA 40,50
02678:  DATA 57,52
0267A:  DATA 3A,25
0267C:  DATA 30,32
0267E:  DATA 75,2F
02680:  DATA 25,30
02682:  DATA 32,75
02684:  DATA 2F,25
02686:  DATA 30,32
02688:  DATA 75,20
0268A:  DATA 25,30
0268C:  DATA 32,75
0268E:  DATA 3A,25
02690:  DATA 30,32
02692:  DATA 75,3A
02694:  DATA 25,30
02696:  DATA 32,75
02698:  DATA 0D,0A
0269A:  DATA 00,00
0269C:  DATA 40,53
0269E:  DATA 4D,50
026A0:  DATA 20,25
026A2:  DATA 30,34
026A4:  DATA 4C,75
026A6:  DATA 0D,0A
026A8:  DATA 00,00
026AA:  DATA 40,53
026AC:  DATA 4D,50
026AE:  DATA 20,25
026B0:  DATA 30,34
026B2:  DATA 4C,75
026B4:  DATA 0D,0A
026B6:  DATA 00,00
026B8:  DATA 45,6E
026BA:  DATA 74,65
026BC:  DATA 72,20
026BE:  DATA 64,61
026C0:  DATA 74,65
026C2:  DATA 20,66
026C4:  DATA 6F,72
026C6:  DATA 6D,61
026C8:  DATA 74,20
026CA:  DATA 30,3D
026CC:  DATA 4D,4D
026CE:  DATA 2F,44
026D0:  DATA 44,2F
026D2:  DATA 59,59
026D4:  DATA 20,20
026D6:  DATA 31,3D
026D8:  DATA 44,44
026DA:  DATA 2F,4D
026DC:  DATA 4D,2F
026DE:  DATA 59,59
026E0:  DATA 0D,0A
026E2:  DATA 00,00
026E4:  DATA 40,4F
026E6:  DATA 4B,21
026E8:  DATA 0D,0A
026EA:  DATA 20,00
026EC:  DATA 40,45
026EE:  DATA 52,52
026F0:  DATA 0D,0A
026F2:  DATA 00,00
026F4:  DATA 40,52
026F6:  DATA 55,4E
026F8:  DATA 0D,0A
026FA:  DATA 00,00
026FC:  DATA 5B,6D
026FE:  DATA 6F,74
02700:  DATA 6F,72
02702:  DATA 3A,31
02704:  DATA 5D,0D
02706:  DATA 0A,00
02708:  DATA 5B,6D
0270A:  DATA 6F,74
0270C:  DATA 6F,72
0270E:  DATA 3A,32
02710:  DATA 5D,0D
02712:  DATA 0A,00
02714:  DATA 2C,45
02716:  DATA 43,4F
02718:  DATA 20,6D
0271A:  DATA 6F,64
0271C:  DATA 65,20
0271E:  DATA 73,65
02720:  DATA 74,0D
02722:  DATA 0A,00
02724:  DATA 2C,57
02726:  DATA 4D,53
02728:  DATA 2D,34
0272A:  DATA 2D,53
0272C:  DATA 44,20
0272E:  DATA 6D,6F
02730:  DATA 64,65
02732:  DATA 20,73
02734:  DATA 65,74
02736:  DATA 0D,0A
02738:  DATA 00,00
0273A:  DATA 2C,41
0273C:  DATA 57,53
0273E:  DATA 20,6D
02740:  DATA 6F,64
02742:  DATA 65,20
02744:  DATA 73,65
02746:  DATA 74,0D
02748:  DATA 0A,00
0274A:  DATA 2C,57
0274C:  DATA 4D,53
0274E:  DATA 2D,34
02750:  DATA 2D,51
02752:  DATA 45,20
02754:  DATA 6D,6F
02756:  DATA 64,65
02758:  DATA 20,73
0275A:  DATA 65,74
0275C:  DATA 0D,0A
0275E:  DATA 00,00
02760:  DATA 32,33
02762:  DATA 2D,4A
02764:  DATA 75,6E
02766:  DATA 2D,31
02768:  DATA 37,00
0276A:  DATA 31,35
0276C:  DATA 3A,34
0276E:  DATA 38,3A
02770:  DATA 34,34
02772:  DATA 00,00
02774:  DATA 53,45
02776:  DATA 4E,44
02778:  DATA 20,48
0277A:  DATA 45,58
0277C:  DATA 20,46
0277E:  DATA 49,4C
02780:  DATA 45,20
02782:  DATA 28,31
02784:  DATA 39,32
02786:  DATA 30,30
02788:  DATA 2C,4E
0278A:  DATA 38,31
0278C:  DATA 2C,58
0278E:  DATA 4F,4E
02790:  DATA 2D,58
02792:  DATA 4F,46
02794:  DATA 46,29
02796:  DATA 0D,0A
02798:  DATA 00,00
0279A:  DATA 40,4F
0279C:  DATA 4B,21
0279E:  DATA 20,00
027A0:  DATA 40,41
027A2:  DATA 52,47
027A4:  DATA 20,00
027A6:  DATA 40,49
027A8:  DATA 4E,56
027AA:  DATA 00,00
027AC:  DATA 40,43
027AE:  DATA 4D,44
027B0:  DATA 00,00
027B2:  DATA 2C,63
027B4:  DATA 6F,6D
027B6:  DATA 6D,61
027B8:  DATA 6E,64
027BA:  DATA 20,70
027BC:  DATA 72,6F
027BE:  DATA 6D,70
027C0:  DATA 74,0D
027C2:  DATA 0A,00
027C4:  DATA 40,53
027C6:  DATA 44,3D
027C8:  DATA 25,4C
027CA:  DATA 75,0D
027CC:  DATA 0A,00
027CE:  DATA 40,4D
027D0:  DATA 43,31
027D2:  DATA 2C,25
027D4:  DATA 4C,75
027D6:  DATA 2C,25
027D8:  DATA 4C,64
027DA:  DATA 0D,0A
027DC:  DATA 00,00
027DE:  DATA 40,4D
027E0:  DATA 43,32
027E2:  DATA 2C,25
027E4:  DATA 4C,75
027E6:  DATA 2C,25
027E8:  DATA 4C,64
027EA:  DATA 0D,0A
027EC:  DATA 00,00
027EE:  DATA 50,72
027F0:  DATA 65,73
027F2:  DATA 73,20
027F4:  DATA 61,6E
027F6:  DATA 64,20
027F8:  DATA 68,6F
027FA:  DATA 6C,64
027FC:  DATA 20,74
027FE:  DATA 68,65
02800:  DATA 20,45
02802:  DATA 73,63
02804:  DATA 20,6B
02806:  DATA 65,79
02808:  DATA 20,74
0280A:  DATA 6F,20
0280C:  DATA 72,65
0280E:  DATA 74,75
02810:  DATA 72,6E
02812:  DATA 20,74
02814:  DATA 6F,20
02816:  DATA 43,6F
02818:  DATA 6D,6D
0281A:  DATA 61,6E
0281C:  DATA 64,20
0281E:  DATA 4D,6F
02820:  DATA 64,65
02822:  DATA 0D,0A
02824:  DATA 00,00
02826:  DATA 52,65
02828:  DATA 74,75
0282A:  DATA 72,6E
0282C:  DATA 69,6E
0282E:  DATA 67,20
02830:  DATA 74,6F
02832:  DATA 20,4C
02834:  DATA 6F,67
02836:  DATA 67,69
02838:  DATA 6E,67
0283A:  DATA 20,4D
0283C:  DATA 6F,64
0283E:  DATA 65,0D
02840:  DATA 0A,00
*
02C52:  CLRF   01
02C54:  CLRF   02
02C56:  CLRF   00
02C58:  CLRF   03
02C5A:  MOVLB  8
02C5C:  MOVF   xBB,W
02C5E:  BNZ   2C64
02C60:  MOVF   xBA,W
02C62:  BZ    2C94
02C64:  MOVLW  10
02C66:  MOVWF  xBC
02C68:  BCF    FD8.0
02C6A:  RLCF   xB8,F
02C6C:  RLCF   xB9,F
02C6E:  RLCF   00,F
02C70:  RLCF   03,F
02C72:  MOVF   xBB,W
02C74:  SUBWF  03,W
02C76:  BNZ   2C7C
02C78:  MOVF   xBA,W
02C7A:  SUBWF  00,W
02C7C:  BNC   2C8C
02C7E:  MOVF   xBA,W
02C80:  SUBWF  00,F
02C82:  BTFSS  FD8.0
02C84:  DECF   03,F
02C86:  MOVF   xBB,W
02C88:  SUBWF  03,F
02C8A:  BSF    FD8.0
02C8C:  RLCF   01,F
02C8E:  RLCF   02,F
02C90:  DECFSZ xBC,F
02C92:  BRA    2C68
02C94:  MOVLB  0
02C96:  RETURN 0
*
034A4:  TSTFSZ 01
034A6:  BRA    34AE
034A8:  TSTFSZ 02
034AA:  BRA    34B0
034AC:  BRA    34BC
034AE:  INCF   02,F
034B0:  MOVFF  00,FEE
034B4:  DECFSZ 01,F
034B6:  BRA    34B0
034B8:  DECFSZ 02,F
034BA:  BRA    34B0
034BC:  RETURN 0
*
0358E:  MOVLB  9
03590:  BTFSC  xCA.7
03592:  BRA    35B4
03594:  MOVLW  0F
03596:  MOVWF  00
03598:  SWAPF  xC9,W
0359A:  ANDWF  00,F
0359C:  MOVLW  0A
0359E:  SUBWF  00,W
035A0:  BC    35A8
035A2:  MOVLW  30
035A4:  ADDWF  00,F
035A6:  BRA    35AC
035A8:  MOVF   xCA,W
035AA:  ADDWF  00,F
035AC:  MOVF   00,W
035AE:  BTFSS  F9E.4
035B0:  BRA    35AE
035B2:  MOVWF  FAD
035B4:  MOVLW  0F
035B6:  ANDWF  xC9,F
035B8:  MOVLW  0A
035BA:  SUBWF  xC9,W
035BC:  BC    35C2
035BE:  MOVLW  30
035C0:  BRA    35C6
035C2:  BCF    xCA.7
035C4:  MOVF   xCA,W
035C6:  ADDWF  xC9,F
035C8:  MOVF   xC9,W
035CA:  BTFSS  F9E.4
035CC:  BRA    35CA
035CE:  MOVWF  FAD
035D0:  MOVLB  0
035D2:  RETURN 0
*
04772:  MOVLB  9
04774:  CLRF   xDB
04776:  CLRF   xDC
04778:  MOVLW  01
0477A:  MOVWF  xDD
0477C:  CLRF   FDA
0477E:  CLRF   FD9
04780:  MOVLW  09
04782:  MOVWF  xE0
04784:  MOVLW  D3
04786:  MOVWF  xDF
04788:  MOVLW  09
0478A:  MOVWF  FEA
0478C:  MOVLW  D7
0478E:  MOVWF  FE9
04790:  MOVFF  9E0,FE2
04794:  MOVFF  9DF,FE1
04798:  MOVFF  9DD,9DE
0479C:  BCF    FD8.0
0479E:  MOVF   FE5,W
047A0:  MULWF  FEE
047A2:  MOVF   FF3,W
047A4:  ADDWFC xDB,F
047A6:  MOVF   FF4,W
047A8:  ADDWFC xDC,F
047AA:  DECFSZ xDE,F
047AC:  BRA    479C
047AE:  MOVFF  9DB,FDE
047B2:  MOVFF  9DC,9DB
047B6:  CLRF   xDC
047B8:  BTFSC  FD8.0
047BA:  INCF   xDC,F
047BC:  INCF   xDF,F
047BE:  BTFSC  FD8.2
047C0:  INCF   xE0,F
047C2:  INCF   xDD,F
047C4:  MOVF   xDD,W
047C6:  SUBLW  05
047C8:  BNZ   4788
047CA:  MOVLB  0
047CC:  RETURN 0
*
05016:  MOVFF  1E,FEA
0501A:  MOVFF  1D,FE9
0501E:  MOVLB  8
05020:  MOVFF  8DC,FEF
05024:  INCF   FE9,F
05026:  BTFSC  FD8.2
05028:  INCF   FEA,F
0502A:  CLRF   FEF
0502C:  INCF   1D,F
0502E:  BTFSC  FD8.2
05030:  INCF   1E,F
05032:  MOVLB  0
05034:  RETURN 0
05036:  TBLRD*+
05038:  MOVF   FF5,F
0503A:  BZ    505C
0503C:  MOVFF  FF6,8C8
05040:  MOVFF  FF7,8C9
05044:  MOVFF  FF8,8CA
05048:  MOVFF  FF5,8DC
0504C:  RCALL  5016
0504E:  MOVFF  8C8,FF6
05052:  MOVFF  8C9,FF7
05056:  MOVFF  8CA,FF8
0505A:  BRA    5036
0505C:  RETURN 0
*
051F8:  MOVF   01,W
051FA:  CLRF   1B
051FC:  BTFSC  FF2.7
051FE:  BSF    1B.7
05200:  BCF    FF2.7
05202:  MOVFF  8CA,A1A
05206:  MOVLW  64
05208:  MOVLB  A
0520A:  MOVWF  x1B
0520C:  MOVLB  0
0520E:  CALL   0F5C
05212:  BTFSC  1B.7
05214:  BSF    FF2.7
05216:  MOVFF  00,8CA
0521A:  MOVF   01,W
0521C:  MOVLW  30
0521E:  BNZ   5230
05220:  MOVLB  8
05222:  BTFSS  xCB.1
05224:  BRA    5244
05226:  BTFSC  xCB.3
05228:  BRA    5244
0522A:  BTFSC  xCB.4
0522C:  MOVLW  20
0522E:  BRA    5238
05230:  MOVLB  8
05232:  BCF    xCB.3
05234:  BCF    xCB.4
05236:  BSF    xCB.0
05238:  ADDWF  01,F
0523A:  MOVFF  01,8DC
0523E:  MOVLB  0
05240:  RCALL  5016
05242:  MOVLB  8
05244:  CLRF   1B
05246:  BTFSC  FF2.7
05248:  BSF    1B.7
0524A:  BCF    FF2.7
0524C:  MOVFF  8CA,A1A
05250:  MOVLW  0A
05252:  MOVLB  A
05254:  MOVWF  x1B
05256:  MOVLB  0
05258:  CALL   0F5C
0525C:  BTFSC  1B.7
0525E:  BSF    FF2.7
05260:  MOVFF  00,8CA
05264:  MOVF   01,W
05266:  MOVLW  30
05268:  BNZ   527A
0526A:  MOVLB  8
0526C:  BTFSC  xCB.3
0526E:  BRA    5284
05270:  BTFSS  xCB.0
05272:  BRA    5284
05274:  BTFSC  xCB.4
05276:  MOVLW  20
05278:  MOVLB  0
0527A:  ADDWF  01,F
0527C:  MOVFF  01,8DC
05280:  RCALL  5016
05282:  MOVLB  8
05284:  MOVLW  30
05286:  ADDWF  xCA,F
05288:  MOVFF  8CA,8DC
0528C:  MOVLB  0
0528E:  RCALL  5016
05290:  RETURN 0
05292:  MOVF   FE9,W
05294:  MOVLB  8
05296:  MOVWF  xCF
05298:  MOVLW  3B
0529A:  MOVWF  xD6
0529C:  MOVLW  9A
0529E:  MOVWF  xD5
052A0:  MOVLW  CA
052A2:  MOVWF  xD4
052A4:  CLRF   xD3
052A6:  MOVLW  0A
052A8:  MOVWF  xD1
052AA:  MOVF   xCE,W
052AC:  BTFSS  FD8.2
052AE:  DECF   xCF,F
052B0:  BSF    FD8.1
052B2:  MOVLW  08
052B4:  MOVWF  FEA
052B6:  MOVLW  CA
052B8:  MOVWF  FE9
052BA:  CLRF   1B
052BC:  BTFSC  FF2.7
052BE:  BSF    1B.7
052C0:  BCF    FF2.7
052C2:  MOVFF  8CD,A27
052C6:  MOVFF  8CC,A26
052CA:  MOVFF  8CB,A25
052CE:  MOVFF  8CA,A24
052D2:  MOVFF  8D6,A2B
052D6:  MOVFF  8D5,A2A
052DA:  MOVFF  8D4,A29
052DE:  MOVFF  8D3,A28
052E2:  MOVLB  0
052E4:  CALL   1038
052E8:  BTFSC  1B.7
052EA:  BSF    FF2.7
052EC:  MOVF   01,W
052EE:  MOVF   00,F
052F0:  BNZ   5318
052F2:  MOVLB  8
052F4:  INCF   xCE,W
052F6:  SUBWF  xD1,W
052F8:  BTFSS  FD8.2
052FA:  BRA    5300
052FC:  MOVLB  0
052FE:  BRA    5318
05300:  MOVF   xCF,W
05302:  BZ    531C
05304:  ANDLW  0F
05306:  SUBWF  xD1,W
05308:  BZ    530C
0530A:  BC    5348
0530C:  BTFSC  xCF.7
0530E:  BRA    5348
05310:  BTFSC  xCF.6
05312:  BRA    531C
05314:  MOVLW  20
05316:  BRA    533C
05318:  MOVLB  8
0531A:  CLRF   xCF
0531C:  MOVF   xCE,W
0531E:  SUBWF  xD1,W
05320:  BNZ   533A
05322:  MOVFF  00,8CF
05326:  MOVLW  2E
05328:  MOVWF  xDC
0532A:  MOVLB  0
0532C:  RCALL  5016
0532E:  MOVLB  8
05330:  MOVFF  8CF,00
05334:  MOVLW  20
05336:  ANDWF  xCF,F
05338:  MOVLW  00
0533A:  MOVLW  30
0533C:  ADDWF  00,F
0533E:  MOVFF  00,8DC
05342:  MOVLB  0
05344:  RCALL  5016
05346:  MOVLB  8
05348:  BCF    FD8.1
0534A:  CLRF   1B
0534C:  BTFSC  FF2.7
0534E:  BSF    1B.7
05350:  BCF    FF2.7
05352:  MOVFF  8D6,A27
05356:  MOVFF  8D5,A26
0535A:  MOVFF  8D4,A25
0535E:  MOVFF  8D3,A24
05362:  MOVLB  A
05364:  CLRF   x2B
05366:  CLRF   x2A
05368:  CLRF   x29
0536A:  MOVLW  0A
0536C:  MOVWF  x28
0536E:  MOVLB  0
05370:  CALL   1038
05374:  BTFSC  1B.7
05376:  BSF    FF2.7
05378:  MOVFF  03,8D6
0537C:  MOVFF  02,8D5
05380:  MOVFF  01,8D4
05384:  MOVFF  00,8D3
05388:  MOVLB  8
0538A:  DECFSZ xD1,F
0538C:  BRA    52B0
0538E:  MOVLB  0
05390:  RETURN 0
*
05C0E:  MOVLB  9
05C10:  MOVF   xE9,W
05C12:  MULWF  xEB
05C14:  MOVFF  FF3,01
05C18:  MOVFF  FF4,00
05C1C:  MULWF  xEC
05C1E:  MOVF   FF3,W
05C20:  ADDWF  00,F
05C22:  MOVF   xEA,W
05C24:  MULWF  xEB
05C26:  MOVF   FF3,W
05C28:  ADDWFC 00,W
05C2A:  MOVWF  02
05C2C:  MOVLB  0
05C2E:  RETURN 0
*
078D2:  MOVF   FEF,F
078D4:  BZ    78F6
078D6:  MOVFF  FEA,98E
078DA:  MOVFF  FE9,98D
078DE:  MOVF   FEF,W
078E0:  BTFSS  F9E.4
078E2:  BRA    78E0
078E4:  MOVWF  FAD
078E6:  MOVFF  98E,FEA
078EA:  MOVFF  98D,FE9
078EE:  INCF   FE9,F
078F0:  BTFSC  FD8.2
078F2:  INCF   FEA,F
078F4:  BRA    78D2
078F6:  RETURN 0
*
08F1A:  MOVFF  FEA,8D5
08F1E:  MOVFF  FE9,8D4
08F22:  MOVLB  8
08F24:  BTFSS  xCE.7
08F26:  BRA    8F38
08F28:  BSF    xD4.7
08F2A:  BTFSS  xD4.4
08F2C:  INCF   xD4,F
08F2E:  COMF   xCD,F
08F30:  COMF   xCE,F
08F32:  INCF   xCD,F
08F34:  BTFSC  FD8.2
08F36:  INCF   xCE,F
08F38:  SWAPF  xCE,W
08F3A:  IORLW  F0
08F3C:  MOVWF  xD0
08F3E:  ADDWF  xD0,F
08F40:  ADDLW  E2
08F42:  MOVWF  xD1
08F44:  ADDLW  32
08F46:  MOVWF  xD3
08F48:  MOVF   xCE,W
08F4A:  ANDLW  0F
08F4C:  ADDWF  xD1,F
08F4E:  ADDWF  xD1,F
08F50:  ADDWF  xD3,F
08F52:  ADDLW  E9
08F54:  MOVWF  xD2
08F56:  ADDWF  xD2,F
08F58:  ADDWF  xD2,F
08F5A:  SWAPF  xCD,W
08F5C:  ANDLW  0F
08F5E:  ADDWF  xD2,F
08F60:  ADDWF  xD3,F
08F62:  RLCF   xD2,F
08F64:  RLCF   xD3,F
08F66:  COMF   xD3,F
08F68:  RLCF   xD3,F
08F6A:  MOVF   xCD,W
08F6C:  ANDLW  0F
08F6E:  ADDWF  xD3,F
08F70:  RLCF   xD0,F
08F72:  MOVLW  07
08F74:  MOVWF  xCF
08F76:  MOVLW  0A
08F78:  DECF   xD2,F
08F7A:  ADDWF  xD3,F
08F7C:  BNC   8F78
08F7E:  DECF   xD1,F
08F80:  ADDWF  xD2,F
08F82:  BNC   8F7E
08F84:  DECF   xD0,F
08F86:  ADDWF  xD1,F
08F88:  BNC   8F84
08F8A:  DECF   xCF,F
08F8C:  ADDWF  xD0,F
08F8E:  BNC   8F8A
08F90:  MOVLW  08
08F92:  MOVWF  FEA
08F94:  MOVLW  CF
08F96:  MOVWF  FE9
08F98:  MOVLW  07
08F9A:  ANDWF  xD4,W
08F9C:  BCF    xD4.6
08F9E:  MOVF   FED,F
08FA0:  ANDWF  xD4,W
08FA2:  BNZ   8FB2
08FA4:  BTFSC  xD4.4
08FA6:  MOVF   FEE,F
08FA8:  BTFSC  xD4.4
08FAA:  BRA    8FB2
08FAC:  MOVLW  20
08FAE:  MOVWF  00
08FB0:  BRA    8FF4
08FB2:  ADDWF  FE9,F
08FB4:  MOVLW  00
08FB6:  ADDWFC FEA,F
08FB8:  MOVF   FE9,W
08FBA:  SUBLW  D3
08FBC:  BNZ   8FC6
08FBE:  MOVF   FEA,W
08FC0:  SUBLW  08
08FC2:  BNZ   8FC6
08FC4:  BSF    xD4.6
08FC6:  MOVF   FEF,W
08FC8:  MOVWF  00
08FCA:  BNZ   8FDC
08FCC:  BTFSC  xD4.6
08FCE:  BRA    8FDC
08FD0:  BTFSC  xD4.4
08FD2:  BRA    8FFC
08FD4:  BTFSC  xD4.3
08FD6:  BRA    8FDC
08FD8:  MOVLW  20
08FDA:  BRA    8FF2
08FDC:  BTFSS  xD4.7
08FDE:  BRA    8FEC
08FE0:  MOVLW  2D
08FE2:  MOVWF  00
08FE4:  MOVF   FED,W
08FE6:  BCF    xD4.6
08FE8:  BCF    xD4.7
08FEA:  BRA    8FF4
08FEC:  BSF    xD4.3
08FEE:  BCF    xD4.4
08FF0:  MOVLW  30
08FF2:  ADDWF  00,F
08FF4:  MOVF   00,W
08FF6:  BTFSS  F9E.4
08FF8:  BRA    8FF6
08FFA:  MOVWF  FAD
08FFC:  MOVF   FEE,W
08FFE:  BTFSS  xD4.6
09000:  BRA    8FB8
09002:  MOVLB  0
09004:  RETURN 0
*
0949A:  MOVF   FE9,W
0949C:  MOVLB  8
0949E:  MOVWF  xD3
094A0:  BTFSS  xD2.7
094A2:  BRA    94BE
094A4:  DECF   xD3,F
094A6:  BSF    xD3.5
094A8:  COMF   xCF,F
094AA:  COMF   xD0,F
094AC:  COMF   xD1,F
094AE:  COMF   xD2,F
094B0:  INCF   xCF,F
094B2:  BTFSC  FD8.2
094B4:  INCF   xD0,F
094B6:  BTFSC  FD8.2
094B8:  INCF   xD1,F
094BA:  BTFSC  FD8.2
094BC:  INCF   xD2,F
094BE:  MOVLW  3B
094C0:  MOVWF  xDA
094C2:  MOVLW  9A
094C4:  MOVWF  xD9
094C6:  MOVLW  CA
094C8:  MOVWF  xD8
094CA:  CLRF   xD7
094CC:  MOVLW  0A
094CE:  MOVWF  xD5
094D0:  BSF    FD8.1
094D2:  MOVLW  08
094D4:  MOVWF  FEA
094D6:  MOVLW  CF
094D8:  MOVWF  FE9
094DA:  CLRF   1B
094DC:  BTFSC  FF2.7
094DE:  BSF    1B.7
094E0:  BCF    FF2.7
094E2:  MOVFF  8D2,A27
094E6:  MOVFF  8D1,A26
094EA:  MOVFF  8D0,A25
094EE:  MOVFF  8CF,A24
094F2:  MOVFF  8DA,A2B
094F6:  MOVFF  8D9,A2A
094FA:  MOVFF  8D8,A29
094FE:  MOVFF  8D7,A28
09502:  MOVLB  0
09504:  CALL   1038
09508:  BTFSC  1B.7
0950A:  BSF    FF2.7
0950C:  MOVF   01,W
0950E:  MOVF   00,F
09510:  BNZ   9538
09512:  MOVLB  8
09514:  MOVF   xD5,W
09516:  XORLW  01
09518:  BTFSS  FD8.2
0951A:  BRA    9520
0951C:  MOVLB  0
0951E:  BRA    9538
09520:  MOVF   xD3,W
09522:  BZ    953E
09524:  ANDLW  0F
09526:  SUBWF  xD5,W
09528:  BZ    952C
0952A:  BC    957C
0952C:  BTFSC  xD3.7
0952E:  BRA    957C
09530:  BTFSC  xD3.6
09532:  BRA    953E
09534:  MOVLW  20
09536:  BRA    9572
09538:  MOVLW  20
0953A:  MOVLB  8
0953C:  ANDWF  xD3,F
0953E:  BTFSS  xD3.5
09540:  BRA    9556
09542:  BCF    xD3.5
09544:  MOVFF  00,8D3
09548:  MOVLW  2D
0954A:  BTFSS  F9E.4
0954C:  BRA    954A
0954E:  MOVWF  FAD
09550:  MOVFF  8D3,00
09554:  CLRF   xD3
09556:  MOVLW  30
09558:  BTFSS  xD3.5
0955A:  BRA    9572
0955C:  BCF    xD3.5
0955E:  MOVFF  00,8D3
09562:  MOVLW  2D
09564:  BTFSS  F9E.4
09566:  BRA    9564
09568:  MOVWF  FAD
0956A:  MOVFF  8D3,00
0956E:  CLRF   xD3
09570:  MOVLW  30
09572:  ADDWF  00,F
09574:  MOVF   00,W
09576:  BTFSS  F9E.4
09578:  BRA    9576
0957A:  MOVWF  FAD
0957C:  BCF    FD8.1
0957E:  CLRF   1B
09580:  BTFSC  FF2.7
09582:  BSF    1B.7
09584:  BCF    FF2.7
09586:  MOVFF  8DA,A27
0958A:  MOVFF  8D9,A26
0958E:  MOVFF  8D8,A25
09592:  MOVFF  8D7,A24
09596:  MOVLB  A
09598:  CLRF   x2B
0959A:  CLRF   x2A
0959C:  CLRF   x29
0959E:  MOVLW  0A
095A0:  MOVWF  x28
095A2:  MOVLB  0
095A4:  CALL   1038
095A8:  BTFSC  1B.7
095AA:  BSF    FF2.7
095AC:  MOVFF  03,8DA
095B0:  MOVFF  02,8D9
095B4:  MOVFF  01,8D8
095B8:  MOVFF  00,8D7
095BC:  MOVLB  8
095BE:  DECFSZ xD5,F
095C0:  BRA    94D0
095C2:  MOVLB  0
095C4:  RETURN 0
*
0A68E:  ADDWF  FE8,W
0A690:  CLRF   FF7
0A692:  RLCF   FF7,F
0A694:  ADDLW  AF
0A696:  MOVWF  FF6
0A698:  MOVLW  A6
0A69A:  ADDWFC FF7,F
0A69C:  MOVLW  00
0A69E:  MOVWF  FF8
0A6A0:  MOVWF  FFB
0A6A2:  TBLRD*-
0A6A4:  MOVF   FF5,W
0A6A6:  MOVWF  FFA
0A6A8:  TBLRD*
0A6AA:  MOVF   FF5,W
0A6AC:  MOVWF  FF9
0A6AE:  DATA EA,9F
0A6B0:  DATA 0A,A0
0A6B2:  DATA 32,A0
0A6B4:  DATA 62,A0
0A6B6:  DATA 8A,A0
*
0A9FA:  TBLRD*+
0A9FC:  MOVFF  FF6,8C9
0AA00:  MOVFF  FF7,8CA
0AA04:  MOVFF  FF8,8CB
0AA08:  MOVFF  FF5,8DC
0AA0C:  CALL   5016
0AA10:  MOVFF  8C9,FF6
0AA14:  MOVFF  8CA,FF7
0AA18:  MOVFF  8CB,FF8
0AA1C:  MOVLB  8
0AA1E:  DECFSZ xC8,F
0AA20:  BRA    AA24
0AA22:  BRA    AA28
0AA24:  MOVLB  0
0AA26:  BRA    A9FA
0AA28:  MOVLB  0
0AA2A:  RETURN 0
0AA2C:  MOVFF  FEA,8DB
0AA30:  MOVFF  FE9,8DA
0AA34:  MOVLB  8
0AA36:  SWAPF  xD4,W
0AA38:  IORLW  F0
0AA3A:  MOVWF  xD6
0AA3C:  ADDWF  xD6,F
0AA3E:  ADDLW  E2
0AA40:  MOVWF  xD7
0AA42:  ADDLW  32
0AA44:  MOVWF  xD9
0AA46:  MOVF   xD4,W
0AA48:  ANDLW  0F
0AA4A:  ADDWF  xD7,F
0AA4C:  ADDWF  xD7,F
0AA4E:  ADDWF  xD9,F
0AA50:  ADDLW  E9
0AA52:  MOVWF  xD8
0AA54:  ADDWF  xD8,F
0AA56:  ADDWF  xD8,F
0AA58:  SWAPF  xD3,W
0AA5A:  ANDLW  0F
0AA5C:  ADDWF  xD8,F
0AA5E:  ADDWF  xD9,F
0AA60:  RLCF   xD8,F
0AA62:  RLCF   xD9,F
0AA64:  COMF   xD9,F
0AA66:  RLCF   xD9,F
0AA68:  MOVF   xD3,W
0AA6A:  ANDLW  0F
0AA6C:  ADDWF  xD9,F
0AA6E:  RLCF   xD6,F
0AA70:  MOVLW  07
0AA72:  MOVWF  xD5
0AA74:  MOVLW  0A
0AA76:  DECF   xD8,F
0AA78:  ADDWF  xD9,F
0AA7A:  BNC   AA76
0AA7C:  DECF   xD7,F
0AA7E:  ADDWF  xD8,F
0AA80:  BNC   AA7C
0AA82:  DECF   xD6,F
0AA84:  ADDWF  xD7,F
0AA86:  BNC   AA82
0AA88:  DECF   xD5,F
0AA8A:  ADDWF  xD6,F
0AA8C:  BNC   AA88
0AA8E:  MOVLW  08
0AA90:  MOVWF  FEA
0AA92:  MOVLW  D5
0AA94:  MOVWF  FE9
0AA96:  MOVLW  07
0AA98:  ANDWF  xDA,W
0AA9A:  BCF    xDA.6
0AA9C:  ADDWF  FE9,F
0AA9E:  MOVLW  00
0AAA0:  ADDWFC FEA,F
0AAA2:  MOVF   FE9,W
0AAA4:  SUBLW  D9
0AAA6:  BNZ   AAB0
0AAA8:  MOVF   FEA,W
0AAAA:  SUBLW  08
0AAAC:  BNZ   AAB0
0AAAE:  BSF    xDA.6
0AAB0:  MOVF   FEF,W
0AAB2:  MOVWF  00
0AAB4:  BNZ   AAC6
0AAB6:  BTFSC  xDA.6
0AAB8:  BRA    AAC6
0AABA:  BTFSC  xDA.4
0AABC:  BRA    AAEA
0AABE:  BTFSC  xDA.3
0AAC0:  BRA    AAC6
0AAC2:  MOVLW  20
0AAC4:  BRA    AACC
0AAC6:  BSF    xDA.3
0AAC8:  BCF    xDA.4
0AACA:  MOVLW  30
0AACC:  ADDWF  00,F
0AACE:  MOVFF  FEA,8D4
0AAD2:  MOVFF  FE9,8D3
0AAD6:  MOVFF  00,8DC
0AADA:  MOVLB  0
0AADC:  CALL   5016
0AAE0:  MOVFF  8D4,FEA
0AAE4:  MOVFF  8D3,FE9
0AAE8:  MOVLB  8
0AAEA:  MOVF   FEE,W
0AAEC:  BTFSS  xDA.6
0AAEE:  BRA    AAA2
0AAF0:  MOVLB  0
0AAF2:  RETURN 0
*
0ACDE:  ADDWF  FE8,W
0ACE0:  CLRF   FF7
0ACE2:  RLCF   FF7,F
0ACE4:  ADDLW  FF
0ACE6:  MOVWF  FF6
0ACE8:  MOVLW  AC
0ACEA:  ADDWFC FF7,F
0ACEC:  MOVLW  00
0ACEE:  MOVWF  FF8
0ACF0:  MOVWF  FFB
0ACF2:  TBLRD*-
0ACF4:  MOVF   FF5,W
0ACF6:  MOVWF  FFA
0ACF8:  TBLRD*
0ACFA:  MOVF   FF5,W
0ACFC:  MOVWF  FF9
0ACFE:  DATA EE,AB
0AD00:  DATA DA,AC
0AD02:  DATA DA,AC
0AD04:  DATA 4E,AB
0AD06:  DATA DA,AC
0AD08:  DATA DA,AC
0AD0A:  DATA DA,AC
0AD0C:  DATA 12,AB
0AD0E:  DATA DA,AC
0AD10:  DATA DA,AC
0AD12:  DATA DA,AC
0AD14:  DATA 64,AC
0AD16:  DATA 8A,AB
0AD18:  DATA DA,AC
0AD1A:  DATA 28,AC
0AD1C:  DATA A0,AC
*
0AD78:  TBLRD*+
0AD7A:  MOVF   FF5,F
0AD7C:  BZ    ADA0
0AD7E:  MOVFF  FF6,862
0AD82:  MOVFF  FF7,863
0AD86:  MOVFF  FF8,864
0AD8A:  MOVF   FF5,W
0AD8C:  BTFSS  F9E.4
0AD8E:  BRA    AD8C
0AD90:  MOVWF  FAD
0AD92:  MOVFF  862,FF6
0AD96:  MOVFF  863,FF7
0AD9A:  MOVFF  864,FF8
0AD9E:  BRA    AD78
0ADA0:  RETURN 0
*
0BF2C:  MOVLB  8
0BF2E:  MOVF   xF0,W
0BF30:  BTFSC  FD8.2
0BF32:  BRA    C016
0BF34:  MOVWF  00
0BF36:  MOVF   xF4,W
0BF38:  BTFSC  FD8.2
0BF3A:  BRA    C016
0BF3C:  ADDWF  00,F
0BF3E:  BNC   BF48
0BF40:  MOVLW  81
0BF42:  ADDWF  00,F
0BF44:  BC    C016
0BF46:  BRA    BF50
0BF48:  MOVLW  7F
0BF4A:  SUBWF  00,F
0BF4C:  BNC   C016
0BF4E:  BZ    C016
0BF50:  MOVFF  8F1,8F8
0BF54:  MOVF   xF5,W
0BF56:  XORWF  xF8,F
0BF58:  BSF    xF1.7
0BF5A:  BSF    xF5.7
0BF5C:  MOVF   xF3,W
0BF5E:  MULWF  xF7
0BF60:  MOVFF  FF4,8FA
0BF64:  MOVF   xF2,W
0BF66:  MULWF  xF6
0BF68:  MOVFF  FF4,03
0BF6C:  MOVFF  FF3,8F9
0BF70:  MULWF  xF7
0BF72:  MOVF   FF3,W
0BF74:  ADDWF  xFA,F
0BF76:  MOVF   FF4,W
0BF78:  ADDWFC xF9,F
0BF7A:  MOVLW  00
0BF7C:  ADDWFC 03,F
0BF7E:  MOVF   xF3,W
0BF80:  MULWF  xF6
0BF82:  MOVF   FF3,W
0BF84:  ADDWF  xFA,F
0BF86:  MOVF   FF4,W
0BF88:  ADDWFC xF9,F
0BF8A:  MOVLW  00
0BF8C:  CLRF   02
0BF8E:  ADDWFC 03,F
0BF90:  ADDWFC 02,F
0BF92:  MOVF   xF1,W
0BF94:  MULWF  xF7
0BF96:  MOVF   FF3,W
0BF98:  ADDWF  xF9,F
0BF9A:  MOVF   FF4,W
0BF9C:  ADDWFC 03,F
0BF9E:  MOVLW  00
0BFA0:  ADDWFC 02,F
0BFA2:  MOVF   xF1,W
0BFA4:  MULWF  xF6
0BFA6:  MOVF   FF3,W
0BFA8:  ADDWF  03,F
0BFAA:  MOVF   FF4,W
0BFAC:  ADDWFC 02,F
0BFAE:  MOVLW  00
0BFB0:  CLRF   01
0BFB2:  ADDWFC 01,F
0BFB4:  MOVF   xF3,W
0BFB6:  MULWF  xF5
0BFB8:  MOVF   FF3,W
0BFBA:  ADDWF  xF9,F
0BFBC:  MOVF   FF4,W
0BFBE:  ADDWFC 03,F
0BFC0:  MOVLW  00
0BFC2:  ADDWFC 02,F
0BFC4:  ADDWFC 01,F
0BFC6:  MOVF   xF2,W
0BFC8:  MULWF  xF5
0BFCA:  MOVF   FF3,W
0BFCC:  ADDWF  03,F
0BFCE:  MOVF   FF4,W
0BFD0:  ADDWFC 02,F
0BFD2:  MOVLW  00
0BFD4:  ADDWFC 01,F
0BFD6:  MOVF   xF1,W
0BFD8:  MULWF  xF5
0BFDA:  MOVF   FF3,W
0BFDC:  ADDWF  02,F
0BFDE:  MOVF   FF4,W
0BFE0:  ADDWFC 01,F
0BFE2:  INCF   00,F
0BFE4:  BTFSC  01.7
0BFE6:  BRA    BFF2
0BFE8:  RLCF   xF9,F
0BFEA:  RLCF   03,F
0BFEC:  RLCF   02,F
0BFEE:  RLCF   01,F
0BFF0:  DECF   00,F
0BFF2:  MOVLW  00
0BFF4:  BTFSS  xF9.7
0BFF6:  BRA    C00C
0BFF8:  INCF   03,F
0BFFA:  ADDWFC 02,F
0BFFC:  ADDWFC 01,F
0BFFE:  MOVF   01,W
0C000:  BNZ   C00C
0C002:  MOVF   02,W
0C004:  BNZ   C00C
0C006:  MOVF   03,W
0C008:  BNZ   C00C
0C00A:  INCF   00,F
0C00C:  BTFSC  xF8.7
0C00E:  BSF    01.7
0C010:  BTFSS  xF8.7
0C012:  BCF    01.7
0C014:  BRA    C01E
0C016:  CLRF   00
0C018:  CLRF   01
0C01A:  CLRF   02
0C01C:  CLRF   03
0C01E:  MOVLB  0
0C020:  RETURN 0
0C022:  MOVLW  80
0C024:  BTFSS  FD8.1
0C026:  BRA    C02C
0C028:  MOVLB  8
0C02A:  XORWF  xF9,F
0C02C:  MOVLB  8
0C02E:  CLRF   xFE
0C030:  CLRF   xFF
0C032:  MOVFF  8F5,8FD
0C036:  MOVF   xF9,W
0C038:  XORWF  xFD,F
0C03A:  MOVF   xF4,W
0C03C:  BTFSC  FD8.2
0C03E:  BRA    C28A
0C040:  MOVWF  xFC
0C042:  MOVWF  00
0C044:  MOVF   xF8,W
0C046:  BTFSC  FD8.2
0C048:  BRA    C29E
0C04A:  SUBWF  xFC,F
0C04C:  BTFSC  FD8.2
0C04E:  BRA    C190
0C050:  BNC   C0EC
0C052:  MOVFF  8F9,902
0C056:  MOVLB  9
0C058:  BSF    x02.7
0C05A:  MOVFF  8FA,901
0C05E:  MOVFF  8FB,900
0C062:  MOVLB  8
0C064:  CLRF   xFF
0C066:  BCF    FD8.0
0C068:  MOVLB  9
0C06A:  RRCF   x02,F
0C06C:  RRCF   x01,F
0C06E:  RRCF   x00,F
0C070:  MOVLB  8
0C072:  RRCF   xFF,F
0C074:  DECFSZ xFC,F
0C076:  BRA    C064
0C078:  BTFSS  xFD.7
0C07A:  BRA    C082
0C07C:  BSF    xFE.0
0C07E:  BRA    C2CE
0C080:  BCF    xFE.0
0C082:  BCF    xFC.0
0C084:  BSF    xFE.4
0C086:  MOVLW  08
0C088:  MOVWF  FEA
0C08A:  MOVLW  F7
0C08C:  MOVWF  FE9
0C08E:  BRA    C308
0C090:  BCF    xFE.4
0C092:  BTFSC  xFD.7
0C094:  BRA    C0AE
0C096:  BTFSS  xFC.0
0C098:  BRA    C0CE
0C09A:  MOVLB  9
0C09C:  RRCF   x02,F
0C09E:  RRCF   x01,F
0C0A0:  RRCF   x00,F
0C0A2:  MOVLB  8
0C0A4:  RRCF   xFF,F
0C0A6:  INCF   00,F
0C0A8:  BTFSC  FD8.2
0C0AA:  BRA    C2C0
0C0AC:  BRA    C0CE
0C0AE:  MOVLB  9
0C0B0:  BTFSC  x02.7
0C0B2:  BRA    C0D4
0C0B4:  BCF    FD8.0
0C0B6:  MOVLB  8
0C0B8:  RLCF   xFF,F
0C0BA:  MOVLB  9
0C0BC:  RLCF   x00,F
0C0BE:  RLCF   x01,F
0C0C0:  RLCF   x02,F
0C0C2:  DECFSZ 00,F
0C0C4:  BRA    C0CA
0C0C6:  MOVLB  8
0C0C8:  BRA    C2C0
0C0CA:  BRA    C0B0
0C0CC:  MOVLB  8
0C0CE:  BSF    xFE.6
0C0D0:  BRA    C1DE
0C0D2:  BCF    xFE.6
0C0D4:  MOVFF  8F5,8FD
0C0D8:  MOVLB  8
0C0DA:  BTFSS  xF5.7
0C0DC:  BRA    C0E4
0C0DE:  MOVLB  9
0C0E0:  BSF    x02.7
0C0E2:  BRA    C2B0
0C0E4:  MOVLB  9
0C0E6:  BCF    x02.7
0C0E8:  BRA    C2B0
0C0EA:  MOVLB  8
0C0EC:  MOVFF  8F8,8FC
0C0F0:  MOVFF  8F8,00
0C0F4:  MOVF   xF4,W
0C0F6:  SUBWF  xFC,F
0C0F8:  MOVFF  8F5,902
0C0FC:  MOVLB  9
0C0FE:  BSF    x02.7
0C100:  MOVFF  8F6,901
0C104:  MOVFF  8F7,900
0C108:  MOVLB  8
0C10A:  CLRF   xFF
0C10C:  BCF    FD8.0
0C10E:  MOVLB  9
0C110:  RRCF   x02,F
0C112:  RRCF   x01,F
0C114:  RRCF   x00,F
0C116:  MOVLB  8
0C118:  RRCF   xFF,F
0C11A:  DECFSZ xFC,F
0C11C:  BRA    C10A
0C11E:  BTFSS  xFD.7
0C120:  BRA    C128
0C122:  BSF    xFE.1
0C124:  BRA    C2CE
0C126:  BCF    xFE.1
0C128:  BCF    xFC.0
0C12A:  BSF    xFE.5
0C12C:  MOVLW  08
0C12E:  MOVWF  FEA
0C130:  MOVLW  FB
0C132:  MOVWF  FE9
0C134:  BRA    C308
0C136:  BCF    xFE.5
0C138:  BTFSC  xFD.7
0C13A:  BRA    C154
0C13C:  BTFSS  xFC.0
0C13E:  BRA    C174
0C140:  MOVLB  9
0C142:  RRCF   x02,F
0C144:  RRCF   x01,F
0C146:  RRCF   x00,F
0C148:  MOVLB  8
0C14A:  RRCF   xFF,F
0C14C:  INCF   00,F
0C14E:  BTFSC  FD8.2
0C150:  BRA    C2C0
0C152:  BRA    C174
0C154:  MOVLB  9
0C156:  BTFSC  x02.7
0C158:  BRA    C17A
0C15A:  BCF    FD8.0
0C15C:  MOVLB  8
0C15E:  RLCF   xFF,F
0C160:  MOVLB  9
0C162:  RLCF   x00,F
0C164:  RLCF   x01,F
0C166:  RLCF   x02,F
0C168:  DECFSZ 00,F
0C16A:  BRA    C170
0C16C:  MOVLB  8
0C16E:  BRA    C2C0
0C170:  BRA    C156
0C172:  MOVLB  8
0C174:  BSF    xFE.7
0C176:  BRA    C1DE
0C178:  BCF    xFE.7
0C17A:  MOVFF  8F9,8FD
0C17E:  MOVLB  8
0C180:  BTFSS  xF9.7
0C182:  BRA    C18A
0C184:  MOVLB  9
0C186:  BSF    x02.7
0C188:  BRA    C2B0
0C18A:  MOVLB  9
0C18C:  BCF    x02.7
0C18E:  BRA    C2B0
0C190:  MOVFF  8F9,902
0C194:  MOVLB  9
0C196:  BSF    x02.7
0C198:  MOVFF  8FA,901
0C19C:  MOVFF  8FB,900
0C1A0:  MOVLB  8
0C1A2:  BTFSS  xFD.7
0C1A4:  BRA    C1B2
0C1A6:  MOVLB  9
0C1A8:  BCF    x02.7
0C1AA:  MOVLB  8
0C1AC:  BSF    xFE.2
0C1AE:  BRA    C2CE
0C1B0:  BCF    xFE.2
0C1B2:  CLRF   xFF
0C1B4:  BCF    xFC.0
0C1B6:  MOVLW  08
0C1B8:  MOVWF  FEA
0C1BA:  MOVLW  F7
0C1BC:  MOVWF  FE9
0C1BE:  BRA    C308
0C1C0:  BTFSC  xFD.7
0C1C2:  BRA    C21E
0C1C4:  MOVFF  8F5,8FD
0C1C8:  BTFSS  xFC.0
0C1CA:  BRA    C1DE
0C1CC:  MOVLB  9
0C1CE:  RRCF   x02,F
0C1D0:  RRCF   x01,F
0C1D2:  RRCF   x00,F
0C1D4:  MOVLB  8
0C1D6:  RRCF   xFF,F
0C1D8:  INCF   00,F
0C1DA:  BTFSC  FD8.2
0C1DC:  BRA    C2C0
0C1DE:  BTFSS  xFF.7
0C1E0:  BRA    C214
0C1E2:  MOVLB  9
0C1E4:  INCF   x00,F
0C1E6:  BTFSC  FD8.2
0C1E8:  BRA    C1EE
0C1EA:  MOVLB  8
0C1EC:  BRA    C214
0C1EE:  INCF   x01,F
0C1F0:  BTFSC  FD8.2
0C1F2:  BRA    C1F8
0C1F4:  MOVLB  8
0C1F6:  BRA    C214
0C1F8:  INCF   x02,F
0C1FA:  BTFSC  FD8.2
0C1FC:  BRA    C202
0C1FE:  MOVLB  8
0C200:  BRA    C214
0C202:  RRCF   x02,F
0C204:  RRCF   x01,F
0C206:  RRCF   x00,F
0C208:  INCF   00,F
0C20A:  BTFSS  FD8.2
0C20C:  BRA    C212
0C20E:  MOVLB  8
0C210:  BRA    C2C0
0C212:  MOVLB  8
0C214:  BTFSC  xFE.6
0C216:  BRA    C0D2
0C218:  BTFSC  xFE.7
0C21A:  BRA    C178
0C21C:  BRA    C27A
0C21E:  MOVLW  80
0C220:  MOVLB  9
0C222:  XORWF  x02,F
0C224:  BTFSS  x02.7
0C226:  BRA    C234
0C228:  MOVLB  8
0C22A:  BRA    C2CE
0C22C:  MOVFF  8F9,8FD
0C230:  BRA    C25A
0C232:  MOVLB  9
0C234:  MOVFF  8F5,8FD
0C238:  MOVF   x02,F
0C23A:  BTFSC  FD8.2
0C23C:  BRA    C242
0C23E:  MOVLB  8
0C240:  BRA    C25A
0C242:  MOVF   x01,F
0C244:  BTFSC  FD8.2
0C246:  BRA    C24C
0C248:  MOVLB  8
0C24A:  BRA    C25A
0C24C:  MOVF   x00,F
0C24E:  BTFSC  FD8.2
0C250:  BRA    C256
0C252:  MOVLB  8
0C254:  BRA    C25A
0C256:  CLRF   00
0C258:  BRA    C2B0
0C25A:  MOVLB  9
0C25C:  BTFSS  x02.7
0C25E:  BRA    C264
0C260:  MOVLB  8
0C262:  BRA    C27A
0C264:  BCF    FD8.0
0C266:  MOVLB  8
0C268:  RLCF   xFF,F
0C26A:  MOVLB  9
0C26C:  RLCF   x00,F
0C26E:  RLCF   x01,F
0C270:  RLCF   x02,F
0C272:  DECFSZ 00,F
0C274:  BRA    C25C
0C276:  MOVLB  8
0C278:  BRA    C2C0
0C27A:  BTFSS  xFD.7
0C27C:  BRA    C284
0C27E:  MOVLB  9
0C280:  BSF    x02.7
0C282:  BRA    C2B0
0C284:  MOVLB  9
0C286:  BCF    x02.7
0C288:  BRA    C2B0
0C28A:  MOVFF  8F8,00
0C28E:  MOVFF  8F9,902
0C292:  MOVFF  8FA,901
0C296:  MOVFF  8FB,900
0C29A:  MOVLB  9
0C29C:  BRA    C2B0
0C29E:  MOVFF  8F4,00
0C2A2:  MOVFF  8F5,902
0C2A6:  MOVFF  8F6,901
0C2AA:  MOVFF  8F7,900
0C2AE:  MOVLB  9
0C2B0:  MOVFF  902,01
0C2B4:  MOVFF  901,02
0C2B8:  MOVFF  900,03
0C2BC:  BRA    C356
0C2BE:  MOVLB  8
0C2C0:  CLRF   00
0C2C2:  CLRF   01
0C2C4:  CLRF   02
0C2C6:  CLRF   03
0C2C8:  MOVLB  9
0C2CA:  BRA    C356
0C2CC:  MOVLB  8
0C2CE:  CLRF   xFF
0C2D0:  MOVLB  9
0C2D2:  COMF   x00,F
0C2D4:  COMF   x01,F
0C2D6:  COMF   x02,F
0C2D8:  MOVLB  8
0C2DA:  COMF   xFF,F
0C2DC:  INCF   xFF,F
0C2DE:  BNZ   C2FA
0C2E0:  MOVLB  9
0C2E2:  INCF   x00,F
0C2E4:  BTFSC  FD8.2
0C2E6:  BRA    C2EC
0C2E8:  MOVLB  8
0C2EA:  BRA    C2FA
0C2EC:  INCF   x01,F
0C2EE:  BTFSC  FD8.2
0C2F0:  BRA    C2F6
0C2F2:  MOVLB  8
0C2F4:  BRA    C2FA
0C2F6:  INCF   x02,F
0C2F8:  MOVLB  8
0C2FA:  BTFSC  xFE.0
0C2FC:  BRA    C080
0C2FE:  BTFSC  xFE.1
0C300:  BRA    C126
0C302:  BTFSC  xFE.2
0C304:  BRA    C1B0
0C306:  BRA    C22C
0C308:  MOVF   FEF,W
0C30A:  MOVLB  9
0C30C:  ADDWF  x00,F
0C30E:  BNC   C320
0C310:  INCF   x01,F
0C312:  BNZ   C320
0C314:  INCF   x02,F
0C316:  BTFSS  FD8.2
0C318:  BRA    C320
0C31A:  MOVLB  8
0C31C:  BSF    xFC.0
0C31E:  MOVLB  9
0C320:  MOVF   FED,F
0C322:  MOVF   FEF,W
0C324:  ADDWF  x01,F
0C326:  BNC   C334
0C328:  INCF   x02,F
0C32A:  BTFSS  FD8.2
0C32C:  BRA    C334
0C32E:  MOVLB  8
0C330:  BSF    xFC.0
0C332:  MOVLB  9
0C334:  MOVF   FED,F
0C336:  MOVF   FEF,W
0C338:  BTFSC  FEF.7
0C33A:  BRA    C33E
0C33C:  XORLW  80
0C33E:  ADDWF  x02,F
0C340:  BTFSS  FD8.0
0C342:  BRA    C348
0C344:  MOVLB  8
0C346:  BSF    xFC.0
0C348:  MOVLB  8
0C34A:  BTFSC  xFE.4
0C34C:  BRA    C090
0C34E:  BTFSC  xFE.5
0C350:  BRA    C136
0C352:  BRA    C1C0
0C354:  MOVLB  9
0C356:  MOVLB  0
0C358:  RETURN 0
0C35A:  MOVLB  8
0C35C:  MOVF   xB9,W
0C35E:  SUBLW  B6
0C360:  MOVWF  xB9
0C362:  CLRF   03
0C364:  MOVFF  8BA,8BD
0C368:  BSF    xBA.7
0C36A:  BCF    FD8.0
0C36C:  RRCF   xBA,F
0C36E:  RRCF   xBB,F
0C370:  RRCF   xBC,F
0C372:  RRCF   03,F
0C374:  RRCF   02,F
0C376:  RRCF   01,F
0C378:  RRCF   00,F
0C37A:  DECFSZ xB9,F
0C37C:  BRA    C36A
0C37E:  BTFSS  xBD.7
0C380:  BRA    C398
0C382:  COMF   00,F
0C384:  COMF   01,F
0C386:  COMF   02,F
0C388:  COMF   03,F
0C38A:  INCF   00,F
0C38C:  BTFSC  FD8.2
0C38E:  INCF   01,F
0C390:  BTFSC  FD8.2
0C392:  INCF   02,F
0C394:  BTFSC  FD8.2
0C396:  INCF   03,F
0C398:  MOVLB  0
0C39A:  RETURN 0
0C39C:  MOVF   FE9,W
0C39E:  MOVLB  8
0C3A0:  MOVWF  x67
0C3A2:  MOVF   x66,W
0C3A4:  MOVWF  x69
0C3A6:  BZ    C3DE
0C3A8:  MOVFF  865,8F3
0C3AC:  MOVFF  864,8F2
0C3B0:  MOVFF  863,8F1
0C3B4:  MOVFF  862,8F0
0C3B8:  CLRF   xF7
0C3BA:  CLRF   xF6
0C3BC:  MOVLW  20
0C3BE:  MOVWF  xF5
0C3C0:  MOVLW  82
0C3C2:  MOVWF  xF4
0C3C4:  MOVLB  0
0C3C6:  RCALL  BF2C
0C3C8:  MOVFF  03,865
0C3CC:  MOVFF  02,864
0C3D0:  MOVFF  01,863
0C3D4:  MOVFF  00,862
0C3D8:  MOVLB  8
0C3DA:  DECFSZ x69,F
0C3DC:  BRA    C3A8
0C3DE:  MOVLW  7E
0C3E0:  MOVWF  00
0C3E2:  CLRF   01
0C3E4:  BTFSC  x63.7
0C3E6:  BSF    01.7
0C3E8:  CLRF   02
0C3EA:  CLRF   03
0C3EC:  BCF    FD8.1
0C3EE:  MOVFF  865,8F7
0C3F2:  MOVFF  864,8F6
0C3F6:  MOVFF  863,8F5
0C3FA:  MOVFF  862,8F4
0C3FE:  MOVFF  03,8FB
0C402:  MOVFF  02,8FA
0C406:  MOVFF  01,8F9
0C40A:  MOVWF  xF8
0C40C:  MOVLB  0
0C40E:  RCALL  C022
0C410:  MOVFF  03,865
0C414:  MOVFF  02,864
0C418:  MOVFF  01,863
0C41C:  MOVFF  00,862
0C420:  MOVFF  865,8BC
0C424:  MOVFF  864,8BB
0C428:  MOVFF  863,8BA
0C42C:  MOVFF  862,8B9
0C430:  RCALL  C35A
0C432:  MOVFF  03,865
0C436:  MOVFF  02,864
0C43A:  MOVFF  01,863
0C43E:  MOVFF  00,862
0C442:  MOVLB  8
0C444:  BTFSS  x65.7
0C446:  BRA    C462
0C448:  DECF   x67,F
0C44A:  BSF    x67.5
0C44C:  COMF   x62,F
0C44E:  COMF   x63,F
0C450:  COMF   x64,F
0C452:  COMF   x65,F
0C454:  INCF   x62,F
0C456:  BTFSC  FD8.2
0C458:  INCF   x63,F
0C45A:  BTFSC  FD8.2
0C45C:  INCF   x64,F
0C45E:  BTFSC  FD8.2
0C460:  INCF   x65,F
0C462:  MOVLW  3B
0C464:  MOVWF  x6E
0C466:  MOVLW  9A
0C468:  MOVWF  x6D
0C46A:  MOVLW  CA
0C46C:  MOVWF  x6C
0C46E:  CLRF   x6B
0C470:  MOVLW  0A
0C472:  MOVWF  x69
0C474:  MOVF   x66,W
0C476:  BTFSC  FD8.2
0C478:  INCF   x67,F
0C47A:  BSF    FD8.1
0C47C:  MOVLW  08
0C47E:  MOVWF  FEA
0C480:  MOVLW  62
0C482:  MOVWF  FE9
0C484:  CLRF   1B
0C486:  BTFSC  FF2.7
0C488:  BSF    1B.7
0C48A:  BCF    FF2.7
0C48C:  MOVFF  865,A27
0C490:  MOVFF  864,A26
0C494:  MOVFF  863,A25
0C498:  MOVFF  862,A24
0C49C:  MOVFF  86E,A2B
0C4A0:  MOVFF  86D,A2A
0C4A4:  MOVFF  86C,A29
0C4A8:  MOVFF  86B,A28
0C4AC:  MOVLB  0
0C4AE:  CALL   1038
0C4B2:  BTFSC  1B.7
0C4B4:  BSF    FF2.7
0C4B6:  MOVF   01,W
0C4B8:  MOVF   00,F
0C4BA:  BNZ   C4E2
0C4BC:  MOVLB  8
0C4BE:  INCF   x66,W
0C4C0:  SUBWF  x69,W
0C4C2:  BTFSS  FD8.2
0C4C4:  BRA    C4CA
0C4C6:  MOVLB  0
0C4C8:  BRA    C4E2
0C4CA:  MOVF   x67,W
0C4CC:  BZ    C4E8
0C4CE:  ANDLW  0F
0C4D0:  SUBWF  x69,W
0C4D2:  BZ    C4D6
0C4D4:  BC    C54E
0C4D6:  BTFSC  x67.7
0C4D8:  BRA    C54E
0C4DA:  BTFSC  x67.6
0C4DC:  BRA    C4E8
0C4DE:  MOVLW  20
0C4E0:  BRA    C544
0C4E2:  MOVLW  20
0C4E4:  MOVLB  8
0C4E6:  ANDWF  x67,F
0C4E8:  BTFSS  x67.5
0C4EA:  BRA    C506
0C4EC:  BCF    x67.5
0C4EE:  MOVF   x66,W
0C4F0:  BTFSS  FD8.2
0C4F2:  DECF   x67,F
0C4F4:  MOVF   00,W
0C4F6:  MOVWF  x67
0C4F8:  MOVLW  2D
0C4FA:  BTFSS  F9E.4
0C4FC:  BRA    C4FA
0C4FE:  MOVWF  FAD
0C500:  MOVF   x67,W
0C502:  MOVWF  00
0C504:  CLRF   x67
0C506:  MOVF   x66,W
0C508:  SUBWF  x69,W
0C50A:  BNZ   C522
0C50C:  MOVF   00,W
0C50E:  MOVWF  x67
0C510:  MOVLW  2E
0C512:  BTFSS  F9E.4
0C514:  BRA    C512
0C516:  MOVWF  FAD
0C518:  MOVF   x67,W
0C51A:  MOVWF  00
0C51C:  MOVLW  20
0C51E:  ANDWF  x67,F
0C520:  MOVLW  00
0C522:  MOVLW  30
0C524:  BTFSS  x67.5
0C526:  BRA    C544
0C528:  BCF    x67.5
0C52A:  MOVF   x66,W
0C52C:  BTFSS  FD8.2
0C52E:  DECF   x67,F
0C530:  MOVF   00,W
0C532:  MOVWF  x67
0C534:  MOVLW  2D
0C536:  BTFSS  F9E.4
0C538:  BRA    C536
0C53A:  MOVWF  FAD
0C53C:  MOVF   x67,W
0C53E:  MOVWF  00
0C540:  CLRF   x67
0C542:  MOVLW  30
0C544:  ADDWF  00,F
0C546:  MOVF   00,W
0C548:  BTFSS  F9E.4
0C54A:  BRA    C548
0C54C:  MOVWF  FAD
0C54E:  BCF    FD8.1
0C550:  CLRF   1B
0C552:  BTFSC  FF2.7
0C554:  BSF    1B.7
0C556:  BCF    FF2.7
0C558:  MOVFF  86E,A27
0C55C:  MOVFF  86D,A26
0C560:  MOVFF  86C,A25
0C564:  MOVFF  86B,A24
0C568:  MOVLB  A
0C56A:  CLRF   x2B
0C56C:  CLRF   x2A
0C56E:  CLRF   x29
0C570:  MOVLW  0A
0C572:  MOVWF  x28
0C574:  MOVLB  0
0C576:  CALL   1038
0C57A:  BTFSC  1B.7
0C57C:  BSF    FF2.7
0C57E:  MOVFF  03,86E
0C582:  MOVFF  02,86D
0C586:  MOVFF  01,86C
0C58A:  MOVFF  00,86B
0C58E:  MOVLB  8
0C590:  DECFSZ x69,F
0C592:  BRA    C47A
0C594:  MOVLB  0
0C596:  RETURN 0
*
0C61A:  MOVLW  8E
0C61C:  MOVWF  00
0C61E:  MOVFF  8F5,01
0C622:  MOVFF  8F4,02
0C626:  CLRF   03
0C628:  MOVF   01,F
0C62A:  BNZ   C63E
0C62C:  MOVFF  02,01
0C630:  CLRF   02
0C632:  MOVLW  08
0C634:  SUBWF  00,F
0C636:  MOVF   01,F
0C638:  BNZ   C63E
0C63A:  CLRF   00
0C63C:  BRA    C64E
0C63E:  BCF    FD8.0
0C640:  BTFSC  01.7
0C642:  BRA    C64C
0C644:  RLCF   02,F
0C646:  RLCF   01,F
0C648:  DECF   00,F
0C64A:  BRA    C63E
0C64C:  BCF    01.7
0C64E:  RETURN 0
0C650:  MOVLB  8
0C652:  MOVF   xD8,W
0C654:  BTFSC  FD8.2
0C656:  BRA    C7A2
0C658:  MOVWF  xE4
0C65A:  MOVF   xDC,W
0C65C:  BTFSC  FD8.2
0C65E:  BRA    C7A2
0C660:  SUBWF  xE4,F
0C662:  BNC   C66E
0C664:  MOVLW  7F
0C666:  ADDWF  xE4,F
0C668:  BTFSC  FD8.0
0C66A:  BRA    C7A2
0C66C:  BRA    C67A
0C66E:  MOVLW  81
0C670:  SUBWF  xE4,F
0C672:  BTFSS  FD8.0
0C674:  BRA    C7A2
0C676:  BTFSC  FD8.2
0C678:  BRA    C7A2
0C67A:  MOVFF  8E4,00
0C67E:  CLRF   01
0C680:  CLRF   02
0C682:  CLRF   03
0C684:  CLRF   xE3
0C686:  MOVFF  8D9,8E2
0C68A:  BSF    xE2.7
0C68C:  MOVFF  8DA,8E1
0C690:  MOVFF  8DB,8E0
0C694:  MOVLW  19
0C696:  MOVWF  xE4
0C698:  MOVF   xDF,W
0C69A:  SUBWF  xE0,F
0C69C:  BC    C6B8
0C69E:  MOVLW  01
0C6A0:  SUBWF  xE1,F
0C6A2:  BC    C6B8
0C6A4:  SUBWF  xE2,F
0C6A6:  BC    C6B8
0C6A8:  SUBWF  xE3,F
0C6AA:  BC    C6B8
0C6AC:  INCF   xE3,F
0C6AE:  INCF   xE2,F
0C6B0:  INCF   xE1,F
0C6B2:  MOVF   xDF,W
0C6B4:  ADDWF  xE0,F
0C6B6:  BRA    C708
0C6B8:  MOVF   xDE,W
0C6BA:  SUBWF  xE1,F
0C6BC:  BC    C6E2
0C6BE:  MOVLW  01
0C6C0:  SUBWF  xE2,F
0C6C2:  BC    C6E2
0C6C4:  SUBWF  xE3,F
0C6C6:  BC    C6E2
0C6C8:  INCF   xE3,F
0C6CA:  INCF   xE2,F
0C6CC:  MOVF   xDE,W
0C6CE:  ADDWF  xE1,F
0C6D0:  MOVF   xDF,W
0C6D2:  ADDWF  xE0,F
0C6D4:  BNC   C708
0C6D6:  INCF   xE1,F
0C6D8:  BNZ   C708
0C6DA:  INCF   xE2,F
0C6DC:  BNZ   C708
0C6DE:  INCF   xE3,F
0C6E0:  BRA    C708
0C6E2:  MOVF   xDD,W
0C6E4:  IORLW  80
0C6E6:  SUBWF  xE2,F
0C6E8:  BC    C706
0C6EA:  MOVLW  01
0C6EC:  SUBWF  xE3,F
0C6EE:  BC    C706
0C6F0:  INCF   xE3,F
0C6F2:  MOVF   xDD,W
0C6F4:  IORLW  80
0C6F6:  ADDWF  xE2,F
0C6F8:  MOVF   xDE,W
0C6FA:  ADDWF  xE1,F
0C6FC:  BNC   C6D0
0C6FE:  INCF   xE2,F
0C700:  BNZ   C6D0
0C702:  INCF   xE3,F
0C704:  BRA    C6D0
0C706:  BSF    03.0
0C708:  DECFSZ xE4,F
0C70A:  BRA    C70E
0C70C:  BRA    C724
0C70E:  BCF    FD8.0
0C710:  RLCF   xE0,F
0C712:  RLCF   xE1,F
0C714:  RLCF   xE2,F
0C716:  RLCF   xE3,F
0C718:  BCF    FD8.0
0C71A:  RLCF   03,F
0C71C:  RLCF   02,F
0C71E:  RLCF   01,F
0C720:  RLCF   xE5,F
0C722:  BRA    C698
0C724:  BTFSS  xE5.0
0C726:  BRA    C734
0C728:  BCF    FD8.0
0C72A:  RRCF   01,F
0C72C:  RRCF   02,F
0C72E:  RRCF   03,F
0C730:  RRCF   xE5,F
0C732:  BRA    C738
0C734:  DECF   00,F
0C736:  BZ    C7A2
0C738:  BTFSC  xE5.7
0C73A:  BRA    C778
0C73C:  BCF    FD8.0
0C73E:  RLCF   xE0,F
0C740:  RLCF   xE1,F
0C742:  RLCF   xE2,F
0C744:  RLCF   xE3,F
0C746:  MOVF   xDF,W
0C748:  SUBWF  xE0,F
0C74A:  BC    C75A
0C74C:  MOVLW  01
0C74E:  SUBWF  xE1,F
0C750:  BC    C75A
0C752:  SUBWF  xE2,F
0C754:  BC    C75A
0C756:  SUBWF  xE3,F
0C758:  BNC   C78E
0C75A:  MOVF   xDE,W
0C75C:  SUBWF  xE1,F
0C75E:  BC    C76A
0C760:  MOVLW  01
0C762:  SUBWF  xE2,F
0C764:  BC    C76A
0C766:  SUBWF  xE3,F
0C768:  BNC   C78E
0C76A:  MOVF   xDD,W
0C76C:  IORLW  80
0C76E:  SUBWF  xE2,F
0C770:  BC    C778
0C772:  MOVLW  01
0C774:  SUBWF  xE3,F
0C776:  BNC   C78E
0C778:  INCF   03,F
0C77A:  BNZ   C78E
0C77C:  INCF   02,F
0C77E:  BNZ   C78E
0C780:  INCF   01,F
0C782:  BNZ   C78E
0C784:  INCF   00,F
0C786:  BZ    C7A2
0C788:  RRCF   01,F
0C78A:  RRCF   02,F
0C78C:  RRCF   03,F
0C78E:  MOVFF  8D9,8E4
0C792:  MOVF   xDD,W
0C794:  XORWF  xE4,F
0C796:  BTFSS  xE4.7
0C798:  BRA    C79E
0C79A:  BSF    01.7
0C79C:  BRA    C7AA
0C79E:  BCF    01.7
0C7A0:  BRA    C7AA
0C7A2:  CLRF   00
0C7A4:  CLRF   01
0C7A6:  CLRF   02
0C7A8:  CLRF   03
0C7AA:  MOVLB  0
0C7AC:  RETURN 0
*
0D238:  MOVFF  FEA,8A6
0D23C:  MOVFF  FE9,8A5
0D240:  MOVLB  8
0D242:  BTFSS  x9F.7
0D244:  BRA    D256
0D246:  BSF    xA5.7
0D248:  BTFSS  xA5.4
0D24A:  INCF   xA5,F
0D24C:  COMF   x9E,F
0D24E:  COMF   x9F,F
0D250:  INCF   x9E,F
0D252:  BTFSC  FD8.2
0D254:  INCF   x9F,F
0D256:  SWAPF  x9F,W
0D258:  IORLW  F0
0D25A:  MOVWF  xA1
0D25C:  ADDWF  xA1,F
0D25E:  ADDLW  E2
0D260:  MOVWF  xA2
0D262:  ADDLW  32
0D264:  MOVWF  xA4
0D266:  MOVF   x9F,W
0D268:  ANDLW  0F
0D26A:  ADDWF  xA2,F
0D26C:  ADDWF  xA2,F
0D26E:  ADDWF  xA4,F
0D270:  ADDLW  E9
0D272:  MOVWF  xA3
0D274:  ADDWF  xA3,F
0D276:  ADDWF  xA3,F
0D278:  SWAPF  x9E,W
0D27A:  ANDLW  0F
0D27C:  ADDWF  xA3,F
0D27E:  ADDWF  xA4,F
0D280:  RLCF   xA3,F
0D282:  RLCF   xA4,F
0D284:  COMF   xA4,F
0D286:  RLCF   xA4,F
0D288:  MOVF   x9E,W
0D28A:  ANDLW  0F
0D28C:  ADDWF  xA4,F
0D28E:  RLCF   xA1,F
0D290:  MOVLW  07
0D292:  MOVWF  xA0
0D294:  MOVLW  0A
0D296:  DECF   xA3,F
0D298:  ADDWF  xA4,F
0D29A:  BNC   D296
0D29C:  DECF   xA2,F
0D29E:  ADDWF  xA3,F
0D2A0:  BNC   D29C
0D2A2:  DECF   xA1,F
0D2A4:  ADDWF  xA2,F
0D2A6:  BNC   D2A2
0D2A8:  DECF   xA0,F
0D2AA:  ADDWF  xA1,F
0D2AC:  BNC   D2A8
0D2AE:  MOVLW  08
0D2B0:  MOVWF  FEA
0D2B2:  MOVLW  A0
0D2B4:  MOVWF  FE9
0D2B6:  MOVLW  07
0D2B8:  ANDWF  xA5,W
0D2BA:  BCF    xA5.6
0D2BC:  MOVF   FED,F
0D2BE:  ANDWF  xA5,W
0D2C0:  BNZ   D2D0
0D2C2:  BTFSC  xA5.4
0D2C4:  MOVF   FEE,F
0D2C6:  BTFSC  xA5.4
0D2C8:  BRA    D2D0
0D2CA:  MOVLW  20
0D2CC:  MOVWF  00
0D2CE:  BRA    D312
0D2D0:  ADDWF  FE9,F
0D2D2:  MOVLW  00
0D2D4:  ADDWFC FEA,F
0D2D6:  MOVF   FE9,W
0D2D8:  SUBLW  A4
0D2DA:  BNZ   D2E4
0D2DC:  MOVF   FEA,W
0D2DE:  SUBLW  08
0D2E0:  BNZ   D2E4
0D2E2:  BSF    xA5.6
0D2E4:  MOVF   FEF,W
0D2E6:  MOVWF  00
0D2E8:  BNZ   D2FA
0D2EA:  BTFSC  xA5.6
0D2EC:  BRA    D2FA
0D2EE:  BTFSC  xA5.4
0D2F0:  BRA    D32E
0D2F2:  BTFSC  xA5.3
0D2F4:  BRA    D2FA
0D2F6:  MOVLW  20
0D2F8:  BRA    D310
0D2FA:  BTFSS  xA5.7
0D2FC:  BRA    D30A
0D2FE:  MOVLW  2D
0D300:  MOVWF  00
0D302:  MOVF   FED,W
0D304:  BCF    xA5.6
0D306:  BCF    xA5.7
0D308:  BRA    D312
0D30A:  BSF    xA5.3
0D30C:  BCF    xA5.4
0D30E:  MOVLW  30
0D310:  ADDWF  00,F
0D312:  MOVFF  FEA,89F
0D316:  MOVFF  FE9,89E
0D31A:  MOVFF  00,8DC
0D31E:  MOVLB  0
0D320:  CALL   5016
0D324:  MOVFF  89F,FEA
0D328:  MOVFF  89E,FE9
0D32C:  MOVLB  8
0D32E:  MOVF   FEE,W
0D330:  BTFSS  xA5.6
0D332:  BRA    D2D6
0D334:  MOVLB  0
0D336:  GOTO   D45A (RETURN)
*
0D6DE:  ADDWF  FE8,W
0D6E0:  CLRF   FF7
0D6E2:  RLCF   FF7,F
0D6E4:  ADDLW  FF
0D6E6:  MOVWF  FF6
0D6E8:  MOVLW  D6
0D6EA:  ADDWFC FF7,F
0D6EC:  MOVLW  00
0D6EE:  MOVWF  FF8
0D6F0:  MOVWF  FFB
0D6F2:  TBLRD*-
0D6F4:  MOVF   FF5,W
0D6F6:  MOVWF  FFA
0D6F8:  TBLRD*
0D6FA:  MOVF   FF5,W
0D6FC:  MOVWF  FF9
0D6FE:  DATA 10,D6
0D700:  DATA 38,D6
0D702:  DATA 58,D6
0D704:  DATA 78,D6
0D706:  DATA 98,D6
0D708:  DATA B8,D6
*
0D788:  TBLRD*+
0D78A:  MOVFF  FF6,896
0D78E:  MOVFF  FF7,897
0D792:  MOVFF  FF8,898
0D796:  MOVF   FF5,W
0D798:  BTFSS  FA4.4
0D79A:  BRA    D798
0D79C:  MOVLB  F
0D79E:  MOVWF  x1C
0D7A0:  MOVFF  896,FF6
0D7A4:  MOVFF  897,FF7
0D7A8:  MOVFF  898,FF8
0D7AC:  MOVLB  8
0D7AE:  DECFSZ x95,F
0D7B0:  BRA    D7B4
0D7B2:  BRA    D7B8
0D7B4:  MOVLB  0
0D7B6:  BRA    D788
0D7B8:  MOVLB  0
0D7BA:  RETURN 0
0D7BC:  MOVF   01,W
0D7BE:  CLRF   1B
0D7C0:  BTFSC  FF2.7
0D7C2:  BSF    1B.7
0D7C4:  BCF    FF2.7
0D7C6:  MOVFF  8D0,A1A
0D7CA:  MOVLW  64
0D7CC:  MOVLB  A
0D7CE:  MOVWF  x1B
0D7D0:  MOVLB  0
0D7D2:  CALL   0F5C
0D7D6:  BTFSC  1B.7
0D7D8:  BSF    FF2.7
0D7DA:  MOVFF  00,8D0
0D7DE:  MOVF   01,W
0D7E0:  MOVLW  30
0D7E2:  BNZ   D7F4
0D7E4:  MOVLB  8
0D7E6:  BTFSS  xD1.1
0D7E8:  BRA    D80A
0D7EA:  BTFSC  xD1.3
0D7EC:  BRA    D80A
0D7EE:  BTFSC  xD1.4
0D7F0:  MOVLW  20
0D7F2:  BRA    D7FC
0D7F4:  MOVLB  8
0D7F6:  BCF    xD1.3
0D7F8:  BCF    xD1.4
0D7FA:  BSF    xD1.0
0D7FC:  ADDWF  01,F
0D7FE:  MOVF   01,W
0D800:  BTFSS  FA4.4
0D802:  BRA    D800
0D804:  MOVLB  F
0D806:  MOVWF  x1C
0D808:  MOVLB  8
0D80A:  CLRF   1B
0D80C:  BTFSC  FF2.7
0D80E:  BSF    1B.7
0D810:  BCF    FF2.7
0D812:  MOVFF  8D0,A1A
0D816:  MOVLW  0A
0D818:  MOVLB  A
0D81A:  MOVWF  x1B
0D81C:  MOVLB  0
0D81E:  CALL   0F5C
0D822:  BTFSC  1B.7
0D824:  BSF    FF2.7
0D826:  MOVFF  00,8D0
0D82A:  MOVF   01,W
0D82C:  MOVLW  30
0D82E:  BNZ   D840
0D830:  MOVLB  8
0D832:  BTFSC  xD1.3
0D834:  BRA    D84E
0D836:  BTFSS  xD1.0
0D838:  BRA    D84E
0D83A:  BTFSC  xD1.4
0D83C:  MOVLW  20
0D83E:  MOVLB  0
0D840:  ADDWF  01,F
0D842:  MOVF   01,W
0D844:  BTFSS  FA4.4
0D846:  BRA    D844
0D848:  MOVLB  F
0D84A:  MOVWF  x1C
0D84C:  MOVLB  8
0D84E:  MOVLW  30
0D850:  ADDWF  xD0,F
0D852:  MOVF   xD0,W
0D854:  BTFSS  FA4.4
0D856:  BRA    D854
0D858:  MOVLB  F
0D85A:  MOVWF  x1C
0D85C:  MOVLB  0
0D85E:  RETURN 0
*
0D882:  TBLRD*+
0D884:  MOVF   FF5,F
0D886:  BZ    D8AE
0D888:  MOVFF  FF6,894
0D88C:  MOVFF  FF7,895
0D890:  MOVFF  FF8,896
0D894:  MOVF   FF5,W
0D896:  BTFSS  FA4.4
0D898:  BRA    D896
0D89A:  MOVLB  F
0D89C:  MOVWF  x1C
0D89E:  MOVFF  894,FF6
0D8A2:  MOVFF  895,FF7
0D8A6:  MOVFF  896,FF8
0D8AA:  MOVLB  0
0D8AC:  BRA    D882
0D8AE:  GOTO   D970 (RETURN)
*
0DE86:  MOVF   FE9,W
0DE88:  MOVLB  8
0DE8A:  MOVWF  x69
0DE8C:  MOVLW  3B
0DE8E:  MOVWF  x70
0DE90:  MOVLW  9A
0DE92:  MOVWF  x6F
0DE94:  MOVLW  CA
0DE96:  MOVWF  x6E
0DE98:  CLRF   x6D
0DE9A:  MOVLW  0A
0DE9C:  MOVWF  x6B
0DE9E:  MOVF   x68,W
0DEA0:  BTFSS  FD8.2
0DEA2:  DECF   x69,F
0DEA4:  BSF    FD8.1
0DEA6:  MOVLW  08
0DEA8:  MOVWF  FEA
0DEAA:  MOVLW  64
0DEAC:  MOVWF  FE9
0DEAE:  CLRF   1B
0DEB0:  BTFSC  FF2.7
0DEB2:  BSF    1B.7
0DEB4:  BCF    FF2.7
0DEB6:  MOVFF  867,A27
0DEBA:  MOVFF  866,A26
0DEBE:  MOVFF  865,A25
0DEC2:  MOVFF  864,A24
0DEC6:  MOVFF  870,A2B
0DECA:  MOVFF  86F,A2A
0DECE:  MOVFF  86E,A29
0DED2:  MOVFF  86D,A28
0DED6:  MOVLB  0
0DED8:  CALL   1038
0DEDC:  BTFSC  1B.7
0DEDE:  BSF    FF2.7
0DEE0:  MOVF   01,W
0DEE2:  MOVF   00,F
0DEE4:  BNZ   DF0C
0DEE6:  MOVLB  8
0DEE8:  INCF   x68,W
0DEEA:  SUBWF  x6B,W
0DEEC:  BTFSS  FD8.2
0DEEE:  BRA    DEF4
0DEF0:  MOVLB  0
0DEF2:  BRA    DF0C
0DEF4:  MOVF   x69,W
0DEF6:  BZ    DF10
0DEF8:  ANDLW  0F
0DEFA:  SUBWF  x6B,W
0DEFC:  BZ    DF00
0DEFE:  BC    DF38
0DF00:  BTFSC  x69.7
0DF02:  BRA    DF38
0DF04:  BTFSC  x69.6
0DF06:  BRA    DF10
0DF08:  MOVLW  20
0DF0A:  BRA    DF2E
0DF0C:  MOVLB  8
0DF0E:  CLRF   x69
0DF10:  MOVF   x68,W
0DF12:  SUBWF  x6B,W
0DF14:  BNZ   DF2C
0DF16:  MOVFF  00,869
0DF1A:  MOVLW  2E
0DF1C:  BTFSS  F9E.4
0DF1E:  BRA    DF1C
0DF20:  MOVWF  FAD
0DF22:  MOVFF  869,00
0DF26:  MOVLW  20
0DF28:  ANDWF  x69,F
0DF2A:  MOVLW  00
0DF2C:  MOVLW  30
0DF2E:  ADDWF  00,F
0DF30:  MOVF   00,W
0DF32:  BTFSS  F9E.4
0DF34:  BRA    DF32
0DF36:  MOVWF  FAD
0DF38:  BCF    FD8.1
0DF3A:  CLRF   1B
0DF3C:  BTFSC  FF2.7
0DF3E:  BSF    1B.7
0DF40:  BCF    FF2.7
0DF42:  MOVFF  870,A27
0DF46:  MOVFF  86F,A26
0DF4A:  MOVFF  86E,A25
0DF4E:  MOVFF  86D,A24
0DF52:  MOVLB  A
0DF54:  CLRF   x2B
0DF56:  CLRF   x2A
0DF58:  CLRF   x29
0DF5A:  MOVLW  0A
0DF5C:  MOVWF  x28
0DF5E:  MOVLB  0
0DF60:  CALL   1038
0DF64:  BTFSC  1B.7
0DF66:  BSF    FF2.7
0DF68:  MOVFF  03,870
0DF6C:  MOVFF  02,86F
0DF70:  MOVFF  01,86E
0DF74:  MOVFF  00,86D
0DF78:  MOVLB  8
0DF7A:  DECFSZ x6B,F
0DF7C:  BRA    DEA4
0DF7E:  MOVLB  0
0DF80:  RETURN 0
*
0F01A:  MOVF   FE9,W
0F01C:  MOVLB  8
0F01E:  MOVWF  xD4
0F020:  MOVLW  3B
0F022:  MOVWF  xDB
0F024:  MOVLW  9A
0F026:  MOVWF  xDA
0F028:  MOVLW  CA
0F02A:  MOVWF  xD9
0F02C:  CLRF   xD8
0F02E:  MOVLW  0A
0F030:  MOVWF  xD6
0F032:  BSF    FD8.1
0F034:  MOVLW  08
0F036:  MOVWF  FEA
0F038:  MOVLW  D0
0F03A:  MOVWF  FE9
0F03C:  CLRF   1B
0F03E:  BTFSC  FF2.7
0F040:  BSF    1B.7
0F042:  BCF    FF2.7
0F044:  MOVFF  8D3,A27
0F048:  MOVFF  8D2,A26
0F04C:  MOVFF  8D1,A25
0F050:  MOVFF  8D0,A24
0F054:  MOVFF  8DB,A2B
0F058:  MOVFF  8DA,A2A
0F05C:  MOVFF  8D9,A29
0F060:  MOVFF  8D8,A28
0F064:  MOVLB  0
0F066:  CALL   1038
0F06A:  BTFSC  1B.7
0F06C:  BSF    FF2.7
0F06E:  MOVF   01,W
0F070:  MOVF   00,F
0F072:  BNZ   F09A
0F074:  MOVLB  8
0F076:  MOVF   xD6,W
0F078:  XORLW  01
0F07A:  BTFSS  FD8.2
0F07C:  BRA    F082
0F07E:  MOVLB  0
0F080:  BRA    F09A
0F082:  MOVF   xD4,W
0F084:  BZ    F09E
0F086:  ANDLW  0F
0F088:  SUBWF  xD6,W
0F08A:  BZ    F08E
0F08C:  BC    F0AE
0F08E:  BTFSC  xD4.7
0F090:  BRA    F0AE
0F092:  BTFSC  xD4.6
0F094:  BRA    F09E
0F096:  MOVLW  20
0F098:  BRA    F0A0
0F09A:  MOVLB  8
0F09C:  CLRF   xD4
0F09E:  MOVLW  30
0F0A0:  ADDWF  00,F
0F0A2:  MOVF   00,W
0F0A4:  BTFSS  FA4.4
0F0A6:  BRA    F0A4
0F0A8:  MOVLB  F
0F0AA:  MOVWF  x1C
0F0AC:  MOVLB  8
0F0AE:  BCF    FD8.1
0F0B0:  CLRF   1B
0F0B2:  BTFSC  FF2.7
0F0B4:  BSF    1B.7
0F0B6:  BCF    FF2.7
0F0B8:  MOVFF  8DB,A27
0F0BC:  MOVFF  8DA,A26
0F0C0:  MOVFF  8D9,A25
0F0C4:  MOVFF  8D8,A24
0F0C8:  MOVLB  A
0F0CA:  CLRF   x2B
0F0CC:  CLRF   x2A
0F0CE:  CLRF   x29
0F0D0:  MOVLW  0A
0F0D2:  MOVWF  x28
0F0D4:  MOVLB  0
0F0D6:  CALL   1038
0F0DA:  BTFSC  1B.7
0F0DC:  BSF    FF2.7
0F0DE:  MOVFF  03,8DB
0F0E2:  MOVFF  02,8DA
0F0E6:  MOVFF  01,8D9
0F0EA:  MOVFF  00,8D8
0F0EE:  MOVLB  8
0F0F0:  DECFSZ xD6,F
0F0F2:  BRA    F032
0F0F4:  MOVLB  0
0F0F6:  GOTO   F220 (RETURN)
*
0F2F0:  ADDWF  FE8,W
0F2F2:  CLRF   FF7
0F2F4:  RLCF   FF7,F
0F2F6:  ADDLW  11
0F2F8:  MOVWF  FF6
0F2FA:  MOVLW  F3
0F2FC:  ADDWFC FF7,F
0F2FE:  MOVLW  00
0F300:  MOVWF  FF8
0F302:  MOVWF  FFB
0F304:  TBLRD*-
0F306:  MOVF   FF5,W
0F308:  MOVWF  FFA
0F30A:  TBLRD*
0F30C:  MOVF   FF5,W
0F30E:  MOVWF  FF9
0F310:  DATA B0,F2
0F312:  DATA B8,F2
0F314:  DATA C0,F2
0F316:  DATA C8,F2
*
0FB26:  MOVF   FEF,F
0FB28:  BZ    FB4A
0FB2A:  MOVFF  FEA,8C9
0FB2E:  MOVFF  FE9,8C8
0FB32:  MOVFF  FEF,8DC
0FB36:  CALL   5016
0FB3A:  MOVFF  8C9,FEA
0FB3E:  MOVFF  8C8,FE9
0FB42:  INCF   FE9,F
0FB44:  BTFSC  FD8.2
0FB46:  INCF   FEA,F
0FB48:  BRA    FB26
0FB4A:  RETURN 0
0FB4C:  MOVFF  FEA,FE2
0FB50:  MOVFF  FE9,FE1
0FB54:  CLRF   01
0FB56:  BSF    00.0
0FB58:  TBLRD*+
0FB5A:  MOVF   FF5,W
0FB5C:  BTFSS  00.0
0FB5E:  BRA    FB6A
0FB60:  SUBWF  FEE,W
0FB62:  BNZ   FB6A
0FB64:  MOVF   FF5,F
0FB66:  BNZ   FB58
0FB68:  BRA    FB84
0FB6A:  BCF    00.0
0FB6C:  MOVF   FF5,F
0FB6E:  BNZ   FB58
0FB70:  INCF   01,F
0FB72:  BSF    00.0
0FB74:  MOVFF  FE2,FEA
0FB78:  MOVFF  FE1,FE9
0FB7C:  TBLRD*
0FB7E:  MOVF   FF5,F
0FB80:  BNZ   FB58
0FB82:  SETF   01
0FB84:  RETURN 0
*
10460:  MOVFF  8F1,8F8
10464:  MOVLB  8
10466:  MOVF   xF5,W
10468:  XORWF  xF8,F
1046A:  BTFSS  xF8.7
1046C:  BRA    10478
1046E:  BCF    FD8.2
10470:  BCF    FD8.0
10472:  BTFSC  xF1.7
10474:  BSF    FD8.0
10476:  BRA    104D6
10478:  MOVFF  8F1,8F8
1047C:  MOVFF  8F4,8F9
10480:  MOVF   xF0,W
10482:  SUBWF  xF9,F
10484:  BZ    10492
10486:  BTFSS  xF8.7
10488:  BRA    104D6
1048A:  MOVF   FD8,W
1048C:  XORLW  01
1048E:  MOVWF  FD8
10490:  BRA    104D6
10492:  MOVFF  8F5,8F9
10496:  MOVF   xF1,W
10498:  SUBWF  xF9,F
1049A:  BZ    104A8
1049C:  BTFSS  xF8.7
1049E:  BRA    104D6
104A0:  MOVF   FD8,W
104A2:  XORLW  01
104A4:  MOVWF  FD8
104A6:  BRA    104D6
104A8:  MOVFF  8F6,8F9
104AC:  MOVF   xF2,W
104AE:  SUBWF  xF9,F
104B0:  BZ    104BE
104B2:  BTFSS  xF8.7
104B4:  BRA    104D6
104B6:  MOVF   FD8,W
104B8:  XORLW  01
104BA:  MOVWF  FD8
104BC:  BRA    104D6
104BE:  MOVFF  8F7,8F9
104C2:  MOVF   xF3,W
104C4:  SUBWF  xF9,F
104C6:  BZ    104D4
104C8:  BTFSS  xF8.7
104CA:  BRA    104D6
104CC:  MOVF   FD8,W
104CE:  XORLW  01
104D0:  MOVWF  FD8
104D2:  BRA    104D6
104D4:  BCF    FD8.0
104D6:  MOVLB  0
104D8:  RETURN 0
104DA:  MOVLW  8E
104DC:  MOVWF  00
104DE:  MOVFF  8CA,01
104E2:  MOVFF  8C9,02
104E6:  CLRF   03
104E8:  BTFSS  01.7
104EA:  BRA    104F6
104EC:  COMF   01,F
104EE:  COMF   02,F
104F0:  INCF   02,F
104F2:  BNZ   104F6
104F4:  INCF   01,F
104F6:  MOVF   01,F
104F8:  BNZ   1050C
104FA:  MOVFF  02,01
104FE:  CLRF   02
10500:  MOVLW  08
10502:  SUBWF  00,F
10504:  MOVF   01,F
10506:  BNZ   1050C
10508:  CLRF   00
1050A:  BRA    10528
1050C:  BCF    FD8.0
1050E:  BTFSC  01.7
10510:  BRA    1051A
10512:  RLCF   02,F
10514:  RLCF   01,F
10516:  DECF   00,F
10518:  BRA    1050C
1051A:  MOVLB  8
1051C:  BTFSS  xCA.7
1051E:  BRA    10524
10520:  MOVLB  0
10522:  BRA    10528
10524:  BCF    01.7
10526:  MOVLB  0
10528:  RETURN 0
*
10926:  MOVF   FE9,W
10928:  MOVLB  8
1092A:  MOVWF  xB1
1092C:  MOVF   xB0,W
1092E:  MOVWF  xB3
10930:  BZ    1096A
10932:  MOVFF  8AF,8F3
10936:  MOVFF  8AE,8F2
1093A:  MOVFF  8AD,8F1
1093E:  MOVFF  8AC,8F0
10942:  CLRF   xF7
10944:  CLRF   xF6
10946:  MOVLW  20
10948:  MOVWF  xF5
1094A:  MOVLW  82
1094C:  MOVWF  xF4
1094E:  MOVLB  0
10950:  CALL   BF2C
10954:  MOVFF  03,8AF
10958:  MOVFF  02,8AE
1095C:  MOVFF  01,8AD
10960:  MOVFF  00,8AC
10964:  MOVLB  8
10966:  DECFSZ xB3,F
10968:  BRA    10932
1096A:  MOVLW  7E
1096C:  MOVWF  00
1096E:  CLRF   01
10970:  BTFSC  xAD.7
10972:  BSF    01.7
10974:  CLRF   02
10976:  CLRF   03
10978:  BCF    FD8.1
1097A:  MOVFF  8AF,8F7
1097E:  MOVFF  8AE,8F6
10982:  MOVFF  8AD,8F5
10986:  MOVFF  8AC,8F4
1098A:  MOVFF  03,8FB
1098E:  MOVFF  02,8FA
10992:  MOVFF  01,8F9
10996:  MOVWF  xF8
10998:  MOVLB  0
1099A:  CALL   C022
1099E:  MOVFF  03,8AF
109A2:  MOVFF  02,8AE
109A6:  MOVFF  01,8AD
109AA:  MOVFF  00,8AC
109AE:  MOVFF  8AF,8BC
109B2:  MOVFF  8AE,8BB
109B6:  MOVFF  8AD,8BA
109BA:  MOVFF  8AC,8B9
109BE:  CALL   C35A
109C2:  MOVFF  03,8AF
109C6:  MOVFF  02,8AE
109CA:  MOVFF  01,8AD
109CE:  MOVFF  00,8AC
109D2:  MOVLB  8
109D4:  BTFSS  xAF.7
109D6:  BRA    109F2
109D8:  DECF   xB1,F
109DA:  BSF    xB1.5
109DC:  COMF   xAC,F
109DE:  COMF   xAD,F
109E0:  COMF   xAE,F
109E2:  COMF   xAF,F
109E4:  INCF   xAC,F
109E6:  BTFSC  FD8.2
109E8:  INCF   xAD,F
109EA:  BTFSC  FD8.2
109EC:  INCF   xAE,F
109EE:  BTFSC  FD8.2
109F0:  INCF   xAF,F
109F2:  MOVLW  3B
109F4:  MOVWF  xB8
109F6:  MOVLW  9A
109F8:  MOVWF  xB7
109FA:  MOVLW  CA
109FC:  MOVWF  xB6
109FE:  CLRF   xB5
10A00:  MOVLW  0A
10A02:  MOVWF  xB3
10A04:  MOVF   xB0,W
10A06:  BTFSC  FD8.2
10A08:  INCF   xB1,F
10A0A:  BSF    FD8.1
10A0C:  MOVLW  08
10A0E:  MOVWF  FEA
10A10:  MOVLW  AC
10A12:  MOVWF  FE9
10A14:  CLRF   1B
10A16:  BTFSC  FF2.7
10A18:  BSF    1B.7
10A1A:  BCF    FF2.7
10A1C:  MOVFF  8AF,A27
10A20:  MOVFF  8AE,A26
10A24:  MOVFF  8AD,A25
10A28:  MOVFF  8AC,A24
10A2C:  MOVFF  8B8,A2B
10A30:  MOVFF  8B7,A2A
10A34:  MOVFF  8B6,A29
10A38:  MOVFF  8B5,A28
10A3C:  MOVLB  0
10A3E:  CALL   1038
10A42:  BTFSC  1B.7
10A44:  BSF    FF2.7
10A46:  MOVF   01,W
10A48:  MOVF   00,F
10A4A:  BNZ   10A72
10A4C:  MOVLB  8
10A4E:  INCF   xB0,W
10A50:  SUBWF  xB3,W
10A52:  BTFSS  FD8.2
10A54:  BRA    10A5A
10A56:  MOVLB  0
10A58:  BRA    10A72
10A5A:  MOVF   xB1,W
10A5C:  BZ    10A78
10A5E:  ANDLW  0F
10A60:  SUBWF  xB3,W
10A62:  BZ    10A66
10A64:  BC    10AEE
10A66:  BTFSC  xB1.7
10A68:  BRA    10AEE
10A6A:  BTFSC  xB1.6
10A6C:  BRA    10A78
10A6E:  MOVLW  20
10A70:  BRA    10AE0
10A72:  MOVLW  20
10A74:  MOVLB  8
10A76:  ANDWF  xB1,F
10A78:  BTFSS  xB1.5
10A7A:  BRA    10A9A
10A7C:  BCF    xB1.5
10A7E:  MOVF   xB0,W
10A80:  BTFSS  FD8.2
10A82:  DECF   xB1,F
10A84:  MOVF   00,W
10A86:  MOVWF  xB1
10A88:  MOVLW  2D
10A8A:  MOVWF  xDC
10A8C:  MOVLB  0
10A8E:  CALL   5016
10A92:  MOVLB  8
10A94:  MOVF   xB1,W
10A96:  MOVWF  00
10A98:  CLRF   xB1
10A9A:  MOVF   xB0,W
10A9C:  SUBWF  xB3,W
10A9E:  BNZ   10ABA
10AA0:  MOVF   00,W
10AA2:  MOVWF  xB1
10AA4:  MOVLW  2E
10AA6:  MOVWF  xDC
10AA8:  MOVLB  0
10AAA:  CALL   5016
10AAE:  MOVLB  8
10AB0:  MOVF   xB1,W
10AB2:  MOVWF  00
10AB4:  MOVLW  20
10AB6:  ANDWF  xB1,F
10AB8:  MOVLW  00
10ABA:  MOVLW  30
10ABC:  BTFSS  xB1.5
10ABE:  BRA    10AE0
10AC0:  BCF    xB1.5
10AC2:  MOVF   xB0,W
10AC4:  BTFSS  FD8.2
10AC6:  DECF   xB1,F
10AC8:  MOVF   00,W
10ACA:  MOVWF  xB1
10ACC:  MOVLW  2D
10ACE:  MOVWF  xDC
10AD0:  MOVLB  0
10AD2:  CALL   5016
10AD6:  MOVLB  8
10AD8:  MOVF   xB1,W
10ADA:  MOVWF  00
10ADC:  CLRF   xB1
10ADE:  MOVLW  30
10AE0:  ADDWF  00,F
10AE2:  MOVFF  00,8DC
10AE6:  MOVLB  0
10AE8:  CALL   5016
10AEC:  MOVLB  8
10AEE:  BCF    FD8.1
10AF0:  CLRF   1B
10AF2:  BTFSC  FF2.7
10AF4:  BSF    1B.7
10AF6:  BCF    FF2.7
10AF8:  MOVFF  8B8,A27
10AFC:  MOVFF  8B7,A26
10B00:  MOVFF  8B6,A25
10B04:  MOVFF  8B5,A24
10B08:  MOVLB  A
10B0A:  CLRF   x2B
10B0C:  CLRF   x2A
10B0E:  CLRF   x29
10B10:  MOVLW  0A
10B12:  MOVWF  x28
10B14:  MOVLB  0
10B16:  CALL   1038
10B1A:  BTFSC  1B.7
10B1C:  BSF    FF2.7
10B1E:  MOVFF  03,8B8
10B22:  MOVFF  02,8B7
10B26:  MOVFF  01,8B6
10B2A:  MOVFF  00,8B5
10B2E:  MOVLB  8
10B30:  DECFSZ xB3,F
10B32:  BRA    10A0A
10B34:  MOVLB  0
10B36:  RETURN 0
*
12438:  ADDWF  FE8,W
1243A:  CLRF   FF7
1243C:  RLCF   FF7,F
1243E:  ADDLW  59
12440:  MOVWF  FF6
12442:  MOVLW  24
12444:  ADDWFC FF7,F
12446:  MOVLW  01
12448:  MOVWF  FF8
1244A:  MOVWF  FFB
1244C:  TBLRD*-
1244E:  MOVF   FF5,W
12450:  MOVWF  FFA
12452:  TBLRD*
12454:  MOVF   FF5,W
12456:  MOVWF  FF9
12458:  DATA FC,23
1245A:  DATA 04,24
1245C:  DATA 0A,24
1245E:  DATA 10,24
*
124F0:  MOVLW  8E
124F2:  MOVWF  00
124F4:  MOVLB  8
124F6:  MOVF   xF0,W
124F8:  SUBWF  00,F
124FA:  MOVFF  8F1,02
124FE:  MOVFF  8F2,01
12502:  BSF    02.7
12504:  MOVF   00,F
12506:  BZ    1251A
12508:  BCF    FD8.0
1250A:  MOVF   02,F
1250C:  BNZ   12512
1250E:  MOVF   01,F
12510:  BZ    1251A
12512:  RRCF   02,F
12514:  RRCF   01,F
12516:  DECFSZ 00,F
12518:  BRA    12508
1251A:  BTFSS  xF1.7
1251C:  BRA    12528
1251E:  COMF   01,F
12520:  COMF   02,F
12522:  INCF   01,F
12524:  BTFSC  FD8.2
12526:  INCF   02,F
12528:  MOVLB  0
1252A:  RETURN 0
*
12FE8:  ADDWF  FE8,W
12FEA:  CLRF   FF7
12FEC:  RLCF   FF7,F
12FEE:  ADDLW  09
12FF0:  MOVWF  FF6
12FF2:  MOVLW  30
12FF4:  ADDWFC FF7,F
12FF6:  MOVLW  01
12FF8:  MOVWF  FF8
12FFA:  MOVWF  FFB
12FFC:  TBLRD*-
12FFE:  MOVF   FF5,W
13000:  MOVWF  FFA
13002:  TBLRD*
13004:  MOVF   FF5,W
13006:  MOVWF  FF9
13008:  DATA 24,2E
1300A:  DATA 2A,2E
1300C:  DATA 48,2E
1300E:  DATA 66,2E
*
13080:  MOVLB  8
13082:  MOVF   xBA,W
13084:  XORWF  xBC,W
13086:  ANDLW  80
13088:  MOVWF  xBE
1308A:  BTFSS  xBA.7
1308C:  BRA    13098
1308E:  COMF   xB9,F
13090:  COMF   xBA,F
13092:  INCF   xB9,F
13094:  BTFSC  FD8.2
13096:  INCF   xBA,F
13098:  BTFSS  xBC.7
1309A:  BRA    130A6
1309C:  COMF   xBB,F
1309E:  COMF   xBC,F
130A0:  INCF   xBB,F
130A2:  BTFSC  FD8.2
130A4:  INCF   xBC,F
130A6:  MOVF   xB9,W
130A8:  MULWF  xBB
130AA:  MOVFF  FF3,01
130AE:  MOVFF  FF4,00
130B2:  MULWF  xBC
130B4:  MOVF   FF3,W
130B6:  ADDWF  00,F
130B8:  MOVF   xBA,W
130BA:  MULWF  xBB
130BC:  MOVF   FF3,W
130BE:  ADDWFC 00,W
130C0:  MOVWF  02
130C2:  BTFSS  xBE.7
130C4:  BRA    130D0
130C6:  COMF   01,F
130C8:  COMF   02,F
130CA:  INCF   01,F
130CC:  BTFSC  FD8.2
130CE:  INCF   02,F
130D0:  MOVLB  0
130D2:  GOTO   131B0 (RETURN)
*
13DFA:  ADDWF  FE8,W
13DFC:  CLRF   FF7
13DFE:  RLCF   FF7,F
13E00:  ADDLW  1B
13E02:  MOVWF  FF6
13E04:  MOVLW  3E
13E06:  ADDWFC FF7,F
13E08:  MOVLW  01
13E0A:  MOVWF  FF8
13E0C:  MOVWF  FFB
13E0E:  TBLRD*-
13E10:  MOVF   FF5,W
13E12:  MOVWF  FFA
13E14:  TBLRD*
13E16:  MOVF   FF5,W
13E18:  MOVWF  FF9
13E1A:  DATA C6,3C
13E1C:  DATA EE,3D
13E1E:  DATA F2,3C
13E20:  DATA EE,3D
13E22:  DATA BE,3B
13E24:  DATA EE,3D
13E26:  DATA EE,3D
13E28:  DATA EE,3D
13E2A:  DATA EE,3D
13E2C:  DATA EE,3D
13E2E:  DATA EE,3D
13E30:  DATA EE,3D
13E32:  DATA EE,3D
13E34:  DATA EE,3D
13E36:  DATA EE,3D
13E38:  DATA EE,3D
13E3A:  DATA E6,3D
13E3C:  DATA EE,3D
13E3E:  DATA EE,3D
13E40:  DATA EE,3D
13E42:  DATA EE,3D
13E44:  DATA EE,3D
13E46:  DATA 5E,3B
13E48:  DATA EE,3D
13E4A:  DATA 92,3B
13E4C:  DATA 9A,3B
13E4E:  DATA EE,3D
13E50:  DATA AE,3B
13E52:  DATA 1E,3D
13E54:  DATA E2,3B
13E56:  DATA EE,3D
13E58:  DATA EE,3D
13E5A:  DATA 74,3C
13E5C:  DATA 56,3C
13E5E:  DATA EE,3D
13E60:  DATA EE,3D
13E62:  DATA EE,3D
13E64:  DATA 38,3D
13E66:  DATA 64,3D
13E68:  DATA 90,3D
13E6A:  DATA 90,3C
13E6C:  DATA BC,3C
13E6E:  DATA EE,3D
13E70:  DATA EE,3D
13E72:  DATA EE,3D
13E74:  DATA EE,3D
13E76:  DATA BC,3D
13E78:  DATA EE,3D
13E7A:  DATA EE,3D
13E7C:  DATA EE,3D
13E7E:  DATA EE,3D
13E80:  DATA EE,3D
13E82:  DATA EE,3D
13E84:  DATA EE,3D
13E86:  DATA EE,3D
13E88:  DATA EE,3D
13E8A:  DATA EE,3D
13E8C:  DATA CA,3B
13E8E:  DATA EE,3D
13E90:  DATA EE,3D
13E92:  DATA EE,3D
13E94:  DATA EE,3D
13E96:  DATA FA,3B
13E98:  DATA EE,3D
13E9A:  DATA EE,3D
13E9C:  DATA 20,3C
13E9E:  DATA EE,3D
13EA0:  DATA EE,3D
13EA2:  DATA EE,3D
13EA4:  DATA 6E,3B
*
13F5A:  MOVFF  FEA,89D
13F5E:  MOVFF  FE9,89C
13F62:  MOVLB  8
13F64:  SWAPF  x96,W
13F66:  IORLW  F0
13F68:  MOVWF  x98
13F6A:  ADDWF  x98,F
13F6C:  ADDLW  E2
13F6E:  MOVWF  x99
13F70:  ADDLW  32
13F72:  MOVWF  x9B
13F74:  MOVF   x96,W
13F76:  ANDLW  0F
13F78:  ADDWF  x99,F
13F7A:  ADDWF  x99,F
13F7C:  ADDWF  x9B,F
13F7E:  ADDLW  E9
13F80:  MOVWF  x9A
13F82:  ADDWF  x9A,F
13F84:  ADDWF  x9A,F
13F86:  SWAPF  x95,W
13F88:  ANDLW  0F
13F8A:  ADDWF  x9A,F
13F8C:  ADDWF  x9B,F
13F8E:  RLCF   x9A,F
13F90:  RLCF   x9B,F
13F92:  COMF   x9B,F
13F94:  RLCF   x9B,F
13F96:  MOVF   x95,W
13F98:  ANDLW  0F
13F9A:  ADDWF  x9B,F
13F9C:  RLCF   x98,F
13F9E:  MOVLW  07
13FA0:  MOVWF  x97
13FA2:  MOVLW  0A
13FA4:  DECF   x9A,F
13FA6:  ADDWF  x9B,F
13FA8:  BNC   13FA4
13FAA:  DECF   x99,F
13FAC:  ADDWF  x9A,F
13FAE:  BNC   13FAA
13FB0:  DECF   x98,F
13FB2:  ADDWF  x99,F
13FB4:  BNC   13FB0
13FB6:  DECF   x97,F
13FB8:  ADDWF  x98,F
13FBA:  BNC   13FB6
13FBC:  MOVLW  08
13FBE:  MOVWF  FEA
13FC0:  MOVLW  97
13FC2:  MOVWF  FE9
13FC4:  MOVLW  07
13FC6:  ANDWF  x9C,W
13FC8:  BCF    x9C.6
13FCA:  ADDWF  FE9,F
13FCC:  MOVLW  00
13FCE:  ADDWFC FEA,F
13FD0:  MOVF   FE9,W
13FD2:  SUBLW  9B
13FD4:  BNZ   13FDE
13FD6:  MOVF   FEA,W
13FD8:  SUBLW  08
13FDA:  BNZ   13FDE
13FDC:  BSF    x9C.6
13FDE:  MOVF   FEF,W
13FE0:  MOVWF  00
13FE2:  BNZ   13FF4
13FE4:  BTFSC  x9C.6
13FE6:  BRA    13FF4
13FE8:  BTFSC  x9C.4
13FEA:  BRA    14008
13FEC:  BTFSC  x9C.3
13FEE:  BRA    13FF4
13FF0:  MOVLW  20
13FF2:  BRA    13FFA
13FF4:  BSF    x9C.3
13FF6:  BCF    x9C.4
13FF8:  MOVLW  30
13FFA:  ADDWF  00,F
13FFC:  MOVF   00,W
13FFE:  BTFSS  FA4.4
14000:  BRA    13FFE
14002:  MOVLB  F
14004:  MOVWF  x1C
14006:  MOVLB  8
14008:  MOVF   FEE,W
1400A:  BTFSS  x9C.6
1400C:  BRA    13FD0
1400E:  MOVLB  0
14010:  GOTO   140AC (RETURN)
*
144F0:  ADDWF  FE8,W
144F2:  CLRF   FF7
144F4:  RLCF   FF7,F
144F6:  ADDLW  11
144F8:  MOVWF  FF6
144FA:  MOVLW  45
144FC:  ADDWFC FF7,F
144FE:  MOVLW  01
14500:  MOVWF  FF8
14502:  MOVWF  FFB
14504:  TBLRD*-
14506:  MOVF   FF5,W
14508:  MOVWF  FFA
1450A:  TBLRD*
1450C:  MOVF   FF5,W
1450E:  MOVWF  FF9
14510:  DATA DC,40
14512:  DATA 3C,41
14514:  DATA 58,41
14516:  DATA 74,41
14518:  DATA 90,41
1451A:  DATA AC,41
1451C:  DATA C8,41
1451E:  DATA E4,41
14520:  DATA 00,42
14522:  DATA 1C,42
14524:  DATA 38,42
14526:  DATA 54,42
14528:  DATA 70,42
1452A:  DATA 8C,42
1452C:  DATA A8,42
1452E:  DATA C4,42
14530:  DATA E0,42
14532:  DATA FC,42
14534:  DATA 18,43
14536:  DATA 34,43
14538:  DATA 50,43
1453A:  DATA 6C,43
1453C:  DATA 88,43
1453E:  DATA A4,43
14540:  DATA C0,43
14542:  DATA DC,43
14544:  DATA F8,43
14546:  DATA 14,44
14548:  DATA 30,44
1454A:  DATA 4C,44
1454C:  DATA 68,44
1454E:  DATA 84,44
14550:  DATA A0,44
*
14D26:  ADDWF  FE8,W
14D28:  CLRF   FF7
14D2A:  RLCF   FF7,F
14D2C:  ADDLW  47
14D2E:  MOVWF  FF6
14D30:  MOVLW  4D
14D32:  ADDWFC FF7,F
14D34:  MOVLW  01
14D36:  MOVWF  FF8
14D38:  MOVWF  FFB
14D3A:  TBLRD*-
14D3C:  MOVF   FF5,W
14D3E:  MOVWF  FFA
14D40:  TBLRD*
14D42:  MOVF   FF5,W
14D44:  MOVWF  FF9
14D46:  DATA 32,49
14D48:  DATA 5A,4A
14D4A:  DATA 5E,49
14D4C:  DATA 5A,4A
14D4E:  DATA 24,48
14D50:  DATA 5A,4A
14D52:  DATA 5A,4A
14D54:  DATA 5A,4A
14D56:  DATA 5A,4A
14D58:  DATA 5A,4A
14D5A:  DATA 5A,4A
14D5C:  DATA 5A,4A
14D5E:  DATA 5A,4A
14D60:  DATA 5A,4A
14D62:  DATA 5A,4A
14D64:  DATA 5A,4A
14D66:  DATA 52,4A
14D68:  DATA 5A,4A
14D6A:  DATA 5A,4A
14D6C:  DATA 5A,4A
14D6E:  DATA 5A,4A
14D70:  DATA 5A,4A
14D72:  DATA 2E,46
14D74:  DATA 5A,4A
14D76:  DATA 62,46
14D78:  DATA 00,48
14D7A:  DATA 5A,4A
14D7C:  DATA 14,48
14D7E:  DATA 8A,49
14D80:  DATA 48,48
14D82:  DATA 5A,4A
14D84:  DATA 5A,4A
14D86:  DATA DA,48
14D88:  DATA BC,48
14D8A:  DATA 5A,4A
14D8C:  DATA 5A,4A
14D8E:  DATA 5A,4A
14D90:  DATA A4,49
14D92:  DATA D0,49
14D94:  DATA FC,49
14D96:  DATA F6,48
14D98:  DATA 26,49
14D9A:  DATA 5A,4A
14D9C:  DATA 5A,4A
14D9E:  DATA 5A,4A
14DA0:  DATA 5A,4A
14DA2:  DATA 28,4A
14DA4:  DATA 5A,4A
14DA6:  DATA 5A,4A
14DA8:  DATA 5A,4A
14DAA:  DATA 5A,4A
14DAC:  DATA 5A,4A
14DAE:  DATA 5A,4A
14DB0:  DATA 5A,4A
14DB2:  DATA 5A,4A
14DB4:  DATA 5A,4A
14DB6:  DATA 5A,4A
14DB8:  DATA 30,48
14DBA:  DATA 5A,4A
14DBC:  DATA 5A,4A
14DBE:  DATA 5A,4A
14DC0:  DATA 5A,4A
14DC2:  DATA 60,48
14DC4:  DATA 5A,4A
14DC6:  DATA 5A,4A
14DC8:  DATA 86,48
14DCA:  DATA 5A,4A
14DCC:  DATA 5A,4A
14DCE:  DATA 5A,4A
14DD0:  DATA 3E,46
14DD2:  DATA 5A,4A
14DD4:  DATA 6A,46
*
15238:  ADDWF  FE8,W
1523A:  CLRF   FF7
1523C:  RLCF   FF7,F
1523E:  ADDLW  59
15240:  MOVWF  FF6
15242:  MOVLW  52
15244:  ADDWFC FF7,F
15246:  MOVLW  01
15248:  MOVWF  FF8
1524A:  MOVWF  FFB
1524C:  TBLRD*-
1524E:  MOVF   FF5,W
15250:  MOVWF  FFA
15252:  TBLRD*
15254:  MOVF   FF5,W
15256:  MOVWF  FF9
15258:  DATA AA,50
1525A:  DATA CA,50
1525C:  DATA EA,50
1525E:  DATA 0A,51
15260:  DATA 2A,51
15262:  DATA 4A,51
15264:  DATA 6A,51
*
1ACCE:  ADDWF  FE8,W
1ACD0:  CLRF   FF7
1ACD2:  RLCF   FF7,F
1ACD4:  ADDLW  EF
1ACD6:  MOVWF  FF6
1ACD8:  MOVLW  AC
1ACDA:  ADDWFC FF7,F
1ACDC:  MOVLW  01
1ACDE:  MOVWF  FF8
1ACE0:  MOVWF  FFB
1ACE2:  TBLRD*-
1ACE4:  MOVF   FF5,W
1ACE6:  MOVWF  FFA
1ACE8:  TBLRD*
1ACEA:  MOVF   FF5,W
1ACEC:  MOVWF  FF9
1ACEE:  DATA 54,AB
1ACF0:  DATA CA,AC
1ACF2:  DATA 5A,AB
1ACF4:  DATA 4E,AB
1ACF6:  DATA CA,AC
1ACF8:  DATA CA,AC
1ACFA:  DATA CA,AC
1ACFC:  DATA 60,AB
1ACFE:  DATA 14,AC
1AD00:  DATA CA,AC
1AD02:  DATA 30,AC
1AD04:  DATA CA,AC
1AD06:  DATA 66,AB
1AD08:  DATA CA,AC
1AD0A:  DATA CA,AC
1AD0C:  DATA CA,AC
1AD0E:  DATA CA,AC
1AD10:  DATA CA,AC
1AD12:  DATA CA,AC
1AD14:  DATA CA,AC
1AD16:  DATA CA,AC
1AD18:  DATA CA,AC
1AD1A:  DATA CA,AC
1AD1C:  DATA CA,AC
1AD1E:  DATA CA,AC
1AD20:  DATA CA,AC
1AD22:  DATA CA,AC
1AD24:  DATA CA,AC
1AD26:  DATA CA,AC
1AD28:  DATA CA,AC
1AD2A:  DATA 6C,AB
1AD2C:  DATA 72,AB
1AD2E:  DATA 78,AB
1AD30:  DATA 7E,AB
1AD32:  DATA 84,AB
1AD34:  DATA 8A,AB
1AD36:  DATA 90,AB
1AD38:  DATA 96,AB
1AD3A:  DATA 9C,AB
1AD3C:  DATA A2,AB
1AD3E:  DATA A8,AB
1AD40:  DATA AE,AB
1AD42:  DATA B4,AB
1AD44:  DATA C0,AB
1AD46:  DATA C6,AB
1AD48:  DATA CC,AB
1AD4A:  DATA D2,AB
1AD4C:  DATA D8,AB
1AD4E:  DATA DE,AB
1AD50:  DATA E4,AB
1AD52:  DATA EA,AB
1AD54:  DATA F0,AB
1AD56:  DATA F6,AB
1AD58:  DATA FC,AB
1AD5A:  DATA 02,AC
1AD5C:  DATA 08,AC
1AD5E:  DATA CA,AC
1AD60:  DATA CA,AC
1AD62:  DATA CA,AC
1AD64:  DATA 0E,AC
1AD66:  DATA CA,AC
1AD68:  DATA CA,AC
1AD6A:  DATA 4C,AC
1AD6C:  DATA 52,AC
1AD6E:  DATA CA,AC
1AD70:  DATA 58,AC
1AD72:  DATA 5E,AC
1AD74:  DATA 64,AC
1AD76:  DATA 6A,AC
1AD78:  DATA 70,AC
1AD7A:  DATA 76,AC
1AD7C:  DATA 7C,AC
1AD7E:  DATA 82,AC
1AD80:  DATA 88,AC
1AD82:  DATA 8E,AC
1AD84:  DATA 94,AC
1AD86:  DATA 9A,AC
1AD88:  DATA A0,AC
1AD8A:  DATA A6,AC
1AD8C:  DATA AC,AC
1AD8E:  DATA B0,AC
1AD90:  DATA B4,AC
1AD92:  DATA B8,AC
1AD94:  DATA CA,AC
1AD96:  DATA BC,AC
1AD98:  DATA C0,AC
1AD9A:  DATA C4,AC
1AD9C:  DATA C8,AC
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8D1
1F8BA:  MOVFF  FF7,8D2
1F8BE:  MOVFF  FF8,8D3
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8D1,FF6
1F8CE:  MOVFF  8D2,FF7
1F8D2:  MOVFF  8D3,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8D2
1F8E0:  MOVFF  FF7,8D3
1F8E4:  MOVFF  FF8,8D4
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8D2,FF6
1F8F4:  MOVFF  8D3,FF7
1F8F8:  MOVFF  8D4,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xD1,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xD2.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xD1,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xD2,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xD1,F
1F936:  MOVLW  0A
1F938:  SUBWF  xD1,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xD2.7
1F942:  MOVF   xD2,W
1F944:  ADDWF  xD1,F
1F946:  MOVF   xD1,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xD4,W
1F956:  CLRF   01
1F958:  SUBWF  xD3,W
1F95A:  BC    1F962
1F95C:  MOVFF  8D3,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xD5
1F968:  RLCF   xD3,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xD4,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xD5,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8D1,8D3
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xD4
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8D1
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xD2.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xD2.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xD2.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xD2.3
1F9AC:  BCF    xD2.4
1F9AE:  BSF    xD2.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8D1,8D3
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xD4
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8D1
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xD2.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xD2.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xD2.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xD1,F
1F9F0:  MOVF   xD1,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8D1,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8D2,01
1FA60:  MOVFF  8D1,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... #ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... #else 
....................    #FUSES NOMCLR 
.................... #endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... #FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... #FUSES WDT_SW                    // WDT is s/w controlled 
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
0288E:  MOVLW  09
02890:  MOVWF  FEA
02892:  MOVLW  C9
02894:  MOVWF  FE9
02896:  MOVF   FEF,W
02898:  BZ    28B6
0289A:  MOVLW  14
0289C:  MOVWF  01
0289E:  CLRF   00
028A0:  DECFSZ 00,F
028A2:  BRA    28A0
028A4:  DECFSZ 01,F
028A6:  BRA    289E
028A8:  MOVLW  BF
028AA:  MOVWF  00
028AC:  DECFSZ 00,F
028AE:  BRA    28AC
028B0:  BRA    28B2
028B2:  DECFSZ FEF,F
028B4:  BRA    289A
028B6:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E1A:  BTFSS  F9E.5
00E1C:  BRA    0E1A
00E1E:  MOVFF  FAB,1C
00E22:  MOVFF  FAE,01
00E26:  BTFSS  1C.1
00E28:  BRA    0E2E
00E2A:  BCF    FAB.4
00E2C:  BSF    FAB.4
00E2E:  RETURN 0
*
0ADAA:  BTFSS  F9E.4
0ADAC:  BRA    ADAA
0ADAE:  MOVWF  FAD
0ADB0:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12B16:  BTFSS  FA4.5
12B18:  BRA    12B16
12B1A:  MOVLB  F
12B1C:  MOVFF  F22,1C
12B20:  MOVFF  F1D,01
12B24:  BTFSS  1C.1
12B26:  BRA    12B2C
12B28:  BCF    x22.4
12B2A:  BSF    x22.4
12B2C:  MOVLB  0
12B2E:  RETURN 0
*
16A58:  BTFSS  FA4.4
16A5A:  BRA    16A58
16A5C:  MOVLB  F
16A5E:  MOVWF  x1C
16A60:  MOVLB  0
16A62:  GOTO   16B06 (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xD7
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xD8
1F850:  MOVF   xD8,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8D6,03
1F85A:  MOVFF  8D5,FE9
1F85E:  MOVFF  8D6,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xD7,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8D9
1F870:  MOVFF  8D5,FE9
1F874:  MOVFF  8D6,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xD9,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xD7
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xD7,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8D9
1F88C:  MOVFF  8D5,FE9
1F890:  MOVFF  8D6,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xD9,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xD7
....................       }  
1F89C:  MOVF   xD8,W
1F89E:  INCF   xD8,F
1F8A0:  INCF   xD5,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xD6,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8D7,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xD5,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8D2,03
1FA84:  MOVFF  8D1,FE9
1FA88:  MOVFF  8D2,FEA
1FA8C:  MOVFF  FEF,8D6
1FA90:  MOVFF  8D4,03
1FA94:  MOVFF  8D3,FE9
1FA98:  MOVFF  8D4,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xD6,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8D2,03
1FAA6:  MOVFF  8D1,FE9
1FAAA:  MOVFF  8D2,FEA
1FAAE:  MOVFF  FEF,8D6
1FAB2:  MOVFF  8D4,03
1FAB6:  MOVFF  8D3,FE9
1FABA:  MOVFF  8D4,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xD6,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8D2,03
1FAD4:  MOVFF  8D1,FE9
1FAD8:  MOVFF  8D2,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8D2,03
1FAEA:  MOVF   xD1,W
1FAEC:  INCF   xD1,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xD2,F
1FAF2:  MOVFF  8D4,03
1FAF6:  MOVF   xD3,W
1FAF8:  INCF   xD3,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xD4,F
1FAFE:  DECF   xD5,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x62.1
1FB0E:  CLRF   x6C
1FB10:  CLRF   x6B
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xC9
1FB2A:  MOVLB  0
1FB2C:  CALL   288E
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x62.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x68
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x68,W
1FB3C:  ADDLW  91
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x68,W
1FB50:  INCF   x68,F
1FB52:  CLRF   03
1FB54:  ADDLW  91
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x68,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x62.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   x91,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xD6
1FB80:  MOVLW  92
1FB82:  MOVWF  xD5
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,867
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xD6
1FB92:  MOVLW  94
1FB94:  MOVWF  xD5
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8D1
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xD6
1FBA4:  MOVLW  96
1FBA6:  MOVWF  xD5
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8D1,86A
1FBB0:  MOVFF  01,869
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xD6
1FBBA:  MOVLW  98
1FBBC:  MOVWF  xD5
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,864
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  86B,86F
1FBCA:  MOVFF  86C,870
1FBCE:  MOVFF  869,86D
1FBD2:  MOVFF  86A,86E
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x64,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x62.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x62.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x70,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x6F,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x6E,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x70,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x6F,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x70,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x6F,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x63
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x66
1FC26:  MOVLW  03
1FC28:  SUBWF  x68,W
1FC2A:  SUBWF  x66,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x66,W
1FC32:  ADDLW  91
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8D1
1FC3E:  MOVFF  03,8D2
1FC42:  MOVFF  03,8D6
1FC46:  MOVFF  01,8D5
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x63,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x66,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x63,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x63
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x68,W
1FC68:  CLRF   03
1FC6A:  ADDLW  91
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8D1
1FC76:  MOVFF  03,8D2
1FC7A:  MOVFF  03,8D6
1FC7E:  MOVFF  01,8D5
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x63,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x62.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x64,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x66
1FCAE:  CLRF   x65
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x68,W
1FCB4:  SUBWF  x66,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x65,W
1FCBA:  INCF   x65,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  71
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8D1
1FCCA:  MOVFF  03,8D2
1FCCE:  CLRF   03
1FCD0:  MOVF   x66,W
1FCD2:  ADDLW  91
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8D3
1FCDE:  MOVFF  03,8D4
1FCE2:  MOVFF  03,8D6
1FCE6:  MOVFF  01,8D5
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8D2,FEA
1FCF2:  MOVFF  8D1,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x66,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xD1
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  870,8D1
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xD2
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  86F,8D1
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xD2
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  86E,8D1
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xD2
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  86D,8D1
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xD2
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  867,8D1
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xD2
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  86F,FF8
1FD80:  MOVFF  86E,FF7
1FD84:  MOVFF  86D,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  71
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  867,8D1
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  86F,FF8
1FD9A:  MOVFF  86E,FF7
1FD9E:  MOVFF  86D,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  91
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xD2
1FDAE:  MOVFF  867,8D1
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xD2
1FDBC:  MOVLW  71
1FDBE:  MOVWF  xD1
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xD4
1FDC4:  MOVLW  91
1FDC6:  MOVWF  xD3
1FDC8:  MOVFF  867,8D5
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x62.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x64,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xD6
1FE02:  MOVLW  9A
1FE04:  MOVWF  xD5
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8D1
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xD6
1FE14:  MOVLW  9C
1FE16:  MOVWF  xD5
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8D1,86C
1FE20:  MOVFF  01,86B
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xD1
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  86B,8D1
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xD2
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x62.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x62.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xD1
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xC9
1FE8E:  MOVLB  0
1FE90:  CALL   288E
1FE94:  MOVLB  8
1FE96:  DECFSZ xD1,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
054C8:  BCF    FF2.5
....................    restart_wdt(); 
054CA:  CLRWDT
054CC:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
054CE:  CLRF   FCF
054D0:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
054D2:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
054D4:  MOVF   2F,W
054D6:  SUBLW  02
054D8:  BNZ   54E0
054DA:  MOVF   30,F
054DC:  BNZ   54E0
054DE:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
054E0:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
054E2:  BSF    F9D.0
054E4:  GOTO   54F8 (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
054E8:  MOVLW  0B
054EA:  MOVWF  FD7
054EC:  MOVLW  DC
054EE:  MOVWF  FD6
....................    restart_wdt(); 
054F0:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
054F2:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
054F4:  BSF    FF2.5
....................    setup_led_pulse(); 
054F6:  BRA    54CE
054F8:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
054FA:  MOVLB  8
054FC:  MOVF   xCA,W
054FE:  XORLW  00
05500:  MOVLB  0
05502:  BZ    550A
05504:  XORLW  01
05506:  BZ    550E
05508:  BRA    5510
....................       case 0 : suspend_heartbeat(); 
0550A:  RCALL  54C8
....................          break; 
0550C:  BRA    5510
....................       case 1 : restart_heartbeat(); 
0550E:  RCALL  54E8
....................          break; 
....................    } 
05510:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
03074:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
03076:  BCF    FD1.0
03078:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
0287E:  MOVLW  0B
02880:  MOVWF  FD7
02882:  MOVLW  DC
02884:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
02886:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
02888:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
0288A:  BSF    FD1.0
0288C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
07844:  MOVFF  98E,994
07848:  MOVFF  98D,993
0784C:  MOVLB  9
0784E:  MOVF   x91,F
07850:  BNZ   7856
07852:  MOVF   x92,F
07854:  BZ    78A0
07856:  MOVFF  990,03
0785A:  MOVFF  98F,FE9
0785E:  MOVFF  990,FEA
07862:  MOVF   FEF,F
07864:  BZ    78A0
....................      *s++ = *s2++; 
07866:  MOVFF  994,996
0786A:  MOVF   x93,W
0786C:  INCF   x93,F
0786E:  BTFSC  FD8.2
07870:  INCF   x94,F
07872:  MOVWF  x95
07874:  MOVFF  990,03
07878:  MOVF   x8F,W
0787A:  INCF   x8F,F
0787C:  BTFSC  FD8.2
0787E:  INCF   x90,F
07880:  MOVWF  FE9
07882:  MOVFF  03,FEA
07886:  MOVFF  FEF,997
0788A:  MOVFF  996,FEA
0788E:  MOVFF  995,FE9
07892:  MOVFF  997,FEF
07896:  MOVF   x91,W
07898:  BTFSC  FD8.2
0789A:  DECF   x92,F
0789C:  DECF   x91,F
0789E:  BRA    784E
....................   for (; n > 0; n--) 
078A0:  MOVF   x91,F
078A2:  BNZ   78A8
078A4:  MOVF   x92,F
078A6:  BZ    78C6
....................      *s++ = '\0'; 
078A8:  MOVFF  994,03
078AC:  MOVF   x93,W
078AE:  INCF   x93,F
078B0:  BTFSC  FD8.2
078B2:  INCF   x94,F
078B4:  MOVWF  FE9
078B6:  MOVFF  03,FEA
078BA:  CLRF   FEF
078BC:  MOVF   x91,W
078BE:  BTFSC  FD8.2
078C0:  DECF   x92,F
078C2:  DECF   x91,F
078C4:  BRA    78A0
....................  
....................   return(s1); 
078C6:  MOVFF  98D,01
078CA:  MOVFF  98E,02
078CE:  MOVLB  0
078D0:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
05456:  MOVFF  8D6,8DA
0545A:  MOVFF  8D5,8D9
0545E:  MOVFF  8DA,03
05462:  MOVLB  8
05464:  MOVFF  8D9,FE9
05468:  MOVFF  8DA,FEA
0546C:  MOVF   FEF,F
0546E:  BZ    547C
05470:  INCF   xD9,F
05472:  BTFSC  FD8.2
05474:  INCF   xDA,F
05476:  MOVLB  0
05478:  BRA    545E
0547A:  MOVLB  8
....................    while(*s2 != '\0') 
0547C:  MOVFF  8D8,03
05480:  MOVFF  8D7,FE9
05484:  MOVFF  8D8,FEA
05488:  MOVF   FEF,F
0548A:  BZ    54B2
....................    { 
....................       *s = *s2; 
0548C:  MOVFF  8D7,FE9
05490:  MOVFF  8D8,FEA
05494:  MOVFF  FEF,8DD
05498:  MOVFF  8DA,FEA
0549C:  MOVFF  8D9,FE9
054A0:  MOVFF  8DD,FEF
....................       ++s; 
054A4:  INCF   xD9,F
054A6:  BTFSC  FD8.2
054A8:  INCF   xDA,F
....................       ++s2; 
054AA:  INCF   xD7,F
054AC:  BTFSC  FD8.2
054AE:  INCF   xD8,F
054B0:  BRA    547C
....................    } 
....................  
....................    *s = '\0'; 
054B2:  MOVFF  8D9,FE9
054B6:  MOVFF  8DA,FEA
054BA:  CLRF   FEF
....................    return(s1); 
054BC:  MOVFF  8D5,01
054C0:  MOVFF  8D6,02
054C4:  MOVLB  0
054C6:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
12A92:  MOVFF  8CB,8D1
12A96:  MOVFF  8CA,8D0
12A9A:  MOVFF  8D1,03
12A9E:  MOVLB  8
12AA0:  MOVFF  8D0,FE9
12AA4:  MOVFF  8D1,FEA
12AA8:  MOVF   FEF,F
12AAA:  BZ    12AB8
12AAC:  INCF   xD0,F
12AAE:  BTFSC  FD8.2
12AB0:  INCF   xD1,F
12AB2:  MOVLB  0
12AB4:  BRA    12A9A
12AB6:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12AB8:  MOVFF  8CD,03
12ABC:  MOVFF  8CC,FE9
12AC0:  MOVFF  8CD,FEA
12AC4:  MOVF   FEF,F
12AC6:  BZ    12B00
12AC8:  MOVF   xCF,F
12ACA:  BNZ   12AD2
12ACC:  MOVF   xCE,W
12ACE:  SUBLW  00
12AD0:  BC    12B00
....................    { 
....................       *s = *s2; 
12AD2:  MOVFF  8CC,FE9
12AD6:  MOVFF  8CD,FEA
12ADA:  MOVFF  FEF,8D4
12ADE:  MOVFF  8D1,FEA
12AE2:  MOVFF  8D0,FE9
12AE6:  MOVFF  8D4,FEF
....................       ++s; 
12AEA:  INCF   xD0,F
12AEC:  BTFSC  FD8.2
12AEE:  INCF   xD1,F
....................       ++s2; 
12AF0:  INCF   xCC,F
12AF2:  BTFSC  FD8.2
12AF4:  INCF   xCD,F
....................       --n; 
12AF6:  MOVF   xCE,W
12AF8:  BTFSC  FD8.2
12AFA:  DECF   xCF,F
12AFC:  DECF   xCE,F
12AFE:  BRA    12AB8
....................    } 
....................  
....................    *s = '\0'; 
12B00:  MOVFF  8D0,FE9
12B04:  MOVFF  8D1,FEA
12B08:  CLRF   FEF
....................    return(s1); 
12B0A:  MOVFF  8CA,01
12B0E:  MOVFF  8CB,02
12B12:  MOVLB  0
12B14:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
04592:  MOVFF  9C7,9CD
04596:  MOVFF  9C6,9CC
0459A:  MOVFF  9C9,9CF
0459E:  MOVFF  9C8,9CE
045A2:  MOVLB  9
045A4:  MOVF   xCB,F
045A6:  BNZ   45AE
045A8:  MOVF   xCA,W
045AA:  SUBLW  00
045AC:  BC    460E
.................... { 
....................    if(*su1!=*su2) 
045AE:  MOVFF  9CC,FE9
045B2:  MOVFF  9CD,FEA
045B6:  MOVFF  FEF,9D0
045BA:  MOVFF  9CF,03
045BE:  MOVFF  9CE,FE9
045C2:  MOVFF  9CF,FEA
045C6:  MOVF   FEF,W
045C8:  SUBWF  xD0,W
045CA:  BZ    45F8
....................       return ((*su1<*su2)?-1:1); 
045CC:  MOVFF  9CD,03
045D0:  MOVFF  9CC,FE9
045D4:  MOVFF  03,FEA
045D8:  MOVFF  FEF,9D0
045DC:  MOVFF  9CF,03
045E0:  MOVFF  9CE,FE9
045E4:  MOVFF  9CF,FEA
045E8:  MOVF   FEF,W
045EA:  SUBWF  xD0,W
045EC:  BC    45F2
045EE:  MOVLW  FF
045F0:  BRA    45F4
045F2:  MOVLW  01
045F4:  MOVWF  01
045F6:  BRA    4612
045F8:  INCF   xCC,F
045FA:  BTFSC  FD8.2
045FC:  INCF   xCD,F
045FE:  INCF   xCE,F
04600:  BTFSC  FD8.2
04602:  INCF   xCF,F
04604:  MOVF   xCA,W
04606:  BTFSC  FD8.2
04608:  DECF   xCB,F
0460A:  DECF   xCA,F
0460C:  BRA    45A4
.................... } 
.................... return 0; 
0460E:  MOVLW  00
04610:  MOVWF  01
04612:  MOVLB  0
04614:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
12A56:  MOVFF  8C9,8CB
12A5A:  MOVFF  8C8,8CA
12A5E:  MOVFF  8CB,03
12A62:  MOVLB  8
12A64:  MOVFF  8CA,FE9
12A68:  MOVFF  8CB,FEA
12A6C:  MOVF   FEF,F
12A6E:  BZ    12A7C
12A70:  INCF   xCA,F
12A72:  BTFSC  FD8.2
12A74:  INCF   xCB,F
12A76:  MOVLB  0
12A78:  BRA    12A5E
12A7A:  MOVLB  8
....................    return(sc - s); 
12A7C:  MOVF   xC8,W
12A7E:  SUBWF  xCA,W
12A80:  MOVWF  00
12A82:  MOVF   xC9,W
12A84:  SUBWFB xCB,W
12A86:  MOVWF  03
12A88:  MOVFF  00,01
12A8C:  MOVWF  02
12A8E:  MOVLB  0
12A90:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
130D6:  MOVLB  8
130D8:  CLRF   xB7
....................    sign = 0; 
130DA:  CLRF   xB5
....................    base = 10; 
130DC:  MOVLW  0A
130DE:  MOVWF  xB6
....................    result = 0; 
130E0:  CLRF   xB4
130E2:  CLRF   xB3
....................  
....................    if (!s) 
130E4:  MOVF   xB1,W
130E6:  IORWF  xB2,W
130E8:  BNZ   130F2
....................       return 0; 
130EA:  MOVLW  00
130EC:  MOVWF  01
130EE:  MOVWF  02
130F0:  BRA    132B6
....................    c = s[index++]; 
130F2:  MOVF   xB7,W
130F4:  INCF   xB7,F
130F6:  ADDWF  xB1,W
130F8:  MOVWF  FE9
130FA:  MOVLW  00
130FC:  ADDWFC xB2,W
130FE:  MOVWF  FEA
13100:  MOVFF  FEF,8B8
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
13104:  MOVF   xB8,W
13106:  SUBLW  2D
13108:  BNZ   13122
....................    { 
....................       sign = 1;         // Set the sign to negative 
1310A:  MOVLW  01
1310C:  MOVWF  xB5
....................       c = s[index++]; 
1310E:  MOVF   xB7,W
13110:  INCF   xB7,F
13112:  ADDWF  xB1,W
13114:  MOVWF  FE9
13116:  MOVLW  00
13118:  ADDWFC xB2,W
1311A:  MOVWF  FEA
1311C:  MOVFF  FEF,8B8
....................    } 
13120:  BRA    1313A
....................    else if (c == '+') 
13122:  MOVF   xB8,W
13124:  SUBLW  2B
13126:  BNZ   1313A
....................    { 
....................       c = s[index++]; 
13128:  MOVF   xB7,W
1312A:  INCF   xB7,F
1312C:  ADDWF  xB1,W
1312E:  MOVWF  FE9
13130:  MOVLW  00
13132:  ADDWFC xB2,W
13134:  MOVWF  FEA
13136:  MOVFF  FEF,8B8
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1313A:  MOVF   xB8,W
1313C:  SUBLW  2F
1313E:  BTFSC  FD8.0
13140:  BRA    1329A
13142:  MOVF   xB8,W
13144:  SUBLW  39
13146:  BTFSS  FD8.0
13148:  BRA    1329A
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1314A:  MOVF   xB8,W
1314C:  SUBLW  30
1314E:  BNZ   1318C
13150:  MOVF   xB7,W
13152:  ADDWF  xB1,W
13154:  MOVWF  FE9
13156:  MOVLW  00
13158:  ADDWFC xB2,W
1315A:  MOVWF  FEA
1315C:  MOVF   FEF,W
1315E:  SUBLW  78
13160:  BZ    13174
13162:  MOVF   xB7,W
13164:  ADDWF  xB1,W
13166:  MOVWF  FE9
13168:  MOVLW  00
1316A:  ADDWFC xB2,W
1316C:  MOVWF  FEA
1316E:  MOVF   FEF,W
13170:  SUBLW  58
13172:  BNZ   1318C
....................       { 
....................          base = 16; 
13174:  MOVLW  10
13176:  MOVWF  xB6
....................          index++; 
13178:  INCF   xB7,F
....................          c = s[index++]; 
1317A:  MOVF   xB7,W
1317C:  INCF   xB7,F
1317E:  ADDWF  xB1,W
13180:  MOVWF  FE9
13182:  MOVLW  00
13184:  ADDWFC xB2,W
13186:  MOVWF  FEA
13188:  MOVFF  FEF,8B8
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1318C:  MOVF   xB6,W
1318E:  SUBLW  0A
13190:  BNZ   131D6
....................       { 
....................          while (c >= '0' && c <= '9') 
13192:  MOVF   xB8,W
13194:  SUBLW  2F
13196:  BC    131D4
13198:  MOVF   xB8,W
1319A:  SUBLW  39
1319C:  BNC   131D4
....................          { 
....................             result = 10*result + (c - '0'); 
1319E:  CLRF   xBA
131A0:  MOVLW  0A
131A2:  MOVWF  xB9
131A4:  MOVFF  8B4,8BC
131A8:  MOVFF  8B3,8BB
131AC:  MOVLB  0
131AE:  BRA    13080
131B0:  MOVLW  30
131B2:  MOVLB  8
131B4:  SUBWF  xB8,W
131B6:  ADDWF  01,W
131B8:  MOVWF  xB3
131BA:  MOVLW  00
131BC:  ADDWFC 02,W
131BE:  MOVWF  xB4
....................             c = s[index++]; 
131C0:  MOVF   xB7,W
131C2:  INCF   xB7,F
131C4:  ADDWF  xB1,W
131C6:  MOVWF  FE9
131C8:  MOVLW  00
131CA:  ADDWFC xB2,W
131CC:  MOVWF  FEA
131CE:  MOVFF  FEF,8B8
131D2:  BRA    13192
....................          } 
....................       } 
131D4:  BRA    1329A
....................       else if (base == 16)    // The number is a hexa number 
131D6:  MOVF   xB6,W
131D8:  SUBLW  10
131DA:  BNZ   1329A
....................       { 
....................          c = toupper(c); 
131DC:  MOVF   xB8,W
131DE:  SUBLW  60
131E0:  BC    131EE
131E2:  MOVF   xB8,W
131E4:  SUBLW  7A
131E6:  BNC   131EE
131E8:  MOVF   xB8,W
131EA:  ANDLW  DF
131EC:  BRA    131F0
131EE:  MOVF   xB8,W
131F0:  MOVWF  xB8
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
131F2:  MOVF   xB8,W
131F4:  SUBLW  2F
131F6:  BC    131FE
131F8:  MOVF   xB8,W
131FA:  SUBLW  39
131FC:  BC    1320A
131FE:  MOVF   xB8,W
13200:  SUBLW  40
13202:  BC    1329A
13204:  MOVF   xB8,W
13206:  SUBLW  46
13208:  BNC   1329A
....................          { 
....................             if (c >= '0' && c <= '9') 
1320A:  MOVF   xB8,W
1320C:  SUBLW  2F
1320E:  BC    13244
13210:  MOVF   xB8,W
13212:  SUBLW  39
13214:  BNC   13244
....................                result = (result << 4) + (c - '0'); 
13216:  RLCF   xB3,W
13218:  MOVWF  xB9
1321A:  RLCF   xB4,W
1321C:  MOVWF  xBA
1321E:  RLCF   xB9,F
13220:  RLCF   xBA,F
13222:  RLCF   xB9,F
13224:  RLCF   xBA,F
13226:  RLCF   xB9,F
13228:  RLCF   xBA,F
1322A:  MOVLW  F0
1322C:  ANDWF  xB9,F
1322E:  MOVLW  30
13230:  SUBWF  xB8,W
13232:  ADDWF  xB9,W
13234:  MOVWF  01
13236:  MOVLW  00
13238:  ADDWFC xBA,W
1323A:  MOVWF  03
1323C:  MOVFF  01,8B3
13240:  MOVWF  xB4
13242:  BRA    13270
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
13244:  RLCF   xB3,W
13246:  MOVWF  xB9
13248:  RLCF   xB4,W
1324A:  MOVWF  xBA
1324C:  RLCF   xB9,F
1324E:  RLCF   xBA,F
13250:  RLCF   xB9,F
13252:  RLCF   xBA,F
13254:  RLCF   xB9,F
13256:  RLCF   xBA,F
13258:  MOVLW  F0
1325A:  ANDWF  xB9,F
1325C:  MOVLW  41
1325E:  SUBWF  xB8,W
13260:  ADDLW  0A
13262:  ADDWF  xB9,W
13264:  MOVWF  01
13266:  MOVLW  00
13268:  ADDWFC xBA,W
1326A:  MOVFF  01,8B3
1326E:  MOVWF  xB4
....................  
....................             c = s[index++];c = toupper(c); 
13270:  MOVF   xB7,W
13272:  INCF   xB7,F
13274:  ADDWF  xB1,W
13276:  MOVWF  FE9
13278:  MOVLW  00
1327A:  ADDWFC xB2,W
1327C:  MOVWF  FEA
1327E:  MOVFF  FEF,8B8
13282:  MOVF   xB8,W
13284:  SUBLW  60
13286:  BC    13294
13288:  MOVF   xB8,W
1328A:  SUBLW  7A
1328C:  BNC   13294
1328E:  MOVF   xB8,W
13290:  ANDLW  DF
13292:  BRA    13296
13294:  MOVF   xB8,W
13296:  MOVWF  xB8
13298:  BRA    131F2
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1329A:  MOVF   xB6,W
1329C:  SUBLW  0A
1329E:  BNZ   132AE
132A0:  DECFSZ xB5,W
132A2:  BRA    132AE
....................       result = -result; 
132A4:  COMF   xB3,F
132A6:  COMF   xB4,F
132A8:  INCF   xB3,F
132AA:  BTFSC  FD8.2
132AC:  INCF   xB4,F
....................  
....................    return(result); 
132AE:  MOVFF  8B3,01
132B2:  MOVFF  8B4,02
132B6:  MOVLB  0
132B8:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0C7AE:  MOVLB  8
0C7B0:  CLRF   x81
0C7B2:  CLRF   x80
0C7B4:  CLRF   x7F
0C7B6:  MOVLW  7F
0C7B8:  MOVWF  x7E
0C7BA:  CLRF   x85
0C7BC:  CLRF   x84
0C7BE:  CLRF   x83
0C7C0:  CLRF   x82
0C7C2:  BSF    x86.0
0C7C4:  BCF    x86.1
0C7C6:  BCF    x86.2
0C7C8:  CLRF   x88
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0C7CA:  MOVF   x7A,W
0C7CC:  IORWF  x7B,W
0C7CE:  BNZ   C7DA
....................       return 0; 
0C7D0:  CLRF   00
0C7D2:  CLRF   01
0C7D4:  CLRF   02
0C7D6:  CLRF   03
0C7D8:  BRA    C9FE
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0C7DA:  MOVF   x88,W
0C7DC:  INCF   x88,F
0C7DE:  ADDWF  x7A,W
0C7E0:  MOVWF  FE9
0C7E2:  MOVLW  00
0C7E4:  ADDWFC x7B,W
0C7E6:  MOVWF  FEA
0C7E8:  MOVFF  FEF,887
0C7EC:  MOVF   x87,F
0C7EE:  BTFSC  FD8.2
0C7F0:  BRA    C982
....................    { 
....................       if (skip && !isspace(c)) 
0C7F2:  BTFSS  x86.0
0C7F4:  BRA    C814
0C7F6:  MOVF   x87,W
0C7F8:  SUBLW  20
0C7FA:  BZ    C814
....................       { 
....................          skip = 0; 
0C7FC:  BCF    x86.0
....................          if (c == '+') 
0C7FE:  MOVF   x87,W
0C800:  SUBLW  2B
0C802:  BNZ   C80A
....................          { 
....................             sign = 0; 
0C804:  BCF    x86.1
....................             continue; 
0C806:  BRA    C96A
....................          }             
0C808:  BRA    C814
....................          else if (c == '-') 
0C80A:  MOVF   x87,W
0C80C:  SUBLW  2D
0C80E:  BNZ   C814
....................          { 
....................             sign = 1; 
0C810:  BSF    x86.1
....................             continue; 
0C812:  BRA    C96A
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0C814:  BTFSC  x86.0
0C816:  BRA    C826
0C818:  MOVF   x87,W
0C81A:  SUBLW  2E
0C81C:  BNZ   C826
0C81E:  BTFSC  x86.2
0C820:  BRA    C826
....................          point = 1; 
0C822:  BSF    x86.2
0C824:  BRA    C96A
....................       else if (!skip && isdigit(c)) 
0C826:  BTFSC  x86.0
0C828:  BRA    C964
0C82A:  MOVF   x87,W
0C82C:  SUBLW  2F
0C82E:  BTFSC  FD8.0
0C830:  BRA    C964
0C832:  MOVF   x87,W
0C834:  SUBLW  39
0C836:  BTFSS  FD8.0
0C838:  BRA    C964
....................       { 
....................          c -= '0'; 
0C83A:  MOVLW  30
0C83C:  SUBWF  x87,F
....................          if (point) 
0C83E:  BTFSS  x86.2
0C840:  BRA    C8EC
....................          { 
....................             pow10 = pow10 * 10.0; 
0C842:  MOVFF  881,8F3
0C846:  MOVFF  880,8F2
0C84A:  MOVFF  87F,8F1
0C84E:  MOVFF  87E,8F0
0C852:  CLRF   xF7
0C854:  CLRF   xF6
0C856:  MOVLW  20
0C858:  MOVWF  xF5
0C85A:  MOVLW  82
0C85C:  MOVWF  xF4
0C85E:  MOVLB  0
0C860:  CALL   BF2C
0C864:  MOVFF  03,881
0C868:  MOVFF  02,880
0C86C:  MOVFF  01,87F
0C870:  MOVFF  00,87E
....................             result += (float)c / pow10;    
0C874:  MOVLB  8
0C876:  CLRF   xF5
0C878:  MOVFF  887,8F4
0C87C:  MOVLB  0
0C87E:  RCALL  C61A
0C880:  MOVFF  03,88C
0C884:  MOVFF  02,88B
0C888:  MOVFF  01,88A
0C88C:  MOVFF  00,889
0C890:  MOVFF  03,8DB
0C894:  MOVFF  02,8DA
0C898:  MOVFF  01,8D9
0C89C:  MOVFF  00,8D8
0C8A0:  MOVFF  881,8DF
0C8A4:  MOVFF  880,8DE
0C8A8:  MOVFF  87F,8DD
0C8AC:  MOVFF  87E,8DC
0C8B0:  RCALL  C650
0C8B2:  BCF    FD8.1
0C8B4:  MOVFF  885,8F7
0C8B8:  MOVFF  884,8F6
0C8BC:  MOVFF  883,8F5
0C8C0:  MOVFF  882,8F4
0C8C4:  MOVFF  03,8FB
0C8C8:  MOVFF  02,8FA
0C8CC:  MOVFF  01,8F9
0C8D0:  MOVFF  00,8F8
0C8D4:  CALL   C022
0C8D8:  MOVFF  03,885
0C8DC:  MOVFF  02,884
0C8E0:  MOVFF  01,883
0C8E4:  MOVFF  00,882
....................          } 
0C8E8:  BRA    C960
0C8EA:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0C8EC:  CLRF   xF3
0C8EE:  CLRF   xF2
0C8F0:  MOVLW  20
0C8F2:  MOVWF  xF1
0C8F4:  MOVLW  82
0C8F6:  MOVWF  xF0
0C8F8:  MOVFF  885,8F7
0C8FC:  MOVFF  884,8F6
0C900:  MOVFF  883,8F5
0C904:  MOVFF  882,8F4
0C908:  MOVLB  0
0C90A:  CALL   BF2C
0C90E:  MOVFF  03,88C
0C912:  MOVFF  02,88B
0C916:  MOVFF  01,88A
0C91A:  MOVFF  00,889
0C91E:  MOVLB  8
0C920:  CLRF   xF5
0C922:  MOVFF  887,8F4
0C926:  MOVLB  0
0C928:  RCALL  C61A
0C92A:  BCF    FD8.1
0C92C:  MOVFF  88C,8F7
0C930:  MOVFF  88B,8F6
0C934:  MOVFF  88A,8F5
0C938:  MOVFF  889,8F4
0C93C:  MOVFF  03,8FB
0C940:  MOVFF  02,8FA
0C944:  MOVFF  01,8F9
0C948:  MOVFF  00,8F8
0C94C:  CALL   C022
0C950:  MOVFF  03,885
0C954:  MOVFF  02,884
0C958:  MOVFF  01,883
0C95C:  MOVFF  00,882
....................          } 
....................       } 
0C960:  BRA    C96C
0C962:  MOVLB  8
....................       else if (!skip) 
0C964:  BTFSC  x86.0
0C966:  BRA    C96A
....................          break; 
0C968:  BRA    C982
0C96A:  MOVLB  0
0C96C:  MOVLB  8
0C96E:  MOVF   x88,W
0C970:  INCF   x88,F
0C972:  ADDWF  x7A,W
0C974:  MOVWF  FE9
0C976:  MOVLW  00
0C978:  ADDWFC x7B,W
0C97A:  MOVWF  FEA
0C97C:  MOVFF  FEF,887
0C980:  BRA    C7EC
....................    } 
....................  
....................    if (sign) 
0C982:  BTFSS  x86.1
0C984:  BRA    C9BA
....................       result = -1*result; 
0C986:  CLRF   xF3
0C988:  CLRF   xF2
0C98A:  MOVLW  80
0C98C:  MOVWF  xF1
0C98E:  MOVLW  7F
0C990:  MOVWF  xF0
0C992:  MOVFF  885,8F7
0C996:  MOVFF  884,8F6
0C99A:  MOVFF  883,8F5
0C99E:  MOVFF  882,8F4
0C9A2:  MOVLB  0
0C9A4:  CALL   BF2C
0C9A8:  MOVFF  03,885
0C9AC:  MOVFF  02,884
0C9B0:  MOVFF  01,883
0C9B4:  MOVFF  00,882
0C9B8:  MOVLB  8
....................        
....................    if(endptr) 
0C9BA:  MOVF   x7C,W
0C9BC:  IORWF  x7D,W
0C9BE:  BZ    C9EE
....................    { 
....................       if (ptr) { 
0C9C0:  MOVF   x88,F
0C9C2:  BZ    C9DC
....................          ptr--; 
0C9C4:  DECF   x88,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0C9C6:  MOVFF  87C,FE9
0C9CA:  MOVFF  87D,FEA
0C9CE:  MOVF   x88,W
0C9D0:  ADDWF  x7A,W
0C9D2:  MOVWF  FEF
0C9D4:  MOVLW  00
0C9D6:  ADDWFC x7B,W
0C9D8:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0C9DA:  BRA    C9EE
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0C9DC:  MOVFF  87C,FE9
0C9E0:  MOVFF  87D,FEA
0C9E4:  MOVFF  87B,FEC
0C9E8:  MOVF   FED,F
0C9EA:  MOVFF  87A,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0C9EE:  MOVFF  882,00
0C9F2:  MOVFF  883,01
0C9F6:  MOVFF  884,02
0C9FA:  MOVFF  885,03
0C9FE:  MOVLB  0
0CA00:  GOTO   CA28 (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
1252C:  MOVLB  8
1252E:  BCF    xEF.0
....................    y = x; 
12530:  MOVFF  8E3,8E8
12534:  MOVFF  8E2,8E7
12538:  MOVFF  8E1,8E6
1253C:  MOVFF  8E0,8E5
....................  
....................    if (x < 0) 
12540:  MOVFF  8E3,8F3
12544:  MOVFF  8E2,8F2
12548:  MOVFF  8E1,8F1
1254C:  MOVFF  8E0,8F0
12550:  CLRF   xF7
12552:  CLRF   xF6
12554:  CLRF   xF5
12556:  CLRF   xF4
12558:  MOVLB  0
1255A:  CALL   10460
1255E:  BNC   1256C
....................    { 
....................       s = 1; 
12560:  MOVLB  8
12562:  BSF    xEF.0
....................       y = -y; 
12564:  MOVF   xE6,W
12566:  XORLW  80
12568:  MOVWF  xE6
1256A:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
1256C:  MOVFF  8E8,8F3
12570:  MOVFF  8E7,8F2
12574:  MOVFF  8E6,8F1
12578:  MOVFF  8E5,8F0
1257C:  MOVLB  8
1257E:  CLRF   xF7
12580:  CLRF   xF6
12582:  CLRF   xF5
12584:  MOVLW  8E
12586:  MOVWF  xF4
12588:  MOVLB  0
1258A:  CALL   10460
1258E:  BC    12592
12590:  BNZ   125C2
....................       res = (float32)(unsigned int16)y; 
12592:  MOVFF  8E8,8F3
12596:  MOVFF  8E7,8F2
1259A:  MOVFF  8E6,8F1
1259E:  MOVFF  8E5,8F0
125A2:  RCALL  124F0
125A4:  MOVFF  02,8F5
125A8:  MOVFF  01,8F4
125AC:  CALL   C61A
125B0:  MOVFF  03,8EC
125B4:  MOVFF  02,8EB
125B8:  MOVFF  01,8EA
125BC:  MOVFF  00,8E9
125C0:  BRA    12764
....................  
....................  else if (y < 10000000.0) 
125C2:  MOVFF  8E8,8F3
125C6:  MOVFF  8E7,8F2
125CA:  MOVFF  8E6,8F1
125CE:  MOVFF  8E5,8F0
125D2:  MOVLW  80
125D4:  MOVLB  8
125D6:  MOVWF  xF7
125D8:  MOVLW  96
125DA:  MOVWF  xF6
125DC:  MOVLW  18
125DE:  MOVWF  xF5
125E0:  MOVLW  96
125E2:  MOVWF  xF4
125E4:  MOVLB  0
125E6:  CALL   10460
125EA:  BTFSS  FD8.0
125EC:  BRA    12754
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
125EE:  MOVFF  8E8,8F3
125F2:  MOVFF  8E7,8F2
125F6:  MOVFF  8E6,8F1
125FA:  MOVFF  8E5,8F0
125FE:  MOVLB  8
12600:  CLRF   xF7
12602:  CLRF   xF6
12604:  CLRF   xF5
12606:  MOVLW  70
12608:  MOVWF  xF4
1260A:  MOVLB  0
1260C:  CALL   BF2C
12610:  MOVFF  03,8F3
12614:  MOVFF  02,8F2
12618:  MOVFF  01,8F1
1261C:  MOVFF  00,8F0
12620:  RCALL  124F0
12622:  MOVFF  02,8EE
12626:  MOVFF  01,8ED
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
1262A:  MOVFF  8E8,8F3
1262E:  MOVFF  8E7,8F2
12632:  MOVFF  8E6,8F1
12636:  MOVFF  8E5,8F0
1263A:  MOVLB  8
1263C:  CLRF   xF7
1263E:  CLRF   xF6
12640:  CLRF   xF5
12642:  MOVLW  70
12644:  MOVWF  xF4
12646:  MOVLB  0
12648:  CALL   BF2C
1264C:  MOVFF  03,8F3
12650:  MOVFF  02,8F2
12654:  MOVFF  01,8F1
12658:  MOVFF  00,8F0
1265C:  MOVFF  8EE,8F5
12660:  MOVFF  8ED,8F4
12664:  CALL   C61A
12668:  BSF    FD8.1
1266A:  MOVFF  8F3,8F7
1266E:  MOVFF  8F2,8F6
12672:  MOVFF  8F1,8F5
12676:  MOVFF  8F0,8F4
1267A:  MOVFF  03,8FB
1267E:  MOVFF  02,8FA
12682:  MOVFF  01,8F9
12686:  MOVFF  00,8F8
1268A:  CALL   C022
1268E:  MOVLB  8
12690:  CLRF   xF3
12692:  CLRF   xF2
12694:  CLRF   xF1
12696:  MOVLW  8E
12698:  MOVWF  xF0
1269A:  MOVFF  03,8F7
1269E:  MOVFF  02,8F6
126A2:  MOVFF  01,8F5
126A6:  MOVFF  00,8F4
126AA:  MOVLB  0
126AC:  CALL   BF2C
126B0:  MOVFF  03,8E8
126B4:  MOVFF  02,8E7
126B8:  MOVFF  01,8E6
126BC:  MOVFF  00,8E5
....................       res = 32768.0*(float32)l; 
126C0:  MOVFF  8EE,8F5
126C4:  MOVFF  8ED,8F4
126C8:  CALL   C61A
126CC:  MOVLB  8
126CE:  CLRF   xF3
126D0:  CLRF   xF2
126D2:  CLRF   xF1
126D4:  MOVLW  8E
126D6:  MOVWF  xF0
126D8:  MOVFF  03,8F7
126DC:  MOVFF  02,8F6
126E0:  MOVFF  01,8F5
126E4:  MOVFF  00,8F4
126E8:  MOVLB  0
126EA:  CALL   BF2C
126EE:  MOVFF  03,8EC
126F2:  MOVFF  02,8EB
126F6:  MOVFF  01,8EA
126FA:  MOVFF  00,8E9
....................       res += (float32)(unsigned int16)y; 
126FE:  MOVFF  8E8,8F3
12702:  MOVFF  8E7,8F2
12706:  MOVFF  8E6,8F1
1270A:  MOVFF  8E5,8F0
1270E:  RCALL  124F0
12710:  MOVFF  02,8F5
12714:  MOVFF  01,8F4
12718:  CALL   C61A
1271C:  BCF    FD8.1
1271E:  MOVFF  8EC,8F7
12722:  MOVFF  8EB,8F6
12726:  MOVFF  8EA,8F5
1272A:  MOVFF  8E9,8F4
1272E:  MOVFF  03,8FB
12732:  MOVFF  02,8FA
12736:  MOVFF  01,8F9
1273A:  MOVFF  00,8F8
1273E:  CALL   C022
12742:  MOVFF  03,8EC
12746:  MOVFF  02,8EB
1274A:  MOVFF  01,8EA
1274E:  MOVFF  00,8E9
....................    } 
12752:  BRA    12764
....................  
....................  else 
....................   res = y; 
12754:  MOVFF  8E8,8EC
12758:  MOVFF  8E7,8EB
1275C:  MOVFF  8E6,8EA
12760:  MOVFF  8E5,8E9
....................  
....................  y = y - (float32)(unsigned int16)y; 
12764:  MOVFF  8E8,8F3
12768:  MOVFF  8E7,8F2
1276C:  MOVFF  8E6,8F1
12770:  MOVFF  8E5,8F0
12774:  RCALL  124F0
12776:  MOVFF  02,8F5
1277A:  MOVFF  01,8F4
1277E:  CALL   C61A
12782:  BSF    FD8.1
12784:  MOVFF  8E8,8F7
12788:  MOVFF  8E7,8F6
1278C:  MOVFF  8E6,8F5
12790:  MOVFF  8E5,8F4
12794:  MOVFF  03,8FB
12798:  MOVFF  02,8FA
1279C:  MOVFF  01,8F9
127A0:  MOVFF  00,8F8
127A4:  CALL   C022
127A8:  MOVFF  03,8E8
127AC:  MOVFF  02,8E7
127B0:  MOVFF  01,8E6
127B4:  MOVFF  00,8E5
....................  
....................  if (s) 
127B8:  MOVLB  8
127BA:  BTFSS  xEF.0
127BC:  BRA    127C4
....................   res = -res; 
127BE:  MOVF   xEA,W
127C0:  XORLW  80
127C2:  MOVWF  xEA
....................  
....................  if (y != 0) 
127C4:  MOVFF  8E8,8F3
127C8:  MOVFF  8E7,8F2
127CC:  MOVFF  8E6,8F1
127D0:  MOVFF  8E5,8F0
127D4:  CLRF   xF7
127D6:  CLRF   xF6
127D8:  CLRF   xF5
127DA:  CLRF   xF4
127DC:  MOVLB  0
127DE:  CALL   10460
127E2:  BZ    1285C
....................  { 
....................   if (s == 1 && n == 0) 
127E4:  MOVLB  8
127E6:  BTFSS  xEF.0
127E8:  BRA    12822
127EA:  MOVF   xE4,F
127EC:  BNZ   12822
....................    res -= 1.0; 
127EE:  BSF    FD8.1
127F0:  MOVFF  8EC,8F7
127F4:  MOVFF  8EB,8F6
127F8:  MOVFF  8EA,8F5
127FC:  MOVFF  8E9,8F4
12800:  CLRF   xFB
12802:  CLRF   xFA
12804:  CLRF   xF9
12806:  MOVLW  7F
12808:  MOVWF  xF8
1280A:  MOVLB  0
1280C:  CALL   C022
12810:  MOVFF  03,8EC
12814:  MOVFF  02,8EB
12818:  MOVFF  01,8EA
1281C:  MOVFF  00,8E9
12820:  MOVLB  8
....................  
....................   if (s == 0 && n == 1) 
12822:  BTFSC  xEF.0
12824:  BRA    1285E
12826:  DECFSZ xE4,W
12828:  BRA    1285E
....................    res += 1.0; 
1282A:  BCF    FD8.1
1282C:  MOVFF  8EC,8F7
12830:  MOVFF  8EB,8F6
12834:  MOVFF  8EA,8F5
12838:  MOVFF  8E9,8F4
1283C:  CLRF   xFB
1283E:  CLRF   xFA
12840:  CLRF   xF9
12842:  MOVLW  7F
12844:  MOVWF  xF8
12846:  MOVLB  0
12848:  CALL   C022
1284C:  MOVFF  03,8EC
12850:  MOVFF  02,8EB
12854:  MOVFF  01,8EA
12858:  MOVFF  00,8E9
1285C:  MOVLB  8
....................  } 
....................  if (x == 0) 
1285E:  MOVFF  8E3,8F3
12862:  MOVFF  8E2,8F2
12866:  MOVFF  8E1,8F1
1286A:  MOVFF  8E0,8F0
1286E:  CLRF   xF7
12870:  CLRF   xF6
12872:  CLRF   xF5
12874:  CLRF   xF4
12876:  MOVLB  0
12878:  CALL   10460
1287C:  BNZ   1288A
....................     res = 0; 
1287E:  MOVLB  8
12880:  CLRF   xEC
12882:  CLRF   xEB
12884:  CLRF   xEA
12886:  CLRF   xE9
12888:  MOVLB  0
....................  
....................  return (res); 
1288A:  MOVFF  8E9,00
1288E:  MOVFF  8EA,01
12892:  MOVFF  8EB,02
12896:  MOVFF  8EC,03
1289A:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
128BA:  MOVFF  8DF,8E3
128BE:  MOVFF  8DE,8E2
128C2:  MOVFF  8DD,8E1
128C6:  MOVFF  8DC,8E0
128CA:  MOVLB  8
128CC:  CLRF   xE4
128CE:  MOVLB  0
128D0:  RCALL  1252C
128D2:  GOTO   129DE (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
1289C:  MOVFF  8DF,8E3
128A0:  MOVFF  8DE,8E2
128A4:  MOVFF  8DD,8E1
128A8:  MOVFF  8DC,8E0
128AC:  MOVLW  01
128AE:  MOVLB  8
128B0:  MOVWF  xE4
128B2:  MOVLB  0
128B4:  RCALL  1252C
128B6:  GOTO   12996 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
128D6:  MOVFF  8D3,8F3
128DA:  MOVFF  8D2,8F2
128DE:  MOVFF  8D1,8F1
128E2:  MOVFF  8D0,8F0
128E6:  MOVLB  8
128E8:  CLRF   xF7
128EA:  CLRF   xF6
128EC:  CLRF   xF5
128EE:  CLRF   xF4
128F0:  MOVLB  0
128F2:  CALL   10460
128F6:  BTFSC  FD8.2
128F8:  BRA    12A3A
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
128FA:  MOVFF  8CF,8DB
128FE:  MOVFF  8CE,8DA
12902:  MOVFF  8CD,8D9
12906:  MOVFF  8CC,8D8
1290A:  MOVFF  8D3,8DF
1290E:  MOVFF  8D2,8DE
12912:  MOVFF  8D1,8DD
12916:  MOVFF  8D0,8DC
1291A:  CALL   C650
1291E:  MOVFF  03,8DB
12922:  MOVFF  02,8DA
12926:  MOVFF  01,8D9
1292A:  MOVFF  00,8D8
1292E:  MOVFF  03,8F3
12932:  MOVFF  02,8F2
12936:  MOVFF  01,8F1
1293A:  MOVFF  00,8F0
1293E:  MOVLB  8
12940:  CLRF   xF7
12942:  CLRF   xF6
12944:  CLRF   xF5
12946:  CLRF   xF4
12948:  MOVLB  0
1294A:  CALL   10460
1294E:  BNC   12998
12950:  MOVFF  8CF,8DB
12954:  MOVFF  8CE,8DA
12958:  MOVFF  8CD,8D9
1295C:  MOVFF  8CC,8D8
12960:  MOVFF  8D3,8DF
12964:  MOVFF  8D2,8DE
12968:  MOVFF  8D1,8DD
1296C:  MOVFF  8D0,8DC
12970:  CALL   C650
12974:  MOVFF  03,8DB
12978:  MOVFF  02,8DA
1297C:  MOVFF  01,8D9
12980:  MOVFF  00,8D8
12984:  MOVFF  03,8DF
12988:  MOVFF  02,8DE
1298C:  MOVFF  01,8DD
12990:  MOVFF  00,8DC
12994:  BRA    1289C
12996:  BRA    129DE
12998:  MOVFF  8CF,8DB
1299C:  MOVFF  8CE,8DA
129A0:  MOVFF  8CD,8D9
129A4:  MOVFF  8CC,8D8
129A8:  MOVFF  8D3,8DF
129AC:  MOVFF  8D2,8DE
129B0:  MOVFF  8D1,8DD
129B4:  MOVFF  8D0,8DC
129B8:  CALL   C650
129BC:  MOVFF  03,8DB
129C0:  MOVFF  02,8DA
129C4:  MOVFF  01,8D9
129C8:  MOVFF  00,8D8
129CC:  MOVFF  03,8DF
129D0:  MOVFF  02,8DE
129D4:  MOVFF  01,8DD
129D8:  MOVFF  00,8DC
129DC:  BRA    128BA
129DE:  MOVFF  03,8D7
129E2:  MOVFF  02,8D6
129E6:  MOVFF  01,8D5
129EA:  MOVFF  00,8D4
....................       return(x-(i*y)); 
129EE:  MOVFF  8D7,8F3
129F2:  MOVFF  8D6,8F2
129F6:  MOVFF  8D5,8F1
129FA:  MOVFF  8D4,8F0
129FE:  MOVFF  8D3,8F7
12A02:  MOVFF  8D2,8F6
12A06:  MOVFF  8D1,8F5
12A0A:  MOVFF  8D0,8F4
12A0E:  CALL   BF2C
12A12:  BSF    FD8.1
12A14:  MOVFF  8CF,8F7
12A18:  MOVFF  8CE,8F6
12A1C:  MOVFF  8CD,8F5
12A20:  MOVFF  8CC,8F4
12A24:  MOVFF  03,8FB
12A28:  MOVFF  02,8FA
12A2C:  MOVFF  01,8F9
12A30:  MOVFF  00,8F8
12A34:  CALL   C022
12A38:  BRA    12A3A
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
12A3A:  GOTO   12CD2 (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
1052A:  MOVFF  8B7,8BB
1052E:  MOVFF  8B6,8BA
10532:  MOVFF  8B5,8B9
10536:  MOVFF  8B4,8B8
....................  
....................    if (y != 1.0) 
1053A:  MOVFF  8BB,8F3
1053E:  MOVFF  8BA,8F2
10542:  MOVFF  8B9,8F1
10546:  MOVFF  8B8,8F0
1054A:  MOVLB  8
1054C:  CLRF   xF7
1054E:  CLRF   xF6
10550:  CLRF   xF5
10552:  MOVLW  7F
10554:  MOVWF  xF4
10556:  MOVLB  0
10558:  RCALL  10460
1055A:  BTFSC  FD8.2
1055C:  BRA    1089A
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
1055E:  MOVLW  08
10560:  MOVLB  8
10562:  MOVWF  xCA
10564:  MOVLW  B8
10566:  MOVWF  FE9
10568:  MOVFF  8CA,FEA
1056C:  MOVLW  7E
1056E:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
10570:  BSF    FD8.1
10572:  MOVFF  8BB,8F7
10576:  MOVFF  8BA,8F6
1057A:  MOVFF  8B9,8F5
1057E:  MOVFF  8B8,8F4
10582:  CLRF   xFB
10584:  CLRF   xFA
10586:  CLRF   xF9
10588:  MOVLW  7F
1058A:  MOVWF  xF8
1058C:  MOVLB  0
1058E:  CALL   C022
10592:  MOVFF  03,8CC
10596:  MOVFF  02,8CB
1059A:  MOVFF  01,8CA
1059E:  MOVFF  00,8C9
105A2:  BCF    FD8.1
105A4:  MOVFF  8BB,8F7
105A8:  MOVFF  8BA,8F6
105AC:  MOVFF  8B9,8F5
105B0:  MOVFF  8B8,8F4
105B4:  MOVLB  8
105B6:  CLRF   xFB
105B8:  CLRF   xFA
105BA:  CLRF   xF9
105BC:  MOVLW  7F
105BE:  MOVWF  xF8
105C0:  MOVLB  0
105C2:  CALL   C022
105C6:  MOVFF  8CC,8DB
105CA:  MOVFF  8CB,8DA
105CE:  MOVFF  8CA,8D9
105D2:  MOVFF  8C9,8D8
105D6:  MOVFF  03,8DF
105DA:  MOVFF  02,8DE
105DE:  MOVFF  01,8DD
105E2:  MOVFF  00,8DC
105E6:  CALL   C650
105EA:  MOVFF  03,8BB
105EE:  MOVFF  02,8BA
105F2:  MOVFF  01,8B9
105F6:  MOVFF  00,8B8
....................  
....................       y2=y*y; 
105FA:  MOVFF  8BB,8F3
105FE:  MOVFF  8BA,8F2
10602:  MOVFF  8B9,8F1
10606:  MOVFF  8B8,8F0
1060A:  MOVFF  8BB,8F7
1060E:  MOVFF  8BA,8F6
10612:  MOVFF  8B9,8F5
10616:  MOVFF  8B8,8F4
1061A:  CALL   BF2C
1061E:  MOVFF  03,8C7
10622:  MOVFF  02,8C6
10626:  MOVFF  01,8C5
1062A:  MOVFF  00,8C4
....................  
....................       res = pl[0]*y2 + pl[1]; 
1062E:  MOVLW  99
10630:  MOVLB  8
10632:  MOVWF  xF3
10634:  MOVLW  47
10636:  MOVWF  xF2
10638:  MOVLW  8A
1063A:  MOVWF  xF1
1063C:  MOVLW  7F
1063E:  MOVWF  xF0
10640:  MOVFF  8C7,8F7
10644:  MOVFF  8C6,8F6
10648:  MOVFF  8C5,8F5
1064C:  MOVFF  8C4,8F4
10650:  MOVLB  0
10652:  CALL   BF2C
10656:  MOVFF  03,8CC
1065A:  MOVFF  02,8CB
1065E:  MOVFF  01,8CA
10662:  MOVFF  00,8C9
10666:  BCF    FD8.1
10668:  MOVFF  03,8F7
1066C:  MOVFF  02,8F6
10670:  MOVFF  01,8F5
10674:  MOVFF  00,8F4
10678:  MOVLB  8
1067A:  CLRF   xFB
1067C:  CLRF   xFA
1067E:  CLRF   xF9
10680:  MOVLW  80
10682:  MOVWF  xF8
10684:  MOVLB  0
10686:  CALL   C022
1068A:  MOVFF  03,8BF
1068E:  MOVFF  02,8BE
10692:  MOVFF  01,8BD
10696:  MOVFF  00,8BC
....................  
....................       r = ql[0]*y2 + ql[1]; 
1069A:  MOVLW  4C
1069C:  MOVLB  8
1069E:  MOVWF  xF3
106A0:  MOVLW  F3
106A2:  MOVWF  xF2
106A4:  MOVLW  3A
106A6:  MOVWF  xF1
106A8:  MOVLW  7B
106AA:  MOVWF  xF0
106AC:  MOVFF  8C7,8F7
106B0:  MOVFF  8C6,8F6
106B4:  MOVFF  8C5,8F5
106B8:  MOVFF  8C4,8F4
106BC:  MOVLB  0
106BE:  CALL   BF2C
106C2:  MOVFF  03,8CC
106C6:  MOVFF  02,8CB
106CA:  MOVFF  01,8CA
106CE:  MOVFF  00,8C9
106D2:  BCF    FD8.1
106D4:  MOVFF  03,8F7
106D8:  MOVFF  02,8F6
106DC:  MOVFF  01,8F5
106E0:  MOVFF  00,8F4
106E4:  MOVLW  2B
106E6:  MOVLB  8
106E8:  MOVWF  xFB
106EA:  MOVLW  9D
106EC:  MOVWF  xFA
106EE:  MOVLW  DF
106F0:  MOVWF  xF9
106F2:  MOVLW  7E
106F4:  MOVWF  xF8
106F6:  MOVLB  0
106F8:  CALL   C022
106FC:  MOVFF  03,8C3
10700:  MOVFF  02,8C2
10704:  MOVFF  01,8C1
10708:  MOVFF  00,8C0
....................       r = r*y2 + 1.0; 
1070C:  MOVFF  8C3,8F3
10710:  MOVFF  8C2,8F2
10714:  MOVFF  8C1,8F1
10718:  MOVFF  8C0,8F0
1071C:  MOVFF  8C7,8F7
10720:  MOVFF  8C6,8F6
10724:  MOVFF  8C5,8F5
10728:  MOVFF  8C4,8F4
1072C:  CALL   BF2C
10730:  MOVFF  03,8CC
10734:  MOVFF  02,8CB
10738:  MOVFF  01,8CA
1073C:  MOVFF  00,8C9
10740:  BCF    FD8.1
10742:  MOVFF  03,8F7
10746:  MOVFF  02,8F6
1074A:  MOVFF  01,8F5
1074E:  MOVFF  00,8F4
10752:  MOVLB  8
10754:  CLRF   xFB
10756:  CLRF   xFA
10758:  CLRF   xF9
1075A:  MOVLW  7F
1075C:  MOVWF  xF8
1075E:  MOVLB  0
10760:  CALL   C022
10764:  MOVFF  03,8C3
10768:  MOVFF  02,8C2
1076C:  MOVFF  01,8C1
10770:  MOVFF  00,8C0
....................  
....................       res = y*res/r; 
10774:  MOVFF  8BB,8F3
10778:  MOVFF  8BA,8F2
1077C:  MOVFF  8B9,8F1
10780:  MOVFF  8B8,8F0
10784:  MOVFF  8BF,8F7
10788:  MOVFF  8BE,8F6
1078C:  MOVFF  8BD,8F5
10790:  MOVFF  8BC,8F4
10794:  CALL   BF2C
10798:  MOVFF  03,8CC
1079C:  MOVFF  02,8CB
107A0:  MOVFF  01,8CA
107A4:  MOVFF  00,8C9
107A8:  MOVFF  03,8DB
107AC:  MOVFF  02,8DA
107B0:  MOVFF  01,8D9
107B4:  MOVFF  00,8D8
107B8:  MOVFF  8C3,8DF
107BC:  MOVFF  8C2,8DE
107C0:  MOVFF  8C1,8DD
107C4:  MOVFF  8C0,8DC
107C8:  CALL   C650
107CC:  MOVFF  03,8BF
107D0:  MOVFF  02,8BE
107D4:  MOVFF  01,8BD
107D8:  MOVFF  00,8BC
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
107DC:  MOVLW  08
107DE:  MOVLB  8
107E0:  MOVWF  xCA
107E2:  MOVLW  B4
107E4:  MOVWF  FE9
107E6:  MOVFF  8CA,FEA
107EA:  MOVLW  7E
107EC:  SUBWF  FEF,W
107EE:  MOVWF  xC8
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
107F0:  BTFSS  xC8.7
107F2:  BRA    1081C
....................          r = -(float32)-n; 
107F4:  MOVLW  00
107F6:  BSF    FD8.0
107F8:  SUBFWB xC8,W
107FA:  CLRF   xCA
107FC:  MOVWF  xC9
107FE:  BTFSC  xC9.7
10800:  DECF   xCA,F
10802:  MOVLB  0
10804:  RCALL  104DA
10806:  MOVFF  00,8C0
1080A:  MOVF   01,W
1080C:  XORLW  80
1080E:  MOVLB  8
10810:  MOVWF  xC1
10812:  MOVFF  02,8C2
10816:  MOVFF  03,8C3
1081A:  BRA    1083C
....................       else 
....................          r = (float32)n; 
1081C:  CLRF   xCA
1081E:  MOVFF  8C8,8C9
10822:  BTFSC  xC9.7
10824:  DECF   xCA,F
10826:  MOVLB  0
10828:  RCALL  104DA
1082A:  MOVFF  03,8C3
1082E:  MOVFF  02,8C2
10832:  MOVFF  01,8C1
10836:  MOVFF  00,8C0
1083A:  MOVLB  8
....................  
....................       res += r*LN2; 
1083C:  MOVFF  8C3,8F3
10840:  MOVFF  8C2,8F2
10844:  MOVFF  8C1,8F1
10848:  MOVFF  8C0,8F0
1084C:  MOVLW  18
1084E:  MOVWF  xF7
10850:  MOVLW  72
10852:  MOVWF  xF6
10854:  MOVLW  31
10856:  MOVWF  xF5
10858:  MOVLW  7E
1085A:  MOVWF  xF4
1085C:  MOVLB  0
1085E:  CALL   BF2C
10862:  BCF    FD8.1
10864:  MOVFF  8BF,8F7
10868:  MOVFF  8BE,8F6
1086C:  MOVFF  8BD,8F5
10870:  MOVFF  8BC,8F4
10874:  MOVFF  03,8FB
10878:  MOVFF  02,8FA
1087C:  MOVFF  01,8F9
10880:  MOVFF  00,8F8
10884:  CALL   C022
10888:  MOVFF  03,8BF
1088C:  MOVFF  02,8BE
10890:  MOVFF  01,8BD
10894:  MOVFF  00,8BC
....................    } 
10898:  BRA    108A6
....................  
....................    else 
....................       res = 0.0; 
1089A:  MOVLB  8
1089C:  CLRF   xBF
1089E:  CLRF   xBE
108A0:  CLRF   xBD
108A2:  CLRF   xBC
108A4:  MOVLB  0
....................  
....................    return(res); 
108A6:  MOVFF  8BC,00
108AA:  MOVFF  8BD,01
108AE:  MOVFF  8BE,02
108B2:  MOVFF  8BF,03
108B6:  GOTO   108CC (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
108BA:  MOVFF  8AF,8B7
108BE:  MOVFF  8AE,8B6
108C2:  MOVFF  8AD,8B5
108C6:  MOVFF  8AC,8B4
108CA:  BRA    1052A
108CC:  MOVFF  03,8B3
108D0:  MOVFF  02,8B2
108D4:  MOVFF  01,8B1
108D8:  MOVFF  00,8B0
....................    r = r*LN10_INV; 
108DC:  MOVFF  8B3,8F3
108E0:  MOVFF  8B2,8F2
108E4:  MOVFF  8B1,8F1
108E8:  MOVFF  8B0,8F0
108EC:  MOVLW  D9
108EE:  MOVLB  8
108F0:  MOVWF  xF7
108F2:  MOVLW  5B
108F4:  MOVWF  xF6
108F6:  MOVLW  5E
108F8:  MOVWF  xF5
108FA:  MOVLW  7D
108FC:  MOVWF  xF4
108FE:  MOVLB  0
10900:  CALL   BF2C
10904:  MOVFF  03,8B3
10908:  MOVFF  02,8B2
1090C:  MOVFF  01,8B1
10910:  MOVFF  00,8B0
....................    return(r); 
10914:  MOVFF  8B0,00
10918:  MOVFF  8B1,01
1091C:  MOVFF  8B2,02
10920:  MOVFF  8B3,03
10924:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
0FFDC:  BCF    FC6.5
0FFDE:  MOVLW  21
0FFE0:  MOVWF  FC6
0FFE2:  MOVLW  40
0FFE4:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
0FFE6:  BSF    F91.2
....................    output_high(EEP_WP); 
0FFE8:  BSF    F91.3
0FFEA:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
*
102C8:  BCF    F91.2
....................    spi_write(0x05);  
102CA:  MOVF   FC9,W
102CC:  MOVLW  05
102CE:  MOVWF  FC9
102D0:  RRCF   FC7,W
102D2:  BNC   102D0
....................    data = spi_read(0);  
102D4:  MOVF   FC9,W
102D6:  CLRF   FC9
102D8:  RRCF   FC7,W
102DA:  BNC   102D8
102DC:  MOVFF  FC9,8AB
....................    output_high(EEP_CS);  
102E0:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
102E2:  MOVLW  00
102E4:  MOVLB  8
102E6:  BTFSS  xAB.0
102E8:  MOVLW  01
102EA:  MOVWF  01
102EC:  MOVLB  0
102EE:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
17B44:  MOVLB  8
17B46:  CLRF   xCA
17B48:  MOVLB  0
17B4A:  CALL   54FA
....................       while(!ext_eeprom_ready()); 
17B4E:  CALL   102C8
17B52:  MOVF   01,F
17B54:  BZ    17B4E
....................     
....................       output_low(EEP_CS);  
17B56:  BCF    F91.2
....................       spi_write(0x06);  
17B58:  MOVF   FC9,W
17B5A:  MOVLW  06
17B5C:  MOVWF  FC9
17B5E:  RRCF   FC7,W
17B60:  BNC   17B5E
....................       output_high(EEP_CS);  
17B62:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
17B64:  BCF    F91.2
....................       spi_write(0x02);  
17B66:  MOVF   FC9,W
17B68:  MOVLW  02
17B6A:  MOVWF  FC9
17B6C:  RRCF   FC7,W
17B6E:  BNC   17B6C
....................       spi_write(address >> 8);  
17B70:  MOVFF  885,887
17B74:  MOVLB  8
17B76:  CLRF   x88
17B78:  MOVF   FC9,W
17B7A:  MOVFF  885,FC9
17B7E:  RRCF   FC7,W
17B80:  BNC   17B7E
....................       spi_write(address);  
17B82:  MOVF   FC9,W
17B84:  MOVFF  884,FC9
17B88:  RRCF   FC7,W
17B8A:  BNC   17B88
....................       spi_write(data);  
17B8C:  MOVF   FC9,W
17B8E:  MOVFF  886,FC9
17B92:  RRCF   FC7,W
17B94:  BNC   17B92
....................       output_high(EEP_CS);  
17B96:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
17B98:  MOVLW  01
17B9A:  MOVWF  xCA
17B9C:  MOVLB  0
17B9E:  CALL   54FA
17BA2:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
102F0:  MOVLB  8
102F2:  CLRF   xCA
102F4:  MOVLB  0
102F6:  CALL   54FA
....................     
....................       while(!ext_eeprom_ready()); 
102FA:  RCALL  102C8
102FC:  MOVF   01,F
102FE:  BZ    102FA
....................        
....................       output_low(EEP_CS);  
10300:  BCF    F91.2
....................       spi_write(0x03);  
10302:  MOVF   FC9,W
10304:  MOVLW  03
10306:  MOVWF  FC9
10308:  RRCF   FC7,W
1030A:  BNC   10308
....................       spi_write(address >> 8);  
1030C:  MOVFF  8A9,8AB
10310:  MOVLB  8
10312:  CLRF   xAC
10314:  MOVF   FC9,W
10316:  MOVFF  8A9,FC9
1031A:  RRCF   FC7,W
1031C:  BNC   1031A
....................       spi_write(address);  
1031E:  MOVF   FC9,W
10320:  MOVFF  8A8,FC9
10324:  RRCF   FC7,W
10326:  BNC   10324
....................        
....................       data = spi_read(0);  
10328:  MOVF   FC9,W
1032A:  CLRF   FC9
1032C:  RRCF   FC7,W
1032E:  BNC   1032C
10330:  MOVFF  FC9,8AA
....................       output_high(EEP_CS);  
10334:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
10336:  MOVLW  01
10338:  MOVWF  xCA
1033A:  MOVLB  0
1033C:  CALL   54FA
....................     
....................    return(data);  
10340:  MOVLB  8
10342:  MOVFF  8AA,01
10346:  MOVLB  0
10348:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
03390:  MOVF   FF2,W
03392:  MOVWF  00
03394:  BCF    FF2.7
03396:  CLRF   F63
03398:  MOVFF  866,F62
0339C:  MOVFF  867,F61
033A0:  BCF    F7F.6
033A2:  BCF    F7F.7
033A4:  BSF    F7F.2
033A6:  MOVLB  F
033A8:  MOVLW  55
033AA:  MOVWF  F7E
033AC:  MOVLW  AA
033AE:  MOVWF  F7E
033B0:  BSF    F7F.1
033B2:  BTFSC  F7F.1
033B4:  BRA    33B2
033B6:  BCF    F7F.2
033B8:  MOVF   00,W
033BA:  IORWF  FF2,F
033BC:  MOVLB  0
033BE:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
029A2:  MOVLB  8
029A4:  CLRF   x95
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
029A6:  MOVFF  FF2,896
029AA:  BCF    FF2.7
029AC:  CLRF   F63
029AE:  MOVFF  894,F62
029B2:  BCF    F7F.6
029B4:  BCF    F7F.7
029B6:  BSF    F7F.0
029B8:  MOVF   F61,W
029BA:  BTFSC  x96.7
029BC:  BSF    FF2.7
029BE:  MOVWF  x95
....................    return(data); 
029C0:  MOVFF  895,01
029C4:  MOVLB  0
029C6:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
04F4C:  MOVLB  8
04F4E:  CLRF   xCE
04F50:  MOVF   xCE,W
04F52:  SUBLW  01
04F54:  BNC   4FAE
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
04F56:  MOVF   xCB,W
04F58:  ADDWF  xCE,W
04F5A:  MOVWF  xCF
04F5C:  MOVLW  08
04F5E:  MOVWF  xD1
04F60:  MOVLW  CC
04F62:  MOVWF  xD0
04F64:  MOVF   xCE,W
04F66:  ADDWF  xD0,W
04F68:  MOVWF  01
04F6A:  MOVLW  00
04F6C:  ADDWFC xD1,W
04F6E:  MOVWF  03
04F70:  MOVF   01,W
04F72:  MOVWF  FE9
04F74:  MOVFF  03,FEA
04F78:  MOVFF  FEF,8D0
04F7C:  MOVF   FF2,W
04F7E:  MOVWF  00
04F80:  BCF    FF2.7
04F82:  CLRF   F63
04F84:  MOVFF  8CF,F62
04F88:  MOVFF  8D0,F61
04F8C:  BCF    F7F.6
04F8E:  BCF    F7F.7
04F90:  BSF    F7F.2
04F92:  MOVLB  F
04F94:  MOVLW  55
04F96:  MOVWF  F7E
04F98:  MOVLW  AA
04F9A:  MOVWF  F7E
04F9C:  BSF    F7F.1
04F9E:  BTFSC  F7F.1
04FA0:  BRA    4F9E
04FA2:  BCF    F7F.2
04FA4:  MOVF   00,W
04FA6:  IORWF  FF2,F
04FA8:  MOVLB  8
04FAA:  INCF   xCE,F
04FAC:  BRA    4F50
....................     }  
04FAE:  MOVLB  0
04FB0:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
02948:  MOVLB  8
0294A:  CLRF   x77
0294C:  CLRF   x76
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
0294E:  CLRF   x75
02950:  MOVF   x75,W
02952:  SUBLW  01
02954:  BNC   2996
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02956:  MOVLW  08
02958:  MOVWF  x79
0295A:  MOVLW  76
0295C:  MOVWF  x78
0295E:  MOVF   x75,W
02960:  ADDWF  x78,W
02962:  MOVWF  01
02964:  MOVLW  00
02966:  ADDWFC x79,W
02968:  MOVWF  03
0296A:  MOVF   01,W
0296C:  MOVWF  FE9
0296E:  MOVFF  03,FEA
02972:  MOVF   x74,W
02974:  ADDWF  x75,W
02976:  MOVWF  x7A
02978:  MOVFF  FF2,87B
0297C:  BCF    FF2.7
0297E:  CLRF   F63
02980:  MOVFF  87A,F62
02984:  BCF    F7F.6
02986:  BCF    F7F.7
02988:  BSF    F7F.0
0298A:  MOVF   F61,W
0298C:  BTFSC  x7B.7
0298E:  BSF    FF2.7
02990:  MOVWF  FEF
02992:  INCF   x75,F
02994:  BRA    2950
....................    } 
....................  
....................    return(data);  
02996:  MOVFF  876,01
0299A:  MOVFF  877,02
0299E:  MOVLB  0
029A0:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0CA4A:  MOVLB  8
0CA4C:  CLRF   x68
0CA4E:  MOVF   x68,W
0CA50:  SUBLW  03
0CA52:  BNC   CAB4
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0CA54:  MOVF   x68,W
0CA56:  ADDWF  x62,W
0CA58:  MOVWF  x69
0CA5A:  MOVLW  00
0CA5C:  ADDWFC x63,W
0CA5E:  MOVWF  x6A
0CA60:  MOVLW  08
0CA62:  MOVWF  x6C
0CA64:  MOVLW  64
0CA66:  MOVWF  x6B
0CA68:  MOVF   x68,W
0CA6A:  ADDWF  x6B,W
0CA6C:  MOVWF  01
0CA6E:  MOVLW  00
0CA70:  ADDWFC x6C,W
0CA72:  MOVWF  03
0CA74:  MOVF   01,W
0CA76:  MOVWF  FE9
0CA78:  MOVFF  03,FEA
0CA7C:  MOVFF  FEF,86B
0CA80:  MOVF   FF2,W
0CA82:  MOVWF  00
0CA84:  BCF    FF2.7
0CA86:  MOVFF  86A,F63
0CA8A:  MOVFF  869,F62
0CA8E:  MOVFF  86B,F61
0CA92:  BCF    F7F.6
0CA94:  BCF    F7F.7
0CA96:  BSF    F7F.2
0CA98:  MOVLB  F
0CA9A:  MOVLW  55
0CA9C:  MOVWF  F7E
0CA9E:  MOVLW  AA
0CAA0:  MOVWF  F7E
0CAA2:  BSF    F7F.1
0CAA4:  BTFSC  F7F.1
0CAA6:  BRA    CAA4
0CAA8:  BCF    F7F.2
0CAAA:  MOVF   00,W
0CAAC:  IORWF  FF2,F
0CAAE:  MOVLB  8
0CAB0:  INCF   x68,F
0CAB2:  BRA    CA4E
....................    } 
0CAB4:  MOVLB  0
0CAB6:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
029C8:  MOVLB  8
029CA:  CLRF   x68
029CC:  CLRF   x67
029CE:  CLRF   x66
029D0:  CLRF   x65
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
029D2:  CLRF   x64
029D4:  MOVF   x64,W
029D6:  SUBLW  03
029D8:  BNC   2A22
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
029DA:  MOVLW  08
029DC:  MOVWF  x6A
029DE:  MOVLW  65
029E0:  MOVWF  x69
029E2:  MOVF   x64,W
029E4:  ADDWF  x69,W
029E6:  MOVWF  01
029E8:  MOVLW  00
029EA:  ADDWFC x6A,W
029EC:  MOVWF  03
029EE:  MOVF   01,W
029F0:  MOVWF  FE9
029F2:  MOVFF  03,FEA
029F6:  MOVF   x64,W
029F8:  ADDWF  x62,W
029FA:  MOVWF  x6B
029FC:  MOVLW  00
029FE:  ADDWFC x63,W
02A00:  MOVWF  x6C
02A02:  MOVFF  FF2,86D
02A06:  BCF    FF2.7
02A08:  MOVFF  86C,F63
02A0C:  MOVFF  86B,F62
02A10:  BCF    F7F.6
02A12:  BCF    F7F.7
02A14:  BSF    F7F.0
02A16:  MOVF   F61,W
02A18:  BTFSC  x6D.7
02A1A:  BSF    FF2.7
02A1C:  MOVWF  FEF
02A1E:  INCF   x64,F
02A20:  BRA    29D4
....................    } 
....................  
....................    return(data);  
02A22:  MOVFF  865,00
02A26:  MOVFF  866,01
02A2A:  MOVFF  867,02
02A2E:  MOVFF  868,03
02A32:  MOVLB  0
02A34:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
17D84:  MOVLB  8
17D86:  CLRF   x80
17D88:  MOVF   x80,W
17D8A:  SUBLW  01
17D8C:  BNC   17DCA
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
17D8E:  MOVF   x80,W
17D90:  ADDWF  x7C,W
17D92:  MOVWF  x81
17D94:  MOVLW  00
17D96:  ADDWFC x7D,W
17D98:  MOVWF  x82
17D9A:  MOVLW  08
17D9C:  MOVWF  x84
17D9E:  MOVLW  7E
17DA0:  MOVWF  x83
17DA2:  MOVF   x80,W
17DA4:  ADDWF  x83,W
17DA6:  MOVWF  01
17DA8:  MOVLW  00
17DAA:  ADDWFC x84,W
17DAC:  MOVWF  03
17DAE:  MOVFF  01,FE9
17DB2:  MOVWF  FEA
17DB4:  MOVFF  FEF,886
17DB8:  MOVFF  882,885
17DBC:  MOVFF  881,884
17DC0:  MOVLB  0
17DC2:  RCALL  17B44
17DC4:  MOVLB  8
17DC6:  INCF   x80,F
17DC8:  BRA    17D88
....................     }  
17DCA:  MOVLB  0
17DCC:  GOTO   17E3C (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
10404:  MOVLB  8
10406:  CLRF   xA3
10408:  CLRF   xA2
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
1040A:  CLRF   xA1
1040C:  MOVF   xA1,W
1040E:  SUBLW  01
10410:  BNC   10454
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
10412:  MOVLW  08
10414:  MOVWF  xA5
10416:  MOVLW  A2
10418:  MOVWF  xA4
1041A:  MOVF   xA1,W
1041C:  ADDWF  xA4,W
1041E:  MOVWF  01
10420:  MOVLW  00
10422:  ADDWFC xA5,W
10424:  MOVWF  03
10426:  MOVFF  01,8A4
1042A:  MOVWF  xA5
1042C:  MOVF   xA1,W
1042E:  ADDWF  x9F,W
10430:  MOVWF  xA6
10432:  MOVLW  00
10434:  ADDWFC xA0,W
10436:  MOVWF  xA7
10438:  MOVWF  xA9
1043A:  MOVFF  8A6,8A8
1043E:  MOVLB  0
10440:  RCALL  102F0
10442:  MOVFF  8A5,FEA
10446:  MOVFF  8A4,FE9
1044A:  MOVFF  01,FEF
1044E:  MOVLB  8
10450:  INCF   xA1,F
10452:  BRA    1040C
....................    } 
....................    return(data);  
10454:  MOVFF  8A2,01
10458:  MOVFF  8A3,02
1045C:  MOVLB  0
1045E:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
15826:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
15828:  MOVF   2F,W
1582A:  SUBLW  02
1582C:  BNZ   15834
1582E:  MOVF   30,F
15830:  BNZ   15834
15832:  BSF    F90.6
....................    delay_ms(32); 
15834:  MOVLW  20
15836:  MOVLB  9
15838:  MOVWF  xC9
1583A:  MOVLB  0
1583C:  CALL   288E
....................    output_bit(BOARD_LED, OFF); 
15840:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
15842:  MOVF   2F,W
15844:  SUBLW  02
15846:  BNZ   1584E
15848:  MOVF   30,F
1584A:  BNZ   1584E
1584C:  BCF    F90.6
....................    delay_ms(32); 
1584E:  MOVLW  20
15850:  MOVLB  9
15852:  MOVWF  xC9
15854:  MOVLB  0
15856:  CALL   288E
1585A:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
030C6:  MOVF   2F,W
030C8:  MOVWF  00
030CA:  MOVF   30,W
030CC:  MOVWF  03
030CE:  BNZ   30D4
030D0:  MOVF   00,F
030D2:  BZ    30F6
030D4:  MOVF   03,W
030D6:  BNZ   30DE
030D8:  MOVLW  01
030DA:  SUBWF  00,W
030DC:  BZ    3148
030DE:  MOVF   03,W
030E0:  BNZ   30E8
030E2:  MOVLW  02
030E4:  SUBWF  00,W
030E6:  BZ    319A
030E8:  MOVF   03,W
030EA:  BNZ   30F4
030EC:  MOVLW  03
030EE:  SUBWF  00,W
030F0:  BTFSC  FD8.2
030F2:  BRA    31EC
030F4:  BRA    323E
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
030F6:  MOVLW  BE
030F8:  MOVWF  FF6
030FA:  MOVLW  05
030FC:  MOVWF  FF7
030FE:  MOVLW  00
03100:  MOVWF  FF8
03102:  CLRF   1B
03104:  BTFSC  FF2.7
03106:  BSF    1B.7
03108:  BCF    FF2.7
0310A:  MOVLW  06
0310C:  MOVLB  A
0310E:  MOVWF  x18
03110:  MOVLB  0
03112:  CALL   1006
03116:  BTFSC  1B.7
03118:  BSF    FF2.7
0311A:  MOVLW  CA
0311C:  MOVWF  FF6
0311E:  MOVLW  05
03120:  MOVWF  FF7
03122:  MOVLW  00
03124:  MOVWF  FF8
03126:  CLRF   1B
03128:  BTFSC  FF2.7
0312A:  BSF    1B.7
0312C:  BCF    FF2.7
0312E:  CALL   0E30
03132:  BTFSC  1B.7
03134:  BSF    FF2.7
03136:  MOVLW  0D
03138:  BTFSS  F9E.4
0313A:  BRA    3138
0313C:  MOVWF  FAD
0313E:  MOVLW  0A
03140:  BTFSS  F9E.4
03142:  BRA    3140
03144:  MOVWF  FAD
....................          break; 
03146:  BRA    328E
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
03148:  MOVLW  D2
0314A:  MOVWF  FF6
0314C:  MOVLW  05
0314E:  MOVWF  FF7
03150:  MOVLW  00
03152:  MOVWF  FF8
03154:  CLRF   1B
03156:  BTFSC  FF2.7
03158:  BSF    1B.7
0315A:  BCF    FF2.7
0315C:  MOVLW  09
0315E:  MOVLB  A
03160:  MOVWF  x18
03162:  MOVLB  0
03164:  CALL   1006
03168:  BTFSC  1B.7
0316A:  BSF    FF2.7
0316C:  MOVLW  E0
0316E:  MOVWF  FF6
03170:  MOVLW  05
03172:  MOVWF  FF7
03174:  MOVLW  00
03176:  MOVWF  FF8
03178:  CLRF   1B
0317A:  BTFSC  FF2.7
0317C:  BSF    1B.7
0317E:  BCF    FF2.7
03180:  CALL   0E30
03184:  BTFSC  1B.7
03186:  BSF    FF2.7
03188:  MOVLW  0D
0318A:  BTFSS  F9E.4
0318C:  BRA    318A
0318E:  MOVWF  FAD
03190:  MOVLW  0A
03192:  BTFSS  F9E.4
03194:  BRA    3192
03196:  MOVWF  FAD
....................          break;  
03198:  BRA    328E
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
0319A:  MOVLW  E8
0319C:  MOVWF  FF6
0319E:  MOVLW  05
031A0:  MOVWF  FF7
031A2:  MOVLW  00
031A4:  MOVWF  FF8
031A6:  CLRF   1B
031A8:  BTFSC  FF2.7
031AA:  BSF    1B.7
031AC:  BCF    FF2.7
031AE:  MOVLW  06
031B0:  MOVLB  A
031B2:  MOVWF  x18
031B4:  MOVLB  0
031B6:  CALL   1006
031BA:  BTFSC  1B.7
031BC:  BSF    FF2.7
031BE:  MOVLW  F4
031C0:  MOVWF  FF6
031C2:  MOVLW  05
031C4:  MOVWF  FF7
031C6:  MOVLW  00
031C8:  MOVWF  FF8
031CA:  CLRF   1B
031CC:  BTFSC  FF2.7
031CE:  BSF    1B.7
031D0:  BCF    FF2.7
031D2:  CALL   0E30
031D6:  BTFSC  1B.7
031D8:  BSF    FF2.7
031DA:  MOVLW  0D
031DC:  BTFSS  F9E.4
031DE:  BRA    31DC
031E0:  MOVWF  FAD
031E2:  MOVLW  0A
031E4:  BTFSS  F9E.4
031E6:  BRA    31E4
031E8:  MOVWF  FAD
....................          break; 
031EA:  BRA    328E
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
031EC:  MOVLW  FC
031EE:  MOVWF  FF6
031F0:  MOVLW  05
031F2:  MOVWF  FF7
031F4:  MOVLW  00
031F6:  MOVWF  FF8
031F8:  CLRF   1B
031FA:  BTFSC  FF2.7
031FC:  BSF    1B.7
031FE:  BCF    FF2.7
03200:  MOVLW  09
03202:  MOVLB  A
03204:  MOVWF  x18
03206:  MOVLB  0
03208:  CALL   1006
0320C:  BTFSC  1B.7
0320E:  BSF    FF2.7
03210:  MOVLW  0A
03212:  MOVWF  FF6
03214:  MOVLW  06
03216:  MOVWF  FF7
03218:  MOVLW  00
0321A:  MOVWF  FF8
0321C:  CLRF   1B
0321E:  BTFSC  FF2.7
03220:  BSF    1B.7
03222:  BCF    FF2.7
03224:  CALL   0E30
03228:  BTFSC  1B.7
0322A:  BSF    FF2.7
0322C:  MOVLW  0D
0322E:  BTFSS  F9E.4
03230:  BRA    322E
03232:  MOVWF  FAD
03234:  MOVLW  0A
03236:  BTFSS  F9E.4
03238:  BRA    3236
0323A:  MOVWF  FAD
....................          break;           
0323C:  BRA    328E
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
0323E:  MOVLW  12
03240:  MOVWF  FF6
03242:  MOVLW  06
03244:  MOVWF  FF7
03246:  MOVLW  00
03248:  MOVWF  FF8
0324A:  CLRF   1B
0324C:  BTFSC  FF2.7
0324E:  BSF    1B.7
03250:  BCF    FF2.7
03252:  MOVLW  06
03254:  MOVLB  A
03256:  MOVWF  x18
03258:  MOVLB  0
0325A:  CALL   1006
0325E:  BTFSC  1B.7
03260:  BSF    FF2.7
03262:  MOVLW  1E
03264:  MOVWF  FF6
03266:  MOVLW  06
03268:  MOVWF  FF7
0326A:  MOVLW  00
0326C:  MOVWF  FF8
0326E:  CLRF   1B
03270:  BTFSC  FF2.7
03272:  BSF    1B.7
03274:  BCF    FF2.7
03276:  CALL   0E30
0327A:  BTFSC  1B.7
0327C:  BSF    FF2.7
0327E:  MOVLW  0D
03280:  BTFSS  F9E.4
03282:  BRA    3280
03284:  MOVWF  FAD
03286:  MOVLW  0A
03288:  BTFSS  F9E.4
0328A:  BRA    3288
0328C:  MOVWF  FAD
....................          break; 
....................    } 
0328E:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
1723A:  MOVLW  26
1723C:  MOVWF  FF6
1723E:  MOVLW  06
17240:  MOVWF  FF7
17242:  MOVLW  00
17244:  MOVWF  FF8
17246:  CLRF   1B
17248:  BTFSC  FF2.7
1724A:  BSF    1B.7
1724C:  BCF    FF2.7
1724E:  CALL   0E30
17252:  BTFSC  1B.7
17254:  BSF    FF2.7
17256:  GOTO   17600 (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0AF66:  MOVLW  2E
0AF68:  MOVWF  FF6
0AF6A:  MOVLW  06
0AF6C:  MOVWF  FF7
0AF6E:  MOVLW  00
0AF70:  MOVWF  FF8
0AF72:  CLRF   1B
0AF74:  BTFSC  FF2.7
0AF76:  BSF    1B.7
0AF78:  BCF    FF2.7
0AF7A:  CALL   0E30
0AF7E:  BTFSC  1B.7
0AF80:  BSF    FF2.7
0AF82:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BC28:  MOVLW  36
0BC2A:  MOVWF  FF6
0BC2C:  MOVLW  06
0BC2E:  MOVWF  FF7
0BC30:  MOVLW  00
0BC32:  MOVWF  FF8
0BC34:  CLRF   1B
0BC36:  BTFSC  FF2.7
0BC38:  BSF    1B.7
0BC3A:  BCF    FF2.7
0BC3C:  CALL   0E30
0BC40:  BTFSC  1B.7
0BC42:  BSF    FF2.7
0BC44:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
035D4:  MOVLW  4E
035D6:  MOVWF  FF6
035D8:  MOVLW  06
035DA:  MOVWF  FF7
035DC:  MOVLW  00
035DE:  MOVWF  FF8
035E0:  CLRF   1B
035E2:  BTFSC  FF2.7
035E4:  BSF    1B.7
035E6:  BCF    FF2.7
035E8:  CALL   0E30
035EC:  BTFSC  1B.7
035EE:  BSF    FF2.7
035F0:  GOTO   4346 (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
04FF8:  MOVLW  56
04FFA:  MOVWF  FF6
04FFC:  MOVLW  06
04FFE:  MOVWF  FF7
05000:  MOVLW  00
05002:  MOVWF  FF8
05004:  CLRF   1B
05006:  BTFSC  FF2.7
05008:  BSF    1B.7
0500A:  BCF    FF2.7
0500C:  CALL   0E30
05010:  BTFSC  1B.7
05012:  BSF    FF2.7
05014:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
15D4E:  MOVLW  5E
15D50:  MOVWF  FF6
15D52:  MOVLW  06
15D54:  MOVWF  FF7
15D56:  MOVLW  00
15D58:  MOVWF  FF8
15D5A:  CLRF   1B
15D5C:  BTFSC  FF2.7
15D5E:  BSF    1B.7
15D60:  BCF    FF2.7
15D62:  CALL   0E30
15D66:  BTFSC  1B.7
15D68:  BSF    FF2.7
15D6A:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
*
0ADB2:  DECFSZ 4A,W
0ADB4:  BRA    ADD4
0ADB6:  MOVLW  66
0ADB8:  MOVWF  FF6
0ADBA:  MOVLW  06
0ADBC:  MOVWF  FF7
0ADBE:  MOVLW  00
0ADC0:  MOVWF  FF8
0ADC2:  CLRF   1B
0ADC4:  BTFSC  FF2.7
0ADC6:  BSF    1B.7
0ADC8:  BCF    FF2.7
0ADCA:  CALL   0E30
0ADCE:  BTFSC  1B.7
0ADD0:  BSF    FF2.7
0ADD2:  BRA    ADF0
....................    else fprintf(COM_A, "@RDY\r\n"); 
0ADD4:  MOVLW  6E
0ADD6:  MOVWF  FF6
0ADD8:  MOVLW  06
0ADDA:  MOVWF  FF7
0ADDC:  MOVLW  00
0ADDE:  MOVWF  FF8
0ADE0:  CLRF   1B
0ADE2:  BTFSC  FF2.7
0ADE4:  BSF    1B.7
0ADE6:  BCF    FF2.7
0ADE8:  CALL   0E30
0ADEC:  BTFSC  1B.7
0ADEE:  BSF    FF2.7
0ADF0:  GOTO   1AF3E (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
034BE:  MOVLW  0A
034C0:  MOVLB  A
034C2:  MOVWF  x0E
034C4:  MOVLW  05
034C6:  MOVFF  A0E,A0C
034CA:  MOVWF  x0B
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
034CC:  MOVF   FC9,W
034CE:  SETF   FC9
034D0:  RRCF   FC7,W
034D2:  BNC   34D0
....................    SD_spi_read(sdcmd); 
034D4:  MOVF   FC9,W
034D6:  MOVFF  A04,FC9
034DA:  RRCF   FC7,W
034DC:  BNC   34DA
....................    SD_spi_read(value[3]); 
034DE:  MOVLW  03
034E0:  ADDWF  x0B,W
034E2:  MOVWF  FE9
034E4:  MOVLW  00
034E6:  ADDWFC x0C,W
034E8:  MOVWF  FEA
034EA:  MOVFF  FEF,A0D
034EE:  MOVF   FC9,W
034F0:  MOVFF  A0D,FC9
034F4:  RRCF   FC7,W
034F6:  BNC   34F4
....................    SD_spi_read(value[2]); 
034F8:  MOVLW  02
034FA:  ADDWF  x0B,W
034FC:  MOVWF  FE9
034FE:  MOVLW  00
03500:  ADDWFC x0C,W
03502:  MOVWF  FEA
03504:  MOVFF  FEF,A0D
03508:  MOVF   FC9,W
0350A:  MOVFF  A0D,FC9
0350E:  RRCF   FC7,W
03510:  BNC   350E
....................    SD_spi_read(value[1]); 
03512:  MOVLW  01
03514:  ADDWF  x0B,W
03516:  MOVWF  FE9
03518:  MOVLW  00
0351A:  ADDWFC x0C,W
0351C:  MOVWF  FEA
0351E:  MOVFF  FEF,A0D
03522:  MOVF   FC9,W
03524:  MOVFF  A0D,FC9
03528:  RRCF   FC7,W
0352A:  BNC   3528
....................    SD_spi_read(value[0]); 
0352C:  MOVFF  A0B,FE9
03530:  MOVFF  A0C,FEA
03534:  MOVFF  FEF,A0D
03538:  MOVF   FC9,W
0353A:  MOVFF  A0D,FC9
0353E:  RRCF   FC7,W
03540:  BNC   353E
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
03542:  MOVF   x04,W
03544:  SUBLW  48
03546:  BNZ   3554
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
03548:  MOVF   FC9,W
0354A:  MOVLW  87
0354C:  MOVWF  FC9
0354E:  RRCF   FC7,W
03550:  BNC   354E
03552:  BRA    355E
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
03554:  MOVF   FC9,W
03556:  MOVLW  95
03558:  MOVWF  FC9
0355A:  RRCF   FC7,W
0355C:  BNC   355A
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
0355E:  CLRF   x09
....................    response = SD_spi_read(0xFF); 
03560:  MOVF   FC9,W
03562:  SETF   FC9
03564:  RRCF   FC7,W
03566:  BNC   3564
03568:  MOVFF  FC9,A0A
....................    while ((response == 0xFF) && (i < 100)) 
0356C:  INCFSZ x0A,W
0356E:  BRA    3586
03570:  MOVF   x09,W
03572:  SUBLW  63
03574:  BNC   3586
....................       { 
....................       i++; 
03576:  INCF   x09,F
....................       response = SD_spi_read(0xFF); 
03578:  MOVF   FC9,W
0357A:  SETF   FC9
0357C:  RRCF   FC7,W
0357E:  BNC   357C
03580:  MOVFF  FC9,A0A
03584:  BRA    356C
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
03586:  MOVFF  A0A,01
0358A:  MOVLB  0
0358C:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
04352:  MOVLW  50
04354:  MOVLB  A
04356:  MOVWF  x04
04358:  MOVFF  A03,A08
0435C:  MOVFF  A02,A07
04360:  MOVFF  A01,A06
04364:  MOVFF  A00,A05
04368:  MOVLB  0
0436A:  CALL   34BE
0436E:  MOVF   01,W
04370:  BZ    4378
04372:  XORLW  40
04374:  BZ    438E
04376:  BRA    4394
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
04378:  MOVFF  A03,4E8
0437C:  MOVFF  A02,4E7
04380:  MOVFF  A01,4E6
04384:  MOVFF  A00,4E5
....................          return(TRUE); 
04388:  MOVLW  01
0438A:  MOVWF  01
0438C:  BRA    4398
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
0438E:  MOVLW  00
04390:  MOVWF  01
04392:  BRA    4398
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
04394:  MOVLW  00
04396:  MOVWF  01
....................       } 
04398:  GOTO   447E (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
0439C:  MOVF   FC9,W
0439E:  SETF   FC9
043A0:  RRCF   FC7,W
043A2:  BNC   43A0
043A4:  MOVFF  FC9,A08
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
043A8:  MOVLB  A
043AA:  CLRF   x07
043AC:  CLRF   x06
043AE:  MOVF   x07,W
043B0:  SUBLW  27
043B2:  BNC   43DC
043B4:  BNZ   43BC
043B6:  MOVF   x06,W
043B8:  SUBLW  0F
043BA:  BNC   43DC
043BC:  INCFSZ x08,W
043BE:  BRA    43DC
....................       { 
....................       delay_us(10); 
043C0:  MOVLW  35
043C2:  MOVWF  00
043C4:  DECFSZ 00,F
043C6:  BRA    43C4
....................       response = SD_spi_read(0xFF);  
043C8:  MOVF   FC9,W
043CA:  SETF   FC9
043CC:  RRCF   FC7,W
043CE:  BNC   43CC
043D0:  MOVFF  FC9,A08
043D4:  INCF   x06,F
043D6:  BTFSC  FD8.2
043D8:  INCF   x07,F
043DA:  BRA    43AE
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
043DC:  MOVF   x08,W
043DE:  SUBLW  FE
043E0:  BZ    43F0
....................       { 
....................       if (!response) 
043E2:  MOVF   x08,F
043E4:  BNZ   43EA
....................          response = 0xFE; 
043E6:  MOVLW  FE
043E8:  MOVWF  x08
....................       return(response); 
043EA:  MOVFF  A08,01
043EE:  BRA    4446
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
043F0:  CLRF   x07
043F2:  CLRF   x06
043F4:  MOVF   x05,F
043F6:  BNZ   440A
043F8:  MOVF   x04,F
043FA:  BNZ   440A
043FC:  MOVF   x07,W
043FE:  SUBWF  x03,W
04400:  BNC   442A
04402:  BNZ   440A
04404:  MOVF   x02,W
04406:  SUBWF  x06,W
04408:  BC    442A
....................       ptr[i]=SD_spi_read(0xFF); 
0440A:  MOVF   x00,W
0440C:  ADDWF  x06,W
0440E:  MOVWF  FE9
04410:  MOVF   x01,W
04412:  ADDWFC x07,W
04414:  MOVWF  FEA
04416:  MOVF   FC9,W
04418:  SETF   FC9
0441A:  RRCF   FC7,W
0441C:  BNC   441A
0441E:  MOVFF  FC9,FEF
04422:  INCF   x06,F
04424:  BTFSC  FD8.2
04426:  INCF   x07,F
04428:  BRA    43F4
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
0442A:  MOVF   FC9,W
0442C:  SETF   FC9
0442E:  RRCF   FC7,W
04430:  BNC   442E
....................    SD_spi_read(0xFF); 
04432:  MOVF   FC9,W
04434:  SETF   FC9
04436:  RRCF   FC7,W
04438:  BNC   4436
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
0443A:  MOVF   FC9,W
0443C:  SETF   FC9
0443E:  RRCF   FC7,W
04440:  BNC   443E
....................    return(0); 
04442:  MOVLW  00
04444:  MOVWF  01
04446:  MOVLB  0
04448:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
057BA:  MOVLW  C3
057BC:  MOVLB  A
057BE:  MOVWF  x08
057C0:  MOVLW  50
057C2:  MOVWF  x07
....................    SD_spi_read(0xFF); 
057C4:  MOVF   FC9,W
057C6:  SETF   FC9
057C8:  RRCF   FC7,W
057CA:  BNC   57C8
....................    do 
....................       { 
....................       delay_us(10); 
057CC:  MOVLW  35
057CE:  MOVWF  00
057D0:  DECFSZ 00,F
057D2:  BRA    57D0
....................       response = SD_spi_read(0xFF); 
057D4:  MOVF   FC9,W
057D6:  SETF   FC9
057D8:  RRCF   FC7,W
057DA:  BNC   57D8
057DC:  MOVFF  FC9,A06
....................       Timer--; 
057E0:  MOVF   x07,W
057E2:  BTFSC  FD8.2
057E4:  DECF   x08,F
057E6:  DECF   x07,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
057E8:  INCFSZ x06,W
057EA:  BRA    57EE
057EC:  BRA    57F4
057EE:  MOVF   x07,W
057F0:  IORWF  x08,W
057F2:  BNZ   57CC
....................       ; 
....................  
....................    return (response); 
057F4:  MOVFF  A06,01
057F8:  MOVLB  0
057FA:  GOTO   580A (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
057FE:  MOVLW  02
05800:  MOVLB  A
05802:  MOVWF  x05
05804:  CLRF   x04
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
05806:  MOVLB  0
05808:  BRA    57BA
0580A:  INCFSZ 01,W
0580C:  BRA    5810
0580E:  BRA    5816
....................       return (FALSE); 
05810:  MOVLW  00
05812:  MOVWF  01
05814:  BRA    58B0
....................  
....................    SD_spi_write(token);               // transmit data token 
05816:  MOVF   FC9,W
05818:  MOVFF  A02,FC9
0581C:  RRCF   FC7,W
0581E:  BNC   581C
....................    if (token != 0xFD) 
05820:  MOVLB  A
05822:  MOVF   x02,W
05824:  SUBLW  FD
05826:  BZ    58AA
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
05828:  MOVFF  A05,03
0582C:  MOVF   x04,W
0582E:  BTFSC  FD8.2
05830:  DECF   x05,F
05832:  DECF   x04,F
05834:  IORWF  03,W
05836:  BZ    585A
....................          SD_spi_write(*ptr++); 
05838:  MOVFF  A01,03
0583C:  MOVF   x00,W
0583E:  INCF   x00,F
05840:  BTFSC  FD8.2
05842:  INCF   x01,F
05844:  MOVWF  FE9
05846:  MOVFF  03,FEA
0584A:  MOVFF  FEF,A06
0584E:  MOVF   FC9,W
05850:  MOVFF  A06,FC9
05854:  RRCF   FC7,W
05856:  BNC   5854
05858:  BRA    5828
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
0585A:  MOVF   FC9,W
0585C:  SETF   FC9
0585E:  RRCF   FC7,W
05860:  BNC   585E
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
05862:  MOVF   FC9,W
05864:  SETF   FC9
05866:  RRCF   FC7,W
05868:  BNC   5866
....................       response = SD_spi_read(0xFF);      // Receive data response 
0586A:  MOVF   FC9,W
0586C:  SETF   FC9
0586E:  RRCF   FC7,W
05870:  BNC   586E
05872:  MOVFF  FC9,A03
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
05876:  CLRF   x05
05878:  CLRF   x04
0587A:  MOVF   x05,W
0587C:  SUBLW  C3
0587E:  BNC   58AA
05880:  BNZ   5888
05882:  MOVF   x04,W
05884:  SUBLW  4F
05886:  BNC   58AA
....................          { 
....................          delay_us(10); 
05888:  MOVLW  35
0588A:  MOVWF  00
0588C:  DECFSZ 00,F
0588E:  BRA    588C
....................          response = SD_spi_read(0xFF);   // digest prior operation 
05890:  MOVF   FC9,W
05892:  SETF   FC9
05894:  RRCF   FC7,W
05896:  BNC   5894
05898:  MOVFF  FC9,A03
....................          if (response != 0x00) 
0589C:  MOVF   x03,F
0589E:  BZ    58A2
....................             break; 
058A0:  BRA    58AA
058A2:  INCF   x04,F
058A4:  BTFSC  FD8.2
058A6:  INCF   x05,F
058A8:  BRA    587A
....................          } 
....................  
....................       } 
....................    return(TRUE); 
058AA:  MOVLW  01
058AC:  MOVWF  01
058AE:  MOVLB  0
058B0:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
058B2:  MOVLB  4
058B4:  BTFSS  xE9.0
058B6:  BRA    58BE
....................       return (RES_NOTRDY); 
058B8:  MOVLW  03
058BA:  MOVWF  01
058BC:  BRA    59F4
....................  
....................    if (Media_Status & STA_PROTECT) 
058BE:  BTFSS  xE9.2
058C0:  BRA    58C8
....................       return (RES_WRPRT); 
058C2:  MOVLW  02
058C4:  MOVWF  01
058C6:  BRA    59F4
....................  
....................    if (!SectorCount) 
058C8:  MOVLB  9
058CA:  MOVF   xFF,F
058CC:  BNZ   58D8
....................       return (RES_PARERR); 
058CE:  MOVLW  04
058D0:  MOVWF  01
058D2:  MOVLB  4
058D4:  BRA    59F4
058D6:  MOVLB  9
....................  
....................    SelectSD; 
058D8:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
058DA:  MOVLB  4
058DC:  MOVF   xE3,W
058DE:  SUBLW  05
058E0:  BZ    58FC
....................       SectorNumber *= 512; 
058E2:  BCF    FD8.0
058E4:  MOVFF  9FD,9FE
058E8:  MOVFF  9FC,9FD
058EC:  MOVFF  9FB,9FC
058F0:  MOVLB  9
058F2:  CLRF   xFB
058F4:  RLCF   xFC,F
058F6:  RLCF   xFD,F
058F8:  RLCF   xFE,F
058FA:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
058FC:  MOVLB  9
058FE:  DECFSZ xFF,W
05900:  BRA    5942
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
05902:  MOVLW  58
05904:  MOVLB  A
05906:  MOVWF  x04
05908:  MOVFF  9FE,A08
0590C:  MOVFF  9FD,A07
05910:  MOVFF  9FC,A06
05914:  MOVFF  9FB,A05
05918:  MOVLB  0
0591A:  CALL   34BE
0591E:  MOVF   01,F
05920:  BNZ   593E
....................          if (SD_write_data(Buffer, 0xFE)) 
05922:  MOVFF  9FA,A01
05926:  MOVFF  9F9,A00
0592A:  MOVLW  FE
0592C:  MOVLB  A
0592E:  MOVWF  x02
05930:  MOVLB  0
05932:  RCALL  57FE
05934:  MOVF   01,F
05936:  BZ    593E
....................             SectorCount = 0; 
05938:  MOVLB  9
0593A:  CLRF   xFF
0593C:  MOVLB  0
....................       } 
0593E:  BRA    59DA
05940:  MOVLB  9
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
05942:  MOVLB  4
05944:  MOVF   xE3,W
05946:  ANDLW  03
05948:  BZ    5976
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
0594A:  MOVLW  77
0594C:  MOVLB  A
0594E:  MOVWF  x04
05950:  CLRF   x08
05952:  CLRF   x07
05954:  CLRF   x06
05956:  CLRF   x05
05958:  MOVLB  0
0595A:  CALL   34BE
....................          SD_cmd(SD_ACMD23, SectorCount); 
0595E:  MOVLW  57
05960:  MOVLB  A
05962:  MOVWF  x04
05964:  CLRF   x08
05966:  CLRF   x07
05968:  CLRF   x06
0596A:  MOVFF  9FF,A05
0596E:  MOVLB  0
05970:  CALL   34BE
05974:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
05976:  MOVLW  59
05978:  MOVLB  A
0597A:  MOVWF  x04
0597C:  MOVFF  9FE,A08
05980:  MOVFF  9FD,A07
05984:  MOVFF  9FC,A06
05988:  MOVFF  9FB,A05
0598C:  MOVLB  0
0598E:  CALL   34BE
05992:  MOVF   01,F
05994:  BNZ   59DA
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
05996:  MOVFF  9FA,A01
0599A:  MOVFF  9F9,A00
0599E:  MOVLW  FC
059A0:  MOVLB  A
059A2:  MOVWF  x02
059A4:  MOVLB  0
059A6:  RCALL  57FE
059A8:  MOVF   01,F
059AA:  BNZ   59AE
....................                break; 
059AC:  BRA    59C0
....................             Buffer += 512; 
059AE:  MOVLW  02
059B0:  MOVLB  9
059B2:  ADDWF  xFA,F
....................             } while (--SectorCount); 
059B4:  DECF   xFF,F
059B6:  BTFSC  FD8.2
059B8:  BRA    59BE
059BA:  MOVLB  0
059BC:  BRA    5996
059BE:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
059C0:  MOVLB  A
059C2:  CLRF   x01
059C4:  CLRF   x00
059C6:  MOVLW  FD
059C8:  MOVWF  x02
059CA:  MOVLB  0
059CC:  RCALL  57FE
059CE:  MOVF   01,F
059D0:  BNZ   59DA
....................             SectorCount = 1; 
059D2:  MOVLW  01
059D4:  MOVLB  9
059D6:  MOVWF  xFF
059D8:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
059DA:  BSF    F91.1
....................    SD_spi_read(0xFF); 
059DC:  MOVF   FC9,W
059DE:  SETF   FC9
059E0:  RRCF   FC7,W
059E2:  BNC   59E0
....................    return SectorCount ? RES_ERROR : RES_OK; 
059E4:  MOVLB  9
059E6:  MOVF   xFF,F
059E8:  BZ    59EE
059EA:  MOVLW  01
059EC:  BRA    59F0
059EE:  MOVLW  00
059F0:  MOVWF  01
059F2:  MOVLB  4
059F4:  MOVLB  0
059F6:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
0444A:  MOVLB  4
0444C:  BTFSS  xE9.0
0444E:  BRA    4456
....................       return (RES_NOTRDY); 
04450:  MOVLW  03
04452:  MOVWF  01
04454:  BRA    458E
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
04456:  MOVLB  9
04458:  MOVF   xFF,W
0445A:  SUBLW  01
0445C:  BNC   4462
0445E:  MOVF   xFF,F
04460:  BNZ   446C
....................       return(RES_PARERR); 
04462:  MOVLW  04
04464:  MOVWF  01
04466:  MOVLB  4
04468:  BRA    458E
0446A:  MOVLB  9
....................  
....................    SelectSD; 
0446C:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
0446E:  MOVLB  A
04470:  CLRF   x03
04472:  CLRF   x02
04474:  MOVLW  02
04476:  MOVWF  x01
04478:  CLRF   x00
0447A:  MOVLB  0
0447C:  BRA    4352
0447E:  MOVF   01,F
04480:  BNZ   448E
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
04482:  BSF    F91.1
....................       return(RES_ERROR); 
04484:  MOVLW  01
04486:  MOVWF  01
04488:  MOVLB  4
0448A:  BRA    458E
0448C:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
0448E:  MOVLB  4
04490:  MOVF   xE3,W
04492:  SUBLW  05
04494:  BZ    44B0
....................       SectorNumber *= 512; 
04496:  BCF    FD8.0
04498:  MOVFF  9FD,9FE
0449C:  MOVFF  9FC,9FD
044A0:  MOVFF  9FB,9FC
044A4:  MOVLB  9
044A6:  CLRF   xFB
044A8:  RLCF   xFC,F
044AA:  RLCF   xFD,F
044AC:  RLCF   xFE,F
044AE:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
044B0:  MOVLB  9
044B2:  DECFSZ xFF,W
044B4:  BRA    450E
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
044B6:  MOVLW  51
044B8:  MOVLB  A
044BA:  MOVWF  x04
044BC:  MOVFF  9FE,A08
044C0:  MOVFF  9FD,A07
044C4:  MOVFF  9FC,A06
044C8:  MOVFF  9FB,A05
044CC:  MOVLB  0
044CE:  CALL   34BE
044D2:  MOVF   01,F
044D4:  BZ    44E2
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
044D6:  BSF    F91.1
....................          return(RES_PARERR); 
044D8:  MOVLW  04
044DA:  MOVWF  01
044DC:  MOVLB  4
044DE:  BRA    458E
044E0:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
044E2:  MOVFF  9FA,A01
044E6:  MOVFF  9F9,A00
044EA:  MOVLB  A
044EC:  CLRF   x05
044EE:  CLRF   x04
044F0:  MOVLW  02
044F2:  MOVWF  x03
044F4:  CLRF   x02
044F6:  MOVLB  0
044F8:  RCALL  439C
044FA:  MOVF   01,F
044FC:  BZ    450A
....................          { 
....................          DeselectSD; 
044FE:  BSF    F91.1
....................          return(RES_ERROR); 
04500:  MOVLW  01
04502:  MOVWF  01
04504:  MOVLB  4
04506:  BRA    458E
04508:  MOVLB  0
....................          } 
....................       } 
0450A:  BRA    4586
0450C:  MOVLB  9
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
0450E:  MOVLW  52
04510:  MOVLB  A
04512:  MOVWF  x04
04514:  MOVFF  9FE,A08
04518:  MOVFF  9FD,A07
0451C:  MOVFF  9FC,A06
04520:  MOVFF  9FB,A05
04524:  MOVLB  0
04526:  CALL   34BE
0452A:  MOVF   01,F
0452C:  BZ    453A
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
0452E:  BSF    F91.1
....................          return(RES_PARERR); 
04530:  MOVLW  04
04532:  MOVWF  01
04534:  MOVLB  4
04536:  BRA    458E
04538:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
0453A:  MOVFF  9FA,A01
0453E:  MOVFF  9F9,A00
04542:  MOVLB  A
04544:  CLRF   x05
04546:  CLRF   x04
04548:  MOVLW  02
0454A:  MOVWF  x03
0454C:  CLRF   x02
0454E:  MOVLB  0
04550:  RCALL  439C
04552:  MOVF   01,F
04554:  BZ    4562
....................             { 
....................             DeselectSD; 
04556:  BSF    F91.1
....................             return(RES_ERROR); 
04558:  MOVLW  01
0455A:  MOVWF  01
0455C:  MOVLB  4
0455E:  BRA    458E
04560:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
04562:  MOVLW  02
04564:  MOVLB  9
04566:  ADDWF  xFA,F
....................          } while (--SectorCount); 
04568:  DECF   xFF,F
0456A:  BTFSC  FD8.2
0456C:  BRA    4572
0456E:  MOVLB  0
04570:  BRA    453A
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
04572:  MOVLW  4C
04574:  MOVLB  A
04576:  MOVWF  x04
04578:  CLRF   x08
0457A:  CLRF   x07
0457C:  CLRF   x06
0457E:  CLRF   x05
04580:  MOVLB  0
04582:  CALL   34BE
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
04586:  BSF    F91.1
....................    return(RES_OK); 
04588:  MOVLW  00
0458A:  MOVWF  01
0458C:  MOVLB  4
0458E:  MOVLB  0
04590:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
05512:  MOVLB  4
05514:  BCF    xE9.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
05516:  BCF    xE9.2
....................  
....................    return(Media_Status); 
05518:  MOVFF  4E9,01
0551C:  MOVLB  0
0551E:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
035F4:  MOVLB  9
035F6:  CLRF   xC8
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
035F8:  MOVLB  4
035FA:  CLRF   xE3
....................  
....................    DeselectSD; 
035FC:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
035FE:  MOVLW  0A
03600:  MOVLB  9
03602:  MOVWF  xC9
03604:  MOVLB  0
03606:  CALL   288E
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
0360A:  BCF    FC6.5
0360C:  MOVLW  22
0360E:  MOVWF  FC6
03610:  MOVLW  40
03612:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
03614:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
03616:  MOVLB  9
03618:  CLRF   xC0
0361A:  MOVF   xC0,W
0361C:  SUBLW  09
0361E:  BNC   362C
....................       SD_spi_read(0xFF); 
03620:  MOVF   FC9,W
03622:  SETF   FC9
03624:  RRCF   FC7,W
03626:  BNC   3624
03628:  INCF   xC0,F
0362A:  BRA    361A
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
0362C:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
0362E:  MOVF   1F,W
03630:  SUBLW  04
03632:  BNZ   3658
03634:  MOVF   20,F
03636:  BNZ   3658
03638:  MOVLW  76
0363A:  MOVWF  FF6
0363C:  MOVLW  06
0363E:  MOVWF  FF7
03640:  MOVLW  00
03642:  MOVWF  FF8
03644:  CLRF   1B
03646:  BTFSC  FF2.7
03648:  BSF    1B.7
0364A:  BCF    FF2.7
0364C:  MOVLB  0
0364E:  CALL   0E30
03652:  BTFSC  1B.7
03654:  BSF    FF2.7
03656:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
03658:  MOVLW  40
0365A:  MOVLB  A
0365C:  MOVWF  x04
0365E:  CLRF   x08
03660:  CLRF   x07
03662:  CLRF   x06
03664:  CLRF   x05
03666:  MOVLB  0
03668:  RCALL  34BE
0366A:  MOVFF  01,9C1
....................    if (response > 1 ) 
0366E:  MOVLB  9
03670:  MOVF   xC1,W
03672:  SUBLW  01
03674:  BC    36CA
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
03676:  MOVF   1F,W
03678:  SUBLW  04
0367A:  BNZ   36C4
0367C:  MOVF   20,F
0367E:  BNZ   36C4
03680:  MOVLW  86
03682:  MOVWF  FF6
03684:  MOVLW  06
03686:  MOVWF  FF7
03688:  MOVLW  00
0368A:  MOVWF  FF8
0368C:  CLRF   1B
0368E:  BTFSC  FF2.7
03690:  BSF    1B.7
03692:  BCF    FF2.7
03694:  MOVLW  31
03696:  MOVLB  A
03698:  MOVWF  x18
0369A:  MOVLB  0
0369C:  CALL   1006
036A0:  BTFSC  1B.7
036A2:  BSF    FF2.7
036A4:  MOVFF  9C1,9C9
036A8:  MOVLW  57
036AA:  MOVLB  9
036AC:  MOVWF  xCA
036AE:  MOVLB  0
036B0:  RCALL  358E
036B2:  MOVLW  0D
036B4:  BTFSS  F9E.4
036B6:  BRA    36B4
036B8:  MOVWF  FAD
036BA:  MOVLW  0A
036BC:  BTFSS  F9E.4
036BE:  BRA    36BC
036C0:  MOVWF  FAD
036C2:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
036C4:  BSF    xC8.0
....................       goto Exit_disk_initialize; 
036C6:  GOTO   4348
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
036CA:  MOVF   1F,W
036CC:  SUBLW  04
036CE:  BNZ   3718
036D0:  MOVF   20,F
036D2:  BNZ   3718
036D4:  MOVLW  BE
036D6:  MOVWF  FF6
036D8:  MOVLW  06
036DA:  MOVWF  FF7
036DC:  MOVLW  00
036DE:  MOVWF  FF8
036E0:  CLRF   1B
036E2:  BTFSC  FF2.7
036E4:  BSF    1B.7
036E6:  BCF    FF2.7
036E8:  MOVLW  1A
036EA:  MOVLB  A
036EC:  MOVWF  x18
036EE:  MOVLB  0
036F0:  CALL   1006
036F4:  BTFSC  1B.7
036F6:  BSF    FF2.7
036F8:  MOVFF  9C1,9C9
036FC:  MOVLW  57
036FE:  MOVLB  9
03700:  MOVWF  xCA
03702:  MOVLB  0
03704:  RCALL  358E
03706:  MOVLW  0D
03708:  BTFSS  F9E.4
0370A:  BRA    3708
0370C:  MOVWF  FAD
0370E:  MOVLW  0A
03710:  BTFSS  F9E.4
03712:  BRA    3710
03714:  MOVWF  FAD
03716:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
03718:  MOVLW  48
0371A:  MOVLB  A
0371C:  MOVWF  x04
0371E:  CLRF   x08
03720:  CLRF   x07
03722:  MOVLW  01
03724:  MOVWF  x06
03726:  MOVLW  AA
03728:  MOVWF  x05
0372A:  MOVLB  0
0372C:  RCALL  34BE
0372E:  MOVFF  01,9C1
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
03732:  MOVF   1F,W
03734:  SUBLW  04
03736:  BNZ   377E
03738:  MOVF   20,F
0373A:  BNZ   377E
0373C:  MOVLW  E0
0373E:  MOVWF  FF6
03740:  MOVLW  06
03742:  MOVWF  FF7
03744:  MOVLW  00
03746:  MOVWF  FF8
03748:  CLRF   1B
0374A:  BTFSC  FF2.7
0374C:  BSF    1B.7
0374E:  BCF    FF2.7
03750:  MOVLW  25
03752:  MOVLB  A
03754:  MOVWF  x18
03756:  MOVLB  0
03758:  CALL   1006
0375C:  BTFSC  1B.7
0375E:  BSF    FF2.7
03760:  MOVFF  9C1,9C9
03764:  MOVLW  57
03766:  MOVLB  9
03768:  MOVWF  xCA
0376A:  MOVLB  0
0376C:  RCALL  358E
0376E:  MOVLW  0D
03770:  BTFSS  F9E.4
03772:  BRA    3770
03774:  MOVWF  FAD
03776:  MOVLW  0A
03778:  BTFSS  F9E.4
0377A:  BRA    3778
0377C:  MOVWF  FAD
....................    if (response == 1)  
0377E:  MOVLB  9
03780:  DECFSZ xC1,W
03782:  BRA    3B54
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
03784:  MOVF   1F,W
03786:  SUBLW  04
03788:  BNZ   37AE
0378A:  MOVF   20,F
0378C:  BNZ   37AE
0378E:  MOVLW  0A
03790:  MOVWF  FF6
03792:  MOVLW  07
03794:  MOVWF  FF7
03796:  MOVLW  00
03798:  MOVWF  FF8
0379A:  CLRF   1B
0379C:  BTFSC  FF2.7
0379E:  BSF    1B.7
037A0:  BCF    FF2.7
037A2:  MOVLB  0
037A4:  CALL   0E30
037A8:  BTFSC  1B.7
037AA:  BSF    FF2.7
037AC:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
037AE:  CLRF   xC0
037B0:  MOVF   xC0,W
037B2:  SUBLW  03
037B4:  BNC   37D4
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
037B6:  CLRF   03
037B8:  MOVF   xC0,W
037BA:  ADDLW  C2
037BC:  MOVWF  FE9
037BE:  MOVLW  09
037C0:  ADDWFC 03,W
037C2:  MOVWF  FEA
037C4:  MOVF   FC9,W
037C6:  SETF   FC9
037C8:  RRCF   FC7,W
037CA:  BNC   37C8
037CC:  MOVFF  FC9,FEF
037D0:  INCF   xC0,F
037D2:  BRA    37B0
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
037D4:  MOVF   1F,W
037D6:  SUBLW  04
037D8:  BNZ   384C
037DA:  MOVF   20,F
037DC:  BNZ   384C
037DE:  MOVLW  2C
037E0:  MOVWF  FF6
037E2:  MOVLW  07
037E4:  MOVWF  FF7
037E6:  MOVLW  00
037E8:  MOVWF  FF8
037EA:  CLRF   1B
037EC:  BTFSC  FF2.7
037EE:  BSF    1B.7
037F0:  BCF    FF2.7
037F2:  MOVLW  1F
037F4:  MOVLB  A
037F6:  MOVWF  x18
037F8:  MOVLB  0
037FA:  CALL   1006
037FE:  BTFSC  1B.7
03800:  BSF    FF2.7
03802:  MOVFF  9C2,9C9
03806:  MOVLW  57
03808:  MOVLB  9
0380A:  MOVWF  xCA
0380C:  MOVLB  0
0380E:  RCALL  358E
03810:  MOVFF  9C3,9C9
03814:  MOVLW  57
03816:  MOVLB  9
03818:  MOVWF  xCA
0381A:  MOVLB  0
0381C:  RCALL  358E
0381E:  MOVFF  9C4,9C9
03822:  MOVLW  57
03824:  MOVLB  9
03826:  MOVWF  xCA
03828:  MOVLB  0
0382A:  RCALL  358E
0382C:  MOVFF  9C5,9C9
03830:  MOVLW  57
03832:  MOVLB  9
03834:  MOVWF  xCA
03836:  MOVLB  0
03838:  RCALL  358E
0383A:  MOVLW  0D
0383C:  BTFSS  F9E.4
0383E:  BRA    383C
03840:  MOVWF  FAD
03842:  MOVLW  0A
03844:  BTFSS  F9E.4
03846:  BRA    3844
03848:  MOVWF  FAD
0384A:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
0384C:  DECFSZ xC4,W
0384E:  BRA    3B2A
03850:  MOVF   xC5,W
03852:  SUBLW  AA
03854:  BTFSS  FD8.2
03856:  BRA    3B2A
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
03858:  MOVF   1F,W
0385A:  SUBLW  04
0385C:  BNZ   3882
0385E:  MOVF   20,F
03860:  BNZ   3882
03862:  MOVLW  5E
03864:  MOVWF  FF6
03866:  MOVLW  07
03868:  MOVWF  FF7
0386A:  MOVLW  00
0386C:  MOVWF  FF8
0386E:  CLRF   1B
03870:  BTFSC  FF2.7
03872:  BSF    1B.7
03874:  BCF    FF2.7
03876:  MOVLB  0
03878:  CALL   0E30
0387C:  BTFSC  1B.7
0387E:  BSF    FF2.7
03880:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
03882:  MOVF   1F,W
03884:  SUBLW  04
03886:  BNZ   38AC
03888:  MOVF   20,F
0388A:  BNZ   38AC
0388C:  MOVLW  84
0388E:  MOVWF  FF6
03890:  MOVLW  07
03892:  MOVWF  FF7
03894:  MOVLW  00
03896:  MOVWF  FF8
03898:  CLRF   1B
0389A:  BTFSC  FF2.7
0389C:  BSF    1B.7
0389E:  BCF    FF2.7
038A0:  MOVLB  0
038A2:  CALL   0E30
038A6:  BTFSC  1B.7
038A8:  BSF    FF2.7
038AA:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
038AC:  CLRF   xC7
038AE:  CLRF   xC6
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
038B0:  MOVLW  77
038B2:  MOVLB  A
038B4:  MOVWF  x04
038B6:  CLRF   x08
038B8:  CLRF   x07
038BA:  CLRF   x06
038BC:  CLRF   x05
038BE:  MOVLB  0
038C0:  RCALL  34BE
038C2:  MOVFF  01,9C1
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
038C6:  MOVLW  69
038C8:  MOVLB  A
038CA:  MOVWF  x04
038CC:  MOVLW  40
038CE:  MOVWF  x08
038D0:  CLRF   x07
038D2:  CLRF   x06
038D4:  CLRF   x05
038D6:  MOVLB  0
038D8:  RCALL  34BE
038DA:  MOVFF  01,9C1
....................          while (response && (Timer < 50000)) 
038DE:  MOVLB  9
038E0:  MOVF   xC1,F
038E2:  BZ    3934
038E4:  MOVF   xC7,W
038E6:  SUBLW  C3
038E8:  BNC   3934
038EA:  BNZ   38F2
038EC:  MOVF   xC6,W
038EE:  SUBLW  4F
038F0:  BNC   3934
....................          { 
....................             delay_us(20); 
038F2:  MOVLW  6A
038F4:  MOVWF  00
038F6:  DECFSZ 00,F
038F8:  BRA    38F6
038FA:  NOP   
....................             Timer++; 
038FC:  INCF   xC6,F
038FE:  BTFSC  FD8.2
03900:  INCF   xC7,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
03902:  MOVLW  77
03904:  MOVLB  A
03906:  MOVWF  x04
03908:  CLRF   x08
0390A:  CLRF   x07
0390C:  CLRF   x06
0390E:  CLRF   x05
03910:  MOVLB  0
03912:  RCALL  34BE
03914:  MOVFF  01,9C1
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
03918:  MOVLW  69
0391A:  MOVLB  A
0391C:  MOVWF  x04
0391E:  MOVLW  40
03920:  MOVWF  x08
03922:  CLRF   x07
03924:  CLRF   x06
03926:  CLRF   x05
03928:  MOVLB  0
0392A:  RCALL  34BE
0392C:  MOVFF  01,9C1
03930:  BRA    38DE
03932:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
03934:  MOVF   1F,W
03936:  SUBLW  04
03938:  BNZ   39C2
0393A:  MOVF   20,F
0393C:  BNZ   39C2
0393E:  MOVLW  B2
03940:  MOVWF  FF6
03942:  MOVLW  07
03944:  MOVWF  FF7
03946:  MOVLW  00
03948:  MOVWF  FF8
0394A:  CLRF   1B
0394C:  BTFSC  FF2.7
0394E:  BSF    1B.7
03950:  BCF    FF2.7
03952:  MOVLW  23
03954:  MOVLB  A
03956:  MOVWF  x18
03958:  MOVLB  0
0395A:  CALL   1006
0395E:  BTFSC  1B.7
03960:  BSF    FF2.7
03962:  MOVFF  9C1,9C9
03966:  MOVLW  57
03968:  MOVLB  9
0396A:  MOVWF  xCA
0396C:  MOVLB  0
0396E:  RCALL  358E
03970:  MOVLW  D9
03972:  MOVWF  FF6
03974:  MOVLW  07
03976:  MOVWF  FF7
03978:  MOVLW  00
0397A:  MOVWF  FF8
0397C:  CLRF   1B
0397E:  BTFSC  FF2.7
03980:  BSF    1B.7
03982:  BCF    FF2.7
03984:  MOVLW  0A
03986:  MOVLB  A
03988:  MOVWF  x18
0398A:  MOVLB  0
0398C:  CALL   1006
03990:  BTFSC  1B.7
03992:  BSF    FF2.7
03994:  MOVLW  10
03996:  MOVWF  FE9
03998:  CLRF   1B
0399A:  BTFSC  FF2.7
0399C:  BSF    1B.7
0399E:  BCF    FF2.7
039A0:  MOVFF  9C7,A19
039A4:  MOVFF  9C6,A18
039A8:  CALL   1188
039AC:  BTFSC  1B.7
039AE:  BSF    FF2.7
039B0:  MOVLW  0D
039B2:  BTFSS  F9E.4
039B4:  BRA    39B2
039B6:  MOVWF  FAD
039B8:  MOVLW  0A
039BA:  BTFSS  F9E.4
039BC:  BRA    39BA
039BE:  MOVWF  FAD
039C0:  MOVLB  9
....................          if (!response) 
039C2:  MOVF   xC1,F
039C4:  BTFSS  FD8.2
039C6:  BRA    3B28
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
039C8:  MOVLW  7A
039CA:  MOVLB  A
039CC:  MOVWF  x04
039CE:  MOVLW  40
039D0:  MOVWF  x08
039D2:  CLRF   x07
039D4:  CLRF   x06
039D6:  CLRF   x05
039D8:  MOVLB  0
039DA:  RCALL  34BE
039DC:  MOVFF  01,9C1
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
039E0:  MOVF   1F,W
039E2:  SUBLW  04
039E4:  BNZ   3A2C
039E6:  MOVF   20,F
039E8:  BNZ   3A2C
039EA:  MOVLW  EA
039EC:  MOVWF  FF6
039EE:  MOVLW  07
039F0:  MOVWF  FF7
039F2:  MOVLW  00
039F4:  MOVWF  FF8
039F6:  CLRF   1B
039F8:  BTFSC  FF2.7
039FA:  BSF    1B.7
039FC:  BCF    FF2.7
039FE:  MOVLW  18
03A00:  MOVLB  A
03A02:  MOVWF  x18
03A04:  MOVLB  0
03A06:  CALL   1006
03A0A:  BTFSC  1B.7
03A0C:  BSF    FF2.7
03A0E:  MOVFF  9C1,9C9
03A12:  MOVLW  57
03A14:  MOVLB  9
03A16:  MOVWF  xCA
03A18:  MOVLB  0
03A1A:  RCALL  358E
03A1C:  MOVLW  0D
03A1E:  BTFSS  F9E.4
03A20:  BRA    3A1E
03A22:  MOVWF  FAD
03A24:  MOVLW  0A
03A26:  BTFSS  F9E.4
03A28:  BRA    3A26
03A2A:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03A2C:  MOVLB  9
03A2E:  MOVF   xC1,F
03A30:  BTFSS  FD8.2
03A32:  BRA    3B28
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03A34:  CLRF   xC0
03A36:  MOVF   xC0,W
03A38:  SUBLW  03
03A3A:  BNC   3A5A
....................                   ocr[i] = SD_spi_read(0xFF); 
03A3C:  CLRF   03
03A3E:  MOVF   xC0,W
03A40:  ADDLW  C2
03A42:  MOVWF  FE9
03A44:  MOVLW  09
03A46:  ADDWFC 03,W
03A48:  MOVWF  FEA
03A4A:  MOVF   FC9,W
03A4C:  SETF   FC9
03A4E:  RRCF   FC7,W
03A50:  BNC   3A4E
03A52:  MOVFF  FC9,FEF
03A56:  INCF   xC0,F
03A58:  BRA    3A36
....................                if (ocr[0] & 0x40) 
03A5A:  BTFSS  xC2.6
03A5C:  BRA    3A68
....................                   Card = SDHC; 
03A5E:  MOVLW  05
03A60:  MOVLB  4
03A62:  MOVWF  xE3
03A64:  BRA    3A6E
03A66:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03A68:  MOVLW  04
03A6A:  MOVLB  4
03A6C:  MOVWF  xE3
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03A6E:  MOVF   1F,W
03A70:  SUBLW  04
03A72:  BNZ   3B26
03A74:  MOVF   20,F
03A76:  BNZ   3B26
03A78:  MOVLW  08
03A7A:  MOVWF  FF6
03A7C:  MOVLW  08
03A7E:  MOVWF  FF7
03A80:  MOVLW  00
03A82:  MOVWF  FF8
03A84:  CLRF   1B
03A86:  BTFSC  FF2.7
03A88:  BSF    1B.7
03A8A:  BCF    FF2.7
03A8C:  MOVLW  1F
03A8E:  MOVLB  A
03A90:  MOVWF  x18
03A92:  MOVLB  0
03A94:  CALL   1006
03A98:  BTFSC  1B.7
03A9A:  BSF    FF2.7
03A9C:  MOVLW  10
03A9E:  MOVWF  FE9
03AA0:  CLRF   1B
03AA2:  BTFSC  FF2.7
03AA4:  BSF    1B.7
03AA6:  BCF    FF2.7
03AA8:  MOVFF  9C7,A19
03AAC:  MOVFF  9C6,A18
03AB0:  CALL   1188
03AB4:  BTFSC  1B.7
03AB6:  BSF    FF2.7
03AB8:  MOVLW  2A
03ABA:  MOVWF  FF6
03ABC:  MOVLW  08
03ABE:  MOVWF  FF7
03AC0:  MOVLW  00
03AC2:  MOVWF  FF8
03AC4:  CLRF   1B
03AC6:  BTFSC  FF2.7
03AC8:  BSF    1B.7
03ACA:  BCF    FF2.7
03ACC:  MOVLW  08
03ACE:  MOVLB  A
03AD0:  MOVWF  x18
03AD2:  MOVLB  0
03AD4:  CALL   1006
03AD8:  BTFSC  1B.7
03ADA:  BSF    FF2.7
03ADC:  MOVFF  9C2,9C9
03AE0:  MOVLW  57
03AE2:  MOVLB  9
03AE4:  MOVWF  xCA
03AE6:  MOVLB  0
03AE8:  RCALL  358E
03AEA:  MOVFF  9C3,9C9
03AEE:  MOVLW  57
03AF0:  MOVLB  9
03AF2:  MOVWF  xCA
03AF4:  MOVLB  0
03AF6:  RCALL  358E
03AF8:  MOVFF  9C4,9C9
03AFC:  MOVLW  57
03AFE:  MOVLB  9
03B00:  MOVWF  xCA
03B02:  MOVLB  0
03B04:  RCALL  358E
03B06:  MOVFF  9C5,9C9
03B0A:  MOVLW  57
03B0C:  MOVLB  9
03B0E:  MOVWF  xCA
03B10:  MOVLB  0
03B12:  RCALL  358E
03B14:  MOVLW  0D
03B16:  BTFSS  F9E.4
03B18:  BRA    3B16
03B1A:  MOVWF  FAD
03B1C:  MOVLW  0A
03B1E:  BTFSS  F9E.4
03B20:  BRA    3B1E
03B22:  MOVWF  FAD
03B24:  MOVLB  4
03B26:  MOVLB  9
....................             } 
....................          } 
....................       } 
03B28:  BRA    3B54
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03B2A:  MOVF   1F,W
03B2C:  SUBLW  04
03B2E:  BNZ   3B54
03B30:  MOVF   20,F
03B32:  BNZ   3B54
03B34:  MOVLW  46
03B36:  MOVWF  FF6
03B38:  MOVLW  08
03B3A:  MOVWF  FF7
03B3C:  MOVLW  00
03B3E:  MOVWF  FF8
03B40:  CLRF   1B
03B42:  BTFSC  FF2.7
03B44:  BSF    1B.7
03B46:  BCF    FF2.7
03B48:  MOVLB  0
03B4A:  CALL   0E30
03B4E:  BTFSC  1B.7
03B50:  BSF    FF2.7
03B52:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03B54:  MOVLB  4
03B56:  MOVF   xE3,F
03B58:  BTFSS  FD8.2
03B5A:  BRA    402A
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03B5C:  MOVF   1F,W
03B5E:  SUBLW  04
03B60:  BNZ   3B86
03B62:  MOVF   20,F
03B64:  BNZ   3B86
03B66:  MOVLW  78
03B68:  MOVWF  FF6
03B6A:  MOVLW  08
03B6C:  MOVWF  FF7
03B6E:  MOVLW  00
03B70:  MOVWF  FF8
03B72:  CLRF   1B
03B74:  BTFSC  FF2.7
03B76:  BSF    1B.7
03B78:  BCF    FF2.7
03B7A:  MOVLB  0
03B7C:  CALL   0E30
03B80:  BTFSC  1B.7
03B82:  BSF    FF2.7
03B84:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03B86:  MOVLW  40
03B88:  MOVLB  A
03B8A:  MOVWF  x04
03B8C:  CLRF   x08
03B8E:  CLRF   x07
03B90:  CLRF   x06
03B92:  CLRF   x05
03B94:  MOVLB  0
03B96:  RCALL  34BE
03B98:  MOVFF  01,9C1
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03B9C:  MOVF   1F,W
03B9E:  SUBLW  04
03BA0:  BNZ   3BE8
03BA2:  MOVF   20,F
03BA4:  BNZ   3BE8
03BA6:  MOVLW  B8
03BA8:  MOVWF  FF6
03BAA:  MOVLW  08
03BAC:  MOVWF  FF7
03BAE:  MOVLW  00
03BB0:  MOVWF  FF8
03BB2:  CLRF   1B
03BB4:  BTFSC  FF2.7
03BB6:  BSF    1B.7
03BB8:  BCF    FF2.7
03BBA:  MOVLW  1C
03BBC:  MOVLB  A
03BBE:  MOVWF  x18
03BC0:  MOVLB  0
03BC2:  CALL   1006
03BC6:  BTFSC  1B.7
03BC8:  BSF    FF2.7
03BCA:  MOVFF  9C1,9C9
03BCE:  MOVLW  57
03BD0:  MOVLB  9
03BD2:  MOVWF  xCA
03BD4:  MOVLB  0
03BD6:  RCALL  358E
03BD8:  MOVLW  0D
03BDA:  BTFSS  F9E.4
03BDC:  BRA    3BDA
03BDE:  MOVWF  FAD
03BE0:  MOVLW  0A
03BE2:  BTFSS  F9E.4
03BE4:  BRA    3BE2
03BE6:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03BE8:  MOVLB  9
03BEA:  DECFSZ xC1,W
03BEC:  BRA    3BF0
03BEE:  BRA    3BFA
03BF0:  MOVF   xC1,F
03BF2:  BZ    3BFA
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03BF4:  BSF    xC8.0
....................          goto Exit_disk_initialize; 
03BF6:  GOTO   4348
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03BFA:  CLRF   xC7
03BFC:  CLRF   xC6
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03BFE:  MOVLW  41
03C00:  MOVLB  A
03C02:  MOVWF  x04
03C04:  CLRF   x08
03C06:  CLRF   x07
03C08:  CLRF   x06
03C0A:  CLRF   x05
03C0C:  MOVLB  0
03C0E:  RCALL  34BE
03C10:  MOVFF  01,9C1
....................          if (response != 0x00 ) 
03C14:  MOVLB  9
03C16:  MOVF   xC1,F
03C18:  BZ    3C22
....................             delay_us(10); 
03C1A:  MOVLW  35
03C1C:  MOVWF  00
03C1E:  DECFSZ 00,F
03C20:  BRA    3C1E
....................          Timer++; 
03C22:  INCF   xC6,F
03C24:  BTFSC  FD8.2
03C26:  INCF   xC7,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03C28:  MOVF   xC1,F
03C2A:  BZ    3C3A
03C2C:  MOVF   xC7,W
03C2E:  SUBLW  C3
03C30:  BNC   3C3A
03C32:  BNZ   3BFE
03C34:  MOVF   xC6,W
03C36:  SUBLW  4F
03C38:  BC    3BFE
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03C3A:  MOVF   1F,W
03C3C:  SUBLW  04
03C3E:  BNZ   3CC8
03C40:  MOVF   20,F
03C42:  BNZ   3CC8
03C44:  MOVLW  DC
03C46:  MOVWF  FF6
03C48:  MOVLW  08
03C4A:  MOVWF  FF7
03C4C:  MOVLW  00
03C4E:  MOVWF  FF8
03C50:  CLRF   1B
03C52:  BTFSC  FF2.7
03C54:  BSF    1B.7
03C56:  BCF    FF2.7
03C58:  MOVLW  28
03C5A:  MOVLB  A
03C5C:  MOVWF  x18
03C5E:  MOVLB  0
03C60:  CALL   1006
03C64:  BTFSC  1B.7
03C66:  BSF    FF2.7
03C68:  MOVFF  9C1,9C9
03C6C:  MOVLW  57
03C6E:  MOVLB  9
03C70:  MOVWF  xCA
03C72:  MOVLB  0
03C74:  RCALL  358E
03C76:  MOVLW  08
03C78:  MOVWF  FF6
03C7A:  MOVLW  09
03C7C:  MOVWF  FF7
03C7E:  MOVLW  00
03C80:  MOVWF  FF8
03C82:  CLRF   1B
03C84:  BTFSC  FF2.7
03C86:  BSF    1B.7
03C88:  BCF    FF2.7
03C8A:  MOVLW  0A
03C8C:  MOVLB  A
03C8E:  MOVWF  x18
03C90:  MOVLB  0
03C92:  CALL   1006
03C96:  BTFSC  1B.7
03C98:  BSF    FF2.7
03C9A:  MOVLW  10
03C9C:  MOVWF  FE9
03C9E:  CLRF   1B
03CA0:  BTFSC  FF2.7
03CA2:  BSF    1B.7
03CA4:  BCF    FF2.7
03CA6:  MOVFF  9C7,A19
03CAA:  MOVFF  9C6,A18
03CAE:  CALL   1188
03CB2:  BTFSC  1B.7
03CB4:  BSF    FF2.7
03CB6:  MOVLW  0D
03CB8:  BTFSS  F9E.4
03CBA:  BRA    3CB8
03CBC:  MOVWF  FAD
03CBE:  MOVLW  0A
03CC0:  BTFSS  F9E.4
03CC2:  BRA    3CC0
03CC4:  MOVWF  FAD
03CC6:  MOVLB  9
....................       if(response) 
03CC8:  MOVF   xC1,F
03CCA:  BZ    3CD0
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03CCC:  BSF    xC8.0
....................          goto Exit_disk_initialize; 
03CCE:  BRA    4348
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03CD0:  MOVLW  77
03CD2:  MOVLB  A
03CD4:  MOVWF  x04
03CD6:  CLRF   x08
03CD8:  CLRF   x07
03CDA:  CLRF   x06
03CDC:  CLRF   x05
03CDE:  MOVLB  0
03CE0:  CALL   34BE
03CE4:  MOVFF  01,9C1
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03CE8:  MOVF   1F,W
03CEA:  SUBLW  04
03CEC:  BNZ   3D34
03CEE:  MOVF   20,F
03CF0:  BNZ   3D34
03CF2:  MOVLW  18
03CF4:  MOVWF  FF6
03CF6:  MOVLW  09
03CF8:  MOVWF  FF7
03CFA:  MOVLW  00
03CFC:  MOVWF  FF8
03CFE:  CLRF   1B
03D00:  BTFSC  FF2.7
03D02:  BSF    1B.7
03D04:  BCF    FF2.7
03D06:  MOVLW  43
03D08:  MOVLB  A
03D0A:  MOVWF  x18
03D0C:  MOVLB  0
03D0E:  CALL   1006
03D12:  BTFSC  1B.7
03D14:  BSF    FF2.7
03D16:  MOVFF  9C1,9C9
03D1A:  MOVLW  57
03D1C:  MOVLB  9
03D1E:  MOVWF  xCA
03D20:  MOVLB  0
03D22:  RCALL  358E
03D24:  MOVLW  0D
03D26:  BTFSS  F9E.4
03D28:  BRA    3D26
03D2A:  MOVWF  FAD
03D2C:  MOVLW  0A
03D2E:  BTFSS  F9E.4
03D30:  BRA    3D2E
03D32:  MOVWF  FAD
....................       if (response) 
03D34:  MOVLB  9
03D36:  MOVF   xC1,F
03D38:  BZ    3D44
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03D3A:  MOVLW  02
03D3C:  MOVLB  4
03D3E:  MOVWF  xE3
....................          } 
03D40:  BRA    3F3E
03D42:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03D44:  MOVLW  69
03D46:  MOVLB  A
03D48:  MOVWF  x04
03D4A:  CLRF   x08
03D4C:  CLRF   x07
03D4E:  CLRF   x06
03D50:  CLRF   x05
03D52:  MOVLB  0
03D54:  CALL   34BE
03D58:  MOVFF  01,9C1
....................          if (response <= 1 ) 
03D5C:  MOVLB  9
03D5E:  MOVF   xC1,W
03D60:  SUBLW  01
03D62:  BNC   3D6E
....................             Card = SDv1; 
03D64:  MOVLW  03
03D66:  MOVLB  4
03D68:  MOVWF  xE3
03D6A:  BRA    3F3E
03D6C:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03D6E:  MOVF   1F,W
03D70:  SUBLW  04
03D72:  BNZ   3DD2
03D74:  MOVF   20,F
03D76:  BNZ   3DD2
03D78:  MOVLW  62
03D7A:  MOVWF  FF6
03D7C:  MOVLW  09
03D7E:  MOVWF  FF7
03D80:  MOVLW  00
03D82:  MOVWF  FF8
03D84:  CLRF   1B
03D86:  BTFSC  FF2.7
03D88:  BSF    1B.7
03D8A:  BCF    FF2.7
03D8C:  MOVLW  2E
03D8E:  MOVLB  A
03D90:  MOVWF  x18
03D92:  MOVLB  0
03D94:  CALL   1006
03D98:  BTFSC  1B.7
03D9A:  BSF    FF2.7
03D9C:  MOVFF  9C1,9C9
03DA0:  MOVLW  37
03DA2:  MOVLB  9
03DA4:  MOVWF  xCA
03DA6:  MOVLB  0
03DA8:  CALL   358E
03DAC:  MOVLW  94
03DAE:  MOVWF  FF6
03DB0:  MOVLW  09
03DB2:  MOVWF  FF7
03DB4:  MOVLW  00
03DB6:  MOVWF  FF8
03DB8:  CLRF   1B
03DBA:  BTFSC  FF2.7
03DBC:  BSF    1B.7
03DBE:  BCF    FF2.7
03DC0:  MOVLW  19
03DC2:  MOVLB  A
03DC4:  MOVWF  x18
03DC6:  MOVLB  0
03DC8:  CALL   1006
03DCC:  BTFSC  1B.7
03DCE:  BSF    FF2.7
03DD0:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03DD2:  MOVLW  40
03DD4:  MOVLB  A
03DD6:  MOVWF  x04
03DD8:  CLRF   x08
03DDA:  CLRF   x07
03DDC:  CLRF   x06
03DDE:  CLRF   x05
03DE0:  MOVLB  0
03DE2:  CALL   34BE
03DE6:  MOVFF  01,9C1
....................             if ((response !=0x01) && (response != 0)) 
03DEA:  MOVLB  9
03DEC:  DECFSZ xC1,W
03DEE:  BRA    3DF2
03DF0:  BRA    3E5E
03DF2:  MOVF   xC1,F
03DF4:  BZ    3E5E
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03DF6:  MOVF   1F,W
03DF8:  SUBLW  04
03DFA:  BNZ   3E5A
03DFC:  MOVF   20,F
03DFE:  BNZ   3E5A
03E00:  MOVLW  AE
03E02:  MOVWF  FF6
03E04:  MOVLW  09
03E06:  MOVWF  FF7
03E08:  MOVLW  00
03E0A:  MOVWF  FF8
03E0C:  CLRF   1B
03E0E:  BTFSC  FF2.7
03E10:  BSF    1B.7
03E12:  BCF    FF2.7
03E14:  MOVLW  2C
03E16:  MOVLB  A
03E18:  MOVWF  x18
03E1A:  MOVLB  0
03E1C:  CALL   1006
03E20:  BTFSC  1B.7
03E22:  BSF    FF2.7
03E24:  MOVFF  9C1,9C9
03E28:  MOVLW  37
03E2A:  MOVLB  9
03E2C:  MOVWF  xCA
03E2E:  MOVLB  0
03E30:  CALL   358E
03E34:  MOVLW  DE
03E36:  MOVWF  FF6
03E38:  MOVLW  09
03E3A:  MOVWF  FF7
03E3C:  MOVLW  00
03E3E:  MOVWF  FF8
03E40:  CLRF   1B
03E42:  BTFSC  FF2.7
03E44:  BSF    1B.7
03E46:  BCF    FF2.7
03E48:  MOVLW  0B
03E4A:  MOVLB  A
03E4C:  MOVWF  x18
03E4E:  MOVLB  0
03E50:  CALL   1006
03E54:  BTFSC  1B.7
03E56:  BSF    FF2.7
03E58:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03E5A:  BSF    xC8.0
....................                goto Exit_disk_initialize; 
03E5C:  BRA    4348
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03E5E:  CLRF   xC7
03E60:  CLRF   xC6
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03E62:  MOVLW  41
03E64:  MOVLB  A
03E66:  MOVWF  x04
03E68:  CLRF   x08
03E6A:  CLRF   x07
03E6C:  CLRF   x06
03E6E:  CLRF   x05
03E70:  MOVLB  0
03E72:  CALL   34BE
03E76:  MOVFF  01,9C1
....................                if (response != 0x00 ) 
03E7A:  MOVLB  9
03E7C:  MOVF   xC1,F
03E7E:  BZ    3E88
....................                   delay_us(10); 
03E80:  MOVLW  35
03E82:  MOVWF  00
03E84:  DECFSZ 00,F
03E86:  BRA    3E84
....................                Timer++; 
03E88:  INCF   xC6,F
03E8A:  BTFSC  FD8.2
03E8C:  INCF   xC7,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03E8E:  MOVF   xC1,F
03E90:  BZ    3EA0
03E92:  MOVF   xC7,W
03E94:  SUBLW  C3
03E96:  BNC   3EA0
03E98:  BNZ   3E62
03E9A:  MOVF   xC6,W
03E9C:  SUBLW  4F
03E9E:  BC    3E62
....................     
....................             if(response) 
03EA0:  MOVF   xC1,F
03EA2:  BZ    3F38
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03EA4:  MOVF   1F,W
03EA6:  SUBLW  04
03EA8:  BNZ   3F34
03EAA:  MOVF   20,F
03EAC:  BNZ   3F34
03EAE:  MOVLW  EA
03EB0:  MOVWF  FF6
03EB2:  MOVLW  09
03EB4:  MOVWF  FF7
03EB6:  MOVLW  00
03EB8:  MOVWF  FF8
03EBA:  CLRF   1B
03EBC:  BTFSC  FF2.7
03EBE:  BSF    1B.7
03EC0:  BCF    FF2.7
03EC2:  MOVLW  4A
03EC4:  MOVLB  A
03EC6:  MOVWF  x18
03EC8:  MOVLB  0
03ECA:  CALL   1006
03ECE:  BTFSC  1B.7
03ED0:  BSF    FF2.7
03ED2:  MOVFF  9C1,9C9
03ED6:  MOVLW  37
03ED8:  MOVLB  9
03EDA:  MOVWF  xCA
03EDC:  MOVLB  0
03EDE:  CALL   358E
03EE2:  MOVLW  38
03EE4:  MOVWF  FF6
03EE6:  MOVLW  0A
03EE8:  MOVWF  FF7
03EEA:  MOVLW  00
03EEC:  MOVWF  FF8
03EEE:  CLRF   1B
03EF0:  BTFSC  FF2.7
03EF2:  BSF    1B.7
03EF4:  BCF    FF2.7
03EF6:  MOVLW  0A
03EF8:  MOVLB  A
03EFA:  MOVWF  x18
03EFC:  MOVLB  0
03EFE:  CALL   1006
03F02:  BTFSC  1B.7
03F04:  BSF    FF2.7
03F06:  MOVLW  10
03F08:  MOVWF  FE9
03F0A:  CLRF   1B
03F0C:  BTFSC  FF2.7
03F0E:  BSF    1B.7
03F10:  BCF    FF2.7
03F12:  MOVFF  9C7,A19
03F16:  MOVFF  9C6,A18
03F1A:  CALL   1188
03F1E:  BTFSC  1B.7
03F20:  BSF    FF2.7
03F22:  MOVLW  0D
03F24:  BTFSS  F9E.4
03F26:  BRA    3F24
03F28:  MOVWF  FAD
03F2A:  MOVLW  0A
03F2C:  BTFSS  F9E.4
03F2E:  BRA    3F2C
03F30:  MOVWF  FAD
03F32:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03F34:  BSF    xC8.0
....................                goto Exit_disk_initialize; 
03F36:  BRA    4348
....................                } 
....................  
....................             Card = MMC; 
03F38:  MOVLW  02
03F3A:  MOVLB  4
03F3C:  MOVWF  xE3
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
03F3E:  MOVF   1F,W
03F40:  SUBLW  04
03F42:  BNZ   3F68
03F44:  MOVF   20,F
03F46:  BNZ   3F68
03F48:  MOVLW  48
03F4A:  MOVWF  FF6
03F4C:  MOVLW  0A
03F4E:  MOVWF  FF7
03F50:  MOVLW  00
03F52:  MOVWF  FF8
03F54:  CLRF   1B
03F56:  BTFSC  FF2.7
03F58:  BSF    1B.7
03F5A:  BCF    FF2.7
03F5C:  MOVLB  0
03F5E:  CALL   0E30
03F62:  BTFSC  1B.7
03F64:  BSF    FF2.7
03F66:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
03F68:  MOVLW  50
03F6A:  MOVLB  A
03F6C:  MOVWF  x04
03F6E:  CLRF   x08
03F70:  CLRF   x07
03F72:  MOVLW  02
03F74:  MOVWF  x06
03F76:  CLRF   x05
03F78:  MOVLB  0
03F7A:  CALL   34BE
03F7E:  MOVFF  01,9C1
....................       if ((Timer == 50000) || (response > 1))    
03F82:  MOVLB  9
03F84:  MOVF   xC6,W
03F86:  SUBLW  50
03F88:  BNZ   3F90
03F8A:  MOVF   xC7,W
03F8C:  SUBLW  C3
03F8E:  BZ    3F96
03F90:  MOVF   xC1,W
03F92:  SUBLW  01
03F94:  BC    402C
....................       { 
....................          Card = None; 
03F96:  MOVLB  4
03F98:  CLRF   xE3
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
03F9A:  MOVF   1F,W
03F9C:  SUBLW  04
03F9E:  BNZ   402A
03FA0:  MOVF   20,F
03FA2:  BNZ   402A
03FA4:  MOVLW  64
03FA6:  MOVWF  FF6
03FA8:  MOVLW  0A
03FAA:  MOVWF  FF7
03FAC:  MOVLW  00
03FAE:  MOVWF  FF8
03FB0:  CLRF   1B
03FB2:  BTFSC  FF2.7
03FB4:  BSF    1B.7
03FB6:  BCF    FF2.7
03FB8:  MOVLW  2B
03FBA:  MOVLB  A
03FBC:  MOVWF  x18
03FBE:  MOVLB  0
03FC0:  CALL   1006
03FC4:  BTFSC  1B.7
03FC6:  BSF    FF2.7
03FC8:  MOVFF  9C1,9C9
03FCC:  MOVLW  57
03FCE:  MOVLB  9
03FD0:  MOVWF  xCA
03FD2:  MOVLB  0
03FD4:  CALL   358E
03FD8:  MOVLW  93
03FDA:  MOVWF  FF6
03FDC:  MOVLW  0A
03FDE:  MOVWF  FF7
03FE0:  MOVLW  00
03FE2:  MOVWF  FF8
03FE4:  CLRF   1B
03FE6:  BTFSC  FF2.7
03FE8:  BSF    1B.7
03FEA:  BCF    FF2.7
03FEC:  MOVLW  0A
03FEE:  MOVLB  A
03FF0:  MOVWF  x18
03FF2:  MOVLB  0
03FF4:  CALL   1006
03FF8:  BTFSC  1B.7
03FFA:  BSF    FF2.7
03FFC:  MOVLW  10
03FFE:  MOVWF  FE9
04000:  CLRF   1B
04002:  BTFSC  FF2.7
04004:  BSF    1B.7
04006:  BCF    FF2.7
04008:  MOVFF  9C7,A19
0400C:  MOVFF  9C6,A18
04010:  CALL   1188
04014:  BTFSC  1B.7
04016:  BSF    FF2.7
04018:  MOVLW  0D
0401A:  BTFSS  F9E.4
0401C:  BRA    401A
0401E:  MOVWF  FAD
04020:  MOVLW  0A
04022:  BTFSS  F9E.4
04024:  BRA    4022
04026:  MOVWF  FAD
04028:  MOVLB  4
0402A:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
0402C:  MOVLB  4
0402E:  MOVF   xE3,F
04030:  BNZ   4064
....................    { 
....................       if (nv_report_mode == 4) 
04032:  MOVF   1F,W
04034:  SUBLW  04
04036:  BNZ   405C
04038:  MOVF   20,F
0403A:  BNZ   405C
....................          printf("@FS:Card Type Discovery Error\r\n"); 
0403C:  MOVLW  A4
0403E:  MOVWF  FF6
04040:  MOVLW  0A
04042:  MOVWF  FF7
04044:  MOVLW  00
04046:  MOVWF  FF8
04048:  CLRF   1B
0404A:  BTFSC  FF2.7
0404C:  BSF    1B.7
0404E:  BCF    FF2.7
04050:  MOVLB  0
04052:  CALL   0E30
04056:  BTFSC  1B.7
04058:  BSF    FF2.7
0405A:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
0405C:  MOVLB  9
0405E:  BSF    xC8.0
....................       goto Exit_disk_initialize; 
04060:  BRA    4348
04062:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
04064:  MOVF   xE3,W
04066:  XORLW  02
04068:  MOVLB  0
0406A:  BZ    407A
0406C:  XORLW  01
0406E:  BZ    40A2
04070:  XORLW  07
04072:  BZ    40CA
04074:  XORLW  01
04076:  BZ    40F2
04078:  BRA    411A
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
0407A:  MOVF   1F,W
0407C:  SUBLW  04
0407E:  BNZ   40A0
04080:  MOVF   20,F
04082:  BNZ   40A0
04084:  MOVLW  C4
04086:  MOVWF  FF6
04088:  MOVLW  0A
0408A:  MOVWF  FF7
0408C:  MOVLW  00
0408E:  MOVWF  FF8
04090:  CLRF   1B
04092:  BTFSC  FF2.7
04094:  BSF    1B.7
04096:  BCF    FF2.7
04098:  CALL   0E30
0409C:  BTFSC  1B.7
0409E:  BSF    FF2.7
....................          break; 
040A0:  BRA    4170
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
040A2:  MOVF   1F,W
040A4:  SUBLW  04
040A6:  BNZ   40C8
040A8:  MOVF   20,F
040AA:  BNZ   40C8
040AC:  MOVLW  DA
040AE:  MOVWF  FF6
040B0:  MOVLW  0A
040B2:  MOVWF  FF7
040B4:  MOVLW  00
040B6:  MOVWF  FF8
040B8:  CLRF   1B
040BA:  BTFSC  FF2.7
040BC:  BSF    1B.7
040BE:  BCF    FF2.7
040C0:  CALL   0E30
040C4:  BTFSC  1B.7
040C6:  BSF    FF2.7
....................          break; 
040C8:  BRA    4170
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
040CA:  MOVF   1F,W
040CC:  SUBLW  04
040CE:  BNZ   40F0
040D0:  MOVF   20,F
040D2:  BNZ   40F0
040D4:  MOVLW  F0
040D6:  MOVWF  FF6
040D8:  MOVLW  0A
040DA:  MOVWF  FF7
040DC:  MOVLW  00
040DE:  MOVWF  FF8
040E0:  CLRF   1B
040E2:  BTFSC  FF2.7
040E4:  BSF    1B.7
040E6:  BCF    FF2.7
040E8:  CALL   0E30
040EC:  BTFSC  1B.7
040EE:  BSF    FF2.7
....................          break; 
040F0:  BRA    4170
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
040F2:  MOVF   1F,W
040F4:  SUBLW  04
040F6:  BNZ   4118
040F8:  MOVF   20,F
040FA:  BNZ   4118
040FC:  MOVLW  06
040FE:  MOVWF  FF6
04100:  MOVLW  0B
04102:  MOVWF  FF7
04104:  MOVLW  00
04106:  MOVWF  FF8
04108:  CLRF   1B
0410A:  BTFSC  FF2.7
0410C:  BSF    1B.7
0410E:  BCF    FF2.7
04110:  CALL   0E30
04114:  BTFSC  1B.7
04116:  BSF    FF2.7
....................          break; 
04118:  BRA    4170
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
0411A:  MOVF   1F,W
0411C:  SUBLW  04
0411E:  BNZ   4168
04120:  MOVF   20,F
04122:  BNZ   4168
04124:  MOVLW  1C
04126:  MOVWF  FF6
04128:  MOVLW  0B
0412A:  MOVWF  FF7
0412C:  MOVLW  00
0412E:  MOVWF  FF8
04130:  CLRF   1B
04132:  BTFSC  FF2.7
04134:  BSF    1B.7
04136:  BCF    FF2.7
04138:  MOVLW  26
0413A:  MOVLB  A
0413C:  MOVWF  x18
0413E:  MOVLB  0
04140:  CALL   1006
04144:  BTFSC  1B.7
04146:  BSF    FF2.7
04148:  MOVFF  4E3,9C9
0414C:  MOVLW  37
0414E:  MOVLB  9
04150:  MOVWF  xCA
04152:  MOVLB  0
04154:  CALL   358E
04158:  MOVLW  0D
0415A:  BTFSS  F9E.4
0415C:  BRA    415A
0415E:  MOVWF  FAD
04160:  MOVLW  0A
04162:  BTFSS  F9E.4
04164:  BRA    4162
04166:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
04168:  MOVLB  9
0416A:  BSF    xC8.0
....................          goto Exit_disk_initialize; 
0416C:  BRA    4348
0416E:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
04170:  MOVLB  9
04172:  BCF    xC8.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
04174:  MOVF   1F,W
04176:  SUBLW  04
04178:  BNZ   41D0
0417A:  MOVF   20,F
0417C:  BNZ   41D0
0417E:  MOVLW  4A
04180:  MOVWF  FF6
04182:  MOVLW  0B
04184:  MOVWF  FF7
04186:  MOVLW  00
04188:  MOVWF  FF8
0418A:  CLRF   1B
0418C:  BTFSC  FF2.7
0418E:  BSF    1B.7
04190:  BCF    FF2.7
04192:  MOVLW  2E
04194:  MOVLB  A
04196:  MOVWF  x18
04198:  MOVLB  0
0419A:  CALL   1006
0419E:  BTFSC  1B.7
041A0:  BSF    FF2.7
041A2:  MOVLW  10
041A4:  MOVWF  FE9
041A6:  CLRF   1B
041A8:  BTFSC  FF2.7
041AA:  BSF    1B.7
041AC:  BCF    FF2.7
041AE:  MOVFF  9C7,A19
041B2:  MOVFF  9C6,A18
041B6:  CALL   1188
041BA:  BTFSC  1B.7
041BC:  BSF    FF2.7
041BE:  MOVLW  0D
041C0:  BTFSS  F9E.4
041C2:  BRA    41C0
041C4:  MOVWF  FAD
041C6:  MOVLW  0A
041C8:  BTFSS  F9E.4
041CA:  BRA    41C8
041CC:  MOVWF  FAD
041CE:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
041D0:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
041D2:  BCF    FC6.5
041D4:  MOVLW  20
041D6:  MOVWF  FC6
041D8:  MOVLW  40
041DA:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
041DC:  BCF    F9E.3
....................    SelectSD; 
041DE:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
041E0:  MOVF   1F,W
041E2:  SUBLW  04
041E4:  BNZ   420A
041E6:  MOVF   20,F
041E8:  BNZ   420A
041EA:  MOVLW  7E
041EC:  MOVWF  FF6
041EE:  MOVLW  0B
041F0:  MOVWF  FF7
041F2:  MOVLW  00
041F4:  MOVWF  FF8
041F6:  CLRF   1B
041F8:  BTFSC  FF2.7
041FA:  BSF    1B.7
041FC:  BCF    FF2.7
041FE:  MOVLB  0
04200:  CALL   0E30
04204:  BTFSC  1B.7
04206:  BSF    FF2.7
04208:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
0420A:  CLRF   xC7
0420C:  CLRF   xC6
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
0420E:  MOVLW  41
04210:  MOVLB  A
04212:  MOVWF  x04
04214:  CLRF   x08
04216:  CLRF   x07
04218:  CLRF   x06
0421A:  CLRF   x05
0421C:  MOVLB  0
0421E:  CALL   34BE
04222:  MOVFF  01,9C1
....................       if (response != 0x00 ) 
04226:  MOVLB  9
04228:  MOVF   xC1,F
0422A:  BZ    4234
....................          delay_us(10); 
0422C:  MOVLW  35
0422E:  MOVWF  00
04230:  DECFSZ 00,F
04232:  BRA    4230
....................  
....................       Timer++; 
04234:  INCF   xC6,F
04236:  BTFSC  FD8.2
04238:  INCF   xC7,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
0423A:  MOVF   xC1,F
0423C:  BZ    424C
0423E:  MOVF   xC7,W
04240:  SUBLW  C3
04242:  BNC   424C
04244:  BNZ   420E
04246:  MOVF   xC6,W
04248:  SUBLW  4F
0424A:  BC    420E
....................  
....................    if (response != 0x00) 
0424C:  MOVF   xC1,F
0424E:  BZ    42E4
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
04250:  MOVF   1F,W
04252:  SUBLW  04
04254:  BNZ   42E0
04256:  MOVF   20,F
04258:  BNZ   42E0
0425A:  MOVLW  9E
0425C:  MOVWF  FF6
0425E:  MOVLW  0B
04260:  MOVWF  FF7
04262:  MOVLW  00
04264:  MOVWF  FF8
04266:  CLRF   1B
04268:  BTFSC  FF2.7
0426A:  BSF    1B.7
0426C:  BCF    FF2.7
0426E:  MOVLW  26
04270:  MOVLB  A
04272:  MOVWF  x18
04274:  MOVLB  0
04276:  CALL   1006
0427A:  BTFSC  1B.7
0427C:  BSF    FF2.7
0427E:  MOVFF  9C1,9C9
04282:  MOVLW  37
04284:  MOVLB  9
04286:  MOVWF  xCA
04288:  MOVLB  0
0428A:  CALL   358E
0428E:  MOVLW  C8
04290:  MOVWF  FF6
04292:  MOVLW  0B
04294:  MOVWF  FF7
04296:  MOVLW  00
04298:  MOVWF  FF8
0429A:  CLRF   1B
0429C:  BTFSC  FF2.7
0429E:  BSF    1B.7
042A0:  BCF    FF2.7
042A2:  MOVLW  0A
042A4:  MOVLB  A
042A6:  MOVWF  x18
042A8:  MOVLB  0
042AA:  CALL   1006
042AE:  BTFSC  1B.7
042B0:  BSF    FF2.7
042B2:  MOVLW  10
042B4:  MOVWF  FE9
042B6:  CLRF   1B
042B8:  BTFSC  FF2.7
042BA:  BSF    1B.7
042BC:  BCF    FF2.7
042BE:  MOVFF  9C7,A19
042C2:  MOVFF  9C6,A18
042C6:  CALL   1188
042CA:  BTFSC  1B.7
042CC:  BSF    FF2.7
042CE:  MOVLW  0D
042D0:  BTFSS  F9E.4
042D2:  BRA    42D0
042D4:  MOVWF  FAD
042D6:  MOVLW  0A
042D8:  BTFSS  F9E.4
042DA:  BRA    42D8
042DC:  MOVWF  FAD
042DE:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
042E0:  BSF    xC8.0
....................       goto Exit_disk_initialize; 
042E2:  BRA    4348
....................    } 
....................  
....................    if (nv_report_mode == 4) 
042E4:  MOVF   1F,W
042E6:  SUBLW  04
042E8:  BNZ   4340
042EA:  MOVF   20,F
042EC:  BNZ   4340
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
042EE:  MOVLW  D8
042F0:  MOVWF  FF6
042F2:  MOVLW  0B
042F4:  MOVWF  FF7
042F6:  MOVLW  00
042F8:  MOVWF  FF8
042FA:  CLRF   1B
042FC:  BTFSC  FF2.7
042FE:  BSF    1B.7
04300:  BCF    FF2.7
04302:  MOVLW  25
04304:  MOVLB  A
04306:  MOVWF  x18
04308:  MOVLB  0
0430A:  CALL   1006
0430E:  BTFSC  1B.7
04310:  BSF    FF2.7
04312:  MOVLW  10
04314:  MOVWF  FE9
04316:  CLRF   1B
04318:  BTFSC  FF2.7
0431A:  BSF    1B.7
0431C:  BCF    FF2.7
0431E:  MOVFF  9C7,A19
04322:  MOVFF  9C6,A18
04326:  CALL   1188
0432A:  BTFSC  1B.7
0432C:  BSF    FF2.7
0432E:  MOVLW  0D
04330:  BTFSS  F9E.4
04332:  BRA    4330
04334:  MOVWF  FAD
04336:  MOVLW  0A
04338:  BTFSS  F9E.4
0433A:  BRA    4338
0433C:  MOVWF  FAD
0433E:  MOVLB  9
....................  
....................    msg_card_ok(); 
04340:  MOVLB  0
04342:  GOTO   35D4
04346:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
04348:  BSF    F91.1
....................    return(SDCardStatus); 
0434A:  MOVFF  9C8,01
0434E:  MOVLB  0
04350:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
059F8:  MOVLW  20
059FA:  MOVLB  7
059FC:  ADDWF  x0E,W
059FE:  MOVWF  FE9
05A00:  MOVLW  00
05A02:  ADDWFC x0F,W
05A04:  MOVWF  FEA
05A06:  MOVFF  FEF,9F1
05A0A:  MOVFF  FEC,9F2
05A0E:  MOVFF  FEC,9F3
05A12:  MOVFF  FEC,9F4
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05A16:  MOVLB  9
05A18:  MOVF   xED,W
05A1A:  SUBWF  xF1,W
05A1C:  BNZ   5A32
05A1E:  MOVF   xEE,W
05A20:  SUBWF  xF2,W
05A22:  BNZ   5A32
05A24:  MOVF   xEF,W
05A26:  SUBWF  xF3,W
05A28:  BNZ   5A32
05A2A:  MOVF   xF0,W
05A2C:  SUBWF  xF4,W
05A2E:  BTFSC  FD8.2
05A30:  BRA    5C06
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05A32:  MOVLW  06
05A34:  MOVLB  7
05A36:  ADDWF  x0E,W
05A38:  MOVWF  FE9
05A3A:  MOVLW  00
05A3C:  ADDWFC x0F,W
05A3E:  MOVWF  FEA
05A40:  MOVF   FEF,F
05A42:  BTFSC  FD8.2
05A44:  BRA    5B90
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05A46:  MOVLW  24
05A48:  ADDWF  x0E,W
05A4A:  MOVWF  01
05A4C:  MOVLW  00
05A4E:  ADDWFC x0F,W
05A50:  MOVWF  03
05A52:  MOVFF  01,9F7
05A56:  MOVLB  9
05A58:  MOVWF  xF8
05A5A:  MOVWF  xFA
05A5C:  MOVFF  01,9F9
05A60:  MOVFF  9F4,9FE
05A64:  MOVFF  9F3,9FD
05A68:  MOVFF  9F2,9FC
05A6C:  MOVFF  9F1,9FB
05A70:  MOVLW  01
05A72:  MOVWF  xFF
05A74:  MOVLB  0
05A76:  RCALL  58B2
05A78:  MOVFF  01,9F5
....................             if (response != RES_OK) 
05A7C:  MOVLB  9
05A7E:  MOVF   xF5,F
05A80:  BZ    5A88
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05A82:  MOVLW  00
05A84:  MOVWF  01
05A86:  BRA    5C0A
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05A88:  MOVLW  06
05A8A:  MOVLB  7
05A8C:  ADDWF  x0E,W
05A8E:  MOVWF  FE9
05A90:  MOVLW  00
05A92:  ADDWFC x0F,W
05A94:  MOVWF  FEA
05A96:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05A98:  MOVLW  10
05A9A:  ADDWF  x0E,W
05A9C:  MOVWF  FE9
05A9E:  MOVLW  00
05AA0:  ADDWFC x0F,W
05AA2:  MOVWF  FEA
05AA4:  MOVFF  FEF,9F7
05AA8:  MOVFF  FEC,9F8
05AAC:  MOVFF  FEC,9F9
05AB0:  MOVFF  FEC,9FA
05AB4:  MOVLW  08
05AB6:  ADDWF  x0E,W
05AB8:  MOVWF  FE9
05ABA:  MOVLW  00
05ABC:  ADDWFC x0F,W
05ABE:  MOVWF  FEA
05AC0:  MOVFF  FEF,00
05AC4:  MOVFF  FEC,01
05AC8:  MOVFF  FEC,02
05ACC:  MOVFF  FEC,03
05AD0:  MOVLB  9
05AD2:  MOVF   xF7,W
05AD4:  ADDWF  00,F
05AD6:  MOVF   xF8,W
05AD8:  ADDWFC 01,F
05ADA:  MOVF   xF9,W
05ADC:  ADDWFC 02,F
05ADE:  MOVF   xFA,W
05AE0:  ADDWFC 03,F
05AE2:  MOVF   xF4,W
05AE4:  SUBWF  03,W
05AE6:  BNC   5B8E
05AE8:  BNZ   5B00
05AEA:  MOVF   xF3,W
05AEC:  SUBWF  02,W
05AEE:  BNC   5B8E
05AF0:  BNZ   5B00
05AF2:  MOVF   xF2,W
05AF4:  SUBWF  01,W
05AF6:  BNC   5B8E
05AF8:  BNZ   5B00
05AFA:  MOVF   00,W
05AFC:  SUBWF  xF1,W
05AFE:  BC    5B8E
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05B00:  MOVLW  03
05B02:  MOVLB  7
05B04:  ADDWF  x0E,W
05B06:  MOVWF  FE9
05B08:  MOVLW  00
05B0A:  ADDWFC x0F,W
05B0C:  MOVWF  FEA
05B0E:  MOVFF  FEF,9F6
05B12:  MOVLB  9
05B14:  MOVF   xF6,W
05B16:  SUBLW  01
05B18:  BC    5B8E
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05B1A:  MOVLW  08
05B1C:  MOVLB  7
05B1E:  ADDWF  x0E,W
05B20:  MOVWF  FE9
05B22:  MOVLW  00
05B24:  ADDWFC x0F,W
05B26:  MOVWF  FEA
05B28:  MOVFF  FEF,00
05B2C:  MOVFF  FEC,01
05B30:  MOVFF  FEC,02
05B34:  MOVFF  FEC,03
05B38:  MOVF   00,W
05B3A:  MOVLB  9
05B3C:  ADDWF  xF1,F
05B3E:  MOVF   01,W
05B40:  ADDWFC xF2,F
05B42:  MOVF   02,W
05B44:  ADDWFC xF3,F
05B46:  MOVF   03,W
05B48:  ADDWFC xF4,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05B4A:  MOVLW  24
05B4C:  MOVLB  7
05B4E:  ADDWF  x0E,W
05B50:  MOVWF  01
05B52:  MOVLW  00
05B54:  ADDWFC x0F,W
05B56:  MOVWF  03
05B58:  MOVFF  01,9F7
05B5C:  MOVLB  9
05B5E:  MOVWF  xF8
05B60:  MOVWF  xFA
05B62:  MOVFF  01,9F9
05B66:  MOVFF  9F4,9FE
05B6A:  MOVFF  9F3,9FD
05B6E:  MOVFF  9F2,9FC
05B72:  MOVFF  9F1,9FB
05B76:  MOVLW  01
05B78:  MOVWF  xFF
05B7A:  MOVLB  0
05B7C:  RCALL  58B2
05B7E:  MOVF   01,F
05B80:  BZ    5B88
....................                      break; 
05B82:  MOVLB  9
05B84:  BRA    5B8E
05B86:  MOVLB  0
05B88:  MOVLB  9
05B8A:  DECF   xF6,F
05B8C:  BRA    5B14
05B8E:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05B90:  MOVLB  9
05B92:  MOVF   xED,F
05B94:  BNZ   5BA2
05B96:  MOVF   xEE,F
05B98:  BNZ   5BA2
05B9A:  MOVF   xEF,F
05B9C:  BNZ   5BA2
05B9E:  MOVF   xF0,F
05BA0:  BZ    5C06
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05BA2:  MOVLW  24
05BA4:  MOVLB  7
05BA6:  ADDWF  x0E,W
05BA8:  MOVWF  01
05BAA:  MOVLW  00
05BAC:  ADDWFC x0F,W
05BAE:  MOVWF  03
05BB0:  MOVFF  01,9F7
05BB4:  MOVLB  9
05BB6:  MOVWF  xF8
05BB8:  MOVWF  xFA
05BBA:  MOVFF  01,9F9
05BBE:  MOVFF  9F0,9FE
05BC2:  MOVFF  9EF,9FD
05BC6:  MOVFF  9EE,9FC
05BCA:  MOVFF  9ED,9FB
05BCE:  MOVLW  01
05BD0:  MOVWF  xFF
05BD2:  MOVLB  0
05BD4:  CALL   444A
05BD8:  MOVF   01,F
05BDA:  BZ    5BE6
....................             return FALSE; 
05BDC:  MOVLW  00
05BDE:  MOVWF  01
05BE0:  MOVLB  9
05BE2:  BRA    5C0A
05BE4:  MOVLB  0
....................          fs->winsect = sector; 
05BE6:  MOVLW  20
05BE8:  MOVLB  7
05BEA:  ADDWF  x0E,W
05BEC:  MOVWF  FE9
05BEE:  MOVLW  00
05BF0:  ADDWFC x0F,W
05BF2:  MOVWF  FEA
05BF4:  MOVFF  9ED,FEF
05BF8:  MOVFF  9EE,FEC
05BFC:  MOVFF  9EF,FEC
05C00:  MOVFF  9F0,FEC
05C04:  MOVLB  9
....................          } 
....................       } 
....................    return (TRUE); 
05C06:  MOVLW  01
05C08:  MOVWF  01
05C0A:  MOVLB  0
05C0C:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05C30:  MOVLB  9
05C32:  MOVF   xDC,F
05C34:  BNZ   5C46
05C36:  MOVF   xDB,F
05C38:  BNZ   5C46
05C3A:  MOVF   xDA,F
05C3C:  BNZ   5C46
05C3E:  MOVF   xD9,W
05C40:  SUBLW  01
05C42:  BTFSC  FD8.0
05C44:  BRA    5F56
05C46:  MOVLW  0C
05C48:  MOVLB  7
05C4A:  ADDWF  x0E,W
05C4C:  MOVWF  FE9
05C4E:  MOVLW  00
05C50:  ADDWFC x0F,W
05C52:  MOVWF  FEA
05C54:  MOVFF  FEF,00
05C58:  MOVFF  FEC,01
05C5C:  MOVFF  FEC,02
05C60:  MOVFF  FEC,03
05C64:  MOVLB  9
05C66:  MOVF   xDC,W
05C68:  SUBWF  03,W
05C6A:  BTFSS  FD8.0
05C6C:  BRA    5F56
05C6E:  BNZ   5C8C
05C70:  MOVF   xDB,W
05C72:  SUBWF  02,W
05C74:  BTFSS  FD8.0
05C76:  BRA    5F56
05C78:  BNZ   5C8C
05C7A:  MOVF   xDA,W
05C7C:  SUBWF  01,W
05C7E:  BTFSS  FD8.0
05C80:  BRA    5F56
05C82:  BNZ   5C8C
05C84:  MOVF   00,W
05C86:  SUBWF  xD9,W
05C88:  BTFSC  FD8.0
05C8A:  BRA    5F56
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05C8C:  MOVLW  10
05C8E:  MOVLB  7
05C90:  ADDWF  x0E,W
05C92:  MOVWF  FE9
05C94:  MOVLW  00
05C96:  ADDWFC x0F,W
05C98:  MOVWF  FEA
05C9A:  MOVFF  FEF,9E1
05C9E:  MOVFF  FEC,9E2
05CA2:  MOVFF  FEC,9E3
05CA6:  MOVFF  FEC,9E4
....................       switch (fs->fs_type)  
05CAA:  MOVF   x0E,W
05CAC:  MOVWF  FE9
05CAE:  MOVF   x0F,W
05CB0:  MOVWF  FEA
05CB2:  MOVF   FEF,W
05CB4:  XORLW  01
05CB6:  MOVLB  0
05CB8:  BZ    5CC8
05CBA:  XORLW  03
05CBC:  BTFSC  FD8.2
05CBE:  BRA    5E0E
05CC0:  XORLW  01
05CC2:  BTFSC  FD8.2
05CC4:  BRA    5E90
05CC6:  BRA    5F58
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05CC8:  MOVFF  9DA,9EA
05CCC:  MOVFF  9D9,9E9
05CD0:  MOVLB  9
05CD2:  CLRF   xEC
05CD4:  MOVLW  03
05CD6:  MOVWF  xEB
05CD8:  MOVLB  0
05CDA:  RCALL  5C0E
05CDC:  BCF    FD8.0
05CDE:  MOVLB  9
05CE0:  RRCF   02,W
05CE2:  MOVWF  xE0
05CE4:  RRCF   01,W
05CE6:  MOVWF  xDF
....................             if (!move_window(fatsect + bc / 512))  
05CE8:  BCF    FD8.0
05CEA:  CLRF   03
05CEC:  RRCF   xE0,W
05CEE:  MOVWF  02
05CF0:  ADDWF  xE1,W
05CF2:  MOVWF  xE5
05CF4:  MOVF   03,W
05CF6:  ADDWFC xE2,W
05CF8:  MOVWF  xE6
05CFA:  MOVLW  00
05CFC:  ADDWFC xE3,W
05CFE:  MOVWF  xE7
05D00:  MOVLW  00
05D02:  ADDWFC xE4,W
05D04:  MOVWF  xE8
05D06:  MOVWF  xF0
05D08:  MOVFF  9E7,9EF
05D0C:  MOVFF  9E6,9EE
05D10:  MOVFF  9E5,9ED
05D14:  MOVLB  0
05D16:  RCALL  59F8
05D18:  MOVF   01,F
05D1A:  BNZ   5D1E
....................                break; 
05D1C:  BRA    5F58
....................             wc = fs->win[bc % 512]; 
05D1E:  MOVLB  9
05D20:  MOVF   xE0,W
05D22:  ANDLW  01
05D24:  MOVWF  xE6
05D26:  MOVLW  24
05D28:  ADDWF  xDF,W
05D2A:  MOVWF  01
05D2C:  MOVLW  00
05D2E:  ADDWFC xE6,W
05D30:  MOVWF  03
05D32:  MOVF   01,W
05D34:  MOVLB  7
05D36:  ADDWF  x0E,W
05D38:  MOVWF  FE9
05D3A:  MOVF   x0F,W
05D3C:  ADDWFC 03,W
05D3E:  MOVWF  FEA
05D40:  MOVLB  9
05D42:  CLRF   xDE
05D44:  MOVFF  FEF,9DD
....................             bc++; 
05D48:  INCF   xDF,F
05D4A:  BTFSC  FD8.2
05D4C:  INCF   xE0,F
....................             if (!move_window(fatsect + bc / 512))  
05D4E:  BCF    FD8.0
05D50:  CLRF   03
05D52:  RRCF   xE0,W
05D54:  MOVWF  02
05D56:  ADDWF  xE1,W
05D58:  MOVWF  xE5
05D5A:  MOVF   03,W
05D5C:  ADDWFC xE2,W
05D5E:  MOVWF  xE6
05D60:  MOVLW  00
05D62:  ADDWFC xE3,W
05D64:  MOVWF  xE7
05D66:  MOVLW  00
05D68:  ADDWFC xE4,W
05D6A:  MOVWF  xE8
05D6C:  MOVWF  xF0
05D6E:  MOVFF  9E7,9EF
05D72:  MOVFF  9E6,9EE
05D76:  MOVFF  9E5,9ED
05D7A:  MOVLB  0
05D7C:  RCALL  59F8
05D7E:  MOVF   01,F
05D80:  BNZ   5D84
....................                break; 
05D82:  BRA    5F58
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05D84:  MOVLB  9
05D86:  MOVF   xE0,W
05D88:  ANDLW  01
05D8A:  MOVWF  xE6
05D8C:  MOVLW  24
05D8E:  ADDWF  xDF,W
05D90:  MOVWF  01
05D92:  MOVLW  00
05D94:  ADDWFC xE6,W
05D96:  MOVWF  03
05D98:  MOVF   01,W
05D9A:  MOVLB  7
05D9C:  ADDWF  x0E,W
05D9E:  MOVWF  FE9
05DA0:  MOVF   x0F,W
05DA2:  ADDWFC 03,W
05DA4:  MOVWF  FEA
05DA6:  MOVF   FEF,W
05DA8:  MOVLB  9
05DAA:  MOVWF  xE7
05DAC:  MOVLW  00
05DAE:  IORWF  xDD,F
05DB0:  MOVF   xE7,W
05DB2:  IORWF  xDE,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05DB4:  MOVF   xD9,W
05DB6:  ANDLW  01
05DB8:  MOVWF  00
05DBA:  CLRF   01
05DBC:  CLRF   02
05DBE:  CLRF   03
05DC0:  MOVF   00,F
05DC2:  BNZ   5DD0
05DC4:  MOVF   01,F
05DC6:  BNZ   5DD0
05DC8:  MOVF   02,F
05DCA:  BNZ   5DD0
05DCC:  MOVF   03,F
05DCE:  BZ    5DF6
05DD0:  RRCF   xDE,W
05DD2:  MOVWF  03
05DD4:  RRCF   xDD,W
05DD6:  MOVWF  02
05DD8:  RRCF   03,F
05DDA:  RRCF   02,F
05DDC:  RRCF   03,F
05DDE:  RRCF   02,F
05DE0:  RRCF   03,F
05DE2:  RRCF   02,F
05DE4:  MOVLW  0F
05DE6:  ANDWF  03,F
05DE8:  MOVFF  02,00
05DEC:  MOVFF  03,01
05DF0:  CLRF   02
05DF2:  CLRF   03
05DF4:  BRA    5E0A
05DF6:  MOVFF  9DD,00
05DFA:  MOVF   xDE,W
05DFC:  ANDLW  0F
05DFE:  MOVWF  03
05E00:  MOVF   xDD,W
05E02:  MOVFF  03,01
05E06:  CLRF   02
05E08:  CLRF   03
05E0A:  BRA    5F64
05E0C:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05E0E:  MOVFF  9DA,00
05E12:  MOVFF  9DB,01
05E16:  MOVFF  9DC,02
05E1A:  CLRF   03
05E1C:  MOVF   00,W
05E1E:  MOVLB  9
05E20:  ADDWF  xE1,W
05E22:  MOVWF  xE5
05E24:  MOVF   xDB,W
05E26:  ADDWFC xE2,W
05E28:  MOVWF  xE6
05E2A:  MOVF   xDC,W
05E2C:  ADDWFC xE3,W
05E2E:  MOVWF  xE7
05E30:  MOVF   03,W
05E32:  ADDWFC xE4,W
05E34:  MOVWF  xE8
05E36:  MOVWF  xF0
05E38:  MOVFF  9E7,9EF
05E3C:  MOVFF  9E6,9EE
05E40:  MOVFF  9E5,9ED
05E44:  MOVLB  0
05E46:  RCALL  59F8
05E48:  MOVF   01,F
05E4A:  BNZ   5E4E
....................                break; 
05E4C:  BRA    5F58
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05E4E:  BCF    FD8.0
05E50:  MOVLB  9
05E52:  RLCF   xD9,W
05E54:  MOVWF  xE5
05E56:  RLCF   xDA,W
05E58:  MOVWF  xE6
05E5A:  MOVLW  01
05E5C:  ANDWF  xE6,F
05E5E:  MOVLW  24
05E60:  ADDWF  xE5,W
05E62:  MOVWF  01
05E64:  MOVLW  00
05E66:  ADDWFC xE6,W
05E68:  MOVWF  03
05E6A:  MOVF   01,W
05E6C:  MOVLB  7
05E6E:  ADDWF  x0E,W
05E70:  MOVWF  01
05E72:  MOVF   x0F,W
05E74:  ADDWFC 03,F
05E76:  MOVFF  01,FE9
05E7A:  MOVFF  03,FEA
05E7E:  MOVFF  FEF,00
05E82:  MOVFF  FEC,01
05E86:  CLRF   02
05E88:  CLRF   03
05E8A:  MOVLB  9
05E8C:  BRA    5F64
05E8E:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05E90:  MOVLB  9
05E92:  RRCF   xDC,W
05E94:  MOVWF  03
05E96:  RRCF   xDB,W
05E98:  MOVWF  02
05E9A:  RRCF   xDA,W
05E9C:  MOVWF  01
05E9E:  RRCF   xD9,W
05EA0:  MOVWF  00
05EA2:  RRCF   03,F
05EA4:  RRCF   02,F
05EA6:  RRCF   01,F
05EA8:  RRCF   00,F
05EAA:  RRCF   03,F
05EAC:  RRCF   02,F
05EAE:  RRCF   01,F
05EB0:  RRCF   00,F
05EB2:  RRCF   03,F
05EB4:  RRCF   02,F
05EB6:  RRCF   01,F
05EB8:  RRCF   00,F
05EBA:  RRCF   03,F
05EBC:  RRCF   02,F
05EBE:  RRCF   01,F
05EC0:  RRCF   00,F
05EC2:  RRCF   03,F
05EC4:  RRCF   02,F
05EC6:  RRCF   01,F
05EC8:  RRCF   00,F
05ECA:  RRCF   03,F
05ECC:  RRCF   02,F
05ECE:  RRCF   01,F
05ED0:  RRCF   00,F
05ED2:  MOVLW  01
05ED4:  ANDWF  03,F
05ED6:  MOVF   00,W
05ED8:  ADDWF  xE1,W
05EDA:  MOVWF  xE5
05EDC:  MOVF   01,W
05EDE:  ADDWFC xE2,W
05EE0:  MOVWF  xE6
05EE2:  MOVF   02,W
05EE4:  ADDWFC xE3,W
05EE6:  MOVWF  xE7
05EE8:  MOVF   03,W
05EEA:  ADDWFC xE4,W
05EEC:  MOVWF  xE8
05EEE:  MOVWF  xF0
05EF0:  MOVFF  9E7,9EF
05EF4:  MOVFF  9E6,9EE
05EF8:  MOVFF  9E5,9ED
05EFC:  MOVLB  0
05EFE:  RCALL  59F8
05F00:  MOVF   01,F
05F02:  BNZ   5F06
....................                break; 
05F04:  BRA    5F58
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05F06:  MOVLB  9
05F08:  RLCF   xD9,W
05F0A:  MOVWF  xE5
05F0C:  RLCF   xDA,W
05F0E:  MOVWF  xE6
05F10:  RLCF   xE5,F
05F12:  RLCF   xE6,F
05F14:  MOVLW  FC
05F16:  ANDWF  xE5,F
05F18:  MOVLW  01
05F1A:  ANDWF  xE6,F
05F1C:  MOVLW  24
05F1E:  ADDWF  xE5,W
05F20:  MOVWF  01
05F22:  MOVLW  00
05F24:  ADDWFC xE6,W
05F26:  MOVWF  03
05F28:  MOVF   01,W
05F2A:  MOVLB  7
05F2C:  ADDWF  x0E,W
05F2E:  MOVWF  01
05F30:  MOVF   x0F,W
05F32:  ADDWFC 03,F
05F34:  MOVFF  01,FE9
05F38:  MOVFF  03,FEA
05F3C:  MOVFF  FEF,00
05F40:  MOVFF  FEC,01
05F44:  MOVFF  FEC,02
05F48:  MOVFF  FEC,9EA
05F4C:  MOVLB  9
05F4E:  MOVF   xEA,W
05F50:  ANDLW  0F
05F52:  MOVWF  03
05F54:  BRA    5F64
05F56:  MOVLB  0
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
05F58:  MOVLW  01
05F5A:  MOVWF  00
05F5C:  CLRF   01
05F5E:  CLRF   02
05F60:  CLRF   03
05F62:  MOVLB  9
05F64:  MOVLB  0
05F66:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
0652A:  MOVLW  10
0652C:  MOVLB  7
0652E:  ADDWF  x0E,W
06530:  MOVWF  FE9
06532:  MOVLW  00
06534:  ADDWFC x0F,W
06536:  MOVWF  FEA
06538:  MOVFF  FEF,9E5
0653C:  MOVFF  FEC,9E6
06540:  MOVFF  FEC,9E7
06544:  MOVFF  FEC,9E8
....................    switch (fs->fs_type)  
06548:  MOVF   x0E,W
0654A:  MOVWF  FE9
0654C:  MOVF   x0F,W
0654E:  MOVWF  FEA
06550:  MOVF   FEF,W
06552:  XORLW  01
06554:  MOVLB  0
06556:  BZ    6566
06558:  XORLW  03
0655A:  BTFSC  FD8.2
0655C:  BRA    673E
0655E:  XORLW  01
06560:  BTFSC  FD8.2
06562:  BRA    67C2
06564:  BRA    688A
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
06566:  MOVFF  9DA,9EA
0656A:  MOVFF  9D9,9E9
0656E:  MOVLB  9
06570:  CLRF   xEC
06572:  MOVLW  03
06574:  MOVWF  xEB
06576:  MOVLB  0
06578:  CALL   5C0E
0657C:  BCF    FD8.0
0657E:  MOVLB  9
06580:  RRCF   02,W
06582:  MOVWF  xE2
06584:  RRCF   01,W
06586:  MOVWF  xE1
....................          if (!move_window(fatsect + bc / 512)) 
06588:  BCF    FD8.0
0658A:  CLRF   03
0658C:  RRCF   xE2,W
0658E:  MOVWF  02
06590:  ADDWF  xE5,W
06592:  MOVWF  xE9
06594:  MOVF   03,W
06596:  ADDWFC xE6,W
06598:  MOVWF  xEA
0659A:  MOVLW  00
0659C:  ADDWFC xE7,W
0659E:  MOVWF  xEB
065A0:  MOVLW  00
065A2:  ADDWFC xE8,W
065A4:  MOVWF  xEC
065A6:  MOVWF  xF0
065A8:  MOVFF  9EB,9EF
065AC:  MOVFF  9EA,9EE
065B0:  MOVFF  9E9,9ED
065B4:  MOVLB  0
065B6:  CALL   59F8
065BA:  MOVF   01,F
065BC:  BNZ   65C4
....................             return (FALSE); 
065BE:  MOVLW  00
065C0:  MOVWF  01
065C2:  BRA    68A8
....................          p = &fs->win[bc % 512]; 
065C4:  MOVLB  9
065C6:  MOVF   xE2,W
065C8:  ANDLW  01
065CA:  MOVWF  xEA
065CC:  MOVLW  24
065CE:  ADDWF  xE1,W
065D0:  MOVWF  01
065D2:  MOVLW  00
065D4:  ADDWFC xEA,W
065D6:  MOVWF  03
065D8:  MOVF   01,W
065DA:  MOVLB  7
065DC:  ADDWF  x0E,W
065DE:  MOVWF  01
065E0:  MOVF   x0F,W
065E2:  ADDWFC 03,F
065E4:  MOVFF  01,9E3
065E8:  MOVLB  9
065EA:  MOVFF  03,9E4
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
065EE:  MOVFF  9E3,9E9
065F2:  MOVFF  9E4,9EA
065F6:  MOVF   xD9,W
065F8:  ANDLW  01
065FA:  MOVWF  00
065FC:  CLRF   01
065FE:  CLRF   02
06600:  CLRF   03
06602:  MOVF   00,F
06604:  BNZ   6612
06606:  MOVF   01,F
06608:  BNZ   6612
0660A:  MOVF   02,F
0660C:  BNZ   6612
0660E:  MOVF   03,F
06610:  BZ    6632
06612:  MOVFF  9E4,03
06616:  MOVFF  9E3,FE9
0661A:  MOVFF  9E4,FEA
0661E:  MOVF   FEF,W
06620:  ANDLW  0F
06622:  MOVWF  xEB
06624:  SWAPF  xDD,W
06626:  MOVWF  00
06628:  MOVLW  F0
0662A:  ANDWF  00,F
0662C:  MOVF   00,W
0662E:  IORWF  xEB,W
06630:  BRA    6634
06632:  MOVF   xDD,W
06634:  MOVFF  9EA,FEA
06638:  MOVFF  9E9,FE9
0663C:  MOVWF  FEF
....................          fs->winflag = 1; 
0663E:  MOVLW  06
06640:  MOVLB  7
06642:  ADDWF  x0E,W
06644:  MOVWF  FE9
06646:  MOVLW  00
06648:  ADDWFC x0F,W
0664A:  MOVWF  FEA
0664C:  MOVLW  01
0664E:  MOVWF  FEF
....................          bc++; 
06650:  MOVLB  9
06652:  INCF   xE1,F
06654:  BTFSC  FD8.2
06656:  INCF   xE2,F
....................          if (!move_window(fatsect + bc / 512)) 
06658:  BCF    FD8.0
0665A:  CLRF   03
0665C:  RRCF   xE2,W
0665E:  MOVWF  02
06660:  ADDWF  xE5,W
06662:  MOVWF  xE9
06664:  MOVF   03,W
06666:  ADDWFC xE6,W
06668:  MOVWF  xEA
0666A:  MOVLW  00
0666C:  ADDWFC xE7,W
0666E:  MOVWF  xEB
06670:  MOVLW  00
06672:  ADDWFC xE8,W
06674:  MOVWF  xEC
06676:  MOVWF  xF0
06678:  MOVFF  9EB,9EF
0667C:  MOVFF  9EA,9EE
06680:  MOVFF  9E9,9ED
06684:  MOVLB  0
06686:  CALL   59F8
0668A:  MOVF   01,F
0668C:  BNZ   6694
....................             return (FALSE); 
0668E:  MOVLW  00
06690:  MOVWF  01
06692:  BRA    68A8
....................          p = &fs->win[bc % 512]; 
06694:  MOVLB  9
06696:  MOVF   xE2,W
06698:  ANDLW  01
0669A:  MOVWF  xEA
0669C:  MOVLW  24
0669E:  ADDWF  xE1,W
066A0:  MOVWF  01
066A2:  MOVLW  00
066A4:  ADDWFC xEA,W
066A6:  MOVWF  03
066A8:  MOVF   01,W
066AA:  MOVLB  7
066AC:  ADDWF  x0E,W
066AE:  MOVWF  01
066B0:  MOVF   x0F,W
066B2:  ADDWFC 03,F
066B4:  MOVFF  01,9E3
066B8:  MOVLB  9
066BA:  MOVFF  03,9E4
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
066BE:  MOVFF  9E3,9E9
066C2:  MOVFF  9E4,9EA
066C6:  MOVF   xD9,W
066C8:  ANDLW  01
066CA:  MOVWF  00
066CC:  CLRF   01
066CE:  CLRF   02
066D0:  CLRF   03
066D2:  MOVF   00,F
066D4:  BNZ   66E2
066D6:  MOVF   01,F
066D8:  BNZ   66E2
066DA:  MOVF   02,F
066DC:  BNZ   66E2
066DE:  MOVF   03,F
066E0:  BZ    6712
066E2:  RRCF   xE0,W
066E4:  MOVWF  03
066E6:  RRCF   xDF,W
066E8:  MOVWF  02
066EA:  RRCF   xDE,W
066EC:  MOVWF  01
066EE:  RRCF   xDD,W
066F0:  MOVWF  00
066F2:  RRCF   03,F
066F4:  RRCF   02,F
066F6:  RRCF   01,F
066F8:  RRCF   00,F
066FA:  RRCF   03,F
066FC:  RRCF   02,F
066FE:  RRCF   01,F
06700:  RRCF   00,F
06702:  RRCF   03,F
06704:  RRCF   02,F
06706:  RRCF   01,F
06708:  RRCF   00,F
0670A:  MOVLW  0F
0670C:  ANDWF  03,F
0670E:  MOVF   00,W
06710:  BRA    6732
06712:  MOVFF  9E3,FE9
06716:  MOVFF  9E4,FEA
0671A:  MOVF   FEF,W
0671C:  ANDLW  F0
0671E:  MOVWF  xEC
06720:  MOVFF  9DE,00
06724:  MOVFF  9DF,01
06728:  MOVFF  9E0,02
0672C:  MOVF   xDE,W
0672E:  ANDLW  0F
06730:  IORWF  xEC,W
06732:  MOVFF  9EA,FEA
06736:  MOVFF  9E9,FE9
0673A:  MOVWF  FEF
....................          break; 
0673C:  BRA    6892
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
0673E:  MOVFF  9DA,00
06742:  MOVFF  9DB,01
06746:  MOVFF  9DC,02
0674A:  CLRF   03
0674C:  MOVF   00,W
0674E:  MOVLB  9
06750:  ADDWF  xE5,W
06752:  MOVWF  xE9
06754:  MOVF   xDB,W
06756:  ADDWFC xE6,W
06758:  MOVWF  xEA
0675A:  MOVF   xDC,W
0675C:  ADDWFC xE7,W
0675E:  MOVWF  xEB
06760:  MOVF   03,W
06762:  ADDWFC xE8,W
06764:  MOVWF  xEC
06766:  MOVWF  xF0
06768:  MOVFF  9EB,9EF
0676C:  MOVFF  9EA,9EE
06770:  MOVFF  9E9,9ED
06774:  MOVLB  0
06776:  CALL   59F8
0677A:  MOVF   01,F
0677C:  BNZ   6784
....................             return (FALSE); 
0677E:  MOVLW  00
06780:  MOVWF  01
06782:  BRA    68A8
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
06784:  BCF    FD8.0
06786:  MOVLB  9
06788:  RLCF   xD9,W
0678A:  MOVWF  xE9
0678C:  RLCF   xDA,W
0678E:  MOVWF  xEA
06790:  MOVLW  01
06792:  ANDWF  xEA,F
06794:  MOVLW  24
06796:  ADDWF  xE9,W
06798:  MOVWF  01
0679A:  MOVLW  00
0679C:  ADDWFC xEA,W
0679E:  MOVWF  03
067A0:  MOVF   01,W
067A2:  MOVLB  7
067A4:  ADDWF  x0E,W
067A6:  MOVWF  01
067A8:  MOVF   x0F,W
067AA:  ADDWFC 03,F
067AC:  MOVFF  01,FE9
067B0:  MOVFF  03,FEA
067B4:  MOVFF  9DE,FEC
067B8:  MOVF   FED,F
067BA:  MOVFF  9DD,FEF
....................          break; 
067BE:  MOVLB  9
067C0:  BRA    6892
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
067C2:  MOVLB  9
067C4:  RRCF   xDC,W
067C6:  MOVWF  03
067C8:  RRCF   xDB,W
067CA:  MOVWF  02
067CC:  RRCF   xDA,W
067CE:  MOVWF  01
067D0:  RRCF   xD9,W
067D2:  MOVWF  00
067D4:  RRCF   03,F
067D6:  RRCF   02,F
067D8:  RRCF   01,F
067DA:  RRCF   00,F
067DC:  RRCF   03,F
067DE:  RRCF   02,F
067E0:  RRCF   01,F
067E2:  RRCF   00,F
067E4:  RRCF   03,F
067E6:  RRCF   02,F
067E8:  RRCF   01,F
067EA:  RRCF   00,F
067EC:  RRCF   03,F
067EE:  RRCF   02,F
067F0:  RRCF   01,F
067F2:  RRCF   00,F
067F4:  RRCF   03,F
067F6:  RRCF   02,F
067F8:  RRCF   01,F
067FA:  RRCF   00,F
067FC:  RRCF   03,F
067FE:  RRCF   02,F
06800:  RRCF   01,F
06802:  RRCF   00,F
06804:  MOVLW  01
06806:  ANDWF  03,F
06808:  MOVF   00,W
0680A:  ADDWF  xE5,W
0680C:  MOVWF  xE9
0680E:  MOVF   01,W
06810:  ADDWFC xE6,W
06812:  MOVWF  xEA
06814:  MOVF   02,W
06816:  ADDWFC xE7,W
06818:  MOVWF  xEB
0681A:  MOVF   03,W
0681C:  ADDWFC xE8,W
0681E:  MOVWF  xEC
06820:  MOVWF  xF0
06822:  MOVFF  9EB,9EF
06826:  MOVFF  9EA,9EE
0682A:  MOVFF  9E9,9ED
0682E:  MOVLB  0
06830:  CALL   59F8
06834:  MOVF   01,F
06836:  BNZ   683E
....................             return (FALSE); 
06838:  MOVLW  00
0683A:  MOVWF  01
0683C:  BRA    68A8
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
0683E:  MOVLB  9
06840:  RLCF   xD9,W
06842:  MOVWF  xE9
06844:  RLCF   xDA,W
06846:  MOVWF  xEA
06848:  RLCF   xE9,F
0684A:  RLCF   xEA,F
0684C:  MOVLW  FC
0684E:  ANDWF  xE9,F
06850:  MOVLW  01
06852:  ANDWF  xEA,F
06854:  MOVLW  24
06856:  ADDWF  xE9,W
06858:  MOVWF  01
0685A:  MOVLW  00
0685C:  ADDWFC xEA,W
0685E:  MOVWF  03
06860:  MOVF   01,W
06862:  MOVLB  7
06864:  ADDWF  x0E,W
06866:  MOVWF  01
06868:  MOVF   x0F,W
0686A:  ADDWFC 03,F
0686C:  MOVFF  01,FE9
06870:  MOVFF  03,FEA
06874:  MOVFF  9DD,FEF
06878:  MOVFF  9DE,FEC
0687C:  MOVFF  9DF,FEC
06880:  MOVFF  9E0,FEC
....................          break; 
06884:  MOVLB  9
06886:  BRA    6892
06888:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
0688A:  MOVLW  00
0688C:  MOVWF  01
0688E:  BRA    68A8
06890:  MOVLB  9
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
06892:  MOVLW  06
06894:  MOVLB  7
06896:  ADDWF  x0E,W
06898:  MOVWF  FE9
0689A:  MOVLW  00
0689C:  ADDWFC x0F,W
0689E:  MOVWF  FEA
068A0:  MOVLW  01
068A2:  MOVWF  FEF
....................    return (TRUE); 
068A4:  MOVWF  01
068A6:  MOVLB  0
068A8:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06E84:  MOVFF  9BB,9DC
06E88:  MOVFF  9BA,9DB
06E8C:  MOVFF  9B9,9DA
06E90:  MOVFF  9B8,9D9
06E94:  CALL   5C30
06E98:  MOVFF  03,9BF
06E9C:  MOVFF  02,9BE
06EA0:  MOVFF  01,9BD
06EA4:  MOVFF  00,9BC
06EA8:  MOVLB  9
06EAA:  MOVF   xBF,F
06EAC:  BNZ   6EBC
06EAE:  MOVF   xBE,F
06EB0:  BNZ   6EBC
06EB2:  MOVF   xBD,F
06EB4:  BNZ   6EBC
06EB6:  MOVF   xBC,W
06EB8:  SUBLW  01
06EBA:  BC    6F1C
....................       { 
....................       if (!put_cluster(clust, 0)) 
06EBC:  MOVFF  9BB,9DC
06EC0:  MOVFF  9BA,9DB
06EC4:  MOVFF  9B9,9DA
06EC8:  MOVFF  9B8,9D9
06ECC:  CLRF   xE0
06ECE:  CLRF   xDF
06ED0:  CLRF   xDE
06ED2:  CLRF   xDD
06ED4:  MOVLB  0
06ED6:  CALL   652A
06EDA:  MOVF   01,F
06EDC:  BNZ   6EE4
....................          return FALSE; 
06EDE:  MOVLW  00
06EE0:  MOVWF  01
06EE2:  BRA    6F22
....................       clust = nxt; 
06EE4:  MOVFF  9BF,9BB
06EE8:  MOVFF  9BE,9BA
06EEC:  MOVFF  9BD,9B9
06EF0:  MOVFF  9BC,9B8
06EF4:  MOVFF  9BB,9DC
06EF8:  MOVFF  9BA,9DB
06EFC:  MOVFF  9B9,9DA
06F00:  MOVFF  9B8,9D9
06F04:  CALL   5C30
06F08:  MOVFF  03,9BF
06F0C:  MOVFF  02,9BE
06F10:  MOVFF  01,9BD
06F14:  MOVFF  00,9BC
06F18:  BRA    6EA8
06F1A:  MOVLB  9
....................       } 
....................    return TRUE; 
06F1C:  MOVLW  01
06F1E:  MOVWF  01
06F20:  MOVLB  0
06F22:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
068AA:  MOVLW  0C
068AC:  MOVLB  7
068AE:  ADDWF  x0E,W
068B0:  MOVWF  FE9
068B2:  MOVLW  00
068B4:  ADDWFC x0F,W
068B6:  MOVWF  FEA
068B8:  MOVFF  FEF,9D5
068BC:  MOVFF  FEC,9D6
068C0:  MOVFF  FEC,9D7
068C4:  MOVFF  FEC,9D8
....................    if (clust == 0)  
068C8:  MOVLB  9
068CA:  MOVF   xC5,F
068CC:  BNZ   6936
068CE:  MOVF   xC6,F
068D0:  BNZ   6936
068D2:  MOVF   xC7,F
068D4:  BNZ   6936
068D6:  MOVF   xC8,F
068D8:  BNZ   6936
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
068DA:  MOVLW  1C
068DC:  MOVLB  7
068DE:  ADDWF  x0E,W
068E0:  MOVWF  FE9
068E2:  MOVLW  00
068E4:  ADDWFC x0F,W
068E6:  MOVWF  FEA
068E8:  MOVFF  FEF,9D1
068EC:  MOVFF  FEC,9D2
068F0:  MOVFF  FEC,9D3
068F4:  MOVFF  FEC,9D4
....................       if (scl < 2 || scl >= mcl) scl = 1; 
068F8:  MOVLB  9
068FA:  MOVF   xD4,F
068FC:  BNZ   690C
068FE:  MOVF   xD3,F
06900:  BNZ   690C
06902:  MOVF   xD2,F
06904:  BNZ   690C
06906:  MOVF   xD1,W
06908:  SUBLW  01
0690A:  BC    692A
0690C:  MOVF   xD8,W
0690E:  SUBWF  xD4,W
06910:  BNC   6934
06912:  BNZ   692A
06914:  MOVF   xD7,W
06916:  SUBWF  xD3,W
06918:  BNC   6934
0691A:  BNZ   692A
0691C:  MOVF   xD6,W
0691E:  SUBWF  xD2,W
06920:  BNC   6934
06922:  BNZ   692A
06924:  MOVF   xD5,W
06926:  SUBWF  xD1,W
06928:  BNC   6934
0692A:  CLRF   xD4
0692C:  CLRF   xD3
0692E:  CLRF   xD2
06930:  MOVLW  01
06932:  MOVWF  xD1
....................       } 
06934:  BRA    69BA
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
06936:  MOVFF  9C8,9DC
0693A:  MOVFF  9C7,9DB
0693E:  MOVFF  9C6,9DA
06942:  MOVFF  9C5,9D9
06946:  MOVLB  0
06948:  CALL   5C30
0694C:  MOVFF  03,9CC
06950:  MOVFF  02,9CB
06954:  MOVFF  01,9CA
06958:  MOVFF  00,9C9
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
0695C:  MOVLB  9
0695E:  MOVF   xCC,F
06960:  BNZ   697A
06962:  MOVF   xCB,F
06964:  BNZ   697A
06966:  MOVF   xCA,F
06968:  BNZ   697A
0696A:  MOVF   xC9,W
0696C:  SUBLW  01
0696E:  BNC   697A
06970:  CLRF   00
06972:  CLRF   01
06974:  CLRF   02
06976:  CLRF   03
06978:  BRA    6B3C
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
0697A:  MOVF   xCC,W
0697C:  SUBWF  xD8,W
0697E:  BNC   69AA
06980:  BNZ   6998
06982:  MOVF   xCB,W
06984:  SUBWF  xD7,W
06986:  BNC   69AA
06988:  BNZ   6998
0698A:  MOVF   xCA,W
0698C:  SUBWF  xD6,W
0698E:  BNC   69AA
06990:  BNZ   6998
06992:  MOVF   xD5,W
06994:  SUBWF  xC9,W
06996:  BC    69AA
06998:  MOVFF  9C9,00
0699C:  MOVFF  9CA,01
069A0:  MOVFF  9CB,02
069A4:  MOVFF  9CC,03
069A8:  BRA    6B3C
....................       scl = clust; 
069AA:  MOVFF  9C8,9D4
069AE:  MOVFF  9C7,9D3
069B2:  MOVFF  9C6,9D2
069B6:  MOVFF  9C5,9D1
....................       } 
....................       ncl = scl;                  // Scan start cluster 
069BA:  MOVFF  9D4,9D0
069BE:  MOVFF  9D3,9CF
069C2:  MOVFF  9D2,9CE
069C6:  MOVFF  9D1,9CD
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
069CA:  MOVLW  01
069CC:  ADDWF  xCD,F
069CE:  BTFSC  FD8.0
069D0:  INCF   xCE,F
069D2:  BTFSC  FD8.2
069D4:  INCF   xCF,F
069D6:  BTFSC  FD8.2
069D8:  INCF   xD0,F
....................       if (ncl >= mcl)  
069DA:  MOVF   xD8,W
069DC:  SUBWF  xD0,W
069DE:  BNC   6A1C
069E0:  BNZ   69F8
069E2:  MOVF   xD7,W
069E4:  SUBWF  xCF,W
069E6:  BNC   6A1C
069E8:  BNZ   69F8
069EA:  MOVF   xD6,W
069EC:  SUBWF  xCE,W
069EE:  BNC   6A1C
069F0:  BNZ   69F8
069F2:  MOVF   xD5,W
069F4:  SUBWF  xCD,W
069F6:  BNC   6A1C
....................          {         // Wrap around 
....................          ncl = 2; 
069F8:  CLRF   xD0
069FA:  CLRF   xCF
069FC:  CLRF   xCE
069FE:  MOVLW  02
06A00:  MOVWF  xCD
....................          if (scl == 1) return 0;      // No free custer was found 
06A02:  DECFSZ xD1,W
06A04:  BRA    6A1C
06A06:  MOVF   xD2,F
06A08:  BNZ   6A1C
06A0A:  MOVF   xD3,F
06A0C:  BNZ   6A1C
06A0E:  MOVF   xD4,F
06A10:  BNZ   6A1C
06A12:  CLRF   00
06A14:  CLRF   01
06A16:  CLRF   02
06A18:  CLRF   03
06A1A:  BRA    6B3C
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06A1C:  MOVF   xD1,W
06A1E:  SUBWF  xCD,W
06A20:  BNZ   6A3E
06A22:  MOVF   xD2,W
06A24:  SUBWF  xCE,W
06A26:  BNZ   6A3E
06A28:  MOVF   xD3,W
06A2A:  SUBWF  xCF,W
06A2C:  BNZ   6A3E
06A2E:  MOVF   xD4,W
06A30:  SUBWF  xD0,W
06A32:  BNZ   6A3E
06A34:  CLRF   00
06A36:  CLRF   01
06A38:  CLRF   02
06A3A:  CLRF   03
06A3C:  BRA    6B3C
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06A3E:  MOVFF  9D0,9DC
06A42:  MOVFF  9CF,9DB
06A46:  MOVFF  9CE,9DA
06A4A:  MOVFF  9CD,9D9
06A4E:  MOVLB  0
06A50:  CALL   5C30
06A54:  MOVFF  03,9CC
06A58:  MOVFF  02,9CB
06A5C:  MOVFF  01,9CA
06A60:  MOVFF  00,9C9
....................       if (cstat == 1) return 0;      // Any error occured 
06A64:  MOVLB  9
06A66:  DECFSZ xC9,W
06A68:  BRA    6A80
06A6A:  MOVF   xCA,F
06A6C:  BNZ   6A80
06A6E:  MOVF   xCB,F
06A70:  BNZ   6A80
06A72:  MOVF   xCC,F
06A74:  BNZ   6A80
06A76:  CLRF   00
06A78:  CLRF   01
06A7A:  CLRF   02
06A7C:  CLRF   03
06A7E:  BRA    6B3C
....................       } while (cstat);            // Repeat until find a free cluster 
06A80:  MOVF   xC9,F
06A82:  BNZ   69CA
06A84:  MOVF   xCA,F
06A86:  BNZ   69CA
06A88:  MOVF   xCB,F
06A8A:  BNZ   69CA
06A8C:  MOVF   xCC,F
06A8E:  BNZ   69CA
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06A90:  MOVFF  9D0,9DC
06A94:  MOVFF  9CF,9DB
06A98:  MOVFF  9CE,9DA
06A9C:  MOVFF  9CD,9D9
06AA0:  MOVLW  0F
06AA2:  MOVWF  xE0
06AA4:  SETF   xDF
06AA6:  SETF   xDE
06AA8:  SETF   xDD
06AAA:  MOVLB  0
06AAC:  RCALL  652A
06AAE:  MOVF   01,F
06AB0:  BNZ   6AC0
06AB2:  CLRF   00
06AB4:  CLRF   01
06AB6:  CLRF   02
06AB8:  CLRF   03
06ABA:  MOVLB  9
06ABC:  BRA    6B3C
06ABE:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06AC0:  MOVLB  9
06AC2:  MOVF   xC5,F
06AC4:  BNZ   6AD2
06AC6:  MOVF   xC6,F
06AC8:  BNZ   6AD2
06ACA:  MOVF   xC7,F
06ACC:  BNZ   6AD2
06ACE:  MOVF   xC8,F
06AD0:  BZ    6B0C
06AD2:  MOVFF  9C8,9DC
06AD6:  MOVFF  9C7,9DB
06ADA:  MOVFF  9C6,9DA
06ADE:  MOVFF  9C5,9D9
06AE2:  MOVFF  9D0,9E0
06AE6:  MOVFF  9CF,9DF
06AEA:  MOVFF  9CE,9DE
06AEE:  MOVFF  9CD,9DD
06AF2:  MOVLB  0
06AF4:  RCALL  652A
06AF6:  MOVF   01,F
06AF8:  BTFSC  FD8.2
06AFA:  BRA    6B00
06AFC:  MOVLB  9
06AFE:  BRA    6B0C
06B00:  CLRF   00
06B02:  CLRF   01
06B04:  CLRF   02
06B06:  CLRF   03
06B08:  MOVLB  9
06B0A:  BRA    6B3C
....................    fs->last_clust = ncl; 
06B0C:  MOVLW  1C
06B0E:  MOVLB  7
06B10:  ADDWF  x0E,W
06B12:  MOVWF  FE9
06B14:  MOVLW  00
06B16:  ADDWFC x0F,W
06B18:  MOVWF  FEA
06B1A:  MOVFF  9CD,FEF
06B1E:  MOVFF  9CE,FEC
06B22:  MOVFF  9CF,FEC
06B26:  MOVFF  9D0,FEC
....................  
....................    return ncl;      // Return new cluster number 
06B2A:  MOVFF  9CD,00
06B2E:  MOVFF  9CE,01
06B32:  MOVFF  9CF,02
06B36:  MOVFF  9D0,03
06B3A:  MOVLB  9
06B3C:  MOVLB  0
06B3E:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
05582:  MOVLW  02
05584:  MOVLB  9
05586:  SUBWF  xCC,F
05588:  MOVLW  00
0558A:  SUBWFB xCD,F
0558C:  SUBWFB xCE,F
0558E:  SUBWFB xCF,F
....................    if (clust >= fs->max_clust)  
05590:  MOVLW  0C
05592:  MOVLB  7
05594:  ADDWF  x0E,W
05596:  MOVWF  FE9
05598:  MOVLW  00
0559A:  ADDWFC x0F,W
0559C:  MOVWF  FEA
0559E:  MOVFF  FEF,00
055A2:  MOVFF  FEC,01
055A6:  MOVFF  FEC,02
055AA:  MOVFF  FEC,03
055AE:  MOVF   03,W
055B0:  MOVLB  9
055B2:  SUBWF  xCF,W
055B4:  BNC   55D8
055B6:  BNZ   55CE
055B8:  MOVF   02,W
055BA:  SUBWF  xCE,W
055BC:  BNC   55D8
055BE:  BNZ   55CE
055C0:  MOVF   01,W
055C2:  SUBWF  xCD,W
055C4:  BNC   55D8
055C6:  BNZ   55CE
055C8:  MOVF   00,W
055CA:  SUBWF  xCC,W
055CC:  BNC   55D8
....................       return 0;      // Invalid cluster#  
055CE:  CLRF   00
055D0:  CLRF   01
055D2:  CLRF   02
055D4:  CLRF   03
055D6:  BRA    5658
....................    return (clust * fs->sects_clust + fs->database); 
055D8:  MOVLW  02
055DA:  MOVLB  7
055DC:  ADDWF  x0E,W
055DE:  MOVWF  FE9
055E0:  MOVLW  00
055E2:  ADDWFC x0F,W
055E4:  MOVWF  FEA
055E6:  MOVFF  FEF,9D7
055EA:  MOVLB  9
055EC:  MOVFF  FEA,9D2
055F0:  MOVFF  FE9,9D1
055F4:  MOVFF  9CF,9D6
055F8:  MOVFF  9CE,9D5
055FC:  MOVFF  9CD,9D4
05600:  MOVFF  9CC,9D3
05604:  CLRF   xDA
05606:  CLRF   xD9
05608:  CLRF   xD8
0560A:  MOVLB  0
0560C:  CALL   4772
05610:  MOVFF  9D2,FEA
05614:  MOVFF  9D1,FE9
05618:  MOVFF  03,9D3
0561C:  MOVFF  02,9D2
05620:  MOVFF  01,9D1
05624:  MOVFF  00,9D0
05628:  MOVLW  18
0562A:  MOVLB  7
0562C:  ADDWF  x0E,W
0562E:  MOVWF  FE9
05630:  MOVLW  00
05632:  ADDWFC x0F,W
05634:  MOVWF  FEA
05636:  MOVFF  FEF,00
0563A:  MOVFF  FEC,01
0563E:  MOVFF  FEC,02
05642:  MOVFF  FEC,03
05646:  MOVLB  9
05648:  MOVF   xD0,W
0564A:  ADDWF  00,F
0564C:  MOVF   xD1,W
0564E:  ADDWFC 01,F
05650:  MOVF   xD2,W
05652:  ADDWFC 02,F
05654:  MOVF   xD3,W
05656:  ADDWFC 03,F
05658:  MOVLB  0
0565A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
04616:  MOVLW  24
04618:  MOVLB  7
0461A:  ADDWF  x0E,W
0461C:  MOVWF  01
0461E:  MOVLW  00
04620:  ADDWFC x0F,W
04622:  MOVWF  03
04624:  MOVFF  01,9C4
04628:  MOVLB  9
0462A:  MOVWF  xC5
0462C:  MOVWF  FEA
0462E:  MOVFF  01,FE9
04632:  CLRF   00
04634:  MOVLW  02
04636:  MOVWF  02
04638:  CLRF   01
0463A:  MOVLB  0
0463C:  CALL   34A4
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
04640:  MOVLW  24
04642:  MOVLB  7
04644:  ADDWF  x0E,W
04646:  MOVWF  01
04648:  MOVLW  00
0464A:  ADDWFC x0F,W
0464C:  MOVWF  03
0464E:  MOVFF  01,9C4
04652:  MOVLB  9
04654:  MOVWF  xC5
04656:  MOVWF  xFA
04658:  MOVFF  01,9F9
0465C:  MOVFF  9C3,9FE
04660:  MOVFF  9C2,9FD
04664:  MOVFF  9C1,9FC
04668:  MOVFF  9C0,9FB
0466C:  MOVLW  01
0466E:  MOVWF  xFF
04670:  MOVLB  0
04672:  RCALL  444A
04674:  MOVF   01,F
04676:  BTFSS  FD8.2
04678:  BRA    4768
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
0467A:  MOVLW  22
0467C:  MOVLB  7
0467E:  ADDWF  x0E,W
04680:  MOVWF  01
04682:  MOVLW  02
04684:  ADDWFC x0F,W
04686:  MOVWF  03
04688:  MOVFF  01,FE9
0468C:  MOVWF  FEA
0468E:  MOVFF  FEC,9C5
04692:  MOVF   FED,F
04694:  MOVFF  FEF,9C4
04698:  MOVLB  9
0469A:  MOVF   xC4,W
0469C:  SUBLW  55
0469E:  BNZ   476A
046A0:  MOVF   xC5,W
046A2:  SUBLW  AA
046A4:  BNZ   476A
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
046A6:  MOVLW  5A
046A8:  MOVLB  7
046AA:  ADDWF  x0E,W
046AC:  MOVWF  01
046AE:  MOVLW  00
046B0:  ADDWFC x0F,W
046B2:  MOVWF  03
046B4:  MOVFF  01,9C4
046B8:  MOVLB  9
046BA:  MOVWF  xC5
046BC:  MOVWF  xC7
046BE:  MOVFF  01,9C6
046C2:  MOVLW  07
046C4:  MOVWF  xC9
046C6:  MOVLW  10
046C8:  MOVWF  xC8
046CA:  CLRF   xCB
046CC:  MOVLW  05
046CE:  MOVWF  xCA
046D0:  MOVLB  0
046D2:  RCALL  4592
046D4:  MOVF   01,F
046D6:  BNZ   46DE
....................             return (FS_FAT12); 
046D8:  MOVLW  01
046DA:  MOVWF  01
046DC:  BRA    4770
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
046DE:  MOVLW  5A
046E0:  MOVLB  7
046E2:  ADDWF  x0E,W
046E4:  MOVWF  01
046E6:  MOVLW  00
046E8:  ADDWFC x0F,W
046EA:  MOVWF  03
046EC:  MOVFF  01,9C4
046F0:  MOVLB  9
046F2:  MOVWF  xC5
046F4:  MOVWF  xC7
046F6:  MOVFF  01,9C6
046FA:  MOVLW  07
046FC:  MOVWF  xC9
046FE:  MOVLW  15
04700:  MOVWF  xC8
04702:  CLRF   xCB
04704:  MOVLW  05
04706:  MOVWF  xCA
04708:  MOVLB  0
0470A:  RCALL  4592
0470C:  MOVF   01,F
0470E:  BNZ   4716
....................             return (FS_FAT16); 
04710:  MOVLW  02
04712:  MOVWF  01
04714:  BRA    4770
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
04716:  MOVLW  76
04718:  MOVLB  7
0471A:  ADDWF  x0E,W
0471C:  MOVWF  01
0471E:  MOVLW  00
04720:  ADDWFC x0F,W
04722:  MOVWF  03
04724:  MOVFF  01,9C4
04728:  MOVLB  9
0472A:  MOVWF  xC5
0472C:  MOVWF  xC7
0472E:  MOVFF  01,9C6
04732:  MOVLW  07
04734:  MOVWF  xC9
04736:  MOVLW  1A
04738:  MOVWF  xC8
0473A:  CLRF   xCB
0473C:  MOVLW  05
0473E:  MOVWF  xCA
04740:  MOVLB  0
04742:  RCALL  4592
04744:  MOVF   01,F
04746:  BNZ   4768
04748:  MOVLW  4C
0474A:  MOVLB  7
0474C:  ADDWF  x0E,W
0474E:  MOVWF  FE9
04750:  MOVLW  00
04752:  ADDWFC x0F,W
04754:  MOVWF  FEA
04756:  MOVF   FEF,F
04758:  BTFSC  FD8.2
0475A:  BRA    4760
0475C:  MOVLB  0
0475E:  BRA    4768
....................             return (FS_FAT32); 
04760:  MOVLW  03
04762:  MOVWF  01
04764:  MOVLB  0
04766:  BRA    4770
04768:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
0476A:  MOVLW  00
0476C:  MOVWF  01
0476E:  MOVLB  0
04770:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
05F68:  MOVLW  0C
05F6A:  MOVLB  9
05F6C:  ADDWF  xC2,W
05F6E:  MOVWF  FE9
05F70:  MOVLW  00
05F72:  ADDWFC xC3,W
05F74:  MOVWF  FEA
05F76:  MOVFF  FEC,9CB
05F7A:  MOVF   FED,F
05F7C:  MOVFF  FEF,9CA
05F80:  MOVLW  01
05F82:  ADDWF  xCA,W
05F84:  MOVWF  xC8
05F86:  MOVLW  00
05F88:  ADDWFC xCB,W
05F8A:  MOVWF  xC9
....................    if ((idx & 15) == 0)  
05F8C:  MOVF   xC8,W
05F8E:  ANDLW  0F
05F90:  MOVWF  xCA
05F92:  CLRF   xCB
05F94:  MOVF   xCA,F
05F96:  BTFSS  FD8.2
05F98:  BRA    6124
05F9A:  MOVF   xCB,F
05F9C:  BTFSS  FD8.2
05F9E:  BRA    6124
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
05FA0:  MOVLW  08
05FA2:  ADDWF  xC2,W
05FA4:  MOVWF  FE9
05FA6:  MOVLW  00
05FA8:  ADDWFC xC3,W
05FAA:  MOVWF  FEA
05FAC:  MOVLW  01
05FAE:  ADDWF  FEE,F
05FB0:  MOVLW  00
05FB2:  ADDWFC FEE,F
05FB4:  ADDWFC FEE,F
05FB6:  ADDWFC FED,F
....................       if (!scan->clust)  
05FB8:  MOVLW  04
05FBA:  ADDWF  xC2,W
05FBC:  MOVWF  FE9
05FBE:  MOVLW  00
05FC0:  ADDWFC xC3,W
05FC2:  MOVWF  FEA
05FC4:  MOVF   FEF,F
05FC6:  BNZ   6004
05FC8:  MOVF   FEC,F
05FCA:  BNZ   6004
05FCC:  MOVF   FEC,F
05FCE:  BNZ   6004
05FD0:  MOVF   FEC,F
05FD2:  BNZ   6004
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
05FD4:  MOVLW  04
05FD6:  MOVLB  7
05FD8:  ADDWF  x0E,W
05FDA:  MOVWF  FE9
05FDC:  MOVLW  00
05FDE:  ADDWFC x0F,W
05FE0:  MOVWF  FEA
05FE2:  MOVFF  FEC,03
05FE6:  MOVF   FED,F
05FE8:  MOVFF  FEF,01
05FEC:  MOVF   03,W
05FEE:  MOVLB  9
05FF0:  SUBWF  xC9,W
05FF2:  BNC   6002
05FF4:  BNZ   5FFC
05FF6:  MOVF   01,W
05FF8:  SUBWF  xC8,W
05FFA:  BNC   6002
....................             return (FALSE);   // Reached to end of table  
05FFC:  MOVLW  00
05FFE:  MOVWF  01
06000:  BRA    613E
....................          }  
06002:  BRA    6124
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
06004:  RRCF   xC9,W
06006:  MOVWF  xCB
06008:  RRCF   xC8,W
0600A:  MOVWF  xCA
0600C:  RRCF   xCB,F
0600E:  RRCF   xCA,F
06010:  RRCF   xCB,F
06012:  RRCF   xCA,F
06014:  RRCF   xCB,F
06016:  RRCF   xCA,F
06018:  MOVLW  0F
0601A:  ANDWF  xCB,F
0601C:  MOVLW  02
0601E:  MOVLB  7
06020:  ADDWF  x0E,W
06022:  MOVWF  FE9
06024:  MOVLW  00
06026:  ADDWFC x0F,W
06028:  MOVWF  FEA
0602A:  MOVLW  01
0602C:  SUBWF  FEF,W
0602E:  MOVLB  9
06030:  ANDWF  xCA,F
06032:  CLRF   xCB
06034:  MOVF   xCA,F
06036:  BTFSS  FD8.2
06038:  BRA    6124
0603A:  MOVF   xCB,F
0603C:  BTFSS  FD8.2
0603E:  BRA    6124
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
06040:  MOVLW  04
06042:  ADDWF  xC2,W
06044:  MOVWF  FE9
06046:  MOVLW  00
06048:  ADDWFC xC3,W
0604A:  MOVWF  FEA
0604C:  MOVFF  FEF,9D9
06050:  MOVFF  FEC,9DA
06054:  MOVFF  FEC,9DB
06058:  MOVFF  FEC,9DC
0605C:  MOVLB  0
0605E:  RCALL  5C30
06060:  MOVFF  03,9C7
06064:  MOVFF  02,9C6
06068:  MOVFF  01,9C5
0606C:  MOVFF  00,9C4
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
06070:  MOVLW  0C
06072:  MOVLB  7
06074:  ADDWF  x0E,W
06076:  MOVWF  FE9
06078:  MOVLW  00
0607A:  ADDWFC x0F,W
0607C:  MOVWF  FEA
0607E:  MOVFF  FEF,00
06082:  MOVFF  FEC,01
06086:  MOVFF  FEC,02
0608A:  MOVFF  FEC,03
0608E:  MOVF   03,W
06090:  MOVLB  9
06092:  SUBWF  xC7,W
06094:  BNC   60AE
06096:  BNZ   60C0
06098:  MOVF   02,W
0609A:  SUBWF  xC6,W
0609C:  BNC   60AE
0609E:  BNZ   60C0
060A0:  MOVF   01,W
060A2:  SUBWF  xC5,W
060A4:  BNC   60AE
060A6:  BNZ   60C0
060A8:  MOVF   00,W
060AA:  SUBWF  xC4,W
060AC:  BC    60C0
060AE:  MOVF   xC7,F
060B0:  BNZ   60C6
060B2:  MOVF   xC6,F
060B4:  BNZ   60C6
060B6:  MOVF   xC5,F
060B8:  BNZ   60C6
060BA:  MOVF   xC4,W
060BC:  SUBLW  01
060BE:  BNC   60C6
....................                return (FALSE); 
060C0:  MOVLW  00
060C2:  MOVWF  01
060C4:  BRA    613E
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
060C6:  MOVLW  04
060C8:  ADDWF  xC2,W
060CA:  MOVWF  FE9
060CC:  MOVLW  00
060CE:  ADDWFC xC3,W
060D0:  MOVWF  FEA
060D2:  MOVFF  9C4,FEF
060D6:  MOVFF  9C5,FEC
060DA:  MOVFF  9C6,FEC
060DE:  MOVFF  9C7,FEC
....................             scan->sect = clust2sect(clust); 
060E2:  MOVLW  08
060E4:  ADDWF  xC2,W
060E6:  MOVWF  01
060E8:  MOVLW  00
060EA:  ADDWFC xC3,W
060EC:  MOVWF  03
060EE:  MOVFF  01,9CA
060F2:  MOVWF  xCB
060F4:  MOVFF  9C7,9CF
060F8:  MOVFF  9C6,9CE
060FC:  MOVFF  9C5,9CD
06100:  MOVFF  9C4,9CC
06104:  MOVLB  0
06106:  CALL   5582
0610A:  MOVFF  9CB,FEA
0610E:  MOVFF  9CA,FE9
06112:  MOVFF  00,FEF
06116:  MOVFF  01,FEC
0611A:  MOVFF  02,FEC
0611E:  MOVFF  03,FEC
06122:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
06124:  MOVLW  0C
06126:  ADDWF  xC2,W
06128:  MOVWF  FE9
0612A:  MOVLW  00
0612C:  ADDWFC xC3,W
0612E:  MOVWF  FEA
06130:  MOVFF  9C9,FEC
06134:  MOVF   FED,F
06136:  MOVFF  9C8,FEF
....................    return (TRUE); 
0613A:  MOVLW  01
0613C:  MOVWF  01
0613E:  MOVLB  0
06140:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
0565C:  MOVFF  9C5,FEA
05660:  MOVFF  9C4,FE9
05664:  MOVLW  20
05666:  MOVWF  00
05668:  CLRF   02
0566A:  MOVLW  0B
0566C:  MOVWF  01
0566E:  CALL   34A4
....................    a = 0; b = 0x18;            // NT flag 
05672:  MOVLB  9
05674:  CLRF   xC9
05676:  MOVLW  18
05678:  MOVWF  xCA
....................    n = 0; t = 8; 
0567A:  CLRF   xC6
0567C:  MOVLW  08
0567E:  MOVWF  xC7
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
05680:  MOVFF  9C2,FE9
05684:  MOVFF  9C3,FEA
05688:  MOVFF  FEC,9CC
0568C:  MOVF   FED,F
0568E:  MOVFF  FEF,9CB
....................       c = *ptr; 
05692:  MOVFF  9CB,FE9
05696:  MOVFF  9CC,FEA
0569A:  MOVFF  FEF,9C8
....................       (*path)++; 
0569E:  MOVFF  9C3,03
056A2:  MOVFF  9C2,FE9
056A6:  MOVFF  9C3,FEA
056AA:  MOVLW  01
056AC:  ADDWF  FEE,F
056AE:  BNC   56B2
056B0:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
056B2:  MOVF   xC8,W
056B4:  SUBLW  20
056B6:  BNC   56BA
....................          c = 0; 
056B8:  CLRF   xC8
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
056BA:  MOVF   xC8,F
056BC:  BZ    56CA
056BE:  MOVF   xC8,W
056C0:  SUBLW  2F
056C2:  BZ    56CA
056C4:  MOVF   xC8,W
056C6:  SUBLW  5C
056C8:  BNZ   56E8
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
056CA:  MOVF   xC6,F
056CC:  BNZ   56D0
....................             break; 
056CE:  BRA    57B0
....................          dirname[11] = a & b;  
056D0:  MOVLW  0B
056D2:  ADDWF  xC4,W
056D4:  MOVWF  FE9
056D6:  MOVLW  00
056D8:  ADDWFC xC5,W
056DA:  MOVWF  FEA
056DC:  MOVF   xC9,W
056DE:  ANDWF  xCA,W
056E0:  MOVWF  FEF
....................             return (c); 
056E2:  MOVFF  9C8,01
056E6:  BRA    57B4
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
056E8:  MOVF   xC8,W
056EA:  SUBLW  20
056EC:  BC    56F4
056EE:  MOVF   xC8,W
056F0:  SUBLW  7F
056F2:  BNZ   56F6
....................          break;   // reject invisible characters 
056F4:  BRA    57B0
....................       if (c == '.')  
056F6:  MOVF   xC8,W
056F8:  SUBLW  2E
056FA:  BNZ   5718
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
056FC:  BTFSC  xC9.0
056FE:  BRA    5716
05700:  MOVF   xC6,W
05702:  SUBLW  00
05704:  BC    5716
05706:  MOVF   xC6,W
05708:  SUBLW  08
0570A:  BNC   5716
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
0570C:  MOVLW  08
0570E:  MOVWF  xC6
05710:  MOVLW  0B
05712:  MOVWF  xC7
....................             continue; 
05714:  BRA    57AE
....................             } 
....................          break; 
05716:  BRA    57B0
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
05718:  MOVF   xC8,W
0571A:  SUBLW  22
0571C:  BNZ   5720
....................          break;               // Reject "  
0571E:  BRA    57B0
....................  
....................       if (c <= ')')  
05720:  MOVF   xC8,W
05722:  SUBLW  29
05724:  BNC   5728
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
05726:  BRA    5792
....................  
....................       if (c <= ',') 
05728:  MOVF   xC8,W
0572A:  SUBLW  2C
0572C:  BNC   5730
....................          break;               // Reject * + ,  
0572E:  BRA    57B0
....................  
....................       if (c <= '9')  
05730:  MOVF   xC8,W
05732:  SUBLW  39
05734:  BNC   5738
....................          goto md_l1;            // Accept - 0-9  
05736:  BRA    5792
....................  
....................       if (c <= '?')  
05738:  MOVF   xC8,W
0573A:  SUBLW  3F
0573C:  BNC   5740
....................          break;               // Reject : ; < = > ?  
0573E:  BRA    57B0
....................  
....................       if (!(a & 1))  
05740:  BTFSC  xC9.0
05742:  BRA    5792
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
05744:  MOVF   xC8,W
05746:  SUBLW  7C
05748:  BNZ   574C
....................             break;            // Reject |  
0574A:  BRA    57B0
....................  
....................          if ((c >= '[') && (c <= ']')) 
0574C:  MOVF   xC8,W
0574E:  SUBLW  5A
05750:  BC    575A
05752:  MOVF   xC8,W
05754:  SUBLW  5D
05756:  BNC   575A
....................             break;// Reject [ \ ]  
05758:  BRA    57B0
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
0575A:  MOVF   xC8,W
0575C:  SUBLW  40
0575E:  BC    5774
05760:  MOVF   xC8,W
05762:  SUBLW  5A
05764:  BNC   5774
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
05766:  MOVF   xC7,W
05768:  SUBLW  08
0576A:  BNZ   5772
0576C:  BCF    xCA.3
0576E:  MOVF   xCA,W
05770:  BRA    5774
05772:  BCF    xCA.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
05774:  MOVF   xC8,W
05776:  SUBLW  60
05778:  BC    5792
0577A:  MOVF   xC8,W
0577C:  SUBLW  7A
0577E:  BNC   5792
....................             {      // Convert to upper case  
....................             c -= 0x20; 
05780:  MOVLW  20
05782:  SUBWF  xC8,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
05784:  MOVF   xC7,W
05786:  SUBLW  08
05788:  BNZ   5790
0578A:  BSF    xC9.3
0578C:  MOVF   xC9,W
0578E:  BRA    5792
05790:  BSF    xC9.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
05792:  BCF    xC9.0
....................    md_l2: 
....................       if (n >= t)  
05794:  MOVF   xC7,W
05796:  SUBWF  xC6,W
05798:  BNC   579C
....................          break; 
0579A:  BRA    57B0
....................       dirname[n++] = c; 
0579C:  MOVF   xC6,W
0579E:  INCF   xC6,F
057A0:  ADDWF  xC4,W
057A2:  MOVWF  FE9
057A4:  MOVLW  00
057A6:  ADDWFC xC5,W
057A8:  MOVWF  FEA
057AA:  MOVFF  9C8,FEF
057AE:  BRA    5680
....................       } 
....................    return 1; 
057B0:  MOVLW  01
057B2:  MOVWF  01
057B4:  MOVLB  0
057B6:  GOTO   62E4 (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
06142:  MOVLB  9
06144:  CLRF   xC1
06146:  CLRF   xC0
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
06148:  MOVLW  14
0614A:  MOVLB  7
0614C:  ADDWF  x0E,W
0614E:  MOVWF  FE9
06150:  MOVLW  00
06152:  ADDWFC x0F,W
06154:  MOVWF  FEA
06156:  MOVFF  FEF,9BB
0615A:  MOVFF  FEC,9BC
0615E:  MOVFF  FEC,9BD
06162:  MOVFF  FEC,9BE
....................    if (fs->fs_type == FS_FAT32)  
06166:  MOVFF  70E,FE9
0616A:  MOVFF  70F,FEA
0616E:  MOVF   FEF,W
06170:  SUBLW  03
06172:  BNZ   61F6
....................       { 
....................       scan->clust = scan->sclust = clust; 
06174:  MOVLW  04
06176:  MOVLB  9
06178:  ADDWF  xB3,W
0617A:  MOVWF  01
0617C:  MOVLW  00
0617E:  ADDWFC xB4,W
06180:  MOVFF  01,9C2
06184:  MOVFF  9B3,FE9
06188:  MOVFF  9B4,FEA
0618C:  MOVFF  9BB,FEF
06190:  MOVFF  9BC,FEC
06194:  MOVFF  9BD,FEC
06198:  MOVFF  9BE,FEC
0619C:  MOVWF  FEA
0619E:  MOVFF  9C2,FE9
061A2:  MOVFF  9BB,FEF
061A6:  MOVFF  9BC,FEC
061AA:  MOVFF  9BD,FEC
061AE:  MOVFF  9BE,FEC
....................       scan->sect = clust2sect(clust); 
061B2:  MOVLW  08
061B4:  ADDWF  xB3,W
061B6:  MOVWF  01
061B8:  MOVLW  00
061BA:  ADDWFC xB4,W
061BC:  MOVWF  03
061BE:  MOVFF  01,9C2
061C2:  MOVWF  xC3
061C4:  MOVFF  9BE,9CF
061C8:  MOVFF  9BD,9CE
061CC:  MOVFF  9BC,9CD
061D0:  MOVFF  9BB,9CC
061D4:  MOVLB  0
061D6:  CALL   5582
061DA:  MOVFF  9C3,FEA
061DE:  MOVFF  9C2,FE9
061E2:  MOVFF  00,FEF
061E6:  MOVFF  01,FEC
061EA:  MOVFF  02,FEC
061EE:  MOVFF  03,FEC
....................       } 
061F2:  BRA    6256
061F4:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
061F6:  MOVLW  04
061F8:  MOVLB  9
061FA:  ADDWF  xB3,W
061FC:  MOVWF  01
061FE:  MOVLW  00
06200:  ADDWFC xB4,W
06202:  MOVWF  03
06204:  MOVFF  9B3,FE9
06208:  MOVFF  9B4,FEA
0620C:  MOVF   FEE,F
0620E:  MOVF   FEE,F
06210:  CLRF   FEC
06212:  MOVF   FED,F
06214:  CLRF   FEF
06216:  MOVF   FED,F
06218:  CLRF   FEF
0621A:  MOVF   FED,F
0621C:  CLRF   FEF
0621E:  MOVLW  00
06220:  MOVFF  03,FEA
06224:  MOVFF  01,FE9
06228:  MOVFF  00,FEF
0622C:  MOVFF  01,FEC
06230:  MOVFF  02,FEC
06234:  MOVFF  03,FEC
....................       scan->sect = clust; 
06238:  MOVLW  08
0623A:  ADDWF  xB3,W
0623C:  MOVWF  FE9
0623E:  MOVLW  00
06240:  ADDWFC xB4,W
06242:  MOVWF  FEA
06244:  MOVFF  9BB,FEF
06248:  MOVFF  9BC,FEC
0624C:  MOVFF  9BD,FEC
06250:  MOVFF  9BE,FEC
06254:  MOVLB  0
....................       } 
....................    scan->index = 0; 
06256:  MOVLW  0C
06258:  MOVLB  9
0625A:  ADDWF  xB3,W
0625C:  MOVWF  FE9
0625E:  MOVLW  00
06260:  ADDWFC xB4,W
06262:  MOVWF  FEA
06264:  CLRF   FEC
06266:  MOVF   FED,F
06268:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
0626A:  MOVFF  9B8,03
0626E:  MOVFF  9B7,FE9
06272:  MOVFF  9B8,FEA
06276:  MOVF   FEF,W
06278:  SUBLW  20
0627A:  BZ    62A0
0627C:  MOVFF  9B8,03
06280:  MOVFF  9B7,FE9
06284:  MOVFF  9B8,FEA
06288:  MOVF   FEF,W
0628A:  SUBLW  2F
0628C:  BZ    62A0
0628E:  MOVFF  9B8,03
06292:  MOVFF  9B7,FE9
06296:  MOVFF  9B8,FEA
0629A:  MOVF   FEF,W
0629C:  SUBLW  5C
0629E:  BNZ   62A8
....................        path++; 
062A0:  INCF   xB7,F
062A2:  BTFSC  FD8.2
062A4:  INCF   xB8,F
062A6:  BRA    626A
....................  
....................    if ((BYTE)*path < ' ')  
062A8:  MOVFF  9B8,03
062AC:  MOVFF  9B7,FE9
062B0:  MOVFF  9B8,FEA
062B4:  MOVF   FEF,W
062B6:  SUBLW  1F
062B8:  BNC   62CE
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
062BA:  MOVFF  9B9,FE9
062BE:  MOVFF  9BA,FEA
062C2:  CLRF   FEC
062C4:  MOVF   FED,F
062C6:  CLRF   FEF
....................       return (FR_OK); 
062C8:  MOVLW  00
062CA:  MOVWF  01
062CC:  BRA    6526
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
062CE:  MOVLW  09
062D0:  MOVWF  xC3
062D2:  MOVLW  B7
062D4:  MOVWF  xC2
062D6:  MOVFF  9B6,9C5
062DA:  MOVFF  9B5,9C4
062DE:  MOVLB  0
062E0:  GOTO   565C
062E4:  MOVFF  01,9BF
....................       if (ds == 1)  
062E8:  MOVLB  9
062EA:  DECFSZ xBF,W
062EC:  BRA    62F4
....................          return (FR_INVALID_NAME); 
062EE:  MOVLW  04
062F0:  MOVWF  01
062F2:  BRA    6526
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
062F4:  MOVLW  08
062F6:  ADDWF  xB3,W
062F8:  MOVWF  FE9
062FA:  MOVLW  00
062FC:  ADDWFC xB4,W
062FE:  MOVWF  FEA
06300:  MOVFF  FEF,9ED
06304:  MOVFF  FEC,9EE
06308:  MOVFF  FEC,9EF
0630C:  MOVFF  FEC,9F0
06310:  MOVLB  0
06312:  CALL   59F8
06316:  MOVF   01,F
06318:  BNZ   6324
....................             return (FR_RW_ERROR); 
0631A:  MOVLW  07
0631C:  MOVWF  01
0631E:  MOVLB  9
06320:  BRA    6526
06322:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
06324:  MOVLW  0C
06326:  MOVLB  9
06328:  ADDWF  xB3,W
0632A:  MOVWF  FE9
0632C:  MOVLW  00
0632E:  ADDWFC xB4,W
06330:  MOVWF  FEA
06332:  MOVFF  FEC,9C3
06336:  MOVF   FED,F
06338:  MOVFF  FEF,9C2
0633C:  MOVLW  0F
0633E:  ANDWF  xC2,F
06340:  CLRF   xC3
06342:  RLCF   xC2,F
06344:  RLCF   xC3,F
06346:  RLCF   xC2,F
06348:  RLCF   xC3,F
0634A:  RLCF   xC2,F
0634C:  RLCF   xC3,F
0634E:  RLCF   xC2,F
06350:  RLCF   xC3,F
06352:  RLCF   xC2,F
06354:  RLCF   xC3,F
06356:  MOVLW  E0
06358:  ANDWF  xC2,F
0635A:  MOVLW  24
0635C:  ADDWF  xC2,W
0635E:  MOVWF  01
06360:  MOVLW  00
06362:  ADDWFC xC3,W
06364:  MOVWF  03
06366:  MOVF   01,W
06368:  MOVLB  7
0636A:  ADDWF  x0E,W
0636C:  MOVWF  01
0636E:  MOVF   x0F,W
06370:  ADDWFC 03,F
06372:  MOVFF  01,9C0
06376:  MOVLB  9
06378:  MOVFF  03,9C1
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
0637C:  MOVFF  9C1,03
06380:  MOVFF  9C0,FE9
06384:  MOVFF  9C1,FEA
06388:  MOVF   FEF,F
0638A:  BNZ   639A
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
0638C:  MOVF   xBF,F
0638E:  BNZ   6394
06390:  MOVLW  02
06392:  BRA    6396
06394:  MOVLW  03
06396:  MOVWF  01
06398:  BRA    6526
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
0639A:  MOVFF  9C1,03
0639E:  MOVFF  9C0,FE9
063A2:  MOVFF  9C1,FEA
063A6:  MOVF   FEF,W
063A8:  SUBLW  E5
063AA:  BZ    63EC
063AC:  MOVLW  0B
063AE:  ADDWF  xC0,W
063B0:  MOVWF  01
063B2:  MOVLW  00
063B4:  ADDWFC xC1,W
063B6:  MOVWF  03
063B8:  MOVFF  01,FE9
063BC:  MOVWF  FEA
063BE:  BTFSC  FEF.3
063C0:  BRA    63EC
063C2:  MOVFF  9C1,9C7
063C6:  MOVFF  9C0,9C6
063CA:  MOVFF  9B6,9C9
063CE:  MOVFF  9B5,9C8
063D2:  CLRF   xCB
063D4:  MOVLW  0B
063D6:  MOVWF  xCA
063D8:  MOVLB  0
063DA:  CALL   4592
063DE:  MOVF   01,F
063E0:  BTFSC  FD8.2
063E2:  BRA    63E8
063E4:  MOVLB  9
063E6:  BRA    63EC
....................              break; 
063E8:  BRA    6414
063EA:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
063EC:  MOVFF  9B4,9C3
063F0:  MOVFF  9B3,9C2
063F4:  MOVLB  0
063F6:  RCALL  5F68
063F8:  MOVF   01,F
063FA:  BNZ   640E
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
063FC:  MOVLB  9
063FE:  MOVF   xBF,F
06400:  BNZ   6406
06402:  MOVLW  02
06404:  BRA    6408
06406:  MOVLW  03
06408:  MOVWF  01
0640A:  BRA    6526
0640C:  MOVLB  0
0640E:  MOVLB  9
06410:  BRA    62F4
06412:  MOVLB  0
....................          } 
....................       if (!ds)  
06414:  MOVLB  9
06416:  MOVF   xBF,F
06418:  BNZ   6432
....................          {  
....................          *win_dir = dptr;  
0641A:  MOVFF  9B9,FE9
0641E:  MOVFF  9BA,FEA
06422:  MOVFF  9C1,FEC
06426:  MOVF   FED,F
06428:  MOVFF  9C0,FEF
....................          return (FR_OK); 
0642C:  MOVLW  00
0642E:  MOVWF  01
06430:  BRA    6526
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
06432:  MOVLW  0B
06434:  ADDWF  xC0,W
06436:  MOVWF  01
06438:  MOVLW  00
0643A:  ADDWFC xC1,W
0643C:  MOVWF  03
0643E:  MOVFF  01,FE9
06442:  MOVWF  FEA
06444:  BTFSC  FEF.4
06446:  BRA    644E
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
06448:  MOVLW  03
0644A:  MOVWF  01
0644C:  BRA    6526
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
0644E:  MOVLW  14
06450:  ADDWF  xC0,W
06452:  MOVWF  01
06454:  MOVLW  00
06456:  ADDWFC xC1,W
06458:  MOVWF  03
0645A:  MOVFF  01,FE9
0645E:  MOVWF  FEA
06460:  MOVFF  FEC,9BE
06464:  MOVF   FED,F
06466:  MOVFF  FEF,9C2
0646A:  MOVFF  9C2,9BD
0646E:  CLRF   xC2
06470:  CLRF   xC3
06472:  MOVLW  1A
06474:  ADDWF  xC0,W
06476:  MOVWF  01
06478:  MOVLW  00
0647A:  ADDWFC xC1,W
0647C:  MOVFF  01,FE9
06480:  MOVWF  FEA
06482:  MOVFF  FEC,03
06486:  MOVF   FED,F
06488:  MOVF   FEF,W
0648A:  IORWF  xC2,W
0648C:  MOVWF  xBB
0648E:  MOVF   03,W
06490:  IORWF  xC3,W
06492:  MOVWF  xBC
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
06494:  MOVLW  04
06496:  ADDWF  xB3,W
06498:  MOVWF  01
0649A:  MOVLW  00
0649C:  ADDWFC xB4,W
0649E:  MOVFF  01,9C2
064A2:  MOVFF  9B3,FE9
064A6:  MOVFF  9B4,FEA
064AA:  MOVFF  9BB,FEF
064AE:  MOVFF  9BC,FEC
064B2:  MOVFF  9BD,FEC
064B6:  MOVFF  9BE,FEC
064BA:  MOVWF  FEA
064BC:  MOVFF  9C2,FE9
064C0:  MOVFF  9BB,FEF
064C4:  MOVFF  9BC,FEC
064C8:  MOVFF  9BD,FEC
064CC:  MOVFF  9BE,FEC
....................       scan->sect = clust2sect(clust); 
064D0:  MOVLW  08
064D2:  ADDWF  xB3,W
064D4:  MOVWF  01
064D6:  MOVLW  00
064D8:  ADDWFC xB4,W
064DA:  MOVWF  03
064DC:  MOVFF  01,9C2
064E0:  MOVWF  xC3
064E2:  MOVFF  9BE,9CF
064E6:  MOVFF  9BD,9CE
064EA:  MOVFF  9BC,9CD
064EE:  MOVFF  9BB,9CC
064F2:  MOVLB  0
064F4:  CALL   5582
064F8:  MOVFF  9C3,FEA
064FC:  MOVFF  9C2,FE9
06500:  MOVFF  00,FEF
06504:  MOVFF  01,FEC
06508:  MOVFF  02,FEC
0650C:  MOVFF  03,FEC
....................       scan->index = 0; 
06510:  MOVLW  0C
06512:  MOVLB  9
06514:  ADDWF  xB3,W
06516:  MOVWF  FE9
06518:  MOVLW  00
0651A:  ADDWFC xB4,W
0651C:  MOVWF  FEA
0651E:  CLRF   FEC
06520:  MOVF   FED,F
06522:  CLRF   FEF
06524:  BRA    62CE
....................       } 
06526:  MOVLB  0
06528:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06B40:  MOVLB  9
06B42:  MOVFF  9B3,FE9
06B46:  MOVFF  9B4,FEA
06B4A:  MOVFF  FEF,9B5
06B4E:  MOVFF  FEC,9B6
06B52:  MOVFF  FEC,9B7
06B56:  MOVFF  FEC,9B8
....................    if (clust) {   // Dyanmic directory table  
06B5A:  MOVF   xB5,F
06B5C:  BNZ   6B6A
06B5E:  MOVF   xB6,F
06B60:  BNZ   6B6A
06B62:  MOVF   xB7,F
06B64:  BNZ   6B6A
06B66:  MOVF   xB8,F
06B68:  BZ    6BCA
....................       scan->clust = clust; 
06B6A:  MOVLW  04
06B6C:  ADDWF  xB3,W
06B6E:  MOVWF  FE9
06B70:  MOVLW  00
06B72:  ADDWFC xB4,W
06B74:  MOVWF  FEA
06B76:  MOVFF  9B5,FEF
06B7A:  MOVFF  9B6,FEC
06B7E:  MOVFF  9B7,FEC
06B82:  MOVFF  9B8,FEC
....................       scan->sect = clust2sect(clust); 
06B86:  MOVLW  08
06B88:  ADDWF  xB3,W
06B8A:  MOVWF  01
06B8C:  MOVLW  00
06B8E:  ADDWFC xB4,W
06B90:  MOVWF  03
06B92:  MOVFF  01,9C1
06B96:  MOVWF  xC2
06B98:  MOVFF  9B8,9CF
06B9C:  MOVFF  9B7,9CE
06BA0:  MOVFF  9B6,9CD
06BA4:  MOVFF  9B5,9CC
06BA8:  MOVLB  0
06BAA:  CALL   5582
06BAE:  MOVFF  9C2,FEA
06BB2:  MOVFF  9C1,FE9
06BB6:  MOVFF  00,FEF
06BBA:  MOVFF  01,FEC
06BBE:  MOVFF  02,FEC
06BC2:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06BC6:  BRA    6C14
06BC8:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06BCA:  MOVLW  08
06BCC:  ADDWF  xB3,W
06BCE:  MOVWF  01
06BD0:  MOVLW  00
06BD2:  ADDWFC xB4,W
06BD4:  MOVWF  03
06BD6:  MOVFF  01,9C1
06BDA:  MOVWF  xC2
06BDC:  MOVLW  14
06BDE:  MOVLB  7
06BE0:  ADDWF  x0E,W
06BE2:  MOVWF  FE9
06BE4:  MOVLW  00
06BE6:  ADDWFC x0F,W
06BE8:  MOVWF  FEA
06BEA:  MOVFF  FEF,00
06BEE:  MOVFF  FEC,01
06BF2:  MOVFF  FEC,02
06BF6:  MOVFF  FEC,03
06BFA:  MOVFF  9C2,FEA
06BFE:  MOVFF  9C1,FE9
06C02:  MOVFF  00,FEF
06C06:  MOVFF  01,FEC
06C0A:  MOVFF  02,FEC
06C0E:  MOVFF  03,FEC
06C12:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06C14:  MOVLW  0C
06C16:  MOVLB  9
06C18:  ADDWF  xB3,W
06C1A:  MOVWF  FE9
06C1C:  MOVLW  00
06C1E:  ADDWFC xB4,W
06C20:  MOVWF  FEA
06C22:  CLRF   FEC
06C24:  MOVF   FED,F
06C26:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06C28:  MOVLW  08
06C2A:  ADDWF  xB3,W
06C2C:  MOVWF  FE9
06C2E:  MOVLW  00
06C30:  ADDWFC xB4,W
06C32:  MOVWF  FEA
06C34:  MOVFF  FEF,9ED
06C38:  MOVFF  FEC,9EE
06C3C:  MOVFF  FEC,9EF
06C40:  MOVFF  FEC,9F0
06C44:  MOVLB  0
06C46:  CALL   59F8
06C4A:  MOVF   01,F
06C4C:  BNZ   6C56
....................          return (NULL); 
06C4E:  MOVLW  00
06C50:  MOVWF  01
06C52:  MOVWF  02
06C54:  BRA    6E7E
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06C56:  MOVLW  0C
06C58:  MOVLB  9
06C5A:  ADDWF  xB3,W
06C5C:  MOVWF  FE9
06C5E:  MOVLW  00
06C60:  ADDWFC xB4,W
06C62:  MOVWF  FEA
06C64:  MOVFF  FEC,9C2
06C68:  MOVF   FED,F
06C6A:  MOVFF  FEF,9C1
06C6E:  MOVLW  0F
06C70:  ANDWF  xC1,F
06C72:  CLRF   xC2
06C74:  RLCF   xC1,F
06C76:  RLCF   xC2,F
06C78:  RLCF   xC1,F
06C7A:  RLCF   xC2,F
06C7C:  RLCF   xC1,F
06C7E:  RLCF   xC2,F
06C80:  RLCF   xC1,F
06C82:  RLCF   xC2,F
06C84:  RLCF   xC1,F
06C86:  RLCF   xC2,F
06C88:  MOVLW  E0
06C8A:  ANDWF  xC1,F
06C8C:  MOVLW  24
06C8E:  ADDWF  xC1,W
06C90:  MOVWF  01
06C92:  MOVLW  00
06C94:  ADDWFC xC2,W
06C96:  MOVWF  03
06C98:  MOVF   01,W
06C9A:  MOVLB  7
06C9C:  ADDWF  x0E,W
06C9E:  MOVWF  01
06CA0:  MOVF   x0F,W
06CA2:  ADDWFC 03,F
06CA4:  MOVFF  01,9BF
06CA8:  MOVLB  9
06CAA:  MOVFF  03,9C0
....................       c = *dptr; 
06CAE:  MOVFF  9BF,FE9
06CB2:  MOVFF  9C0,FEA
06CB6:  MOVFF  FEF,9BD
....................       if ((c == 0) || (c == 0xE5))  
06CBA:  MOVF   xBD,F
06CBC:  BZ    6CC4
06CBE:  MOVF   xBD,W
06CC0:  SUBLW  E5
06CC2:  BNZ   6CD2
....................          return (dptr);      // Found an empty entry!  
06CC4:  MOVFF  9BF,01
06CC8:  MOVFF  9C0,02
06CCC:  MOVLB  0
06CCE:  BRA    6E7E
06CD0:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06CD2:  MOVFF  9B4,9C3
06CD6:  MOVFF  9B3,9C2
06CDA:  MOVLB  0
06CDC:  CALL   5F68
06CE0:  MOVF   01,F
06CE2:  BTFSC  FD8.2
06CE4:  BRA    6CEA
06CE6:  MOVLB  9
06CE8:  BRA    6C28
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06CEA:  MOVLB  9
06CEC:  MOVF   xB5,F
06CEE:  BNZ   6D08
06CF0:  MOVF   xB6,F
06CF2:  BNZ   6D08
06CF4:  MOVF   xB7,F
06CF6:  BNZ   6D08
06CF8:  MOVF   xB8,F
06CFA:  BNZ   6D08
....................        return (NULL); 
06CFC:  MOVLW  00
06CFE:  MOVWF  01
06D00:  MOVWF  02
06D02:  MOVLB  0
06D04:  BRA    6E7E
06D06:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06D08:  MOVLW  04
06D0A:  ADDWF  xB3,W
06D0C:  MOVWF  FE9
06D0E:  MOVLW  00
06D10:  ADDWFC xB4,W
06D12:  MOVWF  FEA
06D14:  MOVFF  FEF,9C5
06D18:  MOVFF  FEC,9C6
06D1C:  MOVFF  FEC,9C7
06D20:  MOVFF  FEC,9C8
06D24:  MOVLB  0
06D26:  RCALL  68AA
06D28:  MOVFF  03,9B8
06D2C:  MOVFF  02,9B7
06D30:  MOVFF  01,9B6
06D34:  MOVFF  00,9B5
....................    if (!(clust))  
06D38:  MOVLB  9
06D3A:  MOVF   xB5,F
06D3C:  BNZ   6D56
06D3E:  MOVF   xB6,F
06D40:  BNZ   6D56
06D42:  MOVF   xB7,F
06D44:  BNZ   6D56
06D46:  MOVF   xB8,F
06D48:  BNZ   6D56
....................       return (NULL); 
06D4A:  MOVLW  00
06D4C:  MOVWF  01
06D4E:  MOVWF  02
06D50:  MOVLB  0
06D52:  BRA    6E7E
06D54:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06D56:  CLRF   xF0
06D58:  CLRF   xEF
06D5A:  CLRF   xEE
06D5C:  CLRF   xED
06D5E:  MOVLB  0
06D60:  CALL   59F8
06D64:  MOVF   01,F
06D66:  BNZ   6D70
....................       return (0); 
06D68:  MOVLW  00
06D6A:  MOVWF  01
06D6C:  MOVWF  02
06D6E:  BRA    6E7E
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06D70:  MOVLW  20
06D72:  MOVLB  7
06D74:  ADDWF  x0E,W
06D76:  MOVWF  01
06D78:  MOVLW  00
06D7A:  ADDWFC x0F,W
06D7C:  MOVWF  03
06D7E:  MOVFF  01,9C1
06D82:  MOVLB  9
06D84:  MOVWF  xC2
06D86:  MOVFF  9B8,9CF
06D8A:  MOVFF  9B7,9CE
06D8E:  MOVFF  9B6,9CD
06D92:  MOVFF  9B5,9CC
06D96:  MOVLB  0
06D98:  CALL   5582
06D9C:  MOVFF  03,9BC
06DA0:  MOVFF  02,9BB
06DA4:  MOVFF  01,9BA
06DA8:  MOVFF  00,9B9
06DAC:  MOVFF  9C2,FEA
06DB0:  MOVFF  9C1,FE9
06DB4:  MOVFF  9B9,FEF
06DB8:  MOVFF  9BA,FEC
06DBC:  MOVFF  9BB,FEC
06DC0:  MOVFF  9BC,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06DC4:  MOVLW  24
06DC6:  MOVLB  7
06DC8:  ADDWF  x0E,W
06DCA:  MOVWF  01
06DCC:  MOVLW  00
06DCE:  ADDWFC x0F,W
06DD0:  MOVWF  03
06DD2:  MOVFF  01,9C1
06DD6:  MOVLB  9
06DD8:  MOVWF  xC2
06DDA:  MOVWF  FEA
06DDC:  MOVFF  01,FE9
06DE0:  CLRF   00
06DE2:  MOVLW  02
06DE4:  MOVWF  02
06DE6:  CLRF   01
06DE8:  MOVLB  0
06DEA:  CALL   34A4
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06DEE:  MOVLW  02
06DF0:  MOVLB  7
06DF2:  ADDWF  x0E,W
06DF4:  MOVWF  FE9
06DF6:  MOVLW  00
06DF8:  ADDWFC x0F,W
06DFA:  MOVWF  FEA
06DFC:  MOVFF  FEF,9BE
06E00:  MOVLB  9
06E02:  MOVF   xBE,F
06E04:  BZ    6E5E
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06E06:  MOVLW  24
06E08:  MOVLB  7
06E0A:  ADDWF  x0E,W
06E0C:  MOVWF  01
06E0E:  MOVLW  00
06E10:  ADDWFC x0F,W
06E12:  MOVWF  03
06E14:  MOVFF  01,9C1
06E18:  MOVLB  9
06E1A:  MOVWF  xC2
06E1C:  MOVWF  xFA
06E1E:  MOVFF  01,9F9
06E22:  MOVFF  9BC,9FE
06E26:  MOVFF  9BB,9FD
06E2A:  MOVFF  9BA,9FC
06E2E:  MOVFF  9B9,9FB
06E32:  MOVLW  01
06E34:  MOVWF  xFF
06E36:  MOVLB  0
06E38:  CALL   58B2
06E3C:  MOVF   01,F
06E3E:  BZ    6E48
....................          return (NULL); 
06E40:  MOVLW  00
06E42:  MOVWF  01
06E44:  MOVWF  02
06E46:  BRA    6E7E
....................       sector++; 
06E48:  MOVLW  01
06E4A:  MOVLB  9
06E4C:  ADDWF  xB9,F
06E4E:  BTFSC  FD8.0
06E50:  INCF   xBA,F
06E52:  BTFSC  FD8.2
06E54:  INCF   xBB,F
06E56:  BTFSC  FD8.2
06E58:  INCF   xBC,F
06E5A:  DECF   xBE,F
06E5C:  BRA    6E02
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06E5E:  MOVLW  06
06E60:  MOVLB  7
06E62:  ADDWF  x0E,W
06E64:  MOVWF  FE9
06E66:  MOVLW  00
06E68:  ADDWFC x0F,W
06E6A:  MOVWF  FEA
06E6C:  MOVLW  01
06E6E:  MOVWF  FEF
....................    return (fs->win); 
06E70:  MOVLW  24
06E72:  ADDWF  x0E,W
06E74:  MOVWF  01
06E76:  MOVLW  00
06E78:  ADDWFC x0F,W
06E7A:  MOVWF  03
06E7C:  MOVWF  02
06E7E:  MOVLB  0
06E80:  GOTO   7116 (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
05520:  MOVLB  7
05522:  MOVF   x0E,W
05524:  IORWF  x0F,W
05526:  BNZ   552E
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
05528:  MOVLW  0B
0552A:  MOVWF  01
0552C:  BRA    557E
....................  
....................    if (disk_status() & STA_NOINIT)  
0552E:  MOVLB  0
05530:  RCALL  5512
05532:  BTFSS  01.0
05534:  BRA    5560
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
05536:  MOVLW  01
05538:  MOVLB  7
0553A:  ADDWF  x0E,W
0553C:  MOVWF  FE9
0553E:  MOVLW  00
05540:  ADDWFC x0F,W
05542:  MOVWF  FEA
05544:  MOVF   FEF,F
05546:  BZ    5550
....................          return (FR_INCORRECT_DISK_CHANGE); 
05548:  MOVLW  09
0554A:  MOVWF  01
0554C:  BRA    557E
0554E:  BRA    555C
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
05550:  MOVLB  0
05552:  CALL   47CE
05556:  MOVF   01,W
05558:  MOVLB  7
0555A:  BRA    557E
....................       }  
0555C:  BRA    557A
0555E:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
05560:  MOVLB  7
05562:  MOVFF  70E,FE9
05566:  MOVFF  70F,FEA
0556A:  MOVF   FEF,F
0556C:  BNZ   557A
....................          return (f_mountdrv());      // Initialize file system and return resulut  
0556E:  MOVLB  0
05570:  CALL   47CE
05574:  MOVF   01,W
05576:  MOVLB  7
05578:  BRA    557E
....................       } 
....................    return FR_OK;                  // File system is valid  
0557A:  MOVLW  00
0557C:  MOVWF  01
0557E:  MOVLB  0
05580:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B5DE:  MOVLB  8
0B5E0:  MOVF   xA9,W
0B5E2:  XORLW  00
0B5E4:  MOVLB  0
0B5E6:  BZ    B620
0B5E8:  XORLW  04
0B5EA:  BZ    B63C
0B5EC:  XORLW  05
0B5EE:  BZ    B658
0B5F0:  XORLW  03
0B5F2:  BZ    B674
0B5F4:  XORLW  01
0B5F6:  BZ    B690
0B5F8:  XORLW  06
0B5FA:  BZ    B6AC
0B5FC:  XORLW  03
0B5FE:  BZ    B6C8
0B600:  XORLW  01
0B602:  BTFSC  FD8.2
0B604:  BRA    B6E4
0B606:  XORLW  0E
0B608:  BTFSC  FD8.2
0B60A:  BRA    B700
0B60C:  XORLW  03
0B60E:  BTFSC  FD8.2
0B610:  BRA    B71C
0B612:  XORLW  01
0B614:  BTFSC  FD8.2
0B616:  BRA    B738
0B618:  XORLW  07
0B61A:  BTFSC  FD8.2
0B61C:  BRA    B754
0B61E:  BRA    B770
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B620:  MOVFF  8AB,FEA
0B624:  MOVFF  8AA,FE9
0B628:  MOVLW  00
0B62A:  CALL   0106
0B62E:  TBLRD*-
0B630:  TBLRD*+
0B632:  MOVF   FF5,W
0B634:  MOVWF  FEE
0B636:  IORLW  00
0B638:  BNZ   B630
....................          break; 
0B63A:  BRA    B78A
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B63C:  MOVFF  8AB,FEA
0B640:  MOVFF  8AA,FE9
0B644:  MOVLW  00
0B646:  CALL   0124
0B64A:  TBLRD*-
0B64C:  TBLRD*+
0B64E:  MOVF   FF5,W
0B650:  MOVWF  FEE
0B652:  IORLW  00
0B654:  BNZ   B64C
....................          break; 
0B656:  BRA    B78A
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0B658:  MOVFF  8AB,FEA
0B65C:  MOVFF  8AA,FE9
0B660:  MOVLW  00
0B662:  CALL   014A
0B666:  TBLRD*-
0B668:  TBLRD*+
0B66A:  MOVF   FF5,W
0B66C:  MOVWF  FEE
0B66E:  IORLW  00
0B670:  BNZ   B668
....................          break; 
0B672:  BRA    B78A
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0B674:  MOVFF  8AB,FEA
0B678:  MOVFF  8AA,FE9
0B67C:  MOVLW  00
0B67E:  CALL   016E
0B682:  TBLRD*-
0B684:  TBLRD*+
0B686:  MOVF   FF5,W
0B688:  MOVWF  FEE
0B68A:  IORLW  00
0B68C:  BNZ   B684
....................          break; 
0B68E:  BRA    B78A
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0B690:  MOVFF  8AB,FEA
0B694:  MOVFF  8AA,FE9
0B698:  MOVLW  00
0B69A:  CALL   0192
0B69E:  TBLRD*-
0B6A0:  TBLRD*+
0B6A2:  MOVF   FF5,W
0B6A4:  MOVWF  FEE
0B6A6:  IORLW  00
0B6A8:  BNZ   B6A0
....................          break; 
0B6AA:  BRA    B78A
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0B6AC:  MOVFF  8AB,FEA
0B6B0:  MOVFF  8AA,FE9
0B6B4:  MOVLW  00
0B6B6:  CALL   01B6
0B6BA:  TBLRD*-
0B6BC:  TBLRD*+
0B6BE:  MOVF   FF5,W
0B6C0:  MOVWF  FEE
0B6C2:  IORLW  00
0B6C4:  BNZ   B6BC
....................          break; 
0B6C6:  BRA    B78A
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0B6C8:  MOVFF  8AB,FEA
0B6CC:  MOVFF  8AA,FE9
0B6D0:  MOVLW  00
0B6D2:  CALL   01D8
0B6D6:  TBLRD*-
0B6D8:  TBLRD*+
0B6DA:  MOVF   FF5,W
0B6DC:  MOVWF  FEE
0B6DE:  IORLW  00
0B6E0:  BNZ   B6D8
....................          break; 
0B6E2:  BRA    B78A
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0B6E4:  MOVFF  8AB,FEA
0B6E8:  MOVFF  8AA,FE9
0B6EC:  MOVLW  00
0B6EE:  CALL   01F8
0B6F2:  TBLRD*-
0B6F4:  TBLRD*+
0B6F6:  MOVF   FF5,W
0B6F8:  MOVWF  FEE
0B6FA:  IORLW  00
0B6FC:  BNZ   B6F4
....................          break; 
0B6FE:  BRA    B78A
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0B700:  MOVFF  8AB,FEA
0B704:  MOVFF  8AA,FE9
0B708:  MOVLW  00
0B70A:  CALL   0216
0B70E:  TBLRD*-
0B710:  TBLRD*+
0B712:  MOVF   FF5,W
0B714:  MOVWF  FEE
0B716:  IORLW  00
0B718:  BNZ   B710
....................          break; 
0B71A:  BRA    B78A
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0B71C:  MOVFF  8AB,FEA
0B720:  MOVFF  8AA,FE9
0B724:  MOVLW  00
0B726:  CALL   0242
0B72A:  TBLRD*-
0B72C:  TBLRD*+
0B72E:  MOVF   FF5,W
0B730:  MOVWF  FEE
0B732:  IORLW  00
0B734:  BNZ   B72C
....................          break; 
0B736:  BRA    B78A
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0B738:  MOVFF  8AB,FEA
0B73C:  MOVFF  8AA,FE9
0B740:  MOVLW  00
0B742:  CALL   0266
0B746:  TBLRD*-
0B748:  TBLRD*+
0B74A:  MOVF   FF5,W
0B74C:  MOVWF  FEE
0B74E:  IORLW  00
0B750:  BNZ   B748
....................          break; 
0B752:  BRA    B78A
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0B754:  MOVFF  8AB,FEA
0B758:  MOVFF  8AA,FE9
0B75C:  MOVLW  00
0B75E:  CALL   028A
0B762:  TBLRD*-
0B764:  TBLRD*+
0B766:  MOVF   FF5,W
0B768:  MOVWF  FEE
0B76A:  IORLW  00
0B76C:  BNZ   B764
....................          break; 
0B76E:  BRA    B78A
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0B770:  MOVFF  8AB,FEA
0B774:  MOVFF  8AA,FE9
0B778:  MOVLW  00
0B77A:  CALL   02AC
0B77E:  TBLRD*-
0B780:  TBLRD*+
0B782:  MOVF   FF5,W
0B784:  MOVWF  FEE
0B786:  IORLW  00
0B788:  BNZ   B780
....................       } 
0B78A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
047CE:  MOVLB  7
047D0:  MOVF   x0E,W
047D2:  IORWF  x0F,W
047D4:  BNZ   47DC
....................       return (FR_NOT_ENABLED); 
047D6:  MOVLW  0B
047D8:  MOVWF  01
047DA:  BRA    4D68
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
047DC:  MOVFF  70F,FEA
047E0:  MOVFF  70E,FE9
047E4:  CLRF   00
047E6:  MOVLW  02
047E8:  MOVWF  02
047EA:  MOVLW  24
047EC:  MOVWF  01
047EE:  MOVLB  0
047F0:  CALL   34A4
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
047F4:  CALL   35F4
047F8:  MOVFF  01,4E9
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
047FC:  MOVLB  4
047FE:  BTFSS  xE9.0
04800:  BRA    480E
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
04802:  MOVLB  0
04804:  CALL   35F4
04808:  MOVFF  01,4E9
0480C:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
0480E:  BTFSS  xE9.0
04810:  BRA    481C
04812:  MOVLW  01
04814:  MOVWF  01
04816:  MOVLB  7
04818:  BRA    4D68
0481A:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
0481C:  MOVLB  9
0481E:  CLRF   xB7
04820:  CLRF   xB6
04822:  CLRF   xB5
04824:  CLRF   xB4
04826:  MOVFF  9B7,9C3
0482A:  MOVFF  9B6,9C2
0482E:  MOVFF  9B5,9C1
04832:  MOVFF  9B4,9C0
04836:  MOVLB  0
04838:  RCALL  4616
0483A:  MOVFF  01,9B3
....................    if (!fat)  
0483E:  MOVLB  9
04840:  MOVF   xB3,F
04842:  BNZ   48B2
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
04844:  MOVLW  E6
04846:  MOVLB  7
04848:  ADDWF  x0E,W
0484A:  MOVWF  FE9
0484C:  MOVLW  01
0484E:  ADDWFC x0F,W
04850:  MOVWF  FEA
04852:  MOVF   FEF,F
04854:  BZ    4892
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
04856:  MOVLW  EA
04858:  ADDWF  x0E,W
0485A:  MOVWF  01
0485C:  MOVLW  01
0485E:  ADDWFC x0F,W
04860:  MOVFF  01,FE9
04864:  MOVWF  FEA
04866:  MOVFF  FEF,9B4
0486A:  MOVFF  FEC,9B5
0486E:  MOVFF  FEC,9B6
04872:  MOVFF  FEC,9B7
....................          fat = check_fs(sect);            // Check the partition  
04876:  MOVFF  9B7,9C3
0487A:  MOVFF  9B6,9C2
0487E:  MOVFF  9B5,9C1
04882:  MOVFF  9B4,9C0
04886:  MOVLB  0
04888:  RCALL  4616
0488A:  MOVFF  01,9B3
....................          } 
0488E:  BRA    48B0
04890:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
04892:  MOVLW  04
04894:  MOVWF  FF6
04896:  MOVLW  0C
04898:  MOVWF  FF7
0489A:  MOVLW  00
0489C:  MOVWF  FF8
0489E:  CLRF   1B
048A0:  BTFSC  FF2.7
048A2:  BSF    1B.7
048A4:  BCF    FF2.7
048A6:  MOVLB  0
048A8:  CALL   0E30
048AC:  BTFSC  1B.7
048AE:  BSF    FF2.7
048B0:  MOVLB  9
....................       } 
....................    if (!fat)  
048B2:  MOVF   xB3,F
048B4:  BNZ   48C0
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
048B6:  MOVLW  0C
048B8:  MOVWF  01
048BA:  MOVLB  7
048BC:  BRA    4D68
048BE:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
048C0:  MOVLB  7
048C2:  MOVFF  70E,FE9
048C6:  MOVFF  70F,FEA
048CA:  MOVFF  9B3,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
048CE:  MOVLB  9
048D0:  MOVF   xB3,W
048D2:  SUBLW  03
048D4:  BNZ   493A
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
048D6:  MOVLW  08
048D8:  MOVLB  7
048DA:  ADDWF  x0E,W
048DC:  MOVWF  01
048DE:  MOVLW  00
048E0:  ADDWFC x0F,W
048E2:  MOVWF  03
048E4:  MOVFF  01,9C0
048E8:  MOVLB  9
048EA:  MOVWF  xC1
048EC:  MOVLW  48
048EE:  MOVLB  7
048F0:  ADDWF  x0E,W
048F2:  MOVWF  01
048F4:  MOVLW  00
048F6:  ADDWFC x0F,W
048F8:  MOVFF  01,FE9
048FC:  MOVWF  FEA
048FE:  MOVFF  FEF,00
04902:  MOVFF  FEC,01
04906:  MOVFF  FEC,02
0490A:  MOVFF  FEC,03
0490E:  MOVFF  03,9C5
04912:  MOVFF  02,9C4
04916:  MOVFF  01,9C3
0491A:  MOVFF  00,9C2
0491E:  MOVFF  9C1,FEA
04922:  MOVFF  9C0,FE9
04926:  MOVFF  00,FEF
0492A:  MOVFF  01,FEC
0492E:  MOVFF  02,FEC
04932:  MOVFF  03,FEC
04936:  BRA    4992
04938:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
0493A:  MOVLW  08
0493C:  MOVLB  7
0493E:  ADDWF  x0E,W
04940:  MOVWF  01
04942:  MOVLW  00
04944:  ADDWFC x0F,W
04946:  MOVWF  03
04948:  MOVFF  01,9C0
0494C:  MOVLB  9
0494E:  MOVWF  xC1
04950:  MOVLW  3A
04952:  MOVLB  7
04954:  ADDWF  x0E,W
04956:  MOVWF  01
04958:  MOVLW  00
0495A:  ADDWFC x0F,W
0495C:  MOVFF  01,FE9
04960:  MOVWF  FEA
04962:  MOVFF  FEC,03
04966:  MOVF   FED,F
04968:  MOVFF  FEF,9C2
0496C:  MOVLB  9
0496E:  MOVFF  03,9C3
04972:  MOVFF  9C1,FEA
04976:  MOVFF  9C0,FE9
0497A:  MOVF   FEE,F
0497C:  MOVF   FEE,F
0497E:  CLRF   FEC
04980:  MOVF   FED,F
04982:  CLRF   FEF
04984:  MOVF   FED,F
04986:  MOVFF  03,FEF
0498A:  MOVF   FED,F
0498C:  MOVFF  9C2,FEF
04990:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
04992:  MOVLW  02
04994:  ADDWF  x0E,W
04996:  MOVWF  01
04998:  MOVLW  00
0499A:  ADDWFC x0F,W
0499C:  MOVWF  03
0499E:  MOVLW  31
049A0:  MOVLB  7
049A2:  ADDWF  x0E,W
049A4:  MOVWF  FE9
049A6:  MOVLW  00
049A8:  ADDWFC x0F,W
049AA:  MOVWF  FEA
049AC:  MOVFF  FEF,9C2
049B0:  MOVLB  9
049B2:  MOVFF  03,FEA
049B6:  MOVFF  01,FE9
049BA:  MOVFF  9C2,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
049BE:  MOVLW  03
049C0:  MOVLB  7
049C2:  ADDWF  x0E,W
049C4:  MOVWF  01
049C6:  MOVLW  00
049C8:  ADDWFC x0F,W
049CA:  MOVWF  03
049CC:  MOVLW  34
049CE:  MOVLB  7
049D0:  ADDWF  x0E,W
049D2:  MOVWF  FE9
049D4:  MOVLW  00
049D6:  ADDWFC x0F,W
049D8:  MOVWF  FEA
049DA:  MOVFF  FEF,9C2
049DE:  MOVLB  9
049E0:  MOVFF  03,FEA
049E4:  MOVFF  01,FE9
049E8:  MOVFF  9C2,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
049EC:  MOVLW  10
049EE:  MOVLB  7
049F0:  ADDWF  x0E,W
049F2:  MOVWF  01
049F4:  MOVLW  00
049F6:  ADDWFC x0F,W
049F8:  MOVWF  03
049FA:  MOVFF  01,9C0
049FE:  MOVLB  9
04A00:  MOVWF  xC1
04A02:  MOVLW  32
04A04:  MOVLB  7
04A06:  ADDWF  x0E,W
04A08:  MOVWF  01
04A0A:  MOVLW  00
04A0C:  ADDWFC x0F,W
04A0E:  MOVFF  01,FE9
04A12:  MOVWF  FEA
04A14:  MOVFF  FEC,03
04A18:  MOVF   FED,F
04A1A:  MOVF   FEF,W
04A1C:  MOVLB  9
04A1E:  ADDWF  xB4,W
04A20:  MOVWF  00
04A22:  MOVF   03,W
04A24:  ADDWFC xB5,W
04A26:  MOVWF  01
04A28:  MOVLW  00
04A2A:  ADDWFC xB6,W
04A2C:  MOVWF  02
04A2E:  MOVLW  00
04A30:  ADDWFC xB7,W
04A32:  MOVFF  9C1,FEA
04A36:  MOVFF  9C0,FE9
04A3A:  MOVFF  00,FEF
04A3E:  MOVFF  01,FEC
04A42:  MOVFF  02,FEC
04A46:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04A48:  MOVLW  04
04A4A:  MOVLB  7
04A4C:  ADDWF  x0E,W
04A4E:  MOVWF  01
04A50:  MOVLW  00
04A52:  ADDWFC x0F,W
04A54:  MOVWF  03
04A56:  MOVFF  01,9C0
04A5A:  MOVLB  9
04A5C:  MOVWF  xC1
04A5E:  MOVLW  35
04A60:  MOVLB  7
04A62:  ADDWF  x0E,W
04A64:  MOVWF  01
04A66:  MOVLW  00
04A68:  ADDWFC x0F,W
04A6A:  MOVFF  01,FE9
04A6E:  MOVWF  FEA
04A70:  MOVFF  FEC,03
04A74:  MOVF   FED,F
04A76:  MOVFF  FEF,9C2
04A7A:  MOVLB  9
04A7C:  MOVFF  9C1,FEA
04A80:  MOVFF  9C0,FE9
04A84:  MOVFF  03,FEC
04A88:  MOVF   FED,F
04A8A:  MOVFF  9C2,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04A8E:  MOVLW  08
04A90:  MOVLB  7
04A92:  ADDWF  x0E,W
04A94:  MOVWF  FE9
04A96:  MOVLW  00
04A98:  ADDWFC x0F,W
04A9A:  MOVWF  FEA
04A9C:  MOVFF  FEF,9D3
04AA0:  MOVFF  FEC,9D4
04AA4:  MOVFF  FEC,9D5
04AA8:  MOVFF  FEC,9D6
04AAC:  MOVLW  03
04AAE:  ADDWF  x0E,W
04AB0:  MOVWF  FE9
04AB2:  MOVLW  00
04AB4:  ADDWFC x0F,W
04AB6:  MOVWF  FEA
04AB8:  MOVFF  FEF,9D7
04ABC:  MOVLB  9
04ABE:  MOVFF  FEA,9C6
04AC2:  MOVFF  FE9,9C5
04AC6:  CLRF   xDA
04AC8:  CLRF   xD9
04ACA:  CLRF   xD8
04ACC:  MOVLB  0
04ACE:  RCALL  4772
04AD0:  MOVFF  9C6,FEA
04AD4:  MOVFF  9C5,FE9
04AD8:  MOVFF  03,9C3
04ADC:  MOVFF  02,9C2
04AE0:  MOVFF  01,9C1
04AE4:  MOVFF  00,9C0
04AE8:  MOVLW  10
04AEA:  MOVLB  7
04AEC:  ADDWF  x0E,W
04AEE:  MOVWF  FE9
04AF0:  MOVLW  00
04AF2:  ADDWFC x0F,W
04AF4:  MOVWF  FEA
04AF6:  MOVFF  FEF,00
04AFA:  MOVFF  FEC,01
04AFE:  MOVFF  FEC,02
04B02:  MOVFF  FEC,03
04B06:  MOVF   00,W
04B08:  MOVLB  9
04B0A:  ADDWF  xC0,W
04B0C:  MOVWF  xB8
04B0E:  MOVF   01,W
04B10:  ADDWFC xC1,W
04B12:  MOVWF  xB9
04B14:  MOVF   02,W
04B16:  ADDWFC xC2,W
04B18:  MOVWF  xBA
04B1A:  MOVF   03,W
04B1C:  ADDWFC xC3,W
04B1E:  MOVWF  xBB
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04B20:  MOVF   xB3,W
04B22:  SUBLW  03
04B24:  BNZ   4B96
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04B26:  MOVLW  14
04B28:  MOVLB  7
04B2A:  ADDWF  x0E,W
04B2C:  MOVWF  01
04B2E:  MOVLW  00
04B30:  ADDWFC x0F,W
04B32:  MOVWF  03
04B34:  MOVFF  01,9C0
04B38:  MOVLB  9
04B3A:  MOVWF  xC1
04B3C:  MOVLW  50
04B3E:  MOVLB  7
04B40:  ADDWF  x0E,W
04B42:  MOVWF  01
04B44:  MOVLW  00
04B46:  ADDWFC x0F,W
04B48:  MOVFF  01,FE9
04B4C:  MOVWF  FEA
04B4E:  MOVFF  FEF,00
04B52:  MOVFF  FEC,01
04B56:  MOVFF  FEC,02
04B5A:  MOVFF  FEC,03
04B5E:  MOVFF  9C1,FEA
04B62:  MOVFF  9C0,FE9
04B66:  MOVFF  00,FEF
04B6A:  MOVFF  01,FEC
04B6E:  MOVFF  02,FEC
04B72:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04B76:  MOVLW  18
04B78:  ADDWF  x0E,W
04B7A:  MOVWF  FE9
04B7C:  MOVLW  00
04B7E:  ADDWFC x0F,W
04B80:  MOVWF  FEA
04B82:  MOVFF  9B8,FEF
04B86:  MOVFF  9B9,FEC
04B8A:  MOVFF  9BA,FEC
04B8E:  MOVFF  9BB,FEC
....................       }  
04B92:  BRA    4C22
04B94:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04B96:  MOVLW  14
04B98:  MOVLB  7
04B9A:  ADDWF  x0E,W
04B9C:  MOVWF  FE9
04B9E:  MOVLW  00
04BA0:  ADDWFC x0F,W
04BA2:  MOVWF  FEA
04BA4:  MOVFF  9B8,FEF
04BA8:  MOVFF  9B9,FEC
04BAC:  MOVFF  9BA,FEC
04BB0:  MOVFF  9BB,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04BB4:  MOVLW  18
04BB6:  ADDWF  x0E,W
04BB8:  MOVWF  01
04BBA:  MOVLW  00
04BBC:  ADDWFC x0F,W
04BBE:  MOVFF  01,9C0
04BC2:  MOVLB  9
04BC4:  MOVWF  xC1
04BC6:  MOVLW  04
04BC8:  MOVLB  7
04BCA:  ADDWF  x0E,W
04BCC:  MOVWF  FE9
04BCE:  MOVLW  00
04BD0:  ADDWFC x0F,W
04BD2:  MOVWF  FEA
04BD4:  MOVFF  FEC,9C3
04BD8:  MOVF   FED,F
04BDA:  MOVFF  FEF,9C2
04BDE:  MOVLB  9
04BE0:  RRCF   xC3,F
04BE2:  RRCF   xC2,F
04BE4:  RRCF   xC3,F
04BE6:  RRCF   xC2,F
04BE8:  RRCF   xC3,F
04BEA:  RRCF   xC2,F
04BEC:  RRCF   xC3,F
04BEE:  RRCF   xC2,F
04BF0:  MOVLW  0F
04BF2:  ANDWF  xC3,F
04BF4:  MOVF   xC2,W
04BF6:  ADDWF  xB8,W
04BF8:  MOVWF  00
04BFA:  MOVF   xC3,W
04BFC:  ADDWFC xB9,W
04BFE:  MOVWF  01
04C00:  MOVLW  00
04C02:  ADDWFC xBA,W
04C04:  MOVWF  02
04C06:  MOVLW  00
04C08:  ADDWFC xBB,W
04C0A:  MOVFF  9C1,FEA
04C0E:  MOVFF  9C0,FE9
04C12:  MOVFF  00,FEF
04C16:  MOVFF  01,FEC
04C1A:  MOVFF  02,FEC
04C1E:  MOVWF  FEC
04C20:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04C22:  MOVLW  44
04C24:  ADDWF  x0E,W
04C26:  MOVWF  01
04C28:  MOVLW  00
04C2A:  ADDWFC x0F,W
04C2C:  MOVFF  01,FE9
04C30:  MOVWF  FEA
04C32:  MOVFF  FEF,9BC
04C36:  MOVFF  FEC,9BD
04C3A:  MOVFF  FEC,9BE
04C3E:  MOVFF  FEC,9BF
....................    if (!maxsect)  
04C42:  MOVLB  9
04C44:  MOVF   xBC,F
04C46:  BNZ   4C76
04C48:  MOVF   xBD,F
04C4A:  BNZ   4C76
04C4C:  MOVF   xBE,F
04C4E:  BNZ   4C76
04C50:  MOVF   xBF,F
04C52:  BNZ   4C76
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04C54:  MOVLW  37
04C56:  MOVLB  7
04C58:  ADDWF  x0E,W
04C5A:  MOVWF  01
04C5C:  MOVLW  00
04C5E:  ADDWFC x0F,W
04C60:  MOVFF  01,FE9
04C64:  MOVWF  FEA
04C66:  MOVLB  9
04C68:  CLRF   xBF
04C6A:  CLRF   xBE
04C6C:  MOVFF  FEC,9BD
04C70:  MOVF   FED,F
04C72:  MOVFF  FEF,9BC
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04C76:  MOVLW  0C
04C78:  MOVLB  7
04C7A:  ADDWF  x0E,W
04C7C:  MOVWF  01
04C7E:  MOVLW  00
04C80:  ADDWFC x0F,W
04C82:  MOVWF  03
04C84:  MOVFF  01,9C0
04C88:  MOVLB  9
04C8A:  MOVWF  xC1
04C8C:  MOVLW  18
04C8E:  MOVLB  7
04C90:  ADDWF  x0E,W
04C92:  MOVWF  FE9
04C94:  MOVLW  00
04C96:  ADDWFC x0F,W
04C98:  MOVWF  FEA
04C9A:  MOVFF  FEF,00
04C9E:  MOVFF  FEC,01
04CA2:  MOVFF  FEC,02
04CA6:  MOVFF  FEC,03
04CAA:  MOVF   00,W
04CAC:  MOVLB  9
04CAE:  SUBWF  xBC,W
04CB0:  MOVWF  xC2
04CB2:  MOVF   01,W
04CB4:  SUBWFB xBD,W
04CB6:  MOVWF  xC3
04CB8:  MOVF   02,W
04CBA:  SUBWFB xBE,W
04CBC:  MOVWF  xC4
04CBE:  MOVF   03,W
04CC0:  SUBWFB xBF,W
04CC2:  MOVWF  xC5
04CC4:  MOVF   xB4,W
04CC6:  ADDWF  xC2,F
04CC8:  MOVF   xB5,W
04CCA:  ADDWFC xC3,F
04CCC:  MOVF   xB6,W
04CCE:  ADDWFC xC4,F
04CD0:  MOVF   xB7,W
04CD2:  ADDWFC xC5,F
04CD4:  MOVLW  02
04CD6:  MOVLB  7
04CD8:  ADDWF  x0E,W
04CDA:  MOVWF  FE9
04CDC:  MOVLW  00
04CDE:  ADDWFC x0F,W
04CE0:  MOVWF  FEA
04CE2:  MOVFF  FEF,A28
04CE6:  MOVLB  9
04CE8:  MOVFF  FEA,9C8
04CEC:  MOVFF  FE9,9C7
04CF0:  BCF    FD8.1
04CF2:  CLRF   1B
04CF4:  BTFSC  FF2.7
04CF6:  BSF    1B.7
04CF8:  BCF    FF2.7
04CFA:  MOVFF  9C5,A27
04CFE:  MOVFF  9C4,A26
04D02:  MOVFF  9C3,A25
04D06:  MOVFF  9C2,A24
04D0A:  MOVLB  A
04D0C:  CLRF   x2B
04D0E:  CLRF   x2A
04D10:  CLRF   x29
04D12:  MOVLB  0
04D14:  CALL   1038
04D18:  BTFSC  1B.7
04D1A:  BSF    FF2.7
04D1C:  MOVFF  9C8,FEA
04D20:  MOVFF  9C7,FE9
04D24:  MOVFF  03,9C5
04D28:  MOVFF  02,9C4
04D2C:  MOVFF  01,9C3
04D30:  MOVFF  00,9C2
04D34:  MOVLW  02
04D36:  MOVLB  9
04D38:  ADDWF  00,W
04D3A:  MOVWF  00
04D3C:  MOVLW  00
04D3E:  ADDWFC 01,W
04D40:  MOVWF  01
04D42:  MOVLW  00
04D44:  ADDWFC 02,W
04D46:  MOVWF  02
04D48:  MOVLW  00
04D4A:  ADDWFC 03,W
04D4C:  MOVFF  9C1,FEA
04D50:  MOVFF  9C0,FE9
04D54:  MOVFF  00,FEF
04D58:  MOVFF  01,FEC
04D5C:  MOVFF  02,FEC
04D60:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04D62:  MOVLW  00
04D64:  MOVWF  01
04D66:  MOVLB  7
04D68:  MOVLB  0
04D6A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
07094:  CALL   5520
07098:  MOVFF  01,9A0
....................    if (result != FR_OK)  
0709C:  MOVLB  9
0709E:  MOVF   xA0,F
070A0:  BZ    70A8
....................       return (result); 
070A2:  MOVFF  9A0,01
070A6:  BRA    74D8
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
070A8:  MOVF   x91,W
070AA:  ANDLW  0A
070AC:  BZ    70C4
070AE:  MOVLB  0
070B0:  CALL   5512
070B4:  BTFSC  01.2
070B6:  BRA    70BC
070B8:  MOVLB  9
070BA:  BRA    70C4
....................          return (FR_WRITE_PROTECTED); 
070BC:  MOVLW  0A
070BE:  MOVWF  01
070C0:  MOVLB  9
070C2:  BRA    74D8
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
070C4:  MOVLW  09
070C6:  MOVWF  xB4
070C8:  MOVLW  92
070CA:  MOVWF  xB3
070CC:  MOVLW  09
070CE:  MOVWF  xB6
070D0:  MOVLW  A3
070D2:  MOVWF  xB5
070D4:  MOVFF  990,9B8
070D8:  MOVFF  98F,9B7
070DC:  MOVLW  09
070DE:  MOVWF  xBA
070E0:  MOVLW  A1
070E2:  MOVWF  xB9
070E4:  MOVLB  0
070E6:  CALL   6142
070EA:  MOVFF  01,9A0
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
070EE:  MOVLB  9
070F0:  MOVF   x91,W
070F2:  ANDLW  18
070F4:  BTFSC  FD8.2
070F6:  BRA    731A
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
070F8:  MOVF   xA0,F
070FA:  BZ    7182
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
070FC:  BSF    x91.3
....................          if (result != FR_NO_FILE) 
070FE:  MOVF   xA0,W
07100:  SUBLW  02
07102:  BZ    710A
....................             return (result); 
07104:  MOVFF  9A0,01
07108:  BRA    74D8
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
0710A:  MOVLW  09
0710C:  MOVWF  xB4
0710E:  MOVLW  92
07110:  MOVWF  xB3
07112:  MOVLB  0
07114:  BRA    6B40
07116:  MOVFF  02,9A2
0711A:  MOVFF  01,9A1
....................          if (dir_ptr == NULL) 
0711E:  MOVLB  9
07120:  MOVF   xA1,F
07122:  BNZ   712E
07124:  MOVF   xA2,F
07126:  BNZ   712E
....................             return (FR_DENIED); 
07128:  MOVLW  05
0712A:  MOVWF  01
0712C:  BRA    74D8
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
0712E:  MOVFF  9A2,FEA
07132:  MOVFF  9A1,FE9
07136:  MOVLW  09
07138:  MOVWF  FE2
0713A:  MOVLW  A3
0713C:  MOVWF  FE1
0713E:  MOVLW  0B
07140:  MOVWF  01
07142:  MOVFF  FE6,FEE
07146:  DECFSZ 01,F
07148:  BRA    7142
....................          *(dir_ptr+12) = fn[11]; 
0714A:  MOVLW  0C
0714C:  ADDWF  xA1,W
0714E:  MOVWF  01
07150:  MOVLW  00
07152:  ADDWFC xA2,W
07154:  MOVFF  01,FE9
07158:  MOVWF  FEA
0715A:  MOVFF  9AE,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
0715E:  MOVLW  0D
07160:  ADDWF  xA1,W
07162:  MOVWF  xB3
07164:  MOVLW  00
07166:  ADDWFC xA2,W
07168:  MOVWF  xB4
0716A:  MOVWF  FEA
0716C:  MOVFF  9B3,FE9
07170:  CLRF   00
07172:  CLRF   02
07174:  MOVLW  13
07176:  MOVWF  01
07178:  MOVLB  0
0717A:  CALL   34A4
....................       }  
0717E:  BRA    7294
07180:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
07182:  MOVF   xA1,F
07184:  BNZ   718A
07186:  MOVF   xA2,F
07188:  BZ    71A2
0718A:  MOVLW  0B
0718C:  ADDWF  xA1,W
0718E:  MOVWF  01
07190:  MOVLW  00
07192:  ADDWFC xA2,W
07194:  MOVWF  03
07196:  MOVFF  01,FE9
0719A:  MOVWF  FEA
0719C:  MOVF   FEF,W
0719E:  ANDLW  11
071A0:  BZ    71A8
....................             return (FR_DENIED); 
071A2:  MOVLW  05
071A4:  MOVWF  01
071A6:  BRA    74D8
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
071A8:  BTFSS  x91.3
071AA:  BRA    7292
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
071AC:  MOVLW  20
071AE:  MOVLB  7
071B0:  ADDWF  x0E,W
071B2:  MOVWF  FE9
071B4:  MOVLW  00
071B6:  ADDWFC x0F,W
071B8:  MOVWF  FEA
071BA:  MOVFF  FEF,9AF
071BE:  MOVFF  FEC,9B0
071C2:  MOVFF  FEC,9B1
071C6:  MOVFF  FEC,9B2
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
071CA:  MOVLW  14
071CC:  MOVLB  9
071CE:  ADDWF  xA1,W
071D0:  MOVWF  01
071D2:  MOVLW  00
071D4:  ADDWFC xA2,W
071D6:  MOVWF  03
071D8:  MOVFF  01,FE9
071DC:  MOVWF  FEA
071DE:  MOVFF  FEC,9BB
071E2:  MOVF   FED,F
071E4:  MOVFF  FEF,9B3
071E8:  CLRF   xB5
071EA:  MOVFF  9B3,9BA
071EE:  CLRF   xB3
071F0:  CLRF   xB4
071F2:  MOVLW  1A
071F4:  ADDWF  xA1,W
071F6:  MOVWF  01
071F8:  MOVLW  00
071FA:  ADDWFC xA2,W
071FC:  MOVFF  01,FE9
07200:  MOVWF  FEA
07202:  MOVFF  FEC,03
07206:  MOVF   FED,F
07208:  MOVF   FEF,W
0720A:  IORWF  xB3,F
0720C:  MOVF   03,W
0720E:  IORWF  xB4,F
07210:  MOVFF  9B4,9B9
07214:  MOVFF  9B3,9B8
07218:  MOVLB  0
0721A:  RCALL  6E84
0721C:  MOVF   01,F
0721E:  BZ    7238
07220:  MOVFF  9B2,9F0
07224:  MOVFF  9B1,9EF
07228:  MOVFF  9B0,9EE
0722C:  MOVFF  9AF,9ED
07230:  CALL   59F8
07234:  MOVF   01,F
07236:  BNZ   7242
....................                return (FR_RW_ERROR); 
07238:  MOVLW  07
0723A:  MOVWF  01
0723C:  MOVLB  9
0723E:  BRA    74D8
07240:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
07242:  MOVLW  14
07244:  MOVLB  9
07246:  ADDWF  xA1,W
07248:  MOVWF  01
0724A:  MOVLW  00
0724C:  ADDWFC xA2,W
0724E:  MOVFF  01,FE9
07252:  MOVWF  FEA
07254:  CLRF   FEC
07256:  MOVF   FED,F
07258:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
0725A:  MOVLW  1A
0725C:  ADDWF  xA1,W
0725E:  MOVWF  01
07260:  MOVLW  00
07262:  ADDWFC xA2,W
07264:  MOVFF  01,FE9
07268:  MOVWF  FEA
0726A:  CLRF   FEC
0726C:  MOVF   FED,F
0726E:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
07270:  MOVLW  1C
07272:  ADDWF  xA1,W
07274:  MOVWF  01
07276:  MOVLW  00
07278:  ADDWFC xA2,W
0727A:  MOVFF  01,FE9
0727E:  MOVWF  FEA
07280:  MOVF   FEE,F
07282:  MOVF   FEE,F
07284:  CLRF   FEC
07286:  MOVF   FED,F
07288:  CLRF   FEF
0728A:  MOVF   FED,F
0728C:  CLRF   FEF
0728E:  MOVF   FED,F
07290:  CLRF   FEF
07292:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
07294:  MOVLB  9
07296:  BTFSS  x91.3
07298:  BRA    7318
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
0729A:  MOVLW  0B
0729C:  ADDWF  xA1,W
0729E:  MOVWF  01
072A0:  MOVLW  00
072A2:  ADDWFC xA2,W
072A4:  MOVFF  01,FE9
072A8:  MOVWF  FEA
072AA:  MOVLW  20
072AC:  MOVWF  FEF
....................          dw = get_fattime(); 
072AE:  MOVLB  0
072B0:  RCALL  6F24
072B2:  MOVFF  03,9B2
072B6:  MOVFF  02,9B1
072BA:  MOVFF  01,9B0
072BE:  MOVFF  00,9AF
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
072C2:  MOVLW  0E
072C4:  MOVLB  9
072C6:  ADDWF  xA1,W
072C8:  MOVWF  01
072CA:  MOVLW  00
072CC:  ADDWFC xA2,W
072CE:  MOVFF  01,FE9
072D2:  MOVWF  FEA
072D4:  MOVFF  9AF,FEF
072D8:  MOVFF  9B0,FEC
072DC:  MOVFF  9B1,FEC
072E0:  MOVFF  9B2,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
072E4:  MOVLW  16
072E6:  ADDWF  xA1,W
072E8:  MOVWF  01
072EA:  MOVLW  00
072EC:  ADDWFC xA2,W
072EE:  MOVFF  01,FE9
072F2:  MOVWF  FEA
072F4:  MOVFF  9AF,FEF
072F8:  MOVFF  9B0,FEC
072FC:  MOVFF  9B1,FEC
07300:  MOVFF  9B2,FEC
....................          fs->winflag = 1; 
07304:  MOVLW  06
07306:  MOVLB  7
07308:  ADDWF  x0E,W
0730A:  MOVWF  FE9
0730C:  MOVLW  00
0730E:  ADDWFC x0F,W
07310:  MOVWF  FEA
07312:  MOVLW  01
07314:  MOVWF  FEF
07316:  MOVLB  9
....................       } 
....................    } 
07318:  BRA    7368
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
0731A:  MOVF   xA0,F
0731C:  BZ    7324
....................          return (result);      // Trace failed  
0731E:  MOVFF  9A0,01
07322:  BRA    74D8
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
07324:  MOVF   xA1,F
07326:  BNZ   732C
07328:  MOVF   xA2,F
0732A:  BZ    7342
0732C:  MOVLW  0B
0732E:  ADDWF  xA1,W
07330:  MOVWF  01
07332:  MOVLW  00
07334:  ADDWFC xA2,W
07336:  MOVWF  03
07338:  MOVFF  01,FE9
0733C:  MOVWF  FEA
0733E:  BTFSS  FEF.4
07340:  BRA    7348
....................          return (FR_NO_FILE); 
07342:  MOVLW  02
07344:  MOVWF  01
07346:  BRA    74D8
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
07348:  BTFSS  x91.1
0734A:  BRA    7368
0734C:  MOVLW  0B
0734E:  ADDWF  xA1,W
07350:  MOVWF  01
07352:  MOVLW  00
07354:  ADDWFC xA2,W
07356:  MOVWF  03
07358:  MOVFF  01,FE9
0735C:  MOVWF  FEA
0735E:  BTFSS  FEF.0
07360:  BRA    7368
....................          return (FR_DENIED); 
07362:  MOVLW  05
07364:  MOVWF  01
07366:  BRA    74D8
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
07368:  MOVLW  1A
0736A:  ADDWF  x8D,W
0736C:  MOVWF  FE9
0736E:  MOVLW  00
07370:  ADDWFC x8E,W
07372:  MOVWF  FEA
07374:  MOVF   x91,W
07376:  ANDLW  03
07378:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
0737A:  MOVLW  14
0737C:  ADDWF  x8D,W
0737E:  MOVWF  01
07380:  MOVLW  00
07382:  ADDWFC x8E,W
07384:  MOVWF  03
07386:  MOVFF  01,9B3
0738A:  MOVWF  xB4
0738C:  MOVLW  20
0738E:  MOVLB  7
07390:  ADDWF  x0E,W
07392:  MOVWF  FE9
07394:  MOVLW  00
07396:  ADDWFC x0F,W
07398:  MOVWF  FEA
0739A:  MOVFF  FEF,00
0739E:  MOVFF  FEC,01
073A2:  MOVFF  FEC,02
073A6:  MOVFF  FEC,03
073AA:  MOVFF  9B4,FEA
073AE:  MOVFF  9B3,FE9
073B2:  MOVFF  00,FEF
073B6:  MOVFF  01,FEC
073BA:  MOVFF  02,FEC
073BE:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
073C2:  MOVLW  18
073C4:  MOVLB  9
073C6:  ADDWF  x8D,W
073C8:  MOVWF  FE9
073CA:  MOVLW  00
073CC:  ADDWFC x8E,W
073CE:  MOVWF  FEA
073D0:  MOVFF  9A2,FEC
073D4:  MOVF   FED,F
073D6:  MOVFF  9A1,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
073DA:  MOVLW  08
073DC:  ADDWF  x8D,W
073DE:  MOVWF  01
073E0:  MOVLW  00
073E2:  ADDWFC x8E,W
073E4:  MOVWF  03
073E6:  MOVFF  01,9B3
073EA:  MOVWF  xB4
073EC:  MOVLW  14
073EE:  ADDWF  xA1,W
073F0:  MOVWF  01
073F2:  MOVLW  00
073F4:  ADDWFC xA2,W
073F6:  MOVWF  03
073F8:  MOVFF  01,FE9
073FC:  MOVWF  FEA
073FE:  MOVFF  FEC,9B8
07402:  MOVF   FED,F
07404:  MOVFF  FEF,9B5
07408:  CLRF   xB7
0740A:  MOVFF  9B5,9B7
0740E:  CLRF   xB5
07410:  CLRF   xB6
07412:  MOVLW  1A
07414:  ADDWF  xA1,W
07416:  MOVWF  01
07418:  MOVLW  00
0741A:  ADDWFC xA2,W
0741C:  MOVFF  01,FE9
07420:  MOVWF  FEA
07422:  MOVFF  FEC,03
07426:  MOVF   FED,F
07428:  MOVF   FEF,W
0742A:  IORWF  xB5,W
0742C:  MOVWF  00
0742E:  MOVF   03,W
07430:  IORWF  xB6,W
07432:  MOVFF  9B7,02
07436:  MOVFF  9B8,03
0743A:  MOVFF  9B4,FEA
0743E:  MOVFF  9B3,FE9
07442:  MOVFF  00,FEF
07446:  MOVWF  FEC
07448:  MOVFF  9B7,FEC
0744C:  MOVFF  9B8,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
07450:  MOVLW  04
07452:  ADDWF  x8D,W
07454:  MOVWF  01
07456:  MOVLW  00
07458:  ADDWFC x8E,W
0745A:  MOVWF  03
0745C:  MOVFF  01,9B3
07460:  MOVWF  xB4
07462:  MOVLW  1C
07464:  ADDWF  xA1,W
07466:  MOVWF  01
07468:  MOVLW  00
0746A:  ADDWFC xA2,W
0746C:  MOVFF  01,FE9
07470:  MOVWF  FEA
07472:  MOVFF  FEF,00
07476:  MOVFF  FEC,01
0747A:  MOVFF  FEC,02
0747E:  MOVFF  FEC,03
07482:  MOVFF  9B4,FEA
07486:  MOVFF  9B3,FE9
0748A:  MOVFF  00,FEF
0748E:  MOVFF  01,FEC
07492:  MOVFF  02,FEC
07496:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
0749A:  MOVFF  98D,FE9
0749E:  MOVFF  98E,FEA
074A2:  MOVF   FEE,F
074A4:  MOVF   FEE,F
074A6:  CLRF   FEC
074A8:  MOVF   FED,F
074AA:  CLRF   FEF
074AC:  MOVF   FED,F
074AE:  CLRF   FEF
074B0:  MOVF   FED,F
074B2:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
074B4:  MOVLW  1B
074B6:  ADDWF  x8D,W
074B8:  MOVWF  FE9
074BA:  MOVLW  00
074BC:  ADDWFC x8E,W
074BE:  MOVWF  FEA
074C0:  MOVLW  01
074C2:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
074C4:  MOVLB  7
074C6:  ADDWF  x0E,W
074C8:  MOVWF  FE9
074CA:  MOVLW  00
074CC:  ADDWFC x0F,W
074CE:  MOVWF  FEA
074D0:  INCF   FEF,F
....................    return (FR_OK); 
074D2:  MOVLW  00
074D4:  MOVWF  01
074D6:  MOVLB  9
074D8:  MOVLB  0
074DA:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B0D0:  MOVFF  8AC,8C1
0B0D4:  MOVFF  8AB,8C0
....................       *br = 0; 
0B0D8:  MOVLB  8
0B0DA:  MOVFF  8AF,FE9
0B0DE:  MOVFF  8B0,FEA
0B0E2:  CLRF   FEC
0B0E4:  MOVF   FED,F
0B0E6:  CLRF   FEF
....................       if (!fs)  
0B0E8:  MOVLB  7
0B0EA:  MOVF   x0E,W
0B0EC:  IORWF  x0F,W
0B0EE:  BNZ   B0F6
....................          return (FR_NOT_ENABLED); 
0B0F0:  MOVLW  0B
0B0F2:  MOVWF  01
0B0F4:  BRA    B5D8
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B0F6:  MOVLB  0
0B0F8:  CALL   5512
0B0FC:  BTFSC  01.0
0B0FE:  BRA    B110
0B100:  MOVLB  7
0B102:  MOVFF  70E,FE9
0B106:  MOVFF  70F,FEA
0B10A:  MOVF   FEF,F
0B10C:  BNZ   B118
0B10E:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B110:  MOVLW  01
0B112:  MOVWF  01
0B114:  MOVLB  7
0B116:  BRA    B5D8
....................     
....................       if (fp->flag & FA__ERROR) 
0B118:  MOVLW  1A
0B11A:  MOVLB  8
0B11C:  ADDWF  xA9,W
0B11E:  MOVWF  FE9
0B120:  MOVLW  00
0B122:  ADDWFC xAA,W
0B124:  MOVWF  FEA
0B126:  BTFSS  FEF.7
0B128:  BRA    B134
....................          return (FR_RW_ERROR);   // Check error flag  
0B12A:  MOVLW  07
0B12C:  MOVWF  01
0B12E:  MOVLB  7
0B130:  BRA    B5D8
0B132:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B134:  MOVLW  1A
0B136:  ADDWF  xA9,W
0B138:  MOVWF  FE9
0B13A:  MOVLW  00
0B13C:  ADDWFC xAA,W
0B13E:  MOVWF  FEA
0B140:  BTFSC  FEF.0
0B142:  BRA    B14E
....................          return (FR_DENIED);      // Check access mode  
0B144:  MOVLW  05
0B146:  MOVWF  01
0B148:  MOVLB  7
0B14A:  BRA    B5D8
0B14C:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B14E:  MOVLW  04
0B150:  ADDWF  xA9,W
0B152:  MOVWF  FE9
0B154:  MOVLW  00
0B156:  ADDWFC xAA,W
0B158:  MOVWF  FEA
0B15A:  MOVFF  FEF,8C2
0B15E:  MOVFF  FEC,8C3
0B162:  MOVFF  FEC,8C4
0B166:  MOVFF  FEC,8C5
0B16A:  MOVFF  8A9,FE9
0B16E:  MOVFF  8AA,FEA
0B172:  MOVFF  FEF,00
0B176:  MOVFF  FEC,01
0B17A:  MOVFF  FEC,02
0B17E:  MOVFF  FEC,03
0B182:  MOVF   00,W
0B184:  SUBWF  xC2,W
0B186:  MOVWF  xB9
0B188:  MOVF   01,W
0B18A:  SUBWFB xC3,W
0B18C:  MOVWF  xBA
0B18E:  MOVF   02,W
0B190:  SUBWFB xC4,W
0B192:  MOVWF  xBB
0B194:  MOVF   03,W
0B196:  SUBWFB xC5,W
0B198:  MOVWF  xBC
....................       if (btr > ln) 
0B19A:  MOVF   xBC,F
0B19C:  BNZ   B1B8
0B19E:  MOVF   xBB,F
0B1A0:  BNZ   B1B8
0B1A2:  MOVF   xBA,W
0B1A4:  SUBWF  xAE,W
0B1A6:  BNC   B1B8
0B1A8:  BNZ   B1B0
0B1AA:  MOVF   xAD,W
0B1AC:  SUBWF  xB9,W
0B1AE:  BC    B1B8
....................          btr = ln;            // Truncate read count by number of bytes left  
0B1B0:  MOVFF  8BA,8AE
0B1B4:  MOVFF  8B9,8AD
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B1B8:  MOVF   xAD,W
0B1BA:  IORWF  xAE,W
0B1BC:  BTFSC  FD8.2
0B1BE:  BRA    B5B6
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B1C0:  MOVFF  8A9,FE9
0B1C4:  MOVFF  8AA,FEA
0B1C8:  MOVFF  FEF,8C2
0B1CC:  MOVFF  FEC,8C3
0B1D0:  MOVFF  FEC,8C4
0B1D4:  MOVFF  FEC,8C5
0B1D8:  MOVLW  01
0B1DA:  ANDWF  xC3,F
0B1DC:  CLRF   xC4
0B1DE:  CLRF   xC5
0B1E0:  MOVF   xC2,F
0B1E2:  BTFSS  FD8.2
0B1E4:  BRA    B45E
0B1E6:  MOVF   xC3,F
0B1E8:  BTFSS  FD8.2
0B1EA:  BRA    B45E
0B1EC:  MOVF   xC4,F
0B1EE:  BTFSS  FD8.2
0B1F0:  BRA    B45E
0B1F2:  MOVF   xC5,F
0B1F4:  BTFSS  FD8.2
0B1F6:  BRA    B45E
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B1F8:  MOVLW  1B
0B1FA:  ADDWF  xA9,W
0B1FC:  MOVWF  FE9
0B1FE:  MOVLW  00
0B200:  ADDWFC xAA,W
0B202:  MOVWF  FEA
0B204:  DECF   FEF,F
0B206:  BZ    B23E
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B208:  MOVLW  10
0B20A:  ADDWF  xA9,W
0B20C:  MOVWF  FE9
0B20E:  MOVLW  00
0B210:  ADDWFC xAA,W
0B212:  MOVWF  FEA
0B214:  MOVFF  FEF,8C2
0B218:  MOVFF  FEC,8C3
0B21C:  MOVFF  FEC,8C4
0B220:  MOVFF  FEC,8C5
0B224:  MOVLW  01
0B226:  ADDWF  xC2,W
0B228:  MOVWF  xB5
0B22A:  MOVLW  00
0B22C:  ADDWFC xC3,W
0B22E:  MOVWF  xB6
0B230:  MOVLW  00
0B232:  ADDWFC xC4,W
0B234:  MOVWF  xB7
0B236:  MOVLW  00
0B238:  ADDWFC xC5,W
0B23A:  MOVWF  xB8
....................                }  
0B23C:  BRA    B37A
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B23E:  MOVFF  8A9,FE9
0B242:  MOVFF  8AA,FEA
0B246:  MOVFF  FEF,8C2
0B24A:  MOVFF  FEC,8C3
0B24E:  MOVFF  FEC,8C4
0B252:  MOVFF  FEC,8C5
0B256:  MOVF   xC2,F
0B258:  BNZ   B284
0B25A:  MOVF   xC3,F
0B25C:  BNZ   B284
0B25E:  MOVF   xC4,F
0B260:  BNZ   B284
0B262:  MOVF   xC5,F
0B264:  BNZ   B284
0B266:  MOVLW  08
0B268:  ADDWF  xA9,W
0B26A:  MOVWF  FE9
0B26C:  MOVLW  00
0B26E:  ADDWFC xAA,W
0B270:  MOVWF  FEA
0B272:  MOVFF  FEF,00
0B276:  MOVFF  FEC,01
0B27A:  MOVFF  FEC,02
0B27E:  MOVFF  FEC,03
0B282:  BRA    B2A8
0B284:  MOVLW  0C
0B286:  ADDWF  xA9,W
0B288:  MOVWF  FE9
0B28A:  MOVLW  00
0B28C:  ADDWFC xAA,W
0B28E:  MOVWF  FEA
0B290:  MOVFF  FEF,9D9
0B294:  MOVFF  FEC,9DA
0B298:  MOVFF  FEC,9DB
0B29C:  MOVFF  FEC,9DC
0B2A0:  MOVLB  0
0B2A2:  CALL   5C30
0B2A6:  MOVLB  8
0B2A8:  MOVFF  03,8B4
0B2AC:  MOVFF  02,8B3
0B2B0:  MOVFF  01,8B2
0B2B4:  MOVFF  00,8B1
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B2B8:  MOVF   xB4,F
0B2BA:  BNZ   B2CA
0B2BC:  MOVF   xB3,F
0B2BE:  BNZ   B2CA
0B2C0:  MOVF   xB2,F
0B2C2:  BNZ   B2CA
0B2C4:  MOVF   xB1,W
0B2C6:  SUBLW  01
0B2C8:  BC    B308
0B2CA:  MOVLW  0C
0B2CC:  MOVLB  7
0B2CE:  ADDWF  x0E,W
0B2D0:  MOVWF  FE9
0B2D2:  MOVLW  00
0B2D4:  ADDWFC x0F,W
0B2D6:  MOVWF  FEA
0B2D8:  MOVFF  FEF,00
0B2DC:  MOVFF  FEC,01
0B2E0:  MOVFF  FEC,02
0B2E4:  MOVFF  FEC,03
0B2E8:  MOVF   03,W
0B2EA:  MOVLB  8
0B2EC:  SUBWF  xB4,W
0B2EE:  BNC   B30A
0B2F0:  BNZ   B308
0B2F2:  MOVF   02,W
0B2F4:  SUBWF  xB3,W
0B2F6:  BNC   B30A
0B2F8:  BNZ   B308
0B2FA:  MOVF   01,W
0B2FC:  SUBWF  xB2,W
0B2FE:  BNC   B30A
0B300:  BNZ   B308
0B302:  MOVF   00,W
0B304:  SUBWF  xB1,W
0B306:  BNC   B30A
....................                   goto fr_error; 
0B308:  BRA    B5C0
....................                fp->curr_clust = clust;            // Current cluster  
0B30A:  MOVLW  0C
0B30C:  ADDWF  xA9,W
0B30E:  MOVWF  FE9
0B310:  MOVLW  00
0B312:  ADDWFC xAA,W
0B314:  MOVWF  FEA
0B316:  MOVFF  8B1,FEF
0B31A:  MOVFF  8B2,FEC
0B31E:  MOVFF  8B3,FEC
0B322:  MOVFF  8B4,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B326:  MOVFF  8B4,9CF
0B32A:  MOVFF  8B3,9CE
0B32E:  MOVFF  8B2,9CD
0B332:  MOVFF  8B1,9CC
0B336:  MOVLB  0
0B338:  CALL   5582
0B33C:  MOVFF  03,8B8
0B340:  MOVFF  02,8B7
0B344:  MOVFF  01,8B6
0B348:  MOVFF  00,8B5
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B34C:  MOVLW  1B
0B34E:  MOVLB  8
0B350:  ADDWF  xA9,W
0B352:  MOVWF  01
0B354:  MOVLW  00
0B356:  ADDWFC xAA,W
0B358:  MOVWF  03
0B35A:  MOVLW  02
0B35C:  MOVLB  7
0B35E:  ADDWF  x0E,W
0B360:  MOVWF  FE9
0B362:  MOVLW  00
0B364:  ADDWFC x0F,W
0B366:  MOVWF  FEA
0B368:  MOVFF  FEF,8C4
0B36C:  MOVLB  8
0B36E:  MOVFF  03,FEA
0B372:  MOVFF  01,FE9
0B376:  MOVFF  8C4,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B37A:  MOVLW  10
0B37C:  ADDWF  xA9,W
0B37E:  MOVWF  FE9
0B380:  MOVLW  00
0B382:  ADDWFC xAA,W
0B384:  MOVWF  FEA
0B386:  MOVFF  8B5,FEF
0B38A:  MOVFF  8B6,FEC
0B38E:  MOVFF  8B7,FEC
0B392:  MOVFF  8B8,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B396:  BCF    FD8.0
0B398:  RRCF   xAE,W
0B39A:  MOVWF  xBF
....................             if (cc)  
0B39C:  MOVF   xBF,F
0B39E:  BZ    B45E
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B3A0:  MOVLW  1B
0B3A2:  ADDWF  xA9,W
0B3A4:  MOVWF  FE9
0B3A6:  MOVLW  00
0B3A8:  ADDWFC xAA,W
0B3AA:  MOVWF  FEA
0B3AC:  MOVF   FEF,W
0B3AE:  SUBWF  xBF,W
0B3B0:  BZ    B3C4
0B3B2:  BNC   B3C4
....................                   cc = fp->sect_clust; 
0B3B4:  MOVLW  1B
0B3B6:  ADDWF  xA9,W
0B3B8:  MOVWF  FE9
0B3BA:  MOVLW  00
0B3BC:  ADDWFC xAA,W
0B3BE:  MOVWF  FEA
0B3C0:  MOVFF  FEF,8BF
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B3C4:  MOVFF  8C1,9FA
0B3C8:  MOVFF  8C0,9F9
0B3CC:  MOVFF  8B8,9FE
0B3D0:  MOVFF  8B7,9FD
0B3D4:  MOVFF  8B6,9FC
0B3D8:  MOVFF  8B5,9FB
0B3DC:  MOVFF  8BF,9FF
0B3E0:  MOVLB  0
0B3E2:  CALL   444A
0B3E6:  MOVF   01,F
0B3E8:  BZ    B3F0
....................                   goto fr_error; 
0B3EA:  MOVLB  8
0B3EC:  BRA    B5C0
0B3EE:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B3F0:  MOVLW  1B
0B3F2:  MOVLB  8
0B3F4:  ADDWF  xA9,W
0B3F6:  MOVWF  FE9
0B3F8:  MOVLW  00
0B3FA:  ADDWFC xAA,W
0B3FC:  MOVWF  FEA
0B3FE:  MOVLW  01
0B400:  SUBWF  xBF,W
0B402:  SUBWF  FEF,W
0B404:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B406:  MOVLW  10
0B408:  ADDWF  xA9,W
0B40A:  MOVWF  FE9
0B40C:  MOVLW  00
0B40E:  ADDWFC xAA,W
0B410:  MOVWF  FEA
0B412:  MOVLW  01
0B414:  SUBWF  xBF,W
0B416:  ADDWF  FEF,W
0B418:  MOVWF  00
0B41A:  MOVLW  00
0B41C:  ADDWFC FEC,W
0B41E:  MOVWF  01
0B420:  MOVLW  00
0B422:  ADDWFC FEC,W
0B424:  MOVWF  02
0B426:  MOVLW  00
0B428:  ADDWFC FEC,W
0B42A:  MOVF   FED,F
0B42C:  MOVF   FED,F
0B42E:  MOVF   FED,F
0B430:  MOVFF  00,FEF
0B434:  MOVFF  01,FEC
0B438:  MOVFF  02,FEC
0B43C:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B43E:  MOVLB  9
0B440:  CLRF   xEA
0B442:  MOVFF  8BF,9E9
0B446:  MOVLW  02
0B448:  MOVWF  xEC
0B44A:  CLRF   xEB
0B44C:  MOVLB  0
0B44E:  CALL   5C0E
0B452:  MOVFF  02,8BE
0B456:  MOVFF  01,8BD
....................                continue; 
0B45A:  BRA    B552
0B45C:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B45E:  MOVLW  10
0B460:  ADDWF  xA9,W
0B462:  MOVWF  FE9
0B464:  MOVLW  00
0B466:  ADDWFC xAA,W
0B468:  MOVWF  FEA
0B46A:  MOVFF  FEF,9ED
0B46E:  MOVFF  FEC,9EE
0B472:  MOVFF  FEC,9EF
0B476:  MOVFF  FEC,9F0
0B47A:  MOVLB  0
0B47C:  CALL   59F8
0B480:  MOVF   01,F
0B482:  BNZ   B48A
....................                goto fr_error; 
0B484:  MOVLB  8
0B486:  BRA    B5C0
0B488:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B48A:  MOVLB  8
0B48C:  MOVFF  8A9,FE9
0B490:  MOVFF  8AA,FEA
0B494:  MOVFF  FEF,8C2
0B498:  MOVFF  FEC,8C3
0B49C:  MOVFF  FEC,8C4
0B4A0:  MOVFF  FEC,8C5
0B4A4:  MOVF   xC3,W
0B4A6:  ANDLW  01
0B4A8:  MOVWF  01
0B4AA:  MOVLW  00
0B4AC:  BSF    FD8.0
0B4AE:  SUBFWB xC2,W
0B4B0:  MOVWF  xBD
0B4B2:  MOVLW  02
0B4B4:  SUBFWB 01,W
0B4B6:  MOVWF  xBE
....................          if (rcnt > btr) 
0B4B8:  MOVF   xAE,W
0B4BA:  SUBWF  xBE,W
0B4BC:  BNC   B4CE
0B4BE:  BNZ   B4C6
0B4C0:  MOVF   xBD,W
0B4C2:  SUBWF  xAD,W
0B4C4:  BC    B4CE
....................             rcnt = btr; 
0B4C6:  MOVFF  8AE,8BE
0B4CA:  MOVFF  8AD,8BD
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B4CE:  MOVFF  8A9,FE9
0B4D2:  MOVFF  8AA,FEA
0B4D6:  MOVFF  FEF,8C2
0B4DA:  MOVFF  FEC,8C3
0B4DE:  MOVFF  FEC,8C4
0B4E2:  MOVFF  FEC,8C5
0B4E6:  MOVLW  01
0B4E8:  ANDWF  xC3,F
0B4EA:  CLRF   xC4
0B4EC:  CLRF   xC5
0B4EE:  MOVLW  24
0B4F0:  ADDWF  xC2,W
0B4F2:  MOVWF  00
0B4F4:  MOVLW  00
0B4F6:  ADDWFC xC3,W
0B4F8:  MOVWF  01
0B4FA:  MOVLW  00
0B4FC:  ADDWFC xC4,W
0B4FE:  MOVWF  02
0B500:  MOVLW  00
0B502:  ADDWFC xC5,W
0B504:  MOVWF  03
0B506:  MOVFF  01,03
0B50A:  MOVF   00,W
0B50C:  MOVLB  7
0B50E:  ADDWF  x0E,W
0B510:  MOVWF  01
0B512:  MOVF   x0F,W
0B514:  ADDWFC 03,F
0B516:  MOVFF  01,8C6
0B51A:  MOVLB  8
0B51C:  MOVFF  03,8C7
0B520:  MOVFF  8C1,FEA
0B524:  MOVFF  8C0,FE9
0B528:  MOVFF  03,FE2
0B52C:  MOVFF  01,FE1
0B530:  MOVFF  8BE,02
0B534:  MOVFF  8BD,01
0B538:  MOVF   01,F
0B53A:  BZ    B540
0B53C:  INCF   02,F
0B53E:  BRA    B544
0B540:  MOVF   02,F
0B542:  BZ    B550
0B544:  MOVFF  FE6,FEE
0B548:  DECFSZ 01,F
0B54A:  BRA    B544
0B54C:  DECFSZ 02,F
0B54E:  BRA    B544
0B550:  MOVLB  0
0B552:  MOVLB  8
0B554:  MOVF   xBD,W
0B556:  ADDWF  xC0,F
0B558:  MOVF   xBE,W
0B55A:  ADDWFC xC1,F
0B55C:  MOVFF  8A9,FE9
0B560:  MOVFF  8AA,FEA
0B564:  MOVF   xBD,W
0B566:  ADDWF  FEF,W
0B568:  MOVWF  00
0B56A:  MOVF   xBE,W
0B56C:  ADDWFC FEC,W
0B56E:  MOVWF  01
0B570:  MOVLW  00
0B572:  ADDWFC FEC,W
0B574:  MOVWF  02
0B576:  MOVLW  00
0B578:  ADDWFC FEC,W
0B57A:  MOVWF  03
0B57C:  MOVF   FED,F
0B57E:  MOVF   FED,F
0B580:  MOVF   FED,F
0B582:  MOVFF  00,FEF
0B586:  MOVFF  01,FEC
0B58A:  MOVFF  02,FEC
0B58E:  MOVWF  FEC
0B590:  MOVFF  8AF,FE9
0B594:  MOVFF  8B0,FEA
0B598:  MOVF   xBD,W
0B59A:  ADDWF  FEF,W
0B59C:  MOVWF  01
0B59E:  MOVF   xBE,W
0B5A0:  ADDWFC FEC,W
0B5A2:  MOVWF  03
0B5A4:  MOVF   FED,F
0B5A6:  MOVFF  01,FEF
0B5AA:  MOVWF  FEC
0B5AC:  MOVF   xBD,W
0B5AE:  SUBWF  xAD,F
0B5B0:  MOVF   xBE,W
0B5B2:  SUBWFB xAE,F
0B5B4:  BRA    B1B8
....................          } 
....................       return (FR_OK); 
0B5B6:  MOVLW  00
0B5B8:  MOVWF  01
0B5BA:  MOVLB  7
0B5BC:  BRA    B5D8
0B5BE:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B5C0:  MOVLW  1A
0B5C2:  ADDWF  xA9,W
0B5C4:  MOVWF  FE9
0B5C6:  MOVLW  00
0B5C8:  ADDWFC xAA,W
0B5CA:  MOVWF  FEA
0B5CC:  MOVF   FEF,W
0B5CE:  IORLW  80
0B5D0:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B5D2:  MOVLW  07
0B5D4:  MOVWF  01
0B5D6:  MOVLB  7
0B5D8:  MOVLB  0
0B5DA:  GOTO   B7D6 (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
07936:  MOVFF  990,9A1
0793A:  MOVFF  98F,9A0
....................       *bw = 0; 
0793E:  MOVLB  9
07940:  MOVFF  993,FE9
07944:  MOVFF  994,FEA
07948:  CLRF   FEC
0794A:  MOVF   FED,F
0794C:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
0794E:  CLRF   x9E
07950:  CLRF   x9D
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
07952:  MOVLB  7
07954:  MOVF   x0E,W
07956:  IORWF  x0F,W
07958:  BNZ   7960
....................          return (FR_NOT_ENABLED); 
0795A:  MOVLW  0B
0795C:  MOVWF  01
0795E:  BRA    7FFC
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
07960:  MOVLB  0
07962:  CALL   5512
07966:  BTFSC  01.0
07968:  BRA    797A
0796A:  MOVLB  7
0796C:  MOVFF  70E,FE9
07970:  MOVFF  70F,FEA
07974:  MOVF   FEF,F
07976:  BNZ   7982
07978:  MOVLB  0
....................          return (FR_NOT_READY); 
0797A:  MOVLW  01
0797C:  MOVWF  01
0797E:  MOVLB  7
07980:  BRA    7FFC
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
07982:  MOVLW  1A
07984:  MOVLB  9
07986:  ADDWF  x8D,W
07988:  MOVWF  FE9
0798A:  MOVLW  00
0798C:  ADDWFC x8E,W
0798E:  MOVWF  FEA
07990:  BTFSS  FEF.7
07992:  BRA    799E
....................          return (FR_RW_ERROR);         // Check error flag  
07994:  MOVLW  07
07996:  MOVWF  01
07998:  MOVLB  7
0799A:  BRA    7FFC
0799C:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
0799E:  MOVLW  1A
079A0:  ADDWF  x8D,W
079A2:  MOVWF  FE9
079A4:  MOVLW  00
079A6:  ADDWFC x8E,W
079A8:  MOVWF  FEA
079AA:  BTFSC  FEF.1
079AC:  BRA    79B8
....................          return (FR_DENIED);            // Check access mode  
079AE:  MOVLW  05
079B0:  MOVWF  01
079B2:  MOVLB  7
079B4:  BRA    7FFC
079B6:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
079B8:  MOVLW  04
079BA:  ADDWF  x8D,W
079BC:  MOVWF  FE9
079BE:  MOVLW  00
079C0:  ADDWFC x8E,W
079C2:  MOVWF  FEA
079C4:  MOVFF  FEF,9A2
079C8:  MOVFF  FEC,9A3
079CC:  MOVFF  FEC,9A4
079D0:  MOVFF  FEC,9A5
079D4:  MOVF   x91,W
079D6:  ADDWF  xA2,F
079D8:  MOVF   x92,W
079DA:  ADDWFC xA3,F
079DC:  MOVLW  00
079DE:  ADDWFC xA4,F
079E0:  ADDWFC xA5,F
079E2:  MOVLW  04
079E4:  ADDWF  x8D,W
079E6:  MOVWF  FE9
079E8:  MOVLW  00
079EA:  ADDWFC x8E,W
079EC:  MOVWF  FEA
079EE:  MOVFF  FEF,00
079F2:  MOVFF  FEC,01
079F6:  MOVFF  FEC,02
079FA:  MOVFF  FEC,03
079FE:  MOVF   xA5,W
07A00:  SUBWF  03,W
07A02:  BNC   7A20
07A04:  BNZ   7A1C
07A06:  MOVF   xA4,W
07A08:  SUBWF  02,W
07A0A:  BNC   7A20
07A0C:  BNZ   7A1C
07A0E:  MOVF   xA3,W
07A10:  SUBWF  01,W
07A12:  BNC   7A20
07A14:  BNZ   7A1C
07A16:  MOVF   00,W
07A18:  SUBWF  xA2,W
07A1A:  BC    7A20
....................          btw = 0;                  // File size cannot reach 4GB  
07A1C:  CLRF   x92
07A1E:  CLRF   x91
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07A20:  MOVF   x91,W
07A22:  IORWF  x92,W
07A24:  BTFSC  FD8.2
07A26:  BRA    7F30
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07A28:  MOVFF  98D,FE9
07A2C:  MOVFF  98E,FEA
07A30:  MOVFF  FEF,9A2
07A34:  MOVFF  FEC,9A3
07A38:  MOVFF  FEC,9A4
07A3C:  MOVFF  FEC,9A5
07A40:  MOVLW  01
07A42:  ANDWF  xA3,F
07A44:  CLRF   xA4
07A46:  CLRF   xA5
07A48:  MOVF   xA2,F
07A4A:  BTFSS  FD8.2
07A4C:  BRA    7DCA
07A4E:  MOVF   xA3,F
07A50:  BTFSS  FD8.2
07A52:  BRA    7DCA
07A54:  MOVF   xA4,F
07A56:  BTFSS  FD8.2
07A58:  BRA    7DCA
07A5A:  MOVF   xA5,F
07A5C:  BTFSS  FD8.2
07A5E:  BRA    7DCA
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07A60:  MOVLW  1B
07A62:  ADDWF  x8D,W
07A64:  MOVWF  FE9
07A66:  MOVLW  00
07A68:  ADDWFC x8E,W
07A6A:  MOVWF  FEA
07A6C:  DECF   FEF,F
07A6E:  BZ    7AA6
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07A70:  MOVLW  10
07A72:  ADDWF  x8D,W
07A74:  MOVWF  FE9
07A76:  MOVLW  00
07A78:  ADDWFC x8E,W
07A7A:  MOVWF  FEA
07A7C:  MOVFF  FEF,9A2
07A80:  MOVFF  FEC,9A3
07A84:  MOVFF  FEC,9A4
07A88:  MOVFF  FEC,9A5
07A8C:  MOVLW  01
07A8E:  ADDWF  xA2,W
07A90:  MOVWF  x99
07A92:  MOVLW  00
07A94:  ADDWFC xA3,W
07A96:  MOVWF  x9A
07A98:  MOVLW  00
07A9A:  ADDWFC xA4,W
07A9C:  MOVWF  x9B
07A9E:  MOVLW  00
07AA0:  ADDWFC xA5,W
07AA2:  MOVWF  x9C
....................                }  
07AA4:  BRA    7C3C
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07AA6:  MOVFF  98D,FE9
07AAA:  MOVFF  98E,FEA
07AAE:  MOVFF  FEF,9A2
07AB2:  MOVFF  FEC,9A3
07AB6:  MOVFF  FEC,9A4
07ABA:  MOVFF  FEC,9A5
07ABE:  MOVF   xA2,F
07AC0:  BNZ   7B46
07AC2:  MOVF   xA3,F
07AC4:  BNZ   7B46
07AC6:  MOVF   xA4,F
07AC8:  BNZ   7B46
07ACA:  MOVF   xA5,F
07ACC:  BNZ   7B46
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07ACE:  MOVLW  08
07AD0:  ADDWF  x8D,W
07AD2:  MOVWF  FE9
07AD4:  MOVLW  00
07AD6:  ADDWFC x8E,W
07AD8:  MOVWF  FEA
07ADA:  MOVFF  FEF,995
07ADE:  MOVFF  FEC,996
07AE2:  MOVFF  FEC,997
07AE6:  MOVFF  FEC,998
....................                   if (clust == 0)            // No cluster is created  
07AEA:  MOVF   x95,F
07AEC:  BNZ   7B44
07AEE:  MOVF   x96,F
07AF0:  BNZ   7B44
07AF2:  MOVF   x97,F
07AF4:  BNZ   7B44
07AF6:  MOVF   x98,F
07AF8:  BNZ   7B44
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07AFA:  MOVLW  08
07AFC:  ADDWF  x8D,W
07AFE:  MOVWF  01
07B00:  MOVLW  00
07B02:  ADDWFC x8E,W
07B04:  MOVWF  03
07B06:  MOVFF  01,9A2
07B0A:  MOVWF  xA3
07B0C:  CLRF   xC8
07B0E:  CLRF   xC7
07B10:  CLRF   xC6
07B12:  CLRF   xC5
07B14:  MOVLB  0
07B16:  CALL   68AA
07B1A:  MOVFF  03,998
07B1E:  MOVFF  02,997
07B22:  MOVFF  01,996
07B26:  MOVFF  00,995
07B2A:  MOVFF  9A3,FEA
07B2E:  MOVFF  9A2,FE9
07B32:  MOVFF  995,FEF
07B36:  MOVFF  996,FEC
07B3A:  MOVFF  997,FEC
07B3E:  MOVFF  998,FEC
07B42:  MOVLB  9
....................                   } 
07B44:  BRA    7B7A
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07B46:  MOVLW  0C
07B48:  ADDWF  x8D,W
07B4A:  MOVWF  FE9
07B4C:  MOVLW  00
07B4E:  ADDWFC x8E,W
07B50:  MOVWF  FEA
07B52:  MOVFF  FEF,9C5
07B56:  MOVFF  FEC,9C6
07B5A:  MOVFF  FEC,9C7
07B5E:  MOVFF  FEC,9C8
07B62:  MOVLB  0
07B64:  CALL   68AA
07B68:  MOVFF  03,998
07B6C:  MOVFF  02,997
07B70:  MOVFF  01,996
07B74:  MOVFF  00,995
07B78:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07B7A:  MOVF   x98,F
07B7C:  BNZ   7B8C
07B7E:  MOVF   x97,F
07B80:  BNZ   7B8C
07B82:  MOVF   x96,F
07B84:  BNZ   7B8C
07B86:  MOVF   x95,W
07B88:  SUBLW  01
07B8A:  BC    7BCA
07B8C:  MOVLW  0C
07B8E:  MOVLB  7
07B90:  ADDWF  x0E,W
07B92:  MOVWF  FE9
07B94:  MOVLW  00
07B96:  ADDWFC x0F,W
07B98:  MOVWF  FEA
07B9A:  MOVFF  FEF,00
07B9E:  MOVFF  FEC,01
07BA2:  MOVFF  FEC,02
07BA6:  MOVFF  FEC,03
07BAA:  MOVF   03,W
07BAC:  MOVLB  9
07BAE:  SUBWF  x98,W
07BB0:  BNC   7BCC
07BB2:  BNZ   7BCA
07BB4:  MOVF   02,W
07BB6:  SUBWF  x97,W
07BB8:  BNC   7BCC
07BBA:  BNZ   7BCA
07BBC:  MOVF   01,W
07BBE:  SUBWF  x96,W
07BC0:  BNC   7BCC
07BC2:  BNZ   7BCA
07BC4:  MOVF   00,W
07BC6:  SUBWF  x95,W
07BC8:  BNC   7BCC
....................                   break; 
07BCA:  BRA    7F30
....................                fp->curr_clust = clust;            // Current cluster  
07BCC:  MOVLW  0C
07BCE:  ADDWF  x8D,W
07BD0:  MOVWF  FE9
07BD2:  MOVLW  00
07BD4:  ADDWFC x8E,W
07BD6:  MOVWF  FEA
07BD8:  MOVFF  995,FEF
07BDC:  MOVFF  996,FEC
07BE0:  MOVFF  997,FEC
07BE4:  MOVFF  998,FEC
....................                sect = clust2sect(clust);         // Current sector  
07BE8:  MOVFF  998,9CF
07BEC:  MOVFF  997,9CE
07BF0:  MOVFF  996,9CD
07BF4:  MOVFF  995,9CC
07BF8:  MOVLB  0
07BFA:  CALL   5582
07BFE:  MOVFF  03,99C
07C02:  MOVFF  02,99B
07C06:  MOVFF  01,99A
07C0A:  MOVFF  00,999
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07C0E:  MOVLW  1B
07C10:  MOVLB  9
07C12:  ADDWF  x8D,W
07C14:  MOVWF  01
07C16:  MOVLW  00
07C18:  ADDWFC x8E,W
07C1A:  MOVWF  03
07C1C:  MOVLW  02
07C1E:  MOVLB  7
07C20:  ADDWF  x0E,W
07C22:  MOVWF  FE9
07C24:  MOVLW  00
07C26:  ADDWFC x0F,W
07C28:  MOVWF  FEA
07C2A:  MOVFF  FEF,9A4
07C2E:  MOVLB  9
07C30:  MOVFF  03,FEA
07C34:  MOVFF  01,FE9
07C38:  MOVFF  9A4,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07C3C:  MOVLW  10
07C3E:  ADDWF  x8D,W
07C40:  MOVWF  FE9
07C42:  MOVLW  00
07C44:  ADDWFC x8E,W
07C46:  MOVWF  FEA
07C48:  MOVFF  999,FEF
07C4C:  MOVFF  99A,FEC
07C50:  MOVFF  99B,FEC
07C54:  MOVFF  99C,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07C58:  BCF    FD8.0
07C5A:  RRCF   x92,W
07C5C:  MOVWF  x9F
....................             if (cc)  
07C5E:  MOVF   x9F,F
07C60:  BZ    7D1A
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07C62:  MOVLW  1B
07C64:  ADDWF  x8D,W
07C66:  MOVWF  FE9
07C68:  MOVLW  00
07C6A:  ADDWFC x8E,W
07C6C:  MOVWF  FEA
07C6E:  MOVF   FEF,W
07C70:  SUBWF  x9F,W
07C72:  BZ    7C86
07C74:  BNC   7C86
....................                   cc = fp->sect_clust; 
07C76:  MOVLW  1B
07C78:  ADDWF  x8D,W
07C7A:  MOVWF  FE9
07C7C:  MOVLW  00
07C7E:  ADDWFC x8E,W
07C80:  MOVWF  FEA
07C82:  MOVFF  FEF,99F
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07C86:  MOVFF  9A1,9FA
07C8A:  MOVFF  9A0,9F9
07C8E:  MOVFF  99C,9FE
07C92:  MOVFF  99B,9FD
07C96:  MOVFF  99A,9FC
07C9A:  MOVFF  999,9FB
07C9E:  MOVFF  99F,9FF
07CA2:  MOVLB  0
07CA4:  CALL   58B2
07CA8:  MOVF   01,F
07CAA:  BZ    7CAE
....................                   goto fw_error; 
07CAC:  BRA    7FE2
....................                fp->sect_clust -= cc - 1; 
07CAE:  MOVLW  1B
07CB0:  MOVLB  9
07CB2:  ADDWF  x8D,W
07CB4:  MOVWF  FE9
07CB6:  MOVLW  00
07CB8:  ADDWFC x8E,W
07CBA:  MOVWF  FEA
07CBC:  MOVLW  01
07CBE:  SUBWF  x9F,W
07CC0:  SUBWF  FEF,W
07CC2:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07CC4:  MOVLW  10
07CC6:  ADDWF  x8D,W
07CC8:  MOVWF  FE9
07CCA:  MOVLW  00
07CCC:  ADDWFC x8E,W
07CCE:  MOVWF  FEA
07CD0:  MOVLW  01
07CD2:  SUBWF  x9F,W
07CD4:  ADDWF  FEF,W
07CD6:  MOVWF  00
07CD8:  MOVLW  00
07CDA:  ADDWFC FEC,W
07CDC:  MOVWF  01
07CDE:  MOVLW  00
07CE0:  ADDWFC FEC,W
07CE2:  MOVWF  02
07CE4:  MOVLW  00
07CE6:  ADDWFC FEC,W
07CE8:  MOVF   FED,F
07CEA:  MOVF   FED,F
07CEC:  MOVF   FED,F
07CEE:  MOVFF  00,FEF
07CF2:  MOVFF  01,FEC
07CF6:  MOVFF  02,FEC
07CFA:  MOVWF  FEC
....................                wcnt = cc * 512; 
07CFC:  CLRF   xEA
07CFE:  MOVFF  99F,9E9
07D02:  MOVLW  02
07D04:  MOVWF  xEC
07D06:  CLRF   xEB
07D08:  MOVLB  0
07D0A:  CALL   5C0E
07D0E:  MOVFF  02,99E
07D12:  MOVFF  01,99D
....................                continue; 
07D16:  BRA    7ECC
07D18:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07D1A:  MOVFF  98D,FE9
07D1E:  MOVFF  98E,FEA
07D22:  MOVFF  FEF,9A2
07D26:  MOVFF  FEC,9A3
07D2A:  MOVFF  FEC,9A4
07D2E:  MOVFF  FEC,9A5
07D32:  MOVLW  04
07D34:  ADDWF  x8D,W
07D36:  MOVWF  FE9
07D38:  MOVLW  00
07D3A:  ADDWFC x8E,W
07D3C:  MOVWF  FEA
07D3E:  MOVFF  FEF,00
07D42:  MOVFF  FEC,01
07D46:  MOVFF  FEC,02
07D4A:  MOVFF  FEC,03
07D4E:  MOVF   03,W
07D50:  SUBWF  xA5,W
07D52:  BNC   7DCA
07D54:  BNZ   7D6C
07D56:  MOVF   02,W
07D58:  SUBWF  xA4,W
07D5A:  BNC   7DCA
07D5C:  BNZ   7D6C
07D5E:  MOVF   01,W
07D60:  SUBWF  xA3,W
07D62:  BNC   7DCA
07D64:  BNZ   7D6C
07D66:  MOVF   00,W
07D68:  SUBWF  xA2,W
07D6A:  BNC   7DCA
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07D6C:  CLRF   xF0
07D6E:  CLRF   xEF
07D70:  CLRF   xEE
07D72:  CLRF   xED
07D74:  MOVLB  0
07D76:  CALL   59F8
07D7A:  MOVF   01,F
07D7C:  BNZ   7D80
....................                   goto fw_error; 
07D7E:  BRA    7FE2
....................                fs->winsect = fp->curr_sect; 
07D80:  MOVLW  20
07D82:  MOVLB  7
07D84:  ADDWF  x0E,W
07D86:  MOVWF  01
07D88:  MOVLW  00
07D8A:  ADDWFC x0F,W
07D8C:  MOVWF  03
07D8E:  MOVFF  01,9A2
07D92:  MOVLB  9
07D94:  MOVWF  xA3
07D96:  MOVLW  10
07D98:  ADDWF  x8D,W
07D9A:  MOVWF  FE9
07D9C:  MOVLW  00
07D9E:  ADDWFC x8E,W
07DA0:  MOVWF  FEA
07DA2:  MOVFF  FEF,00
07DA6:  MOVFF  FEC,01
07DAA:  MOVFF  FEC,02
07DAE:  MOVFF  FEC,03
07DB2:  MOVFF  9A3,FEA
07DB6:  MOVFF  9A2,FE9
07DBA:  MOVFF  00,FEF
07DBE:  MOVFF  01,FEC
07DC2:  MOVFF  02,FEC
07DC6:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07DCA:  MOVLW  10
07DCC:  ADDWF  x8D,W
07DCE:  MOVWF  FE9
07DD0:  MOVLW  00
07DD2:  ADDWFC x8E,W
07DD4:  MOVWF  FEA
07DD6:  MOVFF  FEF,9ED
07DDA:  MOVFF  FEC,9EE
07DDE:  MOVFF  FEC,9EF
07DE2:  MOVFF  FEC,9F0
07DE6:  MOVLB  0
07DE8:  CALL   59F8
07DEC:  MOVF   01,F
07DEE:  BNZ   7DF2
....................             goto fw_error;               // Move sector window 
07DF0:  BRA    7FE2
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07DF2:  MOVLB  9
07DF4:  MOVFF  98D,FE9
07DF8:  MOVFF  98E,FEA
07DFC:  MOVFF  FEF,9A2
07E00:  MOVFF  FEC,9A3
07E04:  MOVFF  FEC,9A4
07E08:  MOVFF  FEC,9A5
07E0C:  MOVF   xA3,W
07E0E:  ANDLW  01
07E10:  MOVWF  01
07E12:  MOVLW  00
07E14:  BSF    FD8.0
07E16:  SUBFWB xA2,W
07E18:  MOVWF  x9D
07E1A:  MOVLW  02
07E1C:  SUBFWB 01,W
07E1E:  MOVWF  x9E
....................          if (wcnt > btw) 
07E20:  MOVF   x92,W
07E22:  SUBWF  x9E,W
07E24:  BNC   7E36
07E26:  BNZ   7E2E
07E28:  MOVF   x9D,W
07E2A:  SUBWF  x91,W
07E2C:  BC    7E36
....................             wcnt = btw; 
07E2E:  MOVFF  992,99E
07E32:  MOVFF  991,99D
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07E36:  MOVFF  98D,FE9
07E3A:  MOVFF  98E,FEA
07E3E:  MOVFF  FEF,9A2
07E42:  MOVFF  FEC,9A3
07E46:  MOVFF  FEC,9A4
07E4A:  MOVFF  FEC,9A5
07E4E:  MOVLW  01
07E50:  ANDWF  xA3,F
07E52:  CLRF   xA4
07E54:  CLRF   xA5
07E56:  MOVLW  24
07E58:  ADDWF  xA2,W
07E5A:  MOVWF  00
07E5C:  MOVLW  00
07E5E:  ADDWFC xA3,W
07E60:  MOVWF  01
07E62:  MOVLW  00
07E64:  ADDWFC xA4,W
07E66:  MOVWF  02
07E68:  MOVLW  00
07E6A:  ADDWFC xA5,W
07E6C:  MOVWF  03
07E6E:  MOVFF  01,03
07E72:  MOVF   00,W
07E74:  MOVLB  7
07E76:  ADDWF  x0E,W
07E78:  MOVWF  01
07E7A:  MOVF   x0F,W
07E7C:  ADDWFC 03,F
07E7E:  MOVFF  01,9A6
07E82:  MOVLB  9
07E84:  MOVFF  03,9A7
07E88:  MOVFF  03,FEA
07E8C:  MOVFF  01,FE9
07E90:  MOVFF  9A1,FE2
07E94:  MOVFF  9A0,FE1
07E98:  MOVFF  99E,02
07E9C:  MOVFF  99D,01
07EA0:  MOVF   01,F
07EA2:  BZ    7EA8
07EA4:  INCF   02,F
07EA6:  BRA    7EAC
07EA8:  MOVF   02,F
07EAA:  BZ    7EB8
07EAC:  MOVFF  FE6,FEE
07EB0:  DECFSZ 01,F
07EB2:  BRA    7EAC
07EB4:  DECFSZ 02,F
07EB6:  BRA    7EAC
....................          fs->winflag = 1; 
07EB8:  MOVLW  06
07EBA:  MOVLB  7
07EBC:  ADDWF  x0E,W
07EBE:  MOVWF  FE9
07EC0:  MOVLW  00
07EC2:  ADDWFC x0F,W
07EC4:  MOVWF  FEA
07EC6:  MOVLW  01
07EC8:  MOVWF  FEF
07ECA:  MOVLB  0
07ECC:  MOVLB  9
07ECE:  MOVF   x9D,W
07ED0:  ADDWF  xA0,F
07ED2:  MOVF   x9E,W
07ED4:  ADDWFC xA1,F
07ED6:  MOVFF  98D,FE9
07EDA:  MOVFF  98E,FEA
07EDE:  MOVF   x9D,W
07EE0:  ADDWF  FEF,W
07EE2:  MOVWF  00
07EE4:  MOVF   x9E,W
07EE6:  ADDWFC FEC,W
07EE8:  MOVWF  01
07EEA:  MOVLW  00
07EEC:  ADDWFC FEC,W
07EEE:  MOVWF  02
07EF0:  MOVLW  00
07EF2:  ADDWFC FEC,W
07EF4:  MOVWF  03
07EF6:  MOVF   FED,F
07EF8:  MOVF   FED,F
07EFA:  MOVF   FED,F
07EFC:  MOVFF  00,FEF
07F00:  MOVFF  01,FEC
07F04:  MOVFF  02,FEC
07F08:  MOVWF  FEC
07F0A:  MOVFF  993,FE9
07F0E:  MOVFF  994,FEA
07F12:  MOVF   x9D,W
07F14:  ADDWF  FEF,W
07F16:  MOVWF  01
07F18:  MOVF   x9E,W
07F1A:  ADDWFC FEC,W
07F1C:  MOVWF  03
07F1E:  MOVF   FED,F
07F20:  MOVFF  01,FEF
07F24:  MOVWF  FEC
07F26:  MOVF   x9D,W
07F28:  SUBWF  x91,F
07F2A:  MOVF   x9E,W
07F2C:  SUBWFB x92,F
07F2E:  BRA    7A20
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
07F30:  MOVFF  98D,FE9
07F34:  MOVFF  98E,FEA
07F38:  MOVFF  FEF,9A2
07F3C:  MOVFF  FEC,9A3
07F40:  MOVFF  FEC,9A4
07F44:  MOVFF  FEC,9A5
07F48:  MOVLW  04
07F4A:  ADDWF  x8D,W
07F4C:  MOVWF  FE9
07F4E:  MOVLW  00
07F50:  ADDWFC x8E,W
07F52:  MOVWF  FEA
07F54:  MOVFF  FEF,00
07F58:  MOVFF  FEC,01
07F5C:  MOVFF  FEC,02
07F60:  MOVFF  FEC,03
07F64:  MOVF   03,W
07F66:  SUBWF  xA5,W
07F68:  BNC   7FC6
07F6A:  BNZ   7F82
07F6C:  MOVF   02,W
07F6E:  SUBWF  xA4,W
07F70:  BNC   7FC6
07F72:  BNZ   7F82
07F74:  MOVF   01,W
07F76:  SUBWF  xA3,W
07F78:  BNC   7FC6
07F7A:  BNZ   7F82
07F7C:  MOVF   xA2,W
07F7E:  SUBWF  00,W
07F80:  BC    7FC6
....................          fp->fsize = fp->fptr;      // Update file size if needed  
07F82:  MOVLW  04
07F84:  ADDWF  x8D,W
07F86:  MOVWF  01
07F88:  MOVLW  00
07F8A:  ADDWFC x8E,W
07F8C:  MOVWF  03
07F8E:  MOVFF  01,9A2
07F92:  MOVFF  03,9A3
07F96:  MOVFF  98D,FE9
07F9A:  MOVFF  98E,FEA
07F9E:  MOVFF  FEF,00
07FA2:  MOVFF  FEC,01
07FA6:  MOVFF  FEC,02
07FAA:  MOVFF  FEC,03
07FAE:  MOVFF  9A3,FEA
07FB2:  MOVFF  9A2,FE9
07FB6:  MOVFF  00,FEF
07FBA:  MOVFF  01,FEC
07FBE:  MOVFF  02,FEC
07FC2:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
07FC6:  MOVLW  1A
07FC8:  ADDWF  x8D,W
07FCA:  MOVWF  FE9
07FCC:  MOVLW  00
07FCE:  ADDWFC x8E,W
07FD0:  MOVWF  FEA
07FD2:  MOVF   FEF,W
07FD4:  IORLW  20
07FD6:  MOVWF  FEF
....................       return (FR_OK); 
07FD8:  MOVLW  00
07FDA:  MOVWF  01
07FDC:  MOVLB  7
07FDE:  BRA    7FFC
07FE0:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
07FE2:  MOVLW  1A
07FE4:  MOVLB  9
07FE6:  ADDWF  x8D,W
07FE8:  MOVWF  FE9
07FEA:  MOVLW  00
07FEC:  ADDWFC x8E,W
07FEE:  MOVWF  FEA
07FF0:  MOVF   FEF,W
07FF2:  IORLW  80
07FF4:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
07FF6:  MOVLW  07
07FF8:  MOVWF  01
07FFA:  MOVLB  7
07FFC:  MOVLB  0
07FFE:  GOTO   83A2 (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
074DC:  MOVLB  7
074DE:  MOVF   x0E,W
074E0:  IORWF  x0F,W
074E2:  BNZ   74EA
....................          return (FR_NOT_ENABLED); 
074E4:  MOVLW  0B
074E6:  MOVWF  01
074E8:  BRA    783E
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
074EA:  MOVLB  0
074EC:  CALL   5512
074F0:  BTFSC  01.0
074F2:  BRA    7504
074F4:  MOVLB  7
074F6:  MOVFF  70E,FE9
074FA:  MOVFF  70F,FEA
074FE:  MOVF   FEF,F
07500:  BNZ   750C
07502:  MOVLB  0
....................          return (FR_NOT_READY); 
07504:  MOVLW  01
07506:  MOVWF  01
07508:  MOVLB  7
0750A:  BRA    783E
....................     
....................       if (fp->flag & FA__ERROR) 
0750C:  MOVLW  1A
0750E:  MOVLB  9
07510:  ADDWF  x8D,W
07512:  MOVWF  FE9
07514:  MOVLW  00
07516:  ADDWFC x8E,W
07518:  MOVWF  FEA
0751A:  BTFSS  FEF.7
0751C:  BRA    7528
....................          return (FR_RW_ERROR); 
0751E:  MOVLW  07
07520:  MOVWF  01
07522:  MOVLB  7
07524:  BRA    783E
07526:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
07528:  MOVLW  04
0752A:  ADDWF  x8D,W
0752C:  MOVWF  FE9
0752E:  MOVLW  00
07530:  ADDWFC x8E,W
07532:  MOVWF  FEA
07534:  MOVFF  FEF,00
07538:  MOVFF  FEC,01
0753C:  MOVFF  FEC,02
07540:  MOVFF  FEC,03
07544:  MOVF   03,W
07546:  SUBWF  x92,W
07548:  BNC   757E
0754A:  BNZ   7562
0754C:  MOVF   02,W
0754E:  SUBWF  x91,W
07550:  BNC   757E
07552:  BNZ   7562
07554:  MOVF   01,W
07556:  SUBWF  x90,W
07558:  BNC   757E
0755A:  BNZ   7562
0755C:  MOVF   x8F,W
0755E:  SUBWF  00,W
07560:  BC    757E
....................          ofs = fp->fsize;               // Clip offset by file size  
07562:  MOVLW  04
07564:  ADDWF  x8D,W
07566:  MOVWF  FE9
07568:  MOVLW  00
0756A:  ADDWFC x8E,W
0756C:  MOVWF  FEA
0756E:  MOVFF  FEF,98F
07572:  MOVFF  FEC,990
07576:  MOVFF  FEC,991
0757A:  MOVFF  FEC,992
....................       fp->fptr = ofs;  
0757E:  MOVFF  98D,FE9
07582:  MOVF   x8E,W
07584:  MOVWF  FEA
07586:  MOVFF  98F,FEF
0758A:  MOVFF  990,FEC
0758E:  MOVFF  991,FEC
07592:  MOVFF  992,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
07596:  MOVLW  1B
07598:  ADDWF  x8D,W
0759A:  MOVWF  FE9
0759C:  MOVLW  00
0759E:  ADDWFC x8E,W
075A0:  MOVWF  FEA
075A2:  MOVLW  01
075A4:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
075A6:  MOVF   x8F,F
075A8:  BNZ   75B8
075AA:  MOVF   x90,F
075AC:  BNZ   75B8
075AE:  MOVF   x91,F
075B0:  BNZ   75B8
075B2:  MOVF   x92,F
075B4:  BTFSC  FD8.2
075B6:  BRA    781C
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
075B8:  MOVLW  01
075BA:  SUBWF  x8F,W
075BC:  MOVLW  00
075BE:  SUBWFB x90,W
075C0:  MOVWF  x99
075C2:  MOVLW  00
075C4:  SUBWFB x91,W
075C6:  MOVWF  x9A
075C8:  MOVLW  00
075CA:  SUBWFB x92,W
075CC:  MOVWF  x9B
075CE:  BCF    FD8.0
075D0:  CLRF   x92
075D2:  RRCF   x9B,W
075D4:  MOVWF  x91
075D6:  RRCF   x9A,W
075D8:  MOVWF  x90
075DA:  RRCF   x99,W
075DC:  MOVWF  x8F
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
075DE:  MOVLW  02
075E0:  MOVLB  7
075E2:  ADDWF  x0E,W
075E4:  MOVWF  FE9
075E6:  MOVLW  00
075E8:  ADDWFC x0F,W
075EA:  MOVWF  FEA
075EC:  MOVFF  FEF,997
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
075F0:  MOVLW  1B
075F2:  MOVLB  9
075F4:  ADDWF  x8D,W
075F6:  MOVWF  01
075F8:  MOVLW  00
075FA:  ADDWFC x8E,W
075FC:  MOVWF  03
075FE:  MOVFF  01,998
07602:  MOVWF  x99
07604:  MOVFF  FEA,99B
07608:  MOVFF  FE9,99A
0760C:  BSF    FD8.1
0760E:  MOVLW  09
07610:  MOVWF  FEA
07612:  MOVLW  9C
07614:  MOVWF  FE9
07616:  CLRF   1B
07618:  BTFSC  FF2.7
0761A:  BSF    1B.7
0761C:  BCF    FF2.7
0761E:  MOVFF  992,A27
07622:  MOVFF  991,A26
07626:  MOVFF  990,A25
0762A:  MOVFF  98F,A24
0762E:  MOVLB  A
07630:  CLRF   x2B
07632:  CLRF   x2A
07634:  CLRF   x29
07636:  MOVFF  997,A28
0763A:  MOVLB  0
0763C:  CALL   1038
07640:  BTFSC  1B.7
07642:  BSF    FF2.7
07644:  MOVFF  99C,00
07648:  MOVFF  99D,01
0764C:  MOVFF  99E,02
07650:  MOVFF  99F,03
07654:  MOVFF  99B,FEA
07658:  MOVFF  99A,FE9
0765C:  MOVF   00,W
0765E:  MOVLB  9
07660:  SUBWF  x97,W
07662:  MOVWF  00
07664:  MOVLW  00
07666:  SUBFWB 01,F
07668:  SUBFWB 02,F
0766A:  SUBFWB 03,F
0766C:  MOVFF  999,FEA
07670:  MOVFF  998,FE9
07674:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
07678:  BCF    FD8.1
0767A:  CLRF   1B
0767C:  BTFSC  FF2.7
0767E:  BSF    1B.7
07680:  BCF    FF2.7
07682:  MOVFF  992,A27
07686:  MOVFF  991,A26
0768A:  MOVFF  990,A25
0768E:  MOVFF  98F,A24
07692:  MOVLB  A
07694:  CLRF   x2B
07696:  CLRF   x2A
07698:  CLRF   x29
0769A:  MOVFF  997,A28
0769E:  MOVLB  0
076A0:  CALL   1038
076A4:  BTFSC  1B.7
076A6:  BSF    FF2.7
076A8:  MOVFF  03,992
076AC:  MOVFF  02,991
076B0:  MOVFF  01,990
076B4:  MOVFF  00,98F
....................          clust = fp->org_clust;            // Seek to current cluster  
076B8:  MOVLW  08
076BA:  MOVLB  9
076BC:  ADDWF  x8D,W
076BE:  MOVWF  FE9
076C0:  MOVLW  00
076C2:  ADDWFC x8E,W
076C4:  MOVWF  FEA
076C6:  MOVFF  FEF,993
076CA:  MOVFF  FEC,994
076CE:  MOVFF  FEC,995
076D2:  MOVFF  FEC,996
....................     
....................          while (ofs--) 
076D6:  MOVFF  992,03
076DA:  MOVFF  991,02
076DE:  MOVFF  990,01
076E2:  MOVFF  98F,00
076E6:  MOVLW  FF
076E8:  ADDWF  x8F,F
076EA:  BTFSS  FD8.0
076EC:  ADDWF  x90,F
076EE:  BTFSS  FD8.0
076F0:  ADDWF  x91,F
076F2:  BTFSS  FD8.0
076F4:  ADDWF  x92,F
076F6:  MOVF   00,F
076F8:  BNZ   7706
076FA:  MOVF   01,F
076FC:  BNZ   7706
076FE:  MOVF   02,F
07700:  BNZ   7706
07702:  MOVF   03,F
07704:  BZ    7730
....................             clust = get_cluster(clust); 
07706:  MOVFF  996,9DC
0770A:  MOVFF  995,9DB
0770E:  MOVFF  994,9DA
07712:  MOVFF  993,9D9
07716:  MOVLB  0
07718:  CALL   5C30
0771C:  MOVFF  03,996
07720:  MOVFF  02,995
07724:  MOVFF  01,994
07728:  MOVFF  00,993
0772C:  MOVLB  9
0772E:  BRA    76D6
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
07730:  MOVF   x96,F
07732:  BNZ   7742
07734:  MOVF   x95,F
07736:  BNZ   7742
07738:  MOVF   x94,F
0773A:  BNZ   7742
0773C:  MOVF   x93,W
0773E:  SUBLW  01
07740:  BC    7780
07742:  MOVLW  0C
07744:  MOVLB  7
07746:  ADDWF  x0E,W
07748:  MOVWF  FE9
0774A:  MOVLW  00
0774C:  ADDWFC x0F,W
0774E:  MOVWF  FEA
07750:  MOVFF  FEF,00
07754:  MOVFF  FEC,01
07758:  MOVFF  FEC,02
0775C:  MOVFF  FEC,03
07760:  MOVF   03,W
07762:  MOVLB  9
07764:  SUBWF  x96,W
07766:  BNC   7782
07768:  BNZ   7780
0776A:  MOVF   02,W
0776C:  SUBWF  x95,W
0776E:  BNC   7782
07770:  BNZ   7780
07772:  MOVF   01,W
07774:  SUBWF  x94,W
07776:  BNC   7782
07778:  BNZ   7780
0777A:  MOVF   00,W
0777C:  SUBWF  x93,W
0777E:  BNC   7782
....................             goto fk_error; 
07780:  BRA    7826
....................     
....................          fp->curr_clust = clust; 
07782:  MOVLW  0C
07784:  ADDWF  x8D,W
07786:  MOVWF  FE9
07788:  MOVLW  00
0778A:  ADDWFC x8E,W
0778C:  MOVWF  FEA
0778E:  MOVFF  993,FEF
07792:  MOVFF  994,FEC
07796:  MOVFF  995,FEC
0779A:  MOVFF  996,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
0779E:  MOVLW  10
077A0:  ADDWF  x8D,W
077A2:  MOVWF  01
077A4:  MOVLW  00
077A6:  ADDWFC x8E,W
077A8:  MOVWF  03
077AA:  MOVFF  01,998
077AE:  MOVWF  x99
077B0:  MOVFF  996,9CF
077B4:  MOVFF  995,9CE
077B8:  MOVFF  994,9CD
077BC:  MOVFF  993,9CC
077C0:  MOVLB  0
077C2:  CALL   5582
077C6:  MOVFF  03,99D
077CA:  MOVFF  02,99C
077CE:  MOVFF  01,99B
077D2:  MOVFF  00,99A
077D6:  MOVLB  9
077D8:  MOVF   x97,W
077DA:  ADDWF  x9A,F
077DC:  MOVLW  00
077DE:  ADDWFC x9B,F
077E0:  ADDWFC x9C,F
077E2:  ADDWFC x9D,F
077E4:  MOVLW  1B
077E6:  ADDWF  x8D,W
077E8:  MOVWF  FE9
077EA:  MOVLW  00
077EC:  ADDWFC x8E,W
077EE:  MOVWF  FEA
077F0:  MOVF   FEF,W
077F2:  SUBWF  x9A,W
077F4:  MOVWF  00
077F6:  MOVLW  00
077F8:  SUBWFB x9B,W
077FA:  MOVWF  01
077FC:  MOVLW  00
077FE:  SUBWFB x9C,W
07800:  MOVWF  02
07802:  MOVLW  00
07804:  SUBWFB x9D,W
07806:  MOVFF  999,FEA
0780A:  MOVFF  998,FE9
0780E:  MOVFF  00,FEF
07812:  MOVFF  01,FEC
07816:  MOVFF  02,FEC
0781A:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
0781C:  MOVLW  00
0781E:  MOVWF  01
07820:  MOVLB  7
07822:  BRA    783E
07824:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
07826:  MOVLW  1A
07828:  ADDWF  x8D,W
0782A:  MOVWF  FE9
0782C:  MOVLW  00
0782E:  ADDWFC x8E,W
07830:  MOVWF  FEA
07832:  MOVF   FEF,W
07834:  IORLW  80
07836:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
07838:  MOVLW  07
0783A:  MOVWF  01
0783C:  MOVLB  7
0783E:  MOVLB  0
07840:  GOTO   82BA (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
08002:  MOVLB  7
08004:  MOVF   x0E,W
08006:  IORWF  x0F,W
08008:  BNZ   8010
....................       return (FR_NOT_ENABLED); 
0800A:  MOVLW  0B
0800C:  MOVWF  01
0800E:  BRA    81DC
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
08010:  MOVLB  0
08012:  CALL   5512
08016:  BTFSC  01.0
08018:  BRA    802A
0801A:  MOVLB  7
0801C:  MOVFF  70E,FE9
08020:  MOVFF  70F,FEA
08024:  MOVF   FEF,F
08026:  BNZ   8032
08028:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
0802A:  MOVLW  09
0802C:  MOVWF  01
0802E:  MOVLB  7
08030:  BRA    81DC
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
08032:  MOVLW  1A
08034:  MOVLB  9
08036:  ADDWF  x90,W
08038:  MOVWF  FE9
0803A:  MOVLW  00
0803C:  ADDWFC x91,W
0803E:  MOVWF  FEA
08040:  BTFSS  FEF.5
08042:  BRA    81BA
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
08044:  MOVLW  14
08046:  ADDWF  x90,W
08048:  MOVWF  FE9
0804A:  MOVLW  00
0804C:  ADDWFC x91,W
0804E:  MOVWF  FEA
08050:  MOVFF  FEF,9ED
08054:  MOVFF  FEC,9EE
08058:  MOVFF  FEC,9EF
0805C:  MOVFF  FEC,9F0
08060:  MOVLB  0
08062:  CALL   59F8
08066:  MOVF   01,F
08068:  BNZ   8074
....................          return (FR_RW_ERROR); 
0806A:  MOVLW  07
0806C:  MOVWF  01
0806E:  MOVLB  7
08070:  BRA    81DC
08072:  MOVLB  0
....................       ptr = fp->dir_ptr; 
08074:  MOVLW  18
08076:  MOVLB  9
08078:  ADDWF  x90,W
0807A:  MOVWF  FE9
0807C:  MOVLW  00
0807E:  ADDWFC x91,W
08080:  MOVWF  FEA
08082:  MOVFF  FEC,993
08086:  MOVF   FED,F
08088:  MOVFF  FEF,992
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
0808C:  MOVLW  0B
0808E:  ADDWF  x92,W
08090:  MOVWF  01
08092:  MOVLW  00
08094:  ADDWFC x93,W
08096:  MOVFF  01,FE9
0809A:  MOVWF  FEA
0809C:  MOVF   FEF,W
0809E:  IORLW  20
080A0:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
080A2:  MOVLW  1C
080A4:  ADDWF  x92,W
080A6:  MOVWF  01
080A8:  MOVLW  00
080AA:  ADDWFC x93,W
080AC:  MOVWF  03
080AE:  MOVFF  01,994
080B2:  MOVWF  x95
080B4:  MOVLW  04
080B6:  ADDWF  x90,W
080B8:  MOVWF  FE9
080BA:  MOVLW  00
080BC:  ADDWFC x91,W
080BE:  MOVWF  FEA
080C0:  MOVFF  FEF,00
080C4:  MOVFF  FEC,01
080C8:  MOVFF  FEC,02
080CC:  MOVFF  FEC,03
080D0:  MOVFF  995,FEA
080D4:  MOVFF  994,FE9
080D8:  MOVFF  00,FEF
080DC:  MOVFF  01,FEC
080E0:  MOVFF  02,FEC
080E4:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
080E8:  MOVLW  1A
080EA:  ADDWF  x92,W
080EC:  MOVWF  01
080EE:  MOVLW  00
080F0:  ADDWFC x93,W
080F2:  MOVWF  03
080F4:  MOVFF  01,994
080F8:  MOVWF  x95
080FA:  MOVLW  08
080FC:  ADDWF  x90,W
080FE:  MOVWF  FE9
08100:  MOVLW  00
08102:  ADDWFC x91,W
08104:  MOVWF  FEA
08106:  MOVFF  FEF,00
0810A:  MOVFF  FEC,01
0810E:  MOVFF  FEC,02
08112:  MOVFF  FEC,03
08116:  MOVFF  995,FEA
0811A:  MOVFF  994,FE9
0811E:  MOVFF  00,FEF
08122:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
08126:  MOVLW  14
08128:  ADDWF  x92,W
0812A:  MOVWF  01
0812C:  MOVLW  00
0812E:  ADDWFC x93,W
08130:  MOVWF  03
08132:  MOVFF  01,994
08136:  MOVWF  x95
08138:  MOVLW  08
0813A:  ADDWF  x90,W
0813C:  MOVWF  FE9
0813E:  MOVLW  00
08140:  ADDWFC x91,W
08142:  MOVWF  FEA
08144:  MOVFF  FEF,996
08148:  MOVFF  FEC,997
0814C:  MOVFF  FEC,00
08150:  MOVFF  FEC,01
08154:  MOVFF  995,FEA
08158:  MOVFF  994,FE9
0815C:  MOVFF  00,FEF
08160:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
08164:  MOVLW  16
08166:  ADDWF  x92,W
08168:  MOVWF  01
0816A:  MOVLW  00
0816C:  ADDWFC x93,W
0816E:  MOVWF  03
08170:  MOVFF  01,994
08174:  MOVWF  x95
08176:  MOVLB  0
08178:  CALL   6F24
0817C:  MOVFF  995,FEA
08180:  MOVFF  994,FE9
08184:  MOVFF  00,FEF
08188:  MOVFF  01,FEC
0818C:  MOVFF  02,FEC
08190:  MOVFF  03,FEC
....................       fs->winflag = 1; 
08194:  MOVLW  06
08196:  MOVLB  7
08198:  ADDWF  x0E,W
0819A:  MOVWF  FE9
0819C:  MOVLW  00
0819E:  ADDWFC x0F,W
081A0:  MOVWF  FEA
081A2:  MOVLW  01
081A4:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
081A6:  MOVLW  1A
081A8:  MOVLB  9
081AA:  ADDWF  x90,W
081AC:  MOVWF  FE9
081AE:  MOVLW  00
081B0:  ADDWFC x91,W
081B2:  MOVWF  FEA
081B4:  MOVF   FEF,W
081B6:  ANDLW  DF
081B8:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
081BA:  CLRF   xF0
081BC:  CLRF   xEF
081BE:  CLRF   xEE
081C0:  CLRF   xED
081C2:  MOVLB  0
081C4:  CALL   59F8
081C8:  MOVF   01,F
081CA:  BNZ   81D6
....................       return (FR_RW_ERROR); 
081CC:  MOVLW  07
081CE:  MOVWF  01
081D0:  MOVLB  7
081D2:  BRA    81DC
081D4:  MOVLB  0
....................  
....................    return (FR_OK); 
081D6:  MOVLW  00
081D8:  MOVWF  01
081DA:  MOVLB  7
081DC:  MOVLB  0
081DE:  GOTO   81EC (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
081E2:  MOVFF  98E,991
081E6:  MOVFF  98D,990
081EA:  BRA    8002
081EC:  MOVFF  01,98F
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
081F0:  MOVLB  9
081F2:  MOVF   x8F,F
081F4:  BNZ   8226
....................       { 
....................       fp->flag = 0; 
081F6:  MOVLW  1A
081F8:  ADDWF  x8D,W
081FA:  MOVWF  FE9
081FC:  MOVLW  00
081FE:  ADDWFC x8E,W
08200:  MOVWF  FEA
08202:  CLRF   FEF
....................       if (fs->files) 
08204:  MOVLW  01
08206:  MOVLB  7
08208:  ADDWF  x0E,W
0820A:  MOVWF  FE9
0820C:  MOVLW  00
0820E:  ADDWFC x0F,W
08210:  MOVWF  FEA
08212:  MOVF   FEF,F
08214:  BZ    8224
....................          fs->files--; 
08216:  MOVLW  01
08218:  ADDWF  x0E,W
0821A:  MOVWF  FE9
0821C:  MOVLW  00
0821E:  ADDWFC x0F,W
08220:  MOVWF  FEA
08222:  DECF   FEF,F
08224:  MOVLB  9
....................       } 
....................    return (res); 
08226:  MOVFF  98F,01
0822A:  MOVLB  0
0822C:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0B906:  CALL   5520
0B90A:  MOVFF  01,868
....................    if (res != FR_OK)  
0B90E:  MOVLB  8
0B910:  MOVF   x68,F
0B912:  BZ    B91A
....................       return (res); 
0B914:  MOVFF  868,01
0B918:  BRA    BBAA
....................  
....................    if (disk_status() & STA_PROTECT) 
0B91A:  MOVLB  0
0B91C:  CALL   5512
0B920:  BTFSS  01.2
0B922:  BRA    B92E
....................       return (FR_WRITE_PROTECTED); 
0B924:  MOVLW  0A
0B926:  MOVWF  01
0B928:  MOVLB  8
0B92A:  BRA    BBAA
0B92C:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0B92E:  MOVLW  08
0B930:  MOVLB  9
0B932:  MOVWF  xB4
0B934:  MOVLW  75
0B936:  MOVWF  xB3
0B938:  MOVLW  08
0B93A:  MOVWF  xB6
0B93C:  MOVLW  83
0B93E:  MOVWF  xB5
0B940:  MOVFF  867,9B8
0B944:  MOVFF  866,9B7
0B948:  MOVLW  08
0B94A:  MOVWF  xBA
0B94C:  MOVLW  69
0B94E:  MOVWF  xB9
0B950:  MOVLB  0
0B952:  CALL   6142
0B956:  MOVFF  01,868
....................  
....................    if (res != FR_OK)  
0B95A:  MOVLB  8
0B95C:  MOVF   x68,F
0B95E:  BZ    B966
....................       return (res);            // Trace failed  
0B960:  MOVFF  868,01
0B964:  BRA    BBAA
....................  
....................    if (dir_ptr == NULL)  
0B966:  MOVF   x69,F
0B968:  BNZ   B974
0B96A:  MOVF   x6A,F
0B96C:  BNZ   B974
....................       return (FR_NO_FILE);      // It is a root directory  
0B96E:  MOVLW  02
0B970:  MOVWF  01
0B972:  BRA    BBAA
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0B974:  MOVLW  0B
0B976:  ADDWF  x69,W
0B978:  MOVWF  01
0B97A:  MOVLW  00
0B97C:  ADDWFC x6A,W
0B97E:  MOVWF  03
0B980:  MOVFF  01,FE9
0B984:  MOVWF  FEA
0B986:  BTFSS  FEF.0
0B988:  BRA    B990
....................       return (FR_DENIED);         // It is a R/O item  
0B98A:  MOVLW  05
0B98C:  MOVWF  01
0B98E:  BRA    BBAA
....................  
....................    dsect = fs->winsect; 
0B990:  MOVLW  20
0B992:  MOVLB  7
0B994:  ADDWF  x0E,W
0B996:  MOVWF  FE9
0B998:  MOVLW  00
0B99A:  ADDWFC x0F,W
0B99C:  MOVWF  FEA
0B99E:  MOVFF  FEF,871
0B9A2:  MOVFF  FEC,872
0B9A6:  MOVFF  FEC,873
0B9AA:  MOVFF  FEC,874
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0B9AE:  MOVLW  14
0B9B0:  MOVLB  8
0B9B2:  ADDWF  x69,W
0B9B4:  MOVWF  01
0B9B6:  MOVLW  00
0B9B8:  ADDWFC x6A,W
0B9BA:  MOVWF  03
0B9BC:  MOVFF  01,FE9
0B9C0:  MOVWF  FEA
0B9C2:  MOVFF  FEC,870
0B9C6:  MOVF   FED,F
0B9C8:  MOVFF  FEF,88F
0B9CC:  MOVFF  88F,86F
0B9D0:  CLRF   x8F
0B9D2:  CLRF   x90
0B9D4:  MOVLW  1A
0B9D6:  ADDWF  x69,W
0B9D8:  MOVWF  01
0B9DA:  MOVLW  00
0B9DC:  ADDWFC x6A,W
0B9DE:  MOVFF  01,FE9
0B9E2:  MOVWF  FEA
0B9E4:  MOVFF  FEC,03
0B9E8:  MOVF   FED,F
0B9EA:  MOVF   FEF,W
0B9EC:  IORWF  x8F,W
0B9EE:  MOVWF  x6D
0B9F0:  MOVF   03,W
0B9F2:  IORWF  x90,W
0B9F4:  MOVWF  x6E
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0B9F6:  MOVLW  0B
0B9F8:  ADDWF  x69,W
0B9FA:  MOVWF  01
0B9FC:  MOVLW  00
0B9FE:  ADDWFC x6A,W
0BA00:  MOVWF  03
0BA02:  MOVFF  01,FE9
0BA06:  MOVWF  FEA
0BA08:  BTFSS  FEF.4
0BA0A:  BRA    BB1E
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BA0C:  MOVFF  870,87C
0BA10:  MOVFF  86F,87B
0BA14:  MOVFF  86E,87A
0BA18:  MOVFF  86D,879
....................       dirscan.sect = clust2sect(dclust); 
0BA1C:  MOVFF  870,9CF
0BA20:  MOVFF  86F,9CE
0BA24:  MOVFF  86E,9CD
0BA28:  MOVFF  86D,9CC
0BA2C:  MOVLB  0
0BA2E:  CALL   5582
0BA32:  MOVFF  03,880
0BA36:  MOVFF  02,87F
0BA3A:  MOVFF  01,87E
0BA3E:  MOVFF  00,87D
....................       dirscan.index = 0; 
0BA42:  MOVLB  8
0BA44:  CLRF   x82
0BA46:  CLRF   x81
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BA48:  MOVFF  880,9F0
0BA4C:  MOVFF  87F,9EF
0BA50:  MOVFF  87E,9EE
0BA54:  MOVFF  87D,9ED
0BA58:  MOVLB  0
0BA5A:  CALL   59F8
0BA5E:  MOVF   01,F
0BA60:  BNZ   BA6C
....................             return (FR_RW_ERROR); 
0BA62:  MOVLW  07
0BA64:  MOVWF  01
0BA66:  MOVLB  8
0BA68:  BRA    BBAA
0BA6A:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BA6C:  MOVLB  8
0BA6E:  MOVF   x81,W
0BA70:  ANDLW  0F
0BA72:  MOVWF  x8F
0BA74:  CLRF   x90
0BA76:  RLCF   x8F,F
0BA78:  RLCF   x90,F
0BA7A:  RLCF   x8F,F
0BA7C:  RLCF   x90,F
0BA7E:  RLCF   x8F,F
0BA80:  RLCF   x90,F
0BA82:  RLCF   x8F,F
0BA84:  RLCF   x90,F
0BA86:  RLCF   x8F,F
0BA88:  RLCF   x90,F
0BA8A:  MOVLW  E0
0BA8C:  ANDWF  x8F,F
0BA8E:  MOVLW  24
0BA90:  ADDWF  x8F,W
0BA92:  MOVWF  01
0BA94:  MOVLW  00
0BA96:  ADDWFC x90,W
0BA98:  MOVWF  03
0BA9A:  MOVF   01,W
0BA9C:  MOVLB  7
0BA9E:  ADDWF  x0E,W
0BAA0:  MOVWF  01
0BAA2:  MOVF   x0F,W
0BAA4:  ADDWFC 03,F
0BAA6:  MOVFF  01,86B
0BAAA:  MOVLB  8
0BAAC:  MOVFF  03,86C
....................          if (*sdir == 0) 
0BAB0:  MOVFF  86C,03
0BAB4:  MOVFF  86B,FE9
0BAB8:  MOVFF  86C,FEA
0BABC:  MOVF   FEF,F
0BABE:  BNZ   BAC2
....................             break; 
0BAC0:  BRA    BB1E
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BAC2:  MOVFF  86C,03
0BAC6:  MOVFF  86B,FE9
0BACA:  MOVFF  86C,FEA
0BACE:  MOVF   FEF,W
0BAD0:  SUBLW  E5
0BAD2:  BZ    BB02
0BAD4:  MOVFF  86C,03
0BAD8:  MOVFF  86B,FE9
0BADC:  MOVFF  86C,FEA
0BAE0:  MOVF   FEF,W
0BAE2:  SUBLW  2E
0BAE4:  BZ    BB02
0BAE6:  MOVLW  0B
0BAE8:  ADDWF  x6B,W
0BAEA:  MOVWF  01
0BAEC:  MOVLW  00
0BAEE:  ADDWFC x6C,W
0BAF0:  MOVWF  03
0BAF2:  MOVFF  01,FE9
0BAF6:  MOVWF  FEA
0BAF8:  BTFSC  FEF.3
0BAFA:  BRA    BB02
....................             return (FR_DENIED);   // The directory is not empty  
0BAFC:  MOVLW  05
0BAFE:  MOVWF  01
0BB00:  BRA    BBAA
....................          } while (next_dir_ptr(&dirscan)); 
0BB02:  MOVLW  08
0BB04:  MOVLB  9
0BB06:  MOVWF  xC3
0BB08:  MOVLW  75
0BB0A:  MOVWF  xC2
0BB0C:  MOVLB  0
0BB0E:  CALL   5F68
0BB12:  MOVF   01,F
0BB14:  BTFSC  FD8.2
0BB16:  BRA    BB1C
0BB18:  MOVLB  8
0BB1A:  BRA    BA48
0BB1C:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BB1E:  MOVFF  874,9F0
0BB22:  MOVFF  873,9EF
0BB26:  MOVFF  872,9EE
0BB2A:  MOVFF  871,9ED
0BB2E:  MOVLB  0
0BB30:  CALL   59F8
0BB34:  MOVF   01,F
0BB36:  BNZ   BB42
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BB38:  MOVLW  07
0BB3A:  MOVWF  01
0BB3C:  MOVLB  8
0BB3E:  BRA    BBAA
0BB40:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BB42:  MOVLB  8
0BB44:  MOVFF  869,FE9
0BB48:  MOVFF  86A,FEA
0BB4C:  MOVLW  E5
0BB4E:  MOVWF  FEF
....................    fs->winflag = 1; 
0BB50:  MOVLW  06
0BB52:  MOVLB  7
0BB54:  ADDWF  x0E,W
0BB56:  MOVWF  FE9
0BB58:  MOVLW  00
0BB5A:  ADDWFC x0F,W
0BB5C:  MOVWF  FEA
0BB5E:  MOVLW  01
0BB60:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BB62:  MOVFF  870,9BB
0BB66:  MOVFF  86F,9BA
0BB6A:  MOVFF  86E,9B9
0BB6E:  MOVFF  86D,9B8
0BB72:  MOVLB  0
0BB74:  CALL   6E84
0BB78:  MOVF   01,F
0BB7A:  BNZ   BB86
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BB7C:  MOVLW  07
0BB7E:  MOVWF  01
0BB80:  MOVLB  8
0BB82:  BRA    BBAA
0BB84:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BB86:  MOVLB  9
0BB88:  CLRF   xF0
0BB8A:  CLRF   xEF
0BB8C:  CLRF   xEE
0BB8E:  CLRF   xED
0BB90:  MOVLB  0
0BB92:  CALL   59F8
0BB96:  MOVF   01,F
0BB98:  BNZ   BBA4
....................       return (FR_RW_ERROR); 
0BB9A:  MOVLW  07
0BB9C:  MOVWF  01
0BB9E:  MOVLB  8
0BBA0:  BRA    BBAA
0BBA2:  MOVLB  0
....................  
....................    return (FR_OK); 
0BBA4:  MOVLW  00
0BBA6:  MOVWF  01
0BBA8:  MOVLB  8
0BBAA:  MOVLB  0
0BBAC:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
078F8:  MOVFF  98E,990
078FC:  MOVFF  98D,98F
07900:  MOVFF  990,03
07904:  MOVLB  9
07906:  MOVFF  98F,FE9
0790A:  MOVFF  990,FEA
0790E:  MOVF   FEF,F
07910:  BZ    791E
07912:  INCF   x8F,F
07914:  BTFSC  FD8.2
07916:  INCF   x90,F
07918:  MOVLB  0
0791A:  BRA    7900
0791C:  MOVLB  9
....................    return(sc - s); 
0791E:  MOVF   x8D,W
07920:  SUBWF  x8F,W
07922:  MOVWF  00
07924:  MOVF   x8E,W
07926:  SUBWFB x90,W
07928:  MOVWF  03
0792A:  MOVFF  00,01
0792E:  MOVWF  02
07930:  MOVLB  0
07932:  GOTO   8372 (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
03486:  MOVLB  4
03488:  CLRF   xE2
0348A:  MOVLW  01
0348C:  MOVWF  xE1
....................    rtc.year=10; 
0348E:  MOVLW  0A
03490:  MOVWF  xE0
....................    rtc.month=1; 
03492:  MOVLW  01
03494:  MOVWF  xDF
....................    rtc.day=1; 
03496:  MOVWF  xDE
....................    rtc.hour=0; 
03498:  CLRF   xDD
....................    rtc.min=0; 
0349A:  CLRF   xDC
....................    rtc.sec=0; 
0349C:  CLRF   xDB
....................    rtc.ms100=0; 
0349E:  CLRF   xDA
034A0:  MOVLB  0
034A2:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
06F24:  MOVLB  9
06F26:  CLRF   xBA
06F28:  CLRF   xB9
06F2A:  CLRF   xB8
06F2C:  MOVFF  4E0,9B7
06F30:  MOVLW  14
06F32:  ADDWF  xB7,F
06F34:  MOVLW  00
06F36:  ADDWFC xB8,F
06F38:  ADDWFC xB9,F
06F3A:  ADDWFC xBA,F
06F3C:  BCF    FD8.0
06F3E:  CLRF   xB3
06F40:  CLRF   xB4
06F42:  CLRF   xB5
06F44:  RLCF   xB7,W
06F46:  MOVWF  xB6
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
06F48:  CLRF   xBA
06F4A:  CLRF   xB9
06F4C:  CLRF   xB8
06F4E:  MOVFF  4DF,9B7
06F52:  MOVLW  0F
06F54:  ANDWF  xB7,F
06F56:  CLRF   xB8
06F58:  CLRF   xB9
06F5A:  CLRF   xBA
06F5C:  CLRF   00
06F5E:  CLRF   01
06F60:  RLCF   xB7,W
06F62:  MOVWF  02
06F64:  RLCF   xB8,W
06F66:  MOVWF  03
06F68:  RLCF   02,F
06F6A:  RLCF   03,F
06F6C:  RLCF   02,F
06F6E:  RLCF   03,F
06F70:  RLCF   02,F
06F72:  RLCF   03,F
06F74:  RLCF   02,F
06F76:  RLCF   03,F
06F78:  MOVLW  E0
06F7A:  ANDWF  02,F
06F7C:  MOVF   00,W
06F7E:  IORWF  xB3,F
06F80:  MOVF   01,W
06F82:  IORWF  xB4,F
06F84:  MOVF   02,W
06F86:  IORWF  xB5,F
06F88:  MOVF   03,W
06F8A:  IORWF  xB6,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
06F8C:  CLRF   xBA
06F8E:  CLRF   xB9
06F90:  CLRF   xB8
06F92:  MOVFF  4DE,9B7
06F96:  MOVLW  1F
06F98:  ANDWF  xB7,F
06F9A:  CLRF   xB8
06F9C:  CLRF   xB9
06F9E:  CLRF   xBA
06FA0:  CLRF   00
06FA2:  CLRF   01
06FA4:  MOVF   00,W
06FA6:  IORWF  xB3,F
06FA8:  MOVF   01,W
06FAA:  IORWF  xB4,F
06FAC:  MOVF   xB7,W
06FAE:  IORWF  xB5,F
06FB0:  MOVF   xB8,W
06FB2:  IORWF  xB6,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
06FB4:  CLRF   xBA
06FB6:  CLRF   xB9
06FB8:  CLRF   xB8
06FBA:  MOVFF  4DD,9B7
06FBE:  MOVLW  1F
06FC0:  ANDWF  xB7,F
06FC2:  CLRF   xB8
06FC4:  CLRF   xB9
06FC6:  CLRF   xBA
06FC8:  CLRF   00
06FCA:  RLCF   xB7,W
06FCC:  MOVWF  01
06FCE:  RLCF   xB8,W
06FD0:  MOVWF  02
06FD2:  RLCF   xB9,W
06FD4:  MOVWF  03
06FD6:  RLCF   01,F
06FD8:  RLCF   02,F
06FDA:  RLCF   03,F
06FDC:  RLCF   01,F
06FDE:  RLCF   02,F
06FE0:  RLCF   03,F
06FE2:  MOVLW  F8
06FE4:  ANDWF  01,F
06FE6:  MOVF   00,W
06FE8:  IORWF  xB3,F
06FEA:  MOVF   01,W
06FEC:  IORWF  xB4,F
06FEE:  MOVF   02,W
06FF0:  IORWF  xB5,F
06FF2:  MOVF   03,W
06FF4:  IORWF  xB6,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
06FF6:  CLRF   xBA
06FF8:  CLRF   xB9
06FFA:  CLRF   xB8
06FFC:  MOVFF  4DC,9B7
07000:  MOVLW  3F
07002:  ANDWF  xB7,F
07004:  CLRF   xB8
07006:  CLRF   xB9
07008:  CLRF   xBA
0700A:  RLCF   xB7,W
0700C:  MOVWF  00
0700E:  RLCF   xB8,W
07010:  MOVWF  01
07012:  RLCF   xB9,W
07014:  MOVWF  02
07016:  RLCF   xBA,W
07018:  MOVWF  03
0701A:  RLCF   00,F
0701C:  RLCF   01,F
0701E:  RLCF   02,F
07020:  RLCF   03,F
07022:  RLCF   00,F
07024:  RLCF   01,F
07026:  RLCF   02,F
07028:  RLCF   03,F
0702A:  RLCF   00,F
0702C:  RLCF   01,F
0702E:  RLCF   02,F
07030:  RLCF   03,F
07032:  RLCF   00,F
07034:  RLCF   01,F
07036:  RLCF   02,F
07038:  RLCF   03,F
0703A:  MOVLW  E0
0703C:  ANDWF  00,F
0703E:  MOVF   00,W
07040:  IORWF  xB3,F
07042:  MOVF   01,W
07044:  IORWF  xB4,F
07046:  MOVF   02,W
07048:  IORWF  xB5,F
0704A:  MOVF   03,W
0704C:  IORWF  xB6,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
0704E:  CLRF   xBA
07050:  CLRF   xB9
07052:  CLRF   xB8
07054:  MOVFF  4DB,9B7
07058:  MOVLW  3F
0705A:  ANDWF  xB7,F
0705C:  CLRF   xB8
0705E:  CLRF   xB9
07060:  CLRF   xBA
07062:  BCF    FD8.0
07064:  RRCF   xBA,W
07066:  MOVWF  03
07068:  RRCF   xB9,W
0706A:  MOVWF  02
0706C:  RRCF   xB8,W
0706E:  MOVWF  01
07070:  RRCF   xB7,W
07072:  IORWF  xB3,F
07074:  MOVF   01,W
07076:  IORWF  xB4,F
07078:  MOVF   02,W
0707A:  IORWF  xB5,F
0707C:  MOVF   03,W
0707E:  IORWF  xB6,F
....................    return (work); 
07080:  MOVFF  9B3,00
07084:  MOVFF  9B4,01
07088:  MOVFF  9B5,02
0708C:  MOVFF  9B6,03
07090:  MOVLB  0
07092:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0B78C:  MOVLW  08
0B78E:  MOVLB  9
0B790:  MOVWF  x8E
0B792:  MOVLW  68
0B794:  MOVWF  x8D
0B796:  MOVFF  867,990
0B79A:  MOVFF  866,98F
0B79E:  MOVLW  01
0B7A0:  MOVWF  x91
0B7A2:  MOVLB  0
0B7A4:  CALL   7094
0B7A8:  MOVFF  01,884
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0B7AC:  MOVLB  8
0B7AE:  MOVF   x84,F
0B7B0:  BTFSS  FD8.2
0B7B2:  BRA    B8B4
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0B7B4:  MOVLW  08
0B7B6:  MOVWF  xAA
0B7B8:  MOVLW  68
0B7BA:  MOVWF  xA9
0B7BC:  MOVLW  08
0B7BE:  MOVWF  xAC
0B7C0:  MOVLW  85
0B7C2:  MOVWF  xAB
0B7C4:  CLRF   xAE
0B7C6:  MOVLW  20
0B7C8:  MOVWF  xAD
0B7CA:  MOVLW  08
0B7CC:  MOVWF  xB0
0B7CE:  MOVLW  A7
0B7D0:  MOVWF  xAF
0B7D2:  MOVLB  0
0B7D4:  BRA    B0D0
0B7D6:  MOVFF  01,884
....................          for (i = 0; i < br; i++) 
0B7DA:  MOVLB  8
0B7DC:  CLRF   xA6
0B7DE:  CLRF   xA5
0B7E0:  MOVF   xA6,W
0B7E2:  SUBWF  xA8,W
0B7E4:  BNC   B810
0B7E6:  BNZ   B7EE
0B7E8:  MOVF   xA7,W
0B7EA:  SUBWF  xA5,W
0B7EC:  BC    B810
....................          { 
....................             putc(mesg[i]); 
0B7EE:  MOVLW  85
0B7F0:  ADDWF  xA5,W
0B7F2:  MOVWF  FE9
0B7F4:  MOVLW  08
0B7F6:  ADDWFC xA6,W
0B7F8:  MOVWF  FEA
0B7FA:  MOVFF  FEF,8A9
0B7FE:  MOVF   xA9,W
0B800:  MOVLB  0
0B802:  CALL   ADAA
0B806:  MOVLB  8
0B808:  INCF   xA5,F
0B80A:  BTFSC  FD8.2
0B80C:  INCF   xA6,F
0B80E:  BRA    B7E0
....................          } 
....................       } while ((result == FR_OK) && br); 
0B810:  MOVF   x84,F
0B812:  BNZ   B81A
0B814:  MOVF   xA7,W
0B816:  IORWF  xA8,W
0B818:  BNZ   B7B4
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0B81A:  MOVF   x84,F
0B81C:  BZ    B890
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0B81E:  MOVLW  16
0B820:  MOVWF  FF6
0B822:  MOVLW  0C
0B824:  MOVWF  FF7
0B826:  MOVLW  00
0B828:  MOVWF  FF8
0B82A:  CLRF   1B
0B82C:  BTFSC  FF2.7
0B82E:  BSF    1B.7
0B830:  BCF    FF2.7
0B832:  MOVLB  0
0B834:  CALL   0E30
0B838:  BTFSC  1B.7
0B83A:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0B83C:  MOVFF  884,8A9
0B840:  MOVLW  08
0B842:  MOVLB  8
0B844:  MOVWF  xAB
0B846:  MOVLW  85
0B848:  MOVWF  xAA
0B84A:  MOVLB  0
0B84C:  RCALL  B5DE
....................          printf("@FS: %s\r\n",mesg); 
0B84E:  MOVLW  2C
0B850:  MOVWF  FF6
0B852:  MOVLW  0C
0B854:  MOVWF  FF7
0B856:  MOVLW  00
0B858:  MOVWF  FF8
0B85A:  CLRF   1B
0B85C:  BTFSC  FF2.7
0B85E:  BSF    1B.7
0B860:  BCF    FF2.7
0B862:  MOVLW  05
0B864:  MOVLB  A
0B866:  MOVWF  x18
0B868:  MOVLB  0
0B86A:  CALL   1006
0B86E:  BTFSC  1B.7
0B870:  BSF    FF2.7
0B872:  MOVLW  08
0B874:  MOVWF  FEA
0B876:  MOVLW  85
0B878:  MOVWF  FE9
0B87A:  CALL   78D2
0B87E:  MOVLW  0D
0B880:  BTFSS  F9E.4
0B882:  BRA    B880
0B884:  MOVWF  FAD
0B886:  MOVLW  0A
0B888:  BTFSS  F9E.4
0B88A:  BRA    B888
0B88C:  MOVWF  FAD
0B88E:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0B890:  MOVLW  08
0B892:  MOVLB  9
0B894:  MOVWF  x8E
0B896:  MOVLW  68
0B898:  MOVWF  x8D
0B89A:  MOVLB  0
0B89C:  CALL   81E2
....................       printf("\r\n");       
0B8A0:  MOVLW  0D
0B8A2:  BTFSS  F9E.4
0B8A4:  BRA    B8A2
0B8A6:  MOVWF  FAD
0B8A8:  MOVLW  0A
0B8AA:  BTFSS  F9E.4
0B8AC:  BRA    B8AA
0B8AE:  MOVWF  FAD
....................    } 
0B8B0:  BRA    B904
0B8B2:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0B8B4:  MOVFF  884,8A9
0B8B8:  MOVLW  08
0B8BA:  MOVWF  xAB
0B8BC:  MOVLW  85
0B8BE:  MOVWF  xAA
0B8C0:  MOVLB  0
0B8C2:  RCALL  B5DE
....................       printf("@FS: %s\r\n",mesg); 
0B8C4:  MOVLW  36
0B8C6:  MOVWF  FF6
0B8C8:  MOVLW  0C
0B8CA:  MOVWF  FF7
0B8CC:  MOVLW  00
0B8CE:  MOVWF  FF8
0B8D0:  CLRF   1B
0B8D2:  BTFSC  FF2.7
0B8D4:  BSF    1B.7
0B8D6:  BCF    FF2.7
0B8D8:  MOVLW  05
0B8DA:  MOVLB  A
0B8DC:  MOVWF  x18
0B8DE:  MOVLB  0
0B8E0:  CALL   1006
0B8E4:  BTFSC  1B.7
0B8E6:  BSF    FF2.7
0B8E8:  MOVLW  08
0B8EA:  MOVWF  FEA
0B8EC:  MOVLW  85
0B8EE:  MOVWF  FE9
0B8F0:  CALL   78D2
0B8F4:  MOVLW  0D
0B8F6:  BTFSS  F9E.4
0B8F8:  BRA    B8F6
0B8FA:  MOVWF  FAD
0B8FC:  MOVLW  0A
0B8FE:  BTFSS  F9E.4
0B900:  BRA    B8FE
0B902:  MOVWF  FAD
....................    } 
0B904:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04D6C:  MOVLW  40
04D6E:  MOVWF  FF6
04D70:  MOVLW  0C
04D72:  MOVWF  FF7
04D74:  MOVLW  00
04D76:  MOVWF  FF8
04D78:  CLRF   1B
04D7A:  BTFSC  FF2.7
04D7C:  BSF    1B.7
04D7E:  BCF    FF2.7
04D80:  CALL   0E30
04D84:  BTFSC  1B.7
04D86:  BSF    FF2.7
....................    if (status & FR_OK) 
04D88:  ANDLW  00
04D8A:  BZ    4DA8
....................       printf("   NoError\r\n"); 
04D8C:  MOVLW  50
04D8E:  MOVWF  FF6
04D90:  MOVLW  0C
04D92:  MOVWF  FF7
04D94:  MOVLW  00
04D96:  MOVWF  FF8
04D98:  CLRF   1B
04D9A:  BTFSC  FF2.7
04D9C:  BSF    1B.7
04D9E:  BCF    FF2.7
04DA0:  CALL   0E30
04DA4:  BTFSC  1B.7
04DA6:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04DA8:  MOVLB  8
04DAA:  BTFSS  x67.0
04DAC:  BRA    4DCE
....................       printf("   Media Not Ready\r\n"); 
04DAE:  MOVLW  5E
04DB0:  MOVWF  FF6
04DB2:  MOVLW  0C
04DB4:  MOVWF  FF7
04DB6:  MOVLW  00
04DB8:  MOVWF  FF8
04DBA:  CLRF   1B
04DBC:  BTFSC  FF2.7
04DBE:  BSF    1B.7
04DC0:  BCF    FF2.7
04DC2:  MOVLB  0
04DC4:  CALL   0E30
04DC8:  BTFSC  1B.7
04DCA:  BSF    FF2.7
04DCC:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04DCE:  BTFSS  x67.1
04DD0:  BRA    4DF2
....................       printf("   File Not Found\r\n"); 
04DD2:  MOVLW  74
04DD4:  MOVWF  FF6
04DD6:  MOVLW  0C
04DD8:  MOVWF  FF7
04DDA:  MOVLW  00
04DDC:  MOVWF  FF8
04DDE:  CLRF   1B
04DE0:  BTFSC  FF2.7
04DE2:  BSF    1B.7
04DE4:  BCF    FF2.7
04DE6:  MOVLB  0
04DE8:  CALL   0E30
04DEC:  BTFSC  1B.7
04DEE:  BSF    FF2.7
04DF0:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04DF2:  MOVF   x67,W
04DF4:  ANDLW  03
04DF6:  BZ    4E18
....................       printf("   Invalid Path\r\n"); 
04DF8:  MOVLW  88
04DFA:  MOVWF  FF6
04DFC:  MOVLW  0C
04DFE:  MOVWF  FF7
04E00:  MOVLW  00
04E02:  MOVWF  FF8
04E04:  CLRF   1B
04E06:  BTFSC  FF2.7
04E08:  BSF    1B.7
04E0A:  BCF    FF2.7
04E0C:  MOVLB  0
04E0E:  CALL   0E30
04E12:  BTFSC  1B.7
04E14:  BSF    FF2.7
04E16:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04E18:  BTFSS  x67.2
04E1A:  BRA    4E3C
....................       printf("   Invalid Name\r\n"); 
04E1C:  MOVLW  9A
04E1E:  MOVWF  FF6
04E20:  MOVLW  0C
04E22:  MOVWF  FF7
04E24:  MOVLW  00
04E26:  MOVWF  FF8
04E28:  CLRF   1B
04E2A:  BTFSC  FF2.7
04E2C:  BSF    1B.7
04E2E:  BCF    FF2.7
04E30:  MOVLB  0
04E32:  CALL   0E30
04E36:  BTFSC  1B.7
04E38:  BSF    FF2.7
04E3A:  MOVLB  8
....................    if (status & FR_DENIED) 
04E3C:  MOVF   x67,W
04E3E:  ANDLW  05
04E40:  BZ    4E62
....................       printf("   Access Denied\r\n"); 
04E42:  MOVLW  AC
04E44:  MOVWF  FF6
04E46:  MOVLW  0C
04E48:  MOVWF  FF7
04E4A:  MOVLW  00
04E4C:  MOVWF  FF8
04E4E:  CLRF   1B
04E50:  BTFSC  FF2.7
04E52:  BSF    1B.7
04E54:  BCF    FF2.7
04E56:  MOVLB  0
04E58:  CALL   0E30
04E5C:  BTFSC  1B.7
04E5E:  BSF    FF2.7
04E60:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04E62:  MOVF   x67,W
04E64:  ANDLW  06
04E66:  BZ    4E88
....................       printf("   Disk Full\r\n"); 
04E68:  MOVLW  C0
04E6A:  MOVWF  FF6
04E6C:  MOVLW  0C
04E6E:  MOVWF  FF7
04E70:  MOVLW  00
04E72:  MOVWF  FF8
04E74:  CLRF   1B
04E76:  BTFSC  FF2.7
04E78:  BSF    1B.7
04E7A:  BCF    FF2.7
04E7C:  MOVLB  0
04E7E:  CALL   0E30
04E82:  BTFSC  1B.7
04E84:  BSF    FF2.7
04E86:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04E88:  MOVF   x67,W
04E8A:  ANDLW  07
04E8C:  BZ    4EAE
....................       printf("   Read/Write Error\r\n"); 
04E8E:  MOVLW  D0
04E90:  MOVWF  FF6
04E92:  MOVLW  0C
04E94:  MOVWF  FF7
04E96:  MOVLW  00
04E98:  MOVWF  FF8
04E9A:  CLRF   1B
04E9C:  BTFSC  FF2.7
04E9E:  BSF    1B.7
04EA0:  BCF    FF2.7
04EA2:  MOVLB  0
04EA4:  CALL   0E30
04EA8:  BTFSC  1B.7
04EAA:  BSF    FF2.7
04EAC:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04EAE:  MOVF   x67,W
04EB0:  ANDLW  09
04EB2:  BZ    4ED4
....................       printf("   Incorrect Media Change\r\n"); 
04EB4:  MOVLW  E6
04EB6:  MOVWF  FF6
04EB8:  MOVLW  0C
04EBA:  MOVWF  FF7
04EBC:  MOVLW  00
04EBE:  MOVWF  FF8
04EC0:  CLRF   1B
04EC2:  BTFSC  FF2.7
04EC4:  BSF    1B.7
04EC6:  BCF    FF2.7
04EC8:  MOVLB  0
04ECA:  CALL   0E30
04ECE:  BTFSC  1B.7
04ED0:  BSF    FF2.7
04ED2:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04ED4:  MOVF   x67,W
04ED6:  ANDLW  0A
04ED8:  BZ    4EFA
....................       printf("   Write Protected\r\n"); 
04EDA:  MOVLW  02
04EDC:  MOVWF  FF6
04EDE:  MOVLW  0D
04EE0:  MOVWF  FF7
04EE2:  MOVLW  00
04EE4:  MOVWF  FF8
04EE6:  CLRF   1B
04EE8:  BTFSC  FF2.7
04EEA:  BSF    1B.7
04EEC:  BCF    FF2.7
04EEE:  MOVLB  0
04EF0:  CALL   0E30
04EF4:  BTFSC  1B.7
04EF6:  BSF    FF2.7
04EF8:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04EFA:  MOVF   x67,W
04EFC:  ANDLW  0B
04EFE:  BZ    4F20
....................       printf("   Not Enabled\r\n"); 
04F00:  MOVLW  18
04F02:  MOVWF  FF6
04F04:  MOVLW  0D
04F06:  MOVWF  FF7
04F08:  MOVLW  00
04F0A:  MOVWF  FF8
04F0C:  CLRF   1B
04F0E:  BTFSC  FF2.7
04F10:  BSF    1B.7
04F12:  BCF    FF2.7
04F14:  MOVLB  0
04F16:  CALL   0E30
04F1A:  BTFSC  1B.7
04F1C:  BSF    FF2.7
04F1E:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04F20:  MOVF   x67,W
04F22:  ANDLW  0C
04F24:  BZ    4F46
....................       printf("   No File System\r\n"); 
04F26:  MOVLW  2A
04F28:  MOVWF  FF6
04F2A:  MOVLW  0D
04F2C:  MOVWF  FF7
04F2E:  MOVLW  00
04F30:  MOVWF  FF8
04F32:  CLRF   1B
04F34:  BTFSC  FF2.7
04F36:  BSF    1B.7
04F38:  BCF    FF2.7
04F3A:  MOVLB  0
04F3C:  CALL   0E30
04F40:  BTFSC  1B.7
04F42:  BSF    FF2.7
04F44:  MOVLB  8
04F46:  MOVLB  0
04F48:  GOTO   4FD2 (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
0822E:  MOVLW  08
08230:  MOVWF  FEA
08232:  MOVLW  ED
08234:  MOVWF  FE9
08236:  CLRF   00
08238:  CLRF   02
0823A:  MOVLW  A0
0823C:  MOVWF  01
0823E:  CALL   34A4
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
08242:  MOVLW  08
08244:  MOVLB  9
08246:  MOVWF  x8E
08248:  MOVLW  CC
0824A:  MOVWF  x8D
0824C:  MOVFF  8CB,990
08250:  MOVFF  8CA,98F
08254:  MOVLW  12
08256:  MOVWF  x91
08258:  MOVLB  0
0825A:  CALL   7094
0825E:  MOVFF  01,8E8
....................    if (result) 
08262:  MOVLB  8
08264:  MOVF   xE8,F
08266:  BZ    828A
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
08268:  MOVLW  3E
0826A:  MOVWF  FF6
0826C:  MOVLW  0D
0826E:  MOVWF  FF7
08270:  MOVLW  00
08272:  MOVWF  FF8
08274:  CLRF   1B
08276:  BTFSC  FF2.7
08278:  BSF    1B.7
0827A:  BCF    FF2.7
0827C:  MOVLB  0
0827E:  CALL   0E30
08282:  BTFSC  1B.7
08284:  BSF    FF2.7
....................    } 
08286:  BRA    8406
08288:  MOVLB  8
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
0828A:  MOVF   xD0,F
0828C:  BNZ   829A
0828E:  MOVF   xD1,F
08290:  BNZ   829A
08292:  MOVF   xD2,F
08294:  BNZ   829A
08296:  MOVF   xD3,F
08298:  BZ    82C0
....................          result = f_lseek(&fdst, fdst.fsize);  
0829A:  MOVLW  08
0829C:  MOVLB  9
0829E:  MOVWF  x8E
082A0:  MOVLW  CC
082A2:  MOVWF  x8D
082A4:  MOVFF  8D3,992
082A8:  MOVFF  8D2,991
082AC:  MOVFF  8D1,990
082B0:  MOVFF  8D0,98F
082B4:  MOVLB  0
082B6:  GOTO   74DC
082BA:  MOVFF  01,8E8
082BE:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
082C0:  MOVLB  0
082C2:  MOVF   x62,F
082C4:  BNZ   82E2
082C6:  MOVLW  08
082C8:  MOVLB  9
082CA:  MOVWF  x8E
082CC:  MOVLW  ED
082CE:  MOVWF  x8D
082D0:  CLRF   x90
082D2:  MOVLW  63
082D4:  MOVWF  x8F
082D6:  CLRF   x92
082D8:  MOVLW  9F
082DA:  MOVWF  x91
082DC:  MOVLB  0
082DE:  CALL   7844
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
082E2:  DECFSZ x62,W
082E4:  BRA    8304
082E6:  MOVLW  08
082E8:  MOVLB  9
082EA:  MOVWF  x8E
082EC:  MOVLW  ED
082EE:  MOVWF  x8D
082F0:  MOVLW  01
082F2:  MOVWF  x90
082F4:  MOVLW  03
082F6:  MOVWF  x8F
082F8:  CLRF   x92
082FA:  MOVLW  9F
082FC:  MOVWF  x91
082FE:  MOVLB  0
08300:  CALL   7844
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
08304:  MOVF   20,F
08306:  BNZ   830E
08308:  MOVF   1F,W
0830A:  SUBLW  04
0830C:  BC    8362
0830E:  MOVLW  5E
08310:  MOVWF  FF6
08312:  MOVLW  0D
08314:  MOVWF  FF7
08316:  MOVLW  00
08318:  MOVWF  FF8
0831A:  CLRF   1B
0831C:  BTFSC  FF2.7
0831E:  BSF    1B.7
08320:  BCF    FF2.7
08322:  MOVLW  0E
08324:  MOVLB  A
08326:  MOVWF  x18
08328:  MOVLB  0
0832A:  CALL   1006
0832E:  BTFSC  1B.7
08330:  BSF    FF2.7
08332:  MOVLW  08
08334:  MOVWF  FEA
08336:  MOVLW  ED
08338:  MOVWF  FE9
0833A:  CALL   78D2
0833E:  MOVLW  6E
08340:  MOVWF  FF6
08342:  MOVLW  0D
08344:  MOVWF  FF7
08346:  MOVLW  00
08348:  MOVWF  FF8
0834A:  CLRF   1B
0834C:  BTFSC  FF2.7
0834E:  BSF    1B.7
08350:  BCF    FF2.7
08352:  MOVLW  03
08354:  MOVLB  A
08356:  MOVWF  x18
08358:  MOVLB  0
0835A:  CALL   1006
0835E:  BTFSC  1B.7
08360:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
08362:  MOVLW  08
08364:  MOVLB  9
08366:  MOVWF  x8E
08368:  MOVLW  ED
0836A:  MOVWF  x8D
0836C:  MOVLB  0
0836E:  GOTO   78F8
08372:  MOVFF  02,8EA
08376:  MOVFF  01,8E9
....................       result = f_write(&fdst, mesg, btw, &bw); 
0837A:  MOVLW  08
0837C:  MOVLB  9
0837E:  MOVWF  x8E
08380:  MOVLW  CC
08382:  MOVWF  x8D
08384:  MOVLW  08
08386:  MOVWF  x90
08388:  MOVLW  ED
0838A:  MOVWF  x8F
0838C:  MOVFF  8EA,992
08390:  MOVFF  8E9,991
08394:  MOVLW  08
08396:  MOVWF  x94
08398:  MOVLW  EB
0839A:  MOVWF  x93
0839C:  MOVLB  0
0839E:  GOTO   7936
083A2:  MOVFF  01,8E8
....................       if (result) 
083A6:  MOVLB  8
083A8:  MOVF   xE8,F
083AA:  BZ    83CE
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
083AC:  MOVLW  72
083AE:  MOVWF  FF6
083B0:  MOVLW  0D
083B2:  MOVWF  FF7
083B4:  MOVLW  00
083B6:  MOVWF  FF8
083B8:  CLRF   1B
083BA:  BTFSC  FF2.7
083BC:  BSF    1B.7
083BE:  BCF    FF2.7
083C0:  MOVLB  0
083C2:  CALL   0E30
083C6:  BTFSC  1B.7
083C8:  BSF    FF2.7
....................       } 
083CA:  BRA    83F6
083CC:  MOVLB  8
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
083CE:  MOVF   20,F
083D0:  BNZ   83D8
083D2:  MOVF   1F,W
083D4:  SUBLW  04
083D6:  BC    83F8
083D8:  MOVLW  86
083DA:  MOVWF  FF6
083DC:  MOVLW  0D
083DE:  MOVWF  FF7
083E0:  MOVLW  00
083E2:  MOVWF  FF8
083E4:  CLRF   1B
083E6:  BTFSC  FF2.7
083E8:  BSF    1B.7
083EA:  BCF    FF2.7
083EC:  MOVLB  0
083EE:  CALL   0E30
083F2:  BTFSC  1B.7
083F4:  BSF    FF2.7
083F6:  MOVLB  8
....................       } 
....................  
....................       f_close(&fdst); 
083F8:  MOVLW  08
083FA:  MOVLB  9
083FC:  MOVWF  x8E
083FE:  MOVLW  CC
08400:  MOVWF  x8D
08402:  MOVLB  0
08404:  RCALL  81E2
....................    } 
....................  
....................    return (result); 
08406:  MOVLB  8
08408:  MOVFF  8E8,01
0840C:  MOVLB  0
0840E:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
17614:  CLRF   1B
17616:  BTFSC  FF2.7
17618:  BSF    1B.7
1761A:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
1761C:  MOVFF  864,A1A
17620:  MOVLW  0A
17622:  MOVLB  A
17624:  MOVWF  x1B
17626:  MOVLB  0
17628:  CALL   0F5C
1762C:  BTFSC  1B.7
1762E:  BSF    FF2.7
17630:  MOVFF  01,865
....................    nibl=data-(nibh*10); 
17634:  MOVLB  8
17636:  MOVF   x65,W
17638:  MULLW  0A
1763A:  MOVF   FF3,W
1763C:  SUBWF  x64,W
1763E:  MOVWF  x66
....................  
....................    return((nibh<<4)|nibl); 
17640:  SWAPF  x65,W
17642:  MOVWF  00
17644:  MOVLW  F0
17646:  ANDWF  00,F
17648:  MOVF   00,W
1764A:  IORWF  x66,W
1764C:  MOVWF  01
1764E:  MOVLB  0
17650:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
03290:  MOVFF  8CB,8CC
....................    data=(i>>4)*10; 
03294:  MOVLB  8
03296:  SWAPF  xCC,W
03298:  MOVWF  00
0329A:  MOVLW  0F
0329C:  ANDWF  00,F
0329E:  MOVF   00,W
032A0:  MULLW  0A
032A2:  MOVFF  FF3,8CB
....................    data=data+(i<<4>>4); 
032A6:  SWAPF  xCC,W
032A8:  MOVWF  00
032AA:  MOVLW  F0
032AC:  ANDWF  00,F
032AE:  MOVF   00,W
032B0:  SWAPF  00,F
032B2:  MOVLW  0F
032B4:  ANDWF  00,F
032B6:  MOVF   00,W
032B8:  ADDWF  xCB,F
....................  
....................    return data; 
032BA:  MOVFF  8CB,01
032BE:  MOVLB  0
032C0:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
03430:  MOVLB  8
03432:  CLRF   xA8
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
03434:  BCF    FC6.5
03436:  MOVLW  21
03438:  MOVWF  FC6
0343A:  MOVLW  40
0343C:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0343E:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
03440:  MOVF   FC9,W
03442:  MOVLW  0C
03444:  MOVWF  FC9
03446:  RRCF   FC7,W
03448:  BNC   3446
0344A:  MOVFF  FC9,8A8
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0344E:  MOVF   FC9,W
03450:  MOVFF  8A8,FC9
03454:  RRCF   FC7,W
03456:  BNC   3454
03458:  MOVFF  FC9,72C
....................    output_bit(RTC_CS, DISABLE); 
0345C:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
0345E:  MOVLB  7
03460:  BCF    x2C.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
03462:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
03464:  MOVF   FC9,W
03466:  MOVLW  8C
03468:  MOVWF  FC9
0346A:  RRCF   FC7,W
0346C:  BNC   346A
0346E:  MOVFF  FC9,8A8
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
03472:  MOVF   FC9,W
03474:  MOVFF  72C,FC9
03478:  RRCF   FC7,W
0347A:  BNC   3478
0347C:  MOVFF  FC9,8A8
....................    output_bit(RTC_CS, DISABLE); 
03480:  BSF    F91.0
03482:  MOVLB  0
03484:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0DF82:  MOVLW  1A
0DF84:  MOVLB  8
0DF86:  MOVWF  x74
0DF88:  MOVLB  0
0DF8A:  CALL   2948
0DF8E:  MOVFF  01,4B
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0DF92:  MOVF   4B,F
0DF94:  BNZ   E002
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0DF96:  MOVLW  94
0DF98:  MOVWF  FF6
0DF9A:  MOVLW  0D
0DF9C:  MOVWF  FF7
0DF9E:  MOVLW  00
0DFA0:  MOVWF  FF8
0DFA2:  CLRF   1B
0DFA4:  BTFSC  FF2.7
0DFA6:  BSF    1B.7
0DFA8:  BCF    FF2.7
0DFAA:  MOVLW  05
0DFAC:  MOVLB  A
0DFAE:  MOVWF  x18
0DFB0:  MOVLB  0
0DFB2:  CALL   1006
0DFB6:  BTFSC  1B.7
0DFB8:  BSF    FF2.7
0DFBA:  CLRF   1B
0DFBC:  BTFSC  FF2.7
0DFBE:  BSF    1B.7
0DFC0:  BCF    FF2.7
0DFC2:  MOVFF  726,A18
0DFC6:  MOVLW  01
0DFC8:  MOVLB  A
0DFCA:  MOVWF  x19
0DFCC:  MOVLB  0
0DFCE:  CALL   0F88
0DFD2:  BTFSC  1B.7
0DFD4:  BSF    FF2.7
0DFD6:  MOVLW  2F
0DFD8:  BTFSS  F9E.4
0DFDA:  BRA    DFD8
0DFDC:  MOVWF  FAD
0DFDE:  CLRF   1B
0DFE0:  BTFSC  FF2.7
0DFE2:  BSF    1B.7
0DFE4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0DFE6:  MOVFF  725,A18
0DFEA:  MOVLW  01
0DFEC:  MOVLB  A
0DFEE:  MOVWF  x19
0DFF0:  MOVLB  0
0DFF2:  CALL   0F88
0DFF6:  BTFSC  1B.7
0DFF8:  BSF    FF2.7
0DFFA:  MOVLW  2F
0DFFC:  BTFSS  F9E.4
0DFFE:  BRA    DFFC
0E000:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0E002:  DECFSZ 4B,W
0E004:  BRA    E072
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0E006:  MOVLW  A0
0E008:  MOVWF  FF6
0E00A:  MOVLW  0D
0E00C:  MOVWF  FF7
0E00E:  MOVLW  00
0E010:  MOVWF  FF8
0E012:  CLRF   1B
0E014:  BTFSC  FF2.7
0E016:  BSF    1B.7
0E018:  BCF    FF2.7
0E01A:  MOVLW  05
0E01C:  MOVLB  A
0E01E:  MOVWF  x18
0E020:  MOVLB  0
0E022:  CALL   1006
0E026:  BTFSC  1B.7
0E028:  BSF    FF2.7
0E02A:  CLRF   1B
0E02C:  BTFSC  FF2.7
0E02E:  BSF    1B.7
0E030:  BCF    FF2.7
0E032:  MOVFF  725,A18
0E036:  MOVLW  01
0E038:  MOVLB  A
0E03A:  MOVWF  x19
0E03C:  MOVLB  0
0E03E:  CALL   0F88
0E042:  BTFSC  1B.7
0E044:  BSF    FF2.7
0E046:  MOVLW  2F
0E048:  BTFSS  F9E.4
0E04A:  BRA    E048
0E04C:  MOVWF  FAD
0E04E:  CLRF   1B
0E050:  BTFSC  FF2.7
0E052:  BSF    1B.7
0E054:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0E056:  MOVFF  726,A18
0E05A:  MOVLW  01
0E05C:  MOVLB  A
0E05E:  MOVWF  x19
0E060:  MOVLB  0
0E062:  CALL   0F88
0E066:  BTFSC  1B.7
0E068:  BSF    FF2.7
0E06A:  MOVLW  2F
0E06C:  BTFSS  F9E.4
0E06E:  BRA    E06C
0E070:  MOVWF  FAD
0E072:  CLRF   1B
0E074:  BTFSC  FF2.7
0E076:  BSF    1B.7
0E078:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0E07A:  MOVFF  727,A18
0E07E:  MOVLW  01
0E080:  MOVLB  A
0E082:  MOVWF  x19
0E084:  MOVLB  0
0E086:  CALL   0F88
0E08A:  BTFSC  1B.7
0E08C:  BSF    FF2.7
0E08E:  MOVLW  20
0E090:  BTFSS  F9E.4
0E092:  BRA    E090
0E094:  MOVWF  FAD
0E096:  CLRF   1B
0E098:  BTFSC  FF2.7
0E09A:  BSF    1B.7
0E09C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E09E:  MOVFF  723,A18
0E0A2:  MOVLW  01
0E0A4:  MOVLB  A
0E0A6:  MOVWF  x19
0E0A8:  MOVLB  0
0E0AA:  CALL   0F88
0E0AE:  BTFSC  1B.7
0E0B0:  BSF    FF2.7
0E0B2:  MOVLW  3A
0E0B4:  BTFSS  F9E.4
0E0B6:  BRA    E0B4
0E0B8:  MOVWF  FAD
0E0BA:  CLRF   1B
0E0BC:  BTFSC  FF2.7
0E0BE:  BSF    1B.7
0E0C0:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E0C2:  MOVFF  722,A18
0E0C6:  MOVLW  01
0E0C8:  MOVLB  A
0E0CA:  MOVWF  x19
0E0CC:  MOVLB  0
0E0CE:  CALL   0F88
0E0D2:  BTFSC  1B.7
0E0D4:  BSF    FF2.7
0E0D6:  MOVLW  3A
0E0D8:  BTFSS  F9E.4
0E0DA:  BRA    E0D8
0E0DC:  MOVWF  FAD
0E0DE:  CLRF   1B
0E0E0:  BTFSC  FF2.7
0E0E2:  BSF    1B.7
0E0E4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E0E6:  MOVFF  721,A18
0E0EA:  MOVLW  01
0E0EC:  MOVLB  A
0E0EE:  MOVWF  x19
0E0F0:  MOVLB  0
0E0F2:  CALL   0F88
0E0F6:  BTFSC  1B.7
0E0F8:  BSF    FF2.7
0E0FA:  MOVLW  0A
0E0FC:  BTFSS  F9E.4
0E0FE:  BRA    E0FC
0E100:  MOVWF  FAD
0E102:  MOVLW  0D
0E104:  BTFSS  F9E.4
0E106:  BRA    E104
0E108:  MOVWF  FAD
0E10A:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
032C2:  MOVLB  8
032C4:  CLRF   xCA
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
032C6:  BCF    FC6.5
032C8:  MOVLW  21
032CA:  MOVWF  FC6
032CC:  MOVLW  40
032CE:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
032D0:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
032D2:  MOVF   FC9,W
032D4:  CLRF   FC9
032D6:  RRCF   FC7,W
032D8:  BNC   32D6
032DA:  MOVFF  FC9,8CA
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
032DE:  MOVF   FC9,W
032E0:  MOVFF  8CA,FC9
032E4:  RRCF   FC7,W
032E6:  BNC   32E4
032E8:  MOVFF  FC9,728
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
032EC:  MOVF   FC9,W
032EE:  MOVFF  8CA,FC9
032F2:  RRCF   FC7,W
032F4:  BNC   32F2
032F6:  MOVFF  FC9,721
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
032FA:  MOVF   FC9,W
032FC:  MOVFF  8CA,FC9
03300:  RRCF   FC7,W
03302:  BNC   3300
03304:  MOVFF  FC9,722
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
03308:  MOVF   FC9,W
0330A:  MOVFF  8CA,FC9
0330E:  RRCF   FC7,W
03310:  BNC   330E
03312:  MOVFF  FC9,723
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
03316:  MOVF   FC9,W
03318:  MOVFF  8CA,FC9
0331C:  RRCF   FC7,W
0331E:  BNC   331C
03320:  MOVFF  FC9,724
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
03324:  MOVF   FC9,W
03326:  MOVFF  8CA,FC9
0332A:  RRCF   FC7,W
0332C:  BNC   332A
0332E:  MOVFF  FC9,725
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
03332:  MOVF   FC9,W
03334:  MOVFF  8CA,FC9
03338:  RRCF   FC7,W
0333A:  BNC   3338
0333C:  MOVFF  FC9,726
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
03340:  MOVF   FC9,W
03342:  MOVFF  8CA,FC9
03346:  RRCF   FC7,W
03348:  BNC   3346
0334A:  MOVFF  FC9,727
....................    output_bit(RTC_CS, DISABLE); 
0334E:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
03350:  MOVFF  721,8CB
03354:  MOVLB  0
03356:  RCALL  3290
03358:  MOVFF  01,721
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
0335C:  MOVFF  722,8CB
03360:  RCALL  3290
03362:  MOVFF  01,722
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
03366:  MOVFF  723,8CB
0336A:  RCALL  3290
0336C:  MOVFF  01,723
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
03370:  MOVFF  725,8CB
03374:  RCALL  3290
03376:  MOVFF  01,725
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
0337A:  MOVFF  726,8CB
0337E:  RCALL  3290
03380:  MOVFF  01,726
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
03384:  MOVFF  727,8CB
03388:  RCALL  3290
0338A:  MOVFF  01,727
0338E:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DCC:  MOVLB  A
00DCE:  CLRF   x0F
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DD0:  BCF    FC6.5
00DD2:  MOVLW  21
00DD4:  MOVWF  FC6
00DD6:  MOVLW  40
00DD8:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00DDA:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00DDC:  MOVF   FC9,W
00DDE:  MOVLW  0F
00DE0:  MOVWF  FC9
00DE2:  RRCF   FC7,W
00DE4:  BNC   0DE2
00DE6:  MOVFF  FC9,A0F
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00DEA:  MOVF   FC9,W
00DEC:  MOVFF  A0F,FC9
00DF0:  RRCF   FC7,W
00DF2:  BNC   0DF0
00DF4:  MOVFF  FC9,72F
....................    output_bit(RTC_CS, DISABLE); 
00DF8:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00DFA:  BCF    49.2
00DFC:  MOVLB  0
00DFE:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E1E2:  MOVF   4B,F
0E1E4:  BNZ   E252
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E1E6:  MOVLW  AC
0E1E8:  MOVWF  FF6
0E1EA:  MOVLW  0D
0E1EC:  MOVWF  FF7
0E1EE:  MOVLW  00
0E1F0:  MOVWF  FF8
0E1F2:  CLRF   1B
0E1F4:  BTFSC  FF2.7
0E1F6:  BSF    1B.7
0E1F8:  BCF    FF2.7
0E1FA:  MOVLW  05
0E1FC:  MOVLB  A
0E1FE:  MOVWF  x18
0E200:  MOVLB  0
0E202:  CALL   1006
0E206:  BTFSC  1B.7
0E208:  BSF    FF2.7
0E20A:  CLRF   1B
0E20C:  BTFSC  FF2.7
0E20E:  BSF    1B.7
0E210:  BCF    FF2.7
0E212:  MOVFF  72A,A18
0E216:  MOVLW  01
0E218:  MOVLB  A
0E21A:  MOVWF  x19
0E21C:  MOVLB  0
0E21E:  CALL   0F88
0E222:  BTFSC  1B.7
0E224:  BSF    FF2.7
0E226:  MOVLW  2F
0E228:  BTFSS  F9E.4
0E22A:  BRA    E228
0E22C:  MOVWF  FAD
0E22E:  CLRF   1B
0E230:  BTFSC  FF2.7
0E232:  BSF    1B.7
0E234:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E236:  MOVFF  72B,A18
0E23A:  MOVLW  01
0E23C:  MOVLB  A
0E23E:  MOVWF  x19
0E240:  MOVLB  0
0E242:  CALL   0F88
0E246:  BTFSC  1B.7
0E248:  BSF    FF2.7
0E24A:  MOVLW  2F
0E24C:  BTFSS  F9E.4
0E24E:  BRA    E24C
0E250:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E252:  DECFSZ 4B,W
0E254:  BRA    E2C2
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E256:  MOVLW  B8
0E258:  MOVWF  FF6
0E25A:  MOVLW  0D
0E25C:  MOVWF  FF7
0E25E:  MOVLW  00
0E260:  MOVWF  FF8
0E262:  CLRF   1B
0E264:  BTFSC  FF2.7
0E266:  BSF    1B.7
0E268:  BCF    FF2.7
0E26A:  MOVLW  05
0E26C:  MOVLB  A
0E26E:  MOVWF  x18
0E270:  MOVLB  0
0E272:  CALL   1006
0E276:  BTFSC  1B.7
0E278:  BSF    FF2.7
0E27A:  CLRF   1B
0E27C:  BTFSC  FF2.7
0E27E:  BSF    1B.7
0E280:  BCF    FF2.7
0E282:  MOVFF  72B,A18
0E286:  MOVLW  01
0E288:  MOVLB  A
0E28A:  MOVWF  x19
0E28C:  MOVLB  0
0E28E:  CALL   0F88
0E292:  BTFSC  1B.7
0E294:  BSF    FF2.7
0E296:  MOVLW  2F
0E298:  BTFSS  F9E.4
0E29A:  BRA    E298
0E29C:  MOVWF  FAD
0E29E:  CLRF   1B
0E2A0:  BTFSC  FF2.7
0E2A2:  BSF    1B.7
0E2A4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E2A6:  MOVFF  72A,A18
0E2AA:  MOVLW  01
0E2AC:  MOVLB  A
0E2AE:  MOVWF  x19
0E2B0:  MOVLB  0
0E2B2:  CALL   0F88
0E2B6:  BTFSC  1B.7
0E2B8:  BSF    FF2.7
0E2BA:  MOVLW  2F
0E2BC:  BTFSS  F9E.4
0E2BE:  BRA    E2BC
0E2C0:  MOVWF  FAD
0E2C2:  CLRF   1B
0E2C4:  BTFSC  FF2.7
0E2C6:  BSF    1B.7
0E2C8:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E2CA:  MOVFF  729,A18
0E2CE:  MOVLW  01
0E2D0:  MOVLB  A
0E2D2:  MOVWF  x19
0E2D4:  MOVLB  0
0E2D6:  CALL   0F88
0E2DA:  BTFSC  1B.7
0E2DC:  BSF    FF2.7
0E2DE:  MOVLW  20
0E2E0:  BTFSS  F9E.4
0E2E2:  BRA    E2E0
0E2E4:  MOVWF  FAD
0E2E6:  CLRF   1B
0E2E8:  BTFSC  FF2.7
0E2EA:  BSF    1B.7
0E2EC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E2EE:  MOVFF  72C,A18
0E2F2:  MOVLW  01
0E2F4:  MOVLB  A
0E2F6:  MOVWF  x19
0E2F8:  MOVLB  0
0E2FA:  CALL   0F88
0E2FE:  BTFSC  1B.7
0E300:  BSF    FF2.7
0E302:  MOVLW  3A
0E304:  BTFSS  F9E.4
0E306:  BRA    E304
0E308:  MOVWF  FAD
0E30A:  CLRF   1B
0E30C:  BTFSC  FF2.7
0E30E:  BSF    1B.7
0E310:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E312:  MOVFF  72D,A18
0E316:  MOVLW  01
0E318:  MOVLB  A
0E31A:  MOVWF  x19
0E31C:  MOVLB  0
0E31E:  CALL   0F88
0E322:  BTFSC  1B.7
0E324:  BSF    FF2.7
0E326:  MOVLW  3A
0E328:  BTFSS  F9E.4
0E32A:  BRA    E328
0E32C:  MOVWF  FAD
0E32E:  CLRF   1B
0E330:  BTFSC  FF2.7
0E332:  BSF    1B.7
0E334:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E336:  MOVFF  72E,A18
0E33A:  MOVLW  01
0E33C:  MOVLB  A
0E33E:  MOVWF  x19
0E340:  MOVLB  0
0E342:  CALL   0F88
0E346:  BTFSC  1B.7
0E348:  BSF    FF2.7
0E34A:  MOVLW  0A
0E34C:  BTFSS  F9E.4
0E34E:  BRA    E34C
0E350:  MOVWF  FAD
0E352:  MOVLW  0D
0E354:  BTFSS  F9E.4
0E356:  BRA    E354
0E358:  MOVWF  FAD
0E35A:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E10C:  MOVLB  8
0E10E:  CLRF   x94
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E110:  BCF    FC6.5
0E112:  MOVLW  21
0E114:  MOVWF  FC6
0E116:  MOVLW  40
0E118:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E11A:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E11C:  MOVF   FC9,W
0E11E:  MOVLW  0A
0E120:  MOVWF  FC9
0E122:  RRCF   FC7,W
0E124:  BNC   E122
0E126:  MOVFF  FC9,894
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E12A:  MOVF   FC9,W
0E12C:  MOVFF  894,FC9
0E130:  RRCF   FC7,W
0E132:  BNC   E130
0E134:  MOVFF  FC9,72A
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E138:  MOVF   FC9,W
0E13A:  MOVFF  894,FC9
0E13E:  RRCF   FC7,W
0E140:  BNC   E13E
0E142:  MOVFF  FC9,72B
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E146:  MOVF   FC9,W
0E148:  MOVFF  894,FC9
0E14C:  RRCF   FC7,W
0E14E:  BNC   E14C
0E150:  MOVFF  FC9,72C
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E154:  MOVF   FC9,W
0E156:  MOVFF  894,FC9
0E15A:  RRCF   FC7,W
0E15C:  BNC   E15A
0E15E:  MOVFF  FC9,72D
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E162:  MOVF   FC9,W
0E164:  MOVFF  894,FC9
0E168:  RRCF   FC7,W
0E16A:  BNC   E168
0E16C:  MOVFF  FC9,72E
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E170:  MOVF   FC9,W
0E172:  MOVFF  894,FC9
0E176:  RRCF   FC7,W
0E178:  BNC   E176
0E17A:  MOVFF  FC9,72F
....................    output_bit(RTC_CS, DISABLE); 
0E17E:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E180:  MOVLW  1F
0E182:  MOVLB  7
0E184:  ANDWF  x2A,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E186:  MOVFF  72A,8CB
0E18A:  MOVLB  0
0E18C:  CALL   3290
0E190:  MOVFF  01,72A
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E194:  MOVLW  3F
0E196:  MOVLB  7
0E198:  ANDWF  x2B,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E19A:  MOVFF  72B,8CB
0E19E:  MOVLB  0
0E1A0:  CALL   3290
0E1A4:  MOVFF  01,72B
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E1A8:  MOVLW  3F
0E1AA:  MOVLB  7
0E1AC:  ANDWF  x2C,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E1AE:  MOVFF  72C,8CB
0E1B2:  MOVLB  0
0E1B4:  CALL   3290
0E1B8:  MOVFF  01,72C
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E1BC:  MOVLB  7
0E1BE:  BCF    x2D.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E1C0:  MOVFF  72D,8CB
0E1C4:  MOVLB  0
0E1C6:  CALL   3290
0E1CA:  MOVFF  01,72D
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E1CE:  MOVLB  7
0E1D0:  BCF    x2E.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E1D2:  MOVFF  72E,8CB
0E1D6:  MOVLB  0
0E1D8:  CALL   3290
0E1DC:  MOVFF  01,72E
0E1E0:  RETURN 0
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
1725A:  MOVLW  08
1725C:  MOVWF  FEA
1725E:  MOVLW  66
17260:  MOVWF  FE9
17262:  CLRF   00
17264:  CLRF   02
17266:  MOVLW  0C
17268:  MOVWF  01
1726A:  CALL   34A4
....................  
....................    time_error = 0; 
1726E:  MOVLB  8
17270:  CLRF   x72
....................     
....................    fputc('[', COM_A); 
17272:  MOVLW  5B
17274:  MOVLB  0
17276:  CALL   ADAA
....................     
....................    for (n=0; n<12; ++n){ 
1727A:  MOVLB  8
1727C:  CLRF   x65
1727E:  MOVF   x65,W
17280:  SUBLW  0B
17282:  BNC   172C8
....................       c = fgetc(COM_A); 
17284:  MOVLB  0
17286:  CALL   0E1A
1728A:  MOVFF  01,864
....................       if (com_echo == TRUE) 
1728E:  DECFSZ 48,W
17290:  BRA    1729C
....................       { 
....................          fputc(c, COM_A); 
17292:  MOVLB  8
17294:  MOVF   x64,W
17296:  MOVLB  0
17298:  CALL   ADAA
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
1729C:  MOVLB  8
1729E:  MOVF   x64,W
172A0:  SUBLW  2F
172A2:  BC    172BE
172A4:  MOVF   x64,W
172A6:  SUBLW  39
172A8:  BNC   172BE
172AA:  CLRF   03
172AC:  MOVF   x65,W
172AE:  ADDLW  66
172B0:  MOVWF  FE9
172B2:  MOVLW  08
172B4:  ADDWFC 03,W
172B6:  MOVWF  FEA
172B8:  MOVFF  864,FEF
172BC:  BRA    172C4
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
172BE:  MOVLW  01
172C0:  MOVWF  x72
....................          break; 
172C2:  BRA    172C8
....................       } 
172C4:  INCF   x65,F
172C6:  BRA    1727E
....................    } 
....................     
....................    if (time_error == 0){ 
172C8:  MOVF   x72,F
172CA:  BTFSS  FD8.2
172CC:  BRA    17604
....................     
....................       fputc(']', COM_A); 
172CE:  MOVLW  5D
172D0:  MOVLB  0
172D2:  CALL   ADAA
....................        
....................       for (n=0; n<12; ++n){ 
172D6:  MOVLB  8
172D8:  CLRF   x65
172DA:  MOVF   x65,W
172DC:  SUBLW  0B
172DE:  BNC   17310
....................          t_entry[n] = (t_entry[n] - 48); 
172E0:  CLRF   03
172E2:  MOVF   x65,W
172E4:  ADDLW  66
172E6:  MOVWF  01
172E8:  MOVLW  08
172EA:  ADDWFC 03,F
172EC:  MOVFF  03,874
172F0:  CLRF   03
172F2:  MOVF   x65,W
172F4:  ADDLW  66
172F6:  MOVWF  FE9
172F8:  MOVLW  08
172FA:  ADDWFC 03,W
172FC:  MOVWF  FEA
172FE:  MOVLW  30
17300:  SUBWF  FEF,W
17302:  MOVFF  874,FEA
17306:  MOVFF  01,FE9
1730A:  MOVWF  FEF
1730C:  INCF   x65,F
1730E:  BRA    172DA
....................       } 
....................        
....................       if (RTCfmt == 0) 
17310:  MOVF   4B,F
17312:  BNZ   17350
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
17314:  MOVF   x66,W
17316:  MULLW  0A
17318:  MOVF   FF3,W
1731A:  ADDWF  x67,W
1731C:  MOVLB  7
1731E:  MOVWF  x34
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17320:  MOVF   x34,F
17322:  BZ    1732A
17324:  MOVF   x34,W
17326:  SUBLW  0C
17328:  BC    17332
1732A:  MOVLW  02
1732C:  MOVLB  8
1732E:  MOVWF  x72
17330:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
17332:  MOVLB  8
17334:  MOVF   x68,W
17336:  MULLW  0A
17338:  MOVF   FF3,W
1733A:  ADDWF  x69,W
1733C:  MOVLB  7
1733E:  MOVWF  x33
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17340:  MOVF   x33,F
17342:  BZ    1734A
17344:  MOVF   x33,W
17346:  SUBLW  1F
17348:  BC    17352
1734A:  MOVLW  02
1734C:  MOVLB  8
1734E:  MOVWF  x72
17350:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17352:  DECFSZ 4B,W
17354:  BRA    17396
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
17356:  MOVLB  8
17358:  MOVF   x66,W
1735A:  MULLW  0A
1735C:  MOVF   FF3,W
1735E:  ADDWF  x67,W
17360:  MOVLB  7
17362:  MOVWF  x33
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17364:  MOVF   x33,F
17366:  BZ    1736E
17368:  MOVF   x33,W
1736A:  SUBLW  1F
1736C:  BC    17376
1736E:  MOVLW  02
17370:  MOVLB  8
17372:  MOVWF  x72
17374:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
17376:  MOVLB  8
17378:  MOVF   x68,W
1737A:  MULLW  0A
1737C:  MOVF   FF3,W
1737E:  ADDWF  x69,W
17380:  MOVLB  7
17382:  MOVWF  x34
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17384:  MOVF   x34,F
17386:  BZ    1738E
17388:  MOVF   x34,W
1738A:  SUBLW  0C
1738C:  BC    17396
1738E:  MOVLW  02
17390:  MOVLB  8
17392:  MOVWF  x72
17394:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
17396:  MOVLB  8
17398:  MOVF   x6A,W
1739A:  MULLW  0A
1739C:  MOVF   FF3,W
1739E:  ADDWF  x6B,W
173A0:  MOVLB  7
173A2:  MOVWF  x35
....................       if (RTC_Yr_Data > 99) time_error = 2;  
173A4:  MOVF   x35,W
173A6:  SUBLW  63
173A8:  BC    173B2
173AA:  MOVLW  02
173AC:  MOVLB  8
173AE:  MOVWF  x72
173B0:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
173B2:  MOVLB  8
173B4:  MOVF   x6C,W
173B6:  MULLW  0A
173B8:  MOVF   FF3,W
173BA:  ADDWF  x6D,W
173BC:  MOVLB  7
173BE:  MOVWF  x32
....................       if (RTC_Hr_Data > 24) time_error = 2;  
173C0:  MOVF   x32,W
173C2:  SUBLW  18
173C4:  BC    173CE
173C6:  MOVLW  02
173C8:  MOVLB  8
173CA:  MOVWF  x72
173CC:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
173CE:  MOVLB  8
173D0:  MOVF   x6E,W
173D2:  MULLW  0A
173D4:  MOVF   FF3,W
173D6:  ADDWF  x6F,W
173D8:  MOVLB  7
173DA:  MOVWF  x31
....................       if (RTC_Min_Data > 60) time_error = 2;  
173DC:  MOVF   x31,W
173DE:  SUBLW  3C
173E0:  BC    173EA
173E2:  MOVLW  02
173E4:  MOVLB  8
173E6:  MOVWF  x72
173E8:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
173EA:  MOVLB  8
173EC:  MOVF   x70,W
173EE:  MULLW  0A
173F0:  MOVF   FF3,W
173F2:  ADDWF  x71,W
173F4:  MOVLB  7
173F6:  MOVWF  x30
....................       if (RTC_Sec_Data > 60) time_error = 2; 
173F8:  MOVF   x30,W
173FA:  SUBLW  3C
173FC:  BC    17406
173FE:  MOVLW  02
17400:  MOVLB  8
17402:  MOVWF  x72
17404:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
17406:  MOVF   4B,F
17408:  BTFSS  FD8.2
1740A:  BRA    174FE
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
1740C:  MOVLW  0A
1740E:  BTFSS  F9E.4
17410:  BRA    1740E
17412:  MOVWF  FAD
17414:  MOVLW  0D
17416:  BTFSS  F9E.4
17418:  BRA    17416
1741A:  MOVWF  FAD
1741C:  CLRF   1B
1741E:  BTFSC  FF2.7
17420:  BSF    1B.7
17422:  BCF    FF2.7
17424:  MOVFF  734,A18
17428:  MOVLW  01
1742A:  MOVLB  A
1742C:  MOVWF  x19
1742E:  MOVLB  0
17430:  CALL   0F88
17434:  BTFSC  1B.7
17436:  BSF    FF2.7
17438:  MOVLW  2F
1743A:  BTFSS  F9E.4
1743C:  BRA    1743A
1743E:  MOVWF  FAD
17440:  CLRF   1B
17442:  BTFSC  FF2.7
17444:  BSF    1B.7
17446:  BCF    FF2.7
17448:  MOVFF  733,A18
1744C:  MOVLW  01
1744E:  MOVLB  A
17450:  MOVWF  x19
17452:  MOVLB  0
17454:  CALL   0F88
17458:  BTFSC  1B.7
1745A:  BSF    FF2.7
1745C:  MOVLW  2F
1745E:  BTFSS  F9E.4
17460:  BRA    1745E
17462:  MOVWF  FAD
17464:  CLRF   1B
17466:  BTFSC  FF2.7
17468:  BSF    1B.7
1746A:  BCF    FF2.7
1746C:  MOVFF  735,A18
17470:  MOVLW  01
17472:  MOVLB  A
17474:  MOVWF  x19
17476:  MOVLB  0
17478:  CALL   0F88
1747C:  BTFSC  1B.7
1747E:  BSF    FF2.7
17480:  MOVLW  20
17482:  BTFSS  F9E.4
17484:  BRA    17482
17486:  MOVWF  FAD
17488:  CLRF   1B
1748A:  BTFSC  FF2.7
1748C:  BSF    1B.7
1748E:  BCF    FF2.7
17490:  MOVFF  732,A18
17494:  MOVLW  01
17496:  MOVLB  A
17498:  MOVWF  x19
1749A:  MOVLB  0
1749C:  CALL   0F88
174A0:  BTFSC  1B.7
174A2:  BSF    FF2.7
174A4:  MOVLW  3A
174A6:  BTFSS  F9E.4
174A8:  BRA    174A6
174AA:  MOVWF  FAD
174AC:  CLRF   1B
174AE:  BTFSC  FF2.7
174B0:  BSF    1B.7
174B2:  BCF    FF2.7
174B4:  MOVFF  731,A18
174B8:  MOVLW  01
174BA:  MOVLB  A
174BC:  MOVWF  x19
174BE:  MOVLB  0
174C0:  CALL   0F88
174C4:  BTFSC  1B.7
174C6:  BSF    FF2.7
174C8:  MOVLW  3A
174CA:  BTFSS  F9E.4
174CC:  BRA    174CA
174CE:  MOVWF  FAD
174D0:  CLRF   1B
174D2:  BTFSC  FF2.7
174D4:  BSF    1B.7
174D6:  BCF    FF2.7
174D8:  MOVFF  730,A18
174DC:  MOVLW  01
174DE:  MOVLB  A
174E0:  MOVWF  x19
174E2:  MOVLB  0
174E4:  CALL   0F88
174E8:  BTFSC  1B.7
174EA:  BSF    FF2.7
174EC:  MOVLW  0A
174EE:  BTFSS  F9E.4
174F0:  BRA    174EE
174F2:  MOVWF  FAD
174F4:  MOVLW  0D
174F6:  BTFSS  F9E.4
174F8:  BRA    174F6
174FA:  MOVWF  FAD
174FC:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
174FE:  DECFSZ 4B,W
17500:  BRA    175F4
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
17502:  MOVLW  0A
17504:  BTFSS  F9E.4
17506:  BRA    17504
17508:  MOVWF  FAD
1750A:  MOVLW  0D
1750C:  BTFSS  F9E.4
1750E:  BRA    1750C
17510:  MOVWF  FAD
17512:  CLRF   1B
17514:  BTFSC  FF2.7
17516:  BSF    1B.7
17518:  BCF    FF2.7
1751A:  MOVFF  733,A18
1751E:  MOVLW  01
17520:  MOVLB  A
17522:  MOVWF  x19
17524:  MOVLB  0
17526:  CALL   0F88
1752A:  BTFSC  1B.7
1752C:  BSF    FF2.7
1752E:  MOVLW  2F
17530:  BTFSS  F9E.4
17532:  BRA    17530
17534:  MOVWF  FAD
17536:  CLRF   1B
17538:  BTFSC  FF2.7
1753A:  BSF    1B.7
1753C:  BCF    FF2.7
1753E:  MOVFF  734,A18
17542:  MOVLW  01
17544:  MOVLB  A
17546:  MOVWF  x19
17548:  MOVLB  0
1754A:  CALL   0F88
1754E:  BTFSC  1B.7
17550:  BSF    FF2.7
17552:  MOVLW  2F
17554:  BTFSS  F9E.4
17556:  BRA    17554
17558:  MOVWF  FAD
1755A:  CLRF   1B
1755C:  BTFSC  FF2.7
1755E:  BSF    1B.7
17560:  BCF    FF2.7
17562:  MOVFF  735,A18
17566:  MOVLW  01
17568:  MOVLB  A
1756A:  MOVWF  x19
1756C:  MOVLB  0
1756E:  CALL   0F88
17572:  BTFSC  1B.7
17574:  BSF    FF2.7
17576:  MOVLW  20
17578:  BTFSS  F9E.4
1757A:  BRA    17578
1757C:  MOVWF  FAD
1757E:  CLRF   1B
17580:  BTFSC  FF2.7
17582:  BSF    1B.7
17584:  BCF    FF2.7
17586:  MOVFF  732,A18
1758A:  MOVLW  01
1758C:  MOVLB  A
1758E:  MOVWF  x19
17590:  MOVLB  0
17592:  CALL   0F88
17596:  BTFSC  1B.7
17598:  BSF    FF2.7
1759A:  MOVLW  3A
1759C:  BTFSS  F9E.4
1759E:  BRA    1759C
175A0:  MOVWF  FAD
175A2:  CLRF   1B
175A4:  BTFSC  FF2.7
175A6:  BSF    1B.7
175A8:  BCF    FF2.7
175AA:  MOVFF  731,A18
175AE:  MOVLW  01
175B0:  MOVLB  A
175B2:  MOVWF  x19
175B4:  MOVLB  0
175B6:  CALL   0F88
175BA:  BTFSC  1B.7
175BC:  BSF    FF2.7
175BE:  MOVLW  3A
175C0:  BTFSS  F9E.4
175C2:  BRA    175C0
175C4:  MOVWF  FAD
175C6:  CLRF   1B
175C8:  BTFSC  FF2.7
175CA:  BSF    1B.7
175CC:  BCF    FF2.7
175CE:  MOVFF  730,A18
175D2:  MOVLW  01
175D4:  MOVLB  A
175D6:  MOVWF  x19
175D8:  MOVLB  0
175DA:  CALL   0F88
175DE:  BTFSC  1B.7
175E0:  BSF    FF2.7
175E2:  MOVLW  0A
175E4:  BTFSS  F9E.4
175E6:  BRA    175E4
175E8:  MOVWF  FAD
175EA:  MOVLW  0D
175EC:  BTFSS  F9E.4
175EE:  BRA    175EC
175F0:  MOVWF  FAD
175F2:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
175F4:  MOVLB  8
175F6:  MOVF   x72,W
175F8:  SUBLW  02
175FA:  BNZ   17602
175FC:  MOVLB  0
175FE:  BRA    1723A
17600:  MOVLB  8
....................  
....................    } 
17602:  BRA    1760C
....................    else cmd_arg(); 
17604:  MOVLB  0
17606:  CALL   AF66
1760A:  MOVLB  8
....................     
....................    return time_error; 
1760C:  MOVFF  872,01
17610:  MOVLB  0
17612:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
17652:  RCALL  1725A
17654:  MOVFF  01,862
....................     
....................    if (time_error ==0 ){ 
17658:  MOVLB  8
1765A:  MOVF   x62,F
1765C:  BTFSS  FD8.2
1765E:  BRA    17796
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
17660:  BCF    FC6.5
17662:  MOVLW  21
17664:  MOVWF  FC6
17666:  MOVLW  40
17668:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
1766A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
1766C:  MOVF   FC9,W
1766E:  MOVLW  86
17670:  MOVWF  FC9
17672:  RRCF   FC7,W
17674:  BNC   17672
17676:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
1767A:  MOVFF  734,864
1767E:  MOVLB  0
17680:  RCALL  17614
17682:  MOVFF  01,864
17686:  MOVF   FC9,W
17688:  MOVFF  01,FC9
1768C:  RRCF   FC7,W
1768E:  BNC   1768C
17690:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
17694:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17696:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
17698:  MOVF   FC9,W
1769A:  MOVLW  85
1769C:  MOVWF  FC9
1769E:  RRCF   FC7,W
176A0:  BNC   1769E
176A2:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
176A6:  MOVFF  733,864
176AA:  RCALL  17614
176AC:  MOVFF  01,864
176B0:  MOVF   FC9,W
176B2:  MOVFF  01,FC9
176B6:  RRCF   FC7,W
176B8:  BNC   176B6
176BA:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
176BE:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
176C0:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
176C2:  MOVF   FC9,W
176C4:  MOVLW  87
176C6:  MOVWF  FC9
176C8:  RRCF   FC7,W
176CA:  BNC   176C8
176CC:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
176D0:  MOVFF  735,864
176D4:  RCALL  17614
176D6:  MOVFF  01,864
176DA:  MOVF   FC9,W
176DC:  MOVFF  01,FC9
176E0:  RRCF   FC7,W
176E2:  BNC   176E0
176E4:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
176E8:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
176EA:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
176EC:  MOVF   FC9,W
176EE:  MOVLW  83
176F0:  MOVWF  FC9
176F2:  RRCF   FC7,W
176F4:  BNC   176F2
176F6:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
176FA:  MOVFF  732,864
176FE:  RCALL  17614
17700:  MOVFF  01,864
17704:  MOVF   FC9,W
17706:  MOVFF  01,FC9
1770A:  RRCF   FC7,W
1770C:  BNC   1770A
1770E:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
17712:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17714:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
17716:  MOVF   FC9,W
17718:  MOVLW  82
1771A:  MOVWF  FC9
1771C:  RRCF   FC7,W
1771E:  BNC   1771C
17720:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
17724:  MOVFF  731,864
17728:  RCALL  17614
1772A:  MOVFF  01,864
1772E:  MOVF   FC9,W
17730:  MOVFF  01,FC9
17734:  RRCF   FC7,W
17736:  BNC   17734
17738:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
1773C:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
1773E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
17740:  MOVF   FC9,W
17742:  MOVLW  81
17744:  MOVWF  FC9
17746:  RRCF   FC7,W
17748:  BNC   17746
1774A:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
1774E:  MOVFF  730,864
17752:  RCALL  17614
17754:  MOVFF  01,864
17758:  MOVF   FC9,W
1775A:  MOVFF  01,FC9
1775E:  RRCF   FC7,W
17760:  BNC   1775E
17762:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
17766:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17768:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
1776A:  MOVF   FC9,W
1776C:  MOVLW  80
1776E:  MOVWF  FC9
17770:  RRCF   FC7,W
17772:  BNC   17770
17774:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
17778:  MOVLB  8
1777A:  CLRF   x64
1777C:  MOVLB  0
1777E:  RCALL  17614
17780:  MOVFF  01,864
17784:  MOVF   FC9,W
17786:  MOVFF  01,FC9
1778A:  RRCF   FC7,W
1778C:  BNC   1778A
1778E:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
17792:  BSF    F91.0
17794:  MOVLB  8
....................    } 
17796:  MOVLB  0
17798:  GOTO   17824 (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
1831C:  CALL   E10C
....................     
....................    time_error = get_time(); 
18320:  CALL   1725A
18324:  MOVFF  01,862
....................     
....................    if (time_error == 0 ){ 
18328:  MOVLB  8
1832A:  MOVF   x62,F
1832C:  BTFSS  FD8.2
1832E:  BRA    18464
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
18330:  MOVFF  735,729
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
18334:  MOVLW  04
18336:  MOVWF  x66
18338:  MOVFF  729,867
1833C:  MOVLB  0
1833E:  CALL   3390
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
18342:  MOVFF  734,864
18346:  CALL   17614
1834A:  MOVFF  01,734
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
1834E:  MOVLB  7
18350:  BSF    x34.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
18352:  BCF    FC6.5
18354:  MOVLW  21
18356:  MOVWF  FC6
18358:  MOVLW  40
1835A:  MOVWF  FC7
....................       delay_us(10); 
1835C:  MOVLW  35
1835E:  MOVWF  00
18360:  DECFSZ 00,F
18362:  BRA    18360
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
18364:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
18366:  MOVF   FC9,W
18368:  MOVLW  8E
1836A:  MOVWF  FC9
1836C:  RRCF   FC7,W
1836E:  BNC   1836C
18370:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
18374:  MOVFF  730,864
18378:  MOVLB  0
1837A:  CALL   17614
1837E:  MOVFF  01,864
18382:  MOVF   FC9,W
18384:  MOVFF  01,FC9
18388:  RRCF   FC7,W
1838A:  BNC   18388
1838C:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
18390:  BSF    F91.0
....................       delay_us(1);            // Delays added 1.020A 
18392:  MOVLW  05
18394:  MOVWF  00
18396:  DECFSZ 00,F
18398:  BRA    18396
....................        
....................       output_bit(RTC_CS, ENABLE); 
1839A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
1839C:  MOVF   FC9,W
1839E:  MOVLW  8D
183A0:  MOVWF  FC9
183A2:  RRCF   FC7,W
183A4:  BNC   183A2
183A6:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
183AA:  MOVFF  731,864
183AE:  CALL   17614
183B2:  MOVFF  01,864
183B6:  MOVF   FC9,W
183B8:  MOVFF  01,FC9
183BC:  RRCF   FC7,W
183BE:  BNC   183BC
183C0:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
183C4:  BSF    F91.0
....................       delay_us(1); 
183C6:  MOVLW  05
183C8:  MOVWF  00
183CA:  DECFSZ 00,F
183CC:  BRA    183CA
....................        
....................       output_bit(RTC_CS, ENABLE); 
183CE:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
183D0:  MOVF   FC9,W
183D2:  MOVLW  8C
183D4:  MOVWF  FC9
183D6:  RRCF   FC7,W
183D8:  BNC   183D6
183DA:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
183DE:  MOVFF  732,864
183E2:  CALL   17614
183E6:  MOVFF  01,864
183EA:  MOVF   FC9,W
183EC:  MOVFF  01,FC9
183F0:  RRCF   FC7,W
183F2:  BNC   183F0
183F4:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
183F8:  BSF    F91.0
....................       delay_us(1);    
183FA:  MOVLW  05
183FC:  MOVWF  00
183FE:  DECFSZ 00,F
18400:  BRA    183FE
....................        
....................       output_bit(RTC_CS, ENABLE); 
18402:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
18404:  MOVF   FC9,W
18406:  MOVLW  8B
18408:  MOVWF  FC9
1840A:  RRCF   FC7,W
1840C:  BNC   1840A
1840E:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
18412:  MOVFF  733,864
18416:  CALL   17614
1841A:  MOVFF  01,864
1841E:  MOVF   FC9,W
18420:  MOVFF  01,FC9
18424:  RRCF   FC7,W
18426:  BNC   18424
18428:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE);  
1842C:  BSF    F91.0
....................       delay_us(1); 
1842E:  MOVLW  05
18430:  MOVWF  00
18432:  DECFSZ 00,F
18434:  BRA    18432
....................        
....................       output_bit(RTC_CS, ENABLE); 
18436:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8A);        // address - Month 
18438:  MOVF   FC9,W
1843A:  MOVLW  8A
1843C:  MOVWF  FC9
1843E:  RRCF   FC7,W
18440:  BNC   1843E
18442:  MOVFF  FC9,863
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
18446:  MOVF   FC9,W
18448:  MOVFF  734,FC9
1844C:  RRCF   FC7,W
1844E:  BNC   1844C
18450:  MOVFF  FC9,863
....................       output_bit(RTC_CS, DISABLE); 
18454:  BSF    F91.0
....................       delay_us(1); 
18456:  MOVLW  05
18458:  MOVWF  00
1845A:  DECFSZ 00,F
1845C:  BRA    1845A
....................     
....................    RTC_read_alarm(); 
1845E:  CALL   E10C
18462:  MOVLB  8
....................    } 
18464:  MOVLB  0
18466:  GOTO   1847C (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
15A08:  BCF    FC6.5
15A0A:  MOVLW  21
15A0C:  MOVWF  FC6
15A0E:  MOVLW  40
15A10:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
15A12:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
15A14:  MOVF   FC9,W
15A16:  MOVLW  8E
15A18:  MOVWF  FC9
15A1A:  RRCF   FC7,W
15A1C:  BNC   15A1A
15A1E:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(0b00000000);  // data 
15A22:  MOVF   FC9,W
15A24:  CLRF   FC9
15A26:  RRCF   FC7,W
15A28:  BNC   15A26
15A2A:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE); 
15A2E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A30:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15A32:  MOVF   FC9,W
15A34:  MOVLW  8D
15A36:  MOVWF  FC9
15A38:  RRCF   FC7,W
15A3A:  BNC   15A38
15A3C:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(0b10000000);  // data 
15A40:  MOVF   FC9,W
15A42:  MOVLW  80
15A44:  MOVWF  FC9
15A46:  RRCF   FC7,W
15A48:  BNC   15A46
15A4A:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE); 
15A4E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A50:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15A52:  MOVF   FC9,W
15A54:  MOVLW  8C
15A56:  MOVWF  FC9
15A58:  RRCF   FC7,W
15A5A:  BNC   15A58
15A5C:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(0b10000000);  // data 
15A60:  MOVF   FC9,W
15A62:  MOVLW  80
15A64:  MOVWF  FC9
15A66:  RRCF   FC7,W
15A68:  BNC   15A66
15A6A:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE); 
15A6E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A70:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15A72:  MOVF   FC9,W
15A74:  MOVLW  8B
15A76:  MOVWF  FC9
15A78:  RRCF   FC7,W
15A7A:  BNC   15A78
15A7C:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(0b11000000);  // data 
15A80:  MOVF   FC9,W
15A82:  MOVLW  C0
15A84:  MOVWF  FC9
15A86:  RRCF   FC7,W
15A88:  BNC   15A86
15A8A:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE);    
15A8E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15A90:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15A92:  MOVF   FC9,W
15A94:  MOVLW  8A
15A96:  MOVWF  FC9
15A98:  RRCF   FC7,W
15A9A:  BNC   15A98
15A9C:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(0b10000000);  // data 
15AA0:  MOVF   FC9,W
15AA2:  MOVLW  80
15AA4:  MOVWF  FC9
15AA6:  RRCF   FC7,W
15AA8:  BNC   15AA6
15AAA:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE); 
15AAE:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15AB0:  CALL   E10C
15AB4:  GOTO   16874 (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
15266:  MOVLB  8
15268:  CLRF   x64
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
1526A:  BCF    FC6.5
1526C:  MOVLW  21
1526E:  MOVWF  FC6
15270:  MOVLW  40
15272:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15274:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
15276:  MOVF   FC9,W
15278:  MOVLW  0A
1527A:  MOVWF  FC9
1527C:  RRCF   FC7,W
1527E:  BNC   1527C
15280:  MOVFF  FC9,864
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
15284:  MOVF   FC9,W
15286:  MOVFF  864,FC9
1528A:  RRCF   FC7,W
1528C:  BNC   1528A
1528E:  MOVFF  FC9,72A
....................    output_bit(RTC_CS, DISABLE); 
15292:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
15294:  MOVLB  7
15296:  BSF    x2A.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15298:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
1529A:  MOVF   FC9,W
1529C:  MOVLW  8A
1529E:  MOVWF  FC9
152A0:  RRCF   FC7,W
152A2:  BNC   152A0
152A4:  MOVFF  FC9,864
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
152A8:  MOVF   FC9,W
152AA:  MOVFF  72A,FC9
152AE:  RRCF   FC7,W
152B0:  BNC   152AE
152B2:  MOVFF  FC9,864
....................    output_bit(RTC_CS, DISABLE); 
152B6:  BSF    F91.0
152B8:  MOVLB  0
152BA:  GOTO   1679E (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
033C0:  MOVFF  721,73B
....................    rtc_last_min   = RTC_Min_Reg; 
033C4:  MOVFF  722,73A
....................    rtc_last_hour  = RTC_Hr_Reg; 
033C8:  MOVFF  723,739
....................    rtc_last_day   = RTC_DOM_Reg; 
033CC:  MOVFF  725,737
....................    rtc_last_month = RTC_Mon_Reg; 
033D0:  MOVFF  726,736
....................    rtc_last_year  = RTC_Yr_Reg; 
033D4:  MOVFF  727,738
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
033D8:  MOVLW  06
033DA:  MOVLB  8
033DC:  MOVWF  x66
033DE:  MOVFF  736,867
033E2:  MOVLB  0
033E4:  RCALL  3390
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
033E6:  MOVLW  08
033E8:  MOVLB  8
033EA:  MOVWF  x66
033EC:  MOVFF  737,867
033F0:  MOVLB  0
033F2:  RCALL  3390
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
033F4:  MOVLW  0A
033F6:  MOVLB  8
033F8:  MOVWF  x66
033FA:  MOVFF  738,867
033FE:  MOVLB  0
03400:  RCALL  3390
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
03402:  MOVLW  0C
03404:  MOVLB  8
03406:  MOVWF  x66
03408:  MOVFF  739,867
0340C:  MOVLB  0
0340E:  RCALL  3390
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
03410:  MOVLW  0E
03412:  MOVLB  8
03414:  MOVWF  x66
03416:  MOVFF  73A,867
0341A:  MOVLB  0
0341C:  RCALL  3390
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
0341E:  MOVLW  10
03420:  MOVLB  8
03422:  MOVWF  x66
03424:  MOVFF  73B,867
03428:  MOVLB  0
0342A:  RCALL  3390
0342C:  GOTO   1B194 (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
152BE:  MOVLB  8
152C0:  CLRF   x67
152C2:  CLRF   x66
152C4:  CLRF   x65
152C6:  CLRF   x64
152C8:  CLRF   x6B
152CA:  CLRF   x6A
152CC:  CLRF   x69
152CE:  CLRF   x68
152D0:  CLRF   x6F
152D2:  CLRF   x6E
152D4:  CLRF   x6D
152D6:  CLRF   x6C
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
152D8:  CLRF   x7C
152DA:  CLRF   x7D
152DC:  MOVLW  1F
152DE:  MOVWF  x7E
152E0:  CLRF   x7F
152E2:  MOVLW  3B
152E4:  MOVWF  x80
152E6:  CLRF   x81
152E8:  MOVLW  5A
152EA:  MOVWF  x82
152EC:  CLRF   x83
152EE:  MOVLW  78
152F0:  MOVWF  x84
152F2:  CLRF   x85
152F4:  MOVLW  97
152F6:  MOVWF  x86
152F8:  CLRF   x87
152FA:  MOVLW  B5
152FC:  MOVWF  x88
152FE:  CLRF   x89
15300:  MOVLW  D4
15302:  MOVWF  x8A
15304:  CLRF   x8B
15306:  MOVLW  F3
15308:  MOVWF  x8C
1530A:  CLRF   x8D
1530C:  MOVLW  11
1530E:  MOVWF  x8E
15310:  MOVLW  01
15312:  MOVWF  x8F
15314:  MOVLW  30
15316:  MOVWF  x90
15318:  MOVLW  01
1531A:  MOVWF  x91
1531C:  MOVLW  4E
1531E:  MOVWF  x92
15320:  MOVLW  01
15322:  MOVWF  x93
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
15324:  BCF    49.3
....................     
....................    RTC_read(); 
15326:  MOVLB  0
15328:  CALL   32C2
....................    RTC_read_alarm(); 
1532C:  CALL   E10C
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
15330:  MOVLW  04
15332:  MOVLB  8
15334:  MOVWF  x94
15336:  MOVLB  0
15338:  CALL   29A2
1533C:  MOVFF  01,729
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
15340:  MOVLB  7
15342:  MOVF   x27,W
15344:  SUBWF  x29,W
15346:  BC    1534C
15348:  BSF    49.3
1534A:  BRA    15774
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
1534C:  MOVF   x29,W
1534E:  SUBWF  x27,W
15350:  BTFSS  FD8.2
15352:  BRA    15774
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
15354:  MOVLW  01
15356:  SUBWF  x26,W
15358:  MOVWF  00
1535A:  BCF    FD8.0
1535C:  RLCF   00,F
1535E:  MOVF   00,W
15360:  CLRF   03
15362:  ADDLW  7C
15364:  MOVWF  FE9
15366:  MOVLW  08
15368:  ADDWFC 03,W
1536A:  MOVWF  FEA
1536C:  MOVFF  FEC,03
15370:  MOVF   FED,F
15372:  MOVFF  FEF,8F4
15376:  MOVFF  03,8F5
1537A:  MOVLB  0
1537C:  CALL   C61A
15380:  MOVFF  03,867
15384:  MOVFF  02,866
15388:  MOVFF  01,865
1538C:  MOVFF  00,864
....................          time_now = time_now + RTC_DOM_Reg; 
15390:  MOVLB  8
15392:  CLRF   xF5
15394:  MOVFF  725,8F4
15398:  MOVLB  0
1539A:  CALL   C61A
1539E:  BCF    FD8.1
153A0:  MOVFF  867,8F7
153A4:  MOVFF  866,8F6
153A8:  MOVFF  865,8F5
153AC:  MOVFF  864,8F4
153B0:  MOVFF  03,8FB
153B4:  MOVFF  02,8FA
153B8:  MOVFF  01,8F9
153BC:  MOVFF  00,8F8
153C0:  CALL   C022
153C4:  MOVFF  03,867
153C8:  MOVFF  02,866
153CC:  MOVFF  01,865
153D0:  MOVFF  00,864
....................           
....................          hour = RTC_Hr_Reg; 
153D4:  MOVLB  8
153D6:  CLRF   xF5
153D8:  MOVFF  723,8F4
153DC:  MOVLB  0
153DE:  CALL   C61A
153E2:  MOVFF  03,873
153E6:  MOVFF  02,872
153EA:  MOVFF  01,871
153EE:  MOVFF  00,870
....................          minute = RTC_Min_Reg; 
153F2:  MOVLB  8
153F4:  CLRF   xF5
153F6:  MOVFF  722,8F4
153FA:  MOVLB  0
153FC:  CALL   C61A
15400:  MOVFF  03,877
15404:  MOVFF  02,876
15408:  MOVFF  01,875
1540C:  MOVFF  00,874
....................          second = RTC_Sec_Reg; 
15410:  MOVLB  8
15412:  CLRF   xF5
15414:  MOVFF  721,8F4
15418:  MOVLB  0
1541A:  CALL   C61A
1541E:  MOVFF  03,87B
15422:  MOVFF  02,87A
15426:  MOVFF  01,879
1542A:  MOVFF  00,878
....................           
....................          fraction_of_day = (hour / 24); 
1542E:  MOVFF  873,8DB
15432:  MOVFF  872,8DA
15436:  MOVFF  871,8D9
1543A:  MOVFF  870,8D8
1543E:  MOVLB  8
15440:  CLRF   xDF
15442:  CLRF   xDE
15444:  MOVLW  40
15446:  MOVWF  xDD
15448:  MOVLW  83
1544A:  MOVWF  xDC
1544C:  MOVLB  0
1544E:  CALL   C650
15452:  MOVFF  03,86F
15456:  MOVFF  02,86E
1545A:  MOVFF  01,86D
1545E:  MOVFF  00,86C
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15462:  MOVFF  877,8DB
15466:  MOVFF  876,8DA
1546A:  MOVFF  875,8D9
1546E:  MOVFF  874,8D8
15472:  MOVLB  8
15474:  CLRF   xDF
15476:  CLRF   xDE
15478:  MOVLW  34
1547A:  MOVWF  xDD
1547C:  MOVLW  89
1547E:  MOVWF  xDC
15480:  MOVLB  0
15482:  CALL   C650
15486:  BCF    FD8.1
15488:  MOVFF  86F,8F7
1548C:  MOVFF  86E,8F6
15490:  MOVFF  86D,8F5
15494:  MOVFF  86C,8F4
15498:  MOVFF  03,8FB
1549C:  MOVFF  02,8FA
154A0:  MOVFF  01,8F9
154A4:  MOVFF  00,8F8
154A8:  CALL   C022
154AC:  MOVFF  03,86F
154B0:  MOVFF  02,86E
154B4:  MOVFF  01,86D
154B8:  MOVFF  00,86C
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
154BC:  MOVFF  87B,8DB
154C0:  MOVFF  87A,8DA
154C4:  MOVFF  879,8D9
154C8:  MOVFF  878,8D8
154CC:  MOVLB  8
154CE:  CLRF   xDF
154D0:  MOVLW  C0
154D2:  MOVWF  xDE
154D4:  MOVLW  28
154D6:  MOVWF  xDD
154D8:  MOVLW  8F
154DA:  MOVWF  xDC
154DC:  MOVLB  0
154DE:  CALL   C650
154E2:  BCF    FD8.1
154E4:  MOVFF  86F,8F7
154E8:  MOVFF  86E,8F6
154EC:  MOVFF  86D,8F5
154F0:  MOVFF  86C,8F4
154F4:  MOVFF  03,8FB
154F8:  MOVFF  02,8FA
154FC:  MOVFF  01,8F9
15500:  MOVFF  00,8F8
15504:  CALL   C022
15508:  MOVFF  03,86F
1550C:  MOVFF  02,86E
15510:  MOVFF  01,86D
15514:  MOVFF  00,86C
....................           
....................          time_now = time_now + fraction_of_day; 
15518:  BCF    FD8.1
1551A:  MOVFF  867,8F7
1551E:  MOVFF  866,8F6
15522:  MOVFF  865,8F5
15526:  MOVFF  864,8F4
1552A:  MOVFF  86F,8FB
1552E:  MOVFF  86E,8FA
15532:  MOVFF  86D,8F9
15536:  MOVFF  86C,8F8
1553A:  CALL   C022
1553E:  MOVFF  03,867
15542:  MOVFF  02,866
15546:  MOVFF  01,865
1554A:  MOVFF  00,864
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
1554E:  MOVLB  8
15550:  CLRF   xF5
15552:  MOVFF  72C,8F4
15556:  MOVLB  0
15558:  CALL   C61A
1555C:  MOVFF  03,873
15560:  MOVFF  02,872
15564:  MOVFF  01,871
15568:  MOVFF  00,870
....................          minute = RTC_Al_Min_Reg; 
1556C:  MOVLB  8
1556E:  CLRF   xF5
15570:  MOVFF  72D,8F4
15574:  MOVLB  0
15576:  CALL   C61A
1557A:  MOVFF  03,877
1557E:  MOVFF  02,876
15582:  MOVFF  01,875
15586:  MOVFF  00,874
....................          second = RTC_Al_Sec_Reg; 
1558A:  MOVLB  8
1558C:  CLRF   xF5
1558E:  MOVFF  72E,8F4
15592:  MOVLB  0
15594:  CALL   C61A
15598:  MOVFF  03,87B
1559C:  MOVFF  02,87A
155A0:  MOVFF  01,879
155A4:  MOVFF  00,878
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
155A8:  MOVLW  01
155AA:  MOVLB  7
155AC:  SUBWF  x2A,W
155AE:  MOVWF  00
155B0:  BCF    FD8.0
155B2:  RLCF   00,F
155B4:  MOVF   00,W
155B6:  CLRF   03
155B8:  ADDLW  7C
155BA:  MOVWF  FE9
155BC:  MOVLW  08
155BE:  ADDWFC 03,W
155C0:  MOVWF  FEA
155C2:  MOVFF  FEC,03
155C6:  MOVF   FED,F
155C8:  MOVFF  FEF,8F4
155CC:  MOVFF  03,8F5
155D0:  MOVLB  0
155D2:  CALL   C61A
155D6:  MOVFF  03,86B
155DA:  MOVFF  02,86A
155DE:  MOVFF  01,869
155E2:  MOVFF  00,868
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
155E6:  MOVLB  8
155E8:  CLRF   xF5
155EA:  MOVFF  72B,8F4
155EE:  MOVLB  0
155F0:  CALL   C61A
155F4:  BCF    FD8.1
155F6:  MOVFF  86B,8F7
155FA:  MOVFF  86A,8F6
155FE:  MOVFF  869,8F5
15602:  MOVFF  868,8F4
15606:  MOVFF  03,8FB
1560A:  MOVFF  02,8FA
1560E:  MOVFF  01,8F9
15612:  MOVFF  00,8F8
15616:  CALL   C022
1561A:  MOVFF  03,86B
1561E:  MOVFF  02,86A
15622:  MOVFF  01,869
15626:  MOVFF  00,868
....................           
....................          fraction_of_day = (hour / 24); 
1562A:  MOVFF  873,8DB
1562E:  MOVFF  872,8DA
15632:  MOVFF  871,8D9
15636:  MOVFF  870,8D8
1563A:  MOVLB  8
1563C:  CLRF   xDF
1563E:  CLRF   xDE
15640:  MOVLW  40
15642:  MOVWF  xDD
15644:  MOVLW  83
15646:  MOVWF  xDC
15648:  MOVLB  0
1564A:  CALL   C650
1564E:  MOVFF  03,86F
15652:  MOVFF  02,86E
15656:  MOVFF  01,86D
1565A:  MOVFF  00,86C
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
1565E:  MOVFF  877,8DB
15662:  MOVFF  876,8DA
15666:  MOVFF  875,8D9
1566A:  MOVFF  874,8D8
1566E:  MOVLB  8
15670:  CLRF   xDF
15672:  CLRF   xDE
15674:  MOVLW  34
15676:  MOVWF  xDD
15678:  MOVLW  89
1567A:  MOVWF  xDC
1567C:  MOVLB  0
1567E:  CALL   C650
15682:  BCF    FD8.1
15684:  MOVFF  86F,8F7
15688:  MOVFF  86E,8F6
1568C:  MOVFF  86D,8F5
15690:  MOVFF  86C,8F4
15694:  MOVFF  03,8FB
15698:  MOVFF  02,8FA
1569C:  MOVFF  01,8F9
156A0:  MOVFF  00,8F8
156A4:  CALL   C022
156A8:  MOVFF  03,86F
156AC:  MOVFF  02,86E
156B0:  MOVFF  01,86D
156B4:  MOVFF  00,86C
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
156B8:  MOVFF  87B,8DB
156BC:  MOVFF  87A,8DA
156C0:  MOVFF  879,8D9
156C4:  MOVFF  878,8D8
156C8:  MOVLB  8
156CA:  CLRF   xDF
156CC:  MOVLW  C0
156CE:  MOVWF  xDE
156D0:  MOVLW  28
156D2:  MOVWF  xDD
156D4:  MOVLW  8F
156D6:  MOVWF  xDC
156D8:  MOVLB  0
156DA:  CALL   C650
156DE:  BCF    FD8.1
156E0:  MOVFF  86F,8F7
156E4:  MOVFF  86E,8F6
156E8:  MOVFF  86D,8F5
156EC:  MOVFF  86C,8F4
156F0:  MOVFF  03,8FB
156F4:  MOVFF  02,8FA
156F8:  MOVFF  01,8F9
156FC:  MOVFF  00,8F8
15700:  CALL   C022
15704:  MOVFF  03,86F
15708:  MOVFF  02,86E
1570C:  MOVFF  01,86D
15710:  MOVFF  00,86C
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
15714:  BCF    FD8.1
15716:  MOVFF  86B,8F7
1571A:  MOVFF  86A,8F6
1571E:  MOVFF  869,8F5
15722:  MOVFF  868,8F4
15726:  MOVFF  86F,8FB
1572A:  MOVFF  86E,8FA
1572E:  MOVFF  86D,8F9
15732:  MOVFF  86C,8F8
15736:  CALL   C022
1573A:  MOVFF  03,86B
1573E:  MOVFF  02,86A
15742:  MOVFF  01,869
15746:  MOVFF  00,868
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
1574A:  MOVFF  86B,8F3
1574E:  MOVFF  86A,8F2
15752:  MOVFF  869,8F1
15756:  MOVFF  868,8F0
1575A:  MOVFF  867,8F7
1575E:  MOVFF  866,8F6
15762:  MOVFF  865,8F5
15766:  MOVFF  864,8F4
1576A:  CALL   10460
1576E:  BNC   15772
15770:  BSF    49.3
15772:  MOVLB  7
....................       } 
....................    } 
15774:  MOVLB  0
15776:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
15778:  BTFSS  49.3
1577A:  BRA    15798
1577C:  MOVLW  C4
1577E:  MOVWF  FF6
15780:  MOVLW  0D
15782:  MOVWF  FF7
15784:  MOVLW  00
15786:  MOVWF  FF8
15788:  CLRF   1B
1578A:  BTFSC  FF2.7
1578C:  BSF    1B.7
1578E:  BCF    FF2.7
15790:  CALL   0E30
15794:  BTFSC  1B.7
15796:  BSF    FF2.7
15798:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F270:  BCF    F67.5
0F272:  MOVLW  32
0F274:  MOVWF  F67
0F276:  MOVLW  40
0F278:  MOVWF  F68
....................     
....................    data = 0; 
0F27A:  MOVLB  8
0F27C:  CLRF   xB4
0F27E:  CLRF   xB3
....................     
....................    DAC_MS_byte = 0; 
0F280:  CLRF   xB5
....................    DAC_LS_byte = 0; 
0F282:  CLRF   xB6
....................     
....................    data = setting & 0b0000111100000000; 
0F284:  CLRF   xB3
0F286:  MOVF   xB2,W
0F288:  ANDLW  0F
0F28A:  MOVWF  xB4
....................    data = data >> 8; 
0F28C:  MOVFF  8B4,8B3
0F290:  CLRF   xB4
....................    DAC_MS_byte = data; 
0F292:  MOVFF  8B3,8B5
....................     
....................    data = setting & 0b0000000011111111; 
0F296:  MOVFF  8B1,8B3
0F29A:  CLRF   xB4
....................    DAC_LS_byte = data; 
0F29C:  MOVFF  8B3,8B6
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F2A0:  MOVLW  01
0F2A2:  SUBWF  xB0,W
0F2A4:  ADDLW  FC
0F2A6:  BC    F2D2
0F2A8:  ADDLW  04
0F2AA:  MOVLB  0
0F2AC:  GOTO   F2F0
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F2B0:  MOVLW  30
0F2B2:  MOVLB  8
0F2B4:  IORWF  xB5,F
....................          break; 
0F2B6:  BRA    F2D2
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F2B8:  MOVLW  70
0F2BA:  MOVLB  8
0F2BC:  IORWF  xB5,F
....................          break; 
0F2BE:  BRA    F2D2
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F2C0:  MOVLW  B0
0F2C2:  MOVLB  8
0F2C4:  IORWF  xB5,F
....................          break; 
0F2C6:  BRA    F2D2
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F2C8:  MOVLW  F0
0F2CA:  MOVLB  8
0F2CC:  IORWF  xB5,F
....................          break; 
0F2CE:  BRA    F2D2
0F2D0:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F2D2:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F2D4:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F2D6:  MOVF   F6A,W
0F2D8:  MOVFF  8B5,F6A
0F2DC:  RRCF   F68,W
0F2DE:  BNC   F2DC
....................    spi_write2(DAC_LS_byte); 
0F2E0:  MOVF   F6A,W
0F2E2:  MOVFF  8B6,F6A
0F2E6:  RRCF   F68,W
0F2E8:  BNC   F2E6
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F2EA:  BSF    F8C.3
0F2EC:  MOVLB  0
0F2EE:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F318:  MOVLB  8
0F31A:  CLRF   xB5
0F31C:  CLRF   xB6
0F31E:  CLRF   xB7
0F320:  CLRF   xB8
0F322:  CLRF   xB9
0F324:  CLRF   xBA
0F326:  CLRF   xBB
0F328:  CLRF   xBC
0F32A:  CLRF   xBD
0F32C:  CLRF   xBE
0F32E:  CLRF   xBF
0F330:  CLRF   xC0
0F332:  CLRF   xC1
0F334:  CLRF   xC2
0F336:  CLRF   xC3
0F338:  CLRF   xC4
0F33A:  CLRF   xC5
0F33C:  CLRF   xC6
0F33E:  CLRF   xC7
0F340:  CLRF   xC8
0F342:  CLRF   xC9
0F344:  CLRF   xCA
0F346:  CLRF   xCB
0F348:  CLRF   xCC
0F34A:  CLRF   xCD
0F34C:  CLRF   xCE
0F34E:  CLRF   xCF
0F350:  CLRF   xD0
0F352:  CLRF   xD1
0F354:  CLRF   xD2
0F356:  CLRF   xD3
0F358:  CLRF   xD4
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F35A:  CLRF   xD5
0F35C:  CLRF   xD6
0F35E:  CLRF   xD7
0F360:  CLRF   xD8
0F362:  CLRF   xD9
0F364:  CLRF   xDA
0F366:  CLRF   xDB
0F368:  CLRF   xDC
0F36A:  CLRF   xDD
0F36C:  CLRF   xDE
0F36E:  CLRF   xDF
0F370:  CLRF   xE0
0F372:  CLRF   xE1
0F374:  CLRF   xE2
0F376:  CLRF   xE3
0F378:  CLRF   xE4
0F37A:  CLRF   xE5
0F37C:  CLRF   xE6
0F37E:  CLRF   xE7
0F380:  CLRF   xE8
0F382:  CLRF   xE9
0F384:  CLRF   xEA
0F386:  CLRF   xEB
0F388:  CLRF   xEC
0F38A:  CLRF   xED
0F38C:  CLRF   xEE
0F38E:  CLRF   xEF
0F390:  CLRF   xF0
0F392:  CLRF   xF1
0F394:  CLRF   xF2
0F396:  CLRF   xF3
0F398:  CLRF   xF4
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F39A:  CLRF   xB4
0F39C:  MOVLW  01
0F39E:  MOVWF  xB3
0F3A0:  MOVLW  01
0F3A2:  ADDWF  xB0,W
0F3A4:  MOVWF  01
0F3A6:  MOVLW  00
0F3A8:  ADDWFC xB1,W
0F3AA:  MOVWF  03
0F3AC:  MOVF   xB4,W
0F3AE:  SUBWF  03,W
0F3B0:  BNC   F496
0F3B2:  BNZ   F3BA
0F3B4:  MOVF   01,W
0F3B6:  SUBWF  xB3,W
0F3B8:  BC    F496
....................    { 
....................       for (n=1; n<5; ++n) 
0F3BA:  MOVLW  01
0F3BC:  MOVWF  xB2
0F3BE:  MOVF   xB2,W
0F3C0:  SUBLW  04
0F3C2:  BNC   F48E
....................       { 
....................          set_adc_channel(n,VSS); 
0F3C4:  RLCF   xB2,W
0F3C6:  MOVWF  00
0F3C8:  RLCF   00,F
0F3CA:  MOVLW  FC
0F3CC:  ANDWF  00,F
0F3CE:  MOVF   FC2,W
0F3D0:  ANDLW  83
0F3D2:  IORWF  00,W
0F3D4:  MOVWF  FC2
0F3D6:  MOVLW  00
0F3D8:  MOVWF  01
0F3DA:  MOVF   FC1,W
0F3DC:  ANDLW  F8
0F3DE:  IORWF  01,W
0F3E0:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F3E2:  MOVF   xB2,W
0F3E4:  MULLW  04
0F3E6:  MOVF   FF3,W
0F3E8:  CLRF   03
0F3EA:  ADDLW  D5
0F3EC:  MOVWF  FE9
0F3EE:  MOVLW  08
0F3F0:  ADDWFC 03,W
0F3F2:  MOVWF  FEA
0F3F4:  BSF    FC2.1
0F3F6:  BTFSC  FC2.1
0F3F8:  BRA    F3F6
0F3FA:  MOVFF  FC3,FEF
0F3FE:  MOVFF  FC4,FEC
0F402:  CLRF   FEC
0F404:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F406:  MOVF   xB2,W
0F408:  MULLW  04
0F40A:  MOVF   FF3,W
0F40C:  CLRF   03
0F40E:  ADDLW  B5
0F410:  MOVWF  01
0F412:  MOVLW  08
0F414:  ADDWFC 03,F
0F416:  MOVFF  01,8F5
0F41A:  MOVFF  03,8F6
0F41E:  MOVF   xB2,W
0F420:  MULLW  04
0F422:  MOVF   FF3,W
0F424:  CLRF   03
0F426:  ADDLW  B5
0F428:  MOVWF  FE9
0F42A:  MOVLW  08
0F42C:  ADDWFC 03,W
0F42E:  MOVWF  FEA
0F430:  MOVFF  FEF,8F7
0F434:  MOVFF  FEC,8F8
0F438:  MOVFF  FEC,8F9
0F43C:  MOVFF  FEC,8FA
0F440:  MOVF   xB2,W
0F442:  MULLW  04
0F444:  MOVF   FF3,W
0F446:  CLRF   03
0F448:  ADDLW  D5
0F44A:  MOVWF  FE9
0F44C:  MOVLW  08
0F44E:  ADDWFC 03,W
0F450:  MOVWF  FEA
0F452:  MOVFF  FEF,00
0F456:  MOVFF  FEC,01
0F45A:  MOVFF  FEC,02
0F45E:  MOVFF  FEC,03
0F462:  MOVF   xF7,W
0F464:  ADDWF  00,F
0F466:  MOVF   xF8,W
0F468:  ADDWFC 01,F
0F46A:  MOVF   xF9,W
0F46C:  ADDWFC 02,F
0F46E:  MOVF   xFA,W
0F470:  ADDWFC 03,F
0F472:  MOVFF  8F6,FEA
0F476:  MOVFF  8F5,FE9
0F47A:  MOVFF  00,FEF
0F47E:  MOVFF  01,FEC
0F482:  MOVFF  02,FEC
0F486:  MOVFF  03,FEC
0F48A:  INCF   xB2,F
0F48C:  BRA    F3BE
....................       } 
0F48E:  INCF   xB3,F
0F490:  BTFSC  FD8.2
0F492:  INCF   xB4,F
0F494:  BRA    F3A0
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F496:  MOVLW  01
0F498:  MOVWF  xB2
0F49A:  MOVF   xB2,W
0F49C:  SUBLW  04
0F49E:  BNC   F510
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F4A0:  BCF    FD8.0
0F4A2:  RLCF   xB2,W
0F4A4:  CLRF   03
0F4A6:  ADDLW  A1
0F4A8:  MOVWF  01
0F4AA:  MOVLW  04
0F4AC:  ADDWFC 03,F
0F4AE:  MOVFF  01,8F5
0F4B2:  MOVFF  03,8F6
0F4B6:  MOVF   xB2,W
0F4B8:  MULLW  04
0F4BA:  MOVF   FF3,W
0F4BC:  CLRF   03
0F4BE:  ADDLW  B5
0F4C0:  MOVWF  FE9
0F4C2:  MOVLW  08
0F4C4:  ADDWFC 03,W
0F4C6:  MOVWF  FEA
0F4C8:  MOVFF  FEF,A24
0F4CC:  MOVFF  FEC,A25
0F4D0:  MOVFF  FEC,A26
0F4D4:  MOVFF  FEC,A27
0F4D8:  BCF    FD8.1
0F4DA:  CLRF   1B
0F4DC:  BTFSC  FF2.7
0F4DE:  BSF    1B.7
0F4E0:  BCF    FF2.7
0F4E2:  MOVLB  A
0F4E4:  CLRF   x2B
0F4E6:  CLRF   x2A
0F4E8:  MOVFF  8B1,A29
0F4EC:  MOVFF  8B0,A28
0F4F0:  MOVLB  0
0F4F2:  CALL   1038
0F4F6:  BTFSC  1B.7
0F4F8:  BSF    FF2.7
0F4FA:  MOVFF  8F6,FEA
0F4FE:  MOVFF  8F5,FE9
0F502:  MOVFF  00,FEF
0F506:  MOVFF  01,FEC
0F50A:  MOVLB  8
0F50C:  INCF   xB2,F
0F50E:  BRA    F49A
....................    } 
0F510:  MOVLB  0
0F512:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    rtc_alarm = TRUE; 
*
00E00:  BSF    49.0
....................    sleep_mode = FALSE; 
00E02:  BCF    49.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E04:  BTFSS  49.2
00E06:  BRA    0E0A
....................    { 
....................       ; 
00E08:  BRA    0E04
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E0A:  BSF    49.2
....................    RTC_read_flags(); 
00E0C:  RCALL  0DCC
....................    ++nv_elapsed; 
00E0E:  INCF   35,F
00E10:  BTFSC  FD8.2
00E12:  INCF   36,F
.................... } 
....................  
00E14:  BCF    FF2.1
00E16:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E5A:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E5C:  BTFSC  49.1
00E5E:  BRA    0EB0
....................    { 
....................       if (kbhit(COM_A)) 
00E60:  BTFSS  F9E.5
00E62:  BRA    0EAE
....................       { 
....................          c = getc(COM_A); 
00E64:  RCALL  0E1A
00E66:  MOVFF  01,A0F
....................          switch (c) 
00E6A:  MOVLB  A
00E6C:  MOVF   x0F,W
00E6E:  XORLW  3F
00E70:  MOVLB  0
00E72:  BZ    0E7E
00E74:  XORLW  2E
00E76:  BZ    0EA2
00E78:  XORLW  0A
00E7A:  BZ    0EA8
00E7C:  BRA    0EAE
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00E7E:  DECFSZ 4A,W
00E80:  BRA    0E92
00E82:  MOVLW  BA
00E84:  MOVWF  FF6
00E86:  MOVLW  0E
00E88:  MOVWF  FF7
00E8A:  MOVLW  00
00E8C:  MOVWF  FF8
00E8E:  RCALL  0E30
00E90:  BRA    0EA0
....................                else fprintf(COM_A, "@RDY\r\n"); 
00E92:  MOVLW  C2
00E94:  MOVWF  FF6
00E96:  MOVLW  0E
00E98:  MOVWF  FF7
00E9A:  MOVLW  00
00E9C:  MOVWF  FF8
00E9E:  RCALL  0E30
....................                break; 
00EA0:  BRA    0EAE
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EA2:  MOVLW  01
00EA4:  MOVWF  4C
....................                break;          
00EA6:  BRA    0EAE
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EA8:  CLRF   32
00EAA:  MOVLW  01
00EAC:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00EAE:  BRA    0EB4
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00EB0:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00EB2:  BCF    F9E.5
....................    } 
00EB4:  BCF    F9E.5
00EB6:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0ADA2:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0ADA4:  MOVF   FAE,W
....................    busy_status = FALSE; 
0ADA6:  CLRF   4A
0ADA8:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
0293E:  MOVLW  01
02940:  MOVWF  4A
....................    clear_interrupt(INT_RDA); 
02942:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
02944:  BSF    F9D.5
02946:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00ECA:  MOVLW  0B
00ECC:  MOVWF  FD7
00ECE:  MOVLW  DC
00ED0:  MOVWF  FD6
....................    restart_wdt(); 
00ED2:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00ED4:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00ED6:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00ED8:  CLRF   FCF
00EDA:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00EDC:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00EDE:  MOVF   2F,W
00EE0:  SUBLW  02
00EE2:  BNZ   0EEA
00EE4:  MOVF   30,F
00EE6:  BNZ   0EEA
00EE8:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00EEA:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00EEC:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00EEE:  BCF    FF2.2
00EF0:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00EF4:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00EF6:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00EF8:  MOVF   2F,W
00EFA:  SUBLW  02
00EFC:  BNZ   0F04
00EFE:  MOVF   30,F
00F00:  BNZ   0F04
00F02:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F04:  BCF    F9E.0
00F06:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
1585C:  MOVLB  8
1585E:  CLRF   x69
15860:  CLRF   x6D
15862:  CLRF   x6C
15864:  CLRF   x6B
15866:  CLRF   x6A
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
15868:  MOVLW  01
1586A:  ADDWF  x6A,F
1586C:  BTFSC  FD8.0
1586E:  INCF   x6B,F
15870:  BTFSC  FD8.2
15872:  INCF   x6C,F
15874:  BTFSC  FD8.2
15876:  INCF   x6D,F
15878:  MOVF   x6D,F
1587A:  BNZ   158BC
1587C:  MOVF   x6C,W
1587E:  SUBLW  04
15880:  BNC   158BC
15882:  BNZ   15892
15884:  MOVF   x6B,W
15886:  SUBLW  93
15888:  BNC   158BC
1588A:  BNZ   15892
1588C:  MOVF   x6A,W
1588E:  SUBLW  DF
15890:  BNC   158BC
....................    { 
....................       if(kbhit(COM_A)) 
15892:  BTFSS  F9E.5
15894:  BRA    158B2
....................       { 
....................          c = fgetc(COM_A); 
15896:  MOVLB  0
15898:  CALL   0E1A
1589C:  MOVFF  01,869
....................          if (com_echo == TRUE) 
158A0:  DECFSZ 48,W
158A2:  BRA    158AE
....................          { 
....................             fputc(c, COM_A); 
158A4:  MOVLB  8
158A6:  MOVF   x69,W
158A8:  MOVLB  0
158AA:  CALL   ADAA
....................          } 
....................          break; 
158AE:  MOVLB  8
158B0:  BRA    158BC
....................       } 
....................  
....................       delay_us(10); 
158B2:  MOVLW  35
158B4:  MOVWF  00
158B6:  DECFSZ 00,F
158B8:  BRA    158B6
158BA:  BRA    15868
....................    } 
....................  
....................    return(c); 
158BC:  MOVFF  869,01
158C0:  MOVLB  0
158C2:  GOTO   158D2 (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AD1E:  MOVLW  58
0AD20:  MOVLB  8
0AD22:  MOVWF  x60
0AD24:  CLRF   x64
0AD26:  CLRF   x63
0AD28:  CLRF   x62
0AD2A:  CLRF   x61
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AD2C:  MOVLW  01
0AD2E:  ADDWF  x61,F
0AD30:  BTFSC  FD8.0
0AD32:  INCF   x62,F
0AD34:  BTFSC  FD8.2
0AD36:  INCF   x63,F
0AD38:  BTFSC  FD8.2
0AD3A:  INCF   x64,F
0AD3C:  MOVF   x64,F
0AD3E:  BNZ   AD6E
0AD40:  MOVF   x63,F
0AD42:  BNZ   AD6E
0AD44:  MOVF   x62,W
0AD46:  SUBLW  C3
0AD48:  BNC   AD6E
0AD4A:  BNZ   AD52
0AD4C:  MOVF   x61,W
0AD4E:  SUBLW  4F
0AD50:  BNC   AD6E
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AD52:  MOVLW  05
0AD54:  MOVWF  00
0AD56:  DECFSZ 00,F
0AD58:  BRA    AD56
....................  
....................       if(kbhit()) 
0AD5A:  BTFSS  F9E.5
0AD5C:  BRA    AD6C
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AD5E:  MOVLB  0
0AD60:  CALL   0E1A
0AD64:  MOVFF  01,860
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AD68:  MOVLB  8
0AD6A:  BRA    AD6E
....................       } 
0AD6C:  BRA    AD2C
....................    } 
....................  
....................    return(EscChar); 
0AD6E:  MOVFF  860,01
0AD72:  MOVLB  0
0AD74:  GOTO   1B388 (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0D774:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0D776:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0D778:  BSF    F8F.3
....................    delay_ms(10); 
0D77A:  MOVLW  0A
0D77C:  MOVLB  9
0D77E:  MOVWF  xC9
0D780:  MOVLB  0
0D782:  CALL   288E
0D786:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0D860:  MOVLB  8
0D862:  CLRF   xD1
0D864:  CLRF   xD0
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0D866:  MOVLB  F
0D868:  BTFSC  x21.1
0D86A:  BRA    D878
....................       ++c; 
0D86C:  MOVLB  8
0D86E:  INCF   xD0,F
0D870:  BTFSC  FD8.2
0D872:  INCF   xD1,F
0D874:  BRA    D866
0D876:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0D878:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0D87A:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0D87C:  BCF    F8F.3
0D87E:  MOVLB  0
0D880:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
16A66:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
16A68:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
16A6A:  BCF    F8F.3
16A6C:  GOTO   16B5A (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
16A70:  MOVLB  8
16A72:  CLRF   x62
16A74:  CLRF   x63
16A76:  CLRF   xB4
16A78:  CLRF   xB5
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16A7A:  MOVLW  0A
16A7C:  MOVWF  FF6
16A7E:  MOVLW  0F
16A80:  MOVWF  FF7
16A82:  MOVLW  00
16A84:  MOVWF  FF8
16A86:  CLRF   1B
16A88:  BTFSC  FF2.7
16A8A:  BSF    1B.7
16A8C:  BCF    FF2.7
16A8E:  MOVLB  0
16A90:  CALL   0E30
16A94:  BTFSC  1B.7
16A96:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16A98:  MOVLB  8
16A9A:  MOVF   x63,W
16A9C:  SUBLW  04
16A9E:  BZ    16B56
....................    { 
....................        if (kbhit(COM_A)) 
16AA0:  BTFSS  F9E.5
16AA2:  BRA    16B3A
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16AA4:  MOVLB  0
16AA6:  CALL   0E1A
16AAA:  MOVFF  01,862
....................           if (com_echo == TRUE) 
16AAE:  DECFSZ 48,W
16AB0:  BRA    16ABC
....................           { 
....................              fputc(charFromA, COM_A); 
16AB2:  MOVLB  8
16AB4:  MOVF   x62,W
16AB6:  MOVLB  0
16AB8:  CALL   ADAA
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16ABC:  MOVLB  8
16ABE:  MOVF   xB5,W
16AC0:  SUBLW  4F
16AC2:  BNC   16B18
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
16AC4:  MOVF   xB5,W
16AC6:  INCF   xB5,F
16AC8:  CLRF   03
16ACA:  ADDLW  64
16ACC:  MOVWF  FE9
16ACE:  MOVLW  08
16AD0:  ADDWFC 03,W
16AD2:  MOVWF  FEA
16AD4:  MOVFF  862,FEF
....................              if (CARRIAGE_RET == charFromA) 
16AD8:  MOVF   x62,W
16ADA:  SUBLW  0D
16ADC:  BNZ   16B16
....................              { 
....................                 multidrop_on(); 
16ADE:  MOVLB  0
16AE0:  CALL   D774
....................                 for (index = 0 ; index < charCount; index++) 
16AE4:  MOVLB  8
16AE6:  CLRF   xB4
16AE8:  MOVF   xB5,W
16AEA:  SUBWF  xB4,W
16AEC:  BC    16B0C
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
16AEE:  CLRF   03
16AF0:  MOVF   xB4,W
16AF2:  ADDLW  64
16AF4:  MOVWF  FE9
16AF6:  MOVLW  08
16AF8:  ADDWFC 03,W
16AFA:  MOVWF  FEA
16AFC:  MOVFF  FEF,8B6
16B00:  MOVF   xB6,W
16B02:  MOVLB  0
16B04:  BRA    16A58
16B06:  MOVLB  8
16B08:  INCF   xB4,F
16B0A:  BRA    16AE8
....................                 } 
....................                 charCount = 0; 
16B0C:  CLRF   xB5
....................                 multidrop_off(); 
16B0E:  MOVLB  0
16B10:  CALL   D860
16B14:  MOVLB  8
....................              } 
....................           } 
16B16:  BRA    16B3A
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
16B18:  MOVLW  12
16B1A:  MOVWF  FF6
16B1C:  MOVLW  0F
16B1E:  MOVWF  FF7
16B20:  MOVLW  00
16B22:  MOVWF  FF8
16B24:  CLRF   1B
16B26:  BTFSC  FF2.7
16B28:  BSF    1B.7
16B2A:  BCF    FF2.7
16B2C:  MOVLB  0
16B2E:  CALL   0E30
16B32:  BTFSC  1B.7
16B34:  BSF    FF2.7
....................              charCount = 0; 
16B36:  MOVLB  8
16B38:  CLRF   xB5
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
16B3A:  BTFSS  FA4.5
16B3C:  BRA    16B54
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
16B3E:  MOVLB  0
16B40:  CALL   12B16
16B44:  MOVFF  01,863
....................           fputc(charFromB, COM_A);                  // send data via USART 
16B48:  MOVLB  8
16B4A:  MOVF   x63,W
16B4C:  MOVLB  0
16B4E:  CALL   ADAA
16B52:  MOVLB  8
....................        } 
16B54:  BRA    16A9A
....................    } 
....................  
....................    multidrop_shdn(); 
16B56:  MOVLB  0
16B58:  BRA    16A66
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
16B5A:  MOVLW  22
16B5C:  MOVWF  FF6
16B5E:  MOVLW  0F
16B60:  MOVWF  FF7
16B62:  MOVLW  00
16B64:  MOVWF  FF8
16B66:  CLRF   1B
16B68:  BTFSC  FF2.7
16B6A:  BSF    1B.7
16B6C:  BCF    FF2.7
16B6E:  CALL   0E30
16B72:  BTFSC  1B.7
16B74:  BSF    FF2.7
16B76:  GOTO   16B90 (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C598:  MOVLB  8
0C59A:  DECF   x7C,F
....................    len=0; 
0C59C:  CLRF   x7D
....................    do { 
....................      c=getc(); 
0C59E:  MOVLB  0
0C5A0:  CALL   0E1A
0C5A4:  MOVFF  01,87E
....................      if(c==8) {  // Backspace 
0C5A8:  MOVLB  8
0C5AA:  MOVF   x7E,W
0C5AC:  SUBLW  08
0C5AE:  BNZ   C5D2
....................         if(len>0) { 
0C5B0:  MOVF   x7D,F
0C5B2:  BZ    C5D0
....................           len--; 
0C5B4:  DECF   x7D,F
....................           putc(c); 
0C5B6:  MOVF   x7E,W
0C5B8:  MOVLB  0
0C5BA:  CALL   ADAA
....................           putc(' '); 
0C5BE:  MOVLW  20
0C5C0:  CALL   ADAA
....................           putc(c); 
0C5C4:  MOVLB  8
0C5C6:  MOVF   x7E,W
0C5C8:  MOVLB  0
0C5CA:  CALL   ADAA
0C5CE:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C5D0:  BRA    C600
0C5D2:  MOVF   x7E,W
0C5D4:  SUBLW  1F
0C5D6:  BC    C600
0C5D8:  MOVF   x7E,W
0C5DA:  SUBLW  7E
0C5DC:  BNC   C600
....................        if(len<=max) { 
0C5DE:  MOVF   x7D,W
0C5E0:  SUBWF  x7C,W
0C5E2:  BNC   C600
....................          s[len++]=c; 
0C5E4:  MOVF   x7D,W
0C5E6:  INCF   x7D,F
0C5E8:  ADDWF  x7A,W
0C5EA:  MOVWF  FE9
0C5EC:  MOVLW  00
0C5EE:  ADDWFC x7B,W
0C5F0:  MOVWF  FEA
0C5F2:  MOVFF  87E,FEF
....................          putc(c); 
0C5F6:  MOVF   x7E,W
0C5F8:  MOVLB  0
0C5FA:  CALL   ADAA
0C5FE:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C600:  MOVF   x7E,W
0C602:  SUBLW  0D
0C604:  BNZ   C59E
....................    s[len]=0; 
0C606:  MOVF   x7D,W
0C608:  ADDWF  x7A,W
0C60A:  MOVWF  FE9
0C60C:  MOVLW  00
0C60E:  ADDWFC x7B,W
0C610:  MOVWF  FEA
0C612:  CLRF   FEF
0C614:  MOVLB  0
0C616:  GOTO   CA16 (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0CA04:  MOVLW  08
0CA06:  MOVLB  8
0CA08:  MOVWF  x7B
0CA0A:  MOVLW  62
0CA0C:  MOVWF  x7A
0CA0E:  MOVLW  14
0CA10:  MOVWF  x7C
0CA12:  MOVLB  0
0CA14:  BRA    C598
....................   f = atof(s); 
0CA16:  MOVLW  08
0CA18:  MOVLB  8
0CA1A:  MOVWF  x7B
0CA1C:  MOVLW  62
0CA1E:  MOVWF  x7A
0CA20:  CLRF   x7D
0CA22:  CLRF   x7C
0CA24:  MOVLB  0
0CA26:  BRA    C7AE
0CA28:  MOVFF  03,879
0CA2C:  MOVFF  02,878
0CA30:  MOVFF  01,877
0CA34:  MOVFF  00,876
....................   return(f); 
0CA38:  MOVFF  876,00
0CA3C:  MOVFF  877,01
0CA40:  MOVFF  878,02
0CA44:  MOVFF  879,03
0CA48:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
028B8:  MOVLW  2F
028BA:  MOVWF  F92
....................    set_tris_b(0b00110111); 
028BC:  MOVLW  37
028BE:  MOVWF  F93
....................    set_tris_c(0b10010000); 
028C0:  MOVLW  90
028C2:  MOVWF  F94
....................    set_tris_d(0b00100000); 
028C4:  MOVLW  20
028C6:  MOVWF  F95
....................    set_tris_e(0b01000000); 
028C8:  MOVLW  40
028CA:  MOVWF  F96
....................    set_tris_f(0b00000000); 
028CC:  MOVLW  00
028CE:  MOVWF  F97
....................    set_tris_g(0b11100100); 
028D0:  MOVLW  E4
028D2:  MOVWF  F98
....................    set_tris_h(0b01000000); 
028D4:  MOVLW  40
028D6:  MOVWF  F99
....................    set_tris_j(0b00000000); 
028D8:  MOVLW  00
028DA:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
028DC:  BCF    F8E.3
....................    output_low(HB_IN1); 
028DE:  BCF    F8E.4
....................    output_low(HB_IN2); 
028E0:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
028E2:  BCF    F91.3
....................    output_high(EEP_CS);        
028E4:  BSF    F91.2
....................    output_high(RTC_CS); 
028E6:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
028E8:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
028EA:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
028EC:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
028EE:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
028F0:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
028F2:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
028F4:  BCF    F8F.3
....................    delay_ms(20);   
028F6:  MOVLW  14
028F8:  MOVLB  9
028FA:  MOVWF  xC9
028FC:  MOVLB  0
028FE:  RCALL  288E
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
02900:  BCF    F8E.1
....................    output_low(VDET);     
02902:  BCF    F90.7
....................    bus_pwr_status=0; 
02904:  MOVLB  4
02906:  CLRF   xB2
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
02908:  BSF    F8C.2
....................    output_high(DAC_CS); 
0290A:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
0290C:  BCF    F8C.0
....................    output_low(HSW2); 
0290E:  BCF    F8C.1
....................    heater_stat=0; 
02910:  CLRF   xB1
02912:  MOVLB  0
02914:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
1579A:  BSF    F91.1
....................    output_low(EEP_WP);        
1579C:  BCF    F91.3
....................    output_high(EEP_CS);        
1579E:  BSF    F91.2
....................    output_high(RTC_CS);  
157A0:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
157A2:  BCF    F8E.3
....................    output_low(HB_IN1);        
157A4:  BCF    F8E.4
....................    output_low(HB_IN2); 
157A6:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
157A8:  BCF    F8C.2
....................    output_low(DAC_CS); 
157AA:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
157AC:  BCF    F8C.0
....................    output_low(HSW2); 
157AE:  BCF    F8C.1
....................    heater_stat=0; 
157B0:  MOVLB  4
157B2:  CLRF   xB1
....................    // Power switches 
....................    output_low(VMOT);         
157B4:  BCF    F8E.1
....................    output_low(VDET);  
157B6:  BCF    F90.7
....................    bus_pwr_status=0; 
157B8:  CLRF   xB2
....................    output_low(VENC1);         
157BA:  BCF    F8E.6
....................    output_low(VENC2);         
157BC:  BCF    F8E.7
....................    output_low(VHBRDG);  
157BE:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
157C0:  MOVLW  2A
157C2:  MOVWF  FF6
157C4:  MOVLW  0F
157C6:  MOVWF  FF7
157C8:  MOVLW  00
157CA:  MOVWF  FF8
157CC:  CLRF   1B
157CE:  BTFSC  FF2.7
157D0:  BSF    1B.7
157D2:  BCF    FF2.7
157D4:  MOVLB  0
157D6:  CALL   0E30
157DA:  BTFSC  1B.7
157DC:  BSF    FF2.7
....................    delay_ms(50); 
157DE:  MOVLW  32
157E0:  MOVLB  9
157E2:  MOVWF  xC9
157E4:  MOVLB  0
157E6:  CALL   288E
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
157EA:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
157EC:  BSF    F91.6
....................    output_low(MD1_TXEN); 
157EE:  BCF    F91.5
....................    output_low(MD2_SHDN);    
157F0:  BCF    F8F.0
....................    output_low(MD2_REN); 
157F2:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
157F4:  BCF    F8F.3
....................  
....................    delay_ms(30); 
157F6:  MOVLW  1E
157F8:  MOVLB  9
157FA:  MOVWF  xC9
157FC:  MOVLB  0
157FE:  CALL   288E
15802:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
04FB2:  MOVLB  8
04FB4:  CLRF   x66
04FB6:  MOVF   x66,W
04FB8:  SUBLW  02
04FBA:  BNC   4FE0
....................       FS_Status = f_mountdrv(); 
04FBC:  MOVLB  0
04FBE:  RCALL  47CE
04FC0:  MOVFF  01,720
....................       if (FS_Status) 
04FC4:  MOVLB  7
04FC6:  MOVF   x20,F
04FC8:  BZ    4FD4
....................          { 
....................          display_file_result(FS_Status); 
04FCA:  MOVFF  720,867
04FCE:  MOVLB  0
04FD0:  BRA    4D6C
....................          } 
04FD2:  BRA    4FDA
....................       else break; 
04FD4:  MOVLB  8
04FD6:  BRA    4FE0
04FD8:  MOVLB  0
04FDA:  MOVLB  8
04FDC:  INCF   x66,F
04FDE:  BRA    4FB6
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
04FE0:  MOVLW  3E
04FE2:  MOVWF  xCB
04FE4:  CLRF   xCD
04FE6:  MOVFF  720,8CC
04FEA:  MOVLB  0
04FEC:  RCALL  4F4C
....................     
....................    return(FS_Status); 
04FEE:  MOVLB  7
04FF0:  MOVFF  720,01
04FF4:  MOVLB  0
04FF6:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
0307A:  MOVLW  01
0307C:  MOVLB  8
0307E:  MOVWF  x60
03080:  MOVF   x60,W
03082:  SUBLW  03
03084:  BNC   30C0
....................    { 
....................       output_bit(BOARD_LED, ON); 
03086:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
03088:  MOVF   2F,W
0308A:  SUBLW  02
0308C:  BNZ   3094
0308E:  MOVF   30,F
03090:  BNZ   3094
03092:  BSF    F90.6
....................       delay_ms(32); 
03094:  MOVLW  20
03096:  MOVLB  9
03098:  MOVWF  xC9
0309A:  MOVLB  0
0309C:  CALL   288E
....................       output_bit(BOARD_LED, OFF); 
030A0:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
030A2:  MOVF   2F,W
030A4:  SUBLW  02
030A6:  BNZ   30AE
030A8:  MOVF   30,F
030AA:  BNZ   30AE
030AC:  BCF    F90.6
....................       delay_ms(32); 
030AE:  MOVLW  20
030B0:  MOVLB  9
030B2:  MOVWF  xC9
030B4:  MOVLB  0
030B6:  CALL   288E
030BA:  MOVLB  8
030BC:  INCF   x60,F
030BE:  BRA    3080
....................    } 
030C0:  MOVLB  0
030C2:  GOTO   1B188 (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
05074:  MOVLB  8
05076:  CLRF   xD0
05078:  CLRF   xCF
0507A:  CLRF   xCE
0507C:  CLRF   xCD
....................    set_adc_channel(0,VSS); 
0507E:  MOVLW  00
05080:  MOVWF  01
05082:  MOVF   FC2,W
05084:  ANDLW  83
05086:  IORWF  01,W
05088:  MOVWF  FC2
0508A:  MOVLW  00
0508C:  MOVWF  01
0508E:  MOVF   FC1,W
05090:  ANDLW  F8
05092:  IORWF  01,W
05094:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
05096:  MOVLW  01
05098:  MOVWF  xCA
0509A:  MOVF   xCA,W
0509C:  SUBLW  32
0509E:  BNC   50C4
....................       reading=read_adc(); 
050A0:  BSF    FC2.1
050A2:  BTFSC  FC2.1
050A4:  BRA    50A2
050A6:  MOVFF  FC3,8D1
050AA:  MOVFF  FC4,8D2
050AE:  CLRF   xD3
050B0:  CLRF   xD4
....................       delay_ms(5); 
050B2:  MOVLW  05
050B4:  MOVLB  9
050B6:  MOVWF  xC9
050B8:  MOVLB  0
050BA:  CALL   288E
050BE:  MOVLB  8
050C0:  INCF   xCA,F
050C2:  BRA    509A
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
050C4:  MOVLW  01
050C6:  MOVWF  xCA
050C8:  MOVF   xCA,W
050CA:  SUBLW  64
050CC:  BNC   517A
....................       reading=read_adc(); 
050CE:  BSF    FC2.1
050D0:  BTFSC  FC2.1
050D2:  BRA    50D0
050D4:  MOVFF  FC3,8D1
050D8:  MOVFF  FC4,8D2
050DC:  CLRF   xD3
050DE:  CLRF   xD4
....................       result=(((result*(i-1))+reading)/i); 
050E0:  MOVLW  01
050E2:  SUBWF  xCA,W
050E4:  MOVWF  xD5
050E6:  MOVFF  8D0,9D6
050EA:  MOVFF  8CF,9D5
050EE:  MOVFF  8CE,9D4
050F2:  MOVFF  8CD,9D3
050F6:  MOVLB  9
050F8:  CLRF   xDA
050FA:  CLRF   xD9
050FC:  CLRF   xD8
050FE:  MOVWF  xD7
05100:  MOVLB  0
05102:  CALL   4772
05106:  MOVFF  03,8D8
0510A:  MOVFF  02,8D7
0510E:  MOVFF  01,8D6
05112:  MOVFF  00,8D5
05116:  MOVLB  8
05118:  MOVF   xD1,W
0511A:  ADDWF  xD5,F
0511C:  MOVF   xD2,W
0511E:  ADDWFC xD6,F
05120:  MOVF   xD3,W
05122:  ADDWFC xD7,F
05124:  MOVF   xD4,W
05126:  ADDWFC xD8,F
05128:  BCF    FD8.1
0512A:  CLRF   1B
0512C:  BTFSC  FF2.7
0512E:  BSF    1B.7
05130:  BCF    FF2.7
05132:  MOVFF  8D8,A27
05136:  MOVFF  8D7,A26
0513A:  MOVFF  8D6,A25
0513E:  MOVFF  8D5,A24
05142:  MOVLB  A
05144:  CLRF   x2B
05146:  CLRF   x2A
05148:  CLRF   x29
0514A:  MOVFF  8CA,A28
0514E:  MOVLB  0
05150:  CALL   1038
05154:  BTFSC  1B.7
05156:  BSF    FF2.7
05158:  MOVFF  03,8D0
0515C:  MOVFF  02,8CF
05160:  MOVFF  01,8CE
05164:  MOVFF  00,8CD
....................       delay_ms(5); 
05168:  MOVLW  05
0516A:  MOVLB  9
0516C:  MOVWF  xC9
0516E:  MOVLB  0
05170:  CALL   288E
05174:  MOVLB  8
05176:  INCF   xCA,F
05178:  BRA    50C8
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
0517A:  MOVFF  8D0,9D6
0517E:  MOVFF  8CF,9D5
05182:  MOVFF  8CE,9D4
05186:  MOVFF  8CD,9D3
0518A:  MOVLB  9
0518C:  CLRF   xDA
0518E:  CLRF   xD9
05190:  CLRF   xD8
05192:  MOVLW  64
05194:  MOVWF  xD7
05196:  MOVLB  0
05198:  CALL   4772
0519C:  MOVFF  03,8D8
051A0:  MOVFF  02,8D7
051A4:  MOVFF  01,8D6
051A8:  MOVFF  00,8D5
051AC:  BCF    FD8.1
051AE:  CLRF   1B
051B0:  BTFSC  FF2.7
051B2:  BSF    1B.7
051B4:  BCF    FF2.7
051B6:  MOVFF  03,A27
051BA:  MOVFF  02,A26
051BE:  MOVFF  01,A25
051C2:  MOVFF  00,A24
051C6:  MOVLB  A
051C8:  CLRF   x2B
051CA:  CLRF   x2A
051CC:  MOVLW  01
051CE:  MOVWF  x29
051D0:  MOVLW  10
051D2:  MOVWF  x28
051D4:  MOVLB  0
051D6:  CALL   1038
051DA:  BTFSC  1B.7
051DC:  BSF    FF2.7
051DE:  MOVLW  56
051E0:  MOVLB  8
051E2:  ADDWF  00,W
051E4:  MOVWF  xCB
051E6:  MOVLW  00
051E8:  ADDWFC 01,W
051EA:  MOVWF  xCC
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
051EC:  MOVFF  8CB,01
051F0:  MOVFF  8CC,02
051F4:  MOVLB  0
051F6:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
0505E:  MOVLW  02
05060:  MOVWF  FEA
05062:  MOVLW  95
05064:  MOVWF  FE9
05066:  CLRF   00
05068:  CLRF   02
0506A:  MOVLW  1E
0506C:  MOVWF  01
0506E:  CALL   34A4
05072:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
12A3E:  MOVLW  02
12A40:  MOVWF  FEA
12A42:  MOVLW  B3
12A44:  MOVWF  FE9
12A46:  CLRF   00
12A48:  CLRF   02
12A4A:  MOVLW  1E
12A4C:  MOVWF  01
12A4E:  CALL   34A4
12A52:  GOTO   12CFA (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
05392:  RCALL  505E
....................     
....................    v_supply = read_supply(); 
05394:  RCALL  5074
05396:  MOVFF  02,8C9
0539A:  MOVFF  01,8C8
....................    RTC_read(); 
0539E:  CALL   32C2
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
053A2:  MOVLW  02
053A4:  MOVWF  1E
053A6:  MOVLW  95
053A8:  MOVWF  1D
053AA:  MOVFF  726,8CA
053AE:  MOVLW  01
053B0:  MOVLB  8
053B2:  MOVWF  xCB
053B4:  MOVLB  0
053B6:  RCALL  51F8
053B8:  MOVLW  2F
053BA:  MOVLB  8
053BC:  MOVWF  xDC
053BE:  MOVLB  0
053C0:  RCALL  5016
053C2:  MOVFF  725,8CA
053C6:  MOVLW  01
053C8:  MOVLB  8
053CA:  MOVWF  xCB
053CC:  MOVLB  0
053CE:  RCALL  51F8
053D0:  MOVLW  2F
053D2:  MOVLB  8
053D4:  MOVWF  xDC
053D6:  MOVLB  0
053D8:  RCALL  5016
053DA:  MOVFF  727,8CA
053DE:  MOVLW  01
053E0:  MOVLB  8
053E2:  MOVWF  xCB
053E4:  MOVLB  0
053E6:  RCALL  51F8
053E8:  MOVLW  20
053EA:  MOVLB  8
053EC:  MOVWF  xDC
053EE:  MOVLB  0
053F0:  RCALL  5016
053F2:  MOVFF  723,8CA
053F6:  MOVLW  01
053F8:  MOVLB  8
053FA:  MOVWF  xCB
053FC:  MOVLB  0
053FE:  RCALL  51F8
05400:  MOVLW  3A
05402:  MOVLB  8
05404:  MOVWF  xDC
05406:  MOVLB  0
05408:  RCALL  5016
0540A:  MOVFF  722,8CA
0540E:  MOVLW  01
05410:  MOVLB  8
05412:  MOVWF  xCB
05414:  MOVLB  0
05416:  RCALL  51F8
05418:  MOVLW  3A
0541A:  MOVLB  8
0541C:  MOVWF  xDC
0541E:  MOVLB  0
05420:  RCALL  5016
05422:  MOVFF  721,8CA
05426:  MOVLW  01
05428:  MOVLB  8
0542A:  MOVWF  xCB
0542C:  MOVLB  0
0542E:  RCALL  51F8
05430:  MOVLW  2C
05432:  MOVLB  8
05434:  MOVWF  xDC
05436:  MOVLB  0
05438:  RCALL  5016
0543A:  MOVLW  44
0543C:  MOVWF  FE9
0543E:  MOVLB  8
05440:  CLRF   xCD
05442:  CLRF   xCC
05444:  MOVFF  8C9,8CB
05448:  MOVFF  8C8,8CA
0544C:  MOVLW  02
0544E:  MOVWF  xCE
05450:  MOVLB  0
05452:  RCALL  5292
05454:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
08410:  MOVLB  2
08412:  MOVF   xD8,F
08414:  BNZ   8490
....................    { 
....................       strcopy(event_buffer,""); 
08416:  MOVLW  01
08418:  MOVWF  FEA
0841A:  MOVLW  03
0841C:  MOVWF  FE9
0841E:  MOVLW  00
08420:  MOVLB  0
08422:  CALL   02CE
08426:  TBLRD*-
08428:  TBLRD*+
0842A:  MOVF   FF5,W
0842C:  MOVWF  FEE
0842E:  IORLW  00
08430:  BNZ   8428
....................       time_stamp(); 
08432:  CALL   5392
....................       strcat(event_buffer, time_stmp_str); 
08436:  MOVLW  01
08438:  MOVLB  8
0843A:  MOVWF  xD6
0843C:  MOVLW  03
0843E:  MOVWF  xD5
08440:  MOVLW  02
08442:  MOVWF  xD8
08444:  MOVLW  95
08446:  MOVWF  xD7
08448:  MOVLB  0
0844A:  CALL   5456
....................       strcat(event_buffer, event_str); 
0844E:  MOVLW  01
08450:  MOVLB  8
08452:  MOVWF  xD6
08454:  MOVLW  03
08456:  MOVWF  xD5
08458:  MOVLW  01
0845A:  MOVWF  xD8
0845C:  MOVLW  A3
0845E:  MOVWF  xD7
08460:  MOVLB  0
08462:  CALL   5456
....................       buffer_select = 1; 
08466:  MOVLW  01
08468:  MOVWF  x62
....................     
....................       heartbeat(FALSE); 
0846A:  MOVLB  8
0846C:  CLRF   xCA
0846E:  MOVLB  0
08470:  CALL   54FA
....................          append_data(file_ptr_events); 
08474:  MOVLW  03
08476:  MOVLB  8
08478:  MOVWF  xCB
0847A:  MOVLW  11
0847C:  MOVWF  xCA
0847E:  MOVLB  0
08480:  RCALL  822E
....................       heartbeat(TRUE); 
08482:  MOVLW  01
08484:  MOVLB  8
08486:  MOVWF  xCA
08488:  MOVLB  0
0848A:  CALL   54FA
0848E:  MOVLB  2
....................    } 
08490:  MOVLB  0
08492:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
02842:  BCF    F8B.2
02844:  MOVLW  0C
02846:  MOVWF  FBB
02848:  CLRF   FBE
0284A:  CLRF   FBF
0284C:  MOVLW  01
0284E:  MOVWF  F9C
02850:  MOVLW  F8
02852:  MOVLB  F
02854:  ANDWF  x2D,F
02856:  MOVLW  00
02858:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
0285A:  BCF    F8B.1
0285C:  MOVLW  0C
0285E:  MOVWF  x4E
02860:  CLRF   x51
02862:  CLRF   x52
02864:  MOVLW  01
02866:  MOVWF  x1B
02868:  MOVLW  C7
0286A:  ANDWF  x2D,F
0286C:  MOVLW  00
0286E:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
02870:  IORLW  05
02872:  MOVWF  FCA
02874:  MOVLW  7F
02876:  MOVWF  FCB
02878:  MOVLB  0
0287A:  GOTO   1B13E (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09C38:  MOVLW  34
09C3A:  MOVWF  FF6
09C3C:  MOVLW  0F
09C3E:  MOVWF  FF7
09C40:  MOVLW  00
09C42:  MOVWF  FF8
09C44:  CLRF   1B
09C46:  BTFSC  FF2.7
09C48:  BSF    1B.7
09C4A:  BCF    FF2.7
09C4C:  MOVLW  05
09C4E:  MOVLB  A
09C50:  MOVWF  x18
09C52:  MOVLB  0
09C54:  CALL   1006
09C58:  BTFSC  1B.7
09C5A:  BSF    FF2.7
09C5C:  MOVLW  10
09C5E:  MOVWF  FE9
09C60:  CLRF   1B
09C62:  BTFSC  FF2.7
09C64:  BSF    1B.7
09C66:  BCF    FF2.7
09C68:  MOVFF  793,A19
09C6C:  MOVFF  792,A18
09C70:  CALL   1188
09C74:  BTFSC  1B.7
09C76:  BSF    FF2.7
09C78:  MOVLW  2C
09C7A:  BTFSS  F9E.4
09C7C:  BRA    9C7A
09C7E:  MOVWF  FAD
09C80:  MOVLW  10
09C82:  MOVWF  FE9
09C84:  CLRF   1B
09C86:  BTFSC  FF2.7
09C88:  BSF    1B.7
09C8A:  BCF    FF2.7
09C8C:  MOVFF  795,A19
09C90:  MOVFF  794,A18
09C94:  CALL   1188
09C98:  BTFSC  1B.7
09C9A:  BSF    FF2.7
09C9C:  MOVLW  0D
09C9E:  BTFSS  F9E.4
09CA0:  BRA    9C9E
09CA2:  MOVWF  FAD
09CA4:  MOVLW  0A
09CA6:  BTFSS  F9E.4
09CA8:  BRA    9CA6
09CAA:  MOVWF  FAD
09CAC:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02C98:  MOVLW  86
02C9A:  MOVLB  8
02C9C:  MOVWF  x74
02C9E:  MOVLB  0
02CA0:  RCALL  2948
02CA2:  MOVFF  02,73F
02CA6:  MOVFF  01,73E
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02CAA:  MOVLW  8A
02CAC:  MOVLB  8
02CAE:  MOVWF  x74
02CB0:  MOVLB  0
02CB2:  RCALL  2948
02CB4:  MOVFF  02,743
02CB8:  MOVFF  01,742
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02CBC:  MOVLW  8E
02CBE:  MOVLB  8
02CC0:  MOVWF  x74
02CC2:  MOVLB  0
02CC4:  RCALL  2948
02CC6:  MOVFF  02,747
02CCA:  MOVFF  01,746
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02CCE:  MOVLW  92
02CD0:  MOVLB  8
02CD2:  MOVWF  x74
02CD4:  MOVLB  0
02CD6:  RCALL  2948
02CD8:  MOVFF  02,74B
02CDC:  MOVFF  01,74A
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02CE0:  MOVLW  96
02CE2:  MOVLB  8
02CE4:  MOVWF  x74
02CE6:  MOVLB  0
02CE8:  RCALL  2948
02CEA:  MOVFF  02,74F
02CEE:  MOVFF  01,74E
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02CF2:  MOVLW  9A
02CF4:  MOVLB  8
02CF6:  MOVWF  x74
02CF8:  MOVLB  0
02CFA:  RCALL  2948
02CFC:  MOVFF  02,753
02D00:  MOVFF  01,752
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02D04:  MOVLW  9E
02D06:  MOVLB  8
02D08:  MOVWF  x74
02D0A:  MOVLB  0
02D0C:  RCALL  2948
02D0E:  MOVFF  02,757
02D12:  MOVFF  01,756
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02D16:  MOVLW  A2
02D18:  MOVLB  8
02D1A:  MOVWF  x74
02D1C:  MOVLB  0
02D1E:  RCALL  2948
02D20:  MOVFF  02,75B
02D24:  MOVFF  01,75A
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02D28:  MOVLW  A6
02D2A:  MOVLB  8
02D2C:  MOVWF  x74
02D2E:  MOVLB  0
02D30:  RCALL  2948
02D32:  MOVFF  02,75F
02D36:  MOVFF  01,75E
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02D3A:  MOVLW  82
02D3C:  MOVLB  8
02D3E:  MOVWF  x74
02D40:  MOVLB  0
02D42:  RCALL  2948
02D44:  MOVFF  02,763
02D48:  MOVFF  01,762
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02D4C:  MOVLW  7E
02D4E:  MOVLB  8
02D50:  MOVWF  x74
02D52:  MOVLB  0
02D54:  RCALL  2948
02D56:  MOVFF  02,7BC
02D5A:  MOVFF  01,7BB
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02D5E:  MOVLW  AA
02D60:  MOVLB  8
02D62:  MOVWF  x74
02D64:  MOVLB  0
02D66:  RCALL  2948
02D68:  MOVFF  02,7C0
02D6C:  MOVFF  01,7BF
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02D70:  MOVLW  7A
02D72:  MOVLB  8
02D74:  MOVWF  x74
02D76:  MOVLB  0
02D78:  RCALL  2948
02D7A:  MOVFF  02,767
02D7E:  MOVFF  01,766
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02D82:  MOVLW  76
02D84:  MOVLB  8
02D86:  MOVWF  x74
02D88:  MOVLB  0
02D8A:  RCALL  2948
02D8C:  MOVFF  02,76B
02D90:  MOVFF  01,76A
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02D94:  MOVLW  72
02D96:  MOVLB  8
02D98:  MOVWF  x74
02D9A:  MOVLB  0
02D9C:  RCALL  2948
02D9E:  MOVFF  02,76F
02DA2:  MOVFF  01,76E
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02DA6:  MOVLW  6E
02DA8:  MOVLB  8
02DAA:  MOVWF  x74
02DAC:  MOVLB  0
02DAE:  RCALL  2948
02DB0:  MOVFF  02,793
02DB4:  MOVFF  01,792
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02DB8:  MOVLW  AE
02DBA:  MOVLB  8
02DBC:  MOVWF  x74
02DBE:  MOVLB  0
02DC0:  RCALL  2948
02DC2:  MOVFF  02,773
02DC6:  MOVFF  01,772
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02DCA:  MOVLW  B2
02DCC:  MOVLB  8
02DCE:  MOVWF  x74
02DD0:  MOVLB  0
02DD2:  RCALL  2948
02DD4:  MOVFF  02,7AC
02DD8:  MOVFF  01,7AB
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02DDC:  MOVLW  B6
02DDE:  MOVLB  8
02DE0:  MOVWF  x74
02DE2:  MOVLB  0
02DE4:  RCALL  2948
02DE6:  MOVFF  02,7B0
02DEA:  MOVFF  01,7AF
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02DEE:  MOVLW  BA
02DF0:  MOVLB  8
02DF2:  MOVWF  x74
02DF4:  MOVLB  0
02DF6:  RCALL  2948
02DF8:  MOVFF  02,777
02DFC:  MOVFF  01,776
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02E00:  MOVLW  BE
02E02:  MOVLB  8
02E04:  MOVWF  x74
02E06:  MOVLB  0
02E08:  RCALL  2948
02E0A:  MOVFF  02,77B
02E0E:  MOVFF  01,77A
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02E12:  MOVLW  C2
02E14:  MOVLB  8
02E16:  MOVWF  x74
02E18:  MOVLB  0
02E1A:  RCALL  2948
02E1C:  MOVFF  02,77F
02E20:  MOVFF  01,77E
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02E24:  MOVLW  88
02E26:  MOVLB  8
02E28:  MOVWF  x74
02E2A:  MOVLB  0
02E2C:  RCALL  2948
02E2E:  MOVFF  02,741
02E32:  MOVFF  01,740
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02E36:  MOVLW  8C
02E38:  MOVLB  8
02E3A:  MOVWF  x74
02E3C:  MOVLB  0
02E3E:  RCALL  2948
02E40:  MOVFF  02,745
02E44:  MOVFF  01,744
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02E48:  MOVLW  90
02E4A:  MOVLB  8
02E4C:  MOVWF  x74
02E4E:  MOVLB  0
02E50:  RCALL  2948
02E52:  MOVFF  02,749
02E56:  MOVFF  01,748
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02E5A:  MOVLW  94
02E5C:  MOVLB  8
02E5E:  MOVWF  x74
02E60:  MOVLB  0
02E62:  RCALL  2948
02E64:  MOVFF  02,74D
02E68:  MOVFF  01,74C
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02E6C:  MOVLW  98
02E6E:  MOVLB  8
02E70:  MOVWF  x74
02E72:  MOVLB  0
02E74:  RCALL  2948
02E76:  MOVFF  02,751
02E7A:  MOVFF  01,750
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02E7E:  MOVLW  9C
02E80:  MOVLB  8
02E82:  MOVWF  x74
02E84:  MOVLB  0
02E86:  RCALL  2948
02E88:  MOVFF  02,755
02E8C:  MOVFF  01,754
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02E90:  MOVLW  A0
02E92:  MOVLB  8
02E94:  MOVWF  x74
02E96:  MOVLB  0
02E98:  RCALL  2948
02E9A:  MOVFF  02,759
02E9E:  MOVFF  01,758
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02EA2:  MOVLW  A4
02EA4:  MOVLB  8
02EA6:  MOVWF  x74
02EA8:  MOVLB  0
02EAA:  RCALL  2948
02EAC:  MOVFF  02,75D
02EB0:  MOVFF  01,75C
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02EB4:  MOVLW  A8
02EB6:  MOVLB  8
02EB8:  MOVWF  x74
02EBA:  MOVLB  0
02EBC:  RCALL  2948
02EBE:  MOVFF  02,761
02EC2:  MOVFF  01,760
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02EC6:  MOVLW  84
02EC8:  MOVLB  8
02ECA:  MOVWF  x74
02ECC:  MOVLB  0
02ECE:  RCALL  2948
02ED0:  MOVFF  02,765
02ED4:  MOVFF  01,764
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02ED8:  MOVLW  80
02EDA:  MOVLB  8
02EDC:  MOVWF  x74
02EDE:  MOVLB  0
02EE0:  RCALL  2948
02EE2:  MOVFF  02,7BE
02EE6:  MOVFF  01,7BD
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02EEA:  MOVLW  AC
02EEC:  MOVLB  8
02EEE:  MOVWF  x74
02EF0:  MOVLB  0
02EF2:  RCALL  2948
02EF4:  MOVFF  02,7C2
02EF8:  MOVFF  01,7C1
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02EFC:  MOVLW  7C
02EFE:  MOVLB  8
02F00:  MOVWF  x74
02F02:  MOVLB  0
02F04:  RCALL  2948
02F06:  MOVFF  02,769
02F0A:  MOVFF  01,768
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02F0E:  MOVLW  78
02F10:  MOVLB  8
02F12:  MOVWF  x74
02F14:  MOVLB  0
02F16:  RCALL  2948
02F18:  MOVFF  02,76D
02F1C:  MOVFF  01,76C
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02F20:  MOVLW  74
02F22:  MOVLB  8
02F24:  MOVWF  x74
02F26:  MOVLB  0
02F28:  RCALL  2948
02F2A:  MOVFF  02,771
02F2E:  MOVFF  01,770
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
02F32:  MOVLW  70
02F34:  MOVLB  8
02F36:  MOVWF  x74
02F38:  MOVLB  0
02F3A:  RCALL  2948
02F3C:  MOVFF  02,795
02F40:  MOVFF  01,794
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
02F44:  MOVLW  B0
02F46:  MOVLB  8
02F48:  MOVWF  x74
02F4A:  MOVLB  0
02F4C:  RCALL  2948
02F4E:  MOVFF  02,775
02F52:  MOVFF  01,774
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
02F56:  MOVLW  B4
02F58:  MOVLB  8
02F5A:  MOVWF  x74
02F5C:  MOVLB  0
02F5E:  RCALL  2948
02F60:  MOVFF  02,7AE
02F64:  MOVFF  01,7AD
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
02F68:  MOVLW  B8
02F6A:  MOVLB  8
02F6C:  MOVWF  x74
02F6E:  MOVLB  0
02F70:  RCALL  2948
02F72:  MOVFF  02,7B2
02F76:  MOVFF  01,7B1
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
02F7A:  MOVLW  BC
02F7C:  MOVLB  8
02F7E:  MOVWF  x74
02F80:  MOVLB  0
02F82:  RCALL  2948
02F84:  MOVFF  02,779
02F88:  MOVFF  01,778
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
02F8C:  MOVLW  C0
02F8E:  MOVLB  8
02F90:  MOVWF  x74
02F92:  MOVLB  0
02F94:  RCALL  2948
02F96:  MOVFF  02,77D
02F9A:  MOVFF  01,77C
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
02F9E:  MOVLW  C4
02FA0:  MOVLB  8
02FA2:  MOVWF  x74
02FA4:  MOVLB  0
02FA6:  RCALL  2948
02FA8:  MOVFF  02,781
02FAC:  MOVFF  01,780
....................     
....................    motor=0; 
02FB0:  MOVLB  7
02FB2:  CLRF   x3C
....................    m_fixed=1; 
02FB4:  MOVLW  01
02FB6:  MOVWF  x3D
....................    m_step_cnt[0]=0; 
02FB8:  CLRF   xA1
02FBA:  CLRF   xA0
02FBC:  CLRF   x9F
02FBE:  CLRF   x9E
....................    m_step_cnt[1]=0; 
02FC0:  CLRF   xA5
02FC2:  CLRF   xA4
02FC4:  CLRF   xA3
02FC6:  CLRF   xA2
....................    e_cha_cnt[0]=0; 
02FC8:  CLRF   xB8
02FCA:  CLRF   xB7
....................    e_cha_cnt[1]=0;  
02FCC:  CLRF   xBA
02FCE:  CLRF   xB9
....................    m_gb_cnt[0]=0; 
02FD0:  CLRF   x97
02FD2:  CLRF   x96
....................    m_gb_cnt[1]=0; 
02FD4:  CLRF   x99
02FD6:  CLRF   x98
....................    e_mode_rst[0]=0; 
02FD8:  CLRF   x9B
02FDA:  CLRF   x9A
....................    e_mode_rst[1]=0;    
02FDC:  CLRF   x9D
02FDE:  CLRF   x9C
....................    e_port_dist[0]=0; 
02FE0:  CLRF   xB4
02FE2:  CLRF   xB3
....................    e_port_dist[1]=0; 
02FE4:  CLRF   xB6
02FE6:  CLRF   xB5
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
02FE8:  MOVFF  773,8B9
02FEC:  MOVFF  772,8B8
02FF0:  MOVFF  75F,8BB
02FF4:  MOVFF  75E,8BA
02FF8:  MOVLB  0
02FFA:  RCALL  2C52
02FFC:  BCF    FD8.0
02FFE:  MOVLB  8
03000:  RLCF   01,W
03002:  MOVLB  7
03004:  MOVWF  xA7
03006:  MOVLB  8
03008:  RLCF   02,W
0300A:  MOVLB  7
0300C:  MOVWF  xA8
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
0300E:  MOVFF  775,8B9
03012:  MOVFF  774,8B8
03016:  MOVFF  761,8BB
0301A:  MOVFF  760,8BA
0301E:  MOVLB  0
03020:  RCALL  2C52
03022:  BCF    FD8.0
03024:  MOVLB  8
03026:  RLCF   01,W
03028:  MOVLB  7
0302A:  MOVWF  xA9
0302C:  MOVLB  8
0302E:  RLCF   02,W
03030:  MOVLB  7
03032:  MOVWF  xAA
03034:  MOVLB  0
03036:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
19BAA:  MOVLW  86
19BAC:  MOVLB  8
19BAE:  MOVWF  xCB
19BB0:  CLRF   xCD
19BB2:  MOVLW  01
19BB4:  MOVWF  xCC
19BB6:  MOVLB  0
19BB8:  CALL   4F4C
....................    write16(ADDR_M1_MODE,FULL); 
19BBC:  MOVLW  8A
19BBE:  MOVLB  8
19BC0:  MOVWF  xCB
19BC2:  CLRF   xCD
19BC4:  CLRF   xCC
19BC6:  MOVLB  0
19BC8:  CALL   4F4C
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
19BCC:  MOVLW  8E
19BCE:  MOVLB  8
19BD0:  MOVWF  xCB
19BD2:  CLRF   xCD
19BD4:  MOVLW  0A
19BD6:  MOVWF  xCC
19BD8:  MOVLB  0
19BDA:  CALL   4F4C
....................    write16(ADDR_M1_POS_DIR,0); 
19BDE:  MOVLW  92
19BE0:  MOVLB  8
19BE2:  MOVWF  xCB
19BE4:  CLRF   xCD
19BE6:  CLRF   xCC
19BE8:  MOVLB  0
19BEA:  CALL   4F4C
....................    write16(ADDR_M1_PWM_HLD,0); 
19BEE:  MOVLW  96
19BF0:  MOVLB  8
19BF2:  MOVWF  xCB
19BF4:  CLRF   xCD
19BF6:  CLRF   xCC
19BF8:  MOVLB  0
19BFA:  CALL   4F4C
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
19BFE:  MOVLW  9A
19C00:  MOVLB  8
19C02:  MOVWF  xCB
19C04:  CLRF   xCD
19C06:  MOVLW  7F
19C08:  MOVWF  xCC
19C0A:  MOVLB  0
19C0C:  CALL   4F4C
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
19C10:  MOVLW  9E
19C12:  MOVLB  8
19C14:  MOVWF  xCB
19C16:  MOVLW  17
19C18:  MOVWF  xCD
19C1A:  MOVLW  70
19C1C:  MOVWF  xCC
19C1E:  MOVLB  0
19C20:  CALL   4F4C
....................    write16(ADDR_E1_CPR,16); 
19C24:  MOVLW  A2
19C26:  MOVLB  8
19C28:  MOVWF  xCB
19C2A:  CLRF   xCD
19C2C:  MOVLW  10
19C2E:  MOVWF  xCC
19C30:  MOVLB  0
19C32:  CALL   4F4C
....................    write16(ADDR_E1_PPR,16); 
19C36:  MOVLW  A6
19C38:  MOVLB  8
19C3A:  MOVWF  xCB
19C3C:  CLRF   xCD
19C3E:  MOVLW  10
19C40:  MOVWF  xCC
19C42:  MOVLB  0
19C44:  CALL   4F4C
....................    write16(ADDR_E1_MODE,2); 
19C48:  MOVLW  82
19C4A:  MOVLB  8
19C4C:  MOVWF  xCB
19C4E:  CLRF   xCD
19C50:  MOVLW  02
19C52:  MOVWF  xCC
19C54:  MOVLB  0
19C56:  CALL   4F4C
....................    write16(ADDR_E1_POS,0); 
19C5A:  MOVLW  7E
19C5C:  MOVLB  8
19C5E:  MOVWF  xCB
19C60:  CLRF   xCD
19C62:  CLRF   xCC
19C64:  MOVLB  0
19C66:  CALL   4F4C
....................    write16(ADDR_E1_PORT,0); 
19C6A:  MOVLW  AA
19C6C:  MOVLB  8
19C6E:  MOVWF  xCB
19C70:  CLRF   xCD
19C72:  CLRF   xCC
19C74:  MOVLB  0
19C76:  CALL   4F4C
....................    write16(ADDR_E1_TYPE,2); 
19C7A:  MOVLW  7A
19C7C:  MOVLB  8
19C7E:  MOVWF  xCB
19C80:  CLRF   xCD
19C82:  MOVLW  02
19C84:  MOVWF  xCC
19C86:  MOVLB  0
19C88:  CALL   4F4C
....................    write16(ADDR_M1_RUN,270); 
19C8C:  MOVLW  76
19C8E:  MOVLB  8
19C90:  MOVWF  xCB
19C92:  MOVLW  01
19C94:  MOVWF  xCD
19C96:  MOVLW  0E
19C98:  MOVWF  xCC
19C9A:  MOVLB  0
19C9C:  CALL   4F4C
....................    write16(ADDR_M1_BKLSH,0); 
19CA0:  MOVLW  72
19CA2:  MOVLB  8
19CA4:  MOVWF  xCB
19CA6:  CLRF   xCD
19CA8:  CLRF   xCC
19CAA:  MOVLB  0
19CAC:  CALL   4F4C
....................    write16(ADDR_M1_ERROR,0);   
19CB0:  MOVLW  6E
19CB2:  MOVLB  8
19CB4:  MOVWF  xCB
19CB6:  CLRF   xCD
19CB8:  CLRF   xCC
19CBA:  MOVLB  0
19CBC:  CALL   4F4C
....................    write16(ADDR_M1_SPR,38400); 
19CC0:  MOVLW  AE
19CC2:  MOVLB  8
19CC4:  MOVWF  xCB
19CC6:  MOVLW  96
19CC8:  MOVWF  xCD
19CCA:  CLRF   xCC
19CCC:  MOVLB  0
19CCE:  CALL   4F4C
....................    write16(ADDR_M1_COMP,0); 
19CD2:  MOVLW  B2
19CD4:  MOVLB  8
19CD6:  MOVWF  xCB
19CD8:  CLRF   xCD
19CDA:  CLRF   xCC
19CDC:  MOVLB  0
19CDE:  CALL   4F4C
....................    write16(ADDR_M1_LIN_POS,0); 
19CE2:  MOVLW  B6
19CE4:  MOVLB  8
19CE6:  MOVWF  xCB
19CE8:  CLRF   xCD
19CEA:  CLRF   xCC
19CEC:  MOVLB  0
19CEE:  CALL   4F4C
....................    write16(ADDR_E1_INDEX,1); 
19CF2:  MOVLW  BA
19CF4:  MOVLB  8
19CF6:  MOVWF  xCB
19CF8:  CLRF   xCD
19CFA:  MOVLW  01
19CFC:  MOVWF  xCC
19CFE:  MOVLB  0
19D00:  CALL   4F4C
....................    write16(ADDR_M1_EVN_SO,0); 
19D04:  MOVLW  BE
19D06:  MOVLB  8
19D08:  MOVWF  xCB
19D0A:  CLRF   xCD
19D0C:  CLRF   xCC
19D0E:  MOVLB  0
19D10:  CALL   4F4C
....................    write16(ADDR_M1_ALIGN_OS,0); 
19D14:  MOVLW  C2
19D16:  MOVLB  8
19D18:  MOVWF  xCB
19D1A:  CLRF   xCD
19D1C:  CLRF   xCC
19D1E:  MOVLB  0
19D20:  CALL   4F4C
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
19D24:  MOVLW  88
19D26:  MOVLB  8
19D28:  MOVWF  xCB
19D2A:  CLRF   xCD
19D2C:  MOVLW  01
19D2E:  MOVWF  xCC
19D30:  MOVLB  0
19D32:  CALL   4F4C
....................    write16(ADDR_M2_MODE,HALF); 
19D36:  MOVLW  8C
19D38:  MOVLB  8
19D3A:  MOVWF  xCB
19D3C:  CLRF   xCD
19D3E:  MOVLW  01
19D40:  MOVWF  xCC
19D42:  MOVLB  0
19D44:  CALL   4F4C
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
19D48:  MOVLW  90
19D4A:  MOVLB  8
19D4C:  MOVWF  xCB
19D4E:  CLRF   xCD
19D50:  MOVLW  05
19D52:  MOVWF  xCC
19D54:  MOVLB  0
19D56:  CALL   4F4C
....................    write16(ADDR_M2_POS_DIR,0); 
19D5A:  MOVLW  94
19D5C:  MOVLB  8
19D5E:  MOVWF  xCB
19D60:  CLRF   xCD
19D62:  CLRF   xCC
19D64:  MOVLB  0
19D66:  CALL   4F4C
....................    write16(ADDR_M2_PWM_HLD,0); 
19D6A:  MOVLW  98
19D6C:  MOVLB  8
19D6E:  MOVWF  xCB
19D70:  CLRF   xCD
19D72:  CLRF   xCC
19D74:  MOVLB  0
19D76:  CALL   4F4C
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
19D7A:  MOVLW  9C
19D7C:  MOVLB  8
19D7E:  MOVWF  xCB
19D80:  CLRF   xCD
19D82:  MOVLW  7F
19D84:  MOVWF  xCC
19D86:  MOVLB  0
19D88:  CALL   4F4C
....................    write16(ADDR_M2_GB_ERR,0); 
19D8C:  MOVLW  A0
19D8E:  MOVLB  8
19D90:  MOVWF  xCB
19D92:  CLRF   xCD
19D94:  CLRF   xCC
19D96:  MOVLB  0
19D98:  CALL   4F4C
....................    write16(ADDR_E2_CPR,0); 
19D9C:  MOVLW  A4
19D9E:  MOVLB  8
19DA0:  MOVWF  xCB
19DA2:  CLRF   xCD
19DA4:  CLRF   xCC
19DA6:  MOVLB  0
19DA8:  CALL   4F4C
....................    write16(ADDR_E2_PPR,0);   
19DAC:  MOVLW  A8
19DAE:  MOVLB  8
19DB0:  MOVWF  xCB
19DB2:  CLRF   xCD
19DB4:  CLRF   xCC
19DB6:  MOVLB  0
19DB8:  CALL   4F4C
....................    write16(ADDR_E2_MODE,0); 
19DBC:  MOVLW  84
19DBE:  MOVLB  8
19DC0:  MOVWF  xCB
19DC2:  CLRF   xCD
19DC4:  CLRF   xCC
19DC6:  MOVLB  0
19DC8:  CALL   4F4C
....................    write16(ADDR_E2_POS,0); 
19DCC:  MOVLW  80
19DCE:  MOVLB  8
19DD0:  MOVWF  xCB
19DD2:  CLRF   xCD
19DD4:  CLRF   xCC
19DD6:  MOVLB  0
19DD8:  CALL   4F4C
....................    write16(ADDR_E2_PORT,0); 
19DDC:  MOVLW  AC
19DDE:  MOVLB  8
19DE0:  MOVWF  xCB
19DE2:  CLRF   xCD
19DE4:  CLRF   xCC
19DE6:  MOVLB  0
19DE8:  CALL   4F4C
....................    write16(ADDR_E2_TYPE,0); 
19DEC:  MOVLW  7C
19DEE:  MOVLB  8
19DF0:  MOVWF  xCB
19DF2:  CLRF   xCD
19DF4:  CLRF   xCC
19DF6:  MOVLB  0
19DF8:  CALL   4F4C
....................    write16(ADDR_M2_RUN,0); 
19DFC:  MOVLW  78
19DFE:  MOVLB  8
19E00:  MOVWF  xCB
19E02:  CLRF   xCD
19E04:  CLRF   xCC
19E06:  MOVLB  0
19E08:  CALL   4F4C
....................    write16(ADDR_M2_BKLSH,0); 
19E0C:  MOVLW  74
19E0E:  MOVLB  8
19E10:  MOVWF  xCB
19E12:  CLRF   xCD
19E14:  CLRF   xCC
19E16:  MOVLB  0
19E18:  CALL   4F4C
....................    write16(ADDR_M2_ERROR,0);   
19E1C:  MOVLW  70
19E1E:  MOVLB  8
19E20:  MOVWF  xCB
19E22:  CLRF   xCD
19E24:  CLRF   xCC
19E26:  MOVLB  0
19E28:  CALL   4F4C
....................    write16(ADDR_M2_SPR,0); 
19E2C:  MOVLW  B0
19E2E:  MOVLB  8
19E30:  MOVWF  xCB
19E32:  CLRF   xCD
19E34:  CLRF   xCC
19E36:  MOVLB  0
19E38:  CALL   4F4C
....................    write16(ADDR_M2_COMP,0); 
19E3C:  MOVLW  B4
19E3E:  MOVLB  8
19E40:  MOVWF  xCB
19E42:  CLRF   xCD
19E44:  CLRF   xCC
19E46:  MOVLB  0
19E48:  CALL   4F4C
....................    write16(ADDR_M2_LIN_POS,0);    
19E4C:  MOVLW  B8
19E4E:  MOVLB  8
19E50:  MOVWF  xCB
19E52:  CLRF   xCD
19E54:  CLRF   xCC
19E56:  MOVLB  0
19E58:  CALL   4F4C
....................    write16(ADDR_E2_INDEX,0); 
19E5C:  MOVLW  BC
19E5E:  MOVLB  8
19E60:  MOVWF  xCB
19E62:  CLRF   xCD
19E64:  CLRF   xCC
19E66:  MOVLB  0
19E68:  CALL   4F4C
....................    write16(ADDR_M2_EVN_SO,0); 
19E6C:  MOVLW  C0
19E6E:  MOVLB  8
19E70:  MOVWF  xCB
19E72:  CLRF   xCD
19E74:  CLRF   xCC
19E76:  MOVLB  0
19E78:  CALL   4F4C
....................    write16(ADDR_M2_ALIGN_OS,0); 
19E7C:  MOVLW  C4
19E7E:  MOVLB  8
19E80:  MOVWF  xCB
19E82:  CLRF   xCD
19E84:  CLRF   xCC
19E86:  MOVLB  0
19E88:  CALL   4F4C
....................     
....................    get_step_vars(); 
19E8C:  CALL   2C98
19E90:  GOTO   1A6DA (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
19E94:  MOVLW  86
19E96:  MOVLB  8
19E98:  MOVWF  xCB
19E9A:  CLRF   xCD
19E9C:  MOVLW  01
19E9E:  MOVWF  xCC
19EA0:  MOVLB  0
19EA2:  CALL   4F4C
....................    write16(ADDR_M1_MODE,FULL); 
19EA6:  MOVLW  8A
19EA8:  MOVLB  8
19EAA:  MOVWF  xCB
19EAC:  CLRF   xCD
19EAE:  CLRF   xCC
19EB0:  MOVLB  0
19EB2:  CALL   4F4C
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
19EB6:  MOVLW  8E
19EB8:  MOVLB  8
19EBA:  MOVWF  xCB
19EBC:  CLRF   xCD
19EBE:  MOVLW  14
19EC0:  MOVWF  xCC
19EC2:  MOVLB  0
19EC4:  CALL   4F4C
....................    write16(ADDR_M1_POS_DIR,1); 
19EC8:  MOVLW  92
19ECA:  MOVLB  8
19ECC:  MOVWF  xCB
19ECE:  CLRF   xCD
19ED0:  MOVLW  01
19ED2:  MOVWF  xCC
19ED4:  MOVLB  0
19ED6:  CALL   4F4C
....................    write16(ADDR_M1_PWM_HLD,51); 
19EDA:  MOVLW  96
19EDC:  MOVLB  8
19EDE:  MOVWF  xCB
19EE0:  CLRF   xCD
19EE2:  MOVLW  33
19EE4:  MOVWF  xCC
19EE6:  MOVLB  0
19EE8:  CALL   4F4C
....................    write16(ADDR_M1_PWM_DRV,511); 
19EEC:  MOVLW  9A
19EEE:  MOVLB  8
19EF0:  MOVWF  xCB
19EF2:  MOVLW  01
19EF4:  MOVWF  xCD
19EF6:  SETF   xCC
19EF8:  MOVLB  0
19EFA:  CALL   4F4C
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
19EFE:  MOVLW  9E
19F00:  MOVLB  8
19F02:  MOVWF  xCB
19F04:  MOVLW  02
19F06:  MOVWF  xCD
19F08:  MOVLW  9E
19F0A:  MOVWF  xCC
19F0C:  MOVLB  0
19F0E:  CALL   4F4C
....................    write16(ADDR_E1_CPR,24); 
19F12:  MOVLW  A2
19F14:  MOVLB  8
19F16:  MOVWF  xCB
19F18:  CLRF   xCD
19F1A:  MOVLW  18
19F1C:  MOVWF  xCC
19F1E:  MOVLB  0
19F20:  CALL   4F4C
....................    write16(ADDR_E1_PPR,48); 
19F24:  MOVLW  A6
19F26:  MOVLB  8
19F28:  MOVWF  xCB
19F2A:  CLRF   xCD
19F2C:  MOVLW  30
19F2E:  MOVWF  xCC
19F30:  MOVLB  0
19F32:  CALL   4F4C
....................    write16(ADDR_E1_MODE,2); 
19F36:  MOVLW  82
19F38:  MOVLB  8
19F3A:  MOVWF  xCB
19F3C:  CLRF   xCD
19F3E:  MOVLW  02
19F40:  MOVWF  xCC
19F42:  MOVLB  0
19F44:  CALL   4F4C
....................    write16(ADDR_E1_POS,0); 
19F48:  MOVLW  7E
19F4A:  MOVLB  8
19F4C:  MOVWF  xCB
19F4E:  CLRF   xCD
19F50:  CLRF   xCC
19F52:  MOVLB  0
19F54:  CALL   4F4C
....................    write16(ADDR_E1_PORT,0); 
19F58:  MOVLW  AA
19F5A:  MOVLB  8
19F5C:  MOVWF  xCB
19F5E:  CLRF   xCD
19F60:  CLRF   xCC
19F62:  MOVLB  0
19F64:  CALL   4F4C
....................    write16(ADDR_E1_TYPE,2); 
19F68:  MOVLW  7A
19F6A:  MOVLB  8
19F6C:  MOVWF  xCB
19F6E:  CLRF   xCD
19F70:  MOVLW  02
19F72:  MOVWF  xCC
19F74:  MOVLB  0
19F76:  CALL   4F4C
....................    write16(ADDR_M1_RUN,34); 
19F7A:  MOVLW  76
19F7C:  MOVLB  8
19F7E:  MOVWF  xCB
19F80:  CLRF   xCD
19F82:  MOVLW  22
19F84:  MOVWF  xCC
19F86:  MOVLB  0
19F88:  CALL   4F4C
....................    write16(ADDR_M1_BKLSH,0); 
19F8C:  MOVLW  72
19F8E:  MOVLB  8
19F90:  MOVWF  xCB
19F92:  CLRF   xCD
19F94:  CLRF   xCC
19F96:  MOVLB  0
19F98:  CALL   4F4C
....................    write16(ADDR_M1_ERROR,0);   
19F9C:  MOVLW  6E
19F9E:  MOVLB  8
19FA0:  MOVWF  xCB
19FA2:  CLRF   xCD
19FA4:  CLRF   xCC
19FA6:  MOVLB  0
19FA8:  CALL   4F4C
....................    write16(ADDR_M1_SPR,6400); 
19FAC:  MOVLW  AE
19FAE:  MOVLB  8
19FB0:  MOVWF  xCB
19FB2:  MOVLW  19
19FB4:  MOVWF  xCD
19FB6:  CLRF   xCC
19FB8:  MOVLB  0
19FBA:  CALL   4F4C
....................    write16(ADDR_M1_COMP,0); 
19FBE:  MOVLW  B2
19FC0:  MOVLB  8
19FC2:  MOVWF  xCB
19FC4:  CLRF   xCD
19FC6:  CLRF   xCC
19FC8:  MOVLB  0
19FCA:  CALL   4F4C
....................    write16(ADDR_M1_LIN_POS,0); 
19FCE:  MOVLW  B6
19FD0:  MOVLB  8
19FD2:  MOVWF  xCB
19FD4:  CLRF   xCD
19FD6:  CLRF   xCC
19FD8:  MOVLB  0
19FDA:  CALL   4F4C
....................    write16(ADDR_E1_INDEX,1);    
19FDE:  MOVLW  BA
19FE0:  MOVLB  8
19FE2:  MOVWF  xCB
19FE4:  CLRF   xCD
19FE6:  MOVLW  01
19FE8:  MOVWF  xCC
19FEA:  MOVLB  0
19FEC:  CALL   4F4C
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
19FF0:  MOVLW  88
19FF2:  MOVLB  8
19FF4:  MOVWF  xCB
19FF6:  CLRF   xCD
19FF8:  MOVLW  01
19FFA:  MOVWF  xCC
19FFC:  MOVLB  0
19FFE:  CALL   4F4C
....................    write16(ADDR_M2_MODE,HALF); 
1A002:  MOVLW  8C
1A004:  MOVLB  8
1A006:  MOVWF  xCB
1A008:  CLRF   xCD
1A00A:  MOVLW  01
1A00C:  MOVWF  xCC
1A00E:  MOVLB  0
1A010:  CALL   4F4C
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A014:  MOVLW  90
1A016:  MOVLB  8
1A018:  MOVWF  xCB
1A01A:  CLRF   xCD
1A01C:  MOVLW  28
1A01E:  MOVWF  xCC
1A020:  MOVLB  0
1A022:  CALL   4F4C
....................    write16(ADDR_M2_POS_DIR,0); 
1A026:  MOVLW  94
1A028:  MOVLB  8
1A02A:  MOVWF  xCB
1A02C:  CLRF   xCD
1A02E:  CLRF   xCC
1A030:  MOVLB  0
1A032:  CALL   4F4C
....................    write16(ADDR_M2_PWM_HLD,0); 
1A036:  MOVLW  98
1A038:  MOVLB  8
1A03A:  MOVWF  xCB
1A03C:  CLRF   xCD
1A03E:  CLRF   xCC
1A040:  MOVLB  0
1A042:  CALL   4F4C
....................    write16(ADDR_M2_PWM_DRV,511); 
1A046:  MOVLW  9C
1A048:  MOVLB  8
1A04A:  MOVWF  xCB
1A04C:  MOVLW  01
1A04E:  MOVWF  xCD
1A050:  SETF   xCC
1A052:  MOVLB  0
1A054:  CALL   4F4C
....................    write16(ADDR_M2_GB_ERR,0); 
1A058:  MOVLW  A0
1A05A:  MOVLB  8
1A05C:  MOVWF  xCB
1A05E:  CLRF   xCD
1A060:  CLRF   xCC
1A062:  MOVLB  0
1A064:  CALL   4F4C
....................    write16(ADDR_E2_CPR,0); 
1A068:  MOVLW  A4
1A06A:  MOVLB  8
1A06C:  MOVWF  xCB
1A06E:  CLRF   xCD
1A070:  CLRF   xCC
1A072:  MOVLB  0
1A074:  CALL   4F4C
....................    write16(ADDR_E2_PPR,0);   
1A078:  MOVLW  A8
1A07A:  MOVLB  8
1A07C:  MOVWF  xCB
1A07E:  CLRF   xCD
1A080:  CLRF   xCC
1A082:  MOVLB  0
1A084:  CALL   4F4C
....................    write16(ADDR_E2_MODE,0); 
1A088:  MOVLW  84
1A08A:  MOVLB  8
1A08C:  MOVWF  xCB
1A08E:  CLRF   xCD
1A090:  CLRF   xCC
1A092:  MOVLB  0
1A094:  CALL   4F4C
....................    write16(ADDR_E2_POS,0); 
1A098:  MOVLW  80
1A09A:  MOVLB  8
1A09C:  MOVWF  xCB
1A09E:  CLRF   xCD
1A0A0:  CLRF   xCC
1A0A2:  MOVLB  0
1A0A4:  CALL   4F4C
....................    write16(ADDR_E2_PORT,0); 
1A0A8:  MOVLW  AC
1A0AA:  MOVLB  8
1A0AC:  MOVWF  xCB
1A0AE:  CLRF   xCD
1A0B0:  CLRF   xCC
1A0B2:  MOVLB  0
1A0B4:  CALL   4F4C
....................    write16(ADDR_E2_TYPE,0); 
1A0B8:  MOVLW  7C
1A0BA:  MOVLB  8
1A0BC:  MOVWF  xCB
1A0BE:  CLRF   xCD
1A0C0:  CLRF   xCC
1A0C2:  MOVLB  0
1A0C4:  CALL   4F4C
....................    write16(ADDR_M2_RUN,0); 
1A0C8:  MOVLW  78
1A0CA:  MOVLB  8
1A0CC:  MOVWF  xCB
1A0CE:  CLRF   xCD
1A0D0:  CLRF   xCC
1A0D2:  MOVLB  0
1A0D4:  CALL   4F4C
....................    write16(ADDR_M2_BKLSH,0); 
1A0D8:  MOVLW  74
1A0DA:  MOVLB  8
1A0DC:  MOVWF  xCB
1A0DE:  CLRF   xCD
1A0E0:  CLRF   xCC
1A0E2:  MOVLB  0
1A0E4:  CALL   4F4C
....................    write16(ADDR_M2_ERROR,0);   
1A0E8:  MOVLW  70
1A0EA:  MOVLB  8
1A0EC:  MOVWF  xCB
1A0EE:  CLRF   xCD
1A0F0:  CLRF   xCC
1A0F2:  MOVLB  0
1A0F4:  CALL   4F4C
....................    write16(ADDR_M2_SPR,0); 
1A0F8:  MOVLW  B0
1A0FA:  MOVLB  8
1A0FC:  MOVWF  xCB
1A0FE:  CLRF   xCD
1A100:  CLRF   xCC
1A102:  MOVLB  0
1A104:  CALL   4F4C
....................    write16(ADDR_M2_COMP,0); 
1A108:  MOVLW  B4
1A10A:  MOVLB  8
1A10C:  MOVWF  xCB
1A10E:  CLRF   xCD
1A110:  CLRF   xCC
1A112:  MOVLB  0
1A114:  CALL   4F4C
....................    write16(ADDR_M2_LIN_POS,0);   
1A118:  MOVLW  B8
1A11A:  MOVLB  8
1A11C:  MOVWF  xCB
1A11E:  CLRF   xCD
1A120:  CLRF   xCC
1A122:  MOVLB  0
1A124:  CALL   4F4C
....................    write16(ADDR_E2_INDEX,0);    
1A128:  MOVLW  BC
1A12A:  MOVLB  8
1A12C:  MOVWF  xCB
1A12E:  CLRF   xCD
1A130:  CLRF   xCC
1A132:  MOVLB  0
1A134:  CALL   4F4C
....................     
....................    get_step_vars(); 
1A138:  CALL   2C98
1A13C:  GOTO   1A6DA (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A140:  MOVLW  86
1A142:  MOVLB  8
1A144:  MOVWF  xCB
1A146:  CLRF   xCD
1A148:  MOVLW  01
1A14A:  MOVWF  xCC
1A14C:  MOVLB  0
1A14E:  CALL   4F4C
....................    write16(ADDR_M1_MODE,FULL); 
1A152:  MOVLW  8A
1A154:  MOVLB  8
1A156:  MOVWF  xCB
1A158:  CLRF   xCD
1A15A:  CLRF   xCC
1A15C:  MOVLB  0
1A15E:  CALL   4F4C
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A162:  MOVLW  8E
1A164:  MOVLB  8
1A166:  MOVWF  xCB
1A168:  CLRF   xCD
1A16A:  MOVLW  0A
1A16C:  MOVWF  xCC
1A16E:  MOVLB  0
1A170:  CALL   4F4C
....................    write16(ADDR_M1_POS_DIR,0); 
1A174:  MOVLW  92
1A176:  MOVLB  8
1A178:  MOVWF  xCB
1A17A:  CLRF   xCD
1A17C:  CLRF   xCC
1A17E:  MOVLB  0
1A180:  CALL   4F4C
....................    write16(ADDR_M1_PWM_HLD,0); 
1A184:  MOVLW  96
1A186:  MOVLB  8
1A188:  MOVWF  xCB
1A18A:  CLRF   xCD
1A18C:  CLRF   xCC
1A18E:  MOVLB  0
1A190:  CALL   4F4C
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A194:  MOVLW  9A
1A196:  MOVLB  8
1A198:  MOVWF  xCB
1A19A:  CLRF   xCD
1A19C:  MOVLW  7F
1A19E:  MOVWF  xCC
1A1A0:  MOVLB  0
1A1A2:  CALL   4F4C
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A1A6:  MOVLW  9E
1A1A8:  MOVLB  8
1A1AA:  MOVWF  xCB
1A1AC:  MOVLW  17
1A1AE:  MOVWF  xCD
1A1B0:  MOVLW  70
1A1B2:  MOVWF  xCC
1A1B4:  MOVLB  0
1A1B6:  CALL   4F4C
....................    write16(ADDR_E1_CPR,16); 
1A1BA:  MOVLW  A2
1A1BC:  MOVLB  8
1A1BE:  MOVWF  xCB
1A1C0:  CLRF   xCD
1A1C2:  MOVLW  10
1A1C4:  MOVWF  xCC
1A1C6:  MOVLB  0
1A1C8:  CALL   4F4C
....................    write16(ADDR_E1_PPR,16); 
1A1CC:  MOVLW  A6
1A1CE:  MOVLB  8
1A1D0:  MOVWF  xCB
1A1D2:  CLRF   xCD
1A1D4:  MOVLW  10
1A1D6:  MOVWF  xCC
1A1D8:  MOVLB  0
1A1DA:  CALL   4F4C
....................    write16(ADDR_E1_MODE,2); 
1A1DE:  MOVLW  82
1A1E0:  MOVLB  8
1A1E2:  MOVWF  xCB
1A1E4:  CLRF   xCD
1A1E6:  MOVLW  02
1A1E8:  MOVWF  xCC
1A1EA:  MOVLB  0
1A1EC:  CALL   4F4C
....................    write16(ADDR_E1_POS,0); 
1A1F0:  MOVLW  7E
1A1F2:  MOVLB  8
1A1F4:  MOVWF  xCB
1A1F6:  CLRF   xCD
1A1F8:  CLRF   xCC
1A1FA:  MOVLB  0
1A1FC:  CALL   4F4C
....................    write16(ADDR_E1_PORT,0); 
1A200:  MOVLW  AA
1A202:  MOVLB  8
1A204:  MOVWF  xCB
1A206:  CLRF   xCD
1A208:  CLRF   xCC
1A20A:  MOVLB  0
1A20C:  CALL   4F4C
....................    write16(ADDR_E1_TYPE,2); 
1A210:  MOVLW  7A
1A212:  MOVLB  8
1A214:  MOVWF  xCB
1A216:  CLRF   xCD
1A218:  MOVLW  02
1A21A:  MOVWF  xCC
1A21C:  MOVLB  0
1A21E:  CALL   4F4C
....................    write16(ADDR_M1_RUN,270); 
1A222:  MOVLW  76
1A224:  MOVLB  8
1A226:  MOVWF  xCB
1A228:  MOVLW  01
1A22A:  MOVWF  xCD
1A22C:  MOVLW  0E
1A22E:  MOVWF  xCC
1A230:  MOVLB  0
1A232:  CALL   4F4C
....................    write16(ADDR_M1_BKLSH,0); 
1A236:  MOVLW  72
1A238:  MOVLB  8
1A23A:  MOVWF  xCB
1A23C:  CLRF   xCD
1A23E:  CLRF   xCC
1A240:  MOVLB  0
1A242:  CALL   4F4C
....................    write16(ADDR_M1_ERROR,0);   
1A246:  MOVLW  6E
1A248:  MOVLB  8
1A24A:  MOVWF  xCB
1A24C:  CLRF   xCD
1A24E:  CLRF   xCC
1A250:  MOVLB  0
1A252:  CALL   4F4C
....................    write16(ADDR_M1_SPR,38400); 
1A256:  MOVLW  AE
1A258:  MOVLB  8
1A25A:  MOVWF  xCB
1A25C:  MOVLW  96
1A25E:  MOVWF  xCD
1A260:  CLRF   xCC
1A262:  MOVLB  0
1A264:  CALL   4F4C
....................    write16(ADDR_M1_COMP,0); 
1A268:  MOVLW  B2
1A26A:  MOVLB  8
1A26C:  MOVWF  xCB
1A26E:  CLRF   xCD
1A270:  CLRF   xCC
1A272:  MOVLB  0
1A274:  CALL   4F4C
....................    write16(ADDR_M1_LIN_POS,0); 
1A278:  MOVLW  B6
1A27A:  MOVLB  8
1A27C:  MOVWF  xCB
1A27E:  CLRF   xCD
1A280:  CLRF   xCC
1A282:  MOVLB  0
1A284:  CALL   4F4C
....................    write16(ADDR_E1_INDEX,1); 
1A288:  MOVLW  BA
1A28A:  MOVLB  8
1A28C:  MOVWF  xCB
1A28E:  CLRF   xCD
1A290:  MOVLW  01
1A292:  MOVWF  xCC
1A294:  MOVLB  0
1A296:  CALL   4F4C
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A29A:  MOVLW  88
1A29C:  MOVLB  8
1A29E:  MOVWF  xCB
1A2A0:  CLRF   xCD
1A2A2:  MOVLW  01
1A2A4:  MOVWF  xCC
1A2A6:  MOVLB  0
1A2A8:  CALL   4F4C
....................    write16(ADDR_M2_MODE,HALF); 
1A2AC:  MOVLW  8C
1A2AE:  MOVLB  8
1A2B0:  MOVWF  xCB
1A2B2:  CLRF   xCD
1A2B4:  MOVLW  01
1A2B6:  MOVWF  xCC
1A2B8:  MOVLB  0
1A2BA:  CALL   4F4C
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A2BE:  MOVLW  90
1A2C0:  MOVLB  8
1A2C2:  MOVWF  xCB
1A2C4:  CLRF   xCD
1A2C6:  MOVLW  64
1A2C8:  MOVWF  xCC
1A2CA:  MOVLB  0
1A2CC:  CALL   4F4C
....................    write16(ADDR_M2_POS_DIR,0); 
1A2D0:  MOVLW  94
1A2D2:  MOVLB  8
1A2D4:  MOVWF  xCB
1A2D6:  CLRF   xCD
1A2D8:  CLRF   xCC
1A2DA:  MOVLB  0
1A2DC:  CALL   4F4C
....................    write16(ADDR_M2_PWM_HLD,0); 
1A2E0:  MOVLW  98
1A2E2:  MOVLB  8
1A2E4:  MOVWF  xCB
1A2E6:  CLRF   xCD
1A2E8:  CLRF   xCC
1A2EA:  MOVLB  0
1A2EC:  CALL   4F4C
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A2F0:  MOVLW  9C
1A2F2:  MOVLB  8
1A2F4:  MOVWF  xCB
1A2F6:  CLRF   xCD
1A2F8:  MOVLW  7F
1A2FA:  MOVWF  xCC
1A2FC:  MOVLB  0
1A2FE:  CALL   4F4C
....................    write16(ADDR_M2_GB_ERR,0); 
1A302:  MOVLW  A0
1A304:  MOVLB  8
1A306:  MOVWF  xCB
1A308:  CLRF   xCD
1A30A:  CLRF   xCC
1A30C:  MOVLB  0
1A30E:  CALL   4F4C
....................    write16(ADDR_E2_CPR,0); 
1A312:  MOVLW  A4
1A314:  MOVLB  8
1A316:  MOVWF  xCB
1A318:  CLRF   xCD
1A31A:  CLRF   xCC
1A31C:  MOVLB  0
1A31E:  CALL   4F4C
....................    write16(ADDR_E2_PPR,0);   
1A322:  MOVLW  A8
1A324:  MOVLB  8
1A326:  MOVWF  xCB
1A328:  CLRF   xCD
1A32A:  CLRF   xCC
1A32C:  MOVLB  0
1A32E:  CALL   4F4C
....................    write16(ADDR_E2_MODE,0); 
1A332:  MOVLW  84
1A334:  MOVLB  8
1A336:  MOVWF  xCB
1A338:  CLRF   xCD
1A33A:  CLRF   xCC
1A33C:  MOVLB  0
1A33E:  CALL   4F4C
....................    write16(ADDR_E2_POS,0); 
1A342:  MOVLW  80
1A344:  MOVLB  8
1A346:  MOVWF  xCB
1A348:  CLRF   xCD
1A34A:  CLRF   xCC
1A34C:  MOVLB  0
1A34E:  CALL   4F4C
....................    write16(ADDR_E2_PORT,0); 
1A352:  MOVLW  AC
1A354:  MOVLB  8
1A356:  MOVWF  xCB
1A358:  CLRF   xCD
1A35A:  CLRF   xCC
1A35C:  MOVLB  0
1A35E:  CALL   4F4C
....................    write16(ADDR_E2_TYPE,0); 
1A362:  MOVLW  7C
1A364:  MOVLB  8
1A366:  MOVWF  xCB
1A368:  CLRF   xCD
1A36A:  CLRF   xCC
1A36C:  MOVLB  0
1A36E:  CALL   4F4C
....................    write16(ADDR_M2_RUN,0); 
1A372:  MOVLW  78
1A374:  MOVLB  8
1A376:  MOVWF  xCB
1A378:  CLRF   xCD
1A37A:  CLRF   xCC
1A37C:  MOVLB  0
1A37E:  CALL   4F4C
....................    write16(ADDR_M2_BKLSH,0); 
1A382:  MOVLW  74
1A384:  MOVLB  8
1A386:  MOVWF  xCB
1A388:  CLRF   xCD
1A38A:  CLRF   xCC
1A38C:  MOVLB  0
1A38E:  CALL   4F4C
....................    write16(ADDR_M2_ERROR,0);   
1A392:  MOVLW  70
1A394:  MOVLB  8
1A396:  MOVWF  xCB
1A398:  CLRF   xCD
1A39A:  CLRF   xCC
1A39C:  MOVLB  0
1A39E:  CALL   4F4C
....................    write16(ADDR_M2_SPR,0); 
1A3A2:  MOVLW  B0
1A3A4:  MOVLB  8
1A3A6:  MOVWF  xCB
1A3A8:  CLRF   xCD
1A3AA:  CLRF   xCC
1A3AC:  MOVLB  0
1A3AE:  CALL   4F4C
....................    write16(ADDR_M2_COMP,0); 
1A3B2:  MOVLW  B4
1A3B4:  MOVLB  8
1A3B6:  MOVWF  xCB
1A3B8:  CLRF   xCD
1A3BA:  CLRF   xCC
1A3BC:  MOVLB  0
1A3BE:  CALL   4F4C
....................    write16(ADDR_M2_LIN_POS,0);    
1A3C2:  MOVLW  B8
1A3C4:  MOVLB  8
1A3C6:  MOVWF  xCB
1A3C8:  CLRF   xCD
1A3CA:  CLRF   xCC
1A3CC:  MOVLB  0
1A3CE:  CALL   4F4C
....................     
....................    get_step_vars(); 
1A3D2:  CALL   2C98
1A3D6:  GOTO   1A6DA (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A3DA:  MOVLW  86
1A3DC:  MOVLB  8
1A3DE:  MOVWF  xCB
1A3E0:  CLRF   xCD
1A3E2:  MOVLW  01
1A3E4:  MOVWF  xCC
1A3E6:  MOVLB  0
1A3E8:  CALL   4F4C
....................    write16(ADDR_M1_MODE,FULL); 
1A3EC:  MOVLW  8A
1A3EE:  MOVLB  8
1A3F0:  MOVWF  xCB
1A3F2:  CLRF   xCD
1A3F4:  CLRF   xCC
1A3F6:  MOVLB  0
1A3F8:  CALL   4F4C
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1A3FC:  MOVLW  8E
1A3FE:  MOVLB  8
1A400:  MOVWF  xCB
1A402:  CLRF   xCD
1A404:  MOVLW  28
1A406:  MOVWF  xCC
1A408:  MOVLB  0
1A40A:  CALL   4F4C
....................    write16(ADDR_M1_POS_DIR,1); 
1A40E:  MOVLW  92
1A410:  MOVLB  8
1A412:  MOVWF  xCB
1A414:  CLRF   xCD
1A416:  MOVLW  01
1A418:  MOVWF  xCC
1A41A:  MOVLB  0
1A41C:  CALL   4F4C
....................    write16(ADDR_M1_PWM_HLD,0); 
1A420:  MOVLW  96
1A422:  MOVLB  8
1A424:  MOVWF  xCB
1A426:  CLRF   xCD
1A428:  CLRF   xCC
1A42A:  MOVLB  0
1A42C:  CALL   4F4C
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A430:  MOVLW  9A
1A432:  MOVLB  8
1A434:  MOVWF  xCB
1A436:  CLRF   xCD
1A438:  MOVLW  7F
1A43A:  MOVWF  xCC
1A43C:  MOVLB  0
1A43E:  CALL   4F4C
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1A442:  MOVLW  9E
1A444:  MOVLB  8
1A446:  MOVWF  xCB
1A448:  MOVLW  02
1A44A:  MOVWF  xCD
1A44C:  MOVLW  9E
1A44E:  MOVWF  xCC
1A450:  MOVLB  0
1A452:  CALL   4F4C
....................    write16(ADDR_E1_CPR,500); 
1A456:  MOVLW  A2
1A458:  MOVLB  8
1A45A:  MOVWF  xCB
1A45C:  MOVLW  01
1A45E:  MOVWF  xCD
1A460:  MOVLW  F4
1A462:  MOVWF  xCC
1A464:  MOVLB  0
1A466:  CALL   4F4C
....................    write16(ADDR_E1_PPR,50); 
1A46A:  MOVLW  A6
1A46C:  MOVLB  8
1A46E:  MOVWF  xCB
1A470:  CLRF   xCD
1A472:  MOVLW  32
1A474:  MOVWF  xCC
1A476:  MOVLB  0
1A478:  CALL   4F4C
....................    write16(ADDR_E1_MODE,2); 
1A47C:  MOVLW  82
1A47E:  MOVLB  8
1A480:  MOVWF  xCB
1A482:  CLRF   xCD
1A484:  MOVLW  02
1A486:  MOVWF  xCC
1A488:  MOVLB  0
1A48A:  CALL   4F4C
....................    write16(ADDR_E1_POS,0); 
1A48E:  MOVLW  7E
1A490:  MOVLB  8
1A492:  MOVWF  xCB
1A494:  CLRF   xCD
1A496:  CLRF   xCC
1A498:  MOVLB  0
1A49A:  CALL   4F4C
....................    write16(ADDR_E1_PORT,0); 
1A49E:  MOVLW  AA
1A4A0:  MOVLB  8
1A4A2:  MOVWF  xCB
1A4A4:  CLRF   xCD
1A4A6:  CLRF   xCC
1A4A8:  MOVLB  0
1A4AA:  CALL   4F4C
....................    write16(ADDR_E1_TYPE,1); 
1A4AE:  MOVLW  7A
1A4B0:  MOVLB  8
1A4B2:  MOVWF  xCB
1A4B4:  CLRF   xCD
1A4B6:  MOVLW  01
1A4B8:  MOVWF  xCC
1A4BA:  MOVLB  0
1A4BC:  CALL   4F4C
....................    write16(ADDR_M1_RUN,0); 
1A4C0:  MOVLW  76
1A4C2:  MOVLB  8
1A4C4:  MOVWF  xCB
1A4C6:  CLRF   xCD
1A4C8:  CLRF   xCC
1A4CA:  MOVLB  0
1A4CC:  CALL   4F4C
....................    write16(ADDR_M1_BKLSH,1300); 
1A4D0:  MOVLW  72
1A4D2:  MOVLB  8
1A4D4:  MOVWF  xCB
1A4D6:  MOVLW  05
1A4D8:  MOVWF  xCD
1A4DA:  MOVLW  14
1A4DC:  MOVWF  xCC
1A4DE:  MOVLB  0
1A4E0:  CALL   4F4C
....................    write16(ADDR_M1_ERROR,0);   
1A4E4:  MOVLW  6E
1A4E6:  MOVLB  8
1A4E8:  MOVWF  xCB
1A4EA:  CLRF   xCD
1A4EC:  CLRF   xCC
1A4EE:  MOVLB  0
1A4F0:  CALL   4F4C
....................    write16(ADDR_M1_SPR,20000); 
1A4F4:  MOVLW  AE
1A4F6:  MOVLB  8
1A4F8:  MOVWF  xCB
1A4FA:  MOVLW  4E
1A4FC:  MOVWF  xCD
1A4FE:  MOVLW  20
1A500:  MOVWF  xCC
1A502:  MOVLB  0
1A504:  CALL   4F4C
....................    write16(ADDR_M1_COMP,0); 
1A508:  MOVLW  B2
1A50A:  MOVLB  8
1A50C:  MOVWF  xCB
1A50E:  CLRF   xCD
1A510:  CLRF   xCC
1A512:  MOVLB  0
1A514:  CALL   4F4C
....................    write16(ADDR_M1_LIN_POS,0); 
1A518:  MOVLW  B6
1A51A:  MOVLB  8
1A51C:  MOVWF  xCB
1A51E:  CLRF   xCD
1A520:  CLRF   xCC
1A522:  MOVLB  0
1A524:  CALL   4F4C
....................    write16(ADDR_E1_INDEX,0); 
1A528:  MOVLW  BA
1A52A:  MOVLB  8
1A52C:  MOVWF  xCB
1A52E:  CLRF   xCD
1A530:  CLRF   xCC
1A532:  MOVLB  0
1A534:  CALL   4F4C
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A538:  MOVLW  88
1A53A:  MOVLB  8
1A53C:  MOVWF  xCB
1A53E:  CLRF   xCD
1A540:  MOVLW  01
1A542:  MOVWF  xCC
1A544:  MOVLB  0
1A546:  CALL   4F4C
....................    write16(ADDR_M2_MODE,HALF); 
1A54A:  MOVLW  8C
1A54C:  MOVLB  8
1A54E:  MOVWF  xCB
1A550:  CLRF   xCD
1A552:  MOVLW  01
1A554:  MOVWF  xCC
1A556:  MOVLB  0
1A558:  CALL   4F4C
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A55C:  MOVLW  90
1A55E:  MOVLB  8
1A560:  MOVWF  xCB
1A562:  CLRF   xCD
1A564:  MOVLW  28
1A566:  MOVWF  xCC
1A568:  MOVLB  0
1A56A:  CALL   4F4C
....................    write16(ADDR_M2_POS_DIR,1); 
1A56E:  MOVLW  94
1A570:  MOVLB  8
1A572:  MOVWF  xCB
1A574:  CLRF   xCD
1A576:  MOVLW  01
1A578:  MOVWF  xCC
1A57A:  MOVLB  0
1A57C:  CALL   4F4C
....................    write16(ADDR_M2_PWM_HLD,0); 
1A580:  MOVLW  98
1A582:  MOVLB  8
1A584:  MOVWF  xCB
1A586:  CLRF   xCD
1A588:  CLRF   xCC
1A58A:  MOVLB  0
1A58C:  CALL   4F4C
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A590:  MOVLW  9C
1A592:  MOVLB  8
1A594:  MOVWF  xCB
1A596:  CLRF   xCD
1A598:  MOVLW  7F
1A59A:  MOVWF  xCC
1A59C:  MOVLB  0
1A59E:  CALL   4F4C
....................    write16(ADDR_M2_GB_ERR,0); 
1A5A2:  MOVLW  A0
1A5A4:  MOVLB  8
1A5A6:  MOVWF  xCB
1A5A8:  CLRF   xCD
1A5AA:  CLRF   xCC
1A5AC:  MOVLB  0
1A5AE:  CALL   4F4C
....................    write16(ADDR_E2_CPR,0); 
1A5B2:  MOVLW  A4
1A5B4:  MOVLB  8
1A5B6:  MOVWF  xCB
1A5B8:  CLRF   xCD
1A5BA:  CLRF   xCC
1A5BC:  MOVLB  0
1A5BE:  CALL   4F4C
....................    write16(ADDR_E2_PPR,0);   
1A5C2:  MOVLW  A8
1A5C4:  MOVLB  8
1A5C6:  MOVWF  xCB
1A5C8:  CLRF   xCD
1A5CA:  CLRF   xCC
1A5CC:  MOVLB  0
1A5CE:  CALL   4F4C
....................    write16(ADDR_E2_MODE,0); 
1A5D2:  MOVLW  84
1A5D4:  MOVLB  8
1A5D6:  MOVWF  xCB
1A5D8:  CLRF   xCD
1A5DA:  CLRF   xCC
1A5DC:  MOVLB  0
1A5DE:  CALL   4F4C
....................    write16(ADDR_E2_POS,0); 
1A5E2:  MOVLW  80
1A5E4:  MOVLB  8
1A5E6:  MOVWF  xCB
1A5E8:  CLRF   xCD
1A5EA:  CLRF   xCC
1A5EC:  MOVLB  0
1A5EE:  CALL   4F4C
....................    write16(ADDR_E2_PORT,0); 
1A5F2:  MOVLW  AC
1A5F4:  MOVLB  8
1A5F6:  MOVWF  xCB
1A5F8:  CLRF   xCD
1A5FA:  CLRF   xCC
1A5FC:  MOVLB  0
1A5FE:  CALL   4F4C
....................    write16(ADDR_E2_TYPE,0); 
1A602:  MOVLW  7C
1A604:  MOVLB  8
1A606:  MOVWF  xCB
1A608:  CLRF   xCD
1A60A:  CLRF   xCC
1A60C:  MOVLB  0
1A60E:  CALL   4F4C
....................    write16(ADDR_M2_RUN,0); 
1A612:  MOVLW  78
1A614:  MOVLB  8
1A616:  MOVWF  xCB
1A618:  CLRF   xCD
1A61A:  CLRF   xCC
1A61C:  MOVLB  0
1A61E:  CALL   4F4C
....................    write16(ADDR_M2_BKLSH,0); 
1A622:  MOVLW  74
1A624:  MOVLB  8
1A626:  MOVWF  xCB
1A628:  CLRF   xCD
1A62A:  CLRF   xCC
1A62C:  MOVLB  0
1A62E:  CALL   4F4C
....................    write16(ADDR_M2_ERROR,0);   
1A632:  MOVLW  70
1A634:  MOVLB  8
1A636:  MOVWF  xCB
1A638:  CLRF   xCD
1A63A:  CLRF   xCC
1A63C:  MOVLB  0
1A63E:  CALL   4F4C
....................    write16(ADDR_M2_SPR,0); 
1A642:  MOVLW  B0
1A644:  MOVLB  8
1A646:  MOVWF  xCB
1A648:  CLRF   xCD
1A64A:  CLRF   xCC
1A64C:  MOVLB  0
1A64E:  CALL   4F4C
....................    write16(ADDR_M2_COMP,0); 
1A652:  MOVLW  B4
1A654:  MOVLB  8
1A656:  MOVWF  xCB
1A658:  CLRF   xCD
1A65A:  CLRF   xCC
1A65C:  MOVLB  0
1A65E:  CALL   4F4C
....................    write16(ADDR_M2_LIN_POS,0);    
1A662:  MOVLW  B8
1A664:  MOVLB  8
1A666:  MOVWF  xCB
1A668:  CLRF   xCD
1A66A:  CLRF   xCC
1A66C:  MOVLB  0
1A66E:  CALL   4F4C
....................    write16(ADDR_E2_INDEX,0); 
1A672:  MOVLW  BC
1A674:  MOVLB  8
1A676:  MOVWF  xCB
1A678:  CLRF   xCD
1A67A:  CLRF   xCC
1A67C:  MOVLB  0
1A67E:  CALL   4F4C
....................     
....................    get_step_vars(); 
1A682:  CALL   2C98
1A686:  GOTO   1A6DA (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
02916:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
02918:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
0291A:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
0291C:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
0291E:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
02920:  BCF    F90.5
....................    set_pwm1_duty(0);    
02922:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
02924:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
02926:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
02928:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
0292A:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
0292C:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
0292E:  BCF    F8D.5
....................    set_pwm2_duty(0);  
02930:  MOVLB  F
02932:  CLRF   x4F
....................  
....................    output_low(VENC1); 
02934:  BCF    F8E.6
....................    output_low(VENC2);         
02936:  BCF    F8E.7
....................    output_low(VHBRDG); 
02938:  BCF    F8E.2
0293A:  MOVLB  0
0293C:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
0123C:  BCF    FD8.0
0123E:  MOVLB  7
01240:  RLCF   x3C,W
01242:  CLRF   03
01244:  ADDLW  4A
01246:  MOVWF  FE9
01248:  MOVLW  07
0124A:  ADDWFC 03,W
0124C:  MOVWF  FEA
0124E:  MOVFF  FEC,A10
01252:  MOVF   FED,F
01254:  MOVFF  FEF,A0F
01258:  MOVLB  A
0125A:  MOVF   x0F,F
0125C:  BTFSS  FD8.2
0125E:  BRA    13E6
01260:  MOVF   x10,F
01262:  BTFSS  FD8.2
01264:  BRA    13E6
....................       if(m_way[motor]==POS) { 
01266:  BCF    FD8.0
01268:  MOVLB  7
0126A:  RLCF   x3C,W
0126C:  CLRF   03
0126E:  ADDLW  82
01270:  MOVWF  FE9
01272:  MOVLW  07
01274:  ADDWFC 03,W
01276:  MOVWF  FEA
01278:  MOVFF  FEC,A10
0127C:  MOVF   FED,F
0127E:  MOVFF  FEF,A0F
01282:  MOVLB  A
01284:  MOVF   x0F,F
01286:  BNZ   1320
01288:  MOVF   x10,F
0128A:  BNZ   1320
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
0128C:  BCF    FD8.0
0128E:  MOVLB  7
01290:  RLCF   x3C,W
01292:  CLRF   03
01294:  ADDLW  BB
01296:  MOVWF  FE9
01298:  MOVLW  07
0129A:  ADDWFC 03,W
0129C:  MOVWF  FEA
0129E:  MOVFF  FEC,A10
012A2:  MOVF   FED,F
012A4:  MOVFF  FEF,A0F
012A8:  BCF    FD8.0
012AA:  RLCF   x3C,W
012AC:  CLRF   03
012AE:  ADDLW  5A
012B0:  MOVWF  FE9
012B2:  MOVLW  07
012B4:  ADDWFC 03,W
012B6:  MOVWF  FEA
012B8:  MOVFF  FEC,03
012BC:  MOVF   FED,F
012BE:  MOVFF  FEF,01
012C2:  MOVF   03,W
012C4:  MOVLB  A
012C6:  SUBWF  x10,W
012C8:  BNC   12EC
012CA:  BNZ   12D2
012CC:  MOVF   01,W
012CE:  SUBWF  x0F,W
012D0:  BNC   12EC
012D2:  BCF    FD8.0
012D4:  MOVLB  7
012D6:  RLCF   x3C,W
012D8:  CLRF   03
012DA:  ADDLW  BB
012DC:  MOVWF  FE9
012DE:  MOVLW  07
012E0:  ADDWFC 03,W
012E2:  MOVWF  FEA
012E4:  CLRF   FEC
012E6:  MOVF   FED,F
012E8:  CLRF   FEF
012EA:  MOVLB  A
....................          e_pos[motor]++; 
012EC:  BCF    FD8.0
012EE:  MOVLB  7
012F0:  RLCF   x3C,W
012F2:  CLRF   03
012F4:  ADDLW  BB
012F6:  MOVWF  FE9
012F8:  MOVLW  07
012FA:  ADDWFC 03,W
012FC:  MOVWF  FEA
012FE:  MOVLW  01
01300:  ADDWF  FEE,F
01302:  BNC   1306
01304:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
01306:  BCF    FD8.0
01308:  RLCF   x3C,W
0130A:  CLRF   03
0130C:  ADDLW  96
0130E:  MOVWF  FE9
01310:  MOVLW  07
01312:  ADDWFC 03,W
01314:  MOVWF  FEA
01316:  CLRF   FEC
01318:  MOVF   FED,F
0131A:  CLRF   FEF
....................       } 
0131C:  BRA    13E4
0131E:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
01320:  BCF    FD8.0
01322:  MOVLB  7
01324:  RLCF   x3C,W
01326:  CLRF   03
01328:  ADDLW  82
0132A:  MOVWF  FE9
0132C:  MOVLW  07
0132E:  ADDWFC 03,W
01330:  MOVWF  FEA
01332:  MOVFF  FEC,A10
01336:  MOVF   FED,F
01338:  MOVFF  FEF,A0F
0133C:  MOVLB  A
0133E:  DECFSZ x0F,W
01340:  BRA    13E6
01342:  MOVF   x10,F
01344:  BNZ   13E6
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01346:  BCF    FD8.0
01348:  MOVLB  7
0134A:  RLCF   x3C,W
0134C:  CLRF   03
0134E:  ADDLW  BB
01350:  MOVWF  FE9
01352:  MOVLW  07
01354:  ADDWFC 03,W
01356:  MOVWF  FEA
01358:  MOVFF  FEC,A10
0135C:  MOVF   FED,F
0135E:  MOVFF  FEF,A0F
01362:  MOVLB  A
01364:  MOVF   x0F,F
01366:  BNZ   13B2
01368:  MOVF   x10,F
0136A:  BNZ   13B2
0136C:  BCF    FD8.0
0136E:  MOVLB  7
01370:  RLCF   x3C,W
01372:  CLRF   03
01374:  ADDLW  BB
01376:  MOVWF  01
01378:  MOVLW  07
0137A:  ADDWFC 03,F
0137C:  MOVLB  A
0137E:  MOVFF  03,A10
01382:  BCF    FD8.0
01384:  MOVLB  7
01386:  RLCF   x3C,W
01388:  CLRF   03
0138A:  ADDLW  5A
0138C:  MOVWF  FE9
0138E:  MOVLW  07
01390:  ADDWFC 03,W
01392:  MOVWF  FEA
01394:  MOVFF  FEC,03
01398:  MOVF   FED,F
0139A:  MOVFF  FEF,A11
0139E:  MOVLB  A
013A0:  MOVFF  A10,FEA
013A4:  MOVFF  01,FE9
013A8:  MOVFF  03,FEC
013AC:  MOVF   FED,F
013AE:  MOVFF  A11,FEF
....................          e_pos[motor]--; 
013B2:  BCF    FD8.0
013B4:  MOVLB  7
013B6:  RLCF   x3C,W
013B8:  CLRF   03
013BA:  ADDLW  BB
013BC:  MOVWF  FE9
013BE:  MOVLW  07
013C0:  ADDWFC 03,W
013C2:  MOVWF  FEA
013C4:  MOVLW  FF
013C6:  ADDWF  FEF,F
013C8:  BC    13CE
013CA:  MOVF   FEE,F
013CC:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
013CE:  BCF    FD8.0
013D0:  RLCF   x3C,W
013D2:  CLRF   03
013D4:  ADDLW  96
013D6:  MOVWF  FE9
013D8:  MOVLW  07
013DA:  ADDWFC 03,W
013DC:  MOVWF  FEA
013DE:  CLRF   FEC
013E0:  MOVF   FED,F
013E2:  CLRF   FEF
013E4:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
013E6:  BCF    FD8.0
013E8:  MOVLB  7
013EA:  RLCF   x3C,W
013EC:  CLRF   03
013EE:  ADDLW  4A
013F0:  MOVWF  FE9
013F2:  MOVLW  07
013F4:  ADDWFC 03,W
013F6:  MOVWF  FEA
013F8:  MOVFF  FEC,A10
013FC:  MOVF   FED,F
013FE:  MOVFF  FEF,A0F
01402:  MOVLB  A
01404:  DECFSZ x0F,W
01406:  BRA    158E
01408:  MOVF   x10,F
0140A:  BTFSS  FD8.2
0140C:  BRA    158E
....................       if(m_way[motor]==NEG) { 
0140E:  BCF    FD8.0
01410:  MOVLB  7
01412:  RLCF   x3C,W
01414:  CLRF   03
01416:  ADDLW  82
01418:  MOVWF  FE9
0141A:  MOVLW  07
0141C:  ADDWFC 03,W
0141E:  MOVWF  FEA
01420:  MOVFF  FEC,A10
01424:  MOVF   FED,F
01426:  MOVFF  FEF,A0F
0142A:  MOVLB  A
0142C:  DECFSZ x0F,W
0142E:  BRA    14C8
01430:  MOVF   x10,F
01432:  BNZ   14C8
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
01434:  BCF    FD8.0
01436:  MOVLB  7
01438:  RLCF   x3C,W
0143A:  CLRF   03
0143C:  ADDLW  BB
0143E:  MOVWF  FE9
01440:  MOVLW  07
01442:  ADDWFC 03,W
01444:  MOVWF  FEA
01446:  MOVFF  FEC,A10
0144A:  MOVF   FED,F
0144C:  MOVFF  FEF,A0F
01450:  BCF    FD8.0
01452:  RLCF   x3C,W
01454:  CLRF   03
01456:  ADDLW  5A
01458:  MOVWF  FE9
0145A:  MOVLW  07
0145C:  ADDWFC 03,W
0145E:  MOVWF  FEA
01460:  MOVFF  FEC,03
01464:  MOVF   FED,F
01466:  MOVFF  FEF,01
0146A:  MOVF   03,W
0146C:  MOVLB  A
0146E:  SUBWF  x10,W
01470:  BNC   1494
01472:  BNZ   147A
01474:  MOVF   01,W
01476:  SUBWF  x0F,W
01478:  BNC   1494
0147A:  BCF    FD8.0
0147C:  MOVLB  7
0147E:  RLCF   x3C,W
01480:  CLRF   03
01482:  ADDLW  BB
01484:  MOVWF  FE9
01486:  MOVLW  07
01488:  ADDWFC 03,W
0148A:  MOVWF  FEA
0148C:  CLRF   FEC
0148E:  MOVF   FED,F
01490:  CLRF   FEF
01492:  MOVLB  A
....................          e_pos[motor]++; 
01494:  BCF    FD8.0
01496:  MOVLB  7
01498:  RLCF   x3C,W
0149A:  CLRF   03
0149C:  ADDLW  BB
0149E:  MOVWF  FE9
014A0:  MOVLW  07
014A2:  ADDWFC 03,W
014A4:  MOVWF  FEA
014A6:  MOVLW  01
014A8:  ADDWF  FEE,F
014AA:  BNC   14AE
014AC:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014AE:  BCF    FD8.0
014B0:  RLCF   x3C,W
014B2:  CLRF   03
014B4:  ADDLW  96
014B6:  MOVWF  FE9
014B8:  MOVLW  07
014BA:  ADDWFC 03,W
014BC:  MOVWF  FEA
014BE:  CLRF   FEC
014C0:  MOVF   FED,F
014C2:  CLRF   FEF
....................       } 
014C4:  BRA    158C
014C6:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
014C8:  BCF    FD8.0
014CA:  MOVLB  7
014CC:  RLCF   x3C,W
014CE:  CLRF   03
014D0:  ADDLW  82
014D2:  MOVWF  FE9
014D4:  MOVLW  07
014D6:  ADDWFC 03,W
014D8:  MOVWF  FEA
014DA:  MOVFF  FEC,A10
014DE:  MOVF   FED,F
014E0:  MOVFF  FEF,A0F
014E4:  MOVLB  A
014E6:  MOVF   x0F,F
014E8:  BNZ   158E
014EA:  MOVF   x10,F
014EC:  BNZ   158E
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
014EE:  BCF    FD8.0
014F0:  MOVLB  7
014F2:  RLCF   x3C,W
014F4:  CLRF   03
014F6:  ADDLW  BB
014F8:  MOVWF  FE9
014FA:  MOVLW  07
014FC:  ADDWFC 03,W
014FE:  MOVWF  FEA
01500:  MOVFF  FEC,A10
01504:  MOVF   FED,F
01506:  MOVFF  FEF,A0F
0150A:  MOVLB  A
0150C:  MOVF   x0F,F
0150E:  BNZ   155A
01510:  MOVF   x10,F
01512:  BNZ   155A
01514:  BCF    FD8.0
01516:  MOVLB  7
01518:  RLCF   x3C,W
0151A:  CLRF   03
0151C:  ADDLW  BB
0151E:  MOVWF  01
01520:  MOVLW  07
01522:  ADDWFC 03,F
01524:  MOVLB  A
01526:  MOVFF  03,A10
0152A:  BCF    FD8.0
0152C:  MOVLB  7
0152E:  RLCF   x3C,W
01530:  CLRF   03
01532:  ADDLW  5A
01534:  MOVWF  FE9
01536:  MOVLW  07
01538:  ADDWFC 03,W
0153A:  MOVWF  FEA
0153C:  MOVFF  FEC,03
01540:  MOVF   FED,F
01542:  MOVFF  FEF,A11
01546:  MOVLB  A
01548:  MOVFF  A10,FEA
0154C:  MOVFF  01,FE9
01550:  MOVFF  03,FEC
01554:  MOVF   FED,F
01556:  MOVFF  A11,FEF
....................          e_pos[motor]--; 
0155A:  BCF    FD8.0
0155C:  MOVLB  7
0155E:  RLCF   x3C,W
01560:  CLRF   03
01562:  ADDLW  BB
01564:  MOVWF  FE9
01566:  MOVLW  07
01568:  ADDWFC 03,W
0156A:  MOVWF  FEA
0156C:  MOVLW  FF
0156E:  ADDWF  FEF,F
01570:  BC    1576
01572:  MOVF   FEE,F
01574:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
01576:  BCF    FD8.0
01578:  RLCF   x3C,W
0157A:  CLRF   03
0157C:  ADDLW  96
0157E:  MOVWF  FE9
01580:  MOVLW  07
01582:  ADDWFC 03,W
01584:  MOVWF  FEA
01586:  CLRF   FEC
01588:  MOVF   FED,F
0158A:  CLRF   FEF
0158C:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
0158E:  MOVF   1F,W
01590:  SUBLW  04
01592:  BTFSS  FD8.2
01594:  BRA    16C8
01596:  MOVF   20,F
01598:  BTFSS  FD8.2
0159A:  BRA    16C8
0159C:  BCF    FD8.0
0159E:  MOVLB  7
015A0:  RLCF   x3C,W
015A2:  CLRF   03
015A4:  ADDLW  66
015A6:  MOVWF  FE9
015A8:  MOVLW  07
015AA:  ADDWFC 03,W
015AC:  MOVWF  FEA
015AE:  MOVFF  FEC,A10
015B2:  MOVF   FED,F
015B4:  MOVFF  FEF,A0F
015B8:  MOVLB  A
015BA:  MOVF   x0F,W
015BC:  SUBLW  02
015BE:  BTFSS  FD8.2
015C0:  BRA    16C8
015C2:  MOVF   x10,F
015C4:  BTFSS  FD8.2
015C6:  BRA    16C8
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
015C8:  MOVLW  01
015CA:  MOVLB  7
015CC:  ADDWF  x3C,W
015CE:  MOVLB  A
015D0:  MOVWF  x0F
015D2:  MOVLB  7
015D4:  MOVF   x3C,W
015D6:  MULLW  04
015D8:  MOVF   FF3,W
015DA:  CLRF   03
015DC:  ADDLW  9E
015DE:  MOVWF  FE9
015E0:  MOVLW  07
015E2:  ADDWFC 03,W
015E4:  MOVWF  FEA
015E6:  MOVFF  FEF,A10
015EA:  MOVFF  FEC,A11
015EE:  MOVFF  FEC,A12
015F2:  MOVFF  FEC,A13
015F6:  BCF    FD8.0
015F8:  RLCF   x3C,W
015FA:  CLRF   03
015FC:  ADDLW  B7
015FE:  MOVWF  FE9
01600:  MOVLW  07
01602:  ADDWFC 03,W
01604:  MOVWF  FEA
01606:  MOVFF  FEC,A15
0160A:  MOVF   FED,F
0160C:  MOVFF  FEF,A14
01610:  BCF    FD8.0
01612:  RLCF   x3C,W
01614:  CLRF   03
01616:  ADDLW  BB
01618:  MOVWF  FE9
0161A:  MOVLW  07
0161C:  ADDWFC 03,W
0161E:  MOVWF  FEA
01620:  MOVFF  FEC,A17
01624:  MOVF   FED,F
01626:  MOVFF  FEF,A16
0162A:  MOVLW  6D
0162C:  BTFSS  F9E.4
0162E:  BRA    162C
01630:  MOVWF  FAD
01632:  MOVLW  3A
01634:  BTFSS  F9E.4
01636:  BRA    1634
01638:  MOVWF  FAD
0163A:  MOVFF  A0F,A18
0163E:  MOVLW  1B
01640:  MOVLB  A
01642:  MOVWF  x19
01644:  MOVLB  0
01646:  RCALL  0F88
01648:  MOVLW  2C
0164A:  BTFSS  F9E.4
0164C:  BRA    164A
0164E:  MOVWF  FAD
01650:  MOVFF  7A6,A18
01654:  MOVLW  1B
01656:  MOVLB  A
01658:  MOVWF  x19
0165A:  MOVLB  0
0165C:  RCALL  0F88
0165E:  MOVLW  4B
01660:  MOVWF  FF6
01662:  MOVLW  0F
01664:  MOVWF  FF7
01666:  MOVLW  00
01668:  MOVWF  FF8
0166A:  MOVLW  03
0166C:  MOVLB  A
0166E:  MOVWF  x18
01670:  MOVLB  0
01672:  RCALL  1006
01674:  MOVLW  41
01676:  MOVWF  FE9
01678:  MOVFF  A13,A1B
0167C:  MOVFF  A12,A1A
01680:  MOVFF  A11,A19
01684:  MOVFF  A10,A18
01688:  RCALL  10CC
0168A:  MOVLW  2C
0168C:  BTFSS  F9E.4
0168E:  BRA    168C
01690:  MOVWF  FAD
01692:  MOVLW  10
01694:  MOVWF  FE9
01696:  MOVFF  A15,A19
0169A:  MOVFF  A14,A18
0169E:  RCALL  1188
016A0:  MOVLW  2C
016A2:  BTFSS  F9E.4
016A4:  BRA    16A2
016A6:  MOVWF  FAD
016A8:  MOVLW  10
016AA:  MOVWF  FE9
016AC:  MOVFF  A17,A19
016B0:  MOVFF  A16,A18
016B4:  RCALL  1188
016B6:  MOVLW  0D
016B8:  BTFSS  F9E.4
016BA:  BRA    16B8
016BC:  MOVWF  FAD
016BE:  MOVLW  0A
016C0:  BTFSS  F9E.4
016C2:  BRA    16C0
016C4:  MOVWF  FAD
016C6:  MOVLB  A
....................    }    
016C8:  MOVLB  0
016CA:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A6B8:  MOVLB  7
0A6BA:  MOVF   x3C,W
0A6BC:  XORLW  00
0A6BE:  MOVLB  0
0A6C0:  BZ    A6C8
0A6C2:  XORLW  01
0A6C4:  BZ    A758
0A6C6:  BRA    A7E6
....................       case 0 : if (e_type[motor]==1) { 
0A6C8:  BCF    FD8.0
0A6CA:  MOVLB  7
0A6CC:  RLCF   x3C,W
0A6CE:  CLRF   03
0A6D0:  ADDLW  66
0A6D2:  MOVWF  FE9
0A6D4:  MOVLW  07
0A6D6:  ADDWFC 03,W
0A6D8:  MOVWF  FEA
0A6DA:  MOVFF  FEC,8A5
0A6DE:  MOVF   FED,F
0A6E0:  MOVFF  FEF,8A4
0A6E4:  MOVLB  8
0A6E6:  DECFSZ xA4,W
0A6E8:  BRA    A708
0A6EA:  MOVF   xA5,F
0A6EC:  BNZ   A708
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A6EE:  CLRF   03
0A6F0:  MOVLB  7
0A6F2:  MOVF   x3C,W
0A6F4:  ADDLW  C7
0A6F6:  MOVWF  FE9
0A6F8:  MOVLW  07
0A6FA:  ADDWFC 03,W
0A6FC:  MOVWF  FEA
0A6FE:  MOVLW  00
0A700:  BTFSC  F81.4
0A702:  MOVLW  01
0A704:  MOVWF  FEF
0A706:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A708:  BCF    FD8.0
0A70A:  MOVLB  7
0A70C:  RLCF   x3C,W
0A70E:  CLRF   03
0A710:  ADDLW  66
0A712:  MOVWF  FE9
0A714:  MOVLW  07
0A716:  ADDWFC 03,W
0A718:  MOVWF  FEA
0A71A:  MOVFF  FEC,8A5
0A71E:  MOVF   FED,F
0A720:  MOVFF  FEF,8A4
0A724:  MOVLB  8
0A726:  MOVF   xA4,W
0A728:  SUBLW  02
0A72A:  BNZ   A754
0A72C:  MOVF   xA5,F
0A72E:  BNZ   A754
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A730:  CLRF   03
0A732:  MOVLB  7
0A734:  MOVF   x3C,W
0A736:  ADDLW  C7
0A738:  MOVWF  FE9
0A73A:  MOVLW  07
0A73C:  ADDWFC 03,W
0A73E:  MOVWF  FEA
0A740:  MOVLW  00
0A742:  BTFSC  F81.4
0A744:  MOVLW  01
0A746:  MOVLB  8
0A748:  MOVWF  xA6
0A74A:  MOVLW  00
0A74C:  BTFSC  F81.1
0A74E:  MOVLW  01
0A750:  ANDWF  xA6,W
0A752:  MOVWF  FEF
....................                } 
....................          break; 
0A754:  MOVLB  0
0A756:  BRA    A7E6
....................       case 1 : if (e_type[motor]==1) { 
0A758:  BCF    FD8.0
0A75A:  MOVLB  7
0A75C:  RLCF   x3C,W
0A75E:  CLRF   03
0A760:  ADDLW  66
0A762:  MOVWF  FE9
0A764:  MOVLW  07
0A766:  ADDWFC 03,W
0A768:  MOVWF  FEA
0A76A:  MOVFF  FEC,8A5
0A76E:  MOVF   FED,F
0A770:  MOVFF  FEF,8A4
0A774:  MOVLB  8
0A776:  DECFSZ xA4,W
0A778:  BRA    A798
0A77A:  MOVF   xA5,F
0A77C:  BNZ   A798
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A77E:  CLRF   03
0A780:  MOVLB  7
0A782:  MOVF   x3C,W
0A784:  ADDLW  C7
0A786:  MOVWF  FE9
0A788:  MOVLW  07
0A78A:  ADDWFC 03,W
0A78C:  MOVWF  FEA
0A78E:  MOVLW  00
0A790:  BTFSC  F81.5
0A792:  MOVLW  01
0A794:  MOVWF  FEF
0A796:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A798:  BCF    FD8.0
0A79A:  MOVLB  7
0A79C:  RLCF   x3C,W
0A79E:  CLRF   03
0A7A0:  ADDLW  66
0A7A2:  MOVWF  FE9
0A7A4:  MOVLW  07
0A7A6:  ADDWFC 03,W
0A7A8:  MOVWF  FEA
0A7AA:  MOVFF  FEC,8A5
0A7AE:  MOVF   FED,F
0A7B0:  MOVFF  FEF,8A4
0A7B4:  MOVLB  8
0A7B6:  MOVF   xA4,W
0A7B8:  SUBLW  02
0A7BA:  BNZ   A7E4
0A7BC:  MOVF   xA5,F
0A7BE:  BNZ   A7E4
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A7C0:  CLRF   03
0A7C2:  MOVLB  7
0A7C4:  MOVF   x3C,W
0A7C6:  ADDLW  C7
0A7C8:  MOVWF  FE9
0A7CA:  MOVLW  07
0A7CC:  ADDWFC 03,W
0A7CE:  MOVWF  FEA
0A7D0:  MOVLW  00
0A7D2:  BTFSC  F81.5
0A7D4:  MOVLW  01
0A7D6:  MOVLB  8
0A7D8:  MOVWF  xA6
0A7DA:  MOVLW  00
0A7DC:  BTFSC  F81.2
0A7DE:  MOVLW  01
0A7E0:  ANDWF  xA6,W
0A7E2:  MOVWF  FEF
....................                } 
....................          break; 
0A7E4:  MOVLB  0
....................    } 
0A7E6:  GOTO   A8A0 (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017B8:  MOVLB  7
017BA:  MOVF   x3C,W
017BC:  XORLW  00
017BE:  MOVLB  0
017C0:  BZ    17C8
017C2:  XORLW  01
017C4:  BZ    1858
017C6:  BRA    18E6
....................       case 0 : if (e_type[motor]==1) { 
017C8:  BCF    FD8.0
017CA:  MOVLB  7
017CC:  RLCF   x3C,W
017CE:  CLRF   03
017D0:  ADDLW  66
017D2:  MOVWF  FE9
017D4:  MOVLW  07
017D6:  ADDWFC 03,W
017D8:  MOVWF  FEA
017DA:  MOVFF  FEC,A10
017DE:  MOVF   FED,F
017E0:  MOVFF  FEF,A0F
017E4:  MOVLB  A
017E6:  DECFSZ x0F,W
017E8:  BRA    1808
017EA:  MOVF   x10,F
017EC:  BNZ   1808
....................                   e_ch_n[motor]=input(ENC1_IND); 
017EE:  CLRF   03
017F0:  MOVLB  7
017F2:  MOVF   x3C,W
017F4:  ADDLW  C7
017F6:  MOVWF  FE9
017F8:  MOVLW  07
017FA:  ADDWFC 03,W
017FC:  MOVWF  FEA
017FE:  MOVLW  00
01800:  BTFSC  F81.4
01802:  MOVLW  01
01804:  MOVWF  FEF
01806:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01808:  BCF    FD8.0
0180A:  MOVLB  7
0180C:  RLCF   x3C,W
0180E:  CLRF   03
01810:  ADDLW  66
01812:  MOVWF  FE9
01814:  MOVLW  07
01816:  ADDWFC 03,W
01818:  MOVWF  FEA
0181A:  MOVFF  FEC,A10
0181E:  MOVF   FED,F
01820:  MOVFF  FEF,A0F
01824:  MOVLB  A
01826:  MOVF   x0F,W
01828:  SUBLW  02
0182A:  BNZ   1854
0182C:  MOVF   x10,F
0182E:  BNZ   1854
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
01830:  CLRF   03
01832:  MOVLB  7
01834:  MOVF   x3C,W
01836:  ADDLW  C7
01838:  MOVWF  FE9
0183A:  MOVLW  07
0183C:  ADDWFC 03,W
0183E:  MOVWF  FEA
01840:  MOVLW  00
01842:  BTFSC  F81.4
01844:  MOVLW  01
01846:  MOVLB  A
01848:  MOVWF  x11
0184A:  MOVLW  00
0184C:  BTFSC  F81.1
0184E:  MOVLW  01
01850:  ANDWF  x11,W
01852:  MOVWF  FEF
....................                } 
....................          break; 
01854:  MOVLB  0
01856:  BRA    18E6
....................       case 1 : if (e_type[motor]==1) { 
01858:  BCF    FD8.0
0185A:  MOVLB  7
0185C:  RLCF   x3C,W
0185E:  CLRF   03
01860:  ADDLW  66
01862:  MOVWF  FE9
01864:  MOVLW  07
01866:  ADDWFC 03,W
01868:  MOVWF  FEA
0186A:  MOVFF  FEC,A10
0186E:  MOVF   FED,F
01870:  MOVFF  FEF,A0F
01874:  MOVLB  A
01876:  DECFSZ x0F,W
01878:  BRA    1898
0187A:  MOVF   x10,F
0187C:  BNZ   1898
....................                   e_ch_n[motor]=input(ENC2_IND); 
0187E:  CLRF   03
01880:  MOVLB  7
01882:  MOVF   x3C,W
01884:  ADDLW  C7
01886:  MOVWF  FE9
01888:  MOVLW  07
0188A:  ADDWFC 03,W
0188C:  MOVWF  FEA
0188E:  MOVLW  00
01890:  BTFSC  F81.5
01892:  MOVLW  01
01894:  MOVWF  FEF
01896:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01898:  BCF    FD8.0
0189A:  MOVLB  7
0189C:  RLCF   x3C,W
0189E:  CLRF   03
018A0:  ADDLW  66
018A2:  MOVWF  FE9
018A4:  MOVLW  07
018A6:  ADDWFC 03,W
018A8:  MOVWF  FEA
018AA:  MOVFF  FEC,A10
018AE:  MOVF   FED,F
018B0:  MOVFF  FEF,A0F
018B4:  MOVLB  A
018B6:  MOVF   x0F,W
018B8:  SUBLW  02
018BA:  BNZ   18E4
018BC:  MOVF   x10,F
018BE:  BNZ   18E4
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018C0:  CLRF   03
018C2:  MOVLB  7
018C4:  MOVF   x3C,W
018C6:  ADDLW  C7
018C8:  MOVWF  FE9
018CA:  MOVLW  07
018CC:  ADDWFC 03,W
018CE:  MOVWF  FEA
018D0:  MOVLW  00
018D2:  BTFSC  F81.5
018D4:  MOVLW  01
018D6:  MOVLB  A
018D8:  MOVWF  x11
018DA:  MOVLW  00
018DC:  BTFSC  F81.2
018DE:  MOVLW  01
018E0:  ANDWF  x11,W
018E2:  MOVWF  FEF
....................                } 
....................          break; 
018E4:  MOVLB  0
....................    } 
018E6:  GOTO   1A34 (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
016CC:  BCF    FD8.0
016CE:  MOVLB  7
016D0:  RLCF   x3C,W
016D2:  CLRF   03
016D4:  ADDLW  B7
016D6:  MOVWF  FE9
016D8:  MOVLW  07
016DA:  ADDWFC 03,W
016DC:  MOVWF  FEA
016DE:  MOVLW  01
016E0:  ADDWF  FEE,F
016E2:  BNC   16E6
016E4:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
016E6:  MOVF   xA6,W
016E8:  XORLW  00
016EA:  MOVLB  0
016EC:  BZ    16F8
016EE:  XORLW  01
016F0:  BZ    16FE
016F2:  XORLW  03
016F4:  BZ    1710
016F6:  BRA    173A
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
016F8:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
016FA:  BCF    FF0.0
....................          break; 
016FC:  BRA    173A
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
016FE:  MOVLW  02
01700:  MOVLB  7
01702:  MOVWF  xA6
....................                disable_interrupts(INT_EXT1_L2H); 
01704:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
01706:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
01708:  BSF    FF0.3
0170A:  BCF    FF1.5
....................          break; 
0170C:  MOVLB  0
0170E:  BRA    173A
....................       case 2 : edge_mode=1; 
01710:  MOVLW  01
01712:  MOVLB  7
01714:  MOVWF  xA6
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01716:  BCF    FD8.0
01718:  RLCF   x3C,W
0171A:  CLRF   03
0171C:  ADDLW  B7
0171E:  MOVWF  FE9
01720:  MOVLW  07
01722:  ADDWFC 03,W
01724:  MOVWF  FEA
01726:  MOVLW  FF
01728:  ADDWF  FEF,F
0172A:  BC    1730
0172C:  MOVF   FEE,F
0172E:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
01730:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
01732:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
01734:  BSF    FF0.3
01736:  BSF    FF1.5
....................          break; 
01738:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
0173A:  RCALL  123C
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
0173C:  BCF    FF0.0
0173E:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
01742:  BCF    FD8.0
01744:  MOVLB  7
01746:  RLCF   x3C,W
01748:  CLRF   03
0174A:  ADDLW  B7
0174C:  MOVWF  FE9
0174E:  MOVLW  07
01750:  ADDWFC 03,W
01752:  MOVWF  FEA
01754:  MOVLW  01
01756:  ADDWF  FEE,F
01758:  BNC   175C
0175A:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
0175C:  MOVF   xA6,W
0175E:  XORLW  00
01760:  MOVLB  0
01762:  BZ    176E
01764:  XORLW  01
01766:  BZ    1774
01768:  XORLW  03
0176A:  BZ    1786
0176C:  BRA    17B0
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
0176E:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
01770:  BCF    FF0.1
....................          break; 
01772:  BRA    17B0
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01774:  MOVLW  02
01776:  MOVLB  7
01778:  MOVWF  xA6
....................                disable_interrupts(INT_EXT2_L2H); 
0177A:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
0177C:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
0177E:  BSF    FF0.4
01780:  BCF    FF1.4
....................          break; 
01782:  MOVLB  0
01784:  BRA    17B0
....................       case 2 : edge_mode=1; 
01786:  MOVLW  01
01788:  MOVLB  7
0178A:  MOVWF  xA6
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
0178C:  BCF    FD8.0
0178E:  RLCF   x3C,W
01790:  CLRF   03
01792:  ADDLW  B7
01794:  MOVWF  FE9
01796:  MOVLW  07
01798:  ADDWFC 03,W
0179A:  MOVWF  FEA
0179C:  MOVLW  FF
0179E:  ADDWF  FEF,F
017A0:  BC    17A6
017A2:  MOVF   FEE,F
017A4:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017A6:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017A8:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017AA:  BSF    FF0.4
017AC:  BSF    FF1.4
....................          break; 
017AE:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017B0:  RCALL  123C
.................... } 
....................  
.................... // motor step timer interrupt 
017B2:  BCF    FF0.1
017B4:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
018EA:  MOVLW  F9
018EC:  MOVWF  FB3
018EE:  MOVLW  C0
018F0:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
018F2:  BCF    FD8.0
018F4:  MOVLB  7
018F6:  RLCF   x3C,W
018F8:  CLRF   03
018FA:  ADDLW  8A
018FC:  MOVWF  FE9
018FE:  MOVLW  07
01900:  ADDWFC 03,W
01902:  MOVWF  FEA
01904:  MOVLW  01
01906:  ADDWF  FEE,F
01908:  BNC   190C
0190A:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
0190C:  BCF    FD8.0
0190E:  RLCF   x3C,W
01910:  CLRF   03
01912:  ADDLW  8A
01914:  MOVWF  FE9
01916:  MOVLW  07
01918:  ADDWFC 03,W
0191A:  MOVWF  FEA
0191C:  MOVFF  FEC,A10
01920:  MOVF   FED,F
01922:  MOVFF  FEF,A0F
01926:  BCF    FD8.0
01928:  RLCF   x3C,W
0192A:  CLRF   03
0192C:  ADDLW  46
0192E:  MOVWF  FE9
01930:  MOVLW  07
01932:  ADDWFC 03,W
01934:  MOVWF  FEA
01936:  MOVFF  FEC,03
0193A:  MOVF   FED,F
0193C:  MOVFF  FEF,01
01940:  MOVF   03,W
01942:  MOVLB  A
01944:  SUBWF  x10,W
01946:  BTFSS  FD8.0
01948:  BRA    1A36
0194A:  BNZ   1954
0194C:  MOVF   01,W
0194E:  SUBWF  x0F,W
01950:  BTFSS  FD8.0
01952:  BRA    1A36
....................    { 
....................       m_step_cnt[motor]++; 
01954:  MOVLB  7
01956:  MOVF   x3C,W
01958:  MULLW  04
0195A:  MOVF   FF3,W
0195C:  CLRF   03
0195E:  ADDLW  9E
01960:  MOVWF  FE9
01962:  MOVLW  07
01964:  ADDWFC 03,W
01966:  MOVWF  FEA
01968:  MOVLW  01
0196A:  ADDWF  FEE,F
0196C:  MOVLW  00
0196E:  ADDWFC FEE,F
01970:  ADDWFC FEE,F
01972:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
01974:  BCF    FD8.0
01976:  RLCF   x3C,W
01978:  CLRF   03
0197A:  ADDLW  96
0197C:  MOVWF  FE9
0197E:  MOVLW  07
01980:  ADDWFC 03,W
01982:  MOVWF  FEA
01984:  MOVLW  01
01986:  ADDWF  FEE,F
01988:  BNC   198C
0198A:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
0198C:  BCF    FD8.0
0198E:  RLCF   x3C,W
01990:  CLRF   03
01992:  ADDLW  8A
01994:  MOVWF  FE9
01996:  MOVLW  07
01998:  ADDWFC 03,W
0199A:  MOVWF  FEA
0199C:  CLRF   FEC
0199E:  MOVF   FED,F
019A0:  CLRF   FEF
....................  
....................       if (motor==0) 
019A2:  MOVF   x3C,F
019A4:  BNZ   19AA
....................       { 
....................          output_toggle(M1_CLOCK); 
019A6:  BTG    F90.4
....................       } 
019A8:  BRA    1A0A
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019AA:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019AC:  BCF    FD8.0
019AE:  RLCF   x3C,W
019B0:  CLRF   03
019B2:  ADDLW  82
019B4:  MOVWF  FE9
019B6:  MOVLW  07
019B8:  ADDWFC 03,W
019BA:  MOVWF  FEA
019BC:  MOVFF  FEC,A10
019C0:  MOVF   FED,F
019C2:  MOVFF  FEF,A0F
019C6:  MOVLB  A
019C8:  MOVF   x0F,F
019CA:  BNZ   19F0
019CC:  MOVF   x10,F
019CE:  BNZ   19F0
019D0:  BCF    FD8.0
019D2:  MOVLB  7
019D4:  RLCF   x3C,W
019D6:  CLRF   03
019D8:  ADDLW  AF
019DA:  MOVWF  FE9
019DC:  MOVLW  07
019DE:  ADDWFC 03,W
019E0:  MOVWF  FEA
019E2:  MOVLW  FF
019E4:  ADDWF  FEF,F
019E6:  BC    19EC
019E8:  MOVF   FEE,F
019EA:  DECF   FED,F
019EC:  BRA    1A0A
019EE:  MOVLB  A
....................          else m_lin_pos[motor]++;          
019F0:  BCF    FD8.0
019F2:  MOVLB  7
019F4:  RLCF   x3C,W
019F6:  CLRF   03
019F8:  ADDLW  AF
019FA:  MOVWF  FE9
019FC:  MOVLW  07
019FE:  ADDWFC 03,W
01A00:  MOVWF  FEA
01A02:  MOVLW  01
01A04:  ADDWF  FEE,F
01A06:  BNC   1A0A
01A08:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A0A:  BCF    FD8.0
01A0C:  RLCF   x3C,W
01A0E:  CLRF   03
01A10:  ADDLW  62
01A12:  MOVWF  FE9
01A14:  MOVLW  07
01A16:  ADDWFC 03,W
01A18:  MOVWF  FEA
01A1A:  MOVFF  FEC,A10
01A1E:  MOVF   FED,F
01A20:  MOVFF  FEF,A0F
01A24:  MOVLB  A
01A26:  MOVF   x0F,W
01A28:  SUBLW  03
01A2A:  BNZ   1A36
01A2C:  MOVF   x10,F
01A2E:  BNZ   1A36
01A30:  MOVLB  0
01A32:  BRA    17B8
01A34:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A36:  BCF    FA1.1
01A38:  BCF    FA1.1
01A3A:  MOVLB  0
01A3C:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
0891A:  BCF    FD8.0
0891C:  MOVLB  7
0891E:  RLCF   x3C,W
08920:  CLRF   03
08922:  ADDLW  4A
08924:  MOVWF  FE9
08926:  MOVLW  07
08928:  ADDWFC 03,W
0892A:  MOVWF  FEA
0892C:  MOVFF  FEC,8B6
08930:  MOVF   FED,F
08932:  MOVFF  FEF,8B5
08936:  MOVLB  8
08938:  DECFSZ xB5,W
0893A:  BRA    898A
0893C:  MOVF   xB6,F
0893E:  BNZ   898A
08940:  BCF    FD8.0
08942:  MOVLB  7
08944:  RLCF   x3C,W
08946:  CLRF   03
08948:  ADDLW  82
0894A:  MOVWF  01
0894C:  MOVLW  07
0894E:  ADDWFC 03,F
08950:  MOVFF  01,8B5
08954:  MOVLB  8
08956:  MOVFF  03,8B6
0895A:  BCF    FD8.0
0895C:  MOVLB  7
0895E:  RLCF   x3C,W
08960:  CLRF   03
08962:  ADDLW  82
08964:  MOVWF  FE9
08966:  MOVLW  07
08968:  ADDWFC 03,W
0896A:  MOVWF  FEA
0896C:  MOVF   FEF,F
0896E:  BNZ   8974
08970:  MOVF   FEC,F
08972:  BZ    8978
08974:  MOVLW  00
08976:  BRA    897A
08978:  MOVLW  01
0897A:  MOVLB  8
0897C:  MOVFF  8B6,FEA
08980:  MOVFF  8B5,FE9
08984:  CLRF   FEC
08986:  MOVF   FED,F
08988:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
0898A:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
0898C:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
0898E:  BCF    FD8.0
08990:  MOVLB  7
08992:  RLCF   x3C,W
08994:  CLRF   03
08996:  ADDLW  3E
08998:  MOVWF  FE9
0899A:  MOVLW  07
0899C:  ADDWFC 03,W
0899E:  MOVWF  FEA
089A0:  MOVF   FEF,F
089A2:  BNZ   89AC
089A4:  MOVF   FEC,F
089A6:  BNZ   89AC
089A8:  BCF    F90.2
089AA:  BRA    89AE
089AC:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
089AE:  BCF    FD8.0
089B0:  RLCF   x3C,W
089B2:  CLRF   03
089B4:  ADDLW  42
089B6:  MOVWF  FE9
089B8:  MOVLW  07
089BA:  ADDWFC 03,W
089BC:  MOVWF  FEA
089BE:  MOVF   FEF,F
089C0:  BNZ   89CA
089C2:  MOVF   FEC,F
089C4:  BNZ   89CA
089C6:  BCF    F90.3
089C8:  BRA    89CC
089CA:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
089CC:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
089CE:  BCF    FD8.0
089D0:  RLCF   x3C,W
089D2:  CLRF   03
089D4:  ADDLW  82
089D6:  MOVWF  FE9
089D8:  MOVLW  07
089DA:  ADDWFC 03,W
089DC:  MOVWF  FEA
089DE:  MOVF   FEF,F
089E0:  BNZ   89EA
089E2:  MOVF   FEC,F
089E4:  BNZ   89EA
089E6:  BCF    F90.5
089E8:  BRA    89EC
089EA:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
089EC:  BCF    FD8.0
089EE:  RLCF   x3C,W
089F0:  CLRF   03
089F2:  ADDLW  52
089F4:  MOVWF  FE9
089F6:  MOVLW  07
089F8:  ADDWFC 03,W
089FA:  MOVWF  FEA
089FC:  MOVFF  FEC,8B6
08A00:  MOVF   FED,F
08A02:  MOVFF  FEF,8B5
08A06:  MOVLB  8
08A08:  RRCF   xB6,F
08A0A:  RRCF   xB5,F
08A0C:  RRCF   xB6,F
08A0E:  RRCF   xB5,F
08A10:  RRCF   xB6,F
08A12:  MOVFF  8B5,FBC
08A16:  RRCF   xB6,F
08A18:  RRCF   xB6,W
08A1A:  ANDLW  30
08A1C:  MOVWF  00
08A1E:  MOVF   FBB,W
08A20:  ANDLW  CF
08A22:  IORWF  00,W
08A24:  MOVWF  FBB
08A26:  MOVLB  0
08A28:  GOTO   8BB2 (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08A2C:  BCF    FD8.0
08A2E:  MOVLB  7
08A30:  RLCF   x3C,W
08A32:  CLRF   03
08A34:  ADDLW  4A
08A36:  MOVWF  FE9
08A38:  MOVLW  07
08A3A:  ADDWFC 03,W
08A3C:  MOVWF  FEA
08A3E:  MOVFF  FEC,8B6
08A42:  MOVF   FED,F
08A44:  MOVFF  FEF,8B5
08A48:  MOVLB  8
08A4A:  DECFSZ xB5,W
08A4C:  BRA    8A9C
08A4E:  MOVF   xB6,F
08A50:  BNZ   8A9C
08A52:  BCF    FD8.0
08A54:  MOVLB  7
08A56:  RLCF   x3C,W
08A58:  CLRF   03
08A5A:  ADDLW  82
08A5C:  MOVWF  01
08A5E:  MOVLW  07
08A60:  ADDWFC 03,F
08A62:  MOVFF  01,8B5
08A66:  MOVLB  8
08A68:  MOVFF  03,8B6
08A6C:  BCF    FD8.0
08A6E:  MOVLB  7
08A70:  RLCF   x3C,W
08A72:  CLRF   03
08A74:  ADDLW  82
08A76:  MOVWF  FE9
08A78:  MOVLW  07
08A7A:  ADDWFC 03,W
08A7C:  MOVWF  FEA
08A7E:  MOVF   FEF,F
08A80:  BNZ   8A86
08A82:  MOVF   FEC,F
08A84:  BZ    8A8A
08A86:  MOVLW  00
08A88:  BRA    8A8C
08A8A:  MOVLW  01
08A8C:  MOVLB  8
08A8E:  MOVFF  8B6,FEA
08A92:  MOVFF  8B5,FE9
08A96:  CLRF   FEC
08A98:  MOVF   FED,F
08A9A:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08A9C:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08A9E:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08AA0:  BCF    FD8.0
08AA2:  MOVLB  7
08AA4:  RLCF   x3C,W
08AA6:  CLRF   03
08AA8:  ADDLW  3E
08AAA:  MOVWF  FE9
08AAC:  MOVLW  07
08AAE:  ADDWFC 03,W
08AB0:  MOVWF  FEA
08AB2:  MOVF   FEF,F
08AB4:  BNZ   8ABE
08AB6:  MOVF   FEC,F
08AB8:  BNZ   8ABE
08ABA:  BCF    F8D.2
08ABC:  BRA    8AC0
08ABE:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08AC0:  BCF    FD8.0
08AC2:  RLCF   x3C,W
08AC4:  CLRF   03
08AC6:  ADDLW  42
08AC8:  MOVWF  FE9
08ACA:  MOVLW  07
08ACC:  ADDWFC 03,W
08ACE:  MOVWF  FEA
08AD0:  MOVF   FEF,F
08AD2:  BNZ   8ADC
08AD4:  MOVF   FEC,F
08AD6:  BNZ   8ADC
08AD8:  BCF    F8D.3
08ADA:  BRA    8ADE
08ADC:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08ADE:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08AE0:  BCF    FD8.0
08AE2:  RLCF   x3C,W
08AE4:  CLRF   03
08AE6:  ADDLW  82
08AE8:  MOVWF  FE9
08AEA:  MOVLW  07
08AEC:  ADDWFC 03,W
08AEE:  MOVWF  FEA
08AF0:  MOVF   FEF,F
08AF2:  BNZ   8AFC
08AF4:  MOVF   FEC,F
08AF6:  BNZ   8AFC
08AF8:  BCF    F8D.5
08AFA:  BRA    8AFE
08AFC:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08AFE:  BCF    FD8.0
08B00:  RLCF   x3C,W
08B02:  CLRF   03
08B04:  ADDLW  52
08B06:  MOVWF  FE9
08B08:  MOVLW  07
08B0A:  ADDWFC 03,W
08B0C:  MOVWF  FEA
08B0E:  MOVFF  FEC,8B6
08B12:  MOVF   FED,F
08B14:  MOVFF  FEF,8B5
08B18:  MOVLB  8
08B1A:  RRCF   xB6,F
08B1C:  RRCF   xB5,F
08B1E:  RRCF   xB6,F
08B20:  RRCF   xB5,F
08B22:  RRCF   xB6,F
08B24:  MOVFF  8B5,F4F
08B28:  RRCF   xB6,F
08B2A:  RRCF   xB6,W
08B2C:  ANDLW  30
08B2E:  MOVWF  00
08B30:  MOVLB  F
08B32:  MOVF   x4E,W
08B34:  ANDLW  CF
08B36:  IORWF  00,W
08B38:  MOVWF  x4E
08B3A:  MOVLB  0
08B3C:  GOTO   8BB2 (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
08906:  MOVLB  8
08908:  MOVF   xC9,F
0890A:  BZ    8912
....................       output_bit(VENC1,ON); 
0890C:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
0890E:  BSF    F8E.7
....................    } 
08910:  BRA    8916
....................    else {       
....................       output_bit(VENC1,OFF); 
08912:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
08914:  BCF    F8E.7
....................    } 
08916:  MOVLB  0
08918:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08CA0:  MOVLB  8
08CA2:  MOVF   xCA,F
08CA4:  BNZ   8CCC
08CA6:  MOVF   xCB,F
08CA8:  BNZ   8CCC
....................       edge_mode=0; 
08CAA:  MOVLB  7
08CAC:  CLRF   xA6
....................       switch (motor){ 
08CAE:  MOVF   x3C,W
08CB0:  XORLW  00
08CB2:  MOVLB  0
08CB4:  BZ    8CBC
08CB6:  XORLW  01
08CB8:  BZ    8CC4
08CBA:  BRA    8CCA
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08CBC:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08CBE:  BSF    FF0.3
08CC0:  BCF    FF1.5
....................             break; 
08CC2:  BRA    8CCA
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08CC4:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08CC6:  BSF    FF0.4
08CC8:  BCF    FF1.4
....................             break; 
08CCA:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08CCC:  DECFSZ xCA,W
08CCE:  BRA    8CF6
08CD0:  MOVF   xCB,F
08CD2:  BNZ   8CF6
....................       edge_mode=0; 
08CD4:  MOVLB  7
08CD6:  CLRF   xA6
....................       switch (motor){ 
08CD8:  MOVF   x3C,W
08CDA:  XORLW  00
08CDC:  MOVLB  0
08CDE:  BZ    8CE6
08CE0:  XORLW  01
08CE2:  BZ    8CEE
08CE4:  BRA    8CF4
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08CE6:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08CE8:  BSF    FF0.3
08CEA:  BSF    FF1.5
....................             break; 
08CEC:  BRA    8CF4
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08CEE:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08CF0:  BSF    FF0.4
08CF2:  BSF    FF1.4
....................             break; 
08CF4:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08CF6:  MOVF   xCA,W
08CF8:  SUBLW  02
08CFA:  BNZ   8D4C
08CFC:  MOVF   xCB,F
08CFE:  BNZ   8D4C
08D00:  BCF    FD8.0
08D02:  MOVLB  7
08D04:  RLCF   x3C,W
08D06:  CLRF   03
08D08:  ADDLW  66
08D0A:  MOVWF  FE9
08D0C:  MOVLW  07
08D0E:  ADDWFC 03,W
08D10:  MOVWF  FEA
08D12:  MOVFF  FEC,8CD
08D16:  MOVF   FED,F
08D18:  MOVFF  FEF,8CC
08D1C:  MOVLB  8
08D1E:  MOVF   xCC,W
08D20:  SUBLW  02
08D22:  BNZ   8D4C
08D24:  MOVF   xCD,F
08D26:  BNZ   8D4C
....................       edge_mode=1; 
08D28:  MOVLW  01
08D2A:  MOVLB  7
08D2C:  MOVWF  xA6
....................       switch (motor){ 
08D2E:  MOVF   x3C,W
08D30:  XORLW  00
08D32:  MOVLB  0
08D34:  BZ    8D3C
08D36:  XORLW  01
08D38:  BZ    8D44
08D3A:  BRA    8D4A
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08D3C:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08D3E:  BSF    FF0.3
08D40:  BSF    FF1.5
....................             break; 
08D42:  BRA    8D4A
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08D44:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08D46:  BSF    FF0.4
08D48:  BSF    FF1.4
....................             break; 
08D4A:  MOVLB  8
....................       }  
....................    }     
08D4C:  MOVLB  0
08D4E:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08EB6:  MOVLB  7
08EB8:  MOVF   x3C,W
08EBA:  XORLW  00
08EBC:  MOVLB  0
08EBE:  BZ    8EC6
08EC0:  XORLW  01
08EC2:  BZ    8EF0
08EC4:  BRA    8F18
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08EC6:  BCF    FD8.0
08EC8:  MOVLB  7
08ECA:  RLCF   x3C,W
08ECC:  CLRF   03
08ECE:  ADDLW  92
08ED0:  MOVWF  FE9
08ED2:  MOVLW  07
08ED4:  ADDWFC 03,W
08ED6:  MOVWF  FEA
08ED8:  MOVFF  FEC,8CD
08EDC:  MOVF   FED,F
08EDE:  MOVFF  FEF,8CC
08EE2:  MOVLW  6E
08EE4:  MOVLB  8
08EE6:  MOVWF  xCB
08EE8:  MOVLB  0
08EEA:  CALL   4F4C
....................          break; 
08EEE:  BRA    8F18
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08EF0:  BCF    FD8.0
08EF2:  MOVLB  7
08EF4:  RLCF   x3C,W
08EF6:  CLRF   03
08EF8:  ADDLW  92
08EFA:  MOVWF  FE9
08EFC:  MOVLW  07
08EFE:  ADDWFC 03,W
08F00:  MOVWF  FEA
08F02:  MOVFF  FEC,8CD
08F06:  MOVF   FED,F
08F08:  MOVFF  FEF,8CC
08F0C:  MOVLW  70
08F0E:  MOVLB  8
08F10:  MOVWF  xCB
08F12:  MOVLB  0
08F14:  CALL   4F4C
....................          break;          
....................    } 
08F18:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08D50:  MOVLB  8
08D52:  MOVF   xC9,F
08D54:  BNZ   8D72
....................    { 
....................       switch (motor) 
08D56:  MOVLB  7
08D58:  MOVF   x3C,W
08D5A:  XORLW  00
08D5C:  MOVLB  0
08D5E:  BZ    8D66
08D60:  XORLW  01
08D62:  BZ    8D6C
08D64:  BRA    8D70
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08D66:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08D68:  BCF    FF0.3
....................             break; 
08D6A:  BRA    8D70
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08D6C:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08D6E:  BCF    FF0.4
....................             break; 
08D70:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08D72:  DECFSZ xC9,W
08D74:  BRA    8DDA
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08D76:  BCF    FD8.0
08D78:  MOVLB  7
08D7A:  RLCF   x3C,W
08D7C:  CLRF   03
08D7E:  ADDLW  66
08D80:  MOVWF  FE9
08D82:  MOVLW  07
08D84:  ADDWFC 03,W
08D86:  MOVWF  FEA
08D88:  MOVFF  FEC,8CB
08D8C:  MOVF   FED,F
08D8E:  MOVFF  FEF,8CA
08D92:  MOVLB  8
08D94:  DECFSZ xCA,W
08D96:  BRA    8DA6
08D98:  MOVF   xCB,F
08D9A:  BNZ   8DA6
08D9C:  CLRF   xCB
08D9E:  CLRF   xCA
08DA0:  MOVLB  0
08DA2:  RCALL  8CA0
08DA4:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08DA6:  BCF    FD8.0
08DA8:  MOVLB  7
08DAA:  RLCF   x3C,W
08DAC:  CLRF   03
08DAE:  ADDLW  66
08DB0:  MOVWF  FE9
08DB2:  MOVLW  07
08DB4:  ADDWFC 03,W
08DB6:  MOVWF  FEA
08DB8:  MOVFF  FEC,8CB
08DBC:  MOVF   FED,F
08DBE:  MOVFF  FEF,8CA
08DC2:  MOVLB  8
08DC4:  MOVF   xCA,W
08DC6:  SUBLW  02
08DC8:  BNZ   8DDA
08DCA:  MOVF   xCB,F
08DCC:  BNZ   8DDA
08DCE:  CLRF   xCB
08DD0:  MOVLW  01
08DD2:  MOVWF  xCA
08DD4:  MOVLB  0
08DD6:  RCALL  8CA0
08DD8:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08DDA:  MOVF   xC9,W
08DDC:  SUBLW  02
08DDE:  BNZ   8E14
08DE0:  BCF    FD8.0
08DE2:  MOVLB  7
08DE4:  RLCF   x3C,W
08DE6:  CLRF   03
08DE8:  ADDLW  66
08DEA:  MOVWF  FE9
08DEC:  MOVLW  07
08DEE:  ADDWFC 03,W
08DF0:  MOVWF  FEA
08DF2:  MOVFF  FEC,8CB
08DF6:  MOVF   FED,F
08DF8:  MOVFF  FEF,8CA
08DFC:  MOVLB  8
08DFE:  MOVF   xCA,W
08E00:  SUBLW  02
08E02:  BNZ   8E14
08E04:  MOVF   xCB,F
08E06:  BNZ   8E14
....................    { 
....................       enable_enc_isr(2);   
08E08:  CLRF   xCB
08E0A:  MOVLW  02
08E0C:  MOVWF  xCA
08E0E:  MOVLB  0
08E10:  RCALL  8CA0
08E12:  MOVLB  8
....................    } 
08E14:  MOVLB  0
08E16:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08B40:  BCF    FD8.0
08B42:  MOVLB  7
08B44:  RLCF   x3C,W
08B46:  CLRF   03
08B48:  ADDLW  8A
08B4A:  MOVWF  FE9
08B4C:  MOVLW  07
08B4E:  ADDWFC 03,W
08B50:  MOVWF  FEA
08B52:  CLRF   FEC
08B54:  MOVF   FED,F
08B56:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08B58:  BCF    FD8.0
08B5A:  RLCF   x3C,W
08B5C:  CLRF   03
08B5E:  ADDLW  B7
08B60:  MOVWF  FE9
08B62:  MOVLW  07
08B64:  ADDWFC 03,W
08B66:  MOVWF  FEA
08B68:  CLRF   FEC
08B6A:  MOVF   FED,F
08B6C:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08B6E:  BCF    FD8.0
08B70:  RLCF   x3C,W
08B72:  CLRF   03
08B74:  ADDLW  96
08B76:  MOVWF  FE9
08B78:  MOVLW  07
08B7A:  ADDWFC 03,W
08B7C:  MOVWF  FEA
08B7E:  CLRF   FEC
08B80:  MOVF   FED,F
08B82:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08B84:  BSF    F8E.1
....................    enc_pwr(ON); 
08B86:  MOVLW  01
08B88:  MOVLB  8
08B8A:  MOVWF  xC9
08B8C:  MOVLB  0
08B8E:  RCALL  8906
....................    delay_ms(100); 
08B90:  MOVLW  64
08B92:  MOVLB  9
08B94:  MOVWF  xC9
08B96:  MOVLB  0
08B98:  CALL   288E
....................     
....................    switch (motor){ 
08B9C:  MOVLB  7
08B9E:  MOVF   x3C,W
08BA0:  XORLW  00
08BA2:  MOVLB  0
08BA4:  BZ    8BAC
08BA6:  XORLW  01
08BA8:  BZ    8BB0
08BAA:  BRA    8BB2
....................       case 0 : motor_setup1(); 
08BAC:  BRA    891A
....................          break; 
08BAE:  BRA    8BB2
....................       case 1 : motor_setup2(); 
08BB0:  BRA    8A2C
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08BB2:  BCF    FD8.0
08BB4:  MOVLB  7
08BB6:  RLCF   x3C,W
08BB8:  CLRF   03
08BBA:  ADDLW  86
08BBC:  MOVWF  FE9
08BBE:  MOVLW  07
08BC0:  ADDWFC 03,W
08BC2:  MOVWF  FEA
08BC4:  MOVFF  FEC,8B6
08BC8:  MOVF   FED,F
08BCA:  MOVFF  FEF,8B5
08BCE:  BCF    FD8.0
08BD0:  RLCF   x3C,W
08BD2:  CLRF   03
08BD4:  ADDLW  82
08BD6:  MOVWF  FE9
08BD8:  MOVLW  07
08BDA:  ADDWFC 03,W
08BDC:  MOVWF  FEA
08BDE:  MOVFF  FEC,03
08BE2:  MOVF   FED,F
08BE4:  MOVF   FEF,W
08BE6:  MOVLB  8
08BE8:  SUBWF  xB5,W
08BEA:  BNZ   8BF2
08BEC:  MOVF   03,W
08BEE:  SUBWF  xB6,W
08BF0:  BZ    8C9A
....................       m_way_rst[motor]=m_way[motor]; 
08BF2:  BCF    FD8.0
08BF4:  MOVLB  7
08BF6:  RLCF   x3C,W
08BF8:  CLRF   03
08BFA:  ADDLW  86
08BFC:  MOVWF  01
08BFE:  MOVLW  07
08C00:  ADDWFC 03,F
08C02:  MOVLB  8
08C04:  MOVFF  03,8B6
08C08:  BCF    FD8.0
08C0A:  MOVLB  7
08C0C:  RLCF   x3C,W
08C0E:  CLRF   03
08C10:  ADDLW  82
08C12:  MOVWF  FE9
08C14:  MOVLW  07
08C16:  ADDWFC 03,W
08C18:  MOVWF  FEA
08C1A:  MOVFF  FEC,03
08C1E:  MOVF   FED,F
08C20:  MOVFF  FEF,8B7
08C24:  MOVLB  8
08C26:  MOVFF  8B6,FEA
08C2A:  MOVFF  01,FE9
08C2E:  MOVFF  03,FEC
08C32:  MOVF   FED,F
08C34:  MOVFF  8B7,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08C38:  BCF    FD8.0
08C3A:  MOVLB  7
08C3C:  RLCF   x3C,W
08C3E:  CLRF   03
08C40:  ADDLW  9A
08C42:  MOVWF  01
08C44:  MOVLW  07
08C46:  ADDWFC 03,F
08C48:  MOVLB  8
08C4A:  MOVFF  03,8B6
08C4E:  BCF    FD8.0
08C50:  MOVLB  7
08C52:  RLCF   x3C,W
08C54:  CLRF   03
08C56:  ADDLW  62
08C58:  MOVWF  FE9
08C5A:  MOVLW  07
08C5C:  ADDWFC 03,W
08C5E:  MOVWF  FEA
08C60:  MOVFF  FEC,03
08C64:  MOVF   FED,F
08C66:  MOVFF  FEF,8B7
08C6A:  MOVLB  8
08C6C:  MOVFF  8B6,FEA
08C70:  MOVFF  01,FE9
08C74:  MOVFF  03,FEC
08C78:  MOVF   FED,F
08C7A:  MOVFF  8B7,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08C7E:  BCF    FD8.0
08C80:  MOVLB  7
08C82:  RLCF   x3C,W
08C84:  CLRF   03
08C86:  ADDLW  62
08C88:  MOVWF  FE9
08C8A:  MOVLW  07
08C8C:  ADDWFC 03,W
08C8E:  MOVWF  FEA
08C90:  CLRF   FEC
08C92:  MOVF   FED,F
08C94:  MOVLW  05
08C96:  MOVWF  FEF
08C98:  MOVLB  8
....................    } 
08C9A:  MOVLB  0
08C9C:  GOTO   8E1A (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08E18:  BRA    8B40
....................     
....................    m_comp[motor]=FALSE; 
08E1A:  BCF    FD8.0
08E1C:  MOVLB  7
08E1E:  RLCF   x3C,W
08E20:  CLRF   03
08E22:  ADDLW  AB
08E24:  MOVWF  FE9
08E26:  MOVLW  07
08E28:  ADDWFC 03,W
08E2A:  MOVWF  FEA
08E2C:  CLRF   FEC
08E2E:  MOVF   FED,F
08E30:  CLRF   FEF
....................     
....................    switch (motor){ 
08E32:  MOVF   x3C,W
08E34:  XORLW  00
08E36:  MOVLB  0
08E38:  BZ    8E40
08E3A:  XORLW  01
08E3C:  BZ    8E52
08E3E:  BRA    8E62
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08E40:  MOVLW  B2
08E42:  MOVLB  8
08E44:  MOVWF  xCB
08E46:  CLRF   xCD
08E48:  CLRF   xCC
08E4A:  MOVLB  0
08E4C:  CALL   4F4C
....................          break; 
08E50:  BRA    8E62
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08E52:  MOVLW  B4
08E54:  MOVLB  8
08E56:  MOVWF  xCB
08E58:  CLRF   xCD
08E5A:  CLRF   xCC
08E5C:  MOVLB  0
08E5E:  CALL   4F4C
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08E62:  MOVLB  7
08E64:  MOVF   x3C,W
08E66:  XORLW  00
08E68:  MOVLB  0
08E6A:  BZ    8E72
08E6C:  XORLW  01
08E6E:  BZ    8E76
08E70:  BRA    8E78
....................       case 0 : output_bit(M1_ENABLE, ON); 
08E72:  BSF    F90.1
....................          break; 
08E74:  BRA    8E78
....................       case 1 : output_bit(M2_ENABLE, ON); 
08E76:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08E78:  MOVLW  32
08E7A:  MOVLB  9
08E7C:  MOVWF  xC9
08E7E:  MOVLB  0
08E80:  CALL   288E
....................     
....................    set_timer3(STEP_INTERVAL); 
08E84:  MOVLW  F9
08E86:  MOVWF  FB3
08E88:  MOVLW  C0
08E8A:  MOVWF  FB2
....................    enc_isr(int_mode); 
08E8C:  MOVFF  8B4,8C9
08E90:  RCALL  8D50
....................    clear_interrupt(INT_TIMER3); 
08E92:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08E94:  BCF    FD8.0
08E96:  MOVLB  7
08E98:  RLCF   x3C,W
08E9A:  CLRF   03
08E9C:  ADDLW  8E
08E9E:  MOVWF  FE9
08EA0:  MOVLW  07
08EA2:  ADDWFC 03,W
08EA4:  MOVWF  FEA
08EA6:  CLRF   FEC
08EA8:  MOVF   FED,F
08EAA:  MOVLW  01
08EAC:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08EAE:  BSF    FA0.1
08EB0:  MOVLB  0
08EB2:  GOTO   A12A (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
0853C:  MOVFF  8B7,8BF
08540:  MOVFF  8B6,8BE
08544:  MOVFF  8B5,8BD
08548:  MOVFF  8B4,8BC
....................    enc_res    = e_cpr[motor]; 
0854C:  BCF    FD8.0
0854E:  MOVLB  7
08550:  RLCF   x3C,W
08552:  CLRF   03
08554:  ADDLW  5A
08556:  MOVWF  FE9
08558:  MOVLW  07
0855A:  ADDWFC 03,W
0855C:  MOVWF  FEA
0855E:  MOVLB  8
08560:  CLRF   xC3
08562:  CLRF   xC2
08564:  MOVFF  FEC,8C1
08568:  MOVF   FED,F
0856A:  MOVFF  FEF,8C0
....................    ports      = e_ppr[motor]; 
0856E:  BCF    FD8.0
08570:  MOVLB  7
08572:  RLCF   x3C,W
08574:  CLRF   03
08576:  ADDLW  5E
08578:  MOVWF  FE9
0857A:  MOVLW  07
0857C:  ADDWFC 03,W
0857E:  MOVWF  FEA
08580:  MOVLB  8
08582:  CLRF   xCB
08584:  CLRF   xCA
08586:  MOVFF  FEC,8C9
0858A:  MOVF   FED,F
0858C:  MOVFF  FEF,8C8
....................     
....................    enc_res = enc_res * 1000; 
08590:  MOVFF  8C3,9D6
08594:  MOVFF  8C2,9D5
08598:  MOVFF  8C1,9D4
0859C:  MOVFF  8C0,9D3
085A0:  MOVLB  9
085A2:  CLRF   xDA
085A4:  CLRF   xD9
085A6:  MOVLW  03
085A8:  MOVWF  xD8
085AA:  MOVLW  E8
085AC:  MOVWF  xD7
085AE:  MOVLB  0
085B0:  CALL   4772
085B4:  MOVFF  03,8C3
085B8:  MOVFF  02,8C2
085BC:  MOVFF  01,8C1
085C0:  MOVFF  00,8C0
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
085C4:  BCF    FD8.1
085C6:  CLRF   1B
085C8:  BTFSC  FF2.7
085CA:  BSF    1B.7
085CC:  BCF    FF2.7
085CE:  MOVFF  8C3,A27
085D2:  MOVFF  8C2,A26
085D6:  MOVFF  8C1,A25
085DA:  MOVFF  8C0,A24
085DE:  MOVFF  8CB,A2B
085E2:  MOVFF  8CA,A2A
085E6:  MOVFF  8C9,A29
085EA:  MOVFF  8C8,A28
085EE:  CALL   1038
085F2:  BTFSC  1B.7
085F4:  BSF    FF2.7
085F6:  MOVFF  03,8BB
085FA:  MOVFF  02,8BA
085FE:  MOVFF  01,8B9
08602:  MOVFF  00,8B8
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
08606:  MOVFF  8B7,9D6
0860A:  MOVFF  8B6,9D5
0860E:  MOVFF  8B5,9D4
08612:  MOVFF  8B4,9D3
08616:  MOVFF  8BB,9DA
0861A:  MOVFF  8BA,9D9
0861E:  MOVFF  8B9,9D8
08622:  MOVFF  8B8,9D7
08626:  CALL   4772
0862A:  MOVLB  8
0862C:  MOVF   xB8,W
0862E:  SUBWF  00,W
08630:  MOVWF  xBC
08632:  MOVF   xB9,W
08634:  SUBWFB 01,W
08636:  MOVWF  xBD
08638:  MOVF   xBA,W
0863A:  SUBWFB 02,W
0863C:  MOVWF  xBE
0863E:  MOVF   xBB,W
08640:  SUBWFB 03,W
08642:  MOVWF  xBF
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
08644:  BCF    FD8.1
08646:  CLRF   1B
08648:  BTFSC  FF2.7
0864A:  BSF    1B.7
0864C:  BCF    FF2.7
0864E:  MOVFF  8BF,A27
08652:  MOVFF  8BE,A26
08656:  MOVFF  8BD,A25
0865A:  MOVFF  8BC,A24
0865E:  MOVLB  A
08660:  CLRF   x2B
08662:  CLRF   x2A
08664:  MOVLW  03
08666:  MOVWF  x29
08668:  MOVLW  E8
0866A:  MOVWF  x28
0866C:  MOVLB  0
0866E:  CALL   1038
08672:  BTFSC  1B.7
08674:  BSF    FF2.7
08676:  MOVFF  03,8C7
0867A:  MOVFF  02,8C6
0867E:  MOVFF  01,8C5
08682:  MOVFF  00,8C4
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
08686:  MOVFF  8C7,9D6
0868A:  MOVFF  8C6,9D5
0868E:  MOVFF  8C5,9D4
08692:  MOVFF  8C4,9D3
08696:  MOVLB  9
08698:  CLRF   xDA
0869A:  CLRF   xD9
0869C:  MOVLW  03
0869E:  MOVWF  xD8
086A0:  MOVLW  E8
086A2:  MOVWF  xD7
086A4:  MOVLB  0
086A6:  CALL   4772
086AA:  MOVFF  03,8C7
086AE:  MOVFF  02,8C6
086B2:  MOVFF  01,8C5
086B6:  MOVFF  00,8C4
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
086BA:  MOVLB  8
086BC:  MOVF   xC4,W
086BE:  SUBWF  xBC,F
086C0:  MOVF   xC5,W
086C2:  SUBWFB xBD,F
086C4:  MOVF   xC6,W
086C6:  SUBWFB xBE,F
086C8:  MOVF   xC7,W
086CA:  SUBWFB xBF,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
086CC:  BCF    FD8.1
086CE:  CLRF   1B
086D0:  BTFSC  FF2.7
086D2:  BSF    1B.7
086D4:  BCF    FF2.7
086D6:  MOVFF  8C7,A27
086DA:  MOVFF  8C6,A26
086DE:  MOVFF  8C5,A25
086E2:  MOVFF  8C4,A24
086E6:  MOVLB  A
086E8:  CLRF   x2B
086EA:  CLRF   x2A
086EC:  MOVLW  03
086EE:  MOVWF  x29
086F0:  MOVLW  E8
086F2:  MOVWF  x28
086F4:  MOVLB  0
086F6:  CALL   1038
086FA:  BTFSC  1B.7
086FC:  BSF    FF2.7
086FE:  MOVFF  03,8C7
08702:  MOVFF  02,8C6
08706:  MOVFF  01,8C5
0870A:  MOVFF  00,8C4
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
0870E:  MOVLB  8
08710:  MOVF   xBF,F
08712:  BNZ   8728
08714:  MOVF   xBE,F
08716:  BNZ   8728
08718:  MOVF   xBD,W
0871A:  SUBLW  00
0871C:  BC    8738
0871E:  XORLW  FF
08720:  BNZ   8728
08722:  MOVF   xBC,W
08724:  SUBLW  F3
08726:  BC    8738
08728:  MOVLW  01
0872A:  ADDWF  xC4,F
0872C:  BTFSC  FD8.0
0872E:  INCF   xC5,F
08730:  BTFSC  FD8.2
08732:  INCF   xC6,F
08734:  BTFSC  FD8.2
08736:  INCF   xC7,F
....................    return(enc_pos); 
08738:  MOVFF  8C4,00
0873C:  MOVFF  8C5,01
08740:  MOVFF  8C6,02
08744:  MOVFF  8C7,03
08748:  MOVLB  0
0874A:  GOTO   A0B2 (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
0874E:  BCF    FD8.0
08750:  MOVLB  7
08752:  RLCF   x3C,W
08754:  CLRF   03
08756:  ADDLW  BB
08758:  MOVWF  FE9
0875A:  MOVLW  07
0875C:  ADDWFC 03,W
0875E:  MOVWF  FEA
08760:  MOVFF  FEC,03
08764:  MOVF   FED,F
08766:  MOVFF  FEF,01
0876A:  MOVF   03,W
0876C:  MOVLB  8
0876E:  SUBWF  xB7,W
08770:  BNC   8838
08772:  BNZ   877A
08774:  MOVF   xB6,W
08776:  SUBWF  01,W
08778:  BC    8838
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
0877A:  BCF    FD8.0
0877C:  MOVLB  7
0877E:  RLCF   x3C,W
08780:  CLRF   03
08782:  ADDLW  BB
08784:  MOVWF  FE9
08786:  MOVLW  07
08788:  ADDWFC 03,W
0878A:  MOVWF  FEA
0878C:  MOVFF  FEC,03
08790:  MOVF   FED,F
08792:  MOVF   FEF,W
08794:  MOVLB  8
08796:  SUBWF  xB6,W
08798:  MOVWF  xB8
0879A:  MOVF   03,W
0879C:  SUBWFB xB7,W
0879E:  MOVWF  xB9
....................       if (e_pos_r > (e_cpr[motor]/2)) 
087A0:  BCF    FD8.0
087A2:  MOVLB  7
087A4:  RLCF   x3C,W
087A6:  CLRF   03
087A8:  ADDLW  5A
087AA:  MOVWF  FE9
087AC:  MOVLW  07
087AE:  ADDWFC 03,W
087B0:  MOVWF  FEA
087B2:  MOVFF  FEC,8BB
087B6:  MOVF   FED,F
087B8:  MOVFF  FEF,8BA
087BC:  BCF    FD8.0
087BE:  MOVLB  8
087C0:  RRCF   xBB,W
087C2:  MOVWF  03
087C4:  RRCF   xBA,W
087C6:  MOVWF  02
087C8:  MOVWF  01
087CA:  MOVF   03,W
087CC:  SUBWF  xB9,W
087CE:  BNC   881C
087D0:  BNZ   87D8
087D2:  MOVF   xB8,W
087D4:  SUBWF  01,W
087D6:  BC    881C
....................       { 
....................          m_way[motor] = NEG; 
087D8:  BCF    FD8.0
087DA:  MOVLB  7
087DC:  RLCF   x3C,W
087DE:  CLRF   03
087E0:  ADDLW  82
087E2:  MOVWF  FE9
087E4:  MOVLW  07
087E6:  ADDWFC 03,W
087E8:  MOVWF  FEA
087EA:  CLRF   FEC
087EC:  MOVF   FED,F
087EE:  MOVLW  01
087F0:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
087F2:  BCF    FD8.0
087F4:  RLCF   x3C,W
087F6:  CLRF   03
087F8:  ADDLW  5A
087FA:  MOVWF  FE9
087FC:  MOVLW  07
087FE:  ADDWFC 03,W
08800:  MOVWF  FEA
08802:  MOVFF  FEC,8BB
08806:  MOVF   FED,F
08808:  MOVFF  FEF,8BA
0880C:  MOVLB  8
0880E:  MOVF   xB8,W
08810:  SUBWF  xBA,W
08812:  MOVWF  xB8
08814:  MOVF   xB9,W
08816:  SUBWFB xBB,W
08818:  MOVWF  xB9
....................       } 
0881A:  BRA    8836
....................       else 
....................       { 
....................          m_way[motor] = POS; 
0881C:  BCF    FD8.0
0881E:  MOVLB  7
08820:  RLCF   x3C,W
08822:  CLRF   03
08824:  ADDLW  82
08826:  MOVWF  FE9
08828:  MOVLW  07
0882A:  ADDWFC 03,W
0882C:  MOVWF  FEA
0882E:  CLRF   FEC
08830:  MOVF   FED,F
08832:  CLRF   FEF
08834:  MOVLB  8
....................       } 
....................    } 
08836:  BRA    88F8
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
08838:  BCF    FD8.0
0883A:  MOVLB  7
0883C:  RLCF   x3C,W
0883E:  CLRF   03
08840:  ADDLW  BB
08842:  MOVWF  FE9
08844:  MOVLW  07
08846:  ADDWFC 03,W
08848:  MOVWF  FEA
0884A:  MOVFF  FEC,8BB
0884E:  MOVF   FED,F
08850:  MOVFF  FEF,8BA
08854:  MOVLB  8
08856:  MOVF   xB6,W
08858:  SUBWF  xBA,W
0885A:  MOVWF  xB8
0885C:  MOVF   xB7,W
0885E:  SUBWFB xBB,W
08860:  MOVWF  xB9
....................       if (e_pos_r > (e_cpr[motor]/2)) 
08862:  BCF    FD8.0
08864:  MOVLB  7
08866:  RLCF   x3C,W
08868:  CLRF   03
0886A:  ADDLW  5A
0886C:  MOVWF  FE9
0886E:  MOVLW  07
08870:  ADDWFC 03,W
08872:  MOVWF  FEA
08874:  MOVFF  FEC,8BB
08878:  MOVF   FED,F
0887A:  MOVFF  FEF,8BA
0887E:  BCF    FD8.0
08880:  MOVLB  8
08882:  RRCF   xBB,W
08884:  MOVWF  03
08886:  RRCF   xBA,W
08888:  MOVWF  02
0888A:  MOVWF  01
0888C:  MOVF   03,W
0888E:  SUBWF  xB9,W
08890:  BNC   88DC
08892:  BNZ   889A
08894:  MOVF   xB8,W
08896:  SUBWF  01,W
08898:  BC    88DC
....................       { 
....................          m_way[motor] = POS; 
0889A:  BCF    FD8.0
0889C:  MOVLB  7
0889E:  RLCF   x3C,W
088A0:  CLRF   03
088A2:  ADDLW  82
088A4:  MOVWF  FE9
088A6:  MOVLW  07
088A8:  ADDWFC 03,W
088AA:  MOVWF  FEA
088AC:  CLRF   FEC
088AE:  MOVF   FED,F
088B0:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088B2:  BCF    FD8.0
088B4:  RLCF   x3C,W
088B6:  CLRF   03
088B8:  ADDLW  5A
088BA:  MOVWF  FE9
088BC:  MOVLW  07
088BE:  ADDWFC 03,W
088C0:  MOVWF  FEA
088C2:  MOVFF  FEC,8BB
088C6:  MOVF   FED,F
088C8:  MOVFF  FEF,8BA
088CC:  MOVLB  8
088CE:  MOVF   xB8,W
088D0:  SUBWF  xBA,W
088D2:  MOVWF  xB8
088D4:  MOVF   xB9,W
088D6:  SUBWFB xBB,W
088D8:  MOVWF  xB9
....................       } 
088DA:  BRA    88F8
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
088DC:  BCF    FD8.0
088DE:  MOVLB  7
088E0:  RLCF   x3C,W
088E2:  CLRF   03
088E4:  ADDLW  82
088E6:  MOVWF  FE9
088E8:  MOVLW  07
088EA:  ADDWFC 03,W
088EC:  MOVWF  FEA
088EE:  CLRF   FEC
088F0:  MOVF   FED,F
088F2:  MOVLW  01
088F4:  MOVWF  FEF
088F6:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
088F8:  MOVFF  8B8,01
088FC:  MOVFF  8B9,02
08900:  MOVLB  0
08902:  GOTO   A0DE (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
09006:  BCF    FD8.0
09008:  MOVLB  7
0900A:  RLCF   x3C,W
0900C:  CLRF   03
0900E:  ADDLW  8E
09010:  MOVWF  FE9
09012:  MOVLW  07
09014:  ADDWFC 03,W
09016:  MOVWF  FEA
09018:  CLRF   FEC
0901A:  MOVF   FED,F
0901C:  CLRF   FEF
....................           
....................    switch (motor){ 
0901E:  MOVF   x3C,W
09020:  XORLW  00
09022:  MOVLB  0
09024:  BZ    902C
09026:  XORLW  01
09028:  BZ    9096
0902A:  BRA    9104
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
0902C:  BCF    FD8.0
0902E:  MOVLB  7
09030:  RLCF   x3C,W
09032:  CLRF   03
09034:  ADDLW  4E
09036:  MOVWF  FE9
09038:  MOVLW  07
0903A:  ADDWFC 03,W
0903C:  MOVWF  FEA
0903E:  MOVFF  FEC,8CA
09042:  MOVF   FED,F
09044:  MOVFF  FEF,8C9
09048:  MOVLB  8
0904A:  MOVF   xC9,F
0904C:  BNZ   9052
0904E:  MOVF   xCA,F
09050:  BZ    9090
09052:  BCF    FD8.0
09054:  MOVLB  7
09056:  RLCF   x3C,W
09058:  CLRF   03
0905A:  ADDLW  4E
0905C:  MOVWF  FE9
0905E:  MOVLW  07
09060:  ADDWFC 03,W
09062:  MOVWF  FEA
09064:  MOVFF  FEC,8CA
09068:  MOVF   FED,F
0906A:  MOVFF  FEF,8C9
0906E:  MOVLB  8
09070:  RRCF   xCA,F
09072:  RRCF   xC9,F
09074:  RRCF   xCA,F
09076:  RRCF   xC9,F
09078:  RRCF   xCA,F
0907A:  MOVFF  8C9,FBC
0907E:  RRCF   xCA,F
09080:  RRCF   xCA,W
09082:  ANDLW  30
09084:  MOVWF  00
09086:  MOVF   FBB,W
09088:  ANDLW  CF
0908A:  IORWF  00,W
0908C:  MOVWF  FBB
0908E:  BRA    9092
....................                else output_bit(M1_ENABLE, OFF); 
09090:  BCF    F90.1
....................          break;   
09092:  MOVLB  0
09094:  BRA    9104
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
09096:  BCF    FD8.0
09098:  MOVLB  7
0909A:  RLCF   x3C,W
0909C:  CLRF   03
0909E:  ADDLW  4E
090A0:  MOVWF  FE9
090A2:  MOVLW  07
090A4:  ADDWFC 03,W
090A6:  MOVWF  FEA
090A8:  MOVFF  FEC,8CA
090AC:  MOVF   FED,F
090AE:  MOVFF  FEF,8C9
090B2:  MOVLB  8
090B4:  MOVF   xC9,F
090B6:  BNZ   90BC
090B8:  MOVF   xCA,F
090BA:  BZ    90FE
090BC:  BCF    FD8.0
090BE:  MOVLB  7
090C0:  RLCF   x3C,W
090C2:  CLRF   03
090C4:  ADDLW  4E
090C6:  MOVWF  FE9
090C8:  MOVLW  07
090CA:  ADDWFC 03,W
090CC:  MOVWF  FEA
090CE:  MOVFF  FEC,8CA
090D2:  MOVF   FED,F
090D4:  MOVFF  FEF,8C9
090D8:  MOVLB  8
090DA:  RRCF   xCA,F
090DC:  RRCF   xC9,F
090DE:  RRCF   xCA,F
090E0:  RRCF   xC9,F
090E2:  RRCF   xCA,F
090E4:  MOVFF  8C9,F4F
090E8:  RRCF   xCA,F
090EA:  RRCF   xCA,W
090EC:  ANDLW  30
090EE:  MOVWF  00
090F0:  MOVLB  F
090F2:  MOVF   x4E,W
090F4:  ANDLW  CF
090F6:  IORWF  00,W
090F8:  MOVWF  x4E
090FA:  BRA    9102
090FC:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
090FE:  BCF    F8D.1
09100:  MOVLB  F
....................          break; 
09102:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
09104:  BCF    FA0.1
....................    enc_isr(OFF); 
09106:  MOVLB  8
09108:  CLRF   xC9
0910A:  MOVLB  0
0910C:  RCALL  8D50
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
0910E:  MOVLB  7
09110:  MOVF   x4E,F
09112:  BNZ   9122
09114:  MOVF   x4F,F
09116:  BNZ   9122
09118:  MOVF   x50,F
0911A:  BNZ   9122
0911C:  MOVF   x51,F
0911E:  BNZ   9122
....................    { 
....................       output_bit(VMOT,OFF); 
09120:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
09122:  MOVLB  8
09124:  CLRF   xC9
09126:  MOVLB  0
09128:  CALL   8906
....................  
....................    if(success==TRUE) 
0912C:  MOVLB  8
0912E:  DECFSZ xC8,W
09130:  BRA    92CC
....................    { 
....................       m_error[motor]=FALSE; 
09132:  BCF    FD8.0
09134:  MOVLB  7
09136:  RLCF   x3C,W
09138:  CLRF   03
0913A:  ADDLW  92
0913C:  MOVWF  FE9
0913E:  MOVLW  07
09140:  ADDWFC 03,W
09142:  MOVWF  FEA
09144:  CLRF   FEC
09146:  MOVF   FED,F
09148:  CLRF   FEF
....................       wrt_m_error(); 
0914A:  MOVLB  0
0914C:  RCALL  8EB6
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
0914E:  BCF    FD8.0
09150:  MOVLB  7
09152:  RLCF   x3C,W
09154:  CLRF   03
09156:  ADDLW  62
09158:  MOVWF  FE9
0915A:  MOVLW  07
0915C:  ADDWFC 03,W
0915E:  MOVWF  FEA
09160:  MOVFF  FEC,8CA
09164:  MOVF   FED,F
09166:  MOVFF  FEF,8C9
0916A:  MOVLB  8
0916C:  MOVF   xC9,W
0916E:  SUBLW  03
09170:  BNZ   91A8
09172:  MOVF   xCA,F
09174:  BNZ   91A8
....................       { 
....................          e_pos[motor] = 0; 
09176:  BCF    FD8.0
09178:  MOVLB  7
0917A:  RLCF   x3C,W
0917C:  CLRF   03
0917E:  ADDLW  BB
09180:  MOVWF  FE9
09182:  MOVLW  07
09184:  ADDWFC 03,W
09186:  MOVWF  FEA
09188:  CLRF   FEC
0918A:  MOVF   FED,F
0918C:  CLRF   FEF
....................          e_port[motor] = 1; 
0918E:  BCF    FD8.0
09190:  RLCF   x3C,W
09192:  CLRF   03
09194:  ADDLW  BF
09196:  MOVWF  FE9
09198:  MOVLW  07
0919A:  ADDWFC 03,W
0919C:  MOVWF  FEA
0919E:  CLRF   FEC
091A0:  MOVF   FED,F
091A2:  MOVLW  01
091A4:  MOVWF  FEF
091A6:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
091A8:  BCF    FD8.0
091AA:  MOVLB  7
091AC:  RLCF   x3C,W
091AE:  CLRF   03
091B0:  ADDLW  62
091B2:  MOVWF  FE9
091B4:  MOVLW  07
091B6:  ADDWFC 03,W
091B8:  MOVWF  FEA
091BA:  MOVFF  FEC,8CA
091BE:  MOVF   FED,F
091C0:  MOVFF  FEF,8C9
091C4:  MOVLB  8
091C6:  MOVF   xC9,W
091C8:  SUBLW  02
091CA:  BNZ   9216
091CC:  MOVF   xCA,F
091CE:  BNZ   9216
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
091D0:  BCF    FD8.0
091D2:  MOVLB  7
091D4:  RLCF   x3C,W
091D6:  CLRF   03
091D8:  ADDLW  BF
091DA:  MOVWF  01
091DC:  MOVLW  07
091DE:  ADDWFC 03,F
091E0:  MOVLB  8
091E2:  MOVFF  03,8CA
091E6:  BCF    FD8.0
091E8:  MOVLB  7
091EA:  RLCF   x3C,W
091EC:  CLRF   03
091EE:  ADDLW  C3
091F0:  MOVWF  FE9
091F2:  MOVLW  07
091F4:  ADDWFC 03,W
091F6:  MOVWF  FEA
091F8:  MOVFF  FEC,03
091FC:  MOVF   FED,F
091FE:  MOVFF  FEF,8CB
09202:  MOVLB  8
09204:  MOVFF  8CA,FEA
09208:  MOVFF  01,FE9
0920C:  MOVFF  03,FEC
09210:  MOVF   FED,F
09212:  MOVFF  8CB,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
09216:  BCF    FD8.0
09218:  MOVLB  7
0921A:  RLCF   x3C,W
0921C:  CLRF   03
0921E:  ADDLW  62
09220:  MOVWF  FE9
09222:  MOVLW  07
09224:  ADDWFC 03,W
09226:  MOVWF  FEA
09228:  MOVFF  FEC,8CA
0922C:  MOVF   FED,F
0922E:  MOVFF  FEF,8C9
09232:  MOVLB  8
09234:  MOVF   xC9,W
09236:  SUBLW  02
09238:  BNZ   923E
0923A:  MOVF   xCA,F
0923C:  BZ    9266
0923E:  BCF    FD8.0
09240:  MOVLB  7
09242:  RLCF   x3C,W
09244:  CLRF   03
09246:  ADDLW  62
09248:  MOVWF  FE9
0924A:  MOVLW  07
0924C:  ADDWFC 03,W
0924E:  MOVWF  FEA
09250:  MOVFF  FEC,8CA
09254:  MOVF   FED,F
09256:  MOVFF  FEF,8C9
0925A:  MOVLB  8
0925C:  MOVF   xC9,W
0925E:  SUBLW  03
09260:  BNZ   92CA
09262:  MOVF   xCA,F
09264:  BNZ   92CA
....................       { 
....................          switch(motor) 
09266:  MOVLB  7
09268:  MOVF   x3C,W
0926A:  XORLW  00
0926C:  MOVLB  0
0926E:  BZ    9276
09270:  XORLW  01
09272:  BZ    92A0
09274:  BRA    92C8
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09276:  MOVLW  7E
09278:  MOVLB  8
0927A:  MOVWF  xCB
0927C:  MOVFF  7BC,8CD
09280:  MOVFF  7BB,8CC
09284:  MOVLB  0
09286:  CALL   4F4C
....................                      write16(ADDR_E1_PORT,e_port[0]); 
0928A:  MOVLW  AA
0928C:  MOVLB  8
0928E:  MOVWF  xCB
09290:  MOVFF  7C0,8CD
09294:  MOVFF  7BF,8CC
09298:  MOVLB  0
0929A:  CALL   4F4C
....................                break; 
0929E:  BRA    92C8
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
092A0:  MOVLW  80
092A2:  MOVLB  8
092A4:  MOVWF  xCB
092A6:  MOVFF  7BE,8CD
092AA:  MOVFF  7BD,8CC
092AE:  MOVLB  0
092B0:  CALL   4F4C
....................                      write16(ADDR_E2_PORT,e_port[1]); 
092B4:  MOVLW  AC
092B6:  MOVLB  8
092B8:  MOVWF  xCB
092BA:  MOVFF  7C2,8CD
092BE:  MOVFF  7C1,8CC
092C2:  MOVLB  0
092C4:  CALL   4F4C
....................                break;             
092C8:  MOVLB  8
....................          } 
....................       } 
....................    } 
092CA:  BRA    9374
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
092CC:  BCF    FD8.0
092CE:  MOVLB  7
092D0:  RLCF   x3C,W
092D2:  CLRF   03
092D4:  ADDLW  92
092D6:  MOVWF  FE9
092D8:  MOVLW  07
092DA:  ADDWFC 03,W
092DC:  MOVWF  FEA
092DE:  CLRF   FEC
092E0:  MOVF   FED,F
092E2:  MOVLW  01
092E4:  MOVWF  FEF
....................       e_pos[motor] = 0; 
092E6:  BCF    FD8.0
092E8:  RLCF   x3C,W
092EA:  CLRF   03
092EC:  ADDLW  BB
092EE:  MOVWF  FE9
092F0:  MOVLW  07
092F2:  ADDWFC 03,W
092F4:  MOVWF  FEA
092F6:  CLRF   FEC
092F8:  MOVF   FED,F
092FA:  CLRF   FEF
....................       e_port[motor] = 0; 
092FC:  BCF    FD8.0
092FE:  RLCF   x3C,W
09300:  CLRF   03
09302:  ADDLW  BF
09304:  MOVWF  FE9
09306:  MOVLW  07
09308:  ADDWFC 03,W
0930A:  MOVWF  FEA
0930C:  CLRF   FEC
0930E:  MOVF   FED,F
09310:  CLRF   FEF
....................       switch(motor) 
09312:  MOVF   x3C,W
09314:  XORLW  00
09316:  MOVLB  0
09318:  BZ    9320
0931A:  XORLW  01
0931C:  BZ    934A
0931E:  BRA    9372
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09320:  MOVLW  7E
09322:  MOVLB  8
09324:  MOVWF  xCB
09326:  MOVFF  7BC,8CD
0932A:  MOVFF  7BB,8CC
0932E:  MOVLB  0
09330:  CALL   4F4C
....................                   write16(ADDR_E1_PORT,e_port[0]); 
09334:  MOVLW  AA
09336:  MOVLB  8
09338:  MOVWF  xCB
0933A:  MOVFF  7C0,8CD
0933E:  MOVFF  7BF,8CC
09342:  MOVLB  0
09344:  CALL   4F4C
....................             break; 
09348:  BRA    9372
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
0934A:  MOVLW  80
0934C:  MOVLB  8
0934E:  MOVWF  xCB
09350:  MOVFF  7BE,8CD
09354:  MOVFF  7BD,8CC
09358:  MOVLB  0
0935A:  CALL   4F4C
....................                   write16(ADDR_E2_PORT,e_port[1]); 
0935E:  MOVLW  AC
09360:  MOVLB  8
09362:  MOVWF  xCB
09364:  MOVFF  7C2,8CD
09368:  MOVFF  7C1,8CC
0936C:  MOVLB  0
0936E:  CALL   4F4C
....................             break;             
09372:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
09374:  BCF    FD8.0
09376:  MOVLB  7
09378:  RLCF   x3C,W
0937A:  CLRF   03
0937C:  ADDLW  AB
0937E:  MOVWF  FE9
09380:  MOVLW  07
09382:  ADDWFC 03,W
09384:  MOVWF  FEA
09386:  CLRF   FEC
09388:  MOVF   FED,F
0938A:  MOVLW  01
0938C:  MOVWF  FEF
....................     
....................    switch (motor) 
0938E:  MOVF   x3C,W
09390:  XORLW  00
09392:  MOVLB  0
09394:  BZ    939C
09396:  XORLW  01
09398:  BZ    93C4
0939A:  BRA    93EA
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
0939C:  MOVLW  B2
0939E:  MOVLB  8
093A0:  MOVWF  xCB
093A2:  CLRF   xCD
093A4:  MOVLW  01
093A6:  MOVWF  xCC
093A8:  MOVLB  0
093AA:  CALL   4F4C
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
093AE:  MOVLW  B6
093B0:  MOVLB  8
093B2:  MOVWF  xCB
093B4:  MOVFF  7B0,8CD
093B8:  MOVFF  7AF,8CC
093BC:  MOVLB  0
093BE:  CALL   4F4C
....................          break; 
093C2:  BRA    93EA
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
093C4:  MOVLW  B4
093C6:  MOVLB  8
093C8:  MOVWF  xCB
093CA:  CLRF   xCD
093CC:  MOVLW  01
093CE:  MOVWF  xCC
093D0:  MOVLB  0
093D2:  CALL   4F4C
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
093D6:  MOVLW  B8
093D8:  MOVLB  8
093DA:  MOVWF  xCB
093DC:  MOVFF  7B2,8CD
093E0:  MOVFF  7B1,8CC
093E4:  MOVLB  0
093E6:  CALL   4F4C
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
093EA:  MOVF   1F,W
093EC:  SUBLW  04
093EE:  BNZ   9494
093F0:  MOVF   20,F
093F2:  BNZ   9494
....................    { 
....................       if(motor==1) 
093F4:  MOVLB  7
093F6:  DECFSZ x3C,W
093F8:  BRA    9496
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
093FA:  BCF    FD8.0
093FC:  RLCF   x3C,W
093FE:  CLRF   03
09400:  ADDLW  AB
09402:  MOVWF  FE9
09404:  MOVLW  07
09406:  ADDWFC 03,W
09408:  MOVWF  FEA
0940A:  MOVFF  FEC,8CA
0940E:  MOVF   FED,F
09410:  MOVFF  FEF,8C9
09414:  BCF    FD8.0
09416:  RLCF   x3C,W
09418:  CLRF   03
0941A:  ADDLW  AF
0941C:  MOVWF  FE9
0941E:  MOVLW  07
09420:  ADDWFC 03,W
09422:  MOVWF  FEA
09424:  MOVFF  FEC,8CC
09428:  MOVF   FED,F
0942A:  MOVFF  FEF,8CB
0942E:  MOVLW  40
09430:  MOVWF  FF6
09432:  MOVLW  1A
09434:  MOVWF  FF7
09436:  MOVLW  00
09438:  MOVWF  FF8
0943A:  CLRF   1B
0943C:  BTFSC  FF2.7
0943E:  BSF    1B.7
09440:  BCF    FF2.7
09442:  MOVLW  05
09444:  MOVLB  A
09446:  MOVWF  x18
09448:  MOVLB  0
0944A:  CALL   1006
0944E:  BTFSC  1B.7
09450:  BSF    FF2.7
09452:  MOVLW  10
09454:  MOVWF  FE9
09456:  CLRF   1B
09458:  BTFSC  FF2.7
0945A:  BSF    1B.7
0945C:  BCF    FF2.7
0945E:  MOVFF  8CA,A19
09462:  MOVFF  8C9,A18
09466:  CALL   1188
0946A:  BTFSC  1B.7
0946C:  BSF    FF2.7
0946E:  MOVLW  2C
09470:  BTFSS  F9E.4
09472:  BRA    9470
09474:  MOVWF  FAD
09476:  MOVLW  10
09478:  MOVWF  FE9
0947A:  MOVFF  8CC,8CE
0947E:  MOVFF  8CB,8CD
09482:  RCALL  8F1A
09484:  MOVLW  0D
09486:  BTFSS  F9E.4
09488:  BRA    9486
0948A:  MOVWF  FAD
0948C:  MOVLW  0A
0948E:  BTFSS  F9E.4
09490:  BRA    948E
09492:  MOVWF  FAD
09494:  MOVLB  7
....................       } 
....................    } 
09496:  MOVLB  0
09498:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
095C6:  BCF    FD8.0
095C8:  MOVLB  7
095CA:  RLCF   x3C,W
095CC:  CLRF   03
095CE:  ADDLW  66
095D0:  MOVWF  FE9
095D2:  MOVLW  07
095D4:  ADDWFC 03,W
095D6:  MOVWF  FEA
095D8:  MOVFF  FEC,8C9
095DC:  MOVF   FED,F
095DE:  MOVFF  FEF,8C8
095E2:  MOVLB  8
095E4:  DECFSZ xC8,W
095E6:  BRA    95F6
095E8:  MOVF   xC9,F
095EA:  BNZ   95F6
095EC:  MOVLW  01
095EE:  MOVWF  xC8
095F0:  MOVLB  0
095F2:  RCALL  9006
095F4:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
095F6:  BCF    FD8.0
095F8:  MOVLB  7
095FA:  RLCF   x3C,W
095FC:  CLRF   03
095FE:  ADDLW  66
09600:  MOVWF  FE9
09602:  MOVLW  07
09604:  ADDWFC 03,W
09606:  MOVWF  FEA
09608:  MOVFF  FEC,8C9
0960C:  MOVF   FED,F
0960E:  MOVFF  FEF,8C8
09612:  MOVLB  8
09614:  MOVF   xC8,W
09616:  SUBLW  02
09618:  BTFSS  FD8.2
0961A:  BRA    9C24
0961C:  MOVF   xC9,F
0961E:  BTFSS  FD8.2
09620:  BRA    9C24
....................       if (e_mode[motor]==2){ 
09622:  BCF    FD8.0
09624:  MOVLB  7
09626:  RLCF   x3C,W
09628:  CLRF   03
0962A:  ADDLW  62
0962C:  MOVWF  FE9
0962E:  MOVLW  07
09630:  ADDWFC 03,W
09632:  MOVWF  FEA
09634:  MOVFF  FEC,8C9
09638:  MOVF   FED,F
0963A:  MOVFF  FEF,8C8
0963E:  MOVLB  8
09640:  MOVF   xC8,W
09642:  SUBLW  02
09644:  BTFSS  FD8.2
09646:  BRA    9BA0
09648:  MOVF   xC9,F
0964A:  BTFSS  FD8.2
0964C:  BRA    9BA0
....................          if(nv_product==ECO || nv_product==WMS2){ 
0964E:  MOVF   2F,F
09650:  BNZ   9656
09652:  MOVF   30,F
09654:  BZ    9664
09656:  MOVF   2F,W
09658:  SUBLW  03
0965A:  BTFSS  FD8.2
0965C:  BRA    97A8
0965E:  MOVF   30,F
09660:  BTFSS  FD8.2
09662:  BRA    97A8
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
09664:  BCF    FD8.0
09666:  MOVLB  7
09668:  RLCF   x3C,W
0966A:  CLRF   03
0966C:  ADDLW  A7
0966E:  MOVWF  FE9
09670:  MOVLW  07
09672:  ADDWFC 03,W
09674:  MOVWF  FEA
09676:  MOVFF  FEC,9D4
0967A:  MOVF   FED,F
0967C:  MOVFF  FEF,9D3
09680:  MOVFF  FEA,8CB
09684:  MOVFF  FE9,8CA
09688:  MOVLB  9
0968A:  CLRF   xD6
0968C:  CLRF   xD5
0968E:  MOVFF  8B9,9DA
09692:  MOVFF  8B8,9D9
09696:  MOVFF  8B7,9D8
0969A:  MOVFF  8B6,9D7
0969E:  MOVLB  0
096A0:  CALL   4772
096A4:  MOVFF  8CB,FEA
096A8:  MOVFF  8CA,FE9
096AC:  MOVFF  03,8CB
096B0:  MOVFF  02,8CA
096B4:  MOVFF  01,8C9
096B8:  MOVFF  00,8C8
096BC:  BCF    FD8.0
096BE:  MOVLB  7
096C0:  RLCF   x3C,W
096C2:  CLRF   03
096C4:  ADDLW  A7
096C6:  MOVWF  FE9
096C8:  MOVLW  07
096CA:  ADDWFC 03,W
096CC:  MOVWF  FEA
096CE:  MOVFF  FEC,8CD
096D2:  MOVF   FED,F
096D4:  MOVFF  FEF,8CC
096D8:  BCF    FD8.0
096DA:  MOVLB  8
096DC:  RRCF   xCD,W
096DE:  MOVWF  03
096E0:  RRCF   xCC,W
096E2:  MOVWF  02
096E4:  ADDWF  00,W
096E6:  MOVWF  00
096E8:  MOVF   03,W
096EA:  ADDWFC 01,W
096EC:  MOVWF  01
096EE:  MOVLW  00
096F0:  ADDWFC xCA,W
096F2:  MOVWF  02
096F4:  MOVLW  00
096F6:  ADDWFC xCB,W
096F8:  MOVWF  xC3
096FA:  MOVFF  02,8C2
096FE:  MOVFF  01,8C1
09702:  MOVFF  00,8C0
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
09706:  BCF    FD8.0
09708:  MOVLB  7
0970A:  RLCF   x3C,W
0970C:  CLRF   03
0970E:  ADDLW  A7
09710:  MOVWF  FE9
09712:  MOVLW  07
09714:  ADDWFC 03,W
09716:  MOVWF  FEA
09718:  MOVFF  FEC,9D4
0971C:  MOVF   FED,F
0971E:  MOVFF  FEF,9D3
09722:  MOVFF  FEA,8CB
09726:  MOVFF  FE9,8CA
0972A:  MOVLB  9
0972C:  CLRF   xD6
0972E:  CLRF   xD5
09730:  MOVFF  8B9,9DA
09734:  MOVFF  8B8,9D9
09738:  MOVFF  8B7,9D8
0973C:  MOVFF  8B6,9D7
09740:  MOVLB  0
09742:  CALL   4772
09746:  MOVFF  8CB,FEA
0974A:  MOVFF  8CA,FE9
0974E:  MOVFF  03,8CB
09752:  MOVFF  02,8CA
09756:  MOVFF  01,8C9
0975A:  MOVFF  00,8C8
0975E:  BCF    FD8.0
09760:  MOVLB  7
09762:  RLCF   x3C,W
09764:  CLRF   03
09766:  ADDLW  A7
09768:  MOVWF  FE9
0976A:  MOVLW  07
0976C:  ADDWFC 03,W
0976E:  MOVWF  FEA
09770:  MOVFF  FEC,8CD
09774:  MOVF   FED,F
09776:  MOVFF  FEF,8CC
0977A:  BCF    FD8.0
0977C:  MOVLB  8
0977E:  RRCF   xCD,W
09780:  MOVWF  03
09782:  RRCF   xCC,W
09784:  MOVWF  02
09786:  SUBWF  00,W
09788:  MOVWF  00
0978A:  MOVF   03,W
0978C:  SUBWFB 01,W
0978E:  MOVWF  01
09790:  MOVLW  00
09792:  SUBWFB xCA,W
09794:  MOVWF  02
09796:  MOVLW  00
09798:  SUBWFB xCB,W
0979A:  MOVWF  xC7
0979C:  MOVFF  02,8C6
097A0:  MOVFF  01,8C5
097A4:  MOVFF  00,8C4
....................          } 
....................          if (nv_product==WMS4){ 
097A8:  DECFSZ 2F,W
097AA:  BRA    99C2
097AC:  MOVF   30,F
097AE:  BTFSS  FD8.2
097B0:  BRA    99C2
....................             if (end_even_port==FALSE){ 
097B2:  MOVLB  2
097B4:  MOVF   xD7,F
097B6:  BNZ   98AC
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
097B8:  BCF    FD8.0
097BA:  MOVLB  7
097BC:  RLCF   x3C,W
097BE:  CLRF   03
097C0:  ADDLW  A7
097C2:  MOVWF  FE9
097C4:  MOVLW  07
097C6:  ADDWFC 03,W
097C8:  MOVWF  FEA
097CA:  MOVFF  FEC,9EA
097CE:  MOVF   FED,F
097D0:  MOVFF  FEF,9E9
097D4:  MOVFF  8BB,9EC
097D8:  MOVFF  8BA,9EB
097DC:  MOVLB  0
097DE:  CALL   5C0E
097E2:  MOVFF  02,8C9
097E6:  MOVFF  01,8C8
097EA:  BCF    FD8.0
097EC:  MOVLB  7
097EE:  RLCF   x3C,W
097F0:  CLRF   03
097F2:  ADDLW  A7
097F4:  MOVWF  FE9
097F6:  MOVLW  07
097F8:  ADDWFC 03,W
097FA:  MOVWF  FEA
097FC:  MOVFF  FEC,8CB
09800:  MOVF   FED,F
09802:  MOVFF  FEF,8CA
09806:  BCF    FD8.0
09808:  MOVLB  8
0980A:  RRCF   xCB,W
0980C:  MOVWF  03
0980E:  RRCF   xCA,W
09810:  MOVWF  02
09812:  ADDWF  01,W
09814:  MOVWF  01
09816:  MOVF   xC9,W
09818:  ADDWFC 03,F
0981A:  MOVFF  01,8C0
0981E:  MOVFF  03,8C1
09822:  CLRF   02
09824:  CLRF   03
09826:  MOVFF  03,8C3
0982A:  MOVFF  02,8C2
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
0982E:  BCF    FD8.0
09830:  MOVLB  7
09832:  RLCF   x3C,W
09834:  CLRF   03
09836:  ADDLW  A7
09838:  MOVWF  FE9
0983A:  MOVLW  07
0983C:  ADDWFC 03,W
0983E:  MOVWF  FEA
09840:  MOVFF  FEC,9EA
09844:  MOVF   FED,F
09846:  MOVFF  FEF,9E9
0984A:  MOVFF  8BB,9EC
0984E:  MOVFF  8BA,9EB
09852:  MOVLB  0
09854:  CALL   5C0E
09858:  MOVFF  02,8C9
0985C:  MOVFF  01,8C8
09860:  BCF    FD8.0
09862:  MOVLB  7
09864:  RLCF   x3C,W
09866:  CLRF   03
09868:  ADDLW  A7
0986A:  MOVWF  FE9
0986C:  MOVLW  07
0986E:  ADDWFC 03,W
09870:  MOVWF  FEA
09872:  MOVFF  FEC,8CB
09876:  MOVF   FED,F
09878:  MOVFF  FEF,8CA
0987C:  BCF    FD8.0
0987E:  MOVLB  8
09880:  RRCF   xCB,W
09882:  MOVWF  03
09884:  RRCF   xCA,W
09886:  MOVWF  02
09888:  SUBWF  01,W
0988A:  MOVWF  00
0988C:  MOVF   03,W
0988E:  SUBWFB xC9,W
09890:  MOVWF  03
09892:  MOVF   00,W
09894:  MOVFF  03,8C5
09898:  CLRF   02
0989A:  CLRF   03
0989C:  MOVFF  03,8C7
098A0:  MOVFF  02,8C6
098A4:  MOVFF  00,8C4
....................             } 
098A8:  BRA    99C2
098AA:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
098AC:  DECFSZ xD7,W
098AE:  BRA    99C4
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
098B0:  BCF    FD8.0
098B2:  MOVLB  7
098B4:  RLCF   x3C,W
098B6:  CLRF   03
098B8:  ADDLW  A7
098BA:  MOVWF  FE9
098BC:  MOVLW  07
098BE:  ADDWFC 03,W
098C0:  MOVWF  FEA
098C2:  MOVFF  FEC,9EA
098C6:  MOVF   FED,F
098C8:  MOVFF  FEF,9E9
098CC:  MOVLW  01
098CE:  MOVLB  8
098D0:  SUBWF  xBA,W
098D2:  MOVWF  00
098D4:  MOVLW  00
098D6:  SUBWFB xBB,W
098D8:  MOVWF  03
098DA:  MOVFF  00,8CA
098DE:  MOVWF  xCB
098E0:  MOVFF  FE8,9EC
098E4:  MOVFF  00,9EB
098E8:  MOVLB  0
098EA:  CALL   5C0E
098EE:  MOVFF  02,8C9
098F2:  MOVFF  01,8C8
098F6:  BCF    FD8.0
098F8:  MOVLB  7
098FA:  RLCF   x3C,W
098FC:  CLRF   03
098FE:  ADDLW  A7
09900:  MOVWF  FE9
09902:  MOVLW  07
09904:  ADDWFC 03,W
09906:  MOVWF  FEA
09908:  MOVFF  FEC,8CB
0990C:  MOVF   FED,F
0990E:  MOVFF  FEF,8CA
09912:  BCF    FD8.0
09914:  MOVLB  8
09916:  RRCF   xCB,W
09918:  MOVWF  03
0991A:  RRCF   xCA,W
0991C:  MOVWF  02
0991E:  ADDWF  01,W
09920:  MOVWF  01
09922:  MOVF   xC9,W
09924:  ADDWFC 03,F
09926:  MOVFF  01,8C0
0992A:  MOVFF  03,8C1
0992E:  CLRF   02
09930:  CLRF   03
09932:  MOVFF  03,8C3
09936:  MOVFF  02,8C2
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
0993A:  BCF    FD8.0
0993C:  MOVLB  7
0993E:  RLCF   x3C,W
09940:  CLRF   03
09942:  ADDLW  A7
09944:  MOVWF  FE9
09946:  MOVLW  07
09948:  ADDWFC 03,W
0994A:  MOVWF  FEA
0994C:  MOVFF  FEC,9EA
09950:  MOVF   FED,F
09952:  MOVFF  FEF,9E9
09956:  MOVLW  01
09958:  MOVLB  8
0995A:  SUBWF  xBA,W
0995C:  MOVWF  00
0995E:  MOVLW  00
09960:  SUBWFB xBB,W
09962:  MOVWF  03
09964:  MOVFF  00,8CA
09968:  MOVWF  xCB
0996A:  MOVFF  FE8,9EC
0996E:  MOVFF  00,9EB
09972:  MOVLB  0
09974:  CALL   5C0E
09978:  MOVFF  02,03
0997C:  MOVFF  01,8C4
09980:  MOVFF  02,8C5
09984:  CLRF   02
09986:  CLRF   03
09988:  MOVFF  03,8C7
0998C:  MOVFF  02,8C6
....................                m_pll = m_pll -(m_ppp[motor]/2); 
09990:  BCF    FD8.0
09992:  MOVLB  7
09994:  RLCF   x3C,W
09996:  CLRF   03
09998:  ADDLW  A7
0999A:  MOVWF  FE9
0999C:  MOVLW  07
0999E:  ADDWFC 03,W
099A0:  MOVWF  FEA
099A2:  MOVFF  FEC,8C9
099A6:  MOVF   FED,F
099A8:  MOVFF  FEF,8C8
099AC:  BCF    FD8.0
099AE:  MOVLB  8
099B0:  RRCF   xC9,W
099B2:  MOVWF  03
099B4:  RRCF   xC8,W
099B6:  SUBWF  xC4,F
099B8:  MOVF   03,W
099BA:  SUBWFB xC5,F
099BC:  MOVLW  00
099BE:  SUBWFB xC6,F
099C0:  SUBWFB xC7,F
099C2:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
099C4:  MOVLB  7
099C6:  MOVF   x3C,W
099C8:  MULLW  04
099CA:  MOVF   FF3,W
099CC:  CLRF   03
099CE:  ADDLW  9E
099D0:  MOVWF  FE9
099D2:  MOVLW  07
099D4:  ADDWFC 03,W
099D6:  MOVWF  FEA
099D8:  MOVFF  FEF,8C8
099DC:  MOVFF  FEC,8C9
099E0:  MOVFF  FEC,8CA
099E4:  MOVFF  FEC,8CB
099E8:  MOVLB  8
099EA:  BTFSC  xC3.7
099EC:  BRA    9A5C
099EE:  MOVF   xC3,W
099F0:  SUBWF  xCB,W
099F2:  BNC   9A0C
099F4:  BNZ   9A5C
099F6:  MOVF   xC2,W
099F8:  SUBWF  xCA,W
099FA:  BNC   9A0C
099FC:  BNZ   9A5C
099FE:  MOVF   xC1,W
09A00:  SUBWF  xC9,W
09A02:  BNC   9A0C
09A04:  BNZ   9A5C
09A06:  MOVF   xC8,W
09A08:  SUBWF  xC0,W
09A0A:  BNC   9A5C
09A0C:  MOVLB  7
09A0E:  MOVF   x3C,W
09A10:  MULLW  04
09A12:  MOVF   FF3,W
09A14:  CLRF   03
09A16:  ADDLW  9E
09A18:  MOVWF  FE9
09A1A:  MOVLW  07
09A1C:  ADDWFC 03,W
09A1E:  MOVWF  FEA
09A20:  MOVFF  FEF,8C8
09A24:  MOVFF  FEC,8C9
09A28:  MOVFF  FEC,8CA
09A2C:  MOVFF  FEC,8CB
09A30:  MOVLB  8
09A32:  BTFSC  xC7.7
09A34:  BRA    9BA0
09A36:  MOVF   xCB,W
09A38:  SUBWF  xC7,W
09A3A:  BTFSS  FD8.0
09A3C:  BRA    9BA0
09A3E:  BNZ   9A5C
09A40:  MOVF   xCA,W
09A42:  SUBWF  xC6,W
09A44:  BTFSS  FD8.0
09A46:  BRA    9BA0
09A48:  BNZ   9A5C
09A4A:  MOVF   xC9,W
09A4C:  SUBWF  xC5,W
09A4E:  BTFSS  FD8.0
09A50:  BRA    9BA0
09A52:  BNZ   9A5C
09A54:  MOVF   xC4,W
09A56:  SUBWF  xC8,W
09A58:  BTFSC  FD8.0
09A5A:  BRA    9BA0
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09A5C:  MOVLW  01
09A5E:  MOVLB  7
09A60:  ADDWF  x3C,W
09A62:  MOVLB  8
09A64:  MOVWF  xC8
09A66:  BCF    FD8.0
09A68:  MOVLB  7
09A6A:  RLCF   x3C,W
09A6C:  CLRF   03
09A6E:  ADDLW  A7
09A70:  MOVWF  FE9
09A72:  MOVLW  07
09A74:  ADDWFC 03,W
09A76:  MOVWF  FEA
09A78:  MOVFF  FEC,8CA
09A7C:  MOVF   FED,F
09A7E:  MOVFF  FEF,8C9
09A82:  MOVF   x3C,W
09A84:  MULLW  04
09A86:  MOVF   FF3,W
09A88:  CLRF   03
09A8A:  ADDLW  9E
09A8C:  MOVWF  FE9
09A8E:  MOVLW  07
09A90:  ADDWFC 03,W
09A92:  MOVWF  FEA
09A94:  MOVFF  FEF,8CB
09A98:  MOVFF  FEC,8CC
09A9C:  MOVFF  FEC,8CD
09AA0:  MOVFF  FEC,8CE
09AA4:  MOVLW  50
09AA6:  MOVWF  FF6
09AA8:  MOVLW  1A
09AAA:  MOVWF  FF7
09AAC:  MOVLW  00
09AAE:  MOVWF  FF8
09AB0:  CLRF   1B
09AB2:  BTFSC  FF2.7
09AB4:  BSF    1B.7
09AB6:  BCF    FF2.7
09AB8:  MOVLW  05
09ABA:  MOVLB  A
09ABC:  MOVWF  x18
09ABE:  MOVLB  0
09AC0:  CALL   1006
09AC4:  BTFSC  1B.7
09AC6:  BSF    FF2.7
09AC8:  CLRF   1B
09ACA:  BTFSC  FF2.7
09ACC:  BSF    1B.7
09ACE:  BCF    FF2.7
09AD0:  MOVFF  8C8,A18
09AD4:  MOVLW  1B
09AD6:  MOVLB  A
09AD8:  MOVWF  x19
09ADA:  MOVLB  0
09ADC:  CALL   0F88
09AE0:  BTFSC  1B.7
09AE2:  BSF    FF2.7
09AE4:  MOVLW  2C
09AE6:  BTFSS  F9E.4
09AE8:  BRA    9AE6
09AEA:  MOVWF  FAD
09AEC:  MOVLW  41
09AEE:  MOVWF  FE9
09AF0:  MOVFF  8B9,8D2
09AF4:  MOVFF  8B8,8D1
09AF8:  MOVFF  8B7,8D0
09AFC:  MOVFF  8B6,8CF
09B00:  RCALL  949A
09B02:  MOVLW  2C
09B04:  BTFSS  F9E.4
09B06:  BRA    9B04
09B08:  MOVWF  FAD
09B0A:  MOVLW  10
09B0C:  MOVWF  FE9
09B0E:  CLRF   1B
09B10:  BTFSC  FF2.7
09B12:  BSF    1B.7
09B14:  BCF    FF2.7
09B16:  MOVFF  8CA,A19
09B1A:  MOVFF  8C9,A18
09B1E:  CALL   1188
09B22:  BTFSC  1B.7
09B24:  BSF    FF2.7
09B26:  MOVLW  2C
09B28:  BTFSS  F9E.4
09B2A:  BRA    9B28
09B2C:  MOVWF  FAD
09B2E:  MOVLW  41
09B30:  MOVWF  FE9
09B32:  CLRF   1B
09B34:  BTFSC  FF2.7
09B36:  BSF    1B.7
09B38:  BCF    FF2.7
09B3A:  MOVFF  8CE,A1B
09B3E:  MOVFF  8CD,A1A
09B42:  MOVFF  8CC,A19
09B46:  MOVFF  8CB,A18
09B4A:  CALL   10CC
09B4E:  BTFSC  1B.7
09B50:  BSF    FF2.7
09B52:  MOVLW  2C
09B54:  BTFSS  F9E.4
09B56:  BRA    9B54
09B58:  MOVWF  FAD
09B5A:  MOVLW  41
09B5C:  MOVWF  FE9
09B5E:  MOVFF  8C3,8D2
09B62:  MOVFF  8C2,8D1
09B66:  MOVFF  8C1,8D0
09B6A:  MOVFF  8C0,8CF
09B6E:  RCALL  949A
09B70:  MOVLW  2C
09B72:  BTFSS  F9E.4
09B74:  BRA    9B72
09B76:  MOVWF  FAD
09B78:  MOVLW  41
09B7A:  MOVWF  FE9
09B7C:  MOVFF  8C7,8D2
09B80:  MOVFF  8C6,8D1
09B84:  MOVFF  8C5,8D0
09B88:  MOVFF  8C4,8CF
09B8C:  RCALL  949A
09B8E:  MOVLW  0D
09B90:  BTFSS  F9E.4
09B92:  BRA    9B90
09B94:  MOVWF  FAD
09B96:  MOVLW  0A
09B98:  BTFSS  F9E.4
09B9A:  BRA    9B98
09B9C:  MOVWF  FAD
09B9E:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09BA0:  BCF    FD8.0
09BA2:  MOVLB  7
09BA4:  RLCF   x3C,W
09BA6:  CLRF   03
09BA8:  ADDLW  9A
09BAA:  MOVWF  01
09BAC:  MOVLW  07
09BAE:  ADDWFC 03,F
09BB0:  MOVLB  8
09BB2:  MOVFF  03,8C9
09BB6:  BCF    FD8.0
09BB8:  MOVLB  7
09BBA:  RLCF   x3C,W
09BBC:  CLRF   03
09BBE:  ADDLW  62
09BC0:  MOVWF  FE9
09BC2:  MOVLW  07
09BC4:  ADDWFC 03,W
09BC6:  MOVWF  FEA
09BC8:  MOVFF  FEC,03
09BCC:  MOVF   FED,F
09BCE:  MOVFF  FEF,8CA
09BD2:  MOVLB  8
09BD4:  MOVFF  8C9,FEA
09BD8:  MOVFF  01,FE9
09BDC:  MOVFF  03,FEC
09BE0:  MOVF   FED,F
09BE2:  MOVFF  8CA,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09BE6:  BCF    FD8.0
09BE8:  MOVLB  7
09BEA:  RLCF   x3C,W
09BEC:  CLRF   03
09BEE:  ADDLW  62
09BF0:  MOVWF  FE9
09BF2:  MOVLW  07
09BF4:  ADDWFC 03,W
09BF6:  MOVWF  FEA
09BF8:  CLRF   FEC
09BFA:  MOVF   FED,F
09BFC:  MOVLW  04
09BFE:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09C00:  MOVF   x3C,W
09C02:  MULLW  04
09C04:  MOVF   FF3,W
09C06:  CLRF   03
09C08:  ADDLW  9E
09C0A:  MOVWF  FE9
09C0C:  MOVLW  07
09C0E:  ADDWFC 03,W
09C10:  MOVWF  FEA
09C12:  MOVFF  FEF,8BC
09C16:  MOVFF  FEC,8BD
09C1A:  MOVFF  FEC,8BE
09C1E:  MOVFF  FEC,8BF
09C22:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09C24:  MOVFF  8BC,00
09C28:  MOVFF  8BD,01
09C2C:  MOVFF  8BE,02
09C30:  MOVFF  8BF,03
09C34:  MOVLB  0
09C36:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
08494:  MOVLB  2
08496:  CLRF   xD7
....................    start_even_port = FALSE; 
08498:  CLRF   xD6
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
0849A:  BCF    FD8.0
0849C:  MOVLB  7
0849E:  RLCF   x3C,W
084A0:  CLRF   03
084A2:  ADDLW  C3
084A4:  MOVWF  FE9
084A6:  MOVLW  07
084A8:  ADDWFC 03,W
084AA:  MOVWF  FEA
084AC:  MOVFF  FEC,8B6
084B0:  MOVF   FED,F
084B2:  MOVFF  FEF,8B5
084B6:  MOVLW  01
084B8:  MOVLB  8
084BA:  ANDWF  xB5,F
084BC:  CLRF   xB6
084BE:  MOVF   xB5,F
084C0:  BNZ   84CE
084C2:  MOVF   xB6,F
084C4:  BNZ   84CE
....................    { 
....................       end_even_port = TRUE; 
084C6:  MOVLW  01
084C8:  MOVLB  2
084CA:  MOVWF  xD7
084CC:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
084CE:  BCF    FD8.0
084D0:  MOVLB  7
084D2:  RLCF   x3C,W
084D4:  CLRF   03
084D6:  ADDLW  BF
084D8:  MOVWF  FE9
084DA:  MOVLW  07
084DC:  ADDWFC 03,W
084DE:  MOVWF  FEA
084E0:  MOVFF  FEC,8B6
084E4:  MOVF   FED,F
084E6:  MOVFF  FEF,8B5
084EA:  MOVLW  01
084EC:  MOVLB  8
084EE:  ANDWF  xB5,F
084F0:  CLRF   xB6
084F2:  MOVF   xB5,F
084F4:  BNZ   8502
084F6:  MOVF   xB6,F
084F8:  BNZ   8502
....................    { 
....................       start_even_port = TRUE; 
084FA:  MOVLW  01
084FC:  MOVLB  2
084FE:  MOVWF  xD6
08500:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
08502:  MOVLB  2
08504:  MOVF   xD6,F
08506:  BNZ   851C
....................    { 
....................       evenOdd = 0; 
08508:  MOVLB  8
0850A:  CLRF   xB4
....................       if (TRUE == end_even_port) 
0850C:  MOVLB  2
0850E:  DECFSZ xD7,W
08510:  BRA    851A
....................       { 
....................          evenOdd = 1; 
08512:  MOVLW  01
08514:  MOVLB  8
08516:  MOVWF  xB4
08518:  MOVLB  2
....................       } 
....................    } 
0851A:  BRA    8530
....................    else 
....................    { 
....................       evenOdd = 2; 
0851C:  MOVLW  02
0851E:  MOVLB  8
08520:  MOVWF  xB4
....................       if (TRUE == end_even_port) 
08522:  MOVLB  2
08524:  DECFSZ xD7,W
08526:  BRA    8530
....................       { 
....................          evenOdd = 3; 
08528:  MOVLW  03
0852A:  MOVLB  8
0852C:  MOVWF  xB4
0852E:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
08530:  MOVLB  8
08532:  MOVFF  8B4,01
08536:  MOVLB  0
08538:  GOTO   9F86 (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09CAE:  BCF    FD8.0
09CB0:  MOVLB  7
09CB2:  RLCF   x3C,W
09CB4:  CLRF   03
09CB6:  ADDLW  82
09CB8:  MOVWF  FE9
09CBA:  MOVLW  07
09CBC:  ADDWFC 03,W
09CBE:  MOVWF  FEA
09CC0:  CLRF   FEC
09CC2:  MOVF   FED,F
09CC4:  MOVFF  8A5,FEF
....................    m_step_cnt[motor] = 0; 
09CC8:  MOVF   x3C,W
09CCA:  MULLW  04
09CCC:  MOVF   FF3,W
09CCE:  CLRF   03
09CD0:  ADDLW  9E
09CD2:  MOVWF  FE9
09CD4:  MOVLW  07
09CD6:  ADDWFC 03,W
09CD8:  MOVWF  FEA
09CDA:  MOVF   FEE,F
09CDC:  MOVF   FEE,F
09CDE:  CLRF   FEC
09CE0:  MOVF   FED,F
09CE2:  CLRF   FEF
09CE4:  MOVF   FED,F
09CE6:  CLRF   FEF
09CE8:  MOVF   FED,F
09CEA:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09CEC:  BCF    FD8.0
09CEE:  RLCF   x3C,W
09CF0:  CLRF   03
09CF2:  ADDLW  6A
09CF4:  MOVWF  FE9
09CF6:  MOVLW  07
09CF8:  ADDWFC 03,W
09CFA:  MOVWF  FEA
09CFC:  MOVFF  FEC,8B2
09D00:  MOVF   FED,F
09D02:  MOVFF  FEF,8B1
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09D06:  BCF    FD8.0
09D08:  RLCF   x3C,W
09D0A:  CLRF   03
09D0C:  ADDLW  72
09D0E:  MOVWF  FE9
09D10:  MOVLW  07
09D12:  ADDWFC 03,W
09D14:  MOVWF  FEA
09D16:  MOVFF  FEC,8B9
09D1A:  MOVF   FED,F
09D1C:  MOVFF  FEF,8B8
09D20:  BCF    FD8.0
09D22:  RLCF   x3C,W
09D24:  CLRF   03
09D26:  ADDLW  5A
09D28:  MOVWF  FE9
09D2A:  MOVLW  07
09D2C:  ADDWFC 03,W
09D2E:  MOVWF  FEA
09D30:  MOVFF  FEC,03
09D34:  MOVF   FED,F
09D36:  MOVFF  FEF,8BA
09D3A:  MOVFF  03,8B7
09D3E:  MOVFF  03,8BB
09D42:  MOVLB  0
09D44:  CALL   2C52
09D48:  MOVFF  02,8B0
09D4C:  MOVFF  01,8AF
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09D50:  BCF    FD8.0
09D52:  MOVLB  7
09D54:  RLCF   x3C,W
09D56:  CLRF   03
09D58:  ADDLW  62
09D5A:  MOVWF  FE9
09D5C:  MOVLW  07
09D5E:  ADDWFC 03,W
09D60:  MOVWF  FEA
09D62:  MOVFF  FEC,8B5
09D66:  MOVF   FED,F
09D68:  MOVFF  FEF,8B4
09D6C:  MOVLB  8
09D6E:  MOVF   xB4,W
09D70:  SUBLW  02
09D72:  BNZ   9DA2
09D74:  MOVF   xB5,F
09D76:  BNZ   9DA2
09D78:  BCF    FD8.0
09D7A:  MOVLB  7
09D7C:  RLCF   x3C,W
09D7E:  CLRF   03
09D80:  ADDLW  BF
09D82:  MOVWF  FE9
09D84:  MOVLW  07
09D86:  ADDWFC 03,W
09D88:  MOVWF  FEA
09D8A:  MOVFF  FEC,8B5
09D8E:  MOVF   FED,F
09D90:  MOVFF  FEF,8B4
09D94:  MOVLB  8
09D96:  MOVF   xB4,F
09D98:  BNZ   9DA2
09D9A:  MOVF   xB5,F
09D9C:  BTFSC  FD8.2
09D9E:  GOTO   A640
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09DA2:  BCF    FD8.0
09DA4:  MOVLB  7
09DA6:  RLCF   x3C,W
09DA8:  CLRF   03
09DAA:  ADDLW  62
09DAC:  MOVWF  FE9
09DAE:  MOVLW  07
09DB0:  ADDWFC 03,W
09DB2:  MOVWF  FEA
09DB4:  MOVFF  FEC,8B5
09DB8:  MOVF   FED,F
09DBA:  MOVFF  FEF,8B4
09DBE:  MOVLB  8
09DC0:  MOVF   xB4,W
09DC2:  SUBLW  02
09DC4:  BTFSS  FD8.2
09DC6:  BRA    A120
09DC8:  MOVF   xB5,F
09DCA:  BTFSS  FD8.2
09DCC:  BRA    A120
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09DCE:  BCF    FD8.0
09DD0:  MOVLB  7
09DD2:  RLCF   x3C,W
09DD4:  CLRF   03
09DD6:  ADDLW  C3
09DD8:  MOVWF  FE9
09DDA:  MOVLW  07
09DDC:  ADDWFC 03,W
09DDE:  MOVWF  FEA
09DE0:  MOVFF  8A6,FEF
09DE4:  MOVFF  8A7,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09DE8:  DECFSZ 2F,W
09DEA:  BRA    A09C
09DEC:  MOVF   30,F
09DEE:  BTFSS  FD8.2
09DF0:  BRA    A09C
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09DF2:  BCF    FD8.0
09DF4:  RLCF   x3C,W
09DF6:  CLRF   03
09DF8:  ADDLW  C3
09DFA:  MOVWF  FE9
09DFC:  MOVLW  07
09DFE:  ADDWFC 03,W
09E00:  MOVWF  FEA
09E02:  MOVFF  FEC,8B5
09E06:  MOVF   FED,F
09E08:  MOVFF  FEF,8B4
09E0C:  BCF    FD8.0
09E0E:  RLCF   x3C,W
09E10:  CLRF   03
09E12:  ADDLW  BF
09E14:  MOVWF  FE9
09E16:  MOVLW  07
09E18:  ADDWFC 03,W
09E1A:  MOVWF  FEA
09E1C:  MOVFF  FEC,03
09E20:  MOVF   FED,F
09E22:  MOVFF  FEF,01
09E26:  MOVF   03,W
09E28:  MOVLB  8
09E2A:  SUBWF  xB5,W
09E2C:  BNC   9EC8
09E2E:  BNZ   9E36
09E30:  MOVF   xB4,W
09E32:  SUBWF  01,W
09E34:  BC    9EC8
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09E36:  BCF    FD8.0
09E38:  MOVLB  7
09E3A:  RLCF   x3C,W
09E3C:  CLRF   03
09E3E:  ADDLW  B3
09E40:  MOVWF  01
09E42:  MOVLW  07
09E44:  ADDWFC 03,F
09E46:  MOVLB  8
09E48:  MOVFF  03,8B5
09E4C:  BCF    FD8.0
09E4E:  MOVLB  7
09E50:  RLCF   x3C,W
09E52:  CLRF   03
09E54:  ADDLW  C3
09E56:  MOVWF  FE9
09E58:  MOVLW  07
09E5A:  ADDWFC 03,W
09E5C:  MOVWF  FEA
09E5E:  MOVFF  FEC,8B7
09E62:  MOVF   FED,F
09E64:  MOVFF  FEF,8B6
09E68:  BCF    FD8.0
09E6A:  RLCF   x3C,W
09E6C:  CLRF   03
09E6E:  ADDLW  BF
09E70:  MOVWF  FE9
09E72:  MOVLW  07
09E74:  ADDWFC 03,W
09E76:  MOVWF  FEA
09E78:  MOVFF  FEC,03
09E7C:  MOVF   FED,F
09E7E:  MOVF   FEF,W
09E80:  MOVLB  8
09E82:  SUBWF  xB6,W
09E84:  MOVWF  00
09E86:  MOVF   03,W
09E88:  SUBWFB xB7,W
09E8A:  MOVFF  8B5,FEA
09E8E:  MOVFF  01,FE9
09E92:  MOVWF  FEC
09E94:  MOVF   FED,F
09E96:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09E9A:  BCF    FD8.0
09E9C:  MOVLB  7
09E9E:  RLCF   x3C,W
09EA0:  CLRF   03
09EA2:  ADDLW  B3
09EA4:  MOVWF  FE9
09EA6:  MOVLW  07
09EA8:  ADDWFC 03,W
09EAA:  MOVWF  FEA
09EAC:  MOVFF  FEC,8B5
09EB0:  MOVF   FED,F
09EB2:  MOVFF  FEF,8B4
09EB6:  BCF    FD8.0
09EB8:  MOVLB  8
09EBA:  CLRF   xA9
09EBC:  CLRF   xA8
09EBE:  RRCF   xB5,W
09EC0:  MOVWF  xA7
09EC2:  RRCF   xB4,W
09EC4:  MOVWF  xA6
....................             } 
09EC6:  BRA    9F80
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09EC8:  BCF    FD8.0
09ECA:  MOVLB  7
09ECC:  RLCF   x3C,W
09ECE:  CLRF   03
09ED0:  ADDLW  B3
09ED2:  MOVWF  01
09ED4:  MOVLW  07
09ED6:  ADDWFC 03,F
09ED8:  MOVFF  01,8B4
09EDC:  MOVLB  8
09EDE:  MOVFF  03,8B5
09EE2:  BCF    FD8.0
09EE4:  MOVLB  7
09EE6:  RLCF   x3C,W
09EE8:  CLRF   03
09EEA:  ADDLW  5E
09EEC:  MOVWF  FE9
09EEE:  MOVLW  07
09EF0:  ADDWFC 03,W
09EF2:  MOVWF  FEA
09EF4:  MOVFF  FEC,8B7
09EF8:  MOVF   FED,F
09EFA:  MOVFF  FEF,8B6
09EFE:  BCF    FD8.0
09F00:  RLCF   x3C,W
09F02:  CLRF   03
09F04:  ADDLW  BF
09F06:  MOVWF  FE9
09F08:  MOVLW  07
09F0A:  ADDWFC 03,W
09F0C:  MOVWF  FEA
09F0E:  MOVFF  FEC,03
09F12:  MOVF   FED,F
09F14:  MOVF   FEF,W
09F16:  MOVLB  8
09F18:  SUBWF  xB6,F
09F1A:  MOVF   03,W
09F1C:  SUBWFB xB7,F
09F1E:  BCF    FD8.0
09F20:  MOVLB  7
09F22:  RLCF   x3C,W
09F24:  CLRF   03
09F26:  ADDLW  C3
09F28:  MOVWF  FE9
09F2A:  MOVLW  07
09F2C:  ADDWFC 03,W
09F2E:  MOVWF  FEA
09F30:  MOVFF  FEC,03
09F34:  MOVF   FED,F
09F36:  MOVF   FEF,W
09F38:  MOVLB  8
09F3A:  ADDWF  xB6,W
09F3C:  MOVWF  01
09F3E:  MOVF   xB7,W
09F40:  ADDWFC 03,F
09F42:  MOVFF  8B5,FEA
09F46:  MOVFF  8B4,FE9
09F4A:  MOVFF  03,FEC
09F4E:  MOVF   FED,F
09F50:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F54:  BCF    FD8.0
09F56:  MOVLB  7
09F58:  RLCF   x3C,W
09F5A:  CLRF   03
09F5C:  ADDLW  B3
09F5E:  MOVWF  FE9
09F60:  MOVLW  07
09F62:  ADDWFC 03,W
09F64:  MOVWF  FEA
09F66:  MOVFF  FEC,8B5
09F6A:  MOVF   FED,F
09F6C:  MOVFF  FEF,8B4
09F70:  BCF    FD8.0
09F72:  MOVLB  8
09F74:  CLRF   xA9
09F76:  CLRF   xA8
09F78:  RRCF   xB5,W
09F7A:  MOVWF  xA7
09F7C:  RRCF   xB4,W
09F7E:  MOVWF  xA6
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
09F80:  MOVLB  0
09F82:  GOTO   8494
09F86:  MOVFF  01,8B3
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
09F8A:  BCF    FD8.0
09F8C:  MOVLB  7
09F8E:  RLCF   x3C,W
09F90:  CLRF   03
09F92:  ADDLW  C3
09F94:  MOVWF  FE9
09F96:  MOVLW  07
09F98:  ADDWFC 03,W
09F9A:  MOVWF  FEA
09F9C:  MOVFF  FEC,8B5
09FA0:  MOVF   FED,F
09FA2:  MOVFF  FEF,8B4
09FA6:  MOVLB  8
09FA8:  MOVF   xB4,W
09FAA:  SUBLW  02
09FAC:  BNZ   9FDC
09FAE:  MOVF   xB5,F
09FB0:  BNZ   9FDC
09FB2:  BCF    FD8.0
09FB4:  MOVLB  7
09FB6:  RLCF   x3C,W
09FB8:  CLRF   03
09FBA:  ADDLW  BF
09FBC:  MOVWF  FE9
09FBE:  MOVLW  07
09FC0:  ADDWFC 03,W
09FC2:  MOVWF  FEA
09FC4:  MOVFF  FEC,8B5
09FC8:  MOVF   FED,F
09FCA:  MOVFF  FEF,8B4
09FCE:  MOVLB  8
09FD0:  DECFSZ xB4,W
09FD2:  BRA    9FDC
09FD4:  MOVF   xB5,F
09FD6:  BNZ   9FDC
....................             { 
....................                port_port=4; 
09FD8:  MOVLW  04
09FDA:  MOVWF  xB3
....................             } 
....................              
....................             switch(port_port){ 
09FDC:  MOVF   xB3,W
09FDE:  ADDLW  FB
09FE0:  BC    A098
09FE2:  ADDLW  05
09FE4:  MOVLB  0
09FE6:  GOTO   A68E
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
09FEA:  BCF    FD8.0
09FEC:  MOVLB  7
09FEE:  RLCF   x3C,W
09FF0:  CLRF   03
09FF2:  ADDLW  6A
09FF4:  MOVWF  FE9
09FF6:  MOVLW  07
09FF8:  ADDWFC 03,W
09FFA:  MOVWF  FEA
09FFC:  MOVFF  FEC,8B2
0A000:  MOVF   FED,F
0A002:  MOVFF  FEF,8B1
....................                   break; 
0A006:  MOVLB  8
0A008:  BRA    A098
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A00A:  BCF    FD8.0
0A00C:  MOVLB  7
0A00E:  RLCF   x3C,W
0A010:  CLRF   03
0A012:  ADDLW  7A
0A014:  MOVWF  FE9
0A016:  MOVLW  07
0A018:  ADDWFC 03,W
0A01A:  MOVWF  FEA
0A01C:  MOVFF  FEC,03
0A020:  MOVF   FED,F
0A022:  MOVF   FEF,W
0A024:  MOVLB  8
0A026:  ADDWF  xAF,W
0A028:  MOVWF  xB1
0A02A:  MOVF   03,W
0A02C:  ADDWFC xB0,W
0A02E:  MOVWF  xB2
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A030:  BRA    A098
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A032:  BCF    FD8.0
0A034:  MOVLB  7
0A036:  RLCF   x3C,W
0A038:  CLRF   03
0A03A:  ADDLW  6A
0A03C:  MOVWF  FE9
0A03E:  MOVLW  07
0A040:  ADDWFC 03,W
0A042:  MOVWF  FEA
0A044:  MOVFF  FEC,8B2
0A048:  MOVF   FED,F
0A04A:  MOVFF  FEF,8B1
....................                         ++m_steps; 
0A04E:  MOVLW  01
0A050:  MOVLB  8
0A052:  ADDWF  xA6,F
0A054:  BTFSC  FD8.0
0A056:  INCF   xA7,F
0A058:  BTFSC  FD8.2
0A05A:  INCF   xA8,F
0A05C:  BTFSC  FD8.2
0A05E:  INCF   xA9,F
....................                   break; 
0A060:  BRA    A098
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A062:  BCF    FD8.0
0A064:  MOVLB  7
0A066:  RLCF   x3C,W
0A068:  CLRF   03
0A06A:  ADDLW  7A
0A06C:  MOVWF  FE9
0A06E:  MOVLW  07
0A070:  ADDWFC 03,W
0A072:  MOVWF  FEA
0A074:  MOVFF  FEC,03
0A078:  MOVF   FED,F
0A07A:  MOVF   FEF,W
0A07C:  MOVLB  8
0A07E:  ADDWF  xAF,W
0A080:  MOVWF  xB1
0A082:  MOVF   03,W
0A084:  ADDWFC xB0,W
0A086:  MOVWF  xB2
....................  
....................                   break; 
0A088:  BRA    A098
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A08A:  MOVFF  8B0,8B2
0A08E:  MOVFF  8AF,8B1
....................                   break;     
0A092:  MOVLB  8
0A094:  BRA    A098
0A096:  MOVLB  8
....................             } 
....................          } 
0A098:  BRA    A0C4
0A09A:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A09C:  MOVFF  8A9,8B7
0A0A0:  MOVFF  8A8,8B6
0A0A4:  MOVFF  8A7,8B5
0A0A8:  MOVFF  8A6,8B4
0A0AC:  MOVLB  0
0A0AE:  GOTO   853C
0A0B2:  MOVFF  03,8A9
0A0B6:  MOVFF  02,8A8
0A0BA:  MOVFF  01,8A7
0A0BE:  MOVFF  00,8A6
0A0C2:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A0C4:  DECFSZ xA4,W
0A0C6:  BRA    A0EE
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A0C8:  MOVFF  8A7,8B5
0A0CC:  MOVFF  8A6,8B4
0A0D0:  MOVFF  8A7,8B7
0A0D4:  MOVFF  8A6,8B6
0A0D8:  MOVLB  0
0A0DA:  GOTO   874E
0A0DE:  MOVLB  8
0A0E0:  CLRF   xA9
0A0E2:  CLRF   xA8
0A0E4:  MOVFF  02,8A7
0A0E8:  MOVFF  01,8A6
....................          } 
0A0EC:  BRA    A120
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A0EE:  MOVF   2F,W
0A0F0:  SUBLW  03
0A0F2:  BNZ   A120
0A0F4:  MOVF   30,F
0A0F6:  BNZ   A120
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A0F8:  BCF    FD8.0
0A0FA:  MOVLB  7
0A0FC:  RLCF   x3C,W
0A0FE:  CLRF   03
0A100:  ADDLW  BB
0A102:  MOVWF  FE9
0A104:  MOVLW  07
0A106:  ADDWFC 03,W
0A108:  MOVWF  FEA
0A10A:  MOVFF  FEC,03
0A10E:  MOVF   FED,F
0A110:  MOVF   FEF,W
0A112:  MOVLB  8
0A114:  SUBWF  xA6,F
0A116:  MOVF   03,W
0A118:  SUBWFB xA7,F
0A11A:  MOVLW  00
0A11C:  SUBWFB xA8,F
0A11E:  SUBWFB xA9,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A120:  MOVFF  8AA,8B4
0A124:  MOVLB  0
0A126:  GOTO   8E18
....................  
....................       while (m_running[motor]) 
0A12A:  BCF    FD8.0
0A12C:  MOVLB  7
0A12E:  RLCF   x3C,W
0A130:  CLRF   03
0A132:  ADDLW  8E
0A134:  MOVWF  FE9
0A136:  MOVLW  07
0A138:  ADDWFC 03,W
0A13A:  MOVWF  FEA
0A13C:  MOVF   FEF,F
0A13E:  BNZ   A146
0A140:  MOVF   FEC,F
0A142:  BTFSC  FD8.2
0A144:  BRA    A63C
....................       { 
....................          switch(e_mode[motor]) 
0A146:  BCF    FD8.0
0A148:  RLCF   x3C,W
0A14A:  CLRF   03
0A14C:  ADDLW  62
0A14E:  MOVWF  FE9
0A150:  MOVLW  07
0A152:  ADDWFC 03,W
0A154:  MOVWF  FEA
0A156:  MOVF   FEF,W
0A158:  MOVWF  00
0A15A:  MOVF   FEE,F
0A15C:  MOVF   FED,W
0A15E:  MOVWF  03
0A160:  MOVF   03,W
0A162:  BNZ   A16C
0A164:  MOVF   00,F
0A166:  MOVLB  0
0A168:  BZ    A1BA
0A16A:  MOVLB  7
0A16C:  MOVF   03,W
0A16E:  BNZ   A17A
0A170:  MOVLW  01
0A172:  SUBWF  00,W
0A174:  MOVLB  0
0A176:  BZ    A210
0A178:  MOVLB  7
0A17A:  MOVF   03,W
0A17C:  BNZ   A188
0A17E:  MOVLW  02
0A180:  SUBWF  00,W
0A182:  MOVLB  0
0A184:  BZ    A210
0A186:  MOVLB  7
0A188:  MOVF   03,W
0A18A:  BNZ   A198
0A18C:  MOVLW  03
0A18E:  SUBWF  00,W
0A190:  MOVLB  0
0A192:  BTFSC  FD8.2
0A194:  BRA    A2DE
0A196:  MOVLB  7
0A198:  MOVF   03,W
0A19A:  BNZ   A1A8
0A19C:  MOVLW  04
0A19E:  SUBWF  00,W
0A1A0:  MOVLB  0
0A1A2:  BTFSC  FD8.2
0A1A4:  BRA    A42E
0A1A6:  MOVLB  7
0A1A8:  MOVF   03,W
0A1AA:  BNZ   A1B8
0A1AC:  MOVLW  05
0A1AE:  SUBWF  00,W
0A1B0:  MOVLB  0
0A1B2:  BTFSC  FD8.2
0A1B4:  BRA    A57E
0A1B6:  MOVLB  7
0A1B8:  BRA    A636
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A1BA:  MOVLB  7
0A1BC:  MOVF   x3C,W
0A1BE:  MULLW  04
0A1C0:  MOVF   FF3,W
0A1C2:  CLRF   03
0A1C4:  ADDLW  9E
0A1C6:  MOVWF  FE9
0A1C8:  MOVLW  07
0A1CA:  ADDWFC 03,W
0A1CC:  MOVWF  FEA
0A1CE:  MOVFF  FEF,8B4
0A1D2:  MOVFF  FEC,8B5
0A1D6:  MOVFF  FEC,8B6
0A1DA:  MOVFF  FEC,8B7
0A1DE:  MOVLB  8
0A1E0:  MOVF   xA9,W
0A1E2:  SUBWF  xB7,W
0A1E4:  BNC   A20A
0A1E6:  BNZ   A1FE
0A1E8:  MOVF   xA8,W
0A1EA:  SUBWF  xB6,W
0A1EC:  BNC   A20A
0A1EE:  BNZ   A1FE
0A1F0:  MOVF   xA7,W
0A1F2:  SUBWF  xB5,W
0A1F4:  BNC   A20A
0A1F6:  BNZ   A1FE
0A1F8:  MOVF   xA6,W
0A1FA:  SUBWF  xB4,W
0A1FC:  BNC   A20A
....................                { 
....................                   terminate(1); 
0A1FE:  MOVLW  01
0A200:  MOVWF  xC8
0A202:  MOVLB  0
0A204:  CALL   9006
0A208:  MOVLB  8
....................                } 
....................                break; 
0A20A:  MOVLB  7
0A20C:  BRA    A636
0A20E:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A210:  BCF    FD8.0
0A212:  MOVLB  7
0A214:  RLCF   x3C,W
0A216:  CLRF   03
0A218:  ADDLW  96
0A21A:  MOVWF  FE9
0A21C:  MOVLW  07
0A21E:  ADDWFC 03,W
0A220:  MOVWF  FEA
0A222:  MOVFF  FEC,8B5
0A226:  MOVF   FED,F
0A228:  MOVFF  FEF,8B4
0A22C:  BCF    FD8.0
0A22E:  RLCF   x3C,W
0A230:  CLRF   03
0A232:  ADDLW  56
0A234:  MOVWF  FE9
0A236:  MOVLW  07
0A238:  ADDWFC 03,W
0A23A:  MOVWF  FEA
0A23C:  MOVFF  FEC,03
0A240:  MOVF   FED,F
0A242:  MOVFF  FEF,01
0A246:  MOVF   03,W
0A248:  MOVLB  8
0A24A:  SUBWF  xB5,W
0A24C:  BNC   A260
0A24E:  BNZ   A256
0A250:  MOVF   01,W
0A252:  SUBWF  xB4,W
0A254:  BNC   A260
....................                { 
....................                   terminate(0); 
0A256:  CLRF   xC8
0A258:  MOVLB  0
0A25A:  CALL   9006
0A25E:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A260:  BCF    FD8.0
0A262:  MOVLB  7
0A264:  RLCF   x3C,W
0A266:  CLRF   03
0A268:  ADDLW  B7
0A26A:  MOVWF  FE9
0A26C:  MOVLW  07
0A26E:  ADDWFC 03,W
0A270:  MOVWF  FEA
0A272:  MOVFF  FEC,8B5
0A276:  MOVF   FED,F
0A278:  MOVFF  FEF,8B4
0A27C:  MOVLB  8
0A27E:  MOVF   xA9,F
0A280:  BNZ   A2D8
0A282:  MOVF   xA8,F
0A284:  BNZ   A2D8
0A286:  MOVF   xA7,W
0A288:  SUBWF  xB5,W
0A28A:  BNC   A2D8
0A28C:  BNZ   A294
0A28E:  MOVF   xA6,W
0A290:  SUBWF  xB4,W
0A292:  BNC   A2D8
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A294:  BCF    FD8.0
0A296:  MOVLB  7
0A298:  RLCF   x3C,W
0A29A:  CLRF   03
0A29C:  ADDLW  B3
0A29E:  MOVWF  FE9
0A2A0:  MOVLW  07
0A2A2:  ADDWFC 03,W
0A2A4:  MOVWF  FEA
0A2A6:  MOVFF  FEC,8BB
0A2AA:  MOVF   FED,F
0A2AC:  MOVFF  FEF,8BA
0A2B0:  MOVFF  8A9,8B9
0A2B4:  MOVFF  8A8,8B8
0A2B8:  MOVFF  8A7,8B7
0A2BC:  MOVFF  8A6,8B6
0A2C0:  MOVLB  0
0A2C2:  CALL   95C6
0A2C6:  MOVFF  03,8AE
0A2CA:  MOVFF  02,8AD
0A2CE:  MOVFF  01,8AC
0A2D2:  MOVFF  00,8AB
0A2D6:  MOVLB  8
....................                } 
....................                break; 
0A2D8:  MOVLB  7
0A2DA:  BRA    A636
0A2DC:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A2DE:  BCF    FD8.0
0A2E0:  MOVLB  7
0A2E2:  RLCF   x3C,W
0A2E4:  CLRF   03
0A2E6:  ADDLW  B7
0A2E8:  MOVWF  FE9
0A2EA:  MOVLW  07
0A2EC:  ADDWFC 03,W
0A2EE:  MOVWF  FEA
0A2F0:  MOVFF  FEC,8B5
0A2F4:  MOVF   FED,F
0A2F6:  MOVFF  FEF,8B4
0A2FA:  MOVLB  8
0A2FC:  MOVF   xA9,F
0A2FE:  BNZ   A31C
0A300:  MOVF   xA8,F
0A302:  BNZ   A31C
0A304:  MOVF   xA7,W
0A306:  SUBWF  xB5,W
0A308:  BNC   A31C
0A30A:  BNZ   A312
0A30C:  MOVF   xA6,W
0A30E:  SUBWF  xB4,W
0A310:  BNC   A31C
....................                { 
....................                   terminate(0); 
0A312:  CLRF   xC8
0A314:  MOVLB  0
0A316:  CALL   9006
0A31A:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A31C:  BCF    FD8.0
0A31E:  MOVLB  7
0A320:  RLCF   x3C,W
0A322:  CLRF   03
0A324:  ADDLW  76
0A326:  MOVWF  FE9
0A328:  MOVLW  07
0A32A:  ADDWFC 03,W
0A32C:  MOVWF  FEA
0A32E:  MOVFF  FEC,8B5
0A332:  MOVF   FED,F
0A334:  MOVFF  FEF,8B4
0A338:  MOVLB  8
0A33A:  MOVF   xB4,F
0A33C:  BNZ   A3A2
0A33E:  MOVF   xB5,F
0A340:  BNZ   A3A2
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A342:  CLRF   03
0A344:  MOVLB  7
0A346:  MOVF   x3C,W
0A348:  ADDLW  C7
0A34A:  MOVWF  FE9
0A34C:  MOVLW  07
0A34E:  ADDWFC 03,W
0A350:  MOVWF  FEA
0A352:  MOVF   FEF,F
0A354:  BNZ   A3A0
....................                   { 
....................                      wrt_m_error(); 
0A356:  MOVLB  0
0A358:  CALL   8EB6
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A35C:  BCF    FD8.0
0A35E:  MOVLB  7
0A360:  RLCF   x3C,W
0A362:  CLRF   03
0A364:  ADDLW  B3
0A366:  MOVWF  FE9
0A368:  MOVLW  07
0A36A:  ADDWFC 03,W
0A36C:  MOVWF  FEA
0A36E:  MOVFF  FEC,8BB
0A372:  MOVF   FED,F
0A374:  MOVFF  FEF,8BA
0A378:  MOVFF  8A9,8B9
0A37C:  MOVFF  8A8,8B8
0A380:  MOVFF  8A7,8B7
0A384:  MOVFF  8A6,8B6
0A388:  MOVLB  0
0A38A:  CALL   95C6
0A38E:  MOVFF  03,8AE
0A392:  MOVFF  02,8AD
0A396:  MOVFF  01,8AC
0A39A:  MOVFF  00,8AB
0A39E:  MOVLB  7
0A3A0:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A3A2:  BCF    FD8.0
0A3A4:  MOVLB  7
0A3A6:  RLCF   x3C,W
0A3A8:  CLRF   03
0A3AA:  ADDLW  76
0A3AC:  MOVWF  FE9
0A3AE:  MOVLW  07
0A3B0:  ADDWFC 03,W
0A3B2:  MOVWF  FEA
0A3B4:  MOVFF  FEC,8B5
0A3B8:  MOVF   FED,F
0A3BA:  MOVFF  FEF,8B4
0A3BE:  MOVLB  8
0A3C0:  DECFSZ xB4,W
0A3C2:  BRA    A428
0A3C4:  MOVF   xB5,F
0A3C6:  BNZ   A428
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A3C8:  CLRF   03
0A3CA:  MOVLB  7
0A3CC:  MOVF   x3C,W
0A3CE:  ADDLW  C7
0A3D0:  MOVWF  FE9
0A3D2:  MOVLW  07
0A3D4:  ADDWFC 03,W
0A3D6:  MOVWF  FEA
0A3D8:  DECFSZ FEF,W
0A3DA:  BRA    A426
....................                   { 
....................                      wrt_m_error(); 
0A3DC:  MOVLB  0
0A3DE:  CALL   8EB6
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A3E2:  BCF    FD8.0
0A3E4:  MOVLB  7
0A3E6:  RLCF   x3C,W
0A3E8:  CLRF   03
0A3EA:  ADDLW  B3
0A3EC:  MOVWF  FE9
0A3EE:  MOVLW  07
0A3F0:  ADDWFC 03,W
0A3F2:  MOVWF  FEA
0A3F4:  MOVFF  FEC,8BB
0A3F8:  MOVF   FED,F
0A3FA:  MOVFF  FEF,8BA
0A3FE:  MOVFF  8A9,8B9
0A402:  MOVFF  8A8,8B8
0A406:  MOVFF  8A7,8B7
0A40A:  MOVFF  8A6,8B6
0A40E:  MOVLB  0
0A410:  CALL   95C6
0A414:  MOVFF  03,8AE
0A418:  MOVFF  02,8AD
0A41C:  MOVFF  01,8AC
0A420:  MOVFF  00,8AB
0A424:  MOVLB  7
0A426:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A428:  MOVLB  7
0A42A:  BRA    A636
0A42C:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A42E:  MOVLB  7
0A430:  MOVF   x3C,W
0A432:  MULLW  04
0A434:  MOVF   FF3,W
0A436:  CLRF   03
0A438:  ADDLW  9E
0A43A:  MOVWF  FE9
0A43C:  MOVLW  07
0A43E:  ADDWFC 03,W
0A440:  MOVWF  FEA
0A442:  MOVFF  FEF,8B4
0A446:  MOVFF  FEC,8B5
0A44A:  MOVFF  FEC,8B6
0A44E:  MOVFF  FEC,8B7
0A452:  MOVLB  8
0A454:  MOVF   xAB,W
0A456:  SUBWF  xB4,F
0A458:  MOVF   xAC,W
0A45A:  SUBWFB xB5,F
0A45C:  MOVF   xAD,W
0A45E:  SUBWFB xB6,F
0A460:  MOVF   xAE,W
0A462:  SUBWFB xB7,F
0A464:  BNZ   A47C
0A466:  MOVF   xB6,F
0A468:  BNZ   A47C
0A46A:  MOVF   xB2,W
0A46C:  SUBWF  xB5,W
0A46E:  BTFSS  FD8.0
0A470:  BRA    A578
0A472:  BNZ   A47C
0A474:  MOVF   xB1,W
0A476:  SUBWF  xB4,W
0A478:  BTFSS  FD8.0
0A47A:  BRA    A578
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A47C:  BCF    FD8.0
0A47E:  MOVLB  7
0A480:  RLCF   x3C,W
0A482:  CLRF   03
0A484:  ADDLW  62
0A486:  MOVWF  01
0A488:  MOVLW  07
0A48A:  ADDWFC 03,F
0A48C:  MOVLB  8
0A48E:  MOVFF  03,8B5
0A492:  BCF    FD8.0
0A494:  MOVLB  7
0A496:  RLCF   x3C,W
0A498:  CLRF   03
0A49A:  ADDLW  9A
0A49C:  MOVWF  FE9
0A49E:  MOVLW  07
0A4A0:  ADDWFC 03,W
0A4A2:  MOVWF  FEA
0A4A4:  MOVFF  FEC,03
0A4A8:  MOVF   FED,F
0A4AA:  MOVFF  FEF,8B6
0A4AE:  MOVLB  8
0A4B0:  MOVFF  8B5,FEA
0A4B4:  MOVFF  01,FE9
0A4B8:  MOVFF  03,FEC
0A4BC:  MOVF   FED,F
0A4BE:  MOVFF  8B6,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A4C2:  MOVLB  7
0A4C4:  MOVF   x3C,W
0A4C6:  MULLW  04
0A4C8:  MOVF   FF3,W
0A4CA:  CLRF   03
0A4CC:  ADDLW  9E
0A4CE:  MOVWF  FE9
0A4D0:  MOVLW  07
0A4D2:  ADDWFC 03,W
0A4D4:  MOVWF  FEA
0A4D6:  MOVFF  FEF,8B4
0A4DA:  MOVFF  FEC,8B5
0A4DE:  MOVFF  FEC,8B6
0A4E2:  MOVFF  FEC,8B7
0A4E6:  MOVLW  6E
0A4E8:  MOVWF  FF6
0A4EA:  MOVLW  1A
0A4EC:  MOVWF  FF7
0A4EE:  MOVLW  00
0A4F0:  MOVWF  FF8
0A4F2:  CLRF   1B
0A4F4:  BTFSC  FF2.7
0A4F6:  BSF    1B.7
0A4F8:  BCF    FF2.7
0A4FA:  MOVLW  0B
0A4FC:  MOVLB  A
0A4FE:  MOVWF  x18
0A500:  MOVLB  0
0A502:  CALL   1006
0A506:  BTFSC  1B.7
0A508:  BSF    FF2.7
0A50A:  MOVLW  41
0A50C:  MOVWF  FE9
0A50E:  CLRF   1B
0A510:  BTFSC  FF2.7
0A512:  BSF    1B.7
0A514:  BCF    FF2.7
0A516:  MOVFF  8B7,A1B
0A51A:  MOVFF  8B6,A1A
0A51E:  MOVFF  8B5,A19
0A522:  MOVFF  8B4,A18
0A526:  CALL   10CC
0A52A:  BTFSC  1B.7
0A52C:  BSF    FF2.7
0A52E:  MOVLW  2C
0A530:  BTFSS  F9E.4
0A532:  BRA    A530
0A534:  MOVWF  FAD
0A536:  MOVLW  41
0A538:  MOVWF  FE9
0A53A:  CLRF   1B
0A53C:  BTFSC  FF2.7
0A53E:  BSF    1B.7
0A540:  BCF    FF2.7
0A542:  MOVFF  8AE,A1B
0A546:  MOVFF  8AD,A1A
0A54A:  MOVFF  8AC,A19
0A54E:  MOVFF  8AB,A18
0A552:  CALL   10CC
0A556:  BTFSC  1B.7
0A558:  BSF    FF2.7
0A55A:  MOVLW  0D
0A55C:  BTFSS  F9E.4
0A55E:  BRA    A55C
0A560:  MOVWF  FAD
0A562:  MOVLW  0A
0A564:  BTFSS  F9E.4
0A566:  BRA    A564
0A568:  MOVWF  FAD
....................                   terminate(1); 
0A56A:  MOVLW  01
0A56C:  MOVLB  8
0A56E:  MOVWF  xC8
0A570:  MOVLB  0
0A572:  CALL   9006
0A576:  MOVLB  8
....................                } 
....................                break; 
0A578:  MOVLB  7
0A57A:  BRA    A636
0A57C:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A57E:  MOVLB  7
0A580:  MOVF   x3C,W
0A582:  MULLW  04
0A584:  MOVF   FF3,W
0A586:  CLRF   03
0A588:  ADDLW  9E
0A58A:  MOVWF  FE9
0A58C:  MOVLW  07
0A58E:  ADDWFC 03,W
0A590:  MOVWF  FEA
0A592:  MOVFF  FEF,8B4
0A596:  MOVFF  FEC,8B5
0A59A:  MOVFF  FEC,8B6
0A59E:  MOVFF  FEC,8B7
0A5A2:  BCF    FD8.0
0A5A4:  RLCF   x3C,W
0A5A6:  CLRF   03
0A5A8:  ADDLW  6E
0A5AA:  MOVWF  FE9
0A5AC:  MOVLW  07
0A5AE:  ADDWFC 03,W
0A5B0:  MOVWF  FEA
0A5B2:  MOVFF  FEC,03
0A5B6:  MOVF   FED,F
0A5B8:  MOVFF  FEF,01
0A5BC:  MOVLB  8
0A5BE:  MOVF   xB7,F
0A5C0:  BNZ   A5D4
0A5C2:  MOVF   xB6,F
0A5C4:  BNZ   A5D4
0A5C6:  MOVF   03,W
0A5C8:  SUBWF  xB5,W
0A5CA:  BNC   A634
0A5CC:  BNZ   A5D4
0A5CE:  MOVF   01,W
0A5D0:  SUBWF  xB4,W
0A5D2:  BNC   A634
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A5D4:  BCF    FD8.0
0A5D6:  MOVLB  7
0A5D8:  RLCF   x3C,W
0A5DA:  CLRF   03
0A5DC:  ADDLW  62
0A5DE:  MOVWF  01
0A5E0:  MOVLW  07
0A5E2:  ADDWFC 03,F
0A5E4:  MOVLB  8
0A5E6:  MOVFF  03,8B5
0A5EA:  BCF    FD8.0
0A5EC:  MOVLB  7
0A5EE:  RLCF   x3C,W
0A5F0:  CLRF   03
0A5F2:  ADDLW  9A
0A5F4:  MOVWF  FE9
0A5F6:  MOVLW  07
0A5F8:  ADDWFC 03,W
0A5FA:  MOVWF  FEA
0A5FC:  MOVFF  FEC,03
0A600:  MOVF   FED,F
0A602:  MOVFF  FEF,8B6
0A606:  MOVLB  8
0A608:  MOVFF  8B5,FEA
0A60C:  MOVFF  01,FE9
0A610:  MOVFF  03,FEC
0A614:  MOVF   FED,F
0A616:  MOVFF  8B6,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A61A:  BCF    FD8.0
0A61C:  MOVLB  7
0A61E:  RLCF   x3C,W
0A620:  CLRF   03
0A622:  ADDLW  B7
0A624:  MOVWF  FE9
0A626:  MOVLW  07
0A628:  ADDWFC 03,W
0A62A:  MOVWF  FEA
0A62C:  CLRF   FEC
0A62E:  MOVF   FED,F
0A630:  CLRF   FEF
0A632:  MOVLB  8
....................                } 
....................                break; 
0A634:  MOVLB  7
....................             } 
....................          } 
0A636:  MOVLB  0
0A638:  BRA    A12A
0A63A:  MOVLB  7
....................       } 
....................    } 
0A63C:  BRA    A65A
0A63E:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A640:  BCF    FD8.0
0A642:  MOVLB  7
0A644:  RLCF   x3C,W
0A646:  CLRF   03
0A648:  ADDLW  92
0A64A:  MOVWF  FE9
0A64C:  MOVLW  07
0A64E:  ADDWFC 03,W
0A650:  MOVWF  FEA
0A652:  CLRF   FEC
0A654:  MOVF   FED,F
0A656:  MOVLW  01
0A658:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A65A:  BCF    FD8.0
0A65C:  RLCF   x3C,W
0A65E:  CLRF   03
0A660:  ADDLW  92
0A662:  MOVWF  FE9
0A664:  MOVLW  07
0A666:  ADDWFC 03,W
0A668:  MOVWF  FEA
0A66A:  MOVFF  FEC,8B5
0A66E:  MOVF   FED,F
0A670:  MOVFF  FEF,8B4
0A674:  MOVLB  8
0A676:  DECFSZ xB4,W
0A678:  BRA    A68A
0A67A:  MOVF   xB5,F
0A67C:  BNZ   A68A
....................       wrt_m_error(); 
0A67E:  MOVLB  0
0A680:  CALL   8EB6
....................       msg_mer(); 
0A684:  CALL   9C38
0A688:  MOVLB  8
....................    } 
0A68A:  MOVLB  0
0A68C:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
16B9E:  MOVF   44,F
16BA0:  BNZ   16BAE
16BA2:  MOVF   45,F
16BA4:  BNZ   16BAE
16BA6:  MOVF   46,F
16BA8:  BNZ   16BAE
16BAA:  MOVF   47,F
16BAC:  BZ    16BDA
16BAE:  MOVF   47,F
16BB0:  BNZ   16BDA
16BB2:  MOVF   46,W
16BB4:  SUBLW  00
16BB6:  BNC   16BDA
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
16BB8:  MOVFF  862,8A4
16BBC:  MOVFF  863,8A5
16BC0:  MOVFF  47,8A9
16BC4:  MOVFF  46,8A8
16BC8:  MOVFF  45,8A7
16BCC:  MOVFF  44,8A6
16BD0:  MOVFF  864,8AA
16BD4:  CALL   9CAE
....................    } 
16BD8:  BRA    16C56
....................    else if(arg==0) 
16BDA:  MOVF   44,F
16BDC:  BNZ   16C52
16BDE:  MOVF   45,F
16BE0:  BNZ   16C52
16BE2:  MOVF   46,F
16BE4:  BNZ   16C52
16BE6:  MOVF   47,F
16BE8:  BNZ   16C52
....................    { 
....................       m_lin_pos[motor]=0; 
16BEA:  BCF    FD8.0
16BEC:  MOVLB  7
16BEE:  RLCF   x3C,W
16BF0:  CLRF   03
16BF2:  ADDLW  AF
16BF4:  MOVWF  FE9
16BF6:  MOVLW  07
16BF8:  ADDWFC 03,W
16BFA:  MOVWF  FEA
16BFC:  CLRF   FEC
16BFE:  MOVF   FED,F
16C00:  CLRF   FEF
....................       switch (motor){ 
16C02:  MOVF   x3C,W
16C04:  XORLW  00
16C06:  MOVLB  0
16C08:  BZ    16C10
16C0A:  XORLW  01
16C0C:  BZ    16C22
16C0E:  BRA    16C32
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
16C10:  MOVLW  B6
16C12:  MOVLB  8
16C14:  MOVWF  xCB
16C16:  CLRF   xCD
16C18:  CLRF   xCC
16C1A:  MOVLB  0
16C1C:  CALL   4F4C
....................             break; 
16C20:  BRA    16C32
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
16C22:  MOVLW  B8
16C24:  MOVLB  8
16C26:  MOVWF  xCB
16C28:  CLRF   xCD
16C2A:  CLRF   xCC
16C2C:  MOVLB  0
16C2E:  CALL   4F4C
....................             break; 
....................       }  
....................       m_error[motor]=0; 
16C32:  BCF    FD8.0
16C34:  MOVLB  7
16C36:  RLCF   x3C,W
16C38:  CLRF   03
16C3A:  ADDLW  92
16C3C:  MOVWF  FE9
16C3E:  MOVLW  07
16C40:  ADDWFC 03,W
16C42:  MOVWF  FEA
16C44:  CLRF   FEC
16C46:  MOVF   FED,F
16C48:  CLRF   FEF
....................       wrt_m_error(); 
16C4A:  MOVLB  0
16C4C:  CALL   8EB6
....................    } 
16C50:  BRA    16C56
....................    else cmd_arg(); 
16C52:  CALL   AF66
16C56:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
18648:  MOVLW  01
1864A:  MOVLB  8
1864C:  MOVWF  xC9
1864E:  MOVLB  0
18650:  CALL   8906
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
18654:  MOVLW  FA
18656:  MOVLB  9
18658:  MOVWF  xC9
1865A:  MOVLB  0
1865C:  CALL   288E
....................       switch(motor) 
18660:  MOVLB  7
18662:  MOVF   x3C,W
18664:  XORLW  00
18666:  MOVLB  0
18668:  BZ    18670
1866A:  XORLW  01
1866C:  BZ    18682
1866E:  BRA    18692
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18670:  MOVLB  8
18672:  CLRF   x62
18674:  BTFSC  F81.4
18676:  INCF   x62,F
....................             chanA = input(ENC1_PHA); 
18678:  CLRF   x63
1867A:  BTFSC  F81.1
1867C:  INCF   x63,F
....................             break; 
1867E:  MOVLB  0
18680:  BRA    18692
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
18682:  MOVLB  8
18684:  CLRF   x62
18686:  BTFSC  F81.5
18688:  INCF   x62,F
....................             chanA = input(ENC2_PHA); 
1868A:  CLRF   x63
1868C:  BTFSC  F81.2
1868E:  INCF   x63,F
....................             break; 
18690:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
18692:  MOVLW  84
18694:  MOVWF  FF6
18696:  MOVLW  1A
18698:  MOVWF  FF7
1869A:  MOVLW  00
1869C:  MOVWF  FF8
1869E:  CLRF   1B
186A0:  BTFSC  FF2.7
186A2:  BSF    1B.7
186A4:  BCF    FF2.7
186A6:  MOVLW  04
186A8:  MOVLB  A
186AA:  MOVWF  x18
186AC:  MOVLB  0
186AE:  CALL   1006
186B2:  BTFSC  1B.7
186B4:  BSF    FF2.7
186B6:  CLRF   1B
186B8:  BTFSC  FF2.7
186BA:  BSF    1B.7
186BC:  BCF    FF2.7
186BE:  MOVFF  862,A18
186C2:  MOVLW  1B
186C4:  MOVLB  A
186C6:  MOVWF  x19
186C8:  MOVLB  0
186CA:  CALL   0F88
186CE:  BTFSC  1B.7
186D0:  BSF    FF2.7
186D2:  MOVLW  8A
186D4:  MOVWF  FF6
186D6:  MOVLW  1A
186D8:  MOVWF  FF7
186DA:  MOVLW  00
186DC:  MOVWF  FF8
186DE:  CLRF   1B
186E0:  BTFSC  FF2.7
186E2:  BSF    1B.7
186E4:  BCF    FF2.7
186E6:  MOVLW  07
186E8:  MOVLB  A
186EA:  MOVWF  x18
186EC:  MOVLB  0
186EE:  CALL   1006
186F2:  BTFSC  1B.7
186F4:  BSF    FF2.7
186F6:  CLRF   1B
186F8:  BTFSC  FF2.7
186FA:  BSF    1B.7
186FC:  BCF    FF2.7
186FE:  MOVFF  863,A18
18702:  MOVLW  1B
18704:  MOVLB  A
18706:  MOVWF  x19
18708:  MOVLB  0
1870A:  CALL   0F88
1870E:  BTFSC  1B.7
18710:  BSF    FF2.7
18712:  MOVLW  0D
18714:  BTFSS  F9E.4
18716:  BRA    18714
18718:  MOVWF  FAD
1871A:  MOVLW  0A
1871C:  BTFSS  F9E.4
1871E:  BRA    1871C
18720:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
18722:  BTFSS  F9E.5
18724:  BRA    18732
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
18726:  CALL   0E1A
1872A:  MOVF   01,W
1872C:  SUBLW  1B
1872E:  BNZ   18732
....................          { 
....................             break; 
18730:  BRA    18734
....................          } 
....................       } 
18732:  BRA    18654
....................    } 
....................  
....................    delay_ms(100); 
18734:  MOVLW  64
18736:  MOVLB  9
18738:  MOVWF  xC9
1873A:  MOVLB  0
1873C:  CALL   288E
....................    enc_pwr(OFF); 
18740:  MOVLB  8
18742:  CLRF   xC9
18744:  MOVLB  0
18746:  CALL   8906
1874A:  GOTO   18766 (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A7EA:  BCF    FD8.0
0A7EC:  MOVLB  7
0A7EE:  RLCF   x3C,W
0A7F0:  CLRF   03
0A7F2:  ADDLW  62
0A7F4:  MOVWF  FE9
0A7F6:  MOVLW  07
0A7F8:  ADDWFC 03,W
0A7FA:  MOVWF  FEA
0A7FC:  MOVFF  FEC,8A3
0A800:  MOVF   FED,F
0A802:  MOVFF  FEF,8A2
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A806:  BCF    FD8.0
0A808:  RLCF   x3C,W
0A80A:  CLRF   03
0A80C:  ADDLW  72
0A80E:  MOVWF  FE9
0A810:  MOVLW  07
0A812:  ADDWFC 03,W
0A814:  MOVWF  FEA
0A816:  MOVFF  FEC,8B9
0A81A:  MOVF   FED,F
0A81C:  MOVFF  FEF,8B8
0A820:  BCF    FD8.0
0A822:  RLCF   x3C,W
0A824:  CLRF   03
0A826:  ADDLW  5E
0A828:  MOVWF  FE9
0A82A:  MOVLW  07
0A82C:  ADDWFC 03,W
0A82E:  MOVWF  FEA
0A830:  MOVFF  FEC,03
0A834:  MOVF   FED,F
0A836:  MOVFF  FEF,8BA
0A83A:  MOVFF  03,8A7
0A83E:  MOVFF  03,8BB
0A842:  MOVLB  0
0A844:  CALL   2C52
0A848:  MOVFF  02,8A1
0A84C:  MOVFF  01,8A0
....................    e_mode[motor] = 0;                          // motor steps 
0A850:  BCF    FD8.0
0A852:  MOVLB  7
0A854:  RLCF   x3C,W
0A856:  CLRF   03
0A858:  ADDLW  62
0A85A:  MOVWF  FE9
0A85C:  MOVLW  07
0A85E:  ADDWFC 03,W
0A860:  MOVWF  FEA
0A862:  CLRF   FEC
0A864:  MOVF   FED,F
0A866:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A868:  MOVLB  8
0A86A:  CLRF   xA4
0A86C:  MOVFF  89F,8A5
0A870:  CLRF   xA9
0A872:  CLRF   xA8
0A874:  MOVFF  8A1,8A7
0A878:  MOVFF  8A0,8A6
0A87C:  MOVLW  01
0A87E:  MOVWF  xAA
0A880:  MOVLB  0
0A882:  CALL   9CAE
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A886:  MOVLW  01
0A888:  MOVLB  8
0A88A:  MOVWF  xC9
0A88C:  MOVLB  0
0A88E:  CALL   8906
....................    delay_ms(100); 
0A892:  MOVLW  64
0A894:  MOVLB  9
0A896:  MOVWF  xC9
0A898:  MOVLB  0
0A89A:  CALL   288E
....................    poll_index(); 
0A89E:  BRA    A6B8
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A8A0:  BCF    FD8.0
0A8A2:  MOVLB  7
0A8A4:  RLCF   x3C,W
0A8A6:  CLRF   03
0A8A8:  ADDLW  5A
0A8AA:  MOVWF  FE9
0A8AC:  MOVLW  07
0A8AE:  ADDWFC 03,W
0A8B0:  MOVWF  FEA
0A8B2:  MOVFF  FEC,8A5
0A8B6:  MOVF   FED,F
0A8B8:  MOVFF  FEF,8A4
0A8BC:  MOVLW  02
0A8BE:  MOVLB  8
0A8C0:  ADDWF  xA4,W
0A8C2:  MOVWF  xA0
0A8C4:  MOVLW  00
0A8C6:  ADDWFC xA5,W
0A8C8:  MOVWF  xA1
....................    e_mode[motor] = 3; 
0A8CA:  BCF    FD8.0
0A8CC:  MOVLB  7
0A8CE:  RLCF   x3C,W
0A8D0:  CLRF   03
0A8D2:  ADDLW  62
0A8D4:  MOVWF  FE9
0A8D6:  MOVLW  07
0A8D8:  ADDWFC 03,W
0A8DA:  MOVWF  FEA
0A8DC:  CLRF   FEC
0A8DE:  MOVF   FED,F
0A8E0:  MOVLW  03
0A8E2:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A8E4:  MOVLB  8
0A8E6:  CLRF   xA4
0A8E8:  MOVFF  89F,8A5
0A8EC:  CLRF   xA9
0A8EE:  CLRF   xA8
0A8F0:  MOVFF  8A1,8A7
0A8F4:  MOVFF  8A0,8A6
0A8F8:  MOVLW  01
0A8FA:  MOVWF  xAA
0A8FC:  MOVLB  0
0A8FE:  CALL   9CAE
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A902:  MOVFF  77F,8A1
0A906:  MOVFF  77E,8A0
....................    e_mode[motor] = 0;                          // motor steps 
0A90A:  BCF    FD8.0
0A90C:  MOVLB  7
0A90E:  RLCF   x3C,W
0A910:  CLRF   03
0A912:  ADDLW  62
0A914:  MOVWF  FE9
0A916:  MOVLW  07
0A918:  ADDWFC 03,W
0A91A:  MOVWF  FEA
0A91C:  CLRF   FEC
0A91E:  MOVF   FED,F
0A920:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0A922:  MOVLB  8
0A924:  CLRF   xA4
0A926:  MOVFF  89F,8A5
0A92A:  CLRF   xA9
0A92C:  CLRF   xA8
0A92E:  MOVFF  8A1,8A7
0A932:  MOVFF  8A0,8A6
0A936:  MOVLW  01
0A938:  MOVWF  xAA
0A93A:  MOVLB  0
0A93C:  CALL   9CAE
....................  
....................    e_pos[motor] = 0; 
0A940:  BCF    FD8.0
0A942:  MOVLB  7
0A944:  RLCF   x3C,W
0A946:  CLRF   03
0A948:  ADDLW  BB
0A94A:  MOVWF  FE9
0A94C:  MOVLW  07
0A94E:  ADDWFC 03,W
0A950:  MOVWF  FEA
0A952:  CLRF   FEC
0A954:  MOVF   FED,F
0A956:  CLRF   FEF
....................    e_port[motor] = 1; 
0A958:  BCF    FD8.0
0A95A:  RLCF   x3C,W
0A95C:  CLRF   03
0A95E:  ADDLW  BF
0A960:  MOVWF  FE9
0A962:  MOVLW  07
0A964:  ADDWFC 03,W
0A966:  MOVWF  FEA
0A968:  CLRF   FEC
0A96A:  MOVF   FED,F
0A96C:  MOVLW  01
0A96E:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0A970:  BCF    FD8.0
0A972:  RLCF   x3C,W
0A974:  CLRF   03
0A976:  ADDLW  62
0A978:  MOVWF  FE9
0A97A:  MOVLW  07
0A97C:  ADDWFC 03,W
0A97E:  MOVWF  FEA
0A980:  MOVFF  8A3,FEC
0A984:  MOVF   FED,F
0A986:  MOVFF  8A2,FEF
0A98A:  MOVLB  0
0A98C:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0DDAC:  BCF    FD8.0
0DDAE:  MOVLB  7
0DDB0:  RLCF   x3C,W
0DDB2:  CLRF   03
0DDB4:  ADDLW  5A
0DDB6:  MOVWF  FE9
0DDB8:  MOVLW  07
0DDBA:  ADDWFC 03,W
0DDBC:  MOVWF  FEA
0DDBE:  MOVFF  FEC,866
0DDC2:  MOVF   FED,F
0DDC4:  MOVFF  FEF,865
0DDC8:  MOVLW  02
0DDCA:  MOVLB  8
0DDCC:  ADDWF  x65,W
0DDCE:  MOVWF  x63
0DDD0:  MOVLW  00
0DDD2:  ADDWFC x66,W
0DDD4:  MOVWF  x64
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0DDD6:  CLRF   xA4
0DDD8:  MOVFF  862,8A5
0DDDC:  CLRF   xA9
0DDDE:  CLRF   xA8
0DDE0:  MOVFF  864,8A7
0DDE4:  MOVFF  863,8A6
0DDE8:  MOVLW  02
0DDEA:  MOVWF  xAA
0DDEC:  MOVLB  0
0DDEE:  CALL   9CAE
0DDF2:  GOTO   DE72 (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0A98E:  MOVF   2F,W
0A990:  SUBLW  02
0A992:  BNZ   A998
0A994:  MOVF   30,F
0A996:  BZ    A9F8
....................    { 
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0A998:  MOVLW  96
0A99A:  MOVWF  FF6
0A99C:  MOVLW  1A
0A99E:  MOVWF  FF7
0A9A0:  MOVLW  00
0A9A2:  MOVWF  FF8
0A9A4:  CLRF   1B
0A9A6:  BTFSC  FF2.7
0A9A8:  BSF    1B.7
0A9AA:  BCF    FF2.7
0A9AC:  CALL   0E30
0A9B0:  BTFSC  1B.7
0A9B2:  BSF    FF2.7
....................       motor=0; 
0A9B4:  MOVLB  7
0A9B6:  CLRF   x3C
....................       align(0); 
0A9B8:  MOVLB  8
0A9BA:  CLRF   x9F
0A9BC:  MOVLB  0
0A9BE:  RCALL  A7EA
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0A9C0:  MOVLW  01
0A9C2:  MOVLB  7
0A9C4:  MOVWF  x3C
....................       move_motor(0,0,22000,1); 
0A9C6:  MOVLB  8
0A9C8:  CLRF   xA4
0A9CA:  CLRF   xA5
0A9CC:  CLRF   xA9
0A9CE:  CLRF   xA8
0A9D0:  MOVLW  55
0A9D2:  MOVWF  xA7
0A9D4:  MOVLW  F0
0A9D6:  MOVWF  xA6
0A9D8:  MOVLW  01
0A9DA:  MOVWF  xAA
0A9DC:  MOVLB  0
0A9DE:  CALL   9CAE
....................        
....................       m_lin_pos[1]=0; 
0A9E2:  MOVLB  7
0A9E4:  CLRF   xB2
0A9E6:  CLRF   xB1
....................       write16(ADDR_M2_LIN_POS,0); 
0A9E8:  MOVLW  B8
0A9EA:  MOVLB  8
0A9EC:  MOVWF  xCB
0A9EE:  CLRF   xCD
0A9F0:  CLRF   xCC
0A9F2:  MOVLB  0
0A9F4:  CALL   4F4C
....................    } 
0A9F8:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0BE6A:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BE6C:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0BE6E:  BCF    F8E.3
....................   delay_ms(20); 
0BE70:  MOVLW  14
0BE72:  MOVLB  9
0BE74:  MOVWF  xC9
0BE76:  MOVLB  0
0BE78:  CALL   288E
....................   output_bit(VMOT,  OFF); 
0BE7C:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0BE7E:  BCF    F8E.2
0BE80:  GOTO   BED6 (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BE84:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BE86:  BSF    F8E.1
....................   delay_ms(50); 
0BE88:  MOVLW  32
0BE8A:  MOVLB  9
0BE8C:  MOVWF  xC9
0BE8E:  MOVLB  0
0BE90:  CALL   288E
....................   output_bit(HB_IN1,ON);           
0BE94:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BE96:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0BE98:  BSF    F8E.3
0BE9A:  GOTO   BED6 (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BE9E:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BEA0:  BSF    F8E.1
....................   delay_ms(50); 
0BEA2:  MOVLW  32
0BEA4:  MOVLB  9
0BEA6:  MOVWF  xC9
0BEA8:  MOVLB  0
0BEAA:  CALL   288E
....................   output_bit(HB_IN1,OFF);           
0BEAE:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0BEB0:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0BEB2:  BSF    F8E.3
0BEB4:  GOTO   BED6 (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0BEB8:  MOVLB  8
0BEBA:  MOVF   x92,W
0BEBC:  XORLW  00
0BEBE:  MOVLB  0
0BEC0:  BZ    BECC
0BEC2:  XORLW  01
0BEC4:  BZ    BED0
0BEC6:  XORLW  03
0BEC8:  BZ    BED4
0BECA:  BRA    BED6
....................       case 0:  HB_all_OFF(); 
0BECC:  BRA    BE6A
....................          break; 
0BECE:  BRA    BED6
....................       case 1:  HB_m1_ON(); 
0BED0:  BRA    BE84
....................          break; 
0BED2:  BRA    BED6
....................       case 2:  HB_m2_ON(); 
0BED4:  BRA    BE9E
....................          break; 
....................    } 
0BED6:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
158C6:  MOVLB  8
158C8:  CLRF   x66
158CA:  CLRF   x67
158CC:  CLRF   x68
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
158CE:  MOVLB  0
158D0:  BRA    1585C
158D2:  MOVFF  01,867
....................       if (serChar) 
158D6:  MOVLB  8
158D8:  MOVF   x67,F
158DA:  BZ    15904
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
158DC:  MOVF   x67,W
158DE:  SUBLW  24
158E0:  BNZ   158EA
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
158E2:  MOVLW  02
158E4:  MOVWF  x68
....................             break; 
158E6:  BRA    15910
....................          }else if (serChar == 'D'){ 
158E8:  BRA    15904
158EA:  MOVF   x67,W
158EC:  SUBLW  44
158EE:  BNZ   15900
....................             wakeup_char_is_D = 1; 
158F0:  MOVLW  01
158F2:  MOVLB  7
158F4:  MOVWF  xC9
....................             wakeUpReason = WAKE_UP_GOOD; 
158F6:  MOVLW  02
158F8:  MOVLB  8
158FA:  MOVWF  x68
....................             break; 
158FC:  BRA    15910
....................          }else 
158FE:  BRA    15904
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
15900:  MOVLW  01
15902:  MOVWF  x68
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
15904:  INCF   x66,F
15906:  MOVF   x66,W
15908:  SUBLW  02
1590A:  BC    1590E
....................       { 
....................          break; 
1590C:  BRA    15910
....................       } 
1590E:  BRA    158CE
....................    } 
....................  
....................    return (wakeUpReason); 
15910:  MOVFF  868,01
15914:  MOVLB  0
15916:  GOTO   1592A (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
0FFEC:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
0FFEE:  BSF    49.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
0FFF0:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
0FFF2:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
0FFF4:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
0FFF6:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
0FFF8:  BSF    FF2.6
0FFFA:  GOTO   1580E (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
*
15804:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
15806:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
15808:  BCF    49.0
....................    set_usart_int(); 
1580A:  GOTO   FFEC
....................    kill_wd(); 
1580E:  CALL   3074
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
15812:  BSF    FF2.4
....................    sleep();  
15814:  MOVFF  FD3,00
15818:  BCF    FD1.7
1581A:  BCF    FD3.7
1581C:  SLEEP 
1581E:  MOVFF  00,FD3
....................    delay_cycles(1); 
15822:  NOP   
15824:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
1591A:  MOVLB  8
1591C:  CLRF   x65
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
1591E:  MOVLB  0
15920:  RCALL  15826
....................  
....................    if (TRUE != rtc_alarm) 
15922:  BTFSC  49.0
15924:  BRA    159E2
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
15926:  RCALL  15826
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
15928:  BRA    158C6
1592A:  MOVFF  01,865
....................       if (WAKE_UP_GOOD == serWakeupReason) 
1592E:  MOVLB  8
15930:  MOVF   x65,W
15932:  SUBLW  02
15934:  BNZ   159DA
....................       { 
....................          sleep_mode = FALSE; 
15936:  BCF    49.1
....................          start_heartbeat(); 
15938:  MOVLB  0
1593A:  CALL   287E
....................          init_hardware(); 
1593E:  CALL   28B8
....................          init_rtc();                      // This is the FAT RTC 
15942:  CALL   3486
....................          sd_status = init_sdcard(); 
15946:  CALL   4FB2
1594A:  MOVFF  01,2D8
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
1594E:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
15950:  MOVLW  01
15952:  MOVWF  1E
15954:  MOVLW  A3
15956:  MOVWF  1D
15958:  MOVLW  CC
1595A:  MOVWF  FF6
1595C:  MOVLW  1A
1595E:  MOVWF  FF7
15960:  MOVLW  00
15962:  MOVWF  FF8
15964:  CALL   5036
....................          record_event(); 
15968:  CALL   8410
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
1596C:  CLRF   32
1596E:  MOVLW  01
15970:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
15972:  MOVLW  02
15974:  MOVLB  8
15976:  MOVWF  x66
15978:  MOVFF  31,867
1597C:  MOVLB  0
1597E:  CALL   3390
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
15982:  MOVLB  7
15984:  MOVF   xC9,F
15986:  BZ    159A8
....................             file_list(file_ptr_rel_new); 
15988:  MOVLW  03
1598A:  MOVLB  8
1598C:  MOVWF  x67
1598E:  MOVWF  x66
15990:  MOVLB  0
15992:  CALL   B78C
....................             f_unlink(file_ptr_rel_new); 
15996:  MOVLW  03
15998:  MOVLB  8
1599A:  MOVWF  x67
1599C:  MOVWF  x66
1599E:  MOVLB  0
159A0:  CALL   B906
....................              
....................             wakeup_char_is_D = 0; 
159A4:  MOVLB  7
159A6:  CLRF   xC9
....................          } 
....................          if(sd_status>0) 
159A8:  MOVLB  2
159AA:  MOVF   xD8,F
159AC:  BZ    159B6
....................          { 
....................             msg_card_fail(); 
159AE:  MOVLB  0
159B0:  CALL   4FF8
159B4:  MOVLB  2
....................          } 
....................  
....................          fprintf(COM_A, "@RST\r\n"); 
159B6:  MOVLW  EE
159B8:  MOVWF  FF6
159BA:  MOVLW  1A
159BC:  MOVWF  FF7
159BE:  MOVLW  00
159C0:  MOVWF  FF8
159C2:  CLRF   1B
159C4:  BTFSC  FF2.7
159C6:  BSF    1B.7
159C8:  BCF    FF2.7
159CA:  MOVLB  0
159CC:  CALL   0E30
159D0:  BTFSC  1B.7
159D2:  BSF    FF2.7
....................          reset_cpu(); 
159D4:  RESET
....................       } 
159D6:  BRA    159E2
159D8:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
159DA:  DECFSZ x65,W
159DC:  BRA    159E4
....................          { 
....................             initilizeSleepState(); 
159DE:  MOVLB  0
159E0:  RCALL  15804
159E2:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
159E4:  MOVLW  00
159E6:  BTFSC  49.0
159E8:  MOVLW  01
159EA:  MOVWF  01
159EC:  MOVLB  0
159EE:  GOTO   159F8 (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
159F2:  RCALL  1579A
....................    initilizeSleepState(); 
159F4:  RCALL  15804
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
159F6:  BRA    1591A
159F8:  DECFSZ 01,W
159FA:  BRA    15A00
....................       { 
....................          rtc_alarm = FALSE; 
159FC:  BCF    49.0
....................          break; 
159FE:  BRA    15A06
....................       } 
....................  
....................       blip(); 
15A00:  RCALL  15826
....................       blip(); 
15A02:  RCALL  15826
15A04:  BRA    159F6
....................    } 
15A06:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0AAF4:  MOVF   FD0,W
0AAF6:  ANDLW  0F
0AAF8:  BTFSS  FD0.4
0AAFA:  MOVLW  00
0AAFC:  BSF    FD0.0
0AAFE:  BSF    FD0.1
0AB00:  BSF    FD0.4
0AB02:  BSF    FD8.3
0AB04:  BSF    FD8.4
0AB06:  ADDLW  F0
0AB08:  BTFSC  FD8.0
0AB0A:  BRA    ACDA
0AB0C:  ADDLW  10
0AB0E:  GOTO   ACDE
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0AB12:  MOVLW  F6
0AB14:  MOVWF  FF6
0AB16:  MOVLW  1A
0AB18:  MOVWF  FF7
0AB1A:  MOVLW  00
0AB1C:  MOVWF  FF8
0AB1E:  CLRF   1B
0AB20:  BTFSC  FF2.7
0AB22:  BSF    1B.7
0AB24:  BCF    FF2.7
0AB26:  CALL   0E30
0AB2A:  BTFSC  1B.7
0AB2C:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0AB2E:  MOVLW  01
0AB30:  MOVWF  1E
0AB32:  MOVLW  A3
0AB34:  MOVWF  1D
0AB36:  MOVLW  FE
0AB38:  MOVWF  FF6
0AB3A:  MOVLW  1A
0AB3C:  MOVWF  FF7
0AB3E:  MOVLW  00
0AB40:  MOVWF  FF8
0AB42:  CALL   5036
....................          record_event(); 
0AB46:  CALL   8410
....................          recovery(); 
0AB4A:  RCALL  A98E
....................          break; 
0AB4C:  BRA    ACDA
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AB4E:  MOVLW  1C
0AB50:  MOVWF  FF6
0AB52:  MOVLW  1B
0AB54:  MOVWF  FF7
0AB56:  MOVLW  00
0AB58:  MOVWF  FF8
0AB5A:  CLRF   1B
0AB5C:  BTFSC  FF2.7
0AB5E:  BSF    1B.7
0AB60:  BCF    FF2.7
0AB62:  CALL   0E30
0AB66:  BTFSC  1B.7
0AB68:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AB6A:  MOVLW  01
0AB6C:  MOVWF  1E
0AB6E:  MOVLW  A3
0AB70:  MOVWF  1D
0AB72:  MOVLW  24
0AB74:  MOVWF  FF6
0AB76:  MOVLW  1B
0AB78:  MOVWF  FF7
0AB7A:  MOVLW  00
0AB7C:  MOVWF  FF8
0AB7E:  CALL   5036
....................          record_event(); 
0AB82:  CALL   8410
....................          recovery(); 
0AB86:  RCALL  A98E
....................          break; 
0AB88:  BRA    ACDA
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0AB8A:  MOVLW  44
0AB8C:  MOVWF  FF6
0AB8E:  MOVLW  1B
0AB90:  MOVWF  FF7
0AB92:  MOVLW  00
0AB94:  MOVWF  FF8
0AB96:  CLRF   1B
0AB98:  BTFSC  FF2.7
0AB9A:  BSF    1B.7
0AB9C:  BCF    FF2.7
0AB9E:  CALL   0E30
0ABA2:  BTFSC  1B.7
0ABA4:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0ABA6:  MOVLW  01
0ABA8:  MOVWF  1E
0ABAA:  MOVLW  A3
0ABAC:  MOVWF  1D
0ABAE:  MOVLW  4C
0ABB0:  MOVWF  FF6
0ABB2:  MOVLW  1B
0ABB4:  MOVWF  FF7
0ABB6:  MOVLW  00
0ABB8:  MOVWF  FF8
0ABBA:  MOVLW  05
0ABBC:  MOVLB  8
0ABBE:  MOVWF  xC8
0ABC0:  MOVLB  0
0ABC2:  RCALL  A9FA
0ABC4:  MOVLW  10
0ABC6:  MOVWF  FE9
0ABC8:  MOVFF  26,8D4
0ABCC:  MOVFF  25,8D3
0ABD0:  RCALL  AA2C
0ABD2:  MOVLW  54
0ABD4:  MOVWF  FF6
0ABD6:  MOVLW  1B
0ABD8:  MOVWF  FF7
0ABDA:  MOVLW  00
0ABDC:  MOVWF  FF8
0ABDE:  MOVLW  20
0ABE0:  MOVLB  8
0ABE2:  MOVWF  xC8
0ABE4:  MOVLB  0
0ABE6:  RCALL  A9FA
....................          record_event(); 
0ABE8:  CALL   8410
....................          break; 
0ABEC:  BRA    ACDA
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0ABEE:  MOVLW  76
0ABF0:  MOVWF  FF6
0ABF2:  MOVLW  1B
0ABF4:  MOVWF  FF7
0ABF6:  MOVLW  00
0ABF8:  MOVWF  FF8
0ABFA:  CLRF   1B
0ABFC:  BTFSC  FF2.7
0ABFE:  BSF    1B.7
0AC00:  BCF    FF2.7
0AC02:  CALL   0E30
0AC06:  BTFSC  1B.7
0AC08:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0AC0A:  MOVLW  01
0AC0C:  MOVWF  1E
0AC0E:  MOVLW  A3
0AC10:  MOVWF  1D
0AC12:  MOVLW  7E
0AC14:  MOVWF  FF6
0AC16:  MOVLW  1B
0AC18:  MOVWF  FF7
0AC1A:  MOVLW  00
0AC1C:  MOVWF  FF8
0AC1E:  CALL   5036
....................          record_event(); 
0AC22:  CALL   8410
....................          break; 
0AC26:  BRA    ACDA
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0AC28:  MOVLW  A2
0AC2A:  MOVWF  FF6
0AC2C:  MOVLW  1B
0AC2E:  MOVWF  FF7
0AC30:  MOVLW  00
0AC32:  MOVWF  FF8
0AC34:  CLRF   1B
0AC36:  BTFSC  FF2.7
0AC38:  BSF    1B.7
0AC3A:  BCF    FF2.7
0AC3C:  CALL   0E30
0AC40:  BTFSC  1B.7
0AC42:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AC44:  MOVLW  01
0AC46:  MOVWF  1E
0AC48:  MOVLW  A3
0AC4A:  MOVWF  1D
0AC4C:  MOVLW  AA
0AC4E:  MOVWF  FF6
0AC50:  MOVLW  1B
0AC52:  MOVWF  FF7
0AC54:  MOVLW  00
0AC56:  MOVWF  FF8
0AC58:  CALL   5036
....................          record_event(); 
0AC5C:  CALL   8410
....................          recovery(); 
0AC60:  RCALL  A98E
....................          break; 
0AC62:  BRA    ACDA
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AC64:  MOVLW  C6
0AC66:  MOVWF  FF6
0AC68:  MOVLW  1B
0AC6A:  MOVWF  FF7
0AC6C:  MOVLW  00
0AC6E:  MOVWF  FF8
0AC70:  CLRF   1B
0AC72:  BTFSC  FF2.7
0AC74:  BSF    1B.7
0AC76:  BCF    FF2.7
0AC78:  CALL   0E30
0AC7C:  BTFSC  1B.7
0AC7E:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0AC80:  MOVLW  01
0AC82:  MOVWF  1E
0AC84:  MOVLW  A3
0AC86:  MOVWF  1D
0AC88:  MOVLW  CE
0AC8A:  MOVWF  FF6
0AC8C:  MOVLW  1B
0AC8E:  MOVWF  FF7
0AC90:  MOVLW  00
0AC92:  MOVWF  FF8
0AC94:  CALL   5036
....................          record_event(); 
0AC98:  CALL   8410
....................          recovery(); 
0AC9C:  RCALL  A98E
....................          break; 
0AC9E:  BRA    ACDA
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0ACA0:  MOVLW  F0
0ACA2:  MOVWF  FF6
0ACA4:  MOVLW  1B
0ACA6:  MOVWF  FF7
0ACA8:  MOVLW  00
0ACAA:  MOVWF  FF8
0ACAC:  CLRF   1B
0ACAE:  BTFSC  FF2.7
0ACB0:  BSF    1B.7
0ACB2:  BCF    FF2.7
0ACB4:  CALL   0E30
0ACB8:  BTFSC  1B.7
0ACBA:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0ACBC:  MOVLW  01
0ACBE:  MOVWF  1E
0ACC0:  MOVLW  A3
0ACC2:  MOVWF  1D
0ACC4:  MOVLW  F8
0ACC6:  MOVWF  FF6
0ACC8:  MOVLW  1B
0ACCA:  MOVWF  FF7
0ACCC:  MOVLW  00
0ACCE:  MOVWF  FF8
0ACD0:  CALL   5036
....................          record_event(); 
0ACD4:  CALL   8410
....................          recovery(); 
0ACD8:  RCALL  A98E
....................          break; 
....................       }         
....................    } 
0ACDA:  GOTO   1B224 (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02A36:  MOVLW  1E
02A38:  MOVLB  8
02A3A:  MOVWF  x74
02A3C:  MOVLB  0
02A3E:  RCALL  2948
02A40:  MOVFF  02,30
02A44:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02A48:  MOVLW  1C
02A4A:  MOVLB  8
02A4C:  MOVWF  x74
02A4E:  MOVLB  0
02A50:  RCALL  2948
02A52:  MOVFF  02,20
02A56:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02A5A:  MOVLW  16
02A5C:  MOVLB  8
02A5E:  MOVWF  x74
02A60:  MOVLB  0
02A62:  RCALL  2948
02A64:  MOVFF  02,22
02A68:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02A6C:  MOVLW  14
02A6E:  MOVLB  8
02A70:  MOVWF  x74
02A72:  MOVLB  0
02A74:  RCALL  2948
02A76:  MOVFF  02,24
02A7A:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02A7E:  MOVLB  8
02A80:  CLRF   x74
02A82:  MOVLB  0
02A84:  RCALL  2948
02A86:  MOVFF  02,26
02A8A:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02A8E:  MOVLW  18
02A90:  MOVLB  8
02A92:  MOVWF  x74
02A94:  MOVLB  0
02A96:  RCALL  2948
02A98:  MOVFF  02,28
02A9C:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02AA0:  MOVLW  02
02AA2:  MOVLB  8
02AA4:  MOVWF  x94
02AA6:  MOVLB  0
02AA8:  RCALL  29A2
02AAA:  CLRF   32
02AAC:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02AB0:  MOVLW  28
02AB2:  MOVLB  8
02AB4:  MOVWF  x94
02AB6:  MOVLB  0
02AB8:  RCALL  29A2
02ABA:  CLRF   34
02ABC:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02AC0:  MOVLW  12
02AC2:  MOVLB  8
02AC4:  MOVWF  x74
02AC6:  MOVLB  0
02AC8:  RCALL  2948
02ACA:  MOVFF  02,36
02ACE:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02AD2:  MOVLW  3A
02AD4:  MOVLB  8
02AD6:  MOVWF  x74
02AD8:  MOVLB  0
02ADA:  RCALL  2948
02ADC:  MOVFF  02,38
02AE0:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02AE4:  MOVLW  3C
02AE6:  MOVLB  8
02AE8:  MOVWF  x74
02AEA:  MOVLB  0
02AEC:  RCALL  2948
02AEE:  MOVFF  02,3A
02AF2:  MOVFF  01,39
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02AF6:  MOVLW  3E
02AF8:  MOVLB  8
02AFA:  MOVWF  x74
02AFC:  MOVLB  0
02AFE:  RCALL  2948
02B00:  MOVFF  02,3C
02B04:  MOVFF  01,3B
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02B08:  MOVLW  40
02B0A:  MOVLB  8
02B0C:  MOVWF  x74
02B0E:  MOVLB  0
02B10:  RCALL  2948
02B12:  MOVFF  02,3E
02B16:  MOVFF  01,3D
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02B1A:  MOVLW  42
02B1C:  MOVLB  8
02B1E:  MOVWF  x74
02B20:  MOVLB  0
02B22:  RCALL  2948
02B24:  MOVFF  02,40
02B28:  MOVFF  01,3F
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02B2C:  MOVLW  04
02B2E:  MOVLB  8
02B30:  MOVWF  x94
02B32:  MOVLB  0
02B34:  RCALL  29A2
02B36:  MOVFF  01,729
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02B3A:  MOVLB  8
02B3C:  CLRF   x63
02B3E:  MOVLW  44
02B40:  MOVWF  x62
02B42:  MOVLB  0
02B44:  RCALL  29C8
02B46:  MOVFF  03,3F4
02B4A:  MOVFF  02,3F3
02B4E:  MOVFF  01,3F2
02B52:  MOVFF  00,3F1
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02B56:  MOVLB  8
02B58:  CLRF   x63
02B5A:  MOVLW  48
02B5C:  MOVWF  x62
02B5E:  MOVLB  0
02B60:  RCALL  29C8
02B62:  MOVFF  03,3F8
02B66:  MOVFF  02,3F7
02B6A:  MOVFF  01,3F6
02B6E:  MOVFF  00,3F5
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02B72:  MOVLB  8
02B74:  CLRF   x63
02B76:  MOVLW  4C
02B78:  MOVWF  x62
02B7A:  MOVLB  0
02B7C:  RCALL  29C8
02B7E:  MOVFF  03,3FC
02B82:  MOVFF  02,3FB
02B86:  MOVFF  01,3FA
02B8A:  MOVFF  00,3F9
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02B8E:  MOVLB  8
02B90:  CLRF   x63
02B92:  MOVLW  52
02B94:  MOVWF  x62
02B96:  MOVLB  0
02B98:  RCALL  29C8
02B9A:  MOVFF  03,400
02B9E:  MOVFF  02,3FF
02BA2:  MOVFF  01,3FE
02BA6:  MOVFF  00,3FD
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02BAA:  MOVLB  8
02BAC:  CLRF   x63
02BAE:  MOVLW  56
02BB0:  MOVWF  x62
02BB2:  MOVLB  0
02BB4:  RCALL  29C8
02BB6:  MOVFF  03,404
02BBA:  MOVFF  02,403
02BBE:  MOVFF  01,402
02BC2:  MOVFF  00,401
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02BC6:  MOVLB  8
02BC8:  CLRF   x63
02BCA:  MOVLW  5A
02BCC:  MOVWF  x62
02BCE:  MOVLB  0
02BD0:  RCALL  29C8
02BD2:  MOVFF  03,408
02BD6:  MOVFF  02,407
02BDA:  MOVFF  01,406
02BDE:  MOVFF  00,405
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02BE2:  MOVLB  8
02BE4:  CLRF   x63
02BE6:  MOVLW  5E
02BE8:  MOVWF  x62
02BEA:  MOVLB  0
02BEC:  RCALL  29C8
02BEE:  MOVFF  03,40C
02BF2:  MOVFF  02,40B
02BF6:  MOVFF  01,40A
02BFA:  MOVFF  00,409
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02BFE:  MOVLB  8
02C00:  CLRF   x63
02C02:  MOVLW  62
02C04:  MOVWF  x62
02C06:  MOVLB  0
02C08:  RCALL  29C8
02C0A:  MOVFF  03,410
02C0E:  MOVFF  02,40F
02C12:  MOVFF  01,40E
02C16:  MOVFF  00,40D
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02C1A:  MOVLW  20
02C1C:  MOVLB  8
02C1E:  MOVWF  x74
02C20:  MOVLB  0
02C22:  RCALL  2948
02C24:  MOVFF  02,2A
02C28:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02C2C:  MOVLW  22
02C2E:  MOVLB  8
02C30:  MOVWF  x74
02C32:  MOVLB  0
02C34:  RCALL  2948
02C36:  MOVFF  02,2C
02C3A:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02C3E:  MOVLW  24
02C40:  MOVLB  8
02C42:  MOVWF  x74
02C44:  MOVLB  0
02C46:  RCALL  2948
02C48:  MOVFF  02,2E
02C4C:  MOVFF  01,2D
02C50:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DBA4:  MOVLW  1C
0DBA6:  MOVLB  8
0DBA8:  MOVWF  xCB
0DBAA:  CLRF   xCD
0DBAC:  CLRF   xCC
0DBAE:  MOVLB  0
0DBB0:  CALL   4F4C
....................    write16(ADDR_SAMPLE,0); 
0DBB4:  MOVLW  16
0DBB6:  MOVLB  8
0DBB8:  MOVWF  xCB
0DBBA:  CLRF   xCD
0DBBC:  CLRF   xCC
0DBBE:  MOVLB  0
0DBC0:  CALL   4F4C
....................    write16(ADDR_INTERVAL,60); 
0DBC4:  MOVLW  14
0DBC6:  MOVLB  8
0DBC8:  MOVWF  xCB
0DBCA:  CLRF   xCD
0DBCC:  MOVLW  3C
0DBCE:  MOVWF  xCC
0DBD0:  MOVLB  0
0DBD2:  CALL   4F4C
....................    write16(ADDR_SERIALNO,9999); 
0DBD6:  MOVLB  8
0DBD8:  CLRF   xCB
0DBDA:  MOVLW  27
0DBDC:  MOVWF  xCD
0DBDE:  MOVLW  0F
0DBE0:  MOVWF  xCC
0DBE2:  MOVLB  0
0DBE4:  CALL   4F4C
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DBE8:  MOVLW  18
0DBEA:  MOVLB  8
0DBEC:  MOVWF  xCB
0DBEE:  MOVLW  0D
0DBF0:  MOVWF  xCD
0DBF2:  MOVLW  20
0DBF4:  MOVWF  xCC
0DBF6:  MOVLB  0
0DBF8:  CALL   4F4C
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DBFC:  MOVLW  02
0DBFE:  MOVLB  8
0DC00:  MOVWF  x66
0DC02:  MOVLW  01
0DC04:  MOVWF  x67
0DC06:  MOVLB  0
0DC08:  CALL   3390
....................    write16(ADDR_MACRO_STEP, 0); 
0DC0C:  MOVLW  3A
0DC0E:  MOVLB  8
0DC10:  MOVWF  xCB
0DC12:  CLRF   xCD
0DC14:  CLRF   xCC
0DC16:  MOVLB  0
0DC18:  CALL   4F4C
....................    write16(ADDR_COM_ERR,3); 
0DC1C:  MOVLW  3C
0DC1E:  MOVLB  8
0DC20:  MOVWF  xCB
0DC22:  CLRF   xCD
0DC24:  MOVLW  03
0DC26:  MOVWF  xCC
0DC28:  MOVLB  0
0DC2A:  CALL   4F4C
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DC2E:  MOVLW  04
0DC30:  MOVLB  8
0DC32:  MOVWF  x66
0DC34:  MOVLW  0A
0DC36:  MOVWF  x67
0DC38:  MOVLB  0
0DC3A:  CALL   3390
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DC3E:  MOVLB  8
0DC40:  CLRF   x63
0DC42:  MOVLW  44
0DC44:  MOVWF  x62
0DC46:  CLRF   x67
0DC48:  CLRF   x66
0DC4A:  CLRF   x65
0DC4C:  MOVLW  7F
0DC4E:  MOVWF  x64
0DC50:  MOVLB  0
0DC52:  CALL   CA4A
....................    write_float(ADDR_CAL_C1,0); 
0DC56:  MOVLB  8
0DC58:  CLRF   x63
0DC5A:  MOVLW  48
0DC5C:  MOVWF  x62
0DC5E:  CLRF   x67
0DC60:  CLRF   x66
0DC62:  CLRF   x65
0DC64:  CLRF   x64
0DC66:  MOVLB  0
0DC68:  CALL   CA4A
....................    write_float(ADDR_CAL_M2,1); 
0DC6C:  MOVLB  8
0DC6E:  CLRF   x63
0DC70:  MOVLW  4C
0DC72:  MOVWF  x62
0DC74:  CLRF   x67
0DC76:  CLRF   x66
0DC78:  CLRF   x65
0DC7A:  MOVLW  7F
0DC7C:  MOVWF  x64
0DC7E:  MOVLB  0
0DC80:  CALL   CA4A
....................    write_float(ADDR_CAL_C2,0); 
0DC84:  MOVLB  8
0DC86:  CLRF   x63
0DC88:  MOVLW  52
0DC8A:  MOVWF  x62
0DC8C:  CLRF   x67
0DC8E:  CLRF   x66
0DC90:  CLRF   x65
0DC92:  CLRF   x64
0DC94:  MOVLB  0
0DC96:  CALL   CA4A
....................    write_float(ADDR_CAL_M3,1); 
0DC9A:  MOVLB  8
0DC9C:  CLRF   x63
0DC9E:  MOVLW  56
0DCA0:  MOVWF  x62
0DCA2:  CLRF   x67
0DCA4:  CLRF   x66
0DCA6:  CLRF   x65
0DCA8:  MOVLW  7F
0DCAA:  MOVWF  x64
0DCAC:  MOVLB  0
0DCAE:  CALL   CA4A
....................    write_float(ADDR_CAL_C3,0); 
0DCB2:  MOVLB  8
0DCB4:  CLRF   x63
0DCB6:  MOVLW  5A
0DCB8:  MOVWF  x62
0DCBA:  CLRF   x67
0DCBC:  CLRF   x66
0DCBE:  CLRF   x65
0DCC0:  CLRF   x64
0DCC2:  MOVLB  0
0DCC4:  CALL   CA4A
....................    write_float(ADDR_CAL_M4,1); 
0DCC8:  MOVLB  8
0DCCA:  CLRF   x63
0DCCC:  MOVLW  5E
0DCCE:  MOVWF  x62
0DCD0:  CLRF   x67
0DCD2:  CLRF   x66
0DCD4:  CLRF   x65
0DCD6:  MOVLW  7F
0DCD8:  MOVWF  x64
0DCDA:  MOVLB  0
0DCDC:  CALL   CA4A
....................    write_float(ADDR_CAL_C4,0);  
0DCE0:  MOVLB  8
0DCE2:  CLRF   x63
0DCE4:  MOVLW  62
0DCE6:  MOVWF  x62
0DCE8:  CLRF   x67
0DCEA:  CLRF   x66
0DCEC:  CLRF   x65
0DCEE:  CLRF   x64
0DCF0:  MOVLB  0
0DCF2:  CALL   CA4A
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0DCF6:  MOVLW  40
0DCF8:  MOVLB  8
0DCFA:  MOVWF  xCB
0DCFC:  MOVLW  4E
0DCFE:  MOVWF  xCD
0DD00:  MOVLW  20
0DD02:  MOVWF  xCC
0DD04:  MOVLB  0
0DD06:  CALL   4F4C
....................    write16(ADDR_D2_TEMP,20000); 
0DD0A:  MOVLW  42
0DD0C:  MOVLB  8
0DD0E:  MOVWF  xCB
0DD10:  MOVLW  4E
0DD12:  MOVWF  xCD
0DD14:  MOVLW  20
0DD16:  MOVWF  xCC
0DD18:  MOVLB  0
0DD1A:  CALL   4F4C
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0DD1E:  MOVLW  20
0DD20:  MOVLB  8
0DD22:  MOVWF  xCB
0DD24:  CLRF   xCD
0DD26:  CLRF   xCC
0DD28:  MOVLB  0
0DD2A:  CALL   4F4C
....................    write16(ADDR_VOLUME,22500);  
0DD2E:  MOVLW  22
0DD30:  MOVLB  8
0DD32:  MOVWF  xCB
0DD34:  MOVLW  57
0DD36:  MOVWF  xCD
0DD38:  MOVLW  E4
0DD3A:  MOVWF  xCC
0DD3C:  MOVLB  0
0DD3E:  CALL   4F4C
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0DD42:  MOVF   2F,W
0DD44:  SUBLW  02
0DD46:  BNZ   DD4C
0DD48:  MOVF   30,F
0DD4A:  BZ    DD60
0DD4C:  MOVLW  24
0DD4E:  MOVLB  8
0DD50:  MOVWF  xCB
0DD52:  CLRF   xCD
0DD54:  MOVLW  02
0DD56:  MOVWF  xCC
0DD58:  MOVLB  0
0DD5A:  CALL   4F4C
0DD5E:  BRA    DD72
....................    else write16(ADDR_PORT,1); 
0DD60:  MOVLW  24
0DD62:  MOVLB  8
0DD64:  MOVWF  xCB
0DD66:  CLRF   xCD
0DD68:  MOVLW  01
0DD6A:  MOVWF  xCC
0DD6C:  MOVLB  0
0DD6E:  CALL   4F4C
....................     
....................    write16(ADDR_DET_TYPE,1); 
0DD72:  MOVLW  26
0DD74:  MOVLB  8
0DD76:  MOVWF  xCB
0DD78:  CLRF   xCD
0DD7A:  MOVLW  01
0DD7C:  MOVWF  xCC
0DD7E:  MOVLB  0
0DD80:  CALL   4F4C
....................     
....................    init_nv_vars(); 
0DD84:  CALL   2A36
0DD88:  GOTO   DDA2 (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
124DA:  MOVLW  02
124DC:  MOVWF  FEA
124DE:  MOVLW  43
124E0:  MOVWF  FE9
124E2:  CLRF   00
124E4:  CLRF   02
124E6:  MOVLW  51
124E8:  MOVWF  01
124EA:  CALL   34A4
124EE:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F606:  MOVLW  03
0F608:  MOVWF  FEA
0F60A:  MOVLW  21
0F60C:  MOVWF  FE9
0F60E:  CLRF   00
0F610:  CLRF   02
0F612:  MOVLW  14
0F614:  MOVWF  01
0F616:  CALL   34A4
0F61A:  GOTO   F63A (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
13010:  MOVLB  8
13012:  CLRF   xB1
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
13014:  CLRF   FEA
13016:  MOVLW  4E
13018:  MOVWF  FE9
1301A:  CLRF   00
1301C:  CLRF   02
1301E:  MOVLW  14
13020:  MOVWF  01
13022:  MOVLB  0
13024:  CALL   34A4
....................  
....................    for(n=0; n<20; n++) { 
13028:  MOVLB  8
1302A:  CLRF   xB2
1302C:  MOVF   xB2,W
1302E:  SUBLW  13
13030:  BNC   13076
....................         c = data_buffer[string_pos];  
13032:  CLRF   03
13034:  MOVLB  2
13036:  MOVF   x94,W
13038:  ADDLW  63
1303A:  MOVWF  FE9
1303C:  MOVLW  00
1303E:  ADDWFC 03,W
13040:  MOVWF  FEA
13042:  MOVFF  FEF,8B1
....................         ++string_pos; 
13046:  INCF   x94,F
....................         if (c == '\0') return(1); // found end 
13048:  MOVLB  8
1304A:  MOVF   xB1,F
1304C:  BNZ   13054
1304E:  MOVLW  01
13050:  MOVWF  01
13052:  BRA    1307A
....................         if (c == ',')  return(0); // found seperator  
13054:  MOVF   xB1,W
13056:  SUBLW  2C
13058:  BNZ   13060
1305A:  MOVLW  00
1305C:  MOVWF  01
1305E:  BRA    1307A
....................         sub_string[n] = c; 
13060:  CLRF   03
13062:  MOVF   xB2,W
13064:  ADDLW  4E
13066:  MOVWF  FE9
13068:  MOVLW  00
1306A:  ADDWFC 03,W
1306C:  MOVWF  FEA
1306E:  MOVFF  8B1,FEF
13072:  INCF   xB2,F
13074:  BRA    1302C
....................    } 
....................     
....................    return(2); // failed = bad string 
13076:  MOVLW  02
13078:  MOVWF  01
1307A:  MOVLB  0
1307C:  GOTO   133A6 (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
132BA:  MOVLW  1C
132BC:  MOVWF  FF6
132BE:  MOVLW  1C
132C0:  MOVWF  FF7
132C2:  MOVLW  00
132C4:  MOVWF  FF8
132C6:  MOVLW  03
132C8:  MOVWF  FEA
132CA:  MOVLW  39
132CC:  MOVWF  FE9
132CE:  CALL   FB4C
132D2:  MOVF   01,W
132D4:  BZ    132E8
132D6:  XORLW  01
132D8:  BZ    13308
132DA:  XORLW  03
132DC:  BZ    13328
132DE:  XORLW  01
132E0:  BZ    13348
132E2:  XORLW  07
132E4:  BZ    13368
132E6:  BRA    13386
....................       case "NO3" : NO3_array[read_i] = result; 
132E8:  BCF    FD8.0
132EA:  MOVLB  3
132EC:  RLCF   x46,W
132EE:  CLRF   03
132F0:  ADDLW  47
132F2:  MOVWF  FE9
132F4:  MOVLW  03
132F6:  ADDWFC 03,W
132F8:  MOVWF  FEA
132FA:  MOVFF  8B2,FEC
132FE:  MOVF   FED,F
13300:  MOVFF  8B1,FEF
....................          break; 
13304:  MOVLB  0
13306:  BRA    13386
....................       case "NO2" : NO2_array[read_i] = result; 
13308:  BCF    FD8.0
1330A:  MOVLB  3
1330C:  RLCF   x46,W
1330E:  CLRF   03
13310:  ADDLW  59
13312:  MOVWF  FE9
13314:  MOVLW  03
13316:  ADDWFC 03,W
13318:  MOVWF  FEA
1331A:  MOVFF  8B2,FEC
1331E:  MOVF   FED,F
13320:  MOVFF  8B1,FEF
....................          break;    
13324:  MOVLB  0
13326:  BRA    13386
....................       case "PO4" : PO4_array[read_i] = result; 
13328:  BCF    FD8.0
1332A:  MOVLB  3
1332C:  RLCF   x46,W
1332E:  CLRF   03
13330:  ADDLW  6B
13332:  MOVWF  FE9
13334:  MOVLW  03
13336:  ADDWFC 03,W
13338:  MOVWF  FEA
1333A:  MOVFF  8B2,FEC
1333E:  MOVF   FED,F
13340:  MOVFF  8B1,FEF
....................          break; 
13344:  MOVLB  0
13346:  BRA    13386
....................       case "NH4" : NH4_array[read_i] = result; 
13348:  BCF    FD8.0
1334A:  MOVLB  3
1334C:  RLCF   x46,W
1334E:  CLRF   03
13350:  ADDLW  7D
13352:  MOVWF  FE9
13354:  MOVLW  03
13356:  ADDWFC 03,W
13358:  MOVWF  FEA
1335A:  MOVFF  8B2,FEC
1335E:  MOVF   FED,F
13360:  MOVFF  8B1,FEF
....................          break; 
13364:  MOVLB  0
13366:  BRA    13386
....................       case "SiO" : SiO_array[read_i] = result; 
13368:  BCF    FD8.0
1336A:  MOVLB  3
1336C:  RLCF   x46,W
1336E:  CLRF   03
13370:  ADDLW  8F
13372:  MOVWF  FE9
13374:  MOVLW  03
13376:  ADDWFC 03,W
13378:  MOVWF  FEA
1337A:  MOVFF  8B2,FEC
1337E:  MOVF   FED,F
13380:  MOVFF  8B1,FEF
....................          break; 
13384:  MOVLB  0
....................    } 
13386:  GOTO   133FE (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
1338A:  MOVLB  8
1338C:  CLRF   xAC
1338E:  CLRF   xAB
13390:  CLRF   xAE
13392:  CLRF   xAD
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
13394:  MOVLB  2
13396:  CLRF   x94
....................     
....................    for (n=0; n<11; ++n){ 
13398:  MOVLB  8
1339A:  CLRF   xAF
1339C:  MOVF   xAF,W
1339E:  SUBLW  0A
133A0:  BNC   133F2
....................       parsed = parse_string(); 
133A2:  MOVLB  0
133A4:  BRA    13010
133A6:  MOVFF  01,8B0
....................       if (parsed == 2) return(0); 
133AA:  MOVLB  8
133AC:  MOVF   xB0,W
133AE:  SUBLW  02
133B0:  BNZ   133BA
133B2:  MOVLW  00
133B4:  MOVWF  01
133B6:  MOVWF  02
133B8:  BRA    13408
....................       if (n==8) result = atol(sub_string); 
133BA:  MOVF   xAF,W
133BC:  SUBLW  08
133BE:  BNZ   133D4
133C0:  CLRF   xB2
133C2:  MOVLW  4E
133C4:  MOVWF  xB1
133C6:  MOVLB  0
133C8:  RCALL  130D6
133CA:  MOVFF  02,8AC
133CE:  MOVFF  01,8AB
133D2:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
133D4:  MOVF   xAF,W
133D6:  SUBLW  0A
133D8:  BNZ   133EE
133DA:  CLRF   xB2
133DC:  MOVLW  4E
133DE:  MOVWF  xB1
133E0:  MOVLB  0
133E2:  RCALL  130D6
133E4:  MOVFF  02,8AE
133E8:  MOVFF  01,8AD
133EC:  MOVLB  8
133EE:  INCF   xAF,F
133F0:  BRA    1339C
....................    } 
....................    load_parsed_data(result); 
133F2:  MOVFF  8AC,8B2
133F6:  MOVFF  8AB,8B1
133FA:  MOVLB  0
133FC:  BRA    132BA
....................    return (temp); 
133FE:  MOVLB  8
13400:  MOVFF  8AD,01
13404:  MOVFF  8AE,02
13408:  MOVLB  0
1340A:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D224:  CLRF   FEA
0D226:  MOVLW  63
0D228:  MOVWF  FE9
0D22A:  CLRF   00
0D22C:  CLRF   02
0D22E:  MOVLW  A0
0D230:  MOVWF  01
0D232:  CALL   34A4
0D236:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F61E:  MOVLW  03
0F620:  MOVWF  FEA
0F622:  MOVLW  39
0F624:  MOVWF  FE9
0F626:  MOVLW  00
0F628:  CALL   02E4
0F62C:  TBLRD*-
0F62E:  TBLRD*+
0F630:  MOVF   FF5,W
0F632:  MOVWF  FEE
0F634:  IORLW  00
0F636:  BNZ   F62E
....................  
....................    clear_flag_str(); 
0F638:  BRA    F606
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F63A:  MOVLW  08
0F63C:  MOVWF  1E
0F63E:  MOVLW  CA
0F640:  MOVWF  1D
0F642:  MOVLW  10
0F644:  MOVWF  FE9
0F646:  MOVFF  320,8D4
0F64A:  MOVFF  31F,8D3
0F64E:  CALL   AA2C
....................  
....................    if (macro_flag < 100) { 
0F652:  MOVLB  3
0F654:  MOVF   x20,F
0F656:  BNZ   F670
0F658:  MOVF   x1F,W
0F65A:  SUBLW  63
0F65C:  BNC   F670
....................       temp_str[3] = '\0'; 
0F65E:  MOVLB  8
0F660:  CLRF   xCD
....................       temp_str[2] = temp_str[1]; 
0F662:  MOVFF  8CB,8CC
....................       temp_str[1] = temp_str[0]; 
0F666:  MOVFF  8CA,8CB
....................       temp_str[0] = '0'; 
0F66A:  MOVLW  30
0F66C:  MOVWF  xCA
0F66E:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F670:  MOVLB  8
0F672:  MOVF   xCA,W
0F674:  XORLW  30
0F676:  MOVLB  0
0F678:  BZ    F69C
0F67A:  XORLW  01
0F67C:  BZ    F6C2
0F67E:  XORLW  03
0F680:  BZ    F6E8
0F682:  XORLW  01
0F684:  BZ    F70E
0F686:  XORLW  07
0F688:  BZ    F734
0F68A:  XORLW  01
0F68C:  BZ    F75A
0F68E:  XORLW  03
0F690:  BTFSC  FD8.2
0F692:  BRA    F780
0F694:  XORLW  01
0F696:  BTFSC  FD8.2
0F698:  BRA    F7A6
0F69A:  BRA    F7CE
....................       case '0' : strcopy(chem,"NO3"); 
0F69C:  MOVLW  03
0F69E:  MOVWF  FEA
0F6A0:  MOVLW  39
0F6A2:  MOVWF  FE9
0F6A4:  MOVLW  00
0F6A6:  CALL   02FC
0F6AA:  TBLRD*-
0F6AC:  TBLRD*+
0F6AE:  MOVF   FF5,W
0F6B0:  MOVWF  FEE
0F6B2:  IORLW  00
0F6B4:  BNZ   F6AC
....................                  wave_l=543; 
0F6B6:  MOVLW  02
0F6B8:  MOVLB  8
0F6BA:  MOVWF  xC9
0F6BC:  MOVLW  1F
0F6BE:  MOVWF  xC8
....................          break; 
0F6C0:  BRA    F7F2
....................       case '1' : strcopy(chem,"PO4"); 
0F6C2:  MOVLW  03
0F6C4:  MOVWF  FEA
0F6C6:  MOVLW  39
0F6C8:  MOVWF  FE9
0F6CA:  MOVLW  00
0F6CC:  CALL   0314
0F6D0:  TBLRD*-
0F6D2:  TBLRD*+
0F6D4:  MOVF   FF5,W
0F6D6:  MOVWF  FEE
0F6D8:  IORLW  00
0F6DA:  BNZ   F6D2
....................                  wave_l=880;       
0F6DC:  MOVLW  03
0F6DE:  MOVLB  8
0F6E0:  MOVWF  xC9
0F6E2:  MOVLW  70
0F6E4:  MOVWF  xC8
....................          break; 
0F6E6:  BRA    F7F2
....................       case '2' : strcopy(chem,"NH4"); 
0F6E8:  MOVLW  03
0F6EA:  MOVWF  FEA
0F6EC:  MOVLW  39
0F6EE:  MOVWF  FE9
0F6F0:  MOVLW  00
0F6F2:  CALL   032C
0F6F6:  TBLRD*-
0F6F8:  TBLRD*+
0F6FA:  MOVF   FF5,W
0F6FC:  MOVWF  FEE
0F6FE:  IORLW  00
0F700:  BNZ   F6F8
....................                  wave_l=660;       
0F702:  MOVLW  02
0F704:  MOVLB  8
0F706:  MOVWF  xC9
0F708:  MOVLW  94
0F70A:  MOVWF  xC8
....................          break; 
0F70C:  BRA    F7F2
....................       case '3' : strcopy(chem,"SiO"); 
0F70E:  MOVLW  03
0F710:  MOVWF  FEA
0F712:  MOVLW  39
0F714:  MOVWF  FE9
0F716:  MOVLW  00
0F718:  CALL   0344
0F71C:  TBLRD*-
0F71E:  TBLRD*+
0F720:  MOVF   FF5,W
0F722:  MOVWF  FEE
0F724:  IORLW  00
0F726:  BNZ   F71E
....................                  wave_l=810;       
0F728:  MOVLW  03
0F72A:  MOVLB  8
0F72C:  MOVWF  xC9
0F72E:  MOVLW  2A
0F730:  MOVWF  xC8
....................          break; 
0F732:  BRA    F7F2
....................       case '4' : strcopy(chem,"Ure"); 
0F734:  MOVLW  03
0F736:  MOVWF  FEA
0F738:  MOVLW  39
0F73A:  MOVWF  FE9
0F73C:  MOVLW  00
0F73E:  CALL   035C
0F742:  TBLRD*-
0F744:  TBLRD*+
0F746:  MOVF   FF5,W
0F748:  MOVWF  FEE
0F74A:  IORLW  00
0F74C:  BNZ   F744
....................                  wave_l=525;       
0F74E:  MOVLW  02
0F750:  MOVLB  8
0F752:  MOVWF  xC9
0F754:  MOVLW  0D
0F756:  MOVWF  xC8
....................          break; 
0F758:  BRA    F7F2
....................       case '5' : strcopy(chem,"NO2"); 
0F75A:  MOVLW  03
0F75C:  MOVWF  FEA
0F75E:  MOVLW  39
0F760:  MOVWF  FE9
0F762:  MOVLW  00
0F764:  CALL   0374
0F768:  TBLRD*-
0F76A:  TBLRD*+
0F76C:  MOVF   FF5,W
0F76E:  MOVWF  FEE
0F770:  IORLW  00
0F772:  BNZ   F76A
....................                  wave_l=543;       
0F774:  MOVLW  02
0F776:  MOVLB  8
0F778:  MOVWF  xC9
0F77A:  MOVLW  1F
0F77C:  MOVWF  xC8
....................          break; 
0F77E:  BRA    F7F2
....................       case '6' : strcopy(chem,"Fe_"); 
0F780:  MOVLW  03
0F782:  MOVWF  FEA
0F784:  MOVLW  39
0F786:  MOVWF  FE9
0F788:  MOVLW  00
0F78A:  CALL   038C
0F78E:  TBLRD*-
0F790:  TBLRD*+
0F792:  MOVF   FF5,W
0F794:  MOVWF  FEE
0F796:  IORLW  00
0F798:  BNZ   F790
....................                  wave_l=543;       
0F79A:  MOVLW  02
0F79C:  MOVLB  8
0F79E:  MOVWF  xC9
0F7A0:  MOVLW  1F
0F7A2:  MOVWF  xC8
....................          break; 
0F7A4:  BRA    F7F2
....................       case '7' : strcopy(chem,"Cl_"); 
0F7A6:  MOVLW  03
0F7A8:  MOVWF  FEA
0F7AA:  MOVLW  39
0F7AC:  MOVWF  FE9
0F7AE:  MOVLW  00
0F7B0:  CALL   03A4
0F7B4:  TBLRD*-
0F7B6:  TBLRD*+
0F7B8:  MOVF   FF5,W
0F7BA:  MOVWF  FEE
0F7BC:  IORLW  00
0F7BE:  BNZ   F7B6
....................                  wave_l=560;       
0F7C0:  MOVLW  02
0F7C2:  MOVLB  8
0F7C4:  MOVWF  xC9
0F7C6:  MOVLW  30
0F7C8:  MOVWF  xC8
....................          break; 
0F7CA:  BRA    F7F2
0F7CC:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0F7CE:  MOVLW  03
0F7D0:  MOVWF  FEA
0F7D2:  MOVLW  39
0F7D4:  MOVWF  FE9
0F7D6:  MOVLW  00
0F7D8:  CALL   02E4
0F7DC:  TBLRD*-
0F7DE:  TBLRD*+
0F7E0:  MOVF   FF5,W
0F7E2:  MOVWF  FEE
0F7E4:  IORLW  00
0F7E6:  BNZ   F7DE
....................                  wave_l=999;       
0F7E8:  MOVLW  03
0F7EA:  MOVLB  8
0F7EC:  MOVWF  xC9
0F7EE:  MOVLW  E7
0F7F0:  MOVWF  xC8
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0F7F2:  MOVF   xCB,W
0F7F4:  XORLW  31
0F7F6:  MOVLB  0
0F7F8:  BZ    F818
0F7FA:  XORLW  03
0F7FC:  BZ    F834
0F7FE:  XORLW  01
0F800:  BZ    F850
0F802:  XORLW  07
0F804:  BZ    F86C
0F806:  XORLW  01
0F808:  BZ    F888
0F80A:  XORLW  03
0F80C:  BZ    F8A4
0F80E:  XORLW  01
0F810:  BZ    F8C0
0F812:  XORLW  0F
0F814:  BZ    F8DC
0F816:  BRA    F8F8
....................       case '1' : strcopy(anal,"Smp"); 
0F818:  MOVLW  03
0F81A:  MOVWF  FEA
0F81C:  MOVLW  3E
0F81E:  MOVWF  FE9
0F820:  MOVLW  00
0F822:  CALL   03BC
0F826:  TBLRD*-
0F828:  TBLRD*+
0F82A:  MOVF   FF5,W
0F82C:  MOVWF  FEE
0F82E:  IORLW  00
0F830:  BNZ   F828
....................          break; 
0F832:  BRA    F912
....................       case '2' : strcopy(anal,"Std"); 
0F834:  MOVLW  03
0F836:  MOVWF  FEA
0F838:  MOVLW  3E
0F83A:  MOVWF  FE9
0F83C:  MOVLW  00
0F83E:  CALL   03D4
0F842:  TBLRD*-
0F844:  TBLRD*+
0F846:  MOVF   FF5,W
0F848:  MOVWF  FEE
0F84A:  IORLW  00
0F84C:  BNZ   F844
....................          break; 
0F84E:  BRA    F912
....................       case '3' : strcopy(anal,"Cmb"); 
0F850:  MOVLW  03
0F852:  MOVWF  FEA
0F854:  MOVLW  3E
0F856:  MOVWF  FE9
0F858:  MOVLW  00
0F85A:  CALL   03EC
0F85E:  TBLRD*-
0F860:  TBLRD*+
0F862:  MOVF   FF5,W
0F864:  MOVWF  FEE
0F866:  IORLW  00
0F868:  BNZ   F860
....................          break; 
0F86A:  BRA    F912
....................       case '4' : strcopy(anal,"Tst"); 
0F86C:  MOVLW  03
0F86E:  MOVWF  FEA
0F870:  MOVLW  3E
0F872:  MOVWF  FE9
0F874:  MOVLW  00
0F876:  CALL   0404
0F87A:  TBLRD*-
0F87C:  TBLRD*+
0F87E:  MOVF   FF5,W
0F880:  MOVWF  FEE
0F882:  IORLW  00
0F884:  BNZ   F87C
....................          break; 
0F886:  BRA    F912
....................       case '5' : strcopy(anal,"Rbl"); 
0F888:  MOVLW  03
0F88A:  MOVWF  FEA
0F88C:  MOVLW  3E
0F88E:  MOVWF  FE9
0F890:  MOVLW  00
0F892:  CALL   041C
0F896:  TBLRD*-
0F898:  TBLRD*+
0F89A:  MOVF   FF5,W
0F89C:  MOVWF  FEE
0F89E:  IORLW  00
0F8A0:  BNZ   F898
....................          break; 
0F8A2:  BRA    F912
....................       case '6' : strcopy(anal,"Cal"); 
0F8A4:  MOVLW  03
0F8A6:  MOVWF  FEA
0F8A8:  MOVLW  3E
0F8AA:  MOVWF  FE9
0F8AC:  MOVLW  00
0F8AE:  CALL   0434
0F8B2:  TBLRD*-
0F8B4:  TBLRD*+
0F8B6:  MOVF   FF5,W
0F8B8:  MOVWF  FEE
0F8BA:  IORLW  00
0F8BC:  BNZ   F8B4
....................          break; 
0F8BE:  BRA    F912
....................       case '7' : strcopy(anal,"Fls"); 
0F8C0:  MOVLW  03
0F8C2:  MOVWF  FEA
0F8C4:  MOVLW  3E
0F8C6:  MOVWF  FE9
0F8C8:  MOVLW  00
0F8CA:  CALL   044C
0F8CE:  TBLRD*-
0F8D0:  TBLRD*+
0F8D2:  MOVF   FF5,W
0F8D4:  MOVWF  FEE
0F8D6:  IORLW  00
0F8D8:  BNZ   F8D0
....................          break; 
0F8DA:  BRA    F912
....................       case '8' : strcopy(anal,"Utl"); 
0F8DC:  MOVLW  03
0F8DE:  MOVWF  FEA
0F8E0:  MOVLW  3E
0F8E2:  MOVWF  FE9
0F8E4:  MOVLW  00
0F8E6:  CALL   0464
0F8EA:  TBLRD*-
0F8EC:  TBLRD*+
0F8EE:  MOVF   FF5,W
0F8F0:  MOVWF  FEE
0F8F2:  IORLW  00
0F8F4:  BNZ   F8EC
....................          break;     
0F8F6:  BRA    F912
....................       default  : strcopy(anal,"XXX"); 
0F8F8:  MOVLW  03
0F8FA:  MOVWF  FEA
0F8FC:  MOVLW  3E
0F8FE:  MOVWF  FE9
0F900:  MOVLW  00
0F902:  CALL   02E4
0F906:  TBLRD*-
0F908:  TBLRD*+
0F90A:  MOVF   FF5,W
0F90C:  MOVWF  FEE
0F90E:  IORLW  00
0F910:  BNZ   F908
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0F912:  MOVLB  8
0F914:  MOVF   xCC,W
0F916:  XORLW  31
0F918:  MOVLB  0
0F91A:  BZ    F944
0F91C:  XORLW  03
0F91E:  BZ    F964
0F920:  XORLW  01
0F922:  BZ    F986
0F924:  XORLW  07
0F926:  BZ    F9A8
0F928:  XORLW  01
0F92A:  BZ    F9CA
0F92C:  XORLW  03
0F92E:  BZ    F9EC
0F930:  XORLW  01
0F932:  BTFSC  FD8.2
0F934:  BRA    FA0E
0F936:  XORLW  0F
0F938:  BTFSC  FD8.2
0F93A:  BRA    FA30
0F93C:  XORLW  01
0F93E:  BTFSC  FD8.2
0F940:  BRA    FA52
0F942:  BRA    FA76
....................       case '1' : strcopy(read_t,"I0s"); 
0F944:  MOVLW  03
0F946:  MOVWF  FEA
0F948:  MOVLW  42
0F94A:  MOVWF  FE9
0F94C:  MOVLW  00
0F94E:  CALL   047C
0F952:  TBLRD*-
0F954:  TBLRD*+
0F956:  MOVF   FF5,W
0F958:  MOVWF  FEE
0F95A:  IORLW  00
0F95C:  BNZ   F954
....................                  read_i = 0; 
0F95E:  MOVLB  3
0F960:  CLRF   x46
....................          break; 
0F962:  BRA    FA94
....................       case '2' : strcopy(read_t,"I1s"); 
0F964:  MOVLW  03
0F966:  MOVWF  FEA
0F968:  MOVLW  42
0F96A:  MOVWF  FE9
0F96C:  MOVLW  00
0F96E:  CALL   0494
0F972:  TBLRD*-
0F974:  TBLRD*+
0F976:  MOVF   FF5,W
0F978:  MOVWF  FEE
0F97A:  IORLW  00
0F97C:  BNZ   F974
....................                  read_i = 1;       
0F97E:  MOVLW  01
0F980:  MOVLB  3
0F982:  MOVWF  x46
....................          break; 
0F984:  BRA    FA94
....................       case '3' : strcopy(read_t,"I0t"); 
0F986:  MOVLW  03
0F988:  MOVWF  FEA
0F98A:  MOVLW  42
0F98C:  MOVWF  FE9
0F98E:  MOVLW  00
0F990:  CALL   04AC
0F994:  TBLRD*-
0F996:  TBLRD*+
0F998:  MOVF   FF5,W
0F99A:  MOVWF  FEE
0F99C:  IORLW  00
0F99E:  BNZ   F996
....................                  read_i = 2;       
0F9A0:  MOVLW  02
0F9A2:  MOVLB  3
0F9A4:  MOVWF  x46
....................          break; 
0F9A6:  BRA    FA94
....................       case '4' : strcopy(read_t,"I1t"); 
0F9A8:  MOVLW  03
0F9AA:  MOVWF  FEA
0F9AC:  MOVLW  42
0F9AE:  MOVWF  FE9
0F9B0:  MOVLW  00
0F9B2:  CALL   04C4
0F9B6:  TBLRD*-
0F9B8:  TBLRD*+
0F9BA:  MOVF   FF5,W
0F9BC:  MOVWF  FEE
0F9BE:  IORLW  00
0F9C0:  BNZ   F9B8
....................                  read_i = 3;       
0F9C2:  MOVLW  03
0F9C4:  MOVLB  3
0F9C6:  MOVWF  x46
....................          break; 
0F9C8:  BRA    FA94
....................       case '5' : strcopy(read_t,"I0r"); 
0F9CA:  MOVLW  03
0F9CC:  MOVWF  FEA
0F9CE:  MOVLW  42
0F9D0:  MOVWF  FE9
0F9D2:  MOVLW  00
0F9D4:  CALL   04DC
0F9D8:  TBLRD*-
0F9DA:  TBLRD*+
0F9DC:  MOVF   FF5,W
0F9DE:  MOVWF  FEE
0F9E0:  IORLW  00
0F9E2:  BNZ   F9DA
....................                  read_i = 4;       
0F9E4:  MOVLW  04
0F9E6:  MOVLB  3
0F9E8:  MOVWF  x46
....................          break; 
0F9EA:  BRA    FA94
....................       case '6' : strcopy(read_t,"I1r"); 
0F9EC:  MOVLW  03
0F9EE:  MOVWF  FEA
0F9F0:  MOVLW  42
0F9F2:  MOVWF  FE9
0F9F4:  MOVLW  00
0F9F6:  CALL   04F4
0F9FA:  TBLRD*-
0F9FC:  TBLRD*+
0F9FE:  MOVF   FF5,W
0FA00:  MOVWF  FEE
0FA02:  IORLW  00
0FA04:  BNZ   F9FC
....................                  read_i = 5;       
0FA06:  MOVLW  05
0FA08:  MOVLB  3
0FA0A:  MOVWF  x46
....................          break; 
0FA0C:  BRA    FA94
....................       case '7' : strcopy(read_t,"I0u"); 
0FA0E:  MOVLW  03
0FA10:  MOVWF  FEA
0FA12:  MOVLW  42
0FA14:  MOVWF  FE9
0FA16:  MOVLW  00
0FA18:  CALL   050C
0FA1C:  TBLRD*-
0FA1E:  TBLRD*+
0FA20:  MOVF   FF5,W
0FA22:  MOVWF  FEE
0FA24:  IORLW  00
0FA26:  BNZ   FA1E
....................                  read_i = 6;       
0FA28:  MOVLW  06
0FA2A:  MOVLB  3
0FA2C:  MOVWF  x46
....................          break; 
0FA2E:  BRA    FA94
....................       case '8' : strcopy(read_t,"I1u"); 
0FA30:  MOVLW  03
0FA32:  MOVWF  FEA
0FA34:  MOVLW  42
0FA36:  MOVWF  FE9
0FA38:  MOVLW  00
0FA3A:  CALL   0524
0FA3E:  TBLRD*-
0FA40:  TBLRD*+
0FA42:  MOVF   FF5,W
0FA44:  MOVWF  FEE
0FA46:  IORLW  00
0FA48:  BNZ   FA40
....................                  read_i = 7;       
0FA4A:  MOVLW  07
0FA4C:  MOVLB  3
0FA4E:  MOVWF  x46
....................          break; 
0FA50:  BRA    FA94
....................       case '9' : strcopy(read_t,"Chk"); 
0FA52:  MOVLW  03
0FA54:  MOVWF  FEA
0FA56:  MOVLW  42
0FA58:  MOVWF  FE9
0FA5A:  MOVLW  00
0FA5C:  CALL   053C
0FA60:  TBLRD*-
0FA62:  TBLRD*+
0FA64:  MOVF   FF5,W
0FA66:  MOVWF  FEE
0FA68:  IORLW  00
0FA6A:  BNZ   FA62
....................                  read_i = 8;       
0FA6C:  MOVLW  08
0FA6E:  MOVLB  3
0FA70:  MOVWF  x46
....................          break;        
0FA72:  BRA    FA94
0FA74:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0FA76:  MOVLW  03
0FA78:  MOVWF  FEA
0FA7A:  MOVLW  42
0FA7C:  MOVWF  FE9
0FA7E:  MOVLW  00
0FA80:  CALL   0554
0FA84:  TBLRD*-
0FA86:  TBLRD*+
0FA88:  MOVF   FF5,W
0FA8A:  MOVWF  FEE
0FA8C:  IORLW  00
0FA8E:  BNZ   FA86
....................                  read_i = 0;       
0FA90:  MOVLB  3
0FA92:  CLRF   x46
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FA94:  MOVLW  03
0FA96:  MOVLB  8
0FA98:  MOVWF  xD6
0FA9A:  MOVLW  21
0FA9C:  MOVWF  xD5
0FA9E:  MOVLW  03
0FAA0:  MOVWF  xD8
0FAA2:  MOVLW  39
0FAA4:  MOVWF  xD7
0FAA6:  MOVLB  0
0FAA8:  CALL   5456
....................    strcat(flag_str, (char *)","); 
0FAAC:  MOVLW  2C
0FAAE:  MOVLB  8
0FAB0:  MOVWF  xD1
0FAB2:  CLRF   xD2
0FAB4:  MOVLW  03
0FAB6:  MOVWF  xD6
0FAB8:  MOVLW  21
0FABA:  MOVWF  xD5
0FABC:  MOVLW  08
0FABE:  MOVWF  xD8
0FAC0:  MOVLW  D1
0FAC2:  MOVWF  xD7
0FAC4:  MOVLB  0
0FAC6:  CALL   5456
....................    strcat(flag_str, anal); 
0FACA:  MOVLW  03
0FACC:  MOVLB  8
0FACE:  MOVWF  xD6
0FAD0:  MOVLW  21
0FAD2:  MOVWF  xD5
0FAD4:  MOVLW  03
0FAD6:  MOVWF  xD8
0FAD8:  MOVLW  3E
0FADA:  MOVWF  xD7
0FADC:  MOVLB  0
0FADE:  CALL   5456
....................    strcat(flag_str, (char *)","); 
0FAE2:  MOVLW  2C
0FAE4:  MOVLB  8
0FAE6:  MOVWF  xD1
0FAE8:  CLRF   xD2
0FAEA:  MOVLW  03
0FAEC:  MOVWF  xD6
0FAEE:  MOVLW  21
0FAF0:  MOVWF  xD5
0FAF2:  MOVLW  08
0FAF4:  MOVWF  xD8
0FAF6:  MOVLW  D1
0FAF8:  MOVWF  xD7
0FAFA:  MOVLB  0
0FAFC:  CALL   5456
....................    strcat(flag_str, read_t);   
0FB00:  MOVLW  03
0FB02:  MOVLB  8
0FB04:  MOVWF  xD6
0FB06:  MOVLW  21
0FB08:  MOVWF  xD5
0FB0A:  MOVLW  03
0FB0C:  MOVWF  xD8
0FB0E:  MOVLW  42
0FB10:  MOVWF  xD7
0FB12:  MOVLB  0
0FB14:  CALL   5456
....................     
....................    return wave_l; 
0FB18:  MOVLB  8
0FB1A:  MOVFF  8C8,01
0FB1E:  MOVFF  8C9,02
0FB22:  MOVLB  0
0FB24:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F0FA:  MOVF   43,W
0F0FC:  SUBLW  4B
0F0FE:  BTFSC  FD8.2
0F100:  MOVFF  44,2D2
....................    if (cmd=='L') detector_li = arg; 
0F104:  MOVF   43,W
0F106:  SUBLW  4C
0F108:  BNZ   F112
0F10A:  MOVFF  45,2D4
0F10E:  MOVFF  44,2D3
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F112:  MOVF   1F,W
0F114:  SUBLW  04
0F116:  BNZ   F1E0
0F118:  MOVF   20,F
0F11A:  BNZ   F1E0
0F11C:  MOVLW  32
0F11E:  MOVWF  FF6
0F120:  MOVLW  1C
0F122:  MOVWF  FF7
0F124:  MOVLW  00
0F126:  MOVWF  FF8
0F128:  CLRF   1B
0F12A:  BTFSC  FF2.7
0F12C:  BSF    1B.7
0F12E:  BCF    FF2.7
0F130:  MOVLW  06
0F132:  MOVLB  A
0F134:  MOVWF  x18
0F136:  MOVLB  0
0F138:  CALL   1006
0F13C:  BTFSC  1B.7
0F13E:  BSF    FF2.7
0F140:  CLRF   1B
0F142:  BTFSC  FF2.7
0F144:  BSF    1B.7
0F146:  BCF    FF2.7
0F148:  MOVFF  2D1,A18
0F14C:  MOVLW  1B
0F14E:  MOVLB  A
0F150:  MOVWF  x19
0F152:  MOVLB  0
0F154:  CALL   0F88
0F158:  BTFSC  1B.7
0F15A:  BSF    FF2.7
0F15C:  MOVLW  5D
0F15E:  BTFSS  F9E.4
0F160:  BRA    F15E
0F162:  MOVWF  FAD
0F164:  MOVLW  5B
0F166:  BTFSS  F9E.4
0F168:  BRA    F166
0F16A:  MOVWF  FAD
0F16C:  MOVF   43,W
0F16E:  BTFSS  F9E.4
0F170:  BRA    F16E
0F172:  MOVWF  FAD
0F174:  MOVLW  3E
0F176:  MOVWF  FF6
0F178:  MOVLW  1C
0F17A:  MOVWF  FF7
0F17C:  MOVLW  00
0F17E:  MOVWF  FF8
0F180:  CLRF   1B
0F182:  BTFSC  FF2.7
0F184:  BSF    1B.7
0F186:  BCF    FF2.7
0F188:  MOVLW  05
0F18A:  MOVLB  A
0F18C:  MOVWF  x18
0F18E:  MOVLB  0
0F190:  CALL   1006
0F194:  BTFSC  1B.7
0F196:  BSF    FF2.7
0F198:  MOVLW  41
0F19A:  MOVWF  FE9
0F19C:  CLRF   1B
0F19E:  BTFSC  FF2.7
0F1A0:  BSF    1B.7
0F1A2:  BCF    FF2.7
0F1A4:  MOVFF  47,A1B
0F1A8:  MOVFF  46,A1A
0F1AC:  MOVFF  45,A19
0F1B0:  MOVFF  44,A18
0F1B4:  CALL   10CC
0F1B8:  BTFSC  1B.7
0F1BA:  BSF    FF2.7
0F1BC:  MOVLW  46
0F1BE:  MOVWF  FF6
0F1C0:  MOVLW  1C
0F1C2:  MOVWF  FF7
0F1C4:  MOVLW  00
0F1C6:  MOVWF  FF8
0F1C8:  CLRF   1B
0F1CA:  BTFSC  FF2.7
0F1CC:  BSF    1B.7
0F1CE:  BCF    FF2.7
0F1D0:  MOVLW  03
0F1D2:  MOVLB  A
0F1D4:  MOVWF  x18
0F1D6:  MOVLB  0
0F1D8:  CALL   1006
0F1DC:  BTFSC  1B.7
0F1DE:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F1E0:  CALL   D774
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F1E4:  MOVLW  2F
0F1E6:  BTFSS  FA4.4
0F1E8:  BRA    F1E6
0F1EA:  MOVLB  F
0F1EC:  MOVWF  x1C
0F1EE:  MOVFF  2D1,8D0
0F1F2:  MOVLW  1B
0F1F4:  MOVLB  8
0F1F6:  MOVWF  xD1
0F1F8:  MOVLB  0
0F1FA:  CALL   D7BC
0F1FE:  MOVF   43,W
0F200:  BTFSS  FA4.4
0F202:  BRA    F200
0F204:  MOVLB  F
0F206:  MOVWF  x1C
0F208:  MOVLW  41
0F20A:  MOVWF  FE9
0F20C:  MOVFF  47,8D3
0F210:  MOVFF  46,8D2
0F214:  MOVFF  45,8D1
0F218:  MOVFF  44,8D0
0F21C:  MOVLB  0
0F21E:  BRA    F01A
0F220:  MOVLW  0D
0F222:  BTFSS  FA4.4
0F224:  BRA    F222
0F226:  MOVLB  F
0F228:  MOVWF  x1C
0F22A:  MOVLW  0A
0F22C:  BTFSS  FA4.4
0F22E:  BRA    F22C
0F230:  MOVWF  x1C
....................    multidrop_off(); 
0F232:  MOVLB  0
0F234:  CALL   D860
0F238:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12B30:  MOVLB  8
12B32:  CLRF   xC9
12B34:  BCF    xCA.0
12B36:  CLRF   xCB
12B38:  CLRF   xCF
12B3A:  CLRF   xCE
12B3C:  CLRF   xCD
12B3E:  CLRF   xCC
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12B40:  MOVLW  02
12B42:  MOVWF  FEA
12B44:  MOVLW  43
12B46:  MOVWF  FE9
12B48:  CLRF   00
12B4A:  CLRF   02
12B4C:  MOVLW  51
12B4E:  MOVWF  01
12B50:  MOVLB  0
12B52:  CALL   34A4
....................  
....................    det_cmd(); 
12B56:  CALL   F0FA
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12B5A:  CALL   54C8
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12B5E:  MOVLB  8
12B60:  MOVF   xCB,W
12B62:  SUBLW  02
12B64:  BZ    12BF8
12B66:  MOVF   xCB,W
12B68:  SUBLW  03
12B6A:  BZ    12BF8
12B6C:  MOVF   xC9,W
12B6E:  SUBLW  50
12B70:  BNC   12BF8
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12B72:  BTFSS  FA4.5
12B74:  BRA    12BAC
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12B76:  MOVLB  0
12B78:  RCALL  12B16
12B7A:  MOVFF  01,8C8
....................  
....................          if(startCharacterRcvd) 
12B7E:  MOVLB  8
12B80:  BTFSS  xCA.0
12B82:  BRA    12BA4
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12B84:  MOVF   xC9,W
12B86:  INCF   xC9,F
12B88:  CLRF   03
12B8A:  ADDLW  43
12B8C:  MOVWF  FE9
12B8E:  MOVLW  02
12B90:  ADDWFC 03,W
12B92:  MOVWF  FEA
12B94:  MOVFF  8C8,FEF
....................             if (CARRIAGE_RET == c) 
12B98:  MOVF   xC8,W
12B9A:  SUBLW  0D
12B9C:  BNZ   12BA2
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12B9E:  MOVLW  02
12BA0:  MOVWF  xCB
....................             } 
....................          } 
12BA2:  BRA    12BAC
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12BA4:  MOVF   xC8,W
12BA6:  SUBLW  40
12BA8:  BNZ   12BAC
....................             { 
....................                startCharacterRcvd = TRUE; 
12BAA:  BSF    xCA.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12BAC:  MOVLW  35
12BAE:  MOVWF  00
12BB0:  DECFSZ 00,F
12BB2:  BRA    12BB0
....................       if (tenMicroSecDelayCounter++ > 500000) 
12BB4:  MOVFF  8CF,8D3
12BB8:  MOVFF  8CE,8D2
12BBC:  MOVFF  8CD,8D1
12BC0:  MOVFF  8CC,8D0
12BC4:  MOVLW  01
12BC6:  ADDWF  xCC,F
12BC8:  BTFSC  FD8.0
12BCA:  INCF   xCD,F
12BCC:  BTFSC  FD8.2
12BCE:  INCF   xCE,F
12BD0:  BTFSC  FD8.2
12BD2:  INCF   xCF,F
12BD4:  MOVF   xD3,F
12BD6:  BNZ   12BF2
12BD8:  MOVF   xD2,W
12BDA:  SUBLW  06
12BDC:  BC    12BF6
12BDE:  XORLW  FF
12BE0:  BNZ   12BF2
12BE2:  MOVF   xD1,W
12BE4:  SUBLW  A0
12BE6:  BC    12BF6
12BE8:  XORLW  FF
12BEA:  BNZ   12BF2
12BEC:  MOVF   xD0,W
12BEE:  SUBLW  20
12BF0:  BC    12BF6
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12BF2:  MOVLW  03
12BF4:  MOVWF  xCB
....................       } 
12BF6:  BRA    12B60
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12BF8:  MOVF   xC9,W
12BFA:  SUBLW  50
12BFC:  BC    12C0E
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12BFE:  MOVF   xCB,W
12C00:  SUBLW  03
12C02:  BZ    12C0E
12C04:  MOVF   xCB,W
12C06:  SUBLW  02
12C08:  BZ    12C0E
....................       { 
....................          rcvDataType = SOME_DATA; 
12C0A:  MOVLW  01
12C0C:  MOVWF  xCB
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12C0E:  MOVLB  0
12C10:  CALL   54E8
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12C14:  MOVLB  8
12C16:  MOVFF  8CB,01
12C1A:  MOVLB  0
12C1C:  GOTO   12D94 (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
0FC54:  MOVF   1F,F
0FC56:  BNZ   FC76
0FC58:  MOVF   20,F
0FC5A:  BNZ   FC76
0FC5C:  MOVLB  8
0FC5E:  DECFSZ xC9,W
0FC60:  BRA    FC64
0FC62:  BRA    FC68
0FC64:  MOVLB  0
0FC66:  BRA    FC76
0FC68:  CLRF   FEA
0FC6A:  MOVLW  63
0FC6C:  MOVWF  FE9
0FC6E:  MOVLB  0
0FC70:  CALL   78D2
0FC74:  BRA    FC8A
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
0FC76:  MOVF   20,F
0FC78:  BNZ   FC80
0FC7A:  MOVF   1F,W
0FC7C:  SUBLW  03
0FC7E:  BC    FC8A
0FC80:  CLRF   FEA
0FC82:  MOVLW  63
0FC84:  MOVWF  FE9
0FC86:  CALL   78D2
....................  
....................    if (store==TRUE && sd_status==0) { 
0FC8A:  MOVLB  8
0FC8C:  DECFSZ xC8,W
0FC8E:  BRA    FCEE
0FC90:  MOVLB  2
0FC92:  MOVF   xD8,F
0FC94:  BTFSC  FD8.2
0FC96:  BRA    FC9C
0FC98:  MOVLB  8
0FC9A:  BRA    FCEE
....................        
....................       buffer_select = 0; 
0FC9C:  MOVLB  0
0FC9E:  CLRF   x62
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FCA0:  MOVLB  8
0FCA2:  CLRF   xCA
0FCA4:  MOVLB  0
0FCA6:  CALL   54FA
....................          append_data(file_ptr_raw_all); 
0FCAA:  MOVLW  02
0FCAC:  MOVLB  8
0FCAE:  MOVWF  xCB
0FCB0:  MOVLW  D9
0FCB2:  MOVWF  xCA
0FCB4:  MOVLB  0
0FCB6:  CALL   822E
....................       heartbeat(TRUE); 
0FCBA:  MOVLW  01
0FCBC:  MOVLB  8
0FCBE:  MOVWF  xCA
0FCC0:  MOVLB  0
0FCC2:  CALL   54FA
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FCC6:  MOVLB  8
0FCC8:  CLRF   xCA
0FCCA:  MOVLB  0
0FCCC:  CALL   54FA
....................          append_data(file_ptr_raw_new); 
0FCD0:  MOVLW  02
0FCD2:  MOVLB  8
0FCD4:  MOVWF  xCB
0FCD6:  MOVLW  E7
0FCD8:  MOVWF  xCA
0FCDA:  MOVLB  0
0FCDC:  CALL   822E
....................       heartbeat(TRUE); 
0FCE0:  MOVLW  01
0FCE2:  MOVLB  8
0FCE4:  MOVWF  xCA
0FCE6:  MOVLB  0
0FCE8:  CALL   54FA
0FCEC:  MOVLB  8
....................    } 
0FCEE:  MOVLB  0
0FCF0:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12C2C:  CLRF   xC2
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12C20:  MOVLW  0D
12C22:  MOVLB  8
12C24:  MOVWF  xAB
12C26:  MOVLW  0A
12C28:  MOVWF  xAC
12C2A:  CLRF   xAD
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12C2E:  MOVLB  0
12C30:  RCALL  124DA
....................    clear_data_buffer(); 
12C32:  CALL   D224
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12C36:  MOVLW  08
12C38:  MOVWF  FEA
12C3A:  MOVLW  AE
12C3C:  MOVWF  FE9
12C3E:  CLRF   00
12C40:  CLRF   02
12C42:  MOVLW  14
12C44:  MOVWF  01
12C46:  CALL   34A4
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12C4A:  MOVLW  01
12C4C:  MOVWF  FEA
12C4E:  MOVLW  A3
12C50:  MOVWF  FE9
12C52:  CLRF   00
12C54:  CLRF   02
12C56:  MOVLW  A0
12C58:  MOVWF  01
12C5A:  CALL   34A4
....................  
....................    time_stamp(); 
12C5E:  CALL   5392
....................    strcpy(data_buffer, time_stmp_str); 
12C62:  CLRF   FEA
12C64:  MOVLW  63
12C66:  MOVWF  FE9
12C68:  MOVLW  02
12C6A:  MOVWF  FE2
12C6C:  MOVLW  95
12C6E:  MOVWF  FE1
12C70:  MOVF   FE7,F
12C72:  MOVFF  FE6,FEE
12C76:  BNZ   12C70
....................    strcat(data_buffer, (char *)","); 
12C78:  MOVLW  2C
12C7A:  MOVLB  8
12C7C:  MOVWF  xC6
12C7E:  CLRF   xC7
12C80:  CLRF   xD6
12C82:  MOVLW  63
12C84:  MOVWF  xD5
12C86:  MOVLW  08
12C88:  MOVWF  xD8
12C8A:  MOVLW  C6
12C8C:  MOVWF  xD7
12C8E:  MOVLB  0
12C90:  CALL   5456
....................  
....................    flag_mod=fmod(macro_flag,10); 
12C94:  MOVFF  320,8F5
12C98:  MOVFF  31F,8F4
12C9C:  CALL   C61A
12CA0:  MOVFF  03,8CB
12CA4:  MOVFF  02,8CA
12CA8:  MOVFF  01,8C9
12CAC:  MOVFF  00,8C8
12CB0:  MOVFF  03,8CF
12CB4:  MOVFF  02,8CE
12CB8:  MOVFF  01,8CD
12CBC:  MOVFF  00,8CC
12CC0:  MOVLB  8
12CC2:  CLRF   xD3
12CC4:  CLRF   xD2
12CC6:  MOVLW  20
12CC8:  MOVWF  xD1
12CCA:  MOVLW  82
12CCC:  MOVWF  xD0
12CCE:  MOVLB  0
12CD0:  BRA    128D6
12CD2:  MOVFF  03,8F3
12CD6:  MOVFF  02,8F2
12CDA:  MOVFF  01,8F1
12CDE:  MOVFF  00,8F0
12CE2:  RCALL  124F0
12CE4:  MOVFF  01,8C5
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
12CE8:  MOVLB  8
12CEA:  DECFSZ xC5,W
12CEC:  BRA    12CF0
12CEE:  BRA    12CF6
12CF0:  MOVF   xC5,W
12CF2:  SUBLW  03
12CF4:  BNZ   12D14
....................    { 
....................       clear_proc_time_stmp_str(); 
12CF6:  MOVLB  0
12CF8:  BRA    12A3E
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
12CFA:  MOVLW  02
12CFC:  MOVWF  FEA
12CFE:  MOVLW  B3
12D00:  MOVWF  FE9
12D02:  MOVLW  02
12D04:  MOVWF  FE2
12D06:  MOVLW  95
12D08:  MOVWF  FE1
12D0A:  MOVF   FE7,F
12D0C:  MOVFF  FE6,FEE
12D10:  BNZ   12D0A
12D12:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
12D14:  MOVLB  0
12D16:  CALL   F61E
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12D1A:  MOVLB  8
12D1C:  CLRF   xC9
12D1E:  MOVLW  63
12D20:  MOVWF  xC8
12D22:  MOVLB  0
12D24:  RCALL  12A56
12D26:  MOVFF  02,03
12D2A:  MOVF   01,W
12D2C:  XORLW  FF
12D2E:  ADDLW  A1
12D30:  MOVLB  8
12D32:  MOVWF  xC8
12D34:  MOVLW  00
12D36:  SUBFWB 02,W
12D38:  MOVWF  xC9
12D3A:  MOVLW  01
12D3C:  SUBWF  xC8,F
12D3E:  MOVLW  00
12D40:  SUBWFB xC9,F
12D42:  CLRF   xCB
12D44:  MOVLW  63
12D46:  MOVWF  xCA
12D48:  MOVLW  03
12D4A:  MOVWF  xCD
12D4C:  MOVLW  21
12D4E:  MOVWF  xCC
12D50:  MOVFF  8C9,8CF
12D54:  MOVFF  8C8,8CE
12D58:  MOVLB  0
12D5A:  RCALL  12A92
....................    strcat(data_buffer, (char *)","); 
12D5C:  MOVLW  2C
12D5E:  MOVLB  8
12D60:  MOVWF  xC6
12D62:  CLRF   xC7
12D64:  CLRF   xD6
12D66:  MOVLW  63
12D68:  MOVWF  xD5
12D6A:  MOVLW  08
12D6C:  MOVWF  xD8
12D6E:  MOVLW  C6
12D70:  MOVWF  xD7
12D72:  MOVLB  0
12D74:  CALL   5456
....................     
....................    cmd = 'S'; 
12D78:  MOVLW  53
12D7A:  MOVWF  43
....................    arg = 1; 
12D7C:  CLRF   47
12D7E:  CLRF   46
12D80:  CLRF   45
12D82:  MOVLW  01
12D84:  MOVWF  44
....................  
....................    for(i = 0; i < 6; i++) 
12D86:  MOVLB  8
12D88:  CLRF   xC3
12D8A:  MOVF   xC3,W
12D8C:  SUBLW  05
12D8E:  BNC   12DA6
....................    { 
....................       rcvdData = get_slave_data(); 
12D90:  MOVLB  0
12D92:  BRA    12B30
12D94:  MOVFF  01,8C2
....................       if (DATA_COMPLETE == rcvdData) 
12D98:  MOVLB  8
12D9A:  MOVF   xC2,W
12D9C:  SUBLW  02
12D9E:  BNZ   12DA2
....................       { 
....................          break; 
12DA0:  BRA    12DA6
....................       } 
12DA2:  INCF   xC3,F
12DA4:  BRA    12D8A
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12DA6:  CLRF   xC9
12DA8:  MOVLW  63
12DAA:  MOVWF  xC8
12DAC:  MOVLB  0
12DAE:  RCALL  12A56
12DB0:  MOVFF  02,03
12DB4:  MOVF   01,W
12DB6:  XORLW  FF
12DB8:  ADDLW  A1
12DBA:  MOVLB  8
12DBC:  MOVWF  xC8
12DBE:  MOVLW  00
12DC0:  SUBFWB 02,W
12DC2:  MOVWF  xC9
12DC4:  MOVLW  01
12DC6:  SUBWF  xC8,F
12DC8:  MOVLW  00
12DCA:  SUBWFB xC9,F
12DCC:  CLRF   xCB
12DCE:  MOVLW  63
12DD0:  MOVWF  xCA
12DD2:  MOVLW  02
12DD4:  MOVWF  xCD
12DD6:  MOVLW  43
12DD8:  MOVWF  xCC
12DDA:  MOVFF  8C9,8CF
12DDE:  MOVFF  8C8,8CE
12DE2:  MOVLB  0
12DE4:  RCALL  12A92
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
12DE6:  MOVLW  02
12DE8:  MOVLB  8
12DEA:  MOVWF  xC9
12DEC:  MOVLW  43
12DEE:  MOVWF  xC8
12DF0:  MOVLB  0
12DF2:  RCALL  12A56
12DF4:  MOVFF  01,8C4
....................    if (rec_len > 0 && rec_len < 12) 
12DF8:  MOVLB  8
12DFA:  MOVF   xC4,F
12DFC:  BZ    12E0A
12DFE:  MOVF   xC4,W
12E00:  SUBLW  0B
12E02:  BNC   12E0A
....................    { 
....................       rcvdData = SHORT_DATA; 
12E04:  MOVLW  04
12E06:  MOVWF  xC2
....................    } 
12E08:  BRA    12E14
....................    else 
....................    { 
....................       if (rec_len > 30) 
12E0A:  MOVF   xC4,W
12E0C:  SUBLW  1E
12E0E:  BC    12E14
....................       { 
....................          rcvdData = LONG_DATA; 
12E10:  MOVLW  05
12E12:  MOVWF  xC2
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
12E14:  MOVLW  02
12E16:  SUBWF  xC2,W
12E18:  ADDLW  FC
12E1A:  BC    12E86
12E1C:  ADDLW  04
12E1E:  MOVLB  0
12E20:  GOTO   12FE8
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
12E24:  MOVLB  8
12E26:  BRA    12E86
12E28:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
12E2A:  MOVLW  08
12E2C:  MOVWF  1E
12E2E:  MOVLW  AE
12E30:  MOVWF  1D
12E32:  MOVLW  4A
12E34:  MOVWF  FF6
12E36:  MOVLW  1C
12E38:  MOVWF  FF7
12E3A:  MOVLW  00
12E3C:  MOVWF  FF8
12E3E:  CALL   5036
....................          break; 
12E42:  MOVLB  8
12E44:  BRA    12E86
12E46:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
12E48:  MOVLW  08
12E4A:  MOVWF  1E
12E4C:  MOVLW  AE
12E4E:  MOVWF  1D
12E50:  MOVLW  54
12E52:  MOVWF  FF6
12E54:  MOVLW  1C
12E56:  MOVWF  FF7
12E58:  MOVLW  00
12E5A:  MOVWF  FF8
12E5C:  CALL   5036
....................          break; 
12E60:  MOVLB  8
12E62:  BRA    12E86
12E64:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
12E66:  MOVLW  08
12E68:  MOVWF  1E
12E6A:  MOVLW  AE
12E6C:  MOVWF  1D
12E6E:  MOVLW  64
12E70:  MOVWF  FF6
12E72:  MOVLW  1C
12E74:  MOVWF  FF7
12E76:  MOVLW  00
12E78:  MOVWF  FF8
12E7A:  CALL   5036
....................          break; 
12E7E:  MOVLB  8
12E80:  BRA    12E86
12E82:  MOVLB  0
12E84:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12E86:  CLRF   xC9
12E88:  MOVLW  63
12E8A:  MOVWF  xC8
12E8C:  MOVLB  0
12E8E:  RCALL  12A56
12E90:  MOVFF  02,03
12E94:  MOVF   01,W
12E96:  XORLW  FF
12E98:  ADDLW  A1
12E9A:  MOVLB  8
12E9C:  MOVWF  xC8
12E9E:  MOVLW  00
12EA0:  SUBFWB 02,W
12EA2:  MOVWF  xC9
12EA4:  MOVLW  01
12EA6:  SUBWF  xC8,F
12EA8:  MOVLW  00
12EAA:  SUBWFB xC9,F
12EAC:  CLRF   xCB
12EAE:  MOVLW  63
12EB0:  MOVWF  xCA
12EB2:  MOVLW  08
12EB4:  MOVWF  xCD
12EB6:  MOVLW  AE
12EB8:  MOVWF  xCC
12EBA:  MOVFF  8C9,8CF
12EBE:  MOVFF  8C8,8CE
12EC2:  MOVLB  0
12EC4:  RCALL  12A92
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12EC6:  MOVLB  8
12EC8:  CLRF   xC9
12ECA:  MOVLW  63
12ECC:  MOVWF  xC8
12ECE:  MOVLB  0
12ED0:  RCALL  12A56
12ED2:  MOVFF  02,03
12ED6:  MOVF   01,W
12ED8:  XORLW  FF
12EDA:  ADDLW  A1
12EDC:  MOVLB  8
12EDE:  MOVWF  xC8
12EE0:  MOVLW  00
12EE2:  SUBFWB 02,W
12EE4:  MOVWF  xC9
12EE6:  MOVLW  01
12EE8:  SUBWF  xC8,F
12EEA:  MOVLW  00
12EEC:  SUBWFB xC9,F
12EEE:  CLRF   xCB
12EF0:  MOVLW  63
12EF2:  MOVWF  xCA
12EF4:  MOVLW  08
12EF6:  MOVWF  xCD
12EF8:  MOVLW  AB
12EFA:  MOVWF  xCC
12EFC:  MOVFF  8C9,8CF
12F00:  MOVFF  8C8,8CE
12F04:  MOVLB  0
12F06:  RCALL  12A92
....................  
....................    if(DATA_COMPLETE != rcvdData) 
12F08:  MOVLB  8
12F0A:  MOVF   xC2,W
12F0C:  SUBLW  02
12F0E:  BZ    12FCA
....................    {    //housekeeping 
....................       time_stamp(); 
12F10:  MOVLB  0
12F12:  CALL   5392
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
12F16:  MOVLW  01
12F18:  MOVWF  1E
12F1A:  MOVLW  A3
12F1C:  MOVWF  1D
12F1E:  MOVLW  74
12F20:  MOVWF  FF6
12F22:  MOVLW  1C
12F24:  MOVWF  FF7
12F26:  MOVLW  00
12F28:  MOVWF  FF8
12F2A:  MOVLW  0A
12F2C:  MOVLB  8
12F2E:  MOVWF  xC8
12F30:  MOVLB  0
12F32:  CALL   A9FA
12F36:  MOVFF  1E,FEA
12F3A:  MOVFF  1D,FE9
12F3E:  CLRF   FEF
12F40:  MOVLW  08
12F42:  MOVWF  FEA
12F44:  MOVLW  AE
12F46:  MOVWF  FE9
12F48:  CALL   FB26
12F4C:  MOVLW  80
12F4E:  MOVWF  FF6
12F50:  MOVLW  1C
12F52:  MOVWF  FF7
12F54:  MOVLW  00
12F56:  MOVWF  FF8
12F58:  MOVLW  06
12F5A:  MOVLB  8
12F5C:  MOVWF  xC8
12F5E:  MOVLB  0
12F60:  CALL   A9FA
12F64:  MOVFF  8C4,8CA
12F68:  MOVLW  1B
12F6A:  MOVLB  8
12F6C:  MOVWF  xCB
12F6E:  MOVLB  0
12F70:  CALL   51F8
12F74:  MOVLW  5D
12F76:  MOVLB  8
12F78:  MOVWF  xDC
12F7A:  MOVLB  0
12F7C:  CALL   5016
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
12F80:  MOVLW  01
12F82:  MOVLB  8
12F84:  MOVWF  xC9
12F86:  MOVLW  A3
12F88:  MOVWF  xC8
12F8A:  MOVLB  0
12F8C:  RCALL  12A56
12F8E:  MOVFF  02,03
12F92:  MOVF   01,W
12F94:  XORLW  FF
12F96:  ADDLW  A1
12F98:  MOVLB  8
12F9A:  MOVWF  xC8
12F9C:  MOVLW  00
12F9E:  SUBFWB 02,W
12FA0:  MOVWF  xC9
12FA2:  MOVLW  01
12FA4:  SUBWF  xC8,F
12FA6:  MOVLW  00
12FA8:  SUBWFB xC9,F
12FAA:  MOVLW  01
12FAC:  MOVWF  xCB
12FAE:  MOVLW  A3
12FB0:  MOVWF  xCA
12FB2:  CLRF   xCD
12FB4:  MOVLW  63
12FB6:  MOVWF  xCC
12FB8:  MOVFF  8C9,8CF
12FBC:  MOVFF  8C8,8CE
12FC0:  MOVLB  0
12FC2:  RCALL  12A92
....................       record_event(); 
12FC4:  CALL   8410
12FC8:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
12FCA:  MOVFF  8A9,8C8
12FCE:  MOVFF  8AA,8C9
12FD2:  MOVLB  0
12FD4:  CALL   FC54
....................  
....................    return (rcvdData); 
12FD8:  CLRF   03
12FDA:  MOVLB  8
12FDC:  MOVFF  8C2,01
12FE0:  MOVFF  03,02
12FE4:  MOVLB  0
12FE6:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
1340C:  MOVLB  8
1340E:  CLRF   xA1
13410:  MOVF   xA1,W
13412:  SUBLW  02
13414:  BTFSS  FD8.0
13416:  BRA    1352C
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
13418:  MOVFF  89F,8A9
1341C:  MOVFF  8A0,8AA
13420:  MOVLB  0
13422:  CALL   12C20
13426:  MOVFF  02,03
1342A:  MOVF   01,W
1342C:  SUBLW  02
1342E:  BNZ   1343C
13430:  MOVF   03,F
13432:  BNZ   1343C
....................       { 
....................          break; 
13434:  MOVLB  8
13436:  BRA    1352C
....................       } 
13438:  BRA    13528
1343A:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
1343C:  MOVLW  01
1343E:  MOVLB  8
13440:  ADDWF  xA1,W
13442:  MOVWF  xA2
13444:  MOVLW  8A
13446:  MOVWF  FF6
13448:  MOVLW  1C
1344A:  MOVWF  FF7
1344C:  MOVLW  00
1344E:  MOVWF  FF8
13450:  CLRF   1B
13452:  BTFSC  FF2.7
13454:  BSF    1B.7
13456:  BCF    FF2.7
13458:  MOVLW  05
1345A:  MOVLB  A
1345C:  MOVWF  x18
1345E:  MOVLB  0
13460:  CALL   1006
13464:  BTFSC  1B.7
13466:  BSF    FF2.7
13468:  CLRF   1B
1346A:  BTFSC  FF2.7
1346C:  BSF    1B.7
1346E:  BCF    FF2.7
13470:  MOVFF  8A2,A18
13474:  MOVLW  1B
13476:  MOVLB  A
13478:  MOVWF  x19
1347A:  MOVLB  0
1347C:  CALL   0F88
13480:  BTFSC  1B.7
13482:  BSF    FF2.7
13484:  MOVLW  0D
13486:  BTFSS  F9E.4
13488:  BRA    13486
1348A:  MOVWF  FAD
1348C:  MOVLW  0A
1348E:  BTFSS  F9E.4
13490:  BRA    1348E
13492:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
13494:  BCF    F90.7
....................          delay_ms(1000); 
13496:  MOVLW  04
13498:  MOVLB  8
1349A:  MOVWF  xA2
1349C:  MOVLW  FA
1349E:  MOVLB  9
134A0:  MOVWF  xC9
134A2:  MOVLB  0
134A4:  CALL   288E
134A8:  MOVLB  8
134AA:  DECFSZ xA2,F
134AC:  BRA    1349C
....................          output_bit(VDET,ON); 
134AE:  BSF    F90.7
....................          delay_ms(1000); 
134B0:  MOVLW  04
134B2:  MOVWF  xA2
134B4:  MOVLW  FA
134B6:  MOVLB  9
134B8:  MOVWF  xC9
134BA:  MOVLB  0
134BC:  CALL   288E
134C0:  MOVLB  8
134C2:  DECFSZ xA2,F
134C4:  BRA    134B4
....................          if (LightTargetFlag==0) 
134C6:  MOVLB  2
134C8:  MOVF   xD5,F
134CA:  BNZ   13512
....................          { 
....................           cmd='K'; 
134CC:  MOVLW  4B
134CE:  MOVWF  43
....................           arg=detector_ch; 
134D0:  CLRF   47
134D2:  CLRF   46
134D4:  CLRF   45
134D6:  MOVFF  2D2,44
....................           det_cmd(); 
134DA:  MOVLB  0
134DC:  CALL   F0FA
....................           delay_ms(1000); 
134E0:  MOVLW  04
134E2:  MOVLB  8
134E4:  MOVWF  xA2
134E6:  MOVLW  FA
134E8:  MOVLB  9
134EA:  MOVWF  xC9
134EC:  MOVLB  0
134EE:  CALL   288E
134F2:  MOVLB  8
134F4:  DECFSZ xA2,F
134F6:  BRA    134E6
....................           cmd='L'; 
134F8:  MOVLW  4C
134FA:  MOVWF  43
....................           arg=detector_li; 
134FC:  CLRF   47
134FE:  CLRF   46
13500:  MOVFF  2D4,45
13504:  MOVFF  2D3,44
....................           det_cmd(); 
13508:  MOVLB  0
1350A:  CALL   F0FA
....................          }  
1350E:  BRA    13526
13510:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
13512:  MOVLW  6C
13514:  MOVWF  43
....................           arg=1; 
13516:  CLRF   47
13518:  CLRF   46
1351A:  CLRF   45
1351C:  MOVLW  01
1351E:  MOVWF  44
....................           det_cmd(); 
13520:  MOVLB  0
13522:  CALL   F0FA
13526:  MOVLB  8
....................          }  
....................       } 
13528:  INCF   xA1,F
1352A:  BRA    13410
....................    } 
....................  
....................    parse_data(); 
1352C:  MOVLB  0
1352E:  RCALL  1338A
....................    data_available = TRUE; 
13530:  MOVLW  01
13532:  MOVLB  3
13534:  MOVWF  x37
....................    macro_flag = 900; 
13536:  MOVLW  03
13538:  MOVWF  x20
1353A:  MOVLW  84
1353C:  MOVWF  x1F
....................  
....................    return; 
1353E:  MOVLB  0
13540:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
138AC:  MOVLB  8
138AE:  CLRF   xAA
138B0:  CLRF   xA9
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
138B2:  MOVLB  0
138B4:  RCALL  1338A
138B6:  MOVFF  02,8AA
138BA:  MOVFF  01,8A9
....................    return (temp); 
138BE:  MOVLB  8
138C0:  MOVFF  8A9,01
138C4:  MOVFF  8AA,02
138C8:  MOVLB  0
138CA:  GOTO   139DC (RETURN)
.................... } 
....................  
.................... void det_temp() 
138CE:  MOVLB  8
138D0:  CLRF   xA6
138D2:  CLRF   xA5
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
138D4:  MOVLB  2
138D6:  MOVF   xD1,W
138D8:  XORLW  01
138DA:  MOVLB  0
138DC:  BZ    138E4
138DE:  XORLW  03
138E0:  BZ    138EE
138E2:  BRA    138F8
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
138E4:  MOVFF  3E,8A8
138E8:  MOVFF  3D,8A7
....................          break; 
138EC:  BRA    13904
....................       case 2 : target_temp = nv_d2_temp; 
138EE:  MOVFF  40,8A8
138F2:  MOVFF  3F,8A7
....................          break; 
138F6:  BRA    13904
....................       default : target_temp = 20000; 
138F8:  MOVLW  4E
138FA:  MOVLB  8
138FC:  MOVWF  xA8
138FE:  MOVLW  20
13900:  MOVWF  xA7
....................          break; 
13902:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
13904:  MOVLB  8
13906:  CLRF   xA4
13908:  MOVLW  3C
1390A:  MOVWF  xA3
....................    n = 0; 
1390C:  CLRF   xA2
1390E:  CLRF   xA1
....................    store=FALSE; 
13910:  CLRF   x9F
....................    display=FALSE; 
13912:  CLRF   xA0
....................  
....................    time_stamp(); 
13914:  MOVLB  0
13916:  CALL   5392
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
1391A:  MOVLW  01
1391C:  MOVWF  1E
1391E:  MOVLW  A3
13920:  MOVWF  1D
13922:  MOVLW  94
13924:  MOVWF  FF6
13926:  MOVLW  1C
13928:  MOVWF  FF7
1392A:  MOVLW  00
1392C:  MOVWF  FF8
1392E:  MOVLW  16
13930:  MOVLB  8
13932:  MOVWF  xC8
13934:  MOVLB  0
13936:  CALL   A9FA
1393A:  MOVLW  10
1393C:  MOVWF  FE9
1393E:  MOVFF  8A8,8D4
13942:  MOVFF  8A7,8D3
13946:  CALL   AA2C
1394A:  MOVLW  AD
1394C:  MOVWF  FF6
1394E:  MOVLW  1C
13950:  MOVWF  FF7
13952:  MOVLW  00
13954:  MOVWF  FF8
13956:  MOVLW  09
13958:  MOVLB  8
1395A:  MOVWF  xC8
1395C:  MOVLB  0
1395E:  CALL   A9FA
13962:  MOVLW  10
13964:  MOVWF  FE9
13966:  MOVFF  8A6,8D4
1396A:  MOVFF  8A5,8D3
1396E:  CALL   AA2C
13972:  MOVLW  B9
13974:  MOVWF  FF6
13976:  MOVLW  1C
13978:  MOVWF  FF7
1397A:  MOVLW  00
1397C:  MOVWF  FF8
1397E:  MOVLW  0B
13980:  MOVLB  8
13982:  MOVWF  xC8
13984:  MOVLB  0
13986:  CALL   A9FA
1398A:  MOVLW  10
1398C:  MOVWF  FE9
1398E:  MOVFF  8A2,8D4
13992:  MOVFF  8A1,8D3
13996:  CALL   AA2C
1399A:  MOVLW  C7
1399C:  MOVWF  FF6
1399E:  MOVLW  1C
139A0:  MOVWF  FF7
139A2:  MOVLW  00
139A4:  MOVWF  FF8
139A6:  MOVLW  03
139A8:  MOVLB  8
139AA:  MOVWF  xC8
139AC:  MOVLB  0
139AE:  CALL   A9FA
....................    record_event(); 
139B2:  CALL   8410
....................  
....................    for (n=1; n<t; ++n) 
139B6:  MOVLB  8
139B8:  CLRF   xA2
139BA:  MOVLW  01
139BC:  MOVWF  xA1
139BE:  MOVF   xA2,W
139C0:  SUBWF  xA4,W
139C2:  BNC   13A1E
139C4:  BNZ   139CC
139C6:  MOVF   xA3,W
139C8:  SUBWF  xA1,W
139CA:  BC    13A1E
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
139CC:  MOVFF  89F,8A9
139D0:  MOVFF  8A0,8AA
139D4:  MOVLB  0
139D6:  CALL   12C20
....................       current_temp=parse_temp(); 
139DA:  BRA    138AC
139DC:  MOVFF  02,8A6
139E0:  MOVFF  01,8A5
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
139E4:  MOVLB  8
139E6:  MOVF   xA8,W
139E8:  SUBWF  xA6,W
139EA:  BNC   139F4
139EC:  BNZ   139FC
139EE:  MOVF   xA7,W
139F0:  SUBWF  xA5,W
139F2:  BC    139FC
139F4:  MOVF   xA5,F
139F6:  BNZ   13A00
139F8:  MOVF   xA6,F
139FA:  BNZ   13A00
139FC:  BRA    13A1E
139FE:  BRA    13A16
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13A00:  MOVLW  0A
13A02:  MOVWF  xA9
13A04:  MOVLW  FA
13A06:  MOVLB  9
13A08:  MOVWF  xC9
13A0A:  MOVLB  0
13A0C:  CALL   288E
13A10:  MOVLB  8
13A12:  DECFSZ xA9,F
13A14:  BRA    13A04
13A16:  INCF   xA1,F
13A18:  BTFSC  FD8.2
13A1A:  INCF   xA2,F
13A1C:  BRA    139BE
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13A1E:  MOVLW  01
13A20:  MOVWF  1E
13A22:  MOVLW  A3
13A24:  MOVWF  1D
13A26:  MOVLW  CC
13A28:  MOVWF  FF6
13A2A:  MOVLW  1C
13A2C:  MOVWF  FF7
13A2E:  MOVLW  00
13A30:  MOVWF  FF8
13A32:  MOVLW  14
13A34:  MOVWF  xC8
13A36:  MOVLB  0
13A38:  CALL   A9FA
13A3C:  MOVLW  10
13A3E:  MOVWF  FE9
13A40:  MOVFF  8A8,8D4
13A44:  MOVFF  8A7,8D3
13A48:  CALL   AA2C
13A4C:  MOVLW  E3
13A4E:  MOVWF  FF6
13A50:  MOVLW  1C
13A52:  MOVWF  FF7
13A54:  MOVLW  00
13A56:  MOVWF  FF8
13A58:  MOVLW  09
13A5A:  MOVLB  8
13A5C:  MOVWF  xC8
13A5E:  MOVLB  0
13A60:  CALL   A9FA
13A64:  MOVLW  10
13A66:  MOVWF  FE9
13A68:  MOVFF  8A6,8D4
13A6C:  MOVFF  8A5,8D3
13A70:  CALL   AA2C
13A74:  MOVLW  EF
13A76:  MOVWF  FF6
13A78:  MOVLW  1C
13A7A:  MOVWF  FF7
13A7C:  MOVLW  00
13A7E:  MOVWF  FF8
13A80:  MOVLW  0B
13A82:  MOVLB  8
13A84:  MOVWF  xC8
13A86:  MOVLB  0
13A88:  CALL   A9FA
13A8C:  MOVLW  10
13A8E:  MOVWF  FE9
13A90:  MOVFF  8A2,8D4
13A94:  MOVFF  8A1,8D3
13A98:  CALL   AA2C
13A9C:  MOVLW  FD
13A9E:  MOVWF  FF6
13AA0:  MOVLW  1C
13AA2:  MOVWF  FF7
13AA4:  MOVLW  00
13AA6:  MOVWF  FF8
13AA8:  MOVLW  03
13AAA:  MOVLB  8
13AAC:  MOVWF  xC8
13AAE:  MOVLB  0
13AB0:  CALL   A9FA
....................    record_event();    
13AB4:  CALL   8410
13AB8:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
13584:  MOVLB  8
13586:  CLRF   xB2
13588:  CLRF   xB1
1358A:  CLRF   xB0
1358C:  CLRF   xAF
....................    set_adc_channel(1,VSS); 
1358E:  MOVLW  04
13590:  MOVWF  01
13592:  MOVF   FC2,W
13594:  ANDLW  83
13596:  IORWF  01,W
13598:  MOVWF  FC2
1359A:  MOVLW  00
1359C:  MOVWF  01
1359E:  MOVF   FC1,W
135A0:  ANDLW  F8
135A2:  IORWF  01,W
135A4:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
135A6:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
135A8:  MOVLW  01
135AA:  MOVWF  xAC
135AC:  MOVF   xAC,W
135AE:  SUBLW  32
135B0:  BNC   135D6
....................       reading=read_adc(); 
135B2:  BSF    FC2.1
135B4:  BTFSC  FC2.1
135B6:  BRA    135B4
135B8:  MOVFF  FC3,8B3
135BC:  MOVFF  FC4,8B4
135C0:  CLRF   xB5
135C2:  CLRF   xB6
....................       delay_ms(5); 
135C4:  MOVLW  05
135C6:  MOVLB  9
135C8:  MOVWF  xC9
135CA:  MOVLB  0
135CC:  CALL   288E
135D0:  MOVLB  8
135D2:  INCF   xAC,F
135D4:  BRA    135AC
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
135D6:  MOVLW  01
135D8:  MOVWF  xAC
135DA:  MOVF   xAC,W
135DC:  SUBLW  64
135DE:  BNC   1368C
....................       reading=read_adc(); 
135E0:  BSF    FC2.1
135E2:  BTFSC  FC2.1
135E4:  BRA    135E2
135E6:  MOVFF  FC3,8B3
135EA:  MOVFF  FC4,8B4
135EE:  CLRF   xB5
135F0:  CLRF   xB6
....................       result=(((result*(i-1))+reading)/i); 
135F2:  MOVLW  01
135F4:  SUBWF  xAC,W
135F6:  MOVWF  xB7
135F8:  MOVFF  8B2,9D6
135FC:  MOVFF  8B1,9D5
13600:  MOVFF  8B0,9D4
13604:  MOVFF  8AF,9D3
13608:  MOVLB  9
1360A:  CLRF   xDA
1360C:  CLRF   xD9
1360E:  CLRF   xD8
13610:  MOVWF  xD7
13612:  MOVLB  0
13614:  CALL   4772
13618:  MOVFF  03,8BA
1361C:  MOVFF  02,8B9
13620:  MOVFF  01,8B8
13624:  MOVFF  00,8B7
13628:  MOVLB  8
1362A:  MOVF   xB3,W
1362C:  ADDWF  xB7,F
1362E:  MOVF   xB4,W
13630:  ADDWFC xB8,F
13632:  MOVF   xB5,W
13634:  ADDWFC xB9,F
13636:  MOVF   xB6,W
13638:  ADDWFC xBA,F
1363A:  BCF    FD8.1
1363C:  CLRF   1B
1363E:  BTFSC  FF2.7
13640:  BSF    1B.7
13642:  BCF    FF2.7
13644:  MOVFF  8BA,A27
13648:  MOVFF  8B9,A26
1364C:  MOVFF  8B8,A25
13650:  MOVFF  8B7,A24
13654:  MOVLB  A
13656:  CLRF   x2B
13658:  CLRF   x2A
1365A:  CLRF   x29
1365C:  MOVFF  8AC,A28
13660:  MOVLB  0
13662:  CALL   1038
13666:  BTFSC  1B.7
13668:  BSF    FF2.7
1366A:  MOVFF  03,8B2
1366E:  MOVFF  02,8B1
13672:  MOVFF  01,8B0
13676:  MOVFF  00,8AF
....................       delay_ms(5); 
1367A:  MOVLW  05
1367C:  MOVLB  9
1367E:  MOVWF  xC9
13680:  MOVLB  0
13682:  CALL   288E
13686:  MOVLB  8
13688:  INCF   xAC,F
1368A:  BRA    135DA
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
1368C:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
1368E:  MOVFF  8B2,9D6
13692:  MOVFF  8B1,9D5
13696:  MOVFF  8B0,9D4
1369A:  MOVFF  8AF,9D3
1369E:  MOVLB  9
136A0:  CLRF   xDA
136A2:  CLRF   xD9
136A4:  MOVLW  10
136A6:  MOVWF  xD8
136A8:  MOVLW  25
136AA:  MOVWF  xD7
136AC:  MOVLB  0
136AE:  CALL   4772
136B2:  MOVFF  03,8BA
136B6:  MOVFF  02,8B9
136BA:  MOVFF  01,8B8
136BE:  MOVFF  00,8B7
136C2:  BCF    FD8.1
136C4:  CLRF   1B
136C6:  BTFSC  FF2.7
136C8:  BSF    1B.7
136CA:  BCF    FF2.7
136CC:  MOVFF  03,A27
136D0:  MOVFF  02,A26
136D4:  MOVFF  01,A25
136D8:  MOVFF  00,A24
136DC:  MOVLB  A
136DE:  CLRF   x2B
136E0:  CLRF   x2A
136E2:  CLRF   x29
136E4:  MOVLW  64
136E6:  MOVWF  x28
136E8:  MOVLB  0
136EA:  CALL   1038
136EE:  BTFSC  1B.7
136F0:  BSF    FF2.7
136F2:  MOVLW  21
136F4:  MOVLB  8
136F6:  SUBWF  00,W
136F8:  MOVWF  xAD
136FA:  MOVLW  50
136FC:  SUBWFB 01,W
136FE:  MOVWF  xAE
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
13700:  MOVFF  8AD,01
13704:  MOVFF  8AE,02
13708:  MOVLB  0
1370A:  GOTO   13770 (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
1371A:  CLRF   xA5
1371C:  CLRF   xA4
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
1370E:  MOVLW  0D
13710:  MOVLB  8
13712:  MOVWF  xA1
13714:  MOVLW  0A
13716:  MOVWF  xA2
13718:  CLRF   xA3
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
1371E:  MOVLB  0
13720:  CALL   124DA
....................    clear_data_buffer(); 
13724:  CALL   D224
....................  
....................    time_stamp(); 
13728:  CALL   5392
....................    strcpy(data_buffer, time_stmp_str); 
1372C:  CLRF   FEA
1372E:  MOVLW  63
13730:  MOVWF  FE9
13732:  MOVLW  02
13734:  MOVWF  FE2
13736:  MOVLW  95
13738:  MOVWF  FE1
1373A:  MOVF   FE7,F
1373C:  MOVFF  FE6,FEE
13740:  BNZ   1373A
....................    strcat(data_buffer, (char *)",Tmp,"); 
13742:  MOVLW  2C
13744:  MOVLB  8
13746:  MOVWF  xA6
13748:  MOVLW  54
1374A:  MOVWF  xA7
1374C:  MOVLW  6D
1374E:  MOVWF  xA8
13750:  MOVLW  70
13752:  MOVWF  xA9
13754:  MOVLW  2C
13756:  MOVWF  xAA
13758:  CLRF   xAB
1375A:  CLRF   xD6
1375C:  MOVLW  63
1375E:  MOVWF  xD5
13760:  MOVLW  08
13762:  MOVWF  xD8
13764:  MOVLW  A6
13766:  MOVWF  xD7
13768:  MOVLB  0
1376A:  CALL   5456
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
1376E:  BRA    13584
13770:  MOVFF  02,8A5
13774:  MOVFF  01,8A4
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
13778:  MOVLW  02
1377A:  MOVWF  1E
1377C:  MOVLW  43
1377E:  MOVWF  1D
13780:  MOVLW  45
13782:  MOVWF  FE9
13784:  MOVLB  8
13786:  CLRF   xCD
13788:  CLRF   xCC
1378A:  MOVFF  8A5,8CB
1378E:  MOVFF  8A4,8CA
13792:  MOVLW  03
13794:  MOVWF  xCE
13796:  MOVLB  0
13798:  CALL   5292
....................  
....................    strcat(slave_reply, endofline); 
1379C:  MOVLW  02
1379E:  MOVLB  8
137A0:  MOVWF  xD6
137A2:  MOVLW  43
137A4:  MOVWF  xD5
137A6:  MOVLW  08
137A8:  MOVWF  xD8
137AA:  MOVLW  A1
137AC:  MOVWF  xD7
137AE:  MOVLB  0
137B0:  CALL   5456
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
137B4:  MOVLB  8
137B6:  CLRF   xC9
137B8:  MOVLW  63
137BA:  MOVWF  xC8
137BC:  MOVLB  0
137BE:  CALL   12A56
137C2:  MOVFF  02,03
137C6:  MOVF   01,W
137C8:  XORLW  FF
137CA:  ADDLW  A1
137CC:  MOVLB  8
137CE:  MOVWF  xAC
137D0:  MOVLW  00
137D2:  SUBFWB 02,W
137D4:  MOVWF  xAD
137D6:  MOVLW  01
137D8:  SUBWF  xAC,F
137DA:  MOVLW  00
137DC:  SUBWFB xAD,F
137DE:  CLRF   xCB
137E0:  MOVLW  63
137E2:  MOVWF  xCA
137E4:  MOVLW  02
137E6:  MOVWF  xCD
137E8:  MOVLW  43
137EA:  MOVWF  xCC
137EC:  MOVFF  8AD,8CF
137F0:  MOVFF  8AC,8CE
137F4:  MOVLB  0
137F6:  CALL   12A92
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
137FA:  MOVF   1F,F
137FC:  BNZ   1381C
137FE:  MOVF   20,F
13800:  BNZ   1381C
13802:  MOVLB  8
13804:  DECFSZ xA0,W
13806:  BRA    1380A
13808:  BRA    1380E
1380A:  MOVLB  0
1380C:  BRA    1381C
1380E:  CLRF   FEA
13810:  MOVLW  63
13812:  MOVWF  FE9
13814:  MOVLB  0
13816:  CALL   78D2
1381A:  BRA    13830
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
1381C:  MOVF   20,F
1381E:  BNZ   13826
13820:  MOVF   1F,W
13822:  SUBLW  03
13824:  BC    13830
13826:  CLRF   FEA
13828:  MOVLW  63
1382A:  MOVWF  FE9
1382C:  CALL   78D2
....................  
....................    if (store == TRUE && sd_status==0) { 
13830:  MOVLB  8
13832:  DECFSZ x9F,W
13834:  BRA    13894
13836:  MOVLB  2
13838:  MOVF   xD8,F
1383A:  BTFSC  FD8.2
1383C:  BRA    13842
1383E:  MOVLB  8
13840:  BRA    13894
....................       buffer_select = 0; 
13842:  MOVLB  0
13844:  CLRF   x62
....................       
....................       heartbeat(FALSE); 
13846:  MOVLB  8
13848:  CLRF   xCA
1384A:  MOVLB  0
1384C:  CALL   54FA
....................          append_data(file_ptr_raw_all); 
13850:  MOVLW  02
13852:  MOVLB  8
13854:  MOVWF  xCB
13856:  MOVLW  D9
13858:  MOVWF  xCA
1385A:  MOVLB  0
1385C:  CALL   822E
....................       heartbeat(TRUE); 
13860:  MOVLW  01
13862:  MOVLB  8
13864:  MOVWF  xCA
13866:  MOVLB  0
13868:  CALL   54FA
....................        
....................       heartbeat(FALSE); 
1386C:  MOVLB  8
1386E:  CLRF   xCA
13870:  MOVLB  0
13872:  CALL   54FA
....................          append_data(file_ptr_raw_new); 
13876:  MOVLW  02
13878:  MOVLB  8
1387A:  MOVWF  xCB
1387C:  MOVLW  E7
1387E:  MOVWF  xCA
13880:  MOVLB  0
13882:  CALL   822E
....................       heartbeat(TRUE); 
13886:  MOVLW  01
13888:  MOVLB  8
1388A:  MOVWF  xCA
1388C:  MOVLB  0
1388E:  CALL   54FA
13892:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
13894:  MOVLW  03
13896:  MOVLB  3
13898:  MOVWF  x20
1389A:  MOVLW  84
1389C:  MOVWF  x1F
....................     
....................    return (temp); 
1389E:  MOVLB  8
138A0:  MOVFF  8A4,01
138A4:  MOVFF  8A5,02
138A8:  MOVLB  0
138AA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
123EC:  MOVLB  8
123EE:  MOVF   xA2,W
123F0:  ADDLW  FC
123F2:  BC    12430
123F4:  ADDLW  04
123F6:  MOVLB  0
123F8:  GOTO   12438
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
123FC:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
123FE:  BCF    F8C.1
....................          break; 
12400:  MOVLB  8
12402:  BRA    12430
....................       case 1 :  
....................             output_bit(HSW1, ON); 
12404:  BSF    F8C.0
....................          break; 
12406:  MOVLB  8
12408:  BRA    12430
....................       case 2 :  
....................             output_bit(HSW2, ON); 
1240A:  BSF    F8C.1
....................          break;  
1240C:  MOVLB  8
1240E:  BRA    12430
....................       case 3 :  
....................             output_bit(HSW1, ON); 
12410:  BSF    F8C.0
....................             delay_ms(500); 
12412:  MOVLW  02
12414:  MOVLB  8
12416:  MOVWF  xA3
12418:  MOVLW  FA
1241A:  MOVLB  9
1241C:  MOVWF  xC9
1241E:  MOVLB  0
12420:  CALL   288E
12424:  MOVLB  8
12426:  DECFSZ xA3,F
12428:  BRA    12418
....................             output_bit(HSW2, ON); 
1242A:  BSF    F8C.1
....................          break;             
1242C:  BRA    12430
1242E:  MOVLB  8
....................    } 
....................    heater_stat=set; 
12430:  MOVFF  8A2,4B1
12434:  MOVLB  0
12436:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F514:  MOVLW  08
0F516:  MOVLB  8
0F518:  MOVWF  xA9
0F51A:  CLRF   xA8
....................    LED_level_change=2048; 
0F51C:  MOVWF  xAB
0F51E:  CLRF   xAA
....................     
....................    for (i=0; i<12; i++){ 
0F520:  CLRF   xA7
0F522:  MOVF   xA7,W
0F524:  SUBLW  0B
0F526:  BNC   F59E
....................       DAC_set(1,LED_level); 
0F528:  MOVLW  01
0F52A:  MOVWF  xB0
0F52C:  MOVFF  8A9,8B2
0F530:  MOVFF  8A8,8B1
0F534:  MOVLB  0
0F536:  RCALL  F270
....................       LED_level_change = LED_level_change/2; 
0F538:  BCF    FD8.0
0F53A:  MOVLB  8
0F53C:  RRCF   xAB,F
0F53E:  RRCF   xAA,F
....................       ADC_average(200); 
0F540:  CLRF   xB1
0F542:  MOVLW  C8
0F544:  MOVWF  xB0
0F546:  MOVLB  0
0F548:  RCALL  F318
....................       output = ADC_val[2]; 
0F54A:  MOVFF  4A6,8AD
0F54E:  MOVFF  4A5,8AC
....................       temp = ADC_val[3]; 
0F552:  MOVFF  4A8,8AF
0F556:  MOVFF  4A7,8AE
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F55A:  MOVLB  8
0F55C:  MOVF   xA6,W
0F55E:  SUBWF  xAD,W
0F560:  BNC   F574
0F562:  BNZ   F56A
0F564:  MOVF   xAC,W
0F566:  SUBWF  xA5,W
0F568:  BC    F574
....................          LED_level=LED_level-LED_level_change; 
0F56A:  MOVF   xAA,W
0F56C:  SUBWF  xA8,F
0F56E:  MOVF   xAB,W
0F570:  SUBWFB xA9,F
....................       } 
0F572:  BRA    F59A
....................       else if(output<intensity){ 
0F574:  MOVF   xAD,W
0F576:  SUBWF  xA6,W
0F578:  BNC   F58C
0F57A:  BNZ   F582
0F57C:  MOVF   xA5,W
0F57E:  SUBWF  xAC,W
0F580:  BC    F58C
....................          LED_level=LED_level+LED_level_change; 
0F582:  MOVF   xAA,W
0F584:  ADDWF  xA8,F
0F586:  MOVF   xAB,W
0F588:  ADDWFC xA9,F
....................       } 
0F58A:  BRA    F59A
....................       else if(output==intensity) break; 
0F58C:  MOVF   xA5,W
0F58E:  SUBWF  xAC,W
0F590:  BNZ   F59A
0F592:  MOVF   xA6,W
0F594:  SUBWF  xAD,W
0F596:  BTFSC  FD8.2
0F598:  BRA    F59E
0F59A:  INCF   xA7,F
0F59C:  BRA    F522
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F59E:  MOVLW  01
0F5A0:  MOVWF  xB0
0F5A2:  MOVFF  8A9,8B2
0F5A6:  MOVFF  8A8,8B1
0F5AA:  MOVLB  0
0F5AC:  RCALL  F270
0F5AE:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F5B0:  MOVLW  01
0F5B2:  MOVLB  8
0F5B4:  MOVWF  xA4
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F5B6:  MOVF   xA2,F
0F5B8:  BNZ   F5BE
0F5BA:  MOVF   xA3,F
0F5BC:  BZ    F5D2
0F5BE:  MOVF   xA3,W
0F5C0:  SUBLW  0F
0F5C2:  BNC   F5D2
0F5C4:  MOVFF  8A3,8A6
0F5C8:  MOVFF  8A2,8A5
0F5CC:  MOVLB  0
0F5CE:  RCALL  F514
0F5D0:  MOVLB  8
....................   if(intensity == 0) { 
0F5D2:  MOVF   xA2,F
0F5D4:  BNZ   F5F8
0F5D6:  MOVF   xA3,F
0F5D8:  BNZ   F5F8
....................       DAC_set(1, 0); 
0F5DA:  MOVLW  01
0F5DC:  MOVWF  xB0
0F5DE:  CLRF   xB2
0F5E0:  CLRF   xB1
0F5E2:  MOVLB  0
0F5E4:  RCALL  F270
....................       DAC_set(2, 0); 
0F5E6:  MOVLW  02
0F5E8:  MOVLB  8
0F5EA:  MOVWF  xB0
0F5EC:  CLRF   xB2
0F5EE:  CLRF   xB1
0F5F0:  MOVLB  0
0F5F2:  RCALL  F270
....................    } 
0F5F4:  BRA    F5FC
0F5F6:  MOVLB  8
....................    else valid=FALSE; 
0F5F8:  CLRF   xA4
0F5FA:  MOVLB  0
....................    return(valid); 
0F5FC:  MOVLB  8
0F5FE:  MOVFF  8A4,01
0F602:  MOVLB  0
0F604:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FB86:  MOVLW  02
0FB88:  MOVWF  FF6
0FB8A:  MOVLW  1D
0FB8C:  MOVWF  FF7
0FB8E:  MOVLW  00
0FB90:  MOVWF  FF8
0FB92:  MOVLW  03
0FB94:  MOVWF  FEA
0FB96:  MOVLW  39
0FB98:  MOVWF  FE9
0FB9A:  RCALL  FB4C
0FB9C:  MOVF   01,W
0FB9E:  BZ    FBB2
0FBA0:  XORLW  01
0FBA2:  BZ    FBD2
0FBA4:  XORLW  03
0FBA6:  BZ    FBF2
0FBA8:  XORLW  01
0FBAA:  BZ    FC12
0FBAC:  XORLW  07
0FBAE:  BZ    FC32
0FBB0:  BRA    FC50
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FBB2:  BCF    FD8.0
0FBB4:  MOVLB  3
0FBB6:  RLCF   x46,W
0FBB8:  CLRF   03
0FBBA:  ADDLW  47
0FBBC:  MOVWF  FE9
0FBBE:  MOVLW  03
0FBC0:  ADDWFC 03,W
0FBC2:  MOVWF  FEA
0FBC4:  MOVFF  4A4,FEC
0FBC8:  MOVF   FED,F
0FBCA:  MOVFF  4A3,FEF
....................          break; 
0FBCE:  MOVLB  0
0FBD0:  BRA    FC50
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FBD2:  BCF    FD8.0
0FBD4:  MOVLB  3
0FBD6:  RLCF   x46,W
0FBD8:  CLRF   03
0FBDA:  ADDLW  59
0FBDC:  MOVWF  FE9
0FBDE:  MOVLW  03
0FBE0:  ADDWFC 03,W
0FBE2:  MOVWF  FEA
0FBE4:  MOVFF  4A4,FEC
0FBE8:  MOVF   FED,F
0FBEA:  MOVFF  4A3,FEF
....................          break;    
0FBEE:  MOVLB  0
0FBF0:  BRA    FC50
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FBF2:  BCF    FD8.0
0FBF4:  MOVLB  3
0FBF6:  RLCF   x46,W
0FBF8:  CLRF   03
0FBFA:  ADDLW  6B
0FBFC:  MOVWF  FE9
0FBFE:  MOVLW  03
0FC00:  ADDWFC 03,W
0FC02:  MOVWF  FEA
0FC04:  MOVFF  4A4,FEC
0FC08:  MOVF   FED,F
0FC0A:  MOVFF  4A3,FEF
....................          break; 
0FC0E:  MOVLB  0
0FC10:  BRA    FC50
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FC12:  BCF    FD8.0
0FC14:  MOVLB  3
0FC16:  RLCF   x46,W
0FC18:  CLRF   03
0FC1A:  ADDLW  7D
0FC1C:  MOVWF  FE9
0FC1E:  MOVLW  03
0FC20:  ADDWFC 03,W
0FC22:  MOVWF  FEA
0FC24:  MOVFF  4A4,FEC
0FC28:  MOVF   FED,F
0FC2A:  MOVFF  4A3,FEF
....................          break; 
0FC2E:  MOVLB  0
0FC30:  BRA    FC50
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FC32:  BCF    FD8.0
0FC34:  MOVLB  3
0FC36:  RLCF   x46,W
0FC38:  CLRF   03
0FC3A:  ADDLW  8F
0FC3C:  MOVWF  FE9
0FC3E:  MOVLW  03
0FC40:  ADDWFC 03,W
0FC42:  MOVWF  FEA
0FC44:  MOVFF  4A4,FEC
0FC48:  MOVF   FED,F
0FC4A:  MOVFF  4A3,FEF
....................          break; 
0FC4E:  MOVLB  0
....................    } 
0FC50:  GOTO   FF34 (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
0FCF2:  MOVFF  8A0,8B1
0FCF6:  MOVFF  89F,8B0
0FCFA:  CALL   F318
....................     
....................    v_supply = read_supply(); 
0FCFE:  CALL   5074
0FD02:  MOVFF  02,8A5
0FD06:  MOVFF  01,8A4
....................        
....................    RTC_reset_HT(); 
0FD0A:  CALL   3430
....................    RTC_read(); 
0FD0E:  CALL   32C2
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
0FD12:  RCALL  F61E
0FD14:  MOVFF  02,8A7
0FD18:  MOVFF  01,8A6
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
0FD1C:  MOVLB  8
0FD1E:  DECFSZ xA3,W
0FD20:  BRA    FD4A
0FD22:  MOVLW  10
0FD24:  MOVWF  FE9
0FD26:  CLRF   1B
0FD28:  BTFSC  FF2.7
0FD2A:  BSF    1B.7
0FD2C:  BCF    FF2.7
0FD2E:  MOVFF  4A6,A19
0FD32:  MOVFF  4A5,A18
0FD36:  MOVLB  0
0FD38:  CALL   1188
0FD3C:  BTFSC  1B.7
0FD3E:  BSF    FF2.7
0FD40:  MOVLW  2C
0FD42:  BTFSS  F9E.4
0FD44:  BRA    FD42
0FD46:  MOVWF  FAD
0FD48:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
0FD4A:  CLRF   1E
0FD4C:  MOVLW  63
0FD4E:  MOVWF  1D
0FD50:  MOVFF  726,8CA
0FD54:  MOVLW  01
0FD56:  MOVWF  xCB
0FD58:  MOVLB  0
0FD5A:  CALL   51F8
0FD5E:  MOVLW  2F
0FD60:  MOVLB  8
0FD62:  MOVWF  xDC
0FD64:  MOVLB  0
0FD66:  CALL   5016
0FD6A:  MOVFF  725,8CA
0FD6E:  MOVLW  01
0FD70:  MOVLB  8
0FD72:  MOVWF  xCB
0FD74:  MOVLB  0
0FD76:  CALL   51F8
0FD7A:  MOVLW  2F
0FD7C:  MOVLB  8
0FD7E:  MOVWF  xDC
0FD80:  MOVLB  0
0FD82:  CALL   5016
0FD86:  MOVFF  727,8CA
0FD8A:  MOVLW  01
0FD8C:  MOVLB  8
0FD8E:  MOVWF  xCB
0FD90:  MOVLB  0
0FD92:  CALL   51F8
0FD96:  MOVLW  20
0FD98:  MOVLB  8
0FD9A:  MOVWF  xDC
0FD9C:  MOVLB  0
0FD9E:  CALL   5016
0FDA2:  MOVFF  723,8CA
0FDA6:  MOVLW  01
0FDA8:  MOVLB  8
0FDAA:  MOVWF  xCB
0FDAC:  MOVLB  0
0FDAE:  CALL   51F8
0FDB2:  MOVLW  3A
0FDB4:  MOVLB  8
0FDB6:  MOVWF  xDC
0FDB8:  MOVLB  0
0FDBA:  CALL   5016
0FDBE:  MOVFF  722,8CA
0FDC2:  MOVLW  01
0FDC4:  MOVLB  8
0FDC6:  MOVWF  xCB
0FDC8:  MOVLB  0
0FDCA:  CALL   51F8
0FDCE:  MOVLW  3A
0FDD0:  MOVLB  8
0FDD2:  MOVWF  xDC
0FDD4:  MOVLB  0
0FDD6:  CALL   5016
0FDDA:  MOVFF  721,8CA
0FDDE:  MOVLW  01
0FDE0:  MOVLB  8
0FDE2:  MOVWF  xCB
0FDE4:  MOVLB  0
0FDE6:  CALL   51F8
0FDEA:  MOVLW  2C
0FDEC:  MOVLB  8
0FDEE:  MOVWF  xDC
0FDF0:  MOVLB  0
0FDF2:  CALL   5016
0FDF6:  MOVLW  04
0FDF8:  MOVWF  FE9
0FDFA:  MOVLB  8
0FDFC:  CLRF   xCD
0FDFE:  CLRF   xCC
0FE00:  MOVFF  8A5,8CB
0FE04:  MOVFF  8A4,8CA
0FE08:  MOVLW  02
0FE0A:  MOVWF  xCE
0FE0C:  MOVLB  0
0FE0E:  CALL   5292
0FE12:  MOVLW  2C
0FE14:  MOVLB  8
0FE16:  MOVWF  xDC
0FE18:  MOVLB  0
0FE1A:  CALL   5016
0FE1E:  MOVFF  1E,FEA
0FE22:  MOVFF  1D,FE9
0FE26:  CLRF   FEF
0FE28:  MOVLW  03
0FE2A:  MOVWF  FEA
0FE2C:  MOVLW  39
0FE2E:  MOVWF  FE9
0FE30:  RCALL  FB26
0FE32:  MOVLW  2C
0FE34:  MOVLB  8
0FE36:  MOVWF  xDC
0FE38:  MOVLB  0
0FE3A:  CALL   5016
0FE3E:  MOVFF  1E,FEA
0FE42:  MOVFF  1D,FE9
0FE46:  CLRF   FEF
0FE48:  MOVLW  03
0FE4A:  MOVWF  FEA
0FE4C:  MOVLW  3E
0FE4E:  MOVWF  FE9
0FE50:  RCALL  FB26
0FE52:  MOVLW  2C
0FE54:  MOVLB  8
0FE56:  MOVWF  xDC
0FE58:  MOVLB  0
0FE5A:  CALL   5016
0FE5E:  MOVFF  1E,FEA
0FE62:  MOVFF  1D,FE9
0FE66:  CLRF   FEF
0FE68:  MOVLW  03
0FE6A:  MOVWF  FEA
0FE6C:  MOVLW  42
0FE6E:  MOVWF  FE9
0FE70:  RCALL  FB26
0FE72:  MOVLW  2C
0FE74:  MOVLB  8
0FE76:  MOVWF  xDC
0FE78:  MOVLB  0
0FE7A:  CALL   5016
0FE7E:  MOVLW  10
0FE80:  MOVWF  FE9
0FE82:  MOVFF  26,8D4
0FE86:  MOVFF  25,8D3
0FE8A:  CALL   AA2C
0FE8E:  MOVLW  2C
0FE90:  MOVLB  8
0FE92:  MOVWF  xDC
0FE94:  MOVLB  0
0FE96:  CALL   5016
0FE9A:  MOVLW  10
0FE9C:  MOVWF  FE9
0FE9E:  MOVFF  8A7,8D4
0FEA2:  MOVFF  8A6,8D3
0FEA6:  CALL   AA2C
0FEAA:  MOVLW  2C
0FEAC:  MOVLB  8
0FEAE:  MOVWF  xDC
0FEB0:  MOVLB  0
0FEB2:  CALL   5016
0FEB6:  MOVFF  4B1,8CA
0FEBA:  MOVLW  1B
0FEBC:  MOVLB  8
0FEBE:  MOVWF  xCB
0FEC0:  MOVLB  0
0FEC2:  CALL   51F8
0FEC6:  MOVLW  2C
0FEC8:  MOVLB  8
0FECA:  MOVWF  xDC
0FECC:  MOVLB  0
0FECE:  CALL   5016
0FED2:  MOVLW  10
0FED4:  MOVWF  FE9
0FED6:  MOVFF  4A4,8D4
0FEDA:  MOVFF  4A3,8D3
0FEDE:  CALL   AA2C
0FEE2:  MOVLW  2C
0FEE4:  MOVLB  8
0FEE6:  MOVWF  xDC
0FEE8:  MOVLB  0
0FEEA:  CALL   5016
0FEEE:  MOVLW  10
0FEF0:  MOVWF  FE9
0FEF2:  MOVFF  4AA,8D4
0FEF6:  MOVFF  4A9,8D3
0FEFA:  CALL   AA2C
0FEFE:  MOVLW  2C
0FF00:  MOVLB  8
0FF02:  MOVWF  xDC
0FF04:  MOVLB  0
0FF06:  CALL   5016
0FF0A:  MOVLW  10
0FF0C:  MOVWF  FE9
0FF0E:  MOVFF  4A8,8D4
0FF12:  MOVFF  4A7,8D3
0FF16:  CALL   AA2C
0FF1A:  MOVLW  0D
0FF1C:  MOVLB  8
0FF1E:  MOVWF  xDC
0FF20:  MOVLB  0
0FF22:  CALL   5016
0FF26:  MOVLW  0A
0FF28:  MOVLB  8
0FF2A:  MOVWF  xDC
0FF2C:  MOVLB  0
0FF2E:  CALL   5016
....................  
....................    load_scanned_data();  
0FF32:  BRA    FB86
....................  
....................    display_rec(store, display); 
0FF34:  MOVFF  8A1,8C8
0FF38:  MOVFF  8A2,8C9
0FF3C:  RCALL  FC54
....................     
....................    data_available = TRUE; 
0FF3E:  MOVLW  01
0FF40:  MOVLB  3
0FF42:  MOVWF  x37
....................    macro_flag = 900; 
0FF44:  MOVLW  03
0FF46:  MOVWF  x20
0FF48:  MOVLW  84
0FF4A:  MOVWF  x1F
0FF4C:  MOVLB  0
0FF4E:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
*
10000:  MOVLB  8
10002:  CLRF   x68
10004:  CLRF   x67
....................    channel=channel-20000; 
10006:  MOVLW  20
10008:  SUBWF  x64,F
1000A:  MOVLW  4E
1000C:  SUBWFB x65,F
....................     
....................    for (i=0; i<9; i++){ 
1000E:  CLRF   x66
10010:  MOVF   x66,W
10012:  SUBLW  08
10014:  BTFSS  FD8.0
10016:  GOTO   100C2
....................       DAC_set(channel, setting); 
1001A:  MOVFF  864,8B0
1001E:  MOVFF  868,8B2
10022:  MOVFF  867,8B1
10026:  MOVLB  0
10028:  CALL   F270
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
1002C:  MOVLW  18
1002E:  MOVWF  FF6
10030:  MOVLW  1D
10032:  MOVWF  FF7
10034:  MOVLW  00
10036:  MOVWF  FF8
10038:  CLRF   1B
1003A:  BTFSC  FF2.7
1003C:  BSF    1B.7
1003E:  BCF    FF2.7
10040:  MOVLW  05
10042:  MOVLB  A
10044:  MOVWF  x18
10046:  MOVLB  0
10048:  CALL   1006
1004C:  BTFSC  1B.7
1004E:  BSF    FF2.7
10050:  MOVLW  10
10052:  MOVWF  FE9
10054:  CLRF   1B
10056:  BTFSC  FF2.7
10058:  BSF    1B.7
1005A:  BCF    FF2.7
1005C:  MOVFF  865,A19
10060:  MOVFF  864,A18
10064:  CALL   1188
10068:  BTFSC  1B.7
1006A:  BSF    FF2.7
1006C:  MOVLW  2C
1006E:  BTFSS  F9E.4
10070:  GOTO   1006E
10074:  MOVWF  FAD
10076:  MOVLW  10
10078:  MOVWF  FE9
1007A:  CLRF   1B
1007C:  BTFSC  FF2.7
1007E:  BSF    1B.7
10080:  BCF    FF2.7
10082:  MOVFF  868,A19
10086:  MOVFF  867,A18
1008A:  CALL   1188
1008E:  BTFSC  1B.7
10090:  BSF    FF2.7
10092:  MOVLW  2C
10094:  BTFSS  F9E.4
10096:  GOTO   10094
1009A:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
1009C:  MOVLB  8
1009E:  CLRF   xA0
100A0:  MOVLW  C8
100A2:  MOVWF  x9F
100A4:  CLRF   xA1
100A6:  MOVLW  01
100A8:  MOVWF  xA2
100AA:  MOVWF  xA3
100AC:  MOVLB  0
100AE:  CALL   FCF2
....................       setting = setting+500; 
100B2:  MOVLW  F4
100B4:  MOVLB  8
100B6:  ADDWF  x67,F
100B8:  MOVLW  01
100BA:  ADDWFC x68,F
100BC:  INCF   x66,F
100BE:  GOTO   10010
....................    } 
100C2:  MOVLB  0
100C4:  GOTO   10194 (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
*
0FF50:  MOVLB  8
0FF52:  CLRF   x64
0FF54:  CLRF   x63
....................     
....................    for (i=0; i<9; i++){ 
0FF56:  CLRF   x62
0FF58:  MOVF   x62,W
0FF5A:  SUBLW  08
0FF5C:  BNC   FFD6
....................       LED_SAR(intensity); 
0FF5E:  MOVFF  864,8A6
0FF62:  MOVFF  863,8A5
0FF66:  MOVLB  0
0FF68:  CALL   F514
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
0FF6C:  MOVLW  26
0FF6E:  MOVWF  FF6
0FF70:  MOVLW  1D
0FF72:  MOVWF  FF7
0FF74:  MOVLW  00
0FF76:  MOVWF  FF8
0FF78:  CLRF   1B
0FF7A:  BTFSC  FF2.7
0FF7C:  BSF    1B.7
0FF7E:  BCF    FF2.7
0FF80:  MOVLW  07
0FF82:  MOVLB  A
0FF84:  MOVWF  x18
0FF86:  MOVLB  0
0FF88:  CALL   1006
0FF8C:  BTFSC  1B.7
0FF8E:  BSF    FF2.7
0FF90:  MOVLW  10
0FF92:  MOVWF  FE9
0FF94:  CLRF   1B
0FF96:  BTFSC  FF2.7
0FF98:  BSF    1B.7
0FF9A:  BCF    FF2.7
0FF9C:  MOVFF  864,A19
0FFA0:  MOVFF  863,A18
0FFA4:  CALL   1188
0FFA8:  BTFSC  1B.7
0FFAA:  BSF    FF2.7
0FFAC:  MOVLW  2C
0FFAE:  BTFSS  F9E.4
0FFB0:  BRA    FFAE
0FFB2:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
0FFB4:  MOVLB  8
0FFB6:  CLRF   xA0
0FFB8:  MOVLW  C8
0FFBA:  MOVWF  x9F
0FFBC:  CLRF   xA1
0FFBE:  MOVLW  01
0FFC0:  MOVWF  xA2
0FFC2:  MOVWF  xA3
0FFC4:  MOVLB  0
0FFC6:  RCALL  FCF2
....................       intensity = intensity+500; 
0FFC8:  MOVLW  F4
0FFCA:  MOVLB  8
0FFCC:  ADDWF  x63,F
0FFCE:  MOVLW  01
0FFD0:  ADDWFC x64,F
0FFD2:  INCF   x62,F
0FFD4:  BRA    FF58
....................    } 
0FFD6:  MOVLB  0
0FFD8:  GOTO   10194 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
03038:  MOVLB  8
0303A:  CLRF   x93
0303C:  MOVF   x93,W
0303E:  SUBLW  20
03040:  BNC   3056
03042:  CLRF   03
03044:  MOVF   x93,W
03046:  ADDLW  B3
03048:  MOVWF  FE9
0304A:  MOVLW  04
0304C:  ADDWFC 03,W
0304E:  MOVWF  FEA
03050:  CLRF   FEF
03052:  INCF   x93,F
03054:  BRA    303C
03056:  MOVLB  0
03058:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
0305A:  MOVF   2F,W
0305C:  SUBLW  02
0305E:  BNZ   3068
03060:  MOVF   30,F
03062:  BNZ   3068
03064:  MOVLW  00
03066:  MOVWF  F99
....................    init_valve_status(); 
03068:  RCALL  3038
....................    bus_pwr_status=0; 
0306A:  MOVLB  4
0306C:  CLRF   xB2
0306E:  MOVLB  0
03070:  GOTO   1B180 (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0EA5E:  MOVLW  32
0EA60:  MOVWF  FF6
0EA62:  MOVLW  1D
0EA64:  MOVWF  FF7
0EA66:  MOVLW  00
0EA68:  MOVWF  FF8
0EA6A:  CLRF   1B
0EA6C:  BTFSC  FF2.7
0EA6E:  BSF    1B.7
0EA70:  BCF    FF2.7
0EA72:  CALL   0E30
0EA76:  BTFSC  1B.7
0EA78:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EA7A:  MOVLW  01
0EA7C:  MOVLB  8
0EA7E:  MOVWF  x93
0EA80:  MOVF   x93,W
0EA82:  SUBLW  08
0EA84:  BNC   EAEE
0EA86:  CLRF   03
0EA88:  MOVF   x93,W
0EA8A:  ADDLW  B3
0EA8C:  MOVWF  FE9
0EA8E:  MOVLW  04
0EA90:  ADDWFC 03,W
0EA92:  MOVWF  FEA
0EA94:  MOVFF  FEF,894
0EA98:  CLRF   1B
0EA9A:  BTFSC  FF2.7
0EA9C:  BSF    1B.7
0EA9E:  BCF    FF2.7
0EAA0:  MOVFF  893,A18
0EAA4:  MOVLW  01
0EAA6:  MOVLB  A
0EAA8:  MOVWF  x19
0EAAA:  MOVLB  0
0EAAC:  CALL   0F88
0EAB0:  BTFSC  1B.7
0EAB2:  BSF    FF2.7
0EAB4:  MOVLW  5B
0EAB6:  BTFSS  F9E.4
0EAB8:  BRA    EAB6
0EABA:  MOVWF  FAD
0EABC:  CLRF   1B
0EABE:  BTFSC  FF2.7
0EAC0:  BSF    1B.7
0EAC2:  BCF    FF2.7
0EAC4:  MOVFF  894,A18
0EAC8:  MOVLW  1B
0EACA:  MOVLB  A
0EACC:  MOVWF  x19
0EACE:  MOVLB  0
0EAD0:  CALL   0F88
0EAD4:  BTFSC  1B.7
0EAD6:  BSF    FF2.7
0EAD8:  MOVLW  5D
0EADA:  BTFSS  F9E.4
0EADC:  BRA    EADA
0EADE:  MOVWF  FAD
0EAE0:  MOVLW  20
0EAE2:  BTFSS  F9E.4
0EAE4:  BRA    EAE2
0EAE6:  MOVWF  FAD
0EAE8:  MOVLB  8
0EAEA:  INCF   x93,F
0EAEC:  BRA    EA80
....................    fprintf(COM_A, "\r\n"); 
0EAEE:  MOVLW  0D
0EAF0:  BTFSS  F9E.4
0EAF2:  BRA    EAF0
0EAF4:  MOVWF  FAD
0EAF6:  MOVLW  0A
0EAF8:  BTFSS  F9E.4
0EAFA:  BRA    EAF8
0EAFC:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EAFE:  MOVLW  38
0EB00:  MOVWF  FF6
0EB02:  MOVLW  1D
0EB04:  MOVWF  FF7
0EB06:  MOVLW  00
0EB08:  MOVWF  FF8
0EB0A:  CLRF   1B
0EB0C:  BTFSC  FF2.7
0EB0E:  BSF    1B.7
0EB10:  BCF    FF2.7
0EB12:  MOVLB  0
0EB14:  CALL   0E30
0EB18:  BTFSC  1B.7
0EB1A:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EB1C:  MOVLW  09
0EB1E:  MOVLB  8
0EB20:  MOVWF  x93
0EB22:  MOVF   x93,W
0EB24:  SUBLW  10
0EB26:  BNC   EB90
0EB28:  CLRF   03
0EB2A:  MOVF   x93,W
0EB2C:  ADDLW  B3
0EB2E:  MOVWF  FE9
0EB30:  MOVLW  04
0EB32:  ADDWFC 03,W
0EB34:  MOVWF  FEA
0EB36:  MOVFF  FEF,894
0EB3A:  CLRF   1B
0EB3C:  BTFSC  FF2.7
0EB3E:  BSF    1B.7
0EB40:  BCF    FF2.7
0EB42:  MOVFF  893,A18
0EB46:  MOVLW  01
0EB48:  MOVLB  A
0EB4A:  MOVWF  x19
0EB4C:  MOVLB  0
0EB4E:  CALL   0F88
0EB52:  BTFSC  1B.7
0EB54:  BSF    FF2.7
0EB56:  MOVLW  5B
0EB58:  BTFSS  F9E.4
0EB5A:  BRA    EB58
0EB5C:  MOVWF  FAD
0EB5E:  CLRF   1B
0EB60:  BTFSC  FF2.7
0EB62:  BSF    1B.7
0EB64:  BCF    FF2.7
0EB66:  MOVFF  894,A18
0EB6A:  MOVLW  1B
0EB6C:  MOVLB  A
0EB6E:  MOVWF  x19
0EB70:  MOVLB  0
0EB72:  CALL   0F88
0EB76:  BTFSC  1B.7
0EB78:  BSF    FF2.7
0EB7A:  MOVLW  5D
0EB7C:  BTFSS  F9E.4
0EB7E:  BRA    EB7C
0EB80:  MOVWF  FAD
0EB82:  MOVLW  20
0EB84:  BTFSS  F9E.4
0EB86:  BRA    EB84
0EB88:  MOVWF  FAD
0EB8A:  MOVLB  8
0EB8C:  INCF   x93,F
0EB8E:  BRA    EB22
....................    fprintf(COM_A, "\r\n"); 
0EB90:  MOVLW  0D
0EB92:  BTFSS  F9E.4
0EB94:  BRA    EB92
0EB96:  MOVWF  FAD
0EB98:  MOVLW  0A
0EB9A:  BTFSS  F9E.4
0EB9C:  BRA    EB9A
0EB9E:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EBA0:  MOVLW  3E
0EBA2:  MOVWF  FF6
0EBA4:  MOVLW  1D
0EBA6:  MOVWF  FF7
0EBA8:  MOVLW  00
0EBAA:  MOVWF  FF8
0EBAC:  CLRF   1B
0EBAE:  BTFSC  FF2.7
0EBB0:  BSF    1B.7
0EBB2:  BCF    FF2.7
0EBB4:  MOVLB  0
0EBB6:  CALL   0E30
0EBBA:  BTFSC  1B.7
0EBBC:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EBBE:  MOVLW  11
0EBC0:  MOVLB  8
0EBC2:  MOVWF  x93
0EBC4:  MOVF   x93,W
0EBC6:  SUBLW  18
0EBC8:  BNC   EC32
0EBCA:  CLRF   03
0EBCC:  MOVF   x93,W
0EBCE:  ADDLW  B3
0EBD0:  MOVWF  FE9
0EBD2:  MOVLW  04
0EBD4:  ADDWFC 03,W
0EBD6:  MOVWF  FEA
0EBD8:  MOVFF  FEF,894
0EBDC:  CLRF   1B
0EBDE:  BTFSC  FF2.7
0EBE0:  BSF    1B.7
0EBE2:  BCF    FF2.7
0EBE4:  MOVFF  893,A18
0EBE8:  MOVLW  01
0EBEA:  MOVLB  A
0EBEC:  MOVWF  x19
0EBEE:  MOVLB  0
0EBF0:  CALL   0F88
0EBF4:  BTFSC  1B.7
0EBF6:  BSF    FF2.7
0EBF8:  MOVLW  5B
0EBFA:  BTFSS  F9E.4
0EBFC:  BRA    EBFA
0EBFE:  MOVWF  FAD
0EC00:  CLRF   1B
0EC02:  BTFSC  FF2.7
0EC04:  BSF    1B.7
0EC06:  BCF    FF2.7
0EC08:  MOVFF  894,A18
0EC0C:  MOVLW  1B
0EC0E:  MOVLB  A
0EC10:  MOVWF  x19
0EC12:  MOVLB  0
0EC14:  CALL   0F88
0EC18:  BTFSC  1B.7
0EC1A:  BSF    FF2.7
0EC1C:  MOVLW  5D
0EC1E:  BTFSS  F9E.4
0EC20:  BRA    EC1E
0EC22:  MOVWF  FAD
0EC24:  MOVLW  20
0EC26:  BTFSS  F9E.4
0EC28:  BRA    EC26
0EC2A:  MOVWF  FAD
0EC2C:  MOVLB  8
0EC2E:  INCF   x93,F
0EC30:  BRA    EBC4
....................    fprintf(COM_A, "\r\n"); 
0EC32:  MOVLW  0D
0EC34:  BTFSS  F9E.4
0EC36:  BRA    EC34
0EC38:  MOVWF  FAD
0EC3A:  MOVLW  0A
0EC3C:  BTFSS  F9E.4
0EC3E:  BRA    EC3C
0EC40:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EC42:  MOVLW  44
0EC44:  MOVWF  FF6
0EC46:  MOVLW  1D
0EC48:  MOVWF  FF7
0EC4A:  MOVLW  00
0EC4C:  MOVWF  FF8
0EC4E:  CLRF   1B
0EC50:  BTFSC  FF2.7
0EC52:  BSF    1B.7
0EC54:  BCF    FF2.7
0EC56:  MOVLB  0
0EC58:  CALL   0E30
0EC5C:  BTFSC  1B.7
0EC5E:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EC60:  MOVLW  19
0EC62:  MOVLB  8
0EC64:  MOVWF  x93
0EC66:  MOVF   x93,W
0EC68:  SUBLW  20
0EC6A:  BNC   ECD4
0EC6C:  CLRF   03
0EC6E:  MOVF   x93,W
0EC70:  ADDLW  B3
0EC72:  MOVWF  FE9
0EC74:  MOVLW  04
0EC76:  ADDWFC 03,W
0EC78:  MOVWF  FEA
0EC7A:  MOVFF  FEF,894
0EC7E:  CLRF   1B
0EC80:  BTFSC  FF2.7
0EC82:  BSF    1B.7
0EC84:  BCF    FF2.7
0EC86:  MOVFF  893,A18
0EC8A:  MOVLW  01
0EC8C:  MOVLB  A
0EC8E:  MOVWF  x19
0EC90:  MOVLB  0
0EC92:  CALL   0F88
0EC96:  BTFSC  1B.7
0EC98:  BSF    FF2.7
0EC9A:  MOVLW  5B
0EC9C:  BTFSS  F9E.4
0EC9E:  BRA    EC9C
0ECA0:  MOVWF  FAD
0ECA2:  CLRF   1B
0ECA4:  BTFSC  FF2.7
0ECA6:  BSF    1B.7
0ECA8:  BCF    FF2.7
0ECAA:  MOVFF  894,A18
0ECAE:  MOVLW  1B
0ECB0:  MOVLB  A
0ECB2:  MOVWF  x19
0ECB4:  MOVLB  0
0ECB6:  CALL   0F88
0ECBA:  BTFSC  1B.7
0ECBC:  BSF    FF2.7
0ECBE:  MOVLW  5D
0ECC0:  BTFSS  F9E.4
0ECC2:  BRA    ECC0
0ECC4:  MOVWF  FAD
0ECC6:  MOVLW  20
0ECC8:  BTFSS  F9E.4
0ECCA:  BRA    ECC8
0ECCC:  MOVWF  FAD
0ECCE:  MOVLB  8
0ECD0:  INCF   x93,F
0ECD2:  BRA    EC66
....................    fprintf(COM_A, "\r\n");    
0ECD4:  MOVLW  0D
0ECD6:  BTFSS  F9E.4
0ECD8:  BRA    ECD6
0ECDA:  MOVWF  FAD
0ECDC:  MOVLW  0A
0ECDE:  BTFSS  F9E.4
0ECE0:  BRA    ECDE
0ECE2:  MOVWF  FAD
0ECE4:  MOVLB  0
0ECE6:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
14014:  MOVF   1F,W
14016:  SUBLW  04
14018:  BNZ   14082
1401A:  MOVF   20,F
1401C:  BNZ   14082
1401E:  MOVLW  4A
14020:  MOVWF  FF6
14022:  MOVLW  1D
14024:  MOVWF  FF7
14026:  MOVLW  00
14028:  MOVWF  FF8
1402A:  CLRF   1B
1402C:  BTFSC  FF2.7
1402E:  BSF    1B.7
14030:  BCF    FF2.7
14032:  MOVLW  0C
14034:  MOVLB  A
14036:  MOVWF  x18
14038:  MOVLB  0
1403A:  CALL   1006
1403E:  BTFSC  1B.7
14040:  BSF    FF2.7
14042:  MOVLW  10
14044:  MOVWF  FE9
14046:  CLRF   1B
14048:  BTFSC  FF2.7
1404A:  BSF    1B.7
1404C:  BCF    FF2.7
1404E:  MOVFF  894,A19
14052:  MOVFF  893,A18
14056:  CALL   1188
1405A:  BTFSC  1B.7
1405C:  BSF    FF2.7
1405E:  MOVLW  59
14060:  MOVWF  FF6
14062:  MOVLW  1D
14064:  MOVWF  FF7
14066:  MOVLW  00
14068:  MOVWF  FF8
1406A:  CLRF   1B
1406C:  BTFSC  FF2.7
1406E:  BSF    1B.7
14070:  BCF    FF2.7
14072:  MOVLW  03
14074:  MOVLB  A
14076:  MOVWF  x18
14078:  MOVLB  0
1407A:  CALL   1006
1407E:  BTFSC  1B.7
14080:  BSF    FF2.7
....................  
....................    multidrop_on(); 
14082:  CALL   D774
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
14086:  MOVLW  5E
14088:  MOVWF  FF6
1408A:  MOVLW  1D
1408C:  MOVWF  FF7
1408E:  MOVLW  00
14090:  MOVWF  FF8
14092:  MOVLW  03
14094:  MOVLB  8
14096:  MOVWF  x95
14098:  MOVLB  0
1409A:  CALL   D788
1409E:  MOVLW  10
140A0:  MOVWF  FE9
140A2:  MOVFF  894,896
140A6:  MOVFF  893,895
140AA:  BRA    13F5A
140AC:  MOVLW  0D
140AE:  BTFSS  FA4.4
140B0:  BRA    140AE
140B2:  MOVLB  F
140B4:  MOVWF  x1C
....................    multidrop_off(); 
140B6:  MOVLB  0
140B8:  CALL   D860
....................  
....................    delay_ms(100); 
140BC:  MOVLW  64
140BE:  MOVLB  9
140C0:  MOVWF  xC9
140C2:  MOVLB  0
140C4:  CALL   288E
140C8:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0D8B2:  MOVF   1F,W
0D8B4:  SUBLW  04
0D8B6:  BNZ   D920
0D8B8:  MOVF   20,F
0D8BA:  BNZ   D920
0D8BC:  MOVLW  66
0D8BE:  MOVWF  FF6
0D8C0:  MOVLW  1D
0D8C2:  MOVWF  FF7
0D8C4:  MOVLW  00
0D8C6:  MOVWF  FF8
0D8C8:  CLRF   1B
0D8CA:  BTFSC  FF2.7
0D8CC:  BSF    1B.7
0D8CE:  BCF    FF2.7
0D8D0:  MOVLW  0C
0D8D2:  MOVLB  A
0D8D4:  MOVWF  x18
0D8D6:  MOVLB  0
0D8D8:  CALL   1006
0D8DC:  BTFSC  1B.7
0D8DE:  BSF    FF2.7
0D8E0:  CLRF   1B
0D8E2:  BTFSC  FF2.7
0D8E4:  BSF    1B.7
0D8E6:  BCF    FF2.7
0D8E8:  MOVFF  893,A18
0D8EC:  MOVLW  1B
0D8EE:  MOVLB  A
0D8F0:  MOVWF  x19
0D8F2:  MOVLB  0
0D8F4:  CALL   0F88
0D8F8:  BTFSC  1B.7
0D8FA:  BSF    FF2.7
0D8FC:  MOVLW  74
0D8FE:  MOVWF  FF6
0D900:  MOVLW  1D
0D902:  MOVWF  FF7
0D904:  MOVLW  00
0D906:  MOVWF  FF8
0D908:  CLRF   1B
0D90A:  BTFSC  FF2.7
0D90C:  BSF    1B.7
0D90E:  BCF    FF2.7
0D910:  MOVLW  03
0D912:  MOVLB  A
0D914:  MOVWF  x18
0D916:  MOVLB  0
0D918:  CALL   1006
0D91C:  BTFSC  1B.7
0D91E:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0D920:  RCALL  D774
....................       fprintf(COM_B, "/1c%u\r",chip); 
0D922:  MOVLW  78
0D924:  MOVWF  FF6
0D926:  MOVLW  1D
0D928:  MOVWF  FF7
0D92A:  MOVLW  00
0D92C:  MOVWF  FF8
0D92E:  MOVLW  03
0D930:  MOVLB  8
0D932:  MOVWF  x95
0D934:  MOVLB  0
0D936:  RCALL  D788
0D938:  MOVFF  893,8D0
0D93C:  MOVLW  1B
0D93E:  MOVLB  8
0D940:  MOVWF  xD1
0D942:  MOVLB  0
0D944:  RCALL  D7BC
0D946:  MOVLW  0D
0D948:  BTFSS  FA4.4
0D94A:  BRA    D948
0D94C:  MOVLB  F
0D94E:  MOVWF  x1C
....................    multidrop_off(); 
0D950:  MOVLB  0
0D952:  RCALL  D860
....................    delay_ms(100); 
0D954:  MOVLW  64
0D956:  MOVLB  9
0D958:  MOVWF  xC9
0D95A:  MOVLB  0
0D95C:  CALL   288E
....................  
....................    multidrop_on(); 
0D960:  RCALL  D774
....................      fprintf(COM_B, "/1s256\r"); 
0D962:  MOVLW  80
0D964:  MOVWF  FF6
0D966:  MOVLW  1D
0D968:  MOVWF  FF7
0D96A:  MOVLW  00
0D96C:  MOVWF  FF8
0D96E:  BRA    D882
....................    multidrop_off();  
0D970:  RCALL  D860
....................    delay_ms(100); 
0D972:  MOVLW  64
0D974:  MOVLB  9
0D976:  MOVWF  xC9
0D978:  MOVLB  0
0D97A:  CALL   288E
0D97E:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
140CA:  MOVLB  8
140CC:  MOVF   x92,W
140CE:  ADDLW  DF
140D0:  BTFSC  FD8.0
140D2:  BRA    144BE
140D4:  ADDLW  21
140D6:  MOVLB  0
140D8:  GOTO   144F0
....................       case 0 : sol_chip_cmd(1); 
140DC:  MOVLW  01
140DE:  MOVLB  8
140E0:  MOVWF  x93
140E2:  MOVLB  0
140E4:  CALL   D8B2
....................                sol_switch_cmd(0); 
140E8:  MOVLB  8
140EA:  CLRF   x94
140EC:  CLRF   x93
140EE:  MOVLB  0
140F0:  RCALL  14014
....................                sol_chip_cmd(2); 
140F2:  MOVLW  02
140F4:  MOVLB  8
140F6:  MOVWF  x93
140F8:  MOVLB  0
140FA:  CALL   D8B2
....................                sol_switch_cmd(0); 
140FE:  MOVLB  8
14100:  CLRF   x94
14102:  CLRF   x93
14104:  MOVLB  0
14106:  RCALL  14014
....................                sol_chip_cmd(3); 
14108:  MOVLW  03
1410A:  MOVLB  8
1410C:  MOVWF  x93
1410E:  MOVLB  0
14110:  CALL   D8B2
....................                sol_switch_cmd(0); 
14114:  MOVLB  8
14116:  CLRF   x94
14118:  CLRF   x93
1411A:  MOVLB  0
1411C:  RCALL  14014
....................                sol_chip_cmd(4); 
1411E:  MOVLW  04
14120:  MOVLB  8
14122:  MOVWF  x93
14124:  MOVLB  0
14126:  CALL   D8B2
....................                sol_switch_cmd(0); 
1412A:  MOVLB  8
1412C:  CLRF   x94
1412E:  CLRF   x93
14130:  MOVLB  0
14132:  RCALL  14014
....................                init_valve_status(); 
14134:  CALL   3038
....................          break; 
14138:  MOVLB  8
1413A:  BRA    144BE
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
1413C:  MOVLW  01
1413E:  MOVLB  8
14140:  MOVWF  x93
14142:  MOVLB  0
14144:  CALL   D8B2
....................                sol_switch_cmd(1); 
14148:  MOVLB  8
1414A:  CLRF   x94
1414C:  MOVLW  01
1414E:  MOVWF  x93
14150:  MOVLB  0
14152:  RCALL  14014
....................          break;     
14154:  MOVLB  8
14156:  BRA    144BE
....................       case 2 : sol_chip_cmd(1); 
14158:  MOVLW  01
1415A:  MOVLB  8
1415C:  MOVWF  x93
1415E:  MOVLB  0
14160:  CALL   D8B2
....................                sol_switch_cmd(2); 
14164:  MOVLB  8
14166:  CLRF   x94
14168:  MOVLW  02
1416A:  MOVWF  x93
1416C:  MOVLB  0
1416E:  RCALL  14014
....................          break;           
14170:  MOVLB  8
14172:  BRA    144BE
....................       case 3 : sol_chip_cmd(1); 
14174:  MOVLW  01
14176:  MOVLB  8
14178:  MOVWF  x93
1417A:  MOVLB  0
1417C:  CALL   D8B2
....................                sol_switch_cmd(4); 
14180:  MOVLB  8
14182:  CLRF   x94
14184:  MOVLW  04
14186:  MOVWF  x93
14188:  MOVLB  0
1418A:  RCALL  14014
....................          break;  
1418C:  MOVLB  8
1418E:  BRA    144BE
....................       case 4 : sol_chip_cmd(1); 
14190:  MOVLW  01
14192:  MOVLB  8
14194:  MOVWF  x93
14196:  MOVLB  0
14198:  CALL   D8B2
....................                sol_switch_cmd(8); 
1419C:  MOVLB  8
1419E:  CLRF   x94
141A0:  MOVLW  08
141A2:  MOVWF  x93
141A4:  MOVLB  0
141A6:  RCALL  14014
....................          break;  
141A8:  MOVLB  8
141AA:  BRA    144BE
....................       case 5 : sol_chip_cmd(1); 
141AC:  MOVLW  01
141AE:  MOVLB  8
141B0:  MOVWF  x93
141B2:  MOVLB  0
141B4:  CALL   D8B2
....................                sol_switch_cmd(16); 
141B8:  MOVLB  8
141BA:  CLRF   x94
141BC:  MOVLW  10
141BE:  MOVWF  x93
141C0:  MOVLB  0
141C2:  RCALL  14014
....................          break;  
141C4:  MOVLB  8
141C6:  BRA    144BE
....................       case 6 : sol_chip_cmd(1); 
141C8:  MOVLW  01
141CA:  MOVLB  8
141CC:  MOVWF  x93
141CE:  MOVLB  0
141D0:  CALL   D8B2
....................                sol_switch_cmd(32); 
141D4:  MOVLB  8
141D6:  CLRF   x94
141D8:  MOVLW  20
141DA:  MOVWF  x93
141DC:  MOVLB  0
141DE:  RCALL  14014
....................          break;  
141E0:  MOVLB  8
141E2:  BRA    144BE
....................       case 7 : sol_chip_cmd(1); 
141E4:  MOVLW  01
141E6:  MOVLB  8
141E8:  MOVWF  x93
141EA:  MOVLB  0
141EC:  CALL   D8B2
....................                sol_switch_cmd(64); 
141F0:  MOVLB  8
141F2:  CLRF   x94
141F4:  MOVLW  40
141F6:  MOVWF  x93
141F8:  MOVLB  0
141FA:  RCALL  14014
....................          break;  
141FC:  MOVLB  8
141FE:  BRA    144BE
....................       case 8 : sol_chip_cmd(1); 
14200:  MOVLW  01
14202:  MOVLB  8
14204:  MOVWF  x93
14206:  MOVLB  0
14208:  CALL   D8B2
....................                sol_switch_cmd(128); 
1420C:  MOVLB  8
1420E:  CLRF   x94
14210:  MOVLW  80
14212:  MOVWF  x93
14214:  MOVLB  0
14216:  RCALL  14014
....................          break;   
14218:  MOVLB  8
1421A:  BRA    144BE
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
1421C:  MOVLW  02
1421E:  MOVLB  8
14220:  MOVWF  x93
14222:  MOVLB  0
14224:  CALL   D8B2
....................                sol_switch_cmd(1); 
14228:  MOVLB  8
1422A:  CLRF   x94
1422C:  MOVLW  01
1422E:  MOVWF  x93
14230:  MOVLB  0
14232:  RCALL  14014
....................          break;     
14234:  MOVLB  8
14236:  BRA    144BE
....................       case 10 : sol_chip_cmd(2); 
14238:  MOVLW  02
1423A:  MOVLB  8
1423C:  MOVWF  x93
1423E:  MOVLB  0
14240:  CALL   D8B2
....................                sol_switch_cmd(2); 
14244:  MOVLB  8
14246:  CLRF   x94
14248:  MOVLW  02
1424A:  MOVWF  x93
1424C:  MOVLB  0
1424E:  RCALL  14014
....................          break;           
14250:  MOVLB  8
14252:  BRA    144BE
....................       case 11 : sol_chip_cmd(2); 
14254:  MOVLW  02
14256:  MOVLB  8
14258:  MOVWF  x93
1425A:  MOVLB  0
1425C:  CALL   D8B2
....................                sol_switch_cmd(4); 
14260:  MOVLB  8
14262:  CLRF   x94
14264:  MOVLW  04
14266:  MOVWF  x93
14268:  MOVLB  0
1426A:  RCALL  14014
....................          break;  
1426C:  MOVLB  8
1426E:  BRA    144BE
....................       case 12 : sol_chip_cmd(2); 
14270:  MOVLW  02
14272:  MOVLB  8
14274:  MOVWF  x93
14276:  MOVLB  0
14278:  CALL   D8B2
....................                sol_switch_cmd(8); 
1427C:  MOVLB  8
1427E:  CLRF   x94
14280:  MOVLW  08
14282:  MOVWF  x93
14284:  MOVLB  0
14286:  RCALL  14014
....................          break;  
14288:  MOVLB  8
1428A:  BRA    144BE
....................       case 13 : sol_chip_cmd(2); 
1428C:  MOVLW  02
1428E:  MOVLB  8
14290:  MOVWF  x93
14292:  MOVLB  0
14294:  CALL   D8B2
....................                sol_switch_cmd(16); 
14298:  MOVLB  8
1429A:  CLRF   x94
1429C:  MOVLW  10
1429E:  MOVWF  x93
142A0:  MOVLB  0
142A2:  RCALL  14014
....................          break;  
142A4:  MOVLB  8
142A6:  BRA    144BE
....................       case 14 : sol_chip_cmd(2); 
142A8:  MOVLW  02
142AA:  MOVLB  8
142AC:  MOVWF  x93
142AE:  MOVLB  0
142B0:  CALL   D8B2
....................                sol_switch_cmd(32); 
142B4:  MOVLB  8
142B6:  CLRF   x94
142B8:  MOVLW  20
142BA:  MOVWF  x93
142BC:  MOVLB  0
142BE:  RCALL  14014
....................          break;  
142C0:  MOVLB  8
142C2:  BRA    144BE
....................       case 15 : sol_chip_cmd(2); 
142C4:  MOVLW  02
142C6:  MOVLB  8
142C8:  MOVWF  x93
142CA:  MOVLB  0
142CC:  CALL   D8B2
....................                sol_switch_cmd(64); 
142D0:  MOVLB  8
142D2:  CLRF   x94
142D4:  MOVLW  40
142D6:  MOVWF  x93
142D8:  MOVLB  0
142DA:  RCALL  14014
....................          break;  
142DC:  MOVLB  8
142DE:  BRA    144BE
....................       case 16 : sol_chip_cmd(2); 
142E0:  MOVLW  02
142E2:  MOVLB  8
142E4:  MOVWF  x93
142E6:  MOVLB  0
142E8:  CALL   D8B2
....................                sol_switch_cmd(128); 
142EC:  MOVLB  8
142EE:  CLRF   x94
142F0:  MOVLW  80
142F2:  MOVWF  x93
142F4:  MOVLB  0
142F6:  RCALL  14014
....................          break;   
142F8:  MOVLB  8
142FA:  BRA    144BE
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
142FC:  MOVLW  03
142FE:  MOVLB  8
14300:  MOVWF  x93
14302:  MOVLB  0
14304:  CALL   D8B2
....................                sol_switch_cmd(1); 
14308:  MOVLB  8
1430A:  CLRF   x94
1430C:  MOVLW  01
1430E:  MOVWF  x93
14310:  MOVLB  0
14312:  RCALL  14014
....................          break;     
14314:  MOVLB  8
14316:  BRA    144BE
....................       case 18 : sol_chip_cmd(3); 
14318:  MOVLW  03
1431A:  MOVLB  8
1431C:  MOVWF  x93
1431E:  MOVLB  0
14320:  CALL   D8B2
....................                sol_switch_cmd(2); 
14324:  MOVLB  8
14326:  CLRF   x94
14328:  MOVLW  02
1432A:  MOVWF  x93
1432C:  MOVLB  0
1432E:  RCALL  14014
....................          break;           
14330:  MOVLB  8
14332:  BRA    144BE
....................       case 19 : sol_chip_cmd(3); 
14334:  MOVLW  03
14336:  MOVLB  8
14338:  MOVWF  x93
1433A:  MOVLB  0
1433C:  CALL   D8B2
....................                sol_switch_cmd(4); 
14340:  MOVLB  8
14342:  CLRF   x94
14344:  MOVLW  04
14346:  MOVWF  x93
14348:  MOVLB  0
1434A:  RCALL  14014
....................          break;  
1434C:  MOVLB  8
1434E:  BRA    144BE
....................       case 20 : sol_chip_cmd(3); 
14350:  MOVLW  03
14352:  MOVLB  8
14354:  MOVWF  x93
14356:  MOVLB  0
14358:  CALL   D8B2
....................                sol_switch_cmd(8); 
1435C:  MOVLB  8
1435E:  CLRF   x94
14360:  MOVLW  08
14362:  MOVWF  x93
14364:  MOVLB  0
14366:  RCALL  14014
....................          break;  
14368:  MOVLB  8
1436A:  BRA    144BE
....................       case 21 : sol_chip_cmd(3); 
1436C:  MOVLW  03
1436E:  MOVLB  8
14370:  MOVWF  x93
14372:  MOVLB  0
14374:  CALL   D8B2
....................                sol_switch_cmd(16); 
14378:  MOVLB  8
1437A:  CLRF   x94
1437C:  MOVLW  10
1437E:  MOVWF  x93
14380:  MOVLB  0
14382:  RCALL  14014
....................          break;  
14384:  MOVLB  8
14386:  BRA    144BE
....................       case 22 : sol_chip_cmd(3); 
14388:  MOVLW  03
1438A:  MOVLB  8
1438C:  MOVWF  x93
1438E:  MOVLB  0
14390:  CALL   D8B2
....................                sol_switch_cmd(32); 
14394:  MOVLB  8
14396:  CLRF   x94
14398:  MOVLW  20
1439A:  MOVWF  x93
1439C:  MOVLB  0
1439E:  RCALL  14014
....................          break;  
143A0:  MOVLB  8
143A2:  BRA    144BE
....................       case 23 : sol_chip_cmd(3); 
143A4:  MOVLW  03
143A6:  MOVLB  8
143A8:  MOVWF  x93
143AA:  MOVLB  0
143AC:  CALL   D8B2
....................                sol_switch_cmd(64); 
143B0:  MOVLB  8
143B2:  CLRF   x94
143B4:  MOVLW  40
143B6:  MOVWF  x93
143B8:  MOVLB  0
143BA:  RCALL  14014
....................          break;  
143BC:  MOVLB  8
143BE:  BRA    144BE
....................       case 24 : sol_chip_cmd(3); 
143C0:  MOVLW  03
143C2:  MOVLB  8
143C4:  MOVWF  x93
143C6:  MOVLB  0
143C8:  CALL   D8B2
....................                sol_switch_cmd(128); 
143CC:  MOVLB  8
143CE:  CLRF   x94
143D0:  MOVLW  80
143D2:  MOVWF  x93
143D4:  MOVLB  0
143D6:  RCALL  14014
....................          break;      
143D8:  MOVLB  8
143DA:  BRA    144BE
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
143DC:  MOVLW  04
143DE:  MOVLB  8
143E0:  MOVWF  x93
143E2:  MOVLB  0
143E4:  CALL   D8B2
....................                sol_switch_cmd(1); 
143E8:  MOVLB  8
143EA:  CLRF   x94
143EC:  MOVLW  01
143EE:  MOVWF  x93
143F0:  MOVLB  0
143F2:  RCALL  14014
....................          break;     
143F4:  MOVLB  8
143F6:  BRA    144BE
....................       case 26 : sol_chip_cmd(4); 
143F8:  MOVLW  04
143FA:  MOVLB  8
143FC:  MOVWF  x93
143FE:  MOVLB  0
14400:  CALL   D8B2
....................                sol_switch_cmd(2); 
14404:  MOVLB  8
14406:  CLRF   x94
14408:  MOVLW  02
1440A:  MOVWF  x93
1440C:  MOVLB  0
1440E:  RCALL  14014
....................          break;           
14410:  MOVLB  8
14412:  BRA    144BE
....................       case 27 : sol_chip_cmd(4); 
14414:  MOVLW  04
14416:  MOVLB  8
14418:  MOVWF  x93
1441A:  MOVLB  0
1441C:  CALL   D8B2
....................                sol_switch_cmd(4); 
14420:  MOVLB  8
14422:  CLRF   x94
14424:  MOVLW  04
14426:  MOVWF  x93
14428:  MOVLB  0
1442A:  RCALL  14014
....................          break;  
1442C:  MOVLB  8
1442E:  BRA    144BE
....................       case 28 : sol_chip_cmd(4); 
14430:  MOVLW  04
14432:  MOVLB  8
14434:  MOVWF  x93
14436:  MOVLB  0
14438:  CALL   D8B2
....................                sol_switch_cmd(8); 
1443C:  MOVLB  8
1443E:  CLRF   x94
14440:  MOVLW  08
14442:  MOVWF  x93
14444:  MOVLB  0
14446:  RCALL  14014
....................          break;  
14448:  MOVLB  8
1444A:  BRA    144BE
....................       case 29 : sol_chip_cmd(4); 
1444C:  MOVLW  04
1444E:  MOVLB  8
14450:  MOVWF  x93
14452:  MOVLB  0
14454:  CALL   D8B2
....................                sol_switch_cmd(16); 
14458:  MOVLB  8
1445A:  CLRF   x94
1445C:  MOVLW  10
1445E:  MOVWF  x93
14460:  MOVLB  0
14462:  RCALL  14014
....................          break;  
14464:  MOVLB  8
14466:  BRA    144BE
....................       case 30 : sol_chip_cmd(4); 
14468:  MOVLW  04
1446A:  MOVLB  8
1446C:  MOVWF  x93
1446E:  MOVLB  0
14470:  CALL   D8B2
....................                sol_switch_cmd(32); 
14474:  MOVLB  8
14476:  CLRF   x94
14478:  MOVLW  20
1447A:  MOVWF  x93
1447C:  MOVLB  0
1447E:  RCALL  14014
....................          break;  
14480:  MOVLB  8
14482:  BRA    144BE
....................       case 31 : sol_chip_cmd(4); 
14484:  MOVLW  04
14486:  MOVLB  8
14488:  MOVWF  x93
1448A:  MOVLB  0
1448C:  CALL   D8B2
....................                sol_switch_cmd(64); 
14490:  MOVLB  8
14492:  CLRF   x94
14494:  MOVLW  40
14496:  MOVWF  x93
14498:  MOVLB  0
1449A:  RCALL  14014
....................          break;  
1449C:  MOVLB  8
1449E:  BRA    144BE
....................       case 32 : sol_chip_cmd(4); 
144A0:  MOVLW  04
144A2:  MOVLB  8
144A4:  MOVWF  x93
144A6:  MOVLB  0
144A8:  CALL   D8B2
....................                sol_switch_cmd(128); 
144AC:  MOVLB  8
144AE:  CLRF   x94
144B0:  MOVLW  80
144B2:  MOVWF  x93
144B4:  MOVLB  0
144B6:  RCALL  14014
....................          break; 
144B8:  MOVLB  8
144BA:  BRA    144BE
144BC:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
144BE:  MOVF   x92,F
144C0:  BZ    144DA
144C2:  MOVF   x92,W
144C4:  SUBLW  20
144C6:  BNC   144DA
144C8:  CLRF   03
144CA:  MOVF   x92,W
144CC:  ADDLW  B3
144CE:  MOVWF  FE9
144D0:  MOVLW  04
144D2:  ADDWFC 03,W
144D4:  MOVWF  FEA
144D6:  MOVLW  01
144D8:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
144DA:  MOVF   1F,W
144DC:  SUBLW  04
144DE:  BNZ   144EC
144E0:  MOVF   20,F
144E2:  BNZ   144EC
144E4:  MOVLB  0
144E6:  CALL   EA5E
144EA:  MOVLB  8
144EC:  MOVLB  0
144EE:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
10202:  MOVLB  8
10204:  CLRF   x7A
10206:  MOVF   x7A,W
10208:  SUBLW  07
1020A:  BNC   10226
1020C:  BCF    FD8.0
1020E:  RLCF   x7A,W
10210:  CLRF   03
10212:  ADDLW  47
10214:  MOVWF  FE9
10216:  MOVLW  03
10218:  ADDWFC 03,W
1021A:  MOVWF  FEA
1021C:  CLRF   FEC
1021E:  MOVF   FED,F
10220:  CLRF   FEF
10222:  INCF   x7A,F
10224:  BRA    10206
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
10226:  CLRF   x7A
10228:  MOVF   x7A,W
1022A:  SUBLW  07
1022C:  BNC   10248
1022E:  BCF    FD8.0
10230:  RLCF   x7A,W
10232:  CLRF   03
10234:  ADDLW  59
10236:  MOVWF  FE9
10238:  MOVLW  03
1023A:  ADDWFC 03,W
1023C:  MOVWF  FEA
1023E:  CLRF   FEC
10240:  MOVF   FED,F
10242:  CLRF   FEF
10244:  INCF   x7A,F
10246:  BRA    10228
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
10248:  CLRF   x7A
1024A:  MOVF   x7A,W
1024C:  SUBLW  07
1024E:  BNC   1026A
10250:  BCF    FD8.0
10252:  RLCF   x7A,W
10254:  CLRF   03
10256:  ADDLW  6B
10258:  MOVWF  FE9
1025A:  MOVLW  03
1025C:  ADDWFC 03,W
1025E:  MOVWF  FEA
10260:  CLRF   FEC
10262:  MOVF   FED,F
10264:  CLRF   FEF
10266:  INCF   x7A,F
10268:  BRA    1024A
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
1026A:  CLRF   x7A
1026C:  MOVF   x7A,W
1026E:  SUBLW  07
10270:  BNC   1028C
10272:  BCF    FD8.0
10274:  RLCF   x7A,W
10276:  CLRF   03
10278:  ADDLW  7D
1027A:  MOVWF  FE9
1027C:  MOVLW  03
1027E:  ADDWFC 03,W
10280:  MOVWF  FEA
10282:  CLRF   FEC
10284:  MOVF   FED,F
10286:  CLRF   FEF
10288:  INCF   x7A,F
1028A:  BRA    1026C
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
1028C:  CLRF   x7A
1028E:  MOVF   x7A,W
10290:  SUBLW  07
10292:  BNC   102AE
10294:  BCF    FD8.0
10296:  RLCF   x7A,W
10298:  CLRF   03
1029A:  ADDLW  8F
1029C:  MOVWF  FE9
1029E:  MOVLW  03
102A0:  ADDWFC 03,W
102A2:  MOVWF  FEA
102A4:  CLRF   FEC
102A6:  MOVF   FED,F
102A8:  CLRF   FEF
102AA:  INCF   x7A,F
102AC:  BRA    1028E
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
102AE:  MOVLW  04
102B0:  MOVWF  FEA
102B2:  MOVLW  21
102B4:  MOVWF  FE9
102B6:  CLRF   00
102B8:  CLRF   02
102BA:  MOVLW  44
102BC:  MOVWF  01
102BE:  MOVLB  0
102C0:  CALL   34A4
102C4:  GOTO   14F10 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10B38:  MOVLB  8
10B3A:  CLRF   x9F
10B3C:  MOVF   x9F,W
10B3E:  SUBLW  03
10B40:  BNC   10B60
10B42:  MOVF   x9F,W
10B44:  MULLW  04
10B46:  MOVF   FF3,W
10B48:  CLRF   03
10B4A:  ADDLW  A1
10B4C:  MOVWF  FE9
10B4E:  MOVLW  03
10B50:  ADDWFC 03,W
10B52:  MOVWF  FEA
10B54:  CLRF   FEF
10B56:  CLRF   FEC
10B58:  CLRF   FEC
10B5A:  CLRF   FEC
10B5C:  INCF   x9F,F
10B5E:  BRA    10B3C
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10B60:  MOVLB  3
10B62:  MOVF   x47,F
10B64:  BTFSS  FD8.2
10B66:  BRA    10B6C
10B68:  MOVF   x48,F
10B6A:  BZ    10C06
10B6C:  MOVF   x49,F
10B6E:  BNZ   10B74
10B70:  MOVF   x4A,F
10B72:  BZ    10C06
....................       blank = NO3_array[0]; 
10B74:  MOVFF  348,8F5
10B78:  MOVFF  347,8F4
10B7C:  MOVLB  0
10B7E:  CALL   C61A
10B82:  MOVFF  03,8A3
10B86:  MOVFF  02,8A2
10B8A:  MOVFF  01,8A1
10B8E:  MOVFF  00,8A0
....................       react = NO3_array[1]; 
10B92:  MOVFF  34A,8F5
10B96:  MOVFF  349,8F4
10B9A:  CALL   C61A
10B9E:  MOVFF  03,8A7
10BA2:  MOVFF  02,8A6
10BA6:  MOVFF  01,8A5
10BAA:  MOVFF  00,8A4
....................       ratio = blank / react; 
10BAE:  MOVFF  8A3,8DB
10BB2:  MOVFF  8A2,8DA
10BB6:  MOVFF  8A1,8D9
10BBA:  MOVFF  8A0,8D8
10BBE:  MOVFF  8A7,8DF
10BC2:  MOVFF  8A6,8DE
10BC6:  MOVFF  8A5,8DD
10BCA:  MOVFF  8A4,8DC
10BCE:  CALL   C650
10BD2:  MOVFF  03,8AB
10BD6:  MOVFF  02,8AA
10BDA:  MOVFF  01,8A9
10BDE:  MOVFF  00,8A8
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10BE2:  MOVFF  8AB,8AF
10BE6:  MOVFF  8AA,8AE
10BEA:  MOVFF  8A9,8AD
10BEE:  MOVFF  8A8,8AC
10BF2:  RCALL  108BA
10BF4:  MOVFF  03,3A4
10BF8:  MOVFF  02,3A3
10BFC:  MOVFF  01,3A2
10C00:  MOVFF  00,3A1
10C04:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10C06:  MOVF   x4B,F
10C08:  BNZ   10C0E
10C0A:  MOVF   x4C,F
10C0C:  BZ    10CA8
10C0E:  MOVF   x4D,F
10C10:  BNZ   10C16
10C12:  MOVF   x4E,F
10C14:  BZ    10CA8
....................       blank = NO3_array[2]; 
10C16:  MOVFF  34C,8F5
10C1A:  MOVFF  34B,8F4
10C1E:  MOVLB  0
10C20:  CALL   C61A
10C24:  MOVFF  03,8A3
10C28:  MOVFF  02,8A2
10C2C:  MOVFF  01,8A1
10C30:  MOVFF  00,8A0
....................       react = NO3_array[3]; 
10C34:  MOVFF  34E,8F5
10C38:  MOVFF  34D,8F4
10C3C:  CALL   C61A
10C40:  MOVFF  03,8A7
10C44:  MOVFF  02,8A6
10C48:  MOVFF  01,8A5
10C4C:  MOVFF  00,8A4
....................       ratio = blank / react;    
10C50:  MOVFF  8A3,8DB
10C54:  MOVFF  8A2,8DA
10C58:  MOVFF  8A1,8D9
10C5C:  MOVFF  8A0,8D8
10C60:  MOVFF  8A7,8DF
10C64:  MOVFF  8A6,8DE
10C68:  MOVFF  8A5,8DD
10C6C:  MOVFF  8A4,8DC
10C70:  CALL   C650
10C74:  MOVFF  03,8AB
10C78:  MOVFF  02,8AA
10C7C:  MOVFF  01,8A9
10C80:  MOVFF  00,8A8
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10C84:  MOVFF  8AB,8AF
10C88:  MOVFF  8AA,8AE
10C8C:  MOVFF  8A9,8AD
10C90:  MOVFF  8A8,8AC
10C94:  RCALL  108BA
10C96:  MOVFF  03,3A8
10C9A:  MOVFF  02,3A7
10C9E:  MOVFF  01,3A6
10CA2:  MOVFF  00,3A5
10CA6:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
10CA8:  MOVF   x4F,F
10CAA:  BNZ   10CB0
10CAC:  MOVF   x50,F
10CAE:  BZ    10D4A
10CB0:  MOVF   x51,F
10CB2:  BNZ   10CB8
10CB4:  MOVF   x52,F
10CB6:  BZ    10D4A
....................       blank = NO3_array[4]; 
10CB8:  MOVFF  350,8F5
10CBC:  MOVFF  34F,8F4
10CC0:  MOVLB  0
10CC2:  CALL   C61A
10CC6:  MOVFF  03,8A3
10CCA:  MOVFF  02,8A2
10CCE:  MOVFF  01,8A1
10CD2:  MOVFF  00,8A0
....................       react = NO3_array[5]; 
10CD6:  MOVFF  352,8F5
10CDA:  MOVFF  351,8F4
10CDE:  CALL   C61A
10CE2:  MOVFF  03,8A7
10CE6:  MOVFF  02,8A6
10CEA:  MOVFF  01,8A5
10CEE:  MOVFF  00,8A4
....................       ratio = blank / react; 
10CF2:  MOVFF  8A3,8DB
10CF6:  MOVFF  8A2,8DA
10CFA:  MOVFF  8A1,8D9
10CFE:  MOVFF  8A0,8D8
10D02:  MOVFF  8A7,8DF
10D06:  MOVFF  8A6,8DE
10D0A:  MOVFF  8A5,8DD
10D0E:  MOVFF  8A4,8DC
10D12:  CALL   C650
10D16:  MOVFF  03,8AB
10D1A:  MOVFF  02,8AA
10D1E:  MOVFF  01,8A9
10D22:  MOVFF  00,8A8
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
10D26:  MOVFF  8AB,8AF
10D2A:  MOVFF  8AA,8AE
10D2E:  MOVFF  8A9,8AD
10D32:  MOVFF  8A8,8AC
10D36:  RCALL  108BA
10D38:  MOVFF  03,3AC
10D3C:  MOVFF  02,3AB
10D40:  MOVFF  01,3AA
10D44:  MOVFF  00,3A9
10D48:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
10D4A:  MOVF   x53,F
10D4C:  BNZ   10D52
10D4E:  MOVF   x54,F
10D50:  BZ    10DEC
10D52:  MOVF   x55,F
10D54:  BNZ   10D5A
10D56:  MOVF   x56,F
10D58:  BZ    10DEC
....................       blank = NO3_array[6]; 
10D5A:  MOVFF  354,8F5
10D5E:  MOVFF  353,8F4
10D62:  MOVLB  0
10D64:  CALL   C61A
10D68:  MOVFF  03,8A3
10D6C:  MOVFF  02,8A2
10D70:  MOVFF  01,8A1
10D74:  MOVFF  00,8A0
....................       react = NO3_array[7]; 
10D78:  MOVFF  356,8F5
10D7C:  MOVFF  355,8F4
10D80:  CALL   C61A
10D84:  MOVFF  03,8A7
10D88:  MOVFF  02,8A6
10D8C:  MOVFF  01,8A5
10D90:  MOVFF  00,8A4
....................       ratio = blank / react; 
10D94:  MOVFF  8A3,8DB
10D98:  MOVFF  8A2,8DA
10D9C:  MOVFF  8A1,8D9
10DA0:  MOVFF  8A0,8D8
10DA4:  MOVFF  8A7,8DF
10DA8:  MOVFF  8A6,8DE
10DAC:  MOVFF  8A5,8DD
10DB0:  MOVFF  8A4,8DC
10DB4:  CALL   C650
10DB8:  MOVFF  03,8AB
10DBC:  MOVFF  02,8AA
10DC0:  MOVFF  01,8A9
10DC4:  MOVFF  00,8A8
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
10DC8:  MOVFF  8AB,8AF
10DCC:  MOVFF  8AA,8AE
10DD0:  MOVFF  8A9,8AD
10DD4:  MOVFF  8A8,8AC
10DD8:  RCALL  108BA
10DDA:  MOVFF  03,3B0
10DDE:  MOVFF  02,3AF
10DE2:  MOVFF  01,3AE
10DE6:  MOVFF  00,3AD
10DEA:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
10DEC:  MOVLW  04
10DEE:  MOVWF  1E
10DF0:  MOVLW  21
10DF2:  MOVWF  1D
10DF4:  MOVLW  88
10DF6:  MOVWF  FF6
10DF8:  MOVLW  1D
10DFA:  MOVWF  FF7
10DFC:  MOVLW  00
10DFE:  MOVWF  FF8
10E00:  MOVLW  06
10E02:  MOVLB  8
10E04:  MOVWF  xC8
10E06:  MOVLB  0
10E08:  CALL   A9FA
10E0C:  MOVLW  10
10E0E:  MOVWF  FE9
10E10:  MOVFF  348,8D4
10E14:  MOVFF  347,8D3
10E18:  CALL   AA2C
10E1C:  MOVLW  91
10E1E:  MOVWF  FF6
10E20:  MOVLW  1D
10E22:  MOVWF  FF7
10E24:  MOVLW  00
10E26:  MOVWF  FF8
10E28:  MOVLW  07
10E2A:  MOVLB  8
10E2C:  MOVWF  xC8
10E2E:  MOVLB  0
10E30:  CALL   A9FA
10E34:  MOVLW  10
10E36:  MOVWF  FE9
10E38:  MOVFF  34A,8D4
10E3C:  MOVFF  349,8D3
10E40:  CALL   AA2C
10E44:  MOVLW  9B
10E46:  MOVWF  FF6
10E48:  MOVLW  1D
10E4A:  MOVWF  FF7
10E4C:  MOVLW  00
10E4E:  MOVWF  FF8
10E50:  MOVLW  09
10E52:  MOVLB  8
10E54:  MOVWF  xC8
10E56:  MOVLB  0
10E58:  CALL   A9FA
10E5C:  MOVLW  89
10E5E:  MOVWF  FE9
10E60:  MOVFF  3A4,8AF
10E64:  MOVFF  3A3,8AE
10E68:  MOVFF  3A2,8AD
10E6C:  MOVFF  3A1,8AC
10E70:  MOVLW  04
10E72:  MOVLB  8
10E74:  MOVWF  xB0
10E76:  MOVLB  0
10E78:  RCALL  10926
10E7A:  MOVLW  A9
10E7C:  MOVWF  FF6
10E7E:  MOVLW  1D
10E80:  MOVWF  FF7
10E82:  MOVLW  00
10E84:  MOVWF  FF8
10E86:  MOVLW  07
10E88:  MOVLB  8
10E8A:  MOVWF  xC8
10E8C:  MOVLB  0
10E8E:  CALL   A9FA
10E92:  MOVLW  10
10E94:  MOVWF  FE9
10E96:  MOVFF  34C,8D4
10E9A:  MOVFF  34B,8D3
10E9E:  CALL   AA2C
10EA2:  MOVLW  B3
10EA4:  MOVWF  FF6
10EA6:  MOVLW  1D
10EA8:  MOVWF  FF7
10EAA:  MOVLW  00
10EAC:  MOVWF  FF8
10EAE:  MOVLW  07
10EB0:  MOVLB  8
10EB2:  MOVWF  xC8
10EB4:  MOVLB  0
10EB6:  CALL   A9FA
10EBA:  MOVLW  10
10EBC:  MOVWF  FE9
10EBE:  MOVFF  34E,8D4
10EC2:  MOVFF  34D,8D3
10EC6:  CALL   AA2C
10ECA:  MOVLW  BD
10ECC:  MOVWF  FF6
10ECE:  MOVLW  1D
10ED0:  MOVWF  FF7
10ED2:  MOVLW  00
10ED4:  MOVWF  FF8
10ED6:  MOVLW  09
10ED8:  MOVLB  8
10EDA:  MOVWF  xC8
10EDC:  MOVLB  0
10EDE:  CALL   A9FA
10EE2:  MOVLW  89
10EE4:  MOVWF  FE9
10EE6:  MOVFF  3A8,8AF
10EEA:  MOVFF  3A7,8AE
10EEE:  MOVFF  3A6,8AD
10EF2:  MOVFF  3A5,8AC
10EF6:  MOVLW  04
10EF8:  MOVLB  8
10EFA:  MOVWF  xB0
10EFC:  MOVLB  0
10EFE:  RCALL  10926
10F00:  MOVLW  CB
10F02:  MOVWF  FF6
10F04:  MOVLW  1D
10F06:  MOVWF  FF7
10F08:  MOVLW  00
10F0A:  MOVWF  FF8
10F0C:  MOVLW  07
10F0E:  MOVLB  8
10F10:  MOVWF  xC8
10F12:  MOVLB  0
10F14:  CALL   A9FA
10F18:  MOVLW  10
10F1A:  MOVWF  FE9
10F1C:  MOVFF  350,8D4
10F20:  MOVFF  34F,8D3
10F24:  CALL   AA2C
10F28:  MOVLW  D5
10F2A:  MOVWF  FF6
10F2C:  MOVLW  1D
10F2E:  MOVWF  FF7
10F30:  MOVLW  00
10F32:  MOVWF  FF8
10F34:  MOVLW  07
10F36:  MOVLB  8
10F38:  MOVWF  xC8
10F3A:  MOVLB  0
10F3C:  CALL   A9FA
10F40:  MOVLW  10
10F42:  MOVWF  FE9
10F44:  MOVFF  352,8D4
10F48:  MOVFF  351,8D3
10F4C:  CALL   AA2C
10F50:  MOVLW  DF
10F52:  MOVWF  FF6
10F54:  MOVLW  1D
10F56:  MOVWF  FF7
10F58:  MOVLW  00
10F5A:  MOVWF  FF8
10F5C:  MOVLW  09
10F5E:  MOVLB  8
10F60:  MOVWF  xC8
10F62:  MOVLB  0
10F64:  CALL   A9FA
10F68:  MOVLW  89
10F6A:  MOVWF  FE9
10F6C:  MOVFF  3AC,8AF
10F70:  MOVFF  3AB,8AE
10F74:  MOVFF  3AA,8AD
10F78:  MOVFF  3A9,8AC
10F7C:  MOVLW  04
10F7E:  MOVLB  8
10F80:  MOVWF  xB0
10F82:  MOVLB  0
10F84:  RCALL  10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
10F86:  MOVF   1F,W
10F88:  SUBLW  02
10F8A:  BNZ   10F90
10F8C:  MOVF   20,F
10F8E:  BZ    10FD0
10F90:  MOVLW  EE
10F92:  MOVWF  FF6
10F94:  MOVLW  1D
10F96:  MOVWF  FF7
10F98:  MOVLW  00
10F9A:  MOVWF  FF8
10F9C:  CLRF   1B
10F9E:  BTFSC  FF2.7
10FA0:  BSF    1B.7
10FA2:  BCF    FF2.7
10FA4:  MOVLW  09
10FA6:  MOVLB  A
10FA8:  MOVWF  x18
10FAA:  MOVLB  0
10FAC:  CALL   1006
10FB0:  BTFSC  1B.7
10FB2:  BSF    FF2.7
10FB4:  MOVLW  04
10FB6:  MOVWF  FEA
10FB8:  MOVLW  21
10FBA:  MOVWF  FE9
10FBC:  CALL   78D2
10FC0:  MOVLW  0D
10FC2:  BTFSS  F9E.4
10FC4:  BRA    10FC2
10FC6:  MOVWF  FAD
10FC8:  MOVLW  0A
10FCA:  BTFSS  F9E.4
10FCC:  BRA    10FCA
10FCE:  MOVWF  FAD
10FD0:  GOTO   122DC (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
10FD4:  MOVLB  8
10FD6:  CLRF   x9F
10FD8:  MOVF   x9F,W
10FDA:  SUBLW  03
10FDC:  BNC   10FFC
10FDE:  MOVF   x9F,W
10FE0:  MULLW  04
10FE2:  MOVF   FF3,W
10FE4:  CLRF   03
10FE6:  ADDLW  B1
10FE8:  MOVWF  FE9
10FEA:  MOVLW  03
10FEC:  ADDWFC 03,W
10FEE:  MOVWF  FEA
10FF0:  CLRF   FEF
10FF2:  CLRF   FEC
10FF4:  CLRF   FEC
10FF6:  CLRF   FEC
10FF8:  INCF   x9F,F
10FFA:  BRA    10FD8
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
10FFC:  MOVLB  3
10FFE:  MOVF   x59,F
11000:  BTFSS  FD8.2
11002:  BRA    11008
11004:  MOVF   x5A,F
11006:  BZ    110A2
11008:  MOVF   x5B,F
1100A:  BNZ   11010
1100C:  MOVF   x5C,F
1100E:  BZ    110A2
....................       blank = NO2_array[0]; 
11010:  MOVFF  35A,8F5
11014:  MOVFF  359,8F4
11018:  MOVLB  0
1101A:  CALL   C61A
1101E:  MOVFF  03,8A3
11022:  MOVFF  02,8A2
11026:  MOVFF  01,8A1
1102A:  MOVFF  00,8A0
....................       react = NO2_array[1]; 
1102E:  MOVFF  35C,8F5
11032:  MOVFF  35B,8F4
11036:  CALL   C61A
1103A:  MOVFF  03,8A7
1103E:  MOVFF  02,8A6
11042:  MOVFF  01,8A5
11046:  MOVFF  00,8A4
....................       ratio = blank / react; 
1104A:  MOVFF  8A3,8DB
1104E:  MOVFF  8A2,8DA
11052:  MOVFF  8A1,8D9
11056:  MOVFF  8A0,8D8
1105A:  MOVFF  8A7,8DF
1105E:  MOVFF  8A6,8DE
11062:  MOVFF  8A5,8DD
11066:  MOVFF  8A4,8DC
1106A:  CALL   C650
1106E:  MOVFF  03,8AB
11072:  MOVFF  02,8AA
11076:  MOVFF  01,8A9
1107A:  MOVFF  00,8A8
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
1107E:  MOVFF  8AB,8AF
11082:  MOVFF  8AA,8AE
11086:  MOVFF  8A9,8AD
1108A:  MOVFF  8A8,8AC
1108E:  RCALL  108BA
11090:  MOVFF  03,3B4
11094:  MOVFF  02,3B3
11098:  MOVFF  01,3B2
1109C:  MOVFF  00,3B1
110A0:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
110A2:  MOVF   x5D,F
110A4:  BNZ   110AA
110A6:  MOVF   x5E,F
110A8:  BZ    11146
110AA:  MOVF   x5F,F
110AC:  BNZ   110B2
110AE:  MOVF   x60,F
110B0:  BZ    11146
....................       blank = NO2_array[2]; 
110B2:  MOVFF  35E,8F5
110B6:  MOVFF  35D,8F4
110BA:  MOVLB  0
110BC:  CALL   C61A
110C0:  MOVFF  03,8A3
110C4:  MOVFF  02,8A2
110C8:  MOVFF  01,8A1
110CC:  MOVFF  00,8A0
....................       react = NO2_array[3]; 
110D0:  MOVFF  360,8F5
110D4:  MOVFF  35F,8F4
110D8:  CALL   C61A
110DC:  MOVFF  03,8A7
110E0:  MOVFF  02,8A6
110E4:  MOVFF  01,8A5
110E8:  MOVFF  00,8A4
....................       ratio = blank / react;    
110EC:  MOVFF  8A3,8DB
110F0:  MOVFF  8A2,8DA
110F4:  MOVFF  8A1,8D9
110F8:  MOVFF  8A0,8D8
110FC:  MOVFF  8A7,8DF
11100:  MOVFF  8A6,8DE
11104:  MOVFF  8A5,8DD
11108:  MOVFF  8A4,8DC
1110C:  CALL   C650
11110:  MOVFF  03,8AB
11114:  MOVFF  02,8AA
11118:  MOVFF  01,8A9
1111C:  MOVFF  00,8A8
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
11120:  MOVFF  8AB,8AF
11124:  MOVFF  8AA,8AE
11128:  MOVFF  8A9,8AD
1112C:  MOVFF  8A8,8AC
11130:  CALL   108BA
11134:  MOVFF  03,3B8
11138:  MOVFF  02,3B7
1113C:  MOVFF  01,3B6
11140:  MOVFF  00,3B5
11144:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
11146:  MOVF   x61,F
11148:  BNZ   1114E
1114A:  MOVF   x62,F
1114C:  BZ    111EA
1114E:  MOVF   x63,F
11150:  BNZ   11156
11152:  MOVF   x64,F
11154:  BZ    111EA
....................       blank = NO2_array[4]; 
11156:  MOVFF  362,8F5
1115A:  MOVFF  361,8F4
1115E:  MOVLB  0
11160:  CALL   C61A
11164:  MOVFF  03,8A3
11168:  MOVFF  02,8A2
1116C:  MOVFF  01,8A1
11170:  MOVFF  00,8A0
....................       react = NO2_array[5]; 
11174:  MOVFF  364,8F5
11178:  MOVFF  363,8F4
1117C:  CALL   C61A
11180:  MOVFF  03,8A7
11184:  MOVFF  02,8A6
11188:  MOVFF  01,8A5
1118C:  MOVFF  00,8A4
....................       ratio = blank / react; 
11190:  MOVFF  8A3,8DB
11194:  MOVFF  8A2,8DA
11198:  MOVFF  8A1,8D9
1119C:  MOVFF  8A0,8D8
111A0:  MOVFF  8A7,8DF
111A4:  MOVFF  8A6,8DE
111A8:  MOVFF  8A5,8DD
111AC:  MOVFF  8A4,8DC
111B0:  CALL   C650
111B4:  MOVFF  03,8AB
111B8:  MOVFF  02,8AA
111BC:  MOVFF  01,8A9
111C0:  MOVFF  00,8A8
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
111C4:  MOVFF  8AB,8AF
111C8:  MOVFF  8AA,8AE
111CC:  MOVFF  8A9,8AD
111D0:  MOVFF  8A8,8AC
111D4:  CALL   108BA
111D8:  MOVFF  03,3BC
111DC:  MOVFF  02,3BB
111E0:  MOVFF  01,3BA
111E4:  MOVFF  00,3B9
111E8:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
111EA:  MOVF   x65,F
111EC:  BNZ   111F2
111EE:  MOVF   x66,F
111F0:  BZ    1128E
111F2:  MOVF   x67,F
111F4:  BNZ   111FA
111F6:  MOVF   x68,F
111F8:  BZ    1128E
....................       blank = NO2_array[6]; 
111FA:  MOVFF  366,8F5
111FE:  MOVFF  365,8F4
11202:  MOVLB  0
11204:  CALL   C61A
11208:  MOVFF  03,8A3
1120C:  MOVFF  02,8A2
11210:  MOVFF  01,8A1
11214:  MOVFF  00,8A0
....................       react = NO2_array[7]; 
11218:  MOVFF  368,8F5
1121C:  MOVFF  367,8F4
11220:  CALL   C61A
11224:  MOVFF  03,8A7
11228:  MOVFF  02,8A6
1122C:  MOVFF  01,8A5
11230:  MOVFF  00,8A4
....................       ratio = blank / react; 
11234:  MOVFF  8A3,8DB
11238:  MOVFF  8A2,8DA
1123C:  MOVFF  8A1,8D9
11240:  MOVFF  8A0,8D8
11244:  MOVFF  8A7,8DF
11248:  MOVFF  8A6,8DE
1124C:  MOVFF  8A5,8DD
11250:  MOVFF  8A4,8DC
11254:  CALL   C650
11258:  MOVFF  03,8AB
1125C:  MOVFF  02,8AA
11260:  MOVFF  01,8A9
11264:  MOVFF  00,8A8
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
11268:  MOVFF  8AB,8AF
1126C:  MOVFF  8AA,8AE
11270:  MOVFF  8A9,8AD
11274:  MOVFF  8A8,8AC
11278:  CALL   108BA
1127C:  MOVFF  03,3C0
11280:  MOVFF  02,3BF
11284:  MOVFF  01,3BE
11288:  MOVFF  00,3BD
1128C:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
1128E:  MOVLW  04
11290:  MOVWF  1E
11292:  MOVLW  21
11294:  MOVWF  1D
11296:  MOVLW  FC
11298:  MOVWF  FF6
1129A:  MOVLW  1D
1129C:  MOVWF  FF7
1129E:  MOVLW  00
112A0:  MOVWF  FF8
112A2:  MOVLW  06
112A4:  MOVLB  8
112A6:  MOVWF  xC8
112A8:  MOVLB  0
112AA:  CALL   A9FA
112AE:  MOVLW  10
112B0:  MOVWF  FE9
112B2:  MOVFF  35A,8D4
112B6:  MOVFF  359,8D3
112BA:  CALL   AA2C
112BE:  MOVLW  05
112C0:  MOVWF  FF6
112C2:  MOVLW  1E
112C4:  MOVWF  FF7
112C6:  MOVLW  00
112C8:  MOVWF  FF8
112CA:  MOVLW  07
112CC:  MOVLB  8
112CE:  MOVWF  xC8
112D0:  MOVLB  0
112D2:  CALL   A9FA
112D6:  MOVLW  10
112D8:  MOVWF  FE9
112DA:  MOVFF  35C,8D4
112DE:  MOVFF  35B,8D3
112E2:  CALL   AA2C
112E6:  MOVLW  0F
112E8:  MOVWF  FF6
112EA:  MOVLW  1E
112EC:  MOVWF  FF7
112EE:  MOVLW  00
112F0:  MOVWF  FF8
112F2:  MOVLW  09
112F4:  MOVLB  8
112F6:  MOVWF  xC8
112F8:  MOVLB  0
112FA:  CALL   A9FA
112FE:  MOVLW  89
11300:  MOVWF  FE9
11302:  MOVFF  3B4,8AF
11306:  MOVFF  3B3,8AE
1130A:  MOVFF  3B2,8AD
1130E:  MOVFF  3B1,8AC
11312:  MOVLW  04
11314:  MOVLB  8
11316:  MOVWF  xB0
11318:  MOVLB  0
1131A:  CALL   10926
1131E:  MOVLW  1D
11320:  MOVWF  FF6
11322:  MOVLW  1E
11324:  MOVWF  FF7
11326:  MOVLW  00
11328:  MOVWF  FF8
1132A:  MOVLW  07
1132C:  MOVLB  8
1132E:  MOVWF  xC8
11330:  MOVLB  0
11332:  CALL   A9FA
11336:  MOVLW  10
11338:  MOVWF  FE9
1133A:  MOVFF  35E,8D4
1133E:  MOVFF  35D,8D3
11342:  CALL   AA2C
11346:  MOVLW  27
11348:  MOVWF  FF6
1134A:  MOVLW  1E
1134C:  MOVWF  FF7
1134E:  MOVLW  00
11350:  MOVWF  FF8
11352:  MOVLW  07
11354:  MOVLB  8
11356:  MOVWF  xC8
11358:  MOVLB  0
1135A:  CALL   A9FA
1135E:  MOVLW  10
11360:  MOVWF  FE9
11362:  MOVFF  360,8D4
11366:  MOVFF  35F,8D3
1136A:  CALL   AA2C
1136E:  MOVLW  31
11370:  MOVWF  FF6
11372:  MOVLW  1E
11374:  MOVWF  FF7
11376:  MOVLW  00
11378:  MOVWF  FF8
1137A:  MOVLW  09
1137C:  MOVLB  8
1137E:  MOVWF  xC8
11380:  MOVLB  0
11382:  CALL   A9FA
11386:  MOVLW  89
11388:  MOVWF  FE9
1138A:  MOVFF  3B8,8AF
1138E:  MOVFF  3B7,8AE
11392:  MOVFF  3B6,8AD
11396:  MOVFF  3B5,8AC
1139A:  MOVLW  04
1139C:  MOVLB  8
1139E:  MOVWF  xB0
113A0:  MOVLB  0
113A2:  CALL   10926
113A6:  MOVLW  3F
113A8:  MOVWF  FF6
113AA:  MOVLW  1E
113AC:  MOVWF  FF7
113AE:  MOVLW  00
113B0:  MOVWF  FF8
113B2:  MOVLW  07
113B4:  MOVLB  8
113B6:  MOVWF  xC8
113B8:  MOVLB  0
113BA:  CALL   A9FA
113BE:  MOVLW  10
113C0:  MOVWF  FE9
113C2:  MOVFF  362,8D4
113C6:  MOVFF  361,8D3
113CA:  CALL   AA2C
113CE:  MOVLW  49
113D0:  MOVWF  FF6
113D2:  MOVLW  1E
113D4:  MOVWF  FF7
113D6:  MOVLW  00
113D8:  MOVWF  FF8
113DA:  MOVLW  07
113DC:  MOVLB  8
113DE:  MOVWF  xC8
113E0:  MOVLB  0
113E2:  CALL   A9FA
113E6:  MOVLW  10
113E8:  MOVWF  FE9
113EA:  MOVFF  364,8D4
113EE:  MOVFF  363,8D3
113F2:  CALL   AA2C
113F6:  MOVLW  53
113F8:  MOVWF  FF6
113FA:  MOVLW  1E
113FC:  MOVWF  FF7
113FE:  MOVLW  00
11400:  MOVWF  FF8
11402:  MOVLW  09
11404:  MOVLB  8
11406:  MOVWF  xC8
11408:  MOVLB  0
1140A:  CALL   A9FA
1140E:  MOVLW  89
11410:  MOVWF  FE9
11412:  MOVFF  3BC,8AF
11416:  MOVFF  3BB,8AE
1141A:  MOVFF  3BA,8AD
1141E:  MOVFF  3B9,8AC
11422:  MOVLW  04
11424:  MOVLB  8
11426:  MOVWF  xB0
11428:  MOVLB  0
1142A:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
1142E:  MOVF   1F,W
11430:  SUBLW  02
11432:  BNZ   11438
11434:  MOVF   20,F
11436:  BZ    11478
11438:  MOVLW  62
1143A:  MOVWF  FF6
1143C:  MOVLW  1E
1143E:  MOVWF  FF7
11440:  MOVLW  00
11442:  MOVWF  FF8
11444:  CLRF   1B
11446:  BTFSC  FF2.7
11448:  BSF    1B.7
1144A:  BCF    FF2.7
1144C:  MOVLW  09
1144E:  MOVLB  A
11450:  MOVWF  x18
11452:  MOVLB  0
11454:  CALL   1006
11458:  BTFSC  1B.7
1145A:  BSF    FF2.7
1145C:  MOVLW  04
1145E:  MOVWF  FEA
11460:  MOVLW  21
11462:  MOVWF  FE9
11464:  CALL   78D2
11468:  MOVLW  0D
1146A:  BTFSS  F9E.4
1146C:  BRA    1146A
1146E:  MOVWF  FAD
11470:  MOVLW  0A
11472:  BTFSS  F9E.4
11474:  BRA    11472
11476:  MOVWF  FAD
11478:  GOTO   122DC (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
1147C:  MOVLB  8
1147E:  CLRF   x9F
11480:  MOVF   x9F,W
11482:  SUBLW  03
11484:  BNC   114A4
11486:  MOVF   x9F,W
11488:  MULLW  04
1148A:  MOVF   FF3,W
1148C:  CLRF   03
1148E:  ADDLW  C1
11490:  MOVWF  FE9
11492:  MOVLW  03
11494:  ADDWFC 03,W
11496:  MOVWF  FEA
11498:  CLRF   FEF
1149A:  CLRF   FEC
1149C:  CLRF   FEC
1149E:  CLRF   FEC
114A0:  INCF   x9F,F
114A2:  BRA    11480
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
114A4:  MOVLB  3
114A6:  MOVF   x6B,F
114A8:  BTFSS  FD8.2
114AA:  BRA    114B0
114AC:  MOVF   x6C,F
114AE:  BZ    1154C
114B0:  MOVF   x6D,F
114B2:  BNZ   114B8
114B4:  MOVF   x6E,F
114B6:  BZ    1154C
....................       blank = PO4_array[0]; 
114B8:  MOVFF  36C,8F5
114BC:  MOVFF  36B,8F4
114C0:  MOVLB  0
114C2:  CALL   C61A
114C6:  MOVFF  03,8A3
114CA:  MOVFF  02,8A2
114CE:  MOVFF  01,8A1
114D2:  MOVFF  00,8A0
....................       react = PO4_array[1]; 
114D6:  MOVFF  36E,8F5
114DA:  MOVFF  36D,8F4
114DE:  CALL   C61A
114E2:  MOVFF  03,8A7
114E6:  MOVFF  02,8A6
114EA:  MOVFF  01,8A5
114EE:  MOVFF  00,8A4
....................       ratio = blank / react; 
114F2:  MOVFF  8A3,8DB
114F6:  MOVFF  8A2,8DA
114FA:  MOVFF  8A1,8D9
114FE:  MOVFF  8A0,8D8
11502:  MOVFF  8A7,8DF
11506:  MOVFF  8A6,8DE
1150A:  MOVFF  8A5,8DD
1150E:  MOVFF  8A4,8DC
11512:  CALL   C650
11516:  MOVFF  03,8AB
1151A:  MOVFF  02,8AA
1151E:  MOVFF  01,8A9
11522:  MOVFF  00,8A8
....................       PO4_abs_array[0] = log10(ratio); 
11526:  MOVFF  8AB,8AF
1152A:  MOVFF  8AA,8AE
1152E:  MOVFF  8A9,8AD
11532:  MOVFF  8A8,8AC
11536:  CALL   108BA
1153A:  MOVFF  03,3C4
1153E:  MOVFF  02,3C3
11542:  MOVFF  01,3C2
11546:  MOVFF  00,3C1
1154A:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
1154C:  MOVF   x6F,F
1154E:  BNZ   11554
11550:  MOVF   x70,F
11552:  BZ    115F0
11554:  MOVF   x71,F
11556:  BNZ   1155C
11558:  MOVF   x72,F
1155A:  BZ    115F0
....................       blank = PO4_array[2]; 
1155C:  MOVFF  370,8F5
11560:  MOVFF  36F,8F4
11564:  MOVLB  0
11566:  CALL   C61A
1156A:  MOVFF  03,8A3
1156E:  MOVFF  02,8A2
11572:  MOVFF  01,8A1
11576:  MOVFF  00,8A0
....................       react = PO4_array[3]; 
1157A:  MOVFF  372,8F5
1157E:  MOVFF  371,8F4
11582:  CALL   C61A
11586:  MOVFF  03,8A7
1158A:  MOVFF  02,8A6
1158E:  MOVFF  01,8A5
11592:  MOVFF  00,8A4
....................       ratio = blank / react;    
11596:  MOVFF  8A3,8DB
1159A:  MOVFF  8A2,8DA
1159E:  MOVFF  8A1,8D9
115A2:  MOVFF  8A0,8D8
115A6:  MOVFF  8A7,8DF
115AA:  MOVFF  8A6,8DE
115AE:  MOVFF  8A5,8DD
115B2:  MOVFF  8A4,8DC
115B6:  CALL   C650
115BA:  MOVFF  03,8AB
115BE:  MOVFF  02,8AA
115C2:  MOVFF  01,8A9
115C6:  MOVFF  00,8A8
....................       PO4_abs_array[1] = log10(ratio); 
115CA:  MOVFF  8AB,8AF
115CE:  MOVFF  8AA,8AE
115D2:  MOVFF  8A9,8AD
115D6:  MOVFF  8A8,8AC
115DA:  CALL   108BA
115DE:  MOVFF  03,3C8
115E2:  MOVFF  02,3C7
115E6:  MOVFF  01,3C6
115EA:  MOVFF  00,3C5
115EE:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
115F0:  MOVF   x73,F
115F2:  BNZ   115F8
115F4:  MOVF   x74,F
115F6:  BZ    11694
115F8:  MOVF   x75,F
115FA:  BNZ   11600
115FC:  MOVF   x76,F
115FE:  BZ    11694
....................       blank = PO4_array[4]; 
11600:  MOVFF  374,8F5
11604:  MOVFF  373,8F4
11608:  MOVLB  0
1160A:  CALL   C61A
1160E:  MOVFF  03,8A3
11612:  MOVFF  02,8A2
11616:  MOVFF  01,8A1
1161A:  MOVFF  00,8A0
....................       react = PO4_array[5]; 
1161E:  MOVFF  376,8F5
11622:  MOVFF  375,8F4
11626:  CALL   C61A
1162A:  MOVFF  03,8A7
1162E:  MOVFF  02,8A6
11632:  MOVFF  01,8A5
11636:  MOVFF  00,8A4
....................       ratio = blank / react; 
1163A:  MOVFF  8A3,8DB
1163E:  MOVFF  8A2,8DA
11642:  MOVFF  8A1,8D9
11646:  MOVFF  8A0,8D8
1164A:  MOVFF  8A7,8DF
1164E:  MOVFF  8A6,8DE
11652:  MOVFF  8A5,8DD
11656:  MOVFF  8A4,8DC
1165A:  CALL   C650
1165E:  MOVFF  03,8AB
11662:  MOVFF  02,8AA
11666:  MOVFF  01,8A9
1166A:  MOVFF  00,8A8
....................       PO4_abs_array[2] = log10(ratio); 
1166E:  MOVFF  8AB,8AF
11672:  MOVFF  8AA,8AE
11676:  MOVFF  8A9,8AD
1167A:  MOVFF  8A8,8AC
1167E:  CALL   108BA
11682:  MOVFF  03,3CC
11686:  MOVFF  02,3CB
1168A:  MOVFF  01,3CA
1168E:  MOVFF  00,3C9
11692:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
11694:  MOVF   x77,F
11696:  BNZ   1169C
11698:  MOVF   x78,F
1169A:  BZ    11738
1169C:  MOVF   x79,F
1169E:  BNZ   116A4
116A0:  MOVF   x7A,F
116A2:  BZ    11738
....................       blank = PO4_array[6]; 
116A4:  MOVFF  378,8F5
116A8:  MOVFF  377,8F4
116AC:  MOVLB  0
116AE:  CALL   C61A
116B2:  MOVFF  03,8A3
116B6:  MOVFF  02,8A2
116BA:  MOVFF  01,8A1
116BE:  MOVFF  00,8A0
....................       react = PO4_array[7]; 
116C2:  MOVFF  37A,8F5
116C6:  MOVFF  379,8F4
116CA:  CALL   C61A
116CE:  MOVFF  03,8A7
116D2:  MOVFF  02,8A6
116D6:  MOVFF  01,8A5
116DA:  MOVFF  00,8A4
....................       ratio = blank / react; 
116DE:  MOVFF  8A3,8DB
116E2:  MOVFF  8A2,8DA
116E6:  MOVFF  8A1,8D9
116EA:  MOVFF  8A0,8D8
116EE:  MOVFF  8A7,8DF
116F2:  MOVFF  8A6,8DE
116F6:  MOVFF  8A5,8DD
116FA:  MOVFF  8A4,8DC
116FE:  CALL   C650
11702:  MOVFF  03,8AB
11706:  MOVFF  02,8AA
1170A:  MOVFF  01,8A9
1170E:  MOVFF  00,8A8
....................       PO4_abs_array[3] = log10(ratio); 
11712:  MOVFF  8AB,8AF
11716:  MOVFF  8AA,8AE
1171A:  MOVFF  8A9,8AD
1171E:  MOVFF  8A8,8AC
11722:  CALL   108BA
11726:  MOVFF  03,3D0
1172A:  MOVFF  02,3CF
1172E:  MOVFF  01,3CE
11732:  MOVFF  00,3CD
11736:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
11738:  MOVLW  04
1173A:  MOVWF  1E
1173C:  MOVLW  21
1173E:  MOVWF  1D
11740:  MOVLW  70
11742:  MOVWF  FF6
11744:  MOVLW  1E
11746:  MOVWF  FF7
11748:  MOVLW  00
1174A:  MOVWF  FF8
1174C:  MOVLW  06
1174E:  MOVLB  8
11750:  MOVWF  xC8
11752:  MOVLB  0
11754:  CALL   A9FA
11758:  MOVLW  10
1175A:  MOVWF  FE9
1175C:  MOVFF  36C,8D4
11760:  MOVFF  36B,8D3
11764:  CALL   AA2C
11768:  MOVLW  79
1176A:  MOVWF  FF6
1176C:  MOVLW  1E
1176E:  MOVWF  FF7
11770:  MOVLW  00
11772:  MOVWF  FF8
11774:  MOVLW  07
11776:  MOVLB  8
11778:  MOVWF  xC8
1177A:  MOVLB  0
1177C:  CALL   A9FA
11780:  MOVLW  10
11782:  MOVWF  FE9
11784:  MOVFF  36E,8D4
11788:  MOVFF  36D,8D3
1178C:  CALL   AA2C
11790:  MOVLW  83
11792:  MOVWF  FF6
11794:  MOVLW  1E
11796:  MOVWF  FF7
11798:  MOVLW  00
1179A:  MOVWF  FF8
1179C:  MOVLW  09
1179E:  MOVLB  8
117A0:  MOVWF  xC8
117A2:  MOVLB  0
117A4:  CALL   A9FA
117A8:  MOVLW  89
117AA:  MOVWF  FE9
117AC:  MOVFF  3C4,8AF
117B0:  MOVFF  3C3,8AE
117B4:  MOVFF  3C2,8AD
117B8:  MOVFF  3C1,8AC
117BC:  MOVLW  04
117BE:  MOVLB  8
117C0:  MOVWF  xB0
117C2:  MOVLB  0
117C4:  CALL   10926
117C8:  MOVLW  91
117CA:  MOVWF  FF6
117CC:  MOVLW  1E
117CE:  MOVWF  FF7
117D0:  MOVLW  00
117D2:  MOVWF  FF8
117D4:  MOVLW  07
117D6:  MOVLB  8
117D8:  MOVWF  xC8
117DA:  MOVLB  0
117DC:  CALL   A9FA
117E0:  MOVLW  10
117E2:  MOVWF  FE9
117E4:  MOVFF  370,8D4
117E8:  MOVFF  36F,8D3
117EC:  CALL   AA2C
117F0:  MOVLW  9B
117F2:  MOVWF  FF6
117F4:  MOVLW  1E
117F6:  MOVWF  FF7
117F8:  MOVLW  00
117FA:  MOVWF  FF8
117FC:  MOVLW  07
117FE:  MOVLB  8
11800:  MOVWF  xC8
11802:  MOVLB  0
11804:  CALL   A9FA
11808:  MOVLW  10
1180A:  MOVWF  FE9
1180C:  MOVFF  372,8D4
11810:  MOVFF  371,8D3
11814:  CALL   AA2C
11818:  MOVLW  A5
1181A:  MOVWF  FF6
1181C:  MOVLW  1E
1181E:  MOVWF  FF7
11820:  MOVLW  00
11822:  MOVWF  FF8
11824:  MOVLW  09
11826:  MOVLB  8
11828:  MOVWF  xC8
1182A:  MOVLB  0
1182C:  CALL   A9FA
11830:  MOVLW  89
11832:  MOVWF  FE9
11834:  MOVFF  3C8,8AF
11838:  MOVFF  3C7,8AE
1183C:  MOVFF  3C6,8AD
11840:  MOVFF  3C5,8AC
11844:  MOVLW  04
11846:  MOVLB  8
11848:  MOVWF  xB0
1184A:  MOVLB  0
1184C:  CALL   10926
11850:  MOVLW  B3
11852:  MOVWF  FF6
11854:  MOVLW  1E
11856:  MOVWF  FF7
11858:  MOVLW  00
1185A:  MOVWF  FF8
1185C:  MOVLW  07
1185E:  MOVLB  8
11860:  MOVWF  xC8
11862:  MOVLB  0
11864:  CALL   A9FA
11868:  MOVLW  10
1186A:  MOVWF  FE9
1186C:  MOVFF  374,8D4
11870:  MOVFF  373,8D3
11874:  CALL   AA2C
11878:  MOVLW  BD
1187A:  MOVWF  FF6
1187C:  MOVLW  1E
1187E:  MOVWF  FF7
11880:  MOVLW  00
11882:  MOVWF  FF8
11884:  MOVLW  07
11886:  MOVLB  8
11888:  MOVWF  xC8
1188A:  MOVLB  0
1188C:  CALL   A9FA
11890:  MOVLW  10
11892:  MOVWF  FE9
11894:  MOVFF  376,8D4
11898:  MOVFF  375,8D3
1189C:  CALL   AA2C
118A0:  MOVLW  C7
118A2:  MOVWF  FF6
118A4:  MOVLW  1E
118A6:  MOVWF  FF7
118A8:  MOVLW  00
118AA:  MOVWF  FF8
118AC:  MOVLW  09
118AE:  MOVLB  8
118B0:  MOVWF  xC8
118B2:  MOVLB  0
118B4:  CALL   A9FA
118B8:  MOVLW  89
118BA:  MOVWF  FE9
118BC:  MOVFF  3CC,8AF
118C0:  MOVFF  3CB,8AE
118C4:  MOVFF  3CA,8AD
118C8:  MOVFF  3C9,8AC
118CC:  MOVLW  04
118CE:  MOVLB  8
118D0:  MOVWF  xB0
118D2:  MOVLB  0
118D4:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
118D8:  MOVF   1F,W
118DA:  SUBLW  02
118DC:  BNZ   118E2
118DE:  MOVF   20,F
118E0:  BZ    11922
118E2:  MOVLW  D6
118E4:  MOVWF  FF6
118E6:  MOVLW  1E
118E8:  MOVWF  FF7
118EA:  MOVLW  00
118EC:  MOVWF  FF8
118EE:  CLRF   1B
118F0:  BTFSC  FF2.7
118F2:  BSF    1B.7
118F4:  BCF    FF2.7
118F6:  MOVLW  09
118F8:  MOVLB  A
118FA:  MOVWF  x18
118FC:  MOVLB  0
118FE:  CALL   1006
11902:  BTFSC  1B.7
11904:  BSF    FF2.7
11906:  MOVLW  04
11908:  MOVWF  FEA
1190A:  MOVLW  21
1190C:  MOVWF  FE9
1190E:  CALL   78D2
11912:  MOVLW  0D
11914:  BTFSS  F9E.4
11916:  BRA    11914
11918:  MOVWF  FAD
1191A:  MOVLW  0A
1191C:  BTFSS  F9E.4
1191E:  BRA    1191C
11920:  MOVWF  FAD
11922:  GOTO   122DC (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
11926:  MOVLB  8
11928:  CLRF   x9F
1192A:  MOVF   x9F,W
1192C:  SUBLW  03
1192E:  BNC   1194E
11930:  MOVF   x9F,W
11932:  MULLW  04
11934:  MOVF   FF3,W
11936:  CLRF   03
11938:  ADDLW  D1
1193A:  MOVWF  FE9
1193C:  MOVLW  03
1193E:  ADDWFC 03,W
11940:  MOVWF  FEA
11942:  CLRF   FEF
11944:  CLRF   FEC
11946:  CLRF   FEC
11948:  CLRF   FEC
1194A:  INCF   x9F,F
1194C:  BRA    1192A
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
1194E:  MOVLB  3
11950:  MOVF   x7D,F
11952:  BTFSS  FD8.2
11954:  BRA    1195A
11956:  MOVF   x7E,F
11958:  BZ    119F6
1195A:  MOVF   x7F,F
1195C:  BNZ   11962
1195E:  MOVF   x80,F
11960:  BZ    119F6
....................       blank = NH4_array[0]; 
11962:  MOVFF  37E,8F5
11966:  MOVFF  37D,8F4
1196A:  MOVLB  0
1196C:  CALL   C61A
11970:  MOVFF  03,8A3
11974:  MOVFF  02,8A2
11978:  MOVFF  01,8A1
1197C:  MOVFF  00,8A0
....................       react = NH4_array[1]; 
11980:  MOVFF  380,8F5
11984:  MOVFF  37F,8F4
11988:  CALL   C61A
1198C:  MOVFF  03,8A7
11990:  MOVFF  02,8A6
11994:  MOVFF  01,8A5
11998:  MOVFF  00,8A4
....................       ratio = blank / react; 
1199C:  MOVFF  8A3,8DB
119A0:  MOVFF  8A2,8DA
119A4:  MOVFF  8A1,8D9
119A8:  MOVFF  8A0,8D8
119AC:  MOVFF  8A7,8DF
119B0:  MOVFF  8A6,8DE
119B4:  MOVFF  8A5,8DD
119B8:  MOVFF  8A4,8DC
119BC:  CALL   C650
119C0:  MOVFF  03,8AB
119C4:  MOVFF  02,8AA
119C8:  MOVFF  01,8A9
119CC:  MOVFF  00,8A8
....................       NH4_abs_array[0] = log10(ratio); 
119D0:  MOVFF  8AB,8AF
119D4:  MOVFF  8AA,8AE
119D8:  MOVFF  8A9,8AD
119DC:  MOVFF  8A8,8AC
119E0:  CALL   108BA
119E4:  MOVFF  03,3D4
119E8:  MOVFF  02,3D3
119EC:  MOVFF  01,3D2
119F0:  MOVFF  00,3D1
119F4:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
119F6:  MOVF   x81,F
119F8:  BNZ   119FE
119FA:  MOVF   x82,F
119FC:  BZ    11A9A
119FE:  MOVF   x83,F
11A00:  BNZ   11A06
11A02:  MOVF   x84,F
11A04:  BZ    11A9A
....................       blank = NH4_array[2]; 
11A06:  MOVFF  382,8F5
11A0A:  MOVFF  381,8F4
11A0E:  MOVLB  0
11A10:  CALL   C61A
11A14:  MOVFF  03,8A3
11A18:  MOVFF  02,8A2
11A1C:  MOVFF  01,8A1
11A20:  MOVFF  00,8A0
....................       react = NH4_array[3]; 
11A24:  MOVFF  384,8F5
11A28:  MOVFF  383,8F4
11A2C:  CALL   C61A
11A30:  MOVFF  03,8A7
11A34:  MOVFF  02,8A6
11A38:  MOVFF  01,8A5
11A3C:  MOVFF  00,8A4
....................       ratio = blank / react;    
11A40:  MOVFF  8A3,8DB
11A44:  MOVFF  8A2,8DA
11A48:  MOVFF  8A1,8D9
11A4C:  MOVFF  8A0,8D8
11A50:  MOVFF  8A7,8DF
11A54:  MOVFF  8A6,8DE
11A58:  MOVFF  8A5,8DD
11A5C:  MOVFF  8A4,8DC
11A60:  CALL   C650
11A64:  MOVFF  03,8AB
11A68:  MOVFF  02,8AA
11A6C:  MOVFF  01,8A9
11A70:  MOVFF  00,8A8
....................       NH4_abs_array[1] = log10(ratio); 
11A74:  MOVFF  8AB,8AF
11A78:  MOVFF  8AA,8AE
11A7C:  MOVFF  8A9,8AD
11A80:  MOVFF  8A8,8AC
11A84:  CALL   108BA
11A88:  MOVFF  03,3D8
11A8C:  MOVFF  02,3D7
11A90:  MOVFF  01,3D6
11A94:  MOVFF  00,3D5
11A98:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
11A9A:  MOVF   x85,F
11A9C:  BNZ   11AA2
11A9E:  MOVF   x86,F
11AA0:  BZ    11B3E
11AA2:  MOVF   x87,F
11AA4:  BNZ   11AAA
11AA6:  MOVF   x88,F
11AA8:  BZ    11B3E
....................       blank = NH4_array[4]; 
11AAA:  MOVFF  386,8F5
11AAE:  MOVFF  385,8F4
11AB2:  MOVLB  0
11AB4:  CALL   C61A
11AB8:  MOVFF  03,8A3
11ABC:  MOVFF  02,8A2
11AC0:  MOVFF  01,8A1
11AC4:  MOVFF  00,8A0
....................       react = NH4_array[5]; 
11AC8:  MOVFF  388,8F5
11ACC:  MOVFF  387,8F4
11AD0:  CALL   C61A
11AD4:  MOVFF  03,8A7
11AD8:  MOVFF  02,8A6
11ADC:  MOVFF  01,8A5
11AE0:  MOVFF  00,8A4
....................       ratio = blank / react; 
11AE4:  MOVFF  8A3,8DB
11AE8:  MOVFF  8A2,8DA
11AEC:  MOVFF  8A1,8D9
11AF0:  MOVFF  8A0,8D8
11AF4:  MOVFF  8A7,8DF
11AF8:  MOVFF  8A6,8DE
11AFC:  MOVFF  8A5,8DD
11B00:  MOVFF  8A4,8DC
11B04:  CALL   C650
11B08:  MOVFF  03,8AB
11B0C:  MOVFF  02,8AA
11B10:  MOVFF  01,8A9
11B14:  MOVFF  00,8A8
....................       NH4_abs_array[2] = log10(ratio); 
11B18:  MOVFF  8AB,8AF
11B1C:  MOVFF  8AA,8AE
11B20:  MOVFF  8A9,8AD
11B24:  MOVFF  8A8,8AC
11B28:  CALL   108BA
11B2C:  MOVFF  03,3DC
11B30:  MOVFF  02,3DB
11B34:  MOVFF  01,3DA
11B38:  MOVFF  00,3D9
11B3C:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11B3E:  MOVF   x89,F
11B40:  BNZ   11B46
11B42:  MOVF   x8A,F
11B44:  BZ    11BE2
11B46:  MOVF   x8B,F
11B48:  BNZ   11B4E
11B4A:  MOVF   x8C,F
11B4C:  BZ    11BE2
....................       blank = NH4_array[6]; 
11B4E:  MOVFF  38A,8F5
11B52:  MOVFF  389,8F4
11B56:  MOVLB  0
11B58:  CALL   C61A
11B5C:  MOVFF  03,8A3
11B60:  MOVFF  02,8A2
11B64:  MOVFF  01,8A1
11B68:  MOVFF  00,8A0
....................       react = NH4_array[7]; 
11B6C:  MOVFF  38C,8F5
11B70:  MOVFF  38B,8F4
11B74:  CALL   C61A
11B78:  MOVFF  03,8A7
11B7C:  MOVFF  02,8A6
11B80:  MOVFF  01,8A5
11B84:  MOVFF  00,8A4
....................       ratio = blank / react; 
11B88:  MOVFF  8A3,8DB
11B8C:  MOVFF  8A2,8DA
11B90:  MOVFF  8A1,8D9
11B94:  MOVFF  8A0,8D8
11B98:  MOVFF  8A7,8DF
11B9C:  MOVFF  8A6,8DE
11BA0:  MOVFF  8A5,8DD
11BA4:  MOVFF  8A4,8DC
11BA8:  CALL   C650
11BAC:  MOVFF  03,8AB
11BB0:  MOVFF  02,8AA
11BB4:  MOVFF  01,8A9
11BB8:  MOVFF  00,8A8
....................       NH4_abs_array[3] = log10(ratio); 
11BBC:  MOVFF  8AB,8AF
11BC0:  MOVFF  8AA,8AE
11BC4:  MOVFF  8A9,8AD
11BC8:  MOVFF  8A8,8AC
11BCC:  CALL   108BA
11BD0:  MOVFF  03,3E0
11BD4:  MOVFF  02,3DF
11BD8:  MOVFF  01,3DE
11BDC:  MOVFF  00,3DD
11BE0:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11BE2:  MOVLW  04
11BE4:  MOVWF  1E
11BE6:  MOVLW  21
11BE8:  MOVWF  1D
11BEA:  MOVLW  E4
11BEC:  MOVWF  FF6
11BEE:  MOVLW  1E
11BF0:  MOVWF  FF7
11BF2:  MOVLW  00
11BF4:  MOVWF  FF8
11BF6:  MOVLW  06
11BF8:  MOVLB  8
11BFA:  MOVWF  xC8
11BFC:  MOVLB  0
11BFE:  CALL   A9FA
11C02:  MOVLW  10
11C04:  MOVWF  FE9
11C06:  MOVFF  37E,8D4
11C0A:  MOVFF  37D,8D3
11C0E:  CALL   AA2C
11C12:  MOVLW  ED
11C14:  MOVWF  FF6
11C16:  MOVLW  1E
11C18:  MOVWF  FF7
11C1A:  MOVLW  00
11C1C:  MOVWF  FF8
11C1E:  MOVLW  07
11C20:  MOVLB  8
11C22:  MOVWF  xC8
11C24:  MOVLB  0
11C26:  CALL   A9FA
11C2A:  MOVLW  10
11C2C:  MOVWF  FE9
11C2E:  MOVFF  380,8D4
11C32:  MOVFF  37F,8D3
11C36:  CALL   AA2C
11C3A:  MOVLW  F7
11C3C:  MOVWF  FF6
11C3E:  MOVLW  1E
11C40:  MOVWF  FF7
11C42:  MOVLW  00
11C44:  MOVWF  FF8
11C46:  MOVLW  09
11C48:  MOVLB  8
11C4A:  MOVWF  xC8
11C4C:  MOVLB  0
11C4E:  CALL   A9FA
11C52:  MOVLW  89
11C54:  MOVWF  FE9
11C56:  MOVFF  3D4,8AF
11C5A:  MOVFF  3D3,8AE
11C5E:  MOVFF  3D2,8AD
11C62:  MOVFF  3D1,8AC
11C66:  MOVLW  04
11C68:  MOVLB  8
11C6A:  MOVWF  xB0
11C6C:  MOVLB  0
11C6E:  CALL   10926
11C72:  MOVLW  05
11C74:  MOVWF  FF6
11C76:  MOVLW  1F
11C78:  MOVWF  FF7
11C7A:  MOVLW  00
11C7C:  MOVWF  FF8
11C7E:  MOVLW  07
11C80:  MOVLB  8
11C82:  MOVWF  xC8
11C84:  MOVLB  0
11C86:  CALL   A9FA
11C8A:  MOVLW  10
11C8C:  MOVWF  FE9
11C8E:  MOVFF  382,8D4
11C92:  MOVFF  381,8D3
11C96:  CALL   AA2C
11C9A:  MOVLW  0F
11C9C:  MOVWF  FF6
11C9E:  MOVLW  1F
11CA0:  MOVWF  FF7
11CA2:  MOVLW  00
11CA4:  MOVWF  FF8
11CA6:  MOVLW  07
11CA8:  MOVLB  8
11CAA:  MOVWF  xC8
11CAC:  MOVLB  0
11CAE:  CALL   A9FA
11CB2:  MOVLW  10
11CB4:  MOVWF  FE9
11CB6:  MOVFF  384,8D4
11CBA:  MOVFF  383,8D3
11CBE:  CALL   AA2C
11CC2:  MOVLW  19
11CC4:  MOVWF  FF6
11CC6:  MOVLW  1F
11CC8:  MOVWF  FF7
11CCA:  MOVLW  00
11CCC:  MOVWF  FF8
11CCE:  MOVLW  09
11CD0:  MOVLB  8
11CD2:  MOVWF  xC8
11CD4:  MOVLB  0
11CD6:  CALL   A9FA
11CDA:  MOVLW  89
11CDC:  MOVWF  FE9
11CDE:  MOVFF  3D8,8AF
11CE2:  MOVFF  3D7,8AE
11CE6:  MOVFF  3D6,8AD
11CEA:  MOVFF  3D5,8AC
11CEE:  MOVLW  04
11CF0:  MOVLB  8
11CF2:  MOVWF  xB0
11CF4:  MOVLB  0
11CF6:  CALL   10926
11CFA:  MOVLW  27
11CFC:  MOVWF  FF6
11CFE:  MOVLW  1F
11D00:  MOVWF  FF7
11D02:  MOVLW  00
11D04:  MOVWF  FF8
11D06:  MOVLW  07
11D08:  MOVLB  8
11D0A:  MOVWF  xC8
11D0C:  MOVLB  0
11D0E:  CALL   A9FA
11D12:  MOVLW  10
11D14:  MOVWF  FE9
11D16:  MOVFF  386,8D4
11D1A:  MOVFF  385,8D3
11D1E:  CALL   AA2C
11D22:  MOVLW  31
11D24:  MOVWF  FF6
11D26:  MOVLW  1F
11D28:  MOVWF  FF7
11D2A:  MOVLW  00
11D2C:  MOVWF  FF8
11D2E:  MOVLW  07
11D30:  MOVLB  8
11D32:  MOVWF  xC8
11D34:  MOVLB  0
11D36:  CALL   A9FA
11D3A:  MOVLW  10
11D3C:  MOVWF  FE9
11D3E:  MOVFF  388,8D4
11D42:  MOVFF  387,8D3
11D46:  CALL   AA2C
11D4A:  MOVLW  3B
11D4C:  MOVWF  FF6
11D4E:  MOVLW  1F
11D50:  MOVWF  FF7
11D52:  MOVLW  00
11D54:  MOVWF  FF8
11D56:  MOVLW  09
11D58:  MOVLB  8
11D5A:  MOVWF  xC8
11D5C:  MOVLB  0
11D5E:  CALL   A9FA
11D62:  MOVLW  89
11D64:  MOVWF  FE9
11D66:  MOVFF  3DC,8AF
11D6A:  MOVFF  3DB,8AE
11D6E:  MOVFF  3DA,8AD
11D72:  MOVFF  3D9,8AC
11D76:  MOVLW  04
11D78:  MOVLB  8
11D7A:  MOVWF  xB0
11D7C:  MOVLB  0
11D7E:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
11D82:  MOVF   1F,W
11D84:  SUBLW  02
11D86:  BNZ   11D8C
11D88:  MOVF   20,F
11D8A:  BZ    11DCC
11D8C:  MOVLW  4A
11D8E:  MOVWF  FF6
11D90:  MOVLW  1F
11D92:  MOVWF  FF7
11D94:  MOVLW  00
11D96:  MOVWF  FF8
11D98:  CLRF   1B
11D9A:  BTFSC  FF2.7
11D9C:  BSF    1B.7
11D9E:  BCF    FF2.7
11DA0:  MOVLW  09
11DA2:  MOVLB  A
11DA4:  MOVWF  x18
11DA6:  MOVLB  0
11DA8:  CALL   1006
11DAC:  BTFSC  1B.7
11DAE:  BSF    FF2.7
11DB0:  MOVLW  04
11DB2:  MOVWF  FEA
11DB4:  MOVLW  21
11DB6:  MOVWF  FE9
11DB8:  CALL   78D2
11DBC:  MOVLW  0D
11DBE:  BTFSS  F9E.4
11DC0:  BRA    11DBE
11DC2:  MOVWF  FAD
11DC4:  MOVLW  0A
11DC6:  BTFSS  F9E.4
11DC8:  BRA    11DC6
11DCA:  MOVWF  FAD
11DCC:  GOTO   122DC (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
11DD0:  MOVLB  8
11DD2:  CLRF   x9F
11DD4:  MOVF   x9F,W
11DD6:  SUBLW  03
11DD8:  BNC   11DF8
11DDA:  MOVF   x9F,W
11DDC:  MULLW  04
11DDE:  MOVF   FF3,W
11DE0:  CLRF   03
11DE2:  ADDLW  E1
11DE4:  MOVWF  FE9
11DE6:  MOVLW  03
11DE8:  ADDWFC 03,W
11DEA:  MOVWF  FEA
11DEC:  CLRF   FEF
11DEE:  CLRF   FEC
11DF0:  CLRF   FEC
11DF2:  CLRF   FEC
11DF4:  INCF   x9F,F
11DF6:  BRA    11DD4
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
11DF8:  MOVLB  3
11DFA:  MOVF   x8F,F
11DFC:  BTFSS  FD8.2
11DFE:  BRA    11E04
11E00:  MOVF   x90,F
11E02:  BZ    11EA0
11E04:  MOVF   x91,F
11E06:  BNZ   11E0C
11E08:  MOVF   x92,F
11E0A:  BZ    11EA0
....................       blank = SiO_array[0]; 
11E0C:  MOVFF  390,8F5
11E10:  MOVFF  38F,8F4
11E14:  MOVLB  0
11E16:  CALL   C61A
11E1A:  MOVFF  03,8A3
11E1E:  MOVFF  02,8A2
11E22:  MOVFF  01,8A1
11E26:  MOVFF  00,8A0
....................       react = SiO_array[1]; 
11E2A:  MOVFF  392,8F5
11E2E:  MOVFF  391,8F4
11E32:  CALL   C61A
11E36:  MOVFF  03,8A7
11E3A:  MOVFF  02,8A6
11E3E:  MOVFF  01,8A5
11E42:  MOVFF  00,8A4
....................       ratio = blank / react; 
11E46:  MOVFF  8A3,8DB
11E4A:  MOVFF  8A2,8DA
11E4E:  MOVFF  8A1,8D9
11E52:  MOVFF  8A0,8D8
11E56:  MOVFF  8A7,8DF
11E5A:  MOVFF  8A6,8DE
11E5E:  MOVFF  8A5,8DD
11E62:  MOVFF  8A4,8DC
11E66:  CALL   C650
11E6A:  MOVFF  03,8AB
11E6E:  MOVFF  02,8AA
11E72:  MOVFF  01,8A9
11E76:  MOVFF  00,8A8
....................       SiO_abs_array[0] = log10(ratio); 
11E7A:  MOVFF  8AB,8AF
11E7E:  MOVFF  8AA,8AE
11E82:  MOVFF  8A9,8AD
11E86:  MOVFF  8A8,8AC
11E8A:  CALL   108BA
11E8E:  MOVFF  03,3E4
11E92:  MOVFF  02,3E3
11E96:  MOVFF  01,3E2
11E9A:  MOVFF  00,3E1
11E9E:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
11EA0:  MOVF   x93,F
11EA2:  BNZ   11EA8
11EA4:  MOVF   x94,F
11EA6:  BZ    11F44
11EA8:  MOVF   x95,F
11EAA:  BNZ   11EB0
11EAC:  MOVF   x96,F
11EAE:  BZ    11F44
....................       blank = SiO_array[2]; 
11EB0:  MOVFF  394,8F5
11EB4:  MOVFF  393,8F4
11EB8:  MOVLB  0
11EBA:  CALL   C61A
11EBE:  MOVFF  03,8A3
11EC2:  MOVFF  02,8A2
11EC6:  MOVFF  01,8A1
11ECA:  MOVFF  00,8A0
....................       react = SiO_array[3]; 
11ECE:  MOVFF  396,8F5
11ED2:  MOVFF  395,8F4
11ED6:  CALL   C61A
11EDA:  MOVFF  03,8A7
11EDE:  MOVFF  02,8A6
11EE2:  MOVFF  01,8A5
11EE6:  MOVFF  00,8A4
....................       ratio = blank / react;    
11EEA:  MOVFF  8A3,8DB
11EEE:  MOVFF  8A2,8DA
11EF2:  MOVFF  8A1,8D9
11EF6:  MOVFF  8A0,8D8
11EFA:  MOVFF  8A7,8DF
11EFE:  MOVFF  8A6,8DE
11F02:  MOVFF  8A5,8DD
11F06:  MOVFF  8A4,8DC
11F0A:  CALL   C650
11F0E:  MOVFF  03,8AB
11F12:  MOVFF  02,8AA
11F16:  MOVFF  01,8A9
11F1A:  MOVFF  00,8A8
....................       SiO_abs_array[1] = log10(ratio); 
11F1E:  MOVFF  8AB,8AF
11F22:  MOVFF  8AA,8AE
11F26:  MOVFF  8A9,8AD
11F2A:  MOVFF  8A8,8AC
11F2E:  CALL   108BA
11F32:  MOVFF  03,3E8
11F36:  MOVFF  02,3E7
11F3A:  MOVFF  01,3E6
11F3E:  MOVFF  00,3E5
11F42:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
11F44:  MOVF   x97,F
11F46:  BNZ   11F4C
11F48:  MOVF   x98,F
11F4A:  BZ    11FE8
11F4C:  MOVF   x99,F
11F4E:  BNZ   11F54
11F50:  MOVF   x9A,F
11F52:  BZ    11FE8
....................       blank = SiO_array[4]; 
11F54:  MOVFF  398,8F5
11F58:  MOVFF  397,8F4
11F5C:  MOVLB  0
11F5E:  CALL   C61A
11F62:  MOVFF  03,8A3
11F66:  MOVFF  02,8A2
11F6A:  MOVFF  01,8A1
11F6E:  MOVFF  00,8A0
....................       react = SiO_array[5]; 
11F72:  MOVFF  39A,8F5
11F76:  MOVFF  399,8F4
11F7A:  CALL   C61A
11F7E:  MOVFF  03,8A7
11F82:  MOVFF  02,8A6
11F86:  MOVFF  01,8A5
11F8A:  MOVFF  00,8A4
....................       ratio = blank / react; 
11F8E:  MOVFF  8A3,8DB
11F92:  MOVFF  8A2,8DA
11F96:  MOVFF  8A1,8D9
11F9A:  MOVFF  8A0,8D8
11F9E:  MOVFF  8A7,8DF
11FA2:  MOVFF  8A6,8DE
11FA6:  MOVFF  8A5,8DD
11FAA:  MOVFF  8A4,8DC
11FAE:  CALL   C650
11FB2:  MOVFF  03,8AB
11FB6:  MOVFF  02,8AA
11FBA:  MOVFF  01,8A9
11FBE:  MOVFF  00,8A8
....................       SiO_abs_array[2] = log10(ratio); 
11FC2:  MOVFF  8AB,8AF
11FC6:  MOVFF  8AA,8AE
11FCA:  MOVFF  8A9,8AD
11FCE:  MOVFF  8A8,8AC
11FD2:  CALL   108BA
11FD6:  MOVFF  03,3EC
11FDA:  MOVFF  02,3EB
11FDE:  MOVFF  01,3EA
11FE2:  MOVFF  00,3E9
11FE6:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
11FE8:  MOVF   x9B,F
11FEA:  BNZ   11FF0
11FEC:  MOVF   x9C,F
11FEE:  BZ    1208C
11FF0:  MOVF   x9D,F
11FF2:  BNZ   11FF8
11FF4:  MOVF   x9E,F
11FF6:  BZ    1208C
....................       blank = SiO_array[6]; 
11FF8:  MOVFF  39C,8F5
11FFC:  MOVFF  39B,8F4
12000:  MOVLB  0
12002:  CALL   C61A
12006:  MOVFF  03,8A3
1200A:  MOVFF  02,8A2
1200E:  MOVFF  01,8A1
12012:  MOVFF  00,8A0
....................       react = SiO_array[7]; 
12016:  MOVFF  39E,8F5
1201A:  MOVFF  39D,8F4
1201E:  CALL   C61A
12022:  MOVFF  03,8A7
12026:  MOVFF  02,8A6
1202A:  MOVFF  01,8A5
1202E:  MOVFF  00,8A4
....................       ratio = blank / react; 
12032:  MOVFF  8A3,8DB
12036:  MOVFF  8A2,8DA
1203A:  MOVFF  8A1,8D9
1203E:  MOVFF  8A0,8D8
12042:  MOVFF  8A7,8DF
12046:  MOVFF  8A6,8DE
1204A:  MOVFF  8A5,8DD
1204E:  MOVFF  8A4,8DC
12052:  CALL   C650
12056:  MOVFF  03,8AB
1205A:  MOVFF  02,8AA
1205E:  MOVFF  01,8A9
12062:  MOVFF  00,8A8
....................       SiO_abs_array[3] = log10(ratio); 
12066:  MOVFF  8AB,8AF
1206A:  MOVFF  8AA,8AE
1206E:  MOVFF  8A9,8AD
12072:  MOVFF  8A8,8AC
12076:  CALL   108BA
1207A:  MOVFF  03,3F0
1207E:  MOVFF  02,3EF
12082:  MOVFF  01,3EE
12086:  MOVFF  00,3ED
1208A:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
1208C:  MOVLW  04
1208E:  MOVWF  1E
12090:  MOVLW  21
12092:  MOVWF  1D
12094:  MOVLW  58
12096:  MOVWF  FF6
12098:  MOVLW  1F
1209A:  MOVWF  FF7
1209C:  MOVLW  00
1209E:  MOVWF  FF8
120A0:  MOVLW  06
120A2:  MOVLB  8
120A4:  MOVWF  xC8
120A6:  MOVLB  0
120A8:  CALL   A9FA
120AC:  MOVLW  10
120AE:  MOVWF  FE9
120B0:  MOVFF  390,8D4
120B4:  MOVFF  38F,8D3
120B8:  CALL   AA2C
120BC:  MOVLW  61
120BE:  MOVWF  FF6
120C0:  MOVLW  1F
120C2:  MOVWF  FF7
120C4:  MOVLW  00
120C6:  MOVWF  FF8
120C8:  MOVLW  07
120CA:  MOVLB  8
120CC:  MOVWF  xC8
120CE:  MOVLB  0
120D0:  CALL   A9FA
120D4:  MOVLW  10
120D6:  MOVWF  FE9
120D8:  MOVFF  392,8D4
120DC:  MOVFF  391,8D3
120E0:  CALL   AA2C
120E4:  MOVLW  6B
120E6:  MOVWF  FF6
120E8:  MOVLW  1F
120EA:  MOVWF  FF7
120EC:  MOVLW  00
120EE:  MOVWF  FF8
120F0:  MOVLW  09
120F2:  MOVLB  8
120F4:  MOVWF  xC8
120F6:  MOVLB  0
120F8:  CALL   A9FA
120FC:  MOVLW  89
120FE:  MOVWF  FE9
12100:  MOVFF  3E4,8AF
12104:  MOVFF  3E3,8AE
12108:  MOVFF  3E2,8AD
1210C:  MOVFF  3E1,8AC
12110:  MOVLW  04
12112:  MOVLB  8
12114:  MOVWF  xB0
12116:  MOVLB  0
12118:  CALL   10926
1211C:  MOVLW  79
1211E:  MOVWF  FF6
12120:  MOVLW  1F
12122:  MOVWF  FF7
12124:  MOVLW  00
12126:  MOVWF  FF8
12128:  MOVLW  07
1212A:  MOVLB  8
1212C:  MOVWF  xC8
1212E:  MOVLB  0
12130:  CALL   A9FA
12134:  MOVLW  10
12136:  MOVWF  FE9
12138:  MOVFF  394,8D4
1213C:  MOVFF  393,8D3
12140:  CALL   AA2C
12144:  MOVLW  83
12146:  MOVWF  FF6
12148:  MOVLW  1F
1214A:  MOVWF  FF7
1214C:  MOVLW  00
1214E:  MOVWF  FF8
12150:  MOVLW  07
12152:  MOVLB  8
12154:  MOVWF  xC8
12156:  MOVLB  0
12158:  CALL   A9FA
1215C:  MOVLW  10
1215E:  MOVWF  FE9
12160:  MOVFF  396,8D4
12164:  MOVFF  395,8D3
12168:  CALL   AA2C
1216C:  MOVLW  8D
1216E:  MOVWF  FF6
12170:  MOVLW  1F
12172:  MOVWF  FF7
12174:  MOVLW  00
12176:  MOVWF  FF8
12178:  MOVLW  09
1217A:  MOVLB  8
1217C:  MOVWF  xC8
1217E:  MOVLB  0
12180:  CALL   A9FA
12184:  MOVLW  89
12186:  MOVWF  FE9
12188:  MOVFF  3E8,8AF
1218C:  MOVFF  3E7,8AE
12190:  MOVFF  3E6,8AD
12194:  MOVFF  3E5,8AC
12198:  MOVLW  04
1219A:  MOVLB  8
1219C:  MOVWF  xB0
1219E:  MOVLB  0
121A0:  CALL   10926
121A4:  MOVLW  9B
121A6:  MOVWF  FF6
121A8:  MOVLW  1F
121AA:  MOVWF  FF7
121AC:  MOVLW  00
121AE:  MOVWF  FF8
121B0:  MOVLW  07
121B2:  MOVLB  8
121B4:  MOVWF  xC8
121B6:  MOVLB  0
121B8:  CALL   A9FA
121BC:  MOVLW  10
121BE:  MOVWF  FE9
121C0:  MOVFF  398,8D4
121C4:  MOVFF  397,8D3
121C8:  CALL   AA2C
121CC:  MOVLW  A5
121CE:  MOVWF  FF6
121D0:  MOVLW  1F
121D2:  MOVWF  FF7
121D4:  MOVLW  00
121D6:  MOVWF  FF8
121D8:  MOVLW  07
121DA:  MOVLB  8
121DC:  MOVWF  xC8
121DE:  MOVLB  0
121E0:  CALL   A9FA
121E4:  MOVLW  10
121E6:  MOVWF  FE9
121E8:  MOVFF  39A,8D4
121EC:  MOVFF  399,8D3
121F0:  CALL   AA2C
121F4:  MOVLW  AF
121F6:  MOVWF  FF6
121F8:  MOVLW  1F
121FA:  MOVWF  FF7
121FC:  MOVLW  00
121FE:  MOVWF  FF8
12200:  MOVLW  09
12202:  MOVLB  8
12204:  MOVWF  xC8
12206:  MOVLB  0
12208:  CALL   A9FA
1220C:  MOVLW  89
1220E:  MOVWF  FE9
12210:  MOVFF  3EC,8AF
12214:  MOVFF  3EB,8AE
12218:  MOVFF  3EA,8AD
1221C:  MOVFF  3E9,8AC
12220:  MOVLW  04
12222:  MOVLB  8
12224:  MOVWF  xB0
12226:  MOVLB  0
12228:  CALL   10926
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
1222C:  MOVF   1F,W
1222E:  SUBLW  02
12230:  BNZ   12236
12232:  MOVF   20,F
12234:  BZ    12276
12236:  MOVLW  BE
12238:  MOVWF  FF6
1223A:  MOVLW  1F
1223C:  MOVWF  FF7
1223E:  MOVLW  00
12240:  MOVWF  FF8
12242:  CLRF   1B
12244:  BTFSC  FF2.7
12246:  BSF    1B.7
12248:  BCF    FF2.7
1224A:  MOVLW  09
1224C:  MOVLB  A
1224E:  MOVWF  x18
12250:  MOVLB  0
12252:  CALL   1006
12256:  BTFSC  1B.7
12258:  BSF    FF2.7
1225A:  MOVLW  04
1225C:  MOVWF  FEA
1225E:  MOVLW  21
12260:  MOVWF  FE9
12262:  CALL   78D2
12266:  MOVLW  0D
12268:  BTFSS  F9E.4
1226A:  BRA    12268
1226C:  MOVWF  FAD
1226E:  MOVLW  0A
12270:  BTFSS  F9E.4
12272:  BRA    12270
12274:  MOVWF  FAD
12276:  GOTO   122DC (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
1227A:  MOVLW  04
1227C:  MOVWF  FEA
1227E:  MOVLW  21
12280:  MOVWF  FE9
12282:  MOVLW  00
12284:  CALL   056C
12288:  TBLRD*-
1228A:  TBLRD*+
1228C:  MOVF   FF5,W
1228E:  MOVWF  FEE
12290:  IORLW  00
12292:  BNZ   1228A
....................     
....................    switch (chem){ 
12294:  MOVLW  CC
12296:  MOVWF  FF6
12298:  MOVLW  1F
1229A:  MOVWF  FF7
1229C:  MOVLW  00
1229E:  MOVWF  FF8
122A0:  MOVLW  03
122A2:  MOVWF  FEA
122A4:  MOVLW  39
122A6:  MOVWF  FE9
122A8:  CALL   FB4C
122AC:  MOVF   01,W
122AE:  BZ    122C2
122B0:  XORLW  01
122B2:  BZ    122C8
122B4:  XORLW  03
122B6:  BZ    122CE
122B8:  XORLW  01
122BA:  BZ    122D4
122BC:  XORLW  07
122BE:  BZ    122DA
122C0:  BRA    122DC
....................       case "NO3" : calc_abs_NO3(); 
122C2:  GOTO   10B38
....................          break; 
122C6:  BRA    122DC
....................       case "NO2" : calc_abs_NO2 (); 
122C8:  GOTO   10FD4
....................          break;    
122CC:  BRA    122DC
....................       case "PO4" : calc_abs_PO4(); 
122CE:  GOTO   1147C
....................          break; 
122D2:  BRA    122DC
....................       case "NH4" : calc_abs_NH4(); 
122D4:  GOTO   11926
....................          break; 
122D8:  BRA    122DC
....................       case "SiO" : calc_abs_SiO(); 
122DA:  BRA    11DD0
....................          break; 
....................    } 
122DC:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
122DE:  CALL   D224
....................     
....................    if (data_available == TRUE) { 
122E2:  MOVLB  3
122E4:  DECFSZ x37,W
122E6:  BRA    123E8
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
122E8:  MOVLB  8
122EA:  CLRF   xD6
122EC:  MOVLW  63
122EE:  MOVWF  xD5
122F0:  MOVLW  02
122F2:  MOVWF  xD8
122F4:  MOVLW  B3
122F6:  MOVWF  xD7
122F8:  MOVLB  0
122FA:  CALL   5456
....................       strcat(data_buffer, comma); 
122FE:  MOVLB  8
12300:  CLRF   xD6
12302:  MOVLW  63
12304:  MOVWF  xD5
12306:  MOVLW  03
12308:  MOVWF  xD8
1230A:  MOVLW  35
1230C:  MOVWF  xD7
1230E:  MOVLB  0
12310:  CALL   5456
....................       strcat(data_buffer, chem); 
12314:  MOVLB  8
12316:  CLRF   xD6
12318:  MOVLW  63
1231A:  MOVWF  xD5
1231C:  MOVLW  03
1231E:  MOVWF  xD8
12320:  MOVLW  39
12322:  MOVWF  xD7
12324:  MOVLB  0
12326:  CALL   5456
....................       strcat(data_buffer, comma); 
1232A:  MOVLB  8
1232C:  CLRF   xD6
1232E:  MOVLW  63
12330:  MOVWF  xD5
12332:  MOVLW  03
12334:  MOVWF  xD8
12336:  MOVLW  35
12338:  MOVWF  xD7
1233A:  MOVLB  0
1233C:  CALL   5456
....................       strcat(data_buffer, abs_str); 
12340:  MOVLB  8
12342:  CLRF   xD6
12344:  MOVLW  63
12346:  MOVWF  xD5
12348:  MOVLW  04
1234A:  MOVWF  xD8
1234C:  MOVLW  21
1234E:  MOVWF  xD7
12350:  MOVLB  0
12352:  CALL   5456
....................       strcat(data_buffer, endofline); 
12356:  MOVLB  8
12358:  CLRF   xD6
1235A:  MOVLW  63
1235C:  MOVWF  xD5
1235E:  MOVLW  07
12360:  MOVWF  xD8
12362:  MOVLW  CA
12364:  MOVWF  xD7
12366:  MOVLB  0
12368:  CALL   5456
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
1236C:  MOVF   1F,W
1236E:  SUBLW  04
12370:  BNZ   12390
12372:  MOVF   20,F
12374:  BNZ   12390
12376:  CLRF   FEA
12378:  MOVLW  63
1237A:  MOVWF  FE9
1237C:  CALL   78D2
12380:  MOVLW  0D
12382:  BTFSS  F9E.4
12384:  BRA    12382
12386:  MOVWF  FAD
12388:  MOVLW  0A
1238A:  BTFSS  F9E.4
1238C:  BRA    1238A
1238E:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
12390:  MOVLB  2
12392:  MOVF   xD8,F
12394:  BNZ   123E6
....................        
....................          buffer_select = 0; 
12396:  MOVLB  0
12398:  CLRF   x62
....................           
....................          heartbeat(FALSE); 
1239A:  MOVLB  8
1239C:  CLRF   xCA
1239E:  MOVLB  0
123A0:  CALL   54FA
....................             append_data(file_ptr_rel_all); 
123A4:  MOVLW  02
123A6:  MOVLB  8
123A8:  MOVWF  xCB
123AA:  MOVLW  F5
123AC:  MOVWF  xCA
123AE:  MOVLB  0
123B0:  CALL   822E
....................          heartbeat(TRUE);          
123B4:  MOVLW  01
123B6:  MOVLB  8
123B8:  MOVWF  xCA
123BA:  MOVLB  0
123BC:  CALL   54FA
....................           
....................          heartbeat(FALSE); 
123C0:  MOVLB  8
123C2:  CLRF   xCA
123C4:  MOVLB  0
123C6:  CALL   54FA
....................             append_data(file_ptr_rel_new);    
123CA:  MOVLW  03
123CC:  MOVLB  8
123CE:  MOVWF  xCB
123D0:  MOVWF  xCA
123D2:  MOVLB  0
123D4:  CALL   822E
....................          heartbeat(TRUE); 
123D8:  MOVLW  01
123DA:  MOVLB  8
123DC:  MOVWF  xCA
123DE:  MOVLB  0
123E0:  CALL   54FA
123E4:  MOVLB  2
123E6:  MOVLB  3
....................       } 
....................    } 
123E8:  MOVLB  0
123EA:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D33A:  MOVLW  2C
0D33C:  MOVLB  8
0D33E:  MOVWF  x7B
0D340:  CLRF   x7C
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D342:  MOVLW  0D
0D344:  MOVWF  x7D
0D346:  MOVLW  0A
0D348:  MOVWF  x7E
0D34A:  CLRF   x7F
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D34C:  MOVLB  0
0D34E:  RCALL  D224
....................    time_stamp(); 
0D350:  CALL   5392
....................    strcat(data_buffer, time_stmp_str); 
0D354:  MOVLB  8
0D356:  CLRF   xD6
0D358:  MOVLW  63
0D35A:  MOVWF  xD5
0D35C:  MOVLW  02
0D35E:  MOVWF  xD8
0D360:  MOVLW  95
0D362:  MOVWF  xD7
0D364:  MOVLB  0
0D366:  CALL   5456
....................    strcat(data_buffer, comma); 
0D36A:  MOVLB  8
0D36C:  CLRF   xD6
0D36E:  MOVLW  63
0D370:  MOVWF  xD5
0D372:  MOVLW  08
0D374:  MOVWF  xD8
0D376:  MOVLW  7B
0D378:  MOVWF  xD7
0D37A:  MOVLB  0
0D37C:  CALL   5456
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D380:  MOVLW  08
0D382:  MOVWF  1E
0D384:  MOVLW  80
0D386:  MOVWF  1D
0D388:  MOVFF  87A,8CA
0D38C:  MOVLW  1B
0D38E:  MOVLB  8
0D390:  MOVWF  xCB
0D392:  MOVLB  0
0D394:  CALL   51F8
0D398:  MOVLW  2C
0D39A:  MOVLB  8
0D39C:  MOVWF  xDC
0D39E:  MOVLB  0
0D3A0:  CALL   5016
0D3A4:  MOVLW  10
0D3A6:  MOVWF  FE9
0D3A8:  MOVFF  2A,8D4
0D3AC:  MOVFF  29,8D3
0D3B0:  CALL   AA2C
0D3B4:  MOVLW  2C
0D3B6:  MOVLB  8
0D3B8:  MOVWF  xDC
0D3BA:  MOVLB  0
0D3BC:  CALL   5016
0D3C0:  MOVLW  10
0D3C2:  MOVWF  FE9
0D3C4:  MOVFF  24,8D4
0D3C8:  MOVFF  23,8D3
0D3CC:  CALL   AA2C
0D3D0:  MOVLW  2C
0D3D2:  MOVLB  8
0D3D4:  MOVWF  xDC
0D3D6:  MOVLB  0
0D3D8:  CALL   5016
0D3DC:  MOVLW  10
0D3DE:  MOVWF  FE9
0D3E0:  MOVFF  2C,8D4
0D3E4:  MOVFF  2B,8D3
0D3E8:  CALL   AA2C
0D3EC:  MOVLW  2C
0D3EE:  MOVLB  8
0D3F0:  MOVWF  xDC
0D3F2:  MOVLB  0
0D3F4:  CALL   5016
0D3F8:  MOVLW  10
0D3FA:  MOVWF  FE9
0D3FC:  MOVFF  2E,8D4
0D400:  MOVFF  2D,8D3
0D404:  CALL   AA2C
0D408:  MOVLW  2C
0D40A:  MOVLB  8
0D40C:  MOVWF  xDC
0D40E:  MOVLB  0
0D410:  CALL   5016
0D414:  MOVLW  10
0D416:  MOVWF  FE9
0D418:  MOVFF  22,8D4
0D41C:  MOVFF  21,8D3
0D420:  CALL   AA2C
0D424:  MOVLW  2C
0D426:  MOVLB  8
0D428:  MOVWF  xDC
0D42A:  MOVLB  0
0D42C:  CALL   5016
0D430:  MOVLW  10
0D432:  MOVWF  FE9
0D434:  MOVFF  7C4,8D4
0D438:  MOVFF  7C3,8D3
0D43C:  CALL   AA2C
0D440:  MOVLW  2C
0D442:  MOVLB  8
0D444:  MOVWF  xDC
0D446:  MOVLB  0
0D448:  CALL   5016
0D44C:  MOVLW  10
0D44E:  MOVWF  FE9
0D450:  MOVFF  7B2,89F
0D454:  MOVFF  7B1,89E
0D458:  BRA    D238
....................    strcat(data_buffer, config_str); 
0D45A:  MOVLB  8
0D45C:  CLRF   xD6
0D45E:  MOVLW  63
0D460:  MOVWF  xD5
0D462:  MOVLW  08
0D464:  MOVWF  xD8
0D466:  MOVLW  80
0D468:  MOVWF  xD7
0D46A:  MOVLB  0
0D46C:  CALL   5456
....................    strcat(data_buffer, endofline); 
0D470:  MOVLB  8
0D472:  CLRF   xD6
0D474:  MOVLW  63
0D476:  MOVWF  xD5
0D478:  MOVLW  08
0D47A:  MOVWF  xD8
0D47C:  MOVLW  7D
0D47E:  MOVWF  xD7
0D480:  MOVLB  0
0D482:  CALL   5456
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D486:  CLRF   FEA
0D488:  MOVLW  63
0D48A:  MOVWF  FE9
0D48C:  CALL   78D2
0D490:  MOVLW  0D
0D492:  BTFSS  F9E.4
0D494:  BRA    D492
0D496:  MOVWF  FAD
0D498:  MOVLW  0A
0D49A:  BTFSS  F9E.4
0D49C:  BRA    D49A
0D49E:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D4A0:  MOVLB  2
0D4A2:  MOVF   xD8,F
0D4A4:  BNZ   D4F8
....................     
....................       buffer_select = 0; 
0D4A6:  MOVLB  0
0D4A8:  CLRF   x62
....................        
....................       heartbeat(FALSE); 
0D4AA:  MOVLB  8
0D4AC:  CLRF   xCA
0D4AE:  MOVLB  0
0D4B0:  CALL   54FA
....................          append_data(file_ptr_raw_all); 
0D4B4:  MOVLW  02
0D4B6:  MOVLB  8
0D4B8:  MOVWF  xCB
0D4BA:  MOVLW  D9
0D4BC:  MOVWF  xCA
0D4BE:  MOVLB  0
0D4C0:  CALL   822E
....................       heartbeat(TRUE);          
0D4C4:  MOVLW  01
0D4C6:  MOVLB  8
0D4C8:  MOVWF  xCA
0D4CA:  MOVLB  0
0D4CC:  CALL   54FA
....................        
....................       heartbeat(FALSE); 
0D4D0:  MOVLB  8
0D4D2:  CLRF   xCA
0D4D4:  MOVLB  0
0D4D6:  CALL   54FA
....................          append_data(file_ptr_raw_new);    
0D4DA:  MOVLW  02
0D4DC:  MOVLB  8
0D4DE:  MOVWF  xCB
0D4E0:  MOVLW  E7
0D4E2:  MOVWF  xCA
0D4E4:  MOVLB  0
0D4E6:  CALL   822E
....................       heartbeat(TRUE); 
0D4EA:  MOVLW  01
0D4EC:  MOVLB  8
0D4EE:  MOVWF  xCA
0D4F0:  MOVLB  0
0D4F2:  CALL   54FA
0D4F6:  MOVLB  2
....................    } 
0D4F8:  MOVLB  0
0D4FA:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
14DD6:  MOVLW  2C
14DD8:  MOVLB  8
14DDA:  MOVWF  x7D
14DDC:  CLRF   x7E
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
14DDE:  MOVLW  0D
14DE0:  MOVWF  x7F
14DE2:  MOVLW  0A
14DE4:  MOVWF  x80
14DE6:  CLRF   x81
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
14DE8:  MOVLB  0
14DEA:  CALL   D224
....................    time_stamp(); 
14DEE:  CALL   5392
....................    strcat(data_buffer, time_stmp_str); 
14DF2:  MOVLB  8
14DF4:  CLRF   xD6
14DF6:  MOVLW  63
14DF8:  MOVWF  xD5
14DFA:  MOVLW  02
14DFC:  MOVWF  xD8
14DFE:  MOVLW  95
14E00:  MOVWF  xD7
14E02:  MOVLB  0
14E04:  CALL   5456
....................    strcat(data_buffer, comma); 
14E08:  MOVLB  8
14E0A:  CLRF   xD6
14E0C:  MOVLW  63
14E0E:  MOVWF  xD5
14E10:  MOVLW  08
14E12:  MOVWF  xD8
14E14:  MOVLW  7D
14E16:  MOVWF  xD7
14E18:  MOVLB  0
14E1A:  CALL   5456
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
14E1E:  MOVLW  08
14E20:  MOVWF  1E
14E22:  MOVLW  82
14E24:  MOVWF  1D
14E26:  MOVFF  87A,8CA
14E2A:  MOVLW  1B
14E2C:  MOVLB  8
14E2E:  MOVWF  xCB
14E30:  MOVLB  0
14E32:  CALL   51F8
14E36:  MOVLW  2C
14E38:  MOVLB  8
14E3A:  MOVWF  xDC
14E3C:  MOVLB  0
14E3E:  CALL   5016
14E42:  MOVLW  10
14E44:  MOVWF  FE9
14E46:  MOVFF  87C,8D4
14E4A:  MOVFF  87B,8D3
14E4E:  CALL   AA2C
....................    strcat(data_buffer, config_str); 
14E52:  MOVLB  8
14E54:  CLRF   xD6
14E56:  MOVLW  63
14E58:  MOVWF  xD5
14E5A:  MOVLW  08
14E5C:  MOVWF  xD8
14E5E:  MOVLW  82
14E60:  MOVWF  xD7
14E62:  MOVLB  0
14E64:  CALL   5456
....................    strcat(data_buffer, endofline); 
14E68:  MOVLB  8
14E6A:  CLRF   xD6
14E6C:  MOVLW  63
14E6E:  MOVWF  xD5
14E70:  MOVLW  08
14E72:  MOVWF  xD8
14E74:  MOVLW  7F
14E76:  MOVWF  xD7
14E78:  MOVLB  0
14E7A:  CALL   5456
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
14E7E:  MOVF   1F,W
14E80:  SUBLW  04
14E82:  BNZ   14EA2
14E84:  MOVF   20,F
14E86:  BNZ   14EA2
14E88:  CLRF   FEA
14E8A:  MOVLW  63
14E8C:  MOVWF  FE9
14E8E:  CALL   78D2
14E92:  MOVLW  0D
14E94:  BTFSS  F9E.4
14E96:  BRA    14E94
14E98:  MOVWF  FAD
14E9A:  MOVLW  0A
14E9C:  BTFSS  F9E.4
14E9E:  BRA    14E9C
14EA0:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
14EA2:  MOVLB  2
14EA4:  MOVF   xD8,F
14EA6:  BNZ   14EFA
....................     
....................       buffer_select = 0; 
14EA8:  MOVLB  0
14EAA:  CLRF   x62
....................        
....................       heartbeat(FALSE); 
14EAC:  MOVLB  8
14EAE:  CLRF   xCA
14EB0:  MOVLB  0
14EB2:  CALL   54FA
....................          append_data(file_ptr_raw_all); 
14EB6:  MOVLW  02
14EB8:  MOVLB  8
14EBA:  MOVWF  xCB
14EBC:  MOVLW  D9
14EBE:  MOVWF  xCA
14EC0:  MOVLB  0
14EC2:  CALL   822E
....................       heartbeat(TRUE);          
14EC6:  MOVLW  01
14EC8:  MOVLB  8
14ECA:  MOVWF  xCA
14ECC:  MOVLB  0
14ECE:  CALL   54FA
....................        
....................       heartbeat(FALSE); 
14ED2:  MOVLB  8
14ED4:  CLRF   xCA
14ED6:  MOVLB  0
14ED8:  CALL   54FA
....................          append_data(file_ptr_raw_new);    
14EDC:  MOVLW  02
14EDE:  MOVLB  8
14EE0:  MOVWF  xCB
14EE2:  MOVLW  E7
14EE4:  MOVWF  xCA
14EE6:  MOVLB  0
14EE8:  CALL   822E
....................       heartbeat(TRUE); 
14EEC:  MOVLW  01
14EEE:  MOVLB  8
14EF0:  MOVWF  xCA
14EF2:  MOVLB  0
14EF4:  CALL   54FA
14EF8:  MOVLB  2
....................    } 
14EFA:  MOVLB  0
14EFC:  GOTO   15098 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0D06C:  BSF    F90.7
....................    delay_ms(500); 
0D06E:  MOVLW  02
0D070:  MOVLB  8
0D072:  MOVWF  x9F
0D074:  MOVLW  FA
0D076:  MOVLB  9
0D078:  MOVWF  xC9
0D07A:  MOVLB  0
0D07C:  CALL   288E
0D080:  MOVLB  8
0D082:  DECFSZ x9F,F
0D084:  BRA    D074
....................    bus_pwr_status=1; 
0D086:  MOVLW  01
0D088:  MOVLB  4
0D08A:  MOVWF  xB2
0D08C:  MOVLB  0
0D08E:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D090:  BCF    F90.7
....................    delay_ms(100); 
0D092:  MOVLW  64
0D094:  MOVLB  9
0D096:  MOVWF  xC9
0D098:  MOVLB  0
0D09A:  CALL   288E
....................    bus_pwr_status=0; 
0D09E:  MOVLB  4
0D0A0:  CLRF   xB2
0D0A2:  MOVLB  0
0D0A4:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
17A9E:  MOVLB  8
17AA0:  CLRF   x74
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
17AA2:  CLRF   x74
17AA4:  MOVF   x74,W
17AA6:  SUBLW  31
17AA8:  BNC   17ABE
....................       string_arg[i] = 0; 
17AAA:  CLRF   03
17AAC:  MOVF   x74,W
17AAE:  ADDLW  21
17AB0:  MOVWF  FE9
17AB2:  MOVLW  08
17AB4:  ADDWFC 03,W
17AB6:  MOVWF  FEA
17AB8:  CLRF   FEF
17ABA:  INCF   x74,F
17ABC:  BRA    17AA4
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
17ABE:  CLRF   x74
17AC0:  MOVF   x74,W
17AC2:  SUBLW  31
17AC4:  BNC   17B3E
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
17AC6:  CLRF   03
17AC8:  MOVF   x74,W
17ACA:  ADDLW  21
17ACC:  MOVWF  FE9
17ACE:  MOVLW  08
17AD0:  ADDWFC 03,W
17AD2:  MOVWF  FEA
17AD4:  MOVFF  FEA,878
17AD8:  MOVFF  FE9,877
17ADC:  MOVLB  0
17ADE:  CALL   0E1A
17AE2:  MOVFF  878,FEA
17AE6:  MOVFF  877,FE9
17AEA:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
17AEE:  DECFSZ 48,W
17AF0:  BRA    17B0E
....................       { 
....................          fputc(string_arg[i],COM_A); 
17AF2:  CLRF   03
17AF4:  MOVLB  8
17AF6:  MOVF   x74,W
17AF8:  ADDLW  21
17AFA:  MOVWF  FE9
17AFC:  MOVLW  08
17AFE:  ADDWFC 03,W
17B00:  MOVWF  FEA
17B02:  MOVFF  FEF,875
17B06:  MOVF   x75,W
17B08:  MOVLB  0
17B0A:  CALL   ADAA
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
17B0E:  CLRF   03
17B10:  MOVLB  8
17B12:  MOVF   x74,W
17B14:  ADDLW  21
17B16:  MOVWF  FE9
17B18:  MOVLW  08
17B1A:  ADDWFC 03,W
17B1C:  MOVWF  FEA
17B1E:  MOVF   FEF,W
17B20:  SUBLW  0D
17B22:  BZ    17B38
17B24:  CLRF   03
17B26:  MOVF   x74,W
17B28:  ADDLW  21
17B2A:  MOVWF  FE9
17B2C:  MOVLW  08
17B2E:  ADDWFC 03,W
17B30:  MOVWF  FEA
17B32:  MOVF   FEF,W
17B34:  SUBLW  0A
17B36:  BNZ   17B3A
....................       { 
....................          break; 
17B38:  BRA    17B3E
....................       } 
17B3A:  INCF   x74,F
17B3C:  BRA    17AC0
....................    } 
17B3E:  MOVLB  0
17B40:  GOTO   17E68 (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
17CE6:  MOVLB  8
17CE8:  CLRF   x74
....................    macro_arg = 0; 
17CEA:  CLRF   x76
17CEC:  CLRF   x75
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
17CEE:  MOVF   x74,W
17CF0:  SUBLW  0D
17CF2:  BZ    17D7E
....................       number = fgetc(COM_A); 
17CF4:  MOVLB  0
17CF6:  CALL   0E1A
17CFA:  MOVFF  01,874
....................       if (com_echo == TRUE) 
17CFE:  DECFSZ 48,W
17D00:  BRA    17D12
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
17D02:  MOVLB  8
17D04:  MOVF   x74,W
17D06:  SUBLW  0D
17D08:  BZ    17D14
17D0A:  MOVF   x74,W
17D0C:  MOVLB  0
17D0E:  CALL   ADAA
17D12:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
17D14:  MOVF   x74,W
17D16:  SUBLW  2F
17D18:  BC    17D4E
17D1A:  MOVF   x74,W
17D1C:  SUBLW  39
17D1E:  BNC   17D4E
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
17D20:  MOVLW  30
17D22:  SUBWF  x74,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
17D24:  MOVFF  876,9EA
17D28:  MOVFF  875,9E9
17D2C:  MOVLB  9
17D2E:  CLRF   xEC
17D30:  MOVLW  0A
17D32:  MOVWF  xEB
17D34:  MOVLB  0
17D36:  CALL   5C0E
17D3A:  MOVFF  02,876
17D3E:  MOVFF  01,875
....................          macro_arg = macro_arg + number;                // for each number 
17D42:  MOVLB  8
17D44:  MOVF   x74,W
17D46:  ADDWF  x75,F
17D48:  MOVLW  00
17D4A:  ADDWFC x76,F
....................       } 
17D4C:  BRA    17D7C
....................       else if (number == CARRIAGE_RET) 
17D4E:  MOVF   x74,W
17D50:  SUBLW  0D
17D52:  BNZ   17D74
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
17D54:  INCFSZ x75,W
17D56:  BRA    17D5E
17D58:  INCFSZ x76,W
17D5A:  BRA    17D5E
17D5C:  BRA    17D6A
17D5E:  MOVFF  875,01
17D62:  MOVFF  876,02
17D66:  BRA    17D7E
17D68:  BRA    17D72
....................          else return(65535); 
17D6A:  MOVLW  FF
17D6C:  MOVWF  01
17D6E:  MOVWF  02
17D70:  BRA    17D7E
....................       } 
17D72:  BRA    17D7C
....................       else 
....................       { 
....................          return(65535); 
17D74:  MOVLW  FF
17D76:  MOVWF  01
17D78:  MOVWF  02
17D7A:  BRA    17D7E
....................       } 
17D7C:  BRA    17CEE
....................    } 
17D7E:  MOVLB  0
17D80:  GOTO   17E92 (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
1782E:  MOVF   2F,W
17830:  MOVWF  00
17832:  MOVF   30,W
17834:  MOVWF  03
17836:  BNZ   1783C
17838:  MOVF   00,F
1783A:  BZ    17862
1783C:  MOVF   03,W
1783E:  BNZ   17848
17840:  MOVLW  03
17842:  SUBWF  00,W
17844:  BTFSC  FD8.2
17846:  BRA    17920
17848:  MOVF   03,W
1784A:  BNZ   17854
1784C:  MOVLW  01
1784E:  SUBWF  00,W
17850:  BTFSC  FD8.2
17852:  BRA    17920
17854:  MOVF   03,W
17856:  BNZ   17860
17858:  MOVLW  02
1785A:  SUBWF  00,W
1785C:  BTFSC  FD8.2
1785E:  BRA    17996
17860:  BRA    17A04
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
17862:  MOVLB  8
17864:  MOVF   x78,F
17866:  BNZ   17896
17868:  MOVF   x77,W
1786A:  SUBLW  23
1786C:  BZ    17890
1786E:  MOVF   x77,W
17870:  SUBLW  25
17872:  BZ    17890
17874:  MOVF   x77,W
17876:  SUBLW  3B
17878:  BZ    17890
1787A:  MOVF   x77,W
1787C:  SUBLW  4D
1787E:  BZ    17890
17880:  MOVF   x77,W
17882:  SUBLW  5A
17884:  BZ    17890
17886:  MOVF   x77,W
17888:  SUBLW  72
1788A:  BZ    17890
1788C:  MOVLW  00
1788E:  BRA    17892
17890:  MOVLW  01
17892:  MOVWF  x79
17894:  BRA    1791C
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
17896:  MOVF   x77,W
17898:  SUBLW  23
1789A:  BZ    17918
1789C:  MOVF   x77,W
1789E:  SUBLW  25
178A0:  BZ    17918
178A2:  MOVF   x77,W
178A4:  SUBLW  2B
178A6:  BZ    17918
178A8:  MOVF   x77,W
178AA:  SUBLW  2D
178AC:  BZ    17918
178AE:  MOVF   x77,W
178B0:  SUBLW  2F
178B2:  BZ    17918
178B4:  MOVF   x77,W
178B6:  SUBLW  3B
178B8:  BZ    17918
178BA:  MOVF   x77,W
178BC:  SUBLW  41
178BE:  BZ    17918
178C0:  MOVF   x77,W
178C2:  SUBLW  42
178C4:  BC    178CC
178C6:  MOVF   x77,W
178C8:  SUBLW  44
178CA:  BC    17918
178CC:  MOVF   x77,W
178CE:  SUBLW  45
178D0:  BC    178D8
178D2:  MOVF   x77,W
178D4:  SUBLW  48
178D6:  BC    17918
178D8:  MOVF   x77,W
178DA:  SUBLW  4A
178DC:  BC    178E4
178DE:  MOVF   x77,W
178E0:  SUBLW  4C
178E2:  BC    17918
178E4:  MOVF   x77,W
178E6:  SUBLW  4F
178E8:  BC    178F0
178EA:  MOVF   x77,W
178EC:  SUBLW  55
178EE:  BC    17918
178F0:  MOVF   x77,W
178F2:  SUBLW  59
178F4:  BZ    17918
178F6:  MOVF   x77,W
178F8:  SUBLW  64
178FA:  BZ    17918
178FC:  MOVF   x77,W
178FE:  SUBLW  69
17900:  BZ    17918
17902:  MOVF   x77,W
17904:  SUBLW  6C
17906:  BZ    17918
17908:  MOVF   x77,W
1790A:  SUBLW  70
1790C:  BZ    17918
1790E:  MOVF   x77,W
17910:  SUBLW  72
17912:  BZ    17918
17914:  MOVLW  00
17916:  BRA    1791A
17918:  MOVLW  01
1791A:  MOVWF  x79
....................          break; 
1791C:  MOVLB  0
1791E:  BRA    17A04
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
17920:  MOVLB  8
17922:  MOVF   x78,F
17924:  BNZ   1794E
17926:  MOVF   x77,W
17928:  SUBLW  23
1792A:  BZ    17948
1792C:  MOVF   x77,W
1792E:  SUBLW  3B
17930:  BZ    17948
17932:  MOVF   x77,W
17934:  SUBLW  4A
17936:  BZ    17948
17938:  MOVF   x77,W
1793A:  SUBLW  4D
1793C:  BZ    17948
1793E:  MOVF   x77,W
17940:  SUBLW  50
17942:  BZ    17948
17944:  MOVLW  00
17946:  BRA    1794A
17948:  MOVLW  01
1794A:  MOVWF  x79
1794C:  BRA    17992
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
1794E:  MOVF   x77,W
17950:  SUBLW  23
17952:  BZ    1798E
17954:  MOVF   x77,W
17956:  SUBLW  2B
17958:  BZ    1798E
1795A:  MOVF   x77,W
1795C:  SUBLW  2D
1795E:  BZ    1798E
17960:  MOVF   x77,W
17962:  SUBLW  3B
17964:  BZ    1798E
17966:  MOVF   x77,W
17968:  SUBLW  42
1796A:  BZ    1798E
1796C:  MOVF   x77,W
1796E:  SUBLW  47
17970:  BZ    1798E
17972:  MOVF   x77,W
17974:  SUBLW  4F
17976:  BC    1797E
17978:  MOVF   x77,W
1797A:  SUBLW  52
1797C:  BC    1798E
1797E:  MOVF   x77,W
17980:  SUBLW  54
17982:  BZ    1798E
17984:  MOVF   x77,W
17986:  SUBLW  59
17988:  BZ    1798E
1798A:  MOVLW  00
1798C:  BRA    17990
1798E:  MOVLW  01
17990:  MOVWF  x79
....................          break;   
17992:  MOVLB  0
17994:  BRA    17A04
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
17996:  MOVLB  8
17998:  MOVF   x78,F
1799A:  BNZ   179BE
1799C:  MOVF   x77,W
1799E:  SUBLW  23
179A0:  BZ    179B8
179A2:  MOVF   x77,W
179A4:  SUBLW  3B
179A6:  BZ    179B8
179A8:  MOVF   x77,W
179AA:  SUBLW  4D
179AC:  BZ    179B8
179AE:  MOVF   x77,W
179B0:  SUBLW  50
179B2:  BZ    179B8
179B4:  MOVLW  00
179B6:  BRA    179BA
179B8:  MOVLW  01
179BA:  MOVWF  x79
179BC:  BRA    17A02
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
179BE:  MOVF   x77,W
179C0:  SUBLW  23
179C2:  BZ    179FE
179C4:  MOVF   x77,W
179C6:  SUBLW  2B
179C8:  BZ    179FE
179CA:  MOVF   x77,W
179CC:  SUBLW  2D
179CE:  BZ    179FE
179D0:  MOVF   x77,W
179D2:  SUBLW  3B
179D4:  BZ    179FE
179D6:  MOVF   x77,W
179D8:  SUBLW  42
179DA:  BC    179E2
179DC:  MOVF   x77,W
179DE:  SUBLW  44
179E0:  BC    179FE
179E2:  MOVF   x77,W
179E4:  SUBLW  4F
179E6:  BC    179EE
179E8:  MOVF   x77,W
179EA:  SUBLW  51
179EC:  BC    179FE
179EE:  MOVF   x77,W
179F0:  SUBLW  53
179F2:  BZ    179FE
179F4:  MOVF   x77,W
179F6:  SUBLW  59
179F8:  BZ    179FE
179FA:  MOVLW  00
179FC:  BRA    17A00
179FE:  MOVLW  01
17A00:  MOVWF  x79
....................          break;   
17A02:  MOVLB  0
....................    } 
....................    return(valid_macro); 
17A04:  MOVLB  8
17A06:  MOVFF  879,01
17A0A:  MOVLB  0
17A0C:  GOTO   17A38 (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
17A10:  MOVLW  01
17A12:  MOVLB  8
17A14:  MOVWF  x76
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
17A16:  MOVLB  0
17A18:  CALL   0E1A
17A1C:  MOVFF  01,875
....................       if (com_echo == TRUE) fputc(e,COM_A); 
17A20:  DECFSZ 48,W
17A22:  BRA    17A2E
17A24:  MOVLB  8
17A26:  MOVF   x75,W
17A28:  MOVLB  0
17A2A:  CALL   ADAA
....................          valid_macro = check_macro(e, macro); 
17A2E:  MOVFF  875,877
17A32:  MOVFF  874,878
17A36:  BRA    1782E
17A38:  MOVFF  01,876
....................       if (valid_macro == TRUE) { 
17A3C:  MOVLB  8
17A3E:  DECFSZ x76,W
17A40:  BRA    17A4A
....................          return(e); 
17A42:  MOVFF  875,01
17A46:  BRA    17A56
....................       } 
17A48:  BRA    17A50
....................       else return(0); 
17A4A:  MOVLW  00
17A4C:  MOVWF  01
17A4E:  BRA    17A56
....................    } while (valid_macro == TRUE); 
17A50:  DECFSZ x76,W
17A52:  BRA    17A56
17A54:  BRA    17A16
17A56:  MOVLB  0
17A58:  GOTO   17E4A (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
17DD0:  BCF    FD8.0
17DD2:  MOVLB  8
17DD4:  RLCF   x77,W
17DD6:  CLRF   03
17DD8:  ADDLW  CD
17DDA:  MOVWF  FE9
17DDC:  MOVLW  07
17DDE:  ADDWFC 03,W
17DE0:  MOVWF  FEA
17DE2:  MOVFF  FEC,87D
17DE6:  MOVF   FED,F
17DE8:  MOVFF  FEF,87C
17DEC:  MOVFF  879,9EA
17DF0:  MOVFF  878,9E9
17DF4:  MOVLB  9
17DF6:  CLRF   xEC
17DF8:  MOVLW  03
17DFA:  MOVWF  xEB
17DFC:  MOVLB  0
17DFE:  CALL   5C0E
17E02:  MOVF   01,W
17E04:  MOVLB  8
17E06:  ADDWF  x7C,W
17E08:  MOVWF  x7A
17E0A:  MOVF   02,W
17E0C:  ADDWFC x7D,W
17E0E:  MOVWF  x7B
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
17E10:  MOVFF  87B,885
17E14:  MOVFF  87A,884
17E18:  MOVFF  874,886
17E1C:  MOVLB  0
17E1E:  RCALL  17B44
....................     
....................    ++addr; 
17E20:  MOVLB  8
17E22:  INCF   x7A,F
17E24:  BTFSC  FD8.2
17E26:  INCF   x7B,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
17E28:  MOVFF  87B,87D
17E2C:  MOVFF  87A,87C
17E30:  MOVFF  876,87F
17E34:  MOVFF  875,87E
17E38:  MOVLB  0
17E3A:  BRA    17D84
17E3C:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
17BA4:  BCF    FD8.0
17BA6:  MOVLB  8
17BA8:  RLCF   x75,W
17BAA:  CLRF   03
17BAC:  ADDLW  CD
17BAE:  MOVWF  FE9
17BB0:  MOVLW  07
17BB2:  ADDWFC 03,W
17BB4:  MOVWF  FEA
17BB6:  MOVFF  FEC,87E
17BBA:  MOVF   FED,F
17BBC:  MOVFF  FEF,87D
17BC0:  MOVFF  877,9EA
17BC4:  MOVFF  876,9E9
17BC8:  MOVLB  9
17BCA:  CLRF   xEC
17BCC:  MOVLW  03
17BCE:  MOVWF  xEB
17BD0:  MOVLB  0
17BD2:  CALL   5C0E
17BD6:  MOVF   01,W
17BD8:  MOVLB  8
17BDA:  ADDWF  x7D,W
17BDC:  MOVWF  x7A
17BDE:  MOVF   02,W
17BE0:  ADDWFC x7E,W
17BE2:  MOVWF  x7B
....................    write_ext_eeprom(addr, macro_cmd); 
17BE4:  MOVFF  87B,885
17BE8:  MOVFF  87A,884
17BEC:  MOVFF  874,886
17BF0:  MOVLB  0
17BF2:  RCALL  17B44
....................     
....................    int i = 0; 
17BF4:  MOVLB  8
17BF6:  CLRF   x7C
....................    addr = string_address[macro] + (count*50); 
17BF8:  BCF    FD8.0
17BFA:  RLCF   x75,W
17BFC:  CLRF   03
17BFE:  ADDLW  F7
17C00:  MOVWF  FE9
17C02:  MOVLW  07
17C04:  ADDWFC 03,W
17C06:  MOVWF  FEA
17C08:  MOVFF  FEC,87E
17C0C:  MOVF   FED,F
17C0E:  MOVFF  FEF,87D
17C12:  MOVFF  879,9EA
17C16:  MOVFF  878,9E9
17C1A:  MOVLB  9
17C1C:  CLRF   xEC
17C1E:  MOVLW  32
17C20:  MOVWF  xEB
17C22:  MOVLB  0
17C24:  CALL   5C0E
17C28:  MOVF   01,W
17C2A:  MOVLB  8
17C2C:  ADDWF  x7D,W
17C2E:  MOVWF  x7A
17C30:  MOVF   02,W
17C32:  ADDWFC x7E,W
17C34:  MOVWF  x7B
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
17C36:  MOVF   x79,F
17C38:  BNZ   17C8E
17C3A:  MOVF   x78,W
17C3C:  SUBLW  14
17C3E:  BNC   17C8E
....................       for(i = 0; i<50; i++) { 
17C40:  CLRF   x7C
17C42:  MOVF   x7C,W
17C44:  SUBLW  31
17C46:  BNC   17C8C
....................          write_ext_eeprom(addr + i, string_arg[i]); 
17C48:  MOVF   x7C,W
17C4A:  ADDWF  x7A,W
17C4C:  MOVWF  x7D
17C4E:  MOVLW  00
17C50:  ADDWFC x7B,W
17C52:  MOVWF  x7E
17C54:  CLRF   03
17C56:  MOVF   x7C,W
17C58:  ADDLW  21
17C5A:  MOVWF  FE9
17C5C:  MOVLW  08
17C5E:  ADDWFC 03,W
17C60:  MOVWF  FEA
17C62:  MOVFF  FEF,886
17C66:  MOVFF  87E,885
17C6A:  MOVFF  87D,884
17C6E:  MOVLB  0
17C70:  RCALL  17B44
....................          if(string_arg[i] == 0){ 
17C72:  CLRF   03
17C74:  MOVLB  8
17C76:  MOVF   x7C,W
17C78:  ADDLW  21
17C7A:  MOVWF  FE9
17C7C:  MOVLW  08
17C7E:  ADDWFC 03,W
17C80:  MOVWF  FEA
17C82:  MOVF   FEF,F
17C84:  BNZ   17C88
....................             break; 
17C86:  BRA    17C8C
....................          } 
17C88:  INCF   x7C,F
17C8A:  BRA    17C42
....................       
....................       } 
....................    }else{ 
17C8C:  BRA    17CE0
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
17C8E:  MOVLW  B4
17C90:  MOVWF  FF6
17C92:  MOVLW  20
17C94:  MOVWF  FF7
17C96:  MOVLW  00
17C98:  MOVWF  FF8
17C9A:  CLRF   1B
17C9C:  BTFSC  FF2.7
17C9E:  BSF    1B.7
17CA0:  BCF    FF2.7
17CA2:  MOVLW  1E
17CA4:  MOVLB  A
17CA6:  MOVWF  x18
17CA8:  MOVLB  0
17CAA:  CALL   1006
17CAE:  BTFSC  1B.7
17CB0:  BSF    FF2.7
17CB2:  MOVLW  10
17CB4:  MOVWF  FE9
17CB6:  CLRF   1B
17CB8:  BTFSC  FF2.7
17CBA:  BSF    1B.7
17CBC:  BCF    FF2.7
17CBE:  MOVFF  877,A19
17CC2:  MOVFF  876,A18
17CC6:  CALL   1188
17CCA:  BTFSC  1B.7
17CCC:  BSF    FF2.7
17CCE:  MOVLW  0A
17CD0:  BTFSS  F9E.4
17CD2:  BRA    17CD0
17CD4:  MOVWF  FAD
17CD6:  MOVLW  0D
17CD8:  BTFSS  F9E.4
17CDA:  BRA    17CD8
17CDC:  MOVWF  FAD
17CDE:  MOVLB  8
....................    } 
17CE0:  MOVLB  0
17CE2:  GOTO   17E82 (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
18022:  CALL   FFDC
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
18026:  MOVLW  3B
18028:  MOVLB  8
1802A:  MOVWF  x74
1802C:  CLRF   x76
1802E:  CLRF   x75
18030:  CLRF   x77
18032:  CLRF   x79
18034:  CLRF   x78
18036:  MOVLB  0
18038:  RCALL  17DD0
....................     
....................    write_macro_line(59, 0, 1, 0); 
1803A:  MOVLW  3B
1803C:  MOVLB  8
1803E:  MOVWF  x74
18040:  CLRF   x76
18042:  CLRF   x75
18044:  MOVLW  01
18046:  MOVWF  x77
18048:  CLRF   x79
1804A:  CLRF   x78
1804C:  MOVLB  0
1804E:  RCALL  17DD0
....................    write_macro_line(59, 0, 2, 0); 
18050:  MOVLW  3B
18052:  MOVLB  8
18054:  MOVWF  x74
18056:  CLRF   x76
18058:  CLRF   x75
1805A:  MOVLW  02
1805C:  MOVWF  x77
1805E:  CLRF   x79
18060:  CLRF   x78
18062:  MOVLB  0
18064:  RCALL  17DD0
....................    write_macro_line(59, 0, 3, 0); 
18066:  MOVLW  3B
18068:  MOVLB  8
1806A:  MOVWF  x74
1806C:  CLRF   x76
1806E:  CLRF   x75
18070:  MOVLW  03
18072:  MOVWF  x77
18074:  CLRF   x79
18076:  CLRF   x78
18078:  MOVLB  0
1807A:  RCALL  17DD0
....................    write_macro_line(59, 0, 4, 0); 
1807C:  MOVLW  3B
1807E:  MOVLB  8
18080:  MOVWF  x74
18082:  CLRF   x76
18084:  CLRF   x75
18086:  MOVLW  04
18088:  MOVWF  x77
1808A:  CLRF   x79
1808C:  CLRF   x78
1808E:  MOVLB  0
18090:  RCALL  17DD0
....................    write_macro_line(59, 0, 5, 0); 
18092:  MOVLW  3B
18094:  MOVLB  8
18096:  MOVWF  x74
18098:  CLRF   x76
1809A:  CLRF   x75
1809C:  MOVLW  05
1809E:  MOVWF  x77
180A0:  CLRF   x79
180A2:  CLRF   x78
180A4:  MOVLB  0
180A6:  RCALL  17DD0
....................    write_macro_line(59, 0, 6, 0); 
180A8:  MOVLW  3B
180AA:  MOVLB  8
180AC:  MOVWF  x74
180AE:  CLRF   x76
180B0:  CLRF   x75
180B2:  MOVLW  06
180B4:  MOVWF  x77
180B6:  CLRF   x79
180B8:  CLRF   x78
180BA:  MOVLB  0
180BC:  RCALL  17DD0
....................    write_macro_line(59, 0, 7, 0); 
180BE:  MOVLW  3B
180C0:  MOVLB  8
180C2:  MOVWF  x74
180C4:  CLRF   x76
180C6:  CLRF   x75
180C8:  MOVLW  07
180CA:  MOVWF  x77
180CC:  CLRF   x79
180CE:  CLRF   x78
180D0:  MOVLB  0
180D2:  RCALL  17DD0
....................    write_macro_line(59, 0, 8, 0); 
180D4:  MOVLW  3B
180D6:  MOVLB  8
180D8:  MOVWF  x74
180DA:  CLRF   x76
180DC:  CLRF   x75
180DE:  MOVLW  08
180E0:  MOVWF  x77
180E2:  CLRF   x79
180E4:  CLRF   x78
180E6:  MOVLB  0
180E8:  RCALL  17DD0
....................     
....................    write_macro_line(59, 0, 9, 0); 
180EA:  MOVLW  3B
180EC:  MOVLB  8
180EE:  MOVWF  x74
180F0:  CLRF   x76
180F2:  CLRF   x75
180F4:  MOVLW  09
180F6:  MOVWF  x77
180F8:  CLRF   x79
180FA:  CLRF   x78
180FC:  MOVLB  0
180FE:  RCALL  17DD0
....................    write_macro_line(59, 0, 10, 0); 
18100:  MOVLW  3B
18102:  MOVLB  8
18104:  MOVWF  x74
18106:  CLRF   x76
18108:  CLRF   x75
1810A:  MOVLW  0A
1810C:  MOVWF  x77
1810E:  CLRF   x79
18110:  CLRF   x78
18112:  MOVLB  0
18114:  RCALL  17DD0
....................    write_macro_line(59, 0, 11, 0); 
18116:  MOVLW  3B
18118:  MOVLB  8
1811A:  MOVWF  x74
1811C:  CLRF   x76
1811E:  CLRF   x75
18120:  MOVLW  0B
18122:  MOVWF  x77
18124:  CLRF   x79
18126:  CLRF   x78
18128:  MOVLB  0
1812A:  RCALL  17DD0
....................    write_macro_line(59, 0, 12, 0); 
1812C:  MOVLW  3B
1812E:  MOVLB  8
18130:  MOVWF  x74
18132:  CLRF   x76
18134:  CLRF   x75
18136:  MOVLW  0C
18138:  MOVWF  x77
1813A:  CLRF   x79
1813C:  CLRF   x78
1813E:  MOVLB  0
18140:  RCALL  17DD0
....................    write_macro_line(59, 0, 13, 0); 
18142:  MOVLW  3B
18144:  MOVLB  8
18146:  MOVWF  x74
18148:  CLRF   x76
1814A:  CLRF   x75
1814C:  MOVLW  0D
1814E:  MOVWF  x77
18150:  CLRF   x79
18152:  CLRF   x78
18154:  MOVLB  0
18156:  RCALL  17DD0
....................    write_macro_line(59, 0, 14, 0); 
18158:  MOVLW  3B
1815A:  MOVLB  8
1815C:  MOVWF  x74
1815E:  CLRF   x76
18160:  CLRF   x75
18162:  MOVLW  0E
18164:  MOVWF  x77
18166:  CLRF   x79
18168:  CLRF   x78
1816A:  MOVLB  0
1816C:  RCALL  17DD0
....................    write_macro_line(59, 0, 15, 0); 
1816E:  MOVLW  3B
18170:  MOVLB  8
18172:  MOVWF  x74
18174:  CLRF   x76
18176:  CLRF   x75
18178:  MOVLW  0F
1817A:  MOVWF  x77
1817C:  CLRF   x79
1817E:  CLRF   x78
18180:  MOVLB  0
18182:  RCALL  17DD0
....................    write_macro_line(59, 0, 16, 0); 
18184:  MOVLW  3B
18186:  MOVLB  8
18188:  MOVWF  x74
1818A:  CLRF   x76
1818C:  CLRF   x75
1818E:  MOVLW  10
18190:  MOVWF  x77
18192:  CLRF   x79
18194:  CLRF   x78
18196:  MOVLB  0
18198:  RCALL  17DD0
1819A:  GOTO   181D2 (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
17A5C:  MOVLB  8
17A5E:  CLRF   x74
....................     
....................    heartbeat(FALSE); 
17A60:  CLRF   xCA
17A62:  MOVLB  0
17A64:  CALL   54FA
....................     
....................    while(mcc != CARRIAGE_RET){ 
17A68:  MOVLB  8
17A6A:  MOVF   x74,W
17A6C:  SUBLW  0D
17A6E:  BZ    17A90
....................       if (kbhit(COM_A)) { 
17A70:  BTFSS  F9E.5
17A72:  BRA    17A8E
....................          mcc=fgetc(COM_A); 
17A74:  MOVLB  0
17A76:  CALL   0E1A
17A7A:  MOVFF  01,874
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
17A7E:  DECFSZ 48,W
17A80:  BRA    17A8C
17A82:  MOVLB  8
17A84:  MOVF   x74,W
17A86:  MOVLB  0
17A88:  CALL   ADAA
17A8C:  MOVLB  8
....................       } 
17A8E:  BRA    17A6A
....................    } 
....................     
....................    heartbeat(TRUE); 
17A90:  MOVLW  01
17A92:  MOVWF  xCA
17A94:  MOVLB  0
17A96:  CALL   54FA
17A9A:  GOTO   17E5A (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
17E3E:  MOVLB  8
17E40:  CLRF   x73
....................     
....................    macro_cmd = get_cmd(macro); 
17E42:  MOVFF  86B,874
17E46:  MOVLB  0
17E48:  BRA    17A10
17E4A:  MOVFF  01,870
....................    if (macro_cmd == 35){  
17E4E:  MOVLB  8
17E50:  MOVF   x70,W
17E52:  SUBLW  23
17E54:  BNZ   17E5E
....................       macro_comment();        // # = 35 
17E56:  MOVLB  0
17E58:  BRA    17A5C
....................    }else if(macro_cmd == 112){// 112 is p 
17E5A:  BRA    17EE0
17E5C:  MOVLB  8
17E5E:  MOVF   x70,W
17E60:  SUBLW  70
17E62:  BNZ   17E8A
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
17E64:  MOVLB  0
17E66:  BRA    17A9E
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
17E68:  MOVFF  870,874
17E6C:  MOVFF  86B,875
17E70:  MOVFF  86D,877
17E74:  MOVFF  86C,876
17E78:  MOVFF  86F,879
17E7C:  MOVFF  86E,878
17E80:  BRA    17BA4
....................       valid_macro = TRUE; 
17E82:  MOVLW  01
17E84:  MOVLB  8
17E86:  MOVWF  x73
....................    }else{ 
17E88:  BRA    17EDE
....................       if (macro_cmd != 0) { 
17E8A:  MOVF   x70,F
17E8C:  BZ    17EB4
....................          macro_arg = get_arg(); 
17E8E:  MOVLB  0
17E90:  BRA    17CE6
17E92:  MOVFF  02,872
17E96:  MOVFF  01,871
....................          if (macro_arg != 65535) valid_macro = TRUE; 
17E9A:  MOVLB  8
17E9C:  INCFSZ x71,W
17E9E:  BRA    17EA6
17EA0:  INCFSZ x72,W
17EA2:  BRA    17EA6
17EA4:  BRA    17EAC
17EA6:  MOVLW  01
17EA8:  MOVWF  x73
17EAA:  BRA    17EB2
....................          else return(macro_cmd); 
17EAC:  MOVFF  870,01
17EB0:  BRA    17EE6
....................       }else return(macro_cmd); 
17EB2:  BRA    17EBA
17EB4:  MOVFF  870,01
17EB8:  BRA    17EE6
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
17EBA:  MOVFF  870,874
17EBE:  MOVFF  872,876
17EC2:  MOVFF  871,875
17EC6:  MOVFF  86B,877
17ECA:  MOVFF  86D,879
17ECE:  MOVFF  86C,878
17ED2:  MOVLB  0
17ED4:  RCALL  17DD0
....................       return(macro_cmd); 
17ED6:  MOVLB  8
17ED8:  MOVFF  870,01
17EDC:  BRA    17EE6
17EDE:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
17EE0:  MOVLB  8
17EE2:  MOVFF  870,01
17EE6:  MOVLB  0
17EE8:  GOTO   17F2E (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
17EEC:  MOVLB  8
17EEE:  CLRF   x6A
17EF0:  CLRF   x69
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
17EF2:  CLRF   x65
17EF4:  CLRF   x64
....................    valid_macro = TRUE; 
17EF6:  MOVLW  01
17EF8:  MOVWF  x66
....................    macro_cmd = 1; 
17EFA:  MOVWF  x67
....................     
....................    init_ext_eeprom(); 
17EFC:  MOVLB  0
17EFE:  CALL   FFDC
....................     
....................    fprintf(COM_A, ":"); 
17F02:  MOVLW  3A
17F04:  BTFSS  F9E.4
17F06:  BRA    17F04
17F08:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
17F0A:  MOVLB  8
17F0C:  MOVF   x67,W
17F0E:  SUBLW  3B
17F10:  BZ    17F74
17F12:  MOVF   x67,F
17F14:  BZ    17F74
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
17F16:  MOVFF  863,86B
17F1A:  MOVFF  865,86D
17F1E:  MOVFF  864,86C
17F22:  MOVFF  86A,86F
17F26:  MOVFF  869,86E
17F2A:  MOVLB  0
17F2C:  BRA    17E3E
17F2E:  MOVFF  01,867
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
17F32:  MOVLB  8
17F34:  MOVF   x67,W
17F36:  SUBLW  70
17F38:  BNZ   17F40
....................          count++; 
17F3A:  INCF   x69,F
17F3C:  BTFSC  FD8.2
17F3E:  INCF   x6A,F
....................       } 
....................       if (macro_cmd != 35) ++line; 
17F40:  MOVF   x67,W
17F42:  SUBLW  23
17F44:  BZ    17F4C
17F46:  INCF   x64,F
17F48:  BTFSC  FD8.2
17F4A:  INCF   x65,F
....................       if (macro_cmd != 59) printf("\r\n:"); 
17F4C:  MOVF   x67,W
17F4E:  SUBLW  3B
17F50:  BZ    17F72
17F52:  MOVLW  D8
17F54:  MOVWF  FF6
17F56:  MOVLW  20
17F58:  MOVWF  FF7
17F5A:  MOVLW  00
17F5C:  MOVWF  FF8
17F5E:  CLRF   1B
17F60:  BTFSC  FF2.7
17F62:  BSF    1B.7
17F64:  BCF    FF2.7
17F66:  MOVLB  0
17F68:  CALL   0E30
17F6C:  BTFSC  1B.7
17F6E:  BSF    FF2.7
17F70:  MOVLB  8
17F72:  BRA    17F0C
....................    }       
....................    if (macro_cmd == 0){ 
17F74:  MOVF   x67,F
17F76:  BNZ   1800C
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
17F78:  MOVLW  DC
17F7A:  MOVWF  FF6
17F7C:  MOVLW  20
17F7E:  MOVWF  FF7
17F80:  MOVLW  00
17F82:  MOVWF  FF8
17F84:  CLRF   1B
17F86:  BTFSC  FF2.7
17F88:  BSF    1B.7
17F8A:  BCF    FF2.7
17F8C:  MOVLB  0
17F8E:  CALL   0E30
17F92:  BTFSC  1B.7
17F94:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
17F96:  MOVLW  04
17F98:  MOVWF  FF6
17F9A:  MOVLW  21
17F9C:  MOVWF  FF7
17F9E:  MOVLW  00
17FA0:  MOVWF  FF8
17FA2:  CLRF   1B
17FA4:  BTFSC  FF2.7
17FA6:  BSF    1B.7
17FA8:  BCF    FF2.7
17FAA:  MOVLW  15
17FAC:  MOVLB  A
17FAE:  MOVWF  x18
17FB0:  MOVLB  0
17FB2:  CALL   1006
17FB6:  BTFSC  1B.7
17FB8:  BSF    FF2.7
17FBA:  MOVLW  10
17FBC:  MOVWF  FE9
17FBE:  MOVFF  865,8CE
17FC2:  MOVFF  864,8CD
17FC6:  CALL   8F1A
17FCA:  MOVLW  1C
17FCC:  MOVWF  FF6
17FCE:  MOVLW  21
17FD0:  MOVWF  FF7
17FD2:  MOVLW  00
17FD4:  MOVWF  FF8
17FD6:  CLRF   1B
17FD8:  BTFSC  FF2.7
17FDA:  BSF    1B.7
17FDC:  BCF    FF2.7
17FDE:  MOVLW  03
17FE0:  MOVLB  A
17FE2:  MOVWF  x18
17FE4:  MOVLB  0
17FE6:  CALL   1006
17FEA:  BTFSC  1B.7
17FEC:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
17FEE:  MOVLW  20
17FF0:  MOVWF  FF6
17FF2:  MOVLW  21
17FF4:  MOVWF  FF7
17FF6:  MOVLW  00
17FF8:  MOVWF  FF8
17FFA:  CLRF   1B
17FFC:  BTFSC  FF2.7
17FFE:  BSF    1B.7
18000:  BCF    FF2.7
18002:  CALL   0E30
18006:  BTFSC  1B.7
18008:  BSF    FF2.7
1800A:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
1800C:  MOVLW  0D
1800E:  BTFSS  F9E.4
18010:  BRA    1800E
18012:  MOVWF  FAD
18014:  MOVLW  0A
18016:  BTFSS  F9E.4
18018:  BRA    18016
1801A:  MOVWF  FAD
1801C:  MOVLB  0
1801E:  GOTO   181BA (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
181DC:  BCF    FD8.0
181DE:  MOVLB  8
181E0:  RLCF   x68,W
181E2:  CLRF   03
181E4:  ADDLW  CD
181E6:  MOVWF  FE9
181E8:  MOVLW  07
181EA:  ADDWFC 03,W
181EC:  MOVWF  FEA
181EE:  MOVFF  FEC,871
181F2:  MOVF   FED,F
181F4:  MOVFF  FEF,870
181F8:  MOVFF  86A,9EA
181FC:  MOVFF  869,9E9
18200:  MOVLB  9
18202:  CLRF   xEC
18204:  MOVLW  03
18206:  MOVWF  xEB
18208:  MOVLB  0
1820A:  CALL   5C0E
1820E:  MOVF   01,W
18210:  MOVLB  8
18212:  ADDWF  x70,W
18214:  MOVWF  x6B
18216:  MOVF   02,W
18218:  ADDWFC x71,W
1821A:  MOVWF  x6C
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
1821C:  MOVFF  86C,8A9
18220:  MOVFF  86B,8A8
18224:  MOVLB  0
18226:  CALL   102F0
1822A:  MOVFF  01,86D
....................    ++addr; 
1822E:  MOVLB  8
18230:  INCF   x6B,F
18232:  BTFSC  FD8.2
18234:  INCF   x6C,F
....................    macro_arg = read16_ext_eeprom(addr); 
18236:  MOVFF  86C,8A0
1823A:  MOVFF  86B,89F
1823E:  MOVLB  0
18240:  CALL   10404
18244:  MOVFF  02,86F
18248:  MOVFF  01,86E
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
1824C:  MOVLB  8
1824E:  MOVF   x6D,W
18250:  BTFSS  F9E.4
18252:  BRA    18250
18254:  MOVWF  FAD
18256:  MOVLW  10
18258:  MOVWF  FE9
1825A:  CLRF   1B
1825C:  BTFSC  FF2.7
1825E:  BSF    1B.7
18260:  BCF    FF2.7
18262:  MOVFF  86F,A19
18266:  MOVFF  86E,A18
1826A:  MOVLB  0
1826C:  CALL   1188
18270:  BTFSC  1B.7
18272:  BSF    FF2.7
18274:  MOVLW  0D
18276:  BTFSS  F9E.4
18278:  BRA    18276
1827A:  MOVWF  FAD
1827C:  MOVLW  0A
1827E:  BTFSS  F9E.4
18280:  BRA    1827E
18282:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
18284:  MOVLB  8
18286:  MOVFF  86D,01
1828A:  MOVLB  0
1828C:  GOTO   182C0 (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
13EA6:  BCF    FD8.0
13EA8:  MOVLB  8
13EAA:  RLCF   x94,W
13EAC:  CLRF   03
13EAE:  ADDLW  CD
13EB0:  MOVWF  FE9
13EB2:  MOVLW  07
13EB4:  ADDWFC 03,W
13EB6:  MOVWF  FEA
13EB8:  MOVFF  FEC,89D
13EBC:  MOVF   FED,F
13EBE:  MOVFF  FEF,89C
13EC2:  MOVFF  896,9EA
13EC6:  MOVFF  895,9E9
13ECA:  MOVLB  9
13ECC:  CLRF   xEC
13ECE:  MOVLW  03
13ED0:  MOVWF  xEB
13ED2:  MOVLB  0
13ED4:  CALL   5C0E
13ED8:  MOVF   01,W
13EDA:  MOVLB  8
13EDC:  ADDWF  x9C,W
13EDE:  MOVWF  x97
13EE0:  MOVF   02,W
13EE2:  ADDWFC x9D,W
13EE4:  MOVWF  x98
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
13EE6:  MOVFF  898,8A9
13EEA:  MOVFF  897,8A8
13EEE:  MOVLB  0
13EF0:  CALL   102F0
13EF4:  MOVFF  01,899
....................    ++addr; 
13EF8:  MOVLB  8
13EFA:  INCF   x97,F
13EFC:  BTFSC  FD8.2
13EFE:  INCF   x98,F
....................    macro_arg = read16_ext_eeprom(addr); 
13F00:  MOVFF  898,8A0
13F04:  MOVFF  897,89F
13F08:  MOVLB  0
13F0A:  CALL   10404
13F0E:  MOVFF  02,89B
13F12:  MOVFF  01,89A
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
13F16:  MOVLB  8
13F18:  MOVF   x99,W
13F1A:  BTFSS  F9E.4
13F1C:  BRA    13F1A
13F1E:  MOVWF  FAD
13F20:  MOVLW  10
13F22:  MOVWF  FE9
13F24:  CLRF   1B
13F26:  BTFSC  FF2.7
13F28:  BSF    1B.7
13F2A:  BCF    FF2.7
13F2C:  MOVFF  89B,A19
13F30:  MOVFF  89A,A18
13F34:  MOVLB  0
13F36:  CALL   1188
13F3A:  BTFSC  1B.7
13F3C:  BSF    FF2.7
13F3E:  MOVLW  0D
13F40:  BTFSS  F9E.4
13F42:  BRA    13F40
13F44:  MOVWF  FAD
13F46:  MOVLW  0A
13F48:  BTFSS  F9E.4
13F4A:  BRA    13F48
13F4C:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
13F4E:  MOVLB  8
13F50:  MOVFF  899,01
13F54:  MOVLB  0
13F56:  GOTO   1472E (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
1034A:  BCF    FD8.0
1034C:  MOVLB  8
1034E:  RLCF   x92,W
10350:  CLRF   03
10352:  ADDLW  F7
10354:  MOVWF  FE9
10356:  MOVLW  07
10358:  ADDWFC 03,W
1035A:  MOVWF  FEA
1035C:  MOVFF  FEC,89B
10360:  MOVF   FED,F
10362:  MOVFF  FEF,89A
10366:  MOVFF  896,9EA
1036A:  MOVFF  895,9E9
1036E:  MOVLB  9
10370:  CLRF   xEC
10372:  MOVLW  32
10374:  MOVWF  xEB
10376:  MOVLB  0
10378:  CALL   5C0E
1037C:  MOVF   01,W
1037E:  MOVLB  8
10380:  ADDWF  x9A,W
10382:  MOVWF  x97
10384:  MOVF   02,W
10386:  ADDWFC x9B,W
10388:  MOVWF  x98
....................     
....................    int i = 0; 
1038A:  CLRF   x99
....................    for(i = 0; i < 50; i++){ 
1038C:  CLRF   x99
1038E:  MOVF   x99,W
10390:  SUBLW  31
10392:  BNC   103A8
....................       string_arg[i] = 0; 
10394:  CLRF   03
10396:  MOVF   x99,W
10398:  ADDLW  21
1039A:  MOVWF  FE9
1039C:  MOVLW  08
1039E:  ADDWFC 03,W
103A0:  MOVWF  FEA
103A2:  CLRF   FEF
103A4:  INCF   x99,F
103A6:  BRA    1038E
....................    }  
....................    for(i = 0; i < 50; i++){ 
103A8:  CLRF   x99
103AA:  MOVF   x99,W
103AC:  SUBLW  31
103AE:  BNC   10400
....................       string_arg[i] = read_ext_eeprom(addr + i); 
103B0:  CLRF   03
103B2:  MOVF   x99,W
103B4:  ADDLW  21
103B6:  MOVWF  01
103B8:  MOVLW  08
103BA:  ADDWFC 03,F
103BC:  MOVFF  01,89A
103C0:  MOVFF  03,89B
103C4:  MOVF   x99,W
103C6:  ADDWF  x97,W
103C8:  MOVWF  x9C
103CA:  MOVLW  00
103CC:  ADDWFC x98,W
103CE:  MOVWF  x9D
103D0:  MOVWF  xA9
103D2:  MOVFF  89C,8A8
103D6:  MOVLB  0
103D8:  RCALL  102F0
103DA:  MOVFF  89B,FEA
103DE:  MOVFF  89A,FE9
103E2:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
103E6:  CLRF   03
103E8:  MOVLB  8
103EA:  MOVF   x99,W
103EC:  ADDLW  21
103EE:  MOVWF  FE9
103F0:  MOVLW  08
103F2:  ADDWFC 03,W
103F4:  MOVWF  FEA
103F6:  MOVF   FEF,F
103F8:  BNZ   103FC
....................          break; 
103FA:  BRA    10400
....................       } 
103FC:  INCF   x99,F
103FE:  BRA    103AA
....................    }   
10400:  MOVLB  0
10402:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
18290:  MOVLB  8
18292:  CLRF   x67
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
18294:  CLRF   x65
18296:  CLRF   x64
....................    macro_cmd = 1; 
18298:  MOVLW  01
1829A:  MOVWF  x66
....................     
....................    init_ext_eeprom(); 
1829C:  MOVLB  0
1829E:  CALL   FFDC
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
182A2:  MOVLB  8
182A4:  MOVF   x65,W
182A6:  SUBLW  03
182A8:  BNC   182F0
182AA:  MOVF   x66,W
182AC:  SUBLW  3B
182AE:  BZ    182F0
....................       macro_cmd = read_macro_line(macro, line); 
182B0:  MOVFF  863,868
182B4:  MOVFF  865,86A
182B8:  MOVFF  864,869
182BC:  MOVLB  0
182BE:  BRA    181DC
182C0:  MOVFF  01,866
....................       if(macro_cmd == 'p'){ 
182C4:  MOVLB  8
182C6:  MOVF   x66,W
182C8:  SUBLW  70
182CA:  BNZ   182E8
....................          read_macro_line_string(macro,line,count); 
182CC:  MOVFF  863,892
182D0:  MOVFF  865,894
182D4:  MOVFF  864,893
182D8:  CLRF   x96
182DA:  MOVFF  867,895
182DE:  MOVLB  0
182E0:  CALL   1034A
....................          count++; 
182E4:  MOVLB  8
182E6:  INCF   x67,F
....................       } 
....................       ++line; 
182E8:  INCF   x64,F
182EA:  BTFSC  FD8.2
182EC:  INCF   x65,F
182EE:  BRA    182A4
....................    } 
182F0:  MOVLB  0
182F2:  GOTO   18312 (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0D036:  MOVLB  8
0D038:  CLRF   xA2
0D03A:  CLRF   xA1
0D03C:  MOVF   xA2,W
0D03E:  SUBWF  xA0,W
0D040:  BNC   D068
0D042:  BNZ   D04A
0D044:  MOVF   x9F,W
0D046:  SUBWF  xA1,W
0D048:  BC    D068
....................       delay_ms(1000); 
0D04A:  MOVLW  04
0D04C:  MOVWF  xA3
0D04E:  MOVLW  FA
0D050:  MOVLB  9
0D052:  MOVWF  xC9
0D054:  MOVLB  0
0D056:  CALL   288E
0D05A:  MOVLB  8
0D05C:  DECFSZ xA3,F
0D05E:  BRA    D04E
0D060:  INCF   xA1,F
0D062:  BTFSC  FD8.2
0D064:  INCF   xA2,F
0D066:  BRA    D03C
....................    }  
0D068:  MOVLB  0
0D06A:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0CFFE:  BCF    FD8.0
0D000:  MOVLB  7
0D002:  RLCF   x3C,W
0D004:  CLRF   03
0D006:  ADDLW  92
0D008:  MOVWF  FE9
0D00A:  MOVLW  07
0D00C:  ADDWFC 03,W
0D00E:  MOVWF  FEA
0D010:  MOVFF  FEC,8A1
0D014:  MOVF   FED,F
0D016:  MOVFF  FEF,8A0
0D01A:  MOVLB  8
0D01C:  DECFSZ xA0,W
0D01E:  BRA    D02A
0D020:  MOVF   xA1,F
0D022:  BNZ   D02A
....................    { 
....................       macro_status = 'e'; 
0D024:  MOVLW  65
0D026:  MOVWF  x9F
....................    } 
0D028:  BRA    D02E
....................    else 
....................    { 
....................       macro_status = 'a'; 
0D02A:  MOVLW  61
0D02C:  MOVWF  x9F
....................    } 
....................    return(macro_status); 
0D02E:  MOVFF  89F,01
0D032:  MOVLB  0
0D034:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
13542:  DECFSZ 41,W
13544:  BRA    13558
13546:  MOVF   42,F
13548:  BNZ   13558
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
1354A:  MOVLW  01
1354C:  MOVLB  8
1354E:  MOVWF  x9F
13550:  MOVWF  xA0
13552:  MOVLB  0
13554:  RCALL  1340C
....................    } 
13556:  BRA    13582
....................    else if(nv_det_type==2 || nv_det_type==3) 
13558:  MOVF   41,W
1355A:  SUBLW  02
1355C:  BNZ   13562
1355E:  MOVF   42,F
13560:  BZ    1356C
13562:  MOVF   41,W
13564:  SUBLW  03
13566:  BNZ   13582
13568:  MOVF   42,F
1356A:  BNZ   13582
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
1356C:  MOVLB  8
1356E:  CLRF   xA0
13570:  MOVLW  C8
13572:  MOVWF  x9F
13574:  MOVLW  01
13576:  MOVWF  xA1
13578:  MOVWF  xA2
1357A:  CLRF   xA3
1357C:  MOVLB  0
1357E:  CALL   FCF2
....................    } 
13582:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
12460:  DECFSZ 41,W
12462:  BRA    1247E
12464:  MOVF   42,F
12466:  BNZ   1247E
....................       cmd = macro_cmd; 
12468:  MOVFF  89F,43
....................       arg = macro_arg; 
1246C:  CLRF   47
1246E:  CLRF   46
12470:  MOVFF  8A1,45
12474:  MOVFF  8A0,44
....................       det_cmd(); 
12478:  CALL   F0FA
....................    } 
1247C:  BRA    12498
....................    else if(nv_det_type==2 || nv_det_type==3) { 
1247E:  MOVF   41,W
12480:  SUBLW  02
12482:  BNZ   12488
12484:  MOVF   42,F
12486:  BZ    12492
12488:  MOVF   41,W
1248A:  SUBLW  03
1248C:  BNZ   12498
1248E:  MOVF   42,F
12490:  BNZ   12498
....................       set_heaters(macro_arg); 
12492:  MOVFF  8A0,8A2
12496:  RCALL  123EC
....................    } 
12498:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
1249A:  DECFSZ 41,W
1249C:  BRA    124B8
1249E:  MOVF   42,F
124A0:  BNZ   124B8
....................       cmd = macro_cmd; 
124A2:  MOVFF  89F,43
....................       arg = macro_arg; 
124A6:  CLRF   47
124A8:  CLRF   46
124AA:  MOVFF  8A1,45
124AE:  MOVFF  8A0,44
....................       det_cmd(); 
124B2:  CALL   F0FA
....................    } 
124B6:  BRA    124D8
....................    else if(nv_det_type==2 || nv_det_type==3) { 
124B8:  MOVF   41,W
124BA:  SUBLW  02
124BC:  BNZ   124C2
124BE:  MOVF   42,F
124C0:  BZ    124CC
124C2:  MOVF   41,W
124C4:  SUBLW  03
124C6:  BNZ   124D8
124C8:  MOVF   42,F
124CA:  BNZ   124D8
....................       set_LED(macro_arg); 
124CC:  MOVFF  8A1,8A3
124D0:  MOVFF  8A0,8A2
124D4:  CALL   F5B0
....................    } 
124D8:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13ABA:  MOVLW  65
13ABC:  MOVLB  8
13ABE:  MOVWF  x9E
....................     
....................    addr = macro_address[macro] + (line*3); 
13AC0:  BCF    FD8.0
13AC2:  RLCF   x94,W
13AC4:  CLRF   03
13AC6:  ADDLW  CD
13AC8:  MOVWF  FE9
13ACA:  MOVLW  07
13ACC:  ADDWFC 03,W
13ACE:  MOVWF  FEA
13AD0:  MOVFF  FEC,8A0
13AD4:  MOVF   FED,F
13AD6:  MOVFF  FEF,89F
13ADA:  MOVFF  896,9EA
13ADE:  MOVFF  895,9E9
13AE2:  MOVLB  9
13AE4:  CLRF   xEC
13AE6:  MOVLW  03
13AE8:  MOVWF  xEB
13AEA:  MOVLB  0
13AEC:  CALL   5C0E
13AF0:  MOVF   01,W
13AF2:  MOVLB  8
13AF4:  ADDWF  x9F,W
13AF6:  MOVWF  x99
13AF8:  MOVF   02,W
13AFA:  ADDWFC xA0,W
13AFC:  MOVWF  x9A
....................  
....................    init_ext_eeprom(); 
13AFE:  MOVLB  0
13B00:  CALL   FFDC
....................    macro_cmd = read_ext_eeprom(addr); 
13B04:  MOVFF  89A,8A9
13B08:  MOVFF  899,8A8
13B0C:  CALL   102F0
13B10:  MOVFF  01,89B
....................    ++addr; 
13B14:  MOVLB  8
13B16:  INCF   x99,F
13B18:  BTFSC  FD8.2
13B1A:  INCF   x9A,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13B1C:  MOVFF  89A,8A0
13B20:  MOVFF  899,89F
13B24:  MOVLB  0
13B26:  CALL   10404
13B2A:  MOVFF  02,89D
13B2E:  MOVFF  01,89C
....................    //} 
....................    heartbeat(TRUE); 
13B32:  MOVLW  01
13B34:  MOVLB  8
13B36:  MOVWF  xCA
13B38:  MOVLB  0
13B3A:  CALL   54FA
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13B3E:  MOVF   2F,F
13B40:  BTFSS  FD8.2
13B42:  BRA    13DEE
13B44:  MOVF   30,F
13B46:  BTFSS  FD8.2
13B48:  BRA    13DEE
....................       switch(macro_cmd) 
13B4A:  MOVLW  2B
13B4C:  MOVLB  8
13B4E:  SUBWF  x9B,W
13B50:  ADDLW  BA
13B52:  BTFSC  FD8.0
13B54:  BRA    13DF0
13B56:  ADDLW  46
13B58:  MOVLB  0
13B5A:  GOTO   13DFA
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
13B5E:  CALL   1227A
....................             store_rel_data(); 
13B62:  CALL   122DE
....................             macro_status = 'a'; 
13B66:  MOVLW  61
13B68:  MOVLB  8
13B6A:  MOVWF  x9E
....................             break; 
13B6C:  BRA    13DF0
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
13B6E:  MOVLW  08
13B70:  MOVWF  FEA
13B72:  MOVLW  21
13B74:  MOVWF  FE9
13B76:  CALL   78D2
13B7A:  MOVLW  0D
13B7C:  BTFSS  F9E.4
13B7E:  BRA    13B7C
13B80:  MOVWF  FAD
13B82:  MOVLW  0A
13B84:  BTFSS  F9E.4
13B86:  BRA    13B84
13B88:  MOVWF  FAD
....................             macro_status = 'a'; 
13B8A:  MOVLW  61
13B8C:  MOVLB  8
13B8E:  MOVWF  x9E
....................             break; 
13B90:  BRA    13DF0
....................          case 'C' : 
....................             calc_abs_data(); 
13B92:  CALL   1227A
....................             break; 
13B96:  MOVLB  8
13B98:  BRA    13DF0
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
13B9A:  MOVFF  89D,8A0
13B9E:  MOVFF  89C,89F
13BA2:  CALL   D036
....................             macro_status = 'a'; 
13BA6:  MOVLW  61
13BA8:  MOVLB  8
13BAA:  MOVWF  x9E
....................             break; 
13BAC:  BRA    13DF0
....................          case 'F' : macro_flag = macro_arg; 
13BAE:  MOVFF  89D,320
13BB2:  MOVFF  89C,31F
....................                     macro_status = 'a'; 
13BB6:  MOVLW  61
13BB8:  MOVLB  8
13BBA:  MOVWF  x9E
....................             break ; 
13BBC:  BRA    13DF0
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
13BBE:  MOVFF  89C,2D1
....................                     macro_status = 'a'; 
13BC2:  MOVLW  61
13BC4:  MOVLB  8
13BC6:  MOVWF  x9E
....................             break ; 
13BC8:  BRA    13DF0
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
13BCA:  MOVFF  89B,89F
13BCE:  MOVFF  89D,8A1
13BD2:  MOVFF  89C,8A0
13BD6:  CALL   12460
....................                     macro_status = 'a'; 
13BDA:  MOVLW  61
13BDC:  MOVLB  8
13BDE:  MOVWF  x9E
....................             break; 
13BE0:  BRA    13DF0
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
13BE2:  MOVFF  89B,89F
13BE6:  MOVFF  89D,8A1
13BEA:  MOVFF  89C,8A0
13BEE:  CALL   12460
....................                     macro_status = 'a'; 
13BF2:  MOVLW  61
13BF4:  MOVLB  8
13BF6:  MOVWF  x9E
....................             break; 
13BF8:  BRA    13DF0
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
13BFA:  MOVFF  89D,8B9
13BFE:  MOVFF  89C,8B8
13C02:  MOVLB  8
13C04:  CLRF   xBB
13C06:  MOVLW  64
13C08:  MOVWF  xBA
13C0A:  MOVLB  0
13C0C:  CALL   2C52
13C10:  MOVFF  02,749
13C14:  MOVFF  01,748
....................                     macro_status = 'a'; 
13C18:  MOVLW  61
13C1A:  MOVLB  8
13C1C:  MOVWF  x9E
....................             break;    
13C1E:  BRA    13DF0
....................          case 'l' : LightTargetFlag = 1; 
13C20:  MOVLW  01
13C22:  MOVLB  2
13C24:  MOVWF  xD5
....................                     set_light(macro_cmd,macro_arg); 
13C26:  MOVFF  89B,89F
13C2A:  MOVFF  89D,8A1
13C2E:  MOVFF  89C,8A0
13C32:  MOVLB  0
13C34:  CALL   1249A
....................                     delay_ms(10000); 
13C38:  MOVLW  28
13C3A:  MOVLB  8
13C3C:  MOVWF  x9F
13C3E:  MOVLW  FA
13C40:  MOVLB  9
13C42:  MOVWF  xC9
13C44:  MOVLB  0
13C46:  CALL   288E
13C4A:  MOVLB  8
13C4C:  DECFSZ x9F,F
13C4E:  BRA    13C3E
....................                     macro_status = 'a'; 
13C50:  MOVLW  61
13C52:  MOVWF  x9E
....................             break;        
13C54:  BRA    13DF0
....................          case 'L' : LightTargetFlag = 0; 
13C56:  MOVLB  2
13C58:  CLRF   xD5
....................                     set_light(macro_cmd,macro_arg); 
13C5A:  MOVFF  89B,89F
13C5E:  MOVFF  89D,8A1
13C62:  MOVFF  89C,8A0
13C66:  MOVLB  0
13C68:  CALL   1249A
....................                     macro_status = 'a'; 
13C6C:  MOVLW  61
13C6E:  MOVLB  8
13C70:  MOVWF  x9E
....................             break; 
13C72:  BRA    13DF0
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
13C74:  MOVFF  89B,43
....................                     arg = macro_arg; 
13C78:  CLRF   47
13C7A:  CLRF   46
13C7C:  MOVFF  89D,45
13C80:  MOVFF  89C,44
....................                     det_cmd(); 
13C84:  CALL   F0FA
....................                     macro_status = 'a'; 
13C88:  MOVLW  61
13C8A:  MOVLB  8
13C8C:  MOVWF  x9E
....................             break ; 
13C8E:  BRA    13DF0
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
13C90:  MOVLB  8
13C92:  DECFSZ x9C,W
13C94:  BRA    13CA0
13C96:  MOVF   x9D,F
13C98:  BNZ   13CA0
13C9A:  MOVLB  0
13C9C:  RCALL  13542
13C9E:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
13CA0:  MOVF   x9C,W
13CA2:  SUBLW  02
13CA4:  BNZ   13CB6
13CA6:  MOVF   x9D,F
13CA8:  BNZ   13CB6
13CAA:  MOVLW  01
13CAC:  MOVWF  x9F
13CAE:  MOVWF  xA0
13CB0:  MOVLB  0
13CB2:  RCALL  1370E
13CB4:  MOVLB  8
....................                     macro_status = 'a'; 
13CB6:  MOVLW  61
13CB8:  MOVWF  x9E
....................             break ;  
13CBA:  BRA    13DF0
....................          case 'T' : det_temp(); 
13CBC:  RCALL  138CE
....................                     macro_status = 'a'; 
13CBE:  MOVLW  61
13CC0:  MOVLB  8
13CC2:  MOVWF  x9E
....................             break; 
13CC4:  BRA    13DF0
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
13CC6:  MOVLW  01
13CC8:  MOVLB  7
13CCA:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
13CCC:  MOVLB  8
13CCE:  CLRF   xA4
13CD0:  CLRF   xA5
13CD2:  CLRF   xA9
13CD4:  CLRF   xA8
13CD6:  MOVFF  89D,8A7
13CDA:  MOVFF  89C,8A6
13CDE:  MOVWF  xAA
13CE0:  MOVLB  0
13CE2:  CALL   9CAE
....................                     macro_status=step_err_status(); 
13CE6:  CALL   CFFE
13CEA:  MOVFF  01,89E
....................             break; 
13CEE:  MOVLB  8
13CF0:  BRA    13DF0
....................          case '-' : motor=1; 
13CF2:  MOVLW  01
13CF4:  MOVLB  7
13CF6:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
13CF8:  MOVLB  8
13CFA:  CLRF   xA4
13CFC:  MOVWF  xA5
13CFE:  CLRF   xA9
13D00:  CLRF   xA8
13D02:  MOVFF  89D,8A7
13D06:  MOVFF  89C,8A6
13D0A:  MOVWF  xAA
13D0C:  MOVLB  0
13D0E:  CALL   9CAE
....................                     macro_status=step_err_status(); 
13D12:  CALL   CFFE
13D16:  MOVFF  01,89E
....................             break; 
13D1A:  MOVLB  8
13D1C:  BRA    13DF0
....................          case 'G' : motor=0; 
13D1E:  MOVLB  7
13D20:  CLRF   x3C
....................                     align(0); 
13D22:  MOVLB  8
13D24:  CLRF   x9F
13D26:  MOVLB  0
13D28:  CALL   A7EA
....................                     macro_status=step_err_status(); 
13D2C:  CALL   CFFE
13D30:  MOVFF  01,89E
....................             break ;           
13D34:  MOVLB  8
13D36:  BRA    13DF0
....................          case 'P' : motor=0; 
13D38:  MOVLB  7
13D3A:  CLRF   x3C
....................                     move_motor(1,0,macro_arg,1);   
13D3C:  MOVLW  01
13D3E:  MOVLB  8
13D40:  MOVWF  xA4
13D42:  CLRF   xA5
13D44:  CLRF   xA9
13D46:  CLRF   xA8
13D48:  MOVFF  89D,8A7
13D4C:  MOVFF  89C,8A6
13D50:  MOVWF  xAA
13D52:  MOVLB  0
13D54:  CALL   9CAE
....................                     macro_status=step_err_status(); 
13D58:  CALL   CFFE
13D5C:  MOVFF  01,89E
....................             break; 
13D60:  MOVLB  8
13D62:  BRA    13DF0
....................          case 'Q' : motor=0; 
13D64:  MOVLB  7
13D66:  CLRF   x3C
....................                     move_motor(0,0,macro_arg,1); 
13D68:  MOVLB  8
13D6A:  CLRF   xA4
13D6C:  CLRF   xA5
13D6E:  CLRF   xA9
13D70:  CLRF   xA8
13D72:  MOVFF  89D,8A7
13D76:  MOVFF  89C,8A6
13D7A:  MOVLW  01
13D7C:  MOVWF  xAA
13D7E:  MOVLB  0
13D80:  CALL   9CAE
....................                     macro_status=step_err_status(); 
13D84:  CALL   CFFE
13D88:  MOVFF  01,89E
....................             break; 
13D8C:  MOVLB  8
13D8E:  BRA    13DF0
....................          case 'R' : motor=0; 
13D90:  MOVLB  7
13D92:  CLRF   x3C
....................                     move_motor(0,1,macro_arg,1); 
13D94:  MOVLB  8
13D96:  CLRF   xA4
13D98:  MOVLW  01
13D9A:  MOVWF  xA5
13D9C:  CLRF   xA9
13D9E:  CLRF   xA8
13DA0:  MOVFF  89D,8A7
13DA4:  MOVFF  89C,8A6
13DA8:  MOVWF  xAA
13DAA:  MOVLB  0
13DAC:  CALL   9CAE
....................                     macro_status=step_err_status(); 
13DB0:  CALL   CFFE
13DB4:  MOVFF  01,89E
....................             break; 
13DB8:  MOVLB  8
13DBA:  BRA    13DF0
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
13DBC:  MOVLB  8
13DBE:  DECFSZ x9C,W
13DC0:  BRA    13DD0
13DC2:  MOVF   x9D,F
13DC4:  BNZ   13DD0
13DC6:  MOVLB  0
13DC8:  CALL   D06C
13DCC:  BRA    13DDE
13DCE:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
13DD0:  MOVF   x9C,F
13DD2:  BNZ   13DE0
13DD4:  MOVF   x9D,F
13DD6:  BNZ   13DE0
13DD8:  MOVLB  0
13DDA:  CALL   D090
13DDE:  MOVLB  8
....................                     macro_status = 'a'; 
13DE0:  MOVLW  61
13DE2:  MOVWF  x9E
....................             break; 
13DE4:  BRA    13DF0
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
13DE6:  MOVLW  66
13DE8:  MOVLB  8
13DEA:  MOVWF  x9E
....................             break ; 
13DEC:  BRA    13DF0
13DEE:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
13DF0:  MOVFF  89E,01
13DF4:  MOVLB  0
13DF6:  GOTO   146F6 (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
14552:  MOVLW  65
14554:  MOVLB  8
14556:  MOVWF  x84
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
14558:  BCF    FD8.0
1455A:  RLCF   x7A,W
1455C:  CLRF   03
1455E:  ADDLW  CD
14560:  MOVWF  FE9
14562:  MOVLW  07
14564:  ADDWFC 03,W
14566:  MOVWF  FEA
14568:  MOVFF  FEC,893
1456C:  MOVF   FED,F
1456E:  MOVFF  FEF,892
14572:  MOVFF  87C,03
14576:  MOVFF  87B,FE9
1457A:  MOVFF  87C,FEA
1457E:  MOVFF  FEC,9EA
14582:  MOVF   FED,F
14584:  MOVFF  FEF,9E9
14588:  MOVLB  9
1458A:  CLRF   xEC
1458C:  MOVLW  03
1458E:  MOVWF  xEB
14590:  MOVLB  0
14592:  CALL   5C0E
14596:  MOVF   01,W
14598:  MOVLB  8
1459A:  ADDWF  x92,W
1459C:  MOVWF  x7F
1459E:  MOVF   02,W
145A0:  ADDWFC x93,W
145A2:  MOVWF  x80
....................  
....................    init_ext_eeprom(); 
145A4:  MOVLB  0
145A6:  CALL   FFDC
....................    macro_cmd = read_ext_eeprom(addr); 
145AA:  MOVFF  880,8A9
145AE:  MOVFF  87F,8A8
145B2:  CALL   102F0
145B6:  MOVFF  01,881
....................    ++addr; 
145BA:  MOVLB  8
145BC:  INCF   x7F,F
145BE:  BTFSC  FD8.2
145C0:  INCF   x80,F
....................    if(macro_cmd == 'p'){ 
145C2:  MOVF   x81,W
145C4:  SUBLW  70
145C6:  BNZ   145EC
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
145C8:  MOVFF  87A,892
145CC:  MOVFF  87C,894
145D0:  MOVFF  87B,893
145D4:  MOVFF  854,896
145D8:  MOVFF  853,895
145DC:  MOVLB  0
145DE:  CALL   1034A
....................       count1++; 
145E2:  MOVLB  8
145E4:  INCF   x53,F
145E6:  BTFSC  FD8.2
145E8:  INCF   x54,F
....................    }else{ 
145EA:  BRA    14604
....................    macro_arg = read16_ext_eeprom(addr); 
145EC:  MOVFF  880,8A0
145F0:  MOVFF  87F,89F
145F4:  MOVLB  0
145F6:  CALL   10404
145FA:  MOVFF  02,883
145FE:  MOVFF  01,882
14602:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
14604:  MOVLW  01
14606:  MOVWF  xCA
14608:  MOVLB  0
1460A:  CALL   54FA
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
1460E:  MOVF   2F,F
14610:  BTFSS  FD8.2
14612:  BRA    14A60
14614:  MOVF   30,F
14616:  BTFSS  FD8.2
14618:  BRA    14A60
....................       switch(macro_cmd){ 
1461A:  MOVLW  2B
1461C:  MOVLB  8
1461E:  SUBWF  x81,W
14620:  ADDLW  B8
14622:  BTFSC  FD8.0
14624:  BRA    14A5C
14626:  ADDLW  48
14628:  MOVLB  0
1462A:  GOTO   14D26
....................          case 'A' : 
....................             calc_abs_data(); 
1462E:  CALL   1227A
....................             store_rel_data(); 
14632:  CALL   122DE
....................             macro_status = 'a'; 
14636:  MOVLW  61
14638:  MOVLB  8
1463A:  MOVWF  x84
....................             break; 
1463C:  BRA    14A5C
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
1463E:  MOVLW  08
14640:  MOVWF  FEA
14642:  MOVLW  21
14644:  MOVWF  FE9
14646:  CALL   78D2
1464A:  MOVLW  0D
1464C:  BTFSS  F9E.4
1464E:  BRA    1464C
14650:  MOVWF  FAD
14652:  MOVLW  0A
14654:  BTFSS  F9E.4
14656:  BRA    14654
14658:  MOVWF  FAD
....................             macro_status = 'a'; 
1465A:  MOVLW  61
1465C:  MOVLB  8
1465E:  MOVWF  x84
....................             break; 
14660:  BRA    14A5C
....................          case 'C' : 
....................             calc_abs_data(); 
14662:  CALL   1227A
....................             break; 
14666:  MOVLB  8
14668:  BRA    14A5C
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
1466A:  MOVLB  8
1466C:  CLRF   x88
1466E:  CLRF   x87
14670:  CLRF   x86
14672:  CLRF   x85
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
14674:  MOVFF  87C,03
14678:  MOVFF  87B,FE9
1467C:  MOVFF  87C,FEA
14680:  MOVLW  01
14682:  ADDWF  FEE,F
14684:  BNC   14688
14686:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
14688:  MOVFF  87B,FE9
1468C:  MOVFF  87C,FEA
14690:  CLRF   x8C
14692:  CLRF   x8B
14694:  MOVFF  FEC,88A
14698:  MOVF   FED,F
1469A:  MOVFF  FEF,889
1469E:  CLRF   x90
146A0:  CLRF   x8F
146A2:  CLRF   x8E
146A4:  CLRF   x8D
....................                    
....................                   while(count < macro_arg){ 
146A6:  MOVF   x88,F
146A8:  BTFSS  FD8.2
146AA:  BRA    147E6
146AC:  MOVF   x87,F
146AE:  BTFSS  FD8.2
146B0:  BRA    147E6
146B2:  MOVF   x86,W
146B4:  SUBWF  x83,W
146B6:  BTFSS  FD8.0
146B8:  BRA    147E6
146BA:  BNZ   146C4
146BC:  MOVF   x82,W
146BE:  SUBWF  x85,W
146C0:  BTFSC  FD8.0
146C2:  BRA    147E6
....................                      char curr = 'A'; 
146C4:  MOVLW  41
146C6:  MOVWF  x91
....................                      while(curr != '%'){ 
146C8:  MOVF   x91,W
146CA:  SUBLW  25
146CC:  BZ    14738
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
146CE:  MOVFF  87C,03
146D2:  MOVFF  87B,FE9
146D6:  MOVFF  87C,FEA
146DA:  MOVFF  FEC,896
146DE:  MOVF   FED,F
146E0:  MOVFF  FEF,895
146E4:  MOVFF  87A,894
146E8:  MOVFF  87E,898
146EC:  MOVFF  87D,897
146F0:  MOVLB  0
146F2:  GOTO   13ABA
....................                         (*line)++; 
146F6:  MOVFF  87C,03
146FA:  MOVLB  8
146FC:  MOVF   x7B,W
146FE:  MOVWF  FE9
14700:  MOVFF  03,FEA
14704:  MOVLW  01
14706:  ADDWF  FEE,F
14708:  BNC   1470C
1470A:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
1470C:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
1470E:  MOVFF  87C,03
14712:  MOVFF  87B,FE9
14716:  MOVFF  87C,FEA
1471A:  MOVFF  FEC,896
1471E:  MOVF   FED,F
14720:  MOVFF  FEF,895
14724:  MOVFF  87A,894
14728:  MOVLB  0
1472A:  GOTO   13EA6
1472E:  MOVFF  01,891
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
14732:  BSF    F91.5
14734:  MOVLB  8
14736:  BRA    146C8
....................                      } 
....................                      end_line = (*line); 
14738:  MOVFF  87B,FE9
1473C:  MOVFF  87C,FEA
14740:  CLRF   x90
14742:  CLRF   x8F
14744:  MOVFF  FEC,88E
14748:  MOVF   FED,F
1474A:  MOVFF  FEF,88D
....................                      count++; 
1474E:  MOVLW  01
14750:  ADDWF  x85,F
14752:  BTFSC  FD8.0
14754:  INCF   x86,F
14756:  BTFSC  FD8.2
14758:  INCF   x87,F
1475A:  BTFSC  FD8.2
1475C:  INCF   x88,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
1475E:  MOVF   x85,W
14760:  SUBWF  x82,W
14762:  MOVWF  x92
14764:  MOVF   x86,W
14766:  SUBWFB x83,W
14768:  MOVWF  x93
1476A:  MOVLW  00
1476C:  SUBFWB x87,W
1476E:  MOVWF  x94
14770:  MOVLW  00
14772:  SUBFWB x88,W
14774:  MOVWF  x95
14776:  MOVLW  38
14778:  MOVWF  FF6
1477A:  MOVLW  21
1477C:  MOVWF  FF7
1477E:  MOVLW  00
14780:  MOVWF  FF8
14782:  CLRF   1B
14784:  BTFSC  FF2.7
14786:  BSF    1B.7
14788:  BCF    FF2.7
1478A:  MOVLW  11
1478C:  MOVLB  A
1478E:  MOVWF  x18
14790:  MOVLB  0
14792:  CALL   1006
14796:  BTFSC  1B.7
14798:  BSF    FF2.7
1479A:  MOVLW  41
1479C:  MOVWF  FE9
1479E:  CLRF   1B
147A0:  BTFSC  FF2.7
147A2:  BSF    1B.7
147A4:  BCF    FF2.7
147A6:  MOVFF  895,A1B
147AA:  MOVFF  894,A1A
147AE:  MOVFF  893,A19
147B2:  MOVFF  892,A18
147B6:  CALL   10CC
147BA:  BTFSC  1B.7
147BC:  BSF    FF2.7
147BE:  MOVLW  0D
147C0:  BTFSS  F9E.4
147C2:  BRA    147C0
147C4:  MOVWF  FAD
147C6:  MOVLW  0A
147C8:  BTFSS  F9E.4
147CA:  BRA    147C8
147CC:  MOVWF  FAD
....................                      (*line) = start_line; 
147CE:  MOVFF  87C,03
147D2:  MOVLB  8
147D4:  MOVFF  87B,FE9
147D8:  MOVFF  87C,FEA
147DC:  MOVFF  889,FEF
147E0:  MOVFF  88A,FEC
147E4:  BRA    146A6
....................                   } 
....................                   (*line) = end_line + 1; 
147E6:  MOVFF  87B,FE9
147EA:  MOVFF  87C,FEA
147EE:  MOVLW  01
147F0:  ADDWF  x8D,W
147F2:  MOVWF  FEF
147F4:  MOVLW  00
147F6:  ADDWFC x8E,W
147F8:  MOVWF  FEC
....................                   macro_status = 'a'; 
147FA:  MOVLW  61
147FC:  MOVWF  x84
....................             break; 
147FE:  BRA    14A5C
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
14800:  MOVFF  883,8A0
14804:  MOVFF  882,89F
14808:  CALL   D036
....................                     macro_status = 'a'; 
1480C:  MOVLW  61
1480E:  MOVLB  8
14810:  MOVWF  x84
....................             break; 
14812:  BRA    14A5C
....................          case 'F' : macro_flag = macro_arg; 
14814:  MOVFF  883,320
14818:  MOVFF  882,31F
....................                     macro_status = 'a'; 
1481C:  MOVLW  61
1481E:  MOVLB  8
14820:  MOVWF  x84
....................             break ; 
14822:  BRA    14A5C
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14824:  MOVFF  882,2D1
....................                     macro_status = 'a'; 
14828:  MOVLW  61
1482A:  MOVLB  8
1482C:  MOVWF  x84
....................             break ; 
1482E:  BRA    14A5C
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14830:  MOVFF  881,89F
14834:  MOVFF  883,8A1
14838:  MOVFF  882,8A0
1483C:  CALL   12460
....................                     macro_status = 'a'; 
14840:  MOVLW  61
14842:  MOVLB  8
14844:  MOVWF  x84
....................             break; 
14846:  BRA    14A5C
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14848:  MOVFF  881,89F
1484C:  MOVFF  883,8A1
14850:  MOVFF  882,8A0
14854:  CALL   12460
....................                     macro_status = 'a'; 
14858:  MOVLW  61
1485A:  MOVLB  8
1485C:  MOVWF  x84
....................             break; 
1485E:  BRA    14A5C
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14860:  MOVFF  883,8B9
14864:  MOVFF  882,8B8
14868:  MOVLB  8
1486A:  CLRF   xBB
1486C:  MOVLW  64
1486E:  MOVWF  xBA
14870:  MOVLB  0
14872:  CALL   2C52
14876:  MOVFF  02,749
1487A:  MOVFF  01,748
....................                     macro_status = 'a'; 
1487E:  MOVLW  61
14880:  MOVLB  8
14882:  MOVWF  x84
....................             break;    
14884:  BRA    14A5C
....................          case 'l' : LightTargetFlag = 1; 
14886:  MOVLW  01
14888:  MOVLB  2
1488A:  MOVWF  xD5
....................                     set_light(macro_cmd,macro_arg); 
1488C:  MOVFF  881,89F
14890:  MOVFF  883,8A1
14894:  MOVFF  882,8A0
14898:  MOVLB  0
1489A:  CALL   1249A
....................                     delay_ms(10000); 
1489E:  MOVLW  28
148A0:  MOVLB  8
148A2:  MOVWF  x92
148A4:  MOVLW  FA
148A6:  MOVLB  9
148A8:  MOVWF  xC9
148AA:  MOVLB  0
148AC:  CALL   288E
148B0:  MOVLB  8
148B2:  DECFSZ x92,F
148B4:  BRA    148A4
....................                     macro_status = 'a'; 
148B6:  MOVLW  61
148B8:  MOVWF  x84
....................             break;        
148BA:  BRA    14A5C
....................          case 'L' : LightTargetFlag = 0; 
148BC:  MOVLB  2
148BE:  CLRF   xD5
....................                     set_light(macro_cmd,macro_arg); 
148C0:  MOVFF  881,89F
148C4:  MOVFF  883,8A1
148C8:  MOVFF  882,8A0
148CC:  MOVLB  0
148CE:  CALL   1249A
....................                     macro_status = 'a'; 
148D2:  MOVLW  61
148D4:  MOVLB  8
148D6:  MOVWF  x84
....................             break; 
148D8:  BRA    14A5C
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
148DA:  MOVFF  881,43
....................                     arg = macro_arg; 
148DE:  CLRF   47
148E0:  CLRF   46
148E2:  MOVFF  883,45
148E6:  MOVFF  882,44
....................                     det_cmd(); 
148EA:  CALL   F0FA
....................                     macro_status = 'a'; 
148EE:  MOVLW  61
148F0:  MOVLB  8
148F2:  MOVWF  x84
....................             break ; 
148F4:  BRA    14A5C
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
148F6:  MOVLB  8
148F8:  DECFSZ x82,W
148FA:  BRA    14908
148FC:  MOVF   x83,F
148FE:  BNZ   14908
14900:  MOVLB  0
14902:  CALL   13542
14906:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14908:  MOVF   x82,W
1490A:  SUBLW  02
1490C:  BNZ   14920
1490E:  MOVF   x83,F
14910:  BNZ   14920
14912:  MOVLW  01
14914:  MOVWF  x9F
14916:  MOVWF  xA0
14918:  MOVLB  0
1491A:  CALL   1370E
1491E:  MOVLB  8
....................                     macro_status = 'a'; 
14920:  MOVLW  61
14922:  MOVWF  x84
....................             break ;  
14924:  BRA    14A5C
....................          case 'T' : det_temp(); 
14926:  CALL   138CE
....................                     macro_status = 'a'; 
1492A:  MOVLW  61
1492C:  MOVLB  8
1492E:  MOVWF  x84
....................             break; 
14930:  BRA    14A5C
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14932:  MOVLW  01
14934:  MOVLB  7
14936:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14938:  MOVLB  8
1493A:  CLRF   xA4
1493C:  CLRF   xA5
1493E:  CLRF   xA9
14940:  CLRF   xA8
14942:  MOVFF  883,8A7
14946:  MOVFF  882,8A6
1494A:  MOVWF  xAA
1494C:  MOVLB  0
1494E:  CALL   9CAE
....................                     macro_status=step_err_status(); 
14952:  CALL   CFFE
14956:  MOVFF  01,884
....................             break; 
1495A:  MOVLB  8
1495C:  BRA    14A5C
....................          case '-' : motor=1; 
1495E:  MOVLW  01
14960:  MOVLB  7
14962:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14964:  MOVLB  8
14966:  CLRF   xA4
14968:  MOVWF  xA5
1496A:  CLRF   xA9
1496C:  CLRF   xA8
1496E:  MOVFF  883,8A7
14972:  MOVFF  882,8A6
14976:  MOVWF  xAA
14978:  MOVLB  0
1497A:  CALL   9CAE
....................                     macro_status=step_err_status(); 
1497E:  CALL   CFFE
14982:  MOVFF  01,884
....................             break; 
14986:  MOVLB  8
14988:  BRA    14A5C
....................          case 'G' : motor=0; 
1498A:  MOVLB  7
1498C:  CLRF   x3C
....................                     align(0); 
1498E:  MOVLB  8
14990:  CLRF   x9F
14992:  MOVLB  0
14994:  CALL   A7EA
....................                     macro_status=step_err_status(); 
14998:  CALL   CFFE
1499C:  MOVFF  01,884
....................             break ;           
149A0:  MOVLB  8
149A2:  BRA    14A5C
....................          case 'P' : motor=0; 
149A4:  MOVLB  7
149A6:  CLRF   x3C
....................                     move_motor(1,0,macro_arg,1);   
149A8:  MOVLW  01
149AA:  MOVLB  8
149AC:  MOVWF  xA4
149AE:  CLRF   xA5
149B0:  CLRF   xA9
149B2:  CLRF   xA8
149B4:  MOVFF  883,8A7
149B8:  MOVFF  882,8A6
149BC:  MOVWF  xAA
149BE:  MOVLB  0
149C0:  CALL   9CAE
....................                     macro_status=step_err_status(); 
149C4:  CALL   CFFE
149C8:  MOVFF  01,884
....................             break; 
149CC:  MOVLB  8
149CE:  BRA    14A5C
....................          case 'Q' : motor=0; 
149D0:  MOVLB  7
149D2:  CLRF   x3C
....................                     move_motor(0,0,macro_arg,1); 
149D4:  MOVLB  8
149D6:  CLRF   xA4
149D8:  CLRF   xA5
149DA:  CLRF   xA9
149DC:  CLRF   xA8
149DE:  MOVFF  883,8A7
149E2:  MOVFF  882,8A6
149E6:  MOVLW  01
149E8:  MOVWF  xAA
149EA:  MOVLB  0
149EC:  CALL   9CAE
....................                     macro_status=step_err_status(); 
149F0:  CALL   CFFE
149F4:  MOVFF  01,884
....................             break; 
149F8:  MOVLB  8
149FA:  BRA    14A5C
....................          case 'R' : motor=0; 
149FC:  MOVLB  7
149FE:  CLRF   x3C
....................                     move_motor(0,1,macro_arg,1); 
14A00:  MOVLB  8
14A02:  CLRF   xA4
14A04:  MOVLW  01
14A06:  MOVWF  xA5
14A08:  CLRF   xA9
14A0A:  CLRF   xA8
14A0C:  MOVFF  883,8A7
14A10:  MOVFF  882,8A6
14A14:  MOVWF  xAA
14A16:  MOVLB  0
14A18:  CALL   9CAE
....................                     macro_status=step_err_status(); 
14A1C:  CALL   CFFE
14A20:  MOVFF  01,884
....................             break; 
14A24:  MOVLB  8
14A26:  BRA    14A5C
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14A28:  MOVLB  8
14A2A:  DECFSZ x82,W
14A2C:  BRA    14A3C
14A2E:  MOVF   x83,F
14A30:  BNZ   14A3C
14A32:  MOVLB  0
14A34:  CALL   D06C
14A38:  BRA    14A4A
14A3A:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14A3C:  MOVF   x82,F
14A3E:  BNZ   14A4C
14A40:  MOVF   x83,F
14A42:  BNZ   14A4C
14A44:  MOVLB  0
14A46:  CALL   D090
14A4A:  MOVLB  8
....................                     macro_status = 'a'; 
14A4C:  MOVLW  61
14A4E:  MOVWF  x84
....................             break; 
14A50:  BRA    14A5C
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14A52:  MOVLW  66
14A54:  MOVLB  8
14A56:  MOVWF  x84
....................             break ; 
14A58:  BRA    14A5C
14A5A:  MOVLB  8
....................       } 
....................    } 
14A5C:  BRA    14D1C
14A5E:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14A60:  DECFSZ 2F,W
14A62:  BRA    14A68
14A64:  MOVF   30,F
14A66:  BZ    14A76
14A68:  MOVF   2F,W
14A6A:  SUBLW  03
14A6C:  BTFSS  FD8.2
14A6E:  BRA    14BF4
14A70:  MOVF   30,F
14A72:  BTFSS  FD8.2
14A74:  BRA    14BF4
....................       switch(macro_cmd){ 
14A76:  MOVLB  8
14A78:  MOVF   x81,W
14A7A:  XORLW  2B
14A7C:  MOVLB  0
14A7E:  BZ    14AAC
14A80:  XORLW  06
14A82:  BZ    14AD6
14A84:  XORLW  6F
14A86:  BZ    14B00
14A88:  XORLW  05
14A8A:  BZ    14B12
14A8C:  XORLW  17
14A8E:  BZ    14B2A
14A90:  XORLW  01
14A92:  BZ    14B54
14A94:  XORLW  03
14A96:  BZ    14B7E
14A98:  XORLW  06
14A9A:  BTFSC  FD8.2
14A9C:  BRA    14BA8
14A9E:  XORLW  0D
14AA0:  BTFSC  FD8.2
14AA2:  BRA    14BBE
14AA4:  XORLW  62
14AA6:  BTFSC  FD8.2
14AA8:  BRA    14BEA
14AAA:  BRA    14BF2
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14AAC:  MOVLW  01
14AAE:  MOVLB  7
14AB0:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14AB2:  MOVLB  8
14AB4:  CLRF   xA4
14AB6:  CLRF   xA5
14AB8:  CLRF   xA9
14ABA:  CLRF   xA8
14ABC:  MOVFF  883,8A7
14AC0:  MOVFF  882,8A6
14AC4:  MOVWF  xAA
14AC6:  MOVLB  0
14AC8:  CALL   9CAE
....................                     macro_status=step_err_status(); 
14ACC:  CALL   CFFE
14AD0:  MOVFF  01,884
....................             break; 
14AD4:  BRA    14BF2
....................          case '-' : motor=1; 
14AD6:  MOVLW  01
14AD8:  MOVLB  7
14ADA:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14ADC:  MOVLB  8
14ADE:  CLRF   xA4
14AE0:  MOVWF  xA5
14AE2:  CLRF   xA9
14AE4:  CLRF   xA8
14AE6:  MOVFF  883,8A7
14AEA:  MOVFF  882,8A6
14AEE:  MOVWF  xAA
14AF0:  MOVLB  0
14AF2:  CALL   9CAE
....................                     macro_status=step_err_status(); 
14AF6:  CALL   CFFE
14AFA:  MOVFF  01,884
....................             break; 
14AFE:  BRA    14BF2
....................          case 'B' : h_bridge(macro_arg); 
14B00:  MOVFF  882,892
14B04:  CALL   BEB8
....................                     macro_status = 'a'; 
14B08:  MOVLW  61
14B0A:  MOVLB  8
14B0C:  MOVWF  x84
....................             break;             
14B0E:  MOVLB  0
14B10:  BRA    14BF2
....................          case 'G' : motor=0; 
14B12:  MOVLB  7
14B14:  CLRF   x3C
....................                     align(0); 
14B16:  MOVLB  8
14B18:  CLRF   x9F
14B1A:  MOVLB  0
14B1C:  CALL   A7EA
....................                     macro_status=step_err_status(); 
14B20:  CALL   CFFE
14B24:  MOVFF  01,884
....................             break ;           
14B28:  BRA    14BF2
....................          case 'P' : motor=0; 
14B2A:  MOVLB  7
14B2C:  CLRF   x3C
....................                     move_motor(0,0,mmacro_var,1);   
14B2E:  MOVLB  8
14B30:  CLRF   xA4
14B32:  CLRF   xA5
14B34:  CLRF   xA9
14B36:  CLRF   xA8
14B38:  MOVFF  87E,8A7
14B3C:  MOVFF  87D,8A6
14B40:  MOVLW  01
14B42:  MOVWF  xAA
14B44:  MOVLB  0
14B46:  CALL   9CAE
....................                     macro_status=step_err_status(); 
14B4A:  CALL   CFFE
14B4E:  MOVFF  01,884
....................             break; 
14B52:  BRA    14BF2
....................          case 'Q' : motor=0; 
14B54:  MOVLB  7
14B56:  CLRF   x3C
....................                     move_motor(0,0,mmacro_var,1); 
14B58:  MOVLB  8
14B5A:  CLRF   xA4
14B5C:  CLRF   xA5
14B5E:  CLRF   xA9
14B60:  CLRF   xA8
14B62:  MOVFF  87E,8A7
14B66:  MOVFF  87D,8A6
14B6A:  MOVLW  01
14B6C:  MOVWF  xAA
14B6E:  MOVLB  0
14B70:  CALL   9CAE
....................                     macro_status=step_err_status(); 
14B74:  CALL   CFFE
14B78:  MOVFF  01,884
....................             break; 
14B7C:  BRA    14BF2
....................          case 'R' : motor=0; 
14B7E:  MOVLB  7
14B80:  CLRF   x3C
....................                     move_motor(0,1,mmacro_var,1); 
14B82:  MOVLB  8
14B84:  CLRF   xA4
14B86:  MOVLW  01
14B88:  MOVWF  xA5
14B8A:  CLRF   xA9
14B8C:  CLRF   xA8
14B8E:  MOVFF  87E,8A7
14B92:  MOVFF  87D,8A6
14B96:  MOVWF  xAA
14B98:  MOVLB  0
14B9A:  CALL   9CAE
....................                     macro_status=step_err_status(); 
14B9E:  CALL   CFFE
14BA2:  MOVFF  01,884
....................             break; 
14BA6:  BRA    14BF2
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
14BA8:  MOVFF  883,8A0
14BAC:  MOVFF  882,89F
14BB0:  CALL   D036
....................                     macro_status = 'a'; 
14BB4:  MOVLW  61
14BB6:  MOVLB  8
14BB8:  MOVWF  x84
....................             break; 
14BBA:  MOVLB  0
14BBC:  BRA    14BF2
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
14BBE:  MOVLB  8
14BC0:  DECFSZ x82,W
14BC2:  BRA    14BD2
14BC4:  MOVF   x83,F
14BC6:  BNZ   14BD2
14BC8:  MOVLB  0
14BCA:  CALL   D06C
14BCE:  BRA    14BE0
14BD0:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14BD2:  MOVF   x82,F
14BD4:  BNZ   14BE2
14BD6:  MOVF   x83,F
14BD8:  BNZ   14BE2
14BDA:  MOVLB  0
14BDC:  CALL   D090
14BE0:  MOVLB  8
....................                     macro_status = 'a'; 
14BE2:  MOVLW  61
14BE4:  MOVWF  x84
....................             break; 
14BE6:  MOVLB  0
14BE8:  BRA    14BF2
....................          case ';' : macro_status = 'f'; 
14BEA:  MOVLW  66
14BEC:  MOVLB  8
14BEE:  MOVWF  x84
....................             break;            
14BF0:  MOVLB  0
....................       } 
....................    } 
14BF2:  BRA    14D1A
....................    else if (nv_product==AWS){ 
14BF4:  MOVF   2F,W
14BF6:  SUBLW  02
14BF8:  BTFSS  FD8.2
14BFA:  BRA    14D1A
14BFC:  MOVF   30,F
14BFE:  BTFSS  FD8.2
14C00:  BRA    14D1A
....................       switch(macro_cmd){ 
14C02:  MOVLB  8
14C04:  MOVF   x81,W
14C06:  XORLW  2B
14C08:  MOVLB  0
14C0A:  BZ    14C30
14C0C:  XORLW  06
14C0E:  BZ    14C5A
14C10:  XORLW  6E
14C12:  BZ    14C84
14C14:  XORLW  07
14C16:  BZ    14C96
14C18:  XORLW  14
14C1A:  BZ    14CAC
14C1C:  XORLW  01
14C1E:  BZ    14CBE
14C20:  XORLW  02
14C22:  BZ    14CD0
14C24:  XORLW  0A
14C26:  BZ    14CE6
14C28:  XORLW  62
14C2A:  BTFSC  FD8.2
14C2C:  BRA    14D12
14C2E:  BRA    14D1A
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14C30:  MOVLW  01
14C32:  MOVLB  7
14C34:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14C36:  MOVLB  8
14C38:  CLRF   xA4
14C3A:  CLRF   xA5
14C3C:  CLRF   xA9
14C3E:  CLRF   xA8
14C40:  MOVFF  883,8A7
14C44:  MOVFF  882,8A6
14C48:  MOVWF  xAA
14C4A:  MOVLB  0
14C4C:  CALL   9CAE
....................                     macro_status=step_err_status(); 
14C50:  CALL   CFFE
14C54:  MOVFF  01,884
....................             break; 
14C58:  BRA    14D1A
....................          case '-' : motor=1; 
14C5A:  MOVLW  01
14C5C:  MOVLB  7
14C5E:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14C60:  MOVLB  8
14C62:  CLRF   xA4
14C64:  MOVWF  xA5
14C66:  CLRF   xA9
14C68:  CLRF   xA8
14C6A:  MOVFF  883,8A7
14C6E:  MOVFF  882,8A6
14C72:  MOVWF  xAA
14C74:  MOVLB  0
14C76:  CALL   9CAE
....................                     macro_status=step_err_status(); 
14C7A:  CALL   CFFE
14C7E:  MOVFF  01,884
....................             break; 
14C82:  BRA    14D1A
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
14C84:  MOVFF  882,893
14C88:  CALL   D8B2
....................                     macro_status = 'a';  
14C8C:  MOVLW  61
14C8E:  MOVLB  8
14C90:  MOVWF  x84
....................             break;          
14C92:  MOVLB  0
14C94:  BRA    14D1A
....................          case 'D' : delay_sec(macro_arg); 
14C96:  MOVFF  883,8A0
14C9A:  MOVFF  882,89F
14C9E:  CALL   D036
....................                     macro_status = 'a'; 
14CA2:  MOVLW  61
14CA4:  MOVLB  8
14CA6:  MOVWF  x84
....................             break; 
14CA8:  MOVLB  0
14CAA:  BRA    14D1A
....................          case 'P' : sol_switch(mmacro_var); 
14CAC:  MOVFF  87D,892
14CB0:  CALL   140CA
....................                     macro_status = 'a'; 
14CB4:  MOVLW  61
14CB6:  MOVLB  8
14CB8:  MOVWF  x84
....................             break;              
14CBA:  MOVLB  0
14CBC:  BRA    14D1A
....................          case 'Q' : sol_switch(macro_arg); 
14CBE:  MOVFF  882,892
14CC2:  CALL   140CA
....................                     macro_status = 'a'; 
14CC6:  MOVLW  61
14CC8:  MOVLB  8
14CCA:  MOVWF  x84
....................             break;             
14CCC:  MOVLB  0
14CCE:  BRA    14D1A
....................          case 'S' : sol_switch_cmd(macro_arg); 
14CD0:  MOVFF  883,894
14CD4:  MOVFF  882,893
14CD8:  CALL   14014
....................                     macro_status = 'a'; 
14CDC:  MOVLW  61
14CDE:  MOVLB  8
14CE0:  MOVWF  x84
....................             break; 
14CE2:  MOVLB  0
14CE4:  BRA    14D1A
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14CE6:  MOVLB  8
14CE8:  DECFSZ x82,W
14CEA:  BRA    14CFA
14CEC:  MOVF   x83,F
14CEE:  BNZ   14CFA
14CF0:  MOVLB  0
14CF2:  CALL   D06C
14CF6:  BRA    14D08
14CF8:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14CFA:  MOVF   x82,F
14CFC:  BNZ   14D0A
14CFE:  MOVF   x83,F
14D00:  BNZ   14D0A
14D02:  MOVLB  0
14D04:  CALL   D090
14D08:  MOVLB  8
....................                     macro_status = 'a'; 
14D0A:  MOVLW  61
14D0C:  MOVWF  x84
....................             break;               
14D0E:  MOVLB  0
14D10:  BRA    14D1A
....................          case ';' : macro_status = 'f'; 
14D12:  MOVLW  66
14D14:  MOVLB  8
14D16:  MOVWF  x84
....................             break;            
14D18:  MOVLB  0
14D1A:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
14D1C:  MOVFF  884,01
14D20:  MOVLB  0
14D22:  GOTO   15032 (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
14F00:  MOVLB  8
14F02:  CLRF   x54
14F04:  CLRF   x53
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
14F06:  MOVLB  0
14F08:  CALL   505E
....................    clear_data_arrays(); 
14F0C:  GOTO   10202
....................     
....................    line = 0;  
14F10:  MOVLB  8
14F12:  CLRF   x78
14F14:  CLRF   x77
....................    macro_status = 'a'; 
14F16:  MOVLW  61
14F18:  MOVWF  x79
....................    data_available = FALSE; 
14F1A:  MOVLB  3
14F1C:  CLRF   x37
....................    macro_flag = 900; 
14F1E:  MOVLW  03
14F20:  MOVWF  x20
14F22:  MOVLW  84
14F24:  MOVWF  x1F
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
14F26:  MOVLW  01
14F28:  MOVWF  1E
14F2A:  MOVLW  A3
14F2C:  MOVWF  1D
14F2E:  MOVLW  50
14F30:  MOVWF  FF6
14F32:  MOVLW  21
14F34:  MOVWF  FF7
14F36:  MOVLW  00
14F38:  MOVWF  FF8
14F3A:  MOVLW  07
14F3C:  MOVLB  8
14F3E:  MOVWF  xC8
14F40:  MOVLB  0
14F42:  CALL   A9FA
14F46:  MOVFF  874,8CA
14F4A:  MOVLW  1B
14F4C:  MOVLB  8
14F4E:  MOVWF  xCB
14F50:  MOVLB  0
14F52:  CALL   51F8
14F56:  MOVLW  59
14F58:  MOVWF  FF6
14F5A:  MOVLW  21
14F5C:  MOVWF  FF7
14F5E:  MOVLW  00
14F60:  MOVWF  FF8
14F62:  MOVLW  09
14F64:  MOVLB  8
14F66:  MOVWF  xC8
14F68:  MOVLB  0
14F6A:  CALL   A9FA
....................    record_event();    
14F6E:  CALL   8410
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
14F72:  MOVLB  8
14F74:  MOVF   x78,W
14F76:  SUBLW  03
14F78:  BNC   1504A
14F7A:  MOVF   x79,W
14F7C:  SUBLW  61
14F7E:  BNZ   1504A
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
14F80:  MOVF   1F,W
14F82:  SUBLW  04
14F84:  BNZ   15018
14F86:  MOVF   20,F
14F88:  BNZ   15018
....................                                                macro_status, (line + 1)); 
14F8A:  MOVLW  01
14F8C:  ADDWF  x77,W
14F8E:  MOVWF  x7A
14F90:  MOVLW  00
14F92:  ADDWFC x78,W
14F94:  MOVWF  x7B
14F96:  MOVLW  64
14F98:  MOVWF  FF6
14F9A:  MOVLW  21
14F9C:  MOVWF  FF7
14F9E:  MOVLW  00
14FA0:  MOVWF  FF8
14FA2:  CLRF   1B
14FA4:  BTFSC  FF2.7
14FA6:  BSF    1B.7
14FA8:  BCF    FF2.7
14FAA:  MOVLW  05
14FAC:  MOVLB  A
14FAE:  MOVWF  x18
14FB0:  MOVLB  0
14FB2:  CALL   1006
14FB6:  BTFSC  1B.7
14FB8:  BSF    FF2.7
14FBA:  MOVLB  8
14FBC:  MOVF   x79,W
14FBE:  BTFSS  F9E.4
14FC0:  BRA    14FBE
14FC2:  MOVWF  FAD
14FC4:  MOVLW  5D
14FC6:  BTFSS  F9E.4
14FC8:  BRA    14FC6
14FCA:  MOVWF  FAD
14FCC:  MOVLW  5B
14FCE:  BTFSS  F9E.4
14FD0:  BRA    14FCE
14FD2:  MOVWF  FAD
14FD4:  MOVLW  10
14FD6:  MOVWF  FE9
14FD8:  CLRF   1B
14FDA:  BTFSC  FF2.7
14FDC:  BSF    1B.7
14FDE:  BCF    FF2.7
14FE0:  MOVFF  87B,A19
14FE4:  MOVFF  87A,A18
14FE8:  MOVLB  0
14FEA:  CALL   1188
14FEE:  BTFSC  1B.7
14FF0:  BSF    FF2.7
14FF2:  MOVLW  70
14FF4:  MOVWF  FF6
14FF6:  MOVLW  21
14FF8:  MOVWF  FF7
14FFA:  MOVLW  00
14FFC:  MOVWF  FF8
14FFE:  CLRF   1B
15000:  BTFSC  FF2.7
15002:  BSF    1B.7
15004:  BCF    FF2.7
15006:  MOVLW  03
15008:  MOVLB  A
1500A:  MOVWF  x18
1500C:  MOVLB  0
1500E:  CALL   1006
15012:  BTFSC  1B.7
15014:  BSF    FF2.7
15016:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
15018:  MOVFF  874,87A
1501C:  MOVLW  08
1501E:  MOVWF  x7C
15020:  MOVLW  77
15022:  MOVWF  x7B
15024:  MOVFF  876,87E
15028:  MOVFF  875,87D
1502C:  MOVLB  0
1502E:  GOTO   14552
15032:  MOVFF  01,879
....................       ++line; 
15036:  MOVLB  8
15038:  INCF   x77,F
1503A:  BTFSC  FD8.2
1503C:  INCF   x78,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
1503E:  DECFSZ 4C,W
15040:  BRA    15048
....................          macro_status = 'g'; 
15042:  MOVLW  67
15044:  MOVWF  x79
....................          break;    
15046:  BRA    1504A
....................       } 
15048:  BRA    14F74
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
1504A:  MOVF   2F,W
1504C:  MOVWF  00
1504E:  MOVF   30,W
15050:  MOVWF  03
15052:  MOVF   03,W
15054:  BNZ   15060
15056:  MOVLW  01
15058:  SUBWF  00,W
1505A:  MOVLB  0
1505C:  BZ    1507E
1505E:  MOVLB  8
15060:  MOVF   03,W
15062:  BNZ   1506E
15064:  MOVLW  03
15066:  SUBWF  00,W
15068:  MOVLB  0
1506A:  BZ    1507E
1506C:  MOVLB  8
1506E:  MOVF   03,W
15070:  BNZ   1507C
15072:  MOVLW  02
15074:  SUBWF  00,W
15076:  MOVLB  0
15078:  BZ    1508A
1507A:  MOVLB  8
1507C:  BRA    1509A
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
1507E:  MOVFF  874,87A
15082:  CALL   D33A
....................          break; 
15086:  MOVLB  8
15088:  BRA    1509A
....................       case AWS : store_aws_data(macro,mmacro_var); 
1508A:  MOVFF  874,87A
1508E:  MOVFF  876,87C
15092:  MOVFF  875,87B
15096:  BRA    14DD6
....................          break; 
15098:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
1509A:  MOVLW  61
1509C:  SUBWF  x79,W
1509E:  ADDLW  F9
150A0:  BC    1518C
150A2:  ADDLW  07
150A4:  MOVLB  0
150A6:  GOTO   15238
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
150AA:  MOVLW  74
150AC:  MOVWF  FF6
150AE:  MOVLW  21
150B0:  MOVWF  FF7
150B2:  MOVLW  00
150B4:  MOVWF  FF8
150B6:  CLRF   1B
150B8:  BTFSC  FF2.7
150BA:  BSF    1B.7
150BC:  BCF    FF2.7
150BE:  CALL   0E30
150C2:  BTFSC  1B.7
150C4:  BSF    FF2.7
....................          break; 
150C6:  MOVLB  8
150C8:  BRA    1518C
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
150CA:  MOVLW  7C
150CC:  MOVWF  FF6
150CE:  MOVLW  21
150D0:  MOVWF  FF7
150D2:  MOVLW  00
150D4:  MOVWF  FF8
150D6:  CLRF   1B
150D8:  BTFSC  FF2.7
150DA:  BSF    1B.7
150DC:  BCF    FF2.7
150DE:  CALL   0E30
150E2:  BTFSC  1B.7
150E4:  BSF    FF2.7
....................          break; 
150E6:  MOVLB  8
150E8:  BRA    1518C
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
150EA:  MOVLW  84
150EC:  MOVWF  FF6
150EE:  MOVLW  21
150F0:  MOVWF  FF7
150F2:  MOVLW  00
150F4:  MOVWF  FF8
150F6:  CLRF   1B
150F8:  BTFSC  FF2.7
150FA:  BSF    1B.7
150FC:  BCF    FF2.7
150FE:  CALL   0E30
15102:  BTFSC  1B.7
15104:  BSF    FF2.7
....................          break; 
15106:  MOVLB  8
15108:  BRA    1518C
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
1510A:  MOVLW  8C
1510C:  MOVWF  FF6
1510E:  MOVLW  21
15110:  MOVWF  FF7
15112:  MOVLW  00
15114:  MOVWF  FF8
15116:  CLRF   1B
15118:  BTFSC  FF2.7
1511A:  BSF    1B.7
1511C:  BCF    FF2.7
1511E:  CALL   0E30
15122:  BTFSC  1B.7
15124:  BSF    FF2.7
....................          break; 
15126:  MOVLB  8
15128:  BRA    1518C
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
1512A:  MOVLW  94
1512C:  MOVWF  FF6
1512E:  MOVLW  21
15130:  MOVWF  FF7
15132:  MOVLW  00
15134:  MOVWF  FF8
15136:  CLRF   1B
15138:  BTFSC  FF2.7
1513A:  BSF    1B.7
1513C:  BCF    FF2.7
1513E:  CALL   0E30
15142:  BTFSC  1B.7
15144:  BSF    FF2.7
....................          break;    
15146:  MOVLB  8
15148:  BRA    1518C
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
1514A:  MOVLW  9C
1514C:  MOVWF  FF6
1514E:  MOVLW  21
15150:  MOVWF  FF7
15152:  MOVLW  00
15154:  MOVWF  FF8
15156:  CLRF   1B
15158:  BTFSC  FF2.7
1515A:  BSF    1B.7
1515C:  BCF    FF2.7
1515E:  CALL   0E30
15162:  BTFSC  1B.7
15164:  BSF    FF2.7
....................          break;    
15166:  MOVLB  8
15168:  BRA    1518C
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
1516A:  MOVLW  A4
1516C:  MOVWF  FF6
1516E:  MOVLW  21
15170:  MOVWF  FF7
15172:  MOVLW  00
15174:  MOVWF  FF8
15176:  CLRF   1B
15178:  BTFSC  FF2.7
1517A:  BSF    1B.7
1517C:  BCF    FF2.7
1517E:  CALL   0E30
15182:  BTFSC  1B.7
15184:  BSF    FF2.7
....................          break;           
15186:  MOVLB  8
15188:  BRA    1518C
1518A:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
1518C:  MOVLW  01
1518E:  MOVWF  1E
15190:  MOVLW  A3
15192:  MOVWF  1D
15194:  MOVLW  AC
15196:  MOVWF  FF6
15198:  MOVLW  21
1519A:  MOVWF  FF7
1519C:  MOVLW  00
1519E:  MOVWF  FF8
151A0:  MOVLW  07
151A2:  MOVWF  xC8
151A4:  MOVLB  0
151A6:  CALL   A9FA
151AA:  MOVFF  874,8CA
151AE:  MOVLW  1B
151B0:  MOVLB  8
151B2:  MOVWF  xCB
151B4:  MOVLB  0
151B6:  CALL   51F8
151BA:  MOVLW  B5
151BC:  MOVWF  FF6
151BE:  MOVLW  21
151C0:  MOVWF  FF7
151C2:  MOVLW  00
151C4:  MOVWF  FF8
151C6:  MOVLW  09
151C8:  MOVLB  8
151CA:  MOVWF  xC8
151CC:  MOVLB  0
151CE:  CALL   A9FA
151D2:  MOVFF  879,8DC
151D6:  CALL   5016
151DA:  MOVLW  C0
151DC:  MOVWF  FF6
151DE:  MOVLW  21
151E0:  MOVWF  FF7
151E2:  MOVLW  00
151E4:  MOVWF  FF8
151E6:  MOVLW  07
151E8:  MOVLB  8
151EA:  MOVWF  xC8
151EC:  MOVLB  0
151EE:  CALL   A9FA
151F2:  MOVLW  10
151F4:  MOVWF  FE9
151F6:  MOVFF  878,8D4
151FA:  MOVFF  877,8D3
151FE:  CALL   AA2C
15202:  MOVLW  CA
15204:  MOVWF  FF6
15206:  MOVLW  21
15208:  MOVWF  FF7
1520A:  MOVLW  00
1520C:  MOVWF  FF8
1520E:  MOVLW  03
15210:  MOVLB  8
15212:  MOVWF  xC8
15214:  MOVLB  0
15216:  CALL   A9FA
....................    record_event(); 
1521A:  CALL   8410
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
1521E:  MOVLB  8
15220:  MOVF   x79,W
15222:  SUBLW  66
15224:  BZ    15234
15226:  MOVF   x79,W
15228:  SUBLW  67
1522A:  BZ    15234
1522C:  MOVLB  0
1522E:  CALL   A98E
15232:  MOVLB  8
15234:  MOVLB  0
15236:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15AB8:  MOVLW  01
15ABA:  MOVLB  8
15ABC:  MOVWF  x6C
....................    while (macro_batch == TRUE){ 
15ABE:  DECFSZ x6C,W
15AC0:  BRA    15D46
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15AC2:  MOVFF  38,9EA
15AC6:  MOVFF  37,9E9
15ACA:  MOVLB  9
15ACC:  CLRF   xEC
15ACE:  MOVLW  03
15AD0:  MOVWF  xEB
15AD2:  MOVLB  0
15AD4:  CALL   5C0E
15AD8:  MOVF   01,W
15ADA:  MOVLB  7
15ADC:  ADDWF  xCD,W
15ADE:  MOVLB  8
15AE0:  MOVWF  x67
15AE2:  MOVF   02,W
15AE4:  MOVLB  7
15AE6:  ADDWFC xCE,W
15AE8:  MOVLB  8
15AEA:  MOVWF  x68
....................       init_ext_eeprom(); 
15AEC:  MOVLB  0
15AEE:  CALL   FFDC
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
15AF2:  MOVFF  868,8A9
15AF6:  MOVFF  867,8A8
15AFA:  CALL   102F0
15AFE:  MOVFF  01,869
....................       ++addr; 
15B02:  MOVLB  8
15B04:  INCF   x67,F
15B06:  BTFSC  FD8.2
15B08:  INCF   x68,F
....................       macro_arg = read16_ext_eeprom(addr); 
15B0A:  MOVFF  868,8A0
15B0E:  MOVFF  867,89F
15B12:  MOVLB  0
15B14:  CALL   10404
15B18:  MOVFF  02,86B
15B1C:  MOVFF  01,86A
....................       ++addr; 
15B20:  MOVLB  8
15B22:  INCF   x67,F
15B24:  BTFSC  FD8.2
15B26:  INCF   x68,F
....................       ++addr;      
15B28:  INCF   x67,F
15B2A:  BTFSC  FD8.2
15B2C:  INCF   x68,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
15B2E:  MOVF   x69,W
15B30:  SUBLW  4D
15B32:  BTFSS  FD8.2
15B34:  BRA    15C5E
15B36:  MOVF   x6A,F
15B38:  BNZ   15B40
15B3A:  MOVF   x6B,F
15B3C:  BTFSC  FD8.2
15B3E:  BRA    15C5E
....................          { 
....................          RTC_reset_HT(); 
15B40:  MOVLB  0
15B42:  CALL   3430
....................          RTC_read(); 
15B46:  CALL   32C2
....................          RTC_display(); 
15B4A:  CALL   DF82
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
15B4E:  MOVLW  CE
15B50:  MOVWF  FF6
15B52:  MOVLW  21
15B54:  MOVWF  FF7
15B56:  MOVLW  00
15B58:  MOVWF  FF8
15B5A:  CLRF   1B
15B5C:  BTFSC  FF2.7
15B5E:  BSF    1B.7
15B60:  BCF    FF2.7
15B62:  MOVLW  09
15B64:  MOVLB  A
15B66:  MOVWF  x18
15B68:  MOVLB  0
15B6A:  CALL   1006
15B6E:  BTFSC  1B.7
15B70:  BSF    FF2.7
15B72:  MOVLB  8
15B74:  MOVF   x69,W
15B76:  BTFSS  F9E.4
15B78:  BRA    15B76
15B7A:  MOVWF  FAD
15B7C:  MOVLW  10
15B7E:  MOVWF  FE9
15B80:  CLRF   1B
15B82:  BTFSC  FF2.7
15B84:  BSF    1B.7
15B86:  BCF    FF2.7
15B88:  MOVFF  86B,A19
15B8C:  MOVFF  86A,A18
15B90:  MOVLB  0
15B92:  CALL   1188
15B96:  BTFSC  1B.7
15B98:  BSF    FF2.7
15B9A:  MOVLW  DC
15B9C:  MOVWF  FF6
15B9E:  MOVLW  21
15BA0:  MOVWF  FF7
15BA2:  MOVLW  00
15BA4:  MOVWF  FF8
15BA6:  CLRF   1B
15BA8:  BTFSC  FF2.7
15BAA:  BSF    1B.7
15BAC:  BCF    FF2.7
15BAE:  MOVLW  03
15BB0:  MOVLB  A
15BB2:  MOVWF  x18
15BB4:  MOVLB  0
15BB6:  CALL   1006
15BBA:  BTFSC  1B.7
15BBC:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
15BBE:  MOVLW  01
15BC0:  ADDWF  21,W
15BC2:  MOVLB  8
15BC4:  MOVWF  x6D
15BC6:  MOVLW  00
15BC8:  ADDWFC 22,W
15BCA:  MOVWF  x6E
15BCC:  MOVLW  E0
15BCE:  MOVWF  FF6
15BD0:  MOVLW  21
15BD2:  MOVWF  FF7
15BD4:  MOVLW  00
15BD6:  MOVWF  FF8
15BD8:  CLRF   1B
15BDA:  BTFSC  FF2.7
15BDC:  BSF    1B.7
15BDE:  BCF    FF2.7
15BE0:  MOVLW  07
15BE2:  MOVLB  A
15BE4:  MOVWF  x18
15BE6:  MOVLB  0
15BE8:  CALL   1006
15BEC:  BTFSC  1B.7
15BEE:  BSF    FF2.7
15BF0:  MOVLW  09
15BF2:  MOVWF  FE9
15BF4:  CLRF   1B
15BF6:  BTFSC  FF2.7
15BF8:  BSF    1B.7
15BFA:  BCF    FF2.7
15BFC:  MOVFF  86E,A19
15C00:  MOVFF  86D,A18
15C04:  CALL   1188
15C08:  BTFSC  1B.7
15C0A:  BSF    FF2.7
15C0C:  MOVLW  EC
15C0E:  MOVWF  FF6
15C10:  MOVLW  21
15C12:  MOVWF  FF7
15C14:  MOVLW  00
15C16:  MOVWF  FF8
15C18:  CLRF   1B
15C1A:  BTFSC  FF2.7
15C1C:  BSF    1B.7
15C1E:  BCF    FF2.7
15C20:  MOVLW  04
15C22:  MOVLB  A
15C24:  MOVWF  x18
15C26:  MOVLB  0
15C28:  CALL   1006
15C2C:  BTFSC  1B.7
15C2E:  BSF    FF2.7
15C30:  MOVLW  09
15C32:  MOVWF  FE9
15C34:  CLRF   1B
15C36:  BTFSC  FF2.7
15C38:  BSF    1B.7
15C3A:  BCF    FF2.7
15C3C:  MOVFF  28,A19
15C40:  MOVFF  27,A18
15C44:  CALL   1188
15C48:  BTFSC  1B.7
15C4A:  BSF    FF2.7
15C4C:  MOVLW  0D
15C4E:  BTFSS  F9E.4
15C50:  BRA    15C4E
15C52:  MOVWF  FAD
15C54:  MOVLW  0A
15C56:  BTFSS  F9E.4
15C58:  BRA    15C56
15C5A:  MOVWF  FAD
15C5C:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
15C5E:  MOVF   28,W
15C60:  SUBWF  22,W
15C62:  BNC   15C70
15C64:  BNZ   15C6C
15C66:  MOVF   27,W
15C68:  SUBWF  21,W
15C6A:  BNC   15C70
....................          {macro_cmd = 'Z';} 
15C6C:  MOVLW  5A
15C6E:  MOVWF  x69
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
15C70:  MOVF   x69,W
15C72:  XORLW  72
15C74:  MOVLB  0
15C76:  BZ    15C8A
15C78:  XORLW  57
15C7A:  BZ    15CAC
15C7C:  XORLW  68
15C7E:  BZ    15CE2
15C80:  XORLW  17
15C82:  BZ    15D18
15C84:  XORLW  61
15C86:  BZ    15D24
15C88:  BRA    15D2E
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
15C8A:  INCF   37,F
15C8C:  BTFSC  FD8.2
15C8E:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
15C90:  MOVLB  8
15C92:  CLRF   x5C
15C94:  CLRF   x5B
15C96:  MOVFF  38,85A
15C9A:  MOVFF  37,859
....................                master_macro_loop_count = macro_arg; 
15C9E:  CLRF   x58
15CA0:  CLRF   x57
15CA2:  MOVFF  86B,856
15CA6:  MOVFF  86A,855
....................             break; 
15CAA:  BRA    15D3A
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
15CAC:  MOVLB  8
15CAE:  MOVF   x58,F
15CB0:  BNZ   15CC0
15CB2:  MOVF   x57,F
15CB4:  BNZ   15CC0
15CB6:  MOVF   x56,F
15CB8:  BNZ   15CC0
15CBA:  MOVF   x55,W
15CBC:  SUBLW  01
15CBE:  BC    15CDA
....................                   nv_macro_step = master_macro_loop_start; 
15CC0:  MOVFF  85A,38
15CC4:  MOVFF  859,37
....................                   master_macro_loop_count--; 
15CC8:  MOVLW  FF
15CCA:  ADDWF  x55,F
15CCC:  BTFSS  FD8.0
15CCE:  ADDWF  x56,F
15CD0:  BTFSS  FD8.0
15CD2:  ADDWF  x57,F
15CD4:  BTFSS  FD8.0
15CD6:  ADDWF  x58,F
....................                }else{ 
15CD8:  BRA    15CE0
....................                   nv_macro_step++; 
15CDA:  INCF   37,F
15CDC:  BTFSC  FD8.2
15CDE:  INCF   38,F
....................                } 
....................             break; 
15CE0:  BRA    15D3A
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
15CE2:  MOVLB  8
15CE4:  MOVF   x6B,F
15CE6:  BNZ   15D16
15CE8:  MOVF   x6A,W
15CEA:  SUBLW  14
15CEC:  BNC   15D16
....................                   play_macro(macro_arg,0);     // casts to int8 
15CEE:  MOVFF  86A,874
15CF2:  CLRF   x76
15CF4:  CLRF   x75
15CF6:  MOVLB  0
15CF8:  CALL   14F00
....................                   delay_ms(100); 
15CFC:  MOVLW  64
15CFE:  MOVLB  9
15D00:  MOVWF  xC9
15D02:  MOVLB  0
15D04:  CALL   288E
....................                   ++nv_sample; 
15D08:  INCF   21,F
15D0A:  BTFSC  FD8.2
15D0C:  INCF   22,F
....................                   ++nv_macro_step; 
15D0E:  INCF   37,F
15D10:  BTFSC  FD8.2
15D12:  INCF   38,F
15D14:  MOVLB  8
....................                } 
....................                break; 
15D16:  BRA    15D3A
....................             case 'Z' : ++nv_macro_step; 
15D18:  INCF   37,F
15D1A:  BTFSC  FD8.2
15D1C:  INCF   38,F
....................                        macro_batch = FALSE; 
15D1E:  MOVLB  8
15D20:  CLRF   x6C
....................                break; 
15D22:  BRA    15D3A
....................             case ';' : nv_macro_step = 0; 
15D24:  CLRF   38
15D26:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
15D28:  MOVLB  8
15D2A:  BRA    15D3A
15D2C:  MOVLB  0
....................             default  : cmd_err(); 
15D2E:  CALL   BC28
....................                        macro_cmd = 'e'; 
15D32:  MOVLW  65
15D34:  MOVLB  8
15D36:  MOVWF  x69
....................                        macro_batch = FALSE; 
15D38:  CLRF   x6C
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
15D3A:  DECFSZ 4C,W
15D3C:  BRA    15D44
....................             macro_cmd = ';'; 
15D3E:  MOVLW  3B
15D40:  MOVWF  x69
....................             break;         // 17 = CTRL-Q (quit) 
15D42:  BRA    15D46
....................          } 
15D44:  BRA    15ABE
....................    } 
....................    return (macro_cmd); 
15D46:  MOVFF  869,01
15D4A:  MOVLB  0
15D4C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D0A6:  MOVLB  8
0D0A8:  MOVF   x69,W
0D0AA:  XORLW  2B
0D0AC:  MOVLB  0
0D0AE:  BZ    D0DE
0D0B0:  XORLW  06
0D0B2:  BZ    D106
0D0B4:  XORLW  6F
0D0B6:  BZ    D12E
0D0B8:  XORLW  05
0D0BA:  BZ    D140
0D0BC:  XORLW  17
0D0BE:  BZ    D156
0D0C0:  XORLW  01
0D0C2:  BZ    D186
0D0C4:  XORLW  03
0D0C6:  BTFSC  FD8.2
0D0C8:  BRA    D1AE
0D0CA:  XORLW  06
0D0CC:  BTFSC  FD8.2
0D0CE:  BRA    D1D6
0D0D0:  XORLW  0D
0D0D2:  BTFSC  FD8.2
0D0D4:  BRA    D1EA
0D0D6:  XORLW  62
0D0D8:  BTFSC  FD8.2
0D0DA:  BRA    D212
0D0DC:  BRA    D21A
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D0DE:  MOVLW  01
0D0E0:  MOVLB  7
0D0E2:  MOVWF  x3C
....................                  move_motor(0,0,macro_arg,1); 
0D0E4:  MOVLB  8
0D0E6:  CLRF   xA4
0D0E8:  CLRF   xA5
0D0EA:  CLRF   xA9
0D0EC:  CLRF   xA8
0D0EE:  MOVFF  86B,8A7
0D0F2:  MOVFF  86A,8A6
0D0F6:  MOVWF  xAA
0D0F8:  MOVLB  0
0D0FA:  CALL   9CAE
....................                  macro_status=step_err_status(); 
0D0FE:  RCALL  CFFE
0D100:  MOVFF  01,86C
....................          break; 
0D104:  BRA    D21A
....................       case '-' : motor=1; 
0D106:  MOVLW  01
0D108:  MOVLB  7
0D10A:  MOVWF  x3C
....................                  move_motor(0,1,macro_arg,1); 
0D10C:  MOVLB  8
0D10E:  CLRF   xA4
0D110:  MOVWF  xA5
0D112:  CLRF   xA9
0D114:  CLRF   xA8
0D116:  MOVFF  86B,8A7
0D11A:  MOVFF  86A,8A6
0D11E:  MOVWF  xAA
0D120:  MOVLB  0
0D122:  CALL   9CAE
....................                  macro_status=step_err_status(); 
0D126:  RCALL  CFFE
0D128:  MOVFF  01,86C
....................          break; 
0D12C:  BRA    D21A
....................       case 'B' : h_bridge(macro_arg); 
0D12E:  MOVFF  86A,892
0D132:  CALL   BEB8
....................                  macro_status = 'a'; 
0D136:  MOVLW  61
0D138:  MOVLB  8
0D13A:  MOVWF  x6C
....................          break; 
0D13C:  MOVLB  0
0D13E:  BRA    D21A
....................       case 'G' : motor=0; 
0D140:  MOVLB  7
0D142:  CLRF   x3C
....................                  align(0); 
0D144:  MOVLB  8
0D146:  CLRF   x9F
0D148:  MOVLB  0
0D14A:  CALL   A7EA
....................                  macro_status=step_err_status(); 
0D14E:  RCALL  CFFE
0D150:  MOVFF  01,86C
....................          break ;           
0D154:  BRA    D21A
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D156:  MOVFF  86B,2E
0D15A:  MOVFF  86A,2D
....................                  motor=0; 
0D15E:  MOVLB  7
0D160:  CLRF   x3C
....................                  move_motor(0,0,macro_arg,1);   
0D162:  MOVLB  8
0D164:  CLRF   xA4
0D166:  CLRF   xA5
0D168:  CLRF   xA9
0D16A:  CLRF   xA8
0D16C:  MOVFF  86B,8A7
0D170:  MOVFF  86A,8A6
0D174:  MOVLW  01
0D176:  MOVWF  xAA
0D178:  MOVLB  0
0D17A:  CALL   9CAE
....................                  macro_status=step_err_status(); 
0D17E:  RCALL  CFFE
0D180:  MOVFF  01,86C
....................          break; 
0D184:  BRA    D21A
....................       case 'Q' : motor=0; 
0D186:  MOVLB  7
0D188:  CLRF   x3C
....................                  move_motor(0,0,macro_arg,1); 
0D18A:  MOVLB  8
0D18C:  CLRF   xA4
0D18E:  CLRF   xA5
0D190:  CLRF   xA9
0D192:  CLRF   xA8
0D194:  MOVFF  86B,8A7
0D198:  MOVFF  86A,8A6
0D19C:  MOVLW  01
0D19E:  MOVWF  xAA
0D1A0:  MOVLB  0
0D1A2:  CALL   9CAE
....................                  macro_status=step_err_status(); 
0D1A6:  RCALL  CFFE
0D1A8:  MOVFF  01,86C
....................          break; 
0D1AC:  BRA    D21A
....................       case 'R' : motor=0; 
0D1AE:  MOVLB  7
0D1B0:  CLRF   x3C
....................                  move_motor(0,1,macro_arg,1); 
0D1B2:  MOVLB  8
0D1B4:  CLRF   xA4
0D1B6:  MOVLW  01
0D1B8:  MOVWF  xA5
0D1BA:  CLRF   xA9
0D1BC:  CLRF   xA8
0D1BE:  MOVFF  86B,8A7
0D1C2:  MOVFF  86A,8A6
0D1C6:  MOVWF  xAA
0D1C8:  MOVLB  0
0D1CA:  CALL   9CAE
....................                  macro_status=step_err_status(); 
0D1CE:  RCALL  CFFE
0D1D0:  MOVFF  01,86C
....................          break; 
0D1D4:  BRA    D21A
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D1D6:  MOVFF  86B,8A0
0D1DA:  MOVFF  86A,89F
0D1DE:  RCALL  D036
....................                  macro_status = 'a'; 
0D1E0:  MOVLW  61
0D1E2:  MOVLB  8
0D1E4:  MOVWF  x6C
....................          break; 
0D1E6:  MOVLB  0
0D1E8:  BRA    D21A
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D1EA:  MOVLB  8
0D1EC:  DECFSZ x6A,W
0D1EE:  BRA    D1FC
0D1F0:  MOVF   x6B,F
0D1F2:  BNZ   D1FC
0D1F4:  MOVLB  0
0D1F6:  RCALL  D06C
0D1F8:  BRA    D208
0D1FA:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D1FC:  MOVF   x6A,F
0D1FE:  BNZ   D20A
0D200:  MOVF   x6B,F
0D202:  BNZ   D20A
0D204:  MOVLB  0
0D206:  RCALL  D090
0D208:  MOVLB  8
....................                  macro_status = 'a'; 
0D20A:  MOVLW  61
0D20C:  MOVWF  x6C
....................          break;           
0D20E:  MOVLB  0
0D210:  BRA    D21A
....................       case ';' : macro_status = 'f'; 
0D212:  MOVLW  66
0D214:  MOVLB  8
0D216:  MOVWF  x6C
....................          break;            
0D218:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D21A:  MOVLB  8
0D21C:  MOVFF  86C,01
0D220:  MOVLB  0
0D222:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D4FC:  MOVF   2E,F
0D4FE:  BNZ   D506
0D500:  MOVF   2D,W
0D502:  SUBLW  01
0D504:  BC    D518
0D506:  MOVF   2E,F
0D508:  BNZ   D518
0D50A:  MOVF   2D,W
0D50C:  SUBLW  30
0D50E:  BNC   D518
0D510:  DECFSZ 2F,W
0D512:  BRA    D518
0D514:  MOVF   30,F
0D516:  BZ    D536
0D518:  MOVF   2E,F
0D51A:  BNZ   D522
0D51C:  MOVF   2D,W
0D51E:  SUBLW  01
0D520:  BC    D540
0D522:  MOVF   2E,F
0D524:  BNZ   D540
0D526:  MOVF   2D,W
0D528:  SUBLW  32
0D52A:  BNC   D540
0D52C:  MOVF   2F,W
0D52E:  SUBLW  03
0D530:  BNZ   D540
0D532:  MOVF   30,F
0D534:  BNZ   D540
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D536:  MOVLW  61
0D538:  MOVLB  8
0D53A:  MOVWF  x68
....................    } 
0D53C:  BRA    D548
0D53E:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D540:  MOVLW  65
0D542:  MOVLB  8
0D544:  MOVWF  x68
....................       goto end_macro;       
0D546:  BRA    D5F8
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D548:  MOVLW  59
0D54A:  MOVWF  x69
0D54C:  CLRF   x6B
0D54E:  MOVLW  01
0D550:  MOVWF  x6A
0D552:  MOVLB  0
0D554:  RCALL  D0A6
0D556:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro; 
0D55A:  MOVLB  8
0D55C:  MOVF   x68,W
0D55E:  SUBLW  61
0D560:  BTFSS  FD8.2
0D562:  BRA    D5F8
....................    macro_status = play_wms_macro_cmd('G',1); 
0D564:  MOVLW  47
0D566:  MOVWF  x69
0D568:  CLRF   x6B
0D56A:  MOVLW  01
0D56C:  MOVWF  x6A
0D56E:  MOVLB  0
0D570:  RCALL  D0A6
0D572:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro; 
0D576:  MOVLB  8
0D578:  MOVF   x68,W
0D57A:  SUBLW  61
0D57C:  BTFSS  FD8.2
0D57E:  BRA    D5F8
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D580:  MOVLW  2D
0D582:  MOVWF  x69
0D584:  MOVFF  2C,86B
0D588:  MOVFF  2B,86A
0D58C:  MOVLB  0
0D58E:  RCALL  D0A6
0D590:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro; 
0D594:  MOVLB  8
0D596:  MOVF   x68,W
0D598:  SUBLW  61
0D59A:  BTFSS  FD8.2
0D59C:  BRA    D5F8
....................    macro_status = play_wms_macro_cmd('P',port); 
0D59E:  MOVLW  50
0D5A0:  MOVWF  x69
0D5A2:  MOVFF  867,86B
0D5A6:  MOVFF  866,86A
0D5AA:  MOVLB  0
0D5AC:  RCALL  D0A6
0D5AE:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro;    
0D5B2:  MOVLB  8
0D5B4:  MOVF   x68,W
0D5B6:  SUBLW  61
0D5B8:  BTFSS  FD8.2
0D5BA:  BRA    D5F8
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D5BC:  MOVLW  2B
0D5BE:  MOVWF  x69
0D5C0:  MOVFF  2C,86B
0D5C4:  MOVFF  2B,86A
0D5C8:  MOVLB  0
0D5CA:  RCALL  D0A6
0D5CC:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro; 
0D5D0:  MOVLB  8
0D5D2:  MOVF   x68,W
0D5D4:  SUBLW  61
0D5D6:  BTFSS  FD8.2
0D5D8:  BRA    D5F8
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D5DA:  MOVLW  59
0D5DC:  MOVWF  x69
0D5DE:  CLRF   x6B
0D5E0:  CLRF   x6A
0D5E2:  MOVLB  0
0D5E4:  RCALL  D0A6
0D5E6:  MOVFF  01,868
....................    if (macro_status != 'a') goto end_macro; 
0D5EA:  MOVLB  8
0D5EC:  MOVF   x68,W
0D5EE:  SUBLW  61
0D5F0:  BTFSS  FD8.2
0D5F2:  BRA    D5F8
....................    macro_status='f';  
0D5F4:  MOVLW  66
0D5F6:  MOVWF  x68
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D5F8:  CLRF   x7A
0D5FA:  MOVLB  0
0D5FC:  RCALL  D33A
....................    
....................    switch(macro_status){ 
0D5FE:  MOVLW  61
0D600:  MOVLB  8
0D602:  SUBWF  x68,W
0D604:  ADDLW  FA
0D606:  BC    D6DA
0D608:  ADDLW  06
0D60A:  MOVLB  0
0D60C:  GOTO   D6DE
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D610:  MOVF   1F,F
0D612:  BNZ   D618
0D614:  MOVF   20,F
0D616:  BZ    D634
0D618:  MOVLW  F8
0D61A:  MOVWF  FF6
0D61C:  MOVLW  21
0D61E:  MOVWF  FF7
0D620:  MOVLW  00
0D622:  MOVWF  FF8
0D624:  CLRF   1B
0D626:  BTFSC  FF2.7
0D628:  BSF    1B.7
0D62A:  BCF    FF2.7
0D62C:  CALL   0E30
0D630:  BTFSC  1B.7
0D632:  BSF    FF2.7
....................          break; 
0D634:  MOVLB  8
0D636:  BRA    D6DA
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D638:  MOVLW  00
0D63A:  MOVWF  FF6
0D63C:  MOVLW  22
0D63E:  MOVWF  FF7
0D640:  MOVLW  00
0D642:  MOVWF  FF8
0D644:  CLRF   1B
0D646:  BTFSC  FF2.7
0D648:  BSF    1B.7
0D64A:  BCF    FF2.7
0D64C:  CALL   0E30
0D650:  BTFSC  1B.7
0D652:  BSF    FF2.7
....................          break; 
0D654:  MOVLB  8
0D656:  BRA    D6DA
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D658:  MOVLW  08
0D65A:  MOVWF  FF6
0D65C:  MOVLW  22
0D65E:  MOVWF  FF7
0D660:  MOVLW  00
0D662:  MOVWF  FF8
0D664:  CLRF   1B
0D666:  BTFSC  FF2.7
0D668:  BSF    1B.7
0D66A:  BCF    FF2.7
0D66C:  CALL   0E30
0D670:  BTFSC  1B.7
0D672:  BSF    FF2.7
....................          break; 
0D674:  MOVLB  8
0D676:  BRA    D6DA
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D678:  MOVLW  10
0D67A:  MOVWF  FF6
0D67C:  MOVLW  22
0D67E:  MOVWF  FF7
0D680:  MOVLW  00
0D682:  MOVWF  FF8
0D684:  CLRF   1B
0D686:  BTFSC  FF2.7
0D688:  BSF    1B.7
0D68A:  BCF    FF2.7
0D68C:  CALL   0E30
0D690:  BTFSC  1B.7
0D692:  BSF    FF2.7
....................          break; 
0D694:  MOVLB  8
0D696:  BRA    D6DA
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D698:  MOVLW  18
0D69A:  MOVWF  FF6
0D69C:  MOVLW  22
0D69E:  MOVWF  FF7
0D6A0:  MOVLW  00
0D6A2:  MOVWF  FF8
0D6A4:  CLRF   1B
0D6A6:  BTFSC  FF2.7
0D6A8:  BSF    1B.7
0D6AA:  BCF    FF2.7
0D6AC:  CALL   0E30
0D6B0:  BTFSC  1B.7
0D6B2:  BSF    FF2.7
....................          break;    
0D6B4:  MOVLB  8
0D6B6:  BRA    D6DA
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D6B8:  MOVLW  20
0D6BA:  MOVWF  FF6
0D6BC:  MOVLW  22
0D6BE:  MOVWF  FF7
0D6C0:  MOVLW  00
0D6C2:  MOVWF  FF8
0D6C4:  CLRF   1B
0D6C6:  BTFSC  FF2.7
0D6C8:  BSF    1B.7
0D6CA:  BCF    FF2.7
0D6CC:  CALL   0E30
0D6D0:  BTFSC  1B.7
0D6D2:  BSF    FF2.7
....................          break;           
0D6D4:  MOVLB  8
0D6D6:  BRA    D6DA
0D6D8:  MOVLB  8
....................    } 
0D6DA:  MOVLB  0
0D6DC:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
15F8E:  MOVLB  8
15F90:  MOVF   x65,W
15F92:  BTFSC  FD8.2
15F94:  DECF   x66,F
15F96:  DECF   x65,F
....................    addr = macro_address[0] + (step*9); 
15F98:  MOVFF  866,9EA
15F9C:  MOVFF  865,9E9
15FA0:  MOVLB  9
15FA2:  CLRF   xEC
15FA4:  MOVLW  09
15FA6:  MOVWF  xEB
15FA8:  MOVLB  0
15FAA:  CALL   5C0E
15FAE:  MOVF   01,W
15FB0:  MOVLB  7
15FB2:  ADDWF  xCD,W
15FB4:  MOVLB  8
15FB6:  MOVWF  x67
15FB8:  MOVF   02,W
15FBA:  MOVLB  7
15FBC:  ADDWFC xCE,W
15FBE:  MOVLB  8
15FC0:  MOVWF  x68
....................     
....................    init_ext_eeprom(); 
15FC2:  MOVLB  0
15FC4:  CALL   FFDC
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
15FC8:  MOVFF  868,8A9
15FCC:  MOVFF  867,8A8
15FD0:  CALL   102F0
15FD4:  MOVFF  01,869
....................    ++addr; 
15FD8:  MOVLB  8
15FDA:  INCF   x67,F
15FDC:  BTFSC  FD8.2
15FDE:  INCF   x68,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
15FE0:  MOVFF  868,8A0
15FE4:  MOVFF  867,89F
15FE8:  MOVLB  0
15FEA:  CALL   10404
15FEE:  MOVFF  02,86D
15FF2:  MOVFF  01,86C
....................    ++addr; 
15FF6:  MOVLB  8
15FF8:  INCF   x67,F
15FFA:  BTFSC  FD8.2
15FFC:  INCF   x68,F
....................    ++addr; 
15FFE:  INCF   x67,F
16000:  BTFSC  FD8.2
16002:  INCF   x68,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
16004:  MOVFF  868,8A9
16008:  MOVFF  867,8A8
1600C:  MOVLB  0
1600E:  CALL   102F0
16012:  MOVFF  01,86A
....................    ++addr; 
16016:  MOVLB  8
16018:  INCF   x67,F
1601A:  BTFSC  FD8.2
1601C:  INCF   x68,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
1601E:  MOVFF  868,8A0
16022:  MOVFF  867,89F
16026:  MOVLB  0
16028:  CALL   10404
1602C:  MOVFF  02,86F
16030:  MOVFF  01,86E
....................    ++addr; 
16034:  MOVLB  8
16036:  INCF   x67,F
16038:  BTFSC  FD8.2
1603A:  INCF   x68,F
....................    ++addr; 
1603C:  INCF   x67,F
1603E:  BTFSC  FD8.2
16040:  INCF   x68,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
16042:  MOVFF  868,8A9
16046:  MOVFF  867,8A8
1604A:  MOVLB  0
1604C:  CALL   102F0
16050:  MOVFF  01,86B
....................    ++addr; 
16054:  MOVLB  8
16056:  INCF   x67,F
16058:  BTFSC  FD8.2
1605A:  INCF   x68,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
1605C:  MOVFF  868,8A0
16060:  MOVFF  867,89F
16064:  MOVLB  0
16066:  CALL   10404
1606A:  MOVFF  02,871
1606E:  MOVFF  01,870
....................    ++addr; 
16072:  MOVLB  8
16074:  INCF   x67,F
16076:  BTFSC  FD8.2
16078:  INCF   x68,F
....................    ++addr; 
1607A:  INCF   x67,F
1607C:  BTFSC  FD8.2
1607E:  INCF   x68,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16080:  MOVFF  868,8A9
16084:  MOVFF  867,8A8
16088:  MOVLB  0
1608A:  CALL   102F0
1608E:  MOVFF  01,872
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
16092:  MOVLB  8
16094:  MOVF   x69,W
16096:  SUBLW  4A
16098:  BTFSS  FD8.2
1609A:  BRA    16170
1609C:  MOVF   x6A,W
1609E:  SUBLW  50
160A0:  BNZ   16170
160A2:  MOVF   x6B,W
160A4:  SUBLW  4D
160A6:  BNZ   16170
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
160A8:  MOVF   x69,W
160AA:  BTFSS  F9E.4
160AC:  BRA    160AA
160AE:  MOVWF  FAD
160B0:  MOVLW  10
160B2:  MOVWF  FE9
160B4:  CLRF   1B
160B6:  BTFSC  FF2.7
160B8:  BSF    1B.7
160BA:  BCF    FF2.7
160BC:  MOVFF  86D,A19
160C0:  MOVFF  86C,A18
160C4:  MOVLB  0
160C6:  CALL   1188
160CA:  BTFSC  1B.7
160CC:  BSF    FF2.7
160CE:  MOVLW  2C
160D0:  BTFSS  F9E.4
160D2:  BRA    160D0
160D4:  MOVWF  FAD
160D6:  MOVLB  8
160D8:  MOVF   x6A,W
160DA:  BTFSS  F9E.4
160DC:  BRA    160DA
160DE:  MOVWF  FAD
160E0:  MOVLW  10
160E2:  MOVWF  FE9
160E4:  CLRF   1B
160E6:  BTFSC  FF2.7
160E8:  BSF    1B.7
160EA:  BCF    FF2.7
160EC:  MOVFF  86F,A19
160F0:  MOVFF  86E,A18
160F4:  MOVLB  0
160F6:  CALL   1188
160FA:  BTFSC  1B.7
160FC:  BSF    FF2.7
160FE:  MOVLW  2C
16100:  BTFSS  F9E.4
16102:  BRA    16100
16104:  MOVWF  FAD
16106:  MOVLB  8
16108:  MOVF   x6B,W
1610A:  BTFSS  F9E.4
1610C:  BRA    1610A
1610E:  MOVWF  FAD
16110:  MOVLW  10
16112:  MOVWF  FE9
16114:  CLRF   1B
16116:  BTFSC  FF2.7
16118:  BSF    1B.7
1611A:  BCF    FF2.7
1611C:  MOVFF  871,A19
16120:  MOVFF  870,A18
16124:  MOVLB  0
16126:  CALL   1188
1612A:  BTFSC  1B.7
1612C:  BSF    FF2.7
1612E:  MOVLW  0D
16130:  BTFSS  F9E.4
16132:  BRA    16130
16134:  MOVWF  FAD
16136:  MOVLW  0A
16138:  BTFSS  F9E.4
1613A:  BRA    16138
1613C:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
1613E:  MOVFF  86D,24
16142:  MOVFF  86C,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
16146:  MOVLB  8
16148:  MOVF   x70,F
1614A:  BNZ   16150
1614C:  MOVF   x71,F
1614E:  BZ    1616E
16150:  MOVF   x71,F
16152:  BNZ   1616E
16154:  MOVF   x70,W
16156:  SUBLW  10
16158:  BNC   1616E
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
1615A:  MOVFF  870,874
1615E:  MOVFF  86F,876
16162:  MOVFF  86E,875
16166:  MOVLB  0
16168:  CALL   14F00
1616C:  MOVLB  8
....................       } 
....................    } 
1616E:  BRA    1617C
....................    else { 
....................       cmd_err(); 
16170:  MOVLB  0
16172:  CALL   BC28
....................       macro_end = 59; 
16176:  MOVLW  3B
16178:  MOVLB  8
1617A:  MOVWF  x72
....................    } 
....................     
....................    return (macro_end); 
1617C:  MOVFF  872,01
16180:  MOVLB  0
16182:  GOTO   1626C (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
1636E:  MOVLB  8
16370:  MOVF   x69,W
16372:  BTFSC  FD8.2
16374:  DECF   x6A,F
16376:  DECF   x69,F
....................    addr = macro_address[0] + (step*6); 
16378:  MOVFF  86A,9EA
1637C:  MOVFF  869,9E9
16380:  MOVLB  9
16382:  CLRF   xEC
16384:  MOVLW  06
16386:  MOVWF  xEB
16388:  MOVLB  0
1638A:  CALL   5C0E
1638E:  MOVF   01,W
16390:  MOVLB  7
16392:  ADDWF  xCD,W
16394:  MOVLB  8
16396:  MOVWF  x6B
16398:  MOVF   02,W
1639A:  MOVLB  7
1639C:  ADDWFC xCE,W
1639E:  MOVLB  8
163A0:  MOVWF  x6C
....................     
....................    init_ext_eeprom(); 
163A2:  MOVLB  0
163A4:  CALL   FFDC
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
163A8:  MOVFF  86C,8A9
163AC:  MOVFF  86B,8A8
163B0:  CALL   102F0
163B4:  MOVFF  01,86D
....................    ++addr; 
163B8:  MOVLB  8
163BA:  INCF   x6B,F
163BC:  BTFSC  FD8.2
163BE:  INCF   x6C,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
163C0:  MOVFF  86C,8A0
163C4:  MOVFF  86B,89F
163C8:  MOVLB  0
163CA:  CALL   10404
163CE:  MOVFF  02,870
163D2:  MOVFF  01,86F
....................    ++addr; 
163D6:  MOVLB  8
163D8:  INCF   x6B,F
163DA:  BTFSC  FD8.2
163DC:  INCF   x6C,F
....................    ++addr; 
163DE:  INCF   x6B,F
163E0:  BTFSC  FD8.2
163E2:  INCF   x6C,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
163E4:  MOVFF  86C,8A9
163E8:  MOVFF  86B,8A8
163EC:  MOVLB  0
163EE:  CALL   102F0
163F2:  MOVFF  01,86E
....................    ++addr; 
163F6:  MOVLB  8
163F8:  INCF   x6B,F
163FA:  BTFSC  FD8.2
163FC:  INCF   x6C,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
163FE:  MOVFF  86C,8A0
16402:  MOVFF  86B,89F
16406:  MOVLB  0
16408:  CALL   10404
1640C:  MOVFF  02,872
16410:  MOVFF  01,871
....................    ++addr; 
16414:  MOVLB  8
16416:  INCF   x6B,F
16418:  BTFSC  FD8.2
1641A:  INCF   x6C,F
....................    ++addr; 
1641C:  INCF   x6B,F
1641E:  BTFSC  FD8.2
16420:  INCF   x6C,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16422:  MOVFF  86C,8A9
16426:  MOVFF  86B,8A8
1642A:  MOVLB  0
1642C:  CALL   102F0
16430:  MOVFF  01,873
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
16434:  MOVLB  8
16436:  MOVF   x6D,W
16438:  SUBLW  50
1643A:  BNZ   164DE
1643C:  MOVF   x6E,W
1643E:  SUBLW  4D
16440:  BNZ   164DE
....................        
....................       RTC_read(); 
16442:  MOVLB  0
16444:  CALL   32C2
....................       RTC_display(); 
16448:  CALL   DF82
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
1644C:  MOVLB  8
1644E:  MOVF   x6D,W
16450:  BTFSS  F9E.4
16452:  BRA    16450
16454:  MOVWF  FAD
16456:  MOVLW  10
16458:  MOVWF  FE9
1645A:  CLRF   1B
1645C:  BTFSC  FF2.7
1645E:  BSF    1B.7
16460:  BCF    FF2.7
16462:  MOVFF  870,A19
16466:  MOVFF  86F,A18
1646A:  MOVLB  0
1646C:  CALL   1188
16470:  BTFSC  1B.7
16472:  BSF    FF2.7
16474:  MOVLW  2C
16476:  BTFSS  F9E.4
16478:  BRA    16476
1647A:  MOVWF  FAD
1647C:  MOVLB  8
1647E:  MOVF   x6E,W
16480:  BTFSS  F9E.4
16482:  BRA    16480
16484:  MOVWF  FAD
16486:  MOVLW  10
16488:  MOVWF  FE9
1648A:  CLRF   1B
1648C:  BTFSC  FF2.7
1648E:  BSF    1B.7
16490:  BCF    FF2.7
16492:  MOVFF  872,A19
16496:  MOVFF  871,A18
1649A:  MOVLB  0
1649C:  CALL   1188
164A0:  BTFSC  1B.7
164A2:  BSF    FF2.7
164A4:  MOVLW  0D
164A6:  BTFSS  F9E.4
164A8:  BRA    164A6
164AA:  MOVWF  FAD
164AC:  MOVLW  0A
164AE:  BTFSS  F9E.4
164B0:  BRA    164AE
164B2:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
164B4:  MOVLB  8
164B6:  MOVF   x71,F
164B8:  BNZ   164BE
164BA:  MOVF   x72,F
164BC:  BZ    164DC
164BE:  MOVF   x72,F
164C0:  BNZ   164DC
164C2:  MOVF   x71,W
164C4:  SUBLW  10
164C6:  BNC   164DC
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
164C8:  MOVFF  871,874
164CC:  MOVFF  870,876
164D0:  MOVFF  86F,875
164D4:  MOVLB  0
164D6:  CALL   14F00
164DA:  MOVLB  8
....................       } 
....................    } 
164DC:  BRA    164EA
....................    else { 
....................       cmd_err(); 
164DE:  MOVLB  0
164E0:  CALL   BC28
....................       macro_end = 59; 
164E4:  MOVLW  3B
164E6:  MOVLB  8
164E8:  MOVWF  x73
....................    } 
....................     
....................    return (macro_end); 
164EA:  MOVFF  873,01
164EE:  MOVLB  0
164F0:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
15D6C:  MOVF   24,W
15D6E:  SUBWF  36,W
15D70:  BTFSS  FD8.0
15D72:  BRA    15F7A
15D74:  BNZ   15D7E
15D76:  MOVF   23,W
15D78:  SUBWF  35,W
15D7A:  BTFSS  FD8.0
15D7C:  BRA    15F7A
15D7E:  MOVF   33,F
15D80:  BTFSS  FD8.2
15D82:  BRA    15F7A
15D84:  MOVF   34,F
15D86:  BTFSS  FD8.2
15D88:  BRA    15F7A
....................       { 
....................          nv_elapsed = 0; 
15D8A:  CLRF   36
15D8C:  CLRF   35
....................  
....................          init_hardware(); 
15D8E:  CALL   28B8
....................          sd_status = init_sdcard(); 
15D92:  CALL   4FB2
15D96:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
15D9A:  MOVLB  2
15D9C:  MOVF   xD8,F
15D9E:  BZ    15DA8
15DA0:  MOVLB  0
15DA2:  CALL   4FF8
15DA6:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
15DA8:  MOVLW  01
15DAA:  MOVWF  1E
15DAC:  MOVLW  A3
15DAE:  MOVWF  1D
15DB0:  MOVLW  28
15DB2:  MOVWF  FF6
15DB4:  MOVLW  22
15DB6:  MOVWF  FF7
15DB8:  MOVLW  00
15DBA:  MOVWF  FF8
15DBC:  MOVLW  14
15DBE:  MOVLB  8
15DC0:  MOVWF  xC8
15DC2:  MOVLB  0
15DC4:  CALL   A9FA
15DC8:  MOVLW  10
15DCA:  MOVWF  FE9
15DCC:  MOVFF  22,8D4
15DD0:  MOVFF  21,8D3
15DD4:  CALL   AA2C
15DD8:  MOVLW  3F
15DDA:  MOVWF  FF6
15DDC:  MOVLW  22
15DDE:  MOVWF  FF7
15DE0:  MOVLW  00
15DE2:  MOVWF  FF8
15DE4:  MOVLW  09
15DE6:  MOVLB  8
15DE8:  MOVWF  xC8
15DEA:  MOVLB  0
15DEC:  CALL   A9FA
....................          record_event();          
15DF0:  CALL   8410
....................              
....................          macro_cmd = master_macro_eco(); 
15DF4:  RCALL  15AB8
15DF6:  MOVFF  01,864
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
15DFA:  MOVLW  16
15DFC:  MOVLB  8
15DFE:  MOVWF  xCB
15E00:  MOVFF  22,8CD
15E04:  MOVFF  21,8CC
15E08:  MOVLB  0
15E0A:  CALL   4F4C
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
15E0E:  MOVLW  3A
15E10:  MOVLB  8
15E12:  MOVWF  xCB
15E14:  MOVFF  38,8CD
15E18:  MOVFF  37,8CC
15E1C:  MOVLB  0
15E1E:  CALL   4F4C
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
15E22:  DECFSZ 4C,W
15E24:  BRA    15E48
....................          { 
....................             disable_interrupts (INT_EXT); 
15E26:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
15E28:  CLRF   32
15E2A:  MOVLW  01
15E2C:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
15E2E:  MOVLW  02
15E30:  MOVLB  8
15E32:  MOVWF  x66
15E34:  MOVFF  31,867
15E38:  MOVLB  0
15E3A:  CALL   3390
....................             busy_clear(); 
15E3E:  CALL   ADA2
....................             return (user_quit); 
15E42:  MOVFF  4C,01
15E46:  BRA    15F8A
....................          } 
....................  
....................          motor_sleep_rdy(); 
15E48:  CALL   2916
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
15E4C:  MOVLW  01
15E4E:  MOVWF  1E
15E50:  MOVLW  A3
15E52:  MOVWF  1D
15E54:  MOVLW  4A
15E56:  MOVWF  FF6
15E58:  MOVLW  22
15E5A:  MOVWF  FF7
15E5C:  MOVLW  00
15E5E:  MOVWF  FF8
15E60:  MOVLW  14
15E62:  MOVLB  8
15E64:  MOVWF  xC8
15E66:  MOVLB  0
15E68:  CALL   A9FA
15E6C:  MOVLW  10
15E6E:  MOVWF  FE9
15E70:  MOVFF  22,8D4
15E74:  MOVFF  21,8D3
15E78:  CALL   AA2C
15E7C:  MOVLW  61
15E7E:  MOVWF  FF6
15E80:  MOVLW  22
15E82:  MOVWF  FF7
15E84:  MOVLW  00
15E86:  MOVWF  FF8
15E88:  MOVLW  0C
15E8A:  MOVLB  8
15E8C:  MOVWF  xC8
15E8E:  MOVLB  0
15E90:  CALL   A9FA
....................          record_event();  
15E94:  CALL   8410
....................           
....................          if (macro_cmd == 'e') 
15E98:  MOVLB  8
15E9A:  MOVF   x64,W
15E9C:  SUBLW  65
15E9E:  BNZ   15EF2
....................          { 
....................             disable_interrupts (INT_EXT); 
15EA0:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
15EA2:  MOVLW  01
15EA4:  MOVWF  1E
15EA6:  MOVLW  A3
15EA8:  MOVWF  1D
15EAA:  MOVLW  6E
15EAC:  MOVWF  FF6
15EAE:  MOVLW  22
15EB0:  MOVWF  FF7
15EB2:  MOVLW  00
15EB4:  MOVWF  FF8
15EB6:  MOVLW  14
15EB8:  MOVWF  xC8
15EBA:  MOVLB  0
15EBC:  CALL   A9FA
15EC0:  MOVLW  10
15EC2:  MOVWF  FE9
15EC4:  MOVFF  22,8D4
15EC8:  MOVFF  21,8D3
15ECC:  CALL   AA2C
15ED0:  MOVLW  85
15ED2:  MOVWF  FF6
15ED4:  MOVLW  22
15ED6:  MOVWF  FF7
15ED8:  MOVLW  00
15EDA:  MOVWF  FF8
15EDC:  MOVLW  09
15EDE:  MOVLB  8
15EE0:  MOVWF  xC8
15EE2:  MOVLB  0
15EE4:  CALL   A9FA
....................             record_event();  
15EE8:  CALL   8410
....................             cmd_err(); 
15EEC:  CALL   BC28
15EF0:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
15EF2:  MOVF   28,W
15EF4:  SUBWF  22,W
15EF6:  BNC   15F7C
15EF8:  BNZ   15F00
15EFA:  MOVF   27,W
15EFC:  SUBWF  21,W
15EFE:  BNC   15F7C
....................          { 
....................             disable_interrupts (INT_EXT); 
15F00:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
15F02:  MOVLW  01
15F04:  MOVWF  1E
15F06:  MOVLW  A3
15F08:  MOVWF  1D
15F0A:  MOVLW  90
15F0C:  MOVWF  FF6
15F0E:  MOVLW  22
15F10:  MOVWF  FF7
15F12:  MOVLW  00
15F14:  MOVWF  FF8
15F16:  MOVLW  14
15F18:  MOVWF  xC8
15F1A:  MOVLB  0
15F1C:  CALL   A9FA
15F20:  MOVLW  10
15F22:  MOVWF  FE9
15F24:  MOVFF  22,8D4
15F28:  MOVFF  21,8D3
15F2C:  CALL   AA2C
15F30:  MOVLW  A7
15F32:  MOVWF  FF6
15F34:  MOVLW  22
15F36:  MOVWF  FF7
15F38:  MOVLW  00
15F3A:  MOVWF  FF8
15F3C:  MOVLW  0F
15F3E:  MOVLB  8
15F40:  MOVWF  xC8
15F42:  MOVLB  0
15F44:  CALL   A9FA
....................             record_event();   
15F48:  CALL   8410
....................             msg_max(); 
15F4C:  RCALL  15D4E
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
15F4E:  CLRF   34
15F50:  MOVLW  01
15F52:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
15F54:  MOVLW  28
15F56:  MOVLB  8
15F58:  MOVWF  x66
15F5A:  MOVFF  33,867
15F5E:  MOVLB  0
15F60:  CALL   3390
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15F64:  CLRF   32
15F66:  MOVLW  01
15F68:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
15F6A:  MOVLW  02
15F6C:  MOVLB  8
15F6E:  MOVWF  x66
15F70:  MOVFF  31,867
15F74:  MOVLB  0
15F76:  CALL   3390
15F7A:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
15F7C:  MOVLB  0
15F7E:  RCALL  159F2
15F80:  BRA    15D6C
....................    } 
....................     
....................    busy_clear(); 
15F82:  CALL   ADA2
....................    return (user_quit); 
15F86:  MOVFF  4C,01
15F8A:  GOTO   168AE (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
16186:  MOVF   24,W
16188:  SUBWF  36,W
1618A:  BTFSS  FD8.0
1618C:  BRA    1635C
1618E:  BNZ   16198
16190:  MOVF   23,W
16192:  SUBWF  35,W
16194:  BTFSS  FD8.0
16196:  BRA    1635C
....................       { 
....................          nv_elapsed = 0; 
16198:  CLRF   36
1619A:  CLRF   35
....................  
....................          init_hardware(); 
1619C:  CALL   28B8
....................          sd_status = init_sdcard(); 
161A0:  CALL   4FB2
161A4:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
161A8:  MOVLB  2
161AA:  MOVF   xD8,F
161AC:  BZ    161B6
161AE:  MOVLB  0
161B0:  CALL   4FF8
161B4:  MOVLB  2
....................  
....................          ++nv_sample; 
161B6:  INCF   21,F
161B8:  BTFSC  FD8.2
161BA:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
161BC:  MOVLW  40
161BE:  BTFSS  F9E.4
161C0:  BRA    161BE
161C2:  MOVWF  FAD
161C4:  MOVLW  53
161C6:  BTFSS  F9E.4
161C8:  BRA    161C6
161CA:  MOVWF  FAD
161CC:  MOVLW  09
161CE:  MOVWF  FE9
161D0:  CLRF   1B
161D2:  BTFSC  FF2.7
161D4:  BSF    1B.7
161D6:  BCF    FF2.7
161D8:  MOVFF  22,A19
161DC:  MOVFF  21,A18
161E0:  MOVLB  0
161E2:  CALL   1188
161E6:  BTFSC  1B.7
161E8:  BSF    FF2.7
161EA:  MOVLW  0D
161EC:  BTFSS  F9E.4
161EE:  BRA    161EC
161F0:  MOVWF  FAD
161F2:  MOVLW  0A
161F4:  BTFSS  F9E.4
161F6:  BRA    161F4
161F8:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
161FA:  MOVLW  01
161FC:  MOVWF  1E
161FE:  MOVLW  A3
16200:  MOVWF  1D
16202:  MOVLW  B8
16204:  MOVWF  FF6
16206:  MOVLW  22
16208:  MOVWF  FF7
1620A:  MOVLW  00
1620C:  MOVWF  FF8
1620E:  MOVLW  14
16210:  MOVLB  8
16212:  MOVWF  xC8
16214:  MOVLB  0
16216:  CALL   A9FA
1621A:  MOVLW  10
1621C:  MOVWF  FE9
1621E:  MOVFF  22,8D4
16222:  MOVFF  21,8D3
16226:  CALL   AA2C
1622A:  MOVLW  CF
1622C:  MOVWF  FF6
1622E:  MOVLW  22
16230:  MOVWF  FF7
16232:  MOVLW  00
16234:  MOVWF  FF8
16236:  MOVLW  09
16238:  MOVLB  8
1623A:  MOVWF  xC8
1623C:  MOVLB  0
1623E:  CALL   A9FA
....................          record_event();   
16242:  CALL   8410
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16246:  MOVLW  16
16248:  MOVLB  8
1624A:  MOVWF  xCB
1624C:  MOVFF  22,8CD
16250:  MOVFF  21,8CC
16254:  MOVLB  0
16256:  CALL   4F4C
....................  
....................          if (nv_macro_mode==TRUE) 
1625A:  DECFSZ 29,W
1625C:  BRA    16272
1625E:  MOVF   2A,F
16260:  BNZ   16272
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
16262:  MOVFF  22,866
16266:  MOVFF  21,865
1626A:  BRA    15F8E
1626C:  MOVFF  01,864
....................          } 
16270:  BRA    162DA
....................          else 
....................          { 
....................             time_stamp(); 
16272:  CALL   5392
....................             play_wms_hard_macro(nv_port); 
16276:  MOVFF  2E,867
1627A:  MOVFF  2D,866
1627E:  CALL   D4FC
....................             ++nv_port; 
16282:  INCF   2D,F
16284:  BTFSC  FD8.2
16286:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
16288:  MOVF   2E,F
1628A:  BNZ   16292
1628C:  MOVF   2D,W
1628E:  SUBLW  01
16290:  BC    162A4
16292:  MOVF   2E,F
16294:  BNZ   162A4
16296:  MOVF   2D,W
16298:  SUBLW  30
1629A:  BNC   162A4
1629C:  DECFSZ 2F,W
1629E:  BRA    162A4
162A0:  MOVF   30,F
162A2:  BZ    162C2
162A4:  MOVF   2E,F
162A6:  BNZ   162AE
162A8:  MOVF   2D,W
162AA:  SUBLW  01
162AC:  BC    162D8
162AE:  MOVF   2E,F
162B0:  BNZ   162D8
162B2:  MOVF   2D,W
162B4:  SUBLW  32
162B6:  BNC   162D8
162B8:  MOVF   2F,W
162BA:  SUBLW  03
162BC:  BNZ   162D8
162BE:  MOVF   30,F
162C0:  BNZ   162D8
....................             { 
....................                write16(ADDR_PORT, nv_port);             
162C2:  MOVLW  24
162C4:  MOVLB  8
162C6:  MOVWF  xCB
162C8:  MOVFF  2E,8CD
162CC:  MOVFF  2D,8CC
162D0:  MOVLB  0
162D2:  CALL   4F4C
....................             } 
162D6:  BRA    162DA
....................             else disable_interrupts (INT_EXT); 
162D8:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
162DA:  DECFSZ 4C,W
162DC:  BRA    16300
....................          { 
....................             disable_interrupts (INT_EXT); 
162DE:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
162E0:  CLRF   32
162E2:  MOVLW  01
162E4:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
162E6:  MOVLW  02
162E8:  MOVLB  8
162EA:  MOVWF  x66
162EC:  MOVFF  31,867
162F0:  MOVLB  0
162F2:  CALL   3390
....................             busy_clear(); 
162F6:  CALL   ADA2
....................             return (user_quit); 
162FA:  MOVFF  4C,01
162FE:  BRA    1636A
....................          } 
....................           
....................          motor_sleep_rdy(); 
16300:  CALL   2916
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16304:  MOVLW  01
16306:  MOVWF  1E
16308:  MOVLW  A3
1630A:  MOVWF  1D
1630C:  MOVLW  DA
1630E:  MOVWF  FF6
16310:  MOVLW  22
16312:  MOVWF  FF7
16314:  MOVLW  00
16316:  MOVWF  FF8
16318:  MOVLW  14
1631A:  MOVLB  8
1631C:  MOVWF  xC8
1631E:  MOVLB  0
16320:  CALL   A9FA
16324:  MOVLW  10
16326:  MOVWF  FE9
16328:  MOVFF  22,8D4
1632C:  MOVFF  21,8D3
16330:  CALL   AA2C
16334:  MOVLW  F1
16336:  MOVWF  FF6
16338:  MOVLW  22
1633A:  MOVWF  FF7
1633C:  MOVLW  00
1633E:  MOVWF  FF8
16340:  MOVLW  0C
16342:  MOVLB  8
16344:  MOVWF  xC8
16346:  MOVLB  0
16348:  CALL   A9FA
....................          record_event();  
1634C:  CALL   8410
....................           
....................          if (macro_end == ';') 
16350:  MOVLB  8
16352:  MOVF   x64,W
16354:  SUBLW  3B
16356:  BNZ   1635A
....................          { 
....................             disable_interrupts (INT_EXT); 
16358:  BCF    FF2.4
1635A:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
1635C:  CALL   159F2
16360:  BRA    16186
....................    } 
....................    busy_clear(); 
16362:  CALL   ADA2
....................    return (user_quit); 
16366:  MOVFF  4C,01
1636A:  GOTO   168B6 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
164F2:  MOVF   24,W
164F4:  SUBWF  36,W
164F6:  BTFSS  FD8.0
164F8:  BRA    166B2
164FA:  BNZ   16504
164FC:  MOVF   23,W
164FE:  SUBWF  35,W
16500:  BTFSS  FD8.0
16502:  BRA    166B2
....................       { 
....................          nv_elapsed = 0; 
16504:  CLRF   36
16506:  CLRF   35
....................  
....................          init_hardware(); 
16508:  CALL   28B8
....................          sd_status = init_sdcard(); 
1650C:  CALL   4FB2
16510:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
16514:  MOVLB  2
16516:  MOVF   xD8,F
16518:  BZ    16522
1651A:  MOVLB  0
1651C:  CALL   4FF8
16520:  MOVLB  2
....................  
....................          ++nv_sample; 
16522:  INCF   21,F
16524:  BTFSC  FD8.2
16526:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
16528:  MOVLW  40
1652A:  BTFSS  F9E.4
1652C:  BRA    1652A
1652E:  MOVWF  FAD
16530:  MOVLW  53
16532:  BTFSS  F9E.4
16534:  BRA    16532
16536:  MOVWF  FAD
16538:  MOVLW  09
1653A:  MOVWF  FE9
1653C:  CLRF   1B
1653E:  BTFSC  FF2.7
16540:  BSF    1B.7
16542:  BCF    FF2.7
16544:  MOVFF  22,A19
16548:  MOVFF  21,A18
1654C:  MOVLB  0
1654E:  CALL   1188
16552:  BTFSC  1B.7
16554:  BSF    FF2.7
16556:  MOVLW  0D
16558:  BTFSS  F9E.4
1655A:  BRA    16558
1655C:  MOVWF  FAD
1655E:  MOVLW  0A
16560:  BTFSS  F9E.4
16562:  BRA    16560
16564:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16566:  MOVLW  01
16568:  MOVWF  1E
1656A:  MOVLW  A3
1656C:  MOVWF  1D
1656E:  MOVLW  FE
16570:  MOVWF  FF6
16572:  MOVLW  22
16574:  MOVWF  FF7
16576:  MOVLW  00
16578:  MOVWF  FF8
1657A:  MOVLW  14
1657C:  MOVLB  8
1657E:  MOVWF  xC8
16580:  MOVLB  0
16582:  CALL   A9FA
16586:  MOVLW  10
16588:  MOVWF  FE9
1658A:  MOVFF  22,8D4
1658E:  MOVFF  21,8D3
16592:  CALL   AA2C
16596:  MOVLW  15
16598:  MOVWF  FF6
1659A:  MOVLW  23
1659C:  MOVWF  FF7
1659E:  MOVLW  00
165A0:  MOVWF  FF8
165A2:  MOVLW  09
165A4:  MOVLB  8
165A6:  MOVWF  xC8
165A8:  MOVLB  0
165AA:  CALL   A9FA
....................          record_event();   
165AE:  CALL   8410
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
165B2:  MOVLW  16
165B4:  MOVLB  8
165B6:  MOVWF  xCB
165B8:  MOVFF  22,8CD
165BC:  MOVFF  21,8CC
165C0:  MOVLB  0
165C2:  CALL   4F4C
....................  
....................          macro_end = master_macro_aws(nv_sample); 
165C6:  MOVFF  22,86A
165CA:  MOVFF  21,869
165CE:  RCALL  1636E
165D0:  MOVFF  01,864
....................           
....................          if (user_quit == TRUE) 
165D4:  DECFSZ 4C,W
165D6:  BRA    165FA
....................          { 
....................             disable_interrupts (INT_EXT); 
165D8:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
165DA:  CLRF   32
165DC:  MOVLW  01
165DE:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
165E0:  MOVLW  02
165E2:  MOVLB  8
165E4:  MOVWF  x66
165E6:  MOVFF  31,867
165EA:  MOVLB  0
165EC:  CALL   3390
....................             busy_clear(); 
165F0:  CALL   ADA2
....................             return (user_quit); 
165F4:  MOVFF  4C,01
165F8:  BRA    166C4
....................          } 
....................           
....................          motor_sleep_rdy(); 
165FA:  CALL   2916
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
165FE:  MOVLW  01
16600:  MOVWF  1E
16602:  MOVLW  A3
16604:  MOVWF  1D
16606:  MOVLW  20
16608:  MOVWF  FF6
1660A:  MOVLW  23
1660C:  MOVWF  FF7
1660E:  MOVLW  00
16610:  MOVWF  FF8
16612:  MOVLW  14
16614:  MOVLB  8
16616:  MOVWF  xC8
16618:  MOVLB  0
1661A:  CALL   A9FA
1661E:  MOVLW  10
16620:  MOVWF  FE9
16622:  MOVFF  22,8D4
16626:  MOVFF  21,8D3
1662A:  CALL   AA2C
1662E:  MOVLW  37
16630:  MOVWF  FF6
16632:  MOVLW  23
16634:  MOVWF  FF7
16636:  MOVLW  00
16638:  MOVWF  FF8
1663A:  MOVLW  0C
1663C:  MOVLB  8
1663E:  MOVWF  xC8
16640:  MOVLB  0
16642:  CALL   A9FA
....................          record_event();  
16646:  CALL   8410
....................           
....................          if (macro_end == ';') 
1664A:  MOVLB  8
1664C:  MOVF   x64,W
1664E:  SUBLW  3B
16650:  BNZ   16654
....................          { 
....................             disable_interrupts (INT_EXT); 
16652:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16654:  MOVF   28,W
16656:  SUBWF  22,W
16658:  BNC   166B4
1665A:  BNZ   16662
1665C:  MOVF   27,W
1665E:  SUBWF  21,W
16660:  BNC   166B4
....................          { 
....................             disable_interrupts (INT_EXT); 
16662:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16664:  MOVLW  01
16666:  MOVWF  1E
16668:  MOVLW  A3
1666A:  MOVWF  1D
1666C:  MOVLW  44
1666E:  MOVWF  FF6
16670:  MOVLW  23
16672:  MOVWF  FF7
16674:  MOVLW  00
16676:  MOVWF  FF8
16678:  MOVLW  14
1667A:  MOVWF  xC8
1667C:  MOVLB  0
1667E:  CALL   A9FA
16682:  MOVLW  10
16684:  MOVWF  FE9
16686:  MOVFF  22,8D4
1668A:  MOVFF  21,8D3
1668E:  CALL   AA2C
16692:  MOVLW  5B
16694:  MOVWF  FF6
16696:  MOVLW  23
16698:  MOVWF  FF7
1669A:  MOVLW  00
1669C:  MOVWF  FF8
1669E:  MOVLW  0F
166A0:  MOVLB  8
166A2:  MOVWF  xC8
166A4:  MOVLB  0
166A6:  CALL   A9FA
....................             record_event();   
166AA:  CALL   8410
....................             msg_max(); 
166AE:  CALL   15D4E
166B2:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
166B4:  MOVLB  0
166B6:  CALL   159F2
166BA:  BRA    164F2
....................    } 
....................    busy_clear(); 
166BC:  CALL   ADA2
....................    return (user_quit); 
166C0:  MOVFF  4C,01
166C4:  GOTO   168BE (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
166C8:  CALL   293E
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
166CC:  MOVLW  01
166CE:  MOVWF  1E
166D0:  MOVLW  A3
166D2:  MOVWF  1D
166D4:  MOVLW  6C
166D6:  MOVWF  FF6
166D8:  MOVLW  23
166DA:  MOVWF  FF7
166DC:  MOVLW  00
166DE:  MOVWF  FF8
166E0:  CALL   5036
....................    record_event(); 
166E4:  CALL   8410
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
166E8:  MOVLW  01
166EA:  MOVWF  1E
166EC:  MOVLW  A3
166EE:  MOVWF  1D
166F0:  MOVLW  86
166F2:  MOVWF  FF6
166F4:  MOVLW  23
166F6:  MOVWF  FF7
166F8:  MOVLW  00
166FA:  MOVWF  FF8
166FC:  MOVLW  0C
166FE:  MOVLB  8
16700:  MOVWF  xC8
16702:  MOVLB  0
16704:  CALL   A9FA
16708:  MOVLW  10
1670A:  MOVWF  FE9
1670C:  MOVFF  26,8D4
16710:  MOVFF  25,8D3
16714:  CALL   AA2C
16718:  MOVLW  95
1671A:  MOVWF  FF6
1671C:  MOVLW  23
1671E:  MOVWF  FF7
16720:  MOVLW  00
16722:  MOVWF  FF8
16724:  MOVLW  06
16726:  MOVLB  8
16728:  MOVWF  xC8
1672A:  MOVLB  0
1672C:  CALL   A9FA
16730:  MOVLW  10
16732:  MOVWF  FE9
16734:  MOVFF  24,8D4
16738:  MOVFF  23,8D3
1673C:  CALL   AA2C
16740:  MOVLW  9E
16742:  MOVWF  FF6
16744:  MOVLW  23
16746:  MOVWF  FF7
16748:  MOVLW  00
1674A:  MOVWF  FF8
1674C:  MOVLW  06
1674E:  MOVLB  8
16750:  MOVWF  xC8
16752:  MOVLB  0
16754:  CALL   A9FA
16758:  MOVLW  10
1675A:  MOVWF  FE9
1675C:  MOVFF  28,8D4
16760:  MOVFF  27,8D3
16764:  CALL   AA2C
16768:  MOVLW  A7
1676A:  MOVWF  FF6
1676C:  MOVLW  23
1676E:  MOVWF  FF7
16770:  MOVLW  00
16772:  MOVWF  FF8
16774:  MOVLW  03
16776:  MOVLB  8
16778:  MOVWF  xC8
1677A:  MOVLB  0
1677C:  CALL   A9FA
....................    record_event(); 
16780:  CALL   8410
....................     
....................    user_quit = FALSE; 
16784:  CLRF   4C
....................     
....................    nv_cmd_mode = FALSE; 
16786:  CLRF   32
16788:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1678A:  MOVLW  02
1678C:  MOVLB  8
1678E:  MOVWF  x66
16790:  MOVFF  31,867
16794:  MOVLB  0
16796:  CALL   3390
....................  
....................    RTC_set_AFE(); 
1679A:  GOTO   15266
....................    // check if start is earlier than now 
....................    RTC_late(); 
1679E:  CALL   152BE
....................    // show clock 
....................    RTC_display(); 
167A2:  CALL   DF82
....................    // show alarm 
....................    RTC_display_alarm(); 
167A6:  CALL   E1E2
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
167AA:  CALL   15778
....................  
....................    if (alarm_passed == FALSE){ 
167AE:  BTFSC  49.3
167B0:  BRA    167B2
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
167B2:  MOVLW  00
167B4:  BTFSC  49.3
167B6:  MOVLW  01
167B8:  MOVLB  8
167BA:  MOVWF  x64
167BC:  MOVLW  01
167BE:  MOVWF  1E
167C0:  MOVLW  A3
167C2:  MOVWF  1D
167C4:  MOVLW  AC
167C6:  MOVWF  FF6
167C8:  MOVLW  23
167CA:  MOVWF  FF7
167CC:  MOVLW  00
167CE:  MOVWF  FF8
167D0:  MOVLW  14
167D2:  MOVWF  xC8
167D4:  MOVLB  0
167D6:  CALL   A9FA
167DA:  MOVLW  10
167DC:  MOVWF  FE9
167DE:  MOVFF  22,8D4
167E2:  MOVFF  21,8D3
167E6:  CALL   AA2C
167EA:  MOVLW  C3
167EC:  MOVWF  FF6
167EE:  MOVLW  23
167F0:  MOVWF  FF7
167F2:  MOVLW  00
167F4:  MOVWF  FF8
167F6:  MOVLW  08
167F8:  MOVLB  8
167FA:  MOVWF  xC8
167FC:  MOVLB  0
167FE:  CALL   A9FA
16802:  MOVFF  864,8CA
16806:  MOVLW  1B
16808:  MOVLB  8
1680A:  MOVWF  xCB
1680C:  MOVLB  0
1680E:  CALL   51F8
16812:  MOVLW  CD
16814:  MOVWF  FF6
16816:  MOVLW  23
16818:  MOVWF  FF7
1681A:  MOVLW  00
1681C:  MOVWF  FF8
1681E:  MOVLW  03
16820:  MOVLB  8
16822:  MOVWF  xC8
16824:  MOVLB  0
16826:  CALL   A9FA
....................    record_event();  
1682A:  CALL   8410
....................  
....................    while (TRUE == RTC_read_flags_running) 
1682E:  BTFSS  49.2
16830:  BRA    16834
....................    { 
....................       ; 
16832:  BRA    1682E
....................    } 
....................    RTC_read_flags_running = TRUE; 
16834:  BSF    49.2
16836:  CLRF   1B
16838:  BTFSC  FF2.7
1683A:  BSF    1B.7
1683C:  BCF    FF2.7
....................    RTC_read_flags(); 
1683E:  CALL   0DCC
16842:  BTFSC  1B.7
16844:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
16846:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
16848:  CALL   2916
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
1684C:  BTFSC  49.3
1684E:  BRA    16870
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
16850:  MOVLW  01
16852:  MOVWF  1E
16854:  MOVLW  A3
16856:  MOVWF  1D
16858:  MOVLW  D2
1685A:  MOVWF  FF6
1685C:  MOVLW  23
1685E:  MOVWF  FF7
16860:  MOVLW  00
16862:  MOVWF  FF8
16864:  CALL   5036
....................       record_event(); 
16868:  CALL   8410
....................       go_to_sleep(); 
1686C:  CALL   159F2
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
16870:  GOTO   15A08
....................    nv_elapsed = nv_interval; 
16874:  MOVFF  24,36
16878:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
1687C:  MOVFF  2F,00
16880:  MOVF   30,W
16882:  MOVWF  03
16884:  BNZ   1688A
16886:  MOVF   00,F
16888:  BZ    168AA
1688A:  MOVF   03,W
1688C:  BNZ   16894
1688E:  MOVLW  01
16890:  SUBWF  00,W
16892:  BZ    168B4
16894:  MOVF   03,W
16896:  BNZ   1689E
16898:  MOVLW  03
1689A:  SUBWF  00,W
1689C:  BZ    168B4
1689E:  MOVF   03,W
168A0:  BNZ   168A8
168A2:  MOVLW  02
168A4:  SUBWF  00,W
168A6:  BZ    168BC
168A8:  BRA    168C2
....................       case ECO: user_quit = auto_sample_eco(); 
168AA:  GOTO   15D6C
168AE:  MOVFF  01,4C
....................          break; 
168B2:  BRA    168C2
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
168B4:  BRA    16186
168B6:  MOVFF  01,4C
....................          break; 
168BA:  BRA    168C2
....................       case AWS: user_quit = auto_sample_aws(); 
168BC:  BRA    164F2
168BE:  MOVFF  01,4C
....................          break;          
....................    } 
....................    return(user_quit); 
168C2:  MOVFF  4C,01
168C6:  GOTO   169BA (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BBF8:  MOVF   44,F
0BBFA:  BNZ   BC08
0BBFC:  MOVF   45,F
0BBFE:  BNZ   BC08
0BC00:  MOVF   46,F
0BC02:  BNZ   BC08
0BC04:  MOVF   47,F
0BC06:  BZ    BC20
0BC08:  MOVF   47,F
0BC0A:  BNZ   BC20
0BC0C:  MOVF   46,F
0BC0E:  BNZ   BC20
0BC10:  MOVF   45,F
0BC12:  BNZ   BC20
0BC14:  MOVF   44,W
0BC16:  SUBLW  02
0BC18:  BNC   BC20
....................       detector = arg; 
0BC1A:  MOVFF  44,2D1
....................    } 
0BC1E:  BRA    BC24
....................    else cmd_arg(); 
0BC20:  CALL   AF66
0BC24:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0BC46:  MOVF   44,F
0BC48:  BNZ   BC56
0BC4A:  MOVF   45,F
0BC4C:  BNZ   BC56
0BC4E:  MOVF   46,F
0BC50:  BNZ   BC56
0BC52:  MOVF   47,F
0BC54:  BZ    BCB0
0BC56:  MOVF   47,F
0BC58:  BNZ   BCB0
0BC5A:  MOVF   46,W
0BC5C:  SUBLW  00
0BC5E:  BNC   BCB0
....................       switch (detector){ 
0BC60:  MOVLB  2
0BC62:  MOVF   xD1,W
0BC64:  XORLW  01
0BC66:  MOVLB  0
0BC68:  BZ    BC70
0BC6A:  XORLW  03
0BC6C:  BZ    BC8E
0BC6E:  BRA    BCAC
....................          case 1 : nv_d1_temp = arg; 
0BC70:  MOVFF  45,3E
0BC74:  MOVFF  44,3D
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0BC78:  MOVLW  40
0BC7A:  MOVLB  8
0BC7C:  MOVWF  xCB
0BC7E:  MOVFF  3E,8CD
0BC82:  MOVFF  3D,8CC
0BC86:  MOVLB  0
0BC88:  CALL   4F4C
....................             break; 
0BC8C:  BRA    BCAE
....................          case 2 : nv_d2_temp = arg; 
0BC8E:  MOVFF  45,40
0BC92:  MOVFF  44,3F
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0BC96:  MOVLW  42
0BC98:  MOVLB  8
0BC9A:  MOVWF  xCB
0BC9C:  MOVFF  40,8CD
0BCA0:  MOVFF  3F,8CC
0BCA4:  MOVLB  0
0BCA6:  CALL   4F4C
....................             break; 
0BCAA:  BRA    BCAE
....................          default : cmd_err(); 
0BCAC:  RCALL  BC28
....................             break; 
....................       } 
....................    } 
0BCAE:  BRA    BD56
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0BCB0:  MOVF   44,F
0BCB2:  BNZ   BD52
0BCB4:  MOVF   45,F
0BCB6:  BNZ   BD52
0BCB8:  MOVF   46,F
0BCBA:  BNZ   BD52
0BCBC:  MOVF   47,F
0BCBE:  BNZ   BD52
0BCC0:  MOVLW  E8
0BCC2:  MOVWF  FF6
0BCC4:  MOVLW  23
0BCC6:  MOVWF  FF7
0BCC8:  MOVLW  00
0BCCA:  MOVWF  FF8
0BCCC:  CLRF   1B
0BCCE:  BTFSC  FF2.7
0BCD0:  BSF    1B.7
0BCD2:  BCF    FF2.7
0BCD4:  MOVLW  03
0BCD6:  MOVLB  A
0BCD8:  MOVWF  x18
0BCDA:  MOVLB  0
0BCDC:  CALL   1006
0BCE0:  BTFSC  1B.7
0BCE2:  BSF    FF2.7
0BCE4:  MOVLW  10
0BCE6:  MOVWF  FE9
0BCE8:  CLRF   1B
0BCEA:  BTFSC  FF2.7
0BCEC:  BSF    1B.7
0BCEE:  BCF    FF2.7
0BCF0:  MOVFF  3E,A19
0BCF4:  MOVFF  3D,A18
0BCF8:  CALL   1188
0BCFC:  BTFSC  1B.7
0BCFE:  BSF    FF2.7
0BD00:  MOVLW  EE
0BD02:  MOVWF  FF6
0BD04:  MOVLW  23
0BD06:  MOVWF  FF7
0BD08:  MOVLW  00
0BD0A:  MOVWF  FF8
0BD0C:  CLRF   1B
0BD0E:  BTFSC  FF2.7
0BD10:  BSF    1B.7
0BD12:  BCF    FF2.7
0BD14:  MOVLW  04
0BD16:  MOVLB  A
0BD18:  MOVWF  x18
0BD1A:  MOVLB  0
0BD1C:  CALL   1006
0BD20:  BTFSC  1B.7
0BD22:  BSF    FF2.7
0BD24:  MOVLW  10
0BD26:  MOVWF  FE9
0BD28:  CLRF   1B
0BD2A:  BTFSC  FF2.7
0BD2C:  BSF    1B.7
0BD2E:  BCF    FF2.7
0BD30:  MOVFF  40,A19
0BD34:  MOVFF  3F,A18
0BD38:  CALL   1188
0BD3C:  BTFSC  1B.7
0BD3E:  BSF    FF2.7
0BD40:  MOVLW  0D
0BD42:  BTFSS  F9E.4
0BD44:  BRA    BD42
0BD46:  MOVWF  FAD
0BD48:  MOVLW  0A
0BD4A:  BTFSS  F9E.4
0BD4C:  BRA    BD4A
0BD4E:  MOVWF  FAD
0BD50:  BRA    BD56
....................    else cmd_arg(); 
0BD52:  CALL   AF66
0BD56:  GOTO   BDBC (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0BD5A:  MOVF   47,F
0BD5C:  BNZ   BD8A
0BD5E:  MOVF   46,F
0BD60:  BNZ   BD8A
0BD62:  MOVF   45,F
0BD64:  BNZ   BD8A
0BD66:  MOVF   44,W
0BD68:  SUBLW  01
0BD6A:  BNC   BD8A
....................       nv_macro_mode = arg; 
0BD6C:  MOVFF  45,2A
0BD70:  MOVFF  44,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0BD74:  MOVLW  20
0BD76:  MOVLB  8
0BD78:  MOVWF  xCB
0BD7A:  MOVFF  2A,8CD
0BD7E:  MOVFF  29,8CC
0BD82:  MOVLB  0
0BD84:  CALL   4F4C
....................    } 
0BD88:  BRA    BD8E
....................    else cmd_arg(); 
0BD8A:  CALL   AF66
0BD8E:  GOTO   BDBC (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0BD92:  MOVF   2F,W
0BD94:  MOVWF  00
0BD96:  MOVF   30,W
0BD98:  MOVWF  03
0BD9A:  BNZ   BDA0
0BD9C:  MOVF   00,F
0BD9E:  BZ    BDB6
0BDA0:  MOVF   03,W
0BDA2:  BNZ   BDAA
0BDA4:  MOVLW  01
0BDA6:  SUBWF  00,W
0BDA8:  BZ    BDBA
0BDAA:  MOVF   03,W
0BDAC:  BNZ   BDB4
0BDAE:  MOVLW  03
0BDB0:  SUBWF  00,W
0BDB2:  BZ    BDBA
0BDB4:  BRA    BDBC
....................       case ECO : commandAe(); 
0BDB6:  BRA    BC46
....................          break; 
0BDB8:  BRA    BDBC
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0BDBA:  BRA    BD5A
....................          break; 
....................    } 
0BDBC:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0BDC0:  MOVF   44,F
0BDC2:  BNZ   BDD0
0BDC4:  MOVF   45,F
0BDC6:  BNZ   BDD0
0BDC8:  MOVF   46,F
0BDCA:  BNZ   BDD0
0BDCC:  MOVF   47,F
0BDCE:  BZ    BE00
0BDD0:  MOVF   47,F
0BDD2:  BNZ   BE00
0BDD4:  MOVF   46,F
0BDD6:  BNZ   BE00
0BDD8:  MOVF   45,F
0BDDA:  BNZ   BE00
0BDDC:  MOVF   44,W
0BDDE:  SUBLW  03
0BDE0:  BNC   BE00
....................       nv_det_type = arg; 
0BDE2:  MOVFF  45,42
0BDE6:  MOVFF  44,41
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0BDEA:  MOVLW  26
0BDEC:  MOVLB  8
0BDEE:  MOVWF  xCB
0BDF0:  MOVFF  42,8CD
0BDF4:  MOVFF  41,8CC
0BDF8:  MOVLB  0
0BDFA:  CALL   4F4C
....................    } 
0BDFE:  BRA    BE66
....................    else if(arg==0) { 
0BE00:  MOVF   44,F
0BE02:  BNZ   BE62
0BE04:  MOVF   45,F
0BE06:  BNZ   BE62
0BE08:  MOVF   46,F
0BE0A:  BNZ   BE62
0BE0C:  MOVF   47,F
0BE0E:  BNZ   BE62
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0BE10:  MOVLW  F8
0BE12:  MOVWF  FF6
0BE14:  MOVLW  23
0BE16:  MOVWF  FF7
0BE18:  MOVLW  00
0BE1A:  MOVWF  FF8
0BE1C:  CLRF   1B
0BE1E:  BTFSC  FF2.7
0BE20:  BSF    1B.7
0BE22:  BCF    FF2.7
0BE24:  MOVLW  05
0BE26:  MOVLB  A
0BE28:  MOVWF  x18
0BE2A:  MOVLB  0
0BE2C:  CALL   1006
0BE30:  BTFSC  1B.7
0BE32:  BSF    FF2.7
0BE34:  MOVLW  10
0BE36:  MOVWF  FE9
0BE38:  CLRF   1B
0BE3A:  BTFSC  FF2.7
0BE3C:  BSF    1B.7
0BE3E:  BCF    FF2.7
0BE40:  MOVFF  42,A19
0BE44:  MOVFF  41,A18
0BE48:  CALL   1188
0BE4C:  BTFSC  1B.7
0BE4E:  BSF    FF2.7
0BE50:  MOVLW  0D
0BE52:  BTFSS  F9E.4
0BE54:  BRA    BE52
0BE56:  MOVWF  FAD
0BE58:  MOVLW  0A
0BE5A:  BTFSS  F9E.4
0BE5C:  BRA    BE5A
0BE5E:  MOVWF  FAD
....................    } 
0BE60:  BRA    BE66
....................    else cmd_arg(); 
0BE62:  CALL   AF66
0BE66:  GOTO   BF28 (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0BED8:  MOVF   47,F
0BEDA:  BNZ   BEF6
0BEDC:  MOVF   46,F
0BEDE:  BNZ   BEF6
0BEE0:  MOVF   45,F
0BEE2:  BNZ   BEF6
0BEE4:  MOVF   44,W
0BEE6:  SUBLW  03
0BEE8:  BNC   BEF6
....................       hb_cmd=arg; 
0BEEA:  MOVFF  44,862
....................       h_bridge(hb_cmd); 
0BEEE:  MOVFF  862,892
0BEF2:  RCALL  BEB8
....................    } 
0BEF4:  BRA    BEFA
....................    else cmd_arg(); 
0BEF6:  CALL   AF66
0BEFA:  GOTO   BF28 (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0BEFE:  MOVF   2F,W
0BF00:  MOVWF  00
0BF02:  MOVF   30,W
0BF04:  MOVWF  03
0BF06:  BNZ   BF0C
0BF08:  MOVF   00,F
0BF0A:  BZ    BF22
0BF0C:  MOVF   03,W
0BF0E:  BNZ   BF16
0BF10:  MOVLW  01
0BF12:  SUBWF  00,W
0BF14:  BZ    BF26
0BF16:  MOVF   03,W
0BF18:  BNZ   BF20
0BF1A:  MOVLW  03
0BF1C:  SUBWF  00,W
0BF1E:  BZ    BF26
0BF20:  BRA    BF28
....................       case ECO : commandBe(); 
0BF22:  BRA    BDC0
....................          break; 
0BF24:  BRA    BF28
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0BF26:  BRA    BED8
....................          break; 
....................    } 
0BF28:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CAB8:  MOVF   44,W
0CABA:  MOVWF  00
0CABC:  MOVF   45,W
0CABE:  MOVWF  03
0CAC0:  BNZ   CAC6
0CAC2:  MOVF   00,F
0CAC4:  BZ    CB28
0CAC6:  MOVF   03,W
0CAC8:  BNZ   CAD2
0CACA:  MOVLW  01
0CACC:  SUBWF  00,W
0CACE:  BTFSC  FD8.2
0CAD0:  BRA    CD16
0CAD2:  MOVF   03,W
0CAD4:  BNZ   CADE
0CAD6:  MOVLW  02
0CAD8:  SUBWF  00,W
0CADA:  BTFSC  FD8.2
0CADC:  BRA    CD72
0CADE:  MOVF   03,W
0CAE0:  BNZ   CAEA
0CAE2:  MOVLW  03
0CAE4:  SUBWF  00,W
0CAE6:  BTFSC  FD8.2
0CAE8:  BRA    CDCE
0CAEA:  MOVF   03,W
0CAEC:  BNZ   CAF6
0CAEE:  MOVLW  04
0CAF0:  SUBWF  00,W
0CAF2:  BTFSC  FD8.2
0CAF4:  BRA    CE2A
0CAF6:  MOVF   03,W
0CAF8:  BNZ   CB02
0CAFA:  MOVLW  05
0CAFC:  SUBWF  00,W
0CAFE:  BTFSC  FD8.2
0CB00:  BRA    CE86
0CB02:  MOVF   03,W
0CB04:  BNZ   CB0E
0CB06:  MOVLW  06
0CB08:  SUBWF  00,W
0CB0A:  BTFSC  FD8.2
0CB0C:  BRA    CEE2
0CB0E:  MOVF   03,W
0CB10:  BNZ   CB1A
0CB12:  MOVLW  07
0CB14:  SUBWF  00,W
0CB16:  BTFSC  FD8.2
0CB18:  BRA    CF3E
0CB1A:  MOVF   03,W
0CB1C:  BNZ   CB26
0CB1E:  MOVLW  08
0CB20:  SUBWF  00,W
0CB22:  BTFSC  FD8.2
0CB24:  BRA    CF9A
0CB26:  BRA    CFF6
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CB28:  MOVLW  04
0CB2A:  MOVWF  FF6
0CB2C:  MOVLW  24
0CB2E:  MOVWF  FF7
0CB30:  MOVLW  00
0CB32:  MOVWF  FF8
0CB34:  CLRF   1B
0CB36:  BTFSC  FF2.7
0CB38:  BSF    1B.7
0CB3A:  BCF    FF2.7
0CB3C:  MOVLW  04
0CB3E:  MOVLB  A
0CB40:  MOVWF  x18
0CB42:  MOVLB  0
0CB44:  CALL   1006
0CB48:  BTFSC  1B.7
0CB4A:  BSF    FF2.7
0CB4C:  MOVLW  89
0CB4E:  MOVWF  FE9
0CB50:  MOVFF  3F4,865
0CB54:  MOVFF  3F3,864
0CB58:  MOVFF  3F2,863
0CB5C:  MOVFF  3F1,862
0CB60:  MOVLW  05
0CB62:  MOVLB  8
0CB64:  MOVWF  x66
0CB66:  MOVLB  0
0CB68:  RCALL  C39C
0CB6A:  MOVLW  2C
0CB6C:  BTFSS  F9E.4
0CB6E:  BRA    CB6C
0CB70:  MOVWF  FAD
0CB72:  MOVLW  89
0CB74:  MOVWF  FE9
0CB76:  MOVFF  3F8,865
0CB7A:  MOVFF  3F7,864
0CB7E:  MOVFF  3F6,863
0CB82:  MOVFF  3F5,862
0CB86:  MOVLW  05
0CB88:  MOVLB  8
0CB8A:  MOVWF  x66
0CB8C:  MOVLB  0
0CB8E:  RCALL  C39C
0CB90:  MOVLW  0D
0CB92:  BTFSS  F9E.4
0CB94:  BRA    CB92
0CB96:  MOVWF  FAD
0CB98:  MOVLW  0A
0CB9A:  BTFSS  F9E.4
0CB9C:  BRA    CB9A
0CB9E:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CBA0:  MOVLW  16
0CBA2:  MOVWF  FF6
0CBA4:  MOVLW  24
0CBA6:  MOVWF  FF7
0CBA8:  MOVLW  00
0CBAA:  MOVWF  FF8
0CBAC:  CLRF   1B
0CBAE:  BTFSC  FF2.7
0CBB0:  BSF    1B.7
0CBB2:  BCF    FF2.7
0CBB4:  MOVLW  04
0CBB6:  MOVLB  A
0CBB8:  MOVWF  x18
0CBBA:  MOVLB  0
0CBBC:  CALL   1006
0CBC0:  BTFSC  1B.7
0CBC2:  BSF    FF2.7
0CBC4:  MOVLW  89
0CBC6:  MOVWF  FE9
0CBC8:  MOVFF  3FC,865
0CBCC:  MOVFF  3FB,864
0CBD0:  MOVFF  3FA,863
0CBD4:  MOVFF  3F9,862
0CBD8:  MOVLW  05
0CBDA:  MOVLB  8
0CBDC:  MOVWF  x66
0CBDE:  MOVLB  0
0CBE0:  CALL   C39C
0CBE4:  MOVLW  2C
0CBE6:  BTFSS  F9E.4
0CBE8:  BRA    CBE6
0CBEA:  MOVWF  FAD
0CBEC:  MOVLW  89
0CBEE:  MOVWF  FE9
0CBF0:  MOVFF  400,865
0CBF4:  MOVFF  3FF,864
0CBF8:  MOVFF  3FE,863
0CBFC:  MOVFF  3FD,862
0CC00:  MOVLW  05
0CC02:  MOVLB  8
0CC04:  MOVWF  x66
0CC06:  MOVLB  0
0CC08:  CALL   C39C
0CC0C:  MOVLW  0D
0CC0E:  BTFSS  F9E.4
0CC10:  BRA    CC0E
0CC12:  MOVWF  FAD
0CC14:  MOVLW  0A
0CC16:  BTFSS  F9E.4
0CC18:  BRA    CC16
0CC1A:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CC1C:  MOVLW  28
0CC1E:  MOVWF  FF6
0CC20:  MOVLW  24
0CC22:  MOVWF  FF7
0CC24:  MOVLW  00
0CC26:  MOVWF  FF8
0CC28:  CLRF   1B
0CC2A:  BTFSC  FF2.7
0CC2C:  BSF    1B.7
0CC2E:  BCF    FF2.7
0CC30:  MOVLW  04
0CC32:  MOVLB  A
0CC34:  MOVWF  x18
0CC36:  MOVLB  0
0CC38:  CALL   1006
0CC3C:  BTFSC  1B.7
0CC3E:  BSF    FF2.7
0CC40:  MOVLW  89
0CC42:  MOVWF  FE9
0CC44:  MOVFF  404,865
0CC48:  MOVFF  403,864
0CC4C:  MOVFF  402,863
0CC50:  MOVFF  401,862
0CC54:  MOVLW  05
0CC56:  MOVLB  8
0CC58:  MOVWF  x66
0CC5A:  MOVLB  0
0CC5C:  CALL   C39C
0CC60:  MOVLW  2C
0CC62:  BTFSS  F9E.4
0CC64:  BRA    CC62
0CC66:  MOVWF  FAD
0CC68:  MOVLW  89
0CC6A:  MOVWF  FE9
0CC6C:  MOVFF  408,865
0CC70:  MOVFF  407,864
0CC74:  MOVFF  406,863
0CC78:  MOVFF  405,862
0CC7C:  MOVLW  05
0CC7E:  MOVLB  8
0CC80:  MOVWF  x66
0CC82:  MOVLB  0
0CC84:  CALL   C39C
0CC88:  MOVLW  0D
0CC8A:  BTFSS  F9E.4
0CC8C:  BRA    CC8A
0CC8E:  MOVWF  FAD
0CC90:  MOVLW  0A
0CC92:  BTFSS  F9E.4
0CC94:  BRA    CC92
0CC96:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CC98:  MOVLW  3A
0CC9A:  MOVWF  FF6
0CC9C:  MOVLW  24
0CC9E:  MOVWF  FF7
0CCA0:  MOVLW  00
0CCA2:  MOVWF  FF8
0CCA4:  CLRF   1B
0CCA6:  BTFSC  FF2.7
0CCA8:  BSF    1B.7
0CCAA:  BCF    FF2.7
0CCAC:  MOVLW  05
0CCAE:  MOVLB  A
0CCB0:  MOVWF  x18
0CCB2:  MOVLB  0
0CCB4:  CALL   1006
0CCB8:  BTFSC  1B.7
0CCBA:  BSF    FF2.7
0CCBC:  MOVLW  89
0CCBE:  MOVWF  FE9
0CCC0:  MOVFF  40C,865
0CCC4:  MOVFF  40B,864
0CCC8:  MOVFF  40A,863
0CCCC:  MOVFF  409,862
0CCD0:  MOVLW  05
0CCD2:  MOVLB  8
0CCD4:  MOVWF  x66
0CCD6:  MOVLB  0
0CCD8:  CALL   C39C
0CCDC:  MOVLW  2C
0CCDE:  BTFSS  F9E.4
0CCE0:  BRA    CCDE
0CCE2:  MOVWF  FAD
0CCE4:  MOVLW  89
0CCE6:  MOVWF  FE9
0CCE8:  MOVFF  410,865
0CCEC:  MOVFF  40F,864
0CCF0:  MOVFF  40E,863
0CCF4:  MOVFF  40D,862
0CCF8:  MOVLW  05
0CCFA:  MOVLB  8
0CCFC:  MOVWF  x66
0CCFE:  MOVLB  0
0CD00:  CALL   C39C
0CD04:  MOVLW  0D
0CD06:  BTFSS  F9E.4
0CD08:  BRA    CD06
0CD0A:  MOVWF  FAD
0CD0C:  MOVLW  0A
0CD0E:  BTFSS  F9E.4
0CD10:  BRA    CD0E
0CD12:  MOVWF  FAD
....................                   break; 
0CD14:  BRA    CFFA
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0CD16:  MOVLW  4E
0CD18:  MOVWF  FF6
0CD1A:  MOVLW  24
0CD1C:  MOVWF  FF7
0CD1E:  MOVLW  00
0CD20:  MOVWF  FF8
0CD22:  CLRF   1B
0CD24:  BTFSC  FF2.7
0CD26:  BSF    1B.7
0CD28:  BCF    FF2.7
0CD2A:  CALL   0E30
0CD2E:  BTFSC  1B.7
0CD30:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0CD32:  RCALL  CA04
0CD34:  MOVFF  03,3F4
0CD38:  MOVFF  02,3F3
0CD3C:  MOVFF  01,3F2
0CD40:  MOVFF  00,3F1
....................                fprintf(COM_A,"\r\n");   
0CD44:  MOVLW  0D
0CD46:  BTFSS  F9E.4
0CD48:  BRA    CD46
0CD4A:  MOVWF  FAD
0CD4C:  MOVLW  0A
0CD4E:  BTFSS  F9E.4
0CD50:  BRA    CD4E
0CD52:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0CD54:  MOVLB  8
0CD56:  CLRF   x63
0CD58:  MOVLW  44
0CD5A:  MOVWF  x62
0CD5C:  MOVFF  3F4,867
0CD60:  MOVFF  3F3,866
0CD64:  MOVFF  3F2,865
0CD68:  MOVFF  3F1,864
0CD6C:  MOVLB  0
0CD6E:  RCALL  CA4A
....................          break; 
0CD70:  BRA    CFFA
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0CD72:  MOVLW  56
0CD74:  MOVWF  FF6
0CD76:  MOVLW  24
0CD78:  MOVWF  FF7
0CD7A:  MOVLW  00
0CD7C:  MOVWF  FF8
0CD7E:  CLRF   1B
0CD80:  BTFSC  FF2.7
0CD82:  BSF    1B.7
0CD84:  BCF    FF2.7
0CD86:  CALL   0E30
0CD8A:  BTFSC  1B.7
0CD8C:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0CD8E:  RCALL  CA04
0CD90:  MOVFF  03,3F8
0CD94:  MOVFF  02,3F7
0CD98:  MOVFF  01,3F6
0CD9C:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");  
0CDA0:  MOVLW  0D
0CDA2:  BTFSS  F9E.4
0CDA4:  BRA    CDA2
0CDA6:  MOVWF  FAD
0CDA8:  MOVLW  0A
0CDAA:  BTFSS  F9E.4
0CDAC:  BRA    CDAA
0CDAE:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0CDB0:  MOVLB  8
0CDB2:  CLRF   x63
0CDB4:  MOVLW  48
0CDB6:  MOVWF  x62
0CDB8:  MOVFF  3F8,867
0CDBC:  MOVFF  3F7,866
0CDC0:  MOVFF  3F6,865
0CDC4:  MOVFF  3F5,864
0CDC8:  MOVLB  0
0CDCA:  RCALL  CA4A
....................          break; 
0CDCC:  BRA    CFFA
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0CDCE:  MOVLW  5E
0CDD0:  MOVWF  FF6
0CDD2:  MOVLW  24
0CDD4:  MOVWF  FF7
0CDD6:  MOVLW  00
0CDD8:  MOVWF  FF8
0CDDA:  CLRF   1B
0CDDC:  BTFSC  FF2.7
0CDDE:  BSF    1B.7
0CDE0:  BCF    FF2.7
0CDE2:  CALL   0E30
0CDE6:  BTFSC  1B.7
0CDE8:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0CDEA:  RCALL  CA04
0CDEC:  MOVFF  03,3FC
0CDF0:  MOVFF  02,3FB
0CDF4:  MOVFF  01,3FA
0CDF8:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n"); 
0CDFC:  MOVLW  0D
0CDFE:  BTFSS  F9E.4
0CE00:  BRA    CDFE
0CE02:  MOVWF  FAD
0CE04:  MOVLW  0A
0CE06:  BTFSS  F9E.4
0CE08:  BRA    CE06
0CE0A:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0CE0C:  MOVLB  8
0CE0E:  CLRF   x63
0CE10:  MOVLW  4C
0CE12:  MOVWF  x62
0CE14:  MOVFF  3FC,867
0CE18:  MOVFF  3FB,866
0CE1C:  MOVFF  3FA,865
0CE20:  MOVFF  3F9,864
0CE24:  MOVLB  0
0CE26:  RCALL  CA4A
....................          break; 
0CE28:  BRA    CFFA
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0CE2A:  MOVLW  66
0CE2C:  MOVWF  FF6
0CE2E:  MOVLW  24
0CE30:  MOVWF  FF7
0CE32:  MOVLW  00
0CE34:  MOVWF  FF8
0CE36:  CLRF   1B
0CE38:  BTFSC  FF2.7
0CE3A:  BSF    1B.7
0CE3C:  BCF    FF2.7
0CE3E:  CALL   0E30
0CE42:  BTFSC  1B.7
0CE44:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0CE46:  RCALL  CA04
0CE48:  MOVFF  03,400
0CE4C:  MOVFF  02,3FF
0CE50:  MOVFF  01,3FE
0CE54:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n");  
0CE58:  MOVLW  0D
0CE5A:  BTFSS  F9E.4
0CE5C:  BRA    CE5A
0CE5E:  MOVWF  FAD
0CE60:  MOVLW  0A
0CE62:  BTFSS  F9E.4
0CE64:  BRA    CE62
0CE66:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0CE68:  MOVLB  8
0CE6A:  CLRF   x63
0CE6C:  MOVLW  52
0CE6E:  MOVWF  x62
0CE70:  MOVFF  3F8,867
0CE74:  MOVFF  3F7,866
0CE78:  MOVFF  3F6,865
0CE7C:  MOVFF  3F5,864
0CE80:  MOVLB  0
0CE82:  RCALL  CA4A
....................          break; 
0CE84:  BRA    CFFA
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0CE86:  MOVLW  6E
0CE88:  MOVWF  FF6
0CE8A:  MOVLW  24
0CE8C:  MOVWF  FF7
0CE8E:  MOVLW  00
0CE90:  MOVWF  FF8
0CE92:  CLRF   1B
0CE94:  BTFSC  FF2.7
0CE96:  BSF    1B.7
0CE98:  BCF    FF2.7
0CE9A:  CALL   0E30
0CE9E:  BTFSC  1B.7
0CEA0:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0CEA2:  RCALL  CA04
0CEA4:  MOVFF  03,404
0CEA8:  MOVFF  02,403
0CEAC:  MOVFF  01,402
0CEB0:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");   
0CEB4:  MOVLW  0D
0CEB6:  BTFSS  F9E.4
0CEB8:  BRA    CEB6
0CEBA:  MOVWF  FAD
0CEBC:  MOVLW  0A
0CEBE:  BTFSS  F9E.4
0CEC0:  BRA    CEBE
0CEC2:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0CEC4:  MOVLB  8
0CEC6:  CLRF   x63
0CEC8:  MOVLW  56
0CECA:  MOVWF  x62
0CECC:  MOVFF  404,867
0CED0:  MOVFF  403,866
0CED4:  MOVFF  402,865
0CED8:  MOVFF  401,864
0CEDC:  MOVLB  0
0CEDE:  RCALL  CA4A
....................          break; 
0CEE0:  BRA    CFFA
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0CEE2:  MOVLW  76
0CEE4:  MOVWF  FF6
0CEE6:  MOVLW  24
0CEE8:  MOVWF  FF7
0CEEA:  MOVLW  00
0CEEC:  MOVWF  FF8
0CEEE:  CLRF   1B
0CEF0:  BTFSC  FF2.7
0CEF2:  BSF    1B.7
0CEF4:  BCF    FF2.7
0CEF6:  CALL   0E30
0CEFA:  BTFSC  1B.7
0CEFC:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0CEFE:  RCALL  CA04
0CF00:  MOVFF  03,408
0CF04:  MOVFF  02,407
0CF08:  MOVFF  01,406
0CF0C:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");  
0CF10:  MOVLW  0D
0CF12:  BTFSS  F9E.4
0CF14:  BRA    CF12
0CF16:  MOVWF  FAD
0CF18:  MOVLW  0A
0CF1A:  BTFSS  F9E.4
0CF1C:  BRA    CF1A
0CF1E:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0CF20:  MOVLB  8
0CF22:  CLRF   x63
0CF24:  MOVLW  5A
0CF26:  MOVWF  x62
0CF28:  MOVFF  408,867
0CF2C:  MOVFF  407,866
0CF30:  MOVFF  406,865
0CF34:  MOVFF  405,864
0CF38:  MOVLB  0
0CF3A:  RCALL  CA4A
....................          break; 
0CF3C:  BRA    CFFA
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0CF3E:  MOVLW  7E
0CF40:  MOVWF  FF6
0CF42:  MOVLW  24
0CF44:  MOVWF  FF7
0CF46:  MOVLW  00
0CF48:  MOVWF  FF8
0CF4A:  CLRF   1B
0CF4C:  BTFSC  FF2.7
0CF4E:  BSF    1B.7
0CF50:  BCF    FF2.7
0CF52:  CALL   0E30
0CF56:  BTFSC  1B.7
0CF58:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0CF5A:  RCALL  CA04
0CF5C:  MOVFF  03,40C
0CF60:  MOVFF  02,40B
0CF64:  MOVFF  01,40A
0CF68:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");   
0CF6C:  MOVLW  0D
0CF6E:  BTFSS  F9E.4
0CF70:  BRA    CF6E
0CF72:  MOVWF  FAD
0CF74:  MOVLW  0A
0CF76:  BTFSS  F9E.4
0CF78:  BRA    CF76
0CF7A:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0CF7C:  MOVLB  8
0CF7E:  CLRF   x63
0CF80:  MOVLW  5E
0CF82:  MOVWF  x62
0CF84:  MOVFF  40C,867
0CF88:  MOVFF  40B,866
0CF8C:  MOVFF  40A,865
0CF90:  MOVFF  409,864
0CF94:  MOVLB  0
0CF96:  RCALL  CA4A
....................          break; 
0CF98:  BRA    CFFA
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0CF9A:  MOVLW  88
0CF9C:  MOVWF  FF6
0CF9E:  MOVLW  24
0CFA0:  MOVWF  FF7
0CFA2:  MOVLW  00
0CFA4:  MOVWF  FF8
0CFA6:  CLRF   1B
0CFA8:  BTFSC  FF2.7
0CFAA:  BSF    1B.7
0CFAC:  BCF    FF2.7
0CFAE:  CALL   0E30
0CFB2:  BTFSC  1B.7
0CFB4:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0CFB6:  RCALL  CA04
0CFB8:  MOVFF  03,410
0CFBC:  MOVFF  02,40F
0CFC0:  MOVFF  01,40E
0CFC4:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");  
0CFC8:  MOVLW  0D
0CFCA:  BTFSS  F9E.4
0CFCC:  BRA    CFCA
0CFCE:  MOVWF  FAD
0CFD0:  MOVLW  0A
0CFD2:  BTFSS  F9E.4
0CFD4:  BRA    CFD2
0CFD6:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0CFD8:  MOVLB  8
0CFDA:  CLRF   x63
0CFDC:  MOVLW  62
0CFDE:  MOVWF  x62
0CFE0:  MOVFF  410,867
0CFE4:  MOVFF  40F,866
0CFE8:  MOVFF  40E,865
0CFEC:  MOVFF  40D,864
0CFF0:  MOVLB  0
0CFF2:  RCALL  CA4A
....................          break;         
0CFF4:  BRA    CFFA
....................       default: cmd_arg(); 
0CFF6:  CALL   AF66
....................          break; 
....................    } 
0CFFA:  GOTO   D9F0 (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0D70A:  MOVF   47,F
0D70C:  BNZ   D71C
0D70E:  MOVF   46,F
0D710:  BNZ   D71C
0D712:  MOVF   45,F
0D714:  BNZ   D71C
0D716:  MOVF   44,W
0D718:  SUBLW  01
0D71A:  BC    D76C
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0D71C:  MOVF   47,F
0D71E:  BNZ   D736
0D720:  MOVF   46,F
0D722:  BNZ   D736
0D724:  MOVF   45,F
0D726:  BNZ   D736
0D728:  MOVF   44,W
0D72A:  SUBLW  30
0D72C:  BNC   D736
0D72E:  DECFSZ 2F,W
0D730:  BRA    D736
0D732:  MOVF   30,F
0D734:  BZ    D752
0D736:  MOVF   47,F
0D738:  BNZ   D766
0D73A:  MOVF   46,F
0D73C:  BNZ   D766
0D73E:  MOVF   45,F
0D740:  BNZ   D766
0D742:  MOVF   44,W
0D744:  SUBLW  32
0D746:  BNC   D766
0D748:  MOVF   2F,W
0D74A:  SUBLW  03
0D74C:  BNZ   D766
0D74E:  MOVF   30,F
0D750:  BNZ   D766
....................          port=arg; 
0D752:  MOVFF  45,863
0D756:  MOVFF  44,862
....................          play_wms_hard_macro(port);    
0D75A:  MOVFF  863,867
0D75E:  MOVFF  862,866
0D762:  RCALL  D4FC
....................       } 
0D764:  BRA    D76A
....................       else cmd_arg(); 
0D766:  CALL   AF66
....................    } 
0D76A:  BRA    D770
....................    else cmd_arg(); 
0D76C:  CALL   AF66
0D770:  GOTO   D9F0 (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0D980:  MOVF   44,F
0D982:  BNZ   D990
0D984:  MOVF   45,F
0D986:  BNZ   D990
0D988:  MOVF   46,F
0D98A:  BNZ   D990
0D98C:  MOVF   47,F
0D98E:  BZ    D9AE
0D990:  MOVF   47,F
0D992:  BNZ   D9AE
0D994:  MOVF   46,F
0D996:  BNZ   D9AE
0D998:  MOVF   45,F
0D99A:  BNZ   D9AE
0D99C:  MOVF   44,W
0D99E:  SUBLW  04
0D9A0:  BNC   D9AE
....................       chip=arg; 
0D9A2:  MOVFF  44,862
....................       sol_chip_cmd(chip); 
0D9A6:  MOVFF  862,893
0D9AA:  RCALL  D8B2
....................    } 
0D9AC:  BRA    D9B2
....................    else cmd_arg();    
0D9AE:  CALL   AF66
0D9B2:  GOTO   D9F0 (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0D9B6:  MOVF   2F,W
0D9B8:  MOVWF  00
0D9BA:  MOVF   30,W
0D9BC:  MOVWF  03
0D9BE:  BNZ   D9C4
0D9C0:  MOVF   00,F
0D9C2:  BZ    D9E4
0D9C4:  MOVF   03,W
0D9C6:  BNZ   D9CE
0D9C8:  MOVLW  01
0D9CA:  SUBWF  00,W
0D9CC:  BZ    D9EA
0D9CE:  MOVF   03,W
0D9D0:  BNZ   D9D8
0D9D2:  MOVLW  03
0D9D4:  SUBWF  00,W
0D9D6:  BZ    D9EA
0D9D8:  MOVF   03,W
0D9DA:  BNZ   D9E2
0D9DC:  MOVLW  02
0D9DE:  SUBWF  00,W
0D9E0:  BZ    D9EE
0D9E2:  BRA    D9F0
....................       case ECO : commandCe(); 
0D9E4:  GOTO   CAB8
....................          break; 
0D9E8:  BRA    D9F0
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0D9EA:  BRA    D70A
....................          break; 
0D9EC:  BRA    D9F0
....................       case AWS : commandCa(); 
0D9EE:  BRA    D980
....................          break;          
....................    } 
0D9F0:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0D9F4:  MOVF   44,W
0D9F6:  MOVWF  00
0D9F8:  MOVF   45,W
0D9FA:  MOVWF  03
0D9FC:  BNZ   DA02
0D9FE:  MOVF   00,F
0DA00:  BZ    DA22
0DA02:  MOVF   03,W
0DA04:  BNZ   DA0C
0DA06:  MOVLW  01
0DA08:  SUBWF  00,W
0DA0A:  BZ    DA34
0DA0C:  MOVF   03,W
0DA0E:  BNZ   DA16
0DA10:  MOVLW  02
0DA12:  SUBWF  00,W
0DA14:  BZ    DA56
0DA16:  MOVF   03,W
0DA18:  BNZ   DA20
0DA1A:  MOVLW  03
0DA1C:  SUBWF  00,W
0DA1E:  BZ    DA68
0DA20:  BRA    DA86
....................       case 0 : file_list(file_ptr_raw_all); 
0DA22:  MOVLW  02
0DA24:  MOVLB  8
0DA26:  MOVWF  x67
0DA28:  MOVLW  D9
0DA2A:  MOVWF  x66
0DA2C:  MOVLB  0
0DA2E:  CALL   B78C
....................          break; 
0DA32:  BRA    DA8A
....................       case 1 : file_list(file_ptr_raw_new); 
0DA34:  MOVLW  02
0DA36:  MOVLB  8
0DA38:  MOVWF  x67
0DA3A:  MOVLW  E7
0DA3C:  MOVWF  x66
0DA3E:  MOVLB  0
0DA40:  CALL   B78C
....................                f_unlink(file_ptr_raw_new); 
0DA44:  MOVLW  02
0DA46:  MOVLB  8
0DA48:  MOVWF  x67
0DA4A:  MOVLW  E7
0DA4C:  MOVWF  x66
0DA4E:  MOVLB  0
0DA50:  CALL   B906
....................          break; 
0DA54:  BRA    DA8A
....................       case 2 : file_list(file_ptr_rel_all); 
0DA56:  MOVLW  02
0DA58:  MOVLB  8
0DA5A:  MOVWF  x67
0DA5C:  MOVLW  F5
0DA5E:  MOVWF  x66
0DA60:  MOVLB  0
0DA62:  CALL   B78C
....................          break; 
0DA66:  BRA    DA8A
....................       case 3 : file_list(file_ptr_rel_new); 
0DA68:  MOVLW  03
0DA6A:  MOVLB  8
0DA6C:  MOVWF  x67
0DA6E:  MOVWF  x66
0DA70:  MOVLB  0
0DA72:  CALL   B78C
....................                f_unlink(file_ptr_rel_new); 
0DA76:  MOVLW  03
0DA78:  MOVLB  8
0DA7A:  MOVWF  x67
0DA7C:  MOVWF  x66
0DA7E:  MOVLB  0
0DA80:  CALL   B906
....................          break;  
0DA84:  BRA    DA8A
....................       default : cmd_arg(); 
0DA86:  CALL   AF66
....................          break; 
....................    } 
0DA8A:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DA8E:  MOVF   44,W
0DA90:  MOVWF  00
0DA92:  MOVF   45,W
0DA94:  MOVWF  03
0DA96:  BNZ   DA9C
0DA98:  MOVF   00,F
0DA9A:  BZ    DAA8
0DA9C:  MOVF   03,W
0DA9E:  BNZ   DAA6
0DAA0:  MOVLW  02
0DAA2:  SUBWF  00,W
0DAA4:  BZ    DB22
0DAA6:  BRA    DB9C
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DAA8:  MOVLW  92
0DAAA:  MOVWF  FF6
0DAAC:  MOVLW  24
0DAAE:  MOVWF  FF7
0DAB0:  MOVLW  00
0DAB2:  MOVWF  FF8
0DAB4:  CLRF   1B
0DAB6:  BTFSC  FF2.7
0DAB8:  BSF    1B.7
0DABA:  BCF    FF2.7
0DABC:  CALL   0E30
0DAC0:  BTFSC  1B.7
0DAC2:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DAC4:  CALL   0E1A
0DAC8:  MOVFF  01,862
....................       if(result == 'Y'){ 
0DACC:  MOVLB  8
0DACE:  MOVF   x62,W
0DAD0:  SUBLW  59
0DAD2:  BNZ   DB02
....................       f_unlink(file_ptr_raw_all); 
0DAD4:  MOVLW  02
0DAD6:  MOVWF  x67
0DAD8:  MOVLW  D9
0DADA:  MOVWF  x66
0DADC:  MOVLB  0
0DADE:  CALL   B906
....................       printf("File deleted!\n\r"); 
0DAE2:  MOVLW  CE
0DAE4:  MOVWF  FF6
0DAE6:  MOVLW  24
0DAE8:  MOVWF  FF7
0DAEA:  MOVLW  00
0DAEC:  MOVWF  FF8
0DAEE:  CLRF   1B
0DAF0:  BTFSC  FF2.7
0DAF2:  BSF    1B.7
0DAF4:  BCF    FF2.7
0DAF6:  CALL   0E30
0DAFA:  BTFSC  1B.7
0DAFC:  BSF    FF2.7
....................       }else{ 
0DAFE:  BRA    DB20
0DB00:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DB02:  MOVLW  DE
0DB04:  MOVWF  FF6
0DB06:  MOVLW  24
0DB08:  MOVWF  FF7
0DB0A:  MOVLW  00
0DB0C:  MOVWF  FF8
0DB0E:  CLRF   1B
0DB10:  BTFSC  FF2.7
0DB12:  BSF    1B.7
0DB14:  BCF    FF2.7
0DB16:  MOVLB  0
0DB18:  CALL   0E30
0DB1C:  BTFSC  1B.7
0DB1E:  BSF    FF2.7
....................       } 
....................          break; 
0DB20:  BRA    DBA0
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DB22:  MOVLW  F4
0DB24:  MOVWF  FF6
0DB26:  MOVLW  24
0DB28:  MOVWF  FF7
0DB2A:  MOVLW  00
0DB2C:  MOVWF  FF8
0DB2E:  CLRF   1B
0DB30:  BTFSC  FF2.7
0DB32:  BSF    1B.7
0DB34:  BCF    FF2.7
0DB36:  CALL   0E30
0DB3A:  BTFSC  1B.7
0DB3C:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DB3E:  CALL   0E1A
0DB42:  MOVFF  01,862
....................          if(result == 'Y'){ 
0DB46:  MOVLB  8
0DB48:  MOVF   x62,W
0DB4A:  SUBLW  59
0DB4C:  BNZ   DB7C
....................             f_unlink(file_ptr_rel_all); 
0DB4E:  MOVLW  02
0DB50:  MOVWF  x67
0DB52:  MOVLW  F5
0DB54:  MOVWF  x66
0DB56:  MOVLB  0
0DB58:  CALL   B906
....................             printf("File deleted!\n\r"); 
0DB5C:  MOVLW  38
0DB5E:  MOVWF  FF6
0DB60:  MOVLW  25
0DB62:  MOVWF  FF7
0DB64:  MOVLW  00
0DB66:  MOVWF  FF8
0DB68:  CLRF   1B
0DB6A:  BTFSC  FF2.7
0DB6C:  BSF    1B.7
0DB6E:  BCF    FF2.7
0DB70:  CALL   0E30
0DB74:  BTFSC  1B.7
0DB76:  BSF    FF2.7
....................          }else{ 
0DB78:  BRA    DB9A
0DB7A:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DB7C:  MOVLW  48
0DB7E:  MOVWF  FF6
0DB80:  MOVLW  25
0DB82:  MOVWF  FF7
0DB84:  MOVLW  00
0DB86:  MOVWF  FF8
0DB88:  CLRF   1B
0DB8A:  BTFSC  FF2.7
0DB8C:  BSF    1B.7
0DB8E:  BCF    FF2.7
0DB90:  MOVLB  0
0DB92:  CALL   0E30
0DB96:  BTFSC  1B.7
0DB98:  BSF    FF2.7
....................          } 
....................          break; 
0DB9A:  BRA    DBA0
....................       default : cmd_arg(); 
0DB9C:  CALL   AF66
....................          break;          
....................    } 
0DBA0:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0DD8C:  MOVF   44,W
0DD8E:  SUBLW  95
0DD90:  BNZ   DDA4
0DD92:  MOVF   45,W
0DD94:  SUBLW  15
0DD96:  BNZ   DDA4
0DD98:  MOVF   46,F
0DD9A:  BNZ   DDA4
0DD9C:  MOVF   47,F
0DD9E:  BNZ   DDA4
....................       reset_nv_vars(); 
0DDA0:  BRA    DBA4
....................    } 
0DDA2:  BRA    DDA8
....................    else cmd_arg(); 
0DDA4:  CALL   AF66
0DDA8:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0DDF6:  MOVF   2F,F
0DDF8:  BNZ   DDFE
0DDFA:  MOVF   30,F
0DDFC:  BZ    DE10
0DDFE:  DECFSZ 2F,W
0DE00:  BRA    DE06
0DE02:  MOVF   30,F
0DE04:  BZ    DE10
0DE06:  MOVF   2F,W
0DE08:  SUBLW  03
0DE0A:  BNZ   DE82
0DE0C:  MOVF   30,F
0DE0E:  BNZ   DE82
....................    { 
....................       busy_set(); 
0DE10:  CALL   293E
....................  
....................       switch(arg) 
0DE14:  MOVFF  44,00
0DE18:  MOVF   45,W
0DE1A:  MOVWF  03
0DE1C:  BNZ   DE24
0DE1E:  MOVLW  01
0DE20:  SUBWF  00,W
0DE22:  BZ    DE3A
0DE24:  MOVF   03,W
0DE26:  BNZ   DE2E
0DE28:  MOVLW  02
0DE2A:  SUBWF  00,W
0DE2C:  BZ    DE4A
0DE2E:  MOVF   03,W
0DE30:  BNZ   DE38
0DE32:  MOVLW  03
0DE34:  SUBWF  00,W
0DE36:  BZ    DE74
0DE38:  BRA    DE7A
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0DE3A:  MOVLB  7
0DE3C:  CLRF   x3C
....................             align(0); 
0DE3E:  MOVLB  8
0DE40:  CLRF   x9F
0DE42:  MOVLB  0
0DE44:  CALL   A7EA
....................             break; 
0DE48:  BRA    DE7E
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0DE4A:  MOVF   44,W
0DE4C:  SUBLW  02
0DE4E:  BNZ   DE72
0DE50:  MOVF   45,F
0DE52:  BNZ   DE72
0DE54:  MOVF   46,F
0DE56:  BNZ   DE72
0DE58:  MOVF   47,F
0DE5A:  BNZ   DE72
0DE5C:  MOVF   1F,W
0DE5E:  SUBLW  04
0DE60:  BNZ   DE72
0DE62:  MOVF   20,F
0DE64:  BNZ   DE72
....................             { 
....................                motor=0; 
0DE66:  MOVLB  7
0DE68:  CLRF   x3C
....................                cal_disk(0); 
0DE6A:  MOVLB  8
0DE6C:  CLRF   x62
0DE6E:  MOVLB  0
0DE70:  BRA    DDAC
....................             } 
....................             break; 
0DE72:  BRA    DE7E
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0DE74:  CALL   A98E
....................             break; 
0DE78:  BRA    DE7E
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0DE7A:  CALL   AF66
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0DE7E:  CALL   ADA2
....................    } 
0DE82:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E35C:  DECFSZ 44,W
0E35E:  BRA    E77C
0E360:  MOVF   45,F
0E362:  BTFSS  FD8.2
0E364:  BRA    E77C
0E366:  MOVF   46,F
0E368:  BTFSS  FD8.2
0E36A:  BRA    E77C
0E36C:  MOVF   47,F
0E36E:  BTFSS  FD8.2
0E370:  BRA    E77C
....................       v_supply = read_supply(); 
0E372:  CALL   5074
0E376:  MOVFF  02,863
0E37A:  MOVFF  01,862
....................        
....................       RTC_reset_HT(); 
0E37E:  CALL   3430
....................       RTC_read(); 
0E382:  CALL   32C2
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E386:  MOVLW  5E
0E388:  MOVWF  FF6
0E38A:  MOVLW  25
0E38C:  MOVWF  FF7
0E38E:  MOVLW  00
0E390:  MOVWF  FF8
0E392:  CLRF   1B
0E394:  BTFSC  FF2.7
0E396:  BSF    1B.7
0E398:  BCF    FF2.7
0E39A:  MOVLW  04
0E39C:  MOVLB  A
0E39E:  MOVWF  x18
0E3A0:  MOVLB  0
0E3A2:  CALL   1006
0E3A6:  BTFSC  1B.7
0E3A8:  BSF    FF2.7
0E3AA:  MOVLW  10
0E3AC:  MOVWF  FE9
0E3AE:  CLRF   1B
0E3B0:  BTFSC  FF2.7
0E3B2:  BSF    1B.7
0E3B4:  BCF    FF2.7
0E3B6:  MOVFF  26,A19
0E3BA:  MOVFF  25,A18
0E3BE:  CALL   1188
0E3C2:  BTFSC  1B.7
0E3C4:  BSF    FF2.7
0E3C6:  MOVLW  20
0E3C8:  BTFSS  F9E.4
0E3CA:  BRA    E3C8
0E3CC:  MOVWF  FAD
0E3CE:  MOVLW  49
0E3D0:  BTFSS  F9E.4
0E3D2:  BRA    E3D0
0E3D4:  MOVWF  FAD
0E3D6:  MOVLW  10
0E3D8:  MOVWF  FE9
0E3DA:  CLRF   1B
0E3DC:  BTFSC  FF2.7
0E3DE:  BSF    1B.7
0E3E0:  BCF    FF2.7
0E3E2:  MOVFF  24,A19
0E3E6:  MOVFF  23,A18
0E3EA:  CALL   1188
0E3EE:  BTFSC  1B.7
0E3F0:  BSF    FF2.7
0E3F2:  MOVLW  20
0E3F4:  BTFSS  F9E.4
0E3F6:  BRA    E3F4
0E3F8:  MOVWF  FAD
0E3FA:  MOVLW  4E
0E3FC:  BTFSS  F9E.4
0E3FE:  BRA    E3FC
0E400:  MOVWF  FAD
0E402:  MOVLW  10
0E404:  MOVWF  FE9
0E406:  CLRF   1B
0E408:  BTFSC  FF2.7
0E40A:  BSF    1B.7
0E40C:  BCF    FF2.7
0E40E:  MOVFF  22,A19
0E412:  MOVFF  21,A18
0E416:  CALL   1188
0E41A:  BTFSC  1B.7
0E41C:  BSF    FF2.7
0E41E:  MOVLW  2F
0E420:  BTFSS  F9E.4
0E422:  BRA    E420
0E424:  MOVWF  FAD
0E426:  MOVLW  10
0E428:  MOVWF  FE9
0E42A:  CLRF   1B
0E42C:  BTFSC  FF2.7
0E42E:  BSF    1B.7
0E430:  BCF    FF2.7
0E432:  MOVFF  28,A19
0E436:  MOVFF  27,A18
0E43A:  CALL   1188
0E43E:  BTFSC  1B.7
0E440:  BSF    FF2.7
0E442:  MOVLW  20
0E444:  BTFSS  F9E.4
0E446:  BRA    E444
0E448:  MOVWF  FAD
0E44A:  MOVLW  58
0E44C:  BTFSS  F9E.4
0E44E:  BRA    E44C
0E450:  MOVWF  FAD
0E452:  MOVLW  10
0E454:  MOVWF  FE9
0E456:  CLRF   1B
0E458:  BTFSC  FF2.7
0E45A:  BSF    1B.7
0E45C:  BCF    FF2.7
0E45E:  MOVFF  20,A19
0E462:  MOVFF  1F,A18
0E466:  CALL   1188
0E46A:  BTFSC  1B.7
0E46C:  BSF    FF2.7
0E46E:  MOVLW  20
0E470:  BTFSS  F9E.4
0E472:  BRA    E470
0E474:  MOVWF  FAD
0E476:  MOVLW  55
0E478:  BTFSS  F9E.4
0E47A:  BRA    E478
0E47C:  MOVWF  FAD
0E47E:  CLRF   1B
0E480:  BTFSC  FF2.7
0E482:  BSF    1B.7
0E484:  BCF    FF2.7
0E486:  MOVFF  73C,A18
0E48A:  MOVLW  1B
0E48C:  MOVLB  A
0E48E:  MOVWF  x19
0E490:  MOVLB  0
0E492:  CALL   0F88
0E496:  BTFSC  1B.7
0E498:  BSF    FF2.7
0E49A:  MOVLW  20
0E49C:  BTFSS  F9E.4
0E49E:  BRA    E49C
0E4A0:  MOVWF  FAD
0E4A2:  MOVLW  04
0E4A4:  MOVWF  FE9
0E4A6:  MOVLB  8
0E4A8:  CLRF   x67
0E4AA:  CLRF   x66
0E4AC:  MOVFF  863,865
0E4B0:  MOVFF  862,864
0E4B4:  MOVLW  02
0E4B6:  MOVWF  x68
0E4B8:  MOVLB  0
0E4BA:  RCALL  DE86
0E4BC:  MOVLW  82
0E4BE:  MOVWF  FF6
0E4C0:  MOVLW  25
0E4C2:  MOVWF  FF7
0E4C4:  MOVLW  00
0E4C6:  MOVWF  FF8
0E4C8:  CLRF   1B
0E4CA:  BTFSC  FF2.7
0E4CC:  BSF    1B.7
0E4CE:  BCF    FF2.7
0E4D0:  MOVLW  03
0E4D2:  MOVLB  A
0E4D4:  MOVWF  x18
0E4D6:  MOVLB  0
0E4D8:  CALL   1006
0E4DC:  BTFSC  1B.7
0E4DE:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E4E0:  MOVLW  86
0E4E2:  MOVWF  FF6
0E4E4:  MOVLW  25
0E4E6:  MOVWF  FF7
0E4E8:  MOVLW  00
0E4EA:  MOVWF  FF8
0E4EC:  CLRF   1B
0E4EE:  BTFSC  FF2.7
0E4F0:  BSF    1B.7
0E4F2:  BCF    FF2.7
0E4F4:  MOVLW  09
0E4F6:  MOVLB  A
0E4F8:  MOVWF  x18
0E4FA:  MOVLB  0
0E4FC:  CALL   1006
0E500:  BTFSC  1B.7
0E502:  BSF    FF2.7
0E504:  MOVLW  10
0E506:  MOVWF  FE9
0E508:  CLRF   1B
0E50A:  BTFSC  FF2.7
0E50C:  BSF    1B.7
0E50E:  BCF    FF2.7
0E510:  MOVFF  7C0,A19
0E514:  MOVFF  7BF,A18
0E518:  CALL   1188
0E51C:  BTFSC  1B.7
0E51E:  BSF    FF2.7
0E520:  MOVLW  92
0E522:  MOVWF  FF6
0E524:  MOVLW  25
0E526:  MOVWF  FF7
0E528:  MOVLW  00
0E52A:  MOVWF  FF8
0E52C:  CLRF   1B
0E52E:  BTFSC  FF2.7
0E530:  BSF    1B.7
0E532:  BCF    FF2.7
0E534:  MOVLW  05
0E536:  MOVLB  A
0E538:  MOVWF  x18
0E53A:  MOVLB  0
0E53C:  CALL   1006
0E540:  BTFSC  1B.7
0E542:  BSF    FF2.7
0E544:  MOVLW  10
0E546:  MOVWF  FE9
0E548:  MOVFF  7B2,8CE
0E54C:  MOVFF  7B1,8CD
0E550:  CALL   8F1A
0E554:  MOVLW  0D
0E556:  BTFSS  F9E.4
0E558:  BRA    E556
0E55A:  MOVWF  FAD
0E55C:  MOVLW  0A
0E55E:  BTFSS  F9E.4
0E560:  BRA    E55E
0E562:  MOVWF  FAD
....................       RTC_display(); 
0E564:  RCALL  DF82
....................       if (RTCfmt == 0) 
0E566:  MOVF   4B,F
0E568:  BTFSS  FD8.2
0E56A:  BRA    E670
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E56C:  MOVLW  9E
0E56E:  MOVWF  FF6
0E570:  MOVLW  25
0E572:  MOVWF  FF7
0E574:  MOVLW  00
0E576:  MOVWF  FF8
0E578:  CLRF   1B
0E57A:  BTFSC  FF2.7
0E57C:  BSF    1B.7
0E57E:  BCF    FF2.7
0E580:  MOVLW  05
0E582:  MOVLB  A
0E584:  MOVWF  x18
0E586:  MOVLB  0
0E588:  CALL   1006
0E58C:  BTFSC  1B.7
0E58E:  BSF    FF2.7
0E590:  CLRF   1B
0E592:  BTFSC  FF2.7
0E594:  BSF    1B.7
0E596:  BCF    FF2.7
0E598:  MOVFF  736,A18
0E59C:  MOVLW  01
0E59E:  MOVLB  A
0E5A0:  MOVWF  x19
0E5A2:  MOVLB  0
0E5A4:  CALL   0F88
0E5A8:  BTFSC  1B.7
0E5AA:  BSF    FF2.7
0E5AC:  MOVLW  2F
0E5AE:  BTFSS  F9E.4
0E5B0:  BRA    E5AE
0E5B2:  MOVWF  FAD
0E5B4:  CLRF   1B
0E5B6:  BTFSC  FF2.7
0E5B8:  BSF    1B.7
0E5BA:  BCF    FF2.7
0E5BC:  MOVFF  737,A18
0E5C0:  MOVLW  01
0E5C2:  MOVLB  A
0E5C4:  MOVWF  x19
0E5C6:  MOVLB  0
0E5C8:  CALL   0F88
0E5CC:  BTFSC  1B.7
0E5CE:  BSF    FF2.7
0E5D0:  MOVLW  2F
0E5D2:  BTFSS  F9E.4
0E5D4:  BRA    E5D2
0E5D6:  MOVWF  FAD
0E5D8:  CLRF   1B
0E5DA:  BTFSC  FF2.7
0E5DC:  BSF    1B.7
0E5DE:  BCF    FF2.7
0E5E0:  MOVFF  738,A18
0E5E4:  MOVLW  01
0E5E6:  MOVLB  A
0E5E8:  MOVWF  x19
0E5EA:  MOVLB  0
0E5EC:  CALL   0F88
0E5F0:  BTFSC  1B.7
0E5F2:  BSF    FF2.7
0E5F4:  MOVLW  20
0E5F6:  BTFSS  F9E.4
0E5F8:  BRA    E5F6
0E5FA:  MOVWF  FAD
0E5FC:  CLRF   1B
0E5FE:  BTFSC  FF2.7
0E600:  BSF    1B.7
0E602:  BCF    FF2.7
0E604:  MOVFF  739,A18
0E608:  MOVLW  01
0E60A:  MOVLB  A
0E60C:  MOVWF  x19
0E60E:  MOVLB  0
0E610:  CALL   0F88
0E614:  BTFSC  1B.7
0E616:  BSF    FF2.7
0E618:  MOVLW  3A
0E61A:  BTFSS  F9E.4
0E61C:  BRA    E61A
0E61E:  MOVWF  FAD
0E620:  CLRF   1B
0E622:  BTFSC  FF2.7
0E624:  BSF    1B.7
0E626:  BCF    FF2.7
0E628:  MOVFF  73A,A18
0E62C:  MOVLW  01
0E62E:  MOVLB  A
0E630:  MOVWF  x19
0E632:  MOVLB  0
0E634:  CALL   0F88
0E638:  BTFSC  1B.7
0E63A:  BSF    FF2.7
0E63C:  MOVLW  3A
0E63E:  BTFSS  F9E.4
0E640:  BRA    E63E
0E642:  MOVWF  FAD
0E644:  CLRF   1B
0E646:  BTFSC  FF2.7
0E648:  BSF    1B.7
0E64A:  BCF    FF2.7
0E64C:  MOVFF  73B,A18
0E650:  MOVLW  01
0E652:  MOVLB  A
0E654:  MOVWF  x19
0E656:  MOVLB  0
0E658:  CALL   0F88
0E65C:  BTFSC  1B.7
0E65E:  BSF    FF2.7
0E660:  MOVLW  0D
0E662:  BTFSS  F9E.4
0E664:  BRA    E662
0E666:  MOVWF  FAD
0E668:  MOVLW  0A
0E66A:  BTFSS  F9E.4
0E66C:  BRA    E66A
0E66E:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E670:  DECFSZ 4B,W
0E672:  BRA    E778
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E674:  MOVLW  C4
0E676:  MOVWF  FF6
0E678:  MOVLW  25
0E67A:  MOVWF  FF7
0E67C:  MOVLW  00
0E67E:  MOVWF  FF8
0E680:  CLRF   1B
0E682:  BTFSC  FF2.7
0E684:  BSF    1B.7
0E686:  BCF    FF2.7
0E688:  MOVLW  05
0E68A:  MOVLB  A
0E68C:  MOVWF  x18
0E68E:  MOVLB  0
0E690:  CALL   1006
0E694:  BTFSC  1B.7
0E696:  BSF    FF2.7
0E698:  CLRF   1B
0E69A:  BTFSC  FF2.7
0E69C:  BSF    1B.7
0E69E:  BCF    FF2.7
0E6A0:  MOVFF  737,A18
0E6A4:  MOVLW  01
0E6A6:  MOVLB  A
0E6A8:  MOVWF  x19
0E6AA:  MOVLB  0
0E6AC:  CALL   0F88
0E6B0:  BTFSC  1B.7
0E6B2:  BSF    FF2.7
0E6B4:  MOVLW  2F
0E6B6:  BTFSS  F9E.4
0E6B8:  BRA    E6B6
0E6BA:  MOVWF  FAD
0E6BC:  CLRF   1B
0E6BE:  BTFSC  FF2.7
0E6C0:  BSF    1B.7
0E6C2:  BCF    FF2.7
0E6C4:  MOVFF  736,A18
0E6C8:  MOVLW  01
0E6CA:  MOVLB  A
0E6CC:  MOVWF  x19
0E6CE:  MOVLB  0
0E6D0:  CALL   0F88
0E6D4:  BTFSC  1B.7
0E6D6:  BSF    FF2.7
0E6D8:  MOVLW  2F
0E6DA:  BTFSS  F9E.4
0E6DC:  BRA    E6DA
0E6DE:  MOVWF  FAD
0E6E0:  CLRF   1B
0E6E2:  BTFSC  FF2.7
0E6E4:  BSF    1B.7
0E6E6:  BCF    FF2.7
0E6E8:  MOVFF  738,A18
0E6EC:  MOVLW  01
0E6EE:  MOVLB  A
0E6F0:  MOVWF  x19
0E6F2:  MOVLB  0
0E6F4:  CALL   0F88
0E6F8:  BTFSC  1B.7
0E6FA:  BSF    FF2.7
0E6FC:  MOVLW  20
0E6FE:  BTFSS  F9E.4
0E700:  BRA    E6FE
0E702:  MOVWF  FAD
0E704:  CLRF   1B
0E706:  BTFSC  FF2.7
0E708:  BSF    1B.7
0E70A:  BCF    FF2.7
0E70C:  MOVFF  739,A18
0E710:  MOVLW  01
0E712:  MOVLB  A
0E714:  MOVWF  x19
0E716:  MOVLB  0
0E718:  CALL   0F88
0E71C:  BTFSC  1B.7
0E71E:  BSF    FF2.7
0E720:  MOVLW  3A
0E722:  BTFSS  F9E.4
0E724:  BRA    E722
0E726:  MOVWF  FAD
0E728:  CLRF   1B
0E72A:  BTFSC  FF2.7
0E72C:  BSF    1B.7
0E72E:  BCF    FF2.7
0E730:  MOVFF  73A,A18
0E734:  MOVLW  01
0E736:  MOVLB  A
0E738:  MOVWF  x19
0E73A:  MOVLB  0
0E73C:  CALL   0F88
0E740:  BTFSC  1B.7
0E742:  BSF    FF2.7
0E744:  MOVLW  3A
0E746:  BTFSS  F9E.4
0E748:  BRA    E746
0E74A:  MOVWF  FAD
0E74C:  CLRF   1B
0E74E:  BTFSC  FF2.7
0E750:  BSF    1B.7
0E752:  BCF    FF2.7
0E754:  MOVFF  73B,A18
0E758:  MOVLW  01
0E75A:  MOVLB  A
0E75C:  MOVWF  x19
0E75E:  MOVLB  0
0E760:  CALL   0F88
0E764:  BTFSC  1B.7
0E766:  BSF    FF2.7
0E768:  MOVLW  0D
0E76A:  BTFSS  F9E.4
0E76C:  BRA    E76A
0E76E:  MOVWF  FAD
0E770:  MOVLW  0A
0E772:  BTFSS  F9E.4
0E774:  BRA    E772
0E776:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0E778:  RCALL  E10C
....................       RTC_display_alarm(); 
0E77A:  RCALL  E1E2
....................    } 
0E77C:  GOTO   EF90 (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0E780:  DECFSZ 44,W
0E782:  BRA    EA5A
0E784:  MOVF   45,F
0E786:  BTFSS  FD8.2
0E788:  BRA    EA5A
0E78A:  MOVF   46,F
0E78C:  BTFSS  FD8.2
0E78E:  BRA    EA5A
0E790:  MOVF   47,F
0E792:  BTFSS  FD8.2
0E794:  BRA    EA5A
....................       v_supply = read_supply(); 
0E796:  CALL   5074
0E79A:  MOVFF  02,863
0E79E:  MOVFF  01,862
....................        
....................       RTC_reset_HT(); 
0E7A2:  CALL   3430
....................       RTC_read(); 
0E7A6:  CALL   32C2
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0E7AA:  MOVLW  41
0E7AC:  BTFSS  F9E.4
0E7AE:  BRA    E7AC
0E7B0:  MOVWF  FAD
0E7B2:  MOVLW  10
0E7B4:  MOVWF  FE9
0E7B6:  CLRF   1B
0E7B8:  BTFSC  FF2.7
0E7BA:  BSF    1B.7
0E7BC:  BCF    FF2.7
0E7BE:  MOVFF  2A,A19
0E7C2:  MOVFF  29,A18
0E7C6:  CALL   1188
0E7CA:  BTFSC  1B.7
0E7CC:  BSF    FF2.7
0E7CE:  MOVLW  20
0E7D0:  BTFSS  F9E.4
0E7D2:  BRA    E7D0
0E7D4:  MOVWF  FAD
0E7D6:  MOVLW  49
0E7D8:  BTFSS  F9E.4
0E7DA:  BRA    E7D8
0E7DC:  MOVWF  FAD
0E7DE:  MOVLW  10
0E7E0:  MOVWF  FE9
0E7E2:  CLRF   1B
0E7E4:  BTFSC  FF2.7
0E7E6:  BSF    1B.7
0E7E8:  BCF    FF2.7
0E7EA:  MOVFF  24,A19
0E7EE:  MOVFF  23,A18
0E7F2:  CALL   1188
0E7F6:  BTFSC  1B.7
0E7F8:  BSF    FF2.7
0E7FA:  MOVLW  20
0E7FC:  BTFSS  F9E.4
0E7FE:  BRA    E7FC
0E800:  MOVWF  FAD
0E802:  MOVLW  4C
0E804:  BTFSS  F9E.4
0E806:  BRA    E804
0E808:  MOVWF  FAD
0E80A:  MOVLW  10
0E80C:  MOVWF  FE9
0E80E:  CLRF   1B
0E810:  BTFSC  FF2.7
0E812:  BSF    1B.7
0E814:  BCF    FF2.7
0E816:  MOVFF  2C,A19
0E81A:  MOVFF  2B,A18
0E81E:  CALL   1188
0E822:  BTFSC  1B.7
0E824:  BSF    FF2.7
0E826:  MOVLW  20
0E828:  BTFSS  F9E.4
0E82A:  BRA    E828
0E82C:  MOVWF  FAD
0E82E:  MOVLW  51
0E830:  BTFSS  F9E.4
0E832:  BRA    E830
0E834:  MOVWF  FAD
0E836:  MOVLW  10
0E838:  MOVWF  FE9
0E83A:  CLRF   1B
0E83C:  BTFSC  FF2.7
0E83E:  BSF    1B.7
0E840:  BCF    FF2.7
0E842:  MOVFF  2E,A19
0E846:  MOVFF  2D,A18
0E84A:  CALL   1188
0E84E:  BTFSC  1B.7
0E850:  BSF    FF2.7
0E852:  MOVLW  20
0E854:  BTFSS  F9E.4
0E856:  BRA    E854
0E858:  MOVWF  FAD
0E85A:  MOVLW  53
0E85C:  BTFSS  F9E.4
0E85E:  BRA    E85C
0E860:  MOVWF  FAD
0E862:  MOVLW  10
0E864:  MOVWF  FE9
0E866:  CLRF   1B
0E868:  BTFSC  FF2.7
0E86A:  BSF    1B.7
0E86C:  BCF    FF2.7
0E86E:  MOVFF  22,A19
0E872:  MOVFF  21,A18
0E876:  CALL   1188
0E87A:  BTFSC  1B.7
0E87C:  BSF    FF2.7
0E87E:  MOVLW  20
0E880:  BTFSS  F9E.4
0E882:  BRA    E880
0E884:  MOVWF  FAD
0E886:  MOVLW  04
0E888:  MOVWF  FE9
0E88A:  MOVLB  8
0E88C:  CLRF   x67
0E88E:  CLRF   x66
0E890:  MOVFF  863,865
0E894:  MOVFF  862,864
0E898:  MOVLW  02
0E89A:  MOVWF  x68
0E89C:  MOVLB  0
0E89E:  CALL   DE86
0E8A2:  MOVLW  08
0E8A4:  MOVWF  FF6
0E8A6:  MOVLW  26
0E8A8:  MOVWF  FF7
0E8AA:  MOVLW  00
0E8AC:  MOVWF  FF8
0E8AE:  CLRF   1B
0E8B0:  BTFSC  FF2.7
0E8B2:  BSF    1B.7
0E8B4:  BCF    FF2.7
0E8B6:  MOVLW  03
0E8B8:  MOVLB  A
0E8BA:  MOVWF  x18
0E8BC:  MOVLB  0
0E8BE:  CALL   1006
0E8C2:  BTFSC  1B.7
0E8C4:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E8C6:  MOVLW  0C
0E8C8:  MOVWF  FF6
0E8CA:  MOVLW  26
0E8CC:  MOVWF  FF7
0E8CE:  MOVLW  00
0E8D0:  MOVWF  FF8
0E8D2:  CLRF   1B
0E8D4:  BTFSC  FF2.7
0E8D6:  BSF    1B.7
0E8D8:  BCF    FF2.7
0E8DA:  MOVLW  09
0E8DC:  MOVLB  A
0E8DE:  MOVWF  x18
0E8E0:  MOVLB  0
0E8E2:  CALL   1006
0E8E6:  BTFSC  1B.7
0E8E8:  BSF    FF2.7
0E8EA:  MOVLW  10
0E8EC:  MOVWF  FE9
0E8EE:  CLRF   1B
0E8F0:  BTFSC  FF2.7
0E8F2:  BSF    1B.7
0E8F4:  BCF    FF2.7
0E8F6:  MOVFF  7C0,A19
0E8FA:  MOVFF  7BF,A18
0E8FE:  CALL   1188
0E902:  BTFSC  1B.7
0E904:  BSF    FF2.7
0E906:  MOVLW  18
0E908:  MOVWF  FF6
0E90A:  MOVLW  26
0E90C:  MOVWF  FF7
0E90E:  MOVLW  00
0E910:  MOVWF  FF8
0E912:  CLRF   1B
0E914:  BTFSC  FF2.7
0E916:  BSF    1B.7
0E918:  BCF    FF2.7
0E91A:  MOVLW  05
0E91C:  MOVLB  A
0E91E:  MOVWF  x18
0E920:  MOVLB  0
0E922:  CALL   1006
0E926:  BTFSC  1B.7
0E928:  BSF    FF2.7
0E92A:  MOVLW  10
0E92C:  MOVWF  FE9
0E92E:  MOVFF  7B2,8CE
0E932:  MOVFF  7B1,8CD
0E936:  CALL   8F1A
0E93A:  MOVLW  0D
0E93C:  BTFSS  F9E.4
0E93E:  BRA    E93C
0E940:  MOVWF  FAD
0E942:  MOVLW  0A
0E944:  BTFSS  F9E.4
0E946:  BRA    E944
0E948:  MOVWF  FAD
....................       RTC_display(); 
0E94A:  CALL   DF82
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E94E:  MOVLW  24
0E950:  MOVWF  FF6
0E952:  MOVLW  26
0E954:  MOVWF  FF7
0E956:  MOVLW  00
0E958:  MOVWF  FF8
0E95A:  CLRF   1B
0E95C:  BTFSC  FF2.7
0E95E:  BSF    1B.7
0E960:  BCF    FF2.7
0E962:  MOVLW  05
0E964:  MOVLB  A
0E966:  MOVWF  x18
0E968:  MOVLB  0
0E96A:  CALL   1006
0E96E:  BTFSC  1B.7
0E970:  BSF    FF2.7
0E972:  CLRF   1B
0E974:  BTFSC  FF2.7
0E976:  BSF    1B.7
0E978:  BCF    FF2.7
0E97A:  MOVFF  736,A18
0E97E:  MOVLW  01
0E980:  MOVLB  A
0E982:  MOVWF  x19
0E984:  MOVLB  0
0E986:  CALL   0F88
0E98A:  BTFSC  1B.7
0E98C:  BSF    FF2.7
0E98E:  MOVLW  2F
0E990:  BTFSS  F9E.4
0E992:  BRA    E990
0E994:  MOVWF  FAD
0E996:  CLRF   1B
0E998:  BTFSC  FF2.7
0E99A:  BSF    1B.7
0E99C:  BCF    FF2.7
0E99E:  MOVFF  737,A18
0E9A2:  MOVLW  01
0E9A4:  MOVLB  A
0E9A6:  MOVWF  x19
0E9A8:  MOVLB  0
0E9AA:  CALL   0F88
0E9AE:  BTFSC  1B.7
0E9B0:  BSF    FF2.7
0E9B2:  MOVLW  2F
0E9B4:  BTFSS  F9E.4
0E9B6:  BRA    E9B4
0E9B8:  MOVWF  FAD
0E9BA:  CLRF   1B
0E9BC:  BTFSC  FF2.7
0E9BE:  BSF    1B.7
0E9C0:  BCF    FF2.7
0E9C2:  MOVFF  738,A18
0E9C6:  MOVLW  01
0E9C8:  MOVLB  A
0E9CA:  MOVWF  x19
0E9CC:  MOVLB  0
0E9CE:  CALL   0F88
0E9D2:  BTFSC  1B.7
0E9D4:  BSF    FF2.7
0E9D6:  MOVLW  20
0E9D8:  BTFSS  F9E.4
0E9DA:  BRA    E9D8
0E9DC:  MOVWF  FAD
0E9DE:  CLRF   1B
0E9E0:  BTFSC  FF2.7
0E9E2:  BSF    1B.7
0E9E4:  BCF    FF2.7
0E9E6:  MOVFF  739,A18
0E9EA:  MOVLW  01
0E9EC:  MOVLB  A
0E9EE:  MOVWF  x19
0E9F0:  MOVLB  0
0E9F2:  CALL   0F88
0E9F6:  BTFSC  1B.7
0E9F8:  BSF    FF2.7
0E9FA:  MOVLW  3A
0E9FC:  BTFSS  F9E.4
0E9FE:  BRA    E9FC
0EA00:  MOVWF  FAD
0EA02:  CLRF   1B
0EA04:  BTFSC  FF2.7
0EA06:  BSF    1B.7
0EA08:  BCF    FF2.7
0EA0A:  MOVFF  73A,A18
0EA0E:  MOVLW  01
0EA10:  MOVLB  A
0EA12:  MOVWF  x19
0EA14:  MOVLB  0
0EA16:  CALL   0F88
0EA1A:  BTFSC  1B.7
0EA1C:  BSF    FF2.7
0EA1E:  MOVLW  3A
0EA20:  BTFSS  F9E.4
0EA22:  BRA    EA20
0EA24:  MOVWF  FAD
0EA26:  CLRF   1B
0EA28:  BTFSC  FF2.7
0EA2A:  BSF    1B.7
0EA2C:  BCF    FF2.7
0EA2E:  MOVFF  73B,A18
0EA32:  MOVLW  01
0EA34:  MOVLB  A
0EA36:  MOVWF  x19
0EA38:  MOVLB  0
0EA3A:  CALL   0F88
0EA3E:  BTFSC  1B.7
0EA40:  BSF    FF2.7
0EA42:  MOVLW  0D
0EA44:  BTFSS  F9E.4
0EA46:  BRA    EA44
0EA48:  MOVWF  FAD
0EA4A:  MOVLW  0A
0EA4C:  BTFSS  F9E.4
0EA4E:  BRA    EA4C
0EA50:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EA52:  CALL   E10C
....................       RTC_display_alarm(); 
0EA56:  CALL   E1E2
....................    } 
0EA5A:  GOTO   EF90 (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0ECE8:  DECFSZ 44,W
0ECEA:  BRA    EF50
0ECEC:  MOVF   45,F
0ECEE:  BTFSS  FD8.2
0ECF0:  BRA    EF50
0ECF2:  MOVF   46,F
0ECF4:  BTFSS  FD8.2
0ECF6:  BRA    EF50
0ECF8:  MOVF   47,F
0ECFA:  BTFSS  FD8.2
0ECFC:  BRA    EF50
....................       v_supply = read_supply(); 
0ECFE:  CALL   5074
0ED02:  MOVFF  02,863
0ED06:  MOVFF  01,862
....................        
....................       RTC_reset_HT(); 
0ED0A:  CALL   3430
....................       RTC_read(); 
0ED0E:  CALL   32C2
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0ED12:  MOVLW  49
0ED14:  BTFSS  F9E.4
0ED16:  BRA    ED14
0ED18:  MOVWF  FAD
0ED1A:  MOVLW  10
0ED1C:  MOVWF  FE9
0ED1E:  CLRF   1B
0ED20:  BTFSC  FF2.7
0ED22:  BSF    1B.7
0ED24:  BCF    FF2.7
0ED26:  MOVFF  24,A19
0ED2A:  MOVFF  23,A18
0ED2E:  CALL   1188
0ED32:  BTFSC  1B.7
0ED34:  BSF    FF2.7
0ED36:  MOVLW  20
0ED38:  BTFSS  F9E.4
0ED3A:  BRA    ED38
0ED3C:  MOVWF  FAD
0ED3E:  MOVLW  4E
0ED40:  BTFSS  F9E.4
0ED42:  BRA    ED40
0ED44:  MOVWF  FAD
0ED46:  MOVLW  10
0ED48:  MOVWF  FE9
0ED4A:  CLRF   1B
0ED4C:  BTFSC  FF2.7
0ED4E:  BSF    1B.7
0ED50:  BCF    FF2.7
0ED52:  MOVFF  22,A19
0ED56:  MOVFF  21,A18
0ED5A:  CALL   1188
0ED5E:  BTFSC  1B.7
0ED60:  BSF    FF2.7
0ED62:  MOVLW  2F
0ED64:  BTFSS  F9E.4
0ED66:  BRA    ED64
0ED68:  MOVWF  FAD
0ED6A:  MOVLW  10
0ED6C:  MOVWF  FE9
0ED6E:  CLRF   1B
0ED70:  BTFSC  FF2.7
0ED72:  BSF    1B.7
0ED74:  BCF    FF2.7
0ED76:  MOVFF  28,A19
0ED7A:  MOVFF  27,A18
0ED7E:  CALL   1188
0ED82:  BTFSC  1B.7
0ED84:  BSF    FF2.7
0ED86:  MOVLW  20
0ED88:  BTFSS  F9E.4
0ED8A:  BRA    ED88
0ED8C:  MOVWF  FAD
0ED8E:  MOVLW  50
0ED90:  BTFSS  F9E.4
0ED92:  BRA    ED90
0ED94:  MOVWF  FAD
0ED96:  MOVLW  10
0ED98:  MOVWF  FE9
0ED9A:  CLRF   1B
0ED9C:  BTFSC  FF2.7
0ED9E:  BSF    1B.7
0EDA0:  BCF    FF2.7
0EDA2:  MOVFF  2E,A19
0EDA6:  MOVFF  2D,A18
0EDAA:  CALL   1188
0EDAE:  BTFSC  1B.7
0EDB0:  BSF    FF2.7
0EDB2:  MOVLW  20
0EDB4:  BTFSS  F9E.4
0EDB6:  BRA    EDB4
0EDB8:  MOVWF  FAD
0EDBA:  MOVLW  04
0EDBC:  MOVWF  FE9
0EDBE:  MOVLB  8
0EDC0:  CLRF   x67
0EDC2:  CLRF   x66
0EDC4:  MOVFF  863,865
0EDC8:  MOVFF  862,864
0EDCC:  MOVLW  02
0EDCE:  MOVWF  x68
0EDD0:  MOVLB  0
0EDD2:  CALL   DE86
0EDD6:  MOVLW  62
0EDD8:  MOVWF  FF6
0EDDA:  MOVLW  26
0EDDC:  MOVWF  FF7
0EDDE:  MOVLW  00
0EDE0:  MOVWF  FF8
0EDE2:  CLRF   1B
0EDE4:  BTFSC  FF2.7
0EDE6:  BSF    1B.7
0EDE8:  BCF    FF2.7
0EDEA:  MOVLW  03
0EDEC:  MOVLB  A
0EDEE:  MOVWF  x18
0EDF0:  MOVLB  0
0EDF2:  CALL   1006
0EDF6:  BTFSC  1B.7
0EDF8:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0EDFA:  MOVLW  66
0EDFC:  MOVWF  FF6
0EDFE:  MOVLW  26
0EE00:  MOVWF  FF7
0EE02:  MOVLW  00
0EE04:  MOVWF  FF8
0EE06:  CLRF   1B
0EE08:  BTFSC  FF2.7
0EE0A:  BSF    1B.7
0EE0C:  BCF    FF2.7
0EE0E:  MOVLW  09
0EE10:  MOVLB  A
0EE12:  MOVWF  x18
0EE14:  MOVLB  0
0EE16:  CALL   1006
0EE1A:  BTFSC  1B.7
0EE1C:  BSF    FF2.7
0EE1E:  MOVLW  10
0EE20:  MOVWF  FE9
0EE22:  MOVFF  7B2,8CE
0EE26:  MOVFF  7B1,8CD
0EE2A:  CALL   8F1A
0EE2E:  MOVLW  0D
0EE30:  BTFSS  F9E.4
0EE32:  BRA    EE30
0EE34:  MOVWF  FAD
0EE36:  MOVLW  0A
0EE38:  BTFSS  F9E.4
0EE3A:  BRA    EE38
0EE3C:  MOVWF  FAD
....................       display_valve_status(); 
0EE3E:  RCALL  EA5E
....................       RTC_display(); 
0EE40:  CALL   DF82
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EE44:  MOVLW  76
0EE46:  MOVWF  FF6
0EE48:  MOVLW  26
0EE4A:  MOVWF  FF7
0EE4C:  MOVLW  00
0EE4E:  MOVWF  FF8
0EE50:  CLRF   1B
0EE52:  BTFSC  FF2.7
0EE54:  BSF    1B.7
0EE56:  BCF    FF2.7
0EE58:  MOVLW  05
0EE5A:  MOVLB  A
0EE5C:  MOVWF  x18
0EE5E:  MOVLB  0
0EE60:  CALL   1006
0EE64:  BTFSC  1B.7
0EE66:  BSF    FF2.7
0EE68:  CLRF   1B
0EE6A:  BTFSC  FF2.7
0EE6C:  BSF    1B.7
0EE6E:  BCF    FF2.7
0EE70:  MOVFF  736,A18
0EE74:  MOVLW  01
0EE76:  MOVLB  A
0EE78:  MOVWF  x19
0EE7A:  MOVLB  0
0EE7C:  CALL   0F88
0EE80:  BTFSC  1B.7
0EE82:  BSF    FF2.7
0EE84:  MOVLW  2F
0EE86:  BTFSS  F9E.4
0EE88:  BRA    EE86
0EE8A:  MOVWF  FAD
0EE8C:  CLRF   1B
0EE8E:  BTFSC  FF2.7
0EE90:  BSF    1B.7
0EE92:  BCF    FF2.7
0EE94:  MOVFF  737,A18
0EE98:  MOVLW  01
0EE9A:  MOVLB  A
0EE9C:  MOVWF  x19
0EE9E:  MOVLB  0
0EEA0:  CALL   0F88
0EEA4:  BTFSC  1B.7
0EEA6:  BSF    FF2.7
0EEA8:  MOVLW  2F
0EEAA:  BTFSS  F9E.4
0EEAC:  BRA    EEAA
0EEAE:  MOVWF  FAD
0EEB0:  CLRF   1B
0EEB2:  BTFSC  FF2.7
0EEB4:  BSF    1B.7
0EEB6:  BCF    FF2.7
0EEB8:  MOVFF  738,A18
0EEBC:  MOVLW  01
0EEBE:  MOVLB  A
0EEC0:  MOVWF  x19
0EEC2:  MOVLB  0
0EEC4:  CALL   0F88
0EEC8:  BTFSC  1B.7
0EECA:  BSF    FF2.7
0EECC:  MOVLW  20
0EECE:  BTFSS  F9E.4
0EED0:  BRA    EECE
0EED2:  MOVWF  FAD
0EED4:  CLRF   1B
0EED6:  BTFSC  FF2.7
0EED8:  BSF    1B.7
0EEDA:  BCF    FF2.7
0EEDC:  MOVFF  739,A18
0EEE0:  MOVLW  01
0EEE2:  MOVLB  A
0EEE4:  MOVWF  x19
0EEE6:  MOVLB  0
0EEE8:  CALL   0F88
0EEEC:  BTFSC  1B.7
0EEEE:  BSF    FF2.7
0EEF0:  MOVLW  3A
0EEF2:  BTFSS  F9E.4
0EEF4:  BRA    EEF2
0EEF6:  MOVWF  FAD
0EEF8:  CLRF   1B
0EEFA:  BTFSC  FF2.7
0EEFC:  BSF    1B.7
0EEFE:  BCF    FF2.7
0EF00:  MOVFF  73A,A18
0EF04:  MOVLW  01
0EF06:  MOVLB  A
0EF08:  MOVWF  x19
0EF0A:  MOVLB  0
0EF0C:  CALL   0F88
0EF10:  BTFSC  1B.7
0EF12:  BSF    FF2.7
0EF14:  MOVLW  3A
0EF16:  BTFSS  F9E.4
0EF18:  BRA    EF16
0EF1A:  MOVWF  FAD
0EF1C:  CLRF   1B
0EF1E:  BTFSC  FF2.7
0EF20:  BSF    1B.7
0EF22:  BCF    FF2.7
0EF24:  MOVFF  73B,A18
0EF28:  MOVLW  01
0EF2A:  MOVLB  A
0EF2C:  MOVWF  x19
0EF2E:  MOVLB  0
0EF30:  CALL   0F88
0EF34:  BTFSC  1B.7
0EF36:  BSF    FF2.7
0EF38:  MOVLW  0D
0EF3A:  BTFSS  F9E.4
0EF3C:  BRA    EF3A
0EF3E:  MOVWF  FAD
0EF40:  MOVLW  0A
0EF42:  BTFSS  F9E.4
0EF44:  BRA    EF42
0EF46:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EF48:  CALL   E10C
....................       RTC_display_alarm(); 
0EF4C:  CALL   E1E2
....................    } 
0EF50:  GOTO   EF90 (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0EF54:  MOVF   2F,W
0EF56:  MOVWF  00
0EF58:  MOVF   30,W
0EF5A:  MOVWF  03
0EF5C:  BNZ   EF62
0EF5E:  MOVF   00,F
0EF60:  BZ    EF82
0EF62:  MOVF   03,W
0EF64:  BNZ   EF6C
0EF66:  MOVLW  01
0EF68:  SUBWF  00,W
0EF6A:  BZ    EF88
0EF6C:  MOVF   03,W
0EF6E:  BNZ   EF76
0EF70:  MOVLW  03
0EF72:  SUBWF  00,W
0EF74:  BZ    EF88
0EF76:  MOVF   03,W
0EF78:  BNZ   EF80
0EF7A:  MOVLW  02
0EF7C:  SUBWF  00,W
0EF7E:  BZ    EF8E
0EF80:  BRA    EF90
....................       case ECO : commandHe(); 
0EF82:  GOTO   E35C
....................          break; 
0EF86:  BRA    EF90
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0EF88:  GOTO   E780
....................          break; 
0EF8C:  BRA    EF90
....................       case AWS : commandHa(); 
0EF8E:  BRA    ECE8
....................          break;          
....................    } 
0EF90:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0EF94:  MOVF   44,F
0EF96:  BNZ   EFA4
0EF98:  MOVF   45,F
0EF9A:  BNZ   EFA4
0EF9C:  MOVF   46,F
0EF9E:  BNZ   EFA4
0EFA0:  MOVF   47,F
0EFA2:  BZ    EFD8
0EFA4:  MOVF   47,F
0EFA6:  BNZ   EFD8
0EFA8:  MOVF   46,F
0EFAA:  BNZ   EFD8
0EFAC:  MOVF   45,W
0EFAE:  SUBLW  FD
0EFB0:  BNC   EFD8
0EFB2:  BNZ   EFBA
0EFB4:  MOVF   44,W
0EFB6:  SUBLW  20
0EFB8:  BNC   EFD8
....................       nv_interval = arg; 
0EFBA:  MOVFF  45,24
0EFBE:  MOVFF  44,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0EFC2:  MOVLW  14
0EFC4:  MOVLB  8
0EFC6:  MOVWF  xCB
0EFC8:  MOVFF  24,8CD
0EFCC:  MOVFF  23,8CC
0EFD0:  MOVLB  0
0EFD2:  CALL   4F4C
....................    } 
0EFD6:  BRA    EFDC
....................    else cmd_arg(); 
0EFD8:  CALL   AF66
0EFDC:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0EFE0:  MOVF   47,F
0EFE2:  BNZ   F012
0EFE4:  MOVF   46,F
0EFE6:  BNZ   F012
0EFE8:  MOVF   45,W
0EFEA:  SUBLW  27
0EFEC:  BNC   F012
0EFEE:  BNZ   EFF6
0EFF0:  MOVF   44,W
0EFF2:  SUBLW  0F
0EFF4:  BNC   F012
....................       nv_serial = arg; 
0EFF6:  MOVFF  45,26
0EFFA:  MOVFF  44,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0EFFE:  MOVLB  8
0F000:  CLRF   xCB
0F002:  MOVFF  26,8CD
0F006:  MOVFF  25,8CC
0F00A:  MOVLB  0
0F00C:  CALL   4F4C
....................    } 
0F010:  BRA    F016
....................    else cmd_arg(); 
0F012:  CALL   AF66
0F016:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F23A:  MOVF   2F,F
0F23C:  BNZ   F26C
0F23E:  MOVF   30,F
0F240:  BNZ   F26C
....................        
....................       if (arg > 0 && arg < 3){ 
0F242:  MOVF   44,F
0F244:  BNZ   F252
0F246:  MOVF   45,F
0F248:  BNZ   F252
0F24A:  MOVF   46,F
0F24C:  BNZ   F252
0F24E:  MOVF   47,F
0F250:  BZ    F268
0F252:  MOVF   47,F
0F254:  BNZ   F268
0F256:  MOVF   46,F
0F258:  BNZ   F268
0F25A:  MOVF   45,F
0F25C:  BNZ   F268
0F25E:  MOVF   44,W
0F260:  SUBLW  02
0F262:  BNC   F268
....................          det_cmd(); 
0F264:  RCALL  F0FA
....................       } 
0F266:  BRA    F26C
....................       else cmd_arg(); 
0F268:  CALL   AF66
....................        
....................    } 
0F26C:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
100C8:  MOVF   47,F
100CA:  BNZ   10136
100CC:  MOVF   46,F
100CE:  BNZ   10136
100D0:  MOVF   45,W
100D2:  SUBLW  0F
100D4:  BNC   10136
....................       switch (nv_det_type){ 
100D6:  MOVFF  41,00
100DA:  MOVF   42,W
100DC:  MOVWF  03
100DE:  BNZ   100E6
100E0:  MOVLW  01
100E2:  SUBWF  00,W
100E4:  BZ    100FC
100E6:  MOVF   03,W
100E8:  BNZ   100F0
100EA:  MOVLW  02
100EC:  SUBWF  00,W
100EE:  BZ    10102
100F0:  MOVF   03,W
100F2:  BNZ   100FA
100F4:  MOVLW  03
100F6:  SUBWF  00,W
100F8:  BZ    10120
100FA:  BRA    10134
....................          case 1 : det_cmd(); 
100FC:  CALL   F0FA
....................             break; 
10100:  BRA    10134
....................          case 2 : DAC_set(1,arg); 
10102:  MOVFF  45,863
10106:  MOVFF  44,862
1010A:  MOVLW  01
1010C:  MOVLB  8
1010E:  MOVWF  xB0
10110:  MOVFF  863,8B2
10114:  MOVFF  862,8B1
10118:  MOVLB  0
1011A:  CALL   F270
....................             break; 
1011E:  BRA    10134
....................          case 3 : set_LED(arg); 
10120:  MOVFF  45,863
10124:  MOVFF  44,862
10128:  MOVFF  863,8A3
1012C:  MOVFF  862,8A2
10130:  CALL   F5B0
....................             break; 
....................       } 
....................    } 
10134:  BRA    10194
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
10136:  MOVF   47,F
10138:  BNZ   1014E
1013A:  MOVF   46,F
1013C:  BNZ   1014E
1013E:  MOVF   45,W
10140:  SUBLW  4D
10142:  BC    10178
10144:  XORLW  FF
10146:  BNZ   1014E
10148:  MOVF   44,W
1014A:  SUBLW  20
1014C:  BC    10178
1014E:  MOVF   47,F
10150:  BNZ   10178
10152:  MOVF   46,F
10154:  BNZ   10178
10156:  MOVF   45,W
10158:  SUBLW  4E
1015A:  BNC   10178
1015C:  BNZ   10164
1015E:  MOVF   44,W
10160:  SUBLW  22
10162:  BNC   10178
10164:  MOVFF  45,863
10168:  MOVFF  44,862
1016C:  MOVFF  863,865
10170:  MOVFF  862,864
10174:  BRA    10000
10176:  BRA    10194
....................    else if(arg==30001)set_LED_test(); 
10178:  MOVF   44,W
1017A:  SUBLW  31
1017C:  BNZ   10190
1017E:  MOVF   45,W
10180:  SUBLW  75
10182:  BNZ   10190
10184:  MOVF   46,F
10186:  BNZ   10190
10188:  MOVF   47,F
1018A:  BNZ   10190
1018C:  BRA    FF50
1018E:  BRA    10194
....................    else cmd_arg(); 
10190:  CALL   AF66
10194:  GOTO   101FE (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
10198:  MOVF   47,F
1019A:  BNZ   101CC
1019C:  MOVF   46,F
1019E:  BNZ   101CC
101A0:  MOVF   45,W
101A2:  SUBLW  57
101A4:  BNC   101CC
101A6:  BNZ   101AE
101A8:  MOVF   44,W
101AA:  SUBLW  E4
101AC:  BNC   101CC
....................       nv_volume = arg; 
101AE:  MOVFF  45,2C
101B2:  MOVFF  44,2B
....................       write16(ADDR_VOLUME, nv_volume); 
101B6:  MOVLW  22
101B8:  MOVLB  8
101BA:  MOVWF  xCB
101BC:  MOVFF  2C,8CD
101C0:  MOVFF  2B,8CC
101C4:  MOVLB  0
101C6:  CALL   4F4C
....................    } 
101CA:  BRA    101D0
....................    else cmd_arg(); 
101CC:  CALL   AF66
101D0:  GOTO   101FE (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
101D4:  MOVF   2F,W
101D6:  MOVWF  00
101D8:  MOVF   30,W
101DA:  MOVWF  03
101DC:  BNZ   101E2
101DE:  MOVF   00,F
101E0:  BZ    101F8
101E2:  MOVF   03,W
101E4:  BNZ   101EC
101E6:  MOVLW  01
101E8:  SUBWF  00,W
101EA:  BZ    101FC
101EC:  MOVF   03,W
101EE:  BNZ   101F6
101F0:  MOVLW  03
101F2:  SUBWF  00,W
101F4:  BZ    101FC
101F6:  BRA    101FE
....................       case ECO : commandLe(); 
101F8:  BRA    100C8
....................          break; 
101FA:  BRA    101FE
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
101FC:  BRA    10198
....................          break; 
....................    } 
101FE:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
168CA:  CALL   293E
....................     
....................    user_quit = FALSE; 
168CE:  CLRF   4C
....................     
....................    if(arg > 0 && arg < 21) 
168D0:  MOVF   44,F
168D2:  BNZ   168E0
168D4:  MOVF   45,F
168D6:  BNZ   168E0
168D8:  MOVF   46,F
168DA:  BNZ   168E0
168DC:  MOVF   47,F
168DE:  BZ    1695C
168E0:  MOVF   47,F
168E2:  BNZ   1695C
168E4:  MOVF   46,F
168E6:  BNZ   1695C
168E8:  MOVF   45,F
168EA:  BNZ   1695C
168EC:  MOVF   44,W
168EE:  SUBLW  14
168F0:  BNC   1695C
....................    { 
....................       macro = arg; 
168F2:  MOVFF  44,863
....................       switch(nv_product){ 
168F6:  MOVFF  2F,00
168FA:  MOVF   30,W
168FC:  MOVWF  03
168FE:  BNZ   16904
16900:  MOVF   00,F
16902:  BZ    16924
16904:  MOVF   03,W
16906:  BNZ   1690E
16908:  MOVLW  01
1690A:  SUBWF  00,W
1690C:  BZ    16924
1690E:  MOVF   03,W
16910:  BNZ   16918
16912:  MOVLW  03
16914:  SUBWF  00,W
16916:  BZ    16924
16918:  MOVF   03,W
1691A:  BNZ   16922
1691C:  MOVLW  02
1691E:  SUBWF  00,W
16920:  BZ    1694A
16922:  BRA    1695A
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
16924:  MOVLW  01
16926:  MOVLB  7
16928:  ADDWF  xBF,W
1692A:  MOVLB  8
1692C:  MOVWF  x64
1692E:  MOVLW  00
16930:  MOVLB  7
16932:  ADDWFC xC0,W
16934:  MOVLB  8
16936:  MOVWF  x65
16938:  MOVFF  863,874
1693C:  MOVWF  x76
1693E:  MOVFF  864,875
16942:  MOVLB  0
16944:  CALL   14F00
....................             break; 
16948:  BRA    1695A
....................          case AWS : play_macro(macro,nv_port); 
1694A:  MOVFF  863,874
1694E:  MOVFF  2E,876
16952:  MOVFF  2D,875
16956:  CALL   14F00
....................             break; 
....................       } 
....................    }    
1695A:  BRA    169C4
....................    else if (arg == 0) 
1695C:  MOVF   44,F
1695E:  BNZ   169C0
16960:  MOVF   45,F
16962:  BNZ   169C0
16964:  MOVF   46,F
16966:  BNZ   169C0
16968:  MOVF   47,F
1696A:  BNZ   169C0
....................    { 
....................       MaxSamples=FALSE; 
1696C:  CLRF   34
1696E:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
16970:  MOVLW  28
16972:  MOVLB  8
16974:  MOVWF  x66
16976:  MOVFF  33,867
1697A:  MOVLB  0
1697C:  CALL   3390
....................       if (LoggingReentry != TRUE) 
16980:  MOVLB  8
16982:  DECFSZ x62,W
16984:  BRA    16988
16986:  BRA    169A0
....................       { 
....................          nv_sample = 0; 
16988:  CLRF   22
1698A:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
1698C:  MOVLW  16
1698E:  MOVWF  xCB
16990:  MOVFF  22,8CD
16994:  MOVFF  21,8CC
16998:  MOVLB  0
1699A:  CALL   4F4C
1699E:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
169A0:  CLRF   x62
....................       nv_macro_step = 0; 
169A2:  CLRF   38
169A4:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
169A6:  MOVLW  3A
169A8:  MOVWF  xCB
169AA:  MOVFF  38,8CD
169AE:  MOVFF  37,8CC
169B2:  MOVLB  0
169B4:  CALL   4F4C
....................       user_quit = auto_sample_ready(); 
169B8:  BRA    166C8
169BA:  MOVFF  01,4C
....................    } 
169BE:  BRA    169C4
....................    else cmd_arg(); 
169C0:  CALL   AF66
....................     
....................    busy_clear(); 
169C4:  CALL   ADA2
169C8:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
169CA:  MOVF   44,F
169CC:  BNZ   169DA
169CE:  MOVF   45,F
169D0:  BNZ   169DA
169D2:  MOVF   46,F
169D4:  BNZ   169DA
169D6:  MOVF   47,F
169D8:  BZ    16A0E
169DA:  MOVF   47,F
169DC:  BNZ   16A0E
169DE:  MOVF   46,F
169E0:  BNZ   16A0E
169E2:  MOVF   45,W
169E4:  SUBLW  0D
169E6:  BNC   16A0E
169E8:  BNZ   169F0
169EA:  MOVF   44,W
169EC:  SUBLW  AC
169EE:  BNC   16A0E
....................       nv_max_samples = arg; 
169F0:  MOVFF  45,28
169F4:  MOVFF  44,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
169F8:  MOVLW  18
169FA:  MOVLB  8
169FC:  MOVWF  xCB
169FE:  MOVFF  28,8CD
16A02:  MOVFF  27,8CC
16A06:  MOVLB  0
16A08:  CALL   4F4C
....................    } 
16A0C:  BRA    16A54
....................    else if(arg == 0) { 
16A0E:  MOVF   44,F
16A10:  BNZ   16A50
16A12:  MOVF   45,F
16A14:  BNZ   16A50
16A16:  MOVF   46,F
16A18:  BNZ   16A50
16A1A:  MOVF   47,F
16A1C:  BNZ   16A50
....................       nv_sample = 0; 
16A1E:  CLRF   22
16A20:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
16A22:  MOVLW  16
16A24:  MOVLB  8
16A26:  MOVWF  xCB
16A28:  MOVFF  22,8CD
16A2C:  MOVFF  21,8CC
16A30:  MOVLB  0
16A32:  CALL   4F4C
....................       nv_macro_step = 0; 
16A36:  CLRF   38
16A38:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16A3A:  MOVLW  3A
16A3C:  MOVLB  8
16A3E:  MOVWF  xCB
16A40:  MOVFF  38,8CD
16A44:  MOVFF  37,8CC
16A48:  MOVLB  0
16A4A:  CALL   4F4C
....................    } 
16A4E:  BRA    16A54
....................    else cmd_arg(); 
16A50:  CALL   AF66
16A54:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
16B7A:  DECFSZ 44,W
16B7C:  BRA    16B96
16B7E:  MOVF   45,F
16B80:  BNZ   16B96
16B82:  MOVF   46,F
16B84:  BNZ   16B96
16B86:  MOVF   47,F
16B88:  BNZ   16B96
....................    { 
....................       bus_on(); 
16B8A:  CALL   D06C
....................       open_pipe(); 
16B8E:  BRA    16A70
....................       bus_off(); 
16B90:  CALL   D090
....................    } 
16B94:  BRA    16B9A
....................    else cmd_arg(); 
16B96:  CALL   AF66
16B9A:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
16C58:  MOVLB  7
16C5A:  DECFSZ x3D,W
16C5C:  BRA    16C60
16C5E:  CLRF   x3C
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
16C60:  MOVF   44,F
16C62:  BNZ   16C72
16C64:  MOVF   45,F
16C66:  BNZ   16C72
16C68:  MOVF   46,F
16C6A:  BNZ   16C72
16C6C:  MOVF   47,F
16C6E:  BTFSC  FD8.2
16C70:  BRA    16D3A
16C72:  BCF    FD8.0
16C74:  RLCF   x3C,W
16C76:  CLRF   03
16C78:  ADDLW  5E
16C7A:  MOVWF  FE9
16C7C:  MOVLW  07
16C7E:  ADDWFC 03,W
16C80:  MOVWF  FEA
16C82:  MOVFF  FEC,03
16C86:  MOVF   FED,F
16C88:  MOVFF  FEF,01
16C8C:  MOVF   47,F
16C8E:  BNZ   16D3A
16C90:  MOVF   46,F
16C92:  BNZ   16D3A
16C94:  MOVF   45,W
16C96:  SUBWF  03,W
16C98:  BNC   16D3A
16C9A:  BNZ   16CA2
16C9C:  MOVF   44,W
16C9E:  SUBWF  01,W
16CA0:  BNC   16D3A
....................       if(e_mode[motor]==2){     // if port mode then move 
16CA2:  BCF    FD8.0
16CA4:  RLCF   x3C,W
16CA6:  CLRF   03
16CA8:  ADDLW  62
16CAA:  MOVWF  FE9
16CAC:  MOVLW  07
16CAE:  ADDWFC 03,W
16CB0:  MOVWF  FEA
16CB2:  MOVFF  FEC,863
16CB6:  MOVF   FED,F
16CB8:  MOVFF  FEF,862
16CBC:  MOVLB  8
16CBE:  MOVF   x62,W
16CC0:  SUBLW  02
16CC2:  BNZ   16D30
16CC4:  MOVF   x63,F
16CC6:  BNZ   16D30
....................          switch (nv_product){ 
16CC8:  MOVF   2F,W
16CCA:  MOVWF  00
16CCC:  MOVF   30,W
16CCE:  MOVWF  03
16CD0:  MOVF   03,W
16CD2:  BNZ   16CDC
16CD4:  MOVF   00,F
16CD6:  MOVLB  0
16CD8:  BZ    16CFA
16CDA:  MOVLB  8
16CDC:  MOVF   03,W
16CDE:  BNZ   16CEA
16CE0:  MOVLW  01
16CE2:  SUBWF  00,W
16CE4:  MOVLB  0
16CE6:  BZ    16D0C
16CE8:  MOVLB  8
16CEA:  MOVF   03,W
16CEC:  BNZ   16CF8
16CEE:  MOVLW  03
16CF0:  SUBWF  00,W
16CF2:  MOVLB  0
16CF4:  BZ    16D1E
16CF6:  MOVLB  8
16CF8:  BRA    16D2E
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
16CFA:  MOVLW  01
16CFC:  MOVLB  8
16CFE:  MOVWF  x62
16D00:  CLRF   x63
16D02:  MOVWF  x64
16D04:  MOVLB  0
16D06:  RCALL  16B9E
....................                break;             
16D08:  MOVLB  8
16D0A:  BRA    16D2E
....................             case WMS4: command_move(0,0,1); 
16D0C:  MOVLB  8
16D0E:  CLRF   x62
16D10:  CLRF   x63
16D12:  MOVLW  01
16D14:  MOVWF  x64
16D16:  MOVLB  0
16D18:  RCALL  16B9E
....................                break; 
16D1A:  MOVLB  8
16D1C:  BRA    16D2E
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
16D1E:  MOVLB  8
16D20:  CLRF   x62
16D22:  CLRF   x63
16D24:  MOVLW  01
16D26:  MOVWF  x64
16D28:  MOVLB  0
16D2A:  RCALL  16B9E
....................                break; 
16D2C:  MOVLB  8
....................          } 
....................       } 
16D2E:  BRA    16D38
....................       else cmd_err();                           // else error 
16D30:  MOVLB  0
16D32:  CALL   BC28
16D36:  MOVLB  8
....................    } 
16D38:  BRA    16D42
....................    else cmd_arg(); 
16D3A:  MOVLB  0
16D3C:  CALL   AF66
16D40:  MOVLB  8
16D42:  MOVLB  0
16D44:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
16D46:  MOVF   47,F
16D48:  BNZ   16D76
16D4A:  MOVF   46,F
16D4C:  BNZ   16D76
16D4E:  MOVF   45,F
16D50:  BNZ   16D76
16D52:  MOVF   44,W
16D54:  SUBLW  30
16D56:  BNC   16D76
....................       nv_port = arg; 
16D58:  MOVFF  45,2E
16D5C:  MOVFF  44,2D
....................       write16(ADDR_PORT, nv_port); 
16D60:  MOVLW  24
16D62:  MOVLB  8
16D64:  MOVWF  xCB
16D66:  MOVFF  2E,8CD
16D6A:  MOVFF  2D,8CC
16D6E:  MOVLB  0
16D70:  CALL   4F4C
....................    } 
16D74:  BRA    16D7A
....................    else cmd_arg(); 
16D76:  CALL   AF66
16D7A:  GOTO   16DB6 (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
16D7E:  MOVF   2F,W
16D80:  MOVWF  00
16D82:  MOVF   30,W
16D84:  MOVWF  03
16D86:  BNZ   16D8C
16D88:  MOVF   00,F
16D8A:  BZ    16DAC
16D8C:  MOVF   03,W
16D8E:  BNZ   16D96
16D90:  MOVLW  01
16D92:  SUBWF  00,W
16D94:  BZ    16DB0
16D96:  MOVF   03,W
16D98:  BNZ   16DA0
16D9A:  MOVLW  03
16D9C:  SUBWF  00,W
16D9E:  BZ    16DB0
16DA0:  MOVF   03,W
16DA2:  BNZ   16DAA
16DA4:  MOVLW  02
16DA6:  SUBWF  00,W
16DA8:  BZ    16DB4
16DAA:  BRA    16DB6
....................       case ECO : commandPe(); 
16DAC:  RCALL  16C58
....................          break; 
16DAE:  BRA    16DB6
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
16DB0:  RCALL  16C58
....................          break; 
16DB2:  BRA    16DB6
....................       case AWS : commandPa(); 
16DB4:  BRA    16D46
....................          break;          
....................    } 
16DB6:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
16E02:  MOVLB  4
16E04:  DECFSZ xB2,W
16E06:  BRA    16E32
....................     
....................       if(arg<33){ 
16E08:  MOVF   47,F
16E0A:  BNZ   16E2A
16E0C:  MOVF   46,F
16E0E:  BNZ   16E2A
16E10:  MOVF   45,F
16E12:  BNZ   16E2A
16E14:  MOVF   44,W
16E16:  SUBLW  20
16E18:  BNC   16E2A
....................          valve=arg;    
16E1A:  MOVFF  44,862
....................          sol_switch(valve); 
16E1E:  MOVFF  862,892
16E22:  MOVLB  0
16E24:  CALL   140CA
....................       }  
16E28:  BRA    16E30
....................       else cmd_arg(); 
16E2A:  MOVLB  0
16E2C:  CALL   AF66
....................    } 
16E30:  BRA    16E38
....................    else cmd_err(); 
16E32:  MOVLB  0
16E34:  CALL   BC28
16E38:  GOTO   16E68 (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
16DBA:  MOVF   44,F
16DBC:  BNZ   16DCA
16DBE:  MOVF   45,F
16DC0:  BNZ   16DCA
16DC2:  MOVF   46,F
16DC4:  BNZ   16DCA
16DC6:  MOVF   47,F
16DC8:  BZ    16DFA
16DCA:  MOVF   47,F
16DCC:  BNZ   16DFA
16DCE:  MOVF   46,F
16DD0:  BNZ   16DFA
16DD2:  MOVF   45,F
16DD4:  BNZ   16DFA
16DD6:  MOVF   44,W
16DD8:  SUBLW  32
16DDA:  BNC   16DFA
....................       nv_port = arg; 
16DDC:  MOVFF  45,2E
16DE0:  MOVFF  44,2D
....................       write16(ADDR_SAMPLE, nv_port); 
16DE4:  MOVLW  16
16DE6:  MOVLB  8
16DE8:  MOVWF  xCB
16DEA:  MOVFF  2E,8CD
16DEE:  MOVFF  2D,8CC
16DF2:  MOVLB  0
16DF4:  CALL   4F4C
....................    } 
16DF8:  BRA    16DFE
....................    else cmd_arg(); 
16DFA:  CALL   AF66
16DFE:  GOTO   16E68 (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
16E3C:  MOVF   2F,W
16E3E:  MOVWF  00
16E40:  MOVF   30,W
16E42:  MOVWF  03
16E44:  BNZ   16E4C
16E46:  MOVLW  01
16E48:  SUBWF  00,W
16E4A:  BZ    16E62
16E4C:  MOVF   03,W
16E4E:  BNZ   16E56
16E50:  MOVLW  03
16E52:  SUBWF  00,W
16E54:  BZ    16E62
16E56:  MOVF   03,W
16E58:  BNZ   16E60
16E5A:  MOVLW  02
16E5C:  SUBWF  00,W
16E5E:  BZ    16E66
16E60:  BRA    16E68
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
16E62:  BRA    16DBA
....................          break; 
16E64:  BRA    16E68
....................       case AWS : commandQa(); 
16E66:  BRA    16E02
....................          break;          
....................    } 
16E68:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
16E6C:  CALL   293E
....................     
....................    nv_macro_step = 0; 
16E70:  CLRF   38
16E72:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
16E74:  MOVLW  3A
16E76:  MOVLB  8
16E78:  MOVWF  xCB
16E7A:  MOVFF  38,8CD
16E7E:  MOVFF  37,8CC
16E82:  MOVLB  0
16E84:  CALL   4F4C
....................     
....................    user_quit = FALSE; 
16E88:  CLRF   4C
....................     
....................    if (arg > 0 && arg < 3501){ 
16E8A:  MOVF   44,F
16E8C:  BNZ   16E9A
16E8E:  MOVF   45,F
16E90:  BNZ   16E9A
16E92:  MOVF   46,F
16E94:  BNZ   16E9A
16E96:  MOVF   47,F
16E98:  BZ    16F46
16E9A:  MOVF   47,F
16E9C:  BNZ   16F46
16E9E:  MOVF   46,F
16EA0:  BNZ   16F46
16EA2:  MOVF   45,W
16EA4:  SUBLW  0D
16EA6:  BNC   16F46
16EA8:  BNZ   16EB0
16EAA:  MOVF   44,W
16EAC:  SUBLW  AC
16EAE:  BNC   16F46
....................       samples = arg; 
16EB0:  MOVFF  45,864
16EB4:  MOVFF  44,863
....................       user_quit = FALSE; 
16EB8:  CLRF   4C
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
16EBA:  MOVLB  8
16EBC:  CLRF   x66
16EBE:  CLRF   x65
16EC0:  MOVF   x66,W
16EC2:  SUBWF  x64,W
16EC4:  BNC   16F44
16EC6:  BNZ   16ECE
16EC8:  MOVF   x63,W
16ECA:  SUBWF  x65,W
16ECC:  BC    16F44
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
16ECE:  MOVLW  01
16ED0:  ADDWF  x65,W
16ED2:  MOVWF  x67
16ED4:  MOVLW  00
16ED6:  ADDWFC x66,W
16ED8:  MOVWF  x68
16EDA:  MOVLW  9C
16EDC:  MOVWF  FF6
16EDE:  MOVLW  26
16EE0:  MOVWF  FF7
16EE2:  MOVLW  00
16EE4:  MOVWF  FF8
16EE6:  CLRF   1B
16EE8:  BTFSC  FF2.7
16EEA:  BSF    1B.7
16EEC:  BCF    FF2.7
16EEE:  MOVLW  05
16EF0:  MOVLB  A
16EF2:  MOVWF  x18
16EF4:  MOVLB  0
16EF6:  CALL   1006
16EFA:  BTFSC  1B.7
16EFC:  BSF    FF2.7
16EFE:  MOVLW  09
16F00:  MOVWF  FE9
16F02:  CLRF   1B
16F04:  BTFSC  FF2.7
16F06:  BSF    1B.7
16F08:  BCF    FF2.7
16F0A:  MOVFF  868,A19
16F0E:  MOVFF  867,A18
16F12:  CALL   1188
16F16:  BTFSC  1B.7
16F18:  BSF    FF2.7
16F1A:  MOVLW  0D
16F1C:  BTFSS  F9E.4
16F1E:  BRA    16F1C
16F20:  MOVWF  FAD
16F22:  MOVLW  0A
16F24:  BTFSS  F9E.4
16F26:  BRA    16F24
16F28:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
16F2A:  CALL   15AB8
16F2E:  MOVFF  01,862
....................          if (macro_cmd == ';') break; 
16F32:  MOVLB  8
16F34:  MOVF   x62,W
16F36:  SUBLW  3B
16F38:  BTFSC  FD8.2
16F3A:  BRA    16F44
16F3C:  INCF   x65,F
16F3E:  BTFSC  FD8.2
16F40:  INCF   x66,F
16F42:  BRA    16EC0
16F44:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
16F46:  CALL   ADA2
16F4A:  GOTO   1710A (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
16F4E:  MOVF   44,F
16F50:  BNZ   16F5E
16F52:  MOVF   45,F
16F54:  BNZ   16F5E
16F56:  MOVF   46,F
16F58:  BNZ   16F5E
16F5A:  MOVF   47,F
16F5C:  BZ    16FA2
16F5E:  MOVF   47,F
16F60:  BNZ   16FA2
16F62:  MOVF   46,F
16F64:  BNZ   16FA2
16F66:  MOVF   45,F
16F68:  BNZ   16FA2
16F6A:  MOVF   44,W
16F6C:  SUBLW  2F
16F6E:  BNC   16FA2
....................       n=arg; 
16F70:  MOVFF  44,865
....................       port=2; 
16F74:  MOVLB  8
16F76:  CLRF   x63
16F78:  MOVLW  02
16F7A:  MOVWF  x62
....................       for(i=0;i<n;++i){ 
16F7C:  CLRF   x64
16F7E:  MOVF   x65,W
16F80:  SUBWF  x64,W
16F82:  BC    16F9E
....................          play_wms_hard_macro(port); 
16F84:  MOVFF  863,867
16F88:  MOVFF  862,866
16F8C:  MOVLB  0
16F8E:  CALL   D4FC
....................          ++port; 
16F92:  MOVLB  8
16F94:  INCF   x62,F
16F96:  BTFSC  FD8.2
16F98:  INCF   x63,F
16F9A:  INCF   x64,F
16F9C:  BRA    16F7E
....................       } 
....................    } 
16F9E:  BRA    16FA8
16FA0:  MOVLB  0
....................    else cmd_arg(); 
16FA2:  CALL   AF66
16FA6:  MOVLB  8
16FA8:  MOVLB  0
16FAA:  GOTO   1710A (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
16FAE:  CALL   293E
....................     
....................    nv_macro_step = 0; 
16FB2:  CLRF   38
16FB4:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
16FB6:  MOVLW  3A
16FB8:  MOVLB  8
16FBA:  MOVWF  xCB
16FBC:  MOVFF  38,8CD
16FC0:  MOVFF  37,8CC
16FC4:  MOVLB  0
16FC6:  CALL   4F4C
....................     
....................    user_quit = FALSE; 
16FCA:  CLRF   4C
....................     
....................    if (arg > 0 && arg < 241){ 
16FCC:  MOVF   44,F
16FCE:  BNZ   16FDE
16FD0:  MOVF   45,F
16FD2:  BNZ   16FDE
16FD4:  MOVF   46,F
16FD6:  BNZ   16FDE
16FD8:  MOVF   47,F
16FDA:  BTFSC  FD8.2
16FDC:  BRA    170CA
16FDE:  MOVF   47,F
16FE0:  BTFSS  FD8.2
16FE2:  BRA    170CA
16FE4:  MOVF   46,F
16FE6:  BTFSS  FD8.2
16FE8:  BRA    170CA
16FEA:  MOVF   45,F
16FEC:  BTFSS  FD8.2
16FEE:  BRA    170CA
16FF0:  MOVF   44,W
16FF2:  SUBLW  F0
16FF4:  BNC   170CA
....................       samples = arg; 
16FF6:  MOVFF  45,864
16FFA:  MOVFF  44,863
....................       user_quit = FALSE; 
16FFE:  CLRF   4C
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
17000:  MOVLB  8
17002:  CLRF   x66
17004:  CLRF   x65
17006:  MOVF   x66,W
17008:  SUBWF  x64,W
1700A:  BNC   170C8
1700C:  BNZ   17014
1700E:  MOVF   x63,W
17010:  SUBWF  x65,W
17012:  BC    170C8
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
17014:  MOVLW  01
17016:  ADDWF  x65,W
17018:  MOVWF  x67
1701A:  MOVLW  00
1701C:  ADDWFC x66,W
1701E:  MOVWF  x68
17020:  MOVLW  AA
17022:  MOVWF  FF6
17024:  MOVLW  26
17026:  MOVWF  FF7
17028:  MOVLW  00
1702A:  MOVWF  FF8
1702C:  CLRF   1B
1702E:  BTFSC  FF2.7
17030:  BSF    1B.7
17032:  BCF    FF2.7
17034:  MOVLW  05
17036:  MOVLB  A
17038:  MOVWF  x18
1703A:  MOVLB  0
1703C:  CALL   1006
17040:  BTFSC  1B.7
17042:  BSF    FF2.7
17044:  MOVLW  09
17046:  MOVWF  FE9
17048:  CLRF   1B
1704A:  BTFSC  FF2.7
1704C:  BSF    1B.7
1704E:  BCF    FF2.7
17050:  MOVFF  868,A19
17054:  MOVFF  867,A18
17058:  CALL   1188
1705C:  BTFSC  1B.7
1705E:  BSF    FF2.7
17060:  MOVLW  0D
17062:  BTFSS  F9E.4
17064:  BRA    17062
17066:  MOVWF  FAD
17068:  MOVLW  0A
1706A:  BTFSS  F9E.4
1706C:  BRA    1706A
1706E:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
17070:  MOVLW  01
17072:  MOVLB  8
17074:  ADDWF  x65,W
17076:  MOVWF  x67
17078:  MOVLW  00
1707A:  ADDWFC x66,W
1707C:  MOVWF  x68
1707E:  MOVWF  x6A
17080:  MOVFF  867,869
17084:  MOVLB  0
17086:  CALL   1636E
1708A:  MOVFF  01,862
....................          ++nv_sample;                     // increment sample number 
1708E:  INCF   21,F
17090:  BTFSC  FD8.2
17092:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
17094:  MOVLW  16
17096:  MOVLB  8
17098:  MOVWF  xCB
1709A:  MOVFF  22,8CD
1709E:  MOVFF  21,8CC
170A2:  MOVLB  0
170A4:  CALL   4F4C
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
170A8:  MOVF   27,W
170AA:  SUBWF  21,W
170AC:  BNZ   170B4
170AE:  MOVF   28,W
170B0:  SUBWF  22,W
170B2:  BZ    170BC
170B4:  MOVLB  8
170B6:  MOVF   x62,W
170B8:  SUBLW  3B
170BA:  BNZ   170C0
170BC:  MOVLB  8
170BE:  BRA    170C8
170C0:  INCF   x65,F
170C2:  BTFSC  FD8.2
170C4:  INCF   x66,F
170C6:  BRA    17006
170C8:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
170CA:  CALL   ADA2
170CE:  GOTO   1710A (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
170D2:  MOVF   2F,W
170D4:  MOVWF  00
170D6:  MOVF   30,W
170D8:  MOVWF  03
170DA:  BNZ   170E0
170DC:  MOVF   00,F
170DE:  BZ    17100
170E0:  MOVF   03,W
170E2:  BNZ   170EA
170E4:  MOVLW  01
170E6:  SUBWF  00,W
170E8:  BZ    17104
170EA:  MOVF   03,W
170EC:  BNZ   170F4
170EE:  MOVLW  03
170F0:  SUBWF  00,W
170F2:  BZ    17104
170F4:  MOVF   03,W
170F6:  BNZ   170FE
170F8:  MOVLW  02
170FA:  SUBWF  00,W
170FC:  BZ    17108
170FE:  BRA    1710A
....................       case ECO : commandRe(); 
17100:  BRA    16E6C
....................          break; 
17102:  BRA    1710A
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
17104:  BRA    16F4E
....................          break; 
17106:  BRA    1710A
....................       case AWS : commandRa(); 
17108:  BRA    16FAE
....................          break;          
....................    } 
1710A:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
1710E:  CALL   293E
....................     
....................    switch(arg){ 
17112:  MOVFF  44,00
17116:  MOVF   45,W
17118:  MOVWF  03
1711A:  BNZ   17122
1711C:  MOVLW  01
1711E:  SUBWF  00,W
17120:  BZ    1712E
17122:  MOVF   03,W
17124:  BNZ   1712C
17126:  MOVLW  02
17128:  SUBWF  00,W
1712A:  BZ    17172
1712C:  BRA    17182
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
1712E:  DECFSZ 41,W
17130:  BRA    17146
17132:  MOVF   42,F
17134:  BNZ   17146
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
17136:  MOVLB  8
17138:  CLRF   x9F
1713A:  MOVLW  01
1713C:  MOVWF  xA0
1713E:  MOVLB  0
17140:  CALL   1340C
....................       } 
17144:  BRA    17170
....................       else if(nv_det_type==2 || nv_det_type==3) 
17146:  MOVF   41,W
17148:  SUBLW  02
1714A:  BNZ   17150
1714C:  MOVF   42,F
1714E:  BZ    1715A
17150:  MOVF   41,W
17152:  SUBLW  03
17154:  BNZ   17170
17156:  MOVF   42,F
17158:  BNZ   17170
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
1715A:  MOVLB  8
1715C:  CLRF   xA0
1715E:  MOVLW  C8
17160:  MOVWF  x9F
17162:  CLRF   xA1
17164:  MOVLW  01
17166:  MOVWF  xA2
17168:  CLRF   xA3
1716A:  MOVLB  0
1716C:  CALL   FCF2
....................       } 
....................       break;                                                        //200 scans,don't store,display 
17170:  BRA    17186
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
17172:  MOVLB  8
17174:  CLRF   x9F
17176:  MOVLW  01
17178:  MOVWF  xA0
1717A:  MOVLB  0
1717C:  CALL   1370E
....................       break; 
17180:  BRA    17186
....................    default: cmd_arg(); 
17182:  CALL   AF66
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
17186:  CALL   ADA2
1718A:  GOTO   17236 (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
1718E:  MOVF   47,F
17190:  BNZ   171C2
17192:  MOVF   46,F
17194:  BNZ   171C2
17196:  MOVF   45,W
17198:  SUBLW  04
1719A:  BNC   171C2
1719C:  BNZ   171A4
1719E:  MOVF   44,W
171A0:  SUBLW  00
171A2:  BNC   171C2
....................       nv_sample = arg; 
171A4:  MOVFF  45,22
171A8:  MOVFF  44,21
....................       write16(ADDR_SAMPLE, nv_sample); 
171AC:  MOVLW  16
171AE:  MOVLB  8
171B0:  MOVWF  xCB
171B2:  MOVFF  22,8CD
171B6:  MOVFF  21,8CC
171BA:  MOVLB  0
171BC:  CALL   4F4C
....................    } 
171C0:  BRA    171C6
....................    else cmd_arg(); 
171C2:  CALL   AF66
171C6:  GOTO   17236 (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
171CA:  MOVF   47,F
171CC:  BNZ   171F6
171CE:  MOVF   46,F
171D0:  BNZ   171F6
171D2:  MOVF   45,W
171D4:  SUBLW  01
171D6:  BNC   171F6
171D8:  BNZ   171E0
171DA:  MOVF   44,W
171DC:  SUBLW  02
171DE:  BNC   171F6
....................       setting = arg; 
171E0:  MOVFF  45,863
171E4:  MOVFF  44,862
....................       sol_switch_cmd(setting); 
171E8:  MOVFF  863,894
171EC:  MOVFF  862,893
171F0:  CALL   14014
....................    } 
171F4:  BRA    171FA
....................    else cmd_arg(); 
171F6:  CALL   AF66
171FA:  GOTO   17236 (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
171FE:  MOVF   2F,W
17200:  MOVWF  00
17202:  MOVF   30,W
17204:  MOVWF  03
17206:  BNZ   1720C
17208:  MOVF   00,F
1720A:  BZ    1722C
1720C:  MOVF   03,W
1720E:  BNZ   17216
17210:  MOVLW  01
17212:  SUBWF  00,W
17214:  BZ    17230
17216:  MOVF   03,W
17218:  BNZ   17220
1721A:  MOVLW  03
1721C:  SUBWF  00,W
1721E:  BZ    17230
17220:  MOVF   03,W
17222:  BNZ   1722A
17224:  MOVLW  02
17226:  SUBWF  00,W
17228:  BZ    17234
1722A:  BRA    17236
....................       case ECO : commandSe(); 
1722C:  BRA    1710E
....................          break; 
1722E:  BRA    17236
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
17230:  BRA    1718E
....................          break; 
17232:  BRA    17236
....................       case AWS : commandSa(); 
17234:  BRA    171CA
....................          break;          
....................    } 
17236:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
1779C:  MOVLW  B8
1779E:  MOVWF  FF6
177A0:  MOVLW  26
177A2:  MOVWF  FF7
177A4:  MOVLW  00
177A6:  MOVWF  FF8
177A8:  CLRF   1B
177AA:  BTFSC  FF2.7
177AC:  BSF    1B.7
177AE:  BCF    FF2.7
177B0:  CALL   0E30
177B4:  BTFSC  1B.7
177B6:  BSF    FF2.7
....................    fputc('>',COM_A); 
177B8:  MOVLW  3E
177BA:  CALL   ADAA
....................    RTCfmt=fgetc(COM_A); 
177BE:  CALL   0E1A
177C2:  MOVFF  01,4B
....................    if (com_echo == TRUE) 
177C6:  DECFSZ 48,W
177C8:  BRA    177D0
....................       { 
....................       fputc(RTCfmt,COM_A); 
177CA:  MOVF   4B,W
177CC:  CALL   ADAA
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
177D0:  MOVLW  30
177D2:  SUBWF  4B,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
177D4:  MOVF   4B,W
177D6:  SUBLW  01
177D8:  BNC   1780E
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
177DA:  MOVLW  E4
177DC:  MOVWF  FF6
177DE:  MOVLW  26
177E0:  MOVWF  FF7
177E2:  MOVLW  00
177E4:  MOVWF  FF8
177E6:  CALL   AD78
177EA:  MOVLW  0D
177EC:  BTFSS  F9E.4
177EE:  BRA    177EC
177F0:  MOVWF  FAD
177F2:  MOVLW  0A
177F4:  BTFSS  F9E.4
177F6:  BRA    177F4
177F8:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
177FA:  MOVLW  1A
177FC:  MOVLB  8
177FE:  MOVWF  xCB
17800:  CLRF   xCD
17802:  MOVFF  4B,8CC
17806:  MOVLB  0
17808:  CALL   4F4C
....................       }  
1780C:  BRA    17812
....................    else cmd_arg(); 
1780E:  CALL   AF66
....................     
....................    if(arg == 1) 
17812:  DECFSZ 44,W
17814:  BRA    17826
17816:  MOVF   45,F
17818:  BNZ   17826
1781A:  MOVF   46,F
1781C:  BNZ   17826
1781E:  MOVF   47,F
17820:  BNZ   17826
....................    { 
....................       RTC_Set(); 
17822:  BRA    17652
....................    } 
17824:  BRA    1782A
....................    else cmd_arg(); 
17826:  CALL   AF66
1782A:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
1819E:  MOVF   47,F
181A0:  BNZ   181BC
181A2:  MOVF   46,F
181A4:  BNZ   181BC
181A6:  MOVF   45,F
181A8:  BNZ   181BC
181AA:  MOVF   44,W
181AC:  SUBLW  14
181AE:  BNC   181BC
....................       macro = arg; 
181B0:  MOVFF  44,862
....................       upload_macro(macro);    
181B4:  MOVFF  862,863
181B8:  BRA    17EEC
....................    }    
181BA:  BRA    181D8
....................    else if (arg == 5525){ 
181BC:  MOVF   44,W
181BE:  SUBLW  95
181C0:  BNZ   181D4
181C2:  MOVF   45,W
181C4:  SUBLW  15
181C6:  BNZ   181D4
181C8:  MOVF   46,F
181CA:  BNZ   181D4
181CC:  MOVF   47,F
181CE:  BNZ   181D4
....................       write_blank_macros(); 
181D0:  BRA    18022
....................    } 
181D2:  BRA    181D8
....................    else cmd_arg(); 
181D4:  CALL   AF66
181D8:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
182F6:  MOVF   47,F
182F8:  BNZ   18314
182FA:  MOVF   46,F
182FC:  BNZ   18314
182FE:  MOVF   45,F
18300:  BNZ   18314
18302:  MOVF   44,W
18304:  SUBLW  14
18306:  BNC   18314
....................       macro = arg;  
18308:  MOVFF  44,862
....................       read_macro(macro); 
1830C:  MOVFF  862,863
18310:  BRA    18290
....................    }    
18312:  BRA    18318
....................    else cmd_arg(); 
18314:  CALL   AF66
18318:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
1846A:  DECFSZ 44,W
1846C:  BRA    18486
1846E:  MOVF   45,F
18470:  BNZ   18486
18472:  MOVF   46,F
18474:  BNZ   18486
18476:  MOVF   47,F
18478:  BNZ   18486
....................       RTC_alarm(); 
1847A:  BRA    1831C
....................       RTC_late(); 
1847C:  CALL   152BE
....................       RTC_alarm_status(); 
18480:  CALL   15778
....................    } 
18484:  BRA    1848A
....................    else cmd_arg(); 
18486:  CALL   AF66
1848A:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
1848E:  MOVF   44,W
18490:  MOVWF  00
18492:  MOVF   45,W
18494:  MOVWF  03
18496:  BNZ   1849C
18498:  MOVF   00,F
1849A:  BZ    184D0
1849C:  MOVF   03,W
1849E:  BNZ   184A6
184A0:  MOVLW  02
184A2:  SUBWF  00,W
184A4:  BZ    184D0
184A6:  MOVF   03,W
184A8:  BNZ   184B0
184AA:  MOVLW  03
184AC:  SUBWF  00,W
184AE:  BZ    184D0
184B0:  MOVF   03,W
184B2:  BNZ   184BA
184B4:  MOVLW  04
184B6:  SUBWF  00,W
184B8:  BZ    184D0
184BA:  MOVF   03,W
184BC:  BNZ   184C4
184BE:  MOVLW  05
184C0:  SUBWF  00,W
184C2:  BZ    184D0
184C4:  MOVF   03,W
184C6:  BNZ   184CE
184C8:  MOVLW  06
184CA:  SUBWF  00,W
184CC:  BZ    184D0
184CE:  BRA    184EE
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
184D0:  MOVFF  45,20
184D4:  MOVFF  44,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
184D8:  MOVLW  1C
184DA:  MOVLB  8
184DC:  MOVWF  xCB
184DE:  MOVFF  20,8CD
184E2:  MOVFF  1F,8CC
184E6:  MOVLB  0
184E8:  CALL   4F4C
....................          break; 
184EC:  BRA    184F2
....................       default: cmd_arg(); 
184EE:  CALL   AF66
....................          break; 
....................    } 
184F2:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
184F6:  CALL   293E
....................     
....................    switch(arg){ 
184FA:  MOVFF  44,00
184FE:  MOVF   45,W
18500:  MOVWF  03
18502:  BNZ   18508
18504:  MOVF   00,F
18506:  BZ    1858C
18508:  MOVF   03,W
1850A:  BNZ   18512
1850C:  MOVLW  0A
1850E:  SUBWF  00,W
18510:  BZ    1858C
18512:  MOVF   03,W
18514:  BNZ   1851C
18516:  MOVLW  01
18518:  SUBWF  00,W
1851A:  BZ    18594
1851C:  MOVF   03,W
1851E:  BNZ   18526
18520:  MOVLW  0B
18522:  SUBWF  00,W
18524:  BZ    18594
18526:  MOVF   03,W
18528:  BNZ   18530
1852A:  MOVLW  14
1852C:  SUBWF  00,W
1852E:  BZ    1859E
18530:  MOVF   03,W
18532:  BNZ   1853A
18534:  MOVLW  15
18536:  SUBWF  00,W
18538:  BZ    185A4
1853A:  MOVF   03,W
1853C:  BNZ   18544
1853E:  MOVLW  1E
18540:  SUBWF  00,W
18542:  BZ    185AA
18544:  MOVF   03,W
18546:  BNZ   1854E
18548:  MOVLW  1F
1854A:  SUBWF  00,W
1854C:  BZ    185B0
1854E:  MOVF   03,W
18550:  BNZ   18558
18552:  MOVLW  28
18554:  SUBWF  00,W
18556:  BZ    185B6
18558:  MOVF   03,W
1855A:  BNZ   18562
1855C:  MOVLW  29
1855E:  SUBWF  00,W
18560:  BZ    185BC
18562:  MOVF   03,W
18564:  BNZ   1856C
18566:  MOVLW  32
18568:  SUBWF  00,W
1856A:  BZ    185C2
1856C:  MOVF   03,W
1856E:  BNZ   18576
18570:  MOVLW  33
18572:  SUBWF  00,W
18574:  BZ    185C8
18576:  MOVF   03,W
18578:  BNZ   18580
1857A:  MOVLW  3C
1857C:  SUBWF  00,W
1857E:  BZ    185CE
18580:  MOVF   03,W
18582:  BNZ   1858A
18584:  MOVLW  3D
18586:  SUBWF  00,W
18588:  BZ    185DC
1858A:  BRA    185EE
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
1858C:  BCF    F90.7
....................                bus_pwr_status=0; 
1858E:  MOVLB  4
18590:  CLRF   xB2
....................          break; 
18592:  BRA    185F4
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
18594:  BSF    F90.7
....................                bus_pwr_status=1; 
18596:  MOVLW  01
18598:  MOVLB  4
1859A:  MOVWF  xB2
....................          break; 
1859C:  BRA    185F4
....................       case 20: output_bit(VMOT,OFF); 
1859E:  BCF    F8E.1
....................          break; 
185A0:  MOVLB  4
185A2:  BRA    185F4
....................       case 21: output_bit(VMOT,ON); 
185A4:  BSF    F8E.1
....................          break; 
185A6:  MOVLB  4
185A8:  BRA    185F4
....................       case 30: output_bit(VENC1,OFF); 
185AA:  BCF    F8E.6
....................          break; 
185AC:  MOVLB  4
185AE:  BRA    185F4
....................       case 31: output_bit(VENC1,ON); 
185B0:  BSF    F8E.6
....................          break; 
185B2:  MOVLB  4
185B4:  BRA    185F4
....................       case 40: output_bit(VENC2,OFF); 
185B6:  BCF    F8E.7
....................          break; 
185B8:  MOVLB  4
185BA:  BRA    185F4
....................       case 41: output_bit(VENC2,ON); 
185BC:  BSF    F8E.7
....................          break; 
185BE:  MOVLB  4
185C0:  BRA    185F4
....................       case 50: output_bit(VHBRDG,OFF); 
185C2:  BCF    F8E.2
....................          break; 
185C4:  MOVLB  4
185C6:  BRA    185F4
....................       case 51: output_bit(VHBRDG,ON); 
185C8:  BSF    F8E.2
....................          break;          
185CA:  MOVLB  4
185CC:  BRA    185F4
....................       case 60: set_heaters(0); 
185CE:  MOVLB  8
185D0:  CLRF   xA2
185D2:  MOVLB  0
185D4:  CALL   123EC
....................          break; 
185D8:  MOVLB  4
185DA:  BRA    185F4
....................       case 61: set_heaters(3); 
185DC:  MOVLW  03
185DE:  MOVLB  8
185E0:  MOVWF  xA2
185E2:  MOVLB  0
185E4:  CALL   123EC
....................          break; 
185E8:  MOVLB  4
185EA:  BRA    185F4
185EC:  MOVLB  0
....................       default : cmd_arg(); 
185EE:  CALL   AF66
....................          break;          
185F2:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
185F4:  MOVLB  0
185F6:  CALL   ADA2
185FA:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
185FE:  MOVF   44,F
18600:  BNZ   1861C
18602:  MOVF   45,F
18604:  BNZ   1861C
18606:  MOVF   46,F
18608:  BNZ   1861C
1860A:  MOVF   47,F
1860C:  BNZ   1861C
....................       motor_sleep_rdy(); 
1860E:  CALL   2916
....................       shutdown(); 
18612:  CALL   1579A
....................       go_to_sleep(); 
18616:  CALL   159F2
....................    } 
1861A:  BRA    18620
....................    else cmd_arg(); 
1861C:  CALL   AF66
18620:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
1874E:  DECFSZ 44,W
18750:  BRA    18762
18752:  MOVF   45,F
18754:  BNZ   18762
18756:  MOVF   46,F
18758:  BNZ   18762
1875A:  MOVF   47,F
1875C:  BNZ   18762
1875E:  BRA    18648
18760:  BRA    18766
....................    else cmd_arg(); 
18762:  CALL   AF66
18766:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
1876A:  MOVF   47,F
1876C:  BNZ   187FC
1876E:  MOVF   46,F
18770:  BNZ   187FC
18772:  MOVF   45,W
18774:  SUBLW  27
18776:  BNC   187FC
18778:  BNZ   18780
1877A:  MOVF   44,W
1877C:  SUBLW  10
1877E:  BNC   187FC
....................       m_bklsh[motor] = arg; 
18780:  BCF    FD8.0
18782:  MOVLB  7
18784:  RLCF   x3C,W
18786:  CLRF   03
18788:  ADDLW  6E
1878A:  MOVWF  FE9
1878C:  MOVLW  07
1878E:  ADDWFC 03,W
18790:  MOVWF  FEA
18792:  MOVFF  44,FEF
18796:  MOVFF  45,FEC
....................       switch(motor){ 
1879A:  MOVF   x3C,W
1879C:  XORLW  00
1879E:  MOVLB  0
187A0:  BZ    187A8
187A2:  XORLW  01
187A4:  BZ    187D2
187A6:  BRA    187FA
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
187A8:  BCF    FD8.0
187AA:  MOVLB  7
187AC:  RLCF   x3C,W
187AE:  CLRF   03
187B0:  ADDLW  6E
187B2:  MOVWF  FE9
187B4:  MOVLW  07
187B6:  ADDWFC 03,W
187B8:  MOVWF  FEA
187BA:  MOVFF  FEC,8CD
187BE:  MOVF   FED,F
187C0:  MOVFF  FEF,8CC
187C4:  MOVLW  72
187C6:  MOVLB  8
187C8:  MOVWF  xCB
187CA:  MOVLB  0
187CC:  CALL   4F4C
....................             break; 
187D0:  BRA    187FA
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
187D2:  BCF    FD8.0
187D4:  MOVLB  7
187D6:  RLCF   x3C,W
187D8:  CLRF   03
187DA:  ADDLW  6E
187DC:  MOVWF  FE9
187DE:  MOVLW  07
187E0:  ADDWFC 03,W
187E2:  MOVWF  FEA
187E4:  MOVFF  FEC,8CD
187E8:  MOVF   FED,F
187EA:  MOVFF  FEF,8CC
187EE:  MOVLW  74
187F0:  MOVLB  8
187F2:  MOVWF  xCB
187F4:  MOVLB  0
187F6:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
187FA:  BRA    18800
....................    else cmd_arg();    
187FC:  CALL   AF66
18800:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
18804:  MOVF   47,F
18806:  BNZ   18892
18808:  MOVF   46,F
1880A:  BNZ   18892
1880C:  MOVF   45,F
1880E:  BNZ   18892
18810:  MOVF   44,W
18812:  SUBLW  01
18814:  BNC   18892
....................       m_pos_dir[motor] = arg; 
18816:  BCF    FD8.0
18818:  MOVLB  7
1881A:  RLCF   x3C,W
1881C:  CLRF   03
1881E:  ADDLW  4A
18820:  MOVWF  FE9
18822:  MOVLW  07
18824:  ADDWFC 03,W
18826:  MOVWF  FEA
18828:  MOVFF  44,FEF
1882C:  MOVFF  45,FEC
....................       switch(motor){ 
18830:  MOVF   x3C,W
18832:  XORLW  00
18834:  MOVLB  0
18836:  BZ    1883E
18838:  XORLW  01
1883A:  BZ    18868
1883C:  BRA    18890
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
1883E:  BCF    FD8.0
18840:  MOVLB  7
18842:  RLCF   x3C,W
18844:  CLRF   03
18846:  ADDLW  4A
18848:  MOVWF  FE9
1884A:  MOVLW  07
1884C:  ADDWFC 03,W
1884E:  MOVWF  FEA
18850:  MOVFF  FEC,8CD
18854:  MOVF   FED,F
18856:  MOVFF  FEF,8CC
1885A:  MOVLW  92
1885C:  MOVLB  8
1885E:  MOVWF  xCB
18860:  MOVLB  0
18862:  CALL   4F4C
....................             break; 
18866:  BRA    18890
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
18868:  BCF    FD8.0
1886A:  MOVLB  7
1886C:  RLCF   x3C,W
1886E:  CLRF   03
18870:  ADDLW  4A
18872:  MOVWF  FE9
18874:  MOVLW  07
18876:  ADDWFC 03,W
18878:  MOVWF  FEA
1887A:  MOVFF  FEC,8CD
1887E:  MOVF   FED,F
18880:  MOVFF  FEF,8CC
18884:  MOVLW  94
18886:  MOVLB  8
18888:  MOVWF  xCB
1888A:  MOVLB  0
1888C:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
18890:  BRA    18896
....................    else cmd_arg();    
18892:  CALL   AF66
18896:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
1889A:  MOVF   47,F
1889C:  BNZ   1892C
1889E:  MOVF   46,F
188A0:  BNZ   1892C
188A2:  MOVF   45,W
188A4:  SUBLW  27
188A6:  BNC   1892C
188A8:  BNZ   188B0
188AA:  MOVF   44,W
188AC:  SUBLW  10
188AE:  BNC   1892C
....................       e_cpr[motor] = arg; 
188B0:  BCF    FD8.0
188B2:  MOVLB  7
188B4:  RLCF   x3C,W
188B6:  CLRF   03
188B8:  ADDLW  5A
188BA:  MOVWF  FE9
188BC:  MOVLW  07
188BE:  ADDWFC 03,W
188C0:  MOVWF  FEA
188C2:  MOVFF  44,FEF
188C6:  MOVFF  45,FEC
....................       switch(motor){ 
188CA:  MOVF   x3C,W
188CC:  XORLW  00
188CE:  MOVLB  0
188D0:  BZ    188D8
188D2:  XORLW  01
188D4:  BZ    18902
188D6:  BRA    1892A
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
188D8:  BCF    FD8.0
188DA:  MOVLB  7
188DC:  RLCF   x3C,W
188DE:  CLRF   03
188E0:  ADDLW  5A
188E2:  MOVWF  FE9
188E4:  MOVLW  07
188E6:  ADDWFC 03,W
188E8:  MOVWF  FEA
188EA:  MOVFF  FEC,8CD
188EE:  MOVF   FED,F
188F0:  MOVFF  FEF,8CC
188F4:  MOVLW  A2
188F6:  MOVLB  8
188F8:  MOVWF  xCB
188FA:  MOVLB  0
188FC:  CALL   4F4C
....................             break; 
18900:  BRA    1892A
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
18902:  BCF    FD8.0
18904:  MOVLB  7
18906:  RLCF   x3C,W
18908:  CLRF   03
1890A:  ADDLW  5A
1890C:  MOVWF  FE9
1890E:  MOVLW  07
18910:  ADDWFC 03,W
18912:  MOVWF  FEA
18914:  MOVFF  FEC,8CD
18918:  MOVF   FED,F
1891A:  MOVFF  FEF,8CC
1891E:  MOVLW  A4
18920:  MOVLB  8
18922:  MOVWF  xCB
18924:  MOVLB  0
18926:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
1892A:  BRA    18930
....................    else cmd_arg();    
1892C:  CALL   AF66
18930:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
18934:  MOVF   47,F
18936:  BNZ   1894C
18938:  MOVF   46,F
1893A:  BNZ   1894C
1893C:  MOVF   45,F
1893E:  BNZ   1894C
18940:  MOVF   44,W
18942:  SUBLW  01
18944:  BNC   1894C
18946:  MOVFF  44,73D
1894A:  BRA    18950
....................    else cmd_arg();    
1894C:  CALL   AF66
18950:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
18954:  MOVF   47,F
18956:  BNZ   189E6
18958:  MOVF   46,F
1895A:  BNZ   189E6
1895C:  MOVF   45,W
1895E:  SUBLW  EA
18960:  BNC   189E6
18962:  BNZ   1896A
18964:  MOVF   44,W
18966:  SUBLW  60
18968:  BNC   189E6
....................       m_gb_err[motor] = arg; 
1896A:  BCF    FD8.0
1896C:  MOVLB  7
1896E:  RLCF   x3C,W
18970:  CLRF   03
18972:  ADDLW  56
18974:  MOVWF  FE9
18976:  MOVLW  07
18978:  ADDWFC 03,W
1897A:  MOVWF  FEA
1897C:  MOVFF  44,FEF
18980:  MOVFF  45,FEC
....................       switch(motor){ 
18984:  MOVF   x3C,W
18986:  XORLW  00
18988:  MOVLB  0
1898A:  BZ    18992
1898C:  XORLW  01
1898E:  BZ    189BC
18990:  BRA    189E4
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
18992:  BCF    FD8.0
18994:  MOVLB  7
18996:  RLCF   x3C,W
18998:  CLRF   03
1899A:  ADDLW  56
1899C:  MOVWF  FE9
1899E:  MOVLW  07
189A0:  ADDWFC 03,W
189A2:  MOVWF  FEA
189A4:  MOVFF  FEC,8CD
189A8:  MOVF   FED,F
189AA:  MOVFF  FEF,8CC
189AE:  MOVLW  9E
189B0:  MOVLB  8
189B2:  MOVWF  xCB
189B4:  MOVLB  0
189B6:  CALL   4F4C
....................             break; 
189BA:  BRA    189E4
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
189BC:  BCF    FD8.0
189BE:  MOVLB  7
189C0:  RLCF   x3C,W
189C2:  CLRF   03
189C4:  ADDLW  56
189C6:  MOVWF  FE9
189C8:  MOVLW  07
189CA:  ADDWFC 03,W
189CC:  MOVWF  FEA
189CE:  MOVFF  FEC,8CD
189D2:  MOVF   FED,F
189D4:  MOVFF  FEF,8CC
189D8:  MOVLW  A0
189DA:  MOVLB  8
189DC:  MOVWF  xCB
189DE:  MOVLB  0
189E0:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
189E4:  BRA    189EA
....................    else cmd_arg();    
189E6:  CALL   AF66
189EA:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
189EE:  MOVF   47,F
189F0:  BNZ   18ABA
189F2:  MOVF   46,F
189F4:  BNZ   18ABA
189F6:  MOVF   45,F
189F8:  BNZ   18ABA
189FA:  MOVF   44,W
189FC:  SUBLW  64
189FE:  BNC   18ABA
....................       hold_pc=arg; 
18A00:  MOVFF  45,863
18A04:  MOVFF  44,862
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
18A08:  BCF    FD8.0
18A0A:  MOVLB  7
18A0C:  RLCF   x3C,W
18A0E:  CLRF   03
18A10:  ADDLW  4E
18A12:  MOVWF  FE9
18A14:  MOVLW  07
18A16:  ADDWFC 03,W
18A18:  MOVWF  FEA
18A1A:  MOVFF  863,9EA
18A1E:  MOVFF  862,9E9
18A22:  MOVLW  01
18A24:  MOVLB  9
18A26:  MOVWF  xEC
18A28:  SETF   xEB
18A2A:  MOVLB  0
18A2C:  CALL   5C0E
18A30:  MOVFF  02,867
18A34:  MOVFF  01,866
18A38:  MOVFF  02,8B9
18A3C:  MOVFF  01,8B8
18A40:  MOVLB  8
18A42:  CLRF   xBB
18A44:  MOVLW  64
18A46:  MOVWF  xBA
18A48:  MOVLB  0
18A4A:  CALL   2C52
18A4E:  MOVFF  01,FEF
18A52:  MOVFF  02,FEC
....................       switch(motor){ 
18A56:  MOVLB  7
18A58:  MOVF   x3C,W
18A5A:  XORLW  00
18A5C:  MOVLB  0
18A5E:  BZ    18A66
18A60:  XORLW  01
18A62:  BZ    18A90
18A64:  BRA    18AB8
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
18A66:  BCF    FD8.0
18A68:  MOVLB  7
18A6A:  RLCF   x3C,W
18A6C:  CLRF   03
18A6E:  ADDLW  4E
18A70:  MOVWF  FE9
18A72:  MOVLW  07
18A74:  ADDWFC 03,W
18A76:  MOVWF  FEA
18A78:  MOVFF  FEC,8CD
18A7C:  MOVF   FED,F
18A7E:  MOVFF  FEF,8CC
18A82:  MOVLW  96
18A84:  MOVLB  8
18A86:  MOVWF  xCB
18A88:  MOVLB  0
18A8A:  CALL   4F4C
....................             break; 
18A8E:  BRA    18AB8
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
18A90:  BCF    FD8.0
18A92:  MOVLB  7
18A94:  RLCF   x3C,W
18A96:  CLRF   03
18A98:  ADDLW  4E
18A9A:  MOVWF  FE9
18A9C:  MOVLW  07
18A9E:  ADDWFC 03,W
18AA0:  MOVWF  FEA
18AA2:  MOVFF  FEC,8CD
18AA6:  MOVF   FED,F
18AA8:  MOVFF  FEF,8CC
18AAC:  MOVLW  98
18AAE:  MOVLB  8
18AB0:  MOVWF  xCB
18AB2:  MOVLB  0
18AB4:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
18AB8:  BRA    18ABE
....................    else cmd_arg();    
18ABA:  CALL   AF66
18ABE:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
18AC2:  MOVF   47,F
18AC4:  BNZ   18B96
18AC6:  MOVF   46,F
18AC8:  BNZ   18B96
18ACA:  MOVF   45,W
18ACC:  SUBLW  EA
18ACE:  BNC   18B96
18AD0:  BNZ   18AD8
18AD2:  MOVF   44,W
18AD4:  SUBLW  60
18AD6:  BNC   18B96
....................       m_stp_int[motor] = (arg/100); 
18AD8:  BCF    FD8.0
18ADA:  MOVLB  7
18ADC:  RLCF   x3C,W
18ADE:  CLRF   03
18AE0:  ADDLW  46
18AE2:  MOVWF  FE9
18AE4:  MOVLW  07
18AE6:  ADDWFC 03,W
18AE8:  MOVWF  FEA
18AEA:  MOVFF  FEA,865
18AEE:  MOVFF  FE9,864
18AF2:  BCF    FD8.1
18AF4:  CLRF   1B
18AF6:  BTFSC  FF2.7
18AF8:  BSF    1B.7
18AFA:  BCF    FF2.7
18AFC:  MOVFF  47,A27
18B00:  MOVFF  46,A26
18B04:  MOVFF  45,A25
18B08:  MOVFF  44,A24
18B0C:  MOVLB  A
18B0E:  CLRF   x2B
18B10:  CLRF   x2A
18B12:  CLRF   x29
18B14:  MOVLW  64
18B16:  MOVWF  x28
18B18:  MOVLB  0
18B1A:  CALL   1038
18B1E:  BTFSC  1B.7
18B20:  BSF    FF2.7
18B22:  MOVFF  865,FEA
18B26:  MOVFF  864,FE9
18B2A:  MOVFF  00,FEF
18B2E:  MOVFF  01,FEC
....................       switch(motor){ 
18B32:  MOVLB  7
18B34:  MOVF   x3C,W
18B36:  XORLW  00
18B38:  MOVLB  0
18B3A:  BZ    18B42
18B3C:  XORLW  01
18B3E:  BZ    18B6C
18B40:  BRA    18B94
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
18B42:  BCF    FD8.0
18B44:  MOVLB  7
18B46:  RLCF   x3C,W
18B48:  CLRF   03
18B4A:  ADDLW  46
18B4C:  MOVWF  FE9
18B4E:  MOVLW  07
18B50:  ADDWFC 03,W
18B52:  MOVWF  FEA
18B54:  MOVFF  FEC,8CD
18B58:  MOVF   FED,F
18B5A:  MOVFF  FEF,8CC
18B5E:  MOVLW  8E
18B60:  MOVLB  8
18B62:  MOVWF  xCB
18B64:  MOVLB  0
18B66:  CALL   4F4C
....................             break; 
18B6A:  BRA    18B94
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
18B6C:  BCF    FD8.0
18B6E:  MOVLB  7
18B70:  RLCF   x3C,W
18B72:  CLRF   03
18B74:  ADDLW  46
18B76:  MOVWF  FE9
18B78:  MOVLW  07
18B7A:  ADDWFC 03,W
18B7C:  MOVWF  FEA
18B7E:  MOVFF  FEC,8CD
18B82:  MOVF   FED,F
18B84:  MOVFF  FEF,8CC
18B88:  MOVLW  90
18B8A:  MOVLB  8
18B8C:  MOVWF  xCB
18B8E:  MOVLB  0
18B90:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
18B94:  BRA    18B9A
....................    else cmd_arg();    
18B96:  CALL   AF66
18B9A:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
18B9E:  MOVF   47,F
18BA0:  BNZ   18C30
18BA2:  MOVF   46,F
18BA4:  BNZ   18C30
18BA6:  MOVF   45,W
18BA8:  SUBLW  27
18BAA:  BNC   18C30
18BAC:  BNZ   18BB4
18BAE:  MOVF   44,W
18BB0:  SUBLW  10
18BB2:  BNC   18C30
....................       m_run[motor] = arg; 
18BB4:  BCF    FD8.0
18BB6:  MOVLB  7
18BB8:  RLCF   x3C,W
18BBA:  CLRF   03
18BBC:  ADDLW  6A
18BBE:  MOVWF  FE9
18BC0:  MOVLW  07
18BC2:  ADDWFC 03,W
18BC4:  MOVWF  FEA
18BC6:  MOVFF  44,FEF
18BCA:  MOVFF  45,FEC
....................       switch(motor){ 
18BCE:  MOVF   x3C,W
18BD0:  XORLW  00
18BD2:  MOVLB  0
18BD4:  BZ    18BDC
18BD6:  XORLW  01
18BD8:  BZ    18C06
18BDA:  BRA    18C2E
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
18BDC:  BCF    FD8.0
18BDE:  MOVLB  7
18BE0:  RLCF   x3C,W
18BE2:  CLRF   03
18BE4:  ADDLW  6A
18BE6:  MOVWF  FE9
18BE8:  MOVLW  07
18BEA:  ADDWFC 03,W
18BEC:  MOVWF  FEA
18BEE:  MOVFF  FEC,8CD
18BF2:  MOVF   FED,F
18BF4:  MOVFF  FEF,8CC
18BF8:  MOVLW  76
18BFA:  MOVLB  8
18BFC:  MOVWF  xCB
18BFE:  MOVLB  0
18C00:  CALL   4F4C
....................             break; 
18C04:  BRA    18C2E
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
18C06:  BCF    FD8.0
18C08:  MOVLB  7
18C0A:  RLCF   x3C,W
18C0C:  CLRF   03
18C0E:  ADDLW  6A
18C10:  MOVWF  FE9
18C12:  MOVLW  07
18C14:  ADDWFC 03,W
18C16:  MOVWF  FEA
18C18:  MOVFF  FEC,8CD
18C1C:  MOVF   FED,F
18C1E:  MOVFF  FEF,8CC
18C22:  MOVLW  78
18C24:  MOVLB  8
18C26:  MOVWF  xCB
18C28:  MOVLB  0
18C2A:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
18C2E:  BRA    18C34
....................    else cmd_arg();    
18C30:  CALL   AF66
18C34:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
18C38:  MOVF   47,F
18C3A:  BNZ   18CC6
18C3C:  MOVF   46,F
18C3E:  BNZ   18CC6
18C40:  MOVF   45,F
18C42:  BNZ   18CC6
18C44:  MOVF   44,W
18C46:  SUBLW  03
18C48:  BNC   18CC6
....................       e_mode[motor] = arg; 
18C4A:  BCF    FD8.0
18C4C:  MOVLB  7
18C4E:  RLCF   x3C,W
18C50:  CLRF   03
18C52:  ADDLW  62
18C54:  MOVWF  FE9
18C56:  MOVLW  07
18C58:  ADDWFC 03,W
18C5A:  MOVWF  FEA
18C5C:  MOVFF  44,FEF
18C60:  MOVFF  45,FEC
....................       switch(motor){ 
18C64:  MOVF   x3C,W
18C66:  XORLW  00
18C68:  MOVLB  0
18C6A:  BZ    18C72
18C6C:  XORLW  01
18C6E:  BZ    18C9C
18C70:  BRA    18CC4
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
18C72:  BCF    FD8.0
18C74:  MOVLB  7
18C76:  RLCF   x3C,W
18C78:  CLRF   03
18C7A:  ADDLW  62
18C7C:  MOVWF  FE9
18C7E:  MOVLW  07
18C80:  ADDWFC 03,W
18C82:  MOVWF  FEA
18C84:  MOVFF  FEC,8CD
18C88:  MOVF   FED,F
18C8A:  MOVFF  FEF,8CC
18C8E:  MOVLW  82
18C90:  MOVLB  8
18C92:  MOVWF  xCB
18C94:  MOVLB  0
18C96:  CALL   4F4C
....................             break; 
18C9A:  BRA    18CC4
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
18C9C:  BCF    FD8.0
18C9E:  MOVLB  7
18CA0:  RLCF   x3C,W
18CA2:  CLRF   03
18CA4:  ADDLW  62
18CA6:  MOVWF  FE9
18CA8:  MOVLW  07
18CAA:  ADDWFC 03,W
18CAC:  MOVWF  FEA
18CAE:  MOVFF  FEC,8CD
18CB2:  MOVF   FED,F
18CB4:  MOVFF  FEF,8CC
18CB8:  MOVLW  84
18CBA:  MOVLB  8
18CBC:  MOVWF  xCB
18CBE:  MOVLB  0
18CC0:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
18CC4:  BRA    18CCA
....................    else cmd_arg();    
18CC6:  CALL   AF66
18CCA:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
1992E:  MOVF   47,F
19930:  BNZ   199BC
19932:  MOVF   46,F
19934:  BNZ   199BC
19936:  MOVF   45,F
19938:  BNZ   199BC
1993A:  MOVF   44,W
1993C:  SUBLW  01
1993E:  BNC   199BC
....................       m_mode[motor] = arg; 
19940:  BCF    FD8.0
19942:  MOVLB  7
19944:  RLCF   x3C,W
19946:  CLRF   03
19948:  ADDLW  42
1994A:  MOVWF  FE9
1994C:  MOVLW  07
1994E:  ADDWFC 03,W
19950:  MOVWF  FEA
19952:  MOVFF  44,FEF
19956:  MOVFF  45,FEC
....................       switch(motor){ 
1995A:  MOVF   x3C,W
1995C:  XORLW  00
1995E:  MOVLB  0
19960:  BZ    19968
19962:  XORLW  01
19964:  BZ    19992
19966:  BRA    199BA
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
19968:  BCF    FD8.0
1996A:  MOVLB  7
1996C:  RLCF   x3C,W
1996E:  CLRF   03
19970:  ADDLW  42
19972:  MOVWF  FE9
19974:  MOVLW  07
19976:  ADDWFC 03,W
19978:  MOVWF  FEA
1997A:  MOVFF  FEC,8CD
1997E:  MOVF   FED,F
19980:  MOVFF  FEF,8CC
19984:  MOVLW  8A
19986:  MOVLB  8
19988:  MOVWF  xCB
1998A:  MOVLB  0
1998C:  CALL   4F4C
....................             break; 
19990:  BRA    199BA
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
19992:  BCF    FD8.0
19994:  MOVLB  7
19996:  RLCF   x3C,W
19998:  CLRF   03
1999A:  ADDLW  42
1999C:  MOVWF  FE9
1999E:  MOVLW  07
199A0:  ADDWFC 03,W
199A2:  MOVWF  FEA
199A4:  MOVFF  FEC,8CD
199A8:  MOVF   FED,F
199AA:  MOVFF  FEF,8CC
199AE:  MOVLW  8C
199B0:  MOVLB  8
199B2:  MOVWF  xCB
199B4:  MOVLB  0
199B6:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
199BA:  BRA    199C0
....................    else cmd_arg();    
199BC:  CALL   AF66
199C0:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
199C4:  MOVF   47,F
199C6:  BNZ   19A52
199C8:  MOVF   46,F
199CA:  BNZ   19A52
199CC:  MOVF   45,F
199CE:  BNZ   19A52
199D0:  MOVF   44,W
199D2:  SUBLW  01
199D4:  BNC   19A52
....................       e_index[motor] = arg; 
199D6:  BCF    FD8.0
199D8:  MOVLB  7
199DA:  RLCF   x3C,W
199DC:  CLRF   03
199DE:  ADDLW  76
199E0:  MOVWF  FE9
199E2:  MOVLW  07
199E4:  ADDWFC 03,W
199E6:  MOVWF  FEA
199E8:  MOVFF  44,FEF
199EC:  MOVFF  45,FEC
....................       switch(motor){ 
199F0:  MOVF   x3C,W
199F2:  XORLW  00
199F4:  MOVLB  0
199F6:  BZ    199FE
199F8:  XORLW  01
199FA:  BZ    19A28
199FC:  BRA    19A50
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
199FE:  BCF    FD8.0
19A00:  MOVLB  7
19A02:  RLCF   x3C,W
19A04:  CLRF   03
19A06:  ADDLW  76
19A08:  MOVWF  FE9
19A0A:  MOVLW  07
19A0C:  ADDWFC 03,W
19A0E:  MOVWF  FEA
19A10:  MOVFF  FEC,8CD
19A14:  MOVF   FED,F
19A16:  MOVFF  FEF,8CC
19A1A:  MOVLW  BA
19A1C:  MOVLB  8
19A1E:  MOVWF  xCB
19A20:  MOVLB  0
19A22:  CALL   4F4C
....................             break; 
19A26:  BRA    19A50
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
19A28:  BCF    FD8.0
19A2A:  MOVLB  7
19A2C:  RLCF   x3C,W
19A2E:  CLRF   03
19A30:  ADDLW  76
19A32:  MOVWF  FE9
19A34:  MOVLW  07
19A36:  ADDWFC 03,W
19A38:  MOVWF  FEA
19A3A:  MOVFF  FEC,8CD
19A3E:  MOVF   FED,F
19A40:  MOVFF  FEF,8CC
19A44:  MOVLW  BC
19A46:  MOVLB  8
19A48:  MOVWF  xCB
19A4A:  MOVLB  0
19A4C:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
19A50:  BRA    19A56
....................    else cmd_arg();    
19A52:  CALL   AF66
19A56:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
19A5A:  MOVF   47,F
19A5C:  BNZ   19AEC
19A5E:  MOVF   46,F
19A60:  BNZ   19AEC
19A62:  MOVF   45,W
19A64:  SUBLW  01
19A66:  BNC   19AEC
19A68:  BNZ   19A70
19A6A:  MOVF   44,W
19A6C:  SUBLW  0A
19A6E:  BNC   19AEC
....................        evn_so[motor] = arg; 
19A70:  BCF    FD8.0
19A72:  MOVLB  7
19A74:  RLCF   x3C,W
19A76:  CLRF   03
19A78:  ADDLW  7A
19A7A:  MOVWF  FE9
19A7C:  MOVLW  07
19A7E:  ADDWFC 03,W
19A80:  MOVWF  FEA
19A82:  MOVFF  44,FEF
19A86:  MOVFF  45,FEC
....................        switch(motor){ 
19A8A:  MOVF   x3C,W
19A8C:  XORLW  00
19A8E:  MOVLB  0
19A90:  BZ    19A98
19A92:  XORLW  01
19A94:  BZ    19AC2
19A96:  BRA    19AEA
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
19A98:  BCF    FD8.0
19A9A:  MOVLB  7
19A9C:  RLCF   x3C,W
19A9E:  CLRF   03
19AA0:  ADDLW  7A
19AA2:  MOVWF  FE9
19AA4:  MOVLW  07
19AA6:  ADDWFC 03,W
19AA8:  MOVWF  FEA
19AAA:  MOVFF  FEC,8CD
19AAE:  MOVF   FED,F
19AB0:  MOVFF  FEF,8CC
19AB4:  MOVLW  BE
19AB6:  MOVLB  8
19AB8:  MOVWF  xCB
19ABA:  MOVLB  0
19ABC:  CALL   4F4C
....................             break; 
19AC0:  BRA    19AEA
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
19AC2:  BCF    FD8.0
19AC4:  MOVLB  7
19AC6:  RLCF   x3C,W
19AC8:  CLRF   03
19ACA:  ADDLW  7A
19ACC:  MOVWF  FE9
19ACE:  MOVLW  07
19AD0:  ADDWFC 03,W
19AD2:  MOVWF  FEA
19AD4:  MOVFF  FEC,8CD
19AD8:  MOVF   FED,F
19ADA:  MOVFF  FEF,8CC
19ADE:  MOVLW  C0
19AE0:  MOVLB  8
19AE2:  MOVWF  xCB
19AE4:  MOVLB  0
19AE6:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
19AEA:  BRA    19AF0
....................    else cmd_arg();    
19AEC:  CALL   AF66
19AF0:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
19AF4:  MOVF   47,F
19AF6:  BNZ   19B86
19AF8:  MOVF   46,F
19AFA:  BNZ   19B86
19AFC:  MOVF   45,W
19AFE:  SUBLW  03
19B00:  BNC   19B86
19B02:  BNZ   19B0A
19B04:  MOVF   44,W
19B06:  SUBLW  E8
19B08:  BNC   19B86
....................       e_ppr[motor] = arg; 
19B0A:  BCF    FD8.0
19B0C:  MOVLB  7
19B0E:  RLCF   x3C,W
19B10:  CLRF   03
19B12:  ADDLW  5E
19B14:  MOVWF  FE9
19B16:  MOVLW  07
19B18:  ADDWFC 03,W
19B1A:  MOVWF  FEA
19B1C:  MOVFF  44,FEF
19B20:  MOVFF  45,FEC
....................       switch(motor){ 
19B24:  MOVF   x3C,W
19B26:  XORLW  00
19B28:  MOVLB  0
19B2A:  BZ    19B32
19B2C:  XORLW  01
19B2E:  BZ    19B5C
19B30:  BRA    19B84
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
19B32:  BCF    FD8.0
19B34:  MOVLB  7
19B36:  RLCF   x3C,W
19B38:  CLRF   03
19B3A:  ADDLW  5E
19B3C:  MOVWF  FE9
19B3E:  MOVLW  07
19B40:  ADDWFC 03,W
19B42:  MOVWF  FEA
19B44:  MOVFF  FEC,8CD
19B48:  MOVF   FED,F
19B4A:  MOVFF  FEF,8CC
19B4E:  MOVLW  A6
19B50:  MOVLB  8
19B52:  MOVWF  xCB
19B54:  MOVLB  0
19B56:  CALL   4F4C
....................             break; 
19B5A:  BRA    19B84
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
19B5C:  BCF    FD8.0
19B5E:  MOVLB  7
19B60:  RLCF   x3C,W
19B62:  CLRF   03
19B64:  ADDLW  5E
19B66:  MOVWF  FE9
19B68:  MOVLW  07
19B6A:  ADDWFC 03,W
19B6C:  MOVWF  FEA
19B6E:  MOVFF  FEC,8CD
19B72:  MOVF   FED,F
19B74:  MOVFF  FEF,8CC
19B78:  MOVLW  A8
19B7A:  MOVLB  8
19B7C:  MOVWF  xCB
19B7E:  MOVLB  0
19B80:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
19B84:  BRA    19B8A
....................    else cmd_arg();    
19B86:  CALL   AF66
19B8A:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
19B8E:  MOVF   44,F
19B90:  BNZ   19BA2
19B92:  MOVF   45,F
19B94:  BNZ   19BA2
19B96:  MOVF   46,F
19B98:  BNZ   19BA2
19B9A:  MOVF   47,F
19B9C:  BNZ   19BA2
19B9E:  BCF    F8E.1
19BA0:  BRA    19BA6
....................    else cmd_arg();    
19BA2:  CALL   AF66
19BA6:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1A68A:  MOVF   44,F
1A68C:  BNZ   1A6DC
1A68E:  MOVF   45,F
1A690:  BNZ   1A6DC
1A692:  MOVF   46,F
1A694:  BNZ   1A6DC
1A696:  MOVF   47,F
1A698:  BNZ   1A6DC
....................       switch (nv_product) { 
1A69A:  MOVFF  2F,00
1A69E:  MOVF   30,W
1A6A0:  MOVWF  03
1A6A2:  BNZ   1A6A8
1A6A4:  MOVF   00,F
1A6A6:  BZ    1A6C8
1A6A8:  MOVF   03,W
1A6AA:  BNZ   1A6B2
1A6AC:  MOVLW  01
1A6AE:  SUBWF  00,W
1A6B0:  BZ    1A6CE
1A6B2:  MOVF   03,W
1A6B4:  BNZ   1A6BC
1A6B6:  MOVLW  02
1A6B8:  SUBWF  00,W
1A6BA:  BZ    1A6D4
1A6BC:  MOVF   03,W
1A6BE:  BNZ   1A6C6
1A6C0:  MOVLW  03
1A6C2:  SUBWF  00,W
1A6C4:  BZ    1A6D8
1A6C6:  BRA    1A6DA
....................          case ECO : rst_step_vars_eco(); 
1A6C8:  GOTO   19BAA
....................             break; 
1A6CC:  BRA    1A6DA
....................          case WMS4 : rst_step_vars_wms4(); 
1A6CE:  GOTO   19E94
....................             break; 
1A6D2:  BRA    1A6DA
....................          case AWS : rst_step_vars_aws(); 
1A6D4:  BRA    1A140
....................             break;             
1A6D6:  BRA    1A6DA
....................          case WMS2 : rst_step_vars_wms2(); 
1A6D8:  BRA    1A3DA
....................             break; 
....................       } 
....................    }  
1A6DA:  BRA    1A6E0
....................    else cmd_arg(); 
1A6DC:  CALL   AF66
1A6E0:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1A6E4:  MOVF   47,F
1A6E6:  BTFSS  FD8.2
1A6E8:  BRA    1A7EA
1A6EA:  MOVF   46,W
1A6EC:  SUBLW  00
1A6EE:  BTFSS  FD8.0
1A6F0:  BRA    1A7EA
....................       m_spr[motor] = arg; 
1A6F2:  BCF    FD8.0
1A6F4:  MOVLB  7
1A6F6:  RLCF   x3C,W
1A6F8:  CLRF   03
1A6FA:  ADDLW  72
1A6FC:  MOVWF  FE9
1A6FE:  MOVLW  07
1A700:  ADDWFC 03,W
1A702:  MOVWF  FEA
1A704:  MOVFF  44,FEF
1A708:  MOVFF  45,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1A70C:  BCF    FD8.0
1A70E:  RLCF   x3C,W
1A710:  CLRF   03
1A712:  ADDLW  A7
1A714:  MOVWF  01
1A716:  MOVLW  07
1A718:  ADDWFC 03,F
1A71A:  MOVFF  01,862
1A71E:  MOVLB  8
1A720:  MOVFF  03,863
1A724:  BCF    FD8.0
1A726:  MOVLB  7
1A728:  RLCF   x3C,W
1A72A:  CLRF   03
1A72C:  ADDLW  72
1A72E:  MOVWF  FE9
1A730:  MOVLW  07
1A732:  ADDWFC 03,W
1A734:  MOVWF  FEA
1A736:  MOVFF  FEC,8B9
1A73A:  MOVF   FED,F
1A73C:  MOVFF  FEF,8B8
1A740:  BCF    FD8.0
1A742:  RLCF   x3C,W
1A744:  CLRF   03
1A746:  ADDLW  5E
1A748:  MOVWF  FE9
1A74A:  MOVLW  07
1A74C:  ADDWFC 03,W
1A74E:  MOVWF  FEA
1A750:  MOVFF  FEC,03
1A754:  MOVF   FED,F
1A756:  MOVFF  FEF,8BA
1A75A:  MOVFF  03,867
1A75E:  MOVFF  03,8BB
1A762:  MOVLB  0
1A764:  CALL   2C52
1A768:  MOVFF  02,865
1A76C:  BCF    FD8.0
1A76E:  MOVLB  8
1A770:  RLCF   01,W
1A772:  MOVWF  02
1A774:  RLCF   x65,W
1A776:  MOVFF  863,FEA
1A77A:  MOVFF  862,FE9
1A77E:  MOVWF  FEC
1A780:  MOVF   FED,F
1A782:  MOVFF  02,FEF
....................       switch(motor){ 
1A786:  MOVLB  7
1A788:  MOVF   x3C,W
1A78A:  XORLW  00
1A78C:  MOVLB  0
1A78E:  BZ    1A796
1A790:  XORLW  01
1A792:  BZ    1A7C0
1A794:  BRA    1A7E8
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1A796:  BCF    FD8.0
1A798:  MOVLB  7
1A79A:  RLCF   x3C,W
1A79C:  CLRF   03
1A79E:  ADDLW  72
1A7A0:  MOVWF  FE9
1A7A2:  MOVLW  07
1A7A4:  ADDWFC 03,W
1A7A6:  MOVWF  FEA
1A7A8:  MOVFF  FEC,8CD
1A7AC:  MOVF   FED,F
1A7AE:  MOVFF  FEF,8CC
1A7B2:  MOVLW  AE
1A7B4:  MOVLB  8
1A7B6:  MOVWF  xCB
1A7B8:  MOVLB  0
1A7BA:  CALL   4F4C
....................             break; 
1A7BE:  BRA    1A7E8
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1A7C0:  BCF    FD8.0
1A7C2:  MOVLB  7
1A7C4:  RLCF   x3C,W
1A7C6:  CLRF   03
1A7C8:  ADDLW  72
1A7CA:  MOVWF  FE9
1A7CC:  MOVLW  07
1A7CE:  ADDWFC 03,W
1A7D0:  MOVWF  FEA
1A7D2:  MOVFF  FEC,8CD
1A7D6:  MOVF   FED,F
1A7D8:  MOVFF  FEF,8CC
1A7DC:  MOVLW  B0
1A7DE:  MOVLB  8
1A7E0:  MOVWF  xCB
1A7E2:  MOVLB  0
1A7E4:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
1A7E8:  BRA    1A7EE
....................    else cmd_arg();    
1A7EA:  CALL   AF66
1A7EE:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1A7F2:  MOVF   47,F
1A7F4:  BNZ   1A880
1A7F6:  MOVF   46,F
1A7F8:  BNZ   1A880
1A7FA:  MOVF   45,F
1A7FC:  BNZ   1A880
1A7FE:  MOVF   44,W
1A800:  SUBLW  02
1A802:  BNC   1A880
....................       e_type[motor] = arg; 
1A804:  BCF    FD8.0
1A806:  MOVLB  7
1A808:  RLCF   x3C,W
1A80A:  CLRF   03
1A80C:  ADDLW  66
1A80E:  MOVWF  FE9
1A810:  MOVLW  07
1A812:  ADDWFC 03,W
1A814:  MOVWF  FEA
1A816:  MOVFF  44,FEF
1A81A:  MOVFF  45,FEC
....................       switch(motor){ 
1A81E:  MOVF   x3C,W
1A820:  XORLW  00
1A822:  MOVLB  0
1A824:  BZ    1A82C
1A826:  XORLW  01
1A828:  BZ    1A856
1A82A:  BRA    1A87E
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1A82C:  BCF    FD8.0
1A82E:  MOVLB  7
1A830:  RLCF   x3C,W
1A832:  CLRF   03
1A834:  ADDLW  66
1A836:  MOVWF  FE9
1A838:  MOVLW  07
1A83A:  ADDWFC 03,W
1A83C:  MOVWF  FEA
1A83E:  MOVFF  FEC,8CD
1A842:  MOVF   FED,F
1A844:  MOVFF  FEF,8CC
1A848:  MOVLW  7A
1A84A:  MOVLB  8
1A84C:  MOVWF  xCB
1A84E:  MOVLB  0
1A850:  CALL   4F4C
....................             break; 
1A854:  BRA    1A87E
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1A856:  BCF    FD8.0
1A858:  MOVLB  7
1A85A:  RLCF   x3C,W
1A85C:  CLRF   03
1A85E:  ADDLW  66
1A860:  MOVWF  FE9
1A862:  MOVLW  07
1A864:  ADDWFC 03,W
1A866:  MOVWF  FEA
1A868:  MOVFF  FEC,8CD
1A86C:  MOVF   FED,F
1A86E:  MOVFF  FEF,8CC
1A872:  MOVLW  7C
1A874:  MOVLB  8
1A876:  MOVWF  xCB
1A878:  MOVLB  0
1A87A:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
1A87E:  BRA    1A884
....................    else cmd_arg();    
1A880:  CALL   AF66
1A884:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
*
1A8C0:  MOVF   47,F
1A8C2:  BNZ   1A98C
1A8C4:  MOVF   46,F
1A8C6:  BNZ   1A98C
1A8C8:  MOVF   45,F
1A8CA:  BNZ   1A98C
1A8CC:  MOVF   44,W
1A8CE:  SUBLW  64
1A8D0:  BNC   1A98C
....................       drive_pc=arg; 
1A8D2:  MOVFF  45,863
1A8D6:  MOVFF  44,862
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1A8DA:  BCF    FD8.0
1A8DC:  MOVLB  7
1A8DE:  RLCF   x3C,W
1A8E0:  CLRF   03
1A8E2:  ADDLW  52
1A8E4:  MOVWF  FE9
1A8E6:  MOVLW  07
1A8E8:  ADDWFC 03,W
1A8EA:  MOVWF  FEA
1A8EC:  MOVFF  863,9EA
1A8F0:  MOVFF  862,9E9
1A8F4:  MOVLW  01
1A8F6:  MOVLB  9
1A8F8:  MOVWF  xEC
1A8FA:  SETF   xEB
1A8FC:  MOVLB  0
1A8FE:  CALL   5C0E
1A902:  MOVFF  02,867
1A906:  MOVFF  01,866
1A90A:  MOVFF  02,8B9
1A90E:  MOVFF  01,8B8
1A912:  MOVLB  8
1A914:  CLRF   xBB
1A916:  MOVLW  64
1A918:  MOVWF  xBA
1A91A:  MOVLB  0
1A91C:  CALL   2C52
1A920:  MOVFF  01,FEF
1A924:  MOVFF  02,FEC
....................       switch(motor){ 
1A928:  MOVLB  7
1A92A:  MOVF   x3C,W
1A92C:  XORLW  00
1A92E:  MOVLB  0
1A930:  BZ    1A938
1A932:  XORLW  01
1A934:  BZ    1A962
1A936:  BRA    1A98A
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1A938:  BCF    FD8.0
1A93A:  MOVLB  7
1A93C:  RLCF   x3C,W
1A93E:  CLRF   03
1A940:  ADDLW  52
1A942:  MOVWF  FE9
1A944:  MOVLW  07
1A946:  ADDWFC 03,W
1A948:  MOVWF  FEA
1A94A:  MOVFF  FEC,8CD
1A94E:  MOVF   FED,F
1A950:  MOVFF  FEF,8CC
1A954:  MOVLW  9A
1A956:  MOVLB  8
1A958:  MOVWF  xCB
1A95A:  MOVLB  0
1A95C:  CALL   4F4C
....................             break; 
1A960:  BRA    1A98A
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1A962:  BCF    FD8.0
1A964:  MOVLB  7
1A966:  RLCF   x3C,W
1A968:  CLRF   03
1A96A:  ADDLW  52
1A96C:  MOVWF  FE9
1A96E:  MOVLW  07
1A970:  ADDWFC 03,W
1A972:  MOVWF  FEA
1A974:  MOVFF  FEC,8CD
1A978:  MOVF   FED,F
1A97A:  MOVFF  FEF,8CC
1A97E:  MOVLW  9C
1A980:  MOVLB  8
1A982:  MOVWF  xCB
1A984:  MOVLB  0
1A986:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
1A98A:  BRA    1A990
....................    else cmd_arg();    
1A98C:  CALL   AF66
1A990:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1A994:  MOVF   47,F
1A996:  BNZ   1AA26
1A998:  MOVF   46,F
1A99A:  BNZ   1AA26
1A99C:  MOVF   45,W
1A99E:  SUBLW  27
1A9A0:  BNC   1AA26
1A9A2:  BNZ   1A9AA
1A9A4:  MOVF   44,W
1A9A6:  SUBLW  0F
1A9A8:  BNC   1AA26
....................        align_os[motor] = arg; 
1A9AA:  BCF    FD8.0
1A9AC:  MOVLB  7
1A9AE:  RLCF   x3C,W
1A9B0:  CLRF   03
1A9B2:  ADDLW  7E
1A9B4:  MOVWF  FE9
1A9B6:  MOVLW  07
1A9B8:  ADDWFC 03,W
1A9BA:  MOVWF  FEA
1A9BC:  MOVFF  44,FEF
1A9C0:  MOVFF  45,FEC
....................        switch(motor){ 
1A9C4:  MOVF   x3C,W
1A9C6:  XORLW  00
1A9C8:  MOVLB  0
1A9CA:  BZ    1A9D2
1A9CC:  XORLW  01
1A9CE:  BZ    1A9FC
1A9D0:  BRA    1AA24
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1A9D2:  BCF    FD8.0
1A9D4:  MOVLB  7
1A9D6:  RLCF   x3C,W
1A9D8:  CLRF   03
1A9DA:  ADDLW  7E
1A9DC:  MOVWF  FE9
1A9DE:  MOVLW  07
1A9E0:  ADDWFC 03,W
1A9E2:  MOVWF  FEA
1A9E4:  MOVFF  FEC,8CD
1A9E8:  MOVF   FED,F
1A9EA:  MOVFF  FEF,8CC
1A9EE:  MOVLW  C2
1A9F0:  MOVLB  8
1A9F2:  MOVWF  xCB
1A9F4:  MOVLB  0
1A9F6:  CALL   4F4C
....................             break; 
1A9FA:  BRA    1AA24
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1A9FC:  BCF    FD8.0
1A9FE:  MOVLB  7
1AA00:  RLCF   x3C,W
1AA02:  CLRF   03
1AA04:  ADDLW  7E
1AA06:  MOVWF  FE9
1AA08:  MOVLW  07
1AA0A:  ADDWFC 03,W
1AA0C:  MOVWF  FEA
1AA0E:  MOVFF  FEC,8CD
1AA12:  MOVF   FED,F
1AA14:  MOVFF  FEF,8CC
1AA18:  MOVLW  C4
1AA1A:  MOVLB  8
1AA1C:  MOVWF  xCB
1AA1E:  MOVLB  0
1AA20:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
1AA24:  BRA    1AA2A
....................    else cmd_arg();    
1AA26:  CALL   AF66
1AA2A:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1AA2E:  MOVF   47,F
1AA30:  BNZ   1AABC
1AA32:  MOVF   46,F
1AA34:  BNZ   1AABC
1AA36:  MOVF   45,F
1AA38:  BNZ   1AABC
1AA3A:  MOVF   44,W
1AA3C:  SUBLW  01
1AA3E:  BNC   1AABC
....................       m_ctrl[motor] = arg; 
1AA40:  BCF    FD8.0
1AA42:  MOVLB  7
1AA44:  RLCF   x3C,W
1AA46:  CLRF   03
1AA48:  ADDLW  3E
1AA4A:  MOVWF  FE9
1AA4C:  MOVLW  07
1AA4E:  ADDWFC 03,W
1AA50:  MOVWF  FEA
1AA52:  MOVFF  44,FEF
1AA56:  MOVFF  45,FEC
....................       switch(motor){ 
1AA5A:  MOVF   x3C,W
1AA5C:  XORLW  00
1AA5E:  MOVLB  0
1AA60:  BZ    1AA68
1AA62:  XORLW  01
1AA64:  BZ    1AA92
1AA66:  BRA    1AABA
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1AA68:  BCF    FD8.0
1AA6A:  MOVLB  7
1AA6C:  RLCF   x3C,W
1AA6E:  CLRF   03
1AA70:  ADDLW  3E
1AA72:  MOVWF  FE9
1AA74:  MOVLW  07
1AA76:  ADDWFC 03,W
1AA78:  MOVWF  FEA
1AA7A:  MOVFF  FEC,8CD
1AA7E:  MOVF   FED,F
1AA80:  MOVFF  FEF,8CC
1AA84:  MOVLW  86
1AA86:  MOVLB  8
1AA88:  MOVWF  xCB
1AA8A:  MOVLB  0
1AA8C:  CALL   4F4C
....................             break; 
1AA90:  BRA    1AABA
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1AA92:  BCF    FD8.0
1AA94:  MOVLB  7
1AA96:  RLCF   x3C,W
1AA98:  CLRF   03
1AA9A:  ADDLW  3E
1AA9C:  MOVWF  FE9
1AA9E:  MOVLW  07
1AAA0:  ADDWFC 03,W
1AAA2:  MOVWF  FEA
1AAA4:  MOVFF  FEC,8CD
1AAA8:  MOVF   FED,F
1AAAA:  MOVFF  FEF,8CC
1AAAE:  MOVLW  88
1AAB0:  MOVLB  8
1AAB2:  MOVWF  xCB
1AAB4:  MOVLB  0
1AAB6:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
1AABA:  BRA    1AAC0
....................    else cmd_arg();    
1AABC:  CALL   AF66
1AAC0:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1A888:  MOVF   44,W
1A88A:  MOVWF  00
1A88C:  MOVF   45,W
1A88E:  MOVWF  03
1A890:  BNZ   1A898
1A892:  MOVLW  01
1A894:  SUBWF  00,W
1A896:  BZ    1A8A4
1A898:  MOVF   03,W
1A89A:  BNZ   1A8A2
1A89C:  MOVLW  02
1A89E:  SUBWF  00,W
1A8A0:  BZ    1A8AA
1A8A2:  BRA    1A8B4
....................       case 1: motor = 0; 
1A8A4:  MOVLB  7
1A8A6:  CLRF   x3C
....................          break; 
1A8A8:  BRA    1A8BA
....................       case 2: motor = 1; 
1A8AA:  MOVLW  01
1A8AC:  MOVLB  7
1A8AE:  MOVWF  x3C
....................          break; 
1A8B0:  BRA    1A8BA
1A8B2:  MOVLB  0
....................       default : cmd_arg(); 
1A8B4:  CALL   AF66
....................          break; 
1A8B8:  MOVLB  7
....................    } 
1A8BA:  MOVLB  0
1A8BC:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1AAC4:  MOVF   44,F
1AAC6:  BNZ   1AAD4
1AAC8:  MOVF   45,F
1AACA:  BNZ   1AAD4
1AACC:  MOVF   46,F
1AACE:  BNZ   1AAD4
1AAD0:  MOVF   47,F
1AAD2:  BZ    1AB32
1AAD4:  MOVF   47,F
1AAD6:  BNZ   1AB32
1AAD8:  MOVF   46,F
1AADA:  BNZ   1AB32
1AADC:  MOVF   45,F
1AADE:  BNZ   1AB32
1AAE0:  MOVF   44,W
1AAE2:  SUBLW  02
1AAE4:  BNC   1AB32
....................       switch(arg){ 
1AAE6:  MOVFF  44,00
1AAEA:  MOVF   45,W
1AAEC:  MOVWF  03
1AAEE:  BNZ   1AAF6
1AAF0:  MOVLW  01
1AAF2:  SUBWF  00,W
1AAF4:  BZ    1AB02
1AAF6:  MOVF   03,W
1AAF8:  BNZ   1AB00
1AAFA:  MOVLW  02
1AAFC:  SUBWF  00,W
1AAFE:  BZ    1AB1A
1AB00:  BRA    1AB30
....................          case 1 : e_pos[0] = 0; 
1AB02:  MOVLB  7
1AB04:  CLRF   xBC
1AB06:  CLRF   xBB
....................                   write16(ADDR_E1_POS, 0); 
1AB08:  MOVLW  7E
1AB0A:  MOVLB  8
1AB0C:  MOVWF  xCB
1AB0E:  CLRF   xCD
1AB10:  CLRF   xCC
1AB12:  MOVLB  0
1AB14:  CALL   4F4C
....................             break; 
1AB18:  BRA    1AB30
....................          case 2 : e_pos[1] = 0; 
1AB1A:  MOVLB  7
1AB1C:  CLRF   xBE
1AB1E:  CLRF   xBD
....................                   write16(ADDR_E2_POS, 0); 
1AB20:  MOVLW  80
1AB22:  MOVLB  8
1AB24:  MOVWF  xCB
1AB26:  CLRF   xCD
1AB28:  CLRF   xCC
1AB2A:  MOVLB  0
1AB2C:  CALL   4F4C
....................             break;             
....................       } 
....................    } 
1AB30:  BRA    1AB36
....................    else cmd_arg();  
1AB32:  CALL   AF66
1AB36:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
18CCE:  DECFSZ 44,W
18CD0:  GOTO   19926
18CD4:  MOVF   45,F
18CD6:  BTFSS  FD8.2
18CD8:  GOTO   19926
18CDC:  MOVF   46,F
18CDE:  BTFSS  FD8.2
18CE0:  GOTO   19926
18CE4:  MOVF   47,F
18CE6:  BTFSS  FD8.2
18CE8:  GOTO   19926
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18CEC:  MOVFF  74F,9EA
18CF0:  MOVFF  74E,9E9
18CF4:  MOVLB  9
18CF6:  CLRF   xEC
18CF8:  MOVLW  64
18CFA:  MOVWF  xEB
18CFC:  MOVLB  0
18CFE:  CALL   5C0E
18D02:  MOVFF  02,869
18D06:  MOVFF  01,868
18D0A:  MOVFF  02,8B9
18D0E:  MOVFF  01,8B8
18D12:  MOVLW  01
18D14:  MOVLB  8
18D16:  MOVWF  xBB
18D18:  SETF   xBA
18D1A:  MOVLB  0
18D1C:  CALL   2C52
18D20:  MOVFF  02,863
18D24:  MOVFF  01,862
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18D28:  MOVFF  753,9EA
18D2C:  MOVFF  752,9E9
18D30:  MOVLB  9
18D32:  CLRF   xEC
18D34:  MOVLW  64
18D36:  MOVWF  xEB
18D38:  MOVLB  0
18D3A:  CALL   5C0E
18D3E:  MOVFF  02,869
18D42:  MOVFF  01,868
18D46:  MOVFF  02,8B9
18D4A:  MOVFF  01,8B8
18D4E:  MOVLW  01
18D50:  MOVLB  8
18D52:  MOVWF  xBB
18D54:  SETF   xBA
18D56:  MOVLB  0
18D58:  CALL   2C52
18D5C:  MOVFF  02,865
18D60:  MOVFF  01,864
....................       step_us  =   m_stp_int[0]*100; 
18D64:  MOVFF  747,9EA
18D68:  MOVFF  746,9E9
18D6C:  MOVLB  9
18D6E:  CLRF   xEC
18D70:  MOVLW  64
18D72:  MOVWF  xEB
18D74:  MOVLB  0
18D76:  CALL   5C0E
18D7A:  MOVFF  02,867
18D7E:  MOVFF  01,866
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
18D82:  MOVLW  FC
18D84:  MOVWF  FF6
18D86:  MOVLW  26
18D88:  MOVWF  FF7
18D8A:  MOVLW  00
18D8C:  MOVWF  FF8
18D8E:  CLRF   1B
18D90:  BTFSC  FF2.7
18D92:  BSF    1B.7
18D94:  BCF    FF2.7
18D96:  CALL   0E30
18D9A:  BTFSC  1B.7
18D9C:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
18D9E:  MOVLW  62
18DA0:  BTFSS  F9E.4
18DA2:  BRA    18DA0
18DA4:  MOVWF  FAD
18DA6:  MOVLW  3A
18DA8:  BTFSS  F9E.4
18DAA:  BRA    18DA8
18DAC:  MOVWF  FAD
18DAE:  MOVLW  10
18DB0:  MOVWF  FE9
18DB2:  CLRF   1B
18DB4:  BTFSC  FF2.7
18DB6:  BSF    1B.7
18DB8:  BCF    FF2.7
18DBA:  MOVFF  76F,A19
18DBE:  MOVFF  76E,A18
18DC2:  CALL   1188
18DC6:  BTFSC  1B.7
18DC8:  BSF    FF2.7
18DCA:  MOVLW  0D
18DCC:  BTFSS  F9E.4
18DCE:  BRA    18DCC
18DD0:  MOVWF  FAD
18DD2:  MOVLW  0A
18DD4:  BTFSS  F9E.4
18DD6:  BRA    18DD4
18DD8:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
18DDA:  MOVLW  63
18DDC:  BTFSS  F9E.4
18DDE:  BRA    18DDC
18DE0:  MOVWF  FAD
18DE2:  MOVLW  3A
18DE4:  BTFSS  F9E.4
18DE6:  BRA    18DE4
18DE8:  MOVWF  FAD
18DEA:  MOVLW  41
18DEC:  MOVWF  FE9
18DEE:  CLRF   1B
18DF0:  BTFSC  FF2.7
18DF2:  BSF    1B.7
18DF4:  BCF    FF2.7
18DF6:  MOVFF  7A1,A1B
18DFA:  MOVFF  7A0,A1A
18DFE:  MOVFF  79F,A19
18E02:  MOVFF  79E,A18
18E06:  CALL   10CC
18E0A:  BTFSC  1B.7
18E0C:  BSF    FF2.7
18E0E:  MOVLW  2F
18E10:  BTFSS  F9E.4
18E12:  BRA    18E10
18E14:  MOVWF  FAD
18E16:  MOVLW  10
18E18:  MOVWF  FE9
18E1A:  CLRF   1B
18E1C:  BTFSC  FF2.7
18E1E:  BSF    1B.7
18E20:  BCF    FF2.7
18E22:  MOVFF  7B8,A19
18E26:  MOVFF  7B7,A18
18E2A:  CALL   1188
18E2E:  BTFSC  1B.7
18E30:  BSF    FF2.7
18E32:  MOVLW  2F
18E34:  BTFSS  F9E.4
18E36:  BRA    18E34
18E38:  MOVWF  FAD
18E3A:  MOVLW  10
18E3C:  MOVWF  FE9
18E3E:  CLRF   1B
18E40:  BTFSC  FF2.7
18E42:  BSF    1B.7
18E44:  BCF    FF2.7
18E46:  MOVFF  7BC,A19
18E4A:  MOVFF  7BB,A18
18E4E:  CALL   1188
18E52:  BTFSC  1B.7
18E54:  BSF    FF2.7
18E56:  MOVLW  0D
18E58:  BTFSS  F9E.4
18E5A:  BRA    18E58
18E5C:  MOVWF  FAD
18E5E:  MOVLW  0A
18E60:  BTFSS  F9E.4
18E62:  BRA    18E60
18E64:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
18E66:  MOVLW  64
18E68:  BTFSS  F9E.4
18E6A:  BRA    18E68
18E6C:  MOVWF  FAD
18E6E:  MOVLW  3A
18E70:  BTFSS  F9E.4
18E72:  BRA    18E70
18E74:  MOVWF  FAD
18E76:  MOVLW  10
18E78:  MOVWF  FE9
18E7A:  CLRF   1B
18E7C:  BTFSC  FF2.7
18E7E:  BSF    1B.7
18E80:  BCF    FF2.7
18E82:  MOVFF  74B,A19
18E86:  MOVFF  74A,A18
18E8A:  CALL   1188
18E8E:  BTFSC  1B.7
18E90:  BSF    FF2.7
18E92:  MOVLW  0D
18E94:  BTFSS  F9E.4
18E96:  BRA    18E94
18E98:  MOVWF  FAD
18E9A:  MOVLW  0A
18E9C:  BTFSS  F9E.4
18E9E:  BRA    18E9C
18EA0:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
18EA2:  MOVLW  65
18EA4:  BTFSS  F9E.4
18EA6:  BRA    18EA4
18EA8:  MOVWF  FAD
18EAA:  MOVLW  3A
18EAC:  BTFSS  F9E.4
18EAE:  BRA    18EAC
18EB0:  MOVWF  FAD
18EB2:  MOVLW  10
18EB4:  MOVWF  FE9
18EB6:  CLRF   1B
18EB8:  BTFSC  FF2.7
18EBA:  BSF    1B.7
18EBC:  BCF    FF2.7
18EBE:  MOVFF  75B,A19
18EC2:  MOVFF  75A,A18
18EC6:  CALL   1188
18ECA:  BTFSC  1B.7
18ECC:  BSF    FF2.7
18ECE:  MOVLW  0D
18ED0:  BTFSS  F9E.4
18ED2:  BRA    18ED0
18ED4:  MOVWF  FAD
18ED6:  MOVLW  0A
18ED8:  BTFSS  F9E.4
18EDA:  BRA    18ED8
18EDC:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
18EDE:  MOVLW  66
18EE0:  BTFSS  F9E.4
18EE2:  BRA    18EE0
18EE4:  MOVWF  FAD
18EE6:  MOVLW  3A
18EE8:  BTFSS  F9E.4
18EEA:  BRA    18EE8
18EEC:  MOVWF  FAD
18EEE:  CLRF   1B
18EF0:  BTFSC  FF2.7
18EF2:  BSF    1B.7
18EF4:  BCF    FF2.7
18EF6:  MOVFF  73D,A18
18EFA:  MOVLW  1B
18EFC:  MOVLB  A
18EFE:  MOVWF  x19
18F00:  MOVLB  0
18F02:  CALL   0F88
18F06:  BTFSC  1B.7
18F08:  BSF    FF2.7
18F0A:  MOVLW  0D
18F0C:  BTFSS  F9E.4
18F0E:  BRA    18F0C
18F10:  MOVWF  FAD
18F12:  MOVLW  0A
18F14:  BTFSS  F9E.4
18F16:  BRA    18F14
18F18:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
18F1A:  MOVLW  67
18F1C:  BTFSS  F9E.4
18F1E:  BRA    18F1C
18F20:  MOVWF  FAD
18F22:  MOVLW  3A
18F24:  BTFSS  F9E.4
18F26:  BRA    18F24
18F28:  MOVWF  FAD
18F2A:  MOVLW  10
18F2C:  MOVWF  FE9
18F2E:  CLRF   1B
18F30:  BTFSC  FF2.7
18F32:  BSF    1B.7
18F34:  BCF    FF2.7
18F36:  MOVFF  757,A19
18F3A:  MOVFF  756,A18
18F3E:  CALL   1188
18F42:  BTFSC  1B.7
18F44:  BSF    FF2.7
18F46:  MOVLW  0D
18F48:  BTFSS  F9E.4
18F4A:  BRA    18F48
18F4C:  MOVWF  FAD
18F4E:  MOVLW  0A
18F50:  BTFSS  F9E.4
18F52:  BRA    18F50
18F54:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
18F56:  MOVLW  68
18F58:  BTFSS  F9E.4
18F5A:  BRA    18F58
18F5C:  MOVWF  FAD
18F5E:  MOVLW  3A
18F60:  BTFSS  F9E.4
18F62:  BRA    18F60
18F64:  MOVWF  FAD
18F66:  MOVLW  10
18F68:  MOVWF  FE9
18F6A:  CLRF   1B
18F6C:  BTFSC  FF2.7
18F6E:  BSF    1B.7
18F70:  BCF    FF2.7
18F72:  MOVFF  863,A19
18F76:  MOVFF  862,A18
18F7A:  CALL   1188
18F7E:  BTFSC  1B.7
18F80:  BSF    FF2.7
18F82:  MOVLW  0D
18F84:  BTFSS  F9E.4
18F86:  BRA    18F84
18F88:  MOVWF  FAD
18F8A:  MOVLW  0A
18F8C:  BTFSS  F9E.4
18F8E:  BRA    18F8C
18F90:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
18F92:  MOVLW  69
18F94:  BTFSS  F9E.4
18F96:  BRA    18F94
18F98:  MOVWF  FAD
18F9A:  MOVLW  3A
18F9C:  BTFSS  F9E.4
18F9E:  BRA    18F9C
18FA0:  MOVWF  FAD
18FA2:  MOVLW  10
18FA4:  MOVWF  FE9
18FA6:  CLRF   1B
18FA8:  BTFSC  FF2.7
18FAA:  BSF    1B.7
18FAC:  BCF    FF2.7
18FAE:  MOVFF  867,A19
18FB2:  MOVFF  866,A18
18FB6:  CALL   1188
18FBA:  BTFSC  1B.7
18FBC:  BSF    FF2.7
18FBE:  MOVLW  0D
18FC0:  BTFSS  F9E.4
18FC2:  BRA    18FC0
18FC4:  MOVWF  FAD
18FC6:  MOVLW  0A
18FC8:  BTFSS  F9E.4
18FCA:  BRA    18FC8
18FCC:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
18FCE:  MOVLW  6A
18FD0:  BTFSS  F9E.4
18FD2:  BRA    18FD0
18FD4:  MOVWF  FAD
18FD6:  MOVLW  3A
18FD8:  BTFSS  F9E.4
18FDA:  BRA    18FD8
18FDC:  MOVWF  FAD
18FDE:  MOVLW  10
18FE0:  MOVWF  FE9
18FE2:  CLRF   1B
18FE4:  BTFSC  FF2.7
18FE6:  BSF    1B.7
18FE8:  BCF    FF2.7
18FEA:  MOVFF  76B,A19
18FEE:  MOVFF  76A,A18
18FF2:  CALL   1188
18FF6:  BTFSC  1B.7
18FF8:  BSF    FF2.7
18FFA:  MOVLW  0D
18FFC:  BTFSS  F9E.4
18FFE:  BRA    18FFC
19000:  MOVWF  FAD
19002:  MOVLW  0A
19004:  BTFSS  F9E.4
19006:  BRA    19004
19008:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
1900A:  MOVLW  6B
1900C:  BTFSS  F9E.4
1900E:  BRA    1900C
19010:  MOVWF  FAD
19012:  MOVLW  3A
19014:  BTFSS  F9E.4
19016:  BRA    19014
19018:  MOVWF  FAD
1901A:  MOVLW  10
1901C:  MOVWF  FE9
1901E:  CLRF   1B
19020:  BTFSC  FF2.7
19022:  BSF    1B.7
19024:  BCF    FF2.7
19026:  MOVFF  763,A19
1902A:  MOVFF  762,A18
1902E:  CALL   1188
19032:  BTFSC  1B.7
19034:  BSF    FF2.7
19036:  MOVLW  0D
19038:  BTFSS  F9E.4
1903A:  BRA    19038
1903C:  MOVWF  FAD
1903E:  MOVLW  0A
19040:  BTFSS  F9E.4
19042:  BRA    19040
19044:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
19046:  MOVLW  6D
19048:  BTFSS  F9E.4
1904A:  BRA    19048
1904C:  MOVWF  FAD
1904E:  MOVLW  3A
19050:  BTFSS  F9E.4
19052:  BRA    19050
19054:  MOVWF  FAD
19056:  MOVLW  10
19058:  MOVWF  FE9
1905A:  CLRF   1B
1905C:  BTFSC  FF2.7
1905E:  BSF    1B.7
19060:  BCF    FF2.7
19062:  MOVFF  743,A19
19066:  MOVFF  742,A18
1906A:  CALL   1188
1906E:  BTFSC  1B.7
19070:  BSF    FF2.7
19072:  MOVLW  0D
19074:  BTFSS  F9E.4
19076:  BRA    19074
19078:  MOVWF  FAD
1907A:  MOVLW  0A
1907C:  BTFSS  F9E.4
1907E:  BRA    1907C
19080:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
19082:  MOVLW  6E
19084:  BTFSS  F9E.4
19086:  BRA    19084
19088:  MOVWF  FAD
1908A:  MOVLW  3A
1908C:  BTFSS  F9E.4
1908E:  BRA    1908C
19090:  MOVWF  FAD
19092:  MOVLW  10
19094:  MOVWF  FE9
19096:  CLRF   1B
19098:  BTFSC  FF2.7
1909A:  BSF    1B.7
1909C:  BCF    FF2.7
1909E:  MOVFF  777,A19
190A2:  MOVFF  776,A18
190A6:  CALL   1188
190AA:  BTFSC  1B.7
190AC:  BSF    FF2.7
190AE:  MOVLW  0D
190B0:  BTFSS  F9E.4
190B2:  BRA    190B0
190B4:  MOVWF  FAD
190B6:  MOVLW  0A
190B8:  BTFSS  F9E.4
190BA:  BRA    190B8
190BC:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
190BE:  MOVLW  6F
190C0:  BTFSS  F9E.4
190C2:  BRA    190C0
190C4:  MOVWF  FAD
190C6:  MOVLW  3A
190C8:  BTFSS  F9E.4
190CA:  BRA    190C8
190CC:  MOVWF  FAD
190CE:  MOVLW  10
190D0:  MOVWF  FE9
190D2:  CLRF   1B
190D4:  BTFSC  FF2.7
190D6:  BSF    1B.7
190D8:  BCF    FF2.7
190DA:  MOVFF  77B,A19
190DE:  MOVFF  77A,A18
190E2:  CALL   1188
190E6:  BTFSC  1B.7
190E8:  BSF    FF2.7
190EA:  MOVLW  0D
190EC:  BTFSS  F9E.4
190EE:  BRA    190EC
190F0:  MOVWF  FAD
190F2:  MOVLW  0A
190F4:  BTFSS  F9E.4
190F6:  BRA    190F4
190F8:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
190FA:  MOVLW  70
190FC:  BTFSS  F9E.4
190FE:  BRA    190FC
19100:  MOVWF  FAD
19102:  MOVLW  3A
19104:  BTFSS  F9E.4
19106:  BRA    19104
19108:  MOVWF  FAD
1910A:  MOVLW  10
1910C:  MOVWF  FE9
1910E:  CLRF   1B
19110:  BTFSC  FF2.7
19112:  BSF    1B.7
19114:  BCF    FF2.7
19116:  MOVFF  7C0,A19
1911A:  MOVFF  7BF,A18
1911E:  CALL   1188
19122:  BTFSC  1B.7
19124:  BSF    FF2.7
19126:  MOVLW  2F
19128:  BTFSS  F9E.4
1912A:  BRA    19128
1912C:  MOVWF  FAD
1912E:  MOVLW  10
19130:  MOVWF  FE9
19132:  CLRF   1B
19134:  BTFSC  FF2.7
19136:  BSF    1B.7
19138:  BCF    FF2.7
1913A:  MOVFF  75F,A19
1913E:  MOVFF  75E,A18
19142:  CALL   1188
19146:  BTFSC  1B.7
19148:  BSF    FF2.7
1914A:  MOVLW  0D
1914C:  BTFSS  F9E.4
1914E:  BRA    1914C
19150:  MOVWF  FAD
19152:  MOVLW  0A
19154:  BTFSS  F9E.4
19156:  BRA    19154
19158:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
1915A:  MOVLW  71
1915C:  BTFSS  F9E.4
1915E:  BRA    1915C
19160:  MOVWF  FAD
19162:  MOVLW  3A
19164:  BTFSS  F9E.4
19166:  BRA    19164
19168:  MOVWF  FAD
1916A:  MOVLW  10
1916C:  MOVWF  FE9
1916E:  CLRF   1B
19170:  BTFSC  FF2.7
19172:  BSF    1B.7
19174:  BCF    FF2.7
19176:  MOVFF  793,A19
1917A:  MOVFF  792,A18
1917E:  CALL   1188
19182:  BTFSC  1B.7
19184:  BSF    FF2.7
19186:  MOVLW  0D
19188:  BTFSS  F9E.4
1918A:  BRA    19188
1918C:  MOVWF  FAD
1918E:  MOVLW  0A
19190:  BTFSS  F9E.4
19192:  BRA    19190
19194:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
19196:  MOVLW  73
19198:  BTFSS  F9E.4
1919A:  BRA    19198
1919C:  MOVWF  FAD
1919E:  MOVLW  3A
191A0:  BTFSS  F9E.4
191A2:  BRA    191A0
191A4:  MOVWF  FAD
191A6:  MOVLW  10
191A8:  MOVWF  FE9
191AA:  CLRF   1B
191AC:  BTFSC  FF2.7
191AE:  BSF    1B.7
191B0:  BCF    FF2.7
191B2:  MOVFF  773,A19
191B6:  MOVFF  772,A18
191BA:  CALL   1188
191BE:  BTFSC  1B.7
191C0:  BSF    FF2.7
191C2:  MOVLW  0D
191C4:  BTFSS  F9E.4
191C6:  BRA    191C4
191C8:  MOVWF  FAD
191CA:  MOVLW  0A
191CC:  BTFSS  F9E.4
191CE:  BRA    191CC
191D0:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
191D2:  MOVLW  74
191D4:  BTFSS  F9E.4
191D6:  BRA    191D4
191D8:  MOVWF  FAD
191DA:  MOVLW  3A
191DC:  BTFSS  F9E.4
191DE:  BRA    191DC
191E0:  MOVWF  FAD
191E2:  MOVLW  10
191E4:  MOVWF  FE9
191E6:  CLRF   1B
191E8:  BTFSC  FF2.7
191EA:  BSF    1B.7
191EC:  BCF    FF2.7
191EE:  MOVFF  767,A19
191F2:  MOVFF  766,A18
191F6:  CALL   1188
191FA:  BTFSC  1B.7
191FC:  BSF    FF2.7
191FE:  MOVLW  0D
19200:  BTFSS  F9E.4
19202:  BRA    19200
19204:  MOVWF  FAD
19206:  MOVLW  0A
19208:  BTFSS  F9E.4
1920A:  BRA    19208
1920C:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
1920E:  MOVLW  01
19210:  MOVLB  7
19212:  ADDWF  x3C,W
19214:  MOVLB  8
19216:  MOVWF  x68
19218:  MOVLW  75
1921A:  BTFSS  F9E.4
1921C:  BRA    1921A
1921E:  MOVWF  FAD
19220:  MOVLW  3A
19222:  BTFSS  F9E.4
19224:  BRA    19222
19226:  MOVWF  FAD
19228:  CLRF   1B
1922A:  BTFSC  FF2.7
1922C:  BSF    1B.7
1922E:  BCF    FF2.7
19230:  MOVFF  868,A18
19234:  MOVLW  1B
19236:  MOVLB  A
19238:  MOVWF  x19
1923A:  MOVLB  0
1923C:  CALL   0F88
19240:  BTFSC  1B.7
19242:  BSF    FF2.7
19244:  MOVLW  0D
19246:  BTFSS  F9E.4
19248:  BRA    19246
1924A:  MOVWF  FAD
1924C:  MOVLW  0A
1924E:  BTFSS  F9E.4
19250:  BRA    1924E
19252:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19254:  MOVLW  77
19256:  BTFSS  F9E.4
19258:  BRA    19256
1925A:  MOVWF  FAD
1925C:  MOVLW  3A
1925E:  BTFSS  F9E.4
19260:  BRA    1925E
19262:  MOVWF  FAD
19264:  MOVLW  10
19266:  MOVWF  FE9
19268:  CLRF   1B
1926A:  BTFSC  FF2.7
1926C:  BSF    1B.7
1926E:  BCF    FF2.7
19270:  MOVFF  865,A19
19274:  MOVFF  864,A18
19278:  CALL   1188
1927C:  BTFSC  1B.7
1927E:  BSF    FF2.7
19280:  MOVLW  0D
19282:  BTFSS  F9E.4
19284:  BRA    19282
19286:  MOVWF  FAD
19288:  MOVLW  0A
1928A:  BTFSS  F9E.4
1928C:  BRA    1928A
1928E:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
19290:  MOVLW  78
19292:  BTFSS  F9E.4
19294:  BRA    19292
19296:  MOVWF  FAD
19298:  MOVLW  3A
1929A:  BTFSS  F9E.4
1929C:  BRA    1929A
1929E:  MOVWF  FAD
192A0:  MOVLW  10
192A2:  MOVWF  FE9
192A4:  CLRF   1B
192A6:  BTFSC  FF2.7
192A8:  BSF    1B.7
192AA:  BCF    FF2.7
192AC:  MOVFF  77F,A19
192B0:  MOVFF  77E,A18
192B4:  CALL   1188
192B8:  BTFSC  1B.7
192BA:  BSF    FF2.7
192BC:  MOVLW  0D
192BE:  BTFSS  F9E.4
192C0:  BRA    192BE
192C2:  MOVWF  FAD
192C4:  MOVLW  0A
192C6:  BTFSS  F9E.4
192C8:  BRA    192C6
192CA:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
192CC:  MOVLW  79
192CE:  BTFSS  F9E.4
192D0:  BRA    192CE
192D2:  MOVWF  FAD
192D4:  MOVLW  3A
192D6:  BTFSS  F9E.4
192D8:  BRA    192D6
192DA:  MOVWF  FAD
192DC:  MOVLW  10
192DE:  MOVWF  FE9
192E0:  CLRF   1B
192E2:  BTFSC  FF2.7
192E4:  BSF    1B.7
192E6:  BCF    FF2.7
192E8:  MOVFF  73F,A19
192EC:  MOVFF  73E,A18
192F0:  CALL   1188
192F4:  BTFSC  1B.7
192F6:  BSF    FF2.7
192F8:  MOVLW  0D
192FA:  BTFSS  F9E.4
192FC:  BRA    192FA
192FE:  MOVWF  FAD
19300:  MOVLW  0A
19302:  BTFSS  F9E.4
19304:  BRA    19302
19306:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19308:  MOVFF  751,9EA
1930C:  MOVFF  750,9E9
19310:  MOVLB  9
19312:  CLRF   xEC
19314:  MOVLW  64
19316:  MOVWF  xEB
19318:  MOVLB  0
1931A:  CALL   5C0E
1931E:  MOVFF  02,869
19322:  MOVFF  01,868
19326:  MOVFF  02,8B9
1932A:  MOVFF  01,8B8
1932E:  MOVLW  01
19330:  MOVLB  8
19332:  MOVWF  xBB
19334:  SETF   xBA
19336:  MOVLB  0
19338:  CALL   2C52
1933C:  MOVFF  02,863
19340:  MOVFF  01,862
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19344:  MOVFF  755,9EA
19348:  MOVFF  754,9E9
1934C:  MOVLB  9
1934E:  CLRF   xEC
19350:  MOVLW  64
19352:  MOVWF  xEB
19354:  MOVLB  0
19356:  CALL   5C0E
1935A:  MOVFF  02,869
1935E:  MOVFF  01,868
19362:  MOVFF  02,8B9
19366:  MOVFF  01,8B8
1936A:  MOVLW  01
1936C:  MOVLB  8
1936E:  MOVWF  xBB
19370:  SETF   xBA
19372:  MOVLB  0
19374:  CALL   2C52
19378:  MOVFF  02,865
1937C:  MOVFF  01,864
....................       step_us  =   m_stp_int[1]*100; 
19380:  MOVFF  749,9EA
19384:  MOVFF  748,9E9
19388:  MOVLB  9
1938A:  CLRF   xEC
1938C:  MOVLW  64
1938E:  MOVWF  xEB
19390:  MOVLB  0
19392:  CALL   5C0E
19396:  MOVFF  02,867
1939A:  MOVFF  01,866
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
1939E:  MOVLW  08
193A0:  MOVWF  FF6
193A2:  MOVLW  27
193A4:  MOVWF  FF7
193A6:  MOVLW  00
193A8:  MOVWF  FF8
193AA:  CLRF   1B
193AC:  BTFSC  FF2.7
193AE:  BSF    1B.7
193B0:  BCF    FF2.7
193B2:  CALL   0E30
193B6:  BTFSC  1B.7
193B8:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
193BA:  MOVLW  62
193BC:  BTFSS  F9E.4
193BE:  BRA    193BC
193C0:  MOVWF  FAD
193C2:  MOVLW  3A
193C4:  BTFSS  F9E.4
193C6:  BRA    193C4
193C8:  MOVWF  FAD
193CA:  MOVLW  10
193CC:  MOVWF  FE9
193CE:  CLRF   1B
193D0:  BTFSC  FF2.7
193D2:  BSF    1B.7
193D4:  BCF    FF2.7
193D6:  MOVFF  771,A19
193DA:  MOVFF  770,A18
193DE:  CALL   1188
193E2:  BTFSC  1B.7
193E4:  BSF    FF2.7
193E6:  MOVLW  0D
193E8:  BTFSS  F9E.4
193EA:  BRA    193E8
193EC:  MOVWF  FAD
193EE:  MOVLW  0A
193F0:  BTFSS  F9E.4
193F2:  BRA    193F0
193F4:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
193F6:  MOVLW  63
193F8:  BTFSS  F9E.4
193FA:  BRA    193F8
193FC:  MOVWF  FAD
193FE:  MOVLW  3A
19400:  BTFSS  F9E.4
19402:  BRA    19400
19404:  MOVWF  FAD
19406:  MOVLW  41
19408:  MOVWF  FE9
1940A:  CLRF   1B
1940C:  BTFSC  FF2.7
1940E:  BSF    1B.7
19410:  BCF    FF2.7
19412:  MOVFF  7A5,A1B
19416:  MOVFF  7A4,A1A
1941A:  MOVFF  7A3,A19
1941E:  MOVFF  7A2,A18
19422:  CALL   10CC
19426:  BTFSC  1B.7
19428:  BSF    FF2.7
1942A:  MOVLW  2F
1942C:  BTFSS  F9E.4
1942E:  BRA    1942C
19430:  MOVWF  FAD
19432:  MOVLW  10
19434:  MOVWF  FE9
19436:  CLRF   1B
19438:  BTFSC  FF2.7
1943A:  BSF    1B.7
1943C:  BCF    FF2.7
1943E:  MOVFF  7BA,A19
19442:  MOVFF  7B9,A18
19446:  CALL   1188
1944A:  BTFSC  1B.7
1944C:  BSF    FF2.7
1944E:  MOVLW  2F
19450:  BTFSS  F9E.4
19452:  BRA    19450
19454:  MOVWF  FAD
19456:  MOVLW  10
19458:  MOVWF  FE9
1945A:  CLRF   1B
1945C:  BTFSC  FF2.7
1945E:  BSF    1B.7
19460:  BCF    FF2.7
19462:  MOVFF  7BE,A19
19466:  MOVFF  7BD,A18
1946A:  CALL   1188
1946E:  BTFSC  1B.7
19470:  BSF    FF2.7
19472:  MOVLW  0D
19474:  BTFSS  F9E.4
19476:  BRA    19474
19478:  MOVWF  FAD
1947A:  MOVLW  0A
1947C:  BTFSS  F9E.4
1947E:  BRA    1947C
19480:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
19482:  MOVLW  64
19484:  BTFSS  F9E.4
19486:  BRA    19484
19488:  MOVWF  FAD
1948A:  MOVLW  3A
1948C:  BTFSS  F9E.4
1948E:  BRA    1948C
19490:  MOVWF  FAD
19492:  MOVLW  10
19494:  MOVWF  FE9
19496:  CLRF   1B
19498:  BTFSC  FF2.7
1949A:  BSF    1B.7
1949C:  BCF    FF2.7
1949E:  MOVFF  74D,A19
194A2:  MOVFF  74C,A18
194A6:  CALL   1188
194AA:  BTFSC  1B.7
194AC:  BSF    FF2.7
194AE:  MOVLW  0D
194B0:  BTFSS  F9E.4
194B2:  BRA    194B0
194B4:  MOVWF  FAD
194B6:  MOVLW  0A
194B8:  BTFSS  F9E.4
194BA:  BRA    194B8
194BC:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
194BE:  MOVLW  65
194C0:  BTFSS  F9E.4
194C2:  BRA    194C0
194C4:  MOVWF  FAD
194C6:  MOVLW  3A
194C8:  BTFSS  F9E.4
194CA:  BRA    194C8
194CC:  MOVWF  FAD
194CE:  MOVLW  10
194D0:  MOVWF  FE9
194D2:  CLRF   1B
194D4:  BTFSC  FF2.7
194D6:  BSF    1B.7
194D8:  BCF    FF2.7
194DA:  MOVFF  75D,A19
194DE:  MOVFF  75C,A18
194E2:  CALL   1188
194E6:  BTFSC  1B.7
194E8:  BSF    FF2.7
194EA:  MOVLW  0D
194EC:  BTFSS  F9E.4
194EE:  BRA    194EC
194F0:  MOVWF  FAD
194F2:  MOVLW  0A
194F4:  BTFSS  F9E.4
194F6:  BRA    194F4
194F8:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
194FA:  MOVLW  66
194FC:  BTFSS  F9E.4
194FE:  BRA    194FC
19500:  MOVWF  FAD
19502:  MOVLW  3A
19504:  BTFSS  F9E.4
19506:  BRA    19504
19508:  MOVWF  FAD
1950A:  CLRF   1B
1950C:  BTFSC  FF2.7
1950E:  BSF    1B.7
19510:  BCF    FF2.7
19512:  MOVFF  73D,A18
19516:  MOVLW  1B
19518:  MOVLB  A
1951A:  MOVWF  x19
1951C:  MOVLB  0
1951E:  CALL   0F88
19522:  BTFSC  1B.7
19524:  BSF    FF2.7
19526:  MOVLW  0D
19528:  BTFSS  F9E.4
1952A:  BRA    19528
1952C:  MOVWF  FAD
1952E:  MOVLW  0A
19530:  BTFSS  F9E.4
19532:  BRA    19530
19534:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
19536:  MOVLW  67
19538:  BTFSS  F9E.4
1953A:  BRA    19538
1953C:  MOVWF  FAD
1953E:  MOVLW  3A
19540:  BTFSS  F9E.4
19542:  BRA    19540
19544:  MOVWF  FAD
19546:  MOVLW  10
19548:  MOVWF  FE9
1954A:  CLRF   1B
1954C:  BTFSC  FF2.7
1954E:  BSF    1B.7
19550:  BCF    FF2.7
19552:  MOVFF  759,A19
19556:  MOVFF  758,A18
1955A:  CALL   1188
1955E:  BTFSC  1B.7
19560:  BSF    FF2.7
19562:  MOVLW  0D
19564:  BTFSS  F9E.4
19566:  BRA    19564
19568:  MOVWF  FAD
1956A:  MOVLW  0A
1956C:  BTFSS  F9E.4
1956E:  BRA    1956C
19570:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19572:  MOVLW  68
19574:  BTFSS  F9E.4
19576:  BRA    19574
19578:  MOVWF  FAD
1957A:  MOVLW  3A
1957C:  BTFSS  F9E.4
1957E:  BRA    1957C
19580:  MOVWF  FAD
19582:  MOVLW  10
19584:  MOVWF  FE9
19586:  CLRF   1B
19588:  BTFSC  FF2.7
1958A:  BSF    1B.7
1958C:  BCF    FF2.7
1958E:  MOVFF  863,A19
19592:  MOVFF  862,A18
19596:  CALL   1188
1959A:  BTFSC  1B.7
1959C:  BSF    FF2.7
1959E:  MOVLW  0D
195A0:  BTFSS  F9E.4
195A2:  BRA    195A0
195A4:  MOVWF  FAD
195A6:  MOVLW  0A
195A8:  BTFSS  F9E.4
195AA:  BRA    195A8
195AC:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
195AE:  MOVLW  69
195B0:  BTFSS  F9E.4
195B2:  BRA    195B0
195B4:  MOVWF  FAD
195B6:  MOVLW  3A
195B8:  BTFSS  F9E.4
195BA:  BRA    195B8
195BC:  MOVWF  FAD
195BE:  MOVLW  10
195C0:  MOVWF  FE9
195C2:  CLRF   1B
195C4:  BTFSC  FF2.7
195C6:  BSF    1B.7
195C8:  BCF    FF2.7
195CA:  MOVFF  867,A19
195CE:  MOVFF  866,A18
195D2:  CALL   1188
195D6:  BTFSC  1B.7
195D8:  BSF    FF2.7
195DA:  MOVLW  0D
195DC:  BTFSS  F9E.4
195DE:  BRA    195DC
195E0:  MOVWF  FAD
195E2:  MOVLW  0A
195E4:  BTFSS  F9E.4
195E6:  BRA    195E4
195E8:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
195EA:  MOVLW  6A
195EC:  BTFSS  F9E.4
195EE:  BRA    195EC
195F0:  MOVWF  FAD
195F2:  MOVLW  3A
195F4:  BTFSS  F9E.4
195F6:  BRA    195F4
195F8:  MOVWF  FAD
195FA:  MOVLW  10
195FC:  MOVWF  FE9
195FE:  CLRF   1B
19600:  BTFSC  FF2.7
19602:  BSF    1B.7
19604:  BCF    FF2.7
19606:  MOVFF  76D,A19
1960A:  MOVFF  76C,A18
1960E:  CALL   1188
19612:  BTFSC  1B.7
19614:  BSF    FF2.7
19616:  MOVLW  0D
19618:  BTFSS  F9E.4
1961A:  BRA    19618
1961C:  MOVWF  FAD
1961E:  MOVLW  0A
19620:  BTFSS  F9E.4
19622:  BRA    19620
19624:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
19626:  MOVLW  6B
19628:  BTFSS  F9E.4
1962A:  BRA    19628
1962C:  MOVWF  FAD
1962E:  MOVLW  3A
19630:  BTFSS  F9E.4
19632:  BRA    19630
19634:  MOVWF  FAD
19636:  MOVLW  10
19638:  MOVWF  FE9
1963A:  CLRF   1B
1963C:  BTFSC  FF2.7
1963E:  BSF    1B.7
19640:  BCF    FF2.7
19642:  MOVFF  765,A19
19646:  MOVFF  764,A18
1964A:  CALL   1188
1964E:  BTFSC  1B.7
19650:  BSF    FF2.7
19652:  MOVLW  0D
19654:  BTFSS  F9E.4
19656:  BRA    19654
19658:  MOVWF  FAD
1965A:  MOVLW  0A
1965C:  BTFSS  F9E.4
1965E:  BRA    1965C
19660:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
19662:  MOVLW  6D
19664:  BTFSS  F9E.4
19666:  BRA    19664
19668:  MOVWF  FAD
1966A:  MOVLW  3A
1966C:  BTFSS  F9E.4
1966E:  BRA    1966C
19670:  MOVWF  FAD
19672:  MOVLW  10
19674:  MOVWF  FE9
19676:  CLRF   1B
19678:  BTFSC  FF2.7
1967A:  BSF    1B.7
1967C:  BCF    FF2.7
1967E:  MOVFF  745,A19
19682:  MOVFF  744,A18
19686:  CALL   1188
1968A:  BTFSC  1B.7
1968C:  BSF    FF2.7
1968E:  MOVLW  0D
19690:  BTFSS  F9E.4
19692:  BRA    19690
19694:  MOVWF  FAD
19696:  MOVLW  0A
19698:  BTFSS  F9E.4
1969A:  BRA    19698
1969C:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
1969E:  MOVLW  6E
196A0:  BTFSS  F9E.4
196A2:  BRA    196A0
196A4:  MOVWF  FAD
196A6:  MOVLW  3A
196A8:  BTFSS  F9E.4
196AA:  BRA    196A8
196AC:  MOVWF  FAD
196AE:  MOVLW  10
196B0:  MOVWF  FE9
196B2:  CLRF   1B
196B4:  BTFSC  FF2.7
196B6:  BSF    1B.7
196B8:  BCF    FF2.7
196BA:  MOVFF  779,A19
196BE:  MOVFF  778,A18
196C2:  CALL   1188
196C6:  BTFSC  1B.7
196C8:  BSF    FF2.7
196CA:  MOVLW  0D
196CC:  BTFSS  F9E.4
196CE:  BRA    196CC
196D0:  MOVWF  FAD
196D2:  MOVLW  0A
196D4:  BTFSS  F9E.4
196D6:  BRA    196D4
196D8:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
196DA:  MOVLW  6F
196DC:  BTFSS  F9E.4
196DE:  BRA    196DC
196E0:  MOVWF  FAD
196E2:  MOVLW  3A
196E4:  BTFSS  F9E.4
196E6:  BRA    196E4
196E8:  MOVWF  FAD
196EA:  MOVLW  10
196EC:  MOVWF  FE9
196EE:  CLRF   1B
196F0:  BTFSC  FF2.7
196F2:  BSF    1B.7
196F4:  BCF    FF2.7
196F6:  MOVFF  77D,A19
196FA:  MOVFF  77C,A18
196FE:  CALL   1188
19702:  BTFSC  1B.7
19704:  BSF    FF2.7
19706:  MOVLW  0D
19708:  BTFSS  F9E.4
1970A:  BRA    19708
1970C:  MOVWF  FAD
1970E:  MOVLW  0A
19710:  BTFSS  F9E.4
19712:  BRA    19710
19714:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
19716:  MOVLW  70
19718:  BTFSS  F9E.4
1971A:  BRA    19718
1971C:  MOVWF  FAD
1971E:  MOVLW  3A
19720:  BTFSS  F9E.4
19722:  BRA    19720
19724:  MOVWF  FAD
19726:  MOVLW  10
19728:  MOVWF  FE9
1972A:  CLRF   1B
1972C:  BTFSC  FF2.7
1972E:  BSF    1B.7
19730:  BCF    FF2.7
19732:  MOVFF  7C2,A19
19736:  MOVFF  7C1,A18
1973A:  CALL   1188
1973E:  BTFSC  1B.7
19740:  BSF    FF2.7
19742:  MOVLW  2F
19744:  BTFSS  F9E.4
19746:  BRA    19744
19748:  MOVWF  FAD
1974A:  MOVLW  10
1974C:  MOVWF  FE9
1974E:  CLRF   1B
19750:  BTFSC  FF2.7
19752:  BSF    1B.7
19754:  BCF    FF2.7
19756:  MOVFF  761,A19
1975A:  MOVFF  760,A18
1975E:  CALL   1188
19762:  BTFSC  1B.7
19764:  BSF    FF2.7
19766:  MOVLW  0D
19768:  BTFSS  F9E.4
1976A:  BRA    19768
1976C:  MOVWF  FAD
1976E:  MOVLW  0A
19770:  BTFSS  F9E.4
19772:  BRA    19770
19774:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
19776:  MOVLW  71
19778:  BTFSS  F9E.4
1977A:  BRA    19778
1977C:  MOVWF  FAD
1977E:  MOVLW  3A
19780:  BTFSS  F9E.4
19782:  BRA    19780
19784:  MOVWF  FAD
19786:  MOVLW  10
19788:  MOVWF  FE9
1978A:  CLRF   1B
1978C:  BTFSC  FF2.7
1978E:  BSF    1B.7
19790:  BCF    FF2.7
19792:  MOVFF  795,A19
19796:  MOVFF  794,A18
1979A:  CALL   1188
1979E:  BTFSC  1B.7
197A0:  BSF    FF2.7
197A2:  MOVLW  0D
197A4:  BTFSS  F9E.4
197A6:  BRA    197A4
197A8:  MOVWF  FAD
197AA:  MOVLW  0A
197AC:  BTFSS  F9E.4
197AE:  BRA    197AC
197B0:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
197B2:  MOVLW  73
197B4:  BTFSS  F9E.4
197B6:  BRA    197B4
197B8:  MOVWF  FAD
197BA:  MOVLW  3A
197BC:  BTFSS  F9E.4
197BE:  BRA    197BC
197C0:  MOVWF  FAD
197C2:  MOVLW  10
197C4:  MOVWF  FE9
197C6:  CLRF   1B
197C8:  BTFSC  FF2.7
197CA:  BSF    1B.7
197CC:  BCF    FF2.7
197CE:  MOVFF  775,A19
197D2:  MOVFF  774,A18
197D6:  CALL   1188
197DA:  BTFSC  1B.7
197DC:  BSF    FF2.7
197DE:  MOVLW  0D
197E0:  BTFSS  F9E.4
197E2:  BRA    197E0
197E4:  MOVWF  FAD
197E6:  MOVLW  0A
197E8:  BTFSS  F9E.4
197EA:  BRA    197E8
197EC:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
197EE:  MOVLW  74
197F0:  BTFSS  F9E.4
197F2:  BRA    197F0
197F4:  MOVWF  FAD
197F6:  MOVLW  3A
197F8:  BTFSS  F9E.4
197FA:  BRA    197F8
197FC:  MOVWF  FAD
197FE:  MOVLW  10
19800:  MOVWF  FE9
19802:  CLRF   1B
19804:  BTFSC  FF2.7
19806:  BSF    1B.7
19808:  BCF    FF2.7
1980A:  MOVFF  769,A19
1980E:  MOVFF  768,A18
19812:  CALL   1188
19816:  BTFSC  1B.7
19818:  BSF    FF2.7
1981A:  MOVLW  0D
1981C:  BTFSS  F9E.4
1981E:  BRA    1981C
19820:  MOVWF  FAD
19822:  MOVLW  0A
19824:  BTFSS  F9E.4
19826:  BRA    19824
19828:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
1982A:  MOVLW  01
1982C:  MOVLB  7
1982E:  ADDWF  x3C,W
19830:  MOVLB  8
19832:  MOVWF  x68
19834:  MOVLW  75
19836:  BTFSS  F9E.4
19838:  BRA    19836
1983A:  MOVWF  FAD
1983C:  MOVLW  3A
1983E:  BTFSS  F9E.4
19840:  BRA    1983E
19842:  MOVWF  FAD
19844:  CLRF   1B
19846:  BTFSC  FF2.7
19848:  BSF    1B.7
1984A:  BCF    FF2.7
1984C:  MOVFF  868,A18
19850:  MOVLW  1B
19852:  MOVLB  A
19854:  MOVWF  x19
19856:  MOVLB  0
19858:  CALL   0F88
1985C:  BTFSC  1B.7
1985E:  BSF    FF2.7
19860:  MOVLW  0D
19862:  BTFSS  F9E.4
19864:  BRA    19862
19866:  MOVWF  FAD
19868:  MOVLW  0A
1986A:  BTFSS  F9E.4
1986C:  BRA    1986A
1986E:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19870:  MOVLW  77
19872:  BTFSS  F9E.4
19874:  BRA    19872
19876:  MOVWF  FAD
19878:  MOVLW  3A
1987A:  BTFSS  F9E.4
1987C:  BRA    1987A
1987E:  MOVWF  FAD
19880:  MOVLW  10
19882:  MOVWF  FE9
19884:  CLRF   1B
19886:  BTFSC  FF2.7
19888:  BSF    1B.7
1988A:  BCF    FF2.7
1988C:  MOVFF  865,A19
19890:  MOVFF  864,A18
19894:  CALL   1188
19898:  BTFSC  1B.7
1989A:  BSF    FF2.7
1989C:  MOVLW  0D
1989E:  BTFSS  F9E.4
198A0:  BRA    1989E
198A2:  MOVWF  FAD
198A4:  MOVLW  0A
198A6:  BTFSS  F9E.4
198A8:  BRA    198A6
198AA:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
198AC:  MOVLW  78
198AE:  BTFSS  F9E.4
198B0:  BRA    198AE
198B2:  MOVWF  FAD
198B4:  MOVLW  3A
198B6:  BTFSS  F9E.4
198B8:  BRA    198B6
198BA:  MOVWF  FAD
198BC:  MOVLW  10
198BE:  MOVWF  FE9
198C0:  CLRF   1B
198C2:  BTFSC  FF2.7
198C4:  BSF    1B.7
198C6:  BCF    FF2.7
198C8:  MOVFF  781,A19
198CC:  MOVFF  780,A18
198D0:  CALL   1188
198D4:  BTFSC  1B.7
198D6:  BSF    FF2.7
198D8:  MOVLW  0D
198DA:  BTFSS  F9E.4
198DC:  BRA    198DA
198DE:  MOVWF  FAD
198E0:  MOVLW  0A
198E2:  BTFSS  F9E.4
198E4:  BRA    198E2
198E6:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
198E8:  MOVLW  79
198EA:  BTFSS  F9E.4
198EC:  BRA    198EA
198EE:  MOVWF  FAD
198F0:  MOVLW  3A
198F2:  BTFSS  F9E.4
198F4:  BRA    198F2
198F6:  MOVWF  FAD
198F8:  MOVLW  10
198FA:  MOVWF  FE9
198FC:  CLRF   1B
198FE:  BTFSC  FF2.7
19900:  BSF    1B.7
19902:  BCF    FF2.7
19904:  MOVFF  741,A19
19908:  MOVFF  740,A18
1990C:  CALL   1188
19910:  BTFSC  1B.7
19912:  BSF    FF2.7
19914:  MOVLW  0D
19916:  BTFSS  F9E.4
19918:  BRA    19916
1991A:  MOVWF  FAD
1991C:  MOVLW  0A
1991E:  BTFSS  F9E.4
19920:  BRA    1991E
19922:  MOVWF  FAD
....................    } 
19924:  BRA    1992A
....................    else cmd_arg(); 
19926:  CALL   AF66
1992A:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BBAE:  MOVF   44,W
0BBB0:  SUBLW  0D
0BBB2:  BNZ   BBD2
0BBB4:  MOVF   45,W
0BBB6:  SUBLW  07
0BBB8:  BNZ   BBD2
0BBBA:  MOVF   46,F
0BBBC:  BNZ   BBD2
0BBBE:  MOVF   47,F
0BBC0:  BNZ   BBD2
0BBC2:  MOVLW  03
0BBC4:  MOVLB  8
0BBC6:  MOVWF  x67
0BBC8:  MOVLW  11
0BBCA:  MOVWF  x66
0BBCC:  MOVLB  0
0BBCE:  RCALL  B78C
0BBD0:  BRA    BBF4
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BBD2:  MOVF   44,W
0BBD4:  SUBLW  98
0BBD6:  BNZ   BBF4
0BBD8:  MOVF   45,W
0BBDA:  SUBLW  07
0BBDC:  BNZ   BBF4
0BBDE:  MOVF   46,F
0BBE0:  BNZ   BBF4
0BBE2:  MOVF   47,F
0BBE4:  BNZ   BBF4
0BBE6:  MOVLW  03
0BBE8:  MOVLB  8
0BBEA:  MOVWF  x67
0BBEC:  MOVLW  11
0BBEE:  MOVWF  x66
0BBF0:  MOVLB  0
0BBF2:  RCALL  B906
0BBF4:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0AFC0:  MOVF   44,W
0AFC2:  MOVWF  00
0AFC4:  MOVFF  45,03
0AFC8:  MOVLW  15
0AFCA:  SUBWF  45,W
0AFCC:  BNZ   AFD4
0AFCE:  MOVLW  95
0AFD0:  SUBWF  00,W
0AFD2:  BZ    AFFA
0AFD4:  MOVLW  15
0AFD6:  SUBWF  03,W
0AFD8:  BNZ   AFE0
0AFDA:  MOVLW  96
0AFDC:  SUBWF  00,W
0AFDE:  BZ    B02C
0AFE0:  MOVLW  15
0AFE2:  SUBWF  03,W
0AFE4:  BNZ   AFEC
0AFE6:  MOVLW  97
0AFE8:  SUBWF  00,W
0AFEA:  BZ    B062
0AFEC:  MOVLW  15
0AFEE:  SUBWF  03,W
0AFF0:  BNZ   AFF8
0AFF2:  MOVLW  98
0AFF4:  SUBWF  00,W
0AFF6:  BZ    B098
0AFF8:  BRA    B0CC
....................       case 5525 : nv_product = ECO; 
0AFFA:  CLRF   30
0AFFC:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0AFFE:  MOVLW  1E
0B000:  MOVLB  8
0B002:  MOVWF  xCB
0B004:  CLRF   xCD
0B006:  CLRF   xCC
0B008:  MOVLB  0
0B00A:  CALL   4F4C
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B00E:  MOVLW  01
0B010:  MOVWF  1E
0B012:  MOVLW  A3
0B014:  MOVWF  1D
0B016:  MOVLW  14
0B018:  MOVWF  FF6
0B01A:  MOVLW  27
0B01C:  MOVWF  FF7
0B01E:  MOVLW  00
0B020:  MOVWF  FF8
0B022:  CALL   5036
....................                   record_event(); 
0B026:  CALL   8410
....................          break; 
0B02A:  BRA    B0CC
....................       case 5526 : nv_product = WMS4; 
0B02C:  CLRF   30
0B02E:  MOVLW  01
0B030:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B032:  MOVLW  1E
0B034:  MOVLB  8
0B036:  MOVWF  xCB
0B038:  CLRF   xCD
0B03A:  MOVLW  01
0B03C:  MOVWF  xCC
0B03E:  MOVLB  0
0B040:  CALL   4F4C
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B044:  MOVLW  01
0B046:  MOVWF  1E
0B048:  MOVLW  A3
0B04A:  MOVWF  1D
0B04C:  MOVLW  24
0B04E:  MOVWF  FF6
0B050:  MOVLW  27
0B052:  MOVWF  FF7
0B054:  MOVLW  00
0B056:  MOVWF  FF8
0B058:  CALL   5036
....................                   record_event();                   
0B05C:  CALL   8410
....................          break;    
0B060:  BRA    B0CC
....................       case 5527 : nv_product = AWS; 
0B062:  CLRF   30
0B064:  MOVLW  02
0B066:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B068:  MOVLW  1E
0B06A:  MOVLB  8
0B06C:  MOVWF  xCB
0B06E:  CLRF   xCD
0B070:  MOVLW  02
0B072:  MOVWF  xCC
0B074:  MOVLB  0
0B076:  CALL   4F4C
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B07A:  MOVLW  01
0B07C:  MOVWF  1E
0B07E:  MOVLW  A3
0B080:  MOVWF  1D
0B082:  MOVLW  3A
0B084:  MOVWF  FF6
0B086:  MOVLW  27
0B088:  MOVWF  FF7
0B08A:  MOVLW  00
0B08C:  MOVWF  FF8
0B08E:  CALL   5036
....................                   record_event();                   
0B092:  CALL   8410
....................          break;   
0B096:  BRA    B0CC
....................       case 5528 : nv_product = WMS2; 
0B098:  CLRF   30
0B09A:  MOVLW  03
0B09C:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B09E:  MOVLW  1E
0B0A0:  MOVLB  8
0B0A2:  MOVWF  xCB
0B0A4:  CLRF   xCD
0B0A6:  MOVLW  03
0B0A8:  MOVWF  xCC
0B0AA:  MOVLB  0
0B0AC:  CALL   4F4C
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B0B0:  MOVLW  01
0B0B2:  MOVWF  1E
0B0B4:  MOVLW  A3
0B0B6:  MOVWF  1D
0B0B8:  MOVLW  4A
0B0BA:  MOVWF  FF6
0B0BC:  MOVLW  27
0B0BE:  MOVWF  FF7
0B0C0:  MOVLW  00
0B0C2:  MOVWF  FF8
0B0C4:  CALL   5036
....................                   record_event();                   
0B0C8:  CALL   8410
....................          break;            
....................    } 
0B0CC:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0AF84:  MOVF   44,W
0AF86:  MOVWF  00
0AF88:  MOVF   45,W
0AF8A:  MOVWF  03
0AF8C:  BNZ   AF92
0AF8E:  MOVF   00,F
0AF90:  BZ    AFA8
0AF92:  MOVF   03,W
0AF94:  BNZ   AF9C
0AF96:  MOVLW  01
0AF98:  SUBWF  00,W
0AF9A:  BZ    AFAE
0AF9C:  MOVF   03,W
0AF9E:  BNZ   AFA6
0AFA0:  MOVLW  02
0AFA2:  SUBWF  00,W
0AFA4:  BZ    AFB4
0AFA6:  BRA    AFBA
....................       case 0 : kill_wd(); 
0AFA8:  CALL   3074
....................          break; 
0AFAC:  BRA    AFBC
....................       case 1 : start_heartbeat(); 
0AFAE:  CALL   287E
....................          break; 
0AFB2:  BRA    AFBC
....................       case 2 : suspend_heartbeat(); 
0AFB4:  CALL   54C8
....................          break; 
0AFB8:  BRA    AFBC
....................       default : cmd_arg(); 
0AFBA:  RCALL  AF66
....................          break; 
....................    } 
0AFBC:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0AEC4:  MOVF   44,W
0AEC6:  MOVWF  00
0AEC8:  MOVF   45,W
0AECA:  MOVWF  03
0AECC:  BNZ   AED2
0AECE:  MOVF   00,F
0AED0:  BZ    AEE0
0AED2:  MOVLW  15
0AED4:  SUBWF  03,W
0AED6:  BNZ   AEDE
0AED8:  MOVLW  95
0AEDA:  SUBWF  00,W
0AEDC:  BZ    AF3E
0AEDE:  BRA    AF62
....................       case 0:     signon(); 
0AEE0:  CALL   30C6
....................                   fprintf(COM_A, __DATE__); 
0AEE4:  MOVLW  60
0AEE6:  MOVWF  FF6
0AEE8:  MOVLW  27
0AEEA:  MOVWF  FF7
0AEEC:  MOVLW  00
0AEEE:  MOVWF  FF8
0AEF0:  CLRF   1B
0AEF2:  BTFSC  FF2.7
0AEF4:  BSF    1B.7
0AEF6:  BCF    FF2.7
0AEF8:  CALL   0E30
0AEFC:  BTFSC  1B.7
0AEFE:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0AF00:  MOVLW  0D
0AF02:  BTFSS  F9E.4
0AF04:  BRA    AF02
0AF06:  MOVWF  FAD
0AF08:  MOVLW  0A
0AF0A:  BTFSS  F9E.4
0AF0C:  BRA    AF0A
0AF0E:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0AF10:  MOVLW  6A
0AF12:  MOVWF  FF6
0AF14:  MOVLW  27
0AF16:  MOVWF  FF7
0AF18:  MOVLW  00
0AF1A:  MOVWF  FF8
0AF1C:  CLRF   1B
0AF1E:  BTFSC  FF2.7
0AF20:  BSF    1B.7
0AF22:  BCF    FF2.7
0AF24:  CALL   0E30
0AF28:  BTFSC  1B.7
0AF2A:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0AF2C:  MOVLW  0D
0AF2E:  BTFSS  F9E.4
0AF30:  BRA    AF2E
0AF32:  MOVWF  FAD
0AF34:  MOVLW  0A
0AF36:  BTFSS  F9E.4
0AF38:  BRA    AF36
0AF3A:  MOVWF  FAD
....................          break; 
0AF3C:  BRA    AF62
....................       case 5525 : kill_wd(); 
0AF3E:  CALL   3074
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0AF42:  MOVLW  74
0AF44:  MOVWF  FF6
0AF46:  MOVLW  27
0AF48:  MOVWF  FF7
0AF4A:  MOVLW  00
0AF4C:  MOVWF  FF8
0AF4E:  CLRF   1B
0AF50:  BTFSC  FF2.7
0AF52:  BSF    1B.7
0AF54:  BCF    FF2.7
0AF56:  CALL   0E30
0AF5A:  BTFSC  1B.7
0AF5C:  BSF    FF2.7
....................                   load_program(); 
0AF5E:  CALL   1F800
....................          break; 
....................    } 
0AF62:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
18622:  MOVF   44,W
18624:  MOVWF  00
18626:  MOVF   45,W
18628:  MOVWF  03
1862A:  BNZ   18630
1862C:  MOVF   00,F
1862E:  BZ    1863C
18630:  MOVF   03,W
18632:  BNZ   1863A
18634:  MOVLW  01
18636:  SUBWF  00,W
18638:  BZ    18640
1863A:  BRA    18644
....................       case 0 : cmd_set=0;  // user 
1863C:  CLRF   4D
....................          break; 
1863E:  BRA    18644
....................       case 1 : cmd_set=1;  // full 
18640:  MOVLW  01
18642:  MOVWF  4D
....................          break; 
....................    } 
18644:  GOTO   1ACCA (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1AB3A:  CALL   ADA2
....................     
....................    switch (cmd) 
1AB3E:  MOVLW  23
1AB40:  SUBWF  43,W
1AB42:  ADDLW  A8
1AB44:  BTFSC  FD8.0
1AB46:  BRA    1ACCA
1AB48:  ADDLW  58
1AB4A:  GOTO   1ACCE
....................    { 
....................       case '&': commandFW(); 
1AB4E:  GOTO   AEC4
....................          break; 
1AB52:  BRA    1ACCA
....................       case '#': command_hash(); 
1AB54:  GOTO   AF84
....................          break;          
1AB58:  BRA    1ACCA
....................       case '%': command_prod(); 
1AB5A:  GOTO   AFC0
....................          break; 
1AB5E:  BRA    1ACCA
....................       case '*': command_star(); 
1AB60:  GOTO   BBAE
....................          break;       
1AB64:  BRA    1ACCA
....................       // standard commands 
....................       case '/': command_addr(); 
1AB66:  GOTO   BBF8
....................          break; 
1AB6A:  BRA    1ACCA
....................       case 'A': commandA(); 
1AB6C:  GOTO   BD92
....................          break; 
1AB70:  BRA    1ACCA
....................       case 'B': commandB(); 
1AB72:  GOTO   BEFE
....................          break; 
1AB76:  BRA    1ACCA
....................       case 'C': commandC(); 
1AB78:  GOTO   D9B6
....................          break; 
1AB7C:  BRA    1ACCA
....................       case 'D': commandD(); 
1AB7E:  GOTO   D9F4
....................          break; 
1AB82:  BRA    1ACCA
....................       case 'E': commandE(); 
1AB84:  GOTO   DA8E
....................          break;          
1AB88:  BRA    1ACCA
....................       case 'F': commandF(); 
1AB8A:  GOTO   DD8C
....................          break;          
1AB8E:  BRA    1ACCA
....................       case 'G': commandG(); 
1AB90:  GOTO   DDF6
....................          break; 
1AB94:  BRA    1ACCA
....................       case 'H': commandH(); 
1AB96:  GOTO   EF54
....................          break; 
1AB9A:  BRA    1ACCA
....................       case 'I': commandI(); 
1AB9C:  GOTO   EF94
....................          break;    
1ABA0:  BRA    1ACCA
....................       case 'J': commandJ(); 
1ABA2:  GOTO   EFE0
....................          break;      
1ABA6:  BRA    1ACCA
....................       case 'K': commandK(); 
1ABA8:  GOTO   F23A
....................          break;    
1ABAC:  BRA    1ACCA
....................       case 'L': commandL(); 
1ABAE:  GOTO   101D4
....................          break;             
1ABB2:  BRA    1ACCA
....................       case 'M': commandM(FALSE); 
1ABB4:  MOVLB  8
1ABB6:  CLRF   x62
1ABB8:  MOVLB  0
1ABBA:  CALL   168CA
....................          break;   
1ABBE:  BRA    1ACCA
....................       case 'N': commandN(); 
1ABC0:  GOTO   169CA
....................          break;          
1ABC4:  BRA    1ACCA
....................       case 'O': commandO(); 
1ABC6:  GOTO   16B7A
....................          break;    
1ABCA:  BRA    1ACCA
....................       case 'P': commandP(); 
1ABCC:  GOTO   16D7E
....................          break;  
1ABD0:  BRA    1ACCA
....................       case 'Q': commandQ(); 
1ABD2:  GOTO   16E3C
....................          break;              
1ABD6:  BRA    1ACCA
....................       case 'R': commandR(); 
1ABD8:  GOTO   170D2
....................          break;    
1ABDC:  BRA    1ACCA
....................       case 'S': commandS(); 
1ABDE:  GOTO   171FE
....................          break;  
1ABE2:  BRA    1ACCA
....................       case 'T': commandT(); 
1ABE4:  GOTO   1779C
....................          break;            
1ABE8:  BRA    1ACCA
....................       case 'U': commandU(); 
1ABEA:  GOTO   1819E
....................          break;           
1ABEE:  BRA    1ACCA
....................       case 'V': commandV(); 
1ABF0:  GOTO   182F6
....................          break; 
1ABF4:  BRA    1ACCA
....................       case 'W': commandW(); 
1ABF6:  GOTO   1846A
....................          break; 
1ABFA:  BRA    1ACCA
....................       case 'X': commandX(); 
1ABFC:  GOTO   1848E
....................          break; 
1AC00:  BRA    1ACCA
....................       case 'Y': commandY(); 
1AC02:  GOTO   184F6
....................          break;  
1AC06:  BRA    1ACCA
....................       case 'Z': commandZ(); 
1AC08:  CALL   185FE
....................          break;    
1AC0C:  BRA    1ACCA
....................       // stepper 
....................       case '^': command_set(); 
1AC0E:  GOTO   18622
....................          break;       
1AC12:  BRA    1ACCA
....................       case '+': if(m_fixed==1) motor=1; 
1AC14:  MOVLB  7
1AC16:  DECFSZ x3D,W
1AC18:  BRA    1AC1E
1AC1A:  MOVLW  01
1AC1C:  MOVWF  x3C
....................                 command_move(0,0,1); 
1AC1E:  MOVLB  8
1AC20:  CLRF   x62
1AC22:  CLRF   x63
1AC24:  MOVLW  01
1AC26:  MOVWF  x64
1AC28:  MOVLB  0
1AC2A:  CALL   16B9E
....................          break; 
1AC2E:  BRA    1ACCA
....................       case '-': if(m_fixed==1) motor=1; 
1AC30:  MOVLB  7
1AC32:  DECFSZ x3D,W
1AC34:  BRA    1AC3A
1AC36:  MOVLW  01
1AC38:  MOVWF  x3C
....................                 command_move(0,1,1); 
1AC3A:  MOVLB  8
1AC3C:  CLRF   x62
1AC3E:  MOVLW  01
1AC40:  MOVWF  x63
1AC42:  MOVWF  x64
1AC44:  MOVLB  0
1AC46:  CALL   16B9E
....................          break; 
1AC4A:  BRA    1ACCA
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1AC4C:  GOTO   1874E
....................          break;     
1AC50:  BRA    1ACCA
....................       case 'b': command_b(); 
1AC52:  GOTO   1876A
....................          break;           
1AC56:  BRA    1ACCA
....................       case 'd': command_d(); 
1AC58:  GOTO   18804
....................          break;          
1AC5C:  BRA    1ACCA
....................       case 'e': command_e(); 
1AC5E:  GOTO   1889A
....................          break;       
1AC62:  BRA    1ACCA
....................       case 'f': command_f(); 
1AC64:  GOTO   18934
....................          break; 
1AC68:  BRA    1ACCA
....................       case 'g': command_g(); 
1AC6A:  GOTO   18954
....................          break;          
1AC6E:  BRA    1ACCA
....................       case 'h': command_h(); 
1AC70:  GOTO   189EE
....................          break; 
1AC74:  BRA    1ACCA
....................       case 'i': command_i(); 
1AC76:  GOTO   18AC2
....................          break;   
1AC7A:  BRA    1ACCA
....................       case 'j': command_j(); 
1AC7C:  GOTO   18B9E
....................          break;           
1AC80:  BRA    1ACCA
....................       case 'k': command_k(); 
1AC82:  GOTO   18C38
....................          break;          
1AC86:  BRA    1ACCA
....................       case 'l': step_var_list(); 
1AC88:  GOTO   18CCE
....................          break;          
1AC8C:  BRA    1ACCA
....................       case 'm': command_m(); 
1AC8E:  GOTO   1992E
....................          break;    
1AC92:  BRA    1ACCA
....................       case 'n': command_n(); 
1AC94:  GOTO   199C4
....................          break; 
1AC98:  BRA    1ACCA
....................       case 'o': command_o(); 
1AC9A:  GOTO   19A5A
....................          break;    
1AC9E:  BRA    1ACCA
....................       case 'p': command_p(); 
1ACA0:  GOTO   19AF4
....................          break;   
1ACA4:  BRA    1ACCA
....................       case 'q': command_q(); 
1ACA6:  GOTO   19B8E
....................          break; 
1ACAA:  BRA    1ACCA
....................       case 'r': command_r(); 
1ACAC:  BRA    1A68A
....................          break;    
1ACAE:  BRA    1ACCA
....................       case 's': command_s(); 
1ACB0:  BRA    1A6E4
....................          break;           
1ACB2:  BRA    1ACCA
....................       case 't': command_t(); 
1ACB4:  BRA    1A7F2
....................          break;          
1ACB6:  BRA    1ACCA
....................       case 'u': command_u(); 
1ACB8:  BRA    1A888
....................          break;           
1ACBA:  BRA    1ACCA
....................       case 'w': command_w(); 
1ACBC:  BRA    1A8C0
....................          break; 
1ACBE:  BRA    1ACCA
....................       case 'x': command_x(); 
1ACC0:  BRA    1A994
....................          break;    
1ACC2:  BRA    1ACCA
....................       case 'y': command_y(); 
1ACC4:  BRA    1AA2E
....................          break;  
1ACC6:  BRA    1ACCA
....................       case 'z': command_z(); 
1ACC8:  BRA    1AAC4
....................          break;           
....................    } 
1ACCA:  GOTO   1AE52 (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................  
....................   number = 0; 
*
1AD9E:  MOVLB  8
1ADA0:  CLRF   x60
....................   arg = 0; 
1ADA2:  CLRF   47
1ADA4:  CLRF   46
1ADA6:  CLRF   45
1ADA8:  CLRF   44
....................   good_arg = FALSE; 
1ADAA:  CLRF   x61
....................    
....................   while (number != CARRIAGE_RET) 
1ADAC:  MOVF   x60,W
1ADAE:  SUBLW  0D
1ADB0:  BZ    1AE84
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
1ADB2:  MOVLB  0
1ADB4:  CALL   0E1A
1ADB8:  MOVFF  01,860
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
1ADBC:  MOVLB  8
1ADBE:  MOVF   x60,W
1ADC0:  SUBLW  0D
1ADC2:  BZ    1ADCE
1ADC4:  MOVF   x60,W
1ADC6:  MOVLB  0
1ADC8:  CALL   ADAA
1ADCC:  MOVLB  8
....................      if (number > 47 && number < 58) 
1ADCE:  MOVF   x60,W
1ADD0:  SUBLW  2F
1ADD2:  BC    1AE24
1ADD4:  MOVF   x60,W
1ADD6:  SUBLW  39
1ADD8:  BNC   1AE24
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
1ADDA:  MOVLW  30
1ADDC:  SUBWF  x60,F
....................         arg = arg * 10;                    // increase significance 
1ADDE:  MOVFF  47,9D6
1ADE2:  MOVFF  46,9D5
1ADE6:  MOVFF  45,9D4
1ADEA:  MOVFF  44,9D3
1ADEE:  MOVLB  9
1ADF0:  CLRF   xDA
1ADF2:  CLRF   xD9
1ADF4:  CLRF   xD8
1ADF6:  MOVLW  0A
1ADF8:  MOVWF  xD7
1ADFA:  MOVLB  0
1ADFC:  CALL   4772
1AE00:  MOVFF  03,47
1AE04:  MOVFF  02,46
1AE08:  MOVFF  01,45
1AE0C:  MOVFF  00,44
....................         arg = arg + number;                // for each number 
1AE10:  MOVLB  8
1AE12:  MOVF   x60,W
1AE14:  ADDWF  44,F
1AE16:  MOVLW  00
1AE18:  ADDWFC 45,F
1AE1A:  ADDWFC 46,F
1AE1C:  ADDWFC 47,F
....................         good_arg = TRUE; 
1AE1E:  MOVLW  01
1AE20:  MOVWF  x61
....................      } 
1AE22:  BRA    1AE7C
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
1AE24:  MOVF   x60,W
1AE26:  SUBLW  0D
1AE28:  BNZ   1AE56
1AE2A:  DECFSZ x61,W
1AE2C:  BRA    1AE56
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
1AE2E:  MOVLW  9A
1AE30:  MOVWF  FF6
1AE32:  MOVLW  27
1AE34:  MOVWF  FF7
1AE36:  MOVLW  00
1AE38:  MOVWF  FF8
1AE3A:  MOVLB  0
1AE3C:  CALL   AD78
1AE40:  MOVLW  0D
1AE42:  BTFSS  F9E.4
1AE44:  BRA    1AE42
1AE46:  MOVWF  FAD
1AE48:  MOVLW  0A
1AE4A:  BTFSS  F9E.4
1AE4C:  BRA    1AE4A
1AE4E:  MOVWF  FAD
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
1AE50:  BRA    1AB3A
....................      } 
1AE52:  BRA    1AE7A
1AE54:  MOVLB  8
....................      else 
....................      { 
....................         good_arg = FALSE; 
1AE56:  CLRF   x61
....................         fputs("@ARG ", COM_A);             // bad input 
1AE58:  MOVLW  A0
1AE5A:  MOVWF  FF6
1AE5C:  MOVLW  27
1AE5E:  MOVWF  FF7
1AE60:  MOVLW  00
1AE62:  MOVWF  FF8
1AE64:  MOVLB  0
1AE66:  CALL   AD78
1AE6A:  MOVLW  0D
1AE6C:  BTFSS  F9E.4
1AE6E:  BRA    1AE6C
1AE70:  MOVWF  FAD
1AE72:  MOVLW  0A
1AE74:  BTFSS  F9E.4
1AE76:  BRA    1AE74
1AE78:  MOVWF  FAD
1AE7A:  MOVLB  8
....................      } 
....................      if (good_arg == FALSE) break; 
1AE7C:  MOVF   x61,F
1AE7E:  BTFSC  FD8.2
1AE80:  BRA    1AE84
1AE82:  BRA    1ADAC
....................   } 
1AE84:  MOVLB  0
1AE86:  GOTO   1AEBA (RETURN)
.................... } 
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0ADF4:  MOVF   4D,F
0ADF6:  BNZ   AE48
0ADF8:  MOVLB  8
0ADFA:  MOVF   x60,W
0ADFC:  SUBLW  24
0ADFE:  BC    AE06
0AE00:  MOVF   x60,W
0AE02:  SUBLW  26
0AE04:  BC    AE40
0AE06:  MOVF   x60,W
0AE08:  SUBLW  29
0AE0A:  BC    AE12
0AE0C:  MOVF   x60,W
0AE0E:  SUBLW  2B
0AE10:  BC    AE40
0AE12:  MOVF   x60,W
0AE14:  SUBLW  2D
0AE16:  BZ    AE40
0AE18:  MOVF   x60,W
0AE1A:  SUBLW  2F
0AE1C:  BZ    AE40
0AE1E:  MOVF   x60,W
0AE20:  SUBLW  40
0AE22:  BC    AE2A
0AE24:  MOVF   x60,W
0AE26:  SUBLW  42
0AE28:  BC    AE40
0AE2A:  MOVF   x60,W
0AE2C:  SUBLW  43
0AE2E:  BC    AE36
0AE30:  MOVF   x60,W
0AE32:  SUBLW  5A
0AE34:  BC    AE40
0AE36:  MOVF   x60,W
0AE38:  SUBLW  5E
0AE3A:  BZ    AE40
0AE3C:  MOVLW  00
0AE3E:  BRA    AE42
0AE40:  MOVLW  01
0AE42:  MOVWF  x61
0AE44:  BRA    AEB6
0AE46:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0AE48:  DECFSZ 4D,W
0AE4A:  BRA    AEB8
0AE4C:  MOVLB  8
0AE4E:  MOVF   x60,W
0AE50:  SUBLW  23
0AE52:  BZ    AEB2
0AE54:  MOVF   x60,W
0AE56:  SUBLW  24
0AE58:  BC    AE60
0AE5A:  MOVF   x60,W
0AE5C:  SUBLW  26
0AE5E:  BC    AEB2
0AE60:  MOVF   x60,W
0AE62:  SUBLW  29
0AE64:  BC    AE6C
0AE66:  MOVF   x60,W
0AE68:  SUBLW  2B
0AE6A:  BC    AEB2
0AE6C:  MOVF   x60,W
0AE6E:  SUBLW  2D
0AE70:  BZ    AEB2
0AE72:  MOVF   x60,W
0AE74:  SUBLW  2F
0AE76:  BZ    AEB2
0AE78:  MOVF   x60,W
0AE7A:  SUBLW  40
0AE7C:  BC    AE84
0AE7E:  MOVF   x60,W
0AE80:  SUBLW  42
0AE82:  BC    AEB2
0AE84:  MOVF   x60,W
0AE86:  SUBLW  43
0AE88:  BC    AE90
0AE8A:  MOVF   x60,W
0AE8C:  SUBLW  5A
0AE8E:  BC    AEB2
0AE90:  MOVF   x60,W
0AE92:  SUBLW  5E
0AE94:  BZ    AEB2
0AE96:  MOVF   x60,W
0AE98:  SUBLW  60
0AE9A:  BC    AEA2
0AE9C:  MOVF   x60,W
0AE9E:  SUBLW  75
0AEA0:  BC    AEB2
0AEA2:  MOVF   x60,W
0AEA4:  SUBLW  76
0AEA6:  BC    AEAE
0AEA8:  MOVF   x60,W
0AEAA:  SUBLW  7A
0AEAC:  BC    AEB2
0AEAE:  MOVLW  00
0AEB0:  BRA    AEB4
0AEB2:  MOVLW  01
0AEB4:  MOVWF  x61
0AEB6:  MOVLB  0
....................    return(valid); 
0AEB8:  MOVLB  8
0AEBA:  MOVFF  861,01
0AEBE:  MOVLB  0
0AEC0:  GOTO   1AE92 (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
*
1AE8A:  MOVFF  43,860
1AE8E:  GOTO   ADF4
1AE92:  MOVF   01,F
1AE94:  BZ    1AE9A
1AE96:  BRA    1AD9E
1AE98:  BRA    1AEBA
....................    else fputs("@INV", COM_A); 
1AE9A:  MOVLW  A6
1AE9C:  MOVWF  FF6
1AE9E:  MOVLW  27
1AEA0:  MOVWF  FF7
1AEA2:  MOVLW  00
1AEA4:  MOVWF  FF8
1AEA6:  CALL   AD78
1AEAA:  MOVLW  0D
1AEAC:  BTFSS  F9E.4
1AEAE:  BRA    1AEAC
1AEB0:  MOVWF  FAD
1AEB2:  MOVLW  0A
1AEB4:  BTFSS  F9E.4
1AEB6:  BRA    1AEB4
1AEB8:  MOVWF  FAD
1AEBA:  GOTO   1AF3E (RETURN)
.................... } 
....................  
.................... void command_prompt() 
.................... { 
....................    disable_interrupts(INT_EXT); 
1AEBE:  BCF    FF2.4
....................     
....................    nv_cmd_mode = TRUE; 
1AEC0:  CLRF   32
1AEC2:  MOVLW  01
1AEC4:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1AEC6:  MOVLW  02
1AEC8:  MOVLB  8
1AECA:  MOVWF  x66
1AECC:  MOVFF  31,867
1AED0:  MOVLB  0
1AED2:  CALL   3390
....................     
....................    fputs("@CMD", COM_A); 
1AED6:  MOVLW  AC
1AED8:  MOVWF  FF6
1AEDA:  MOVLW  27
1AEDC:  MOVWF  FF7
1AEDE:  MOVLW  00
1AEE0:  MOVWF  FF8
1AEE2:  CALL   AD78
1AEE6:  MOVLW  0D
1AEE8:  BTFSS  F9E.4
1AEEA:  BRA    1AEE8
1AEEC:  MOVWF  FAD
1AEEE:  MOVLW  0A
1AEF0:  BTFSS  F9E.4
1AEF2:  BRA    1AEF0
1AEF4:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1AEF6:  MOVLW  01
1AEF8:  MOVWF  1E
1AEFA:  MOVLW  A3
1AEFC:  MOVWF  1D
1AEFE:  MOVLW  B2
1AF00:  MOVWF  FF6
1AF02:  MOVLW  27
1AF04:  MOVWF  FF7
1AF06:  MOVLW  00
1AF08:  MOVWF  FF8
1AF0A:  CALL   5036
....................    record_event(); 
1AF0E:  CALL   8410
....................     
....................    busy_clear(); 
1AF12:  CALL   ADA2
....................     
....................    cmd_set=0; // user 
1AF16:  CLRF   4D
....................     
....................    do { 
....................       fputc('>',COM_A); 
1AF18:  MOVLW  3E
1AF1A:  CALL   ADAA
....................       cmd=fgetc(COM_A); 
1AF1E:  CALL   0E1A
1AF22:  MOVFF  01,43
....................       if (com_echo == TRUE) 
1AF26:  DECFSZ 48,W
1AF28:  BRA    1AF30
....................       { 
....................          fputc(cmd,COM_A); 
1AF2A:  MOVF   43,W
1AF2C:  CALL   ADAA
....................       } 
....................       if (cmd == '?') msg_busy(); 
1AF30:  MOVF   43,W
1AF32:  SUBLW  3F
1AF34:  BNZ   1AF3C
1AF36:  GOTO   ADB2
1AF3A:  BRA    1AF3E
....................       else proc_cmd(); 
1AF3C:  BRA    1AE8A
....................    } while(nv_cmd_mode == TRUE); 
1AF3E:  DECFSZ 31,W
1AF40:  BRA    1AF46
1AF42:  MOVF   32,F
1AF44:  BZ    1AF18
1AF46:  RETURN 0
.................... } 
....................  
....................  
.................... void main() 
1AF48:  CLRF   FF8
1AF4A:  BCF    FD0.7
1AF4C:  BSF    07.7
1AF4E:  MOVLW  70
1AF50:  MOVWF  FD3
1AF52:  MOVLW  40
1AF54:  MOVWF  F9B
1AF56:  CLRF   F64
1AF58:  CLRF   1C
1AF5A:  BSF    F65.3
1AF5C:  MOVWF  FAF
1AF5E:  MOVLW  03
1AF60:  MOVWF  FD4
1AF62:  MOVLW  A6
1AF64:  MOVWF  FAC
1AF66:  MOVLW  90
1AF68:  MOVWF  FAB
1AF6A:  MOVLB  F
1AF6C:  BSF    x20.3
1AF6E:  MOVLW  82
1AF70:  MOVWF  x1E
1AF72:  MOVLW  06
1AF74:  MOVWF  x1F
1AF76:  MOVLW  A6
1AF78:  MOVWF  x21
1AF7A:  MOVLW  90
1AF7C:  MOVWF  x22
1AF7E:  BSF    F65.3
1AF80:  MOVLW  40
1AF82:  MOVWF  FAF
1AF84:  MOVLW  03
1AF86:  MOVWF  FD4
1AF88:  MOVLW  A6
1AF8A:  MOVWF  FAC
1AF8C:  MOVLW  90
1AF8E:  MOVWF  FAB
1AF90:  CLRF   1E
1AF92:  CLRF   1D
1AF94:  CLRF   42
1AF96:  MOVLW  01
1AF98:  MOVWF  41
1AF9A:  MOVWF  48
1AF9C:  BCF    49.0
1AF9E:  BCF    49.1
1AFA0:  BCF    49.2
1AFA2:  MOVLB  0
1AFA4:  CLRF   x62
1AFA6:  MOVLB  2
1AFA8:  MOVWF  xD5
1AFAA:  MOVLB  3
1AFAC:  CLRF   x37
1AFAE:  MOVLB  4
1AFB0:  CLRF   xE3
1AFB2:  MOVWF  xE9
1AFB4:  MOVLW  04
1AFB6:  MOVLB  7
1AFB8:  MOVWF  x0F
1AFBA:  MOVLW  EA
1AFBC:  MOVWF  x0E
1AFBE:  CLRF   xC9
1AFC0:  MOVLB  8
1AFC2:  CLRF   x54
1AFC4:  CLRF   x53
1AFC6:  CLRF   x58
1AFC8:  CLRF   x57
1AFCA:  CLRF   x56
1AFCC:  CLRF   x55
1AFCE:  CLRF   x5C
1AFD0:  CLRF   x5B
1AFD2:  CLRF   x5A
1AFD4:  CLRF   x59
1AFD6:  MOVLW  00
1AFD8:  MOVLB  F
1AFDA:  MOVWF  x23
1AFDC:  MOVWF  x24
1AFDE:  MOVWF  x25
1AFE0:  BCF    FC1.3
1AFE2:  BCF    FC1.4
1AFE4:  BCF    FC1.5
1AFE6:  CLRF   x2E
1AFE8:  CLRF   x2F
1AFEA:  CLRF   x54
1AFEC:  BRA    1B0AE
1AFEE:  DATA 44,02
1AFF0:  DATA D9,20
1AFF2:  DATA 64,72
1AFF4:  DATA 61,77
1AFF6:  DATA 5F,61
1AFF8:  DATA 6C,6C
1AFFA:  DATA 2E,63
1AFFC:  DATA 73,76
1AFFE:  DATA 00,20
1B000:  DATA 64,72
1B002:  DATA 61,77
1B004:  DATA 5F,6E
1B006:  DATA 65,77
1B008:  DATA 2E,63
1B00A:  DATA 73,76
1B00C:  DATA 00,20
1B00E:  DATA 64,72
1B010:  DATA 65,6C
1B012:  DATA 5F,61
1B014:  DATA 6C,6C
1B016:  DATA 2E,63
1B018:  DATA 73,76
1B01A:  DATA 00,20
1B01C:  DATA 64,72
1B01E:  DATA 65,6C
1B020:  DATA 5F,6E
1B022:  DATA 65,77
1B024:  DATA 2E,63
1B026:  DATA 73,76
1B028:  DATA 00,20
1B02A:  DATA 65,76
1B02C:  DATA 65,6E
1B02E:  DATA 74,73
1B030:  DATA 2E,74
1B032:  DATA 78,74
1B034:  DATA 00,02
1B036:  DATA 03,35
1B038:  DATA 2C,00
1B03A:  DATA 02,04
1B03C:  DATA D4,00
1B03E:  DATA 00,10
1B040:  DATA 07,10
1B042:  DATA 46,41
1B044:  DATA 54,31
1B046:  DATA 32,46
1B048:  DATA 41,54
1B04A:  DATA 31,36
1B04C:  DATA 46,41
1B04E:  DATA 54,33
1B050:  DATA 32,00
1B052:  DATA 57,07
1B054:  DATA CA,0D
1B056:  DATA 0A,00
1B058:  DATA 00,03
1B05A:  DATA 00,0F
1B05C:  DATA 00,1B
1B05E:  DATA 00,27
1B060:  DATA 00,33
1B062:  DATA 00,3F
1B064:  DATA 00,4B
1B066:  DATA 00,57
1B068:  DATA 00,63
1B06A:  DATA 00,6F
1B06C:  DATA 00,7B
1B06E:  DATA 00,87
1B070:  DATA 00,93
1B072:  DATA 00,9F
1B074:  DATA 00,AB
1B076:  DATA 00,B7
1B078:  DATA 00,C3
1B07A:  DATA 48,B1
1B07C:  DATA 70,D4
1B07E:  DATA 98,F7
1B080:  DATA C0,1A
1B082:  DATA 00,CF
1B084:  DATA 28,F2
1B086:  DATA 50,15
1B088:  DATA 78,38
1B08A:  DATA A0,5B
1B08C:  DATA C8,7E
1B08E:  DATA F0,A1
1B090:  DATA 18,C5
1B092:  DATA 40,E8
1B094:  DATA 68,0B
1B096:  DATA 90,2E
1B098:  DATA B8,51
1B09A:  DATA E0,74
1B09C:  DATA 08,98
1B09E:  DATA 30,BB
1B0A0:  DATA 58,DE
1B0A2:  DATA 80,01
1B0A4:  DATA A8,24
1B0A6:  DATA D0,47
1B0A8:  DATA F8,6A
1B0AA:  DATA 20,8E
1B0AC:  DATA 00,00
1B0AE:  MOVLW  01
1B0B0:  MOVWF  FF8
1B0B2:  MOVLW  AF
1B0B4:  MOVWF  FF7
1B0B6:  MOVLW  EE
1B0B8:  MOVWF  FF6
1B0BA:  TBLRD*+
1B0BC:  MOVF   FF5,W
1B0BE:  MOVWF  00
1B0C0:  XORLW  00
1B0C2:  BZ    1B0EA
1B0C4:  TBLRD*+
1B0C6:  MOVF   FF5,W
1B0C8:  MOVWF  01
1B0CA:  BTFSC  FE8.7
1B0CC:  BRA    1B0D8
1B0CE:  ANDLW  0F
1B0D0:  MOVWF  FEA
1B0D2:  TBLRD*+
1B0D4:  MOVFF  FF5,FE9
1B0D8:  BTFSC  01.6
1B0DA:  TBLRD*+
1B0DC:  BTFSS  01.6
1B0DE:  TBLRD*+
1B0E0:  MOVFF  FF5,FEE
1B0E4:  DCFSNZ 00,F
1B0E6:  BRA    1B0BA
1B0E8:  BRA    1B0DC
1B0EA:  CLRF   FF8
1B0EC:  MOVLB  8
1B0EE:  CLRF   x5D
1B0F0:  CLRF   x5F
1B0F2:  CLRF   x5E
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B0F4:  BCF    FF2.6
1B0F6:  BCF    FF2.7
1B0F8:  BTFSC  FF2.7
1B0FA:  BRA    1B0F6
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B0FC:  BCF    FC6.5
1B0FE:  MOVLW  21
1B100:  MOVWF  FC6
1B102:  MOVLW  40
1B104:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B106:  BCF    F67.5
1B108:  MOVLW  21
1B10A:  MOVWF  F67
1B10C:  MOVLW  40
1B10E:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B110:  MOVLW  00
1B112:  MOVLB  F
1B114:  MOVWF  x23
1B116:  MOVWF  x24
1B118:  MOVLW  1F
1B11A:  MOVWF  x25
1B11C:  BCF    FC1.3
1B11E:  BSF    FC1.4
1B120:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B122:  MOVF   FC0,W
1B124:  ANDLW  C0
1B126:  IORLW  07
1B128:  MOVWF  FC0
1B12A:  BSF    FC0.7
1B12C:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B12E:  MOVLW  87
1B130:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B132:  MOVLW  37
1B134:  MOVWF  FCD
1B136:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B138:  MOVLB  0
1B13A:  GOTO   2842
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B13E:  CLRF   FB0
1B140:  MOVLW  07
1B142:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B144:  MOVLW  04
1B146:  MOVLB  F
1B148:  MOVWF  x2E
1B14A:  MOVWF  x2F
1B14C:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B14E:  MOVLW  70
1B150:  MOVWF  FD3
1B152:  MOVLW  40
1B154:  MOVWF  F9B
1B156:  CLRF   F64
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B158:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B15A:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B15C:  MOVLB  0
1B15E:  CALL   287E
....................  
....................    enable_interrupts(GLOBAL); 
1B162:  MOVLW  C0
1B164:  IORWF  FF2,F
....................  
....................    init_hardware(); 
1B166:  CALL   28B8
....................    motor_sleep_rdy(); 
1B16A:  CALL   2916
....................  
....................    sleep_mode = FALSE;    
1B16E:  BCF    49.1
....................    busy_set(); 
1B170:  CALL   293E
....................     
....................    init_nv_vars(); 
1B174:  CALL   2A36
....................    get_step_vars(); 
1B178:  CALL   2C98
....................    init_aws(); 
1B17C:  GOTO   305A
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B180:  CALL   3074
....................    blink(); 
1B184:  GOTO   307A
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B188:  CALL   30C6
....................     
....................    RTC_read(); 
1B18C:  CALL   32C2
....................    RTC_last_power(); 
1B190:  GOTO   33C0
....................    RTC_reset_HT();   
1B194:  CALL   3430
....................    RTC_read(); 
1B198:  CALL   32C2
1B19C:  CLRF   1B
1B19E:  BTFSC  FF2.7
1B1A0:  BSF    1B.7
1B1A2:  BCF    FF2.7
....................    RTC_read_flags(); 
1B1A4:  CALL   0DCC
1B1A8:  BTFSC  1B.7
1B1AA:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B1AC:  MOVF   3B,F
1B1AE:  BNZ   1B1B4
1B1B0:  MOVF   3C,F
1B1B2:  BZ    1B204
1B1B4:  MOVLW  C4
1B1B6:  MOVWF  FF6
1B1B8:  MOVLW  27
1B1BA:  MOVWF  FF7
1B1BC:  MOVLW  00
1B1BE:  MOVWF  FF8
1B1C0:  CLRF   1B
1B1C2:  BTFSC  FF2.7
1B1C4:  BSF    1B.7
1B1C6:  BCF    FF2.7
1B1C8:  MOVLW  04
1B1CA:  MOVLB  A
1B1CC:  MOVWF  x18
1B1CE:  MOVLB  0
1B1D0:  CALL   1006
1B1D4:  BTFSC  1B.7
1B1D6:  BSF    FF2.7
1B1D8:  MOVLW  10
1B1DA:  MOVWF  FE9
1B1DC:  CLRF   1B
1B1DE:  BTFSC  FF2.7
1B1E0:  BSF    1B.7
1B1E2:  BCF    FF2.7
1B1E4:  MOVFF  3C,A19
1B1E8:  MOVFF  3B,A18
1B1EC:  CALL   1188
1B1F0:  BTFSC  1B.7
1B1F2:  BSF    FF2.7
1B1F4:  MOVLW  0D
1B1F6:  BTFSS  F9E.4
1B1F8:  BRA    1B1F6
1B1FA:  MOVWF  FAD
1B1FC:  MOVLW  0A
1B1FE:  BTFSS  F9E.4
1B200:  BRA    1B1FE
1B202:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B204:  CALL   3486
....................    sd_status = init_sdcard(); 
1B208:  CALL   4FB2
1B20C:  MOVFF  01,2D8
....................    if(sd_status>0) msg_card_fail(); 
1B210:  MOVLB  2
1B212:  MOVF   xD8,F
1B214:  BZ    1B21E
1B216:  MOVLB  0
1B218:  CALL   4FF8
1B21C:  MOVLB  2
....................     
....................    reset_event(); 
1B21E:  MOVLB  0
1B220:  GOTO   AAF4
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B224:  MOVLB  7
1B226:  MOVF   x92,F
1B228:  BNZ   1B236
1B22A:  MOVF   x93,F
1B22C:  BNZ   1B236
1B22E:  MOVF   x94,F
1B230:  BNZ   1B236
1B232:  MOVF   x95,F
1B234:  BZ    1B23E
1B236:  MOVLB  0
1B238:  CALL   9C38
1B23C:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B23E:  MOVF   xAB,F
1B240:  BNZ   1B2C4
1B242:  MOVF   xAC,F
1B244:  BNZ   1B2C4
....................       e_port[0]=0; 
1B246:  CLRF   xC0
1B248:  CLRF   xBF
....................       write16(ADDR_E1_PORT,0); 
1B24A:  MOVLW  AA
1B24C:  MOVLB  8
1B24E:  MOVWF  xCB
1B250:  CLRF   xCD
1B252:  CLRF   xCC
1B254:  MOVLB  0
1B256:  CALL   4F4C
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B25A:  MOVLW  CE
1B25C:  MOVWF  FF6
1B25E:  MOVLW  27
1B260:  MOVWF  FF7
1B262:  MOVLW  00
1B264:  MOVWF  FF8
1B266:  CLRF   1B
1B268:  BTFSC  FF2.7
1B26A:  BSF    1B.7
1B26C:  BCF    FF2.7
1B26E:  MOVLW  05
1B270:  MOVLB  A
1B272:  MOVWF  x18
1B274:  MOVLB  0
1B276:  CALL   1006
1B27A:  BTFSC  1B.7
1B27C:  BSF    FF2.7
1B27E:  MOVLW  10
1B280:  MOVWF  FE9
1B282:  CLRF   1B
1B284:  BTFSC  FF2.7
1B286:  BSF    1B.7
1B288:  BCF    FF2.7
1B28A:  MOVFF  7AC,A19
1B28E:  MOVFF  7AB,A18
1B292:  CALL   1188
1B296:  BTFSC  1B.7
1B298:  BSF    FF2.7
1B29A:  MOVLW  2C
1B29C:  BTFSS  F9E.4
1B29E:  BRA    1B29C
1B2A0:  MOVWF  FAD
1B2A2:  MOVLW  10
1B2A4:  MOVWF  FE9
1B2A6:  MOVFF  7C0,8CE
1B2AA:  MOVFF  7BF,8CD
1B2AE:  CALL   8F1A
1B2B2:  MOVLW  0D
1B2B4:  BTFSS  F9E.4
1B2B6:  BRA    1B2B4
1B2B8:  MOVWF  FAD
1B2BA:  MOVLW  0A
1B2BC:  BTFSS  F9E.4
1B2BE:  BRA    1B2BC
1B2C0:  MOVWF  FAD
1B2C2:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B2C4:  MOVF   xAD,F
1B2C6:  BNZ   1B34A
1B2C8:  MOVF   xAE,F
1B2CA:  BNZ   1B34A
....................       m_lin_pos[1]=-1; 
1B2CC:  SETF   xB2
1B2CE:  SETF   xB1
....................       write16(ADDR_M2_LIN_POS, -1); 
1B2D0:  MOVLW  B8
1B2D2:  MOVLB  8
1B2D4:  MOVWF  xCB
1B2D6:  SETF   xCD
1B2D8:  SETF   xCC
1B2DA:  MOVLB  0
1B2DC:  CALL   4F4C
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B2E0:  MOVLW  DE
1B2E2:  MOVWF  FF6
1B2E4:  MOVLW  27
1B2E6:  MOVWF  FF7
1B2E8:  MOVLW  00
1B2EA:  MOVWF  FF8
1B2EC:  CLRF   1B
1B2EE:  BTFSC  FF2.7
1B2F0:  BSF    1B.7
1B2F2:  BCF    FF2.7
1B2F4:  MOVLW  05
1B2F6:  MOVLB  A
1B2F8:  MOVWF  x18
1B2FA:  MOVLB  0
1B2FC:  CALL   1006
1B300:  BTFSC  1B.7
1B302:  BSF    FF2.7
1B304:  MOVLW  10
1B306:  MOVWF  FE9
1B308:  CLRF   1B
1B30A:  BTFSC  FF2.7
1B30C:  BSF    1B.7
1B30E:  BCF    FF2.7
1B310:  MOVFF  7AE,A19
1B314:  MOVFF  7AD,A18
1B318:  CALL   1188
1B31C:  BTFSC  1B.7
1B31E:  BSF    FF2.7
1B320:  MOVLW  2C
1B322:  BTFSS  F9E.4
1B324:  BRA    1B322
1B326:  MOVWF  FAD
1B328:  MOVLW  10
1B32A:  MOVWF  FE9
1B32C:  MOVFF  7B2,8CE
1B330:  MOVFF  7B1,8CD
1B334:  CALL   8F1A
1B338:  MOVLW  0D
1B33A:  BTFSS  F9E.4
1B33C:  BRA    1B33A
1B33E:  MOVWF  FAD
1B340:  MOVLW  0A
1B342:  BTFSS  F9E.4
1B344:  BRA    1B342
1B346:  MOVWF  FAD
1B348:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1B34A:  MOVF   31,F
1B34C:  BNZ   1B3F0
1B34E:  MOVF   32,F
1B350:  BNZ   1B3F0
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1B352:  MOVLW  EE
1B354:  MOVWF  FF6
1B356:  MOVLW  27
1B358:  MOVWF  FF7
1B35A:  MOVLW  00
1B35C:  MOVWF  FF8
1B35E:  CLRF   1B
1B360:  BTFSC  FF2.7
1B362:  BSF    1B.7
1B364:  BCF    FF2.7
1B366:  MOVLB  0
1B368:  CALL   0E30
1B36C:  BTFSC  1B.7
1B36E:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1B370:  MOVLB  8
1B372:  MOVF   x5F,F
1B374:  BNZ   1B3A2
1B376:  MOVF   x5E,W
1B378:  SUBLW  63
1B37A:  BNC   1B3A2
1B37C:  MOVF   x5D,W
1B37E:  SUBLW  1B
1B380:  BZ    1B3A2
....................       { 
....................          EscNum=TestForEsc(); 
1B382:  MOVLB  0
1B384:  GOTO   AD1E
1B388:  MOVFF  01,85D
....................          if(EscNum == ESCAPE) command_prompt(); 
1B38C:  MOVLB  8
1B38E:  MOVF   x5D,W
1B390:  SUBLW  1B
1B392:  BNZ   1B39A
1B394:  MOVLB  0
1B396:  RCALL  1AEBE
1B398:  MOVLB  8
....................          EscCount++; 
1B39A:  INCF   x5E,F
1B39C:  BTFSC  FD8.2
1B39E:  INCF   x5F,F
1B3A0:  BRA    1B372
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1B3A2:  DECFSZ 33,W
1B3A4:  BRA    1B3BA
1B3A6:  MOVF   34,F
1B3A8:  BNZ   1B3BA
....................       { 
....................          arg=0; 
1B3AA:  CLRF   47
1B3AC:  CLRF   46
1B3AE:  CLRF   45
1B3B0:  CLRF   44
....................          commandZ(); 
1B3B2:  MOVLB  0
1B3B4:  CALL   185FE
1B3B8:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1B3BA:  MOVLW  26
1B3BC:  MOVWF  FF6
1B3BE:  MOVLW  28
1B3C0:  MOVWF  FF7
1B3C2:  MOVLW  00
1B3C4:  MOVWF  FF8
1B3C6:  CLRF   1B
1B3C8:  BTFSC  FF2.7
1B3CA:  BSF    1B.7
1B3CC:  BCF    FF2.7
1B3CE:  MOVLB  0
1B3D0:  CALL   0E30
1B3D4:  BTFSC  1B.7
1B3D6:  BSF    FF2.7
....................       arg = 0; 
1B3D8:  CLRF   47
1B3DA:  CLRF   46
1B3DC:  CLRF   45
1B3DE:  CLRF   44
....................       commandM(TRUE); 
1B3E0:  MOVLW  01
1B3E2:  MOVLB  8
1B3E4:  MOVWF  x62
1B3E6:  MOVLB  0
1B3E8:  CALL   168CA
....................    } 
1B3EC:  BRA    1B3F4
1B3EE:  MOVLB  7
....................    else 
....................    { 
....................       command_prompt(); 
1B3F0:  MOVLB  0
1B3F2:  RCALL  1AEBE
....................    } 
....................  
....................    reset_cpu(); 
1B3F4:  RESET
.................... } 
....................  
1B3F6:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 2A78   PUT NOBROWNOUT BORV18 ZPBORM WDT_SW WDT1024
   Word  3: 0BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 NOMCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
