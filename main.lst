CCS PCH C Compiler, Version 5.071d, 1               06-Jul-17 15:10
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   87170 bytes (67%)
                           Largest free fragment is 43532
               RAM used:   2148 (56%) at main() level
                           2730 (71%) worst case
               Stack used: 16 locations (12 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1493A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0F12
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0F3C
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   1932
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E3E
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   1714
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   178A
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0EA2
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
....................              /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
*
005B2:  DATA 77,72
005B4:  DATA 69,74
005B6:  DATA 69,6E
005B8:  DATA 67,00
005BA:  DATA 72,65
005BC:  DATA 61,64
005BE:  DATA 69,6E
005C0:  DATA 67,00
005C2:  DATA 25,6C
005C4:  DATA 78,3A
005C6:  DATA 20,72
005C8:  DATA 65,61
005CA:  DATA 64,20
005CC:  DATA 25,78
005CE:  DATA 2C,20
005D0:  DATA 73,68
005D2:  DATA 6F,75
005D4:  DATA 6C,64
005D6:  DATA 20,62
005D8:  DATA 65,20
005DA:  DATA 25,78
005DC:  DATA 0A,0D
005DE:  DATA 00,00
005E0:  DATA 64,6F
005E2:  DATA 6E,65
005E4:  DATA 0A,0D
005E6:  DATA 00,00
005E8:  DATA 45,43
005EA:  DATA 4F,2D
005EC:  DATA 32,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 53,44
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 41,57
00614:  DATA 53,2D
00616:  DATA 31,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 57,4D
00628:  DATA 53,2D
0062A:  DATA 34,2D
0062C:  DATA 51,45
0062E:  DATA 20,25
00630:  DATA 73,0D
00632:  DATA 0A,00
00634:  DATA 56,32
00636:  DATA 2E,31
00638:  DATA 32,35
0063A:  DATA 00,00
0063C:  DATA 58,58
0063E:  DATA 58,2D
00640:  DATA 30,20
00642:  DATA 25,73
00644:  DATA 0D,0A
00646:  DATA 00,00
00648:  DATA 56,32
0064A:  DATA 2E,31
0064C:  DATA 32,35
0064E:  DATA 00,00
00650:  DATA 40,49
00652:  DATA 4E,56
00654:  DATA 0D,0A
00656:  DATA 00,00
00658:  DATA 40,41
0065A:  DATA 52,47
0065C:  DATA 0D,0A
0065E:  DATA 00,00
00660:  DATA 40,45
00662:  DATA 52,52
00664:  DATA 0D,0A
00666:  DATA 00,00
00668:  DATA 40,4F
0066A:  DATA 4B,21
0066C:  DATA 0D,0A
0066E:  DATA 00,00
00670:  DATA 40,52
00672:  DATA 45,53
00674:  DATA 0D,0A
00676:  DATA 00,00
00678:  DATA 40,53
0067A:  DATA 44,31
0067C:  DATA 0D,0A
0067E:  DATA 00,00
00680:  DATA 40,53
00682:  DATA 44,5F
00684:  DATA 0D,0A
00686:  DATA 00,00
00688:  DATA 40,4D
0068A:  DATA 41,58
0068C:  DATA 0D,0A
0068E:  DATA 00,00
00690:  DATA 3F,40
00692:  DATA 42,53
00694:  DATA 59,0D
00696:  DATA 0A,00
00698:  DATA 40,52
0069A:  DATA 44,59
0069C:  DATA 0D,0A
0069E:  DATA 00,00
006A0:  DATA 40,46
006A2:  DATA 53,3A
006A4:  DATA 44,69
006A6:  DATA 73,63
006A8:  DATA 6F,76
006AA:  DATA 65,72
006AC:  DATA 79,0D
006AE:  DATA 0A,00
006B0:  DATA 40,46
006B2:  DATA 53,3A
006B4:  DATA 55,6E
006B6:  DATA 61,62
006B8:  DATA 6C,65
006BA:  DATA 20,74
006BC:  DATA 6F,20
006BE:  DATA 70,75
006C0:  DATA 74,20
006C2:  DATA 63,61
006C4:  DATA 72,64
006C6:  DATA 20,69
006C8:  DATA 6E,20
006CA:  DATA 69,64
006CC:  DATA 6C,65
006CE:  DATA 20,73
006D0:  DATA 74,61
006D2:  DATA 74,65
006D4:  DATA 2C,20
006D6:  DATA 72,65
006D8:  DATA 73,70
006DA:  DATA 6F,6E
006DC:  DATA 73,65
006DE:  DATA 20,3D
006E0:  DATA 20,25
006E2:  DATA 30,32
006E4:  DATA 78,0D
006E6:  DATA 0A,00
006E8:  DATA 40,46
006EA:  DATA 53,3A
006EC:  DATA 43,61
006EE:  DATA 72,64
006F0:  DATA 20,69
006F2:  DATA 64,6C
006F4:  DATA 65,2C
006F6:  DATA 20,72
006F8:  DATA 65,73
006FA:  DATA 70,6F
006FC:  DATA 6E,73
006FE:  DATA 65,20
00700:  DATA 3D,20
00702:  DATA 25,30
00704:  DATA 32,78
00706:  DATA 0D,0A
00708:  DATA 00,00
0070A:  DATA 40,46
0070C:  DATA 53,3A
0070E:  DATA 52,65
00710:  DATA 73,70
00712:  DATA 6F,6E
00714:  DATA 73,65
00716:  DATA 20,74
00718:  DATA 6F,20
0071A:  DATA 53,44
0071C:  DATA 20,76
0071E:  DATA 65,72
00720:  DATA 20,32
00722:  DATA 20,74
00724:  DATA 65,73
00726:  DATA 74,20
00728:  DATA 43,4D
0072A:  DATA 44,38
0072C:  DATA 20,3D
0072E:  DATA 20,25
00730:  DATA 78,0D
00732:  DATA 0A,00
00734:  DATA 40,46
00736:  DATA 53,3A
00738:  DATA 50,6F
0073A:  DATA 73,73
0073C:  DATA 69,62
0073E:  DATA 6C,65
00740:  DATA 20,53
00742:  DATA 44,76
00744:  DATA 32,20
00746:  DATA 63,61
00748:  DATA 72,64
0074A:  DATA 20,64
0074C:  DATA 65,74
0074E:  DATA 65,63
00750:  DATA 74,65
00752:  DATA 64,0D
00754:  DATA 0A,00
00756:  DATA 40,46
00758:  DATA 53,3A
0075A:  DATA 56,6F
0075C:  DATA 6C,74
0075E:  DATA 61,67
00760:  DATA 65,20
00762:  DATA 72,61
00764:  DATA 6E,67
00766:  DATA 65,20
00768:  DATA 63,68
0076A:  DATA 65,63
0076C:  DATA 6B,2C
0076E:  DATA 20,6F
00770:  DATA 63,72
00772:  DATA 20,3D
00774:  DATA 20,25
00776:  DATA 30,32
00778:  DATA 78,25
0077A:  DATA 30,32
0077C:  DATA 78,25
0077E:  DATA 30,32
00780:  DATA 78,25
00782:  DATA 30,32
00784:  DATA 78,0D
00786:  DATA 0A,00
00788:  DATA 40,46
0078A:  DATA 53,3A
0078C:  DATA 43,61
0078E:  DATA 72,64
00790:  DATA 20,56
00792:  DATA 64,64
00794:  DATA 20,72
00796:  DATA 61,6E
00798:  DATA 67,65
0079A:  DATA 20,3D
0079C:  DATA 20,32
0079E:  DATA 2E,37
007A0:  DATA 2D,33
007A2:  DATA 2E,36
007A4:  DATA 20,76
007A6:  DATA 6F,6C
007A8:  DATA 74,73
007AA:  DATA 0D,0A
007AC:  DATA 00,00
007AE:  DATA 40,46
007B0:  DATA 53,3A
007B2:  DATA 53,65
007B4:  DATA 6E,64
007B6:  DATA 69,6E
007B8:  DATA 67,20
007BA:  DATA 41,43
007BC:  DATA 4D,44
007BE:  DATA 34,31
007C0:  DATA 20,63
007C2:  DATA 6F,6D
007C4:  DATA 6D,61
007C6:  DATA 6E,64
007C8:  DATA 20,74
007CA:  DATA 6F,20
007CC:  DATA 53,44
007CE:  DATA 20,76
007D0:  DATA 65,72
007D2:  DATA 20,32
007D4:  DATA 20,63
007D6:  DATA 61,72
007D8:  DATA 64,0D
007DA:  DATA 0A,00
007DC:  DATA 40,46
007DE:  DATA 53,3A
007E0:  DATA 52,65
007E2:  DATA 73,70
007E4:  DATA 6F,6E
007E6:  DATA 73,65
007E8:  DATA 20,66
007EA:  DATA 72,6F
007EC:  DATA 6D,20
007EE:  DATA 73,65
007F0:  DATA 6E,64
007F2:  DATA 69,6E
007F4:  DATA 67,20
007F6:  DATA 41,43
007F8:  DATA 4D,44
007FA:  DATA 34,31
007FC:  DATA 20,3D
007FE:  DATA 20,25
00800:  DATA 30,32
00802:  DATA 78,2C
00804:  DATA 20,54
00806:  DATA 69,6D
00808:  DATA 65,72
0080A:  DATA 20,3D
0080C:  DATA 20,25
0080E:  DATA 6C,75
00810:  DATA 0D,0A
00812:  DATA 00,00
00814:  DATA 40,46
00816:  DATA 53,3A
00818:  DATA 52,65
0081A:  DATA 73,70
0081C:  DATA 6F,6E
0081E:  DATA 73,65
00820:  DATA 20,74
00822:  DATA 6F,20
00824:  DATA 43,4D
00826:  DATA 44,35
00828:  DATA 38,20
0082A:  DATA 3D,20
0082C:  DATA 25,78
0082E:  DATA 0D,0A
00830:  DATA 00,00
00832:  DATA 40,46
00834:  DATA 53,3A
00836:  DATA 53,65
00838:  DATA 6E,74
0083A:  DATA 20,43
0083C:  DATA 4D,44
0083E:  DATA 20,35
00840:  DATA 38,2C
00842:  DATA 20,54
00844:  DATA 69,6D
00846:  DATA 65,72
00848:  DATA 20,76
0084A:  DATA 61,6C
0084C:  DATA 75,65
0084E:  DATA 20,3D
00850:  DATA 20,25
00852:  DATA 6C,75
00854:  DATA 2C,20
00856:  DATA 6F,63
00858:  DATA 72,20
0085A:  DATA 3D,20
0085C:  DATA 25,30
0085E:  DATA 32,78
00860:  DATA 25,30
00862:  DATA 32,78
00864:  DATA 25,30
00866:  DATA 32,78
00868:  DATA 25,30
0086A:  DATA 32,78
0086C:  DATA 0D,0A
0086E:  DATA 00,00
00870:  DATA 40,46
00872:  DATA 53,3A
00874:  DATA 43,61
00876:  DATA 72,64
00878:  DATA 20,43
0087A:  DATA 41,4E
0087C:  DATA 4E,4F
0087E:  DATA 54,20
00880:  DATA 77,6F
00882:  DATA 72,6B
00884:  DATA 20,56
00886:  DATA 64,64
00888:  DATA 20,72
0088A:  DATA 61,6E
0088C:  DATA 67,65
0088E:  DATA 20,6F
00890:  DATA 66,20
00892:  DATA 32,2E
00894:  DATA 37,2D
00896:  DATA 33,2E
00898:  DATA 36,20
0089A:  DATA 76,6F
0089C:  DATA 6C,74
0089E:  DATA 73,0D
008A0:  DATA 0A,00
008A2:  DATA 40,46
008A4:  DATA 53,3A
008A6:  DATA 4E,6F
008A8:  DATA 74,20
008AA:  DATA 61,6E
008AC:  DATA 20,53
008AE:  DATA 44,53
008B0:  DATA 43,20
008B2:  DATA 6F,72
008B4:  DATA 20,53
008B6:  DATA 44,48
008B8:  DATA 43,20
008BA:  DATA 63,61
008BC:  DATA 72,64
008BE:  DATA 2C,20
008C0:  DATA 54,65
008C2:  DATA 73,74
008C4:  DATA 69,6E
008C6:  DATA 67,20
008C8:  DATA 66,6F
008CA:  DATA 72,20
008CC:  DATA 53,44
008CE:  DATA 20,56
008D0:  DATA 65,72
008D2:  DATA 31,20
008D4:  DATA 6F,72
008D6:  DATA 20,4D
008D8:  DATA 4D,43
008DA:  DATA 20,43
008DC:  DATA 61,72
008DE:  DATA 64,0D
008E0:  DATA 0A,00
008E2:  DATA 40,46
008E4:  DATA 53,3A
008E6:  DATA 52,65
008E8:  DATA 73,70
008EA:  DATA 6F,6E
008EC:  DATA 73,65
008EE:  DATA 20,66
008F0:  DATA 72,6F
008F2:  DATA 6D,20
008F4:  DATA 47,4F
008F6:  DATA 5F,49
008F8:  DATA 44,4C
008FA:  DATA 45,20
008FC:  DATA 3D,20
008FE:  DATA 25,30
00900:  DATA 32,78
00902:  DATA 0D,0A
00904:  DATA 00,00
00906:  DATA 40,46
00908:  DATA 53,3A
0090A:  DATA 52,65
0090C:  DATA 73,70
0090E:  DATA 6F,6E
00910:  DATA 73,65
00912:  DATA 20,66
00914:  DATA 72,6F
00916:  DATA 6D,20
00918:  DATA 53,44
0091A:  DATA 5F,43
0091C:  DATA 4D,44
0091E:  DATA 5F,53
00920:  DATA 45,4E
00922:  DATA 44,5F
00924:  DATA 4F,50
00926:  DATA 5F,43
00928:  DATA 4F,4E
0092A:  DATA 44,20
0092C:  DATA 3D,20
0092E:  DATA 25,30
00930:  DATA 32,78
00932:  DATA 2C,20
00934:  DATA 54,69
00936:  DATA 6D,65
00938:  DATA 72,20
0093A:  DATA 3D,20
0093C:  DATA 25,6C
0093E:  DATA 75,0D
00940:  DATA 0A,00
00942:  DATA 40,46
00944:  DATA 53,3A
00946:  DATA 41,74
00948:  DATA 74,65
0094A:  DATA 6D,70
0094C:  DATA 74,69
0094E:  DATA 6E,67
00950:  DATA 20,53
00952:  DATA 44,76
00954:  DATA 31,20
00956:  DATA 76,65
00958:  DATA 72,73
0095A:  DATA 75,73
0095C:  DATA 20,4D
0095E:  DATA 4D,43
00960:  DATA 20,49
00962:  DATA 44,2C
00964:  DATA 20,52
00966:  DATA 65,73
00968:  DATA 70,6F
0096A:  DATA 6E,73
0096C:  DATA 65,20
0096E:  DATA 66,72
00970:  DATA 6F,6D
00972:  DATA 20,53
00974:  DATA 44,5F
00976:  DATA 43,4D
00978:  DATA 44,5F
0097A:  DATA 41,50
0097C:  DATA 50,4C
0097E:  DATA 5F,43
00980:  DATA 4D,44
00982:  DATA 20,3D
00984:  DATA 20,25
00986:  DATA 30,32
00988:  DATA 78,0D
0098A:  DATA 0A,00
0098C:  DATA 40,46
0098E:  DATA 53,3A
00990:  DATA 49,6E
00992:  DATA 76,61
00994:  DATA 6C,69
00996:  DATA 64,20
00998:  DATA 72,65
0099A:  DATA 73,70
0099C:  DATA 6F,6E
0099E:  DATA 73,65
009A0:  DATA 20,74
009A2:  DATA 6F,20
009A4:  DATA 53,44
009A6:  DATA 5F,41
009A8:  DATA 43,4D
009AA:  DATA 44,34
009AC:  DATA 31,2C
009AE:  DATA 20,72
009B0:  DATA 65,73
009B2:  DATA 70,6F
009B4:  DATA 6E,73
009B6:  DATA 65,20
009B8:  DATA 3D,20
009BA:  DATA 25,30
009BC:  DATA 32,58
009BE:  DATA 2C,20
009C0:  DATA 72,65
009C2:  DATA 69,6E
009C4:  DATA 69,74
009C6:  DATA 69,61
009C8:  DATA 6C,69
009CA:  DATA 7A,69
009CC:  DATA 6E,67
009CE:  DATA 20,61
009D0:  DATA 73,20
009D2:  DATA 4D,4D
009D4:  DATA 43,0D
009D6:  DATA 0A,00
009D8:  DATA 40,46
009DA:  DATA 53,3A
009DC:  DATA 46,61
009DE:  DATA 69,6C
009E0:  DATA 65,64
009E2:  DATA 20,74
009E4:  DATA 6F,20
009E6:  DATA 69,6E
009E8:  DATA 69,74
009EA:  DATA 69,61
009EC:  DATA 6C,69
009EE:  DATA 7A,65
009F0:  DATA 20,61
009F2:  DATA 73,20
009F4:  DATA 4D,4D
009F6:  DATA 43,2C
009F8:  DATA 20,72
009FA:  DATA 65,73
009FC:  DATA 70,6F
009FE:  DATA 6E,73
00A00:  DATA 65,20
00A02:  DATA 3D,20
00A04:  DATA 25,30
00A06:  DATA 32,58
00A08:  DATA 2C,20
00A0A:  DATA 65,78
00A0C:  DATA 69,74
00A0E:  DATA 69,6E
00A10:  DATA 67,0D
00A12:  DATA 0A,00
00A14:  DATA 40,46
00A16:  DATA 53,3A
00A18:  DATA 43,61
00A1A:  DATA 72,64
00A1C:  DATA 20,66
00A1E:  DATA 61,69
00A20:  DATA 6C,65
00A22:  DATA 64,20
00A24:  DATA 74,6F
00A26:  DATA 20,72
00A28:  DATA 65,73
00A2A:  DATA 70,6F
00A2C:  DATA 6E,64
00A2E:  DATA 20,63
00A30:  DATA 6F,72
00A32:  DATA 72,65
00A34:  DATA 63,6C
00A36:  DATA 79,20
00A38:  DATA 61,66
00A3A:  DATA 74,65
00A3C:  DATA 72,20
00A3E:  DATA 53,44
00A40:  DATA 5F,43
00A42:  DATA 4D,44
00A44:  DATA 5F,53
00A46:  DATA 45,4E
00A48:  DATA 44,5F
00A4A:  DATA 4F,50
00A4C:  DATA 5F,43
00A4E:  DATA 4F,4E
00A50:  DATA 44,2C
00A52:  DATA 20,72
00A54:  DATA 65,73
00A56:  DATA 70,6F
00A58:  DATA 6E,73
00A5A:  DATA 65,20
00A5C:  DATA 3D,20
00A5E:  DATA 25,30
00A60:  DATA 32,58
00A62:  DATA 2C,20
00A64:  DATA 54,69
00A66:  DATA 6D,65
00A68:  DATA 72,20
00A6A:  DATA 3D,20
00A6C:  DATA 25,6C
00A6E:  DATA 75,0D
00A70:  DATA 0A,00
00A72:  DATA 40,46
00A74:  DATA 53,3A
00A76:  DATA 53,65
00A78:  DATA 74,74
00A7A:  DATA 69,6E
00A7C:  DATA 67,20
00A7E:  DATA 62,6C
00A80:  DATA 6F,63
00A82:  DATA 6B,20
00A84:  DATA 6C,65
00A86:  DATA 6E,67
00A88:  DATA 74,68
00A8A:  DATA 0D,0A
00A8C:  DATA 00,00
00A8E:  DATA 40,46
00A90:  DATA 53,3A
00A92:  DATA 45,72
00A94:  DATA 72,6F
00A96:  DATA 72,20
00A98:  DATA 73,65
00A9A:  DATA 74,74
00A9C:  DATA 69,6E
00A9E:  DATA 67,20
00AA0:  DATA 62,6C
00AA2:  DATA 6F,63
00AA4:  DATA 6B,20
00AA6:  DATA 6C,65
00AA8:  DATA 6E,67
00AAA:  DATA 74,68
00AAC:  DATA 2C,20
00AAE:  DATA 72,65
00AB0:  DATA 73,70
00AB2:  DATA 6F,6E
00AB4:  DATA 73,65
00AB6:  DATA 20,3D
00AB8:  DATA 20,25
00ABA:  DATA 30,32
00ABC:  DATA 78,2C
00ABE:  DATA 20,74
00AC0:  DATA 69,6D
00AC2:  DATA 65,72
00AC4:  DATA 20,3D
00AC6:  DATA 20,25
00AC8:  DATA 6C,75
00ACA:  DATA 0D,0A
00ACC:  DATA 00,00
00ACE:  DATA 40,46
00AD0:  DATA 53,3A
00AD2:  DATA 43,61
00AD4:  DATA 72,64
00AD6:  DATA 20,54
00AD8:  DATA 79,70
00ADA:  DATA 65,20
00ADC:  DATA 44,69
00ADE:  DATA 73,63
00AE0:  DATA 6F,76
00AE2:  DATA 65,72
00AE4:  DATA 79,20
00AE6:  DATA 45,72
00AE8:  DATA 72,6F
00AEA:  DATA 72,0D
00AEC:  DATA 0A,00
00AEE:  DATA 40,46
00AF0:  DATA 53,3A
00AF2:  DATA 4D,4D
00AF4:  DATA 43,20
00AF6:  DATA 43,61
00AF8:  DATA 72,64
00AFA:  DATA 20,66
00AFC:  DATA 6F,75
00AFE:  DATA 6E,64
00B00:  DATA 0D,0A
00B02:  DATA 00,00
00B04:  DATA 40,46
00B06:  DATA 53,3A
00B08:  DATA 53,44
00B0A:  DATA 76,31
00B0C:  DATA 20,43
00B0E:  DATA 61,72
00B10:  DATA 64,20
00B12:  DATA 66,6F
00B14:  DATA 75,6E
00B16:  DATA 64,0D
00B18:  DATA 0A,00
00B1A:  DATA 40,46
00B1C:  DATA 53,3A
00B1E:  DATA 53,44
00B20:  DATA 53,43
00B22:  DATA 20,43
00B24:  DATA 61,72
00B26:  DATA 64,20
00B28:  DATA 66,6F
00B2A:  DATA 75,6E
00B2C:  DATA 64,0D
00B2E:  DATA 0A,00
00B30:  DATA 40,46
00B32:  DATA 53,3A
00B34:  DATA 53,44
00B36:  DATA 48,43
00B38:  DATA 20,43
00B3A:  DATA 61,72
00B3C:  DATA 64,20
00B3E:  DATA 66,6F
00B40:  DATA 75,6E
00B42:  DATA 64,0D
00B44:  DATA 0A,00
00B46:  DATA 40,46
00B48:  DATA 53,3A
00B4A:  DATA 43,61
00B4C:  DATA 72,64
00B4E:  DATA 20,54
00B50:  DATA 79,70
00B52:  DATA 65,20
00B54:  DATA 44,69
00B56:  DATA 73,63
00B58:  DATA 6F,76
00B5A:  DATA 65,72
00B5C:  DATA 79,20
00B5E:  DATA 45,72
00B60:  DATA 72,6F
00B62:  DATA 72,2C
00B64:  DATA 20,43
00B66:  DATA 61,72
00B68:  DATA 64,20
00B6A:  DATA 3D,20
00B6C:  DATA 25,30
00B6E:  DATA 32,58
00B70:  DATA 0D,0A
00B72:  DATA 00,00
00B74:  DATA 40,46
00B76:  DATA 53,3A
00B78:  DATA 43,61
00B7A:  DATA 72,64
00B7C:  DATA 20,72
00B7E:  DATA 65,73
00B80:  DATA 65,74
00B82:  DATA 20,73
00B84:  DATA 75,63
00B86:  DATA 63,65
00B88:  DATA 73,73
00B8A:  DATA 20,2D
00B8C:  DATA 20,43
00B8E:  DATA 6D,64
00B90:  DATA 20,74
00B92:  DATA 6F,20
00B94:  DATA 52,65
00B96:  DATA 61,64
00B98:  DATA 79,20
00B9A:  DATA 63,6F
00B9C:  DATA 75,6E
00B9E:  DATA 74,20
00BA0:  DATA 3D,20
00BA2:  DATA 25,6C
00BA4:  DATA 75,0D
00BA6:  DATA 0A,00
00BA8:  DATA 40,46
00BAA:  DATA 53,3A
00BAC:  DATA 53,50
00BAE:  DATA 49,20
00BB0:  DATA 62,75
00BB2:  DATA 73,20
00BB4:  DATA 73,70
00BB6:  DATA 65,65
00BB8:  DATA 64,20
00BBA:  DATA 73,65
00BBC:  DATA 74,20
00BBE:  DATA 74,6F
00BC0:  DATA 20,68
00BC2:  DATA 69,67
00BC4:  DATA 68,0D
00BC6:  DATA 0A,00
00BC8:  DATA 40,46
00BCA:  DATA 53,3A
00BCC:  DATA 43,61
00BCE:  DATA 72,64
00BD0:  DATA 20,61
00BD2:  DATA 63,74
00BD4:  DATA 69,76
00BD6:  DATA 61,74
00BD8:  DATA 65,20
00BDA:  DATA 66,61
00BDC:  DATA 69,6C
00BDE:  DATA 75,72
00BE0:  DATA 65,2C
00BE2:  DATA 20,72
00BE4:  DATA 65,73
00BE6:  DATA 70,6F
00BE8:  DATA 6E,73
00BEA:  DATA 65,20
00BEC:  DATA 3D,20
00BEE:  DATA 25,30
00BF0:  DATA 32,58
00BF2:  DATA 2C,20
00BF4:  DATA 54,69
00BF6:  DATA 6D,65
00BF8:  DATA 72,20
00BFA:  DATA 3D,20
00BFC:  DATA 25,6C
00BFE:  DATA 75,0D
00C00:  DATA 0A,00
00C02:  DATA 40,46
00C04:  DATA 53,3A
00C06:  DATA 43,61
00C08:  DATA 72,64
00C0A:  DATA 20,61
00C0C:  DATA 63,74
00C0E:  DATA 69,76
00C10:  DATA 61,74
00C12:  DATA 65,20
00C14:  DATA 73,75
00C16:  DATA 63,63
00C18:  DATA 65,73
00C1A:  DATA 73,20
00C1C:  DATA 6F,6E
00C1E:  DATA 20,61
00C20:  DATA 74,74
00C22:  DATA 65,6D
00C24:  DATA 70,74
00C26:  DATA 20,25
00C28:  DATA 6C,75
00C2A:  DATA 0D,0A
00C2C:  DATA 00,00
00C2E:  DATA 46,41
00C30:  DATA 54,20
00C32:  DATA 61,74
00C34:  DATA 20,73
00C36:  DATA 65,63
00C38:  DATA 74,6F
00C3A:  DATA 72,20
00C3C:  DATA 30,0D
00C3E:  DATA 0A,00
00C40:  DATA 54,59
00C42:  DATA 50,45
00C44:  DATA 20,63
00C46:  DATA 6F,6D
00C48:  DATA 6D,61
00C4A:  DATA 6E,64
00C4C:  DATA 20,45
00C4E:  DATA 52,52
00C50:  DATA 4F,52
00C52:  DATA 0D,0A
00C54:  DATA 00,00
00C56:  DATA 40,46
00C58:  DATA 53,3A
00C5A:  DATA 20,25
00C5C:  DATA 73,0D
00C5E:  DATA 0A,00
00C60:  DATA 40,46
00C62:  DATA 53,3A
00C64:  DATA 20,25
00C66:  DATA 73,0D
00C68:  DATA 0A,00
00C6A:  DATA 2A,2A
00C6C:  DATA 20,40
00C6E:  DATA 46,53
00C70:  DATA 3A,20
00C72:  DATA 45,52
00C74:  DATA 52,4F
00C76:  DATA 52,0D
00C78:  DATA 0A,00
00C7A:  DATA 20,20
00C7C:  DATA 20,4E
00C7E:  DATA 6F,45
00C80:  DATA 72,72
00C82:  DATA 6F,72
00C84:  DATA 0D,0A
00C86:  DATA 00,00
00C88:  DATA 20,20
00C8A:  DATA 20,4D
00C8C:  DATA 65,64
00C8E:  DATA 69,61
00C90:  DATA 20,4E
00C92:  DATA 6F,74
00C94:  DATA 20,52
00C96:  DATA 65,61
00C98:  DATA 64,79
00C9A:  DATA 0D,0A
00C9C:  DATA 00,00
00C9E:  DATA 20,20
00CA0:  DATA 20,46
00CA2:  DATA 69,6C
00CA4:  DATA 65,20
00CA6:  DATA 4E,6F
00CA8:  DATA 74,20
00CAA:  DATA 46,6F
00CAC:  DATA 75,6E
00CAE:  DATA 64,0D
00CB0:  DATA 0A,00
00CB2:  DATA 20,20
00CB4:  DATA 20,49
00CB6:  DATA 6E,76
00CB8:  DATA 61,6C
00CBA:  DATA 69,64
00CBC:  DATA 20,50
00CBE:  DATA 61,74
00CC0:  DATA 68,0D
00CC2:  DATA 0A,00
00CC4:  DATA 20,20
00CC6:  DATA 20,49
00CC8:  DATA 6E,76
00CCA:  DATA 61,6C
00CCC:  DATA 69,64
00CCE:  DATA 20,4E
00CD0:  DATA 61,6D
00CD2:  DATA 65,0D
00CD4:  DATA 0A,00
00CD6:  DATA 20,20
00CD8:  DATA 20,41
00CDA:  DATA 63,63
00CDC:  DATA 65,73
00CDE:  DATA 73,20
00CE0:  DATA 44,65
00CE2:  DATA 6E,69
00CE4:  DATA 65,64
00CE6:  DATA 0D,0A
00CE8:  DATA 00,00
00CEA:  DATA 20,20
00CEC:  DATA 20,44
00CEE:  DATA 69,73
00CF0:  DATA 6B,20
00CF2:  DATA 46,75
00CF4:  DATA 6C,6C
00CF6:  DATA 0D,0A
00CF8:  DATA 00,00
00CFA:  DATA 20,20
00CFC:  DATA 20,52
00CFE:  DATA 65,61
00D00:  DATA 64,2F
00D02:  DATA 57,72
00D04:  DATA 69,74
00D06:  DATA 65,20
00D08:  DATA 45,72
00D0A:  DATA 72,6F
00D0C:  DATA 72,0D
00D0E:  DATA 0A,00
00D10:  DATA 20,20
00D12:  DATA 20,49
00D14:  DATA 6E,63
00D16:  DATA 6F,72
00D18:  DATA 72,65
00D1A:  DATA 63,74
00D1C:  DATA 20,4D
00D1E:  DATA 65,64
00D20:  DATA 69,61
00D22:  DATA 20,43
00D24:  DATA 68,61
00D26:  DATA 6E,67
00D28:  DATA 65,0D
00D2A:  DATA 0A,00
00D2C:  DATA 20,20
00D2E:  DATA 20,57
00D30:  DATA 72,69
00D32:  DATA 74,65
00D34:  DATA 20,50
00D36:  DATA 72,6F
00D38:  DATA 74,65
00D3A:  DATA 63,74
00D3C:  DATA 65,64
00D3E:  DATA 0D,0A
00D40:  DATA 00,00
00D42:  DATA 20,20
00D44:  DATA 20,4E
00D46:  DATA 6F,74
00D48:  DATA 20,45
00D4A:  DATA 6E,61
00D4C:  DATA 62,6C
00D4E:  DATA 65,64
00D50:  DATA 0D,0A
00D52:  DATA 00,00
00D54:  DATA 20,20
00D56:  DATA 20,4E
00D58:  DATA 6F,20
00D5A:  DATA 46,69
00D5C:  DATA 6C,65
00D5E:  DATA 20,53
00D60:  DATA 79,73
00D62:  DATA 74,65
00D64:  DATA 6D,0D
00D66:  DATA 0A,00
00D68:  DATA 61,70
00D6A:  DATA 70,65
00D6C:  DATA 6E,64
00D6E:  DATA 3A,20
00D70:  DATA 46,53
00D72:  DATA 20,45
00D74:  DATA 52,52
00D76:  DATA 4F,52
00D78:  DATA 20,6F
00D7A:  DATA 6E,20
00D7C:  DATA 66,69
00D7E:  DATA 6C,65
00D80:  DATA 5F,6F
00D82:  DATA 70,65
00D84:  DATA 6E,0D
00D86:  DATA 0A,00
00D88:  DATA 40,46
00D8A:  DATA 53,3A
00D8C:  DATA 57,72
00D8E:  DATA 69,74
00D90:  DATA 69,6E
00D92:  DATA 67,0D
00D94:  DATA 0A,5B
00D96:  DATA 25,73
00D98:  DATA 5D,0D
00D9A:  DATA 0A,00
00D9C:  DATA 40,46
00D9E:  DATA 53,3A
00DA0:  DATA 45,52
00DA2:  DATA 52,4F
00DA4:  DATA 52,5B
00DA6:  DATA 61,70
00DA8:  DATA 70,65
00DAA:  DATA 6E,64
00DAC:  DATA 5D,0D
00DAE:  DATA 0A,00
00DB0:  DATA 40,46
00DB2:  DATA 53,3A
00DB4:  DATA 43,6C
00DB6:  DATA 6F,73
00DB8:  DATA 69,6E
00DBA:  DATA 67,0D
00DBC:  DATA 0A,00
00DBE:  DATA 40,52
00DC0:  DATA 54,43
00DC2:  DATA 3A,25
00DC4:  DATA 30,32
00DC6:  DATA 75,2F
00DC8:  DATA 00,00
00DCA:  DATA 40,52
00DCC:  DATA 54,43
00DCE:  DATA 3A,25
00DD0:  DATA 30,32
00DD2:  DATA 75,2F
00DD4:  DATA 00,00
00DD6:  DATA 40,41
00DD8:  DATA 4C,4D
00DDA:  DATA 3A,25
00DDC:  DATA 30,32
00DDE:  DATA 75,2F
00DE0:  DATA 00,00
00DE2:  DATA 40,41
00DE4:  DATA 4C,4D
00DE6:  DATA 3A,25
00DE8:  DATA 30,32
00DEA:  DATA 75,2F
00DEC:  DATA 00,00
00DEE:  DATA 74,65
00DF0:  DATA 73,74
00DF2:  DATA 36,3A
00DF4:  DATA 20,25
00DF6:  DATA 64,0D
00DF8:  DATA 0A,00
00DFA:  DATA 40,41
00DFC:  DATA 4C,4D
00DFE:  DATA 0D,0A
00E00:  DATA 00,00
*
00E78:  TBLRD*+
00E7A:  MOVF   FF5,F
00E7C:  BZ    0EA0
00E7E:  MOVFF  FF6,A11
00E82:  MOVFF  FF7,A12
00E86:  MOVFF  FF8,A13
00E8A:  MOVF   FF5,W
00E8C:  BTFSS  F9E.4
00E8E:  BRA    0E8C
00E90:  MOVWF  FAD
00E92:  MOVFF  A11,FF6
00E96:  MOVFF  A12,FF7
00E9A:  MOVFF  A13,FF8
00E9E:  BRA    0E78
00EA0:  RETURN 0
*
00F02:  DATA 3F,40
00F04:  DATA 42,53
00F06:  DATA 59,0D
00F08:  DATA 0A,00
00F0A:  DATA 40,52
00F0C:  DATA 44,59
00F0E:  DATA 0D,0A
00F10:  DATA 00,00
*
00F52:  DATA 40,5B
00F54:  DATA 4F,5D
00F56:  DATA 0D,0A
00F58:  DATA 00,00
00F5A:  DATA 40,43
00F5C:  DATA 4D,44
00F5E:  DATA 20,74
00F60:  DATA 6F,6F
00F62:  DATA 20,6C
00F64:  DATA 6F,6E
00F66:  DATA 67,0D
00F68:  DATA 0A,00
00F6A:  DATA 40,5B
00F6C:  DATA 43,5D
00F6E:  DATA 0D,0A
00F70:  DATA 00,00
00F72:  DATA 40,53
00F74:  DATA 4C,45
00F76:  DATA 45,50
00F78:  DATA 0D,0A
00F7A:  DATA 00,00
00F7C:  DATA 40,4D
00F7E:  DATA 45,52
00F80:  DATA 2C,25
00F82:  DATA 4C,75
00F84:  DATA 2C,25
00F86:  DATA 4C,75
00F88:  DATA 0D,0A
00F8A:  DATA 00,00
00F8C:  DATA 6D,3A
00F8E:  DATA 25,75
00F90:  DATA 2C,25
00F92:  DATA 75,20
00F94:  DATA 63,3A
00F96:  DATA 25,4C
00F98:  DATA 75,2C
00F9A:  DATA 25,4C
00F9C:  DATA 75,2C
00F9E:  DATA 25,4C
00FA0:  DATA 75,0D
00FA2:  DATA 0A,00
00FA4:  MOVLB  A
00FA6:  MOVF   x1C,W
00FA8:  CLRF   01
00FAA:  SUBWF  x1B,W
00FAC:  BC    0FB4
00FAE:  MOVFF  A1B,00
00FB2:  BRA    0FCC
00FB4:  CLRF   00
00FB6:  MOVLW  08
00FB8:  MOVWF  x1D
00FBA:  RLCF   x1B,F
00FBC:  RLCF   00,F
00FBE:  MOVF   x1C,W
00FC0:  SUBWF  00,W
00FC2:  BTFSC  FD8.0
00FC4:  MOVWF  00
00FC6:  RLCF   01,F
00FC8:  DECFSZ x1D,F
00FCA:  BRA    0FBA
00FCC:  MOVLB  0
00FCE:  RETURN 0
00FD0:  MOVF   01,W
00FD2:  MOVFF  A19,A1B
00FD6:  MOVLW  64
00FD8:  MOVLB  A
00FDA:  MOVWF  x1C
00FDC:  MOVLB  0
00FDE:  RCALL  0FA4
00FE0:  MOVFF  00,A19
00FE4:  MOVF   01,W
00FE6:  MOVLW  30
00FE8:  BNZ   0FFA
00FEA:  MOVLB  A
00FEC:  BTFSS  x1A.1
00FEE:  BRA    100C
00FF0:  BTFSC  x1A.3
00FF2:  BRA    100C
00FF4:  BTFSC  x1A.4
00FF6:  MOVLW  20
00FF8:  BRA    1002
00FFA:  MOVLB  A
00FFC:  BCF    x1A.3
00FFE:  BCF    x1A.4
01000:  BSF    x1A.0
01002:  ADDWF  01,F
01004:  MOVF   01,W
01006:  BTFSS  F9E.4
01008:  BRA    1006
0100A:  MOVWF  FAD
0100C:  MOVFF  A19,A1B
01010:  MOVLW  0A
01012:  MOVWF  x1C
01014:  MOVLB  0
01016:  RCALL  0FA4
01018:  MOVFF  00,A19
0101C:  MOVF   01,W
0101E:  MOVLW  30
01020:  BNZ   1032
01022:  MOVLB  A
01024:  BTFSC  x1A.3
01026:  BRA    103E
01028:  BTFSS  x1A.0
0102A:  BRA    103E
0102C:  BTFSC  x1A.4
0102E:  MOVLW  20
01030:  MOVLB  0
01032:  ADDWF  01,F
01034:  MOVF   01,W
01036:  BTFSS  F9E.4
01038:  BRA    1036
0103A:  MOVWF  FAD
0103C:  MOVLB  A
0103E:  MOVLW  30
01040:  ADDWF  x19,F
01042:  MOVF   x19,W
01044:  BTFSS  F9E.4
01046:  BRA    1044
01048:  MOVWF  FAD
0104A:  MOVLB  0
0104C:  RETURN 0
0104E:  TBLRD*+
01050:  MOVFF  FF6,A1A
01054:  MOVFF  FF7,A1B
01058:  MOVFF  FF8,A1C
0105C:  MOVF   FF5,W
0105E:  BTFSS  F9E.4
01060:  BRA    105E
01062:  MOVWF  FAD
01064:  MOVFF  A1A,FF6
01068:  MOVFF  A1B,FF7
0106C:  MOVFF  A1C,FF8
01070:  MOVLB  A
01072:  DECFSZ x19,F
01074:  BRA    1078
01076:  BRA    107C
01078:  MOVLB  0
0107A:  BRA    104E
0107C:  MOVLB  0
0107E:  RETURN 0
01080:  BTFSC  FD8.1
01082:  BRA    108C
01084:  MOVLW  0A
01086:  MOVWF  FEA
01088:  MOVLW  2D
0108A:  MOVWF  FE9
0108C:  CLRF   00
0108E:  CLRF   01
01090:  CLRF   02
01092:  CLRF   03
01094:  MOVLB  A
01096:  CLRF   x2D
01098:  CLRF   x2E
0109A:  CLRF   x2F
0109C:  CLRF   x30
0109E:  MOVF   x2C,W
010A0:  IORWF  x2B,W
010A2:  IORWF  x2A,W
010A4:  IORWF  x29,W
010A6:  BZ    1100
010A8:  MOVLW  20
010AA:  MOVWF  x31
010AC:  BCF    FD8.0
010AE:  RLCF   x25,F
010B0:  RLCF   x26,F
010B2:  RLCF   x27,F
010B4:  RLCF   x28,F
010B6:  RLCF   x2D,F
010B8:  RLCF   x2E,F
010BA:  RLCF   x2F,F
010BC:  RLCF   x30,F
010BE:  MOVF   x2C,W
010C0:  SUBWF  x30,W
010C2:  BNZ   10D4
010C4:  MOVF   x2B,W
010C6:  SUBWF  x2F,W
010C8:  BNZ   10D4
010CA:  MOVF   x2A,W
010CC:  SUBWF  x2E,W
010CE:  BNZ   10D4
010D0:  MOVF   x29,W
010D2:  SUBWF  x2D,W
010D4:  BNC   10F4
010D6:  MOVF   x29,W
010D8:  SUBWF  x2D,F
010DA:  MOVF   x2A,W
010DC:  BTFSS  FD8.0
010DE:  INCFSZ x2A,W
010E0:  SUBWF  x2E,F
010E2:  MOVF   x2B,W
010E4:  BTFSS  FD8.0
010E6:  INCFSZ x2B,W
010E8:  SUBWF  x2F,F
010EA:  MOVF   x2C,W
010EC:  BTFSS  FD8.0
010EE:  INCFSZ x2C,W
010F0:  SUBWF  x30,F
010F2:  BSF    FD8.0
010F4:  RLCF   00,F
010F6:  RLCF   01,F
010F8:  RLCF   02,F
010FA:  RLCF   03,F
010FC:  DECFSZ x31,F
010FE:  BRA    10AC
01100:  MOVFF  A2D,FEF
01104:  MOVFF  A2E,FEC
01108:  MOVFF  A2F,FEC
0110C:  MOVFF  A30,FEC
01110:  MOVLB  0
01112:  RETURN 0
01114:  MOVF   FE9,W
01116:  MOVLB  A
01118:  MOVWF  x1D
0111A:  MOVLW  3B
0111C:  MOVWF  x24
0111E:  MOVLW  9A
01120:  MOVWF  x23
01122:  MOVLW  CA
01124:  MOVWF  x22
01126:  CLRF   x21
01128:  MOVLW  0A
0112A:  MOVWF  x1F
0112C:  BSF    FD8.1
0112E:  MOVLW  0A
01130:  MOVWF  FEA
01132:  MOVLW  19
01134:  MOVWF  FE9
01136:  MOVFF  A1C,A28
0113A:  MOVFF  A1B,A27
0113E:  MOVFF  A1A,A26
01142:  MOVFF  A19,A25
01146:  MOVFF  A24,A2C
0114A:  MOVFF  A23,A2B
0114E:  MOVFF  A22,A2A
01152:  MOVFF  A21,A29
01156:  MOVLB  0
01158:  RCALL  1080
0115A:  MOVF   01,W
0115C:  MOVF   00,F
0115E:  BNZ   1186
01160:  MOVLB  A
01162:  MOVF   x1F,W
01164:  XORLW  01
01166:  BTFSS  FD8.2
01168:  BRA    116E
0116A:  MOVLB  0
0116C:  BRA    1186
0116E:  MOVF   x1D,W
01170:  BZ    118A
01172:  ANDLW  0F
01174:  SUBWF  x1F,W
01176:  BZ    117A
01178:  BC    1196
0117A:  BTFSC  x1D.7
0117C:  BRA    1196
0117E:  BTFSC  x1D.6
01180:  BRA    118A
01182:  MOVLW  20
01184:  BRA    118C
01186:  MOVLB  A
01188:  CLRF   x1D
0118A:  MOVLW  30
0118C:  ADDWF  00,F
0118E:  MOVF   00,W
01190:  BTFSS  F9E.4
01192:  BRA    1190
01194:  MOVWF  FAD
01196:  BCF    FD8.1
01198:  MOVFF  A24,A28
0119C:  MOVFF  A23,A27
011A0:  MOVFF  A22,A26
011A4:  MOVFF  A21,A25
011A8:  CLRF   x2C
011AA:  CLRF   x2B
011AC:  CLRF   x2A
011AE:  MOVLW  0A
011B0:  MOVWF  x29
011B2:  MOVLB  0
011B4:  RCALL  1080
011B6:  MOVFF  03,A24
011BA:  MOVFF  02,A23
011BE:  MOVFF  01,A22
011C2:  MOVFF  00,A21
011C6:  MOVLB  A
011C8:  DECFSZ x1F,F
011CA:  BRA    112C
011CC:  MOVLB  0
011CE:  RETURN 0
011D0:  MOVFF  FEA,A21
011D4:  MOVFF  FE9,A20
011D8:  MOVLB  A
011DA:  SWAPF  x1A,W
011DC:  IORLW  F0
011DE:  MOVWF  x1C
011E0:  ADDWF  x1C,F
011E2:  ADDLW  E2
011E4:  MOVWF  x1D
011E6:  ADDLW  32
011E8:  MOVWF  x1F
011EA:  MOVF   x1A,W
011EC:  ANDLW  0F
011EE:  ADDWF  x1D,F
011F0:  ADDWF  x1D,F
011F2:  ADDWF  x1F,F
011F4:  ADDLW  E9
011F6:  MOVWF  x1E
011F8:  ADDWF  x1E,F
011FA:  ADDWF  x1E,F
011FC:  SWAPF  x19,W
011FE:  ANDLW  0F
01200:  ADDWF  x1E,F
01202:  ADDWF  x1F,F
01204:  RLCF   x1E,F
01206:  RLCF   x1F,F
01208:  COMF   x1F,F
0120A:  RLCF   x1F,F
0120C:  MOVF   x19,W
0120E:  ANDLW  0F
01210:  ADDWF  x1F,F
01212:  RLCF   x1C,F
01214:  MOVLW  07
01216:  MOVWF  x1B
01218:  MOVLW  0A
0121A:  DECF   x1E,F
0121C:  ADDWF  x1F,F
0121E:  BNC   121A
01220:  DECF   x1D,F
01222:  ADDWF  x1E,F
01224:  BNC   1220
01226:  DECF   x1C,F
01228:  ADDWF  x1D,F
0122A:  BNC   1226
0122C:  DECF   x1B,F
0122E:  ADDWF  x1C,F
01230:  BNC   122C
01232:  MOVLW  0A
01234:  MOVWF  FEA
01236:  MOVLW  1B
01238:  MOVWF  FE9
0123A:  MOVLW  07
0123C:  ANDWF  x20,W
0123E:  BCF    x20.6
01240:  ADDWF  FE9,F
01242:  MOVLW  00
01244:  ADDWFC FEA,F
01246:  MOVF   FE9,W
01248:  SUBLW  1F
0124A:  BNZ   1254
0124C:  MOVF   FEA,W
0124E:  SUBLW  0A
01250:  BNZ   1254
01252:  BSF    x20.6
01254:  MOVF   FEF,W
01256:  MOVWF  00
01258:  BNZ   126A
0125A:  BTFSC  x20.6
0125C:  BRA    126A
0125E:  BTFSC  x20.4
01260:  BRA    127A
01262:  BTFSC  x20.3
01264:  BRA    126A
01266:  MOVLW  20
01268:  BRA    1270
0126A:  BSF    x20.3
0126C:  BCF    x20.4
0126E:  MOVLW  30
01270:  ADDWF  00,F
01272:  MOVF   00,W
01274:  BTFSS  F9E.4
01276:  BRA    1274
01278:  MOVWF  FAD
0127A:  MOVF   FEE,W
0127C:  BTFSS  x20.6
0127E:  BRA    1246
01280:  MOVLB  0
01282:  RETURN 0
*
01A88:  DATA 40,4C
01A8A:  DATA 50,43
01A8C:  DATA 2C,25
01A8E:  DATA 4C,75
01A90:  DATA 2C,25
01A92:  DATA 4C,64
01A94:  DATA 0D,0A
01A96:  DATA 00,00
01A98:  DATA 40,4D
01A9A:  DATA 4D,45
01A9C:  DATA 2C,25
01A9E:  DATA 75,2C
01AA0:  DATA 25,4C
01AA2:  DATA 64,2C
01AA4:  DATA 25,4C
01AA6:  DATA 75,2C
01AA8:  DATA 25,4C
01AAA:  DATA 75,2C
01AAC:  DATA 25,4C
01AAE:  DATA 64,2C
01AB0:  DATA 25,4C
01AB2:  DATA 64,0D
01AB4:  DATA 0A,00
01AB6:  DATA 56,41
01AB8:  DATA 4C,56
01ABA:  DATA 45,20
01ABC:  DATA 53,54
01ABE:  DATA 4F,50
01AC0:  DATA 20,25
01AC2:  DATA 4C,75
01AC4:  DATA 2C,25
01AC6:  DATA 4C,75
01AC8:  DATA 0D,0A
01ACA:  DATA 00,00
01ACC:  DATA 69,6E
01ACE:  DATA 64,3A
01AD0:  DATA 25,75
01AD2:  DATA 20,2F
01AD4:  DATA 20,70
01AD6:  DATA 68,61
01AD8:  DATA 3A,25
01ADA:  DATA 75,0D
01ADC:  DATA 0A,00
01ADE:  DATA 40,52
01AE0:  DATA 45,43
01AE2:  DATA 20,2D
01AE4:  DATA 20,68
01AE6:  DATA 6F,6D
01AE8:  DATA 69,6E
01AEA:  DATA 67,20
01AEC:  DATA 73,79
01AEE:  DATA 72,69
01AF0:  DATA 6E,67
01AF2:  DATA 65,20
01AF4:  DATA 61,6E
01AF6:  DATA 64,20
01AF8:  DATA 61,6C
01AFA:  DATA 69,67
01AFC:  DATA 6E,69
01AFE:  DATA 6E,67
01B00:  DATA 20,76
01B02:  DATA 61,6C
01B04:  DATA 76,65
01B06:  DATA 20,74
01B08:  DATA 6F,20
01B0A:  DATA 70,6F
01B0C:  DATA 72,74
01B0E:  DATA 20,31
01B10:  DATA 0D,0A
01B12:  DATA 00,00
01B14:  DATA 2C,73
01B16:  DATA 65,72
01B18:  DATA 69,61
01B1A:  DATA 6C,20
01B1C:  DATA 77,61
01B1E:  DATA 6B,65
01B20:  DATA 2D,75
01B22:  DATA 70,2C
01B24:  DATA 53,44
01B26:  DATA 20,69
01B28:  DATA 6E,69
01B2A:  DATA 74,69
01B2C:  DATA 61,6C
01B2E:  DATA 69,7A
01B30:  DATA 65,64
01B32:  DATA 0D,0A
01B34:  DATA 00,00
01B36:  DATA 40,52
01B38:  DATA 53,54
01B3A:  DATA 0D,0A
01B3C:  DATA 00,00
01B3E:  DATA 40,57
01B40:  DATA 44,54
01B42:  DATA 0D,0A
01B44:  DATA 00,00
01B46:  DATA 2C,72
01B48:  DATA 65,73
01B4A:  DATA 74,61
01B4C:  DATA 72,74
01B4E:  DATA 20,63
01B50:  DATA 61,75
01B52:  DATA 73,65
01B54:  DATA 2C,57
01B56:  DATA 44,20
01B58:  DATA 74,69
01B5A:  DATA 6D,65
01B5C:  DATA 2D,6F
01B5E:  DATA 75,74
01B60:  DATA 0D,0A
01B62:  DATA 00,00
01B64:  DATA 40,57
01B66:  DATA 44,53
01B68:  DATA 0D,0A
01B6A:  DATA 00,00
01B6C:  DATA 2C,72
01B6E:  DATA 65,73
01B70:  DATA 74,61
01B72:  DATA 72,74
01B74:  DATA 20,63
01B76:  DATA 61,75
01B78:  DATA 73,65
01B7A:  DATA 2C,57
01B7C:  DATA 44,20
01B7E:  DATA 66,72
01B80:  DATA 6F,6D
01B82:  DATA 20,73
01B84:  DATA 6C,65
01B86:  DATA 65,70
01B88:  DATA 0D,0A
01B8A:  DATA 00,00
01B8C:  DATA 40,4E
01B8E:  DATA 50,55
01B90:  DATA 0D,0A
01B92:  DATA 00,00
01B94:  DATA 2C,69
01B96:  DATA 64,23
01B98:  DATA 5B,25
01B9A:  DATA 4C,75
01B9C:  DATA 5D,2C
01B9E:  DATA 70,6F
01BA0:  DATA 77,65
01BA2:  DATA 72,20
01BA4:  DATA 61,70
01BA6:  DATA 70,6C
01BA8:  DATA 69,65
01BAA:  DATA 64,2C
01BAC:  DATA 53,44
01BAE:  DATA 20,69
01BB0:  DATA 6E,69
01BB2:  DATA 74,69
01BB4:  DATA 61,6C
01BB6:  DATA 69,7A
01BB8:  DATA 65,64
01BBA:  DATA 0D,0A
01BBC:  DATA 00,00
01BBE:  DATA 40,52
01BC0:  DATA 53,54
01BC2:  DATA 0D,0A
01BC4:  DATA 00,00
01BC6:  DATA 2C,72
01BC8:  DATA 65,73
01BCA:  DATA 74,61
01BCC:  DATA 72,74
01BCE:  DATA 20,63
01BD0:  DATA 61,75
01BD2:  DATA 73,65
01BD4:  DATA 2C,72
01BD6:  DATA 65,73
01BD8:  DATA 65,74
01BDA:  DATA 20,69
01BDC:  DATA 6E,73
01BDE:  DATA 74,72
01BE0:  DATA 75,63
01BE2:  DATA 74,69
01BE4:  DATA 6F,6E
01BE6:  DATA 0D,0A
01BE8:  DATA 00,00
01BEA:  DATA 40,42
01BEC:  DATA 4F,52
01BEE:  DATA 0D,0A
01BF0:  DATA 00,00
01BF2:  DATA 2C,72
01BF4:  DATA 65,73
01BF6:  DATA 74,61
01BF8:  DATA 72,74
01BFA:  DATA 20,63
01BFC:  DATA 61,75
01BFE:  DATA 73,65
01C00:  DATA 2C,62
01C02:  DATA 72,6F
01C04:  DATA 77,6E
01C06:  DATA 2D,6F
01C08:  DATA 75,74
01C0A:  DATA 0D,0A
01C0C:  DATA 00,00
01C0E:  DATA 40,4D
01C10:  DATA 52,53
01C12:  DATA 0D,0A
01C14:  DATA 00,00
01C16:  DATA 2C,72
01C18:  DATA 65,73
01C1A:  DATA 74,61
01C1C:  DATA 72,74
01C1E:  DATA 20,63
01C20:  DATA 61,75
01C22:  DATA 73,65
01C24:  DATA 2C,4D
01C26:  DATA 43,4C
01C28:  DATA 52,20
01C2A:  DATA 66,72
01C2C:  DATA 6F,6D
01C2E:  DATA 20,73
01C30:  DATA 6C,65
01C32:  DATA 65,70
01C34:  DATA 0D,0A
01C36:  DATA 00,00
01C38:  DATA 40,4D
01C3A:  DATA 52,52
01C3C:  DATA 0D,0A
01C3E:  DATA 00,00
01C40:  DATA 2C,72
01C42:  DATA 65,73
01C44:  DATA 74,61
01C46:  DATA 72,74
01C48:  DATA 20,63
01C4A:  DATA 61,75
01C4C:  DATA 73,65
01C4E:  DATA 2C,4D
01C50:  DATA 43,4C
01C52:  DATA 52,20
01C54:  DATA 77,68
01C56:  DATA 65,6E
01C58:  DATA 20,72
01C5A:  DATA 75,6E
01C5C:  DATA 6E,69
01C5E:  DATA 6E,67
01C60:  DATA 0D,0A
01C62:  DATA 00,00
01C64:  DATA 4E,4F
01C66:  DATA 33,00
01C68:  DATA 4E,4F
01C6A:  DATA 32,00
01C6C:  DATA 50,4F
01C6E:  DATA 34,00
01C70:  DATA 4E,48
01C72:  DATA 34,00
01C74:  DATA 53,69
01C76:  DATA 4F,00
01C78:  DATA 00,00
01C7A:  DATA 40,44
01C7C:  DATA 45,54
01C7E:  DATA 5B,2F
01C80:  DATA 25,75
01C82:  DATA 5D,5B
01C84:  DATA 25,63
01C86:  DATA 5D,41
01C88:  DATA 52,47
01C8A:  DATA 5B,25
01C8C:  DATA 4C,75
01C8E:  DATA 5D,0D
01C90:  DATA 0A,00
01C92:  DATA 20,74
01C94:  DATA 69,6D
01C96:  DATA 65,2D
01C98:  DATA 6F,75
01C9A:  DATA 74,00
01C9C:  DATA 20,64
01C9E:  DATA 61,74
01CA0:  DATA 61,20
01CA2:  DATA 74,6F
01CA4:  DATA 6F,20
01CA6:  DATA 73,68
01CA8:  DATA 6F,72
01CAA:  DATA 74,00
01CAC:  DATA 20,64
01CAE:  DATA 61,74
01CB0:  DATA 61,20
01CB2:  DATA 74,6F
01CB4:  DATA 6F,20
01CB6:  DATA 6C,6F
01CB8:  DATA 6E,67
01CBA:  DATA 00,00
01CBC:  DATA 2C,64
01CBE:  DATA 65,74
01CC0:  DATA 65,63
01CC2:  DATA 74,6F
01CC4:  DATA 72,5B
01CC6:  DATA 25,73
01CC8:  DATA 5D,2C
01CCA:  DATA 6C,65
01CCC:  DATA 6E,5B
01CCE:  DATA 25,75
01CD0:  DATA 5D,00
01CD2:  DATA 40,52
01CD4:  DATA 54,59
01CD6:  DATA 2C,25
01CD8:  DATA 75,0D
01CDA:  DATA 0A,00
01CDC:  DATA 2C,73
01CDE:  DATA 74,61
01CE0:  DATA 72,74
01CE2:  DATA 20,68
01CE4:  DATA 65,61
01CE6:  DATA 74,69
01CE8:  DATA 6E,67
01CEA:  DATA 2C,74
01CEC:  DATA 61,72
01CEE:  DATA 67,65
01CF0:  DATA 74,5B
01CF2:  DATA 25,4C
01CF4:  DATA 75,5D
01CF6:  DATA 2C,61
01CF8:  DATA 63,74
01CFA:  DATA 75,61
01CFC:  DATA 6C,5B
01CFE:  DATA 25,4C
01D00:  DATA 75,5D
01D02:  DATA 2C,72
01D04:  DATA 65,61
01D06:  DATA 64,69
01D08:  DATA 6E,67
01D0A:  DATA 73,5B
01D0C:  DATA 25,4C
01D0E:  DATA 75,5D
01D10:  DATA 0D,0A
01D12:  DATA 00,00
01D14:  DATA 2C,65
01D16:  DATA 6E,64
01D18:  DATA 20,68
01D1A:  DATA 65,61
01D1C:  DATA 74,69
01D1E:  DATA 6E,67
01D20:  DATA 2C,74
01D22:  DATA 61,72
01D24:  DATA 67,65
01D26:  DATA 74,5B
01D28:  DATA 25,4C
01D2A:  DATA 75,5D
01D2C:  DATA 2C,61
01D2E:  DATA 63,74
01D30:  DATA 75,61
01D32:  DATA 6C,5B
01D34:  DATA 25,4C
01D36:  DATA 75,5D
01D38:  DATA 2C,72
01D3A:  DATA 65,61
01D3C:  DATA 64,69
01D3E:  DATA 6E,67
01D40:  DATA 73,5B
01D42:  DATA 25,4C
01D44:  DATA 75,5D
01D46:  DATA 0D,0A
01D48:  DATA 00,00
01D4A:  DATA 4E,4F
01D4C:  DATA 33,00
01D4E:  DATA 4E,4F
01D50:  DATA 32,00
01D52:  DATA 50,4F
01D54:  DATA 34,00
01D56:  DATA 4E,48
01D58:  DATA 34,00
01D5A:  DATA 53,69
01D5C:  DATA 4F,00
01D5E:  DATA 00,00
01D60:  DATA 40,44
01D62:  DATA 41,43
01D64:  DATA 2C,25
01D66:  DATA 4C,75
01D68:  DATA 2C,25
01D6A:  DATA 4C,75
01D6C:  DATA 2C,00
01D6E:  DATA 40,53
01D70:  DATA 41,52
01D72:  DATA 2C,31
01D74:  DATA 2C,25
01D76:  DATA 4C,75
01D78:  DATA 2C,00
01D7A:  DATA 40,56
01D7C:  DATA 41,4C
01D7E:  DATA 20,00
01D80:  DATA 40,56
01D82:  DATA 41,4C
01D84:  DATA 20,00
01D86:  DATA 40,56
01D88:  DATA 41,4C
01D8A:  DATA 20,00
01D8C:  DATA 40,56
01D8E:  DATA 41,4C
01D90:  DATA 20,00
01D92:  DATA 40,53
01D94:  DATA 4F,4C
01D96:  DATA 5B,2F
01D98:  DATA 31,5D
01D9A:  DATA 5B,73
01D9C:  DATA 5D,5B
01D9E:  DATA 25,4C
01DA0:  DATA 75,5D
01DA2:  DATA 0D,0A
01DA4:  DATA 00,00
01DA6:  DATA 2F,31
01DA8:  DATA 73,25
01DAA:  DATA 4C,75
01DAC:  DATA 0D,00
01DAE:  DATA 40,53
01DB0:  DATA 4F,4C
01DB2:  DATA 5B,2F
01DB4:  DATA 31,5D
01DB6:  DATA 5B,63
01DB8:  DATA 5D,5B
01DBA:  DATA 25,75
01DBC:  DATA 5D,0D
01DBE:  DATA 0A,00
01DC0:  DATA 2F,31
01DC2:  DATA 63,25
01DC4:  DATA 75,0D
01DC6:  DATA 00,00
01DC8:  DATA 2F,31
01DCA:  DATA 73,32
01DCC:  DATA 35,36
01DCE:  DATA 0D,00
01DD0:  DATA 28,49
01DD2:  DATA 30,73
01DD4:  DATA 29,2C
01DD6:  DATA 25,4C
01DD8:  DATA 75,2C
01DDA:  DATA 28,49
01DDC:  DATA 31,73
01DDE:  DATA 29,2C
01DE0:  DATA 25,4C
01DE2:  DATA 75,2C
01DE4:  DATA 28,41
01DE6:  DATA 62,73
01DE8:  DATA 2D,73
01DEA:  DATA 29,2C
01DEC:  DATA 25,31
01DEE:  DATA 2E,34
01DF0:  DATA 67,2C
01DF2:  DATA 28,49
01DF4:  DATA 30,74
01DF6:  DATA 29,2C
01DF8:  DATA 25,4C
01DFA:  DATA 75,2C
01DFC:  DATA 28,49
01DFE:  DATA 31,74
01E00:  DATA 29,2C
01E02:  DATA 25,4C
01E04:  DATA 75,2C
01E06:  DATA 28,41
01E08:  DATA 62,73
01E0A:  DATA 2D,74
01E0C:  DATA 29,2C
01E0E:  DATA 25,31
01E10:  DATA 2E,34
01E12:  DATA 67,2C
01E14:  DATA 28,49
01E16:  DATA 30,72
01E18:  DATA 29,2C
01E1A:  DATA 25,4C
01E1C:  DATA 75,2C
01E1E:  DATA 28,49
01E20:  DATA 31,72
01E22:  DATA 29,2C
01E24:  DATA 25,4C
01E26:  DATA 75,2C
01E28:  DATA 28,41
01E2A:  DATA 62,73
01E2C:  DATA 2D,72
01E2E:  DATA 29,2C
01E30:  DATA 25,31
01E32:  DATA 2E,34
01E34:  DATA 67,00
01E36:  DATA 40,41
01E38:  DATA 62,73
01E3A:  DATA 2C,4E
01E3C:  DATA 4F,33
01E3E:  DATA 2C,25
01E40:  DATA 73,0D
01E42:  DATA 0A,00
01E44:  DATA 28,49
01E46:  DATA 30,73
01E48:  DATA 29,2C
01E4A:  DATA 25,4C
01E4C:  DATA 75,2C
01E4E:  DATA 28,49
01E50:  DATA 31,73
01E52:  DATA 29,2C
01E54:  DATA 25,4C
01E56:  DATA 75,2C
01E58:  DATA 28,41
01E5A:  DATA 62,73
01E5C:  DATA 2D,73
01E5E:  DATA 29,2C
01E60:  DATA 25,31
01E62:  DATA 2E,34
01E64:  DATA 67,2C
01E66:  DATA 28,49
01E68:  DATA 30,74
01E6A:  DATA 29,2C
01E6C:  DATA 25,4C
01E6E:  DATA 75,2C
01E70:  DATA 28,49
01E72:  DATA 31,74
01E74:  DATA 29,2C
01E76:  DATA 25,4C
01E78:  DATA 75,2C
01E7A:  DATA 28,41
01E7C:  DATA 62,73
01E7E:  DATA 2D,74
01E80:  DATA 29,2C
01E82:  DATA 25,31
01E84:  DATA 2E,34
01E86:  DATA 67,2C
01E88:  DATA 28,49
01E8A:  DATA 30,72
01E8C:  DATA 29,2C
01E8E:  DATA 25,4C
01E90:  DATA 75,2C
01E92:  DATA 28,49
01E94:  DATA 31,72
01E96:  DATA 29,2C
01E98:  DATA 25,4C
01E9A:  DATA 75,2C
01E9C:  DATA 28,41
01E9E:  DATA 62,73
01EA0:  DATA 2D,72
01EA2:  DATA 29,2C
01EA4:  DATA 25,31
01EA6:  DATA 2E,34
01EA8:  DATA 67,00
01EAA:  DATA 40,41
01EAC:  DATA 62,73
01EAE:  DATA 2C,4E
01EB0:  DATA 4F,32
01EB2:  DATA 2C,25
01EB4:  DATA 73,0D
01EB6:  DATA 0A,00
01EB8:  DATA 28,49
01EBA:  DATA 30,73
01EBC:  DATA 29,2C
01EBE:  DATA 25,4C
01EC0:  DATA 75,2C
01EC2:  DATA 28,49
01EC4:  DATA 31,73
01EC6:  DATA 29,2C
01EC8:  DATA 25,4C
01ECA:  DATA 75,2C
01ECC:  DATA 28,41
01ECE:  DATA 62,73
01ED0:  DATA 2D,73
01ED2:  DATA 29,2C
01ED4:  DATA 25,31
01ED6:  DATA 2E,34
01ED8:  DATA 67,2C
01EDA:  DATA 28,49
01EDC:  DATA 30,74
01EDE:  DATA 29,2C
01EE0:  DATA 25,4C
01EE2:  DATA 75,2C
01EE4:  DATA 28,49
01EE6:  DATA 31,74
01EE8:  DATA 29,2C
01EEA:  DATA 25,4C
01EEC:  DATA 75,2C
01EEE:  DATA 28,41
01EF0:  DATA 62,73
01EF2:  DATA 2D,74
01EF4:  DATA 29,2C
01EF6:  DATA 25,31
01EF8:  DATA 2E,34
01EFA:  DATA 67,2C
01EFC:  DATA 28,49
01EFE:  DATA 30,72
01F00:  DATA 29,2C
01F02:  DATA 25,4C
01F04:  DATA 75,2C
01F06:  DATA 28,49
01F08:  DATA 31,72
01F0A:  DATA 29,2C
01F0C:  DATA 25,4C
01F0E:  DATA 75,2C
01F10:  DATA 28,41
01F12:  DATA 62,73
01F14:  DATA 2D,72
01F16:  DATA 29,2C
01F18:  DATA 25,31
01F1A:  DATA 2E,34
01F1C:  DATA 67,00
01F1E:  DATA 40,41
01F20:  DATA 62,73
01F22:  DATA 2C,50
01F24:  DATA 4F,34
01F26:  DATA 2C,25
01F28:  DATA 73,0D
01F2A:  DATA 0A,00
01F2C:  DATA 28,49
01F2E:  DATA 30,73
01F30:  DATA 29,2C
01F32:  DATA 25,4C
01F34:  DATA 75,2C
01F36:  DATA 28,49
01F38:  DATA 31,73
01F3A:  DATA 29,2C
01F3C:  DATA 25,4C
01F3E:  DATA 75,2C
01F40:  DATA 28,41
01F42:  DATA 62,73
01F44:  DATA 2D,73
01F46:  DATA 29,2C
01F48:  DATA 25,31
01F4A:  DATA 2E,34
01F4C:  DATA 67,2C
01F4E:  DATA 28,49
01F50:  DATA 30,74
01F52:  DATA 29,2C
01F54:  DATA 25,4C
01F56:  DATA 75,2C
01F58:  DATA 28,49
01F5A:  DATA 31,74
01F5C:  DATA 29,2C
01F5E:  DATA 25,4C
01F60:  DATA 75,2C
01F62:  DATA 28,41
01F64:  DATA 62,73
01F66:  DATA 2D,74
01F68:  DATA 29,2C
01F6A:  DATA 25,31
01F6C:  DATA 2E,34
01F6E:  DATA 67,2C
01F70:  DATA 28,49
01F72:  DATA 30,72
01F74:  DATA 29,2C
01F76:  DATA 25,4C
01F78:  DATA 75,2C
01F7A:  DATA 28,49
01F7C:  DATA 31,72
01F7E:  DATA 29,2C
01F80:  DATA 25,4C
01F82:  DATA 75,2C
01F84:  DATA 28,41
01F86:  DATA 62,73
01F88:  DATA 2D,72
01F8A:  DATA 29,2C
01F8C:  DATA 25,31
01F8E:  DATA 2E,34
01F90:  DATA 67,00
01F92:  DATA 40,41
01F94:  DATA 62,73
01F96:  DATA 2C,4E
01F98:  DATA 48,34
01F9A:  DATA 2C,25
01F9C:  DATA 73,0D
01F9E:  DATA 0A,00
01FA0:  DATA 28,49
01FA2:  DATA 30,73
01FA4:  DATA 29,2C
01FA6:  DATA 25,4C
01FA8:  DATA 75,2C
01FAA:  DATA 28,49
01FAC:  DATA 31,73
01FAE:  DATA 29,2C
01FB0:  DATA 25,4C
01FB2:  DATA 75,2C
01FB4:  DATA 28,41
01FB6:  DATA 62,73
01FB8:  DATA 2D,73
01FBA:  DATA 29,2C
01FBC:  DATA 25,31
01FBE:  DATA 2E,34
01FC0:  DATA 67,2C
01FC2:  DATA 28,49
01FC4:  DATA 30,74
01FC6:  DATA 29,2C
01FC8:  DATA 25,4C
01FCA:  DATA 75,2C
01FCC:  DATA 28,49
01FCE:  DATA 31,74
01FD0:  DATA 29,2C
01FD2:  DATA 25,4C
01FD4:  DATA 75,2C
01FD6:  DATA 28,41
01FD8:  DATA 62,73
01FDA:  DATA 2D,74
01FDC:  DATA 29,2C
01FDE:  DATA 25,31
01FE0:  DATA 2E,34
01FE2:  DATA 67,2C
01FE4:  DATA 28,49
01FE6:  DATA 30,72
01FE8:  DATA 29,2C
01FEA:  DATA 25,4C
01FEC:  DATA 75,2C
01FEE:  DATA 28,49
01FF0:  DATA 31,72
01FF2:  DATA 29,2C
01FF4:  DATA 25,4C
01FF6:  DATA 75,2C
01FF8:  DATA 28,41
01FFA:  DATA 62,73
01FFC:  DATA 2D,72
01FFE:  DATA 29,2C
02000:  DATA 25,31
02002:  DATA 2E,34
02004:  DATA 67,00
02006:  DATA 40,41
02008:  DATA 42,53
0200A:  DATA 2C,53
0200C:  DATA 69,4F
0200E:  DATA 2C,25
02010:  DATA 73,0D
02012:  DATA 0A,00
02014:  DATA 4E,4F
02016:  DATA 33,00
02018:  DATA 4E,4F
0201A:  DATA 32,00
0201C:  DATA 50,4F
0201E:  DATA 34,00
02020:  DATA 4E,48
02022:  DATA 34,00
02024:  DATA 53,69
02026:  DATA 4F,00
02028:  DATA 00,00
0202A:  DATA 28,6D
0202C:  DATA 29,2C
0202E:  DATA 25,33
02030:  DATA 2E,33
02032:  DATA 67,2C
02034:  DATA 28,63
02036:  DATA 29,2C
02038:  DATA 25,33
0203A:  DATA 2E,33
0203C:  DATA 67,00
0203E:  DATA 28,43
02040:  DATA 73,29
02042:  DATA 2C,25
02044:  DATA 33,2E
02046:  DATA 33,67
02048:  DATA 0D,0A
0204A:  DATA 00,00
0204C:  DATA 40,43
0204E:  DATA 4F,4E
02050:  DATA 2C,4E
02052:  DATA 4F,33
02054:  DATA 2C,25
02056:  DATA 73,0D
02058:  DATA 0A,00
0205A:  DATA 28,6D
0205C:  DATA 29,2C
0205E:  DATA 25,33
02060:  DATA 2E,33
02062:  DATA 67,2C
02064:  DATA 28,63
02066:  DATA 29,2C
02068:  DATA 25,33
0206A:  DATA 2E,33
0206C:  DATA 67,00
0206E:  DATA 28,43
02070:  DATA 73,29
02072:  DATA 2C,25
02074:  DATA 33,2E
02076:  DATA 33,67
02078:  DATA 0D,0A
0207A:  DATA 00,00
0207C:  DATA 40,43
0207E:  DATA 4F,4E
02080:  DATA 2C,50
02082:  DATA 4F,34
02084:  DATA 2C,25
02086:  DATA 73,0D
02088:  DATA 0A,00
0208A:  DATA 28,6D
0208C:  DATA 29,2C
0208E:  DATA 25,33
02090:  DATA 2E,33
02092:  DATA 67,2C
02094:  DATA 28,63
02096:  DATA 29,2C
02098:  DATA 25,33
0209A:  DATA 2E,33
0209C:  DATA 67,00
0209E:  DATA 28,43
020A0:  DATA 73,29
020A2:  DATA 2C,25
020A4:  DATA 33,2E
020A6:  DATA 33,67
020A8:  DATA 0D,0A
020AA:  DATA 00,00
020AC:  DATA 40,43
020AE:  DATA 4F,4E
020B0:  DATA 2C,4E
020B2:  DATA 48,34
020B4:  DATA 2C,25
020B6:  DATA 73,0D
020B8:  DATA 0A,00
020BA:  DATA 28,6D
020BC:  DATA 29,2C
020BE:  DATA 25,33
020C0:  DATA 2E,33
020C2:  DATA 67,2C
020C4:  DATA 28,63
020C6:  DATA 29,2C
020C8:  DATA 25,33
020CA:  DATA 2E,33
020CC:  DATA 67,00
020CE:  DATA 28,43
020D0:  DATA 73,29
020D2:  DATA 2C,25
020D4:  DATA 33,2E
020D6:  DATA 33,67
020D8:  DATA 0D,0A
020DA:  DATA 00,00
020DC:  DATA 40,43
020DE:  DATA 4F,4E
020E0:  DATA 2C,53
020E2:  DATA 69,4F
020E4:  DATA 2C,25
020E6:  DATA 73,0D
020E8:  DATA 0A,00
020EA:  DATA 4E,4F
020EC:  DATA 33,00
020EE:  DATA 50,4F
020F0:  DATA 34,00
020F2:  DATA 4E,48
020F4:  DATA 34,00
020F6:  DATA 53,69
020F8:  DATA 4F,00
020FA:  DATA 00,00
020FC:  DATA 4D,45
020FE:  DATA 4D,4F
02100:  DATA 52,59
02102:  DATA 20,4F
02104:  DATA 56,45
02106:  DATA 52,46
02108:  DATA 4C,4F
0210A:  DATA 57,20
0210C:  DATA 45,52
0210E:  DATA 52,4F
02110:  DATA 52,20
02112:  DATA 40,20
02114:  DATA 4C,69
02116:  DATA 6E,65
02118:  DATA 20,3A
0211A:  DATA 25,4C
0211C:  DATA 75,0A
0211E:  DATA 0D,00
02120:  DATA 0D,0A
02122:  DATA 3A,00
02124:  DATA 0D,0A
02126:  DATA 57,41
02128:  DATA 52,4E
0212A:  DATA 49,4E
0212C:  DATA 47,3A
0212E:  DATA 20,49
02130:  DATA 4E,56
02132:  DATA 41,4C
02134:  DATA 49,44
02136:  DATA 20,43
02138:  DATA 4F,4D
0213A:  DATA 4D,41
0213C:  DATA 4E,44
0213E:  DATA 20,49
02140:  DATA 4E,20
02142:  DATA 4D,41
02144:  DATA 43,52
02146:  DATA 4F,21
02148:  DATA 0D,0A
0214A:  DATA 00,00
0214C:  DATA 42,61
0214E:  DATA 64,20
02150:  DATA 63,6F
02152:  DATA 6D,6D
02154:  DATA 61,6E
02156:  DATA 64,20
02158:  DATA 61,74
0215A:  DATA 20,6C
0215C:  DATA 69,6E
0215E:  DATA 65,3A
02160:  DATA 20,25
02162:  DATA 4C,64
02164:  DATA 20,0D
02166:  DATA 0A,00
02168:  DATA 50,6C
0216A:  DATA 65,61
0216C:  DATA 73,65
0216E:  DATA 20,72
02170:  DATA 65,2D
02172:  DATA 75,70
02174:  DATA 6C,6F
02176:  DATA 61,64
02178:  DATA 20,6D
0217A:  DATA 61,63
0217C:  DATA 72,6F
0217E:  DATA 00,00
02180:  DATA 49,74
02182:  DATA 65,72
02184:  DATA 61,74
02186:  DATA 69,6F
02188:  DATA 6E,73
0218A:  DATA 20,6C
0218C:  DATA 65,66
0218E:  DATA 74,3A
02190:  DATA 20,25
02192:  DATA 4C,75
02194:  DATA 0D,0A
02196:  DATA 00,00
02198:  DATA 2C,6D
0219A:  DATA 61,63
0219C:  DATA 72,6F
0219E:  DATA 5B,25
021A0:  DATA 75,5D
021A2:  DATA 2C,73
021A4:  DATA 74,61
021A6:  DATA 72,74
021A8:  DATA 0D,0A
021AA:  DATA 00,00
021AC:  DATA 40,4D
021AE:  DATA 43,4C
021B0:  DATA 5B,25
021B2:  DATA 63,5D
021B4:  DATA 5B,25
021B6:  DATA 4C,75
021B8:  DATA 5D,0D
021BA:  DATA 0A,00
021BC:  DATA 40,4C
021BE:  DATA 4E,45
021C0:  DATA 0D,0A
021C2:  DATA 00,00
021C4:  DATA 40,52
021C6:  DATA 55,4E
021C8:  DATA 0D,0A
021CA:  DATA 00,00
021CC:  DATA 40,42
021CE:  DATA 41,44
021D0:  DATA 0D,0A
021D2:  DATA 00,00
021D4:  DATA 40,54
021D6:  DATA 2F,4F
021D8:  DATA 0D,0A
021DA:  DATA 00,00
021DC:  DATA 40,45
021DE:  DATA 52,52
021E0:  DATA 0D,0A
021E2:  DATA 00,00
021E4:  DATA 40,45
021E6:  DATA 4E,44
021E8:  DATA 0D,0A
021EA:  DATA 00,00
021EC:  DATA 40,48
021EE:  DATA 4C,54
021F0:  DATA 0D,0A
021F2:  DATA 00,00
021F4:  DATA 2C,6D
021F6:  DATA 61,63
021F8:  DATA 72,6F
021FA:  DATA 5B,25
021FC:  DATA 75,5D
021FE:  DATA 2C,73
02200:  DATA 74,61
02202:  DATA 74,75
02204:  DATA 73,5B
02206:  DATA 25,63
02208:  DATA 5D,2C
0220A:  DATA 6C,69
0220C:  DATA 6E,65
0220E:  DATA 5B,25
02210:  DATA 4C,75
02212:  DATA 5D,0D
02214:  DATA 0A,00
02216:  DATA 40,52
02218:  DATA 75,6E
0221A:  DATA 6E,69
0221C:  DATA 6E,67
0221E:  DATA 20,25
02220:  DATA 63,25
02222:  DATA 4C,75
02224:  DATA 20,0D
02226:  DATA 0A,00
02228:  DATA 40,4D
0222A:  DATA 61,63
0222C:  DATA 72,6F
0222E:  DATA 20,25
02230:  DATA 30,34
02232:  DATA 4C,75
02234:  DATA 20,6F
02236:  DATA 66,20
02238:  DATA 25,30
0223A:  DATA 34,4C
0223C:  DATA 75,0D
0223E:  DATA 0A,00
02240:  DATA 40,4C
02242:  DATA 4E,45
02244:  DATA 0D,0A
02246:  DATA 00,00
02248:  DATA 40,52
0224A:  DATA 55,4E
0224C:  DATA 0D,0A
0224E:  DATA 00,00
02250:  DATA 40,42
02252:  DATA 41,44
02254:  DATA 0D,0A
02256:  DATA 00,00
02258:  DATA 40,54
0225A:  DATA 2F,4F
0225C:  DATA 0D,0A
0225E:  DATA 00,00
02260:  DATA 40,45
02262:  DATA 52,52
02264:  DATA 0D,0A
02266:  DATA 00,00
02268:  DATA 40,45
0226A:  DATA 4E,44
0226C:  DATA 0D,0A
0226E:  DATA 00,00
02270:  DATA 2C,61
02272:  DATA 75,74
02274:  DATA 6F,2D
02276:  DATA 73,61
02278:  DATA 6D,70
0227A:  DATA 6C,65
0227C:  DATA 2C,73
0227E:  DATA 61,6D
02280:  DATA 70,6C
02282:  DATA 65,5B
02284:  DATA 25,4C
02286:  DATA 75,5D
02288:  DATA 2C,73
0228A:  DATA 74,61
0228C:  DATA 72,74
0228E:  DATA 0D,0A
02290:  DATA 00,00
02292:  DATA 2C,61
02294:  DATA 75,74
02296:  DATA 6F,2D
02298:  DATA 73,61
0229A:  DATA 6D,70
0229C:  DATA 6C,65
0229E:  DATA 2C,73
022A0:  DATA 61,6D
022A2:  DATA 70,6C
022A4:  DATA 65,5B
022A6:  DATA 25,4C
022A8:  DATA 75,5D
022AA:  DATA 2C,63
022AC:  DATA 6F,6D
022AE:  DATA 70,6C
022B0:  DATA 65,74
022B2:  DATA 65,0D
022B4:  DATA 0A,00
022B6:  DATA 2C,61
022B8:  DATA 75,74
022BA:  DATA 6F,2D
022BC:  DATA 73,61
022BE:  DATA 6D,70
022C0:  DATA 6C,65
022C2:  DATA 2C,73
022C4:  DATA 61,6D
022C6:  DATA 70,6C
022C8:  DATA 65,5B
022CA:  DATA 25,4C
022CC:  DATA 75,5D
022CE:  DATA 2C,65
022D0:  DATA 72,72
022D2:  DATA 6F,72
022D4:  DATA 0D,0A
022D6:  DATA 00,00
022D8:  DATA 2C,61
022DA:  DATA 75,74
022DC:  DATA 6F,2D
022DE:  DATA 73,61
022E0:  DATA 6D,70
022E2:  DATA 6C,65
022E4:  DATA 2C,73
022E6:  DATA 61,6D
022E8:  DATA 70,6C
022EA:  DATA 65,5B
022EC:  DATA 25,4C
022EE:  DATA 75,5D
022F0:  DATA 2C,6D
022F2:  DATA 61,78
022F4:  DATA 20,73
022F6:  DATA 61,6D
022F8:  DATA 70,6C
022FA:  DATA 65,73
022FC:  DATA 0D,0A
022FE:  DATA 00,00
02300:  DATA 2C,61
02302:  DATA 75,74
02304:  DATA 6F,2D
02306:  DATA 73,61
02308:  DATA 6D,70
0230A:  DATA 6C,65
0230C:  DATA 2C,73
0230E:  DATA 61,6D
02310:  DATA 70,6C
02312:  DATA 65,5B
02314:  DATA 25,4C
02316:  DATA 75,5D
02318:  DATA 2C,73
0231A:  DATA 74,61
0231C:  DATA 72,74
0231E:  DATA 0D,0A
02320:  DATA 00,00
02322:  DATA 2C,61
02324:  DATA 75,74
02326:  DATA 6F,2D
02328:  DATA 73,61
0232A:  DATA 6D,70
0232C:  DATA 6C,65
0232E:  DATA 2C,73
02330:  DATA 61,6D
02332:  DATA 70,6C
02334:  DATA 65,5B
02336:  DATA 25,4C
02338:  DATA 75,5D
0233A:  DATA 2C,63
0233C:  DATA 6F,6D
0233E:  DATA 70,6C
02340:  DATA 65,74
02342:  DATA 65,0D
02344:  DATA 0A,00
02346:  DATA 2C,61
02348:  DATA 75,74
0234A:  DATA 6F,2D
0234C:  DATA 73,61
0234E:  DATA 6D,70
02350:  DATA 6C,65
02352:  DATA 2C,73
02354:  DATA 61,6D
02356:  DATA 70,6C
02358:  DATA 65,5B
0235A:  DATA 25,4C
0235C:  DATA 75,5D
0235E:  DATA 2C,73
02360:  DATA 74,61
02362:  DATA 72,74
02364:  DATA 0D,0A
02366:  DATA 00,00
02368:  DATA 2C,61
0236A:  DATA 75,74
0236C:  DATA 6F,2D
0236E:  DATA 73,61
02370:  DATA 6D,70
02372:  DATA 6C,65
02374:  DATA 2C,73
02376:  DATA 61,6D
02378:  DATA 70,6C
0237A:  DATA 65,5B
0237C:  DATA 25,4C
0237E:  DATA 75,5D
02380:  DATA 2C,63
02382:  DATA 6F,6D
02384:  DATA 70,6C
02386:  DATA 65,74
02388:  DATA 65,0D
0238A:  DATA 0A,00
0238C:  DATA 2C,61
0238E:  DATA 75,74
02390:  DATA 6F,2D
02392:  DATA 73,61
02394:  DATA 6D,70
02396:  DATA 6C,65
02398:  DATA 2C,73
0239A:  DATA 61,6D
0239C:  DATA 70,6C
0239E:  DATA 65,5B
023A0:  DATA 25,4C
023A2:  DATA 75,5D
023A4:  DATA 2C,6D
023A6:  DATA 61,78
023A8:  DATA 20,73
023AA:  DATA 61,6D
023AC:  DATA 70,6C
023AE:  DATA 65,73
023B0:  DATA 0D,0A
023B2:  DATA 00,00
023B4:  DATA 2C,61
023B6:  DATA 75,74
023B8:  DATA 6F,2D
023BA:  DATA 73,61
023BC:  DATA 6D,70
023BE:  DATA 6C,65
023C0:  DATA 2C,69
023C2:  DATA 6E,69
023C4:  DATA 74,69
023C6:  DATA 61,6C
023C8:  DATA 69,7A
023CA:  DATA 65,0D
023CC:  DATA 0A,00
023CE:  DATA 2C,68
023D0:  DATA 65,61
023D2:  DATA 64,65
023D4:  DATA 72,2C
023D6:  DATA 69,64
023D8:  DATA 23,5B
023DA:  DATA 25,4C
023DC:  DATA 75,5D
023DE:  DATA 2C,69
023E0:  DATA 6E,74
023E2:  DATA 5B,25
023E4:  DATA 4C,75
023E6:  DATA 5D,2C
023E8:  DATA 6D,61
023EA:  DATA 78,5B
023EC:  DATA 25,4C
023EE:  DATA 75,5D
023F0:  DATA 0D,0A
023F2:  DATA 00,00
023F4:  DATA 2C,61
023F6:  DATA 75,74
023F8:  DATA 6F,2D
023FA:  DATA 73,61
023FC:  DATA 6D,70
023FE:  DATA 6C,65
02400:  DATA 2C,73
02402:  DATA 61,6D
02404:  DATA 70,6C
02406:  DATA 65,5B
02408:  DATA 25,4C
0240A:  DATA 75,5D
0240C:  DATA 2C,61
0240E:  DATA 6C,61
02410:  DATA 72,6D
02412:  DATA 5B,25
02414:  DATA 75,5D
02416:  DATA 0D,0A
02418:  DATA 00,00
0241A:  DATA 2C,61
0241C:  DATA 75,74
0241E:  DATA 6F,2D
02420:  DATA 73,61
02422:  DATA 6D,70
02424:  DATA 6C,65
02426:  DATA 2C,73
02428:  DATA 6C,65
0242A:  DATA 65,70
0242C:  DATA 0D,0A
0242E:  DATA 00,00
02430:  DATA 74,31
02432:  DATA 3A,25
02434:  DATA 4C,75
02436:  DATA 20,74
02438:  DATA 32,3A
0243A:  DATA 25,4C
0243C:  DATA 75,0D
0243E:  DATA 0A,00
02440:  DATA 40,44
02442:  DATA 45,54
02444:  DATA 2C,25
02446:  DATA 4C,75
02448:  DATA 0D,0A
0244A:  DATA 00,00
0244C:  DATA 4E,4F
0244E:  DATA 33,2C
02450:  DATA 25,31
02452:  DATA 2E,35
02454:  DATA 67,2C
02456:  DATA 25,31
02458:  DATA 2E,35
0245A:  DATA 67,0D
0245C:  DATA 0A,00
0245E:  DATA 50,4F
02460:  DATA 34,2C
02462:  DATA 25,31
02464:  DATA 2E,35
02466:  DATA 67,2C
02468:  DATA 25,31
0246A:  DATA 2E,35
0246C:  DATA 67,0D
0246E:  DATA 0A,00
02470:  DATA 4E,48
02472:  DATA 34,2C
02474:  DATA 25,31
02476:  DATA 2E,35
02478:  DATA 67,2C
0247A:  DATA 25,31
0247C:  DATA 2E,35
0247E:  DATA 67,0D
02480:  DATA 0A,00
02482:  DATA 53,69
02484:  DATA 4F,34
02486:  DATA 2C,25
02488:  DATA 31,2E
0248A:  DATA 35,67
0248C:  DATA 2C,25
0248E:  DATA 31,2E
02490:  DATA 35,67
02492:  DATA 0D,0A
02494:  DATA 00,00
02496:  DATA 4E,4F
02498:  DATA 33,28
0249A:  DATA 6D,29
0249C:  DATA 3A,00
0249E:  DATA 4E,4F
024A0:  DATA 33,28
024A2:  DATA 63,29
024A4:  DATA 3A,00
024A6:  DATA 50,4F
024A8:  DATA 34,28
024AA:  DATA 6D,29
024AC:  DATA 3A,00
024AE:  DATA 50,4F
024B0:  DATA 34,28
024B2:  DATA 63,29
024B4:  DATA 3A,00
024B6:  DATA 4E,48
024B8:  DATA 34,28
024BA:  DATA 6D,29
024BC:  DATA 3A,00
024BE:  DATA 4E,48
024C0:  DATA 34,28
024C2:  DATA 63,29
024C4:  DATA 3A,00
024C6:  DATA 53,69
024C8:  DATA 4F,34
024CA:  DATA 28,6D
024CC:  DATA 29,3A
024CE:  DATA 00,00
024D0:  DATA 53,69
024D2:  DATA 4F,34
024D4:  DATA 28,63
024D6:  DATA 29,3A
024D8:  DATA 00,00
024DA:  DATA 41,72
024DC:  DATA 65,20
024DE:  DATA 79,6F
024E0:  DATA 75,20
024E2:  DATA 73,75
024E4:  DATA 72,65
024E6:  DATA 20,79
024E8:  DATA 6F,75
024EA:  DATA 20,77
024EC:  DATA 61,6E
024EE:  DATA 74,20
024F0:  DATA 74,6F
024F2:  DATA 20,65
024F4:  DATA 72,61
024F6:  DATA 73,65
024F8:  DATA 20,74
024FA:  DATA 68,65
024FC:  DATA 20,72
024FE:  DATA 61,77
02500:  DATA 20,64
02502:  DATA 61,74
02504:  DATA 61,20
02506:  DATA 66,69
02508:  DATA 6C,65
0250A:  DATA 3F,20
0250C:  DATA 59,20
0250E:  DATA 6F,72
02510:  DATA 20,4E
02512:  DATA 21,0D
02514:  DATA 0A,00
02516:  DATA 46,69
02518:  DATA 6C,65
0251A:  DATA 20,64
0251C:  DATA 65,6C
0251E:  DATA 65,74
02520:  DATA 65,64
02522:  DATA 21,0A
02524:  DATA 0D,00
02526:  DATA 4F,70
02528:  DATA 65,72
0252A:  DATA 61,74
0252C:  DATA 69,6F
0252E:  DATA 6E,20
02530:  DATA 63,61
02532:  DATA 6E,63
02534:  DATA 65,6C
02536:  DATA 65,64
02538:  DATA 21,0D
0253A:  DATA 0A,00
0253C:  DATA 41,72
0253E:  DATA 65,20
02540:  DATA 79,6F
02542:  DATA 75,20
02544:  DATA 73,75
02546:  DATA 72,65
02548:  DATA 20,79
0254A:  DATA 6F,75
0254C:  DATA 20,77
0254E:  DATA 61,6E
02550:  DATA 74,20
02552:  DATA 74,6F
02554:  DATA 20,65
02556:  DATA 72,61
02558:  DATA 73,65
0255A:  DATA 20,74
0255C:  DATA 68,65
0255E:  DATA 20,63
02560:  DATA 61,6C
02562:  DATA 63,75
02564:  DATA 6C,61
02566:  DATA 74,65
02568:  DATA 64,20
0256A:  DATA 64,61
0256C:  DATA 74,61
0256E:  DATA 20,66
02570:  DATA 69,6C
02572:  DATA 65,3F
02574:  DATA 20,59
02576:  DATA 20,6F
02578:  DATA 72,20
0257A:  DATA 4E,21
0257C:  DATA 0D,0A
0257E:  DATA 00,00
02580:  DATA 46,69
02582:  DATA 6C,65
02584:  DATA 20,64
02586:  DATA 65,6C
02588:  DATA 65,74
0258A:  DATA 65,64
0258C:  DATA 21,0A
0258E:  DATA 0D,00
02590:  DATA 4F,70
02592:  DATA 65,72
02594:  DATA 61,74
02596:  DATA 69,6F
02598:  DATA 6E,20
0259A:  DATA 63,61
0259C:  DATA 6E,63
0259E:  DATA 65,6C
025A0:  DATA 65,64
025A2:  DATA 21,0D
025A4:  DATA 0A,00
025A6:  DATA 40,49
025A8:  DATA 44,23
025AA:  DATA 25,4C
025AC:  DATA 75,20
025AE:  DATA 49,25
025B0:  DATA 4C,75
025B2:  DATA 20,4E
025B4:  DATA 25,4C
025B6:  DATA 75,2F
025B8:  DATA 25,4C
025BA:  DATA 75,20
025BC:  DATA 58,25
025BE:  DATA 4C,75
025C0:  DATA 20,55
025C2:  DATA 25,75
025C4:  DATA 20,25
025C6:  DATA 34,2E
025C8:  DATA 32,77
025CA:  DATA 56,0D
025CC:  DATA 0A,00
025CE:  DATA 40,4D
025D0:  DATA 4F,54
025D2:  DATA 3A,56
025D4:  DATA 41,4C
025D6:  DATA 3D,25
025D8:  DATA 4C,75
025DA:  DATA 20,53
025DC:  DATA 59,52
025DE:  DATA 3D,25
025E0:  DATA 4C,64
025E2:  DATA 0D,0A
025E4:  DATA 00,00
025E6:  DATA 40,50
025E8:  DATA 57,52
025EA:  DATA 3A,25
025EC:  DATA 30,32
025EE:  DATA 75,2F
025F0:  DATA 25,30
025F2:  DATA 32,75
025F4:  DATA 2F,25
025F6:  DATA 30,32
025F8:  DATA 75,20
025FA:  DATA 25,30
025FC:  DATA 32,75
025FE:  DATA 3A,25
02600:  DATA 30,32
02602:  DATA 75,3A
02604:  DATA 25,30
02606:  DATA 32,75
02608:  DATA 0D,0A
0260A:  DATA 00,00
0260C:  DATA 40,50
0260E:  DATA 57,52
02610:  DATA 3A,25
02612:  DATA 30,32
02614:  DATA 75,2F
02616:  DATA 25,30
02618:  DATA 32,75
0261A:  DATA 2F,25
0261C:  DATA 30,32
0261E:  DATA 75,20
02620:  DATA 25,30
02622:  DATA 32,75
02624:  DATA 3A,25
02626:  DATA 30,32
02628:  DATA 75,3A
0262A:  DATA 25,30
0262C:  DATA 32,75
0262E:  DATA 0D,0A
02630:  DATA 00,00
02632:  DATA 41,25
02634:  DATA 4C,75
02636:  DATA 20,49
02638:  DATA 25,4C
0263A:  DATA 75,20
0263C:  DATA 4C,25
0263E:  DATA 4C,75
02640:  DATA 20,51
02642:  DATA 25,4C
02644:  DATA 75,20
02646:  DATA 53,25
02648:  DATA 4C,75
0264A:  DATA 20,25
0264C:  DATA 34,2E
0264E:  DATA 32,77
02650:  DATA 56,0D
02652:  DATA 0A,00
02654:  DATA 40,4D
02656:  DATA 4F,54
02658:  DATA 3A,56
0265A:  DATA 41,4C
0265C:  DATA 3D,25
0265E:  DATA 4C,75
02660:  DATA 20,53
02662:  DATA 59,52
02664:  DATA 3D,25
02666:  DATA 4C,64
02668:  DATA 0D,0A
0266A:  DATA 00,00
0266C:  DATA 40,50
0266E:  DATA 57,52
02670:  DATA 3A,25
02672:  DATA 30,32
02674:  DATA 75,2F
02676:  DATA 25,30
02678:  DATA 32,75
0267A:  DATA 2F,25
0267C:  DATA 30,32
0267E:  DATA 75,20
02680:  DATA 25,30
02682:  DATA 32,75
02684:  DATA 3A,25
02686:  DATA 30,32
02688:  DATA 75,3A
0268A:  DATA 25,30
0268C:  DATA 32,75
0268E:  DATA 0D,0A
02690:  DATA 00,00
02692:  DATA 49,25
02694:  DATA 4C,75
02696:  DATA 20,4E
02698:  DATA 25,4C
0269A:  DATA 75,2F
0269C:  DATA 25,4C
0269E:  DATA 75,20
026A0:  DATA 50,25
026A2:  DATA 4C,75
026A4:  DATA 20,25
026A6:  DATA 34,2E
026A8:  DATA 32,77
026AA:  DATA 56,0D
026AC:  DATA 0A,00
026AE:  DATA 40,4D
026B0:  DATA 4F,54
026B2:  DATA 3A,53
026B4:  DATA 59,52
026B6:  DATA 3D,25
026B8:  DATA 4C,64
026BA:  DATA 0D,0A
026BC:  DATA 00,00
026BE:  DATA 40,50
026C0:  DATA 57,52
026C2:  DATA 3A,25
026C4:  DATA 30,32
026C6:  DATA 75,2F
026C8:  DATA 25,30
026CA:  DATA 32,75
026CC:  DATA 2F,25
026CE:  DATA 30,32
026D0:  DATA 75,20
026D2:  DATA 25,30
026D4:  DATA 32,75
026D6:  DATA 3A,25
026D8:  DATA 30,32
026DA:  DATA 75,3A
026DC:  DATA 25,30
026DE:  DATA 32,75
026E0:  DATA 0D,0A
026E2:  DATA 00,00
026E4:  DATA 40,53
026E6:  DATA 4D,50
026E8:  DATA 20,25
026EA:  DATA 30,34
026EC:  DATA 4C,75
026EE:  DATA 0D,0A
026F0:  DATA 00,00
026F2:  DATA 40,53
026F4:  DATA 4D,50
026F6:  DATA 20,25
026F8:  DATA 30,34
026FA:  DATA 4C,75
026FC:  DATA 0D,0A
026FE:  DATA 00,00
02700:  DATA 45,6E
02702:  DATA 74,65
02704:  DATA 72,20
02706:  DATA 64,61
02708:  DATA 74,65
0270A:  DATA 20,66
0270C:  DATA 6F,72
0270E:  DATA 6D,61
02710:  DATA 74,20
02712:  DATA 30,3D
02714:  DATA 4D,4D
02716:  DATA 2F,44
02718:  DATA 44,2F
0271A:  DATA 59,59
0271C:  DATA 20,20
0271E:  DATA 31,3D
02720:  DATA 44,44
02722:  DATA 2F,4D
02724:  DATA 4D,2F
02726:  DATA 59,59
02728:  DATA 0D,0A
0272A:  DATA 00,00
0272C:  DATA 40,4F
0272E:  DATA 4B,21
02730:  DATA 0D,0A
02732:  DATA 20,00
02734:  DATA 40,45
02736:  DATA 52,52
02738:  DATA 0D,0A
0273A:  DATA 00,00
0273C:  DATA 40,52
0273E:  DATA 55,4E
02740:  DATA 0D,0A
02742:  DATA 00,00
02744:  DATA 5B,6D
02746:  DATA 6F,74
02748:  DATA 6F,72
0274A:  DATA 3A,31
0274C:  DATA 5D,0D
0274E:  DATA 0A,00
02750:  DATA 5B,6D
02752:  DATA 6F,74
02754:  DATA 6F,72
02756:  DATA 3A,32
02758:  DATA 5D,0D
0275A:  DATA 0A,00
0275C:  DATA 2C,45
0275E:  DATA 43,4F
02760:  DATA 20,6D
02762:  DATA 6F,64
02764:  DATA 65,20
02766:  DATA 73,65
02768:  DATA 74,0D
0276A:  DATA 0A,00
0276C:  DATA 2C,57
0276E:  DATA 4D,53
02770:  DATA 2D,34
02772:  DATA 2D,53
02774:  DATA 44,20
02776:  DATA 6D,6F
02778:  DATA 64,65
0277A:  DATA 20,73
0277C:  DATA 65,74
0277E:  DATA 0D,0A
02780:  DATA 00,00
02782:  DATA 2C,41
02784:  DATA 57,53
02786:  DATA 20,6D
02788:  DATA 6F,64
0278A:  DATA 65,20
0278C:  DATA 73,65
0278E:  DATA 74,0D
02790:  DATA 0A,00
02792:  DATA 2C,57
02794:  DATA 4D,53
02796:  DATA 2D,34
02798:  DATA 2D,51
0279A:  DATA 45,20
0279C:  DATA 6D,6F
0279E:  DATA 64,65
027A0:  DATA 20,73
027A2:  DATA 65,74
027A4:  DATA 0D,0A
027A6:  DATA 00,00
027A8:  DATA 30,36
027AA:  DATA 2D,4A
027AC:  DATA 75,6C
027AE:  DATA 2D,31
027B0:  DATA 37,00
027B2:  DATA 31,35
027B4:  DATA 3A,31
027B6:  DATA 30,3A
027B8:  DATA 34,31
027BA:  DATA 00,00
027BC:  DATA 53,45
027BE:  DATA 4E,44
027C0:  DATA 20,48
027C2:  DATA 45,58
027C4:  DATA 20,46
027C6:  DATA 49,4C
027C8:  DATA 45,20
027CA:  DATA 28,31
027CC:  DATA 39,32
027CE:  DATA 30,30
027D0:  DATA 2C,4E
027D2:  DATA 38,31
027D4:  DATA 2C,58
027D6:  DATA 4F,4E
027D8:  DATA 2D,58
027DA:  DATA 4F,46
027DC:  DATA 46,29
027DE:  DATA 0D,0A
027E0:  DATA 00,00
027E2:  DATA 40,4F
027E4:  DATA 4B,21
027E6:  DATA 20,00
027E8:  DATA 40,41
027EA:  DATA 52,47
027EC:  DATA 20,00
027EE:  DATA 40,49
027F0:  DATA 4E,56
027F2:  DATA 00,00
027F4:  DATA 40,43
027F6:  DATA 4D,44
027F8:  DATA 00,00
027FA:  DATA 2C,63
027FC:  DATA 6F,6D
027FE:  DATA 6D,61
02800:  DATA 6E,64
02802:  DATA 20,70
02804:  DATA 72,6F
02806:  DATA 6D,70
02808:  DATA 74,0D
0280A:  DATA 0A,00
0280C:  DATA 20,20
0280E:  DATA 20,20
02810:  DATA 20,20
02812:  DATA 20,20
02814:  DATA 20,20
02816:  DATA 20,20
02818:  DATA 20,20
0281A:  DATA 20,20
0281C:  DATA 20,20
0281E:  DATA 20,20
02820:  DATA 20,20
02822:  DATA 20,20
02824:  DATA 20,20
02826:  DATA 20,20
02828:  DATA 20,20
0282A:  DATA 20,20
0282C:  DATA 20,20
0282E:  DATA 20,20
02830:  DATA 20,20
02832:  DATA 20,00
02834:  DATA 40,43
02836:  DATA 4D,44
02838:  DATA 00,00
0283A:  DATA 2C,63
0283C:  DATA 6F,6D
0283E:  DATA 6D,61
02840:  DATA 6E,64
02842:  DATA 20,70
02844:  DATA 72,6F
02846:  DATA 6D,70
02848:  DATA 74,0D
0284A:  DATA 0A,00
0284C:  DATA 40,53
0284E:  DATA 44,3D
02850:  DATA 25,4C
02852:  DATA 75,0D
02854:  DATA 0A,00
02856:  DATA 40,4D
02858:  DATA 43,31
0285A:  DATA 2C,25
0285C:  DATA 4C,75
0285E:  DATA 2C,25
02860:  DATA 4C,64
02862:  DATA 0D,0A
02864:  DATA 00,00
02866:  DATA 40,4D
02868:  DATA 43,32
0286A:  DATA 2C,25
0286C:  DATA 4C,75
0286E:  DATA 2C,25
02870:  DATA 4C,64
02872:  DATA 0D,0A
02874:  DATA 00,00
02876:  DATA 50,72
02878:  DATA 65,73
0287A:  DATA 73,20
0287C:  DATA 61,6E
0287E:  DATA 64,20
02880:  DATA 68,6F
02882:  DATA 6C,64
02884:  DATA 20,74
02886:  DATA 68,65
02888:  DATA 20,45
0288A:  DATA 73,63
0288C:  DATA 20,6B
0288E:  DATA 65,79
02890:  DATA 20,74
02892:  DATA 6F,20
02894:  DATA 72,65
02896:  DATA 74,75
02898:  DATA 72,6E
0289A:  DATA 20,74
0289C:  DATA 6F,20
0289E:  DATA 43,6F
028A0:  DATA 6D,6D
028A2:  DATA 61,6E
028A4:  DATA 64,20
028A6:  DATA 4D,6F
028A8:  DATA 64,65
028AA:  DATA 0D,0A
028AC:  DATA 00,00
028AE:  DATA 52,65
028B0:  DATA 74,75
028B2:  DATA 72,6E
028B4:  DATA 69,6E
028B6:  DATA 67,20
028B8:  DATA 74,6F
028BA:  DATA 20,4C
028BC:  DATA 6F,67
028BE:  DATA 67,69
028C0:  DATA 6E,67
028C2:  DATA 20,4D
028C4:  DATA 6F,64
028C6:  DATA 65,0D
028C8:  DATA 0A,00
*
02CB4:  CLRF   01
02CB6:  CLRF   02
02CB8:  CLRF   00
02CBA:  CLRF   03
02CBC:  MOVLB  8
02CBE:  MOVF   xBC,W
02CC0:  BNZ   2CC6
02CC2:  MOVF   xBB,W
02CC4:  BZ    2CF6
02CC6:  MOVLW  10
02CC8:  MOVWF  xBD
02CCA:  BCF    FD8.0
02CCC:  RLCF   xB9,F
02CCE:  RLCF   xBA,F
02CD0:  RLCF   00,F
02CD2:  RLCF   03,F
02CD4:  MOVF   xBC,W
02CD6:  SUBWF  03,W
02CD8:  BNZ   2CDE
02CDA:  MOVF   xBB,W
02CDC:  SUBWF  00,W
02CDE:  BNC   2CEE
02CE0:  MOVF   xBB,W
02CE2:  SUBWF  00,F
02CE4:  BTFSS  FD8.0
02CE6:  DECF   03,F
02CE8:  MOVF   xBC,W
02CEA:  SUBWF  03,F
02CEC:  BSF    FD8.0
02CEE:  RLCF   01,F
02CF0:  RLCF   02,F
02CF2:  DECFSZ xBD,F
02CF4:  BRA    2CCA
02CF6:  MOVLB  0
02CF8:  RETURN 0
*
0350A:  TSTFSZ 01
0350C:  BRA    3514
0350E:  TSTFSZ 02
03510:  BRA    3516
03512:  BRA    3522
03514:  INCF   02,F
03516:  MOVFF  00,FEE
0351A:  DECFSZ 01,F
0351C:  BRA    3516
0351E:  DECFSZ 02,F
03520:  BRA    3516
03522:  RETURN 0
*
035F4:  MOVLB  9
035F6:  BTFSC  xCB.7
035F8:  BRA    361A
035FA:  MOVLW  0F
035FC:  MOVWF  00
035FE:  SWAPF  xCA,W
03600:  ANDWF  00,F
03602:  MOVLW  0A
03604:  SUBWF  00,W
03606:  BC    360E
03608:  MOVLW  30
0360A:  ADDWF  00,F
0360C:  BRA    3612
0360E:  MOVF   xCB,W
03610:  ADDWF  00,F
03612:  MOVF   00,W
03614:  BTFSS  F9E.4
03616:  BRA    3614
03618:  MOVWF  FAD
0361A:  MOVLW  0F
0361C:  ANDWF  xCA,F
0361E:  MOVLW  0A
03620:  SUBWF  xCA,W
03622:  BC    3628
03624:  MOVLW  30
03626:  BRA    362C
03628:  BCF    xCB.7
0362A:  MOVF   xCB,W
0362C:  ADDWF  xCA,F
0362E:  MOVF   xCA,W
03630:  BTFSS  F9E.4
03632:  BRA    3630
03634:  MOVWF  FAD
03636:  MOVLB  0
03638:  RETURN 0
*
047D4:  MOVLB  9
047D6:  CLRF   xDC
047D8:  CLRF   xDD
047DA:  MOVLW  01
047DC:  MOVWF  xDE
047DE:  CLRF   FDA
047E0:  CLRF   FD9
047E2:  MOVLW  09
047E4:  MOVWF  xE1
047E6:  MOVLW  D4
047E8:  MOVWF  xE0
047EA:  MOVLW  09
047EC:  MOVWF  FEA
047EE:  MOVLW  D8
047F0:  MOVWF  FE9
047F2:  MOVFF  9E1,FE2
047F6:  MOVFF  9E0,FE1
047FA:  MOVFF  9DE,9DF
047FE:  BCF    FD8.0
04800:  MOVF   FE5,W
04802:  MULWF  FEE
04804:  MOVF   FF3,W
04806:  ADDWFC xDC,F
04808:  MOVF   FF4,W
0480A:  ADDWFC xDD,F
0480C:  DECFSZ xDF,F
0480E:  BRA    47FE
04810:  MOVFF  9DC,FDE
04814:  MOVFF  9DD,9DC
04818:  CLRF   xDD
0481A:  BTFSC  FD8.0
0481C:  INCF   xDD,F
0481E:  INCF   xE0,F
04820:  BTFSC  FD8.2
04822:  INCF   xE1,F
04824:  INCF   xDE,F
04826:  MOVF   xDE,W
04828:  SUBLW  05
0482A:  BNZ   47EA
0482C:  MOVLB  0
0482E:  RETURN 0
*
05078:  MOVFF  1E,FEA
0507C:  MOVFF  1D,FE9
05080:  MOVLB  8
05082:  MOVFF  8DD,FEF
05086:  INCF   FE9,F
05088:  BTFSC  FD8.2
0508A:  INCF   FEA,F
0508C:  CLRF   FEF
0508E:  INCF   1D,F
05090:  BTFSC  FD8.2
05092:  INCF   1E,F
05094:  MOVLB  0
05096:  RETURN 0
05098:  TBLRD*+
0509A:  MOVF   FF5,F
0509C:  BZ    50BE
0509E:  MOVFF  FF6,8C9
050A2:  MOVFF  FF7,8CA
050A6:  MOVFF  FF8,8CB
050AA:  MOVFF  FF5,8DD
050AE:  RCALL  5078
050B0:  MOVFF  8C9,FF6
050B4:  MOVFF  8CA,FF7
050B8:  MOVFF  8CB,FF8
050BC:  BRA    5098
050BE:  RETURN 0
*
0525A:  MOVF   01,W
0525C:  CLRF   1B
0525E:  BTFSC  FF2.7
05260:  BSF    1B.7
05262:  BCF    FF2.7
05264:  MOVFF  8CB,A1B
05268:  MOVLW  64
0526A:  MOVLB  A
0526C:  MOVWF  x1C
0526E:  MOVLB  0
05270:  CALL   0FA4
05274:  BTFSC  1B.7
05276:  BSF    FF2.7
05278:  MOVFF  00,8CB
0527C:  MOVF   01,W
0527E:  MOVLW  30
05280:  BNZ   5292
05282:  MOVLB  8
05284:  BTFSS  xCC.1
05286:  BRA    52A6
05288:  BTFSC  xCC.3
0528A:  BRA    52A6
0528C:  BTFSC  xCC.4
0528E:  MOVLW  20
05290:  BRA    529A
05292:  MOVLB  8
05294:  BCF    xCC.3
05296:  BCF    xCC.4
05298:  BSF    xCC.0
0529A:  ADDWF  01,F
0529C:  MOVFF  01,8DD
052A0:  MOVLB  0
052A2:  RCALL  5078
052A4:  MOVLB  8
052A6:  CLRF   1B
052A8:  BTFSC  FF2.7
052AA:  BSF    1B.7
052AC:  BCF    FF2.7
052AE:  MOVFF  8CB,A1B
052B2:  MOVLW  0A
052B4:  MOVLB  A
052B6:  MOVWF  x1C
052B8:  MOVLB  0
052BA:  CALL   0FA4
052BE:  BTFSC  1B.7
052C0:  BSF    FF2.7
052C2:  MOVFF  00,8CB
052C6:  MOVF   01,W
052C8:  MOVLW  30
052CA:  BNZ   52DC
052CC:  MOVLB  8
052CE:  BTFSC  xCC.3
052D0:  BRA    52E6
052D2:  BTFSS  xCC.0
052D4:  BRA    52E6
052D6:  BTFSC  xCC.4
052D8:  MOVLW  20
052DA:  MOVLB  0
052DC:  ADDWF  01,F
052DE:  MOVFF  01,8DD
052E2:  RCALL  5078
052E4:  MOVLB  8
052E6:  MOVLW  30
052E8:  ADDWF  xCB,F
052EA:  MOVFF  8CB,8DD
052EE:  MOVLB  0
052F0:  RCALL  5078
052F2:  RETURN 0
052F4:  MOVF   FE9,W
052F6:  MOVLB  8
052F8:  MOVWF  xD0
052FA:  MOVLW  3B
052FC:  MOVWF  xD7
052FE:  MOVLW  9A
05300:  MOVWF  xD6
05302:  MOVLW  CA
05304:  MOVWF  xD5
05306:  CLRF   xD4
05308:  MOVLW  0A
0530A:  MOVWF  xD2
0530C:  MOVF   xCF,W
0530E:  BTFSS  FD8.2
05310:  DECF   xD0,F
05312:  BSF    FD8.1
05314:  MOVLW  08
05316:  MOVWF  FEA
05318:  MOVLW  CB
0531A:  MOVWF  FE9
0531C:  CLRF   1B
0531E:  BTFSC  FF2.7
05320:  BSF    1B.7
05322:  BCF    FF2.7
05324:  MOVFF  8CE,A28
05328:  MOVFF  8CD,A27
0532C:  MOVFF  8CC,A26
05330:  MOVFF  8CB,A25
05334:  MOVFF  8D7,A2C
05338:  MOVFF  8D6,A2B
0533C:  MOVFF  8D5,A2A
05340:  MOVFF  8D4,A29
05344:  MOVLB  0
05346:  CALL   1080
0534A:  BTFSC  1B.7
0534C:  BSF    FF2.7
0534E:  MOVF   01,W
05350:  MOVF   00,F
05352:  BNZ   537A
05354:  MOVLB  8
05356:  INCF   xCF,W
05358:  SUBWF  xD2,W
0535A:  BTFSS  FD8.2
0535C:  BRA    5362
0535E:  MOVLB  0
05360:  BRA    537A
05362:  MOVF   xD0,W
05364:  BZ    537E
05366:  ANDLW  0F
05368:  SUBWF  xD2,W
0536A:  BZ    536E
0536C:  BC    53AA
0536E:  BTFSC  xD0.7
05370:  BRA    53AA
05372:  BTFSC  xD0.6
05374:  BRA    537E
05376:  MOVLW  20
05378:  BRA    539E
0537A:  MOVLB  8
0537C:  CLRF   xD0
0537E:  MOVF   xCF,W
05380:  SUBWF  xD2,W
05382:  BNZ   539C
05384:  MOVFF  00,8D0
05388:  MOVLW  2E
0538A:  MOVWF  xDD
0538C:  MOVLB  0
0538E:  RCALL  5078
05390:  MOVLB  8
05392:  MOVFF  8D0,00
05396:  MOVLW  20
05398:  ANDWF  xD0,F
0539A:  MOVLW  00
0539C:  MOVLW  30
0539E:  ADDWF  00,F
053A0:  MOVFF  00,8DD
053A4:  MOVLB  0
053A6:  RCALL  5078
053A8:  MOVLB  8
053AA:  BCF    FD8.1
053AC:  CLRF   1B
053AE:  BTFSC  FF2.7
053B0:  BSF    1B.7
053B2:  BCF    FF2.7
053B4:  MOVFF  8D7,A28
053B8:  MOVFF  8D6,A27
053BC:  MOVFF  8D5,A26
053C0:  MOVFF  8D4,A25
053C4:  MOVLB  A
053C6:  CLRF   x2C
053C8:  CLRF   x2B
053CA:  CLRF   x2A
053CC:  MOVLW  0A
053CE:  MOVWF  x29
053D0:  MOVLB  0
053D2:  CALL   1080
053D6:  BTFSC  1B.7
053D8:  BSF    FF2.7
053DA:  MOVFF  03,8D7
053DE:  MOVFF  02,8D6
053E2:  MOVFF  01,8D5
053E6:  MOVFF  00,8D4
053EA:  MOVLB  8
053EC:  DECFSZ xD2,F
053EE:  BRA    5312
053F0:  MOVLB  0
053F2:  RETURN 0
*
05C76:  MOVLB  9
05C78:  MOVF   xEA,W
05C7A:  MULWF  xEC
05C7C:  MOVFF  FF3,01
05C80:  MOVFF  FF4,00
05C84:  MULWF  xED
05C86:  MOVF   FF3,W
05C88:  ADDWF  00,F
05C8A:  MOVF   xEB,W
05C8C:  MULWF  xEC
05C8E:  MOVF   FF3,W
05C90:  ADDWFC 00,W
05C92:  MOVWF  02
05C94:  MOVLB  0
05C96:  RETURN 0
*
0793C:  MOVF   FEF,F
0793E:  BZ    7960
07940:  MOVFF  FEA,98F
07944:  MOVFF  FE9,98E
07948:  MOVF   FEF,W
0794A:  BTFSS  F9E.4
0794C:  BRA    794A
0794E:  MOVWF  FAD
07950:  MOVFF  98F,FEA
07954:  MOVFF  98E,FE9
07958:  INCF   FE9,F
0795A:  BTFSC  FD8.2
0795C:  INCF   FEA,F
0795E:  BRA    793C
07960:  RETURN 0
*
08F84:  MOVFF  FEA,8D6
08F88:  MOVFF  FE9,8D5
08F8C:  MOVLB  8
08F8E:  BTFSS  xCF.7
08F90:  BRA    8FA2
08F92:  BSF    xD5.7
08F94:  BTFSS  xD5.4
08F96:  INCF   xD5,F
08F98:  COMF   xCE,F
08F9A:  COMF   xCF,F
08F9C:  INCF   xCE,F
08F9E:  BTFSC  FD8.2
08FA0:  INCF   xCF,F
08FA2:  SWAPF  xCF,W
08FA4:  IORLW  F0
08FA6:  MOVWF  xD1
08FA8:  ADDWF  xD1,F
08FAA:  ADDLW  E2
08FAC:  MOVWF  xD2
08FAE:  ADDLW  32
08FB0:  MOVWF  xD4
08FB2:  MOVF   xCF,W
08FB4:  ANDLW  0F
08FB6:  ADDWF  xD2,F
08FB8:  ADDWF  xD2,F
08FBA:  ADDWF  xD4,F
08FBC:  ADDLW  E9
08FBE:  MOVWF  xD3
08FC0:  ADDWF  xD3,F
08FC2:  ADDWF  xD3,F
08FC4:  SWAPF  xCE,W
08FC6:  ANDLW  0F
08FC8:  ADDWF  xD3,F
08FCA:  ADDWF  xD4,F
08FCC:  RLCF   xD3,F
08FCE:  RLCF   xD4,F
08FD0:  COMF   xD4,F
08FD2:  RLCF   xD4,F
08FD4:  MOVF   xCE,W
08FD6:  ANDLW  0F
08FD8:  ADDWF  xD4,F
08FDA:  RLCF   xD1,F
08FDC:  MOVLW  07
08FDE:  MOVWF  xD0
08FE0:  MOVLW  0A
08FE2:  DECF   xD3,F
08FE4:  ADDWF  xD4,F
08FE6:  BNC   8FE2
08FE8:  DECF   xD2,F
08FEA:  ADDWF  xD3,F
08FEC:  BNC   8FE8
08FEE:  DECF   xD1,F
08FF0:  ADDWF  xD2,F
08FF2:  BNC   8FEE
08FF4:  DECF   xD0,F
08FF6:  ADDWF  xD1,F
08FF8:  BNC   8FF4
08FFA:  MOVLW  08
08FFC:  MOVWF  FEA
08FFE:  MOVLW  D0
09000:  MOVWF  FE9
09002:  MOVLW  07
09004:  ANDWF  xD5,W
09006:  BCF    xD5.6
09008:  MOVF   FED,F
0900A:  ANDWF  xD5,W
0900C:  BNZ   901C
0900E:  BTFSC  xD5.4
09010:  MOVF   FEE,F
09012:  BTFSC  xD5.4
09014:  BRA    901C
09016:  MOVLW  20
09018:  MOVWF  00
0901A:  BRA    905E
0901C:  ADDWF  FE9,F
0901E:  MOVLW  00
09020:  ADDWFC FEA,F
09022:  MOVF   FE9,W
09024:  SUBLW  D4
09026:  BNZ   9030
09028:  MOVF   FEA,W
0902A:  SUBLW  08
0902C:  BNZ   9030
0902E:  BSF    xD5.6
09030:  MOVF   FEF,W
09032:  MOVWF  00
09034:  BNZ   9046
09036:  BTFSC  xD5.6
09038:  BRA    9046
0903A:  BTFSC  xD5.4
0903C:  BRA    9066
0903E:  BTFSC  xD5.3
09040:  BRA    9046
09042:  MOVLW  20
09044:  BRA    905C
09046:  BTFSS  xD5.7
09048:  BRA    9056
0904A:  MOVLW  2D
0904C:  MOVWF  00
0904E:  MOVF   FED,W
09050:  BCF    xD5.6
09052:  BCF    xD5.7
09054:  BRA    905E
09056:  BSF    xD5.3
09058:  BCF    xD5.4
0905A:  MOVLW  30
0905C:  ADDWF  00,F
0905E:  MOVF   00,W
09060:  BTFSS  F9E.4
09062:  BRA    9060
09064:  MOVWF  FAD
09066:  MOVF   FEE,W
09068:  BTFSS  xD5.6
0906A:  BRA    9022
0906C:  MOVLB  0
0906E:  RETURN 0
*
09504:  MOVF   FE9,W
09506:  MOVLB  8
09508:  MOVWF  xD4
0950A:  BTFSS  xD3.7
0950C:  BRA    9528
0950E:  DECF   xD4,F
09510:  BSF    xD4.5
09512:  COMF   xD0,F
09514:  COMF   xD1,F
09516:  COMF   xD2,F
09518:  COMF   xD3,F
0951A:  INCF   xD0,F
0951C:  BTFSC  FD8.2
0951E:  INCF   xD1,F
09520:  BTFSC  FD8.2
09522:  INCF   xD2,F
09524:  BTFSC  FD8.2
09526:  INCF   xD3,F
09528:  MOVLW  3B
0952A:  MOVWF  xDB
0952C:  MOVLW  9A
0952E:  MOVWF  xDA
09530:  MOVLW  CA
09532:  MOVWF  xD9
09534:  CLRF   xD8
09536:  MOVLW  0A
09538:  MOVWF  xD6
0953A:  BSF    FD8.1
0953C:  MOVLW  08
0953E:  MOVWF  FEA
09540:  MOVLW  D0
09542:  MOVWF  FE9
09544:  CLRF   1B
09546:  BTFSC  FF2.7
09548:  BSF    1B.7
0954A:  BCF    FF2.7
0954C:  MOVFF  8D3,A28
09550:  MOVFF  8D2,A27
09554:  MOVFF  8D1,A26
09558:  MOVFF  8D0,A25
0955C:  MOVFF  8DB,A2C
09560:  MOVFF  8DA,A2B
09564:  MOVFF  8D9,A2A
09568:  MOVFF  8D8,A29
0956C:  MOVLB  0
0956E:  CALL   1080
09572:  BTFSC  1B.7
09574:  BSF    FF2.7
09576:  MOVF   01,W
09578:  MOVF   00,F
0957A:  BNZ   95A2
0957C:  MOVLB  8
0957E:  MOVF   xD6,W
09580:  XORLW  01
09582:  BTFSS  FD8.2
09584:  BRA    958A
09586:  MOVLB  0
09588:  BRA    95A2
0958A:  MOVF   xD4,W
0958C:  BZ    95A8
0958E:  ANDLW  0F
09590:  SUBWF  xD6,W
09592:  BZ    9596
09594:  BC    95E6
09596:  BTFSC  xD4.7
09598:  BRA    95E6
0959A:  BTFSC  xD4.6
0959C:  BRA    95A8
0959E:  MOVLW  20
095A0:  BRA    95DC
095A2:  MOVLW  20
095A4:  MOVLB  8
095A6:  ANDWF  xD4,F
095A8:  BTFSS  xD4.5
095AA:  BRA    95C0
095AC:  BCF    xD4.5
095AE:  MOVFF  00,8D4
095B2:  MOVLW  2D
095B4:  BTFSS  F9E.4
095B6:  BRA    95B4
095B8:  MOVWF  FAD
095BA:  MOVFF  8D4,00
095BE:  CLRF   xD4
095C0:  MOVLW  30
095C2:  BTFSS  xD4.5
095C4:  BRA    95DC
095C6:  BCF    xD4.5
095C8:  MOVFF  00,8D4
095CC:  MOVLW  2D
095CE:  BTFSS  F9E.4
095D0:  BRA    95CE
095D2:  MOVWF  FAD
095D4:  MOVFF  8D4,00
095D8:  CLRF   xD4
095DA:  MOVLW  30
095DC:  ADDWF  00,F
095DE:  MOVF   00,W
095E0:  BTFSS  F9E.4
095E2:  BRA    95E0
095E4:  MOVWF  FAD
095E6:  BCF    FD8.1
095E8:  CLRF   1B
095EA:  BTFSC  FF2.7
095EC:  BSF    1B.7
095EE:  BCF    FF2.7
095F0:  MOVFF  8DB,A28
095F4:  MOVFF  8DA,A27
095F8:  MOVFF  8D9,A26
095FC:  MOVFF  8D8,A25
09600:  MOVLB  A
09602:  CLRF   x2C
09604:  CLRF   x2B
09606:  CLRF   x2A
09608:  MOVLW  0A
0960A:  MOVWF  x29
0960C:  MOVLB  0
0960E:  CALL   1080
09612:  BTFSC  1B.7
09614:  BSF    FF2.7
09616:  MOVFF  03,8DB
0961A:  MOVFF  02,8DA
0961E:  MOVFF  01,8D9
09622:  MOVFF  00,8D8
09626:  MOVLB  8
09628:  DECFSZ xD6,F
0962A:  BRA    953A
0962C:  MOVLB  0
0962E:  RETURN 0
*
0A6F8:  ADDWF  FE8,W
0A6FA:  CLRF   FF7
0A6FC:  RLCF   FF7,F
0A6FE:  ADDLW  19
0A700:  MOVWF  FF6
0A702:  MOVLW  A7
0A704:  ADDWFC FF7,F
0A706:  MOVLW  00
0A708:  MOVWF  FF8
0A70A:  MOVWF  FFB
0A70C:  TBLRD*-
0A70E:  MOVF   FF5,W
0A710:  MOVWF  FFA
0A712:  TBLRD*
0A714:  MOVF   FF5,W
0A716:  MOVWF  FF9
0A718:  DATA 54,A0
0A71A:  DATA 74,A0
0A71C:  DATA 9C,A0
0A71E:  DATA CC,A0
0A720:  DATA F4,A0
*
0AA6C:  TBLRD*+
0AA6E:  MOVFF  FF6,8CA
0AA72:  MOVFF  FF7,8CB
0AA76:  MOVFF  FF8,8CC
0AA7A:  MOVFF  FF5,8DD
0AA7E:  CALL   5078
0AA82:  MOVFF  8CA,FF6
0AA86:  MOVFF  8CB,FF7
0AA8A:  MOVFF  8CC,FF8
0AA8E:  MOVLB  8
0AA90:  DECFSZ xC9,F
0AA92:  BRA    AA96
0AA94:  BRA    AA9A
0AA96:  MOVLB  0
0AA98:  BRA    AA6C
0AA9A:  MOVLB  0
0AA9C:  RETURN 0
0AA9E:  MOVFF  FEA,8DC
0AAA2:  MOVFF  FE9,8DB
0AAA6:  MOVLB  8
0AAA8:  SWAPF  xD5,W
0AAAA:  IORLW  F0
0AAAC:  MOVWF  xD7
0AAAE:  ADDWF  xD7,F
0AAB0:  ADDLW  E2
0AAB2:  MOVWF  xD8
0AAB4:  ADDLW  32
0AAB6:  MOVWF  xDA
0AAB8:  MOVF   xD5,W
0AABA:  ANDLW  0F
0AABC:  ADDWF  xD8,F
0AABE:  ADDWF  xD8,F
0AAC0:  ADDWF  xDA,F
0AAC2:  ADDLW  E9
0AAC4:  MOVWF  xD9
0AAC6:  ADDWF  xD9,F
0AAC8:  ADDWF  xD9,F
0AACA:  SWAPF  xD4,W
0AACC:  ANDLW  0F
0AACE:  ADDWF  xD9,F
0AAD0:  ADDWF  xDA,F
0AAD2:  RLCF   xD9,F
0AAD4:  RLCF   xDA,F
0AAD6:  COMF   xDA,F
0AAD8:  RLCF   xDA,F
0AADA:  MOVF   xD4,W
0AADC:  ANDLW  0F
0AADE:  ADDWF  xDA,F
0AAE0:  RLCF   xD7,F
0AAE2:  MOVLW  07
0AAE4:  MOVWF  xD6
0AAE6:  MOVLW  0A
0AAE8:  DECF   xD9,F
0AAEA:  ADDWF  xDA,F
0AAEC:  BNC   AAE8
0AAEE:  DECF   xD8,F
0AAF0:  ADDWF  xD9,F
0AAF2:  BNC   AAEE
0AAF4:  DECF   xD7,F
0AAF6:  ADDWF  xD8,F
0AAF8:  BNC   AAF4
0AAFA:  DECF   xD6,F
0AAFC:  ADDWF  xD7,F
0AAFE:  BNC   AAFA
0AB00:  MOVLW  08
0AB02:  MOVWF  FEA
0AB04:  MOVLW  D6
0AB06:  MOVWF  FE9
0AB08:  MOVLW  07
0AB0A:  ANDWF  xDB,W
0AB0C:  BCF    xDB.6
0AB0E:  ADDWF  FE9,F
0AB10:  MOVLW  00
0AB12:  ADDWFC FEA,F
0AB14:  MOVF   FE9,W
0AB16:  SUBLW  DA
0AB18:  BNZ   AB22
0AB1A:  MOVF   FEA,W
0AB1C:  SUBLW  08
0AB1E:  BNZ   AB22
0AB20:  BSF    xDB.6
0AB22:  MOVF   FEF,W
0AB24:  MOVWF  00
0AB26:  BNZ   AB38
0AB28:  BTFSC  xDB.6
0AB2A:  BRA    AB38
0AB2C:  BTFSC  xDB.4
0AB2E:  BRA    AB5C
0AB30:  BTFSC  xDB.3
0AB32:  BRA    AB38
0AB34:  MOVLW  20
0AB36:  BRA    AB3E
0AB38:  BSF    xDB.3
0AB3A:  BCF    xDB.4
0AB3C:  MOVLW  30
0AB3E:  ADDWF  00,F
0AB40:  MOVFF  FEA,8D5
0AB44:  MOVFF  FE9,8D4
0AB48:  MOVFF  00,8DD
0AB4C:  MOVLB  0
0AB4E:  CALL   5078
0AB52:  MOVFF  8D5,FEA
0AB56:  MOVFF  8D4,FE9
0AB5A:  MOVLB  8
0AB5C:  MOVF   FEE,W
0AB5E:  BTFSS  xDB.6
0AB60:  BRA    AB14
0AB62:  MOVLB  0
0AB64:  RETURN 0
*
0AD50:  ADDWF  FE8,W
0AD52:  CLRF   FF7
0AD54:  RLCF   FF7,F
0AD56:  ADDLW  71
0AD58:  MOVWF  FF6
0AD5A:  MOVLW  AD
0AD5C:  ADDWFC FF7,F
0AD5E:  MOVLW  00
0AD60:  MOVWF  FF8
0AD62:  MOVWF  FFB
0AD64:  TBLRD*-
0AD66:  MOVF   FF5,W
0AD68:  MOVWF  FFA
0AD6A:  TBLRD*
0AD6C:  MOVF   FF5,W
0AD6E:  MOVWF  FF9
0AD70:  DATA 60,AC
0AD72:  DATA 4C,AD
0AD74:  DATA 4C,AD
0AD76:  DATA C0,AB
0AD78:  DATA 4C,AD
0AD7A:  DATA 4C,AD
0AD7C:  DATA 4C,AD
0AD7E:  DATA 84,AB
0AD80:  DATA 4C,AD
0AD82:  DATA 4C,AD
0AD84:  DATA 4C,AD
0AD86:  DATA D6,AC
0AD88:  DATA FC,AB
0AD8A:  DATA 4C,AD
0AD8C:  DATA 9A,AC
0AD8E:  DATA 12,AD
*
0ADEA:  TBLRD*+
0ADEC:  MOVF   FF5,F
0ADEE:  BZ    AE12
0ADF0:  MOVFF  FF6,8A2
0ADF4:  MOVFF  FF7,8A3
0ADF8:  MOVFF  FF8,8A4
0ADFC:  MOVF   FF5,W
0ADFE:  BTFSS  F9E.4
0AE00:  BRA    ADFE
0AE02:  MOVWF  FAD
0AE04:  MOVFF  8A2,FF6
0AE08:  MOVFF  8A3,FF7
0AE0C:  MOVFF  8A4,FF8
0AE10:  BRA    ADEA
0AE12:  GOTO   AE7C (RETURN)
*
0BF74:  MOVFF  FEA,FE2
0BF78:  MOVFF  FE9,FE1
0BF7C:  CLRF   01
0BF7E:  BSF    00.0
0BF80:  TBLRD*+
0BF82:  MOVF   FF5,W
0BF84:  BTFSS  00.0
0BF86:  BRA    BF92
0BF88:  SUBWF  FEE,W
0BF8A:  BNZ   BF92
0BF8C:  MOVF   FF5,F
0BF8E:  BNZ   BF80
0BF90:  BRA    BFAC
0BF92:  BCF    00.0
0BF94:  MOVF   FF5,F
0BF96:  BNZ   BF80
0BF98:  INCF   01,F
0BF9A:  BSF    00.0
0BF9C:  MOVFF  FE2,FEA
0BFA0:  MOVFF  FE1,FE9
0BFA4:  TBLRD*
0BFA6:  MOVF   FF5,F
0BFA8:  BNZ   BF80
0BFAA:  SETF   01
0BFAC:  RETURN 0
0BFAE:  MOVLW  8E
0BFB0:  MOVWF  00
0BFB2:  MOVFF  8F6,01
0BFB6:  MOVFF  8F5,02
0BFBA:  CLRF   03
0BFBC:  MOVF   01,F
0BFBE:  BNZ   BFD2
0BFC0:  MOVFF  02,01
0BFC4:  CLRF   02
0BFC6:  MOVLW  08
0BFC8:  SUBWF  00,F
0BFCA:  MOVF   01,F
0BFCC:  BNZ   BFD2
0BFCE:  CLRF   00
0BFD0:  BRA    BFE2
0BFD2:  BCF    FD8.0
0BFD4:  BTFSC  01.7
0BFD6:  BRA    BFE0
0BFD8:  RLCF   02,F
0BFDA:  RLCF   01,F
0BFDC:  DECF   00,F
0BFDE:  BRA    BFD2
0BFE0:  BCF    01.7
0BFE2:  RETURN 0
0BFE4:  MOVLB  8
0BFE6:  MOVF   xD9,W
0BFE8:  BTFSC  FD8.2
0BFEA:  BRA    C136
0BFEC:  MOVWF  xE5
0BFEE:  MOVF   xDD,W
0BFF0:  BTFSC  FD8.2
0BFF2:  BRA    C136
0BFF4:  SUBWF  xE5,F
0BFF6:  BNC   C002
0BFF8:  MOVLW  7F
0BFFA:  ADDWF  xE5,F
0BFFC:  BTFSC  FD8.0
0BFFE:  BRA    C136
0C000:  BRA    C00E
0C002:  MOVLW  81
0C004:  SUBWF  xE5,F
0C006:  BTFSS  FD8.0
0C008:  BRA    C136
0C00A:  BTFSC  FD8.2
0C00C:  BRA    C136
0C00E:  MOVFF  8E5,00
0C012:  CLRF   01
0C014:  CLRF   02
0C016:  CLRF   03
0C018:  CLRF   xE4
0C01A:  MOVFF  8DA,8E3
0C01E:  BSF    xE3.7
0C020:  MOVFF  8DB,8E2
0C024:  MOVFF  8DC,8E1
0C028:  MOVLW  19
0C02A:  MOVWF  xE5
0C02C:  MOVF   xE0,W
0C02E:  SUBWF  xE1,F
0C030:  BC    C04C
0C032:  MOVLW  01
0C034:  SUBWF  xE2,F
0C036:  BC    C04C
0C038:  SUBWF  xE3,F
0C03A:  BC    C04C
0C03C:  SUBWF  xE4,F
0C03E:  BC    C04C
0C040:  INCF   xE4,F
0C042:  INCF   xE3,F
0C044:  INCF   xE2,F
0C046:  MOVF   xE0,W
0C048:  ADDWF  xE1,F
0C04A:  BRA    C09C
0C04C:  MOVF   xDF,W
0C04E:  SUBWF  xE2,F
0C050:  BC    C076
0C052:  MOVLW  01
0C054:  SUBWF  xE3,F
0C056:  BC    C076
0C058:  SUBWF  xE4,F
0C05A:  BC    C076
0C05C:  INCF   xE4,F
0C05E:  INCF   xE3,F
0C060:  MOVF   xDF,W
0C062:  ADDWF  xE2,F
0C064:  MOVF   xE0,W
0C066:  ADDWF  xE1,F
0C068:  BNC   C09C
0C06A:  INCF   xE2,F
0C06C:  BNZ   C09C
0C06E:  INCF   xE3,F
0C070:  BNZ   C09C
0C072:  INCF   xE4,F
0C074:  BRA    C09C
0C076:  MOVF   xDE,W
0C078:  IORLW  80
0C07A:  SUBWF  xE3,F
0C07C:  BC    C09A
0C07E:  MOVLW  01
0C080:  SUBWF  xE4,F
0C082:  BC    C09A
0C084:  INCF   xE4,F
0C086:  MOVF   xDE,W
0C088:  IORLW  80
0C08A:  ADDWF  xE3,F
0C08C:  MOVF   xDF,W
0C08E:  ADDWF  xE2,F
0C090:  BNC   C064
0C092:  INCF   xE3,F
0C094:  BNZ   C064
0C096:  INCF   xE4,F
0C098:  BRA    C064
0C09A:  BSF    03.0
0C09C:  DECFSZ xE5,F
0C09E:  BRA    C0A2
0C0A0:  BRA    C0B8
0C0A2:  BCF    FD8.0
0C0A4:  RLCF   xE1,F
0C0A6:  RLCF   xE2,F
0C0A8:  RLCF   xE3,F
0C0AA:  RLCF   xE4,F
0C0AC:  BCF    FD8.0
0C0AE:  RLCF   03,F
0C0B0:  RLCF   02,F
0C0B2:  RLCF   01,F
0C0B4:  RLCF   xE6,F
0C0B6:  BRA    C02C
0C0B8:  BTFSS  xE6.0
0C0BA:  BRA    C0C8
0C0BC:  BCF    FD8.0
0C0BE:  RRCF   01,F
0C0C0:  RRCF   02,F
0C0C2:  RRCF   03,F
0C0C4:  RRCF   xE6,F
0C0C6:  BRA    C0CC
0C0C8:  DECF   00,F
0C0CA:  BZ    C136
0C0CC:  BTFSC  xE6.7
0C0CE:  BRA    C10C
0C0D0:  BCF    FD8.0
0C0D2:  RLCF   xE1,F
0C0D4:  RLCF   xE2,F
0C0D6:  RLCF   xE3,F
0C0D8:  RLCF   xE4,F
0C0DA:  MOVF   xE0,W
0C0DC:  SUBWF  xE1,F
0C0DE:  BC    C0EE
0C0E0:  MOVLW  01
0C0E2:  SUBWF  xE2,F
0C0E4:  BC    C0EE
0C0E6:  SUBWF  xE3,F
0C0E8:  BC    C0EE
0C0EA:  SUBWF  xE4,F
0C0EC:  BNC   C122
0C0EE:  MOVF   xDF,W
0C0F0:  SUBWF  xE2,F
0C0F2:  BC    C0FE
0C0F4:  MOVLW  01
0C0F6:  SUBWF  xE3,F
0C0F8:  BC    C0FE
0C0FA:  SUBWF  xE4,F
0C0FC:  BNC   C122
0C0FE:  MOVF   xDE,W
0C100:  IORLW  80
0C102:  SUBWF  xE3,F
0C104:  BC    C10C
0C106:  MOVLW  01
0C108:  SUBWF  xE4,F
0C10A:  BNC   C122
0C10C:  INCF   03,F
0C10E:  BNZ   C122
0C110:  INCF   02,F
0C112:  BNZ   C122
0C114:  INCF   01,F
0C116:  BNZ   C122
0C118:  INCF   00,F
0C11A:  BZ    C136
0C11C:  RRCF   01,F
0C11E:  RRCF   02,F
0C120:  RRCF   03,F
0C122:  MOVFF  8DA,8E5
0C126:  MOVF   xDE,W
0C128:  XORWF  xE5,F
0C12A:  BTFSS  xE5.7
0C12C:  BRA    C132
0C12E:  BSF    01.7
0C130:  BRA    C13E
0C132:  BCF    01.7
0C134:  BRA    C13E
0C136:  CLRF   00
0C138:  CLRF   01
0C13A:  CLRF   02
0C13C:  CLRF   03
0C13E:  MOVLB  0
0C140:  RETURN 0
0C142:  MOVFF  8F2,8F9
0C146:  MOVLB  8
0C148:  MOVF   xF6,W
0C14A:  XORWF  xF9,F
0C14C:  BTFSS  xF9.7
0C14E:  BRA    C15A
0C150:  BCF    FD8.2
0C152:  BCF    FD8.0
0C154:  BTFSC  xF2.7
0C156:  BSF    FD8.0
0C158:  BRA    C1B8
0C15A:  MOVFF  8F2,8F9
0C15E:  MOVFF  8F5,8FA
0C162:  MOVF   xF1,W
0C164:  SUBWF  xFA,F
0C166:  BZ    C174
0C168:  BTFSS  xF9.7
0C16A:  BRA    C1B8
0C16C:  MOVF   FD8,W
0C16E:  XORLW  01
0C170:  MOVWF  FD8
0C172:  BRA    C1B8
0C174:  MOVFF  8F6,8FA
0C178:  MOVF   xF2,W
0C17A:  SUBWF  xFA,F
0C17C:  BZ    C18A
0C17E:  BTFSS  xF9.7
0C180:  BRA    C1B8
0C182:  MOVF   FD8,W
0C184:  XORLW  01
0C186:  MOVWF  FD8
0C188:  BRA    C1B8
0C18A:  MOVFF  8F7,8FA
0C18E:  MOVF   xF3,W
0C190:  SUBWF  xFA,F
0C192:  BZ    C1A0
0C194:  BTFSS  xF9.7
0C196:  BRA    C1B8
0C198:  MOVF   FD8,W
0C19A:  XORLW  01
0C19C:  MOVWF  FD8
0C19E:  BRA    C1B8
0C1A0:  MOVFF  8F8,8FA
0C1A4:  MOVF   xF4,W
0C1A6:  SUBWF  xFA,F
0C1A8:  BZ    C1B6
0C1AA:  BTFSS  xF9.7
0C1AC:  BRA    C1B8
0C1AE:  MOVF   FD8,W
0C1B0:  XORLW  01
0C1B2:  MOVWF  FD8
0C1B4:  BRA    C1B8
0C1B6:  BCF    FD8.0
0C1B8:  MOVLB  0
0C1BA:  RETURN 0
0C1BC:  MOVLW  80
0C1BE:  BTFSS  FD8.1
0C1C0:  BRA    C1C6
0C1C2:  MOVLB  8
0C1C4:  XORWF  xFA,F
0C1C6:  MOVLB  8
0C1C8:  CLRF   xFF
0C1CA:  MOVLB  9
0C1CC:  CLRF   x00
0C1CE:  MOVFF  8F6,8FE
0C1D2:  MOVLB  8
0C1D4:  MOVF   xFA,W
0C1D6:  XORWF  xFE,F
0C1D8:  MOVF   xF5,W
0C1DA:  BTFSC  FD8.2
0C1DC:  BRA    C404
0C1DE:  MOVWF  xFD
0C1E0:  MOVWF  00
0C1E2:  MOVF   xF9,W
0C1E4:  BTFSC  FD8.2
0C1E6:  BRA    C418
0C1E8:  SUBWF  xFD,F
0C1EA:  BTFSC  FD8.2
0C1EC:  BRA    C326
0C1EE:  BNC   C286
0C1F0:  MOVFF  8FA,903
0C1F4:  MOVLB  9
0C1F6:  BSF    x03.7
0C1F8:  MOVFF  8FB,902
0C1FC:  MOVFF  8FC,901
0C200:  CLRF   x00
0C202:  BCF    FD8.0
0C204:  RRCF   x03,F
0C206:  RRCF   x02,F
0C208:  RRCF   x01,F
0C20A:  RRCF   x00,F
0C20C:  MOVLB  8
0C20E:  DECFSZ xFD,F
0C210:  BRA    C214
0C212:  BRA    C218
0C214:  MOVLB  9
0C216:  BRA    C200
0C218:  BTFSS  xFE.7
0C21A:  BRA    C222
0C21C:  BSF    xFF.0
0C21E:  BRA    C442
0C220:  BCF    xFF.0
0C222:  BCF    xFD.0
0C224:  BSF    xFF.4
0C226:  MOVLW  08
0C228:  MOVWF  FEA
0C22A:  MOVLW  F8
0C22C:  MOVWF  FE9
0C22E:  BRA    C46C
0C230:  BCF    xFF.4
0C232:  BTFSC  xFE.7
0C234:  BRA    C24E
0C236:  BTFSS  xFD.0
0C238:  BRA    C268
0C23A:  MOVLB  9
0C23C:  RRCF   x03,F
0C23E:  RRCF   x02,F
0C240:  RRCF   x01,F
0C242:  RRCF   x00,F
0C244:  INCF   00,F
0C246:  BTFSC  FD8.2
0C248:  BRA    C438
0C24A:  MOVLB  8
0C24C:  BRA    C268
0C24E:  MOVLB  9
0C250:  BTFSC  x03.7
0C252:  BRA    C26E
0C254:  BCF    FD8.0
0C256:  RLCF   x00,F
0C258:  RLCF   x01,F
0C25A:  RLCF   x02,F
0C25C:  RLCF   x03,F
0C25E:  DECF   00,F
0C260:  BTFSC  FD8.2
0C262:  BRA    C438
0C264:  BRA    C250
0C266:  MOVLB  8
0C268:  BSF    xFF.6
0C26A:  BRA    C374
0C26C:  BCF    xFF.6
0C26E:  MOVFF  8F6,8FE
0C272:  MOVLB  8
0C274:  BTFSS  xF6.7
0C276:  BRA    C27E
0C278:  MOVLB  9
0C27A:  BSF    x03.7
0C27C:  BRA    C42A
0C27E:  MOVLB  9
0C280:  BCF    x03.7
0C282:  BRA    C42A
0C284:  MOVLB  8
0C286:  MOVFF  8F9,8FD
0C28A:  MOVFF  8F9,00
0C28E:  MOVF   xF5,W
0C290:  SUBWF  xFD,F
0C292:  MOVFF  8F6,903
0C296:  MOVLB  9
0C298:  BSF    x03.7
0C29A:  MOVFF  8F7,902
0C29E:  MOVFF  8F8,901
0C2A2:  CLRF   x00
0C2A4:  BCF    FD8.0
0C2A6:  RRCF   x03,F
0C2A8:  RRCF   x02,F
0C2AA:  RRCF   x01,F
0C2AC:  RRCF   x00,F
0C2AE:  MOVLB  8
0C2B0:  DECFSZ xFD,F
0C2B2:  BRA    C2B6
0C2B4:  BRA    C2BA
0C2B6:  MOVLB  9
0C2B8:  BRA    C2A2
0C2BA:  BTFSS  xFE.7
0C2BC:  BRA    C2C4
0C2BE:  BSF    xFF.1
0C2C0:  BRA    C442
0C2C2:  BCF    xFF.1
0C2C4:  BCF    xFD.0
0C2C6:  BSF    xFF.5
0C2C8:  MOVLW  08
0C2CA:  MOVWF  FEA
0C2CC:  MOVLW  FC
0C2CE:  MOVWF  FE9
0C2D0:  BRA    C46C
0C2D2:  BCF    xFF.5
0C2D4:  BTFSC  xFE.7
0C2D6:  BRA    C2F0
0C2D8:  BTFSS  xFD.0
0C2DA:  BRA    C30A
0C2DC:  MOVLB  9
0C2DE:  RRCF   x03,F
0C2E0:  RRCF   x02,F
0C2E2:  RRCF   x01,F
0C2E4:  RRCF   x00,F
0C2E6:  INCF   00,F
0C2E8:  BTFSC  FD8.2
0C2EA:  BRA    C438
0C2EC:  MOVLB  8
0C2EE:  BRA    C30A
0C2F0:  MOVLB  9
0C2F2:  BTFSC  x03.7
0C2F4:  BRA    C310
0C2F6:  BCF    FD8.0
0C2F8:  RLCF   x00,F
0C2FA:  RLCF   x01,F
0C2FC:  RLCF   x02,F
0C2FE:  RLCF   x03,F
0C300:  DECF   00,F
0C302:  BTFSC  FD8.2
0C304:  BRA    C438
0C306:  BRA    C2F2
0C308:  MOVLB  8
0C30A:  BSF    xFF.7
0C30C:  BRA    C374
0C30E:  BCF    xFF.7
0C310:  MOVFF  8FA,8FE
0C314:  MOVLB  8
0C316:  BTFSS  xFA.7
0C318:  BRA    C320
0C31A:  MOVLB  9
0C31C:  BSF    x03.7
0C31E:  BRA    C42A
0C320:  MOVLB  9
0C322:  BCF    x03.7
0C324:  BRA    C42A
0C326:  MOVFF  8FA,903
0C32A:  MOVLB  9
0C32C:  BSF    x03.7
0C32E:  MOVFF  8FB,902
0C332:  MOVFF  8FC,901
0C336:  MOVLB  8
0C338:  BTFSS  xFE.7
0C33A:  BRA    C348
0C33C:  MOVLB  9
0C33E:  BCF    x03.7
0C340:  MOVLB  8
0C342:  BSF    xFF.2
0C344:  BRA    C442
0C346:  BCF    xFF.2
0C348:  MOVLB  9
0C34A:  CLRF   x00
0C34C:  MOVLB  8
0C34E:  BCF    xFD.0
0C350:  MOVLW  08
0C352:  MOVWF  FEA
0C354:  MOVLW  F8
0C356:  MOVWF  FE9
0C358:  BRA    C46C
0C35A:  BTFSC  xFE.7
0C35C:  BRA    C39C
0C35E:  MOVFF  8F6,8FE
0C362:  BTFSS  xFD.0
0C364:  BRA    C374
0C366:  MOVLB  9
0C368:  RRCF   x03,F
0C36A:  RRCF   x02,F
0C36C:  RRCF   x01,F
0C36E:  RRCF   x00,F
0C370:  INCF   00,F
0C372:  BZ    C438
0C374:  MOVLB  9
0C376:  BTFSS  x00.7
0C378:  BRA    C390
0C37A:  INCF   x01,F
0C37C:  BNZ   C390
0C37E:  INCF   x02,F
0C380:  BNZ   C390
0C382:  INCF   x03,F
0C384:  BNZ   C390
0C386:  RRCF   x03,F
0C388:  RRCF   x02,F
0C38A:  RRCF   x01,F
0C38C:  INCF   00,F
0C38E:  BZ    C438
0C390:  MOVLB  8
0C392:  BTFSC  xFF.6
0C394:  BRA    C26C
0C396:  BTFSC  xFF.7
0C398:  BRA    C30E
0C39A:  BRA    C3F4
0C39C:  MOVLW  80
0C39E:  MOVLB  9
0C3A0:  XORWF  x03,F
0C3A2:  BTFSS  x03.7
0C3A4:  BRA    C3B2
0C3A6:  MOVLB  8
0C3A8:  BRA    C442
0C3AA:  MOVFF  8FA,8FE
0C3AE:  BRA    C3D8
0C3B0:  MOVLB  9
0C3B2:  MOVFF  8F6,8FE
0C3B6:  MOVF   x03,F
0C3B8:  BTFSC  FD8.2
0C3BA:  BRA    C3C0
0C3BC:  MOVLB  8
0C3BE:  BRA    C3D8
0C3C0:  MOVF   x02,F
0C3C2:  BTFSC  FD8.2
0C3C4:  BRA    C3CA
0C3C6:  MOVLB  8
0C3C8:  BRA    C3D8
0C3CA:  MOVF   x01,F
0C3CC:  BTFSC  FD8.2
0C3CE:  BRA    C3D4
0C3D0:  MOVLB  8
0C3D2:  BRA    C3D8
0C3D4:  CLRF   00
0C3D6:  BRA    C42A
0C3D8:  MOVLB  9
0C3DA:  BTFSS  x03.7
0C3DC:  BRA    C3E2
0C3DE:  MOVLB  8
0C3E0:  BRA    C3F4
0C3E2:  BCF    FD8.0
0C3E4:  RLCF   x00,F
0C3E6:  RLCF   x01,F
0C3E8:  RLCF   x02,F
0C3EA:  RLCF   x03,F
0C3EC:  DECFSZ 00,F
0C3EE:  BRA    C3DA
0C3F0:  BRA    C438
0C3F2:  MOVLB  8
0C3F4:  BTFSS  xFE.7
0C3F6:  BRA    C3FE
0C3F8:  MOVLB  9
0C3FA:  BSF    x03.7
0C3FC:  BRA    C42A
0C3FE:  MOVLB  9
0C400:  BCF    x03.7
0C402:  BRA    C42A
0C404:  MOVFF  8F9,00
0C408:  MOVFF  8FA,903
0C40C:  MOVFF  8FB,902
0C410:  MOVFF  8FC,901
0C414:  MOVLB  9
0C416:  BRA    C42A
0C418:  MOVFF  8F5,00
0C41C:  MOVFF  8F6,903
0C420:  MOVFF  8F7,902
0C424:  MOVFF  8F8,901
0C428:  MOVLB  9
0C42A:  MOVFF  903,01
0C42E:  MOVFF  902,02
0C432:  MOVFF  901,03
0C436:  BRA    C4BA
0C438:  CLRF   00
0C43A:  CLRF   01
0C43C:  CLRF   02
0C43E:  CLRF   03
0C440:  BRA    C4BA
0C442:  MOVLB  9
0C444:  CLRF   x00
0C446:  COMF   x01,F
0C448:  COMF   x02,F
0C44A:  COMF   x03,F
0C44C:  COMF   x00,F
0C44E:  INCF   x00,F
0C450:  BNZ   C45C
0C452:  INCF   x01,F
0C454:  BNZ   C45C
0C456:  INCF   x02,F
0C458:  BNZ   C45C
0C45A:  INCF   x03,F
0C45C:  MOVLB  8
0C45E:  BTFSC  xFF.0
0C460:  BRA    C220
0C462:  BTFSC  xFF.1
0C464:  BRA    C2C2
0C466:  BTFSC  xFF.2
0C468:  BRA    C346
0C46A:  BRA    C3AA
0C46C:  MOVF   FEF,W
0C46E:  MOVLB  9
0C470:  ADDWF  x01,F
0C472:  BNC   C484
0C474:  INCF   x02,F
0C476:  BNZ   C484
0C478:  INCF   x03,F
0C47A:  BTFSS  FD8.2
0C47C:  BRA    C484
0C47E:  MOVLB  8
0C480:  BSF    xFD.0
0C482:  MOVLB  9
0C484:  MOVF   FED,F
0C486:  MOVF   FEF,W
0C488:  ADDWF  x02,F
0C48A:  BNC   C498
0C48C:  INCF   x03,F
0C48E:  BTFSS  FD8.2
0C490:  BRA    C498
0C492:  MOVLB  8
0C494:  BSF    xFD.0
0C496:  MOVLB  9
0C498:  MOVF   FED,F
0C49A:  MOVF   FEF,W
0C49C:  BTFSC  FEF.7
0C49E:  BRA    C4A2
0C4A0:  XORLW  80
0C4A2:  ADDWF  x03,F
0C4A4:  BTFSS  FD8.0
0C4A6:  BRA    C4AC
0C4A8:  MOVLB  8
0C4AA:  BSF    xFD.0
0C4AC:  MOVLB  8
0C4AE:  BTFSC  xFF.4
0C4B0:  BRA    C230
0C4B2:  BTFSC  xFF.5
0C4B4:  BRA    C2D2
0C4B6:  BRA    C35A
0C4B8:  MOVLB  9
0C4BA:  MOVLB  0
0C4BC:  RETURN 0
0C4BE:  MOVLB  8
0C4C0:  MOVF   xF1,W
0C4C2:  BTFSC  FD8.2
0C4C4:  BRA    C5A8
0C4C6:  MOVWF  00
0C4C8:  MOVF   xF5,W
0C4CA:  BTFSC  FD8.2
0C4CC:  BRA    C5A8
0C4CE:  ADDWF  00,F
0C4D0:  BNC   C4DA
0C4D2:  MOVLW  81
0C4D4:  ADDWF  00,F
0C4D6:  BC    C5A8
0C4D8:  BRA    C4E2
0C4DA:  MOVLW  7F
0C4DC:  SUBWF  00,F
0C4DE:  BNC   C5A8
0C4E0:  BZ    C5A8
0C4E2:  MOVFF  8F2,8F9
0C4E6:  MOVF   xF6,W
0C4E8:  XORWF  xF9,F
0C4EA:  BSF    xF2.7
0C4EC:  BSF    xF6.7
0C4EE:  MOVF   xF4,W
0C4F0:  MULWF  xF8
0C4F2:  MOVFF  FF4,8FB
0C4F6:  MOVF   xF3,W
0C4F8:  MULWF  xF7
0C4FA:  MOVFF  FF4,03
0C4FE:  MOVFF  FF3,8FA
0C502:  MULWF  xF8
0C504:  MOVF   FF3,W
0C506:  ADDWF  xFB,F
0C508:  MOVF   FF4,W
0C50A:  ADDWFC xFA,F
0C50C:  MOVLW  00
0C50E:  ADDWFC 03,F
0C510:  MOVF   xF4,W
0C512:  MULWF  xF7
0C514:  MOVF   FF3,W
0C516:  ADDWF  xFB,F
0C518:  MOVF   FF4,W
0C51A:  ADDWFC xFA,F
0C51C:  MOVLW  00
0C51E:  CLRF   02
0C520:  ADDWFC 03,F
0C522:  ADDWFC 02,F
0C524:  MOVF   xF2,W
0C526:  MULWF  xF8
0C528:  MOVF   FF3,W
0C52A:  ADDWF  xFA,F
0C52C:  MOVF   FF4,W
0C52E:  ADDWFC 03,F
0C530:  MOVLW  00
0C532:  ADDWFC 02,F
0C534:  MOVF   xF2,W
0C536:  MULWF  xF7
0C538:  MOVF   FF3,W
0C53A:  ADDWF  03,F
0C53C:  MOVF   FF4,W
0C53E:  ADDWFC 02,F
0C540:  MOVLW  00
0C542:  CLRF   01
0C544:  ADDWFC 01,F
0C546:  MOVF   xF4,W
0C548:  MULWF  xF6
0C54A:  MOVF   FF3,W
0C54C:  ADDWF  xFA,F
0C54E:  MOVF   FF4,W
0C550:  ADDWFC 03,F
0C552:  MOVLW  00
0C554:  ADDWFC 02,F
0C556:  ADDWFC 01,F
0C558:  MOVF   xF3,W
0C55A:  MULWF  xF6
0C55C:  MOVF   FF3,W
0C55E:  ADDWF  03,F
0C560:  MOVF   FF4,W
0C562:  ADDWFC 02,F
0C564:  MOVLW  00
0C566:  ADDWFC 01,F
0C568:  MOVF   xF2,W
0C56A:  MULWF  xF6
0C56C:  MOVF   FF3,W
0C56E:  ADDWF  02,F
0C570:  MOVF   FF4,W
0C572:  ADDWFC 01,F
0C574:  INCF   00,F
0C576:  BTFSC  01.7
0C578:  BRA    C584
0C57A:  RLCF   xFA,F
0C57C:  RLCF   03,F
0C57E:  RLCF   02,F
0C580:  RLCF   01,F
0C582:  DECF   00,F
0C584:  MOVLW  00
0C586:  BTFSS  xFA.7
0C588:  BRA    C59E
0C58A:  INCF   03,F
0C58C:  ADDWFC 02,F
0C58E:  ADDWFC 01,F
0C590:  MOVF   01,W
0C592:  BNZ   C59E
0C594:  MOVF   02,W
0C596:  BNZ   C59E
0C598:  MOVF   03,W
0C59A:  BNZ   C59E
0C59C:  INCF   00,F
0C59E:  BTFSC  xF9.7
0C5A0:  BSF    01.7
0C5A2:  BTFSS  xF9.7
0C5A4:  BCF    01.7
0C5A6:  BRA    C5B0
0C5A8:  CLRF   00
0C5AA:  CLRF   01
0C5AC:  CLRF   02
0C5AE:  CLRF   03
0C5B0:  MOVLB  0
0C5B2:  RETURN 0
0C5B4:  MOVLW  8E
0C5B6:  MOVWF  00
0C5B8:  MOVFF  8CB,01
0C5BC:  MOVFF  8CA,02
0C5C0:  CLRF   03
0C5C2:  BTFSS  01.7
0C5C4:  BRA    C5D0
0C5C6:  COMF   01,F
0C5C8:  COMF   02,F
0C5CA:  INCF   02,F
0C5CC:  BNZ   C5D0
0C5CE:  INCF   01,F
0C5D0:  MOVF   01,F
0C5D2:  BNZ   C5E6
0C5D4:  MOVFF  02,01
0C5D8:  CLRF   02
0C5DA:  MOVLW  08
0C5DC:  SUBWF  00,F
0C5DE:  MOVF   01,F
0C5E0:  BNZ   C5E6
0C5E2:  CLRF   00
0C5E4:  BRA    C602
0C5E6:  BCF    FD8.0
0C5E8:  BTFSC  01.7
0C5EA:  BRA    C5F4
0C5EC:  RLCF   02,F
0C5EE:  RLCF   01,F
0C5F0:  DECF   00,F
0C5F2:  BRA    C5E6
0C5F4:  MOVLB  8
0C5F6:  BTFSS  xCB.7
0C5F8:  BRA    C5FE
0C5FA:  MOVLB  0
0C5FC:  BRA    C602
0C5FE:  BCF    01.7
0C600:  MOVLB  0
0C602:  RETURN 0
*
0C9E4:  MOVLB  8
0C9E6:  MOVF   xBA,W
0C9E8:  SUBLW  B6
0C9EA:  MOVWF  xBA
0C9EC:  CLRF   03
0C9EE:  MOVFF  8BB,8BE
0C9F2:  BSF    xBB.7
0C9F4:  BCF    FD8.0
0C9F6:  RRCF   xBB,F
0C9F8:  RRCF   xBC,F
0C9FA:  RRCF   xBD,F
0C9FC:  RRCF   03,F
0C9FE:  RRCF   02,F
0CA00:  RRCF   01,F
0CA02:  RRCF   00,F
0CA04:  DECFSZ xBA,F
0CA06:  BRA    C9F4
0CA08:  BTFSS  xBE.7
0CA0A:  BRA    CA22
0CA0C:  COMF   00,F
0CA0E:  COMF   01,F
0CA10:  COMF   02,F
0CA12:  COMF   03,F
0CA14:  INCF   00,F
0CA16:  BTFSC  FD8.2
0CA18:  INCF   01,F
0CA1A:  BTFSC  FD8.2
0CA1C:  INCF   02,F
0CA1E:  BTFSC  FD8.2
0CA20:  INCF   03,F
0CA22:  MOVLB  0
0CA24:  GOTO   CAC0 (RETURN)
0CA28:  MOVF   FE9,W
0CA2A:  MOVLB  8
0CA2C:  MOVWF  xB2
0CA2E:  MOVF   xB1,W
0CA30:  MOVWF  xB4
0CA32:  BZ    CA6A
0CA34:  MOVFF  8B0,8F4
0CA38:  MOVFF  8AF,8F3
0CA3C:  MOVFF  8AE,8F2
0CA40:  MOVFF  8AD,8F1
0CA44:  CLRF   xF8
0CA46:  CLRF   xF7
0CA48:  MOVLW  20
0CA4A:  MOVWF  xF6
0CA4C:  MOVLW  82
0CA4E:  MOVWF  xF5
0CA50:  MOVLB  0
0CA52:  RCALL  C4BE
0CA54:  MOVFF  03,8B0
0CA58:  MOVFF  02,8AF
0CA5C:  MOVFF  01,8AE
0CA60:  MOVFF  00,8AD
0CA64:  MOVLB  8
0CA66:  DECFSZ xB4,F
0CA68:  BRA    CA34
0CA6A:  MOVLW  7E
0CA6C:  MOVWF  00
0CA6E:  CLRF   01
0CA70:  BTFSC  xAE.7
0CA72:  BSF    01.7
0CA74:  CLRF   02
0CA76:  CLRF   03
0CA78:  BCF    FD8.1
0CA7A:  MOVFF  8B0,8F8
0CA7E:  MOVFF  8AF,8F7
0CA82:  MOVFF  8AE,8F6
0CA86:  MOVFF  8AD,8F5
0CA8A:  MOVFF  03,8FC
0CA8E:  MOVFF  02,8FB
0CA92:  MOVFF  01,8FA
0CA96:  MOVWF  xF9
0CA98:  MOVLB  0
0CA9A:  CALL   C1BC
0CA9E:  MOVFF  03,8B0
0CAA2:  MOVFF  02,8AF
0CAA6:  MOVFF  01,8AE
0CAAA:  MOVFF  00,8AD
0CAAE:  MOVFF  8B0,8BD
0CAB2:  MOVFF  8AF,8BC
0CAB6:  MOVFF  8AE,8BB
0CABA:  MOVFF  8AD,8BA
0CABE:  BRA    C9E4
0CAC0:  MOVFF  03,8B0
0CAC4:  MOVFF  02,8AF
0CAC8:  MOVFF  01,8AE
0CACC:  MOVFF  00,8AD
0CAD0:  MOVLB  8
0CAD2:  BTFSS  xB0.7
0CAD4:  BRA    CAF0
0CAD6:  DECF   xB2,F
0CAD8:  BSF    xB2.5
0CADA:  COMF   xAD,F
0CADC:  COMF   xAE,F
0CADE:  COMF   xAF,F
0CAE0:  COMF   xB0,F
0CAE2:  INCF   xAD,F
0CAE4:  BTFSC  FD8.2
0CAE6:  INCF   xAE,F
0CAE8:  BTFSC  FD8.2
0CAEA:  INCF   xAF,F
0CAEC:  BTFSC  FD8.2
0CAEE:  INCF   xB0,F
0CAF0:  MOVLW  3B
0CAF2:  MOVWF  xB9
0CAF4:  MOVLW  9A
0CAF6:  MOVWF  xB8
0CAF8:  MOVLW  CA
0CAFA:  MOVWF  xB7
0CAFC:  CLRF   xB6
0CAFE:  MOVLW  0A
0CB00:  MOVWF  xB4
0CB02:  MOVF   xB1,W
0CB04:  BTFSC  FD8.2
0CB06:  INCF   xB2,F
0CB08:  BSF    FD8.1
0CB0A:  MOVLW  08
0CB0C:  MOVWF  FEA
0CB0E:  MOVLW  AD
0CB10:  MOVWF  FE9
0CB12:  CLRF   1B
0CB14:  BTFSC  FF2.7
0CB16:  BSF    1B.7
0CB18:  BCF    FF2.7
0CB1A:  MOVFF  8B0,A28
0CB1E:  MOVFF  8AF,A27
0CB22:  MOVFF  8AE,A26
0CB26:  MOVFF  8AD,A25
0CB2A:  MOVFF  8B9,A2C
0CB2E:  MOVFF  8B8,A2B
0CB32:  MOVFF  8B7,A2A
0CB36:  MOVFF  8B6,A29
0CB3A:  MOVLB  0
0CB3C:  CALL   1080
0CB40:  BTFSC  1B.7
0CB42:  BSF    FF2.7
0CB44:  MOVF   01,W
0CB46:  MOVF   00,F
0CB48:  BNZ   CB70
0CB4A:  MOVLB  8
0CB4C:  INCF   xB1,W
0CB4E:  SUBWF  xB4,W
0CB50:  BTFSS  FD8.2
0CB52:  BRA    CB58
0CB54:  MOVLB  0
0CB56:  BRA    CB70
0CB58:  MOVF   xB2,W
0CB5A:  BZ    CB76
0CB5C:  ANDLW  0F
0CB5E:  SUBWF  xB4,W
0CB60:  BZ    CB64
0CB62:  BC    CBEC
0CB64:  BTFSC  xB2.7
0CB66:  BRA    CBEC
0CB68:  BTFSC  xB2.6
0CB6A:  BRA    CB76
0CB6C:  MOVLW  20
0CB6E:  BRA    CBDE
0CB70:  MOVLW  20
0CB72:  MOVLB  8
0CB74:  ANDWF  xB2,F
0CB76:  BTFSS  xB2.5
0CB78:  BRA    CB98
0CB7A:  BCF    xB2.5
0CB7C:  MOVF   xB1,W
0CB7E:  BTFSS  FD8.2
0CB80:  DECF   xB2,F
0CB82:  MOVF   00,W
0CB84:  MOVWF  xB2
0CB86:  MOVLW  2D
0CB88:  MOVWF  xDD
0CB8A:  MOVLB  0
0CB8C:  CALL   5078
0CB90:  MOVLB  8
0CB92:  MOVF   xB2,W
0CB94:  MOVWF  00
0CB96:  CLRF   xB2
0CB98:  MOVF   xB1,W
0CB9A:  SUBWF  xB4,W
0CB9C:  BNZ   CBB8
0CB9E:  MOVF   00,W
0CBA0:  MOVWF  xB2
0CBA2:  MOVLW  2E
0CBA4:  MOVWF  xDD
0CBA6:  MOVLB  0
0CBA8:  CALL   5078
0CBAC:  MOVLB  8
0CBAE:  MOVF   xB2,W
0CBB0:  MOVWF  00
0CBB2:  MOVLW  20
0CBB4:  ANDWF  xB2,F
0CBB6:  MOVLW  00
0CBB8:  MOVLW  30
0CBBA:  BTFSS  xB2.5
0CBBC:  BRA    CBDE
0CBBE:  BCF    xB2.5
0CBC0:  MOVF   xB1,W
0CBC2:  BTFSS  FD8.2
0CBC4:  DECF   xB2,F
0CBC6:  MOVF   00,W
0CBC8:  MOVWF  xB2
0CBCA:  MOVLW  2D
0CBCC:  MOVWF  xDD
0CBCE:  MOVLB  0
0CBD0:  CALL   5078
0CBD4:  MOVLB  8
0CBD6:  MOVF   xB2,W
0CBD8:  MOVWF  00
0CBDA:  CLRF   xB2
0CBDC:  MOVLW  30
0CBDE:  ADDWF  00,F
0CBE0:  MOVFF  00,8DD
0CBE4:  MOVLB  0
0CBE6:  CALL   5078
0CBEA:  MOVLB  8
0CBEC:  BCF    FD8.1
0CBEE:  CLRF   1B
0CBF0:  BTFSC  FF2.7
0CBF2:  BSF    1B.7
0CBF4:  BCF    FF2.7
0CBF6:  MOVFF  8B9,A28
0CBFA:  MOVFF  8B8,A27
0CBFE:  MOVFF  8B7,A26
0CC02:  MOVFF  8B6,A25
0CC06:  MOVLB  A
0CC08:  CLRF   x2C
0CC0A:  CLRF   x2B
0CC0C:  CLRF   x2A
0CC0E:  MOVLW  0A
0CC10:  MOVWF  x29
0CC12:  MOVLB  0
0CC14:  CALL   1080
0CC18:  BTFSC  1B.7
0CC1A:  BSF    FF2.7
0CC1C:  MOVFF  03,8B9
0CC20:  MOVFF  02,8B8
0CC24:  MOVFF  01,8B7
0CC28:  MOVFF  00,8B6
0CC2C:  MOVLB  8
0CC2E:  DECFSZ xB4,F
0CC30:  BRA    CB08
0CC32:  MOVLB  0
0CC34:  RETURN 0
*
0E54A:  MOVF   01,W
0E54C:  CLRF   1B
0E54E:  BTFSC  FF2.7
0E550:  BSF    1B.7
0E552:  BCF    FF2.7
0E554:  MOVFF  8D1,A1B
0E558:  MOVLW  64
0E55A:  MOVLB  A
0E55C:  MOVWF  x1C
0E55E:  MOVLB  0
0E560:  CALL   0FA4
0E564:  BTFSC  1B.7
0E566:  BSF    FF2.7
0E568:  MOVFF  00,8D1
0E56C:  MOVF   01,W
0E56E:  MOVLW  30
0E570:  BNZ   E582
0E572:  MOVLB  8
0E574:  BTFSS  xD2.1
0E576:  BRA    E598
0E578:  BTFSC  xD2.3
0E57A:  BRA    E598
0E57C:  BTFSC  xD2.4
0E57E:  MOVLW  20
0E580:  BRA    E58A
0E582:  MOVLB  8
0E584:  BCF    xD2.3
0E586:  BCF    xD2.4
0E588:  BSF    xD2.0
0E58A:  ADDWF  01,F
0E58C:  MOVF   01,W
0E58E:  BTFSS  FA4.4
0E590:  BRA    E58E
0E592:  MOVLB  F
0E594:  MOVWF  x1C
0E596:  MOVLB  8
0E598:  CLRF   1B
0E59A:  BTFSC  FF2.7
0E59C:  BSF    1B.7
0E59E:  BCF    FF2.7
0E5A0:  MOVFF  8D1,A1B
0E5A4:  MOVLW  0A
0E5A6:  MOVLB  A
0E5A8:  MOVWF  x1C
0E5AA:  MOVLB  0
0E5AC:  CALL   0FA4
0E5B0:  BTFSC  1B.7
0E5B2:  BSF    FF2.7
0E5B4:  MOVFF  00,8D1
0E5B8:  MOVF   01,W
0E5BA:  MOVLW  30
0E5BC:  BNZ   E5CE
0E5BE:  MOVLB  8
0E5C0:  BTFSC  xD2.3
0E5C2:  BRA    E5DC
0E5C4:  BTFSS  xD2.0
0E5C6:  BRA    E5DC
0E5C8:  BTFSC  xD2.4
0E5CA:  MOVLW  20
0E5CC:  MOVLB  0
0E5CE:  ADDWF  01,F
0E5D0:  MOVF   01,W
0E5D2:  BTFSS  FA4.4
0E5D4:  BRA    E5D2
0E5D6:  MOVLB  F
0E5D8:  MOVWF  x1C
0E5DA:  MOVLB  8
0E5DC:  MOVLW  30
0E5DE:  ADDWF  xD1,F
0E5E0:  MOVF   xD1,W
0E5E2:  BTFSS  FA4.4
0E5E4:  BRA    E5E2
0E5E6:  MOVLB  F
0E5E8:  MOVWF  x1C
0E5EA:  MOVLB  0
0E5EC:  RETURN 0
0E5EE:  MOVF   FE9,W
0E5F0:  MOVLB  8
0E5F2:  MOVWF  xD5
0E5F4:  MOVLW  3B
0E5F6:  MOVWF  xDC
0E5F8:  MOVLW  9A
0E5FA:  MOVWF  xDB
0E5FC:  MOVLW  CA
0E5FE:  MOVWF  xDA
0E600:  CLRF   xD9
0E602:  MOVLW  0A
0E604:  MOVWF  xD7
0E606:  BSF    FD8.1
0E608:  MOVLW  08
0E60A:  MOVWF  FEA
0E60C:  MOVLW  D1
0E60E:  MOVWF  FE9
0E610:  CLRF   1B
0E612:  BTFSC  FF2.7
0E614:  BSF    1B.7
0E616:  BCF    FF2.7
0E618:  MOVFF  8D4,A28
0E61C:  MOVFF  8D3,A27
0E620:  MOVFF  8D2,A26
0E624:  MOVFF  8D1,A25
0E628:  MOVFF  8DC,A2C
0E62C:  MOVFF  8DB,A2B
0E630:  MOVFF  8DA,A2A
0E634:  MOVFF  8D9,A29
0E638:  MOVLB  0
0E63A:  CALL   1080
0E63E:  BTFSC  1B.7
0E640:  BSF    FF2.7
0E642:  MOVF   01,W
0E644:  MOVF   00,F
0E646:  BNZ   E66E
0E648:  MOVLB  8
0E64A:  MOVF   xD7,W
0E64C:  XORLW  01
0E64E:  BTFSS  FD8.2
0E650:  BRA    E656
0E652:  MOVLB  0
0E654:  BRA    E66E
0E656:  MOVF   xD5,W
0E658:  BZ    E672
0E65A:  ANDLW  0F
0E65C:  SUBWF  xD7,W
0E65E:  BZ    E662
0E660:  BC    E682
0E662:  BTFSC  xD5.7
0E664:  BRA    E682
0E666:  BTFSC  xD5.6
0E668:  BRA    E672
0E66A:  MOVLW  20
0E66C:  BRA    E674
0E66E:  MOVLB  8
0E670:  CLRF   xD5
0E672:  MOVLW  30
0E674:  ADDWF  00,F
0E676:  MOVF   00,W
0E678:  BTFSS  FA4.4
0E67A:  BRA    E678
0E67C:  MOVLB  F
0E67E:  MOVWF  x1C
0E680:  MOVLB  8
0E682:  BCF    FD8.1
0E684:  CLRF   1B
0E686:  BTFSC  FF2.7
0E688:  BSF    1B.7
0E68A:  BCF    FF2.7
0E68C:  MOVFF  8DC,A28
0E690:  MOVFF  8DB,A27
0E694:  MOVFF  8DA,A26
0E698:  MOVFF  8D9,A25
0E69C:  MOVLB  A
0E69E:  CLRF   x2C
0E6A0:  CLRF   x2B
0E6A2:  CLRF   x2A
0E6A4:  MOVLW  0A
0E6A6:  MOVWF  x29
0E6A8:  MOVLB  0
0E6AA:  CALL   1080
0E6AE:  BTFSC  1B.7
0E6B0:  BSF    FF2.7
0E6B2:  MOVFF  03,8DC
0E6B6:  MOVFF  02,8DB
0E6BA:  MOVFF  01,8DA
0E6BE:  MOVFF  00,8D9
0E6C2:  MOVLB  8
0E6C4:  DECFSZ xD7,F
0E6C6:  BRA    E606
0E6C8:  MOVLB  0
0E6CA:  GOTO   E812 (RETURN)
*
0E878:  ADDWF  FE8,W
0E87A:  CLRF   FF7
0E87C:  RLCF   FF7,F
0E87E:  ADDLW  99
0E880:  MOVWF  FF6
0E882:  MOVLW  E8
0E884:  ADDWFC FF7,F
0E886:  MOVLW  00
0E888:  MOVWF  FF8
0E88A:  MOVWF  FFB
0E88C:  TBLRD*-
0E88E:  MOVF   FF5,W
0E890:  MOVWF  FFA
0E892:  TBLRD*
0E894:  MOVF   FF5,W
0E896:  MOVWF  FF9
0E898:  DATA 3A,E8
0E89A:  DATA 42,E8
0E89C:  DATA 48,E8
0E89E:  DATA 4E,E8
*
0E958:  ADDWF  FE8,W
0E95A:  CLRF   FF7
0E95C:  RLCF   FF7,F
0E95E:  ADDLW  79
0E960:  MOVWF  FF6
0E962:  MOVLW  E9
0E964:  ADDWFC FF7,F
0E966:  MOVLW  00
0E968:  MOVWF  FF8
0E96A:  MOVWF  FFB
0E96C:  TBLRD*-
0E96E:  MOVF   FF5,W
0E970:  MOVWF  FFA
0E972:  TBLRD*
0E974:  MOVF   FF5,W
0E976:  MOVWF  FF9
0E978:  DATA 18,E9
0E97A:  DATA 20,E9
0E97C:  DATA 28,E9
0E97E:  DATA 30,E9
*
0ECC4:  MOVLW  8E
0ECC6:  MOVWF  00
0ECC8:  MOVLB  8
0ECCA:  MOVF   xF1,W
0ECCC:  SUBWF  00,F
0ECCE:  MOVFF  8F2,02
0ECD2:  MOVFF  8F3,01
0ECD6:  BSF    02.7
0ECD8:  MOVF   00,F
0ECDA:  BZ    ECEE
0ECDC:  BCF    FD8.0
0ECDE:  MOVF   02,F
0ECE0:  BNZ   ECE6
0ECE2:  MOVF   01,F
0ECE4:  BZ    ECEE
0ECE6:  RRCF   02,F
0ECE8:  RRCF   01,F
0ECEA:  DECFSZ 00,F
0ECEC:  BRA    ECDC
0ECEE:  BTFSS  xF2.7
0ECF0:  BRA    ECFC
0ECF2:  COMF   01,F
0ECF4:  COMF   02,F
0ECF6:  INCF   01,F
0ECF8:  BTFSC  FD8.2
0ECFA:  INCF   02,F
0ECFC:  MOVLB  0
0ECFE:  RETURN 0
*
0F916:  MOVF   FEF,F
0F918:  BZ    F93A
0F91A:  MOVFF  FEA,8CA
0F91E:  MOVFF  FE9,8C9
0F922:  MOVFF  FEF,8DD
0F926:  CALL   5078
0F92A:  MOVFF  8CA,FEA
0F92E:  MOVFF  8C9,FE9
0F932:  INCF   FE9,F
0F934:  BTFSC  FD8.2
0F936:  INCF   FEA,F
0F938:  BRA    F916
0F93A:  RETURN 0
*
0FDA6:  ADDWF  FE8,W
0FDA8:  CLRF   FF7
0FDAA:  RLCF   FF7,F
0FDAC:  ADDLW  C7
0FDAE:  MOVWF  FF6
0FDB0:  MOVLW  FD
0FDB2:  ADDWFC FF7,F
0FDB4:  MOVLW  00
0FDB6:  MOVWF  FF8
0FDB8:  MOVWF  FFB
0FDBA:  TBLRD*-
0FDBC:  MOVF   FF5,W
0FDBE:  MOVWF  FFA
0FDC0:  TBLRD*
0FDC2:  MOVF   FF5,W
0FDC4:  MOVWF  FF9
0FDC6:  DATA E6,FB
0FDC8:  DATA EC,FB
0FDCA:  DATA 0A,FC
0FDCC:  DATA 28,FC
*
0FE3E:  MOVLB  8
0FE40:  MOVF   xBB,W
0FE42:  XORWF  xBD,W
0FE44:  ANDLW  80
0FE46:  MOVWF  xBF
0FE48:  BTFSS  xBB.7
0FE4A:  BRA    FE56
0FE4C:  COMF   xBA,F
0FE4E:  COMF   xBB,F
0FE50:  INCF   xBA,F
0FE52:  BTFSC  FD8.2
0FE54:  INCF   xBB,F
0FE56:  BTFSS  xBD.7
0FE58:  BRA    FE64
0FE5A:  COMF   xBC,F
0FE5C:  COMF   xBD,F
0FE5E:  INCF   xBC,F
0FE60:  BTFSC  FD8.2
0FE62:  INCF   xBD,F
0FE64:  MOVF   xBA,W
0FE66:  MULWF  xBC
0FE68:  MOVFF  FF3,01
0FE6C:  MOVFF  FF4,00
0FE70:  MULWF  xBD
0FE72:  MOVF   FF3,W
0FE74:  ADDWF  00,F
0FE76:  MOVF   xBB,W
0FE78:  MULWF  xBC
0FE7A:  MOVF   FF3,W
0FE7C:  ADDWFC 00,W
0FE7E:  MOVWF  02
0FE80:  BTFSS  xBF.7
0FE82:  BRA    FE8E
0FE84:  COMF   01,F
0FE86:  COMF   02,F
0FE88:  INCF   01,F
0FE8A:  BTFSC  FD8.2
0FE8C:  INCF   02,F
0FE8E:  MOVLB  0
0FE90:  GOTO   10108 (RETURN)
*
1113A:  ADDWF  FE8,W
1113C:  CLRF   FF7
1113E:  RLCF   FF7,F
11140:  ADDLW  5B
11142:  MOVWF  FF6
11144:  MOVLW  11
11146:  ADDWFC FF7,F
11148:  MOVLW  01
1114A:  MOVWF  FF8
1114C:  MOVWF  FFB
1114E:  TBLRD*-
11150:  MOVF   FF5,W
11152:  MOVWF  FFA
11154:  TBLRD*
11156:  MOVF   FF5,W
11158:  MOVWF  FF9
1115A:  DATA FE,0F
1115C:  DATA 2E,11
1115E:  DATA 28,10
11160:  DATA 2E,11
11162:  DATA F4,0E
11164:  DATA 2E,11
11166:  DATA 2E,11
11168:  DATA 2E,11
1116A:  DATA 2E,11
1116C:  DATA 2E,11
1116E:  DATA 2E,11
11170:  DATA 2E,11
11172:  DATA 2E,11
11174:  DATA 2E,11
11176:  DATA 2E,11
11178:  DATA 2E,11
1117A:  DATA 26,11
1117C:  DATA 2E,11
1117E:  DATA 2E,11
11180:  DATA 2E,11
11182:  DATA 2E,11
11184:  DATA 2E,11
11186:  DATA 94,0E
11188:  DATA 2E,11
1118A:  DATA C8,0E
1118C:  DATA D0,0E
1118E:  DATA 2E,11
11190:  DATA E4,0E
11192:  DATA 52,10
11194:  DATA 18,0F
11196:  DATA 2E,11
11198:  DATA 2E,11
1119A:  DATA AA,0F
1119C:  DATA 8C,0F
1119E:  DATA 2E,11
111A0:  DATA 2E,11
111A2:  DATA 2E,11
111A4:  DATA 6A,10
111A6:  DATA 94,10
111A8:  DATA BE,10
111AA:  DATA C6,0F
111AC:  DATA F4,0F
111AE:  DATA 2E,11
111B0:  DATA 2E,11
111B2:  DATA 2E,11
111B4:  DATA 2E,11
111B6:  DATA E8,10
111B8:  DATA 2E,11
111BA:  DATA 2E,11
111BC:  DATA 2E,11
111BE:  DATA 2E,11
111C0:  DATA 2E,11
111C2:  DATA 2E,11
111C4:  DATA 2E,11
111C6:  DATA 2E,11
111C8:  DATA 2E,11
111CA:  DATA 2E,11
111CC:  DATA 00,0F
111CE:  DATA 2E,11
111D0:  DATA 2E,11
111D2:  DATA 2E,11
111D4:  DATA 2E,11
111D6:  DATA 30,0F
111D8:  DATA 2E,11
111DA:  DATA 2E,11
111DC:  DATA 56,0F
111DE:  DATA 2E,11
111E0:  DATA 2E,11
111E2:  DATA 2E,11
111E4:  DATA A4,0E
111E6:  DATA 2E,11
111E8:  DATA 2E,11
111EA:  DATA 2E,11
111EC:  DATA 2E,11
111EE:  DATA 2E,11
111F0:  DATA 10,11
*
11314:  TBLRD*+
11316:  MOVFF  FF6,897
1131A:  MOVFF  FF7,898
1131E:  MOVFF  FF8,899
11322:  MOVF   FF5,W
11324:  BTFSS  FA4.4
11326:  BRA    11324
11328:  MOVLB  F
1132A:  MOVWF  x1C
1132C:  MOVFF  897,FF6
11330:  MOVFF  898,FF7
11334:  MOVFF  899,FF8
11338:  MOVLB  8
1133A:  DECFSZ x96,F
1133C:  BRA    11340
1133E:  BRA    11344
11340:  MOVLB  0
11342:  BRA    11314
11344:  MOVLB  0
11346:  RETURN 0
11348:  TBLRD*+
1134A:  MOVF   FF5,F
1134C:  BZ    11374
1134E:  MOVFF  FF6,895
11352:  MOVFF  FF7,896
11356:  MOVFF  FF8,897
1135A:  MOVF   FF5,W
1135C:  BTFSS  FA4.4
1135E:  BRA    1135C
11360:  MOVLB  F
11362:  MOVWF  x1C
11364:  MOVFF  895,FF6
11368:  MOVFF  896,FF7
1136C:  MOVFF  897,FF8
11370:  MOVLB  0
11372:  BRA    11348
11374:  GOTO   1143E (RETURN)
*
11450:  MOVFF  FEA,89E
11454:  MOVFF  FE9,89D
11458:  MOVLB  8
1145A:  SWAPF  x97,W
1145C:  IORLW  F0
1145E:  MOVWF  x99
11460:  ADDWF  x99,F
11462:  ADDLW  E2
11464:  MOVWF  x9A
11466:  ADDLW  32
11468:  MOVWF  x9C
1146A:  MOVF   x97,W
1146C:  ANDLW  0F
1146E:  ADDWF  x9A,F
11470:  ADDWF  x9A,F
11472:  ADDWF  x9C,F
11474:  ADDLW  E9
11476:  MOVWF  x9B
11478:  ADDWF  x9B,F
1147A:  ADDWF  x9B,F
1147C:  SWAPF  x96,W
1147E:  ANDLW  0F
11480:  ADDWF  x9B,F
11482:  ADDWF  x9C,F
11484:  RLCF   x9B,F
11486:  RLCF   x9C,F
11488:  COMF   x9C,F
1148A:  RLCF   x9C,F
1148C:  MOVF   x96,W
1148E:  ANDLW  0F
11490:  ADDWF  x9C,F
11492:  RLCF   x99,F
11494:  MOVLW  07
11496:  MOVWF  x98
11498:  MOVLW  0A
1149A:  DECF   x9B,F
1149C:  ADDWF  x9C,F
1149E:  BNC   1149A
114A0:  DECF   x9A,F
114A2:  ADDWF  x9B,F
114A4:  BNC   114A0
114A6:  DECF   x99,F
114A8:  ADDWF  x9A,F
114AA:  BNC   114A6
114AC:  DECF   x98,F
114AE:  ADDWF  x99,F
114B0:  BNC   114AC
114B2:  MOVLW  08
114B4:  MOVWF  FEA
114B6:  MOVLW  98
114B8:  MOVWF  FE9
114BA:  MOVLW  07
114BC:  ANDWF  x9D,W
114BE:  BCF    x9D.6
114C0:  ADDWF  FE9,F
114C2:  MOVLW  00
114C4:  ADDWFC FEA,F
114C6:  MOVF   FE9,W
114C8:  SUBLW  9C
114CA:  BNZ   114D4
114CC:  MOVF   FEA,W
114CE:  SUBLW  08
114D0:  BNZ   114D4
114D2:  BSF    x9D.6
114D4:  MOVF   FEF,W
114D6:  MOVWF  00
114D8:  BNZ   114EA
114DA:  BTFSC  x9D.6
114DC:  BRA    114EA
114DE:  BTFSC  x9D.4
114E0:  BRA    114FE
114E2:  BTFSC  x9D.3
114E4:  BRA    114EA
114E6:  MOVLW  20
114E8:  BRA    114F0
114EA:  BSF    x9D.3
114EC:  BCF    x9D.4
114EE:  MOVLW  30
114F0:  ADDWF  00,F
114F2:  MOVF   00,W
114F4:  BTFSS  FA4.4
114F6:  BRA    114F4
114F8:  MOVLB  F
114FA:  MOVWF  x1C
114FC:  MOVLB  8
114FE:  MOVF   FEE,W
11500:  BTFSS  x9D.6
11502:  BRA    114C6
11504:  MOVLB  0
11506:  GOTO   115A0 (RETURN)
*
11C30:  ADDWF  FE8,W
11C32:  CLRF   FF7
11C34:  RLCF   FF7,F
11C36:  ADDLW  51
11C38:  MOVWF  FF6
11C3A:  MOVLW  1C
11C3C:  ADDWFC FF7,F
11C3E:  MOVLW  01
11C40:  MOVWF  FF8
11C42:  MOVWF  FFB
11C44:  TBLRD*-
11C46:  MOVF   FF5,W
11C48:  MOVWF  FFA
11C4A:  TBLRD*
11C4C:  MOVF   FF5,W
11C4E:  MOVWF  FF9
11C50:  DATA 5C,18
11C52:  DATA B4,18
11C54:  DATA CE,18
11C56:  DATA E8,18
11C58:  DATA 02,19
11C5A:  DATA 1C,19
11C5C:  DATA 36,19
11C5E:  DATA 50,19
11C60:  DATA 6A,19
11C62:  DATA 84,19
11C64:  DATA 9E,19
11C66:  DATA B8,19
11C68:  DATA D2,19
11C6A:  DATA EC,19
11C6C:  DATA 06,1A
11C6E:  DATA 20,1A
11C70:  DATA 3A,1A
11C72:  DATA 54,1A
11C74:  DATA 6E,1A
11C76:  DATA 88,1A
11C78:  DATA A2,1A
11C7A:  DATA BC,1A
11C7C:  DATA D6,1A
11C7E:  DATA F0,1A
11C80:  DATA 0A,1B
11C82:  DATA 24,1B
11C84:  DATA 3E,1B
11C86:  DATA 58,1B
11C88:  DATA 72,1B
11C8A:  DATA 8E,1B
11C8C:  DATA AA,1B
11C8E:  DATA C6,1B
11C90:  DATA E2,1B
*
1247E:  ADDWF  FE8,W
12480:  CLRF   FF7
12482:  RLCF   FF7,F
12484:  ADDLW  9F
12486:  MOVWF  FF6
12488:  MOVLW  24
1248A:  ADDWFC FF7,F
1248C:  MOVLW  01
1248E:  MOVWF  FF8
12490:  MOVWF  FFB
12492:  TBLRD*-
12494:  MOVF   FF5,W
12496:  MOVWF  FFA
12498:  TBLRD*
1249A:  MOVF   FF5,W
1249C:  MOVWF  FF9
1249E:  DATA 72,20
124A0:  DATA B2,21
124A2:  DATA 9E,20
124A4:  DATA B2,21
124A6:  DATA 64,1F
124A8:  DATA B2,21
124AA:  DATA B2,21
124AC:  DATA B2,21
124AE:  DATA B2,21
124B0:  DATA B2,21
124B2:  DATA B2,21
124B4:  DATA B2,21
124B6:  DATA B2,21
124B8:  DATA B2,21
124BA:  DATA B2,21
124BC:  DATA B2,21
124BE:  DATA AA,21
124C0:  DATA B2,21
124C2:  DATA B2,21
124C4:  DATA B2,21
124C6:  DATA B2,21
124C8:  DATA B2,21
124CA:  DATA 6E,1D
124CC:  DATA B2,21
124CE:  DATA A2,1D
124D0:  DATA 40,1F
124D2:  DATA B2,21
124D4:  DATA 54,1F
124D6:  DATA CA,20
124D8:  DATA 88,1F
124DA:  DATA B2,21
124DC:  DATA B2,21
124DE:  DATA 1A,20
124E0:  DATA FC,1F
124E2:  DATA B2,21
124E4:  DATA B2,21
124E6:  DATA B2,21
124E8:  DATA E4,20
124EA:  DATA 10,21
124EC:  DATA 3C,21
124EE:  DATA 36,20
124F0:  DATA 66,20
124F2:  DATA B2,21
124F4:  DATA B2,21
124F6:  DATA B2,21
124F8:  DATA B2,21
124FA:  DATA 68,21
124FC:  DATA B2,21
124FE:  DATA B2,21
12500:  DATA B2,21
12502:  DATA B2,21
12504:  DATA B2,21
12506:  DATA B2,21
12508:  DATA B2,21
1250A:  DATA B2,21
1250C:  DATA B2,21
1250E:  DATA B2,21
12510:  DATA 70,1F
12512:  DATA B2,21
12514:  DATA B2,21
12516:  DATA B2,21
12518:  DATA B2,21
1251A:  DATA A0,1F
1251C:  DATA B2,21
1251E:  DATA B2,21
12520:  DATA C6,1F
12522:  DATA B2,21
12524:  DATA B2,21
12526:  DATA B2,21
12528:  DATA 7E,1D
1252A:  DATA B2,21
1252C:  DATA AA,1D
1252E:  DATA B2,21
12530:  DATA B2,21
12532:  DATA B2,21
12534:  DATA 92,21
12536:  MOVFF  FEA,8A7
1253A:  MOVFF  FE9,8A6
1253E:  MOVLB  8
12540:  BTFSS  xA0.7
12542:  BRA    12554
12544:  BSF    xA6.7
12546:  BTFSS  xA6.4
12548:  INCF   xA6,F
1254A:  COMF   x9F,F
1254C:  COMF   xA0,F
1254E:  INCF   x9F,F
12550:  BTFSC  FD8.2
12552:  INCF   xA0,F
12554:  SWAPF  xA0,W
12556:  IORLW  F0
12558:  MOVWF  xA2
1255A:  ADDWF  xA2,F
1255C:  ADDLW  E2
1255E:  MOVWF  xA3
12560:  ADDLW  32
12562:  MOVWF  xA5
12564:  MOVF   xA0,W
12566:  ANDLW  0F
12568:  ADDWF  xA3,F
1256A:  ADDWF  xA3,F
1256C:  ADDWF  xA5,F
1256E:  ADDLW  E9
12570:  MOVWF  xA4
12572:  ADDWF  xA4,F
12574:  ADDWF  xA4,F
12576:  SWAPF  x9F,W
12578:  ANDLW  0F
1257A:  ADDWF  xA4,F
1257C:  ADDWF  xA5,F
1257E:  RLCF   xA4,F
12580:  RLCF   xA5,F
12582:  COMF   xA5,F
12584:  RLCF   xA5,F
12586:  MOVF   x9F,W
12588:  ANDLW  0F
1258A:  ADDWF  xA5,F
1258C:  RLCF   xA2,F
1258E:  MOVLW  07
12590:  MOVWF  xA1
12592:  MOVLW  0A
12594:  DECF   xA4,F
12596:  ADDWF  xA5,F
12598:  BNC   12594
1259A:  DECF   xA3,F
1259C:  ADDWF  xA4,F
1259E:  BNC   1259A
125A0:  DECF   xA2,F
125A2:  ADDWF  xA3,F
125A4:  BNC   125A0
125A6:  DECF   xA1,F
125A8:  ADDWF  xA2,F
125AA:  BNC   125A6
125AC:  MOVLW  08
125AE:  MOVWF  FEA
125B0:  MOVLW  A1
125B2:  MOVWF  FE9
125B4:  MOVLW  07
125B6:  ANDWF  xA6,W
125B8:  BCF    xA6.6
125BA:  MOVF   FED,F
125BC:  ANDWF  xA6,W
125BE:  BNZ   125CE
125C0:  BTFSC  xA6.4
125C2:  MOVF   FEE,F
125C4:  BTFSC  xA6.4
125C6:  BRA    125CE
125C8:  MOVLW  20
125CA:  MOVWF  00
125CC:  BRA    12610
125CE:  ADDWF  FE9,F
125D0:  MOVLW  00
125D2:  ADDWFC FEA,F
125D4:  MOVF   FE9,W
125D6:  SUBLW  A5
125D8:  BNZ   125E2
125DA:  MOVF   FEA,W
125DC:  SUBLW  08
125DE:  BNZ   125E2
125E0:  BSF    xA6.6
125E2:  MOVF   FEF,W
125E4:  MOVWF  00
125E6:  BNZ   125F8
125E8:  BTFSC  xA6.6
125EA:  BRA    125F8
125EC:  BTFSC  xA6.4
125EE:  BRA    1262C
125F0:  BTFSC  xA6.3
125F2:  BRA    125F8
125F4:  MOVLW  20
125F6:  BRA    1260E
125F8:  BTFSS  xA6.7
125FA:  BRA    12608
125FC:  MOVLW  2D
125FE:  MOVWF  00
12600:  MOVF   FED,W
12602:  BCF    xA6.6
12604:  BCF    xA6.7
12606:  BRA    12610
12608:  BSF    xA6.3
1260A:  BCF    xA6.4
1260C:  MOVLW  30
1260E:  ADDWF  00,F
12610:  MOVFF  FEA,8A0
12614:  MOVFF  FE9,89F
12618:  MOVFF  00,8DD
1261C:  MOVLB  0
1261E:  CALL   5078
12622:  MOVFF  8A0,FEA
12626:  MOVFF  89F,FE9
1262A:  MOVLB  8
1262C:  MOVF   FEE,W
1262E:  BTFSS  xA6.6
12630:  BRA    125D4
12632:  MOVLB  0
12634:  GOTO   1275A (RETURN)
*
12C5C:  ADDWF  FE8,W
12C5E:  CLRF   FF7
12C60:  RLCF   FF7,F
12C62:  ADDLW  7D
12C64:  MOVWF  FF6
12C66:  MOVLW  2C
12C68:  ADDWFC FF7,F
12C6A:  MOVLW  01
12C6C:  MOVWF  FF8
12C6E:  MOVWF  FFB
12C70:  TBLRD*-
12C72:  MOVF   FF5,W
12C74:  MOVWF  FFA
12C76:  TBLRD*
12C78:  MOVF   FF5,W
12C7A:  MOVWF  FF9
12C7C:  DATA CE,2A
12C7E:  DATA EE,2A
12C80:  DATA 0E,2B
12C82:  DATA 2E,2B
12C84:  DATA 4E,2B
12C86:  DATA 6E,2B
12C88:  DATA 8E,2B
*
140AA:  ADDWF  FE8,W
140AC:  CLRF   FF7
140AE:  RLCF   FF7,F
140B0:  ADDLW  CB
140B2:  MOVWF  FF6
140B4:  MOVLW  40
140B6:  ADDWFC FF7,F
140B8:  MOVLW  01
140BA:  MOVWF  FF8
140BC:  MOVWF  FFB
140BE:  TBLRD*-
140C0:  MOVF   FF5,W
140C2:  MOVWF  FFA
140C4:  TBLRD*
140C6:  MOVF   FF5,W
140C8:  MOVWF  FF9
140CA:  DATA DA,3F
140CC:  DATA 02,40
140CE:  DATA 22,40
140D0:  DATA 42,40
140D2:  DATA 62,40
140D4:  DATA 82,40
*
1F908:  TBLRD*+
1F90A:  MOVF   FF5,F
1F90C:  BZ    1F930
1F90E:  MOVFF  FF6,AA1
1F912:  MOVFF  FF7,AA2
1F916:  MOVFF  FF8,AA3
1F91A:  MOVF   FF5,W
1F91C:  BTFSS  F9E.4
1F91E:  BRA    1F91C
1F920:  MOVWF  FAD
1F922:  MOVFF  AA1,FF6
1F926:  MOVFF  AA2,FF7
1F92A:  MOVFF  AA3,FF8
1F92E:  BRA    1F908
1F930:  RETURN 0
1F932:  TBLRD*+
1F934:  MOVFF  FF6,AA2
1F938:  MOVFF  FF7,AA3
1F93C:  MOVFF  FF8,AA4
1F940:  MOVF   FF5,W
1F942:  BTFSS  F9E.4
1F944:  BRA    1F942
1F946:  MOVWF  FAD
1F948:  MOVFF  AA2,FF6
1F94C:  MOVFF  AA3,FF7
1F950:  MOVFF  AA4,FF8
1F954:  MOVLB  A
1F956:  DECFSZ xA1,F
1F958:  BRA    1F95C
1F95A:  BRA    1F960
1F95C:  MOVLB  0
1F95E:  BRA    1F932
1F960:  MOVLB  0
1F962:  RETURN 0
1F964:  MOVLB  A
1F966:  BTFSC  xA2.7
1F968:  BRA    1F98A
1F96A:  MOVLW  0F
1F96C:  MOVWF  00
1F96E:  SWAPF  xA1,W
1F970:  ANDWF  00,F
1F972:  MOVLW  0A
1F974:  SUBWF  00,W
1F976:  BC    1F97E
1F978:  MOVLW  30
1F97A:  ADDWF  00,F
1F97C:  BRA    1F982
1F97E:  MOVF   xA2,W
1F980:  ADDWF  00,F
1F982:  MOVF   00,W
1F984:  BTFSS  F9E.4
1F986:  BRA    1F984
1F988:  MOVWF  FAD
1F98A:  MOVLW  0F
1F98C:  ANDWF  xA1,F
1F98E:  MOVLW  0A
1F990:  SUBWF  xA1,W
1F992:  BC    1F998
1F994:  MOVLW  30
1F996:  BRA    1F99C
1F998:  BCF    xA2.7
1F99A:  MOVF   xA2,W
1F99C:  ADDWF  xA1,F
1F99E:  MOVF   xA1,W
1F9A0:  BTFSS  F9E.4
1F9A2:  BRA    1F9A0
1F9A4:  MOVWF  FAD
1F9A6:  MOVLB  0
1F9A8:  RETURN 0
1F9AA:  MOVLB  A
1F9AC:  MOVF   xA4,W
1F9AE:  CLRF   01
1F9B0:  SUBWF  xA3,W
1F9B2:  BC    1F9BA
1F9B4:  MOVFF  AA3,00
1F9B8:  BRA    1F9D2
1F9BA:  CLRF   00
1F9BC:  MOVLW  08
1F9BE:  MOVWF  xA5
1F9C0:  RLCF   xA3,F
1F9C2:  RLCF   00,F
1F9C4:  MOVF   xA4,W
1F9C6:  SUBWF  00,W
1F9C8:  BTFSC  FD8.0
1F9CA:  MOVWF  00
1F9CC:  RLCF   01,F
1F9CE:  DECFSZ xA5,F
1F9D0:  BRA    1F9C0
1F9D2:  MOVLB  0
1F9D4:  RETURN 0
1F9D6:  MOVF   01,W
1F9D8:  MOVFF  AA1,AA3
1F9DC:  MOVLW  64
1F9DE:  MOVLB  A
1F9E0:  MOVWF  xA4
1F9E2:  MOVLB  0
1F9E4:  RCALL  1F9AA
1F9E6:  MOVFF  00,AA1
1F9EA:  MOVF   01,W
1F9EC:  MOVLW  30
1F9EE:  BNZ   1FA00
1F9F0:  MOVLB  A
1F9F2:  BTFSS  xA2.1
1F9F4:  BRA    1FA12
1F9F6:  BTFSC  xA2.3
1F9F8:  BRA    1FA12
1F9FA:  BTFSC  xA2.4
1F9FC:  MOVLW  20
1F9FE:  BRA    1FA08
1FA00:  MOVLB  A
1FA02:  BCF    xA2.3
1FA04:  BCF    xA2.4
1FA06:  BSF    xA2.0
1FA08:  ADDWF  01,F
1FA0A:  MOVF   01,W
1FA0C:  BTFSS  F9E.4
1FA0E:  BRA    1FA0C
1FA10:  MOVWF  FAD
1FA12:  MOVFF  AA1,AA3
1FA16:  MOVLW  0A
1FA18:  MOVWF  xA4
1FA1A:  MOVLB  0
1FA1C:  RCALL  1F9AA
1FA1E:  MOVFF  00,AA1
1FA22:  MOVF   01,W
1FA24:  MOVLW  30
1FA26:  BNZ   1FA38
1FA28:  MOVLB  A
1FA2A:  BTFSC  xA2.3
1FA2C:  BRA    1FA44
1FA2E:  BTFSS  xA2.0
1FA30:  BRA    1FA44
1FA32:  BTFSC  xA2.4
1FA34:  MOVLW  20
1FA36:  MOVLB  0
1FA38:  ADDWF  01,F
1FA3A:  MOVF   01,W
1FA3C:  BTFSS  F9E.4
1FA3E:  BRA    1FA3C
1FA40:  MOVWF  FAD
1FA42:  MOVLB  A
1FA44:  MOVLW  30
1FA46:  ADDWF  xA1,F
1FA48:  MOVF   xA1,W
1FA4A:  BTFSS  F9E.4
1FA4C:  BRA    1FA4A
1FA4E:  MOVWF  FAD
1FA50:  MOVLB  0
1FA52:  RETURN 0
1FA54:  MOVF   FF2,W
1FA56:  MOVWF  03
1FA58:  BCF    FF2.7
1FA5A:  BSF    F7F.7
1FA5C:  BSF    F7F.2
1FA5E:  MOVLB  F
1FA60:  MOVLW  55
1FA62:  MOVWF  F7E
1FA64:  MOVLW  AA
1FA66:  MOVWF  F7E
1FA68:  BSF    F7F.1
1FA6A:  NOP   
1FA6C:  MOVF   03,W
1FA6E:  IORWF  FF2,F
1FA70:  MOVLB  0
1FA72:  RETURN 0
1FA74:  BCF    F7F.6
1FA76:  MOVF   FF6,W
1FA78:  ANDLW  7F
1FA7A:  MOVWF  00
1FA7C:  MOVLW  80
1FA7E:  ANDWF  FF6,F
1FA80:  TBLRD*-
1FA82:  MOVFF  AA1,01
1FA86:  TSTFSZ 00
1FA88:  BRA    1FA98
1FA8A:  MOVFF  FEE,FF5
1FA8E:  MOVF   01,F
1FA90:  BZ    1FA9A
1FA92:  TBLWT+*
1FA94:  DECF   01,F
1FA96:  BRA    1FA9E
1FA98:  DECF   00,F
1FA9A:  TBLRD+*
1FA9C:  TBLWT*
1FA9E:  MOVLW  7F
1FAA0:  ANDWF  FF6,W
1FAA2:  XORLW  7F
1FAA4:  BNZ   1FA86
1FAA6:  BSF    F7F.4
1FAA8:  RCALL  1FA54
1FAAA:  RCALL  1FA54
1FAAC:  TSTFSZ 01
1FAAE:  BRA    1FA86
1FAB0:  CLRF   FF8
1FAB2:  RETURN 0
1FAB4:  MOVFF  AA2,01
1FAB8:  MOVFF  AA1,00
1FABC:  TSTFSZ 00
1FABE:  INCF   01,F
1FAC0:  TBLRD*+
1FAC2:  MOVFF  FF5,FEE
1FAC6:  DECFSZ 00,F
1FAC8:  BRA    1FAC0
1FACA:  DECFSZ 01,F
1FACC:  BRA    1FAC0
1FACE:  CLRF   FF8
1FAD0:  RETURN 0
*
1FE64:  DATA 44,4E
1FE66:  DATA 0D,00
1FE68:  DATA 43,53
1FE6A:  DATA 0D,00
1FE6C:  DATA 57,52
1FE6E:  DATA 2C,20
1FE70:  DATA 30,78
1FE72:  DATA 25,6C
1FE74:  DATA 78,2C
1FE76:  DATA 20,25
1FE78:  DATA 75,2C
1FE7A:  DATA 20,00
1FE7C:  DATA 41,43
1FE7E:  DATA 4B,0D
1FE80:  DATA 00,00
1FE82:  DATA 4E,41
1FE84:  DATA 43,4B
1FE86:  DATA 0D,00
1FE88:  DATA 48,41
1FE8A:  DATA 2C,20
1FE8C:  DATA 30,78
1FE8E:  DATA 25,78
1FE90:  DATA 0D,00
1FE92:  DATA 0D,0A
1FE94:  DATA 40,46
1FE96:  DATA 57,55
1FE98:  DATA 0D,0A
1FE9A:  DATA 0A,00
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... //#ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... //#else 
....................    //#FUSES NOMCLR 
.................... //#endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... #FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... #FUSES WDT_SW   
.................... //#use delay(clock=2000000) 
....................  
.................... #FUSES NOWDT 
....................  
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
00588:  MOVLW  0A
0058A:  MOVWF  FEA
0058C:  MOVLW  A2
0058E:  MOVWF  FE9
00590:  MOVF   FEF,W
00592:  BZ    05B0
00594:  MOVLW  14
00596:  MOVWF  01
00598:  CLRF   00
0059A:  DECFSZ 00,F
0059C:  BRA    059A
0059E:  DECFSZ 01,F
005A0:  BRA    0598
005A2:  MOVLW  BF
005A4:  MOVWF  00
005A6:  DECFSZ 00,F
005A8:  BRA    05A6
005AA:  BRA    05AC
005AC:  DECFSZ FEF,F
005AE:  BRA    0594
005B0:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E62:  BTFSS  F9E.5
00E64:  BRA    0E62
00E66:  MOVFF  FAB,1C
00E6A:  MOVFF  FAE,01
00E6E:  BTFSS  1C.1
00E70:  BRA    0E76
00E72:  BCF    FAB.4
00E74:  BSF    FAB.4
00E76:  RETURN 0
*
0AE1E:  BTFSS  F9E.4
0AE20:  BRA    AE1E
0AE22:  MOVWF  FAD
0AE24:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
0F80A:  BTFSS  FA4.5
0F80C:  BRA    F80A
0F80E:  MOVLB  F
0F810:  MOVFF  F22,1C
0F814:  MOVFF  F1D,01
0F818:  BTFSS  1C.1
0F81A:  BRA    F820
0F81C:  BCF    x22.4
0F81E:  BSF    x22.4
0F820:  MOVLB  0
0F822:  GOTO   F870 (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F900:  BTFSS  F9E.4
1F902:  BRA    1F900
1F904:  MOVWF  FAD
1F906:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
*
1F80A:  MOVLB  A
1F80C:  CLRF   xA7
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F80E:  CLRF   xA8
1F810:  MOVF   xA8,W
1F812:  SUBLW  01
1F814:  BNC   1F868
....................    {  
....................       if (*s >= 'A')  
1F816:  MOVFF  AA6,03
1F81A:  MOVFF  AA5,FE9
1F81E:  MOVFF  AA6,FEA
1F822:  MOVF   FEF,W
1F824:  SUBLW  40
1F826:  BC    1F844
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F828:  MOVF   xA7,W
1F82A:  MULLW  10
1F82C:  MOVFF  FF3,AA9
1F830:  MOVFF  AA5,FE9
1F834:  MOVFF  AA6,FEA
1F838:  MOVF   FEF,W
1F83A:  ADDWF  xA9,W
1F83C:  ADDLW  BF
1F83E:  ADDLW  0A
1F840:  MOVWF  xA7
....................       }  
1F842:  BRA    1F85C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F844:  MOVF   xA7,W
1F846:  MULLW  10
1F848:  MOVFF  FF3,AA9
1F84C:  MOVFF  AA5,FE9
1F850:  MOVFF  AA6,FEA
1F854:  MOVF   FEF,W
1F856:  ADDWF  xA9,W
1F858:  ADDLW  D0
1F85A:  MOVWF  xA7
....................       }  
1F85C:  MOVF   xA8,W
1F85E:  INCF   xA8,F
1F860:  INCF   xA5,F
1F862:  BTFSC  FD8.2
1F864:  INCF   xA6,F
1F866:  BRA    1F810
....................    }  
....................  
....................    return(result);  
1F868:  MOVFF  AA7,01
1F86C:  MOVLB  0
1F86E:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
1F870:  MOVLB  A
1F872:  MOVF   xA5,F
1F874:  BZ    1F8F8
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1F876:  MOVFF  AA2,03
1F87A:  MOVFF  AA1,FE9
1F87E:  MOVFF  AA2,FEA
1F882:  MOVFF  FEF,AA6
1F886:  MOVFF  AA4,03
1F88A:  MOVFF  AA3,FE9
1F88E:  MOVFF  AA4,FEA
1F892:  MOVF   FEF,W
1F894:  SUBWF  xA6,W
1F896:  BZ    1F8C6
1F898:  MOVFF  AA2,03
1F89C:  MOVFF  AA1,FE9
1F8A0:  MOVFF  AA2,FEA
1F8A4:  MOVFF  FEF,AA6
1F8A8:  MOVFF  AA4,03
1F8AC:  MOVFF  AA3,FE9
1F8B0:  MOVFF  AA4,FEA
1F8B4:  MOVF   FEF,W
1F8B6:  SUBWF  xA6,W
1F8B8:  BC    1F8BE
1F8BA:  MOVLW  FF
1F8BC:  BRA    1F8C0
1F8BE:  MOVLW  01
1F8C0:  MOVWF  01
1F8C2:  BRA    1F8FC
1F8C4:  BRA    1F8DC
....................       else if (*s1 == '\0') return(0);  
1F8C6:  MOVFF  AA2,03
1F8CA:  MOVFF  AA1,FE9
1F8CE:  MOVFF  AA2,FEA
1F8D2:  MOVF   FEF,F
1F8D4:  BNZ   1F8DC
1F8D6:  MOVLW  00
1F8D8:  MOVWF  01
1F8DA:  BRA    1F8FC
1F8DC:  MOVFF  AA2,03
1F8E0:  MOVF   xA1,W
1F8E2:  INCF   xA1,F
1F8E4:  BTFSC  FD8.2
1F8E6:  INCF   xA2,F
1F8E8:  MOVFF  AA4,03
1F8EC:  MOVF   xA3,W
1F8EE:  INCF   xA3,F
1F8F0:  BTFSC  FD8.2
1F8F2:  INCF   xA4,F
1F8F4:  DECF   xA5,F
1F8F6:  BRA    1F872
....................    }  
....................    return(0);  
1F8F8:  MOVLW  00
1F8FA:  MOVWF  01
1F8FC:  MOVLB  0
1F8FE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
*
1FAD2:  MOVLB  A
1FAD4:  BCF    x32.1
1FAD6:  CLRF   x3C
1FAD8:  CLRF   x3B
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FADA:  BSF    F65.3
1FADC:  MOVLW  40
1FADE:  MOVWF  FAF
1FAE0:  MOVLW  03
1FAE2:  MOVWF  FD4
1FAE4:  MOVLW  A6
1FAE6:  MOVWF  FAC
1FAE8:  MOVLW  90
1FAEA:  MOVWF  FAB
....................    delay_ms(5); 
1FAEC:  MOVLW  05
1FAEE:  MOVWF  xA2
1FAF0:  MOVLB  0
1FAF2:  CALL   0588
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FAF6:  MOVLB  A
1FAF8:  BTFSC  x32.1
1FAFA:  BRA    1FE30
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FAFC:  CLRF   x38
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FAFE:  CLRF   03
1FB00:  MOVF   x38,W
1FB02:  ADDLW  61
1FB04:  MOVWF  FE9
1FB06:  MOVLW  0A
1FB08:  ADDWFC 03,W
1FB0A:  MOVWF  FEA
1FB0C:  BTFSS  F9E.5
1FB0E:  BRA    1FB0C
1FB10:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB14:  MOVF   x38,W
1FB16:  INCF   x38,F
1FB18:  CLRF   03
1FB1A:  ADDLW  61
1FB1C:  MOVWF  FE9
1FB1E:  MOVLW  0A
1FB20:  ADDWFC 03,W
1FB22:  MOVWF  FEA
1FB24:  MOVF   FEF,W
1FB26:  SUBLW  0D
1FB28:  BZ    1FB30
1FB2A:  MOVF   x38,W
1FB2C:  SUBLW  40
1FB2E:  BC    1FAFE
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB30:  MOVLW  13
1FB32:  MOVLB  0
1FB34:  RCALL  1F900
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB36:  MOVLB  A
1FB38:  BSF    x32.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB3A:  MOVF   x61,W
1FB3C:  SUBLW  3A
1FB3E:  BTFSS  FD8.2
1FB40:  BRA    1FE1A
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB42:  MOVLW  0A
1FB44:  MOVWF  xA6
1FB46:  MOVLW  62
1FB48:  MOVWF  xA5
1FB4A:  MOVLB  0
1FB4C:  RCALL  1F80A
1FB4E:  MOVFF  01,A37
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB52:  MOVLW  0A
1FB54:  MOVLB  A
1FB56:  MOVWF  xA6
1FB58:  MOVLW  64
1FB5A:  MOVWF  xA5
1FB5C:  MOVLB  0
1FB5E:  RCALL  1F80A
1FB60:  MOVFF  01,AA1
1FB64:  MOVLW  0A
1FB66:  MOVLB  A
1FB68:  MOVWF  xA6
1FB6A:  MOVLW  66
1FB6C:  MOVWF  xA5
1FB6E:  MOVLB  0
1FB70:  RCALL  1F80A
1FB72:  MOVFF  AA1,A3A
1FB76:  MOVFF  01,A39
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FB7A:  MOVLW  0A
1FB7C:  MOVLB  A
1FB7E:  MOVWF  xA6
1FB80:  MOVLW  68
1FB82:  MOVWF  xA5
1FB84:  MOVLB  0
1FB86:  RCALL  1F80A
1FB88:  MOVFF  01,A34
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FB8C:  MOVFF  A3B,A3F
1FB90:  MOVFF  A3C,A40
1FB94:  MOVFF  A39,A3D
1FB98:  MOVFF  A3A,A3E
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FB9C:  MOVLB  A
1FB9E:  DECFSZ x34,W
1FBA0:  BRA    1FBBA
....................          {  
....................             done = TRUE;  
1FBA2:  BSF    x32.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBA4:  MOVLW  64
1FBA6:  MOVWF  FF6
1FBA8:  MOVLW  FE
1FBAA:  MOVWF  FF7
1FBAC:  MOVLW  01
1FBAE:  MOVWF  FF8
1FBB0:  MOVLB  0
1FBB2:  RCALL  1F908
....................             do_ACKLOD = FALSE;  
1FBB4:  MOVLB  A
1FBB6:  BCF    x32.0
....................          }  
1FBB8:  BRA    1FE1A
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBBA:  MOVF   x40,F
1FBBC:  BNZ   1FBCC
1FBBE:  MOVF   x3F,W
1FBC0:  SUBLW  01
1FBC2:  BNC   1FBCC
1FBC4:  BNZ   1FBD8
1FBC6:  MOVF   x3E,W
1FBC8:  SUBLW  F7
1FBCA:  BC    1FBD8
1FBCC:  MOVF   x40,F
1FBCE:  BNZ   1FBD8
1FBD0:  MOVF   x3F,W
1FBD2:  SUBLW  01
1FBD4:  BTFSC  FD8.0
1FBD6:  BRA    1FE1A
1FBD8:  MOVF   x40,F
1FBDA:  BTFSS  FD8.2
1FBDC:  BRA    1FE1A
1FBDE:  MOVF   x3F,W
1FBE0:  SUBLW  2F
1FBE2:  BTFSS  FD8.0
1FBE4:  BRA    1FE1A
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FBE6:  CLRF   x33
....................             for (i=1; i<(buffidx-3); i+=2)  
1FBE8:  MOVLW  01
1FBEA:  MOVWF  x36
1FBEC:  MOVLW  03
1FBEE:  SUBWF  x38,W
1FBF0:  SUBWF  x36,W
1FBF2:  BC    1FC20
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FBF4:  CLRF   03
1FBF6:  MOVF   x36,W
1FBF8:  ADDLW  61
1FBFA:  MOVWF  01
1FBFC:  MOVLW  0A
1FBFE:  ADDWFC 03,F
1FC00:  MOVFF  01,AA1
1FC04:  MOVFF  03,AA2
1FC08:  MOVFF  03,AA6
1FC0C:  MOVFF  01,AA5
1FC10:  MOVLB  0
1FC12:  RCALL  1F80A
1FC14:  MOVF   01,W
1FC16:  MOVLB  A
1FC18:  ADDWF  x33,F
1FC1A:  MOVLW  02
1FC1C:  ADDWF  x36,F
1FC1E:  BRA    1FBEC
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC20:  MOVLW  FF
1FC22:  BSF    FD8.0
1FC24:  SUBFWB x33,W
1FC26:  ADDLW  01
1FC28:  MOVWF  x33
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC2A:  MOVLW  03
1FC2C:  SUBWF  x38,W
1FC2E:  CLRF   03
1FC30:  ADDLW  61
1FC32:  MOVWF  01
1FC34:  MOVLW  0A
1FC36:  ADDWFC 03,F
1FC38:  MOVFF  01,AA1
1FC3C:  MOVFF  03,AA2
1FC40:  MOVFF  03,AA6
1FC44:  MOVFF  01,AA5
1FC48:  MOVLB  0
1FC4A:  RCALL  1F80A
1FC4C:  MOVF   01,W
1FC4E:  MOVLB  A
1FC50:  SUBWF  x33,W
1FC52:  BZ    1FC6A
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC54:  MOVLW  68
1FC56:  MOVWF  FF6
1FC58:  MOVLW  FE
1FC5A:  MOVWF  FF7
1FC5C:  MOVLW  01
1FC5E:  MOVWF  FF8
1FC60:  MOVLB  0
1FC62:  RCALL  1F908
....................                do_ACKLOD = FALSE;  
1FC64:  MOVLB  A
1FC66:  BCF    x32.0
....................             }  
1FC68:  BRA    1FE1A
....................             else  
....................             {  
....................                if (line_type == 0)  
1FC6A:  MOVF   x34,F
1FC6C:  BTFSS  FD8.2
1FC6E:  BRA    1FDBE
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FC70:  MOVLW  09
1FC72:  MOVWF  x36
1FC74:  CLRF   x35
1FC76:  MOVLW  03
1FC78:  SUBWF  x38,W
1FC7A:  SUBWF  x36,W
1FC7C:  BC    1FCC8
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FC7E:  MOVF   x35,W
1FC80:  INCF   x35,F
1FC82:  CLRF   03
1FC84:  ADDLW  41
1FC86:  MOVWF  01
1FC88:  MOVLW  0A
1FC8A:  ADDWFC 03,F
1FC8C:  MOVFF  01,AA1
1FC90:  MOVFF  03,AA2
1FC94:  CLRF   03
1FC96:  MOVF   x36,W
1FC98:  ADDLW  61
1FC9A:  MOVWF  01
1FC9C:  MOVLW  0A
1FC9E:  ADDWFC 03,F
1FCA0:  MOVFF  01,AA3
1FCA4:  MOVFF  03,AA4
1FCA8:  MOVFF  03,AA6
1FCAC:  MOVFF  01,AA5
1FCB0:  MOVLB  0
1FCB2:  RCALL  1F80A
1FCB4:  MOVFF  AA2,FEA
1FCB8:  MOVFF  AA1,FE9
1FCBC:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCC0:  MOVLW  02
1FCC2:  MOVLB  A
1FCC4:  ADDWF  x36,F
1FCC6:  BRA    1FC76
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FCC8:  MOVLW  6C
1FCCA:  MOVWF  FF6
1FCCC:  MOVLW  FE
1FCCE:  MOVWF  FF7
1FCD0:  MOVLW  01
1FCD2:  MOVWF  FF8
1FCD4:  MOVLW  06
1FCD6:  MOVWF  xA1
1FCD8:  MOVLB  0
1FCDA:  RCALL  1F932
1FCDC:  MOVFF  A40,AA1
1FCE0:  MOVLW  57
1FCE2:  MOVLB  A
1FCE4:  MOVWF  xA2
1FCE6:  MOVLB  0
1FCE8:  RCALL  1F964
1FCEA:  MOVFF  A3F,AA1
1FCEE:  MOVLW  57
1FCF0:  MOVLB  A
1FCF2:  MOVWF  xA2
1FCF4:  MOVLB  0
1FCF6:  RCALL  1F964
1FCF8:  MOVFF  A3E,AA1
1FCFC:  MOVLW  57
1FCFE:  MOVLB  A
1FD00:  MOVWF  xA2
1FD02:  MOVLB  0
1FD04:  RCALL  1F964
1FD06:  MOVFF  A3D,AA1
1FD0A:  MOVLW  57
1FD0C:  MOVLB  A
1FD0E:  MOVWF  xA2
1FD10:  MOVLB  0
1FD12:  RCALL  1F964
1FD14:  MOVLW  2C
1FD16:  BTFSS  F9E.4
1FD18:  BRA    1FD16
1FD1A:  MOVWF  FAD
1FD1C:  MOVLW  20
1FD1E:  BTFSS  F9E.4
1FD20:  BRA    1FD1E
1FD22:  MOVWF  FAD
1FD24:  MOVFF  A37,AA1
1FD28:  MOVLW  1B
1FD2A:  MOVLB  A
1FD2C:  MOVWF  xA2
1FD2E:  MOVLB  0
1FD30:  RCALL  1F9D6
1FD32:  MOVLW  2C
1FD34:  BTFSS  F9E.4
1FD36:  BRA    1FD34
1FD38:  MOVWF  FAD
1FD3A:  MOVLW  20
1FD3C:  BTFSS  F9E.4
1FD3E:  BRA    1FD3C
1FD40:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD42:  MOVFF  A3F,FF8
1FD46:  MOVFF  A3E,FF7
1FD4A:  MOVFF  A3D,FF6
1FD4E:  MOVLW  0A
1FD50:  MOVWF  FEA
1FD52:  MOVLW  41
1FD54:  MOVWF  FE9
1FD56:  MOVFF  A37,AA1
1FD5A:  RCALL  1FA74
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD5C:  MOVFF  A3F,FF8
1FD60:  MOVFF  A3E,FF7
1FD64:  MOVFF  A3D,FF6
1FD68:  MOVLW  0A
1FD6A:  MOVWF  FEA
1FD6C:  MOVLW  61
1FD6E:  MOVWF  FE9
1FD70:  MOVLB  A
1FD72:  CLRF   xA2
1FD74:  MOVFF  A37,AA1
1FD78:  MOVLB  0
1FD7A:  RCALL  1FAB4
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FD7C:  MOVLW  0A
1FD7E:  MOVLB  A
1FD80:  MOVWF  xA2
1FD82:  MOVLW  41
1FD84:  MOVWF  xA1
1FD86:  MOVLW  0A
1FD88:  MOVWF  xA4
1FD8A:  MOVLW  61
1FD8C:  MOVWF  xA3
1FD8E:  MOVFF  A37,AA5
1FD92:  MOVLB  0
1FD94:  RCALL  1F870
1FD96:  MOVF   01,F
1FD98:  BNZ   1FDAA
1FD9A:  MOVLW  7C
1FD9C:  MOVWF  FF6
1FD9E:  MOVLW  FE
1FDA0:  MOVWF  FF7
1FDA2:  MOVLW  01
1FDA4:  MOVWF  FF8
1FDA6:  RCALL  1F908
1FDA8:  BRA    1FDB8
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDAA:  MOVLW  82
1FDAC:  MOVWF  FF6
1FDAE:  MOVLW  FE
1FDB0:  MOVWF  FF7
1FDB2:  MOVLW  01
1FDB4:  MOVWF  FF8
1FDB6:  RCALL  1F908
....................                   do_ACKLOD = FALSE;  
1FDB8:  MOVLB  A
1FDBA:  BCF    x32.0
....................                }  
1FDBC:  BRA    1FE1A
....................                else if (line_type == 4)  
1FDBE:  MOVF   x34,W
1FDC0:  SUBLW  04
1FDC2:  BNZ   1FE1A
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDC4:  MOVLW  0A
1FDC6:  MOVWF  xA6
1FDC8:  MOVLW  6A
1FDCA:  MOVWF  xA5
1FDCC:  MOVLB  0
1FDCE:  RCALL  1F80A
1FDD0:  MOVFF  01,AA1
1FDD4:  MOVLW  0A
1FDD6:  MOVLB  A
1FDD8:  MOVWF  xA6
1FDDA:  MOVLW  6C
1FDDC:  MOVWF  xA5
1FDDE:  MOVLB  0
1FDE0:  RCALL  1F80A
1FDE2:  MOVFF  AA1,A3C
1FDE6:  MOVFF  01,A3B
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FDEA:  MOVLW  88
1FDEC:  MOVWF  FF6
1FDEE:  MOVLW  FE
1FDF0:  MOVWF  FF7
1FDF2:  MOVLW  01
1FDF4:  MOVWF  FF8
1FDF6:  MOVLW  06
1FDF8:  MOVLB  A
1FDFA:  MOVWF  xA1
1FDFC:  MOVLB  0
1FDFE:  RCALL  1F932
1FE00:  MOVFF  A3B,AA1
1FE04:  MOVLW  57
1FE06:  MOVLB  A
1FE08:  MOVWF  xA2
1FE0A:  MOVLB  0
1FE0C:  RCALL  1F964
1FE0E:  MOVLW  0D
1FE10:  BTFSS  F9E.4
1FE12:  BRA    1FE10
1FE14:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE16:  MOVLB  A
1FE18:  BCF    x32.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE1A:  BTFSS  x32.0
1FE1C:  BRA    1FE26
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE1E:  MOVLW  06
1FE20:  MOVLB  0
1FE22:  RCALL  1F900
1FE24:  MOVLB  A
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE26:  MOVLW  11
1FE28:  MOVLB  0
1FE2A:  RCALL  1F900
1FE2C:  BRA    1FAF6
1FE2E:  MOVLB  A
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE30:  MOVLW  06
1FE32:  MOVLB  0
1FE34:  RCALL  1F900
....................    fputc(XON, LOADER_STRM);  
1FE36:  MOVLW  11
1FE38:  RCALL  1F900
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE3A:  MOVLW  92
1FE3C:  MOVWF  FF6
1FE3E:  MOVLW  FE
1FE40:  MOVWF  FF7
1FE42:  MOVLW  01
1FE44:  MOVWF  FF8
1FE46:  RCALL  1F908
....................    delay_ms(4000); 
1FE48:  MOVLW  10
1FE4A:  MOVLB  A
1FE4C:  MOVWF  xA1
1FE4E:  MOVLW  FA
1FE50:  MOVWF  xA2
1FE52:  MOVLB  0
1FE54:  CALL   0588
1FE58:  MOVLB  A
1FE5A:  DECFSZ xA1,F
1FE5C:  BRA    1FE4E
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE5E:  RESET
1FE60:  MOVLB  0
1FE62:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FAD2
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... int16 valve_align_timeout = -1; 
.................... int16 valve_align_counter = -1; 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
0552A:  BCF    FF2.5
....................    restart_wdt(); 
0552C:  CLRWDT
0552E:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
05530:  CLRF   FCF
05532:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
05534:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
05536:  MOVF   2F,W
05538:  SUBLW  02
0553A:  BNZ   5542
0553C:  MOVF   30,F
0553E:  BNZ   5542
05540:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
05542:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
05544:  BSF    F9D.0
05546:  GOTO   555A (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
0554A:  MOVLW  0B
0554C:  MOVWF  FD7
0554E:  MOVLW  DC
05550:  MOVWF  FD6
....................    restart_wdt(); 
05552:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
05554:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
05556:  BSF    FF2.5
....................    setup_led_pulse(); 
05558:  BRA    5530
0555A:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
0555C:  MOVLB  8
0555E:  MOVF   xCB,W
05560:  XORLW  00
05562:  MOVLB  0
05564:  BZ    556C
05566:  XORLW  01
05568:  BZ    5570
0556A:  BRA    5572
....................       case 0 : suspend_heartbeat(); 
0556C:  RCALL  552A
....................          break; 
0556E:  BRA    5572
....................       case 1 : restart_heartbeat(); 
05570:  RCALL  554A
....................          break; 
....................    } 
05572:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
030D8:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
030DA:  BCF    FD1.0
030DC:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
02906:  MOVLW  0B
02908:  MOVWF  FD7
0290A:  MOVLW  DC
0290C:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
0290E:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
02910:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
02912:  BSF    FD1.0
02914:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
078AE:  MOVFF  98F,995
078B2:  MOVFF  98E,994
078B6:  MOVLB  9
078B8:  MOVF   x92,F
078BA:  BNZ   78C0
078BC:  MOVF   x93,F
078BE:  BZ    790A
078C0:  MOVFF  991,03
078C4:  MOVFF  990,FE9
078C8:  MOVFF  991,FEA
078CC:  MOVF   FEF,F
078CE:  BZ    790A
....................      *s++ = *s2++; 
078D0:  MOVFF  995,997
078D4:  MOVF   x94,W
078D6:  INCF   x94,F
078D8:  BTFSC  FD8.2
078DA:  INCF   x95,F
078DC:  MOVWF  x96
078DE:  MOVFF  991,03
078E2:  MOVF   x90,W
078E4:  INCF   x90,F
078E6:  BTFSC  FD8.2
078E8:  INCF   x91,F
078EA:  MOVWF  FE9
078EC:  MOVFF  03,FEA
078F0:  MOVFF  FEF,998
078F4:  MOVFF  997,FEA
078F8:  MOVFF  996,FE9
078FC:  MOVFF  998,FEF
07900:  MOVF   x92,W
07902:  BTFSC  FD8.2
07904:  DECF   x93,F
07906:  DECF   x92,F
07908:  BRA    78B8
....................   for (; n > 0; n--) 
0790A:  MOVF   x92,F
0790C:  BNZ   7912
0790E:  MOVF   x93,F
07910:  BZ    7930
....................      *s++ = '\0'; 
07912:  MOVFF  995,03
07916:  MOVF   x94,W
07918:  INCF   x94,F
0791A:  BTFSC  FD8.2
0791C:  INCF   x95,F
0791E:  MOVWF  FE9
07920:  MOVFF  03,FEA
07924:  CLRF   FEF
07926:  MOVF   x92,W
07928:  BTFSC  FD8.2
0792A:  DECF   x93,F
0792C:  DECF   x92,F
0792E:  BRA    790A
....................  
....................   return(s1); 
07930:  MOVFF  98E,01
07934:  MOVFF  98F,02
07938:  MOVLB  0
0793A:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
054B8:  MOVFF  8D7,8DB
054BC:  MOVFF  8D6,8DA
054C0:  MOVFF  8DB,03
054C4:  MOVLB  8
054C6:  MOVFF  8DA,FE9
054CA:  MOVFF  8DB,FEA
054CE:  MOVF   FEF,F
054D0:  BZ    54DE
054D2:  INCF   xDA,F
054D4:  BTFSC  FD8.2
054D6:  INCF   xDB,F
054D8:  MOVLB  0
054DA:  BRA    54C0
054DC:  MOVLB  8
....................    while(*s2 != '\0') 
054DE:  MOVFF  8D9,03
054E2:  MOVFF  8D8,FE9
054E6:  MOVFF  8D9,FEA
054EA:  MOVF   FEF,F
054EC:  BZ    5514
....................    { 
....................       *s = *s2; 
054EE:  MOVFF  8D8,FE9
054F2:  MOVFF  8D9,FEA
054F6:  MOVFF  FEF,8DE
054FA:  MOVFF  8DB,FEA
054FE:  MOVFF  8DA,FE9
05502:  MOVFF  8DE,FEF
....................       ++s; 
05506:  INCF   xDA,F
05508:  BTFSC  FD8.2
0550A:  INCF   xDB,F
....................       ++s2; 
0550C:  INCF   xD8,F
0550E:  BTFSC  FD8.2
05510:  INCF   xD9,F
05512:  BRA    54DE
....................    } 
....................  
....................    *s = '\0'; 
05514:  MOVFF  8DA,FE9
05518:  MOVFF  8DB,FEA
0551C:  CLRF   FEF
....................    return(s1); 
0551E:  MOVFF  8D6,01
05522:  MOVFF  8D7,02
05526:  MOVLB  0
05528:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0F786:  MOVFF  8CC,8D2
0F78A:  MOVFF  8CB,8D1
0F78E:  MOVFF  8D2,03
0F792:  MOVLB  8
0F794:  MOVFF  8D1,FE9
0F798:  MOVFF  8D2,FEA
0F79C:  MOVF   FEF,F
0F79E:  BZ    F7AC
0F7A0:  INCF   xD1,F
0F7A2:  BTFSC  FD8.2
0F7A4:  INCF   xD2,F
0F7A6:  MOVLB  0
0F7A8:  BRA    F78E
0F7AA:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
0F7AC:  MOVFF  8CE,03
0F7B0:  MOVFF  8CD,FE9
0F7B4:  MOVFF  8CE,FEA
0F7B8:  MOVF   FEF,F
0F7BA:  BZ    F7F4
0F7BC:  MOVF   xD0,F
0F7BE:  BNZ   F7C6
0F7C0:  MOVF   xCF,W
0F7C2:  SUBLW  00
0F7C4:  BC    F7F4
....................    { 
....................       *s = *s2; 
0F7C6:  MOVFF  8CD,FE9
0F7CA:  MOVFF  8CE,FEA
0F7CE:  MOVFF  FEF,8D5
0F7D2:  MOVFF  8D2,FEA
0F7D6:  MOVFF  8D1,FE9
0F7DA:  MOVFF  8D5,FEF
....................       ++s; 
0F7DE:  INCF   xD1,F
0F7E0:  BTFSC  FD8.2
0F7E2:  INCF   xD2,F
....................       ++s2; 
0F7E4:  INCF   xCD,F
0F7E6:  BTFSC  FD8.2
0F7E8:  INCF   xCE,F
....................       --n; 
0F7EA:  MOVF   xCF,W
0F7EC:  BTFSC  FD8.2
0F7EE:  DECF   xD0,F
0F7F0:  DECF   xCF,F
0F7F2:  BRA    F7AC
....................    } 
....................  
....................    *s = '\0'; 
0F7F4:  MOVFF  8D1,FE9
0F7F8:  MOVFF  8D2,FEA
0F7FC:  CLRF   FEF
....................    return(s1); 
0F7FE:  MOVFF  8CB,01
0F802:  MOVFF  8CC,02
0F806:  MOVLB  0
0F808:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
045F2:  MOVFF  9C8,9CE
045F6:  MOVFF  9C7,9CD
045FA:  MOVFF  9CA,9D0
045FE:  MOVFF  9C9,9CF
04602:  MOVLB  9
04604:  MOVF   xCC,F
04606:  BNZ   460E
04608:  MOVF   xCB,W
0460A:  SUBLW  00
0460C:  BC    466E
.................... { 
....................    if(*su1!=*su2) 
0460E:  MOVFF  9CD,FE9
04612:  MOVFF  9CE,FEA
04616:  MOVFF  FEF,9D1
0461A:  MOVFF  9D0,03
0461E:  MOVFF  9CF,FE9
04622:  MOVFF  9D0,FEA
04626:  MOVF   FEF,W
04628:  SUBWF  xD1,W
0462A:  BZ    4658
....................       return ((*su1<*su2)?-1:1); 
0462C:  MOVFF  9CE,03
04630:  MOVFF  9CD,FE9
04634:  MOVFF  03,FEA
04638:  MOVFF  FEF,9D1
0463C:  MOVFF  9D0,03
04640:  MOVFF  9CF,FE9
04644:  MOVFF  9D0,FEA
04648:  MOVF   FEF,W
0464A:  SUBWF  xD1,W
0464C:  BC    4652
0464E:  MOVLW  FF
04650:  BRA    4654
04652:  MOVLW  01
04654:  MOVWF  01
04656:  BRA    4672
04658:  INCF   xCD,F
0465A:  BTFSC  FD8.2
0465C:  INCF   xCE,F
0465E:  INCF   xCF,F
04660:  BTFSC  FD8.2
04662:  INCF   xD0,F
04664:  MOVF   xCB,W
04666:  BTFSC  FD8.2
04668:  DECF   xCC,F
0466A:  DECF   xCB,F
0466C:  BRA    4604
.................... } 
.................... return 0; 
0466E:  MOVLW  00
04670:  MOVWF  01
04672:  MOVLB  0
04674:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0F74A:  MOVFF  8CA,8CC
0F74E:  MOVFF  8C9,8CB
0F752:  MOVFF  8CC,03
0F756:  MOVLB  8
0F758:  MOVFF  8CB,FE9
0F75C:  MOVFF  8CC,FEA
0F760:  MOVF   FEF,F
0F762:  BZ    F770
0F764:  INCF   xCB,F
0F766:  BTFSC  FD8.2
0F768:  INCF   xCC,F
0F76A:  MOVLB  0
0F76C:  BRA    F752
0F76E:  MOVLB  8
....................    return(sc - s); 
0F770:  MOVF   xC9,W
0F772:  SUBWF  xCB,W
0F774:  MOVWF  00
0F776:  MOVF   xCA,W
0F778:  SUBWFB xCC,W
0F77A:  MOVWF  03
0F77C:  MOVFF  00,01
0F780:  MOVWF  02
0F782:  MOVLB  0
0F784:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
10000:  MOVLB  8
10002:  CLRF   xB8
....................    sign = 0; 
10004:  CLRF   xB6
....................    base = 10; 
10006:  MOVLW  0A
10008:  MOVWF  xB7
....................    result = 0; 
1000A:  CLRF   xB5
1000C:  CLRF   xB4
....................  
....................    if (!s) 
1000E:  MOVF   xB2,W
10010:  IORWF  xB3,W
10012:  BTFSS  FD8.2
10014:  GOTO   10022
....................       return 0; 
10018:  MOVLW  00
1001A:  MOVWF  01
1001C:  MOVWF  02
1001E:  GOTO   1024A
....................    c = s[index++]; 
10022:  MOVF   xB8,W
10024:  INCF   xB8,F
10026:  ADDWF  xB2,W
10028:  MOVWF  FE9
1002A:  MOVLW  00
1002C:  ADDWFC xB3,W
1002E:  MOVWF  FEA
10030:  MOVFF  FEF,8B9
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
10034:  MOVF   xB9,W
10036:  SUBLW  2D
10038:  BTFSS  FD8.2
1003A:  GOTO   10058
....................    { 
....................       sign = 1;         // Set the sign to negative 
1003E:  MOVLW  01
10040:  MOVWF  xB6
....................       c = s[index++]; 
10042:  MOVF   xB8,W
10044:  INCF   xB8,F
10046:  ADDWF  xB2,W
10048:  MOVWF  FE9
1004A:  MOVLW  00
1004C:  ADDWFC xB3,W
1004E:  MOVWF  FEA
10050:  MOVFF  FEF,8B9
....................    } 
10054:  GOTO   10074
....................    else if (c == '+') 
10058:  MOVF   xB9,W
1005A:  SUBLW  2B
1005C:  BTFSS  FD8.2
1005E:  GOTO   10074
....................    { 
....................       c = s[index++]; 
10062:  MOVF   xB8,W
10064:  INCF   xB8,F
10066:  ADDWF  xB2,W
10068:  MOVWF  FE9
1006A:  MOVLW  00
1006C:  ADDWFC xB3,W
1006E:  MOVWF  FEA
10070:  MOVFF  FEF,8B9
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
10074:  MOVF   xB9,W
10076:  SUBLW  2F
10078:  BTFSC  FD8.0
1007A:  GOTO   10228
1007E:  MOVF   xB9,W
10080:  SUBLW  39
10082:  BTFSS  FD8.0
10084:  GOTO   10228
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
10088:  MOVF   xB9,W
1008A:  SUBLW  30
1008C:  BTFSS  FD8.2
1008E:  GOTO   100D6
10092:  MOVF   xB8,W
10094:  ADDWF  xB2,W
10096:  MOVWF  FE9
10098:  MOVLW  00
1009A:  ADDWFC xB3,W
1009C:  MOVWF  FEA
1009E:  MOVF   FEF,W
100A0:  SUBLW  78
100A2:  BTFSC  FD8.2
100A4:  GOTO   100BE
100A8:  MOVF   xB8,W
100AA:  ADDWF  xB2,W
100AC:  MOVWF  FE9
100AE:  MOVLW  00
100B0:  ADDWFC xB3,W
100B2:  MOVWF  FEA
100B4:  MOVF   FEF,W
100B6:  SUBLW  58
100B8:  BTFSS  FD8.2
100BA:  GOTO   100D6
....................       { 
....................          base = 16; 
100BE:  MOVLW  10
100C0:  MOVWF  xB7
....................          index++; 
100C2:  INCF   xB8,F
....................          c = s[index++]; 
100C4:  MOVF   xB8,W
100C6:  INCF   xB8,F
100C8:  ADDWF  xB2,W
100CA:  MOVWF  FE9
100CC:  MOVLW  00
100CE:  ADDWFC xB3,W
100D0:  MOVWF  FEA
100D2:  MOVFF  FEF,8B9
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
100D6:  MOVF   xB7,W
100D8:  SUBLW  0A
100DA:  BTFSS  FD8.2
100DC:  GOTO   1013A
....................       { 
....................          while (c >= '0' && c <= '9') 
100E0:  MOVF   xB9,W
100E2:  SUBLW  2F
100E4:  BTFSC  FD8.0
100E6:  GOTO   10136
100EA:  MOVF   xB9,W
100EC:  SUBLW  39
100EE:  BTFSS  FD8.0
100F0:  GOTO   10136
....................          { 
....................             result = 10*result + (c - '0'); 
100F4:  CLRF   xBB
100F6:  MOVLW  0A
100F8:  MOVWF  xBA
100FA:  MOVFF  8B5,8BD
100FE:  MOVFF  8B4,8BC
10102:  MOVLB  0
10104:  GOTO   FE3E
10108:  MOVFF  02,8BB
1010C:  MOVFF  01,8BA
10110:  MOVLW  30
10112:  MOVLB  8
10114:  SUBWF  xB9,W
10116:  ADDWF  xBA,W
10118:  MOVWF  xB4
1011A:  MOVLW  00
1011C:  ADDWFC xBB,W
1011E:  MOVWF  xB5
....................             c = s[index++]; 
10120:  MOVF   xB8,W
10122:  INCF   xB8,F
10124:  ADDWF  xB2,W
10126:  MOVWF  FE9
10128:  MOVLW  00
1012A:  ADDWFC xB3,W
1012C:  MOVWF  FEA
1012E:  MOVFF  FEF,8B9
10132:  GOTO   100E0
....................          } 
....................       } 
10136:  GOTO   10228
....................       else if (base == 16)    // The number is a hexa number 
1013A:  MOVF   xB7,W
1013C:  SUBLW  10
1013E:  BTFSS  FD8.2
10140:  GOTO   10228
....................       { 
....................          c = toupper(c); 
10144:  MOVF   xB9,W
10146:  SUBLW  60
10148:  BTFSC  FD8.0
1014A:  GOTO   10160
1014E:  MOVF   xB9,W
10150:  SUBLW  7A
10152:  BTFSS  FD8.0
10154:  GOTO   10160
10158:  MOVF   xB9,W
1015A:  ANDLW  DF
1015C:  GOTO   10162
10160:  MOVF   xB9,W
10162:  MOVWF  xB9
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
10164:  MOVF   xB9,W
10166:  SUBLW  2F
10168:  BTFSC  FD8.0
1016A:  GOTO   10178
1016E:  MOVF   xB9,W
10170:  SUBLW  39
10172:  BTFSC  FD8.0
10174:  GOTO   1018C
10178:  MOVF   xB9,W
1017A:  SUBLW  40
1017C:  BTFSC  FD8.0
1017E:  GOTO   10228
10182:  MOVF   xB9,W
10184:  SUBLW  46
10186:  BTFSS  FD8.0
10188:  GOTO   10228
....................          { 
....................             if (c >= '0' && c <= '9') 
1018C:  MOVF   xB9,W
1018E:  SUBLW  2F
10190:  BTFSC  FD8.0
10192:  GOTO   101CA
10196:  MOVF   xB9,W
10198:  SUBLW  39
1019A:  BTFSS  FD8.0
1019C:  GOTO   101CA
....................                result = (result << 4) + (c - '0'); 
101A0:  RLCF   xB4,W
101A2:  MOVWF  xBA
101A4:  RLCF   xB5,W
101A6:  MOVWF  xBB
101A8:  RLCF   xBA,F
101AA:  RLCF   xBB,F
101AC:  RLCF   xBA,F
101AE:  RLCF   xBB,F
101B0:  RLCF   xBA,F
101B2:  RLCF   xBB,F
101B4:  MOVLW  F0
101B6:  ANDWF  xBA,F
101B8:  MOVLW  30
101BA:  SUBWF  xB9,W
101BC:  ADDWF  xBA,W
101BE:  MOVWF  xB4
101C0:  MOVLW  00
101C2:  ADDWFC xBB,W
101C4:  MOVWF  xB5
101C6:  GOTO   101F2
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
101CA:  RLCF   xB4,W
101CC:  MOVWF  xBA
101CE:  RLCF   xB5,W
101D0:  MOVWF  xBB
101D2:  RLCF   xBA,F
101D4:  RLCF   xBB,F
101D6:  RLCF   xBA,F
101D8:  RLCF   xBB,F
101DA:  RLCF   xBA,F
101DC:  RLCF   xBB,F
101DE:  MOVLW  F0
101E0:  ANDWF  xBA,F
101E2:  MOVLW  41
101E4:  SUBWF  xB9,W
101E6:  ADDLW  0A
101E8:  ADDWF  xBA,W
101EA:  MOVWF  xB4
101EC:  MOVLW  00
101EE:  ADDWFC xBB,W
101F0:  MOVWF  xB5
....................  
....................             c = s[index++];c = toupper(c); 
101F2:  MOVF   xB8,W
101F4:  INCF   xB8,F
101F6:  ADDWF  xB2,W
101F8:  MOVWF  FE9
101FA:  MOVLW  00
101FC:  ADDWFC xB3,W
101FE:  MOVWF  FEA
10200:  MOVFF  FEF,8B9
10204:  MOVF   xB9,W
10206:  SUBLW  60
10208:  BTFSC  FD8.0
1020A:  GOTO   10220
1020E:  MOVF   xB9,W
10210:  SUBLW  7A
10212:  BTFSS  FD8.0
10214:  GOTO   10220
10218:  MOVF   xB9,W
1021A:  ANDLW  DF
1021C:  GOTO   10222
10220:  MOVF   xB9,W
10222:  MOVWF  xB9
10224:  GOTO   10164
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
10228:  MOVF   xB7,W
1022A:  SUBLW  0A
1022C:  BTFSS  FD8.2
1022E:  GOTO   10242
10232:  DECFSZ xB6,W
10234:  GOTO   10242
....................       result = -result; 
10238:  COMF   xB4,F
1023A:  COMF   xB5,F
1023C:  INCF   xB4,F
1023E:  BTFSC  FD8.2
10240:  INCF   xB5,F
....................  
....................    return(result); 
10242:  MOVFF  8B4,01
10246:  MOVFF  8B5,02
1024A:  MOVLB  0
1024C:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
0ED00:  MOVLB  8
0ED02:  BCF    xF0.0
....................    y = x; 
0ED04:  MOVFF  8E4,8E9
0ED08:  MOVFF  8E3,8E8
0ED0C:  MOVFF  8E2,8E7
0ED10:  MOVFF  8E1,8E6
....................  
....................    if (x < 0) 
0ED14:  MOVFF  8E4,8F4
0ED18:  MOVFF  8E3,8F3
0ED1C:  MOVFF  8E2,8F2
0ED20:  MOVFF  8E1,8F1
0ED24:  CLRF   xF8
0ED26:  CLRF   xF7
0ED28:  CLRF   xF6
0ED2A:  CLRF   xF5
0ED2C:  MOVLB  0
0ED2E:  CALL   C142
0ED32:  BNC   ED40
....................    { 
....................       s = 1; 
0ED34:  MOVLB  8
0ED36:  BSF    xF0.0
....................       y = -y; 
0ED38:  MOVF   xE7,W
0ED3A:  XORLW  80
0ED3C:  MOVWF  xE7
0ED3E:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
0ED40:  MOVFF  8E9,8F4
0ED44:  MOVFF  8E8,8F3
0ED48:  MOVFF  8E7,8F2
0ED4C:  MOVFF  8E6,8F1
0ED50:  MOVLB  8
0ED52:  CLRF   xF8
0ED54:  CLRF   xF7
0ED56:  CLRF   xF6
0ED58:  MOVLW  8E
0ED5A:  MOVWF  xF5
0ED5C:  MOVLB  0
0ED5E:  CALL   C142
0ED62:  BC    ED66
0ED64:  BNZ   ED96
....................       res = (float32)(unsigned int16)y; 
0ED66:  MOVFF  8E9,8F4
0ED6A:  MOVFF  8E8,8F3
0ED6E:  MOVFF  8E7,8F2
0ED72:  MOVFF  8E6,8F1
0ED76:  RCALL  ECC4
0ED78:  MOVFF  02,8F6
0ED7C:  MOVFF  01,8F5
0ED80:  CALL   BFAE
0ED84:  MOVFF  03,8ED
0ED88:  MOVFF  02,8EC
0ED8C:  MOVFF  01,8EB
0ED90:  MOVFF  00,8EA
0ED94:  BRA    EF38
....................  
....................  else if (y < 10000000.0) 
0ED96:  MOVFF  8E9,8F4
0ED9A:  MOVFF  8E8,8F3
0ED9E:  MOVFF  8E7,8F2
0EDA2:  MOVFF  8E6,8F1
0EDA6:  MOVLW  80
0EDA8:  MOVLB  8
0EDAA:  MOVWF  xF8
0EDAC:  MOVLW  96
0EDAE:  MOVWF  xF7
0EDB0:  MOVLW  18
0EDB2:  MOVWF  xF6
0EDB4:  MOVLW  96
0EDB6:  MOVWF  xF5
0EDB8:  MOVLB  0
0EDBA:  CALL   C142
0EDBE:  BTFSS  FD8.0
0EDC0:  BRA    EF28
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0EDC2:  MOVFF  8E9,8F4
0EDC6:  MOVFF  8E8,8F3
0EDCA:  MOVFF  8E7,8F2
0EDCE:  MOVFF  8E6,8F1
0EDD2:  MOVLB  8
0EDD4:  CLRF   xF8
0EDD6:  CLRF   xF7
0EDD8:  CLRF   xF6
0EDDA:  MOVLW  70
0EDDC:  MOVWF  xF5
0EDDE:  MOVLB  0
0EDE0:  CALL   C4BE
0EDE4:  MOVFF  03,8F4
0EDE8:  MOVFF  02,8F3
0EDEC:  MOVFF  01,8F2
0EDF0:  MOVFF  00,8F1
0EDF4:  RCALL  ECC4
0EDF6:  MOVFF  02,8EF
0EDFA:  MOVFF  01,8EE
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0EDFE:  MOVFF  8E9,8F4
0EE02:  MOVFF  8E8,8F3
0EE06:  MOVFF  8E7,8F2
0EE0A:  MOVFF  8E6,8F1
0EE0E:  MOVLB  8
0EE10:  CLRF   xF8
0EE12:  CLRF   xF7
0EE14:  CLRF   xF6
0EE16:  MOVLW  70
0EE18:  MOVWF  xF5
0EE1A:  MOVLB  0
0EE1C:  CALL   C4BE
0EE20:  MOVFF  03,8F4
0EE24:  MOVFF  02,8F3
0EE28:  MOVFF  01,8F2
0EE2C:  MOVFF  00,8F1
0EE30:  MOVFF  8EF,8F6
0EE34:  MOVFF  8EE,8F5
0EE38:  CALL   BFAE
0EE3C:  BSF    FD8.1
0EE3E:  MOVFF  8F4,8F8
0EE42:  MOVFF  8F3,8F7
0EE46:  MOVFF  8F2,8F6
0EE4A:  MOVFF  8F1,8F5
0EE4E:  MOVFF  03,8FC
0EE52:  MOVFF  02,8FB
0EE56:  MOVFF  01,8FA
0EE5A:  MOVFF  00,8F9
0EE5E:  CALL   C1BC
0EE62:  MOVLB  8
0EE64:  CLRF   xF4
0EE66:  CLRF   xF3
0EE68:  CLRF   xF2
0EE6A:  MOVLW  8E
0EE6C:  MOVWF  xF1
0EE6E:  MOVFF  03,8F8
0EE72:  MOVFF  02,8F7
0EE76:  MOVFF  01,8F6
0EE7A:  MOVFF  00,8F5
0EE7E:  MOVLB  0
0EE80:  CALL   C4BE
0EE84:  MOVFF  03,8E9
0EE88:  MOVFF  02,8E8
0EE8C:  MOVFF  01,8E7
0EE90:  MOVFF  00,8E6
....................       res = 32768.0*(float32)l; 
0EE94:  MOVFF  8EF,8F6
0EE98:  MOVFF  8EE,8F5
0EE9C:  CALL   BFAE
0EEA0:  MOVLB  8
0EEA2:  CLRF   xF4
0EEA4:  CLRF   xF3
0EEA6:  CLRF   xF2
0EEA8:  MOVLW  8E
0EEAA:  MOVWF  xF1
0EEAC:  MOVFF  03,8F8
0EEB0:  MOVFF  02,8F7
0EEB4:  MOVFF  01,8F6
0EEB8:  MOVFF  00,8F5
0EEBC:  MOVLB  0
0EEBE:  CALL   C4BE
0EEC2:  MOVFF  03,8ED
0EEC6:  MOVFF  02,8EC
0EECA:  MOVFF  01,8EB
0EECE:  MOVFF  00,8EA
....................       res += (float32)(unsigned int16)y; 
0EED2:  MOVFF  8E9,8F4
0EED6:  MOVFF  8E8,8F3
0EEDA:  MOVFF  8E7,8F2
0EEDE:  MOVFF  8E6,8F1
0EEE2:  RCALL  ECC4
0EEE4:  MOVFF  02,8F6
0EEE8:  MOVFF  01,8F5
0EEEC:  CALL   BFAE
0EEF0:  BCF    FD8.1
0EEF2:  MOVFF  8ED,8F8
0EEF6:  MOVFF  8EC,8F7
0EEFA:  MOVFF  8EB,8F6
0EEFE:  MOVFF  8EA,8F5
0EF02:  MOVFF  03,8FC
0EF06:  MOVFF  02,8FB
0EF0A:  MOVFF  01,8FA
0EF0E:  MOVFF  00,8F9
0EF12:  CALL   C1BC
0EF16:  MOVFF  03,8ED
0EF1A:  MOVFF  02,8EC
0EF1E:  MOVFF  01,8EB
0EF22:  MOVFF  00,8EA
....................    } 
0EF26:  BRA    EF38
....................  
....................  else 
....................   res = y; 
0EF28:  MOVFF  8E9,8ED
0EF2C:  MOVFF  8E8,8EC
0EF30:  MOVFF  8E7,8EB
0EF34:  MOVFF  8E6,8EA
....................  
....................  y = y - (float32)(unsigned int16)y; 
0EF38:  MOVFF  8E9,8F4
0EF3C:  MOVFF  8E8,8F3
0EF40:  MOVFF  8E7,8F2
0EF44:  MOVFF  8E6,8F1
0EF48:  RCALL  ECC4
0EF4A:  MOVFF  02,8F6
0EF4E:  MOVFF  01,8F5
0EF52:  CALL   BFAE
0EF56:  BSF    FD8.1
0EF58:  MOVFF  8E9,8F8
0EF5C:  MOVFF  8E8,8F7
0EF60:  MOVFF  8E7,8F6
0EF64:  MOVFF  8E6,8F5
0EF68:  MOVFF  03,8FC
0EF6C:  MOVFF  02,8FB
0EF70:  MOVFF  01,8FA
0EF74:  MOVFF  00,8F9
0EF78:  CALL   C1BC
0EF7C:  MOVFF  03,8E9
0EF80:  MOVFF  02,8E8
0EF84:  MOVFF  01,8E7
0EF88:  MOVFF  00,8E6
....................  
....................  if (s) 
0EF8C:  MOVLB  8
0EF8E:  BTFSS  xF0.0
0EF90:  BRA    EF98
....................   res = -res; 
0EF92:  MOVF   xEB,W
0EF94:  XORLW  80
0EF96:  MOVWF  xEB
....................  
....................  if (y != 0) 
0EF98:  MOVFF  8E9,8F4
0EF9C:  MOVFF  8E8,8F3
0EFA0:  MOVFF  8E7,8F2
0EFA4:  MOVFF  8E6,8F1
0EFA8:  CLRF   xF8
0EFAA:  CLRF   xF7
0EFAC:  CLRF   xF6
0EFAE:  CLRF   xF5
0EFB0:  MOVLB  0
0EFB2:  CALL   C142
0EFB6:  BZ    F030
....................  { 
....................   if (s == 1 && n == 0) 
0EFB8:  MOVLB  8
0EFBA:  BTFSS  xF0.0
0EFBC:  BRA    EFF6
0EFBE:  MOVF   xE5,F
0EFC0:  BNZ   EFF6
....................    res -= 1.0; 
0EFC2:  BSF    FD8.1
0EFC4:  MOVFF  8ED,8F8
0EFC8:  MOVFF  8EC,8F7
0EFCC:  MOVFF  8EB,8F6
0EFD0:  MOVFF  8EA,8F5
0EFD4:  CLRF   xFC
0EFD6:  CLRF   xFB
0EFD8:  CLRF   xFA
0EFDA:  MOVLW  7F
0EFDC:  MOVWF  xF9
0EFDE:  MOVLB  0
0EFE0:  CALL   C1BC
0EFE4:  MOVFF  03,8ED
0EFE8:  MOVFF  02,8EC
0EFEC:  MOVFF  01,8EB
0EFF0:  MOVFF  00,8EA
0EFF4:  MOVLB  8
....................  
....................   if (s == 0 && n == 1) 
0EFF6:  BTFSC  xF0.0
0EFF8:  BRA    F032
0EFFA:  DECFSZ xE5,W
0EFFC:  BRA    F032
....................    res += 1.0; 
0EFFE:  BCF    FD8.1
0F000:  MOVFF  8ED,8F8
0F004:  MOVFF  8EC,8F7
0F008:  MOVFF  8EB,8F6
0F00C:  MOVFF  8EA,8F5
0F010:  CLRF   xFC
0F012:  CLRF   xFB
0F014:  CLRF   xFA
0F016:  MOVLW  7F
0F018:  MOVWF  xF9
0F01A:  MOVLB  0
0F01C:  CALL   C1BC
0F020:  MOVFF  03,8ED
0F024:  MOVFF  02,8EC
0F028:  MOVFF  01,8EB
0F02C:  MOVFF  00,8EA
0F030:  MOVLB  8
....................  } 
....................  if (x == 0) 
0F032:  MOVFF  8E4,8F4
0F036:  MOVFF  8E3,8F3
0F03A:  MOVFF  8E2,8F2
0F03E:  MOVFF  8E1,8F1
0F042:  CLRF   xF8
0F044:  CLRF   xF7
0F046:  CLRF   xF6
0F048:  CLRF   xF5
0F04A:  MOVLB  0
0F04C:  CALL   C142
0F050:  BNZ   F05E
....................     res = 0; 
0F052:  MOVLB  8
0F054:  CLRF   xED
0F056:  CLRF   xEC
0F058:  CLRF   xEB
0F05A:  CLRF   xEA
0F05C:  MOVLB  0
....................  
....................  return (res); 
0F05E:  MOVFF  8EA,00
0F062:  MOVFF  8EB,01
0F066:  MOVFF  8EC,02
0F06A:  MOVFF  8ED,03
0F06E:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
0F08E:  MOVFF  8E0,8E4
0F092:  MOVFF  8DF,8E3
0F096:  MOVFF  8DE,8E2
0F09A:  MOVFF  8DD,8E1
0F09E:  MOVLB  8
0F0A0:  CLRF   xE5
0F0A2:  MOVLB  0
0F0A4:  RCALL  ED00
0F0A6:  GOTO   F1B2 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0F070:  MOVFF  8E0,8E4
0F074:  MOVFF  8DF,8E3
0F078:  MOVFF  8DE,8E2
0F07C:  MOVFF  8DD,8E1
0F080:  MOVLW  01
0F082:  MOVLB  8
0F084:  MOVWF  xE5
0F086:  MOVLB  0
0F088:  RCALL  ED00
0F08A:  GOTO   F16A (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
0F0AA:  MOVFF  8D4,8F4
0F0AE:  MOVFF  8D3,8F3
0F0B2:  MOVFF  8D2,8F2
0F0B6:  MOVFF  8D1,8F1
0F0BA:  MOVLB  8
0F0BC:  CLRF   xF8
0F0BE:  CLRF   xF7
0F0C0:  CLRF   xF6
0F0C2:  CLRF   xF5
0F0C4:  MOVLB  0
0F0C6:  CALL   C142
0F0CA:  BTFSC  FD8.2
0F0CC:  BRA    F20E
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
0F0CE:  MOVFF  8D0,8DC
0F0D2:  MOVFF  8CF,8DB
0F0D6:  MOVFF  8CE,8DA
0F0DA:  MOVFF  8CD,8D9
0F0DE:  MOVFF  8D4,8E0
0F0E2:  MOVFF  8D3,8DF
0F0E6:  MOVFF  8D2,8DE
0F0EA:  MOVFF  8D1,8DD
0F0EE:  CALL   BFE4
0F0F2:  MOVFF  03,8DC
0F0F6:  MOVFF  02,8DB
0F0FA:  MOVFF  01,8DA
0F0FE:  MOVFF  00,8D9
0F102:  MOVFF  03,8F4
0F106:  MOVFF  02,8F3
0F10A:  MOVFF  01,8F2
0F10E:  MOVFF  00,8F1
0F112:  MOVLB  8
0F114:  CLRF   xF8
0F116:  CLRF   xF7
0F118:  CLRF   xF6
0F11A:  CLRF   xF5
0F11C:  MOVLB  0
0F11E:  CALL   C142
0F122:  BNC   F16C
0F124:  MOVFF  8D0,8DC
0F128:  MOVFF  8CF,8DB
0F12C:  MOVFF  8CE,8DA
0F130:  MOVFF  8CD,8D9
0F134:  MOVFF  8D4,8E0
0F138:  MOVFF  8D3,8DF
0F13C:  MOVFF  8D2,8DE
0F140:  MOVFF  8D1,8DD
0F144:  CALL   BFE4
0F148:  MOVFF  03,8DC
0F14C:  MOVFF  02,8DB
0F150:  MOVFF  01,8DA
0F154:  MOVFF  00,8D9
0F158:  MOVFF  03,8E0
0F15C:  MOVFF  02,8DF
0F160:  MOVFF  01,8DE
0F164:  MOVFF  00,8DD
0F168:  BRA    F070
0F16A:  BRA    F1B2
0F16C:  MOVFF  8D0,8DC
0F170:  MOVFF  8CF,8DB
0F174:  MOVFF  8CE,8DA
0F178:  MOVFF  8CD,8D9
0F17C:  MOVFF  8D4,8E0
0F180:  MOVFF  8D3,8DF
0F184:  MOVFF  8D2,8DE
0F188:  MOVFF  8D1,8DD
0F18C:  CALL   BFE4
0F190:  MOVFF  03,8DC
0F194:  MOVFF  02,8DB
0F198:  MOVFF  01,8DA
0F19C:  MOVFF  00,8D9
0F1A0:  MOVFF  03,8E0
0F1A4:  MOVFF  02,8DF
0F1A8:  MOVFF  01,8DE
0F1AC:  MOVFF  00,8DD
0F1B0:  BRA    F08E
0F1B2:  MOVFF  03,8D8
0F1B6:  MOVFF  02,8D7
0F1BA:  MOVFF  01,8D6
0F1BE:  MOVFF  00,8D5
....................       return(x-(i*y)); 
0F1C2:  MOVFF  8D8,8F4
0F1C6:  MOVFF  8D7,8F3
0F1CA:  MOVFF  8D6,8F2
0F1CE:  MOVFF  8D5,8F1
0F1D2:  MOVFF  8D4,8F8
0F1D6:  MOVFF  8D3,8F7
0F1DA:  MOVFF  8D2,8F6
0F1DE:  MOVFF  8D1,8F5
0F1E2:  CALL   C4BE
0F1E6:  BSF    FD8.1
0F1E8:  MOVFF  8D0,8F8
0F1EC:  MOVFF  8CF,8F7
0F1F0:  MOVFF  8CE,8F6
0F1F4:  MOVFF  8CD,8F5
0F1F8:  MOVFF  03,8FC
0F1FC:  MOVFF  02,8FB
0F200:  MOVFF  01,8FA
0F204:  MOVFF  00,8F9
0F208:  CALL   C1BC
0F20C:  BRA    F20E
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0F20E:  GOTO   FA90 (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
0C604:  MOVFF  8B8,8BC
0C608:  MOVFF  8B7,8BB
0C60C:  MOVFF  8B6,8BA
0C610:  MOVFF  8B5,8B9
....................  
....................    if (y != 1.0) 
0C614:  MOVFF  8BC,8F4
0C618:  MOVFF  8BB,8F3
0C61C:  MOVFF  8BA,8F2
0C620:  MOVFF  8B9,8F1
0C624:  MOVLB  8
0C626:  CLRF   xF8
0C628:  CLRF   xF7
0C62A:  CLRF   xF6
0C62C:  MOVLW  7F
0C62E:  MOVWF  xF5
0C630:  MOVLB  0
0C632:  RCALL  C142
0C634:  BTFSC  FD8.2
0C636:  BRA    C95A
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
0C638:  MOVLW  08
0C63A:  MOVLB  8
0C63C:  MOVWF  xCB
0C63E:  MOVLW  B9
0C640:  MOVWF  FE9
0C642:  MOVFF  8CB,FEA
0C646:  MOVLW  7E
0C648:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
0C64A:  BSF    FD8.1
0C64C:  MOVFF  8BC,8F8
0C650:  MOVFF  8BB,8F7
0C654:  MOVFF  8BA,8F6
0C658:  MOVFF  8B9,8F5
0C65C:  CLRF   xFC
0C65E:  CLRF   xFB
0C660:  CLRF   xFA
0C662:  MOVLW  7F
0C664:  MOVWF  xF9
0C666:  MOVLB  0
0C668:  RCALL  C1BC
0C66A:  MOVFF  03,8CD
0C66E:  MOVFF  02,8CC
0C672:  MOVFF  01,8CB
0C676:  MOVFF  00,8CA
0C67A:  BCF    FD8.1
0C67C:  MOVFF  8BC,8F8
0C680:  MOVFF  8BB,8F7
0C684:  MOVFF  8BA,8F6
0C688:  MOVFF  8B9,8F5
0C68C:  MOVLB  8
0C68E:  CLRF   xFC
0C690:  CLRF   xFB
0C692:  CLRF   xFA
0C694:  MOVLW  7F
0C696:  MOVWF  xF9
0C698:  MOVLB  0
0C69A:  RCALL  C1BC
0C69C:  MOVFF  8CD,8DC
0C6A0:  MOVFF  8CC,8DB
0C6A4:  MOVFF  8CB,8DA
0C6A8:  MOVFF  8CA,8D9
0C6AC:  MOVFF  03,8E0
0C6B0:  MOVFF  02,8DF
0C6B4:  MOVFF  01,8DE
0C6B8:  MOVFF  00,8DD
0C6BC:  RCALL  BFE4
0C6BE:  MOVFF  03,8BC
0C6C2:  MOVFF  02,8BB
0C6C6:  MOVFF  01,8BA
0C6CA:  MOVFF  00,8B9
....................  
....................       y2=y*y; 
0C6CE:  MOVFF  8BC,8F4
0C6D2:  MOVFF  8BB,8F3
0C6D6:  MOVFF  8BA,8F2
0C6DA:  MOVFF  8B9,8F1
0C6DE:  MOVFF  8BC,8F8
0C6E2:  MOVFF  8BB,8F7
0C6E6:  MOVFF  8BA,8F6
0C6EA:  MOVFF  8B9,8F5
0C6EE:  RCALL  C4BE
0C6F0:  MOVFF  03,8C8
0C6F4:  MOVFF  02,8C7
0C6F8:  MOVFF  01,8C6
0C6FC:  MOVFF  00,8C5
....................  
....................       res = pl[0]*y2 + pl[1]; 
0C700:  MOVLW  99
0C702:  MOVLB  8
0C704:  MOVWF  xF4
0C706:  MOVLW  47
0C708:  MOVWF  xF3
0C70A:  MOVLW  8A
0C70C:  MOVWF  xF2
0C70E:  MOVLW  7F
0C710:  MOVWF  xF1
0C712:  MOVFF  8C8,8F8
0C716:  MOVFF  8C7,8F7
0C71A:  MOVFF  8C6,8F6
0C71E:  MOVFF  8C5,8F5
0C722:  MOVLB  0
0C724:  RCALL  C4BE
0C726:  MOVFF  03,8CD
0C72A:  MOVFF  02,8CC
0C72E:  MOVFF  01,8CB
0C732:  MOVFF  00,8CA
0C736:  BCF    FD8.1
0C738:  MOVFF  03,8F8
0C73C:  MOVFF  02,8F7
0C740:  MOVFF  01,8F6
0C744:  MOVFF  00,8F5
0C748:  MOVLB  8
0C74A:  CLRF   xFC
0C74C:  CLRF   xFB
0C74E:  CLRF   xFA
0C750:  MOVLW  80
0C752:  MOVWF  xF9
0C754:  MOVLB  0
0C756:  RCALL  C1BC
0C758:  MOVFF  03,8C0
0C75C:  MOVFF  02,8BF
0C760:  MOVFF  01,8BE
0C764:  MOVFF  00,8BD
....................  
....................       r = ql[0]*y2 + ql[1]; 
0C768:  MOVLW  4C
0C76A:  MOVLB  8
0C76C:  MOVWF  xF4
0C76E:  MOVLW  F3
0C770:  MOVWF  xF3
0C772:  MOVLW  3A
0C774:  MOVWF  xF2
0C776:  MOVLW  7B
0C778:  MOVWF  xF1
0C77A:  MOVFF  8C8,8F8
0C77E:  MOVFF  8C7,8F7
0C782:  MOVFF  8C6,8F6
0C786:  MOVFF  8C5,8F5
0C78A:  MOVLB  0
0C78C:  RCALL  C4BE
0C78E:  MOVFF  03,8CD
0C792:  MOVFF  02,8CC
0C796:  MOVFF  01,8CB
0C79A:  MOVFF  00,8CA
0C79E:  BCF    FD8.1
0C7A0:  MOVFF  03,8F8
0C7A4:  MOVFF  02,8F7
0C7A8:  MOVFF  01,8F6
0C7AC:  MOVFF  00,8F5
0C7B0:  MOVLW  2B
0C7B2:  MOVLB  8
0C7B4:  MOVWF  xFC
0C7B6:  MOVLW  9D
0C7B8:  MOVWF  xFB
0C7BA:  MOVLW  DF
0C7BC:  MOVWF  xFA
0C7BE:  MOVLW  7E
0C7C0:  MOVWF  xF9
0C7C2:  MOVLB  0
0C7C4:  RCALL  C1BC
0C7C6:  MOVFF  03,8C4
0C7CA:  MOVFF  02,8C3
0C7CE:  MOVFF  01,8C2
0C7D2:  MOVFF  00,8C1
....................       r = r*y2 + 1.0; 
0C7D6:  MOVFF  8C4,8F4
0C7DA:  MOVFF  8C3,8F3
0C7DE:  MOVFF  8C2,8F2
0C7E2:  MOVFF  8C1,8F1
0C7E6:  MOVFF  8C8,8F8
0C7EA:  MOVFF  8C7,8F7
0C7EE:  MOVFF  8C6,8F6
0C7F2:  MOVFF  8C5,8F5
0C7F6:  RCALL  C4BE
0C7F8:  MOVFF  03,8CD
0C7FC:  MOVFF  02,8CC
0C800:  MOVFF  01,8CB
0C804:  MOVFF  00,8CA
0C808:  BCF    FD8.1
0C80A:  MOVFF  03,8F8
0C80E:  MOVFF  02,8F7
0C812:  MOVFF  01,8F6
0C816:  MOVFF  00,8F5
0C81A:  MOVLB  8
0C81C:  CLRF   xFC
0C81E:  CLRF   xFB
0C820:  CLRF   xFA
0C822:  MOVLW  7F
0C824:  MOVWF  xF9
0C826:  MOVLB  0
0C828:  RCALL  C1BC
0C82A:  MOVFF  03,8C4
0C82E:  MOVFF  02,8C3
0C832:  MOVFF  01,8C2
0C836:  MOVFF  00,8C1
....................  
....................       res = y*res/r; 
0C83A:  MOVFF  8BC,8F4
0C83E:  MOVFF  8BB,8F3
0C842:  MOVFF  8BA,8F2
0C846:  MOVFF  8B9,8F1
0C84A:  MOVFF  8C0,8F8
0C84E:  MOVFF  8BF,8F7
0C852:  MOVFF  8BE,8F6
0C856:  MOVFF  8BD,8F5
0C85A:  RCALL  C4BE
0C85C:  MOVFF  03,8CD
0C860:  MOVFF  02,8CC
0C864:  MOVFF  01,8CB
0C868:  MOVFF  00,8CA
0C86C:  MOVFF  03,8DC
0C870:  MOVFF  02,8DB
0C874:  MOVFF  01,8DA
0C878:  MOVFF  00,8D9
0C87C:  MOVFF  8C4,8E0
0C880:  MOVFF  8C3,8DF
0C884:  MOVFF  8C2,8DE
0C888:  MOVFF  8C1,8DD
0C88C:  CALL   BFE4
0C890:  MOVFF  03,8C0
0C894:  MOVFF  02,8BF
0C898:  MOVFF  01,8BE
0C89C:  MOVFF  00,8BD
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
0C8A0:  MOVLW  08
0C8A2:  MOVLB  8
0C8A4:  MOVWF  xCB
0C8A6:  MOVLW  B5
0C8A8:  MOVWF  FE9
0C8AA:  MOVFF  8CB,FEA
0C8AE:  MOVLW  7E
0C8B0:  SUBWF  FEF,W
0C8B2:  MOVWF  xC9
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
0C8B4:  BTFSS  xC9.7
0C8B6:  BRA    C8E0
....................          r = -(float32)-n; 
0C8B8:  MOVLW  00
0C8BA:  BSF    FD8.0
0C8BC:  SUBFWB xC9,W
0C8BE:  CLRF   xCB
0C8C0:  MOVWF  xCA
0C8C2:  BTFSC  xCA.7
0C8C4:  DECF   xCB,F
0C8C6:  MOVLB  0
0C8C8:  RCALL  C5B4
0C8CA:  MOVFF  00,8C1
0C8CE:  MOVF   01,W
0C8D0:  XORLW  80
0C8D2:  MOVLB  8
0C8D4:  MOVWF  xC2
0C8D6:  MOVFF  02,8C3
0C8DA:  MOVFF  03,8C4
0C8DE:  BRA    C900
....................       else 
....................          r = (float32)n; 
0C8E0:  CLRF   xCB
0C8E2:  MOVFF  8C9,8CA
0C8E6:  BTFSC  xCA.7
0C8E8:  DECF   xCB,F
0C8EA:  MOVLB  0
0C8EC:  RCALL  C5B4
0C8EE:  MOVFF  03,8C4
0C8F2:  MOVFF  02,8C3
0C8F6:  MOVFF  01,8C2
0C8FA:  MOVFF  00,8C1
0C8FE:  MOVLB  8
....................  
....................       res += r*LN2; 
0C900:  MOVFF  8C4,8F4
0C904:  MOVFF  8C3,8F3
0C908:  MOVFF  8C2,8F2
0C90C:  MOVFF  8C1,8F1
0C910:  MOVLW  18
0C912:  MOVWF  xF8
0C914:  MOVLW  72
0C916:  MOVWF  xF7
0C918:  MOVLW  31
0C91A:  MOVWF  xF6
0C91C:  MOVLW  7E
0C91E:  MOVWF  xF5
0C920:  MOVLB  0
0C922:  RCALL  C4BE
0C924:  BCF    FD8.1
0C926:  MOVFF  8C0,8F8
0C92A:  MOVFF  8BF,8F7
0C92E:  MOVFF  8BE,8F6
0C932:  MOVFF  8BD,8F5
0C936:  MOVFF  03,8FC
0C93A:  MOVFF  02,8FB
0C93E:  MOVFF  01,8FA
0C942:  MOVFF  00,8F9
0C946:  RCALL  C1BC
0C948:  MOVFF  03,8C0
0C94C:  MOVFF  02,8BF
0C950:  MOVFF  01,8BE
0C954:  MOVFF  00,8BD
....................    } 
0C958:  BRA    C966
....................  
....................    else 
....................       res = 0.0; 
0C95A:  MOVLB  8
0C95C:  CLRF   xC0
0C95E:  CLRF   xBF
0C960:  CLRF   xBE
0C962:  CLRF   xBD
0C964:  MOVLB  0
....................  
....................    return(res); 
0C966:  MOVFF  8BD,00
0C96A:  MOVFF  8BE,01
0C96E:  MOVFF  8BF,02
0C972:  MOVFF  8C0,03
0C976:  GOTO   C98C (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
0C97A:  MOVFF  8B0,8B8
0C97E:  MOVFF  8AF,8B7
0C982:  MOVFF  8AE,8B6
0C986:  MOVFF  8AD,8B5
0C98A:  BRA    C604
0C98C:  MOVFF  03,8B4
0C990:  MOVFF  02,8B3
0C994:  MOVFF  01,8B2
0C998:  MOVFF  00,8B1
....................    r = r*LN10_INV; 
0C99C:  MOVFF  8B4,8F4
0C9A0:  MOVFF  8B3,8F3
0C9A4:  MOVFF  8B2,8F2
0C9A8:  MOVFF  8B1,8F1
0C9AC:  MOVLW  D9
0C9AE:  MOVLB  8
0C9B0:  MOVWF  xF8
0C9B2:  MOVLW  5B
0C9B4:  MOVWF  xF7
0C9B6:  MOVLW  5E
0C9B8:  MOVWF  xF6
0C9BA:  MOVLW  7D
0C9BC:  MOVWF  xF5
0C9BE:  MOVLB  0
0C9C0:  RCALL  C4BE
0C9C2:  MOVFF  03,8B4
0C9C6:  MOVFF  02,8B3
0C9CA:  MOVFF  01,8B2
0C9CE:  MOVFF  00,8B1
....................    return(r); 
0C9D2:  MOVFF  8B1,00
0C9D6:  MOVFF  8B2,01
0C9DA:  MOVFF  8B3,02
0C9DE:  MOVFF  8B4,03
0C9E2:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
0BDC8:  BCF    FC6.5
0BDCA:  MOVLW  21
0BDCC:  MOVWF  FC6
0BDCE:  MOVLW  40
0BDD0:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
0BDD2:  BSF    F91.2
....................    output_high(EEP_WP); 
0BDD4:  BSF    F91.3
0BDD6:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
0BDD8:  BCF    F91.2
....................    spi_write(0x05);  
0BDDA:  MOVF   FC9,W
0BDDC:  MOVLW  05
0BDDE:  MOVWF  FC9
0BDE0:  RRCF   FC7,W
0BDE2:  BNC   BDE0
....................    data = spi_read(0);  
0BDE4:  MOVF   FC9,W
0BDE6:  CLRF   FC9
0BDE8:  RRCF   FC7,W
0BDEA:  BNC   BDE8
0BDEC:  MOVFF  FC9,8AC
....................    output_high(EEP_CS);  
0BDF0:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
0BDF2:  MOVLW  00
0BDF4:  MOVLB  8
0BDF6:  BTFSS  xAC.0
0BDF8:  MOVLW  01
0BDFA:  MOVWF  01
0BDFC:  MOVLB  0
0BDFE:  GOTO   BE0E (RETURN)
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
....................       while(!ext_eeprom_ready()); 
....................     
....................       output_low(EEP_CS);  
....................       spi_write(0x06);  
....................       output_high(EEP_CS);  
....................        
....................       output_low(EEP_CS);  
....................       spi_write(0x02);  
....................       spi_write(address >> 8);  
....................       spi_write(address);  
....................       spi_write(data);  
....................       output_high(EEP_CS);  
....................        
....................    heartbeat(TRUE);   
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
0BE02:  MOVLB  8
0BE04:  CLRF   xCB
0BE06:  MOVLB  0
0BE08:  CALL   555C
....................     
....................       while(!ext_eeprom_ready()); 
0BE0C:  BRA    BDD8
0BE0E:  MOVF   01,F
0BE10:  BZ    BE0C
....................        
....................       output_low(EEP_CS);  
0BE12:  BCF    F91.2
....................       spi_write(0x03);  
0BE14:  MOVF   FC9,W
0BE16:  MOVLW  03
0BE18:  MOVWF  FC9
0BE1A:  RRCF   FC7,W
0BE1C:  BNC   BE1A
....................       spi_write(address >> 8);  
0BE1E:  MOVFF  8AA,8AC
0BE22:  MOVLB  8
0BE24:  CLRF   xAD
0BE26:  MOVF   FC9,W
0BE28:  MOVFF  8AA,FC9
0BE2C:  RRCF   FC7,W
0BE2E:  BNC   BE2C
....................       spi_write(address);  
0BE30:  MOVF   FC9,W
0BE32:  MOVFF  8A9,FC9
0BE36:  RRCF   FC7,W
0BE38:  BNC   BE36
....................        
....................       data = spi_read(0);  
0BE3A:  MOVF   FC9,W
0BE3C:  CLRF   FC9
0BE3E:  RRCF   FC7,W
0BE40:  BNC   BE3E
0BE42:  MOVFF  FC9,8AB
....................       output_high(EEP_CS);  
0BE46:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
0BE48:  MOVLW  01
0BE4A:  MOVWF  xCB
0BE4C:  MOVLB  0
0BE4E:  CALL   555C
....................     
....................    return(data);  
0BE52:  MOVLB  8
0BE54:  MOVFF  8AB,01
0BE58:  MOVLB  0
0BE5A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
033F6:  MOVF   FF2,W
033F8:  MOVWF  00
033FA:  BCF    FF2.7
033FC:  CLRF   F63
033FE:  MOVFF  8A2,F62
03402:  MOVFF  8A3,F61
03406:  BCF    F7F.6
03408:  BCF    F7F.7
0340A:  BSF    F7F.2
0340C:  MOVLB  F
0340E:  MOVLW  55
03410:  MOVWF  F7E
03412:  MOVLW  AA
03414:  MOVWF  F7E
03416:  BSF    F7F.1
03418:  BTFSC  F7F.1
0341A:  BRA    3418
0341C:  BCF    F7F.2
0341E:  MOVF   00,W
03420:  IORWF  FF2,F
03422:  MOVLB  0
03424:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
02A02:  MOVLB  8
02A04:  CLRF   x97
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
02A06:  MOVFF  FF2,898
02A0A:  BCF    FF2.7
02A0C:  CLRF   F63
02A0E:  MOVFF  896,F62
02A12:  BCF    F7F.6
02A14:  BCF    F7F.7
02A16:  BSF    F7F.0
02A18:  MOVF   F61,W
02A1A:  BTFSC  x98.7
02A1C:  BSF    FF2.7
02A1E:  MOVWF  x97
....................    return(data); 
02A20:  MOVFF  897,01
02A24:  MOVLB  0
02A26:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
04FAE:  MOVLB  8
04FB0:  CLRF   xCF
04FB2:  MOVF   xCF,W
04FB4:  SUBLW  01
04FB6:  BNC   5010
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
04FB8:  MOVF   xCC,W
04FBA:  ADDWF  xCF,W
04FBC:  MOVWF  xD0
04FBE:  MOVLW  08
04FC0:  MOVWF  xD2
04FC2:  MOVLW  CD
04FC4:  MOVWF  xD1
04FC6:  MOVF   xCF,W
04FC8:  ADDWF  xD1,W
04FCA:  MOVWF  01
04FCC:  MOVLW  00
04FCE:  ADDWFC xD2,W
04FD0:  MOVWF  03
04FD2:  MOVF   01,W
04FD4:  MOVWF  FE9
04FD6:  MOVFF  03,FEA
04FDA:  MOVFF  FEF,8D1
04FDE:  MOVF   FF2,W
04FE0:  MOVWF  00
04FE2:  BCF    FF2.7
04FE4:  CLRF   F63
04FE6:  MOVFF  8D0,F62
04FEA:  MOVFF  8D1,F61
04FEE:  BCF    F7F.6
04FF0:  BCF    F7F.7
04FF2:  BSF    F7F.2
04FF4:  MOVLB  F
04FF6:  MOVLW  55
04FF8:  MOVWF  F7E
04FFA:  MOVLW  AA
04FFC:  MOVWF  F7E
04FFE:  BSF    F7F.1
05000:  BTFSC  F7F.1
05002:  BRA    5000
05004:  BCF    F7F.2
05006:  MOVF   00,W
05008:  IORWF  FF2,F
0500A:  MOVLB  8
0500C:  INCF   xCF,F
0500E:  BRA    4FB2
....................     }  
05010:  MOVLB  0
05012:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
029A8:  MOVLB  8
029AA:  CLRF   x75
029AC:  CLRF   x74
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
029AE:  CLRF   x73
029B0:  MOVF   x73,W
029B2:  SUBLW  01
029B4:  BNC   29F6
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
029B6:  MOVLW  08
029B8:  MOVWF  x77
029BA:  MOVLW  74
029BC:  MOVWF  x76
029BE:  MOVF   x73,W
029C0:  ADDWF  x76,W
029C2:  MOVWF  01
029C4:  MOVLW  00
029C6:  ADDWFC x77,W
029C8:  MOVWF  03
029CA:  MOVF   01,W
029CC:  MOVWF  FE9
029CE:  MOVFF  03,FEA
029D2:  MOVF   x72,W
029D4:  ADDWF  x73,W
029D6:  MOVWF  x78
029D8:  MOVFF  FF2,879
029DC:  BCF    FF2.7
029DE:  CLRF   F63
029E0:  MOVFF  878,F62
029E4:  BCF    F7F.6
029E6:  BCF    F7F.7
029E8:  BSF    F7F.0
029EA:  MOVF   F61,W
029EC:  BTFSC  x79.7
029EE:  BSF    FF2.7
029F0:  MOVWF  FEF
029F2:  INCF   x73,F
029F4:  BRA    29B0
....................    } 
....................  
....................    return(data);  
029F6:  MOVFF  874,01
029FA:  MOVFF  875,02
029FE:  MOVLB  0
02A00:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
....................    } 
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
02A28:  MOVLB  8
02A2A:  CLRF   x6A
02A2C:  CLRF   x69
02A2E:  CLRF   x68
02A30:  CLRF   x67
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
02A32:  CLRF   x66
02A34:  MOVF   x66,W
02A36:  SUBLW  03
02A38:  BNC   2A82
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02A3A:  MOVLW  08
02A3C:  MOVWF  x6C
02A3E:  MOVLW  67
02A40:  MOVWF  x6B
02A42:  MOVF   x66,W
02A44:  ADDWF  x6B,W
02A46:  MOVWF  01
02A48:  MOVLW  00
02A4A:  ADDWFC x6C,W
02A4C:  MOVWF  03
02A4E:  MOVF   01,W
02A50:  MOVWF  FE9
02A52:  MOVFF  03,FEA
02A56:  MOVF   x66,W
02A58:  ADDWF  x64,W
02A5A:  MOVWF  x6D
02A5C:  MOVLW  00
02A5E:  ADDWFC x65,W
02A60:  MOVWF  x6E
02A62:  MOVFF  FF2,86F
02A66:  BCF    FF2.7
02A68:  MOVFF  86E,F63
02A6C:  MOVFF  86D,F62
02A70:  BCF    F7F.6
02A72:  BCF    F7F.7
02A74:  BSF    F7F.0
02A76:  MOVF   F61,W
02A78:  BTFSC  x6F.7
02A7A:  BSF    FF2.7
02A7C:  MOVWF  FEF
02A7E:  INCF   x66,F
02A80:  BRA    2A34
....................    } 
....................  
....................    return(data);  
02A82:  MOVFF  867,00
02A86:  MOVFF  868,01
02A8A:  MOVFF  869,02
02A8E:  MOVFF  86A,03
02A92:  MOVLB  0
02A94:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
....................     }  
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
0BF18:  MOVLB  8
0BF1A:  CLRF   xA4
0BF1C:  CLRF   xA3
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
0BF1E:  CLRF   xA2
0BF20:  MOVF   xA2,W
0BF22:  SUBLW  01
0BF24:  BNC   BF68
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
0BF26:  MOVLW  08
0BF28:  MOVWF  xA6
0BF2A:  MOVLW  A3
0BF2C:  MOVWF  xA5
0BF2E:  MOVF   xA2,W
0BF30:  ADDWF  xA5,W
0BF32:  MOVWF  01
0BF34:  MOVLW  00
0BF36:  ADDWFC xA6,W
0BF38:  MOVWF  03
0BF3A:  MOVFF  01,8A5
0BF3E:  MOVWF  xA6
0BF40:  MOVF   xA2,W
0BF42:  ADDWF  xA0,W
0BF44:  MOVWF  xA7
0BF46:  MOVLW  00
0BF48:  ADDWFC xA1,W
0BF4A:  MOVWF  xA8
0BF4C:  MOVWF  xAA
0BF4E:  MOVFF  8A7,8A9
0BF52:  MOVLB  0
0BF54:  RCALL  BE02
0BF56:  MOVFF  8A6,FEA
0BF5A:  MOVFF  8A5,FE9
0BF5E:  MOVFF  01,FEF
0BF62:  MOVLB  8
0BF64:  INCF   xA2,F
0BF66:  BRA    BF20
....................    } 
....................    return(data);  
0BF68:  MOVFF  8A3,01
0BF6C:  MOVFF  8A4,02
0BF70:  MOVLB  0
0BF72:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
0AFF0:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
0AFF2:  MOVF   2F,W
0AFF4:  SUBLW  02
0AFF6:  BNZ   AFFE
0AFF8:  MOVF   30,F
0AFFA:  BNZ   AFFE
0AFFC:  BSF    F90.6
....................    delay_ms(32); 
0AFFE:  MOVLW  20
0B000:  MOVLB  A
0B002:  MOVWF  xA2
0B004:  MOVLB  0
0B006:  CALL   0588
....................    output_bit(BOARD_LED, OFF); 
0B00A:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
0B00C:  MOVF   2F,W
0B00E:  SUBLW  02
0B010:  BNZ   B018
0B012:  MOVF   30,F
0B014:  BNZ   B018
0B016:  BCF    F90.6
....................    delay_ms(32); 
0B018:  MOVLW  20
0B01A:  MOVLB  A
0B01C:  MOVWF  xA2
0B01E:  MOVLB  0
0B020:  CALL   0588
0B024:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
0312A:  MOVF   2F,W
0312C:  MOVWF  00
0312E:  MOVF   30,W
03130:  MOVWF  03
03132:  BNZ   3138
03134:  MOVF   00,F
03136:  BZ    315A
03138:  MOVF   03,W
0313A:  BNZ   3142
0313C:  MOVLW  01
0313E:  SUBWF  00,W
03140:  BZ    31AC
03142:  MOVF   03,W
03144:  BNZ   314C
03146:  MOVLW  02
03148:  SUBWF  00,W
0314A:  BZ    31FE
0314C:  MOVF   03,W
0314E:  BNZ   3158
03150:  MOVLW  03
03152:  SUBWF  00,W
03154:  BTFSC  FD8.2
03156:  BRA    3250
03158:  BRA    32A2
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
0315A:  MOVLW  E8
0315C:  MOVWF  FF6
0315E:  MOVLW  05
03160:  MOVWF  FF7
03162:  MOVLW  00
03164:  MOVWF  FF8
03166:  CLRF   1B
03168:  BTFSC  FF2.7
0316A:  BSF    1B.7
0316C:  BCF    FF2.7
0316E:  MOVLW  06
03170:  MOVLB  A
03172:  MOVWF  x19
03174:  MOVLB  0
03176:  CALL   104E
0317A:  BTFSC  1B.7
0317C:  BSF    FF2.7
0317E:  MOVLW  F4
03180:  MOVWF  FF6
03182:  MOVLW  05
03184:  MOVWF  FF7
03186:  MOVLW  00
03188:  MOVWF  FF8
0318A:  CLRF   1B
0318C:  BTFSC  FF2.7
0318E:  BSF    1B.7
03190:  BCF    FF2.7
03192:  CALL   0E78
03196:  BTFSC  1B.7
03198:  BSF    FF2.7
0319A:  MOVLW  0D
0319C:  BTFSS  F9E.4
0319E:  BRA    319C
031A0:  MOVWF  FAD
031A2:  MOVLW  0A
031A4:  BTFSS  F9E.4
031A6:  BRA    31A4
031A8:  MOVWF  FAD
....................          break; 
031AA:  BRA    32F2
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
031AC:  MOVLW  FC
031AE:  MOVWF  FF6
031B0:  MOVLW  05
031B2:  MOVWF  FF7
031B4:  MOVLW  00
031B6:  MOVWF  FF8
031B8:  CLRF   1B
031BA:  BTFSC  FF2.7
031BC:  BSF    1B.7
031BE:  BCF    FF2.7
031C0:  MOVLW  09
031C2:  MOVLB  A
031C4:  MOVWF  x19
031C6:  MOVLB  0
031C8:  CALL   104E
031CC:  BTFSC  1B.7
031CE:  BSF    FF2.7
031D0:  MOVLW  0A
031D2:  MOVWF  FF6
031D4:  MOVLW  06
031D6:  MOVWF  FF7
031D8:  MOVLW  00
031DA:  MOVWF  FF8
031DC:  CLRF   1B
031DE:  BTFSC  FF2.7
031E0:  BSF    1B.7
031E2:  BCF    FF2.7
031E4:  CALL   0E78
031E8:  BTFSC  1B.7
031EA:  BSF    FF2.7
031EC:  MOVLW  0D
031EE:  BTFSS  F9E.4
031F0:  BRA    31EE
031F2:  MOVWF  FAD
031F4:  MOVLW  0A
031F6:  BTFSS  F9E.4
031F8:  BRA    31F6
031FA:  MOVWF  FAD
....................          break;  
031FC:  BRA    32F2
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
031FE:  MOVLW  12
03200:  MOVWF  FF6
03202:  MOVLW  06
03204:  MOVWF  FF7
03206:  MOVLW  00
03208:  MOVWF  FF8
0320A:  CLRF   1B
0320C:  BTFSC  FF2.7
0320E:  BSF    1B.7
03210:  BCF    FF2.7
03212:  MOVLW  06
03214:  MOVLB  A
03216:  MOVWF  x19
03218:  MOVLB  0
0321A:  CALL   104E
0321E:  BTFSC  1B.7
03220:  BSF    FF2.7
03222:  MOVLW  1E
03224:  MOVWF  FF6
03226:  MOVLW  06
03228:  MOVWF  FF7
0322A:  MOVLW  00
0322C:  MOVWF  FF8
0322E:  CLRF   1B
03230:  BTFSC  FF2.7
03232:  BSF    1B.7
03234:  BCF    FF2.7
03236:  CALL   0E78
0323A:  BTFSC  1B.7
0323C:  BSF    FF2.7
0323E:  MOVLW  0D
03240:  BTFSS  F9E.4
03242:  BRA    3240
03244:  MOVWF  FAD
03246:  MOVLW  0A
03248:  BTFSS  F9E.4
0324A:  BRA    3248
0324C:  MOVWF  FAD
....................          break; 
0324E:  BRA    32F2
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
03250:  MOVLW  26
03252:  MOVWF  FF6
03254:  MOVLW  06
03256:  MOVWF  FF7
03258:  MOVLW  00
0325A:  MOVWF  FF8
0325C:  CLRF   1B
0325E:  BTFSC  FF2.7
03260:  BSF    1B.7
03262:  BCF    FF2.7
03264:  MOVLW  09
03266:  MOVLB  A
03268:  MOVWF  x19
0326A:  MOVLB  0
0326C:  CALL   104E
03270:  BTFSC  1B.7
03272:  BSF    FF2.7
03274:  MOVLW  34
03276:  MOVWF  FF6
03278:  MOVLW  06
0327A:  MOVWF  FF7
0327C:  MOVLW  00
0327E:  MOVWF  FF8
03280:  CLRF   1B
03282:  BTFSC  FF2.7
03284:  BSF    1B.7
03286:  BCF    FF2.7
03288:  CALL   0E78
0328C:  BTFSC  1B.7
0328E:  BSF    FF2.7
03290:  MOVLW  0D
03292:  BTFSS  F9E.4
03294:  BRA    3292
03296:  MOVWF  FAD
03298:  MOVLW  0A
0329A:  BTFSS  F9E.4
0329C:  BRA    329A
0329E:  MOVWF  FAD
....................          break;           
032A0:  BRA    32F2
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
032A2:  MOVLW  3C
032A4:  MOVWF  FF6
032A6:  MOVLW  06
032A8:  MOVWF  FF7
032AA:  MOVLW  00
032AC:  MOVWF  FF8
032AE:  CLRF   1B
032B0:  BTFSC  FF2.7
032B2:  BSF    1B.7
032B4:  BCF    FF2.7
032B6:  MOVLW  06
032B8:  MOVLB  A
032BA:  MOVWF  x19
032BC:  MOVLB  0
032BE:  CALL   104E
032C2:  BTFSC  1B.7
032C4:  BSF    FF2.7
032C6:  MOVLW  48
032C8:  MOVWF  FF6
032CA:  MOVLW  06
032CC:  MOVWF  FF7
032CE:  MOVLW  00
032D0:  MOVWF  FF8
032D2:  CLRF   1B
032D4:  BTFSC  FF2.7
032D6:  BSF    1B.7
032D8:  BCF    FF2.7
032DA:  CALL   0E78
032DE:  BTFSC  1B.7
032E0:  BSF    FF2.7
032E2:  MOVLW  0D
032E4:  BTFSS  F9E.4
032E6:  BRA    32E4
032E8:  MOVWF  FAD
032EA:  MOVLW  0A
032EC:  BTFSS  F9E.4
032EE:  BRA    32EC
032F0:  MOVWF  FAD
....................          break; 
....................    } 
032F2:  GOTO   14B86 (RETURN)
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0BCC2:  MOVLW  58
0BCC4:  MOVWF  FF6
0BCC6:  MOVLW  06
0BCC8:  MOVWF  FF7
0BCCA:  MOVLW  00
0BCCC:  MOVWF  FF8
0BCCE:  CLRF   1B
0BCD0:  BTFSC  FF2.7
0BCD2:  BSF    1B.7
0BCD4:  BCF    FF2.7
0BCD6:  CALL   0E78
0BCDA:  BTFSC  1B.7
0BCDC:  BSF    FF2.7
0BCDE:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
1364C:  MOVLW  60
1364E:  MOVWF  FF6
13650:  MOVLW  06
13652:  MOVWF  FF7
13654:  MOVLW  00
13656:  MOVWF  FF8
13658:  CLRF   1B
1365A:  BTFSC  FF2.7
1365C:  BSF    1B.7
1365E:  BCF    FF2.7
13660:  CALL   0E78
13664:  BTFSC  1B.7
13666:  BSF    FF2.7
13668:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
0363A:  MOVLW  78
0363C:  MOVWF  FF6
0363E:  MOVLW  06
03640:  MOVWF  FF7
03642:  MOVLW  00
03644:  MOVWF  FF8
03646:  CLRF   1B
03648:  BTFSC  FF2.7
0364A:  BSF    1B.7
0364C:  BCF    FF2.7
0364E:  CALL   0E78
03652:  BTFSC  1B.7
03654:  BSF    FF2.7
03656:  GOTO   43AC (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
0505A:  MOVLW  80
0505C:  MOVWF  FF6
0505E:  MOVLW  06
05060:  MOVWF  FF7
05062:  MOVLW  00
05064:  MOVWF  FF8
05066:  CLRF   1B
05068:  BTFSC  FF2.7
0506A:  BSF    1B.7
0506C:  BCF    FF2.7
0506E:  CALL   0E78
05072:  BTFSC  1B.7
05074:  BSF    FF2.7
05076:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
138FE:  MOVLW  88
13900:  MOVWF  FF6
13902:  MOVLW  06
13904:  MOVWF  FF7
13906:  MOVLW  00
13908:  MOVWF  FF8
1390A:  CLRF   1B
1390C:  BTFSC  FF2.7
1390E:  BSF    1B.7
13910:  BCF    FF2.7
13912:  CALL   0E78
13916:  BTFSC  1B.7
13918:  BSF    FF2.7
1391A:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
....................    else fprintf(COM_A, "@RDY\r\n"); 
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
03524:  MOVLW  0A
03526:  MOVLB  A
03528:  MOVWF  x0F
0352A:  MOVLW  06
0352C:  MOVFF  A0F,A0D
03530:  MOVWF  x0C
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
03532:  MOVF   FC9,W
03534:  SETF   FC9
03536:  RRCF   FC7,W
03538:  BNC   3536
....................    SD_spi_read(sdcmd); 
0353A:  MOVF   FC9,W
0353C:  MOVFF  A05,FC9
03540:  RRCF   FC7,W
03542:  BNC   3540
....................    SD_spi_read(value[3]); 
03544:  MOVLW  03
03546:  ADDWF  x0C,W
03548:  MOVWF  FE9
0354A:  MOVLW  00
0354C:  ADDWFC x0D,W
0354E:  MOVWF  FEA
03550:  MOVFF  FEF,A0E
03554:  MOVF   FC9,W
03556:  MOVFF  A0E,FC9
0355A:  RRCF   FC7,W
0355C:  BNC   355A
....................    SD_spi_read(value[2]); 
0355E:  MOVLW  02
03560:  ADDWF  x0C,W
03562:  MOVWF  FE9
03564:  MOVLW  00
03566:  ADDWFC x0D,W
03568:  MOVWF  FEA
0356A:  MOVFF  FEF,A0E
0356E:  MOVF   FC9,W
03570:  MOVFF  A0E,FC9
03574:  RRCF   FC7,W
03576:  BNC   3574
....................    SD_spi_read(value[1]); 
03578:  MOVLW  01
0357A:  ADDWF  x0C,W
0357C:  MOVWF  FE9
0357E:  MOVLW  00
03580:  ADDWFC x0D,W
03582:  MOVWF  FEA
03584:  MOVFF  FEF,A0E
03588:  MOVF   FC9,W
0358A:  MOVFF  A0E,FC9
0358E:  RRCF   FC7,W
03590:  BNC   358E
....................    SD_spi_read(value[0]); 
03592:  MOVFF  A0C,FE9
03596:  MOVFF  A0D,FEA
0359A:  MOVFF  FEF,A0E
0359E:  MOVF   FC9,W
035A0:  MOVFF  A0E,FC9
035A4:  RRCF   FC7,W
035A6:  BNC   35A4
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
035A8:  MOVF   x05,W
035AA:  SUBLW  48
035AC:  BNZ   35BA
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
035AE:  MOVF   FC9,W
035B0:  MOVLW  87
035B2:  MOVWF  FC9
035B4:  RRCF   FC7,W
035B6:  BNC   35B4
035B8:  BRA    35C4
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
035BA:  MOVF   FC9,W
035BC:  MOVLW  95
035BE:  MOVWF  FC9
035C0:  RRCF   FC7,W
035C2:  BNC   35C0
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
035C4:  CLRF   x0A
....................    response = SD_spi_read(0xFF); 
035C6:  MOVF   FC9,W
035C8:  SETF   FC9
035CA:  RRCF   FC7,W
035CC:  BNC   35CA
035CE:  MOVFF  FC9,A0B
....................    while ((response == 0xFF) && (i < 100)) 
035D2:  INCFSZ x0B,W
035D4:  BRA    35EC
035D6:  MOVF   x0A,W
035D8:  SUBLW  63
035DA:  BNC   35EC
....................       { 
....................       i++; 
035DC:  INCF   x0A,F
....................       response = SD_spi_read(0xFF); 
035DE:  MOVF   FC9,W
035E0:  SETF   FC9
035E2:  RRCF   FC7,W
035E4:  BNC   35E2
035E6:  MOVFF  FC9,A0B
035EA:  BRA    35D2
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
035EC:  MOVFF  A0B,01
035F0:  MOVLB  0
035F2:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
043B8:  MOVLW  50
043BA:  MOVLB  A
043BC:  MOVWF  x05
043BE:  MOVFF  A04,A09
043C2:  MOVFF  A03,A08
043C6:  MOVFF  A02,A07
043CA:  MOVFF  A01,A06
043CE:  MOVLB  0
043D0:  CALL   3524
043D4:  MOVF   01,W
043D6:  BZ    43DE
043D8:  XORLW  40
043DA:  BZ    43F4
043DC:  BRA    43FA
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
043DE:  MOVFF  A04,4EC
043E2:  MOVFF  A03,4EB
043E6:  MOVFF  A02,4EA
043EA:  MOVFF  A01,4E9
....................          return(TRUE); 
043EE:  MOVLW  01
043F0:  MOVWF  01
043F2:  BRA    43FE
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
043F4:  MOVLW  00
043F6:  MOVWF  01
043F8:  BRA    43FE
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
043FA:  MOVLW  00
043FC:  MOVWF  01
....................       } 
043FE:  GOTO   44E2 (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
04402:  MOVF   FC9,W
04404:  SETF   FC9
04406:  RRCF   FC7,W
04408:  BNC   4406
0440A:  MOVFF  FC9,A09
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
0440E:  MOVLB  A
04410:  CLRF   x08
04412:  CLRF   x07
04414:  MOVF   x08,W
04416:  SUBLW  27
04418:  BNC   4442
0441A:  BNZ   4422
0441C:  MOVF   x07,W
0441E:  SUBLW  0F
04420:  BNC   4442
04422:  INCFSZ x09,W
04424:  BRA    4442
....................       { 
....................       delay_us(10); 
04426:  MOVLW  35
04428:  MOVWF  00
0442A:  DECFSZ 00,F
0442C:  BRA    442A
....................       response = SD_spi_read(0xFF);  
0442E:  MOVF   FC9,W
04430:  SETF   FC9
04432:  RRCF   FC7,W
04434:  BNC   4432
04436:  MOVFF  FC9,A09
0443A:  INCF   x07,F
0443C:  BTFSC  FD8.2
0443E:  INCF   x08,F
04440:  BRA    4414
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
04442:  MOVF   x09,W
04444:  SUBLW  FE
04446:  BZ    4456
....................       { 
....................       if (!response) 
04448:  MOVF   x09,F
0444A:  BNZ   4450
....................          response = 0xFE; 
0444C:  MOVLW  FE
0444E:  MOVWF  x09
....................       return(response); 
04450:  MOVFF  A09,01
04454:  BRA    44AC
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
04456:  CLRF   x08
04458:  CLRF   x07
0445A:  MOVF   x06,F
0445C:  BNZ   4470
0445E:  MOVF   x05,F
04460:  BNZ   4470
04462:  MOVF   x08,W
04464:  SUBWF  x04,W
04466:  BNC   4490
04468:  BNZ   4470
0446A:  MOVF   x03,W
0446C:  SUBWF  x07,W
0446E:  BC    4490
....................       ptr[i]=SD_spi_read(0xFF); 
04470:  MOVF   x01,W
04472:  ADDWF  x07,W
04474:  MOVWF  FE9
04476:  MOVF   x02,W
04478:  ADDWFC x08,W
0447A:  MOVWF  FEA
0447C:  MOVF   FC9,W
0447E:  SETF   FC9
04480:  RRCF   FC7,W
04482:  BNC   4480
04484:  MOVFF  FC9,FEF
04488:  INCF   x07,F
0448A:  BTFSC  FD8.2
0448C:  INCF   x08,F
0448E:  BRA    445A
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
04490:  MOVF   FC9,W
04492:  SETF   FC9
04494:  RRCF   FC7,W
04496:  BNC   4494
....................    SD_spi_read(0xFF); 
04498:  MOVF   FC9,W
0449A:  SETF   FC9
0449C:  RRCF   FC7,W
0449E:  BNC   449C
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
044A0:  MOVF   FC9,W
044A2:  SETF   FC9
044A4:  RRCF   FC7,W
044A6:  BNC   44A4
....................    return(0); 
044A8:  MOVLW  00
044AA:  MOVWF  01
044AC:  MOVLB  0
044AE:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
0581C:  MOVLW  C3
0581E:  MOVLB  A
05820:  MOVWF  x09
05822:  MOVLW  50
05824:  MOVWF  x08
....................    SD_spi_read(0xFF); 
05826:  MOVF   FC9,W
05828:  SETF   FC9
0582A:  RRCF   FC7,W
0582C:  BNC   582A
....................    do 
....................       { 
....................       delay_us(10); 
0582E:  MOVLW  35
05830:  MOVWF  00
05832:  DECFSZ 00,F
05834:  BRA    5832
....................       response = SD_spi_read(0xFF); 
05836:  MOVF   FC9,W
05838:  SETF   FC9
0583A:  RRCF   FC7,W
0583C:  BNC   583A
0583E:  MOVFF  FC9,A07
....................       Timer--; 
05842:  MOVF   x08,W
05844:  BTFSC  FD8.2
05846:  DECF   x09,F
05848:  DECF   x08,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
0584A:  INCFSZ x07,W
0584C:  BRA    5850
0584E:  BRA    5856
05850:  MOVF   x08,W
05852:  IORWF  x09,W
05854:  BNZ   582E
....................       ; 
....................  
....................    return (response); 
05856:  MOVFF  A07,01
0585A:  MOVLB  0
0585C:  GOTO   586C (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
05860:  MOVLW  02
05862:  MOVLB  A
05864:  MOVWF  x06
05866:  CLRF   x05
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
05868:  MOVLB  0
0586A:  BRA    581C
0586C:  INCFSZ 01,W
0586E:  BRA    5872
05870:  BRA    5878
....................       return (FALSE); 
05872:  MOVLW  00
05874:  MOVWF  01
05876:  BRA    5912
....................  
....................    SD_spi_write(token);               // transmit data token 
05878:  MOVF   FC9,W
0587A:  MOVFF  A03,FC9
0587E:  RRCF   FC7,W
05880:  BNC   587E
....................    if (token != 0xFD) 
05882:  MOVLB  A
05884:  MOVF   x03,W
05886:  SUBLW  FD
05888:  BZ    590C
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
0588A:  MOVFF  A06,03
0588E:  MOVF   x05,W
05890:  BTFSC  FD8.2
05892:  DECF   x06,F
05894:  DECF   x05,F
05896:  IORWF  03,W
05898:  BZ    58BC
....................          SD_spi_write(*ptr++); 
0589A:  MOVFF  A02,03
0589E:  MOVF   x01,W
058A0:  INCF   x01,F
058A2:  BTFSC  FD8.2
058A4:  INCF   x02,F
058A6:  MOVWF  FE9
058A8:  MOVFF  03,FEA
058AC:  MOVFF  FEF,A07
058B0:  MOVF   FC9,W
058B2:  MOVFF  A07,FC9
058B6:  RRCF   FC7,W
058B8:  BNC   58B6
058BA:  BRA    588A
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
058BC:  MOVF   FC9,W
058BE:  SETF   FC9
058C0:  RRCF   FC7,W
058C2:  BNC   58C0
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
058C4:  MOVF   FC9,W
058C6:  SETF   FC9
058C8:  RRCF   FC7,W
058CA:  BNC   58C8
....................       response = SD_spi_read(0xFF);      // Receive data response 
058CC:  MOVF   FC9,W
058CE:  SETF   FC9
058D0:  RRCF   FC7,W
058D2:  BNC   58D0
058D4:  MOVFF  FC9,A04
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
058D8:  CLRF   x06
058DA:  CLRF   x05
058DC:  MOVF   x06,W
058DE:  SUBLW  C3
058E0:  BNC   590C
058E2:  BNZ   58EA
058E4:  MOVF   x05,W
058E6:  SUBLW  4F
058E8:  BNC   590C
....................          { 
....................          delay_us(10); 
058EA:  MOVLW  35
058EC:  MOVWF  00
058EE:  DECFSZ 00,F
058F0:  BRA    58EE
....................          response = SD_spi_read(0xFF);   // digest prior operation 
058F2:  MOVF   FC9,W
058F4:  SETF   FC9
058F6:  RRCF   FC7,W
058F8:  BNC   58F6
058FA:  MOVFF  FC9,A04
....................          if (response != 0x00) 
058FE:  MOVF   x04,F
05900:  BZ    5904
....................             break; 
05902:  BRA    590C
05904:  INCF   x05,F
05906:  BTFSC  FD8.2
05908:  INCF   x06,F
0590A:  BRA    58DC
....................          } 
....................  
....................       } 
....................    return(TRUE); 
0590C:  MOVLW  01
0590E:  MOVWF  01
05910:  MOVLB  0
05912:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
05914:  MOVLB  4
05916:  BTFSS  xED.0
05918:  BRA    5920
....................       return (RES_NOTRDY); 
0591A:  MOVLW  03
0591C:  MOVWF  01
0591E:  BRA    5A56
....................  
....................    if (Media_Status & STA_PROTECT) 
05920:  BTFSS  xED.2
05922:  BRA    592A
....................       return (RES_WRPRT); 
05924:  MOVLW  02
05926:  MOVWF  01
05928:  BRA    5A56
....................  
....................    if (!SectorCount) 
0592A:  MOVLB  A
0592C:  MOVF   x00,F
0592E:  BNZ   593A
....................       return (RES_PARERR); 
05930:  MOVLW  04
05932:  MOVWF  01
05934:  MOVLB  4
05936:  BRA    5A56
05938:  MOVLB  A
....................  
....................    SelectSD; 
0593A:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
0593C:  MOVLB  4
0593E:  MOVF   xE7,W
05940:  SUBLW  05
05942:  BZ    595E
....................       SectorNumber *= 512; 
05944:  BCF    FD8.0
05946:  MOVFF  9FE,9FF
0594A:  MOVFF  9FD,9FE
0594E:  MOVFF  9FC,9FD
05952:  MOVLB  9
05954:  CLRF   xFC
05956:  RLCF   xFD,F
05958:  RLCF   xFE,F
0595A:  RLCF   xFF,F
0595C:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
0595E:  MOVLB  A
05960:  DECFSZ x00,W
05962:  BRA    59A2
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
05964:  MOVLW  58
05966:  MOVWF  x05
05968:  MOVFF  9FF,A09
0596C:  MOVFF  9FE,A08
05970:  MOVFF  9FD,A07
05974:  MOVFF  9FC,A06
05978:  MOVLB  0
0597A:  CALL   3524
0597E:  MOVF   01,F
05980:  BNZ   599E
....................          if (SD_write_data(Buffer, 0xFE)) 
05982:  MOVFF  9FB,A02
05986:  MOVFF  9FA,A01
0598A:  MOVLW  FE
0598C:  MOVLB  A
0598E:  MOVWF  x03
05990:  MOVLB  0
05992:  RCALL  5860
05994:  MOVF   01,F
05996:  BZ    599E
....................             SectorCount = 0; 
05998:  MOVLB  A
0599A:  CLRF   x00
0599C:  MOVLB  0
....................       } 
0599E:  BRA    5A3C
059A0:  MOVLB  A
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
059A2:  MOVLB  4
059A4:  MOVF   xE7,W
059A6:  ANDLW  03
059A8:  BZ    59D6
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
059AA:  MOVLW  77
059AC:  MOVLB  A
059AE:  MOVWF  x05
059B0:  CLRF   x09
059B2:  CLRF   x08
059B4:  CLRF   x07
059B6:  CLRF   x06
059B8:  MOVLB  0
059BA:  CALL   3524
....................          SD_cmd(SD_ACMD23, SectorCount); 
059BE:  MOVLW  57
059C0:  MOVLB  A
059C2:  MOVWF  x05
059C4:  CLRF   x09
059C6:  CLRF   x08
059C8:  CLRF   x07
059CA:  MOVFF  A00,A06
059CE:  MOVLB  0
059D0:  CALL   3524
059D4:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
059D6:  MOVLW  59
059D8:  MOVLB  A
059DA:  MOVWF  x05
059DC:  MOVFF  9FF,A09
059E0:  MOVFF  9FE,A08
059E4:  MOVFF  9FD,A07
059E8:  MOVFF  9FC,A06
059EC:  MOVLB  0
059EE:  CALL   3524
059F2:  MOVF   01,F
059F4:  BNZ   5A3C
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
059F6:  MOVFF  9FB,A02
059FA:  MOVFF  9FA,A01
059FE:  MOVLW  FC
05A00:  MOVLB  A
05A02:  MOVWF  x03
05A04:  MOVLB  0
05A06:  RCALL  5860
05A08:  MOVF   01,F
05A0A:  BNZ   5A0E
....................                break; 
05A0C:  BRA    5A22
....................             Buffer += 512; 
05A0E:  MOVLW  02
05A10:  MOVLB  9
05A12:  ADDWF  xFB,F
....................             } while (--SectorCount); 
05A14:  MOVLB  A
05A16:  DECF   x00,F
05A18:  BTFSC  FD8.2
05A1A:  BRA    5A20
05A1C:  MOVLB  0
05A1E:  BRA    59F6
05A20:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
05A22:  MOVLB  A
05A24:  CLRF   x02
05A26:  CLRF   x01
05A28:  MOVLW  FD
05A2A:  MOVWF  x03
05A2C:  MOVLB  0
05A2E:  RCALL  5860
05A30:  MOVF   01,F
05A32:  BNZ   5A3C
....................             SectorCount = 1; 
05A34:  MOVLW  01
05A36:  MOVLB  A
05A38:  MOVWF  x00
05A3A:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
05A3C:  BSF    F91.1
....................    SD_spi_read(0xFF); 
05A3E:  MOVF   FC9,W
05A40:  SETF   FC9
05A42:  RRCF   FC7,W
05A44:  BNC   5A42
....................    return SectorCount ? RES_ERROR : RES_OK; 
05A46:  MOVLB  A
05A48:  MOVF   x00,F
05A4A:  BZ    5A50
05A4C:  MOVLW  01
05A4E:  BRA    5A52
05A50:  MOVLW  00
05A52:  MOVWF  01
05A54:  MOVLB  4
05A56:  MOVLB  0
05A58:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
044B0:  MOVLB  4
044B2:  BTFSS  xED.0
044B4:  BRA    44BC
....................       return (RES_NOTRDY); 
044B6:  MOVLW  03
044B8:  MOVWF  01
044BA:  BRA    45EE
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
044BC:  MOVLB  A
044BE:  MOVF   x00,W
044C0:  SUBLW  01
044C2:  BNC   44C8
044C4:  MOVF   x00,F
044C6:  BNZ   44D2
....................       return(RES_PARERR); 
044C8:  MOVLW  04
044CA:  MOVWF  01
044CC:  MOVLB  4
044CE:  BRA    45EE
044D0:  MOVLB  A
....................  
....................    SelectSD; 
044D2:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
044D4:  CLRF   x04
044D6:  CLRF   x03
044D8:  MOVLW  02
044DA:  MOVWF  x02
044DC:  CLRF   x01
044DE:  MOVLB  0
044E0:  BRA    43B8
044E2:  MOVF   01,F
044E4:  BNZ   44F2
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
044E6:  BSF    F91.1
....................       return(RES_ERROR); 
044E8:  MOVLW  01
044EA:  MOVWF  01
044EC:  MOVLB  4
044EE:  BRA    45EE
044F0:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
044F2:  MOVLB  4
044F4:  MOVF   xE7,W
044F6:  SUBLW  05
044F8:  BZ    4514
....................       SectorNumber *= 512; 
044FA:  BCF    FD8.0
044FC:  MOVFF  9FE,9FF
04500:  MOVFF  9FD,9FE
04504:  MOVFF  9FC,9FD
04508:  MOVLB  9
0450A:  CLRF   xFC
0450C:  RLCF   xFD,F
0450E:  RLCF   xFE,F
04510:  RLCF   xFF,F
04512:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
04514:  MOVLB  A
04516:  DECFSZ x00,W
04518:  BRA    4570
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
0451A:  MOVLW  51
0451C:  MOVWF  x05
0451E:  MOVFF  9FF,A09
04522:  MOVFF  9FE,A08
04526:  MOVFF  9FD,A07
0452A:  MOVFF  9FC,A06
0452E:  MOVLB  0
04530:  CALL   3524
04534:  MOVF   01,F
04536:  BZ    4544
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
04538:  BSF    F91.1
....................          return(RES_PARERR); 
0453A:  MOVLW  04
0453C:  MOVWF  01
0453E:  MOVLB  4
04540:  BRA    45EE
04542:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
04544:  MOVFF  9FB,A02
04548:  MOVFF  9FA,A01
0454C:  MOVLB  A
0454E:  CLRF   x06
04550:  CLRF   x05
04552:  MOVLW  02
04554:  MOVWF  x04
04556:  CLRF   x03
04558:  MOVLB  0
0455A:  RCALL  4402
0455C:  MOVF   01,F
0455E:  BZ    456C
....................          { 
....................          DeselectSD; 
04560:  BSF    F91.1
....................          return(RES_ERROR); 
04562:  MOVLW  01
04564:  MOVWF  01
04566:  MOVLB  4
04568:  BRA    45EE
0456A:  MOVLB  0
....................          } 
....................       } 
0456C:  BRA    45E6
0456E:  MOVLB  A
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
04570:  MOVLW  52
04572:  MOVWF  x05
04574:  MOVFF  9FF,A09
04578:  MOVFF  9FE,A08
0457C:  MOVFF  9FD,A07
04580:  MOVFF  9FC,A06
04584:  MOVLB  0
04586:  CALL   3524
0458A:  MOVF   01,F
0458C:  BZ    459A
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
0458E:  BSF    F91.1
....................          return(RES_PARERR); 
04590:  MOVLW  04
04592:  MOVWF  01
04594:  MOVLB  4
04596:  BRA    45EE
04598:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
0459A:  MOVFF  9FB,A02
0459E:  MOVFF  9FA,A01
045A2:  MOVLB  A
045A4:  CLRF   x06
045A6:  CLRF   x05
045A8:  MOVLW  02
045AA:  MOVWF  x04
045AC:  CLRF   x03
045AE:  MOVLB  0
045B0:  RCALL  4402
045B2:  MOVF   01,F
045B4:  BZ    45C2
....................             { 
....................             DeselectSD; 
045B6:  BSF    F91.1
....................             return(RES_ERROR); 
045B8:  MOVLW  01
045BA:  MOVWF  01
045BC:  MOVLB  4
045BE:  BRA    45EE
045C0:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
045C2:  MOVLW  02
045C4:  MOVLB  9
045C6:  ADDWF  xFB,F
....................          } while (--SectorCount); 
045C8:  MOVLB  A
045CA:  DECF   x00,F
045CC:  BTFSC  FD8.2
045CE:  BRA    45D4
045D0:  MOVLB  0
045D2:  BRA    459A
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
045D4:  MOVLW  4C
045D6:  MOVWF  x05
045D8:  CLRF   x09
045DA:  CLRF   x08
045DC:  CLRF   x07
045DE:  CLRF   x06
045E0:  MOVLB  0
045E2:  CALL   3524
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
045E6:  BSF    F91.1
....................    return(RES_OK); 
045E8:  MOVLW  00
045EA:  MOVWF  01
045EC:  MOVLB  4
045EE:  MOVLB  0
045F0:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
05574:  MOVLB  4
05576:  BCF    xED.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
05578:  BCF    xED.2
....................  
....................    return(Media_Status); 
0557A:  MOVFF  4ED,01
0557E:  MOVLB  0
05580:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
0365A:  MOVLB  9
0365C:  CLRF   xC9
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
0365E:  MOVLB  4
03660:  CLRF   xE7
....................  
....................    DeselectSD; 
03662:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
03664:  MOVLW  0A
03666:  MOVLB  A
03668:  MOVWF  xA2
0366A:  MOVLB  0
0366C:  CALL   0588
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
03670:  BCF    FC6.5
03672:  MOVLW  22
03674:  MOVWF  FC6
03676:  MOVLW  40
03678:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
0367A:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
0367C:  MOVLB  9
0367E:  CLRF   xC1
03680:  MOVF   xC1,W
03682:  SUBLW  09
03684:  BNC   3692
....................       SD_spi_read(0xFF); 
03686:  MOVF   FC9,W
03688:  SETF   FC9
0368A:  RRCF   FC7,W
0368C:  BNC   368A
0368E:  INCF   xC1,F
03690:  BRA    3680
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
03692:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
03694:  MOVF   1F,W
03696:  SUBLW  04
03698:  BNZ   36BE
0369A:  MOVF   20,F
0369C:  BNZ   36BE
0369E:  MOVLW  A0
036A0:  MOVWF  FF6
036A2:  MOVLW  06
036A4:  MOVWF  FF7
036A6:  MOVLW  00
036A8:  MOVWF  FF8
036AA:  CLRF   1B
036AC:  BTFSC  FF2.7
036AE:  BSF    1B.7
036B0:  BCF    FF2.7
036B2:  MOVLB  0
036B4:  CALL   0E78
036B8:  BTFSC  1B.7
036BA:  BSF    FF2.7
036BC:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
036BE:  MOVLW  40
036C0:  MOVLB  A
036C2:  MOVWF  x05
036C4:  CLRF   x09
036C6:  CLRF   x08
036C8:  CLRF   x07
036CA:  CLRF   x06
036CC:  MOVLB  0
036CE:  RCALL  3524
036D0:  MOVFF  01,9C2
....................    if (response > 1 ) 
036D4:  MOVLB  9
036D6:  MOVF   xC2,W
036D8:  SUBLW  01
036DA:  BC    3730
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
036DC:  MOVF   1F,W
036DE:  SUBLW  04
036E0:  BNZ   372A
036E2:  MOVF   20,F
036E4:  BNZ   372A
036E6:  MOVLW  B0
036E8:  MOVWF  FF6
036EA:  MOVLW  06
036EC:  MOVWF  FF7
036EE:  MOVLW  00
036F0:  MOVWF  FF8
036F2:  CLRF   1B
036F4:  BTFSC  FF2.7
036F6:  BSF    1B.7
036F8:  BCF    FF2.7
036FA:  MOVLW  31
036FC:  MOVLB  A
036FE:  MOVWF  x19
03700:  MOVLB  0
03702:  CALL   104E
03706:  BTFSC  1B.7
03708:  BSF    FF2.7
0370A:  MOVFF  9C2,9CA
0370E:  MOVLW  57
03710:  MOVLB  9
03712:  MOVWF  xCB
03714:  MOVLB  0
03716:  RCALL  35F4
03718:  MOVLW  0D
0371A:  BTFSS  F9E.4
0371C:  BRA    371A
0371E:  MOVWF  FAD
03720:  MOVLW  0A
03722:  BTFSS  F9E.4
03724:  BRA    3722
03726:  MOVWF  FAD
03728:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
0372A:  BSF    xC9.0
....................       goto Exit_disk_initialize; 
0372C:  GOTO   43AE
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
03730:  MOVF   1F,W
03732:  SUBLW  04
03734:  BNZ   377E
03736:  MOVF   20,F
03738:  BNZ   377E
0373A:  MOVLW  E8
0373C:  MOVWF  FF6
0373E:  MOVLW  06
03740:  MOVWF  FF7
03742:  MOVLW  00
03744:  MOVWF  FF8
03746:  CLRF   1B
03748:  BTFSC  FF2.7
0374A:  BSF    1B.7
0374C:  BCF    FF2.7
0374E:  MOVLW  1A
03750:  MOVLB  A
03752:  MOVWF  x19
03754:  MOVLB  0
03756:  CALL   104E
0375A:  BTFSC  1B.7
0375C:  BSF    FF2.7
0375E:  MOVFF  9C2,9CA
03762:  MOVLW  57
03764:  MOVLB  9
03766:  MOVWF  xCB
03768:  MOVLB  0
0376A:  RCALL  35F4
0376C:  MOVLW  0D
0376E:  BTFSS  F9E.4
03770:  BRA    376E
03772:  MOVWF  FAD
03774:  MOVLW  0A
03776:  BTFSS  F9E.4
03778:  BRA    3776
0377A:  MOVWF  FAD
0377C:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
0377E:  MOVLW  48
03780:  MOVLB  A
03782:  MOVWF  x05
03784:  CLRF   x09
03786:  CLRF   x08
03788:  MOVLW  01
0378A:  MOVWF  x07
0378C:  MOVLW  AA
0378E:  MOVWF  x06
03790:  MOVLB  0
03792:  RCALL  3524
03794:  MOVFF  01,9C2
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
03798:  MOVF   1F,W
0379A:  SUBLW  04
0379C:  BNZ   37E4
0379E:  MOVF   20,F
037A0:  BNZ   37E4
037A2:  MOVLW  0A
037A4:  MOVWF  FF6
037A6:  MOVLW  07
037A8:  MOVWF  FF7
037AA:  MOVLW  00
037AC:  MOVWF  FF8
037AE:  CLRF   1B
037B0:  BTFSC  FF2.7
037B2:  BSF    1B.7
037B4:  BCF    FF2.7
037B6:  MOVLW  25
037B8:  MOVLB  A
037BA:  MOVWF  x19
037BC:  MOVLB  0
037BE:  CALL   104E
037C2:  BTFSC  1B.7
037C4:  BSF    FF2.7
037C6:  MOVFF  9C2,9CA
037CA:  MOVLW  57
037CC:  MOVLB  9
037CE:  MOVWF  xCB
037D0:  MOVLB  0
037D2:  RCALL  35F4
037D4:  MOVLW  0D
037D6:  BTFSS  F9E.4
037D8:  BRA    37D6
037DA:  MOVWF  FAD
037DC:  MOVLW  0A
037DE:  BTFSS  F9E.4
037E0:  BRA    37DE
037E2:  MOVWF  FAD
....................    if (response == 1)  
037E4:  MOVLB  9
037E6:  DECFSZ xC2,W
037E8:  BRA    3BBA
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
037EA:  MOVF   1F,W
037EC:  SUBLW  04
037EE:  BNZ   3814
037F0:  MOVF   20,F
037F2:  BNZ   3814
037F4:  MOVLW  34
037F6:  MOVWF  FF6
037F8:  MOVLW  07
037FA:  MOVWF  FF7
037FC:  MOVLW  00
037FE:  MOVWF  FF8
03800:  CLRF   1B
03802:  BTFSC  FF2.7
03804:  BSF    1B.7
03806:  BCF    FF2.7
03808:  MOVLB  0
0380A:  CALL   0E78
0380E:  BTFSC  1B.7
03810:  BSF    FF2.7
03812:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
03814:  CLRF   xC1
03816:  MOVF   xC1,W
03818:  SUBLW  03
0381A:  BNC   383A
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
0381C:  CLRF   03
0381E:  MOVF   xC1,W
03820:  ADDLW  C3
03822:  MOVWF  FE9
03824:  MOVLW  09
03826:  ADDWFC 03,W
03828:  MOVWF  FEA
0382A:  MOVF   FC9,W
0382C:  SETF   FC9
0382E:  RRCF   FC7,W
03830:  BNC   382E
03832:  MOVFF  FC9,FEF
03836:  INCF   xC1,F
03838:  BRA    3816
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
0383A:  MOVF   1F,W
0383C:  SUBLW  04
0383E:  BNZ   38B2
03840:  MOVF   20,F
03842:  BNZ   38B2
03844:  MOVLW  56
03846:  MOVWF  FF6
03848:  MOVLW  07
0384A:  MOVWF  FF7
0384C:  MOVLW  00
0384E:  MOVWF  FF8
03850:  CLRF   1B
03852:  BTFSC  FF2.7
03854:  BSF    1B.7
03856:  BCF    FF2.7
03858:  MOVLW  1F
0385A:  MOVLB  A
0385C:  MOVWF  x19
0385E:  MOVLB  0
03860:  CALL   104E
03864:  BTFSC  1B.7
03866:  BSF    FF2.7
03868:  MOVFF  9C3,9CA
0386C:  MOVLW  57
0386E:  MOVLB  9
03870:  MOVWF  xCB
03872:  MOVLB  0
03874:  RCALL  35F4
03876:  MOVFF  9C4,9CA
0387A:  MOVLW  57
0387C:  MOVLB  9
0387E:  MOVWF  xCB
03880:  MOVLB  0
03882:  RCALL  35F4
03884:  MOVFF  9C5,9CA
03888:  MOVLW  57
0388A:  MOVLB  9
0388C:  MOVWF  xCB
0388E:  MOVLB  0
03890:  RCALL  35F4
03892:  MOVFF  9C6,9CA
03896:  MOVLW  57
03898:  MOVLB  9
0389A:  MOVWF  xCB
0389C:  MOVLB  0
0389E:  RCALL  35F4
038A0:  MOVLW  0D
038A2:  BTFSS  F9E.4
038A4:  BRA    38A2
038A6:  MOVWF  FAD
038A8:  MOVLW  0A
038AA:  BTFSS  F9E.4
038AC:  BRA    38AA
038AE:  MOVWF  FAD
038B0:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
038B2:  DECFSZ xC5,W
038B4:  BRA    3B90
038B6:  MOVF   xC6,W
038B8:  SUBLW  AA
038BA:  BTFSS  FD8.2
038BC:  BRA    3B90
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
038BE:  MOVF   1F,W
038C0:  SUBLW  04
038C2:  BNZ   38E8
038C4:  MOVF   20,F
038C6:  BNZ   38E8
038C8:  MOVLW  88
038CA:  MOVWF  FF6
038CC:  MOVLW  07
038CE:  MOVWF  FF7
038D0:  MOVLW  00
038D2:  MOVWF  FF8
038D4:  CLRF   1B
038D6:  BTFSC  FF2.7
038D8:  BSF    1B.7
038DA:  BCF    FF2.7
038DC:  MOVLB  0
038DE:  CALL   0E78
038E2:  BTFSC  1B.7
038E4:  BSF    FF2.7
038E6:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
038E8:  MOVF   1F,W
038EA:  SUBLW  04
038EC:  BNZ   3912
038EE:  MOVF   20,F
038F0:  BNZ   3912
038F2:  MOVLW  AE
038F4:  MOVWF  FF6
038F6:  MOVLW  07
038F8:  MOVWF  FF7
038FA:  MOVLW  00
038FC:  MOVWF  FF8
038FE:  CLRF   1B
03900:  BTFSC  FF2.7
03902:  BSF    1B.7
03904:  BCF    FF2.7
03906:  MOVLB  0
03908:  CALL   0E78
0390C:  BTFSC  1B.7
0390E:  BSF    FF2.7
03910:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
03912:  CLRF   xC8
03914:  CLRF   xC7
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
03916:  MOVLW  77
03918:  MOVLB  A
0391A:  MOVWF  x05
0391C:  CLRF   x09
0391E:  CLRF   x08
03920:  CLRF   x07
03922:  CLRF   x06
03924:  MOVLB  0
03926:  RCALL  3524
03928:  MOVFF  01,9C2
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
0392C:  MOVLW  69
0392E:  MOVLB  A
03930:  MOVWF  x05
03932:  MOVLW  40
03934:  MOVWF  x09
03936:  CLRF   x08
03938:  CLRF   x07
0393A:  CLRF   x06
0393C:  MOVLB  0
0393E:  RCALL  3524
03940:  MOVFF  01,9C2
....................          while (response && (Timer < 50000)) 
03944:  MOVLB  9
03946:  MOVF   xC2,F
03948:  BZ    399A
0394A:  MOVF   xC8,W
0394C:  SUBLW  C3
0394E:  BNC   399A
03950:  BNZ   3958
03952:  MOVF   xC7,W
03954:  SUBLW  4F
03956:  BNC   399A
....................          { 
....................             delay_us(20); 
03958:  MOVLW  6A
0395A:  MOVWF  00
0395C:  DECFSZ 00,F
0395E:  BRA    395C
03960:  NOP   
....................             Timer++; 
03962:  INCF   xC7,F
03964:  BTFSC  FD8.2
03966:  INCF   xC8,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
03968:  MOVLW  77
0396A:  MOVLB  A
0396C:  MOVWF  x05
0396E:  CLRF   x09
03970:  CLRF   x08
03972:  CLRF   x07
03974:  CLRF   x06
03976:  MOVLB  0
03978:  RCALL  3524
0397A:  MOVFF  01,9C2
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
0397E:  MOVLW  69
03980:  MOVLB  A
03982:  MOVWF  x05
03984:  MOVLW  40
03986:  MOVWF  x09
03988:  CLRF   x08
0398A:  CLRF   x07
0398C:  CLRF   x06
0398E:  MOVLB  0
03990:  RCALL  3524
03992:  MOVFF  01,9C2
03996:  BRA    3944
03998:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
0399A:  MOVF   1F,W
0399C:  SUBLW  04
0399E:  BNZ   3A28
039A0:  MOVF   20,F
039A2:  BNZ   3A28
039A4:  MOVLW  DC
039A6:  MOVWF  FF6
039A8:  MOVLW  07
039AA:  MOVWF  FF7
039AC:  MOVLW  00
039AE:  MOVWF  FF8
039B0:  CLRF   1B
039B2:  BTFSC  FF2.7
039B4:  BSF    1B.7
039B6:  BCF    FF2.7
039B8:  MOVLW  23
039BA:  MOVLB  A
039BC:  MOVWF  x19
039BE:  MOVLB  0
039C0:  CALL   104E
039C4:  BTFSC  1B.7
039C6:  BSF    FF2.7
039C8:  MOVFF  9C2,9CA
039CC:  MOVLW  57
039CE:  MOVLB  9
039D0:  MOVWF  xCB
039D2:  MOVLB  0
039D4:  RCALL  35F4
039D6:  MOVLW  03
039D8:  MOVWF  FF6
039DA:  MOVLW  08
039DC:  MOVWF  FF7
039DE:  MOVLW  00
039E0:  MOVWF  FF8
039E2:  CLRF   1B
039E4:  BTFSC  FF2.7
039E6:  BSF    1B.7
039E8:  BCF    FF2.7
039EA:  MOVLW  0A
039EC:  MOVLB  A
039EE:  MOVWF  x19
039F0:  MOVLB  0
039F2:  CALL   104E
039F6:  BTFSC  1B.7
039F8:  BSF    FF2.7
039FA:  MOVLW  10
039FC:  MOVWF  FE9
039FE:  CLRF   1B
03A00:  BTFSC  FF2.7
03A02:  BSF    1B.7
03A04:  BCF    FF2.7
03A06:  MOVFF  9C8,A1A
03A0A:  MOVFF  9C7,A19
03A0E:  CALL   11D0
03A12:  BTFSC  1B.7
03A14:  BSF    FF2.7
03A16:  MOVLW  0D
03A18:  BTFSS  F9E.4
03A1A:  BRA    3A18
03A1C:  MOVWF  FAD
03A1E:  MOVLW  0A
03A20:  BTFSS  F9E.4
03A22:  BRA    3A20
03A24:  MOVWF  FAD
03A26:  MOVLB  9
....................          if (!response) 
03A28:  MOVF   xC2,F
03A2A:  BTFSS  FD8.2
03A2C:  BRA    3B8E
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
03A2E:  MOVLW  7A
03A30:  MOVLB  A
03A32:  MOVWF  x05
03A34:  MOVLW  40
03A36:  MOVWF  x09
03A38:  CLRF   x08
03A3A:  CLRF   x07
03A3C:  CLRF   x06
03A3E:  MOVLB  0
03A40:  RCALL  3524
03A42:  MOVFF  01,9C2
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
03A46:  MOVF   1F,W
03A48:  SUBLW  04
03A4A:  BNZ   3A92
03A4C:  MOVF   20,F
03A4E:  BNZ   3A92
03A50:  MOVLW  14
03A52:  MOVWF  FF6
03A54:  MOVLW  08
03A56:  MOVWF  FF7
03A58:  MOVLW  00
03A5A:  MOVWF  FF8
03A5C:  CLRF   1B
03A5E:  BTFSC  FF2.7
03A60:  BSF    1B.7
03A62:  BCF    FF2.7
03A64:  MOVLW  18
03A66:  MOVLB  A
03A68:  MOVWF  x19
03A6A:  MOVLB  0
03A6C:  CALL   104E
03A70:  BTFSC  1B.7
03A72:  BSF    FF2.7
03A74:  MOVFF  9C2,9CA
03A78:  MOVLW  57
03A7A:  MOVLB  9
03A7C:  MOVWF  xCB
03A7E:  MOVLB  0
03A80:  RCALL  35F4
03A82:  MOVLW  0D
03A84:  BTFSS  F9E.4
03A86:  BRA    3A84
03A88:  MOVWF  FAD
03A8A:  MOVLW  0A
03A8C:  BTFSS  F9E.4
03A8E:  BRA    3A8C
03A90:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03A92:  MOVLB  9
03A94:  MOVF   xC2,F
03A96:  BTFSS  FD8.2
03A98:  BRA    3B8E
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03A9A:  CLRF   xC1
03A9C:  MOVF   xC1,W
03A9E:  SUBLW  03
03AA0:  BNC   3AC0
....................                   ocr[i] = SD_spi_read(0xFF); 
03AA2:  CLRF   03
03AA4:  MOVF   xC1,W
03AA6:  ADDLW  C3
03AA8:  MOVWF  FE9
03AAA:  MOVLW  09
03AAC:  ADDWFC 03,W
03AAE:  MOVWF  FEA
03AB0:  MOVF   FC9,W
03AB2:  SETF   FC9
03AB4:  RRCF   FC7,W
03AB6:  BNC   3AB4
03AB8:  MOVFF  FC9,FEF
03ABC:  INCF   xC1,F
03ABE:  BRA    3A9C
....................                if (ocr[0] & 0x40) 
03AC0:  BTFSS  xC3.6
03AC2:  BRA    3ACE
....................                   Card = SDHC; 
03AC4:  MOVLW  05
03AC6:  MOVLB  4
03AC8:  MOVWF  xE7
03ACA:  BRA    3AD4
03ACC:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03ACE:  MOVLW  04
03AD0:  MOVLB  4
03AD2:  MOVWF  xE7
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03AD4:  MOVF   1F,W
03AD6:  SUBLW  04
03AD8:  BNZ   3B8C
03ADA:  MOVF   20,F
03ADC:  BNZ   3B8C
03ADE:  MOVLW  32
03AE0:  MOVWF  FF6
03AE2:  MOVLW  08
03AE4:  MOVWF  FF7
03AE6:  MOVLW  00
03AE8:  MOVWF  FF8
03AEA:  CLRF   1B
03AEC:  BTFSC  FF2.7
03AEE:  BSF    1B.7
03AF0:  BCF    FF2.7
03AF2:  MOVLW  1F
03AF4:  MOVLB  A
03AF6:  MOVWF  x19
03AF8:  MOVLB  0
03AFA:  CALL   104E
03AFE:  BTFSC  1B.7
03B00:  BSF    FF2.7
03B02:  MOVLW  10
03B04:  MOVWF  FE9
03B06:  CLRF   1B
03B08:  BTFSC  FF2.7
03B0A:  BSF    1B.7
03B0C:  BCF    FF2.7
03B0E:  MOVFF  9C8,A1A
03B12:  MOVFF  9C7,A19
03B16:  CALL   11D0
03B1A:  BTFSC  1B.7
03B1C:  BSF    FF2.7
03B1E:  MOVLW  54
03B20:  MOVWF  FF6
03B22:  MOVLW  08
03B24:  MOVWF  FF7
03B26:  MOVLW  00
03B28:  MOVWF  FF8
03B2A:  CLRF   1B
03B2C:  BTFSC  FF2.7
03B2E:  BSF    1B.7
03B30:  BCF    FF2.7
03B32:  MOVLW  08
03B34:  MOVLB  A
03B36:  MOVWF  x19
03B38:  MOVLB  0
03B3A:  CALL   104E
03B3E:  BTFSC  1B.7
03B40:  BSF    FF2.7
03B42:  MOVFF  9C3,9CA
03B46:  MOVLW  57
03B48:  MOVLB  9
03B4A:  MOVWF  xCB
03B4C:  MOVLB  0
03B4E:  RCALL  35F4
03B50:  MOVFF  9C4,9CA
03B54:  MOVLW  57
03B56:  MOVLB  9
03B58:  MOVWF  xCB
03B5A:  MOVLB  0
03B5C:  RCALL  35F4
03B5E:  MOVFF  9C5,9CA
03B62:  MOVLW  57
03B64:  MOVLB  9
03B66:  MOVWF  xCB
03B68:  MOVLB  0
03B6A:  RCALL  35F4
03B6C:  MOVFF  9C6,9CA
03B70:  MOVLW  57
03B72:  MOVLB  9
03B74:  MOVWF  xCB
03B76:  MOVLB  0
03B78:  RCALL  35F4
03B7A:  MOVLW  0D
03B7C:  BTFSS  F9E.4
03B7E:  BRA    3B7C
03B80:  MOVWF  FAD
03B82:  MOVLW  0A
03B84:  BTFSS  F9E.4
03B86:  BRA    3B84
03B88:  MOVWF  FAD
03B8A:  MOVLB  4
03B8C:  MOVLB  9
....................             } 
....................          } 
....................       } 
03B8E:  BRA    3BBA
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03B90:  MOVF   1F,W
03B92:  SUBLW  04
03B94:  BNZ   3BBA
03B96:  MOVF   20,F
03B98:  BNZ   3BBA
03B9A:  MOVLW  70
03B9C:  MOVWF  FF6
03B9E:  MOVLW  08
03BA0:  MOVWF  FF7
03BA2:  MOVLW  00
03BA4:  MOVWF  FF8
03BA6:  CLRF   1B
03BA8:  BTFSC  FF2.7
03BAA:  BSF    1B.7
03BAC:  BCF    FF2.7
03BAE:  MOVLB  0
03BB0:  CALL   0E78
03BB4:  BTFSC  1B.7
03BB6:  BSF    FF2.7
03BB8:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03BBA:  MOVLB  4
03BBC:  MOVF   xE7,F
03BBE:  BTFSS  FD8.2
03BC0:  BRA    4090
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03BC2:  MOVF   1F,W
03BC4:  SUBLW  04
03BC6:  BNZ   3BEC
03BC8:  MOVF   20,F
03BCA:  BNZ   3BEC
03BCC:  MOVLW  A2
03BCE:  MOVWF  FF6
03BD0:  MOVLW  08
03BD2:  MOVWF  FF7
03BD4:  MOVLW  00
03BD6:  MOVWF  FF8
03BD8:  CLRF   1B
03BDA:  BTFSC  FF2.7
03BDC:  BSF    1B.7
03BDE:  BCF    FF2.7
03BE0:  MOVLB  0
03BE2:  CALL   0E78
03BE6:  BTFSC  1B.7
03BE8:  BSF    FF2.7
03BEA:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03BEC:  MOVLW  40
03BEE:  MOVLB  A
03BF0:  MOVWF  x05
03BF2:  CLRF   x09
03BF4:  CLRF   x08
03BF6:  CLRF   x07
03BF8:  CLRF   x06
03BFA:  MOVLB  0
03BFC:  RCALL  3524
03BFE:  MOVFF  01,9C2
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03C02:  MOVF   1F,W
03C04:  SUBLW  04
03C06:  BNZ   3C4E
03C08:  MOVF   20,F
03C0A:  BNZ   3C4E
03C0C:  MOVLW  E2
03C0E:  MOVWF  FF6
03C10:  MOVLW  08
03C12:  MOVWF  FF7
03C14:  MOVLW  00
03C16:  MOVWF  FF8
03C18:  CLRF   1B
03C1A:  BTFSC  FF2.7
03C1C:  BSF    1B.7
03C1E:  BCF    FF2.7
03C20:  MOVLW  1C
03C22:  MOVLB  A
03C24:  MOVWF  x19
03C26:  MOVLB  0
03C28:  CALL   104E
03C2C:  BTFSC  1B.7
03C2E:  BSF    FF2.7
03C30:  MOVFF  9C2,9CA
03C34:  MOVLW  57
03C36:  MOVLB  9
03C38:  MOVWF  xCB
03C3A:  MOVLB  0
03C3C:  RCALL  35F4
03C3E:  MOVLW  0D
03C40:  BTFSS  F9E.4
03C42:  BRA    3C40
03C44:  MOVWF  FAD
03C46:  MOVLW  0A
03C48:  BTFSS  F9E.4
03C4A:  BRA    3C48
03C4C:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03C4E:  MOVLB  9
03C50:  DECFSZ xC2,W
03C52:  BRA    3C56
03C54:  BRA    3C60
03C56:  MOVF   xC2,F
03C58:  BZ    3C60
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03C5A:  BSF    xC9.0
....................          goto Exit_disk_initialize; 
03C5C:  GOTO   43AE
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03C60:  CLRF   xC8
03C62:  CLRF   xC7
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03C64:  MOVLW  41
03C66:  MOVLB  A
03C68:  MOVWF  x05
03C6A:  CLRF   x09
03C6C:  CLRF   x08
03C6E:  CLRF   x07
03C70:  CLRF   x06
03C72:  MOVLB  0
03C74:  RCALL  3524
03C76:  MOVFF  01,9C2
....................          if (response != 0x00 ) 
03C7A:  MOVLB  9
03C7C:  MOVF   xC2,F
03C7E:  BZ    3C88
....................             delay_us(10); 
03C80:  MOVLW  35
03C82:  MOVWF  00
03C84:  DECFSZ 00,F
03C86:  BRA    3C84
....................          Timer++; 
03C88:  INCF   xC7,F
03C8A:  BTFSC  FD8.2
03C8C:  INCF   xC8,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03C8E:  MOVF   xC2,F
03C90:  BZ    3CA0
03C92:  MOVF   xC8,W
03C94:  SUBLW  C3
03C96:  BNC   3CA0
03C98:  BNZ   3C64
03C9A:  MOVF   xC7,W
03C9C:  SUBLW  4F
03C9E:  BC    3C64
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03CA0:  MOVF   1F,W
03CA2:  SUBLW  04
03CA4:  BNZ   3D2E
03CA6:  MOVF   20,F
03CA8:  BNZ   3D2E
03CAA:  MOVLW  06
03CAC:  MOVWF  FF6
03CAE:  MOVLW  09
03CB0:  MOVWF  FF7
03CB2:  MOVLW  00
03CB4:  MOVWF  FF8
03CB6:  CLRF   1B
03CB8:  BTFSC  FF2.7
03CBA:  BSF    1B.7
03CBC:  BCF    FF2.7
03CBE:  MOVLW  28
03CC0:  MOVLB  A
03CC2:  MOVWF  x19
03CC4:  MOVLB  0
03CC6:  CALL   104E
03CCA:  BTFSC  1B.7
03CCC:  BSF    FF2.7
03CCE:  MOVFF  9C2,9CA
03CD2:  MOVLW  57
03CD4:  MOVLB  9
03CD6:  MOVWF  xCB
03CD8:  MOVLB  0
03CDA:  RCALL  35F4
03CDC:  MOVLW  32
03CDE:  MOVWF  FF6
03CE0:  MOVLW  09
03CE2:  MOVWF  FF7
03CE4:  MOVLW  00
03CE6:  MOVWF  FF8
03CE8:  CLRF   1B
03CEA:  BTFSC  FF2.7
03CEC:  BSF    1B.7
03CEE:  BCF    FF2.7
03CF0:  MOVLW  0A
03CF2:  MOVLB  A
03CF4:  MOVWF  x19
03CF6:  MOVLB  0
03CF8:  CALL   104E
03CFC:  BTFSC  1B.7
03CFE:  BSF    FF2.7
03D00:  MOVLW  10
03D02:  MOVWF  FE9
03D04:  CLRF   1B
03D06:  BTFSC  FF2.7
03D08:  BSF    1B.7
03D0A:  BCF    FF2.7
03D0C:  MOVFF  9C8,A1A
03D10:  MOVFF  9C7,A19
03D14:  CALL   11D0
03D18:  BTFSC  1B.7
03D1A:  BSF    FF2.7
03D1C:  MOVLW  0D
03D1E:  BTFSS  F9E.4
03D20:  BRA    3D1E
03D22:  MOVWF  FAD
03D24:  MOVLW  0A
03D26:  BTFSS  F9E.4
03D28:  BRA    3D26
03D2A:  MOVWF  FAD
03D2C:  MOVLB  9
....................       if(response) 
03D2E:  MOVF   xC2,F
03D30:  BZ    3D36
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03D32:  BSF    xC9.0
....................          goto Exit_disk_initialize; 
03D34:  BRA    43AE
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03D36:  MOVLW  77
03D38:  MOVLB  A
03D3A:  MOVWF  x05
03D3C:  CLRF   x09
03D3E:  CLRF   x08
03D40:  CLRF   x07
03D42:  CLRF   x06
03D44:  MOVLB  0
03D46:  CALL   3524
03D4A:  MOVFF  01,9C2
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03D4E:  MOVF   1F,W
03D50:  SUBLW  04
03D52:  BNZ   3D9A
03D54:  MOVF   20,F
03D56:  BNZ   3D9A
03D58:  MOVLW  42
03D5A:  MOVWF  FF6
03D5C:  MOVLW  09
03D5E:  MOVWF  FF7
03D60:  MOVLW  00
03D62:  MOVWF  FF8
03D64:  CLRF   1B
03D66:  BTFSC  FF2.7
03D68:  BSF    1B.7
03D6A:  BCF    FF2.7
03D6C:  MOVLW  43
03D6E:  MOVLB  A
03D70:  MOVWF  x19
03D72:  MOVLB  0
03D74:  CALL   104E
03D78:  BTFSC  1B.7
03D7A:  BSF    FF2.7
03D7C:  MOVFF  9C2,9CA
03D80:  MOVLW  57
03D82:  MOVLB  9
03D84:  MOVWF  xCB
03D86:  MOVLB  0
03D88:  RCALL  35F4
03D8A:  MOVLW  0D
03D8C:  BTFSS  F9E.4
03D8E:  BRA    3D8C
03D90:  MOVWF  FAD
03D92:  MOVLW  0A
03D94:  BTFSS  F9E.4
03D96:  BRA    3D94
03D98:  MOVWF  FAD
....................       if (response) 
03D9A:  MOVLB  9
03D9C:  MOVF   xC2,F
03D9E:  BZ    3DAA
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03DA0:  MOVLW  02
03DA2:  MOVLB  4
03DA4:  MOVWF  xE7
....................          } 
03DA6:  BRA    3FA4
03DA8:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03DAA:  MOVLW  69
03DAC:  MOVLB  A
03DAE:  MOVWF  x05
03DB0:  CLRF   x09
03DB2:  CLRF   x08
03DB4:  CLRF   x07
03DB6:  CLRF   x06
03DB8:  MOVLB  0
03DBA:  CALL   3524
03DBE:  MOVFF  01,9C2
....................          if (response <= 1 ) 
03DC2:  MOVLB  9
03DC4:  MOVF   xC2,W
03DC6:  SUBLW  01
03DC8:  BNC   3DD4
....................             Card = SDv1; 
03DCA:  MOVLW  03
03DCC:  MOVLB  4
03DCE:  MOVWF  xE7
03DD0:  BRA    3FA4
03DD2:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03DD4:  MOVF   1F,W
03DD6:  SUBLW  04
03DD8:  BNZ   3E38
03DDA:  MOVF   20,F
03DDC:  BNZ   3E38
03DDE:  MOVLW  8C
03DE0:  MOVWF  FF6
03DE2:  MOVLW  09
03DE4:  MOVWF  FF7
03DE6:  MOVLW  00
03DE8:  MOVWF  FF8
03DEA:  CLRF   1B
03DEC:  BTFSC  FF2.7
03DEE:  BSF    1B.7
03DF0:  BCF    FF2.7
03DF2:  MOVLW  2E
03DF4:  MOVLB  A
03DF6:  MOVWF  x19
03DF8:  MOVLB  0
03DFA:  CALL   104E
03DFE:  BTFSC  1B.7
03E00:  BSF    FF2.7
03E02:  MOVFF  9C2,9CA
03E06:  MOVLW  37
03E08:  MOVLB  9
03E0A:  MOVWF  xCB
03E0C:  MOVLB  0
03E0E:  CALL   35F4
03E12:  MOVLW  BE
03E14:  MOVWF  FF6
03E16:  MOVLW  09
03E18:  MOVWF  FF7
03E1A:  MOVLW  00
03E1C:  MOVWF  FF8
03E1E:  CLRF   1B
03E20:  BTFSC  FF2.7
03E22:  BSF    1B.7
03E24:  BCF    FF2.7
03E26:  MOVLW  19
03E28:  MOVLB  A
03E2A:  MOVWF  x19
03E2C:  MOVLB  0
03E2E:  CALL   104E
03E32:  BTFSC  1B.7
03E34:  BSF    FF2.7
03E36:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03E38:  MOVLW  40
03E3A:  MOVLB  A
03E3C:  MOVWF  x05
03E3E:  CLRF   x09
03E40:  CLRF   x08
03E42:  CLRF   x07
03E44:  CLRF   x06
03E46:  MOVLB  0
03E48:  CALL   3524
03E4C:  MOVFF  01,9C2
....................             if ((response !=0x01) && (response != 0)) 
03E50:  MOVLB  9
03E52:  DECFSZ xC2,W
03E54:  BRA    3E58
03E56:  BRA    3EC4
03E58:  MOVF   xC2,F
03E5A:  BZ    3EC4
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03E5C:  MOVF   1F,W
03E5E:  SUBLW  04
03E60:  BNZ   3EC0
03E62:  MOVF   20,F
03E64:  BNZ   3EC0
03E66:  MOVLW  D8
03E68:  MOVWF  FF6
03E6A:  MOVLW  09
03E6C:  MOVWF  FF7
03E6E:  MOVLW  00
03E70:  MOVWF  FF8
03E72:  CLRF   1B
03E74:  BTFSC  FF2.7
03E76:  BSF    1B.7
03E78:  BCF    FF2.7
03E7A:  MOVLW  2C
03E7C:  MOVLB  A
03E7E:  MOVWF  x19
03E80:  MOVLB  0
03E82:  CALL   104E
03E86:  BTFSC  1B.7
03E88:  BSF    FF2.7
03E8A:  MOVFF  9C2,9CA
03E8E:  MOVLW  37
03E90:  MOVLB  9
03E92:  MOVWF  xCB
03E94:  MOVLB  0
03E96:  CALL   35F4
03E9A:  MOVLW  08
03E9C:  MOVWF  FF6
03E9E:  MOVLW  0A
03EA0:  MOVWF  FF7
03EA2:  MOVLW  00
03EA4:  MOVWF  FF8
03EA6:  CLRF   1B
03EA8:  BTFSC  FF2.7
03EAA:  BSF    1B.7
03EAC:  BCF    FF2.7
03EAE:  MOVLW  0B
03EB0:  MOVLB  A
03EB2:  MOVWF  x19
03EB4:  MOVLB  0
03EB6:  CALL   104E
03EBA:  BTFSC  1B.7
03EBC:  BSF    FF2.7
03EBE:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03EC0:  BSF    xC9.0
....................                goto Exit_disk_initialize; 
03EC2:  BRA    43AE
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03EC4:  CLRF   xC8
03EC6:  CLRF   xC7
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03EC8:  MOVLW  41
03ECA:  MOVLB  A
03ECC:  MOVWF  x05
03ECE:  CLRF   x09
03ED0:  CLRF   x08
03ED2:  CLRF   x07
03ED4:  CLRF   x06
03ED6:  MOVLB  0
03ED8:  CALL   3524
03EDC:  MOVFF  01,9C2
....................                if (response != 0x00 ) 
03EE0:  MOVLB  9
03EE2:  MOVF   xC2,F
03EE4:  BZ    3EEE
....................                   delay_us(10); 
03EE6:  MOVLW  35
03EE8:  MOVWF  00
03EEA:  DECFSZ 00,F
03EEC:  BRA    3EEA
....................                Timer++; 
03EEE:  INCF   xC7,F
03EF0:  BTFSC  FD8.2
03EF2:  INCF   xC8,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03EF4:  MOVF   xC2,F
03EF6:  BZ    3F06
03EF8:  MOVF   xC8,W
03EFA:  SUBLW  C3
03EFC:  BNC   3F06
03EFE:  BNZ   3EC8
03F00:  MOVF   xC7,W
03F02:  SUBLW  4F
03F04:  BC    3EC8
....................     
....................             if(response) 
03F06:  MOVF   xC2,F
03F08:  BZ    3F9E
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03F0A:  MOVF   1F,W
03F0C:  SUBLW  04
03F0E:  BNZ   3F9A
03F10:  MOVF   20,F
03F12:  BNZ   3F9A
03F14:  MOVLW  14
03F16:  MOVWF  FF6
03F18:  MOVLW  0A
03F1A:  MOVWF  FF7
03F1C:  MOVLW  00
03F1E:  MOVWF  FF8
03F20:  CLRF   1B
03F22:  BTFSC  FF2.7
03F24:  BSF    1B.7
03F26:  BCF    FF2.7
03F28:  MOVLW  4A
03F2A:  MOVLB  A
03F2C:  MOVWF  x19
03F2E:  MOVLB  0
03F30:  CALL   104E
03F34:  BTFSC  1B.7
03F36:  BSF    FF2.7
03F38:  MOVFF  9C2,9CA
03F3C:  MOVLW  37
03F3E:  MOVLB  9
03F40:  MOVWF  xCB
03F42:  MOVLB  0
03F44:  CALL   35F4
03F48:  MOVLW  62
03F4A:  MOVWF  FF6
03F4C:  MOVLW  0A
03F4E:  MOVWF  FF7
03F50:  MOVLW  00
03F52:  MOVWF  FF8
03F54:  CLRF   1B
03F56:  BTFSC  FF2.7
03F58:  BSF    1B.7
03F5A:  BCF    FF2.7
03F5C:  MOVLW  0A
03F5E:  MOVLB  A
03F60:  MOVWF  x19
03F62:  MOVLB  0
03F64:  CALL   104E
03F68:  BTFSC  1B.7
03F6A:  BSF    FF2.7
03F6C:  MOVLW  10
03F6E:  MOVWF  FE9
03F70:  CLRF   1B
03F72:  BTFSC  FF2.7
03F74:  BSF    1B.7
03F76:  BCF    FF2.7
03F78:  MOVFF  9C8,A1A
03F7C:  MOVFF  9C7,A19
03F80:  CALL   11D0
03F84:  BTFSC  1B.7
03F86:  BSF    FF2.7
03F88:  MOVLW  0D
03F8A:  BTFSS  F9E.4
03F8C:  BRA    3F8A
03F8E:  MOVWF  FAD
03F90:  MOVLW  0A
03F92:  BTFSS  F9E.4
03F94:  BRA    3F92
03F96:  MOVWF  FAD
03F98:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03F9A:  BSF    xC9.0
....................                goto Exit_disk_initialize; 
03F9C:  BRA    43AE
....................                } 
....................  
....................             Card = MMC; 
03F9E:  MOVLW  02
03FA0:  MOVLB  4
03FA2:  MOVWF  xE7
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
03FA4:  MOVF   1F,W
03FA6:  SUBLW  04
03FA8:  BNZ   3FCE
03FAA:  MOVF   20,F
03FAC:  BNZ   3FCE
03FAE:  MOVLW  72
03FB0:  MOVWF  FF6
03FB2:  MOVLW  0A
03FB4:  MOVWF  FF7
03FB6:  MOVLW  00
03FB8:  MOVWF  FF8
03FBA:  CLRF   1B
03FBC:  BTFSC  FF2.7
03FBE:  BSF    1B.7
03FC0:  BCF    FF2.7
03FC2:  MOVLB  0
03FC4:  CALL   0E78
03FC8:  BTFSC  1B.7
03FCA:  BSF    FF2.7
03FCC:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
03FCE:  MOVLW  50
03FD0:  MOVLB  A
03FD2:  MOVWF  x05
03FD4:  CLRF   x09
03FD6:  CLRF   x08
03FD8:  MOVLW  02
03FDA:  MOVWF  x07
03FDC:  CLRF   x06
03FDE:  MOVLB  0
03FE0:  CALL   3524
03FE4:  MOVFF  01,9C2
....................       if ((Timer == 50000) || (response > 1))    
03FE8:  MOVLB  9
03FEA:  MOVF   xC7,W
03FEC:  SUBLW  50
03FEE:  BNZ   3FF6
03FF0:  MOVF   xC8,W
03FF2:  SUBLW  C3
03FF4:  BZ    3FFC
03FF6:  MOVF   xC2,W
03FF8:  SUBLW  01
03FFA:  BC    4092
....................       { 
....................          Card = None; 
03FFC:  MOVLB  4
03FFE:  CLRF   xE7
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
04000:  MOVF   1F,W
04002:  SUBLW  04
04004:  BNZ   4090
04006:  MOVF   20,F
04008:  BNZ   4090
0400A:  MOVLW  8E
0400C:  MOVWF  FF6
0400E:  MOVLW  0A
04010:  MOVWF  FF7
04012:  MOVLW  00
04014:  MOVWF  FF8
04016:  CLRF   1B
04018:  BTFSC  FF2.7
0401A:  BSF    1B.7
0401C:  BCF    FF2.7
0401E:  MOVLW  2B
04020:  MOVLB  A
04022:  MOVWF  x19
04024:  MOVLB  0
04026:  CALL   104E
0402A:  BTFSC  1B.7
0402C:  BSF    FF2.7
0402E:  MOVFF  9C2,9CA
04032:  MOVLW  57
04034:  MOVLB  9
04036:  MOVWF  xCB
04038:  MOVLB  0
0403A:  CALL   35F4
0403E:  MOVLW  BD
04040:  MOVWF  FF6
04042:  MOVLW  0A
04044:  MOVWF  FF7
04046:  MOVLW  00
04048:  MOVWF  FF8
0404A:  CLRF   1B
0404C:  BTFSC  FF2.7
0404E:  BSF    1B.7
04050:  BCF    FF2.7
04052:  MOVLW  0A
04054:  MOVLB  A
04056:  MOVWF  x19
04058:  MOVLB  0
0405A:  CALL   104E
0405E:  BTFSC  1B.7
04060:  BSF    FF2.7
04062:  MOVLW  10
04064:  MOVWF  FE9
04066:  CLRF   1B
04068:  BTFSC  FF2.7
0406A:  BSF    1B.7
0406C:  BCF    FF2.7
0406E:  MOVFF  9C8,A1A
04072:  MOVFF  9C7,A19
04076:  CALL   11D0
0407A:  BTFSC  1B.7
0407C:  BSF    FF2.7
0407E:  MOVLW  0D
04080:  BTFSS  F9E.4
04082:  BRA    4080
04084:  MOVWF  FAD
04086:  MOVLW  0A
04088:  BTFSS  F9E.4
0408A:  BRA    4088
0408C:  MOVWF  FAD
0408E:  MOVLB  4
04090:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
04092:  MOVLB  4
04094:  MOVF   xE7,F
04096:  BNZ   40CA
....................    { 
....................       if (nv_report_mode == 4) 
04098:  MOVF   1F,W
0409A:  SUBLW  04
0409C:  BNZ   40C2
0409E:  MOVF   20,F
040A0:  BNZ   40C2
....................          printf("@FS:Card Type Discovery Error\r\n"); 
040A2:  MOVLW  CE
040A4:  MOVWF  FF6
040A6:  MOVLW  0A
040A8:  MOVWF  FF7
040AA:  MOVLW  00
040AC:  MOVWF  FF8
040AE:  CLRF   1B
040B0:  BTFSC  FF2.7
040B2:  BSF    1B.7
040B4:  BCF    FF2.7
040B6:  MOVLB  0
040B8:  CALL   0E78
040BC:  BTFSC  1B.7
040BE:  BSF    FF2.7
040C0:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
040C2:  MOVLB  9
040C4:  BSF    xC9.0
....................       goto Exit_disk_initialize; 
040C6:  BRA    43AE
040C8:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
040CA:  MOVF   xE7,W
040CC:  XORLW  02
040CE:  MOVLB  0
040D0:  BZ    40E0
040D2:  XORLW  01
040D4:  BZ    4108
040D6:  XORLW  07
040D8:  BZ    4130
040DA:  XORLW  01
040DC:  BZ    4158
040DE:  BRA    4180
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
040E0:  MOVF   1F,W
040E2:  SUBLW  04
040E4:  BNZ   4106
040E6:  MOVF   20,F
040E8:  BNZ   4106
040EA:  MOVLW  EE
040EC:  MOVWF  FF6
040EE:  MOVLW  0A
040F0:  MOVWF  FF7
040F2:  MOVLW  00
040F4:  MOVWF  FF8
040F6:  CLRF   1B
040F8:  BTFSC  FF2.7
040FA:  BSF    1B.7
040FC:  BCF    FF2.7
040FE:  CALL   0E78
04102:  BTFSC  1B.7
04104:  BSF    FF2.7
....................          break; 
04106:  BRA    41D6
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
04108:  MOVF   1F,W
0410A:  SUBLW  04
0410C:  BNZ   412E
0410E:  MOVF   20,F
04110:  BNZ   412E
04112:  MOVLW  04
04114:  MOVWF  FF6
04116:  MOVLW  0B
04118:  MOVWF  FF7
0411A:  MOVLW  00
0411C:  MOVWF  FF8
0411E:  CLRF   1B
04120:  BTFSC  FF2.7
04122:  BSF    1B.7
04124:  BCF    FF2.7
04126:  CALL   0E78
0412A:  BTFSC  1B.7
0412C:  BSF    FF2.7
....................          break; 
0412E:  BRA    41D6
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
04130:  MOVF   1F,W
04132:  SUBLW  04
04134:  BNZ   4156
04136:  MOVF   20,F
04138:  BNZ   4156
0413A:  MOVLW  1A
0413C:  MOVWF  FF6
0413E:  MOVLW  0B
04140:  MOVWF  FF7
04142:  MOVLW  00
04144:  MOVWF  FF8
04146:  CLRF   1B
04148:  BTFSC  FF2.7
0414A:  BSF    1B.7
0414C:  BCF    FF2.7
0414E:  CALL   0E78
04152:  BTFSC  1B.7
04154:  BSF    FF2.7
....................          break; 
04156:  BRA    41D6
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
04158:  MOVF   1F,W
0415A:  SUBLW  04
0415C:  BNZ   417E
0415E:  MOVF   20,F
04160:  BNZ   417E
04162:  MOVLW  30
04164:  MOVWF  FF6
04166:  MOVLW  0B
04168:  MOVWF  FF7
0416A:  MOVLW  00
0416C:  MOVWF  FF8
0416E:  CLRF   1B
04170:  BTFSC  FF2.7
04172:  BSF    1B.7
04174:  BCF    FF2.7
04176:  CALL   0E78
0417A:  BTFSC  1B.7
0417C:  BSF    FF2.7
....................          break; 
0417E:  BRA    41D6
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
04180:  MOVF   1F,W
04182:  SUBLW  04
04184:  BNZ   41CE
04186:  MOVF   20,F
04188:  BNZ   41CE
0418A:  MOVLW  46
0418C:  MOVWF  FF6
0418E:  MOVLW  0B
04190:  MOVWF  FF7
04192:  MOVLW  00
04194:  MOVWF  FF8
04196:  CLRF   1B
04198:  BTFSC  FF2.7
0419A:  BSF    1B.7
0419C:  BCF    FF2.7
0419E:  MOVLW  26
041A0:  MOVLB  A
041A2:  MOVWF  x19
041A4:  MOVLB  0
041A6:  CALL   104E
041AA:  BTFSC  1B.7
041AC:  BSF    FF2.7
041AE:  MOVFF  4E7,9CA
041B2:  MOVLW  37
041B4:  MOVLB  9
041B6:  MOVWF  xCB
041B8:  MOVLB  0
041BA:  CALL   35F4
041BE:  MOVLW  0D
041C0:  BTFSS  F9E.4
041C2:  BRA    41C0
041C4:  MOVWF  FAD
041C6:  MOVLW  0A
041C8:  BTFSS  F9E.4
041CA:  BRA    41C8
041CC:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
041CE:  MOVLB  9
041D0:  BSF    xC9.0
....................          goto Exit_disk_initialize; 
041D2:  BRA    43AE
041D4:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
041D6:  MOVLB  9
041D8:  BCF    xC9.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
041DA:  MOVF   1F,W
041DC:  SUBLW  04
041DE:  BNZ   4236
041E0:  MOVF   20,F
041E2:  BNZ   4236
041E4:  MOVLW  74
041E6:  MOVWF  FF6
041E8:  MOVLW  0B
041EA:  MOVWF  FF7
041EC:  MOVLW  00
041EE:  MOVWF  FF8
041F0:  CLRF   1B
041F2:  BTFSC  FF2.7
041F4:  BSF    1B.7
041F6:  BCF    FF2.7
041F8:  MOVLW  2E
041FA:  MOVLB  A
041FC:  MOVWF  x19
041FE:  MOVLB  0
04200:  CALL   104E
04204:  BTFSC  1B.7
04206:  BSF    FF2.7
04208:  MOVLW  10
0420A:  MOVWF  FE9
0420C:  CLRF   1B
0420E:  BTFSC  FF2.7
04210:  BSF    1B.7
04212:  BCF    FF2.7
04214:  MOVFF  9C8,A1A
04218:  MOVFF  9C7,A19
0421C:  CALL   11D0
04220:  BTFSC  1B.7
04222:  BSF    FF2.7
04224:  MOVLW  0D
04226:  BTFSS  F9E.4
04228:  BRA    4226
0422A:  MOVWF  FAD
0422C:  MOVLW  0A
0422E:  BTFSS  F9E.4
04230:  BRA    422E
04232:  MOVWF  FAD
04234:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
04236:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
04238:  BCF    FC6.5
0423A:  MOVLW  20
0423C:  MOVWF  FC6
0423E:  MOVLW  40
04240:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
04242:  BCF    F9E.3
....................    SelectSD; 
04244:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
04246:  MOVF   1F,W
04248:  SUBLW  04
0424A:  BNZ   4270
0424C:  MOVF   20,F
0424E:  BNZ   4270
04250:  MOVLW  A8
04252:  MOVWF  FF6
04254:  MOVLW  0B
04256:  MOVWF  FF7
04258:  MOVLW  00
0425A:  MOVWF  FF8
0425C:  CLRF   1B
0425E:  BTFSC  FF2.7
04260:  BSF    1B.7
04262:  BCF    FF2.7
04264:  MOVLB  0
04266:  CALL   0E78
0426A:  BTFSC  1B.7
0426C:  BSF    FF2.7
0426E:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
04270:  CLRF   xC8
04272:  CLRF   xC7
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
04274:  MOVLW  41
04276:  MOVLB  A
04278:  MOVWF  x05
0427A:  CLRF   x09
0427C:  CLRF   x08
0427E:  CLRF   x07
04280:  CLRF   x06
04282:  MOVLB  0
04284:  CALL   3524
04288:  MOVFF  01,9C2
....................       if (response != 0x00 ) 
0428C:  MOVLB  9
0428E:  MOVF   xC2,F
04290:  BZ    429A
....................          delay_us(10); 
04292:  MOVLW  35
04294:  MOVWF  00
04296:  DECFSZ 00,F
04298:  BRA    4296
....................  
....................       Timer++; 
0429A:  INCF   xC7,F
0429C:  BTFSC  FD8.2
0429E:  INCF   xC8,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
042A0:  MOVF   xC2,F
042A2:  BZ    42B2
042A4:  MOVF   xC8,W
042A6:  SUBLW  C3
042A8:  BNC   42B2
042AA:  BNZ   4274
042AC:  MOVF   xC7,W
042AE:  SUBLW  4F
042B0:  BC    4274
....................  
....................    if (response != 0x00) 
042B2:  MOVF   xC2,F
042B4:  BZ    434A
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
042B6:  MOVF   1F,W
042B8:  SUBLW  04
042BA:  BNZ   4346
042BC:  MOVF   20,F
042BE:  BNZ   4346
042C0:  MOVLW  C8
042C2:  MOVWF  FF6
042C4:  MOVLW  0B
042C6:  MOVWF  FF7
042C8:  MOVLW  00
042CA:  MOVWF  FF8
042CC:  CLRF   1B
042CE:  BTFSC  FF2.7
042D0:  BSF    1B.7
042D2:  BCF    FF2.7
042D4:  MOVLW  26
042D6:  MOVLB  A
042D8:  MOVWF  x19
042DA:  MOVLB  0
042DC:  CALL   104E
042E0:  BTFSC  1B.7
042E2:  BSF    FF2.7
042E4:  MOVFF  9C2,9CA
042E8:  MOVLW  37
042EA:  MOVLB  9
042EC:  MOVWF  xCB
042EE:  MOVLB  0
042F0:  CALL   35F4
042F4:  MOVLW  F2
042F6:  MOVWF  FF6
042F8:  MOVLW  0B
042FA:  MOVWF  FF7
042FC:  MOVLW  00
042FE:  MOVWF  FF8
04300:  CLRF   1B
04302:  BTFSC  FF2.7
04304:  BSF    1B.7
04306:  BCF    FF2.7
04308:  MOVLW  0A
0430A:  MOVLB  A
0430C:  MOVWF  x19
0430E:  MOVLB  0
04310:  CALL   104E
04314:  BTFSC  1B.7
04316:  BSF    FF2.7
04318:  MOVLW  10
0431A:  MOVWF  FE9
0431C:  CLRF   1B
0431E:  BTFSC  FF2.7
04320:  BSF    1B.7
04322:  BCF    FF2.7
04324:  MOVFF  9C8,A1A
04328:  MOVFF  9C7,A19
0432C:  CALL   11D0
04330:  BTFSC  1B.7
04332:  BSF    FF2.7
04334:  MOVLW  0D
04336:  BTFSS  F9E.4
04338:  BRA    4336
0433A:  MOVWF  FAD
0433C:  MOVLW  0A
0433E:  BTFSS  F9E.4
04340:  BRA    433E
04342:  MOVWF  FAD
04344:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
04346:  BSF    xC9.0
....................       goto Exit_disk_initialize; 
04348:  BRA    43AE
....................    } 
....................  
....................    if (nv_report_mode == 4) 
0434A:  MOVF   1F,W
0434C:  SUBLW  04
0434E:  BNZ   43A6
04350:  MOVF   20,F
04352:  BNZ   43A6
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
04354:  MOVLW  02
04356:  MOVWF  FF6
04358:  MOVLW  0C
0435A:  MOVWF  FF7
0435C:  MOVLW  00
0435E:  MOVWF  FF8
04360:  CLRF   1B
04362:  BTFSC  FF2.7
04364:  BSF    1B.7
04366:  BCF    FF2.7
04368:  MOVLW  25
0436A:  MOVLB  A
0436C:  MOVWF  x19
0436E:  MOVLB  0
04370:  CALL   104E
04374:  BTFSC  1B.7
04376:  BSF    FF2.7
04378:  MOVLW  10
0437A:  MOVWF  FE9
0437C:  CLRF   1B
0437E:  BTFSC  FF2.7
04380:  BSF    1B.7
04382:  BCF    FF2.7
04384:  MOVFF  9C8,A1A
04388:  MOVFF  9C7,A19
0438C:  CALL   11D0
04390:  BTFSC  1B.7
04392:  BSF    FF2.7
04394:  MOVLW  0D
04396:  BTFSS  F9E.4
04398:  BRA    4396
0439A:  MOVWF  FAD
0439C:  MOVLW  0A
0439E:  BTFSS  F9E.4
043A0:  BRA    439E
043A2:  MOVWF  FAD
043A4:  MOVLB  9
....................  
....................    msg_card_ok(); 
043A6:  MOVLB  0
043A8:  GOTO   363A
043AC:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
043AE:  BSF    F91.1
....................    return(SDCardStatus); 
043B0:  MOVFF  9C9,01
043B4:  MOVLB  0
043B6:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05A5A:  MOVLW  20
05A5C:  MOVLB  7
05A5E:  ADDWF  x12,W
05A60:  MOVWF  FE9
05A62:  MOVLW  00
05A64:  ADDWFC x13,W
05A66:  MOVWF  FEA
05A68:  MOVFF  FEF,9F2
05A6C:  MOVFF  FEC,9F3
05A70:  MOVFF  FEC,9F4
05A74:  MOVFF  FEC,9F5
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05A78:  MOVLB  9
05A7A:  MOVF   xEE,W
05A7C:  SUBWF  xF2,W
05A7E:  BNZ   5A94
05A80:  MOVF   xEF,W
05A82:  SUBWF  xF3,W
05A84:  BNZ   5A94
05A86:  MOVF   xF0,W
05A88:  SUBWF  xF4,W
05A8A:  BNZ   5A94
05A8C:  MOVF   xF1,W
05A8E:  SUBWF  xF5,W
05A90:  BTFSC  FD8.2
05A92:  BRA    5C6E
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05A94:  MOVLW  06
05A96:  MOVLB  7
05A98:  ADDWF  x12,W
05A9A:  MOVWF  FE9
05A9C:  MOVLW  00
05A9E:  ADDWFC x13,W
05AA0:  MOVWF  FEA
05AA2:  MOVF   FEF,F
05AA4:  BTFSC  FD8.2
05AA6:  BRA    5BF6
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05AA8:  MOVLW  24
05AAA:  ADDWF  x12,W
05AAC:  MOVWF  01
05AAE:  MOVLW  00
05AB0:  ADDWFC x13,W
05AB2:  MOVWF  03
05AB4:  MOVFF  01,9F8
05AB8:  MOVLB  9
05ABA:  MOVWF  xF9
05ABC:  MOVWF  xFB
05ABE:  MOVFF  01,9FA
05AC2:  MOVFF  9F5,9FF
05AC6:  MOVFF  9F4,9FE
05ACA:  MOVFF  9F3,9FD
05ACE:  MOVFF  9F2,9FC
05AD2:  MOVLW  01
05AD4:  MOVLB  A
05AD6:  MOVWF  x00
05AD8:  MOVLB  0
05ADA:  RCALL  5914
05ADC:  MOVFF  01,9F6
....................             if (response != RES_OK) 
05AE0:  MOVLB  9
05AE2:  MOVF   xF6,F
05AE4:  BZ    5AEC
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05AE6:  MOVLW  00
05AE8:  MOVWF  01
05AEA:  BRA    5C72
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05AEC:  MOVLW  06
05AEE:  MOVLB  7
05AF0:  ADDWF  x12,W
05AF2:  MOVWF  FE9
05AF4:  MOVLW  00
05AF6:  ADDWFC x13,W
05AF8:  MOVWF  FEA
05AFA:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05AFC:  MOVLW  10
05AFE:  ADDWF  x12,W
05B00:  MOVWF  FE9
05B02:  MOVLW  00
05B04:  ADDWFC x13,W
05B06:  MOVWF  FEA
05B08:  MOVFF  FEF,9F8
05B0C:  MOVFF  FEC,9F9
05B10:  MOVFF  FEC,9FA
05B14:  MOVFF  FEC,9FB
05B18:  MOVLW  08
05B1A:  ADDWF  x12,W
05B1C:  MOVWF  FE9
05B1E:  MOVLW  00
05B20:  ADDWFC x13,W
05B22:  MOVWF  FEA
05B24:  MOVFF  FEF,00
05B28:  MOVFF  FEC,01
05B2C:  MOVFF  FEC,02
05B30:  MOVFF  FEC,03
05B34:  MOVLB  9
05B36:  MOVF   xF8,W
05B38:  ADDWF  00,F
05B3A:  MOVF   xF9,W
05B3C:  ADDWFC 01,F
05B3E:  MOVF   xFA,W
05B40:  ADDWFC 02,F
05B42:  MOVF   xFB,W
05B44:  ADDWFC 03,F
05B46:  MOVF   xF5,W
05B48:  SUBWF  03,W
05B4A:  BNC   5BF4
05B4C:  BNZ   5B64
05B4E:  MOVF   xF4,W
05B50:  SUBWF  02,W
05B52:  BNC   5BF4
05B54:  BNZ   5B64
05B56:  MOVF   xF3,W
05B58:  SUBWF  01,W
05B5A:  BNC   5BF4
05B5C:  BNZ   5B64
05B5E:  MOVF   00,W
05B60:  SUBWF  xF2,W
05B62:  BC    5BF4
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05B64:  MOVLW  03
05B66:  MOVLB  7
05B68:  ADDWF  x12,W
05B6A:  MOVWF  FE9
05B6C:  MOVLW  00
05B6E:  ADDWFC x13,W
05B70:  MOVWF  FEA
05B72:  MOVFF  FEF,9F7
05B76:  MOVLB  9
05B78:  MOVF   xF7,W
05B7A:  SUBLW  01
05B7C:  BC    5BF4
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05B7E:  MOVLW  08
05B80:  MOVLB  7
05B82:  ADDWF  x12,W
05B84:  MOVWF  FE9
05B86:  MOVLW  00
05B88:  ADDWFC x13,W
05B8A:  MOVWF  FEA
05B8C:  MOVFF  FEF,00
05B90:  MOVFF  FEC,01
05B94:  MOVFF  FEC,02
05B98:  MOVFF  FEC,03
05B9C:  MOVF   00,W
05B9E:  MOVLB  9
05BA0:  ADDWF  xF2,F
05BA2:  MOVF   01,W
05BA4:  ADDWFC xF3,F
05BA6:  MOVF   02,W
05BA8:  ADDWFC xF4,F
05BAA:  MOVF   03,W
05BAC:  ADDWFC xF5,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05BAE:  MOVLW  24
05BB0:  MOVLB  7
05BB2:  ADDWF  x12,W
05BB4:  MOVWF  01
05BB6:  MOVLW  00
05BB8:  ADDWFC x13,W
05BBA:  MOVWF  03
05BBC:  MOVFF  01,9F8
05BC0:  MOVLB  9
05BC2:  MOVWF  xF9
05BC4:  MOVWF  xFB
05BC6:  MOVFF  01,9FA
05BCA:  MOVFF  9F5,9FF
05BCE:  MOVFF  9F4,9FE
05BD2:  MOVFF  9F3,9FD
05BD6:  MOVFF  9F2,9FC
05BDA:  MOVLW  01
05BDC:  MOVLB  A
05BDE:  MOVWF  x00
05BE0:  MOVLB  0
05BE2:  RCALL  5914
05BE4:  MOVF   01,F
05BE6:  BZ    5BEE
....................                      break; 
05BE8:  MOVLB  9
05BEA:  BRA    5BF4
05BEC:  MOVLB  0
05BEE:  MOVLB  9
05BF0:  DECF   xF7,F
05BF2:  BRA    5B78
05BF4:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05BF6:  MOVLB  9
05BF8:  MOVF   xEE,F
05BFA:  BNZ   5C08
05BFC:  MOVF   xEF,F
05BFE:  BNZ   5C08
05C00:  MOVF   xF0,F
05C02:  BNZ   5C08
05C04:  MOVF   xF1,F
05C06:  BZ    5C6E
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05C08:  MOVLW  24
05C0A:  MOVLB  7
05C0C:  ADDWF  x12,W
05C0E:  MOVWF  01
05C10:  MOVLW  00
05C12:  ADDWFC x13,W
05C14:  MOVWF  03
05C16:  MOVFF  01,9F8
05C1A:  MOVLB  9
05C1C:  MOVWF  xF9
05C1E:  MOVWF  xFB
05C20:  MOVFF  01,9FA
05C24:  MOVFF  9F1,9FF
05C28:  MOVFF  9F0,9FE
05C2C:  MOVFF  9EF,9FD
05C30:  MOVFF  9EE,9FC
05C34:  MOVLW  01
05C36:  MOVLB  A
05C38:  MOVWF  x00
05C3A:  MOVLB  0
05C3C:  CALL   44B0
05C40:  MOVF   01,F
05C42:  BZ    5C4E
....................             return FALSE; 
05C44:  MOVLW  00
05C46:  MOVWF  01
05C48:  MOVLB  9
05C4A:  BRA    5C72
05C4C:  MOVLB  0
....................          fs->winsect = sector; 
05C4E:  MOVLW  20
05C50:  MOVLB  7
05C52:  ADDWF  x12,W
05C54:  MOVWF  FE9
05C56:  MOVLW  00
05C58:  ADDWFC x13,W
05C5A:  MOVWF  FEA
05C5C:  MOVFF  9EE,FEF
05C60:  MOVFF  9EF,FEC
05C64:  MOVFF  9F0,FEC
05C68:  MOVFF  9F1,FEC
05C6C:  MOVLB  9
....................          } 
....................       } 
....................    return (TRUE); 
05C6E:  MOVLW  01
05C70:  MOVWF  01
05C72:  MOVLB  0
05C74:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05C98:  MOVLB  9
05C9A:  MOVF   xDD,F
05C9C:  BNZ   5CAE
05C9E:  MOVF   xDC,F
05CA0:  BNZ   5CAE
05CA2:  MOVF   xDB,F
05CA4:  BNZ   5CAE
05CA6:  MOVF   xDA,W
05CA8:  SUBLW  01
05CAA:  BTFSC  FD8.0
05CAC:  BRA    5FBE
05CAE:  MOVLW  0C
05CB0:  MOVLB  7
05CB2:  ADDWF  x12,W
05CB4:  MOVWF  FE9
05CB6:  MOVLW  00
05CB8:  ADDWFC x13,W
05CBA:  MOVWF  FEA
05CBC:  MOVFF  FEF,00
05CC0:  MOVFF  FEC,01
05CC4:  MOVFF  FEC,02
05CC8:  MOVFF  FEC,03
05CCC:  MOVLB  9
05CCE:  MOVF   xDD,W
05CD0:  SUBWF  03,W
05CD2:  BTFSS  FD8.0
05CD4:  BRA    5FBE
05CD6:  BNZ   5CF4
05CD8:  MOVF   xDC,W
05CDA:  SUBWF  02,W
05CDC:  BTFSS  FD8.0
05CDE:  BRA    5FBE
05CE0:  BNZ   5CF4
05CE2:  MOVF   xDB,W
05CE4:  SUBWF  01,W
05CE6:  BTFSS  FD8.0
05CE8:  BRA    5FBE
05CEA:  BNZ   5CF4
05CEC:  MOVF   00,W
05CEE:  SUBWF  xDA,W
05CF0:  BTFSC  FD8.0
05CF2:  BRA    5FBE
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05CF4:  MOVLW  10
05CF6:  MOVLB  7
05CF8:  ADDWF  x12,W
05CFA:  MOVWF  FE9
05CFC:  MOVLW  00
05CFE:  ADDWFC x13,W
05D00:  MOVWF  FEA
05D02:  MOVFF  FEF,9E2
05D06:  MOVFF  FEC,9E3
05D0A:  MOVFF  FEC,9E4
05D0E:  MOVFF  FEC,9E5
....................       switch (fs->fs_type)  
05D12:  MOVF   x12,W
05D14:  MOVWF  FE9
05D16:  MOVF   x13,W
05D18:  MOVWF  FEA
05D1A:  MOVF   FEF,W
05D1C:  XORLW  01
05D1E:  MOVLB  0
05D20:  BZ    5D30
05D22:  XORLW  03
05D24:  BTFSC  FD8.2
05D26:  BRA    5E76
05D28:  XORLW  01
05D2A:  BTFSC  FD8.2
05D2C:  BRA    5EF8
05D2E:  BRA    5FC0
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05D30:  MOVFF  9DB,9EB
05D34:  MOVFF  9DA,9EA
05D38:  MOVLB  9
05D3A:  CLRF   xED
05D3C:  MOVLW  03
05D3E:  MOVWF  xEC
05D40:  MOVLB  0
05D42:  RCALL  5C76
05D44:  BCF    FD8.0
05D46:  MOVLB  9
05D48:  RRCF   02,W
05D4A:  MOVWF  xE1
05D4C:  RRCF   01,W
05D4E:  MOVWF  xE0
....................             if (!move_window(fatsect + bc / 512))  
05D50:  BCF    FD8.0
05D52:  CLRF   03
05D54:  RRCF   xE1,W
05D56:  MOVWF  02
05D58:  ADDWF  xE2,W
05D5A:  MOVWF  xE6
05D5C:  MOVF   03,W
05D5E:  ADDWFC xE3,W
05D60:  MOVWF  xE7
05D62:  MOVLW  00
05D64:  ADDWFC xE4,W
05D66:  MOVWF  xE8
05D68:  MOVLW  00
05D6A:  ADDWFC xE5,W
05D6C:  MOVWF  xE9
05D6E:  MOVWF  xF1
05D70:  MOVFF  9E8,9F0
05D74:  MOVFF  9E7,9EF
05D78:  MOVFF  9E6,9EE
05D7C:  MOVLB  0
05D7E:  RCALL  5A5A
05D80:  MOVF   01,F
05D82:  BNZ   5D86
....................                break; 
05D84:  BRA    5FC0
....................             wc = fs->win[bc % 512]; 
05D86:  MOVLB  9
05D88:  MOVF   xE1,W
05D8A:  ANDLW  01
05D8C:  MOVWF  xE7
05D8E:  MOVLW  24
05D90:  ADDWF  xE0,W
05D92:  MOVWF  01
05D94:  MOVLW  00
05D96:  ADDWFC xE7,W
05D98:  MOVWF  03
05D9A:  MOVF   01,W
05D9C:  MOVLB  7
05D9E:  ADDWF  x12,W
05DA0:  MOVWF  FE9
05DA2:  MOVF   x13,W
05DA4:  ADDWFC 03,W
05DA6:  MOVWF  FEA
05DA8:  MOVLB  9
05DAA:  CLRF   xDF
05DAC:  MOVFF  FEF,9DE
....................             bc++; 
05DB0:  INCF   xE0,F
05DB2:  BTFSC  FD8.2
05DB4:  INCF   xE1,F
....................             if (!move_window(fatsect + bc / 512))  
05DB6:  BCF    FD8.0
05DB8:  CLRF   03
05DBA:  RRCF   xE1,W
05DBC:  MOVWF  02
05DBE:  ADDWF  xE2,W
05DC0:  MOVWF  xE6
05DC2:  MOVF   03,W
05DC4:  ADDWFC xE3,W
05DC6:  MOVWF  xE7
05DC8:  MOVLW  00
05DCA:  ADDWFC xE4,W
05DCC:  MOVWF  xE8
05DCE:  MOVLW  00
05DD0:  ADDWFC xE5,W
05DD2:  MOVWF  xE9
05DD4:  MOVWF  xF1
05DD6:  MOVFF  9E8,9F0
05DDA:  MOVFF  9E7,9EF
05DDE:  MOVFF  9E6,9EE
05DE2:  MOVLB  0
05DE4:  RCALL  5A5A
05DE6:  MOVF   01,F
05DE8:  BNZ   5DEC
....................                break; 
05DEA:  BRA    5FC0
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05DEC:  MOVLB  9
05DEE:  MOVF   xE1,W
05DF0:  ANDLW  01
05DF2:  MOVWF  xE7
05DF4:  MOVLW  24
05DF6:  ADDWF  xE0,W
05DF8:  MOVWF  01
05DFA:  MOVLW  00
05DFC:  ADDWFC xE7,W
05DFE:  MOVWF  03
05E00:  MOVF   01,W
05E02:  MOVLB  7
05E04:  ADDWF  x12,W
05E06:  MOVWF  FE9
05E08:  MOVF   x13,W
05E0A:  ADDWFC 03,W
05E0C:  MOVWF  FEA
05E0E:  MOVF   FEF,W
05E10:  MOVLB  9
05E12:  MOVWF  xE8
05E14:  MOVLW  00
05E16:  IORWF  xDE,F
05E18:  MOVF   xE8,W
05E1A:  IORWF  xDF,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05E1C:  MOVF   xDA,W
05E1E:  ANDLW  01
05E20:  MOVWF  00
05E22:  CLRF   01
05E24:  CLRF   02
05E26:  CLRF   03
05E28:  MOVF   00,F
05E2A:  BNZ   5E38
05E2C:  MOVF   01,F
05E2E:  BNZ   5E38
05E30:  MOVF   02,F
05E32:  BNZ   5E38
05E34:  MOVF   03,F
05E36:  BZ    5E5E
05E38:  RRCF   xDF,W
05E3A:  MOVWF  03
05E3C:  RRCF   xDE,W
05E3E:  MOVWF  02
05E40:  RRCF   03,F
05E42:  RRCF   02,F
05E44:  RRCF   03,F
05E46:  RRCF   02,F
05E48:  RRCF   03,F
05E4A:  RRCF   02,F
05E4C:  MOVLW  0F
05E4E:  ANDWF  03,F
05E50:  MOVFF  02,00
05E54:  MOVFF  03,01
05E58:  CLRF   02
05E5A:  CLRF   03
05E5C:  BRA    5E72
05E5E:  MOVFF  9DE,00
05E62:  MOVF   xDF,W
05E64:  ANDLW  0F
05E66:  MOVWF  03
05E68:  MOVF   xDE,W
05E6A:  MOVFF  03,01
05E6E:  CLRF   02
05E70:  CLRF   03
05E72:  BRA    5FCC
05E74:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05E76:  MOVFF  9DB,00
05E7A:  MOVFF  9DC,01
05E7E:  MOVFF  9DD,02
05E82:  CLRF   03
05E84:  MOVF   00,W
05E86:  MOVLB  9
05E88:  ADDWF  xE2,W
05E8A:  MOVWF  xE6
05E8C:  MOVF   xDC,W
05E8E:  ADDWFC xE3,W
05E90:  MOVWF  xE7
05E92:  MOVF   xDD,W
05E94:  ADDWFC xE4,W
05E96:  MOVWF  xE8
05E98:  MOVF   03,W
05E9A:  ADDWFC xE5,W
05E9C:  MOVWF  xE9
05E9E:  MOVWF  xF1
05EA0:  MOVFF  9E8,9F0
05EA4:  MOVFF  9E7,9EF
05EA8:  MOVFF  9E6,9EE
05EAC:  MOVLB  0
05EAE:  RCALL  5A5A
05EB0:  MOVF   01,F
05EB2:  BNZ   5EB6
....................                break; 
05EB4:  BRA    5FC0
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05EB6:  BCF    FD8.0
05EB8:  MOVLB  9
05EBA:  RLCF   xDA,W
05EBC:  MOVWF  xE6
05EBE:  RLCF   xDB,W
05EC0:  MOVWF  xE7
05EC2:  MOVLW  01
05EC4:  ANDWF  xE7,F
05EC6:  MOVLW  24
05EC8:  ADDWF  xE6,W
05ECA:  MOVWF  01
05ECC:  MOVLW  00
05ECE:  ADDWFC xE7,W
05ED0:  MOVWF  03
05ED2:  MOVF   01,W
05ED4:  MOVLB  7
05ED6:  ADDWF  x12,W
05ED8:  MOVWF  01
05EDA:  MOVF   x13,W
05EDC:  ADDWFC 03,F
05EDE:  MOVFF  01,FE9
05EE2:  MOVFF  03,FEA
05EE6:  MOVFF  FEF,00
05EEA:  MOVFF  FEC,01
05EEE:  CLRF   02
05EF0:  CLRF   03
05EF2:  MOVLB  9
05EF4:  BRA    5FCC
05EF6:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05EF8:  MOVLB  9
05EFA:  RRCF   xDD,W
05EFC:  MOVWF  03
05EFE:  RRCF   xDC,W
05F00:  MOVWF  02
05F02:  RRCF   xDB,W
05F04:  MOVWF  01
05F06:  RRCF   xDA,W
05F08:  MOVWF  00
05F0A:  RRCF   03,F
05F0C:  RRCF   02,F
05F0E:  RRCF   01,F
05F10:  RRCF   00,F
05F12:  RRCF   03,F
05F14:  RRCF   02,F
05F16:  RRCF   01,F
05F18:  RRCF   00,F
05F1A:  RRCF   03,F
05F1C:  RRCF   02,F
05F1E:  RRCF   01,F
05F20:  RRCF   00,F
05F22:  RRCF   03,F
05F24:  RRCF   02,F
05F26:  RRCF   01,F
05F28:  RRCF   00,F
05F2A:  RRCF   03,F
05F2C:  RRCF   02,F
05F2E:  RRCF   01,F
05F30:  RRCF   00,F
05F32:  RRCF   03,F
05F34:  RRCF   02,F
05F36:  RRCF   01,F
05F38:  RRCF   00,F
05F3A:  MOVLW  01
05F3C:  ANDWF  03,F
05F3E:  MOVF   00,W
05F40:  ADDWF  xE2,W
05F42:  MOVWF  xE6
05F44:  MOVF   01,W
05F46:  ADDWFC xE3,W
05F48:  MOVWF  xE7
05F4A:  MOVF   02,W
05F4C:  ADDWFC xE4,W
05F4E:  MOVWF  xE8
05F50:  MOVF   03,W
05F52:  ADDWFC xE5,W
05F54:  MOVWF  xE9
05F56:  MOVWF  xF1
05F58:  MOVFF  9E8,9F0
05F5C:  MOVFF  9E7,9EF
05F60:  MOVFF  9E6,9EE
05F64:  MOVLB  0
05F66:  RCALL  5A5A
05F68:  MOVF   01,F
05F6A:  BNZ   5F6E
....................                break; 
05F6C:  BRA    5FC0
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05F6E:  MOVLB  9
05F70:  RLCF   xDA,W
05F72:  MOVWF  xE6
05F74:  RLCF   xDB,W
05F76:  MOVWF  xE7
05F78:  RLCF   xE6,F
05F7A:  RLCF   xE7,F
05F7C:  MOVLW  FC
05F7E:  ANDWF  xE6,F
05F80:  MOVLW  01
05F82:  ANDWF  xE7,F
05F84:  MOVLW  24
05F86:  ADDWF  xE6,W
05F88:  MOVWF  01
05F8A:  MOVLW  00
05F8C:  ADDWFC xE7,W
05F8E:  MOVWF  03
05F90:  MOVF   01,W
05F92:  MOVLB  7
05F94:  ADDWF  x12,W
05F96:  MOVWF  01
05F98:  MOVF   x13,W
05F9A:  ADDWFC 03,F
05F9C:  MOVFF  01,FE9
05FA0:  MOVFF  03,FEA
05FA4:  MOVFF  FEF,00
05FA8:  MOVFF  FEC,01
05FAC:  MOVFF  FEC,02
05FB0:  MOVFF  FEC,9EB
05FB4:  MOVLB  9
05FB6:  MOVF   xEB,W
05FB8:  ANDLW  0F
05FBA:  MOVWF  03
05FBC:  BRA    5FCC
05FBE:  MOVLB  0
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
05FC0:  MOVLW  01
05FC2:  MOVWF  00
05FC4:  CLRF   01
05FC6:  CLRF   02
05FC8:  CLRF   03
05FCA:  MOVLB  9
05FCC:  MOVLB  0
05FCE:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
06592:  MOVLW  10
06594:  MOVLB  7
06596:  ADDWF  x12,W
06598:  MOVWF  FE9
0659A:  MOVLW  00
0659C:  ADDWFC x13,W
0659E:  MOVWF  FEA
065A0:  MOVFF  FEF,9E6
065A4:  MOVFF  FEC,9E7
065A8:  MOVFF  FEC,9E8
065AC:  MOVFF  FEC,9E9
....................    switch (fs->fs_type)  
065B0:  MOVF   x12,W
065B2:  MOVWF  FE9
065B4:  MOVF   x13,W
065B6:  MOVWF  FEA
065B8:  MOVF   FEF,W
065BA:  XORLW  01
065BC:  MOVLB  0
065BE:  BZ    65CE
065C0:  XORLW  03
065C2:  BTFSC  FD8.2
065C4:  BRA    67A6
065C6:  XORLW  01
065C8:  BTFSC  FD8.2
065CA:  BRA    682A
065CC:  BRA    68F2
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
065CE:  MOVFF  9DB,9EB
065D2:  MOVFF  9DA,9EA
065D6:  MOVLB  9
065D8:  CLRF   xED
065DA:  MOVLW  03
065DC:  MOVWF  xEC
065DE:  MOVLB  0
065E0:  CALL   5C76
065E4:  BCF    FD8.0
065E6:  MOVLB  9
065E8:  RRCF   02,W
065EA:  MOVWF  xE3
065EC:  RRCF   01,W
065EE:  MOVWF  xE2
....................          if (!move_window(fatsect + bc / 512)) 
065F0:  BCF    FD8.0
065F2:  CLRF   03
065F4:  RRCF   xE3,W
065F6:  MOVWF  02
065F8:  ADDWF  xE6,W
065FA:  MOVWF  xEA
065FC:  MOVF   03,W
065FE:  ADDWFC xE7,W
06600:  MOVWF  xEB
06602:  MOVLW  00
06604:  ADDWFC xE8,W
06606:  MOVWF  xEC
06608:  MOVLW  00
0660A:  ADDWFC xE9,W
0660C:  MOVWF  xED
0660E:  MOVWF  xF1
06610:  MOVFF  9EC,9F0
06614:  MOVFF  9EB,9EF
06618:  MOVFF  9EA,9EE
0661C:  MOVLB  0
0661E:  CALL   5A5A
06622:  MOVF   01,F
06624:  BNZ   662C
....................             return (FALSE); 
06626:  MOVLW  00
06628:  MOVWF  01
0662A:  BRA    6910
....................          p = &fs->win[bc % 512]; 
0662C:  MOVLB  9
0662E:  MOVF   xE3,W
06630:  ANDLW  01
06632:  MOVWF  xEB
06634:  MOVLW  24
06636:  ADDWF  xE2,W
06638:  MOVWF  01
0663A:  MOVLW  00
0663C:  ADDWFC xEB,W
0663E:  MOVWF  03
06640:  MOVF   01,W
06642:  MOVLB  7
06644:  ADDWF  x12,W
06646:  MOVWF  01
06648:  MOVF   x13,W
0664A:  ADDWFC 03,F
0664C:  MOVFF  01,9E4
06650:  MOVLB  9
06652:  MOVFF  03,9E5
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
06656:  MOVFF  9E4,9EA
0665A:  MOVFF  9E5,9EB
0665E:  MOVF   xDA,W
06660:  ANDLW  01
06662:  MOVWF  00
06664:  CLRF   01
06666:  CLRF   02
06668:  CLRF   03
0666A:  MOVF   00,F
0666C:  BNZ   667A
0666E:  MOVF   01,F
06670:  BNZ   667A
06672:  MOVF   02,F
06674:  BNZ   667A
06676:  MOVF   03,F
06678:  BZ    669A
0667A:  MOVFF  9E5,03
0667E:  MOVFF  9E4,FE9
06682:  MOVFF  9E5,FEA
06686:  MOVF   FEF,W
06688:  ANDLW  0F
0668A:  MOVWF  xEC
0668C:  SWAPF  xDE,W
0668E:  MOVWF  00
06690:  MOVLW  F0
06692:  ANDWF  00,F
06694:  MOVF   00,W
06696:  IORWF  xEC,W
06698:  BRA    669C
0669A:  MOVF   xDE,W
0669C:  MOVFF  9EB,FEA
066A0:  MOVFF  9EA,FE9
066A4:  MOVWF  FEF
....................          fs->winflag = 1; 
066A6:  MOVLW  06
066A8:  MOVLB  7
066AA:  ADDWF  x12,W
066AC:  MOVWF  FE9
066AE:  MOVLW  00
066B0:  ADDWFC x13,W
066B2:  MOVWF  FEA
066B4:  MOVLW  01
066B6:  MOVWF  FEF
....................          bc++; 
066B8:  MOVLB  9
066BA:  INCF   xE2,F
066BC:  BTFSC  FD8.2
066BE:  INCF   xE3,F
....................          if (!move_window(fatsect + bc / 512)) 
066C0:  BCF    FD8.0
066C2:  CLRF   03
066C4:  RRCF   xE3,W
066C6:  MOVWF  02
066C8:  ADDWF  xE6,W
066CA:  MOVWF  xEA
066CC:  MOVF   03,W
066CE:  ADDWFC xE7,W
066D0:  MOVWF  xEB
066D2:  MOVLW  00
066D4:  ADDWFC xE8,W
066D6:  MOVWF  xEC
066D8:  MOVLW  00
066DA:  ADDWFC xE9,W
066DC:  MOVWF  xED
066DE:  MOVWF  xF1
066E0:  MOVFF  9EC,9F0
066E4:  MOVFF  9EB,9EF
066E8:  MOVFF  9EA,9EE
066EC:  MOVLB  0
066EE:  CALL   5A5A
066F2:  MOVF   01,F
066F4:  BNZ   66FC
....................             return (FALSE); 
066F6:  MOVLW  00
066F8:  MOVWF  01
066FA:  BRA    6910
....................          p = &fs->win[bc % 512]; 
066FC:  MOVLB  9
066FE:  MOVF   xE3,W
06700:  ANDLW  01
06702:  MOVWF  xEB
06704:  MOVLW  24
06706:  ADDWF  xE2,W
06708:  MOVWF  01
0670A:  MOVLW  00
0670C:  ADDWFC xEB,W
0670E:  MOVWF  03
06710:  MOVF   01,W
06712:  MOVLB  7
06714:  ADDWF  x12,W
06716:  MOVWF  01
06718:  MOVF   x13,W
0671A:  ADDWFC 03,F
0671C:  MOVFF  01,9E4
06720:  MOVLB  9
06722:  MOVFF  03,9E5
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
06726:  MOVFF  9E4,9EA
0672A:  MOVFF  9E5,9EB
0672E:  MOVF   xDA,W
06730:  ANDLW  01
06732:  MOVWF  00
06734:  CLRF   01
06736:  CLRF   02
06738:  CLRF   03
0673A:  MOVF   00,F
0673C:  BNZ   674A
0673E:  MOVF   01,F
06740:  BNZ   674A
06742:  MOVF   02,F
06744:  BNZ   674A
06746:  MOVF   03,F
06748:  BZ    677A
0674A:  RRCF   xE1,W
0674C:  MOVWF  03
0674E:  RRCF   xE0,W
06750:  MOVWF  02
06752:  RRCF   xDF,W
06754:  MOVWF  01
06756:  RRCF   xDE,W
06758:  MOVWF  00
0675A:  RRCF   03,F
0675C:  RRCF   02,F
0675E:  RRCF   01,F
06760:  RRCF   00,F
06762:  RRCF   03,F
06764:  RRCF   02,F
06766:  RRCF   01,F
06768:  RRCF   00,F
0676A:  RRCF   03,F
0676C:  RRCF   02,F
0676E:  RRCF   01,F
06770:  RRCF   00,F
06772:  MOVLW  0F
06774:  ANDWF  03,F
06776:  MOVF   00,W
06778:  BRA    679A
0677A:  MOVFF  9E4,FE9
0677E:  MOVFF  9E5,FEA
06782:  MOVF   FEF,W
06784:  ANDLW  F0
06786:  MOVWF  xED
06788:  MOVFF  9DF,00
0678C:  MOVFF  9E0,01
06790:  MOVFF  9E1,02
06794:  MOVF   xDF,W
06796:  ANDLW  0F
06798:  IORWF  xED,W
0679A:  MOVFF  9EB,FEA
0679E:  MOVFF  9EA,FE9
067A2:  MOVWF  FEF
....................          break; 
067A4:  BRA    68FA
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
067A6:  MOVFF  9DB,00
067AA:  MOVFF  9DC,01
067AE:  MOVFF  9DD,02
067B2:  CLRF   03
067B4:  MOVF   00,W
067B6:  MOVLB  9
067B8:  ADDWF  xE6,W
067BA:  MOVWF  xEA
067BC:  MOVF   xDC,W
067BE:  ADDWFC xE7,W
067C0:  MOVWF  xEB
067C2:  MOVF   xDD,W
067C4:  ADDWFC xE8,W
067C6:  MOVWF  xEC
067C8:  MOVF   03,W
067CA:  ADDWFC xE9,W
067CC:  MOVWF  xED
067CE:  MOVWF  xF1
067D0:  MOVFF  9EC,9F0
067D4:  MOVFF  9EB,9EF
067D8:  MOVFF  9EA,9EE
067DC:  MOVLB  0
067DE:  CALL   5A5A
067E2:  MOVF   01,F
067E4:  BNZ   67EC
....................             return (FALSE); 
067E6:  MOVLW  00
067E8:  MOVWF  01
067EA:  BRA    6910
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
067EC:  BCF    FD8.0
067EE:  MOVLB  9
067F0:  RLCF   xDA,W
067F2:  MOVWF  xEA
067F4:  RLCF   xDB,W
067F6:  MOVWF  xEB
067F8:  MOVLW  01
067FA:  ANDWF  xEB,F
067FC:  MOVLW  24
067FE:  ADDWF  xEA,W
06800:  MOVWF  01
06802:  MOVLW  00
06804:  ADDWFC xEB,W
06806:  MOVWF  03
06808:  MOVF   01,W
0680A:  MOVLB  7
0680C:  ADDWF  x12,W
0680E:  MOVWF  01
06810:  MOVF   x13,W
06812:  ADDWFC 03,F
06814:  MOVFF  01,FE9
06818:  MOVFF  03,FEA
0681C:  MOVFF  9DF,FEC
06820:  MOVF   FED,F
06822:  MOVFF  9DE,FEF
....................          break; 
06826:  MOVLB  9
06828:  BRA    68FA
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
0682A:  MOVLB  9
0682C:  RRCF   xDD,W
0682E:  MOVWF  03
06830:  RRCF   xDC,W
06832:  MOVWF  02
06834:  RRCF   xDB,W
06836:  MOVWF  01
06838:  RRCF   xDA,W
0683A:  MOVWF  00
0683C:  RRCF   03,F
0683E:  RRCF   02,F
06840:  RRCF   01,F
06842:  RRCF   00,F
06844:  RRCF   03,F
06846:  RRCF   02,F
06848:  RRCF   01,F
0684A:  RRCF   00,F
0684C:  RRCF   03,F
0684E:  RRCF   02,F
06850:  RRCF   01,F
06852:  RRCF   00,F
06854:  RRCF   03,F
06856:  RRCF   02,F
06858:  RRCF   01,F
0685A:  RRCF   00,F
0685C:  RRCF   03,F
0685E:  RRCF   02,F
06860:  RRCF   01,F
06862:  RRCF   00,F
06864:  RRCF   03,F
06866:  RRCF   02,F
06868:  RRCF   01,F
0686A:  RRCF   00,F
0686C:  MOVLW  01
0686E:  ANDWF  03,F
06870:  MOVF   00,W
06872:  ADDWF  xE6,W
06874:  MOVWF  xEA
06876:  MOVF   01,W
06878:  ADDWFC xE7,W
0687A:  MOVWF  xEB
0687C:  MOVF   02,W
0687E:  ADDWFC xE8,W
06880:  MOVWF  xEC
06882:  MOVF   03,W
06884:  ADDWFC xE9,W
06886:  MOVWF  xED
06888:  MOVWF  xF1
0688A:  MOVFF  9EC,9F0
0688E:  MOVFF  9EB,9EF
06892:  MOVFF  9EA,9EE
06896:  MOVLB  0
06898:  CALL   5A5A
0689C:  MOVF   01,F
0689E:  BNZ   68A6
....................             return (FALSE); 
068A0:  MOVLW  00
068A2:  MOVWF  01
068A4:  BRA    6910
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
068A6:  MOVLB  9
068A8:  RLCF   xDA,W
068AA:  MOVWF  xEA
068AC:  RLCF   xDB,W
068AE:  MOVWF  xEB
068B0:  RLCF   xEA,F
068B2:  RLCF   xEB,F
068B4:  MOVLW  FC
068B6:  ANDWF  xEA,F
068B8:  MOVLW  01
068BA:  ANDWF  xEB,F
068BC:  MOVLW  24
068BE:  ADDWF  xEA,W
068C0:  MOVWF  01
068C2:  MOVLW  00
068C4:  ADDWFC xEB,W
068C6:  MOVWF  03
068C8:  MOVF   01,W
068CA:  MOVLB  7
068CC:  ADDWF  x12,W
068CE:  MOVWF  01
068D0:  MOVF   x13,W
068D2:  ADDWFC 03,F
068D4:  MOVFF  01,FE9
068D8:  MOVFF  03,FEA
068DC:  MOVFF  9DE,FEF
068E0:  MOVFF  9DF,FEC
068E4:  MOVFF  9E0,FEC
068E8:  MOVFF  9E1,FEC
....................          break; 
068EC:  MOVLB  9
068EE:  BRA    68FA
068F0:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
068F2:  MOVLW  00
068F4:  MOVWF  01
068F6:  BRA    6910
068F8:  MOVLB  9
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
068FA:  MOVLW  06
068FC:  MOVLB  7
068FE:  ADDWF  x12,W
06900:  MOVWF  FE9
06902:  MOVLW  00
06904:  ADDWFC x13,W
06906:  MOVWF  FEA
06908:  MOVLW  01
0690A:  MOVWF  FEF
....................    return (TRUE); 
0690C:  MOVWF  01
0690E:  MOVLB  0
06910:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06EEE:  MOVFF  9BC,9DD
06EF2:  MOVFF  9BB,9DC
06EF6:  MOVFF  9BA,9DB
06EFA:  MOVFF  9B9,9DA
06EFE:  CALL   5C98
06F02:  MOVFF  03,9C0
06F06:  MOVFF  02,9BF
06F0A:  MOVFF  01,9BE
06F0E:  MOVFF  00,9BD
06F12:  MOVLB  9
06F14:  MOVF   xC0,F
06F16:  BNZ   6F26
06F18:  MOVF   xBF,F
06F1A:  BNZ   6F26
06F1C:  MOVF   xBE,F
06F1E:  BNZ   6F26
06F20:  MOVF   xBD,W
06F22:  SUBLW  01
06F24:  BC    6F86
....................       { 
....................       if (!put_cluster(clust, 0)) 
06F26:  MOVFF  9BC,9DD
06F2A:  MOVFF  9BB,9DC
06F2E:  MOVFF  9BA,9DB
06F32:  MOVFF  9B9,9DA
06F36:  CLRF   xE1
06F38:  CLRF   xE0
06F3A:  CLRF   xDF
06F3C:  CLRF   xDE
06F3E:  MOVLB  0
06F40:  CALL   6592
06F44:  MOVF   01,F
06F46:  BNZ   6F4E
....................          return FALSE; 
06F48:  MOVLW  00
06F4A:  MOVWF  01
06F4C:  BRA    6F8C
....................       clust = nxt; 
06F4E:  MOVFF  9C0,9BC
06F52:  MOVFF  9BF,9BB
06F56:  MOVFF  9BE,9BA
06F5A:  MOVFF  9BD,9B9
06F5E:  MOVFF  9BC,9DD
06F62:  MOVFF  9BB,9DC
06F66:  MOVFF  9BA,9DB
06F6A:  MOVFF  9B9,9DA
06F6E:  CALL   5C98
06F72:  MOVFF  03,9C0
06F76:  MOVFF  02,9BF
06F7A:  MOVFF  01,9BE
06F7E:  MOVFF  00,9BD
06F82:  BRA    6F12
06F84:  MOVLB  9
....................       } 
....................    return TRUE; 
06F86:  MOVLW  01
06F88:  MOVWF  01
06F8A:  MOVLB  0
06F8C:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
06912:  MOVLW  0C
06914:  MOVLB  7
06916:  ADDWF  x12,W
06918:  MOVWF  FE9
0691A:  MOVLW  00
0691C:  ADDWFC x13,W
0691E:  MOVWF  FEA
06920:  MOVFF  FEF,9D6
06924:  MOVFF  FEC,9D7
06928:  MOVFF  FEC,9D8
0692C:  MOVFF  FEC,9D9
....................    if (clust == 0)  
06930:  MOVLB  9
06932:  MOVF   xC6,F
06934:  BNZ   699E
06936:  MOVF   xC7,F
06938:  BNZ   699E
0693A:  MOVF   xC8,F
0693C:  BNZ   699E
0693E:  MOVF   xC9,F
06940:  BNZ   699E
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
06942:  MOVLW  1C
06944:  MOVLB  7
06946:  ADDWF  x12,W
06948:  MOVWF  FE9
0694A:  MOVLW  00
0694C:  ADDWFC x13,W
0694E:  MOVWF  FEA
06950:  MOVFF  FEF,9D2
06954:  MOVFF  FEC,9D3
06958:  MOVFF  FEC,9D4
0695C:  MOVFF  FEC,9D5
....................       if (scl < 2 || scl >= mcl) scl = 1; 
06960:  MOVLB  9
06962:  MOVF   xD5,F
06964:  BNZ   6974
06966:  MOVF   xD4,F
06968:  BNZ   6974
0696A:  MOVF   xD3,F
0696C:  BNZ   6974
0696E:  MOVF   xD2,W
06970:  SUBLW  01
06972:  BC    6992
06974:  MOVF   xD9,W
06976:  SUBWF  xD5,W
06978:  BNC   699C
0697A:  BNZ   6992
0697C:  MOVF   xD8,W
0697E:  SUBWF  xD4,W
06980:  BNC   699C
06982:  BNZ   6992
06984:  MOVF   xD7,W
06986:  SUBWF  xD3,W
06988:  BNC   699C
0698A:  BNZ   6992
0698C:  MOVF   xD6,W
0698E:  SUBWF  xD2,W
06990:  BNC   699C
06992:  CLRF   xD5
06994:  CLRF   xD4
06996:  CLRF   xD3
06998:  MOVLW  01
0699A:  MOVWF  xD2
....................       } 
0699C:  BRA    6A22
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
0699E:  MOVFF  9C9,9DD
069A2:  MOVFF  9C8,9DC
069A6:  MOVFF  9C7,9DB
069AA:  MOVFF  9C6,9DA
069AE:  MOVLB  0
069B0:  CALL   5C98
069B4:  MOVFF  03,9CD
069B8:  MOVFF  02,9CC
069BC:  MOVFF  01,9CB
069C0:  MOVFF  00,9CA
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
069C4:  MOVLB  9
069C6:  MOVF   xCD,F
069C8:  BNZ   69E2
069CA:  MOVF   xCC,F
069CC:  BNZ   69E2
069CE:  MOVF   xCB,F
069D0:  BNZ   69E2
069D2:  MOVF   xCA,W
069D4:  SUBLW  01
069D6:  BNC   69E2
069D8:  CLRF   00
069DA:  CLRF   01
069DC:  CLRF   02
069DE:  CLRF   03
069E0:  BRA    6BA4
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
069E2:  MOVF   xCD,W
069E4:  SUBWF  xD9,W
069E6:  BNC   6A12
069E8:  BNZ   6A00
069EA:  MOVF   xCC,W
069EC:  SUBWF  xD8,W
069EE:  BNC   6A12
069F0:  BNZ   6A00
069F2:  MOVF   xCB,W
069F4:  SUBWF  xD7,W
069F6:  BNC   6A12
069F8:  BNZ   6A00
069FA:  MOVF   xD6,W
069FC:  SUBWF  xCA,W
069FE:  BC    6A12
06A00:  MOVFF  9CA,00
06A04:  MOVFF  9CB,01
06A08:  MOVFF  9CC,02
06A0C:  MOVFF  9CD,03
06A10:  BRA    6BA4
....................       scl = clust; 
06A12:  MOVFF  9C9,9D5
06A16:  MOVFF  9C8,9D4
06A1A:  MOVFF  9C7,9D3
06A1E:  MOVFF  9C6,9D2
....................       } 
....................       ncl = scl;                  // Scan start cluster 
06A22:  MOVFF  9D5,9D1
06A26:  MOVFF  9D4,9D0
06A2A:  MOVFF  9D3,9CF
06A2E:  MOVFF  9D2,9CE
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
06A32:  MOVLW  01
06A34:  ADDWF  xCE,F
06A36:  BTFSC  FD8.0
06A38:  INCF   xCF,F
06A3A:  BTFSC  FD8.2
06A3C:  INCF   xD0,F
06A3E:  BTFSC  FD8.2
06A40:  INCF   xD1,F
....................       if (ncl >= mcl)  
06A42:  MOVF   xD9,W
06A44:  SUBWF  xD1,W
06A46:  BNC   6A84
06A48:  BNZ   6A60
06A4A:  MOVF   xD8,W
06A4C:  SUBWF  xD0,W
06A4E:  BNC   6A84
06A50:  BNZ   6A60
06A52:  MOVF   xD7,W
06A54:  SUBWF  xCF,W
06A56:  BNC   6A84
06A58:  BNZ   6A60
06A5A:  MOVF   xD6,W
06A5C:  SUBWF  xCE,W
06A5E:  BNC   6A84
....................          {         // Wrap around 
....................          ncl = 2; 
06A60:  CLRF   xD1
06A62:  CLRF   xD0
06A64:  CLRF   xCF
06A66:  MOVLW  02
06A68:  MOVWF  xCE
....................          if (scl == 1) return 0;      // No free custer was found 
06A6A:  DECFSZ xD2,W
06A6C:  BRA    6A84
06A6E:  MOVF   xD3,F
06A70:  BNZ   6A84
06A72:  MOVF   xD4,F
06A74:  BNZ   6A84
06A76:  MOVF   xD5,F
06A78:  BNZ   6A84
06A7A:  CLRF   00
06A7C:  CLRF   01
06A7E:  CLRF   02
06A80:  CLRF   03
06A82:  BRA    6BA4
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06A84:  MOVF   xD2,W
06A86:  SUBWF  xCE,W
06A88:  BNZ   6AA6
06A8A:  MOVF   xD3,W
06A8C:  SUBWF  xCF,W
06A8E:  BNZ   6AA6
06A90:  MOVF   xD4,W
06A92:  SUBWF  xD0,W
06A94:  BNZ   6AA6
06A96:  MOVF   xD5,W
06A98:  SUBWF  xD1,W
06A9A:  BNZ   6AA6
06A9C:  CLRF   00
06A9E:  CLRF   01
06AA0:  CLRF   02
06AA2:  CLRF   03
06AA4:  BRA    6BA4
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06AA6:  MOVFF  9D1,9DD
06AAA:  MOVFF  9D0,9DC
06AAE:  MOVFF  9CF,9DB
06AB2:  MOVFF  9CE,9DA
06AB6:  MOVLB  0
06AB8:  CALL   5C98
06ABC:  MOVFF  03,9CD
06AC0:  MOVFF  02,9CC
06AC4:  MOVFF  01,9CB
06AC8:  MOVFF  00,9CA
....................       if (cstat == 1) return 0;      // Any error occured 
06ACC:  MOVLB  9
06ACE:  DECFSZ xCA,W
06AD0:  BRA    6AE8
06AD2:  MOVF   xCB,F
06AD4:  BNZ   6AE8
06AD6:  MOVF   xCC,F
06AD8:  BNZ   6AE8
06ADA:  MOVF   xCD,F
06ADC:  BNZ   6AE8
06ADE:  CLRF   00
06AE0:  CLRF   01
06AE2:  CLRF   02
06AE4:  CLRF   03
06AE6:  BRA    6BA4
....................       } while (cstat);            // Repeat until find a free cluster 
06AE8:  MOVF   xCA,F
06AEA:  BNZ   6A32
06AEC:  MOVF   xCB,F
06AEE:  BNZ   6A32
06AF0:  MOVF   xCC,F
06AF2:  BNZ   6A32
06AF4:  MOVF   xCD,F
06AF6:  BNZ   6A32
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06AF8:  MOVFF  9D1,9DD
06AFC:  MOVFF  9D0,9DC
06B00:  MOVFF  9CF,9DB
06B04:  MOVFF  9CE,9DA
06B08:  MOVLW  0F
06B0A:  MOVWF  xE1
06B0C:  SETF   xE0
06B0E:  SETF   xDF
06B10:  SETF   xDE
06B12:  MOVLB  0
06B14:  RCALL  6592
06B16:  MOVF   01,F
06B18:  BNZ   6B28
06B1A:  CLRF   00
06B1C:  CLRF   01
06B1E:  CLRF   02
06B20:  CLRF   03
06B22:  MOVLB  9
06B24:  BRA    6BA4
06B26:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06B28:  MOVLB  9
06B2A:  MOVF   xC6,F
06B2C:  BNZ   6B3A
06B2E:  MOVF   xC7,F
06B30:  BNZ   6B3A
06B32:  MOVF   xC8,F
06B34:  BNZ   6B3A
06B36:  MOVF   xC9,F
06B38:  BZ    6B74
06B3A:  MOVFF  9C9,9DD
06B3E:  MOVFF  9C8,9DC
06B42:  MOVFF  9C7,9DB
06B46:  MOVFF  9C6,9DA
06B4A:  MOVFF  9D1,9E1
06B4E:  MOVFF  9D0,9E0
06B52:  MOVFF  9CF,9DF
06B56:  MOVFF  9CE,9DE
06B5A:  MOVLB  0
06B5C:  RCALL  6592
06B5E:  MOVF   01,F
06B60:  BTFSC  FD8.2
06B62:  BRA    6B68
06B64:  MOVLB  9
06B66:  BRA    6B74
06B68:  CLRF   00
06B6A:  CLRF   01
06B6C:  CLRF   02
06B6E:  CLRF   03
06B70:  MOVLB  9
06B72:  BRA    6BA4
....................    fs->last_clust = ncl; 
06B74:  MOVLW  1C
06B76:  MOVLB  7
06B78:  ADDWF  x12,W
06B7A:  MOVWF  FE9
06B7C:  MOVLW  00
06B7E:  ADDWFC x13,W
06B80:  MOVWF  FEA
06B82:  MOVFF  9CE,FEF
06B86:  MOVFF  9CF,FEC
06B8A:  MOVFF  9D0,FEC
06B8E:  MOVFF  9D1,FEC
....................  
....................    return ncl;      // Return new cluster number 
06B92:  MOVFF  9CE,00
06B96:  MOVFF  9CF,01
06B9A:  MOVFF  9D0,02
06B9E:  MOVFF  9D1,03
06BA2:  MOVLB  9
06BA4:  MOVLB  0
06BA6:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
055E4:  MOVLW  02
055E6:  MOVLB  9
055E8:  SUBWF  xCD,F
055EA:  MOVLW  00
055EC:  SUBWFB xCE,F
055EE:  SUBWFB xCF,F
055F0:  SUBWFB xD0,F
....................    if (clust >= fs->max_clust)  
055F2:  MOVLW  0C
055F4:  MOVLB  7
055F6:  ADDWF  x12,W
055F8:  MOVWF  FE9
055FA:  MOVLW  00
055FC:  ADDWFC x13,W
055FE:  MOVWF  FEA
05600:  MOVFF  FEF,00
05604:  MOVFF  FEC,01
05608:  MOVFF  FEC,02
0560C:  MOVFF  FEC,03
05610:  MOVF   03,W
05612:  MOVLB  9
05614:  SUBWF  xD0,W
05616:  BNC   563A
05618:  BNZ   5630
0561A:  MOVF   02,W
0561C:  SUBWF  xCF,W
0561E:  BNC   563A
05620:  BNZ   5630
05622:  MOVF   01,W
05624:  SUBWF  xCE,W
05626:  BNC   563A
05628:  BNZ   5630
0562A:  MOVF   00,W
0562C:  SUBWF  xCD,W
0562E:  BNC   563A
....................       return 0;      // Invalid cluster#  
05630:  CLRF   00
05632:  CLRF   01
05634:  CLRF   02
05636:  CLRF   03
05638:  BRA    56BA
....................    return (clust * fs->sects_clust + fs->database); 
0563A:  MOVLW  02
0563C:  MOVLB  7
0563E:  ADDWF  x12,W
05640:  MOVWF  FE9
05642:  MOVLW  00
05644:  ADDWFC x13,W
05646:  MOVWF  FEA
05648:  MOVFF  FEF,9D8
0564C:  MOVLB  9
0564E:  MOVFF  FEA,9D3
05652:  MOVFF  FE9,9D2
05656:  MOVFF  9D0,9D7
0565A:  MOVFF  9CF,9D6
0565E:  MOVFF  9CE,9D5
05662:  MOVFF  9CD,9D4
05666:  CLRF   xDB
05668:  CLRF   xDA
0566A:  CLRF   xD9
0566C:  MOVLB  0
0566E:  CALL   47D4
05672:  MOVFF  9D3,FEA
05676:  MOVFF  9D2,FE9
0567A:  MOVFF  03,9D4
0567E:  MOVFF  02,9D3
05682:  MOVFF  01,9D2
05686:  MOVFF  00,9D1
0568A:  MOVLW  18
0568C:  MOVLB  7
0568E:  ADDWF  x12,W
05690:  MOVWF  FE9
05692:  MOVLW  00
05694:  ADDWFC x13,W
05696:  MOVWF  FEA
05698:  MOVFF  FEF,00
0569C:  MOVFF  FEC,01
056A0:  MOVFF  FEC,02
056A4:  MOVFF  FEC,03
056A8:  MOVLB  9
056AA:  MOVF   xD1,W
056AC:  ADDWF  00,F
056AE:  MOVF   xD2,W
056B0:  ADDWFC 01,F
056B2:  MOVF   xD3,W
056B4:  ADDWFC 02,F
056B6:  MOVF   xD4,W
056B8:  ADDWFC 03,F
056BA:  MOVLB  0
056BC:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
04676:  MOVLW  24
04678:  MOVLB  7
0467A:  ADDWF  x12,W
0467C:  MOVWF  01
0467E:  MOVLW  00
04680:  ADDWFC x13,W
04682:  MOVWF  03
04684:  MOVFF  01,9C5
04688:  MOVLB  9
0468A:  MOVWF  xC6
0468C:  MOVWF  FEA
0468E:  MOVFF  01,FE9
04692:  CLRF   00
04694:  MOVLW  02
04696:  MOVWF  02
04698:  CLRF   01
0469A:  MOVLB  0
0469C:  CALL   350A
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
046A0:  MOVLW  24
046A2:  MOVLB  7
046A4:  ADDWF  x12,W
046A6:  MOVWF  01
046A8:  MOVLW  00
046AA:  ADDWFC x13,W
046AC:  MOVWF  03
046AE:  MOVFF  01,9C5
046B2:  MOVLB  9
046B4:  MOVWF  xC6
046B6:  MOVWF  xFB
046B8:  MOVFF  01,9FA
046BC:  MOVFF  9C4,9FF
046C0:  MOVFF  9C3,9FE
046C4:  MOVFF  9C2,9FD
046C8:  MOVFF  9C1,9FC
046CC:  MOVLW  01
046CE:  MOVLB  A
046D0:  MOVWF  x00
046D2:  MOVLB  0
046D4:  RCALL  44B0
046D6:  MOVF   01,F
046D8:  BTFSS  FD8.2
046DA:  BRA    47CA
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
046DC:  MOVLW  22
046DE:  MOVLB  7
046E0:  ADDWF  x12,W
046E2:  MOVWF  01
046E4:  MOVLW  02
046E6:  ADDWFC x13,W
046E8:  MOVWF  03
046EA:  MOVFF  01,FE9
046EE:  MOVWF  FEA
046F0:  MOVFF  FEC,9C6
046F4:  MOVF   FED,F
046F6:  MOVFF  FEF,9C5
046FA:  MOVLB  9
046FC:  MOVF   xC5,W
046FE:  SUBLW  55
04700:  BNZ   47CC
04702:  MOVF   xC6,W
04704:  SUBLW  AA
04706:  BNZ   47CC
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
04708:  MOVLW  5A
0470A:  MOVLB  7
0470C:  ADDWF  x12,W
0470E:  MOVWF  01
04710:  MOVLW  00
04712:  ADDWFC x13,W
04714:  MOVWF  03
04716:  MOVFF  01,9C5
0471A:  MOVLB  9
0471C:  MOVWF  xC6
0471E:  MOVWF  xC8
04720:  MOVFF  01,9C7
04724:  MOVLW  07
04726:  MOVWF  xCA
04728:  MOVLW  14
0472A:  MOVWF  xC9
0472C:  CLRF   xCC
0472E:  MOVLW  05
04730:  MOVWF  xCB
04732:  MOVLB  0
04734:  RCALL  45F2
04736:  MOVF   01,F
04738:  BNZ   4740
....................             return (FS_FAT12); 
0473A:  MOVLW  01
0473C:  MOVWF  01
0473E:  BRA    47D2
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
04740:  MOVLW  5A
04742:  MOVLB  7
04744:  ADDWF  x12,W
04746:  MOVWF  01
04748:  MOVLW  00
0474A:  ADDWFC x13,W
0474C:  MOVWF  03
0474E:  MOVFF  01,9C5
04752:  MOVLB  9
04754:  MOVWF  xC6
04756:  MOVWF  xC8
04758:  MOVFF  01,9C7
0475C:  MOVLW  07
0475E:  MOVWF  xCA
04760:  MOVLW  19
04762:  MOVWF  xC9
04764:  CLRF   xCC
04766:  MOVLW  05
04768:  MOVWF  xCB
0476A:  MOVLB  0
0476C:  RCALL  45F2
0476E:  MOVF   01,F
04770:  BNZ   4778
....................             return (FS_FAT16); 
04772:  MOVLW  02
04774:  MOVWF  01
04776:  BRA    47D2
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
04778:  MOVLW  76
0477A:  MOVLB  7
0477C:  ADDWF  x12,W
0477E:  MOVWF  01
04780:  MOVLW  00
04782:  ADDWFC x13,W
04784:  MOVWF  03
04786:  MOVFF  01,9C5
0478A:  MOVLB  9
0478C:  MOVWF  xC6
0478E:  MOVWF  xC8
04790:  MOVFF  01,9C7
04794:  MOVLW  07
04796:  MOVWF  xCA
04798:  MOVLW  1E
0479A:  MOVWF  xC9
0479C:  CLRF   xCC
0479E:  MOVLW  05
047A0:  MOVWF  xCB
047A2:  MOVLB  0
047A4:  RCALL  45F2
047A6:  MOVF   01,F
047A8:  BNZ   47CA
047AA:  MOVLW  4C
047AC:  MOVLB  7
047AE:  ADDWF  x12,W
047B0:  MOVWF  FE9
047B2:  MOVLW  00
047B4:  ADDWFC x13,W
047B6:  MOVWF  FEA
047B8:  MOVF   FEF,F
047BA:  BTFSC  FD8.2
047BC:  BRA    47C2
047BE:  MOVLB  0
047C0:  BRA    47CA
....................             return (FS_FAT32); 
047C2:  MOVLW  03
047C4:  MOVWF  01
047C6:  MOVLB  0
047C8:  BRA    47D2
047CA:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
047CC:  MOVLW  00
047CE:  MOVWF  01
047D0:  MOVLB  0
047D2:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
05FD0:  MOVLW  0C
05FD2:  MOVLB  9
05FD4:  ADDWF  xC3,W
05FD6:  MOVWF  FE9
05FD8:  MOVLW  00
05FDA:  ADDWFC xC4,W
05FDC:  MOVWF  FEA
05FDE:  MOVFF  FEC,9CC
05FE2:  MOVF   FED,F
05FE4:  MOVFF  FEF,9CB
05FE8:  MOVLW  01
05FEA:  ADDWF  xCB,W
05FEC:  MOVWF  xC9
05FEE:  MOVLW  00
05FF0:  ADDWFC xCC,W
05FF2:  MOVWF  xCA
....................    if ((idx & 15) == 0)  
05FF4:  MOVF   xC9,W
05FF6:  ANDLW  0F
05FF8:  MOVWF  xCB
05FFA:  CLRF   xCC
05FFC:  MOVF   xCB,F
05FFE:  BTFSS  FD8.2
06000:  BRA    618C
06002:  MOVF   xCC,F
06004:  BTFSS  FD8.2
06006:  BRA    618C
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
06008:  MOVLW  08
0600A:  ADDWF  xC3,W
0600C:  MOVWF  FE9
0600E:  MOVLW  00
06010:  ADDWFC xC4,W
06012:  MOVWF  FEA
06014:  MOVLW  01
06016:  ADDWF  FEE,F
06018:  MOVLW  00
0601A:  ADDWFC FEE,F
0601C:  ADDWFC FEE,F
0601E:  ADDWFC FED,F
....................       if (!scan->clust)  
06020:  MOVLW  04
06022:  ADDWF  xC3,W
06024:  MOVWF  FE9
06026:  MOVLW  00
06028:  ADDWFC xC4,W
0602A:  MOVWF  FEA
0602C:  MOVF   FEF,F
0602E:  BNZ   606C
06030:  MOVF   FEC,F
06032:  BNZ   606C
06034:  MOVF   FEC,F
06036:  BNZ   606C
06038:  MOVF   FEC,F
0603A:  BNZ   606C
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
0603C:  MOVLW  04
0603E:  MOVLB  7
06040:  ADDWF  x12,W
06042:  MOVWF  FE9
06044:  MOVLW  00
06046:  ADDWFC x13,W
06048:  MOVWF  FEA
0604A:  MOVFF  FEC,03
0604E:  MOVF   FED,F
06050:  MOVFF  FEF,01
06054:  MOVF   03,W
06056:  MOVLB  9
06058:  SUBWF  xCA,W
0605A:  BNC   606A
0605C:  BNZ   6064
0605E:  MOVF   01,W
06060:  SUBWF  xC9,W
06062:  BNC   606A
....................             return (FALSE);   // Reached to end of table  
06064:  MOVLW  00
06066:  MOVWF  01
06068:  BRA    61A6
....................          }  
0606A:  BRA    618C
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
0606C:  RRCF   xCA,W
0606E:  MOVWF  xCC
06070:  RRCF   xC9,W
06072:  MOVWF  xCB
06074:  RRCF   xCC,F
06076:  RRCF   xCB,F
06078:  RRCF   xCC,F
0607A:  RRCF   xCB,F
0607C:  RRCF   xCC,F
0607E:  RRCF   xCB,F
06080:  MOVLW  0F
06082:  ANDWF  xCC,F
06084:  MOVLW  02
06086:  MOVLB  7
06088:  ADDWF  x12,W
0608A:  MOVWF  FE9
0608C:  MOVLW  00
0608E:  ADDWFC x13,W
06090:  MOVWF  FEA
06092:  MOVLW  01
06094:  SUBWF  FEF,W
06096:  MOVLB  9
06098:  ANDWF  xCB,F
0609A:  CLRF   xCC
0609C:  MOVF   xCB,F
0609E:  BTFSS  FD8.2
060A0:  BRA    618C
060A2:  MOVF   xCC,F
060A4:  BTFSS  FD8.2
060A6:  BRA    618C
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
060A8:  MOVLW  04
060AA:  ADDWF  xC3,W
060AC:  MOVWF  FE9
060AE:  MOVLW  00
060B0:  ADDWFC xC4,W
060B2:  MOVWF  FEA
060B4:  MOVFF  FEF,9DA
060B8:  MOVFF  FEC,9DB
060BC:  MOVFF  FEC,9DC
060C0:  MOVFF  FEC,9DD
060C4:  MOVLB  0
060C6:  RCALL  5C98
060C8:  MOVFF  03,9C8
060CC:  MOVFF  02,9C7
060D0:  MOVFF  01,9C6
060D4:  MOVFF  00,9C5
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
060D8:  MOVLW  0C
060DA:  MOVLB  7
060DC:  ADDWF  x12,W
060DE:  MOVWF  FE9
060E0:  MOVLW  00
060E2:  ADDWFC x13,W
060E4:  MOVWF  FEA
060E6:  MOVFF  FEF,00
060EA:  MOVFF  FEC,01
060EE:  MOVFF  FEC,02
060F2:  MOVFF  FEC,03
060F6:  MOVF   03,W
060F8:  MOVLB  9
060FA:  SUBWF  xC8,W
060FC:  BNC   6116
060FE:  BNZ   6128
06100:  MOVF   02,W
06102:  SUBWF  xC7,W
06104:  BNC   6116
06106:  BNZ   6128
06108:  MOVF   01,W
0610A:  SUBWF  xC6,W
0610C:  BNC   6116
0610E:  BNZ   6128
06110:  MOVF   00,W
06112:  SUBWF  xC5,W
06114:  BC    6128
06116:  MOVF   xC8,F
06118:  BNZ   612E
0611A:  MOVF   xC7,F
0611C:  BNZ   612E
0611E:  MOVF   xC6,F
06120:  BNZ   612E
06122:  MOVF   xC5,W
06124:  SUBLW  01
06126:  BNC   612E
....................                return (FALSE); 
06128:  MOVLW  00
0612A:  MOVWF  01
0612C:  BRA    61A6
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
0612E:  MOVLW  04
06130:  ADDWF  xC3,W
06132:  MOVWF  FE9
06134:  MOVLW  00
06136:  ADDWFC xC4,W
06138:  MOVWF  FEA
0613A:  MOVFF  9C5,FEF
0613E:  MOVFF  9C6,FEC
06142:  MOVFF  9C7,FEC
06146:  MOVFF  9C8,FEC
....................             scan->sect = clust2sect(clust); 
0614A:  MOVLW  08
0614C:  ADDWF  xC3,W
0614E:  MOVWF  01
06150:  MOVLW  00
06152:  ADDWFC xC4,W
06154:  MOVWF  03
06156:  MOVFF  01,9CB
0615A:  MOVWF  xCC
0615C:  MOVFF  9C8,9D0
06160:  MOVFF  9C7,9CF
06164:  MOVFF  9C6,9CE
06168:  MOVFF  9C5,9CD
0616C:  MOVLB  0
0616E:  CALL   55E4
06172:  MOVFF  9CC,FEA
06176:  MOVFF  9CB,FE9
0617A:  MOVFF  00,FEF
0617E:  MOVFF  01,FEC
06182:  MOVFF  02,FEC
06186:  MOVFF  03,FEC
0618A:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
0618C:  MOVLW  0C
0618E:  ADDWF  xC3,W
06190:  MOVWF  FE9
06192:  MOVLW  00
06194:  ADDWFC xC4,W
06196:  MOVWF  FEA
06198:  MOVFF  9CA,FEC
0619C:  MOVF   FED,F
0619E:  MOVFF  9C9,FEF
....................    return (TRUE); 
061A2:  MOVLW  01
061A4:  MOVWF  01
061A6:  MOVLB  0
061A8:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
056BE:  MOVFF  9C6,FEA
056C2:  MOVFF  9C5,FE9
056C6:  MOVLW  20
056C8:  MOVWF  00
056CA:  CLRF   02
056CC:  MOVLW  0B
056CE:  MOVWF  01
056D0:  CALL   350A
....................    a = 0; b = 0x18;            // NT flag 
056D4:  MOVLB  9
056D6:  CLRF   xCA
056D8:  MOVLW  18
056DA:  MOVWF  xCB
....................    n = 0; t = 8; 
056DC:  CLRF   xC7
056DE:  MOVLW  08
056E0:  MOVWF  xC8
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
056E2:  MOVFF  9C3,FE9
056E6:  MOVFF  9C4,FEA
056EA:  MOVFF  FEC,9CD
056EE:  MOVF   FED,F
056F0:  MOVFF  FEF,9CC
....................       c = *ptr; 
056F4:  MOVFF  9CC,FE9
056F8:  MOVFF  9CD,FEA
056FC:  MOVFF  FEF,9C9
....................       (*path)++; 
05700:  MOVFF  9C4,03
05704:  MOVFF  9C3,FE9
05708:  MOVFF  9C4,FEA
0570C:  MOVLW  01
0570E:  ADDWF  FEE,F
05710:  BNC   5714
05712:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
05714:  MOVF   xC9,W
05716:  SUBLW  20
05718:  BNC   571C
....................          c = 0; 
0571A:  CLRF   xC9
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
0571C:  MOVF   xC9,F
0571E:  BZ    572C
05720:  MOVF   xC9,W
05722:  SUBLW  2F
05724:  BZ    572C
05726:  MOVF   xC9,W
05728:  SUBLW  5C
0572A:  BNZ   574A
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
0572C:  MOVF   xC7,F
0572E:  BNZ   5732
....................             break; 
05730:  BRA    5812
....................          dirname[11] = a & b;  
05732:  MOVLW  0B
05734:  ADDWF  xC5,W
05736:  MOVWF  FE9
05738:  MOVLW  00
0573A:  ADDWFC xC6,W
0573C:  MOVWF  FEA
0573E:  MOVF   xCA,W
05740:  ANDWF  xCB,W
05742:  MOVWF  FEF
....................             return (c); 
05744:  MOVFF  9C9,01
05748:  BRA    5816
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
0574A:  MOVF   xC9,W
0574C:  SUBLW  20
0574E:  BC    5756
05750:  MOVF   xC9,W
05752:  SUBLW  7F
05754:  BNZ   5758
....................          break;   // reject invisible characters 
05756:  BRA    5812
....................       if (c == '.')  
05758:  MOVF   xC9,W
0575A:  SUBLW  2E
0575C:  BNZ   577A
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
0575E:  BTFSC  xCA.0
05760:  BRA    5778
05762:  MOVF   xC7,W
05764:  SUBLW  00
05766:  BC    5778
05768:  MOVF   xC7,W
0576A:  SUBLW  08
0576C:  BNC   5778
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
0576E:  MOVLW  08
05770:  MOVWF  xC7
05772:  MOVLW  0B
05774:  MOVWF  xC8
....................             continue; 
05776:  BRA    5810
....................             } 
....................          break; 
05778:  BRA    5812
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
0577A:  MOVF   xC9,W
0577C:  SUBLW  22
0577E:  BNZ   5782
....................          break;               // Reject "  
05780:  BRA    5812
....................  
....................       if (c <= ')')  
05782:  MOVF   xC9,W
05784:  SUBLW  29
05786:  BNC   578A
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
05788:  BRA    57F4
....................  
....................       if (c <= ',') 
0578A:  MOVF   xC9,W
0578C:  SUBLW  2C
0578E:  BNC   5792
....................          break;               // Reject * + ,  
05790:  BRA    5812
....................  
....................       if (c <= '9')  
05792:  MOVF   xC9,W
05794:  SUBLW  39
05796:  BNC   579A
....................          goto md_l1;            // Accept - 0-9  
05798:  BRA    57F4
....................  
....................       if (c <= '?')  
0579A:  MOVF   xC9,W
0579C:  SUBLW  3F
0579E:  BNC   57A2
....................          break;               // Reject : ; < = > ?  
057A0:  BRA    5812
....................  
....................       if (!(a & 1))  
057A2:  BTFSC  xCA.0
057A4:  BRA    57F4
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
057A6:  MOVF   xC9,W
057A8:  SUBLW  7C
057AA:  BNZ   57AE
....................             break;            // Reject |  
057AC:  BRA    5812
....................  
....................          if ((c >= '[') && (c <= ']')) 
057AE:  MOVF   xC9,W
057B0:  SUBLW  5A
057B2:  BC    57BC
057B4:  MOVF   xC9,W
057B6:  SUBLW  5D
057B8:  BNC   57BC
....................             break;// Reject [ \ ]  
057BA:  BRA    5812
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
057BC:  MOVF   xC9,W
057BE:  SUBLW  40
057C0:  BC    57D6
057C2:  MOVF   xC9,W
057C4:  SUBLW  5A
057C6:  BNC   57D6
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
057C8:  MOVF   xC8,W
057CA:  SUBLW  08
057CC:  BNZ   57D4
057CE:  BCF    xCB.3
057D0:  MOVF   xCB,W
057D2:  BRA    57D6
057D4:  BCF    xCB.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
057D6:  MOVF   xC9,W
057D8:  SUBLW  60
057DA:  BC    57F4
057DC:  MOVF   xC9,W
057DE:  SUBLW  7A
057E0:  BNC   57F4
....................             {      // Convert to upper case  
....................             c -= 0x20; 
057E2:  MOVLW  20
057E4:  SUBWF  xC9,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
057E6:  MOVF   xC8,W
057E8:  SUBLW  08
057EA:  BNZ   57F2
057EC:  BSF    xCA.3
057EE:  MOVF   xCA,W
057F0:  BRA    57F4
057F2:  BSF    xCA.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
057F4:  BCF    xCA.0
....................    md_l2: 
....................       if (n >= t)  
057F6:  MOVF   xC8,W
057F8:  SUBWF  xC7,W
057FA:  BNC   57FE
....................          break; 
057FC:  BRA    5812
....................       dirname[n++] = c; 
057FE:  MOVF   xC7,W
05800:  INCF   xC7,F
05802:  ADDWF  xC5,W
05804:  MOVWF  FE9
05806:  MOVLW  00
05808:  ADDWFC xC6,W
0580A:  MOVWF  FEA
0580C:  MOVFF  9C9,FEF
05810:  BRA    56E2
....................       } 
....................    return 1; 
05812:  MOVLW  01
05814:  MOVWF  01
05816:  MOVLB  0
05818:  GOTO   634C (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
061AA:  MOVLB  9
061AC:  CLRF   xC2
061AE:  CLRF   xC1
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
061B0:  MOVLW  14
061B2:  MOVLB  7
061B4:  ADDWF  x12,W
061B6:  MOVWF  FE9
061B8:  MOVLW  00
061BA:  ADDWFC x13,W
061BC:  MOVWF  FEA
061BE:  MOVFF  FEF,9BC
061C2:  MOVFF  FEC,9BD
061C6:  MOVFF  FEC,9BE
061CA:  MOVFF  FEC,9BF
....................    if (fs->fs_type == FS_FAT32)  
061CE:  MOVFF  712,FE9
061D2:  MOVFF  713,FEA
061D6:  MOVF   FEF,W
061D8:  SUBLW  03
061DA:  BNZ   625E
....................       { 
....................       scan->clust = scan->sclust = clust; 
061DC:  MOVLW  04
061DE:  MOVLB  9
061E0:  ADDWF  xB4,W
061E2:  MOVWF  01
061E4:  MOVLW  00
061E6:  ADDWFC xB5,W
061E8:  MOVFF  01,9C3
061EC:  MOVFF  9B4,FE9
061F0:  MOVFF  9B5,FEA
061F4:  MOVFF  9BC,FEF
061F8:  MOVFF  9BD,FEC
061FC:  MOVFF  9BE,FEC
06200:  MOVFF  9BF,FEC
06204:  MOVWF  FEA
06206:  MOVFF  9C3,FE9
0620A:  MOVFF  9BC,FEF
0620E:  MOVFF  9BD,FEC
06212:  MOVFF  9BE,FEC
06216:  MOVFF  9BF,FEC
....................       scan->sect = clust2sect(clust); 
0621A:  MOVLW  08
0621C:  ADDWF  xB4,W
0621E:  MOVWF  01
06220:  MOVLW  00
06222:  ADDWFC xB5,W
06224:  MOVWF  03
06226:  MOVFF  01,9C3
0622A:  MOVWF  xC4
0622C:  MOVFF  9BF,9D0
06230:  MOVFF  9BE,9CF
06234:  MOVFF  9BD,9CE
06238:  MOVFF  9BC,9CD
0623C:  MOVLB  0
0623E:  CALL   55E4
06242:  MOVFF  9C4,FEA
06246:  MOVFF  9C3,FE9
0624A:  MOVFF  00,FEF
0624E:  MOVFF  01,FEC
06252:  MOVFF  02,FEC
06256:  MOVFF  03,FEC
....................       } 
0625A:  BRA    62BE
0625C:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
0625E:  MOVLW  04
06260:  MOVLB  9
06262:  ADDWF  xB4,W
06264:  MOVWF  01
06266:  MOVLW  00
06268:  ADDWFC xB5,W
0626A:  MOVWF  03
0626C:  MOVFF  9B4,FE9
06270:  MOVFF  9B5,FEA
06274:  MOVF   FEE,F
06276:  MOVF   FEE,F
06278:  CLRF   FEC
0627A:  MOVF   FED,F
0627C:  CLRF   FEF
0627E:  MOVF   FED,F
06280:  CLRF   FEF
06282:  MOVF   FED,F
06284:  CLRF   FEF
06286:  MOVLW  00
06288:  MOVFF  03,FEA
0628C:  MOVFF  01,FE9
06290:  MOVFF  00,FEF
06294:  MOVFF  01,FEC
06298:  MOVFF  02,FEC
0629C:  MOVFF  03,FEC
....................       scan->sect = clust; 
062A0:  MOVLW  08
062A2:  ADDWF  xB4,W
062A4:  MOVWF  FE9
062A6:  MOVLW  00
062A8:  ADDWFC xB5,W
062AA:  MOVWF  FEA
062AC:  MOVFF  9BC,FEF
062B0:  MOVFF  9BD,FEC
062B4:  MOVFF  9BE,FEC
062B8:  MOVFF  9BF,FEC
062BC:  MOVLB  0
....................       } 
....................    scan->index = 0; 
062BE:  MOVLW  0C
062C0:  MOVLB  9
062C2:  ADDWF  xB4,W
062C4:  MOVWF  FE9
062C6:  MOVLW  00
062C8:  ADDWFC xB5,W
062CA:  MOVWF  FEA
062CC:  CLRF   FEC
062CE:  MOVF   FED,F
062D0:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
062D2:  MOVFF  9B9,03
062D6:  MOVFF  9B8,FE9
062DA:  MOVFF  9B9,FEA
062DE:  MOVF   FEF,W
062E0:  SUBLW  20
062E2:  BZ    6308
062E4:  MOVFF  9B9,03
062E8:  MOVFF  9B8,FE9
062EC:  MOVFF  9B9,FEA
062F0:  MOVF   FEF,W
062F2:  SUBLW  2F
062F4:  BZ    6308
062F6:  MOVFF  9B9,03
062FA:  MOVFF  9B8,FE9
062FE:  MOVFF  9B9,FEA
06302:  MOVF   FEF,W
06304:  SUBLW  5C
06306:  BNZ   6310
....................        path++; 
06308:  INCF   xB8,F
0630A:  BTFSC  FD8.2
0630C:  INCF   xB9,F
0630E:  BRA    62D2
....................  
....................    if ((BYTE)*path < ' ')  
06310:  MOVFF  9B9,03
06314:  MOVFF  9B8,FE9
06318:  MOVFF  9B9,FEA
0631C:  MOVF   FEF,W
0631E:  SUBLW  1F
06320:  BNC   6336
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
06322:  MOVFF  9BA,FE9
06326:  MOVFF  9BB,FEA
0632A:  CLRF   FEC
0632C:  MOVF   FED,F
0632E:  CLRF   FEF
....................       return (FR_OK); 
06330:  MOVLW  00
06332:  MOVWF  01
06334:  BRA    658E
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
06336:  MOVLW  09
06338:  MOVWF  xC4
0633A:  MOVLW  B8
0633C:  MOVWF  xC3
0633E:  MOVFF  9B7,9C6
06342:  MOVFF  9B6,9C5
06346:  MOVLB  0
06348:  GOTO   56BE
0634C:  MOVFF  01,9C0
....................       if (ds == 1)  
06350:  MOVLB  9
06352:  DECFSZ xC0,W
06354:  BRA    635C
....................          return (FR_INVALID_NAME); 
06356:  MOVLW  04
06358:  MOVWF  01
0635A:  BRA    658E
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
0635C:  MOVLW  08
0635E:  ADDWF  xB4,W
06360:  MOVWF  FE9
06362:  MOVLW  00
06364:  ADDWFC xB5,W
06366:  MOVWF  FEA
06368:  MOVFF  FEF,9EE
0636C:  MOVFF  FEC,9EF
06370:  MOVFF  FEC,9F0
06374:  MOVFF  FEC,9F1
06378:  MOVLB  0
0637A:  CALL   5A5A
0637E:  MOVF   01,F
06380:  BNZ   638C
....................             return (FR_RW_ERROR); 
06382:  MOVLW  07
06384:  MOVWF  01
06386:  MOVLB  9
06388:  BRA    658E
0638A:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
0638C:  MOVLW  0C
0638E:  MOVLB  9
06390:  ADDWF  xB4,W
06392:  MOVWF  FE9
06394:  MOVLW  00
06396:  ADDWFC xB5,W
06398:  MOVWF  FEA
0639A:  MOVFF  FEC,9C4
0639E:  MOVF   FED,F
063A0:  MOVFF  FEF,9C3
063A4:  MOVLW  0F
063A6:  ANDWF  xC3,F
063A8:  CLRF   xC4
063AA:  RLCF   xC3,F
063AC:  RLCF   xC4,F
063AE:  RLCF   xC3,F
063B0:  RLCF   xC4,F
063B2:  RLCF   xC3,F
063B4:  RLCF   xC4,F
063B6:  RLCF   xC3,F
063B8:  RLCF   xC4,F
063BA:  RLCF   xC3,F
063BC:  RLCF   xC4,F
063BE:  MOVLW  E0
063C0:  ANDWF  xC3,F
063C2:  MOVLW  24
063C4:  ADDWF  xC3,W
063C6:  MOVWF  01
063C8:  MOVLW  00
063CA:  ADDWFC xC4,W
063CC:  MOVWF  03
063CE:  MOVF   01,W
063D0:  MOVLB  7
063D2:  ADDWF  x12,W
063D4:  MOVWF  01
063D6:  MOVF   x13,W
063D8:  ADDWFC 03,F
063DA:  MOVFF  01,9C1
063DE:  MOVLB  9
063E0:  MOVFF  03,9C2
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
063E4:  MOVFF  9C2,03
063E8:  MOVFF  9C1,FE9
063EC:  MOVFF  9C2,FEA
063F0:  MOVF   FEF,F
063F2:  BNZ   6402
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
063F4:  MOVF   xC0,F
063F6:  BNZ   63FC
063F8:  MOVLW  02
063FA:  BRA    63FE
063FC:  MOVLW  03
063FE:  MOVWF  01
06400:  BRA    658E
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
06402:  MOVFF  9C2,03
06406:  MOVFF  9C1,FE9
0640A:  MOVFF  9C2,FEA
0640E:  MOVF   FEF,W
06410:  SUBLW  E5
06412:  BZ    6454
06414:  MOVLW  0B
06416:  ADDWF  xC1,W
06418:  MOVWF  01
0641A:  MOVLW  00
0641C:  ADDWFC xC2,W
0641E:  MOVWF  03
06420:  MOVFF  01,FE9
06424:  MOVWF  FEA
06426:  BTFSC  FEF.3
06428:  BRA    6454
0642A:  MOVFF  9C2,9C8
0642E:  MOVFF  9C1,9C7
06432:  MOVFF  9B7,9CA
06436:  MOVFF  9B6,9C9
0643A:  CLRF   xCC
0643C:  MOVLW  0B
0643E:  MOVWF  xCB
06440:  MOVLB  0
06442:  CALL   45F2
06446:  MOVF   01,F
06448:  BTFSC  FD8.2
0644A:  BRA    6450
0644C:  MOVLB  9
0644E:  BRA    6454
....................              break; 
06450:  BRA    647C
06452:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
06454:  MOVFF  9B5,9C4
06458:  MOVFF  9B4,9C3
0645C:  MOVLB  0
0645E:  RCALL  5FD0
06460:  MOVF   01,F
06462:  BNZ   6476
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06464:  MOVLB  9
06466:  MOVF   xC0,F
06468:  BNZ   646E
0646A:  MOVLW  02
0646C:  BRA    6470
0646E:  MOVLW  03
06470:  MOVWF  01
06472:  BRA    658E
06474:  MOVLB  0
06476:  MOVLB  9
06478:  BRA    635C
0647A:  MOVLB  0
....................          } 
....................       if (!ds)  
0647C:  MOVLB  9
0647E:  MOVF   xC0,F
06480:  BNZ   649A
....................          {  
....................          *win_dir = dptr;  
06482:  MOVFF  9BA,FE9
06486:  MOVFF  9BB,FEA
0648A:  MOVFF  9C2,FEC
0648E:  MOVF   FED,F
06490:  MOVFF  9C1,FEF
....................          return (FR_OK); 
06494:  MOVLW  00
06496:  MOVWF  01
06498:  BRA    658E
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
0649A:  MOVLW  0B
0649C:  ADDWF  xC1,W
0649E:  MOVWF  01
064A0:  MOVLW  00
064A2:  ADDWFC xC2,W
064A4:  MOVWF  03
064A6:  MOVFF  01,FE9
064AA:  MOVWF  FEA
064AC:  BTFSC  FEF.4
064AE:  BRA    64B6
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
064B0:  MOVLW  03
064B2:  MOVWF  01
064B4:  BRA    658E
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
064B6:  MOVLW  14
064B8:  ADDWF  xC1,W
064BA:  MOVWF  01
064BC:  MOVLW  00
064BE:  ADDWFC xC2,W
064C0:  MOVWF  03
064C2:  MOVFF  01,FE9
064C6:  MOVWF  FEA
064C8:  MOVFF  FEC,9BF
064CC:  MOVF   FED,F
064CE:  MOVFF  FEF,9C3
064D2:  MOVFF  9C3,9BE
064D6:  CLRF   xC3
064D8:  CLRF   xC4
064DA:  MOVLW  1A
064DC:  ADDWF  xC1,W
064DE:  MOVWF  01
064E0:  MOVLW  00
064E2:  ADDWFC xC2,W
064E4:  MOVFF  01,FE9
064E8:  MOVWF  FEA
064EA:  MOVFF  FEC,03
064EE:  MOVF   FED,F
064F0:  MOVF   FEF,W
064F2:  IORWF  xC3,W
064F4:  MOVWF  xBC
064F6:  MOVF   03,W
064F8:  IORWF  xC4,W
064FA:  MOVWF  xBD
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
064FC:  MOVLW  04
064FE:  ADDWF  xB4,W
06500:  MOVWF  01
06502:  MOVLW  00
06504:  ADDWFC xB5,W
06506:  MOVFF  01,9C3
0650A:  MOVFF  9B4,FE9
0650E:  MOVFF  9B5,FEA
06512:  MOVFF  9BC,FEF
06516:  MOVFF  9BD,FEC
0651A:  MOVFF  9BE,FEC
0651E:  MOVFF  9BF,FEC
06522:  MOVWF  FEA
06524:  MOVFF  9C3,FE9
06528:  MOVFF  9BC,FEF
0652C:  MOVFF  9BD,FEC
06530:  MOVFF  9BE,FEC
06534:  MOVFF  9BF,FEC
....................       scan->sect = clust2sect(clust); 
06538:  MOVLW  08
0653A:  ADDWF  xB4,W
0653C:  MOVWF  01
0653E:  MOVLW  00
06540:  ADDWFC xB5,W
06542:  MOVWF  03
06544:  MOVFF  01,9C3
06548:  MOVWF  xC4
0654A:  MOVFF  9BF,9D0
0654E:  MOVFF  9BE,9CF
06552:  MOVFF  9BD,9CE
06556:  MOVFF  9BC,9CD
0655A:  MOVLB  0
0655C:  CALL   55E4
06560:  MOVFF  9C4,FEA
06564:  MOVFF  9C3,FE9
06568:  MOVFF  00,FEF
0656C:  MOVFF  01,FEC
06570:  MOVFF  02,FEC
06574:  MOVFF  03,FEC
....................       scan->index = 0; 
06578:  MOVLW  0C
0657A:  MOVLB  9
0657C:  ADDWF  xB4,W
0657E:  MOVWF  FE9
06580:  MOVLW  00
06582:  ADDWFC xB5,W
06584:  MOVWF  FEA
06586:  CLRF   FEC
06588:  MOVF   FED,F
0658A:  CLRF   FEF
0658C:  BRA    6336
....................       } 
0658E:  MOVLB  0
06590:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06BA8:  MOVLB  9
06BAA:  MOVFF  9B4,FE9
06BAE:  MOVFF  9B5,FEA
06BB2:  MOVFF  FEF,9B6
06BB6:  MOVFF  FEC,9B7
06BBA:  MOVFF  FEC,9B8
06BBE:  MOVFF  FEC,9B9
....................    if (clust) {   // Dyanmic directory table  
06BC2:  MOVF   xB6,F
06BC4:  BNZ   6BD2
06BC6:  MOVF   xB7,F
06BC8:  BNZ   6BD2
06BCA:  MOVF   xB8,F
06BCC:  BNZ   6BD2
06BCE:  MOVF   xB9,F
06BD0:  BZ    6C32
....................       scan->clust = clust; 
06BD2:  MOVLW  04
06BD4:  ADDWF  xB4,W
06BD6:  MOVWF  FE9
06BD8:  MOVLW  00
06BDA:  ADDWFC xB5,W
06BDC:  MOVWF  FEA
06BDE:  MOVFF  9B6,FEF
06BE2:  MOVFF  9B7,FEC
06BE6:  MOVFF  9B8,FEC
06BEA:  MOVFF  9B9,FEC
....................       scan->sect = clust2sect(clust); 
06BEE:  MOVLW  08
06BF0:  ADDWF  xB4,W
06BF2:  MOVWF  01
06BF4:  MOVLW  00
06BF6:  ADDWFC xB5,W
06BF8:  MOVWF  03
06BFA:  MOVFF  01,9C2
06BFE:  MOVWF  xC3
06C00:  MOVFF  9B9,9D0
06C04:  MOVFF  9B8,9CF
06C08:  MOVFF  9B7,9CE
06C0C:  MOVFF  9B6,9CD
06C10:  MOVLB  0
06C12:  CALL   55E4
06C16:  MOVFF  9C3,FEA
06C1A:  MOVFF  9C2,FE9
06C1E:  MOVFF  00,FEF
06C22:  MOVFF  01,FEC
06C26:  MOVFF  02,FEC
06C2A:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06C2E:  BRA    6C7C
06C30:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06C32:  MOVLW  08
06C34:  ADDWF  xB4,W
06C36:  MOVWF  01
06C38:  MOVLW  00
06C3A:  ADDWFC xB5,W
06C3C:  MOVWF  03
06C3E:  MOVFF  01,9C2
06C42:  MOVWF  xC3
06C44:  MOVLW  14
06C46:  MOVLB  7
06C48:  ADDWF  x12,W
06C4A:  MOVWF  FE9
06C4C:  MOVLW  00
06C4E:  ADDWFC x13,W
06C50:  MOVWF  FEA
06C52:  MOVFF  FEF,00
06C56:  MOVFF  FEC,01
06C5A:  MOVFF  FEC,02
06C5E:  MOVFF  FEC,03
06C62:  MOVFF  9C3,FEA
06C66:  MOVFF  9C2,FE9
06C6A:  MOVFF  00,FEF
06C6E:  MOVFF  01,FEC
06C72:  MOVFF  02,FEC
06C76:  MOVFF  03,FEC
06C7A:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06C7C:  MOVLW  0C
06C7E:  MOVLB  9
06C80:  ADDWF  xB4,W
06C82:  MOVWF  FE9
06C84:  MOVLW  00
06C86:  ADDWFC xB5,W
06C88:  MOVWF  FEA
06C8A:  CLRF   FEC
06C8C:  MOVF   FED,F
06C8E:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06C90:  MOVLW  08
06C92:  ADDWF  xB4,W
06C94:  MOVWF  FE9
06C96:  MOVLW  00
06C98:  ADDWFC xB5,W
06C9A:  MOVWF  FEA
06C9C:  MOVFF  FEF,9EE
06CA0:  MOVFF  FEC,9EF
06CA4:  MOVFF  FEC,9F0
06CA8:  MOVFF  FEC,9F1
06CAC:  MOVLB  0
06CAE:  CALL   5A5A
06CB2:  MOVF   01,F
06CB4:  BNZ   6CBE
....................          return (NULL); 
06CB6:  MOVLW  00
06CB8:  MOVWF  01
06CBA:  MOVWF  02
06CBC:  BRA    6EE8
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06CBE:  MOVLW  0C
06CC0:  MOVLB  9
06CC2:  ADDWF  xB4,W
06CC4:  MOVWF  FE9
06CC6:  MOVLW  00
06CC8:  ADDWFC xB5,W
06CCA:  MOVWF  FEA
06CCC:  MOVFF  FEC,9C3
06CD0:  MOVF   FED,F
06CD2:  MOVFF  FEF,9C2
06CD6:  MOVLW  0F
06CD8:  ANDWF  xC2,F
06CDA:  CLRF   xC3
06CDC:  RLCF   xC2,F
06CDE:  RLCF   xC3,F
06CE0:  RLCF   xC2,F
06CE2:  RLCF   xC3,F
06CE4:  RLCF   xC2,F
06CE6:  RLCF   xC3,F
06CE8:  RLCF   xC2,F
06CEA:  RLCF   xC3,F
06CEC:  RLCF   xC2,F
06CEE:  RLCF   xC3,F
06CF0:  MOVLW  E0
06CF2:  ANDWF  xC2,F
06CF4:  MOVLW  24
06CF6:  ADDWF  xC2,W
06CF8:  MOVWF  01
06CFA:  MOVLW  00
06CFC:  ADDWFC xC3,W
06CFE:  MOVWF  03
06D00:  MOVF   01,W
06D02:  MOVLB  7
06D04:  ADDWF  x12,W
06D06:  MOVWF  01
06D08:  MOVF   x13,W
06D0A:  ADDWFC 03,F
06D0C:  MOVFF  01,9C0
06D10:  MOVLB  9
06D12:  MOVFF  03,9C1
....................       c = *dptr; 
06D16:  MOVFF  9C0,FE9
06D1A:  MOVFF  9C1,FEA
06D1E:  MOVFF  FEF,9BE
....................       if ((c == 0) || (c == 0xE5))  
06D22:  MOVF   xBE,F
06D24:  BZ    6D2C
06D26:  MOVF   xBE,W
06D28:  SUBLW  E5
06D2A:  BNZ   6D3A
....................          return (dptr);      // Found an empty entry!  
06D2C:  MOVFF  9C0,01
06D30:  MOVFF  9C1,02
06D34:  MOVLB  0
06D36:  BRA    6EE8
06D38:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06D3A:  MOVFF  9B5,9C4
06D3E:  MOVFF  9B4,9C3
06D42:  MOVLB  0
06D44:  CALL   5FD0
06D48:  MOVF   01,F
06D4A:  BTFSC  FD8.2
06D4C:  BRA    6D52
06D4E:  MOVLB  9
06D50:  BRA    6C90
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06D52:  MOVLB  9
06D54:  MOVF   xB6,F
06D56:  BNZ   6D70
06D58:  MOVF   xB7,F
06D5A:  BNZ   6D70
06D5C:  MOVF   xB8,F
06D5E:  BNZ   6D70
06D60:  MOVF   xB9,F
06D62:  BNZ   6D70
....................        return (NULL); 
06D64:  MOVLW  00
06D66:  MOVWF  01
06D68:  MOVWF  02
06D6A:  MOVLB  0
06D6C:  BRA    6EE8
06D6E:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06D70:  MOVLW  04
06D72:  ADDWF  xB4,W
06D74:  MOVWF  FE9
06D76:  MOVLW  00
06D78:  ADDWFC xB5,W
06D7A:  MOVWF  FEA
06D7C:  MOVFF  FEF,9C6
06D80:  MOVFF  FEC,9C7
06D84:  MOVFF  FEC,9C8
06D88:  MOVFF  FEC,9C9
06D8C:  MOVLB  0
06D8E:  RCALL  6912
06D90:  MOVFF  03,9B9
06D94:  MOVFF  02,9B8
06D98:  MOVFF  01,9B7
06D9C:  MOVFF  00,9B6
....................    if (!(clust))  
06DA0:  MOVLB  9
06DA2:  MOVF   xB6,F
06DA4:  BNZ   6DBE
06DA6:  MOVF   xB7,F
06DA8:  BNZ   6DBE
06DAA:  MOVF   xB8,F
06DAC:  BNZ   6DBE
06DAE:  MOVF   xB9,F
06DB0:  BNZ   6DBE
....................       return (NULL); 
06DB2:  MOVLW  00
06DB4:  MOVWF  01
06DB6:  MOVWF  02
06DB8:  MOVLB  0
06DBA:  BRA    6EE8
06DBC:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06DBE:  CLRF   xF1
06DC0:  CLRF   xF0
06DC2:  CLRF   xEF
06DC4:  CLRF   xEE
06DC6:  MOVLB  0
06DC8:  CALL   5A5A
06DCC:  MOVF   01,F
06DCE:  BNZ   6DD8
....................       return (0); 
06DD0:  MOVLW  00
06DD2:  MOVWF  01
06DD4:  MOVWF  02
06DD6:  BRA    6EE8
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06DD8:  MOVLW  20
06DDA:  MOVLB  7
06DDC:  ADDWF  x12,W
06DDE:  MOVWF  01
06DE0:  MOVLW  00
06DE2:  ADDWFC x13,W
06DE4:  MOVWF  03
06DE6:  MOVFF  01,9C2
06DEA:  MOVLB  9
06DEC:  MOVWF  xC3
06DEE:  MOVFF  9B9,9D0
06DF2:  MOVFF  9B8,9CF
06DF6:  MOVFF  9B7,9CE
06DFA:  MOVFF  9B6,9CD
06DFE:  MOVLB  0
06E00:  CALL   55E4
06E04:  MOVFF  03,9BD
06E08:  MOVFF  02,9BC
06E0C:  MOVFF  01,9BB
06E10:  MOVFF  00,9BA
06E14:  MOVFF  9C3,FEA
06E18:  MOVFF  9C2,FE9
06E1C:  MOVFF  9BA,FEF
06E20:  MOVFF  9BB,FEC
06E24:  MOVFF  9BC,FEC
06E28:  MOVFF  9BD,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06E2C:  MOVLW  24
06E2E:  MOVLB  7
06E30:  ADDWF  x12,W
06E32:  MOVWF  01
06E34:  MOVLW  00
06E36:  ADDWFC x13,W
06E38:  MOVWF  03
06E3A:  MOVFF  01,9C2
06E3E:  MOVLB  9
06E40:  MOVWF  xC3
06E42:  MOVWF  FEA
06E44:  MOVFF  01,FE9
06E48:  CLRF   00
06E4A:  MOVLW  02
06E4C:  MOVWF  02
06E4E:  CLRF   01
06E50:  MOVLB  0
06E52:  CALL   350A
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06E56:  MOVLW  02
06E58:  MOVLB  7
06E5A:  ADDWF  x12,W
06E5C:  MOVWF  FE9
06E5E:  MOVLW  00
06E60:  ADDWFC x13,W
06E62:  MOVWF  FEA
06E64:  MOVFF  FEF,9BF
06E68:  MOVLB  9
06E6A:  MOVF   xBF,F
06E6C:  BZ    6EC8
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06E6E:  MOVLW  24
06E70:  MOVLB  7
06E72:  ADDWF  x12,W
06E74:  MOVWF  01
06E76:  MOVLW  00
06E78:  ADDWFC x13,W
06E7A:  MOVWF  03
06E7C:  MOVFF  01,9C2
06E80:  MOVLB  9
06E82:  MOVWF  xC3
06E84:  MOVWF  xFB
06E86:  MOVFF  01,9FA
06E8A:  MOVFF  9BD,9FF
06E8E:  MOVFF  9BC,9FE
06E92:  MOVFF  9BB,9FD
06E96:  MOVFF  9BA,9FC
06E9A:  MOVLW  01
06E9C:  MOVLB  A
06E9E:  MOVWF  x00
06EA0:  MOVLB  0
06EA2:  CALL   5914
06EA6:  MOVF   01,F
06EA8:  BZ    6EB2
....................          return (NULL); 
06EAA:  MOVLW  00
06EAC:  MOVWF  01
06EAE:  MOVWF  02
06EB0:  BRA    6EE8
....................       sector++; 
06EB2:  MOVLW  01
06EB4:  MOVLB  9
06EB6:  ADDWF  xBA,F
06EB8:  BTFSC  FD8.0
06EBA:  INCF   xBB,F
06EBC:  BTFSC  FD8.2
06EBE:  INCF   xBC,F
06EC0:  BTFSC  FD8.2
06EC2:  INCF   xBD,F
06EC4:  DECF   xBF,F
06EC6:  BRA    6E6A
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06EC8:  MOVLW  06
06ECA:  MOVLB  7
06ECC:  ADDWF  x12,W
06ECE:  MOVWF  FE9
06ED0:  MOVLW  00
06ED2:  ADDWFC x13,W
06ED4:  MOVWF  FEA
06ED6:  MOVLW  01
06ED8:  MOVWF  FEF
....................    return (fs->win); 
06EDA:  MOVLW  24
06EDC:  ADDWF  x12,W
06EDE:  MOVWF  01
06EE0:  MOVLW  00
06EE2:  ADDWFC x13,W
06EE4:  MOVWF  03
06EE6:  MOVWF  02
06EE8:  MOVLB  0
06EEA:  GOTO   7180 (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
05582:  MOVLB  7
05584:  MOVF   x12,W
05586:  IORWF  x13,W
05588:  BNZ   5590
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
0558A:  MOVLW  0B
0558C:  MOVWF  01
0558E:  BRA    55E0
....................  
....................    if (disk_status() & STA_NOINIT)  
05590:  MOVLB  0
05592:  RCALL  5574
05594:  BTFSS  01.0
05596:  BRA    55C2
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
05598:  MOVLW  01
0559A:  MOVLB  7
0559C:  ADDWF  x12,W
0559E:  MOVWF  FE9
055A0:  MOVLW  00
055A2:  ADDWFC x13,W
055A4:  MOVWF  FEA
055A6:  MOVF   FEF,F
055A8:  BZ    55B2
....................          return (FR_INCORRECT_DISK_CHANGE); 
055AA:  MOVLW  09
055AC:  MOVWF  01
055AE:  BRA    55E0
055B0:  BRA    55BE
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
055B2:  MOVLB  0
055B4:  CALL   4830
055B8:  MOVF   01,W
055BA:  MOVLB  7
055BC:  BRA    55E0
....................       }  
055BE:  BRA    55DC
055C0:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
055C2:  MOVLB  7
055C4:  MOVFF  712,FE9
055C8:  MOVFF  713,FEA
055CC:  MOVF   FEF,F
055CE:  BNZ   55DC
....................          return (f_mountdrv());      // Initialize file system and return resulut  
055D0:  MOVLB  0
055D2:  CALL   4830
055D6:  MOVF   01,W
055D8:  MOVLB  7
055DA:  BRA    55E0
....................       } 
....................    return FR_OK;                  // File system is valid  
055DC:  MOVLW  00
055DE:  MOVWF  01
055E0:  MOVLB  0
055E2:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B5F0:  MOVLB  8
0B5F2:  MOVF   xAB,W
0B5F4:  XORLW  00
0B5F6:  MOVLB  0
0B5F8:  BZ    B632
0B5FA:  XORLW  04
0B5FC:  BZ    B64E
0B5FE:  XORLW  05
0B600:  BZ    B66A
0B602:  XORLW  03
0B604:  BZ    B686
0B606:  XORLW  01
0B608:  BZ    B6A2
0B60A:  XORLW  06
0B60C:  BZ    B6BE
0B60E:  XORLW  03
0B610:  BZ    B6DA
0B612:  XORLW  01
0B614:  BTFSC  FD8.2
0B616:  BRA    B6F6
0B618:  XORLW  0E
0B61A:  BTFSC  FD8.2
0B61C:  BRA    B712
0B61E:  XORLW  03
0B620:  BTFSC  FD8.2
0B622:  BRA    B72E
0B624:  XORLW  01
0B626:  BTFSC  FD8.2
0B628:  BRA    B74A
0B62A:  XORLW  07
0B62C:  BTFSC  FD8.2
0B62E:  BRA    B766
0B630:  BRA    B782
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B632:  MOVFF  8AD,FEA
0B636:  MOVFF  8AC,FE9
0B63A:  MOVLW  00
0B63C:  CALL   0106
0B640:  TBLRD*-
0B642:  TBLRD*+
0B644:  MOVF   FF5,W
0B646:  MOVWF  FEE
0B648:  IORLW  00
0B64A:  BNZ   B642
....................          break; 
0B64C:  BRA    B79C
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B64E:  MOVFF  8AD,FEA
0B652:  MOVFF  8AC,FE9
0B656:  MOVLW  00
0B658:  CALL   0124
0B65C:  TBLRD*-
0B65E:  TBLRD*+
0B660:  MOVF   FF5,W
0B662:  MOVWF  FEE
0B664:  IORLW  00
0B666:  BNZ   B65E
....................          break; 
0B668:  BRA    B79C
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0B66A:  MOVFF  8AD,FEA
0B66E:  MOVFF  8AC,FE9
0B672:  MOVLW  00
0B674:  CALL   014A
0B678:  TBLRD*-
0B67A:  TBLRD*+
0B67C:  MOVF   FF5,W
0B67E:  MOVWF  FEE
0B680:  IORLW  00
0B682:  BNZ   B67A
....................          break; 
0B684:  BRA    B79C
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0B686:  MOVFF  8AD,FEA
0B68A:  MOVFF  8AC,FE9
0B68E:  MOVLW  00
0B690:  CALL   016E
0B694:  TBLRD*-
0B696:  TBLRD*+
0B698:  MOVF   FF5,W
0B69A:  MOVWF  FEE
0B69C:  IORLW  00
0B69E:  BNZ   B696
....................          break; 
0B6A0:  BRA    B79C
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0B6A2:  MOVFF  8AD,FEA
0B6A6:  MOVFF  8AC,FE9
0B6AA:  MOVLW  00
0B6AC:  CALL   0192
0B6B0:  TBLRD*-
0B6B2:  TBLRD*+
0B6B4:  MOVF   FF5,W
0B6B6:  MOVWF  FEE
0B6B8:  IORLW  00
0B6BA:  BNZ   B6B2
....................          break; 
0B6BC:  BRA    B79C
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0B6BE:  MOVFF  8AD,FEA
0B6C2:  MOVFF  8AC,FE9
0B6C6:  MOVLW  00
0B6C8:  CALL   01B6
0B6CC:  TBLRD*-
0B6CE:  TBLRD*+
0B6D0:  MOVF   FF5,W
0B6D2:  MOVWF  FEE
0B6D4:  IORLW  00
0B6D6:  BNZ   B6CE
....................          break; 
0B6D8:  BRA    B79C
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0B6DA:  MOVFF  8AD,FEA
0B6DE:  MOVFF  8AC,FE9
0B6E2:  MOVLW  00
0B6E4:  CALL   01D8
0B6E8:  TBLRD*-
0B6EA:  TBLRD*+
0B6EC:  MOVF   FF5,W
0B6EE:  MOVWF  FEE
0B6F0:  IORLW  00
0B6F2:  BNZ   B6EA
....................          break; 
0B6F4:  BRA    B79C
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0B6F6:  MOVFF  8AD,FEA
0B6FA:  MOVFF  8AC,FE9
0B6FE:  MOVLW  00
0B700:  CALL   01F8
0B704:  TBLRD*-
0B706:  TBLRD*+
0B708:  MOVF   FF5,W
0B70A:  MOVWF  FEE
0B70C:  IORLW  00
0B70E:  BNZ   B706
....................          break; 
0B710:  BRA    B79C
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0B712:  MOVFF  8AD,FEA
0B716:  MOVFF  8AC,FE9
0B71A:  MOVLW  00
0B71C:  CALL   0216
0B720:  TBLRD*-
0B722:  TBLRD*+
0B724:  MOVF   FF5,W
0B726:  MOVWF  FEE
0B728:  IORLW  00
0B72A:  BNZ   B722
....................          break; 
0B72C:  BRA    B79C
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0B72E:  MOVFF  8AD,FEA
0B732:  MOVFF  8AC,FE9
0B736:  MOVLW  00
0B738:  CALL   0242
0B73C:  TBLRD*-
0B73E:  TBLRD*+
0B740:  MOVF   FF5,W
0B742:  MOVWF  FEE
0B744:  IORLW  00
0B746:  BNZ   B73E
....................          break; 
0B748:  BRA    B79C
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0B74A:  MOVFF  8AD,FEA
0B74E:  MOVFF  8AC,FE9
0B752:  MOVLW  00
0B754:  CALL   0266
0B758:  TBLRD*-
0B75A:  TBLRD*+
0B75C:  MOVF   FF5,W
0B75E:  MOVWF  FEE
0B760:  IORLW  00
0B762:  BNZ   B75A
....................          break; 
0B764:  BRA    B79C
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0B766:  MOVFF  8AD,FEA
0B76A:  MOVFF  8AC,FE9
0B76E:  MOVLW  00
0B770:  CALL   028A
0B774:  TBLRD*-
0B776:  TBLRD*+
0B778:  MOVF   FF5,W
0B77A:  MOVWF  FEE
0B77C:  IORLW  00
0B77E:  BNZ   B776
....................          break; 
0B780:  BRA    B79C
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0B782:  MOVFF  8AD,FEA
0B786:  MOVFF  8AC,FE9
0B78A:  MOVLW  00
0B78C:  CALL   02AC
0B790:  TBLRD*-
0B792:  TBLRD*+
0B794:  MOVF   FF5,W
0B796:  MOVWF  FEE
0B798:  IORLW  00
0B79A:  BNZ   B792
....................       } 
0B79C:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
04830:  MOVLB  7
04832:  MOVF   x12,W
04834:  IORWF  x13,W
04836:  BNZ   483E
....................       return (FR_NOT_ENABLED); 
04838:  MOVLW  0B
0483A:  MOVWF  01
0483C:  BRA    4DCA
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
0483E:  MOVFF  713,FEA
04842:  MOVFF  712,FE9
04846:  CLRF   00
04848:  MOVLW  02
0484A:  MOVWF  02
0484C:  MOVLW  24
0484E:  MOVWF  01
04850:  MOVLB  0
04852:  CALL   350A
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
04856:  CALL   365A
0485A:  MOVFF  01,4ED
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
0485E:  MOVLB  4
04860:  BTFSS  xED.0
04862:  BRA    4870
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
04864:  MOVLB  0
04866:  CALL   365A
0486A:  MOVFF  01,4ED
0486E:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
04870:  BTFSS  xED.0
04872:  BRA    487E
04874:  MOVLW  01
04876:  MOVWF  01
04878:  MOVLB  7
0487A:  BRA    4DCA
0487C:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
0487E:  MOVLB  9
04880:  CLRF   xB8
04882:  CLRF   xB7
04884:  CLRF   xB6
04886:  CLRF   xB5
04888:  MOVFF  9B8,9C4
0488C:  MOVFF  9B7,9C3
04890:  MOVFF  9B6,9C2
04894:  MOVFF  9B5,9C1
04898:  MOVLB  0
0489A:  RCALL  4676
0489C:  MOVFF  01,9B4
....................    if (!fat)  
048A0:  MOVLB  9
048A2:  MOVF   xB4,F
048A4:  BNZ   4914
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
048A6:  MOVLW  E6
048A8:  MOVLB  7
048AA:  ADDWF  x12,W
048AC:  MOVWF  FE9
048AE:  MOVLW  01
048B0:  ADDWFC x13,W
048B2:  MOVWF  FEA
048B4:  MOVF   FEF,F
048B6:  BZ    48F4
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
048B8:  MOVLW  EA
048BA:  ADDWF  x12,W
048BC:  MOVWF  01
048BE:  MOVLW  01
048C0:  ADDWFC x13,W
048C2:  MOVFF  01,FE9
048C6:  MOVWF  FEA
048C8:  MOVFF  FEF,9B5
048CC:  MOVFF  FEC,9B6
048D0:  MOVFF  FEC,9B7
048D4:  MOVFF  FEC,9B8
....................          fat = check_fs(sect);            // Check the partition  
048D8:  MOVFF  9B8,9C4
048DC:  MOVFF  9B7,9C3
048E0:  MOVFF  9B6,9C2
048E4:  MOVFF  9B5,9C1
048E8:  MOVLB  0
048EA:  RCALL  4676
048EC:  MOVFF  01,9B4
....................          } 
048F0:  BRA    4912
048F2:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
048F4:  MOVLW  2E
048F6:  MOVWF  FF6
048F8:  MOVLW  0C
048FA:  MOVWF  FF7
048FC:  MOVLW  00
048FE:  MOVWF  FF8
04900:  CLRF   1B
04902:  BTFSC  FF2.7
04904:  BSF    1B.7
04906:  BCF    FF2.7
04908:  MOVLB  0
0490A:  CALL   0E78
0490E:  BTFSC  1B.7
04910:  BSF    FF2.7
04912:  MOVLB  9
....................       } 
....................    if (!fat)  
04914:  MOVF   xB4,F
04916:  BNZ   4922
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
04918:  MOVLW  0C
0491A:  MOVWF  01
0491C:  MOVLB  7
0491E:  BRA    4DCA
04920:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
04922:  MOVLB  7
04924:  MOVFF  712,FE9
04928:  MOVFF  713,FEA
0492C:  MOVFF  9B4,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
04930:  MOVLB  9
04932:  MOVF   xB4,W
04934:  SUBLW  03
04936:  BNZ   499C
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
04938:  MOVLW  08
0493A:  MOVLB  7
0493C:  ADDWF  x12,W
0493E:  MOVWF  01
04940:  MOVLW  00
04942:  ADDWFC x13,W
04944:  MOVWF  03
04946:  MOVFF  01,9C1
0494A:  MOVLB  9
0494C:  MOVWF  xC2
0494E:  MOVLW  48
04950:  MOVLB  7
04952:  ADDWF  x12,W
04954:  MOVWF  01
04956:  MOVLW  00
04958:  ADDWFC x13,W
0495A:  MOVFF  01,FE9
0495E:  MOVWF  FEA
04960:  MOVFF  FEF,00
04964:  MOVFF  FEC,01
04968:  MOVFF  FEC,02
0496C:  MOVFF  FEC,03
04970:  MOVFF  03,9C6
04974:  MOVFF  02,9C5
04978:  MOVFF  01,9C4
0497C:  MOVFF  00,9C3
04980:  MOVFF  9C2,FEA
04984:  MOVFF  9C1,FE9
04988:  MOVFF  00,FEF
0498C:  MOVFF  01,FEC
04990:  MOVFF  02,FEC
04994:  MOVFF  03,FEC
04998:  BRA    49F4
0499A:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
0499C:  MOVLW  08
0499E:  MOVLB  7
049A0:  ADDWF  x12,W
049A2:  MOVWF  01
049A4:  MOVLW  00
049A6:  ADDWFC x13,W
049A8:  MOVWF  03
049AA:  MOVFF  01,9C1
049AE:  MOVLB  9
049B0:  MOVWF  xC2
049B2:  MOVLW  3A
049B4:  MOVLB  7
049B6:  ADDWF  x12,W
049B8:  MOVWF  01
049BA:  MOVLW  00
049BC:  ADDWFC x13,W
049BE:  MOVFF  01,FE9
049C2:  MOVWF  FEA
049C4:  MOVFF  FEC,03
049C8:  MOVF   FED,F
049CA:  MOVFF  FEF,9C3
049CE:  MOVLB  9
049D0:  MOVFF  03,9C4
049D4:  MOVFF  9C2,FEA
049D8:  MOVFF  9C1,FE9
049DC:  MOVF   FEE,F
049DE:  MOVF   FEE,F
049E0:  CLRF   FEC
049E2:  MOVF   FED,F
049E4:  CLRF   FEF
049E6:  MOVF   FED,F
049E8:  MOVFF  03,FEF
049EC:  MOVF   FED,F
049EE:  MOVFF  9C3,FEF
049F2:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
049F4:  MOVLW  02
049F6:  ADDWF  x12,W
049F8:  MOVWF  01
049FA:  MOVLW  00
049FC:  ADDWFC x13,W
049FE:  MOVWF  03
04A00:  MOVLW  31
04A02:  MOVLB  7
04A04:  ADDWF  x12,W
04A06:  MOVWF  FE9
04A08:  MOVLW  00
04A0A:  ADDWFC x13,W
04A0C:  MOVWF  FEA
04A0E:  MOVFF  FEF,9C3
04A12:  MOVLB  9
04A14:  MOVFF  03,FEA
04A18:  MOVFF  01,FE9
04A1C:  MOVFF  9C3,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
04A20:  MOVLW  03
04A22:  MOVLB  7
04A24:  ADDWF  x12,W
04A26:  MOVWF  01
04A28:  MOVLW  00
04A2A:  ADDWFC x13,W
04A2C:  MOVWF  03
04A2E:  MOVLW  34
04A30:  MOVLB  7
04A32:  ADDWF  x12,W
04A34:  MOVWF  FE9
04A36:  MOVLW  00
04A38:  ADDWFC x13,W
04A3A:  MOVWF  FEA
04A3C:  MOVFF  FEF,9C3
04A40:  MOVLB  9
04A42:  MOVFF  03,FEA
04A46:  MOVFF  01,FE9
04A4A:  MOVFF  9C3,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
04A4E:  MOVLW  10
04A50:  MOVLB  7
04A52:  ADDWF  x12,W
04A54:  MOVWF  01
04A56:  MOVLW  00
04A58:  ADDWFC x13,W
04A5A:  MOVWF  03
04A5C:  MOVFF  01,9C1
04A60:  MOVLB  9
04A62:  MOVWF  xC2
04A64:  MOVLW  32
04A66:  MOVLB  7
04A68:  ADDWF  x12,W
04A6A:  MOVWF  01
04A6C:  MOVLW  00
04A6E:  ADDWFC x13,W
04A70:  MOVFF  01,FE9
04A74:  MOVWF  FEA
04A76:  MOVFF  FEC,03
04A7A:  MOVF   FED,F
04A7C:  MOVF   FEF,W
04A7E:  MOVLB  9
04A80:  ADDWF  xB5,W
04A82:  MOVWF  00
04A84:  MOVF   03,W
04A86:  ADDWFC xB6,W
04A88:  MOVWF  01
04A8A:  MOVLW  00
04A8C:  ADDWFC xB7,W
04A8E:  MOVWF  02
04A90:  MOVLW  00
04A92:  ADDWFC xB8,W
04A94:  MOVFF  9C2,FEA
04A98:  MOVFF  9C1,FE9
04A9C:  MOVFF  00,FEF
04AA0:  MOVFF  01,FEC
04AA4:  MOVFF  02,FEC
04AA8:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04AAA:  MOVLW  04
04AAC:  MOVLB  7
04AAE:  ADDWF  x12,W
04AB0:  MOVWF  01
04AB2:  MOVLW  00
04AB4:  ADDWFC x13,W
04AB6:  MOVWF  03
04AB8:  MOVFF  01,9C1
04ABC:  MOVLB  9
04ABE:  MOVWF  xC2
04AC0:  MOVLW  35
04AC2:  MOVLB  7
04AC4:  ADDWF  x12,W
04AC6:  MOVWF  01
04AC8:  MOVLW  00
04ACA:  ADDWFC x13,W
04ACC:  MOVFF  01,FE9
04AD0:  MOVWF  FEA
04AD2:  MOVFF  FEC,03
04AD6:  MOVF   FED,F
04AD8:  MOVFF  FEF,9C3
04ADC:  MOVLB  9
04ADE:  MOVFF  9C2,FEA
04AE2:  MOVFF  9C1,FE9
04AE6:  MOVFF  03,FEC
04AEA:  MOVF   FED,F
04AEC:  MOVFF  9C3,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04AF0:  MOVLW  08
04AF2:  MOVLB  7
04AF4:  ADDWF  x12,W
04AF6:  MOVWF  FE9
04AF8:  MOVLW  00
04AFA:  ADDWFC x13,W
04AFC:  MOVWF  FEA
04AFE:  MOVFF  FEF,9D4
04B02:  MOVFF  FEC,9D5
04B06:  MOVFF  FEC,9D6
04B0A:  MOVFF  FEC,9D7
04B0E:  MOVLW  03
04B10:  ADDWF  x12,W
04B12:  MOVWF  FE9
04B14:  MOVLW  00
04B16:  ADDWFC x13,W
04B18:  MOVWF  FEA
04B1A:  MOVFF  FEF,9D8
04B1E:  MOVLB  9
04B20:  MOVFF  FEA,9C7
04B24:  MOVFF  FE9,9C6
04B28:  CLRF   xDB
04B2A:  CLRF   xDA
04B2C:  CLRF   xD9
04B2E:  MOVLB  0
04B30:  RCALL  47D4
04B32:  MOVFF  9C7,FEA
04B36:  MOVFF  9C6,FE9
04B3A:  MOVFF  03,9C4
04B3E:  MOVFF  02,9C3
04B42:  MOVFF  01,9C2
04B46:  MOVFF  00,9C1
04B4A:  MOVLW  10
04B4C:  MOVLB  7
04B4E:  ADDWF  x12,W
04B50:  MOVWF  FE9
04B52:  MOVLW  00
04B54:  ADDWFC x13,W
04B56:  MOVWF  FEA
04B58:  MOVFF  FEF,00
04B5C:  MOVFF  FEC,01
04B60:  MOVFF  FEC,02
04B64:  MOVFF  FEC,03
04B68:  MOVF   00,W
04B6A:  MOVLB  9
04B6C:  ADDWF  xC1,W
04B6E:  MOVWF  xB9
04B70:  MOVF   01,W
04B72:  ADDWFC xC2,W
04B74:  MOVWF  xBA
04B76:  MOVF   02,W
04B78:  ADDWFC xC3,W
04B7A:  MOVWF  xBB
04B7C:  MOVF   03,W
04B7E:  ADDWFC xC4,W
04B80:  MOVWF  xBC
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04B82:  MOVF   xB4,W
04B84:  SUBLW  03
04B86:  BNZ   4BF8
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04B88:  MOVLW  14
04B8A:  MOVLB  7
04B8C:  ADDWF  x12,W
04B8E:  MOVWF  01
04B90:  MOVLW  00
04B92:  ADDWFC x13,W
04B94:  MOVWF  03
04B96:  MOVFF  01,9C1
04B9A:  MOVLB  9
04B9C:  MOVWF  xC2
04B9E:  MOVLW  50
04BA0:  MOVLB  7
04BA2:  ADDWF  x12,W
04BA4:  MOVWF  01
04BA6:  MOVLW  00
04BA8:  ADDWFC x13,W
04BAA:  MOVFF  01,FE9
04BAE:  MOVWF  FEA
04BB0:  MOVFF  FEF,00
04BB4:  MOVFF  FEC,01
04BB8:  MOVFF  FEC,02
04BBC:  MOVFF  FEC,03
04BC0:  MOVFF  9C2,FEA
04BC4:  MOVFF  9C1,FE9
04BC8:  MOVFF  00,FEF
04BCC:  MOVFF  01,FEC
04BD0:  MOVFF  02,FEC
04BD4:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04BD8:  MOVLW  18
04BDA:  ADDWF  x12,W
04BDC:  MOVWF  FE9
04BDE:  MOVLW  00
04BE0:  ADDWFC x13,W
04BE2:  MOVWF  FEA
04BE4:  MOVFF  9B9,FEF
04BE8:  MOVFF  9BA,FEC
04BEC:  MOVFF  9BB,FEC
04BF0:  MOVFF  9BC,FEC
....................       }  
04BF4:  BRA    4C84
04BF6:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04BF8:  MOVLW  14
04BFA:  MOVLB  7
04BFC:  ADDWF  x12,W
04BFE:  MOVWF  FE9
04C00:  MOVLW  00
04C02:  ADDWFC x13,W
04C04:  MOVWF  FEA
04C06:  MOVFF  9B9,FEF
04C0A:  MOVFF  9BA,FEC
04C0E:  MOVFF  9BB,FEC
04C12:  MOVFF  9BC,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04C16:  MOVLW  18
04C18:  ADDWF  x12,W
04C1A:  MOVWF  01
04C1C:  MOVLW  00
04C1E:  ADDWFC x13,W
04C20:  MOVFF  01,9C1
04C24:  MOVLB  9
04C26:  MOVWF  xC2
04C28:  MOVLW  04
04C2A:  MOVLB  7
04C2C:  ADDWF  x12,W
04C2E:  MOVWF  FE9
04C30:  MOVLW  00
04C32:  ADDWFC x13,W
04C34:  MOVWF  FEA
04C36:  MOVFF  FEC,9C4
04C3A:  MOVF   FED,F
04C3C:  MOVFF  FEF,9C3
04C40:  MOVLB  9
04C42:  RRCF   xC4,F
04C44:  RRCF   xC3,F
04C46:  RRCF   xC4,F
04C48:  RRCF   xC3,F
04C4A:  RRCF   xC4,F
04C4C:  RRCF   xC3,F
04C4E:  RRCF   xC4,F
04C50:  RRCF   xC3,F
04C52:  MOVLW  0F
04C54:  ANDWF  xC4,F
04C56:  MOVF   xC3,W
04C58:  ADDWF  xB9,W
04C5A:  MOVWF  00
04C5C:  MOVF   xC4,W
04C5E:  ADDWFC xBA,W
04C60:  MOVWF  01
04C62:  MOVLW  00
04C64:  ADDWFC xBB,W
04C66:  MOVWF  02
04C68:  MOVLW  00
04C6A:  ADDWFC xBC,W
04C6C:  MOVFF  9C2,FEA
04C70:  MOVFF  9C1,FE9
04C74:  MOVFF  00,FEF
04C78:  MOVFF  01,FEC
04C7C:  MOVFF  02,FEC
04C80:  MOVWF  FEC
04C82:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04C84:  MOVLW  44
04C86:  ADDWF  x12,W
04C88:  MOVWF  01
04C8A:  MOVLW  00
04C8C:  ADDWFC x13,W
04C8E:  MOVFF  01,FE9
04C92:  MOVWF  FEA
04C94:  MOVFF  FEF,9BD
04C98:  MOVFF  FEC,9BE
04C9C:  MOVFF  FEC,9BF
04CA0:  MOVFF  FEC,9C0
....................    if (!maxsect)  
04CA4:  MOVLB  9
04CA6:  MOVF   xBD,F
04CA8:  BNZ   4CD8
04CAA:  MOVF   xBE,F
04CAC:  BNZ   4CD8
04CAE:  MOVF   xBF,F
04CB0:  BNZ   4CD8
04CB2:  MOVF   xC0,F
04CB4:  BNZ   4CD8
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04CB6:  MOVLW  37
04CB8:  MOVLB  7
04CBA:  ADDWF  x12,W
04CBC:  MOVWF  01
04CBE:  MOVLW  00
04CC0:  ADDWFC x13,W
04CC2:  MOVFF  01,FE9
04CC6:  MOVWF  FEA
04CC8:  MOVLB  9
04CCA:  CLRF   xC0
04CCC:  CLRF   xBF
04CCE:  MOVFF  FEC,9BE
04CD2:  MOVF   FED,F
04CD4:  MOVFF  FEF,9BD
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04CD8:  MOVLW  0C
04CDA:  MOVLB  7
04CDC:  ADDWF  x12,W
04CDE:  MOVWF  01
04CE0:  MOVLW  00
04CE2:  ADDWFC x13,W
04CE4:  MOVWF  03
04CE6:  MOVFF  01,9C1
04CEA:  MOVLB  9
04CEC:  MOVWF  xC2
04CEE:  MOVLW  18
04CF0:  MOVLB  7
04CF2:  ADDWF  x12,W
04CF4:  MOVWF  FE9
04CF6:  MOVLW  00
04CF8:  ADDWFC x13,W
04CFA:  MOVWF  FEA
04CFC:  MOVFF  FEF,00
04D00:  MOVFF  FEC,01
04D04:  MOVFF  FEC,02
04D08:  MOVFF  FEC,03
04D0C:  MOVF   00,W
04D0E:  MOVLB  9
04D10:  SUBWF  xBD,W
04D12:  MOVWF  xC3
04D14:  MOVF   01,W
04D16:  SUBWFB xBE,W
04D18:  MOVWF  xC4
04D1A:  MOVF   02,W
04D1C:  SUBWFB xBF,W
04D1E:  MOVWF  xC5
04D20:  MOVF   03,W
04D22:  SUBWFB xC0,W
04D24:  MOVWF  xC6
04D26:  MOVF   xB5,W
04D28:  ADDWF  xC3,F
04D2A:  MOVF   xB6,W
04D2C:  ADDWFC xC4,F
04D2E:  MOVF   xB7,W
04D30:  ADDWFC xC5,F
04D32:  MOVF   xB8,W
04D34:  ADDWFC xC6,F
04D36:  MOVLW  02
04D38:  MOVLB  7
04D3A:  ADDWF  x12,W
04D3C:  MOVWF  FE9
04D3E:  MOVLW  00
04D40:  ADDWFC x13,W
04D42:  MOVWF  FEA
04D44:  MOVFF  FEF,A29
04D48:  MOVLB  9
04D4A:  MOVFF  FEA,9C9
04D4E:  MOVFF  FE9,9C8
04D52:  BCF    FD8.1
04D54:  CLRF   1B
04D56:  BTFSC  FF2.7
04D58:  BSF    1B.7
04D5A:  BCF    FF2.7
04D5C:  MOVFF  9C6,A28
04D60:  MOVFF  9C5,A27
04D64:  MOVFF  9C4,A26
04D68:  MOVFF  9C3,A25
04D6C:  MOVLB  A
04D6E:  CLRF   x2C
04D70:  CLRF   x2B
04D72:  CLRF   x2A
04D74:  MOVLB  0
04D76:  CALL   1080
04D7A:  BTFSC  1B.7
04D7C:  BSF    FF2.7
04D7E:  MOVFF  9C9,FEA
04D82:  MOVFF  9C8,FE9
04D86:  MOVFF  03,9C6
04D8A:  MOVFF  02,9C5
04D8E:  MOVFF  01,9C4
04D92:  MOVFF  00,9C3
04D96:  MOVLW  02
04D98:  MOVLB  9
04D9A:  ADDWF  00,W
04D9C:  MOVWF  00
04D9E:  MOVLW  00
04DA0:  ADDWFC 01,W
04DA2:  MOVWF  01
04DA4:  MOVLW  00
04DA6:  ADDWFC 02,W
04DA8:  MOVWF  02
04DAA:  MOVLW  00
04DAC:  ADDWFC 03,W
04DAE:  MOVFF  9C2,FEA
04DB2:  MOVFF  9C1,FE9
04DB6:  MOVFF  00,FEF
04DBA:  MOVFF  01,FEC
04DBE:  MOVFF  02,FEC
04DC2:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04DC4:  MOVLW  00
04DC6:  MOVWF  01
04DC8:  MOVLB  7
04DCA:  MOVLB  0
04DCC:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
070FE:  CALL   5582
07102:  MOVFF  01,9A1
....................    if (result != FR_OK)  
07106:  MOVLB  9
07108:  MOVF   xA1,F
0710A:  BZ    7112
....................       return (result); 
0710C:  MOVFF  9A1,01
07110:  BRA    7542
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
07112:  MOVF   x92,W
07114:  ANDLW  0A
07116:  BZ    712E
07118:  MOVLB  0
0711A:  CALL   5574
0711E:  BTFSC  01.2
07120:  BRA    7126
07122:  MOVLB  9
07124:  BRA    712E
....................          return (FR_WRITE_PROTECTED); 
07126:  MOVLW  0A
07128:  MOVWF  01
0712A:  MOVLB  9
0712C:  BRA    7542
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0712E:  MOVLW  09
07130:  MOVWF  xB5
07132:  MOVLW  93
07134:  MOVWF  xB4
07136:  MOVLW  09
07138:  MOVWF  xB7
0713A:  MOVLW  A4
0713C:  MOVWF  xB6
0713E:  MOVFF  991,9B9
07142:  MOVFF  990,9B8
07146:  MOVLW  09
07148:  MOVWF  xBB
0714A:  MOVLW  A2
0714C:  MOVWF  xBA
0714E:  MOVLB  0
07150:  CALL   61AA
07154:  MOVFF  01,9A1
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
07158:  MOVLB  9
0715A:  MOVF   x92,W
0715C:  ANDLW  18
0715E:  BTFSC  FD8.2
07160:  BRA    7384
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
07162:  MOVF   xA1,F
07164:  BZ    71EC
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
07166:  BSF    x92.3
....................          if (result != FR_NO_FILE) 
07168:  MOVF   xA1,W
0716A:  SUBLW  02
0716C:  BZ    7174
....................             return (result); 
0716E:  MOVFF  9A1,01
07172:  BRA    7542
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
07174:  MOVLW  09
07176:  MOVWF  xB5
07178:  MOVLW  93
0717A:  MOVWF  xB4
0717C:  MOVLB  0
0717E:  BRA    6BA8
07180:  MOVFF  02,9A3
07184:  MOVFF  01,9A2
....................          if (dir_ptr == NULL) 
07188:  MOVLB  9
0718A:  MOVF   xA2,F
0718C:  BNZ   7198
0718E:  MOVF   xA3,F
07190:  BNZ   7198
....................             return (FR_DENIED); 
07192:  MOVLW  05
07194:  MOVWF  01
07196:  BRA    7542
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
07198:  MOVFF  9A3,FEA
0719C:  MOVFF  9A2,FE9
071A0:  MOVLW  09
071A2:  MOVWF  FE2
071A4:  MOVLW  A4
071A6:  MOVWF  FE1
071A8:  MOVLW  0B
071AA:  MOVWF  01
071AC:  MOVFF  FE6,FEE
071B0:  DECFSZ 01,F
071B2:  BRA    71AC
....................          *(dir_ptr+12) = fn[11]; 
071B4:  MOVLW  0C
071B6:  ADDWF  xA2,W
071B8:  MOVWF  01
071BA:  MOVLW  00
071BC:  ADDWFC xA3,W
071BE:  MOVFF  01,FE9
071C2:  MOVWF  FEA
071C4:  MOVFF  9AF,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
071C8:  MOVLW  0D
071CA:  ADDWF  xA2,W
071CC:  MOVWF  xB4
071CE:  MOVLW  00
071D0:  ADDWFC xA3,W
071D2:  MOVWF  xB5
071D4:  MOVWF  FEA
071D6:  MOVFF  9B4,FE9
071DA:  CLRF   00
071DC:  CLRF   02
071DE:  MOVLW  13
071E0:  MOVWF  01
071E2:  MOVLB  0
071E4:  CALL   350A
....................       }  
071E8:  BRA    72FE
071EA:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
071EC:  MOVF   xA2,F
071EE:  BNZ   71F4
071F0:  MOVF   xA3,F
071F2:  BZ    720C
071F4:  MOVLW  0B
071F6:  ADDWF  xA2,W
071F8:  MOVWF  01
071FA:  MOVLW  00
071FC:  ADDWFC xA3,W
071FE:  MOVWF  03
07200:  MOVFF  01,FE9
07204:  MOVWF  FEA
07206:  MOVF   FEF,W
07208:  ANDLW  11
0720A:  BZ    7212
....................             return (FR_DENIED); 
0720C:  MOVLW  05
0720E:  MOVWF  01
07210:  BRA    7542
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
07212:  BTFSS  x92.3
07214:  BRA    72FC
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
07216:  MOVLW  20
07218:  MOVLB  7
0721A:  ADDWF  x12,W
0721C:  MOVWF  FE9
0721E:  MOVLW  00
07220:  ADDWFC x13,W
07222:  MOVWF  FEA
07224:  MOVFF  FEF,9B0
07228:  MOVFF  FEC,9B1
0722C:  MOVFF  FEC,9B2
07230:  MOVFF  FEC,9B3
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
07234:  MOVLW  14
07236:  MOVLB  9
07238:  ADDWF  xA2,W
0723A:  MOVWF  01
0723C:  MOVLW  00
0723E:  ADDWFC xA3,W
07240:  MOVWF  03
07242:  MOVFF  01,FE9
07246:  MOVWF  FEA
07248:  MOVFF  FEC,9BC
0724C:  MOVF   FED,F
0724E:  MOVFF  FEF,9B4
07252:  CLRF   xB6
07254:  MOVFF  9B4,9BB
07258:  CLRF   xB4
0725A:  CLRF   xB5
0725C:  MOVLW  1A
0725E:  ADDWF  xA2,W
07260:  MOVWF  01
07262:  MOVLW  00
07264:  ADDWFC xA3,W
07266:  MOVFF  01,FE9
0726A:  MOVWF  FEA
0726C:  MOVFF  FEC,03
07270:  MOVF   FED,F
07272:  MOVF   FEF,W
07274:  IORWF  xB4,F
07276:  MOVF   03,W
07278:  IORWF  xB5,F
0727A:  MOVFF  9B5,9BA
0727E:  MOVFF  9B4,9B9
07282:  MOVLB  0
07284:  RCALL  6EEE
07286:  MOVF   01,F
07288:  BZ    72A2
0728A:  MOVFF  9B3,9F1
0728E:  MOVFF  9B2,9F0
07292:  MOVFF  9B1,9EF
07296:  MOVFF  9B0,9EE
0729A:  CALL   5A5A
0729E:  MOVF   01,F
072A0:  BNZ   72AC
....................                return (FR_RW_ERROR); 
072A2:  MOVLW  07
072A4:  MOVWF  01
072A6:  MOVLB  9
072A8:  BRA    7542
072AA:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
072AC:  MOVLW  14
072AE:  MOVLB  9
072B0:  ADDWF  xA2,W
072B2:  MOVWF  01
072B4:  MOVLW  00
072B6:  ADDWFC xA3,W
072B8:  MOVFF  01,FE9
072BC:  MOVWF  FEA
072BE:  CLRF   FEC
072C0:  MOVF   FED,F
072C2:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
072C4:  MOVLW  1A
072C6:  ADDWF  xA2,W
072C8:  MOVWF  01
072CA:  MOVLW  00
072CC:  ADDWFC xA3,W
072CE:  MOVFF  01,FE9
072D2:  MOVWF  FEA
072D4:  CLRF   FEC
072D6:  MOVF   FED,F
072D8:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
072DA:  MOVLW  1C
072DC:  ADDWF  xA2,W
072DE:  MOVWF  01
072E0:  MOVLW  00
072E2:  ADDWFC xA3,W
072E4:  MOVFF  01,FE9
072E8:  MOVWF  FEA
072EA:  MOVF   FEE,F
072EC:  MOVF   FEE,F
072EE:  CLRF   FEC
072F0:  MOVF   FED,F
072F2:  CLRF   FEF
072F4:  MOVF   FED,F
072F6:  CLRF   FEF
072F8:  MOVF   FED,F
072FA:  CLRF   FEF
072FC:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
072FE:  MOVLB  9
07300:  BTFSS  x92.3
07302:  BRA    7382
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
07304:  MOVLW  0B
07306:  ADDWF  xA2,W
07308:  MOVWF  01
0730A:  MOVLW  00
0730C:  ADDWFC xA3,W
0730E:  MOVFF  01,FE9
07312:  MOVWF  FEA
07314:  MOVLW  20
07316:  MOVWF  FEF
....................          dw = get_fattime(); 
07318:  MOVLB  0
0731A:  RCALL  6F8E
0731C:  MOVFF  03,9B3
07320:  MOVFF  02,9B2
07324:  MOVFF  01,9B1
07328:  MOVFF  00,9B0
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
0732C:  MOVLW  0E
0732E:  MOVLB  9
07330:  ADDWF  xA2,W
07332:  MOVWF  01
07334:  MOVLW  00
07336:  ADDWFC xA3,W
07338:  MOVFF  01,FE9
0733C:  MOVWF  FEA
0733E:  MOVFF  9B0,FEF
07342:  MOVFF  9B1,FEC
07346:  MOVFF  9B2,FEC
0734A:  MOVFF  9B3,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
0734E:  MOVLW  16
07350:  ADDWF  xA2,W
07352:  MOVWF  01
07354:  MOVLW  00
07356:  ADDWFC xA3,W
07358:  MOVFF  01,FE9
0735C:  MOVWF  FEA
0735E:  MOVFF  9B0,FEF
07362:  MOVFF  9B1,FEC
07366:  MOVFF  9B2,FEC
0736A:  MOVFF  9B3,FEC
....................          fs->winflag = 1; 
0736E:  MOVLW  06
07370:  MOVLB  7
07372:  ADDWF  x12,W
07374:  MOVWF  FE9
07376:  MOVLW  00
07378:  ADDWFC x13,W
0737A:  MOVWF  FEA
0737C:  MOVLW  01
0737E:  MOVWF  FEF
07380:  MOVLB  9
....................       } 
....................    } 
07382:  BRA    73D2
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
07384:  MOVF   xA1,F
07386:  BZ    738E
....................          return (result);      // Trace failed  
07388:  MOVFF  9A1,01
0738C:  BRA    7542
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
0738E:  MOVF   xA2,F
07390:  BNZ   7396
07392:  MOVF   xA3,F
07394:  BZ    73AC
07396:  MOVLW  0B
07398:  ADDWF  xA2,W
0739A:  MOVWF  01
0739C:  MOVLW  00
0739E:  ADDWFC xA3,W
073A0:  MOVWF  03
073A2:  MOVFF  01,FE9
073A6:  MOVWF  FEA
073A8:  BTFSS  FEF.4
073AA:  BRA    73B2
....................          return (FR_NO_FILE); 
073AC:  MOVLW  02
073AE:  MOVWF  01
073B0:  BRA    7542
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
073B2:  BTFSS  x92.1
073B4:  BRA    73D2
073B6:  MOVLW  0B
073B8:  ADDWF  xA2,W
073BA:  MOVWF  01
073BC:  MOVLW  00
073BE:  ADDWFC xA3,W
073C0:  MOVWF  03
073C2:  MOVFF  01,FE9
073C6:  MOVWF  FEA
073C8:  BTFSS  FEF.0
073CA:  BRA    73D2
....................          return (FR_DENIED); 
073CC:  MOVLW  05
073CE:  MOVWF  01
073D0:  BRA    7542
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
073D2:  MOVLW  1A
073D4:  ADDWF  x8E,W
073D6:  MOVWF  FE9
073D8:  MOVLW  00
073DA:  ADDWFC x8F,W
073DC:  MOVWF  FEA
073DE:  MOVF   x92,W
073E0:  ANDLW  03
073E2:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
073E4:  MOVLW  14
073E6:  ADDWF  x8E,W
073E8:  MOVWF  01
073EA:  MOVLW  00
073EC:  ADDWFC x8F,W
073EE:  MOVWF  03
073F0:  MOVFF  01,9B4
073F4:  MOVWF  xB5
073F6:  MOVLW  20
073F8:  MOVLB  7
073FA:  ADDWF  x12,W
073FC:  MOVWF  FE9
073FE:  MOVLW  00
07400:  ADDWFC x13,W
07402:  MOVWF  FEA
07404:  MOVFF  FEF,00
07408:  MOVFF  FEC,01
0740C:  MOVFF  FEC,02
07410:  MOVFF  FEC,03
07414:  MOVFF  9B5,FEA
07418:  MOVFF  9B4,FE9
0741C:  MOVFF  00,FEF
07420:  MOVFF  01,FEC
07424:  MOVFF  02,FEC
07428:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
0742C:  MOVLW  18
0742E:  MOVLB  9
07430:  ADDWF  x8E,W
07432:  MOVWF  FE9
07434:  MOVLW  00
07436:  ADDWFC x8F,W
07438:  MOVWF  FEA
0743A:  MOVFF  9A3,FEC
0743E:  MOVF   FED,F
07440:  MOVFF  9A2,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
07444:  MOVLW  08
07446:  ADDWF  x8E,W
07448:  MOVWF  01
0744A:  MOVLW  00
0744C:  ADDWFC x8F,W
0744E:  MOVWF  03
07450:  MOVFF  01,9B4
07454:  MOVWF  xB5
07456:  MOVLW  14
07458:  ADDWF  xA2,W
0745A:  MOVWF  01
0745C:  MOVLW  00
0745E:  ADDWFC xA3,W
07460:  MOVWF  03
07462:  MOVFF  01,FE9
07466:  MOVWF  FEA
07468:  MOVFF  FEC,9B9
0746C:  MOVF   FED,F
0746E:  MOVFF  FEF,9B6
07472:  CLRF   xB8
07474:  MOVFF  9B6,9B8
07478:  CLRF   xB6
0747A:  CLRF   xB7
0747C:  MOVLW  1A
0747E:  ADDWF  xA2,W
07480:  MOVWF  01
07482:  MOVLW  00
07484:  ADDWFC xA3,W
07486:  MOVFF  01,FE9
0748A:  MOVWF  FEA
0748C:  MOVFF  FEC,03
07490:  MOVF   FED,F
07492:  MOVF   FEF,W
07494:  IORWF  xB6,W
07496:  MOVWF  00
07498:  MOVF   03,W
0749A:  IORWF  xB7,W
0749C:  MOVFF  9B8,02
074A0:  MOVFF  9B9,03
074A4:  MOVFF  9B5,FEA
074A8:  MOVFF  9B4,FE9
074AC:  MOVFF  00,FEF
074B0:  MOVWF  FEC
074B2:  MOVFF  9B8,FEC
074B6:  MOVFF  9B9,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
074BA:  MOVLW  04
074BC:  ADDWF  x8E,W
074BE:  MOVWF  01
074C0:  MOVLW  00
074C2:  ADDWFC x8F,W
074C4:  MOVWF  03
074C6:  MOVFF  01,9B4
074CA:  MOVWF  xB5
074CC:  MOVLW  1C
074CE:  ADDWF  xA2,W
074D0:  MOVWF  01
074D2:  MOVLW  00
074D4:  ADDWFC xA3,W
074D6:  MOVFF  01,FE9
074DA:  MOVWF  FEA
074DC:  MOVFF  FEF,00
074E0:  MOVFF  FEC,01
074E4:  MOVFF  FEC,02
074E8:  MOVFF  FEC,03
074EC:  MOVFF  9B5,FEA
074F0:  MOVFF  9B4,FE9
074F4:  MOVFF  00,FEF
074F8:  MOVFF  01,FEC
074FC:  MOVFF  02,FEC
07500:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
07504:  MOVFF  98E,FE9
07508:  MOVFF  98F,FEA
0750C:  MOVF   FEE,F
0750E:  MOVF   FEE,F
07510:  CLRF   FEC
07512:  MOVF   FED,F
07514:  CLRF   FEF
07516:  MOVF   FED,F
07518:  CLRF   FEF
0751A:  MOVF   FED,F
0751C:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
0751E:  MOVLW  1B
07520:  ADDWF  x8E,W
07522:  MOVWF  FE9
07524:  MOVLW  00
07526:  ADDWFC x8F,W
07528:  MOVWF  FEA
0752A:  MOVLW  01
0752C:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
0752E:  MOVLB  7
07530:  ADDWF  x12,W
07532:  MOVWF  FE9
07534:  MOVLW  00
07536:  ADDWFC x13,W
07538:  MOVWF  FEA
0753A:  INCF   FEF,F
....................    return (FR_OK); 
0753C:  MOVLW  00
0753E:  MOVWF  01
07540:  MOVLB  9
07542:  MOVLB  0
07544:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B0E2:  MOVFF  8AE,8C3
0B0E6:  MOVFF  8AD,8C2
....................       *br = 0; 
0B0EA:  MOVLB  8
0B0EC:  MOVFF  8B1,FE9
0B0F0:  MOVFF  8B2,FEA
0B0F4:  CLRF   FEC
0B0F6:  MOVF   FED,F
0B0F8:  CLRF   FEF
....................       if (!fs)  
0B0FA:  MOVLB  7
0B0FC:  MOVF   x12,W
0B0FE:  IORWF  x13,W
0B100:  BNZ   B108
....................          return (FR_NOT_ENABLED); 
0B102:  MOVLW  0B
0B104:  MOVWF  01
0B106:  BRA    B5EA
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B108:  MOVLB  0
0B10A:  CALL   5574
0B10E:  BTFSC  01.0
0B110:  BRA    B122
0B112:  MOVLB  7
0B114:  MOVFF  712,FE9
0B118:  MOVFF  713,FEA
0B11C:  MOVF   FEF,F
0B11E:  BNZ   B12A
0B120:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B122:  MOVLW  01
0B124:  MOVWF  01
0B126:  MOVLB  7
0B128:  BRA    B5EA
....................     
....................       if (fp->flag & FA__ERROR) 
0B12A:  MOVLW  1A
0B12C:  MOVLB  8
0B12E:  ADDWF  xAB,W
0B130:  MOVWF  FE9
0B132:  MOVLW  00
0B134:  ADDWFC xAC,W
0B136:  MOVWF  FEA
0B138:  BTFSS  FEF.7
0B13A:  BRA    B146
....................          return (FR_RW_ERROR);   // Check error flag  
0B13C:  MOVLW  07
0B13E:  MOVWF  01
0B140:  MOVLB  7
0B142:  BRA    B5EA
0B144:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B146:  MOVLW  1A
0B148:  ADDWF  xAB,W
0B14A:  MOVWF  FE9
0B14C:  MOVLW  00
0B14E:  ADDWFC xAC,W
0B150:  MOVWF  FEA
0B152:  BTFSC  FEF.0
0B154:  BRA    B160
....................          return (FR_DENIED);      // Check access mode  
0B156:  MOVLW  05
0B158:  MOVWF  01
0B15A:  MOVLB  7
0B15C:  BRA    B5EA
0B15E:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B160:  MOVLW  04
0B162:  ADDWF  xAB,W
0B164:  MOVWF  FE9
0B166:  MOVLW  00
0B168:  ADDWFC xAC,W
0B16A:  MOVWF  FEA
0B16C:  MOVFF  FEF,8C4
0B170:  MOVFF  FEC,8C5
0B174:  MOVFF  FEC,8C6
0B178:  MOVFF  FEC,8C7
0B17C:  MOVFF  8AB,FE9
0B180:  MOVFF  8AC,FEA
0B184:  MOVFF  FEF,00
0B188:  MOVFF  FEC,01
0B18C:  MOVFF  FEC,02
0B190:  MOVFF  FEC,03
0B194:  MOVF   00,W
0B196:  SUBWF  xC4,W
0B198:  MOVWF  xBB
0B19A:  MOVF   01,W
0B19C:  SUBWFB xC5,W
0B19E:  MOVWF  xBC
0B1A0:  MOVF   02,W
0B1A2:  SUBWFB xC6,W
0B1A4:  MOVWF  xBD
0B1A6:  MOVF   03,W
0B1A8:  SUBWFB xC7,W
0B1AA:  MOVWF  xBE
....................       if (btr > ln) 
0B1AC:  MOVF   xBE,F
0B1AE:  BNZ   B1CA
0B1B0:  MOVF   xBD,F
0B1B2:  BNZ   B1CA
0B1B4:  MOVF   xBC,W
0B1B6:  SUBWF  xB0,W
0B1B8:  BNC   B1CA
0B1BA:  BNZ   B1C2
0B1BC:  MOVF   xAF,W
0B1BE:  SUBWF  xBB,W
0B1C0:  BC    B1CA
....................          btr = ln;            // Truncate read count by number of bytes left  
0B1C2:  MOVFF  8BC,8B0
0B1C6:  MOVFF  8BB,8AF
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B1CA:  MOVF   xAF,W
0B1CC:  IORWF  xB0,W
0B1CE:  BTFSC  FD8.2
0B1D0:  BRA    B5C8
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B1D2:  MOVFF  8AB,FE9
0B1D6:  MOVFF  8AC,FEA
0B1DA:  MOVFF  FEF,8C4
0B1DE:  MOVFF  FEC,8C5
0B1E2:  MOVFF  FEC,8C6
0B1E6:  MOVFF  FEC,8C7
0B1EA:  MOVLW  01
0B1EC:  ANDWF  xC5,F
0B1EE:  CLRF   xC6
0B1F0:  CLRF   xC7
0B1F2:  MOVF   xC4,F
0B1F4:  BTFSS  FD8.2
0B1F6:  BRA    B470
0B1F8:  MOVF   xC5,F
0B1FA:  BTFSS  FD8.2
0B1FC:  BRA    B470
0B1FE:  MOVF   xC6,F
0B200:  BTFSS  FD8.2
0B202:  BRA    B470
0B204:  MOVF   xC7,F
0B206:  BTFSS  FD8.2
0B208:  BRA    B470
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B20A:  MOVLW  1B
0B20C:  ADDWF  xAB,W
0B20E:  MOVWF  FE9
0B210:  MOVLW  00
0B212:  ADDWFC xAC,W
0B214:  MOVWF  FEA
0B216:  DECF   FEF,F
0B218:  BZ    B250
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B21A:  MOVLW  10
0B21C:  ADDWF  xAB,W
0B21E:  MOVWF  FE9
0B220:  MOVLW  00
0B222:  ADDWFC xAC,W
0B224:  MOVWF  FEA
0B226:  MOVFF  FEF,8C4
0B22A:  MOVFF  FEC,8C5
0B22E:  MOVFF  FEC,8C6
0B232:  MOVFF  FEC,8C7
0B236:  MOVLW  01
0B238:  ADDWF  xC4,W
0B23A:  MOVWF  xB7
0B23C:  MOVLW  00
0B23E:  ADDWFC xC5,W
0B240:  MOVWF  xB8
0B242:  MOVLW  00
0B244:  ADDWFC xC6,W
0B246:  MOVWF  xB9
0B248:  MOVLW  00
0B24A:  ADDWFC xC7,W
0B24C:  MOVWF  xBA
....................                }  
0B24E:  BRA    B38C
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B250:  MOVFF  8AB,FE9
0B254:  MOVFF  8AC,FEA
0B258:  MOVFF  FEF,8C4
0B25C:  MOVFF  FEC,8C5
0B260:  MOVFF  FEC,8C6
0B264:  MOVFF  FEC,8C7
0B268:  MOVF   xC4,F
0B26A:  BNZ   B296
0B26C:  MOVF   xC5,F
0B26E:  BNZ   B296
0B270:  MOVF   xC6,F
0B272:  BNZ   B296
0B274:  MOVF   xC7,F
0B276:  BNZ   B296
0B278:  MOVLW  08
0B27A:  ADDWF  xAB,W
0B27C:  MOVWF  FE9
0B27E:  MOVLW  00
0B280:  ADDWFC xAC,W
0B282:  MOVWF  FEA
0B284:  MOVFF  FEF,00
0B288:  MOVFF  FEC,01
0B28C:  MOVFF  FEC,02
0B290:  MOVFF  FEC,03
0B294:  BRA    B2BA
0B296:  MOVLW  0C
0B298:  ADDWF  xAB,W
0B29A:  MOVWF  FE9
0B29C:  MOVLW  00
0B29E:  ADDWFC xAC,W
0B2A0:  MOVWF  FEA
0B2A2:  MOVFF  FEF,9DA
0B2A6:  MOVFF  FEC,9DB
0B2AA:  MOVFF  FEC,9DC
0B2AE:  MOVFF  FEC,9DD
0B2B2:  MOVLB  0
0B2B4:  CALL   5C98
0B2B8:  MOVLB  8
0B2BA:  MOVFF  03,8B6
0B2BE:  MOVFF  02,8B5
0B2C2:  MOVFF  01,8B4
0B2C6:  MOVFF  00,8B3
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B2CA:  MOVF   xB6,F
0B2CC:  BNZ   B2DC
0B2CE:  MOVF   xB5,F
0B2D0:  BNZ   B2DC
0B2D2:  MOVF   xB4,F
0B2D4:  BNZ   B2DC
0B2D6:  MOVF   xB3,W
0B2D8:  SUBLW  01
0B2DA:  BC    B31A
0B2DC:  MOVLW  0C
0B2DE:  MOVLB  7
0B2E0:  ADDWF  x12,W
0B2E2:  MOVWF  FE9
0B2E4:  MOVLW  00
0B2E6:  ADDWFC x13,W
0B2E8:  MOVWF  FEA
0B2EA:  MOVFF  FEF,00
0B2EE:  MOVFF  FEC,01
0B2F2:  MOVFF  FEC,02
0B2F6:  MOVFF  FEC,03
0B2FA:  MOVF   03,W
0B2FC:  MOVLB  8
0B2FE:  SUBWF  xB6,W
0B300:  BNC   B31C
0B302:  BNZ   B31A
0B304:  MOVF   02,W
0B306:  SUBWF  xB5,W
0B308:  BNC   B31C
0B30A:  BNZ   B31A
0B30C:  MOVF   01,W
0B30E:  SUBWF  xB4,W
0B310:  BNC   B31C
0B312:  BNZ   B31A
0B314:  MOVF   00,W
0B316:  SUBWF  xB3,W
0B318:  BNC   B31C
....................                   goto fr_error; 
0B31A:  BRA    B5D2
....................                fp->curr_clust = clust;            // Current cluster  
0B31C:  MOVLW  0C
0B31E:  ADDWF  xAB,W
0B320:  MOVWF  FE9
0B322:  MOVLW  00
0B324:  ADDWFC xAC,W
0B326:  MOVWF  FEA
0B328:  MOVFF  8B3,FEF
0B32C:  MOVFF  8B4,FEC
0B330:  MOVFF  8B5,FEC
0B334:  MOVFF  8B6,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B338:  MOVFF  8B6,9D0
0B33C:  MOVFF  8B5,9CF
0B340:  MOVFF  8B4,9CE
0B344:  MOVFF  8B3,9CD
0B348:  MOVLB  0
0B34A:  CALL   55E4
0B34E:  MOVFF  03,8BA
0B352:  MOVFF  02,8B9
0B356:  MOVFF  01,8B8
0B35A:  MOVFF  00,8B7
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B35E:  MOVLW  1B
0B360:  MOVLB  8
0B362:  ADDWF  xAB,W
0B364:  MOVWF  01
0B366:  MOVLW  00
0B368:  ADDWFC xAC,W
0B36A:  MOVWF  03
0B36C:  MOVLW  02
0B36E:  MOVLB  7
0B370:  ADDWF  x12,W
0B372:  MOVWF  FE9
0B374:  MOVLW  00
0B376:  ADDWFC x13,W
0B378:  MOVWF  FEA
0B37A:  MOVFF  FEF,8C6
0B37E:  MOVLB  8
0B380:  MOVFF  03,FEA
0B384:  MOVFF  01,FE9
0B388:  MOVFF  8C6,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B38C:  MOVLW  10
0B38E:  ADDWF  xAB,W
0B390:  MOVWF  FE9
0B392:  MOVLW  00
0B394:  ADDWFC xAC,W
0B396:  MOVWF  FEA
0B398:  MOVFF  8B7,FEF
0B39C:  MOVFF  8B8,FEC
0B3A0:  MOVFF  8B9,FEC
0B3A4:  MOVFF  8BA,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B3A8:  BCF    FD8.0
0B3AA:  RRCF   xB0,W
0B3AC:  MOVWF  xC1
....................             if (cc)  
0B3AE:  MOVF   xC1,F
0B3B0:  BZ    B470
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B3B2:  MOVLW  1B
0B3B4:  ADDWF  xAB,W
0B3B6:  MOVWF  FE9
0B3B8:  MOVLW  00
0B3BA:  ADDWFC xAC,W
0B3BC:  MOVWF  FEA
0B3BE:  MOVF   FEF,W
0B3C0:  SUBWF  xC1,W
0B3C2:  BZ    B3D6
0B3C4:  BNC   B3D6
....................                   cc = fp->sect_clust; 
0B3C6:  MOVLW  1B
0B3C8:  ADDWF  xAB,W
0B3CA:  MOVWF  FE9
0B3CC:  MOVLW  00
0B3CE:  ADDWFC xAC,W
0B3D0:  MOVWF  FEA
0B3D2:  MOVFF  FEF,8C1
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B3D6:  MOVFF  8C3,9FB
0B3DA:  MOVFF  8C2,9FA
0B3DE:  MOVFF  8BA,9FF
0B3E2:  MOVFF  8B9,9FE
0B3E6:  MOVFF  8B8,9FD
0B3EA:  MOVFF  8B7,9FC
0B3EE:  MOVFF  8C1,A00
0B3F2:  MOVLB  0
0B3F4:  CALL   44B0
0B3F8:  MOVF   01,F
0B3FA:  BZ    B402
....................                   goto fr_error; 
0B3FC:  MOVLB  8
0B3FE:  BRA    B5D2
0B400:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B402:  MOVLW  1B
0B404:  MOVLB  8
0B406:  ADDWF  xAB,W
0B408:  MOVWF  FE9
0B40A:  MOVLW  00
0B40C:  ADDWFC xAC,W
0B40E:  MOVWF  FEA
0B410:  MOVLW  01
0B412:  SUBWF  xC1,W
0B414:  SUBWF  FEF,W
0B416:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B418:  MOVLW  10
0B41A:  ADDWF  xAB,W
0B41C:  MOVWF  FE9
0B41E:  MOVLW  00
0B420:  ADDWFC xAC,W
0B422:  MOVWF  FEA
0B424:  MOVLW  01
0B426:  SUBWF  xC1,W
0B428:  ADDWF  FEF,W
0B42A:  MOVWF  00
0B42C:  MOVLW  00
0B42E:  ADDWFC FEC,W
0B430:  MOVWF  01
0B432:  MOVLW  00
0B434:  ADDWFC FEC,W
0B436:  MOVWF  02
0B438:  MOVLW  00
0B43A:  ADDWFC FEC,W
0B43C:  MOVF   FED,F
0B43E:  MOVF   FED,F
0B440:  MOVF   FED,F
0B442:  MOVFF  00,FEF
0B446:  MOVFF  01,FEC
0B44A:  MOVFF  02,FEC
0B44E:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B450:  MOVLB  9
0B452:  CLRF   xEB
0B454:  MOVFF  8C1,9EA
0B458:  MOVLW  02
0B45A:  MOVWF  xED
0B45C:  CLRF   xEC
0B45E:  MOVLB  0
0B460:  CALL   5C76
0B464:  MOVFF  02,8C0
0B468:  MOVFF  01,8BF
....................                continue; 
0B46C:  BRA    B564
0B46E:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B470:  MOVLW  10
0B472:  ADDWF  xAB,W
0B474:  MOVWF  FE9
0B476:  MOVLW  00
0B478:  ADDWFC xAC,W
0B47A:  MOVWF  FEA
0B47C:  MOVFF  FEF,9EE
0B480:  MOVFF  FEC,9EF
0B484:  MOVFF  FEC,9F0
0B488:  MOVFF  FEC,9F1
0B48C:  MOVLB  0
0B48E:  CALL   5A5A
0B492:  MOVF   01,F
0B494:  BNZ   B49C
....................                goto fr_error; 
0B496:  MOVLB  8
0B498:  BRA    B5D2
0B49A:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B49C:  MOVLB  8
0B49E:  MOVFF  8AB,FE9
0B4A2:  MOVFF  8AC,FEA
0B4A6:  MOVFF  FEF,8C4
0B4AA:  MOVFF  FEC,8C5
0B4AE:  MOVFF  FEC,8C6
0B4B2:  MOVFF  FEC,8C7
0B4B6:  MOVF   xC5,W
0B4B8:  ANDLW  01
0B4BA:  MOVWF  01
0B4BC:  MOVLW  00
0B4BE:  BSF    FD8.0
0B4C0:  SUBFWB xC4,W
0B4C2:  MOVWF  xBF
0B4C4:  MOVLW  02
0B4C6:  SUBFWB 01,W
0B4C8:  MOVWF  xC0
....................          if (rcnt > btr) 
0B4CA:  MOVF   xB0,W
0B4CC:  SUBWF  xC0,W
0B4CE:  BNC   B4E0
0B4D0:  BNZ   B4D8
0B4D2:  MOVF   xBF,W
0B4D4:  SUBWF  xAF,W
0B4D6:  BC    B4E0
....................             rcnt = btr; 
0B4D8:  MOVFF  8B0,8C0
0B4DC:  MOVFF  8AF,8BF
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B4E0:  MOVFF  8AB,FE9
0B4E4:  MOVFF  8AC,FEA
0B4E8:  MOVFF  FEF,8C4
0B4EC:  MOVFF  FEC,8C5
0B4F0:  MOVFF  FEC,8C6
0B4F4:  MOVFF  FEC,8C7
0B4F8:  MOVLW  01
0B4FA:  ANDWF  xC5,F
0B4FC:  CLRF   xC6
0B4FE:  CLRF   xC7
0B500:  MOVLW  24
0B502:  ADDWF  xC4,W
0B504:  MOVWF  00
0B506:  MOVLW  00
0B508:  ADDWFC xC5,W
0B50A:  MOVWF  01
0B50C:  MOVLW  00
0B50E:  ADDWFC xC6,W
0B510:  MOVWF  02
0B512:  MOVLW  00
0B514:  ADDWFC xC7,W
0B516:  MOVWF  03
0B518:  MOVFF  01,03
0B51C:  MOVF   00,W
0B51E:  MOVLB  7
0B520:  ADDWF  x12,W
0B522:  MOVWF  01
0B524:  MOVF   x13,W
0B526:  ADDWFC 03,F
0B528:  MOVFF  01,8C8
0B52C:  MOVLB  8
0B52E:  MOVFF  03,8C9
0B532:  MOVFF  8C3,FEA
0B536:  MOVFF  8C2,FE9
0B53A:  MOVFF  03,FE2
0B53E:  MOVFF  01,FE1
0B542:  MOVFF  8C0,02
0B546:  MOVFF  8BF,01
0B54A:  MOVF   01,F
0B54C:  BZ    B552
0B54E:  INCF   02,F
0B550:  BRA    B556
0B552:  MOVF   02,F
0B554:  BZ    B562
0B556:  MOVFF  FE6,FEE
0B55A:  DECFSZ 01,F
0B55C:  BRA    B556
0B55E:  DECFSZ 02,F
0B560:  BRA    B556
0B562:  MOVLB  0
0B564:  MOVLB  8
0B566:  MOVF   xBF,W
0B568:  ADDWF  xC2,F
0B56A:  MOVF   xC0,W
0B56C:  ADDWFC xC3,F
0B56E:  MOVFF  8AB,FE9
0B572:  MOVFF  8AC,FEA
0B576:  MOVF   xBF,W
0B578:  ADDWF  FEF,W
0B57A:  MOVWF  00
0B57C:  MOVF   xC0,W
0B57E:  ADDWFC FEC,W
0B580:  MOVWF  01
0B582:  MOVLW  00
0B584:  ADDWFC FEC,W
0B586:  MOVWF  02
0B588:  MOVLW  00
0B58A:  ADDWFC FEC,W
0B58C:  MOVWF  03
0B58E:  MOVF   FED,F
0B590:  MOVF   FED,F
0B592:  MOVF   FED,F
0B594:  MOVFF  00,FEF
0B598:  MOVFF  01,FEC
0B59C:  MOVFF  02,FEC
0B5A0:  MOVWF  FEC
0B5A2:  MOVFF  8B1,FE9
0B5A6:  MOVFF  8B2,FEA
0B5AA:  MOVF   xBF,W
0B5AC:  ADDWF  FEF,W
0B5AE:  MOVWF  01
0B5B0:  MOVF   xC0,W
0B5B2:  ADDWFC FEC,W
0B5B4:  MOVWF  03
0B5B6:  MOVF   FED,F
0B5B8:  MOVFF  01,FEF
0B5BC:  MOVWF  FEC
0B5BE:  MOVF   xBF,W
0B5C0:  SUBWF  xAF,F
0B5C2:  MOVF   xC0,W
0B5C4:  SUBWFB xB0,F
0B5C6:  BRA    B1CA
....................          } 
....................       return (FR_OK); 
0B5C8:  MOVLW  00
0B5CA:  MOVWF  01
0B5CC:  MOVLB  7
0B5CE:  BRA    B5EA
0B5D0:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B5D2:  MOVLW  1A
0B5D4:  ADDWF  xAB,W
0B5D6:  MOVWF  FE9
0B5D8:  MOVLW  00
0B5DA:  ADDWFC xAC,W
0B5DC:  MOVWF  FEA
0B5DE:  MOVF   FEF,W
0B5E0:  IORLW  80
0B5E2:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B5E4:  MOVLW  07
0B5E6:  MOVWF  01
0B5E8:  MOVLB  7
0B5EA:  MOVLB  0
0B5EC:  GOTO   B7E8 (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
079A0:  MOVFF  991,9A2
079A4:  MOVFF  990,9A1
....................       *bw = 0; 
079A8:  MOVLB  9
079AA:  MOVFF  994,FE9
079AE:  MOVFF  995,FEA
079B2:  CLRF   FEC
079B4:  MOVF   FED,F
079B6:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
079B8:  CLRF   x9F
079BA:  CLRF   x9E
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
079BC:  MOVLB  7
079BE:  MOVF   x12,W
079C0:  IORWF  x13,W
079C2:  BNZ   79CA
....................          return (FR_NOT_ENABLED); 
079C4:  MOVLW  0B
079C6:  MOVWF  01
079C8:  BRA    8066
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
079CA:  MOVLB  0
079CC:  CALL   5574
079D0:  BTFSC  01.0
079D2:  BRA    79E4
079D4:  MOVLB  7
079D6:  MOVFF  712,FE9
079DA:  MOVFF  713,FEA
079DE:  MOVF   FEF,F
079E0:  BNZ   79EC
079E2:  MOVLB  0
....................          return (FR_NOT_READY); 
079E4:  MOVLW  01
079E6:  MOVWF  01
079E8:  MOVLB  7
079EA:  BRA    8066
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
079EC:  MOVLW  1A
079EE:  MOVLB  9
079F0:  ADDWF  x8E,W
079F2:  MOVWF  FE9
079F4:  MOVLW  00
079F6:  ADDWFC x8F,W
079F8:  MOVWF  FEA
079FA:  BTFSS  FEF.7
079FC:  BRA    7A08
....................          return (FR_RW_ERROR);         // Check error flag  
079FE:  MOVLW  07
07A00:  MOVWF  01
07A02:  MOVLB  7
07A04:  BRA    8066
07A06:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
07A08:  MOVLW  1A
07A0A:  ADDWF  x8E,W
07A0C:  MOVWF  FE9
07A0E:  MOVLW  00
07A10:  ADDWFC x8F,W
07A12:  MOVWF  FEA
07A14:  BTFSC  FEF.1
07A16:  BRA    7A22
....................          return (FR_DENIED);            // Check access mode  
07A18:  MOVLW  05
07A1A:  MOVWF  01
07A1C:  MOVLB  7
07A1E:  BRA    8066
07A20:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
07A22:  MOVLW  04
07A24:  ADDWF  x8E,W
07A26:  MOVWF  FE9
07A28:  MOVLW  00
07A2A:  ADDWFC x8F,W
07A2C:  MOVWF  FEA
07A2E:  MOVFF  FEF,9A3
07A32:  MOVFF  FEC,9A4
07A36:  MOVFF  FEC,9A5
07A3A:  MOVFF  FEC,9A6
07A3E:  MOVF   x92,W
07A40:  ADDWF  xA3,F
07A42:  MOVF   x93,W
07A44:  ADDWFC xA4,F
07A46:  MOVLW  00
07A48:  ADDWFC xA5,F
07A4A:  ADDWFC xA6,F
07A4C:  MOVLW  04
07A4E:  ADDWF  x8E,W
07A50:  MOVWF  FE9
07A52:  MOVLW  00
07A54:  ADDWFC x8F,W
07A56:  MOVWF  FEA
07A58:  MOVFF  FEF,00
07A5C:  MOVFF  FEC,01
07A60:  MOVFF  FEC,02
07A64:  MOVFF  FEC,03
07A68:  MOVF   xA6,W
07A6A:  SUBWF  03,W
07A6C:  BNC   7A8A
07A6E:  BNZ   7A86
07A70:  MOVF   xA5,W
07A72:  SUBWF  02,W
07A74:  BNC   7A8A
07A76:  BNZ   7A86
07A78:  MOVF   xA4,W
07A7A:  SUBWF  01,W
07A7C:  BNC   7A8A
07A7E:  BNZ   7A86
07A80:  MOVF   00,W
07A82:  SUBWF  xA3,W
07A84:  BC    7A8A
....................          btw = 0;                  // File size cannot reach 4GB  
07A86:  CLRF   x93
07A88:  CLRF   x92
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07A8A:  MOVF   x92,W
07A8C:  IORWF  x93,W
07A8E:  BTFSC  FD8.2
07A90:  BRA    7F9A
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07A92:  MOVFF  98E,FE9
07A96:  MOVFF  98F,FEA
07A9A:  MOVFF  FEF,9A3
07A9E:  MOVFF  FEC,9A4
07AA2:  MOVFF  FEC,9A5
07AA6:  MOVFF  FEC,9A6
07AAA:  MOVLW  01
07AAC:  ANDWF  xA4,F
07AAE:  CLRF   xA5
07AB0:  CLRF   xA6
07AB2:  MOVF   xA3,F
07AB4:  BTFSS  FD8.2
07AB6:  BRA    7E34
07AB8:  MOVF   xA4,F
07ABA:  BTFSS  FD8.2
07ABC:  BRA    7E34
07ABE:  MOVF   xA5,F
07AC0:  BTFSS  FD8.2
07AC2:  BRA    7E34
07AC4:  MOVF   xA6,F
07AC6:  BTFSS  FD8.2
07AC8:  BRA    7E34
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07ACA:  MOVLW  1B
07ACC:  ADDWF  x8E,W
07ACE:  MOVWF  FE9
07AD0:  MOVLW  00
07AD2:  ADDWFC x8F,W
07AD4:  MOVWF  FEA
07AD6:  DECF   FEF,F
07AD8:  BZ    7B10
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07ADA:  MOVLW  10
07ADC:  ADDWF  x8E,W
07ADE:  MOVWF  FE9
07AE0:  MOVLW  00
07AE2:  ADDWFC x8F,W
07AE4:  MOVWF  FEA
07AE6:  MOVFF  FEF,9A3
07AEA:  MOVFF  FEC,9A4
07AEE:  MOVFF  FEC,9A5
07AF2:  MOVFF  FEC,9A6
07AF6:  MOVLW  01
07AF8:  ADDWF  xA3,W
07AFA:  MOVWF  x9A
07AFC:  MOVLW  00
07AFE:  ADDWFC xA4,W
07B00:  MOVWF  x9B
07B02:  MOVLW  00
07B04:  ADDWFC xA5,W
07B06:  MOVWF  x9C
07B08:  MOVLW  00
07B0A:  ADDWFC xA6,W
07B0C:  MOVWF  x9D
....................                }  
07B0E:  BRA    7CA6
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07B10:  MOVFF  98E,FE9
07B14:  MOVFF  98F,FEA
07B18:  MOVFF  FEF,9A3
07B1C:  MOVFF  FEC,9A4
07B20:  MOVFF  FEC,9A5
07B24:  MOVFF  FEC,9A6
07B28:  MOVF   xA3,F
07B2A:  BNZ   7BB0
07B2C:  MOVF   xA4,F
07B2E:  BNZ   7BB0
07B30:  MOVF   xA5,F
07B32:  BNZ   7BB0
07B34:  MOVF   xA6,F
07B36:  BNZ   7BB0
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07B38:  MOVLW  08
07B3A:  ADDWF  x8E,W
07B3C:  MOVWF  FE9
07B3E:  MOVLW  00
07B40:  ADDWFC x8F,W
07B42:  MOVWF  FEA
07B44:  MOVFF  FEF,996
07B48:  MOVFF  FEC,997
07B4C:  MOVFF  FEC,998
07B50:  MOVFF  FEC,999
....................                   if (clust == 0)            // No cluster is created  
07B54:  MOVF   x96,F
07B56:  BNZ   7BAE
07B58:  MOVF   x97,F
07B5A:  BNZ   7BAE
07B5C:  MOVF   x98,F
07B5E:  BNZ   7BAE
07B60:  MOVF   x99,F
07B62:  BNZ   7BAE
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07B64:  MOVLW  08
07B66:  ADDWF  x8E,W
07B68:  MOVWF  01
07B6A:  MOVLW  00
07B6C:  ADDWFC x8F,W
07B6E:  MOVWF  03
07B70:  MOVFF  01,9A3
07B74:  MOVWF  xA4
07B76:  CLRF   xC9
07B78:  CLRF   xC8
07B7A:  CLRF   xC7
07B7C:  CLRF   xC6
07B7E:  MOVLB  0
07B80:  CALL   6912
07B84:  MOVFF  03,999
07B88:  MOVFF  02,998
07B8C:  MOVFF  01,997
07B90:  MOVFF  00,996
07B94:  MOVFF  9A4,FEA
07B98:  MOVFF  9A3,FE9
07B9C:  MOVFF  996,FEF
07BA0:  MOVFF  997,FEC
07BA4:  MOVFF  998,FEC
07BA8:  MOVFF  999,FEC
07BAC:  MOVLB  9
....................                   } 
07BAE:  BRA    7BE4
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07BB0:  MOVLW  0C
07BB2:  ADDWF  x8E,W
07BB4:  MOVWF  FE9
07BB6:  MOVLW  00
07BB8:  ADDWFC x8F,W
07BBA:  MOVWF  FEA
07BBC:  MOVFF  FEF,9C6
07BC0:  MOVFF  FEC,9C7
07BC4:  MOVFF  FEC,9C8
07BC8:  MOVFF  FEC,9C9
07BCC:  MOVLB  0
07BCE:  CALL   6912
07BD2:  MOVFF  03,999
07BD6:  MOVFF  02,998
07BDA:  MOVFF  01,997
07BDE:  MOVFF  00,996
07BE2:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07BE4:  MOVF   x99,F
07BE6:  BNZ   7BF6
07BE8:  MOVF   x98,F
07BEA:  BNZ   7BF6
07BEC:  MOVF   x97,F
07BEE:  BNZ   7BF6
07BF0:  MOVF   x96,W
07BF2:  SUBLW  01
07BF4:  BC    7C34
07BF6:  MOVLW  0C
07BF8:  MOVLB  7
07BFA:  ADDWF  x12,W
07BFC:  MOVWF  FE9
07BFE:  MOVLW  00
07C00:  ADDWFC x13,W
07C02:  MOVWF  FEA
07C04:  MOVFF  FEF,00
07C08:  MOVFF  FEC,01
07C0C:  MOVFF  FEC,02
07C10:  MOVFF  FEC,03
07C14:  MOVF   03,W
07C16:  MOVLB  9
07C18:  SUBWF  x99,W
07C1A:  BNC   7C36
07C1C:  BNZ   7C34
07C1E:  MOVF   02,W
07C20:  SUBWF  x98,W
07C22:  BNC   7C36
07C24:  BNZ   7C34
07C26:  MOVF   01,W
07C28:  SUBWF  x97,W
07C2A:  BNC   7C36
07C2C:  BNZ   7C34
07C2E:  MOVF   00,W
07C30:  SUBWF  x96,W
07C32:  BNC   7C36
....................                   break; 
07C34:  BRA    7F9A
....................                fp->curr_clust = clust;            // Current cluster  
07C36:  MOVLW  0C
07C38:  ADDWF  x8E,W
07C3A:  MOVWF  FE9
07C3C:  MOVLW  00
07C3E:  ADDWFC x8F,W
07C40:  MOVWF  FEA
07C42:  MOVFF  996,FEF
07C46:  MOVFF  997,FEC
07C4A:  MOVFF  998,FEC
07C4E:  MOVFF  999,FEC
....................                sect = clust2sect(clust);         // Current sector  
07C52:  MOVFF  999,9D0
07C56:  MOVFF  998,9CF
07C5A:  MOVFF  997,9CE
07C5E:  MOVFF  996,9CD
07C62:  MOVLB  0
07C64:  CALL   55E4
07C68:  MOVFF  03,99D
07C6C:  MOVFF  02,99C
07C70:  MOVFF  01,99B
07C74:  MOVFF  00,99A
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07C78:  MOVLW  1B
07C7A:  MOVLB  9
07C7C:  ADDWF  x8E,W
07C7E:  MOVWF  01
07C80:  MOVLW  00
07C82:  ADDWFC x8F,W
07C84:  MOVWF  03
07C86:  MOVLW  02
07C88:  MOVLB  7
07C8A:  ADDWF  x12,W
07C8C:  MOVWF  FE9
07C8E:  MOVLW  00
07C90:  ADDWFC x13,W
07C92:  MOVWF  FEA
07C94:  MOVFF  FEF,9A5
07C98:  MOVLB  9
07C9A:  MOVFF  03,FEA
07C9E:  MOVFF  01,FE9
07CA2:  MOVFF  9A5,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07CA6:  MOVLW  10
07CA8:  ADDWF  x8E,W
07CAA:  MOVWF  FE9
07CAC:  MOVLW  00
07CAE:  ADDWFC x8F,W
07CB0:  MOVWF  FEA
07CB2:  MOVFF  99A,FEF
07CB6:  MOVFF  99B,FEC
07CBA:  MOVFF  99C,FEC
07CBE:  MOVFF  99D,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07CC2:  BCF    FD8.0
07CC4:  RRCF   x93,W
07CC6:  MOVWF  xA0
....................             if (cc)  
07CC8:  MOVF   xA0,F
07CCA:  BZ    7D84
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07CCC:  MOVLW  1B
07CCE:  ADDWF  x8E,W
07CD0:  MOVWF  FE9
07CD2:  MOVLW  00
07CD4:  ADDWFC x8F,W
07CD6:  MOVWF  FEA
07CD8:  MOVF   FEF,W
07CDA:  SUBWF  xA0,W
07CDC:  BZ    7CF0
07CDE:  BNC   7CF0
....................                   cc = fp->sect_clust; 
07CE0:  MOVLW  1B
07CE2:  ADDWF  x8E,W
07CE4:  MOVWF  FE9
07CE6:  MOVLW  00
07CE8:  ADDWFC x8F,W
07CEA:  MOVWF  FEA
07CEC:  MOVFF  FEF,9A0
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07CF0:  MOVFF  9A2,9FB
07CF4:  MOVFF  9A1,9FA
07CF8:  MOVFF  99D,9FF
07CFC:  MOVFF  99C,9FE
07D00:  MOVFF  99B,9FD
07D04:  MOVFF  99A,9FC
07D08:  MOVFF  9A0,A00
07D0C:  MOVLB  0
07D0E:  CALL   5914
07D12:  MOVF   01,F
07D14:  BZ    7D18
....................                   goto fw_error; 
07D16:  BRA    804C
....................                fp->sect_clust -= cc - 1; 
07D18:  MOVLW  1B
07D1A:  MOVLB  9
07D1C:  ADDWF  x8E,W
07D1E:  MOVWF  FE9
07D20:  MOVLW  00
07D22:  ADDWFC x8F,W
07D24:  MOVWF  FEA
07D26:  MOVLW  01
07D28:  SUBWF  xA0,W
07D2A:  SUBWF  FEF,W
07D2C:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07D2E:  MOVLW  10
07D30:  ADDWF  x8E,W
07D32:  MOVWF  FE9
07D34:  MOVLW  00
07D36:  ADDWFC x8F,W
07D38:  MOVWF  FEA
07D3A:  MOVLW  01
07D3C:  SUBWF  xA0,W
07D3E:  ADDWF  FEF,W
07D40:  MOVWF  00
07D42:  MOVLW  00
07D44:  ADDWFC FEC,W
07D46:  MOVWF  01
07D48:  MOVLW  00
07D4A:  ADDWFC FEC,W
07D4C:  MOVWF  02
07D4E:  MOVLW  00
07D50:  ADDWFC FEC,W
07D52:  MOVF   FED,F
07D54:  MOVF   FED,F
07D56:  MOVF   FED,F
07D58:  MOVFF  00,FEF
07D5C:  MOVFF  01,FEC
07D60:  MOVFF  02,FEC
07D64:  MOVWF  FEC
....................                wcnt = cc * 512; 
07D66:  CLRF   xEB
07D68:  MOVFF  9A0,9EA
07D6C:  MOVLW  02
07D6E:  MOVWF  xED
07D70:  CLRF   xEC
07D72:  MOVLB  0
07D74:  CALL   5C76
07D78:  MOVFF  02,99F
07D7C:  MOVFF  01,99E
....................                continue; 
07D80:  BRA    7F36
07D82:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07D84:  MOVFF  98E,FE9
07D88:  MOVFF  98F,FEA
07D8C:  MOVFF  FEF,9A3
07D90:  MOVFF  FEC,9A4
07D94:  MOVFF  FEC,9A5
07D98:  MOVFF  FEC,9A6
07D9C:  MOVLW  04
07D9E:  ADDWF  x8E,W
07DA0:  MOVWF  FE9
07DA2:  MOVLW  00
07DA4:  ADDWFC x8F,W
07DA6:  MOVWF  FEA
07DA8:  MOVFF  FEF,00
07DAC:  MOVFF  FEC,01
07DB0:  MOVFF  FEC,02
07DB4:  MOVFF  FEC,03
07DB8:  MOVF   03,W
07DBA:  SUBWF  xA6,W
07DBC:  BNC   7E34
07DBE:  BNZ   7DD6
07DC0:  MOVF   02,W
07DC2:  SUBWF  xA5,W
07DC4:  BNC   7E34
07DC6:  BNZ   7DD6
07DC8:  MOVF   01,W
07DCA:  SUBWF  xA4,W
07DCC:  BNC   7E34
07DCE:  BNZ   7DD6
07DD0:  MOVF   00,W
07DD2:  SUBWF  xA3,W
07DD4:  BNC   7E34
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07DD6:  CLRF   xF1
07DD8:  CLRF   xF0
07DDA:  CLRF   xEF
07DDC:  CLRF   xEE
07DDE:  MOVLB  0
07DE0:  CALL   5A5A
07DE4:  MOVF   01,F
07DE6:  BNZ   7DEA
....................                   goto fw_error; 
07DE8:  BRA    804C
....................                fs->winsect = fp->curr_sect; 
07DEA:  MOVLW  20
07DEC:  MOVLB  7
07DEE:  ADDWF  x12,W
07DF0:  MOVWF  01
07DF2:  MOVLW  00
07DF4:  ADDWFC x13,W
07DF6:  MOVWF  03
07DF8:  MOVFF  01,9A3
07DFC:  MOVLB  9
07DFE:  MOVWF  xA4
07E00:  MOVLW  10
07E02:  ADDWF  x8E,W
07E04:  MOVWF  FE9
07E06:  MOVLW  00
07E08:  ADDWFC x8F,W
07E0A:  MOVWF  FEA
07E0C:  MOVFF  FEF,00
07E10:  MOVFF  FEC,01
07E14:  MOVFF  FEC,02
07E18:  MOVFF  FEC,03
07E1C:  MOVFF  9A4,FEA
07E20:  MOVFF  9A3,FE9
07E24:  MOVFF  00,FEF
07E28:  MOVFF  01,FEC
07E2C:  MOVFF  02,FEC
07E30:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07E34:  MOVLW  10
07E36:  ADDWF  x8E,W
07E38:  MOVWF  FE9
07E3A:  MOVLW  00
07E3C:  ADDWFC x8F,W
07E3E:  MOVWF  FEA
07E40:  MOVFF  FEF,9EE
07E44:  MOVFF  FEC,9EF
07E48:  MOVFF  FEC,9F0
07E4C:  MOVFF  FEC,9F1
07E50:  MOVLB  0
07E52:  CALL   5A5A
07E56:  MOVF   01,F
07E58:  BNZ   7E5C
....................             goto fw_error;               // Move sector window 
07E5A:  BRA    804C
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07E5C:  MOVLB  9
07E5E:  MOVFF  98E,FE9
07E62:  MOVFF  98F,FEA
07E66:  MOVFF  FEF,9A3
07E6A:  MOVFF  FEC,9A4
07E6E:  MOVFF  FEC,9A5
07E72:  MOVFF  FEC,9A6
07E76:  MOVF   xA4,W
07E78:  ANDLW  01
07E7A:  MOVWF  01
07E7C:  MOVLW  00
07E7E:  BSF    FD8.0
07E80:  SUBFWB xA3,W
07E82:  MOVWF  x9E
07E84:  MOVLW  02
07E86:  SUBFWB 01,W
07E88:  MOVWF  x9F
....................          if (wcnt > btw) 
07E8A:  MOVF   x93,W
07E8C:  SUBWF  x9F,W
07E8E:  BNC   7EA0
07E90:  BNZ   7E98
07E92:  MOVF   x9E,W
07E94:  SUBWF  x92,W
07E96:  BC    7EA0
....................             wcnt = btw; 
07E98:  MOVFF  993,99F
07E9C:  MOVFF  992,99E
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07EA0:  MOVFF  98E,FE9
07EA4:  MOVFF  98F,FEA
07EA8:  MOVFF  FEF,9A3
07EAC:  MOVFF  FEC,9A4
07EB0:  MOVFF  FEC,9A5
07EB4:  MOVFF  FEC,9A6
07EB8:  MOVLW  01
07EBA:  ANDWF  xA4,F
07EBC:  CLRF   xA5
07EBE:  CLRF   xA6
07EC0:  MOVLW  24
07EC2:  ADDWF  xA3,W
07EC4:  MOVWF  00
07EC6:  MOVLW  00
07EC8:  ADDWFC xA4,W
07ECA:  MOVWF  01
07ECC:  MOVLW  00
07ECE:  ADDWFC xA5,W
07ED0:  MOVWF  02
07ED2:  MOVLW  00
07ED4:  ADDWFC xA6,W
07ED6:  MOVWF  03
07ED8:  MOVFF  01,03
07EDC:  MOVF   00,W
07EDE:  MOVLB  7
07EE0:  ADDWF  x12,W
07EE2:  MOVWF  01
07EE4:  MOVF   x13,W
07EE6:  ADDWFC 03,F
07EE8:  MOVFF  01,9A7
07EEC:  MOVLB  9
07EEE:  MOVFF  03,9A8
07EF2:  MOVFF  03,FEA
07EF6:  MOVFF  01,FE9
07EFA:  MOVFF  9A2,FE2
07EFE:  MOVFF  9A1,FE1
07F02:  MOVFF  99F,02
07F06:  MOVFF  99E,01
07F0A:  MOVF   01,F
07F0C:  BZ    7F12
07F0E:  INCF   02,F
07F10:  BRA    7F16
07F12:  MOVF   02,F
07F14:  BZ    7F22
07F16:  MOVFF  FE6,FEE
07F1A:  DECFSZ 01,F
07F1C:  BRA    7F16
07F1E:  DECFSZ 02,F
07F20:  BRA    7F16
....................          fs->winflag = 1; 
07F22:  MOVLW  06
07F24:  MOVLB  7
07F26:  ADDWF  x12,W
07F28:  MOVWF  FE9
07F2A:  MOVLW  00
07F2C:  ADDWFC x13,W
07F2E:  MOVWF  FEA
07F30:  MOVLW  01
07F32:  MOVWF  FEF
07F34:  MOVLB  0
07F36:  MOVLB  9
07F38:  MOVF   x9E,W
07F3A:  ADDWF  xA1,F
07F3C:  MOVF   x9F,W
07F3E:  ADDWFC xA2,F
07F40:  MOVFF  98E,FE9
07F44:  MOVFF  98F,FEA
07F48:  MOVF   x9E,W
07F4A:  ADDWF  FEF,W
07F4C:  MOVWF  00
07F4E:  MOVF   x9F,W
07F50:  ADDWFC FEC,W
07F52:  MOVWF  01
07F54:  MOVLW  00
07F56:  ADDWFC FEC,W
07F58:  MOVWF  02
07F5A:  MOVLW  00
07F5C:  ADDWFC FEC,W
07F5E:  MOVWF  03
07F60:  MOVF   FED,F
07F62:  MOVF   FED,F
07F64:  MOVF   FED,F
07F66:  MOVFF  00,FEF
07F6A:  MOVFF  01,FEC
07F6E:  MOVFF  02,FEC
07F72:  MOVWF  FEC
07F74:  MOVFF  994,FE9
07F78:  MOVFF  995,FEA
07F7C:  MOVF   x9E,W
07F7E:  ADDWF  FEF,W
07F80:  MOVWF  01
07F82:  MOVF   x9F,W
07F84:  ADDWFC FEC,W
07F86:  MOVWF  03
07F88:  MOVF   FED,F
07F8A:  MOVFF  01,FEF
07F8E:  MOVWF  FEC
07F90:  MOVF   x9E,W
07F92:  SUBWF  x92,F
07F94:  MOVF   x9F,W
07F96:  SUBWFB x93,F
07F98:  BRA    7A8A
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
07F9A:  MOVFF  98E,FE9
07F9E:  MOVFF  98F,FEA
07FA2:  MOVFF  FEF,9A3
07FA6:  MOVFF  FEC,9A4
07FAA:  MOVFF  FEC,9A5
07FAE:  MOVFF  FEC,9A6
07FB2:  MOVLW  04
07FB4:  ADDWF  x8E,W
07FB6:  MOVWF  FE9
07FB8:  MOVLW  00
07FBA:  ADDWFC x8F,W
07FBC:  MOVWF  FEA
07FBE:  MOVFF  FEF,00
07FC2:  MOVFF  FEC,01
07FC6:  MOVFF  FEC,02
07FCA:  MOVFF  FEC,03
07FCE:  MOVF   03,W
07FD0:  SUBWF  xA6,W
07FD2:  BNC   8030
07FD4:  BNZ   7FEC
07FD6:  MOVF   02,W
07FD8:  SUBWF  xA5,W
07FDA:  BNC   8030
07FDC:  BNZ   7FEC
07FDE:  MOVF   01,W
07FE0:  SUBWF  xA4,W
07FE2:  BNC   8030
07FE4:  BNZ   7FEC
07FE6:  MOVF   xA3,W
07FE8:  SUBWF  00,W
07FEA:  BC    8030
....................          fp->fsize = fp->fptr;      // Update file size if needed  
07FEC:  MOVLW  04
07FEE:  ADDWF  x8E,W
07FF0:  MOVWF  01
07FF2:  MOVLW  00
07FF4:  ADDWFC x8F,W
07FF6:  MOVWF  03
07FF8:  MOVFF  01,9A3
07FFC:  MOVFF  03,9A4
08000:  MOVFF  98E,FE9
08004:  MOVFF  98F,FEA
08008:  MOVFF  FEF,00
0800C:  MOVFF  FEC,01
08010:  MOVFF  FEC,02
08014:  MOVFF  FEC,03
08018:  MOVFF  9A4,FEA
0801C:  MOVFF  9A3,FE9
08020:  MOVFF  00,FEF
08024:  MOVFF  01,FEC
08028:  MOVFF  02,FEC
0802C:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
08030:  MOVLW  1A
08032:  ADDWF  x8E,W
08034:  MOVWF  FE9
08036:  MOVLW  00
08038:  ADDWFC x8F,W
0803A:  MOVWF  FEA
0803C:  MOVF   FEF,W
0803E:  IORLW  20
08040:  MOVWF  FEF
....................       return (FR_OK); 
08042:  MOVLW  00
08044:  MOVWF  01
08046:  MOVLB  7
08048:  BRA    8066
0804A:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0804C:  MOVLW  1A
0804E:  MOVLB  9
08050:  ADDWF  x8E,W
08052:  MOVWF  FE9
08054:  MOVLW  00
08056:  ADDWFC x8F,W
08058:  MOVWF  FEA
0805A:  MOVF   FEF,W
0805C:  IORLW  80
0805E:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
08060:  MOVLW  07
08062:  MOVWF  01
08064:  MOVLB  7
08066:  MOVLB  0
08068:  GOTO   840C (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
07546:  MOVLB  7
07548:  MOVF   x12,W
0754A:  IORWF  x13,W
0754C:  BNZ   7554
....................          return (FR_NOT_ENABLED); 
0754E:  MOVLW  0B
07550:  MOVWF  01
07552:  BRA    78A8
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
07554:  MOVLB  0
07556:  CALL   5574
0755A:  BTFSC  01.0
0755C:  BRA    756E
0755E:  MOVLB  7
07560:  MOVFF  712,FE9
07564:  MOVFF  713,FEA
07568:  MOVF   FEF,F
0756A:  BNZ   7576
0756C:  MOVLB  0
....................          return (FR_NOT_READY); 
0756E:  MOVLW  01
07570:  MOVWF  01
07572:  MOVLB  7
07574:  BRA    78A8
....................     
....................       if (fp->flag & FA__ERROR) 
07576:  MOVLW  1A
07578:  MOVLB  9
0757A:  ADDWF  x8E,W
0757C:  MOVWF  FE9
0757E:  MOVLW  00
07580:  ADDWFC x8F,W
07582:  MOVWF  FEA
07584:  BTFSS  FEF.7
07586:  BRA    7592
....................          return (FR_RW_ERROR); 
07588:  MOVLW  07
0758A:  MOVWF  01
0758C:  MOVLB  7
0758E:  BRA    78A8
07590:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
07592:  MOVLW  04
07594:  ADDWF  x8E,W
07596:  MOVWF  FE9
07598:  MOVLW  00
0759A:  ADDWFC x8F,W
0759C:  MOVWF  FEA
0759E:  MOVFF  FEF,00
075A2:  MOVFF  FEC,01
075A6:  MOVFF  FEC,02
075AA:  MOVFF  FEC,03
075AE:  MOVF   03,W
075B0:  SUBWF  x93,W
075B2:  BNC   75E8
075B4:  BNZ   75CC
075B6:  MOVF   02,W
075B8:  SUBWF  x92,W
075BA:  BNC   75E8
075BC:  BNZ   75CC
075BE:  MOVF   01,W
075C0:  SUBWF  x91,W
075C2:  BNC   75E8
075C4:  BNZ   75CC
075C6:  MOVF   x90,W
075C8:  SUBWF  00,W
075CA:  BC    75E8
....................          ofs = fp->fsize;               // Clip offset by file size  
075CC:  MOVLW  04
075CE:  ADDWF  x8E,W
075D0:  MOVWF  FE9
075D2:  MOVLW  00
075D4:  ADDWFC x8F,W
075D6:  MOVWF  FEA
075D8:  MOVFF  FEF,990
075DC:  MOVFF  FEC,991
075E0:  MOVFF  FEC,992
075E4:  MOVFF  FEC,993
....................       fp->fptr = ofs;  
075E8:  MOVFF  98E,FE9
075EC:  MOVF   x8F,W
075EE:  MOVWF  FEA
075F0:  MOVFF  990,FEF
075F4:  MOVFF  991,FEC
075F8:  MOVFF  992,FEC
075FC:  MOVFF  993,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
07600:  MOVLW  1B
07602:  ADDWF  x8E,W
07604:  MOVWF  FE9
07606:  MOVLW  00
07608:  ADDWFC x8F,W
0760A:  MOVWF  FEA
0760C:  MOVLW  01
0760E:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
07610:  MOVF   x90,F
07612:  BNZ   7622
07614:  MOVF   x91,F
07616:  BNZ   7622
07618:  MOVF   x92,F
0761A:  BNZ   7622
0761C:  MOVF   x93,F
0761E:  BTFSC  FD8.2
07620:  BRA    7886
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
07622:  MOVLW  01
07624:  SUBWF  x90,W
07626:  MOVLW  00
07628:  SUBWFB x91,W
0762A:  MOVWF  x9A
0762C:  MOVLW  00
0762E:  SUBWFB x92,W
07630:  MOVWF  x9B
07632:  MOVLW  00
07634:  SUBWFB x93,W
07636:  MOVWF  x9C
07638:  BCF    FD8.0
0763A:  CLRF   x93
0763C:  RRCF   x9C,W
0763E:  MOVWF  x92
07640:  RRCF   x9B,W
07642:  MOVWF  x91
07644:  RRCF   x9A,W
07646:  MOVWF  x90
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
07648:  MOVLW  02
0764A:  MOVLB  7
0764C:  ADDWF  x12,W
0764E:  MOVWF  FE9
07650:  MOVLW  00
07652:  ADDWFC x13,W
07654:  MOVWF  FEA
07656:  MOVFF  FEF,998
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
0765A:  MOVLW  1B
0765C:  MOVLB  9
0765E:  ADDWF  x8E,W
07660:  MOVWF  01
07662:  MOVLW  00
07664:  ADDWFC x8F,W
07666:  MOVWF  03
07668:  MOVFF  01,999
0766C:  MOVWF  x9A
0766E:  MOVFF  FEA,99C
07672:  MOVFF  FE9,99B
07676:  BSF    FD8.1
07678:  MOVLW  09
0767A:  MOVWF  FEA
0767C:  MOVLW  9D
0767E:  MOVWF  FE9
07680:  CLRF   1B
07682:  BTFSC  FF2.7
07684:  BSF    1B.7
07686:  BCF    FF2.7
07688:  MOVFF  993,A28
0768C:  MOVFF  992,A27
07690:  MOVFF  991,A26
07694:  MOVFF  990,A25
07698:  MOVLB  A
0769A:  CLRF   x2C
0769C:  CLRF   x2B
0769E:  CLRF   x2A
076A0:  MOVFF  998,A29
076A4:  MOVLB  0
076A6:  CALL   1080
076AA:  BTFSC  1B.7
076AC:  BSF    FF2.7
076AE:  MOVFF  99D,00
076B2:  MOVFF  99E,01
076B6:  MOVFF  99F,02
076BA:  MOVFF  9A0,03
076BE:  MOVFF  99C,FEA
076C2:  MOVFF  99B,FE9
076C6:  MOVF   00,W
076C8:  MOVLB  9
076CA:  SUBWF  x98,W
076CC:  MOVWF  00
076CE:  MOVLW  00
076D0:  SUBFWB 01,F
076D2:  SUBFWB 02,F
076D4:  SUBFWB 03,F
076D6:  MOVFF  99A,FEA
076DA:  MOVFF  999,FE9
076DE:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
076E2:  BCF    FD8.1
076E4:  CLRF   1B
076E6:  BTFSC  FF2.7
076E8:  BSF    1B.7
076EA:  BCF    FF2.7
076EC:  MOVFF  993,A28
076F0:  MOVFF  992,A27
076F4:  MOVFF  991,A26
076F8:  MOVFF  990,A25
076FC:  MOVLB  A
076FE:  CLRF   x2C
07700:  CLRF   x2B
07702:  CLRF   x2A
07704:  MOVFF  998,A29
07708:  MOVLB  0
0770A:  CALL   1080
0770E:  BTFSC  1B.7
07710:  BSF    FF2.7
07712:  MOVFF  03,993
07716:  MOVFF  02,992
0771A:  MOVFF  01,991
0771E:  MOVFF  00,990
....................          clust = fp->org_clust;            // Seek to current cluster  
07722:  MOVLW  08
07724:  MOVLB  9
07726:  ADDWF  x8E,W
07728:  MOVWF  FE9
0772A:  MOVLW  00
0772C:  ADDWFC x8F,W
0772E:  MOVWF  FEA
07730:  MOVFF  FEF,994
07734:  MOVFF  FEC,995
07738:  MOVFF  FEC,996
0773C:  MOVFF  FEC,997
....................     
....................          while (ofs--) 
07740:  MOVFF  993,03
07744:  MOVFF  992,02
07748:  MOVFF  991,01
0774C:  MOVFF  990,00
07750:  MOVLW  FF
07752:  ADDWF  x90,F
07754:  BTFSS  FD8.0
07756:  ADDWF  x91,F
07758:  BTFSS  FD8.0
0775A:  ADDWF  x92,F
0775C:  BTFSS  FD8.0
0775E:  ADDWF  x93,F
07760:  MOVF   00,F
07762:  BNZ   7770
07764:  MOVF   01,F
07766:  BNZ   7770
07768:  MOVF   02,F
0776A:  BNZ   7770
0776C:  MOVF   03,F
0776E:  BZ    779A
....................             clust = get_cluster(clust); 
07770:  MOVFF  997,9DD
07774:  MOVFF  996,9DC
07778:  MOVFF  995,9DB
0777C:  MOVFF  994,9DA
07780:  MOVLB  0
07782:  CALL   5C98
07786:  MOVFF  03,997
0778A:  MOVFF  02,996
0778E:  MOVFF  01,995
07792:  MOVFF  00,994
07796:  MOVLB  9
07798:  BRA    7740
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
0779A:  MOVF   x97,F
0779C:  BNZ   77AC
0779E:  MOVF   x96,F
077A0:  BNZ   77AC
077A2:  MOVF   x95,F
077A4:  BNZ   77AC
077A6:  MOVF   x94,W
077A8:  SUBLW  01
077AA:  BC    77EA
077AC:  MOVLW  0C
077AE:  MOVLB  7
077B0:  ADDWF  x12,W
077B2:  MOVWF  FE9
077B4:  MOVLW  00
077B6:  ADDWFC x13,W
077B8:  MOVWF  FEA
077BA:  MOVFF  FEF,00
077BE:  MOVFF  FEC,01
077C2:  MOVFF  FEC,02
077C6:  MOVFF  FEC,03
077CA:  MOVF   03,W
077CC:  MOVLB  9
077CE:  SUBWF  x97,W
077D0:  BNC   77EC
077D2:  BNZ   77EA
077D4:  MOVF   02,W
077D6:  SUBWF  x96,W
077D8:  BNC   77EC
077DA:  BNZ   77EA
077DC:  MOVF   01,W
077DE:  SUBWF  x95,W
077E0:  BNC   77EC
077E2:  BNZ   77EA
077E4:  MOVF   00,W
077E6:  SUBWF  x94,W
077E8:  BNC   77EC
....................             goto fk_error; 
077EA:  BRA    7890
....................     
....................          fp->curr_clust = clust; 
077EC:  MOVLW  0C
077EE:  ADDWF  x8E,W
077F0:  MOVWF  FE9
077F2:  MOVLW  00
077F4:  ADDWFC x8F,W
077F6:  MOVWF  FEA
077F8:  MOVFF  994,FEF
077FC:  MOVFF  995,FEC
07800:  MOVFF  996,FEC
07804:  MOVFF  997,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
07808:  MOVLW  10
0780A:  ADDWF  x8E,W
0780C:  MOVWF  01
0780E:  MOVLW  00
07810:  ADDWFC x8F,W
07812:  MOVWF  03
07814:  MOVFF  01,999
07818:  MOVWF  x9A
0781A:  MOVFF  997,9D0
0781E:  MOVFF  996,9CF
07822:  MOVFF  995,9CE
07826:  MOVFF  994,9CD
0782A:  MOVLB  0
0782C:  CALL   55E4
07830:  MOVFF  03,99E
07834:  MOVFF  02,99D
07838:  MOVFF  01,99C
0783C:  MOVFF  00,99B
07840:  MOVLB  9
07842:  MOVF   x98,W
07844:  ADDWF  x9B,F
07846:  MOVLW  00
07848:  ADDWFC x9C,F
0784A:  ADDWFC x9D,F
0784C:  ADDWFC x9E,F
0784E:  MOVLW  1B
07850:  ADDWF  x8E,W
07852:  MOVWF  FE9
07854:  MOVLW  00
07856:  ADDWFC x8F,W
07858:  MOVWF  FEA
0785A:  MOVF   FEF,W
0785C:  SUBWF  x9B,W
0785E:  MOVWF  00
07860:  MOVLW  00
07862:  SUBWFB x9C,W
07864:  MOVWF  01
07866:  MOVLW  00
07868:  SUBWFB x9D,W
0786A:  MOVWF  02
0786C:  MOVLW  00
0786E:  SUBWFB x9E,W
07870:  MOVFF  99A,FEA
07874:  MOVFF  999,FE9
07878:  MOVFF  00,FEF
0787C:  MOVFF  01,FEC
07880:  MOVFF  02,FEC
07884:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
07886:  MOVLW  00
07888:  MOVWF  01
0788A:  MOVLB  7
0788C:  BRA    78A8
0788E:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
07890:  MOVLW  1A
07892:  ADDWF  x8E,W
07894:  MOVWF  FE9
07896:  MOVLW  00
07898:  ADDWFC x8F,W
0789A:  MOVWF  FEA
0789C:  MOVF   FEF,W
0789E:  IORLW  80
078A0:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
078A2:  MOVLW  07
078A4:  MOVWF  01
078A6:  MOVLB  7
078A8:  MOVLB  0
078AA:  GOTO   8324 (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
0806C:  MOVLB  7
0806E:  MOVF   x12,W
08070:  IORWF  x13,W
08072:  BNZ   807A
....................       return (FR_NOT_ENABLED); 
08074:  MOVLW  0B
08076:  MOVWF  01
08078:  BRA    8246
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
0807A:  MOVLB  0
0807C:  CALL   5574
08080:  BTFSC  01.0
08082:  BRA    8094
08084:  MOVLB  7
08086:  MOVFF  712,FE9
0808A:  MOVFF  713,FEA
0808E:  MOVF   FEF,F
08090:  BNZ   809C
08092:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
08094:  MOVLW  09
08096:  MOVWF  01
08098:  MOVLB  7
0809A:  BRA    8246
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
0809C:  MOVLW  1A
0809E:  MOVLB  9
080A0:  ADDWF  x91,W
080A2:  MOVWF  FE9
080A4:  MOVLW  00
080A6:  ADDWFC x92,W
080A8:  MOVWF  FEA
080AA:  BTFSS  FEF.5
080AC:  BRA    8224
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
080AE:  MOVLW  14
080B0:  ADDWF  x91,W
080B2:  MOVWF  FE9
080B4:  MOVLW  00
080B6:  ADDWFC x92,W
080B8:  MOVWF  FEA
080BA:  MOVFF  FEF,9EE
080BE:  MOVFF  FEC,9EF
080C2:  MOVFF  FEC,9F0
080C6:  MOVFF  FEC,9F1
080CA:  MOVLB  0
080CC:  CALL   5A5A
080D0:  MOVF   01,F
080D2:  BNZ   80DE
....................          return (FR_RW_ERROR); 
080D4:  MOVLW  07
080D6:  MOVWF  01
080D8:  MOVLB  7
080DA:  BRA    8246
080DC:  MOVLB  0
....................       ptr = fp->dir_ptr; 
080DE:  MOVLW  18
080E0:  MOVLB  9
080E2:  ADDWF  x91,W
080E4:  MOVWF  FE9
080E6:  MOVLW  00
080E8:  ADDWFC x92,W
080EA:  MOVWF  FEA
080EC:  MOVFF  FEC,994
080F0:  MOVF   FED,F
080F2:  MOVFF  FEF,993
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
080F6:  MOVLW  0B
080F8:  ADDWF  x93,W
080FA:  MOVWF  01
080FC:  MOVLW  00
080FE:  ADDWFC x94,W
08100:  MOVFF  01,FE9
08104:  MOVWF  FEA
08106:  MOVF   FEF,W
08108:  IORLW  20
0810A:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
0810C:  MOVLW  1C
0810E:  ADDWF  x93,W
08110:  MOVWF  01
08112:  MOVLW  00
08114:  ADDWFC x94,W
08116:  MOVWF  03
08118:  MOVFF  01,995
0811C:  MOVWF  x96
0811E:  MOVLW  04
08120:  ADDWF  x91,W
08122:  MOVWF  FE9
08124:  MOVLW  00
08126:  ADDWFC x92,W
08128:  MOVWF  FEA
0812A:  MOVFF  FEF,00
0812E:  MOVFF  FEC,01
08132:  MOVFF  FEC,02
08136:  MOVFF  FEC,03
0813A:  MOVFF  996,FEA
0813E:  MOVFF  995,FE9
08142:  MOVFF  00,FEF
08146:  MOVFF  01,FEC
0814A:  MOVFF  02,FEC
0814E:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
08152:  MOVLW  1A
08154:  ADDWF  x93,W
08156:  MOVWF  01
08158:  MOVLW  00
0815A:  ADDWFC x94,W
0815C:  MOVWF  03
0815E:  MOVFF  01,995
08162:  MOVWF  x96
08164:  MOVLW  08
08166:  ADDWF  x91,W
08168:  MOVWF  FE9
0816A:  MOVLW  00
0816C:  ADDWFC x92,W
0816E:  MOVWF  FEA
08170:  MOVFF  FEF,00
08174:  MOVFF  FEC,01
08178:  MOVFF  FEC,02
0817C:  MOVFF  FEC,03
08180:  MOVFF  996,FEA
08184:  MOVFF  995,FE9
08188:  MOVFF  00,FEF
0818C:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
08190:  MOVLW  14
08192:  ADDWF  x93,W
08194:  MOVWF  01
08196:  MOVLW  00
08198:  ADDWFC x94,W
0819A:  MOVWF  03
0819C:  MOVFF  01,995
081A0:  MOVWF  x96
081A2:  MOVLW  08
081A4:  ADDWF  x91,W
081A6:  MOVWF  FE9
081A8:  MOVLW  00
081AA:  ADDWFC x92,W
081AC:  MOVWF  FEA
081AE:  MOVFF  FEF,997
081B2:  MOVFF  FEC,998
081B6:  MOVFF  FEC,00
081BA:  MOVFF  FEC,01
081BE:  MOVFF  996,FEA
081C2:  MOVFF  995,FE9
081C6:  MOVFF  00,FEF
081CA:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
081CE:  MOVLW  16
081D0:  ADDWF  x93,W
081D2:  MOVWF  01
081D4:  MOVLW  00
081D6:  ADDWFC x94,W
081D8:  MOVWF  03
081DA:  MOVFF  01,995
081DE:  MOVWF  x96
081E0:  MOVLB  0
081E2:  CALL   6F8E
081E6:  MOVFF  996,FEA
081EA:  MOVFF  995,FE9
081EE:  MOVFF  00,FEF
081F2:  MOVFF  01,FEC
081F6:  MOVFF  02,FEC
081FA:  MOVFF  03,FEC
....................       fs->winflag = 1; 
081FE:  MOVLW  06
08200:  MOVLB  7
08202:  ADDWF  x12,W
08204:  MOVWF  FE9
08206:  MOVLW  00
08208:  ADDWFC x13,W
0820A:  MOVWF  FEA
0820C:  MOVLW  01
0820E:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
08210:  MOVLW  1A
08212:  MOVLB  9
08214:  ADDWF  x91,W
08216:  MOVWF  FE9
08218:  MOVLW  00
0821A:  ADDWFC x92,W
0821C:  MOVWF  FEA
0821E:  MOVF   FEF,W
08220:  ANDLW  DF
08222:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
08224:  CLRF   xF1
08226:  CLRF   xF0
08228:  CLRF   xEF
0822A:  CLRF   xEE
0822C:  MOVLB  0
0822E:  CALL   5A5A
08232:  MOVF   01,F
08234:  BNZ   8240
....................       return (FR_RW_ERROR); 
08236:  MOVLW  07
08238:  MOVWF  01
0823A:  MOVLB  7
0823C:  BRA    8246
0823E:  MOVLB  0
....................  
....................    return (FR_OK); 
08240:  MOVLW  00
08242:  MOVWF  01
08244:  MOVLB  7
08246:  MOVLB  0
08248:  GOTO   8256 (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
0824C:  MOVFF  98F,992
08250:  MOVFF  98E,991
08254:  BRA    806C
08256:  MOVFF  01,990
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
0825A:  MOVLB  9
0825C:  MOVF   x90,F
0825E:  BNZ   8290
....................       { 
....................       fp->flag = 0; 
08260:  MOVLW  1A
08262:  ADDWF  x8E,W
08264:  MOVWF  FE9
08266:  MOVLW  00
08268:  ADDWFC x8F,W
0826A:  MOVWF  FEA
0826C:  CLRF   FEF
....................       if (fs->files) 
0826E:  MOVLW  01
08270:  MOVLB  7
08272:  ADDWF  x12,W
08274:  MOVWF  FE9
08276:  MOVLW  00
08278:  ADDWFC x13,W
0827A:  MOVWF  FEA
0827C:  MOVF   FEF,F
0827E:  BZ    828E
....................          fs->files--; 
08280:  MOVLW  01
08282:  ADDWF  x12,W
08284:  MOVWF  FE9
08286:  MOVLW  00
08288:  ADDWFC x13,W
0828A:  MOVWF  FEA
0828C:  DECF   FEF,F
0828E:  MOVLB  9
....................       } 
....................    return (res); 
08290:  MOVFF  990,01
08294:  MOVLB  0
08296:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0B91A:  CALL   5582
0B91E:  MOVFF  01,86A
....................    if (res != FR_OK)  
0B922:  MOVLB  8
0B924:  MOVF   x6A,F
0B926:  BZ    B92E
....................       return (res); 
0B928:  MOVFF  86A,01
0B92C:  BRA    BBBE
....................  
....................    if (disk_status() & STA_PROTECT) 
0B92E:  MOVLB  0
0B930:  CALL   5574
0B934:  BTFSS  01.2
0B936:  BRA    B942
....................       return (FR_WRITE_PROTECTED); 
0B938:  MOVLW  0A
0B93A:  MOVWF  01
0B93C:  MOVLB  8
0B93E:  BRA    BBBE
0B940:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0B942:  MOVLW  08
0B944:  MOVLB  9
0B946:  MOVWF  xB5
0B948:  MOVLW  77
0B94A:  MOVWF  xB4
0B94C:  MOVLW  08
0B94E:  MOVWF  xB7
0B950:  MOVLW  85
0B952:  MOVWF  xB6
0B954:  MOVFF  869,9B9
0B958:  MOVFF  868,9B8
0B95C:  MOVLW  08
0B95E:  MOVWF  xBB
0B960:  MOVLW  6B
0B962:  MOVWF  xBA
0B964:  MOVLB  0
0B966:  CALL   61AA
0B96A:  MOVFF  01,86A
....................  
....................    if (res != FR_OK)  
0B96E:  MOVLB  8
0B970:  MOVF   x6A,F
0B972:  BZ    B97A
....................       return (res);            // Trace failed  
0B974:  MOVFF  86A,01
0B978:  BRA    BBBE
....................  
....................    if (dir_ptr == NULL)  
0B97A:  MOVF   x6B,F
0B97C:  BNZ   B988
0B97E:  MOVF   x6C,F
0B980:  BNZ   B988
....................       return (FR_NO_FILE);      // It is a root directory  
0B982:  MOVLW  02
0B984:  MOVWF  01
0B986:  BRA    BBBE
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0B988:  MOVLW  0B
0B98A:  ADDWF  x6B,W
0B98C:  MOVWF  01
0B98E:  MOVLW  00
0B990:  ADDWFC x6C,W
0B992:  MOVWF  03
0B994:  MOVFF  01,FE9
0B998:  MOVWF  FEA
0B99A:  BTFSS  FEF.0
0B99C:  BRA    B9A4
....................       return (FR_DENIED);         // It is a R/O item  
0B99E:  MOVLW  05
0B9A0:  MOVWF  01
0B9A2:  BRA    BBBE
....................  
....................    dsect = fs->winsect; 
0B9A4:  MOVLW  20
0B9A6:  MOVLB  7
0B9A8:  ADDWF  x12,W
0B9AA:  MOVWF  FE9
0B9AC:  MOVLW  00
0B9AE:  ADDWFC x13,W
0B9B0:  MOVWF  FEA
0B9B2:  MOVFF  FEF,873
0B9B6:  MOVFF  FEC,874
0B9BA:  MOVFF  FEC,875
0B9BE:  MOVFF  FEC,876
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0B9C2:  MOVLW  14
0B9C4:  MOVLB  8
0B9C6:  ADDWF  x6B,W
0B9C8:  MOVWF  01
0B9CA:  MOVLW  00
0B9CC:  ADDWFC x6C,W
0B9CE:  MOVWF  03
0B9D0:  MOVFF  01,FE9
0B9D4:  MOVWF  FEA
0B9D6:  MOVFF  FEC,872
0B9DA:  MOVF   FED,F
0B9DC:  MOVFF  FEF,891
0B9E0:  MOVFF  891,871
0B9E4:  CLRF   x91
0B9E6:  CLRF   x92
0B9E8:  MOVLW  1A
0B9EA:  ADDWF  x6B,W
0B9EC:  MOVWF  01
0B9EE:  MOVLW  00
0B9F0:  ADDWFC x6C,W
0B9F2:  MOVFF  01,FE9
0B9F6:  MOVWF  FEA
0B9F8:  MOVFF  FEC,03
0B9FC:  MOVF   FED,F
0B9FE:  MOVF   FEF,W
0BA00:  IORWF  x91,W
0BA02:  MOVWF  x6F
0BA04:  MOVF   03,W
0BA06:  IORWF  x92,W
0BA08:  MOVWF  x70
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BA0A:  MOVLW  0B
0BA0C:  ADDWF  x6B,W
0BA0E:  MOVWF  01
0BA10:  MOVLW  00
0BA12:  ADDWFC x6C,W
0BA14:  MOVWF  03
0BA16:  MOVFF  01,FE9
0BA1A:  MOVWF  FEA
0BA1C:  BTFSS  FEF.4
0BA1E:  BRA    BB32
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BA20:  MOVFF  872,87E
0BA24:  MOVFF  871,87D
0BA28:  MOVFF  870,87C
0BA2C:  MOVFF  86F,87B
....................       dirscan.sect = clust2sect(dclust); 
0BA30:  MOVFF  872,9D0
0BA34:  MOVFF  871,9CF
0BA38:  MOVFF  870,9CE
0BA3C:  MOVFF  86F,9CD
0BA40:  MOVLB  0
0BA42:  CALL   55E4
0BA46:  MOVFF  03,882
0BA4A:  MOVFF  02,881
0BA4E:  MOVFF  01,880
0BA52:  MOVFF  00,87F
....................       dirscan.index = 0; 
0BA56:  MOVLB  8
0BA58:  CLRF   x84
0BA5A:  CLRF   x83
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BA5C:  MOVFF  882,9F1
0BA60:  MOVFF  881,9F0
0BA64:  MOVFF  880,9EF
0BA68:  MOVFF  87F,9EE
0BA6C:  MOVLB  0
0BA6E:  CALL   5A5A
0BA72:  MOVF   01,F
0BA74:  BNZ   BA80
....................             return (FR_RW_ERROR); 
0BA76:  MOVLW  07
0BA78:  MOVWF  01
0BA7A:  MOVLB  8
0BA7C:  BRA    BBBE
0BA7E:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BA80:  MOVLB  8
0BA82:  MOVF   x83,W
0BA84:  ANDLW  0F
0BA86:  MOVWF  x91
0BA88:  CLRF   x92
0BA8A:  RLCF   x91,F
0BA8C:  RLCF   x92,F
0BA8E:  RLCF   x91,F
0BA90:  RLCF   x92,F
0BA92:  RLCF   x91,F
0BA94:  RLCF   x92,F
0BA96:  RLCF   x91,F
0BA98:  RLCF   x92,F
0BA9A:  RLCF   x91,F
0BA9C:  RLCF   x92,F
0BA9E:  MOVLW  E0
0BAA0:  ANDWF  x91,F
0BAA2:  MOVLW  24
0BAA4:  ADDWF  x91,W
0BAA6:  MOVWF  01
0BAA8:  MOVLW  00
0BAAA:  ADDWFC x92,W
0BAAC:  MOVWF  03
0BAAE:  MOVF   01,W
0BAB0:  MOVLB  7
0BAB2:  ADDWF  x12,W
0BAB4:  MOVWF  01
0BAB6:  MOVF   x13,W
0BAB8:  ADDWFC 03,F
0BABA:  MOVFF  01,86D
0BABE:  MOVLB  8
0BAC0:  MOVFF  03,86E
....................          if (*sdir == 0) 
0BAC4:  MOVFF  86E,03
0BAC8:  MOVFF  86D,FE9
0BACC:  MOVFF  86E,FEA
0BAD0:  MOVF   FEF,F
0BAD2:  BNZ   BAD6
....................             break; 
0BAD4:  BRA    BB32
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BAD6:  MOVFF  86E,03
0BADA:  MOVFF  86D,FE9
0BADE:  MOVFF  86E,FEA
0BAE2:  MOVF   FEF,W
0BAE4:  SUBLW  E5
0BAE6:  BZ    BB16
0BAE8:  MOVFF  86E,03
0BAEC:  MOVFF  86D,FE9
0BAF0:  MOVFF  86E,FEA
0BAF4:  MOVF   FEF,W
0BAF6:  SUBLW  2E
0BAF8:  BZ    BB16
0BAFA:  MOVLW  0B
0BAFC:  ADDWF  x6D,W
0BAFE:  MOVWF  01
0BB00:  MOVLW  00
0BB02:  ADDWFC x6E,W
0BB04:  MOVWF  03
0BB06:  MOVFF  01,FE9
0BB0A:  MOVWF  FEA
0BB0C:  BTFSC  FEF.3
0BB0E:  BRA    BB16
....................             return (FR_DENIED);   // The directory is not empty  
0BB10:  MOVLW  05
0BB12:  MOVWF  01
0BB14:  BRA    BBBE
....................          } while (next_dir_ptr(&dirscan)); 
0BB16:  MOVLW  08
0BB18:  MOVLB  9
0BB1A:  MOVWF  xC4
0BB1C:  MOVLW  77
0BB1E:  MOVWF  xC3
0BB20:  MOVLB  0
0BB22:  CALL   5FD0
0BB26:  MOVF   01,F
0BB28:  BTFSC  FD8.2
0BB2A:  BRA    BB30
0BB2C:  MOVLB  8
0BB2E:  BRA    BA5C
0BB30:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BB32:  MOVFF  876,9F1
0BB36:  MOVFF  875,9F0
0BB3A:  MOVFF  874,9EF
0BB3E:  MOVFF  873,9EE
0BB42:  MOVLB  0
0BB44:  CALL   5A5A
0BB48:  MOVF   01,F
0BB4A:  BNZ   BB56
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BB4C:  MOVLW  07
0BB4E:  MOVWF  01
0BB50:  MOVLB  8
0BB52:  BRA    BBBE
0BB54:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BB56:  MOVLB  8
0BB58:  MOVFF  86B,FE9
0BB5C:  MOVFF  86C,FEA
0BB60:  MOVLW  E5
0BB62:  MOVWF  FEF
....................    fs->winflag = 1; 
0BB64:  MOVLW  06
0BB66:  MOVLB  7
0BB68:  ADDWF  x12,W
0BB6A:  MOVWF  FE9
0BB6C:  MOVLW  00
0BB6E:  ADDWFC x13,W
0BB70:  MOVWF  FEA
0BB72:  MOVLW  01
0BB74:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BB76:  MOVFF  872,9BC
0BB7A:  MOVFF  871,9BB
0BB7E:  MOVFF  870,9BA
0BB82:  MOVFF  86F,9B9
0BB86:  MOVLB  0
0BB88:  CALL   6EEE
0BB8C:  MOVF   01,F
0BB8E:  BNZ   BB9A
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BB90:  MOVLW  07
0BB92:  MOVWF  01
0BB94:  MOVLB  8
0BB96:  BRA    BBBE
0BB98:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BB9A:  MOVLB  9
0BB9C:  CLRF   xF1
0BB9E:  CLRF   xF0
0BBA0:  CLRF   xEF
0BBA2:  CLRF   xEE
0BBA4:  MOVLB  0
0BBA6:  CALL   5A5A
0BBAA:  MOVF   01,F
0BBAC:  BNZ   BBB8
....................       return (FR_RW_ERROR); 
0BBAE:  MOVLW  07
0BBB0:  MOVWF  01
0BBB2:  MOVLB  8
0BBB4:  BRA    BBBE
0BBB6:  MOVLB  0
....................  
....................    return (FR_OK); 
0BBB8:  MOVLW  00
0BBBA:  MOVWF  01
0BBBC:  MOVLB  8
0BBBE:  MOVLB  0
0BBC0:  GOTO   BC54 (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
07962:  MOVFF  98F,991
07966:  MOVFF  98E,990
0796A:  MOVFF  991,03
0796E:  MOVLB  9
07970:  MOVFF  990,FE9
07974:  MOVFF  991,FEA
07978:  MOVF   FEF,F
0797A:  BZ    7988
0797C:  INCF   x90,F
0797E:  BTFSC  FD8.2
07980:  INCF   x91,F
07982:  MOVLB  0
07984:  BRA    796A
07986:  MOVLB  9
....................    return(sc - s); 
07988:  MOVF   x8E,W
0798A:  SUBWF  x90,W
0798C:  MOVWF  00
0798E:  MOVF   x8F,W
07990:  SUBWFB x91,W
07992:  MOVWF  03
07994:  MOVFF  00,01
07998:  MOVWF  02
0799A:  MOVLB  0
0799C:  GOTO   83DC (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
034EC:  MOVLB  4
034EE:  CLRF   xE6
034F0:  MOVLW  01
034F2:  MOVWF  xE5
....................    rtc.year=10; 
034F4:  MOVLW  0A
034F6:  MOVWF  xE4
....................    rtc.month=1; 
034F8:  MOVLW  01
034FA:  MOVWF  xE3
....................    rtc.day=1; 
034FC:  MOVWF  xE2
....................    rtc.hour=0; 
034FE:  CLRF   xE1
....................    rtc.min=0; 
03500:  CLRF   xE0
....................    rtc.sec=0; 
03502:  CLRF   xDF
....................    rtc.ms100=0; 
03504:  CLRF   xDE
03506:  MOVLB  0
03508:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
06F8E:  MOVLB  9
06F90:  CLRF   xBB
06F92:  CLRF   xBA
06F94:  CLRF   xB9
06F96:  MOVFF  4E4,9B8
06F9A:  MOVLW  14
06F9C:  ADDWF  xB8,F
06F9E:  MOVLW  00
06FA0:  ADDWFC xB9,F
06FA2:  ADDWFC xBA,F
06FA4:  ADDWFC xBB,F
06FA6:  BCF    FD8.0
06FA8:  CLRF   xB4
06FAA:  CLRF   xB5
06FAC:  CLRF   xB6
06FAE:  RLCF   xB8,W
06FB0:  MOVWF  xB7
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
06FB2:  CLRF   xBB
06FB4:  CLRF   xBA
06FB6:  CLRF   xB9
06FB8:  MOVFF  4E3,9B8
06FBC:  MOVLW  0F
06FBE:  ANDWF  xB8,F
06FC0:  CLRF   xB9
06FC2:  CLRF   xBA
06FC4:  CLRF   xBB
06FC6:  CLRF   00
06FC8:  CLRF   01
06FCA:  RLCF   xB8,W
06FCC:  MOVWF  02
06FCE:  RLCF   xB9,W
06FD0:  MOVWF  03
06FD2:  RLCF   02,F
06FD4:  RLCF   03,F
06FD6:  RLCF   02,F
06FD8:  RLCF   03,F
06FDA:  RLCF   02,F
06FDC:  RLCF   03,F
06FDE:  RLCF   02,F
06FE0:  RLCF   03,F
06FE2:  MOVLW  E0
06FE4:  ANDWF  02,F
06FE6:  MOVF   00,W
06FE8:  IORWF  xB4,F
06FEA:  MOVF   01,W
06FEC:  IORWF  xB5,F
06FEE:  MOVF   02,W
06FF0:  IORWF  xB6,F
06FF2:  MOVF   03,W
06FF4:  IORWF  xB7,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
06FF6:  CLRF   xBB
06FF8:  CLRF   xBA
06FFA:  CLRF   xB9
06FFC:  MOVFF  4E2,9B8
07000:  MOVLW  1F
07002:  ANDWF  xB8,F
07004:  CLRF   xB9
07006:  CLRF   xBA
07008:  CLRF   xBB
0700A:  CLRF   00
0700C:  CLRF   01
0700E:  MOVF   00,W
07010:  IORWF  xB4,F
07012:  MOVF   01,W
07014:  IORWF  xB5,F
07016:  MOVF   xB8,W
07018:  IORWF  xB6,F
0701A:  MOVF   xB9,W
0701C:  IORWF  xB7,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
0701E:  CLRF   xBB
07020:  CLRF   xBA
07022:  CLRF   xB9
07024:  MOVFF  4E1,9B8
07028:  MOVLW  1F
0702A:  ANDWF  xB8,F
0702C:  CLRF   xB9
0702E:  CLRF   xBA
07030:  CLRF   xBB
07032:  CLRF   00
07034:  RLCF   xB8,W
07036:  MOVWF  01
07038:  RLCF   xB9,W
0703A:  MOVWF  02
0703C:  RLCF   xBA,W
0703E:  MOVWF  03
07040:  RLCF   01,F
07042:  RLCF   02,F
07044:  RLCF   03,F
07046:  RLCF   01,F
07048:  RLCF   02,F
0704A:  RLCF   03,F
0704C:  MOVLW  F8
0704E:  ANDWF  01,F
07050:  MOVF   00,W
07052:  IORWF  xB4,F
07054:  MOVF   01,W
07056:  IORWF  xB5,F
07058:  MOVF   02,W
0705A:  IORWF  xB6,F
0705C:  MOVF   03,W
0705E:  IORWF  xB7,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
07060:  CLRF   xBB
07062:  CLRF   xBA
07064:  CLRF   xB9
07066:  MOVFF  4E0,9B8
0706A:  MOVLW  3F
0706C:  ANDWF  xB8,F
0706E:  CLRF   xB9
07070:  CLRF   xBA
07072:  CLRF   xBB
07074:  RLCF   xB8,W
07076:  MOVWF  00
07078:  RLCF   xB9,W
0707A:  MOVWF  01
0707C:  RLCF   xBA,W
0707E:  MOVWF  02
07080:  RLCF   xBB,W
07082:  MOVWF  03
07084:  RLCF   00,F
07086:  RLCF   01,F
07088:  RLCF   02,F
0708A:  RLCF   03,F
0708C:  RLCF   00,F
0708E:  RLCF   01,F
07090:  RLCF   02,F
07092:  RLCF   03,F
07094:  RLCF   00,F
07096:  RLCF   01,F
07098:  RLCF   02,F
0709A:  RLCF   03,F
0709C:  RLCF   00,F
0709E:  RLCF   01,F
070A0:  RLCF   02,F
070A2:  RLCF   03,F
070A4:  MOVLW  E0
070A6:  ANDWF  00,F
070A8:  MOVF   00,W
070AA:  IORWF  xB4,F
070AC:  MOVF   01,W
070AE:  IORWF  xB5,F
070B0:  MOVF   02,W
070B2:  IORWF  xB6,F
070B4:  MOVF   03,W
070B6:  IORWF  xB7,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
070B8:  CLRF   xBB
070BA:  CLRF   xBA
070BC:  CLRF   xB9
070BE:  MOVFF  4DF,9B8
070C2:  MOVLW  3F
070C4:  ANDWF  xB8,F
070C6:  CLRF   xB9
070C8:  CLRF   xBA
070CA:  CLRF   xBB
070CC:  BCF    FD8.0
070CE:  RRCF   xBB,W
070D0:  MOVWF  03
070D2:  RRCF   xBA,W
070D4:  MOVWF  02
070D6:  RRCF   xB9,W
070D8:  MOVWF  01
070DA:  RRCF   xB8,W
070DC:  IORWF  xB4,F
070DE:  MOVF   01,W
070E0:  IORWF  xB5,F
070E2:  MOVF   02,W
070E4:  IORWF  xB6,F
070E6:  MOVF   03,W
070E8:  IORWF  xB7,F
....................    return (work); 
070EA:  MOVFF  9B4,00
070EE:  MOVFF  9B5,01
070F2:  MOVFF  9B6,02
070F6:  MOVFF  9B7,03
070FA:  MOVLB  0
070FC:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0B79E:  MOVLW  08
0B7A0:  MOVLB  9
0B7A2:  MOVWF  x8F
0B7A4:  MOVLW  6A
0B7A6:  MOVWF  x8E
0B7A8:  MOVFF  869,991
0B7AC:  MOVFF  868,990
0B7B0:  MOVLW  01
0B7B2:  MOVWF  x92
0B7B4:  MOVLB  0
0B7B6:  CALL   70FE
0B7BA:  MOVFF  01,886
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0B7BE:  MOVLB  8
0B7C0:  MOVF   x86,F
0B7C2:  BTFSS  FD8.2
0B7C4:  BRA    B8C6
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0B7C6:  MOVLW  08
0B7C8:  MOVWF  xAC
0B7CA:  MOVLW  6A
0B7CC:  MOVWF  xAB
0B7CE:  MOVLW  08
0B7D0:  MOVWF  xAE
0B7D2:  MOVLW  87
0B7D4:  MOVWF  xAD
0B7D6:  CLRF   xB0
0B7D8:  MOVLW  20
0B7DA:  MOVWF  xAF
0B7DC:  MOVLW  08
0B7DE:  MOVWF  xB2
0B7E0:  MOVLW  A9
0B7E2:  MOVWF  xB1
0B7E4:  MOVLB  0
0B7E6:  BRA    B0E2
0B7E8:  MOVFF  01,886
....................          for (i = 0; i < br; i++) 
0B7EC:  MOVLB  8
0B7EE:  CLRF   xA8
0B7F0:  CLRF   xA7
0B7F2:  MOVF   xA8,W
0B7F4:  SUBWF  xAA,W
0B7F6:  BNC   B822
0B7F8:  BNZ   B800
0B7FA:  MOVF   xA9,W
0B7FC:  SUBWF  xA7,W
0B7FE:  BC    B822
....................          { 
....................             putc(mesg[i]); 
0B800:  MOVLW  87
0B802:  ADDWF  xA7,W
0B804:  MOVWF  FE9
0B806:  MOVLW  08
0B808:  ADDWFC xA8,W
0B80A:  MOVWF  FEA
0B80C:  MOVFF  FEF,8AB
0B810:  MOVF   xAB,W
0B812:  MOVLB  0
0B814:  CALL   AE1E
0B818:  MOVLB  8
0B81A:  INCF   xA7,F
0B81C:  BTFSC  FD8.2
0B81E:  INCF   xA8,F
0B820:  BRA    B7F2
....................          } 
....................       } while ((result == FR_OK) && br); 
0B822:  MOVF   x86,F
0B824:  BNZ   B82C
0B826:  MOVF   xA9,W
0B828:  IORWF  xAA,W
0B82A:  BNZ   B7C6
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0B82C:  MOVF   x86,F
0B82E:  BZ    B8A2
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0B830:  MOVLW  40
0B832:  MOVWF  FF6
0B834:  MOVLW  0C
0B836:  MOVWF  FF7
0B838:  MOVLW  00
0B83A:  MOVWF  FF8
0B83C:  CLRF   1B
0B83E:  BTFSC  FF2.7
0B840:  BSF    1B.7
0B842:  BCF    FF2.7
0B844:  MOVLB  0
0B846:  CALL   0E78
0B84A:  BTFSC  1B.7
0B84C:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0B84E:  MOVFF  886,8AB
0B852:  MOVLW  08
0B854:  MOVLB  8
0B856:  MOVWF  xAD
0B858:  MOVLW  87
0B85A:  MOVWF  xAC
0B85C:  MOVLB  0
0B85E:  RCALL  B5F0
....................          printf("@FS: %s\r\n",mesg); 
0B860:  MOVLW  56
0B862:  MOVWF  FF6
0B864:  MOVLW  0C
0B866:  MOVWF  FF7
0B868:  MOVLW  00
0B86A:  MOVWF  FF8
0B86C:  CLRF   1B
0B86E:  BTFSC  FF2.7
0B870:  BSF    1B.7
0B872:  BCF    FF2.7
0B874:  MOVLW  05
0B876:  MOVLB  A
0B878:  MOVWF  x19
0B87A:  MOVLB  0
0B87C:  CALL   104E
0B880:  BTFSC  1B.7
0B882:  BSF    FF2.7
0B884:  MOVLW  08
0B886:  MOVWF  FEA
0B888:  MOVLW  87
0B88A:  MOVWF  FE9
0B88C:  CALL   793C
0B890:  MOVLW  0D
0B892:  BTFSS  F9E.4
0B894:  BRA    B892
0B896:  MOVWF  FAD
0B898:  MOVLW  0A
0B89A:  BTFSS  F9E.4
0B89C:  BRA    B89A
0B89E:  MOVWF  FAD
0B8A0:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0B8A2:  MOVLW  08
0B8A4:  MOVLB  9
0B8A6:  MOVWF  x8F
0B8A8:  MOVLW  6A
0B8AA:  MOVWF  x8E
0B8AC:  MOVLB  0
0B8AE:  CALL   824C
....................       printf("\r\n");       
0B8B2:  MOVLW  0D
0B8B4:  BTFSS  F9E.4
0B8B6:  BRA    B8B4
0B8B8:  MOVWF  FAD
0B8BA:  MOVLW  0A
0B8BC:  BTFSS  F9E.4
0B8BE:  BRA    B8BC
0B8C0:  MOVWF  FAD
....................    } 
0B8C2:  BRA    B916
0B8C4:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0B8C6:  MOVFF  886,8AB
0B8CA:  MOVLW  08
0B8CC:  MOVWF  xAD
0B8CE:  MOVLW  87
0B8D0:  MOVWF  xAC
0B8D2:  MOVLB  0
0B8D4:  RCALL  B5F0
....................       printf("@FS: %s\r\n",mesg); 
0B8D6:  MOVLW  60
0B8D8:  MOVWF  FF6
0B8DA:  MOVLW  0C
0B8DC:  MOVWF  FF7
0B8DE:  MOVLW  00
0B8E0:  MOVWF  FF8
0B8E2:  CLRF   1B
0B8E4:  BTFSC  FF2.7
0B8E6:  BSF    1B.7
0B8E8:  BCF    FF2.7
0B8EA:  MOVLW  05
0B8EC:  MOVLB  A
0B8EE:  MOVWF  x19
0B8F0:  MOVLB  0
0B8F2:  CALL   104E
0B8F6:  BTFSC  1B.7
0B8F8:  BSF    FF2.7
0B8FA:  MOVLW  08
0B8FC:  MOVWF  FEA
0B8FE:  MOVLW  87
0B900:  MOVWF  FE9
0B902:  CALL   793C
0B906:  MOVLW  0D
0B908:  BTFSS  F9E.4
0B90A:  BRA    B908
0B90C:  MOVWF  FAD
0B90E:  MOVLW  0A
0B910:  BTFSS  F9E.4
0B912:  BRA    B910
0B914:  MOVWF  FAD
....................    } 
0B916:  GOTO   BC46 (RETURN)
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04DCE:  MOVLW  6A
04DD0:  MOVWF  FF6
04DD2:  MOVLW  0C
04DD4:  MOVWF  FF7
04DD6:  MOVLW  00
04DD8:  MOVWF  FF8
04DDA:  CLRF   1B
04DDC:  BTFSC  FF2.7
04DDE:  BSF    1B.7
04DE0:  BCF    FF2.7
04DE2:  CALL   0E78
04DE6:  BTFSC  1B.7
04DE8:  BSF    FF2.7
....................    if (status & FR_OK) 
04DEA:  ANDLW  00
04DEC:  BZ    4E0A
....................       printf("   NoError\r\n"); 
04DEE:  MOVLW  7A
04DF0:  MOVWF  FF6
04DF2:  MOVLW  0C
04DF4:  MOVWF  FF7
04DF6:  MOVLW  00
04DF8:  MOVWF  FF8
04DFA:  CLRF   1B
04DFC:  BTFSC  FF2.7
04DFE:  BSF    1B.7
04E00:  BCF    FF2.7
04E02:  CALL   0E78
04E06:  BTFSC  1B.7
04E08:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04E0A:  MOVLB  8
04E0C:  BTFSS  x69.0
04E0E:  BRA    4E30
....................       printf("   Media Not Ready\r\n"); 
04E10:  MOVLW  88
04E12:  MOVWF  FF6
04E14:  MOVLW  0C
04E16:  MOVWF  FF7
04E18:  MOVLW  00
04E1A:  MOVWF  FF8
04E1C:  CLRF   1B
04E1E:  BTFSC  FF2.7
04E20:  BSF    1B.7
04E22:  BCF    FF2.7
04E24:  MOVLB  0
04E26:  CALL   0E78
04E2A:  BTFSC  1B.7
04E2C:  BSF    FF2.7
04E2E:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04E30:  BTFSS  x69.1
04E32:  BRA    4E54
....................       printf("   File Not Found\r\n"); 
04E34:  MOVLW  9E
04E36:  MOVWF  FF6
04E38:  MOVLW  0C
04E3A:  MOVWF  FF7
04E3C:  MOVLW  00
04E3E:  MOVWF  FF8
04E40:  CLRF   1B
04E42:  BTFSC  FF2.7
04E44:  BSF    1B.7
04E46:  BCF    FF2.7
04E48:  MOVLB  0
04E4A:  CALL   0E78
04E4E:  BTFSC  1B.7
04E50:  BSF    FF2.7
04E52:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04E54:  MOVF   x69,W
04E56:  ANDLW  03
04E58:  BZ    4E7A
....................       printf("   Invalid Path\r\n"); 
04E5A:  MOVLW  B2
04E5C:  MOVWF  FF6
04E5E:  MOVLW  0C
04E60:  MOVWF  FF7
04E62:  MOVLW  00
04E64:  MOVWF  FF8
04E66:  CLRF   1B
04E68:  BTFSC  FF2.7
04E6A:  BSF    1B.7
04E6C:  BCF    FF2.7
04E6E:  MOVLB  0
04E70:  CALL   0E78
04E74:  BTFSC  1B.7
04E76:  BSF    FF2.7
04E78:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04E7A:  BTFSS  x69.2
04E7C:  BRA    4E9E
....................       printf("   Invalid Name\r\n"); 
04E7E:  MOVLW  C4
04E80:  MOVWF  FF6
04E82:  MOVLW  0C
04E84:  MOVWF  FF7
04E86:  MOVLW  00
04E88:  MOVWF  FF8
04E8A:  CLRF   1B
04E8C:  BTFSC  FF2.7
04E8E:  BSF    1B.7
04E90:  BCF    FF2.7
04E92:  MOVLB  0
04E94:  CALL   0E78
04E98:  BTFSC  1B.7
04E9A:  BSF    FF2.7
04E9C:  MOVLB  8
....................    if (status & FR_DENIED) 
04E9E:  MOVF   x69,W
04EA0:  ANDLW  05
04EA2:  BZ    4EC4
....................       printf("   Access Denied\r\n"); 
04EA4:  MOVLW  D6
04EA6:  MOVWF  FF6
04EA8:  MOVLW  0C
04EAA:  MOVWF  FF7
04EAC:  MOVLW  00
04EAE:  MOVWF  FF8
04EB0:  CLRF   1B
04EB2:  BTFSC  FF2.7
04EB4:  BSF    1B.7
04EB6:  BCF    FF2.7
04EB8:  MOVLB  0
04EBA:  CALL   0E78
04EBE:  BTFSC  1B.7
04EC0:  BSF    FF2.7
04EC2:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04EC4:  MOVF   x69,W
04EC6:  ANDLW  06
04EC8:  BZ    4EEA
....................       printf("   Disk Full\r\n"); 
04ECA:  MOVLW  EA
04ECC:  MOVWF  FF6
04ECE:  MOVLW  0C
04ED0:  MOVWF  FF7
04ED2:  MOVLW  00
04ED4:  MOVWF  FF8
04ED6:  CLRF   1B
04ED8:  BTFSC  FF2.7
04EDA:  BSF    1B.7
04EDC:  BCF    FF2.7
04EDE:  MOVLB  0
04EE0:  CALL   0E78
04EE4:  BTFSC  1B.7
04EE6:  BSF    FF2.7
04EE8:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04EEA:  MOVF   x69,W
04EEC:  ANDLW  07
04EEE:  BZ    4F10
....................       printf("   Read/Write Error\r\n"); 
04EF0:  MOVLW  FA
04EF2:  MOVWF  FF6
04EF4:  MOVLW  0C
04EF6:  MOVWF  FF7
04EF8:  MOVLW  00
04EFA:  MOVWF  FF8
04EFC:  CLRF   1B
04EFE:  BTFSC  FF2.7
04F00:  BSF    1B.7
04F02:  BCF    FF2.7
04F04:  MOVLB  0
04F06:  CALL   0E78
04F0A:  BTFSC  1B.7
04F0C:  BSF    FF2.7
04F0E:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04F10:  MOVF   x69,W
04F12:  ANDLW  09
04F14:  BZ    4F36
....................       printf("   Incorrect Media Change\r\n"); 
04F16:  MOVLW  10
04F18:  MOVWF  FF6
04F1A:  MOVLW  0D
04F1C:  MOVWF  FF7
04F1E:  MOVLW  00
04F20:  MOVWF  FF8
04F22:  CLRF   1B
04F24:  BTFSC  FF2.7
04F26:  BSF    1B.7
04F28:  BCF    FF2.7
04F2A:  MOVLB  0
04F2C:  CALL   0E78
04F30:  BTFSC  1B.7
04F32:  BSF    FF2.7
04F34:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04F36:  MOVF   x69,W
04F38:  ANDLW  0A
04F3A:  BZ    4F5C
....................       printf("   Write Protected\r\n"); 
04F3C:  MOVLW  2C
04F3E:  MOVWF  FF6
04F40:  MOVLW  0D
04F42:  MOVWF  FF7
04F44:  MOVLW  00
04F46:  MOVWF  FF8
04F48:  CLRF   1B
04F4A:  BTFSC  FF2.7
04F4C:  BSF    1B.7
04F4E:  BCF    FF2.7
04F50:  MOVLB  0
04F52:  CALL   0E78
04F56:  BTFSC  1B.7
04F58:  BSF    FF2.7
04F5A:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04F5C:  MOVF   x69,W
04F5E:  ANDLW  0B
04F60:  BZ    4F82
....................       printf("   Not Enabled\r\n"); 
04F62:  MOVLW  42
04F64:  MOVWF  FF6
04F66:  MOVLW  0D
04F68:  MOVWF  FF7
04F6A:  MOVLW  00
04F6C:  MOVWF  FF8
04F6E:  CLRF   1B
04F70:  BTFSC  FF2.7
04F72:  BSF    1B.7
04F74:  BCF    FF2.7
04F76:  MOVLB  0
04F78:  CALL   0E78
04F7C:  BTFSC  1B.7
04F7E:  BSF    FF2.7
04F80:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04F82:  MOVF   x69,W
04F84:  ANDLW  0C
04F86:  BZ    4FA8
....................       printf("   No File System\r\n"); 
04F88:  MOVLW  54
04F8A:  MOVWF  FF6
04F8C:  MOVLW  0D
04F8E:  MOVWF  FF7
04F90:  MOVLW  00
04F92:  MOVWF  FF8
04F94:  CLRF   1B
04F96:  BTFSC  FF2.7
04F98:  BSF    1B.7
04F9A:  BCF    FF2.7
04F9C:  MOVLB  0
04F9E:  CALL   0E78
04FA2:  BTFSC  1B.7
04FA4:  BSF    FF2.7
04FA6:  MOVLB  8
04FA8:  MOVLB  0
04FAA:  GOTO   5034 (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
08298:  MOVLW  08
0829A:  MOVWF  FEA
0829C:  MOVLW  EE
0829E:  MOVWF  FE9
082A0:  CLRF   00
082A2:  CLRF   02
082A4:  MOVLW  A0
082A6:  MOVWF  01
082A8:  CALL   350A
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
082AC:  MOVLW  08
082AE:  MOVLB  9
082B0:  MOVWF  x8F
082B2:  MOVLW  CD
082B4:  MOVWF  x8E
082B6:  MOVFF  8CC,991
082BA:  MOVFF  8CB,990
082BE:  MOVLW  12
082C0:  MOVWF  x92
082C2:  MOVLB  0
082C4:  CALL   70FE
082C8:  MOVFF  01,8E9
....................    if (result) 
082CC:  MOVLB  8
082CE:  MOVF   xE9,F
082D0:  BZ    82F4
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
082D2:  MOVLW  68
082D4:  MOVWF  FF6
082D6:  MOVLW  0D
082D8:  MOVWF  FF7
082DA:  MOVLW  00
082DC:  MOVWF  FF8
082DE:  CLRF   1B
082E0:  BTFSC  FF2.7
082E2:  BSF    1B.7
082E4:  BCF    FF2.7
082E6:  MOVLB  0
082E8:  CALL   0E78
082EC:  BTFSC  1B.7
082EE:  BSF    FF2.7
....................    } 
082F0:  BRA    8470
082F2:  MOVLB  8
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
082F4:  MOVF   xD1,F
082F6:  BNZ   8304
082F8:  MOVF   xD2,F
082FA:  BNZ   8304
082FC:  MOVF   xD3,F
082FE:  BNZ   8304
08300:  MOVF   xD4,F
08302:  BZ    832A
....................          result = f_lseek(&fdst, fdst.fsize);  
08304:  MOVLW  08
08306:  MOVLB  9
08308:  MOVWF  x8F
0830A:  MOVLW  CD
0830C:  MOVWF  x8E
0830E:  MOVFF  8D4,993
08312:  MOVFF  8D3,992
08316:  MOVFF  8D2,991
0831A:  MOVFF  8D1,990
0831E:  MOVLB  0
08320:  GOTO   7546
08324:  MOVFF  01,8E9
08328:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
0832A:  MOVLB  0
0832C:  MOVF   x66,F
0832E:  BNZ   834C
08330:  MOVLW  08
08332:  MOVLB  9
08334:  MOVWF  x8F
08336:  MOVLW  EE
08338:  MOVWF  x8E
0833A:  CLRF   x91
0833C:  MOVLW  67
0833E:  MOVWF  x90
08340:  CLRF   x93
08342:  MOVLW  9F
08344:  MOVWF  x92
08346:  MOVLB  0
08348:  CALL   78AE
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
0834C:  DECFSZ x66,W
0834E:  BRA    836E
08350:  MOVLW  08
08352:  MOVLB  9
08354:  MOVWF  x8F
08356:  MOVLW  EE
08358:  MOVWF  x8E
0835A:  MOVLW  01
0835C:  MOVWF  x91
0835E:  MOVLW  07
08360:  MOVWF  x90
08362:  CLRF   x93
08364:  MOVLW  9F
08366:  MOVWF  x92
08368:  MOVLB  0
0836A:  CALL   78AE
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
0836E:  MOVF   20,F
08370:  BNZ   8378
08372:  MOVF   1F,W
08374:  SUBLW  04
08376:  BC    83CC
08378:  MOVLW  88
0837A:  MOVWF  FF6
0837C:  MOVLW  0D
0837E:  MOVWF  FF7
08380:  MOVLW  00
08382:  MOVWF  FF8
08384:  CLRF   1B
08386:  BTFSC  FF2.7
08388:  BSF    1B.7
0838A:  BCF    FF2.7
0838C:  MOVLW  0E
0838E:  MOVLB  A
08390:  MOVWF  x19
08392:  MOVLB  0
08394:  CALL   104E
08398:  BTFSC  1B.7
0839A:  BSF    FF2.7
0839C:  MOVLW  08
0839E:  MOVWF  FEA
083A0:  MOVLW  EE
083A2:  MOVWF  FE9
083A4:  CALL   793C
083A8:  MOVLW  98
083AA:  MOVWF  FF6
083AC:  MOVLW  0D
083AE:  MOVWF  FF7
083B0:  MOVLW  00
083B2:  MOVWF  FF8
083B4:  CLRF   1B
083B6:  BTFSC  FF2.7
083B8:  BSF    1B.7
083BA:  BCF    FF2.7
083BC:  MOVLW  03
083BE:  MOVLB  A
083C0:  MOVWF  x19
083C2:  MOVLB  0
083C4:  CALL   104E
083C8:  BTFSC  1B.7
083CA:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
083CC:  MOVLW  08
083CE:  MOVLB  9
083D0:  MOVWF  x8F
083D2:  MOVLW  EE
083D4:  MOVWF  x8E
083D6:  MOVLB  0
083D8:  GOTO   7962
083DC:  MOVFF  02,8EB
083E0:  MOVFF  01,8EA
....................       result = f_write(&fdst, mesg, btw, &bw); 
083E4:  MOVLW  08
083E6:  MOVLB  9
083E8:  MOVWF  x8F
083EA:  MOVLW  CD
083EC:  MOVWF  x8E
083EE:  MOVLW  08
083F0:  MOVWF  x91
083F2:  MOVLW  EE
083F4:  MOVWF  x90
083F6:  MOVFF  8EB,993
083FA:  MOVFF  8EA,992
083FE:  MOVLW  08
08400:  MOVWF  x95
08402:  MOVLW  EC
08404:  MOVWF  x94
08406:  MOVLB  0
08408:  GOTO   79A0
0840C:  MOVFF  01,8E9
....................       if (result) 
08410:  MOVLB  8
08412:  MOVF   xE9,F
08414:  BZ    8438
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
08416:  MOVLW  9C
08418:  MOVWF  FF6
0841A:  MOVLW  0D
0841C:  MOVWF  FF7
0841E:  MOVLW  00
08420:  MOVWF  FF8
08422:  CLRF   1B
08424:  BTFSC  FF2.7
08426:  BSF    1B.7
08428:  BCF    FF2.7
0842A:  MOVLB  0
0842C:  CALL   0E78
08430:  BTFSC  1B.7
08432:  BSF    FF2.7
....................       } 
08434:  BRA    8460
08436:  MOVLB  8
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
08438:  MOVF   20,F
0843A:  BNZ   8442
0843C:  MOVF   1F,W
0843E:  SUBLW  04
08440:  BC    8462
08442:  MOVLW  B0
08444:  MOVWF  FF6
08446:  MOVLW  0D
08448:  MOVWF  FF7
0844A:  MOVLW  00
0844C:  MOVWF  FF8
0844E:  CLRF   1B
08450:  BTFSC  FF2.7
08452:  BSF    1B.7
08454:  BCF    FF2.7
08456:  MOVLB  0
08458:  CALL   0E78
0845C:  BTFSC  1B.7
0845E:  BSF    FF2.7
08460:  MOVLB  8
....................       } 
....................  
....................       f_close(&fdst); 
08462:  MOVLW  08
08464:  MOVLB  9
08466:  MOVWF  x8F
08468:  MOVLW  CD
0846A:  MOVWF  x8E
0846C:  MOVLB  0
0846E:  RCALL  824C
....................    } 
....................  
....................    return (result); 
08470:  MOVLB  8
08472:  MOVFF  8E9,01
08476:  MOVLB  0
08478:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
....................    nibl=data-(nibh*10); 
....................  
....................    return((nibh<<4)|nibl); 
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
032F6:  MOVFF  8CC,8CD
....................    data=(i>>4)*10; 
032FA:  MOVLB  8
032FC:  SWAPF  xCD,W
032FE:  MOVWF  00
03300:  MOVLW  0F
03302:  ANDWF  00,F
03304:  MOVF   00,W
03306:  MULLW  0A
03308:  MOVFF  FF3,8CC
....................    data=data+(i<<4>>4); 
0330C:  SWAPF  xCD,W
0330E:  MOVWF  00
03310:  MOVLW  F0
03312:  ANDWF  00,F
03314:  MOVF   00,W
03316:  SWAPF  00,F
03318:  MOVLW  0F
0331A:  ANDWF  00,F
0331C:  MOVF   00,W
0331E:  ADDWF  xCC,F
....................  
....................    return data; 
03320:  MOVFF  8CC,01
03324:  MOVLB  0
03326:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
03496:  MOVLB  8
03498:  CLRF   xA9
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0349A:  BCF    FC6.5
0349C:  MOVLW  21
0349E:  MOVWF  FC6
034A0:  MOVLW  40
034A2:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
034A4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
034A6:  MOVF   FC9,W
034A8:  MOVLW  0C
034AA:  MOVWF  FC9
034AC:  RRCF   FC7,W
034AE:  BNC   34AC
034B0:  MOVFF  FC9,8A9
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
034B4:  MOVF   FC9,W
034B6:  MOVFF  8A9,FC9
034BA:  RRCF   FC7,W
034BC:  BNC   34BA
034BE:  MOVFF  FC9,730
....................    output_bit(RTC_CS, DISABLE); 
034C2:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
034C4:  MOVLB  7
034C6:  BCF    x30.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
034C8:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
034CA:  MOVF   FC9,W
034CC:  MOVLW  8C
034CE:  MOVWF  FC9
034D0:  RRCF   FC7,W
034D2:  BNC   34D0
034D4:  MOVFF  FC9,8A9
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
034D8:  MOVF   FC9,W
034DA:  MOVFF  730,FC9
034DE:  RRCF   FC7,W
034E0:  BNC   34DE
034E2:  MOVFF  FC9,8A9
....................    output_bit(RTC_CS, DISABLE); 
034E6:  BSF    F91.0
034E8:  MOVLB  0
034EA:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
13272:  MOVLW  1A
13274:  MOVLB  8
13276:  MOVWF  x72
13278:  MOVLB  0
1327A:  CALL   29A8
1327E:  MOVFF  01,4F
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
13282:  MOVF   4F,F
13284:  BNZ   132F2
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
13286:  MOVLW  BE
13288:  MOVWF  FF6
1328A:  MOVLW  0D
1328C:  MOVWF  FF7
1328E:  MOVLW  00
13290:  MOVWF  FF8
13292:  CLRF   1B
13294:  BTFSC  FF2.7
13296:  BSF    1B.7
13298:  BCF    FF2.7
1329A:  MOVLW  05
1329C:  MOVLB  A
1329E:  MOVWF  x19
132A0:  MOVLB  0
132A2:  CALL   104E
132A6:  BTFSC  1B.7
132A8:  BSF    FF2.7
132AA:  CLRF   1B
132AC:  BTFSC  FF2.7
132AE:  BSF    1B.7
132B0:  BCF    FF2.7
132B2:  MOVFF  72A,A19
132B6:  MOVLW  01
132B8:  MOVLB  A
132BA:  MOVWF  x1A
132BC:  MOVLB  0
132BE:  CALL   0FD0
132C2:  BTFSC  1B.7
132C4:  BSF    FF2.7
132C6:  MOVLW  2F
132C8:  BTFSS  F9E.4
132CA:  BRA    132C8
132CC:  MOVWF  FAD
132CE:  CLRF   1B
132D0:  BTFSC  FF2.7
132D2:  BSF    1B.7
132D4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
132D6:  MOVFF  729,A19
132DA:  MOVLW  01
132DC:  MOVLB  A
132DE:  MOVWF  x1A
132E0:  MOVLB  0
132E2:  CALL   0FD0
132E6:  BTFSC  1B.7
132E8:  BSF    FF2.7
132EA:  MOVLW  2F
132EC:  BTFSS  F9E.4
132EE:  BRA    132EC
132F0:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
132F2:  DECFSZ 4F,W
132F4:  BRA    13362
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
132F6:  MOVLW  CA
132F8:  MOVWF  FF6
132FA:  MOVLW  0D
132FC:  MOVWF  FF7
132FE:  MOVLW  00
13300:  MOVWF  FF8
13302:  CLRF   1B
13304:  BTFSC  FF2.7
13306:  BSF    1B.7
13308:  BCF    FF2.7
1330A:  MOVLW  05
1330C:  MOVLB  A
1330E:  MOVWF  x19
13310:  MOVLB  0
13312:  CALL   104E
13316:  BTFSC  1B.7
13318:  BSF    FF2.7
1331A:  CLRF   1B
1331C:  BTFSC  FF2.7
1331E:  BSF    1B.7
13320:  BCF    FF2.7
13322:  MOVFF  729,A19
13326:  MOVLW  01
13328:  MOVLB  A
1332A:  MOVWF  x1A
1332C:  MOVLB  0
1332E:  CALL   0FD0
13332:  BTFSC  1B.7
13334:  BSF    FF2.7
13336:  MOVLW  2F
13338:  BTFSS  F9E.4
1333A:  BRA    13338
1333C:  MOVWF  FAD
1333E:  CLRF   1B
13340:  BTFSC  FF2.7
13342:  BSF    1B.7
13344:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
13346:  MOVFF  72A,A19
1334A:  MOVLW  01
1334C:  MOVLB  A
1334E:  MOVWF  x1A
13350:  MOVLB  0
13352:  CALL   0FD0
13356:  BTFSC  1B.7
13358:  BSF    FF2.7
1335A:  MOVLW  2F
1335C:  BTFSS  F9E.4
1335E:  BRA    1335C
13360:  MOVWF  FAD
13362:  CLRF   1B
13364:  BTFSC  FF2.7
13366:  BSF    1B.7
13368:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
1336A:  MOVFF  72B,A19
1336E:  MOVLW  01
13370:  MOVLB  A
13372:  MOVWF  x1A
13374:  MOVLB  0
13376:  CALL   0FD0
1337A:  BTFSC  1B.7
1337C:  BSF    FF2.7
1337E:  MOVLW  20
13380:  BTFSS  F9E.4
13382:  BRA    13380
13384:  MOVWF  FAD
13386:  CLRF   1B
13388:  BTFSC  FF2.7
1338A:  BSF    1B.7
1338C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
1338E:  MOVFF  727,A19
13392:  MOVLW  01
13394:  MOVLB  A
13396:  MOVWF  x1A
13398:  MOVLB  0
1339A:  CALL   0FD0
1339E:  BTFSC  1B.7
133A0:  BSF    FF2.7
133A2:  MOVLW  3A
133A4:  BTFSS  F9E.4
133A6:  BRA    133A4
133A8:  MOVWF  FAD
133AA:  CLRF   1B
133AC:  BTFSC  FF2.7
133AE:  BSF    1B.7
133B0:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
133B2:  MOVFF  726,A19
133B6:  MOVLW  01
133B8:  MOVLB  A
133BA:  MOVWF  x1A
133BC:  MOVLB  0
133BE:  CALL   0FD0
133C2:  BTFSC  1B.7
133C4:  BSF    FF2.7
133C6:  MOVLW  3A
133C8:  BTFSS  F9E.4
133CA:  BRA    133C8
133CC:  MOVWF  FAD
133CE:  CLRF   1B
133D0:  BTFSC  FF2.7
133D2:  BSF    1B.7
133D4:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
133D6:  MOVFF  725,A19
133DA:  MOVLW  01
133DC:  MOVLB  A
133DE:  MOVWF  x1A
133E0:  MOVLB  0
133E2:  CALL   0FD0
133E6:  BTFSC  1B.7
133E8:  BSF    FF2.7
133EA:  MOVLW  0A
133EC:  BTFSS  F9E.4
133EE:  BRA    133EC
133F0:  MOVWF  FAD
133F2:  MOVLW  0D
133F4:  BTFSS  F9E.4
133F6:  BRA    133F4
133F8:  MOVWF  FAD
133FA:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
03328:  MOVLB  8
0332A:  CLRF   xCB
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0332C:  BCF    FC6.5
0332E:  MOVLW  21
03330:  MOVWF  FC6
03332:  MOVLW  40
03334:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
03336:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
03338:  MOVF   FC9,W
0333A:  CLRF   FC9
0333C:  RRCF   FC7,W
0333E:  BNC   333C
03340:  MOVFF  FC9,8CB
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
03344:  MOVF   FC9,W
03346:  MOVFF  8CB,FC9
0334A:  RRCF   FC7,W
0334C:  BNC   334A
0334E:  MOVFF  FC9,72C
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
03352:  MOVF   FC9,W
03354:  MOVFF  8CB,FC9
03358:  RRCF   FC7,W
0335A:  BNC   3358
0335C:  MOVFF  FC9,725
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
03360:  MOVF   FC9,W
03362:  MOVFF  8CB,FC9
03366:  RRCF   FC7,W
03368:  BNC   3366
0336A:  MOVFF  FC9,726
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
0336E:  MOVF   FC9,W
03370:  MOVFF  8CB,FC9
03374:  RRCF   FC7,W
03376:  BNC   3374
03378:  MOVFF  FC9,727
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
0337C:  MOVF   FC9,W
0337E:  MOVFF  8CB,FC9
03382:  RRCF   FC7,W
03384:  BNC   3382
03386:  MOVFF  FC9,728
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
0338A:  MOVF   FC9,W
0338C:  MOVFF  8CB,FC9
03390:  RRCF   FC7,W
03392:  BNC   3390
03394:  MOVFF  FC9,729
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
03398:  MOVF   FC9,W
0339A:  MOVFF  8CB,FC9
0339E:  RRCF   FC7,W
033A0:  BNC   339E
033A2:  MOVFF  FC9,72A
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
033A6:  MOVF   FC9,W
033A8:  MOVFF  8CB,FC9
033AC:  RRCF   FC7,W
033AE:  BNC   33AC
033B0:  MOVFF  FC9,72B
....................    output_bit(RTC_CS, DISABLE); 
033B4:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
033B6:  MOVFF  725,8CC
033BA:  MOVLB  0
033BC:  RCALL  32F6
033BE:  MOVFF  01,725
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
033C2:  MOVFF  726,8CC
033C6:  RCALL  32F6
033C8:  MOVFF  01,726
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
033CC:  MOVFF  727,8CC
033D0:  RCALL  32F6
033D2:  MOVFF  01,727
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
033D6:  MOVFF  729,8CC
033DA:  RCALL  32F6
033DC:  MOVFF  01,729
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
033E0:  MOVFF  72A,8CC
033E4:  RCALL  32F6
033E6:  MOVFF  01,72A
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
033EA:  MOVFF  72B,8CC
033EE:  RCALL  32F6
033F0:  MOVFF  01,72B
033F4:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00E02:  MOVLB  A
00E04:  CLRF   x10
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00E06:  BCF    FC6.5
00E08:  MOVLW  21
00E0A:  MOVWF  FC6
00E0C:  MOVLW  40
00E0E:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00E10:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00E12:  MOVF   FC9,W
00E14:  MOVLW  0F
00E16:  MOVWF  FC9
00E18:  RRCF   FC7,W
00E1A:  BNC   0E18
00E1C:  MOVFF  FC9,A10
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00E20:  MOVF   FC9,W
00E22:  MOVFF  A10,FC9
00E26:  RRCF   FC7,W
00E28:  BNC   0E26
00E2A:  MOVFF  FC9,733
....................    spi_read(0x00); 
00E2E:  MOVF   FC9,W
00E30:  CLRF   FC9
00E32:  RRCF   FC7,W
00E34:  BNC   0E32
....................    output_bit(RTC_CS, DISABLE); 
00E36:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00E38:  BCF    4D.2
00E3A:  MOVLB  0
00E3C:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
133FC:  MOVF   4F,F
133FE:  BNZ   1346C
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
13400:  MOVLW  D6
13402:  MOVWF  FF6
13404:  MOVLW  0D
13406:  MOVWF  FF7
13408:  MOVLW  00
1340A:  MOVWF  FF8
1340C:  CLRF   1B
1340E:  BTFSC  FF2.7
13410:  BSF    1B.7
13412:  BCF    FF2.7
13414:  MOVLW  05
13416:  MOVLB  A
13418:  MOVWF  x19
1341A:  MOVLB  0
1341C:  CALL   104E
13420:  BTFSC  1B.7
13422:  BSF    FF2.7
13424:  CLRF   1B
13426:  BTFSC  FF2.7
13428:  BSF    1B.7
1342A:  BCF    FF2.7
1342C:  MOVFF  72E,A19
13430:  MOVLW  01
13432:  MOVLB  A
13434:  MOVWF  x1A
13436:  MOVLB  0
13438:  CALL   0FD0
1343C:  BTFSC  1B.7
1343E:  BSF    FF2.7
13440:  MOVLW  2F
13442:  BTFSS  F9E.4
13444:  BRA    13442
13446:  MOVWF  FAD
13448:  CLRF   1B
1344A:  BTFSC  FF2.7
1344C:  BSF    1B.7
1344E:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
13450:  MOVFF  72F,A19
13454:  MOVLW  01
13456:  MOVLB  A
13458:  MOVWF  x1A
1345A:  MOVLB  0
1345C:  CALL   0FD0
13460:  BTFSC  1B.7
13462:  BSF    FF2.7
13464:  MOVLW  2F
13466:  BTFSS  F9E.4
13468:  BRA    13466
1346A:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
1346C:  DECFSZ 4F,W
1346E:  BRA    134DC
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
13470:  MOVLW  E2
13472:  MOVWF  FF6
13474:  MOVLW  0D
13476:  MOVWF  FF7
13478:  MOVLW  00
1347A:  MOVWF  FF8
1347C:  CLRF   1B
1347E:  BTFSC  FF2.7
13480:  BSF    1B.7
13482:  BCF    FF2.7
13484:  MOVLW  05
13486:  MOVLB  A
13488:  MOVWF  x19
1348A:  MOVLB  0
1348C:  CALL   104E
13490:  BTFSC  1B.7
13492:  BSF    FF2.7
13494:  CLRF   1B
13496:  BTFSC  FF2.7
13498:  BSF    1B.7
1349A:  BCF    FF2.7
1349C:  MOVFF  72F,A19
134A0:  MOVLW  01
134A2:  MOVLB  A
134A4:  MOVWF  x1A
134A6:  MOVLB  0
134A8:  CALL   0FD0
134AC:  BTFSC  1B.7
134AE:  BSF    FF2.7
134B0:  MOVLW  2F
134B2:  BTFSS  F9E.4
134B4:  BRA    134B2
134B6:  MOVWF  FAD
134B8:  CLRF   1B
134BA:  BTFSC  FF2.7
134BC:  BSF    1B.7
134BE:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
134C0:  MOVFF  72E,A19
134C4:  MOVLW  01
134C6:  MOVLB  A
134C8:  MOVWF  x1A
134CA:  MOVLB  0
134CC:  CALL   0FD0
134D0:  BTFSC  1B.7
134D2:  BSF    FF2.7
134D4:  MOVLW  2F
134D6:  BTFSS  F9E.4
134D8:  BRA    134D6
134DA:  MOVWF  FAD
134DC:  CLRF   1B
134DE:  BTFSC  FF2.7
134E0:  BSF    1B.7
134E2:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
134E4:  MOVFF  72D,A19
134E8:  MOVLW  01
134EA:  MOVLB  A
134EC:  MOVWF  x1A
134EE:  MOVLB  0
134F0:  CALL   0FD0
134F4:  BTFSC  1B.7
134F6:  BSF    FF2.7
134F8:  MOVLW  20
134FA:  BTFSS  F9E.4
134FC:  BRA    134FA
134FE:  MOVWF  FAD
13500:  CLRF   1B
13502:  BTFSC  FF2.7
13504:  BSF    1B.7
13506:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
13508:  MOVFF  730,A19
1350C:  MOVLW  01
1350E:  MOVLB  A
13510:  MOVWF  x1A
13512:  MOVLB  0
13514:  CALL   0FD0
13518:  BTFSC  1B.7
1351A:  BSF    FF2.7
1351C:  MOVLW  3A
1351E:  BTFSS  F9E.4
13520:  BRA    1351E
13522:  MOVWF  FAD
13524:  CLRF   1B
13526:  BTFSC  FF2.7
13528:  BSF    1B.7
1352A:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
1352C:  MOVFF  731,A19
13530:  MOVLW  01
13532:  MOVLB  A
13534:  MOVWF  x1A
13536:  MOVLB  0
13538:  CALL   0FD0
1353C:  BTFSC  1B.7
1353E:  BSF    FF2.7
13540:  MOVLW  3A
13542:  BTFSS  F9E.4
13544:  BRA    13542
13546:  MOVWF  FAD
13548:  CLRF   1B
1354A:  BTFSC  FF2.7
1354C:  BSF    1B.7
1354E:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
13550:  MOVFF  732,A19
13554:  MOVLW  01
13556:  MOVLB  A
13558:  MOVWF  x1A
1355A:  MOVLB  0
1355C:  CALL   0FD0
13560:  BTFSC  1B.7
13562:  BSF    FF2.7
13564:  MOVLW  0A
13566:  BTFSS  F9E.4
13568:  BRA    13566
1356A:  MOVWF  FAD
1356C:  MOVLW  0D
1356E:  BTFSS  F9E.4
13570:  BRA    1356E
13572:  MOVWF  FAD
13574:  GOTO   146FA (RETURN)
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
12CE2:  MOVLB  8
12CE4:  CLRF   x96
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
12CE6:  BCF    FC6.5
12CE8:  MOVLW  21
12CEA:  MOVWF  FC6
12CEC:  MOVLW  40
12CEE:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
12CF0:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
12CF2:  MOVF   FC9,W
12CF4:  MOVLW  0A
12CF6:  MOVWF  FC9
12CF8:  RRCF   FC7,W
12CFA:  BNC   12CF8
12CFC:  MOVFF  FC9,896
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
12D00:  MOVF   FC9,W
12D02:  MOVFF  896,FC9
12D06:  RRCF   FC7,W
12D08:  BNC   12D06
12D0A:  MOVFF  FC9,72E
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
12D0E:  MOVF   FC9,W
12D10:  MOVFF  896,FC9
12D14:  RRCF   FC7,W
12D16:  BNC   12D14
12D18:  MOVFF  FC9,72F
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
12D1C:  MOVF   FC9,W
12D1E:  MOVFF  896,FC9
12D22:  RRCF   FC7,W
12D24:  BNC   12D22
12D26:  MOVFF  FC9,730
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
12D2A:  MOVF   FC9,W
12D2C:  MOVFF  896,FC9
12D30:  RRCF   FC7,W
12D32:  BNC   12D30
12D34:  MOVFF  FC9,731
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
12D38:  MOVF   FC9,W
12D3A:  MOVFF  896,FC9
12D3E:  RRCF   FC7,W
12D40:  BNC   12D3E
12D42:  MOVFF  FC9,732
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
12D46:  MOVF   FC9,W
12D48:  MOVFF  896,FC9
12D4C:  RRCF   FC7,W
12D4E:  BNC   12D4C
12D50:  MOVFF  FC9,733
....................    output_bit(RTC_CS, DISABLE); 
12D54:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
12D56:  MOVLW  1F
12D58:  MOVLB  7
12D5A:  ANDWF  x2E,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
12D5C:  MOVFF  72E,8CC
12D60:  MOVLB  0
12D62:  CALL   32F6
12D66:  MOVFF  01,72E
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
12D6A:  MOVLW  3F
12D6C:  MOVLB  7
12D6E:  ANDWF  x2F,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
12D70:  MOVFF  72F,8CC
12D74:  MOVLB  0
12D76:  CALL   32F6
12D7A:  MOVFF  01,72F
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
12D7E:  MOVLW  3F
12D80:  MOVLB  7
12D82:  ANDWF  x30,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
12D84:  MOVFF  730,8CC
12D88:  MOVLB  0
12D8A:  CALL   32F6
12D8E:  MOVFF  01,730
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
12D92:  MOVLB  7
12D94:  BCF    x31.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
12D96:  MOVFF  731,8CC
12D9A:  MOVLB  0
12D9C:  CALL   32F6
12DA0:  MOVFF  01,731
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
12DA4:  MOVLB  7
12DA6:  BCF    x32.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
12DA8:  MOVFF  732,8CC
12DAC:  MOVLB  0
12DAE:  CALL   32F6
12DB2:  MOVFF  01,732
12DB6:  RETURN 0
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
....................  
....................    time_error = 0; 
....................     
....................    fputc('[', COM_A); 
....................     
....................    for (n=0; n<12; ++n){ 
....................       c = fgetc(COM_A); 
....................       if (com_echo == TRUE) 
....................       { 
....................          fputc(c, COM_A); 
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
....................          break; 
....................       } 
....................    } 
....................     
....................    if (time_error == 0){ 
....................     
....................       fputc(']', COM_A); 
....................        
....................       for (n=0; n<12; ++n){ 
....................          t_entry[n] = (t_entry[n] - 48); 
....................       } 
....................        
....................       if (RTCfmt == 0) 
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
....................       } 
....................        
....................       if (RTCfmt == 1) 
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
....................       if (RTC_Yr_Data > 99) time_error = 2;  
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
....................       if (RTC_Hr_Data > 24) time_error = 2;  
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
....................       if (RTC_Min_Data > 60) time_error = 2;  
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
....................       if (RTC_Sec_Data > 60) time_error = 2; 
....................        
....................       if (RTCfmt == 0) 
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
....................       } 
....................        
....................       if (RTCfmt == 1) 
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
....................       } 
....................       if (time_error == 2) cmd_inv();             
....................  
....................    } 
....................    else cmd_arg(); 
....................     
....................    return time_error; 
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
....................     
....................    if (time_error ==0 ){ 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................     
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x86);        // address - Month 
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x87);        // address - Year 
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x82);        // address - Min 
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x80);        // address - ms 
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................    } 
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    time_error = get_time(); 
....................     
....................    if (time_error == 0 ){ 
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................       delay_us(10); 
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................       delay_us(1); // Delays added 1.020A 
....................        
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................       delay_us(1); 
....................        
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................       delay_us(1);  
....................        
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
....................       output_bit(RTC_CS, DISABLE);  
....................       delay_us(1); 
....................        
....................       output_bit(RTC_CS, ENABLE); 
....................       //fprintf(COM_A,"test61\r\n"); 
....................       RTC_buffer = spi_read(0x8A);// address - Month 
....................       //fprintf(COM_A,"test62\r\n"); 
....................       fprintf(COM_A,"test6: %d\r\n",RTC_Mon_Data); 
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
....................       output_bit(RTC_CS, DISABLE); 
....................       delay_us(1); 
....................       //fprintf(COM_A,"test6\r\n"); 
....................     
....................    RTC_read_alarm(); 
....................    } 
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
1359C:  BCF    FC6.5
1359E:  MOVLW  21
135A0:  MOVWF  FC6
135A2:  MOVLW  40
135A4:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
135A6:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
135A8:  MOVF   FC9,W
135AA:  MOVLW  8E
135AC:  MOVWF  FC9
135AE:  RRCF   FC7,W
135B0:  BNC   135AE
135B2:  MOVFF  FC9,866
....................    RTC_buffer = spi_read(0b00000000);  // data 
135B6:  MOVF   FC9,W
135B8:  CLRF   FC9
135BA:  RRCF   FC7,W
135BC:  BNC   135BA
135BE:  MOVFF  FC9,866
....................    output_bit(RTC_CS, DISABLE); 
135C2:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
135C4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
135C6:  MOVF   FC9,W
135C8:  MOVLW  8D
135CA:  MOVWF  FC9
135CC:  RRCF   FC7,W
135CE:  BNC   135CC
135D0:  MOVFF  FC9,866
....................    RTC_buffer = spi_read(0b10000000);  // data 
135D4:  MOVF   FC9,W
135D6:  MOVLW  80
135D8:  MOVWF  FC9
135DA:  RRCF   FC7,W
135DC:  BNC   135DA
135DE:  MOVFF  FC9,866
....................    output_bit(RTC_CS, DISABLE); 
135E2:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
135E4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
135E6:  MOVF   FC9,W
135E8:  MOVLW  8C
135EA:  MOVWF  FC9
135EC:  RRCF   FC7,W
135EE:  BNC   135EC
135F0:  MOVFF  FC9,866
....................    RTC_buffer = spi_read(0b10000000);  // data 
135F4:  MOVF   FC9,W
135F6:  MOVLW  80
135F8:  MOVWF  FC9
135FA:  RRCF   FC7,W
135FC:  BNC   135FA
135FE:  MOVFF  FC9,866
....................    output_bit(RTC_CS, DISABLE); 
13602:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
13604:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
13606:  MOVF   FC9,W
13608:  MOVLW  8B
1360A:  MOVWF  FC9
1360C:  RRCF   FC7,W
1360E:  BNC   1360C
13610:  MOVFF  FC9,866
....................    RTC_buffer = spi_read(0b11000000);  // data 
13614:  MOVF   FC9,W
13616:  MOVLW  C0
13618:  MOVWF  FC9
1361A:  RRCF   FC7,W
1361C:  BNC   1361A
1361E:  MOVFF  FC9,866
....................    output_bit(RTC_CS, DISABLE);    
13622:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
13624:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
13626:  MOVF   FC9,W
13628:  MOVLW  8A
1362A:  MOVWF  FC9
1362C:  RRCF   FC7,W
1362E:  BNC   1362C
13630:  MOVFF  FC9,866
....................    RTC_buffer = spi_read(0b10000000);  // data 
13634:  MOVF   FC9,W
13636:  MOVLW  80
13638:  MOVWF  FC9
1363A:  RRCF   FC7,W
1363C:  BNC   1363A
1363E:  MOVFF  FC9,866
....................    output_bit(RTC_CS, DISABLE); 
13642:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
13644:  CALL   12CE2
13648:  GOTO   147C4 (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
12C8A:  MOVLB  8
12C8C:  CLRF   x66
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
12C8E:  BCF    FC6.5
12C90:  MOVLW  21
12C92:  MOVWF  FC6
12C94:  MOVLW  40
12C96:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
12C98:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
12C9A:  MOVF   FC9,W
12C9C:  MOVLW  0A
12C9E:  MOVWF  FC9
12CA0:  RRCF   FC7,W
12CA2:  BNC   12CA0
12CA4:  MOVFF  FC9,866
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
12CA8:  MOVF   FC9,W
12CAA:  MOVFF  866,FC9
12CAE:  RRCF   FC7,W
12CB0:  BNC   12CAE
12CB2:  MOVFF  FC9,72E
....................    output_bit(RTC_CS, DISABLE); 
12CB6:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
12CB8:  MOVLB  7
12CBA:  BSF    x2E.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
12CBC:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
12CBE:  MOVF   FC9,W
12CC0:  MOVLW  8A
12CC2:  MOVWF  FC9
12CC4:  RRCF   FC7,W
12CC6:  BNC   12CC4
12CC8:  MOVFF  FC9,866
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
12CCC:  MOVF   FC9,W
12CCE:  MOVFF  72E,FC9
12CD2:  RRCF   FC7,W
12CD4:  BNC   12CD2
12CD6:  MOVFF  FC9,866
....................    output_bit(RTC_CS, DISABLE); 
12CDA:  BSF    F91.0
12CDC:  MOVLB  0
12CDE:  GOTO   146EE (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
03426:  MOVFF  725,73F
....................    rtc_last_min   = RTC_Min_Reg; 
0342A:  MOVFF  726,73E
....................    rtc_last_hour  = RTC_Hr_Reg; 
0342E:  MOVFF  727,73D
....................    rtc_last_day   = RTC_DOM_Reg; 
03432:  MOVFF  729,73B
....................    rtc_last_month = RTC_Mon_Reg; 
03436:  MOVFF  72A,73A
....................    rtc_last_year  = RTC_Yr_Reg; 
0343A:  MOVFF  72B,73C
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
0343E:  MOVLW  06
03440:  MOVLB  8
03442:  MOVWF  xA2
03444:  MOVFF  73A,8A3
03448:  MOVLB  0
0344A:  RCALL  33F6
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
0344C:  MOVLW  08
0344E:  MOVLB  8
03450:  MOVWF  xA2
03452:  MOVFF  73B,8A3
03456:  MOVLB  0
03458:  RCALL  33F6
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
0345A:  MOVLW  0A
0345C:  MOVLB  8
0345E:  MOVWF  xA2
03460:  MOVFF  73C,8A3
03464:  MOVLB  0
03466:  RCALL  33F6
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
03468:  MOVLW  0C
0346A:  MOVLB  8
0346C:  MOVWF  xA2
0346E:  MOVFF  73D,8A3
03472:  MOVLB  0
03474:  RCALL  33F6
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
03476:  MOVLW  0E
03478:  MOVLB  8
0347A:  MOVWF  xA2
0347C:  MOVFF  73E,8A3
03480:  MOVLB  0
03482:  RCALL  33F6
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
03484:  MOVLW  10
03486:  MOVLB  8
03488:  MOVWF  xA2
0348A:  MOVFF  73F,8A3
0348E:  MOVLB  0
03490:  RCALL  33F6
03492:  GOTO   14B8E (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
12DB8:  MOVLB  8
12DBA:  CLRF   x69
12DBC:  CLRF   x68
12DBE:  CLRF   x67
12DC0:  CLRF   x66
12DC2:  CLRF   x6D
12DC4:  CLRF   x6C
12DC6:  CLRF   x6B
12DC8:  CLRF   x6A
12DCA:  CLRF   x71
12DCC:  CLRF   x70
12DCE:  CLRF   x6F
12DD0:  CLRF   x6E
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
12DD2:  CLRF   x7E
12DD4:  CLRF   x7F
12DD6:  MOVLW  1F
12DD8:  MOVWF  x80
12DDA:  CLRF   x81
12DDC:  MOVLW  3B
12DDE:  MOVWF  x82
12DE0:  CLRF   x83
12DE2:  MOVLW  5A
12DE4:  MOVWF  x84
12DE6:  CLRF   x85
12DE8:  MOVLW  78
12DEA:  MOVWF  x86
12DEC:  CLRF   x87
12DEE:  MOVLW  97
12DF0:  MOVWF  x88
12DF2:  CLRF   x89
12DF4:  MOVLW  B5
12DF6:  MOVWF  x8A
12DF8:  CLRF   x8B
12DFA:  MOVLW  D4
12DFC:  MOVWF  x8C
12DFE:  CLRF   x8D
12E00:  MOVLW  F3
12E02:  MOVWF  x8E
12E04:  CLRF   x8F
12E06:  MOVLW  11
12E08:  MOVWF  x90
12E0A:  MOVLW  01
12E0C:  MOVWF  x91
12E0E:  MOVLW  30
12E10:  MOVWF  x92
12E12:  MOVLW  01
12E14:  MOVWF  x93
12E16:  MOVLW  4E
12E18:  MOVWF  x94
12E1A:  MOVLW  01
12E1C:  MOVWF  x95
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
12E1E:  BCF    4D.3
....................     
....................    RTC_read(); 
12E20:  MOVLB  0
12E22:  CALL   3328
....................    RTC_read_alarm(); 
12E26:  RCALL  12CE2
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
12E28:  MOVLW  04
12E2A:  MOVLB  8
12E2C:  MOVWF  x96
12E2E:  MOVLB  0
12E30:  CALL   2A02
12E34:  MOVFF  01,72D
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
12E38:  MOVLB  7
12E3A:  MOVF   x2B,W
12E3C:  SUBWF  x2D,W
12E3E:  BC    12E44
12E40:  BSF    4D.3
12E42:  BRA    1326C
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
12E44:  MOVF   x2D,W
12E46:  SUBWF  x2B,W
12E48:  BTFSS  FD8.2
12E4A:  BRA    1326C
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
12E4C:  MOVLW  01
12E4E:  SUBWF  x2A,W
12E50:  MOVWF  00
12E52:  BCF    FD8.0
12E54:  RLCF   00,F
12E56:  MOVF   00,W
12E58:  CLRF   03
12E5A:  ADDLW  7E
12E5C:  MOVWF  FE9
12E5E:  MOVLW  08
12E60:  ADDWFC 03,W
12E62:  MOVWF  FEA
12E64:  MOVFF  FEC,03
12E68:  MOVF   FED,F
12E6A:  MOVFF  FEF,8F5
12E6E:  MOVFF  03,8F6
12E72:  MOVLB  0
12E74:  CALL   BFAE
12E78:  MOVFF  03,869
12E7C:  MOVFF  02,868
12E80:  MOVFF  01,867
12E84:  MOVFF  00,866
....................          time_now = time_now + RTC_DOM_Reg; 
12E88:  MOVLB  8
12E8A:  CLRF   xF6
12E8C:  MOVFF  729,8F5
12E90:  MOVLB  0
12E92:  CALL   BFAE
12E96:  BCF    FD8.1
12E98:  MOVFF  869,8F8
12E9C:  MOVFF  868,8F7
12EA0:  MOVFF  867,8F6
12EA4:  MOVFF  866,8F5
12EA8:  MOVFF  03,8FC
12EAC:  MOVFF  02,8FB
12EB0:  MOVFF  01,8FA
12EB4:  MOVFF  00,8F9
12EB8:  CALL   C1BC
12EBC:  MOVFF  03,869
12EC0:  MOVFF  02,868
12EC4:  MOVFF  01,867
12EC8:  MOVFF  00,866
....................           
....................          hour = RTC_Hr_Reg; 
12ECC:  MOVLB  8
12ECE:  CLRF   xF6
12ED0:  MOVFF  727,8F5
12ED4:  MOVLB  0
12ED6:  CALL   BFAE
12EDA:  MOVFF  03,875
12EDE:  MOVFF  02,874
12EE2:  MOVFF  01,873
12EE6:  MOVFF  00,872
....................          minute = RTC_Min_Reg; 
12EEA:  MOVLB  8
12EEC:  CLRF   xF6
12EEE:  MOVFF  726,8F5
12EF2:  MOVLB  0
12EF4:  CALL   BFAE
12EF8:  MOVFF  03,879
12EFC:  MOVFF  02,878
12F00:  MOVFF  01,877
12F04:  MOVFF  00,876
....................          second = RTC_Sec_Reg; 
12F08:  MOVLB  8
12F0A:  CLRF   xF6
12F0C:  MOVFF  725,8F5
12F10:  MOVLB  0
12F12:  CALL   BFAE
12F16:  MOVFF  03,87D
12F1A:  MOVFF  02,87C
12F1E:  MOVFF  01,87B
12F22:  MOVFF  00,87A
....................           
....................          fraction_of_day = (hour / 24); 
12F26:  MOVFF  875,8DC
12F2A:  MOVFF  874,8DB
12F2E:  MOVFF  873,8DA
12F32:  MOVFF  872,8D9
12F36:  MOVLB  8
12F38:  CLRF   xE0
12F3A:  CLRF   xDF
12F3C:  MOVLW  40
12F3E:  MOVWF  xDE
12F40:  MOVLW  83
12F42:  MOVWF  xDD
12F44:  MOVLB  0
12F46:  CALL   BFE4
12F4A:  MOVFF  03,871
12F4E:  MOVFF  02,870
12F52:  MOVFF  01,86F
12F56:  MOVFF  00,86E
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
12F5A:  MOVFF  879,8DC
12F5E:  MOVFF  878,8DB
12F62:  MOVFF  877,8DA
12F66:  MOVFF  876,8D9
12F6A:  MOVLB  8
12F6C:  CLRF   xE0
12F6E:  CLRF   xDF
12F70:  MOVLW  34
12F72:  MOVWF  xDE
12F74:  MOVLW  89
12F76:  MOVWF  xDD
12F78:  MOVLB  0
12F7A:  CALL   BFE4
12F7E:  BCF    FD8.1
12F80:  MOVFF  871,8F8
12F84:  MOVFF  870,8F7
12F88:  MOVFF  86F,8F6
12F8C:  MOVFF  86E,8F5
12F90:  MOVFF  03,8FC
12F94:  MOVFF  02,8FB
12F98:  MOVFF  01,8FA
12F9C:  MOVFF  00,8F9
12FA0:  CALL   C1BC
12FA4:  MOVFF  03,871
12FA8:  MOVFF  02,870
12FAC:  MOVFF  01,86F
12FB0:  MOVFF  00,86E
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
12FB4:  MOVFF  87D,8DC
12FB8:  MOVFF  87C,8DB
12FBC:  MOVFF  87B,8DA
12FC0:  MOVFF  87A,8D9
12FC4:  MOVLB  8
12FC6:  CLRF   xE0
12FC8:  MOVLW  C0
12FCA:  MOVWF  xDF
12FCC:  MOVLW  28
12FCE:  MOVWF  xDE
12FD0:  MOVLW  8F
12FD2:  MOVWF  xDD
12FD4:  MOVLB  0
12FD6:  CALL   BFE4
12FDA:  BCF    FD8.1
12FDC:  MOVFF  871,8F8
12FE0:  MOVFF  870,8F7
12FE4:  MOVFF  86F,8F6
12FE8:  MOVFF  86E,8F5
12FEC:  MOVFF  03,8FC
12FF0:  MOVFF  02,8FB
12FF4:  MOVFF  01,8FA
12FF8:  MOVFF  00,8F9
12FFC:  CALL   C1BC
13000:  MOVFF  03,871
13004:  MOVFF  02,870
13008:  MOVFF  01,86F
1300C:  MOVFF  00,86E
....................           
....................          time_now = time_now + fraction_of_day; 
13010:  BCF    FD8.1
13012:  MOVFF  869,8F8
13016:  MOVFF  868,8F7
1301A:  MOVFF  867,8F6
1301E:  MOVFF  866,8F5
13022:  MOVFF  871,8FC
13026:  MOVFF  870,8FB
1302A:  MOVFF  86F,8FA
1302E:  MOVFF  86E,8F9
13032:  CALL   C1BC
13036:  MOVFF  03,869
1303A:  MOVFF  02,868
1303E:  MOVFF  01,867
13042:  MOVFF  00,866
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
13046:  MOVLB  8
13048:  CLRF   xF6
1304A:  MOVFF  730,8F5
1304E:  MOVLB  0
13050:  CALL   BFAE
13054:  MOVFF  03,875
13058:  MOVFF  02,874
1305C:  MOVFF  01,873
13060:  MOVFF  00,872
....................          minute = RTC_Al_Min_Reg; 
13064:  MOVLB  8
13066:  CLRF   xF6
13068:  MOVFF  731,8F5
1306C:  MOVLB  0
1306E:  CALL   BFAE
13072:  MOVFF  03,879
13076:  MOVFF  02,878
1307A:  MOVFF  01,877
1307E:  MOVFF  00,876
....................          second = RTC_Al_Sec_Reg; 
13082:  MOVLB  8
13084:  CLRF   xF6
13086:  MOVFF  732,8F5
1308A:  MOVLB  0
1308C:  CALL   BFAE
13090:  MOVFF  03,87D
13094:  MOVFF  02,87C
13098:  MOVFF  01,87B
1309C:  MOVFF  00,87A
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
130A0:  MOVLW  01
130A2:  MOVLB  7
130A4:  SUBWF  x2E,W
130A6:  MOVWF  00
130A8:  BCF    FD8.0
130AA:  RLCF   00,F
130AC:  MOVF   00,W
130AE:  CLRF   03
130B0:  ADDLW  7E
130B2:  MOVWF  FE9
130B4:  MOVLW  08
130B6:  ADDWFC 03,W
130B8:  MOVWF  FEA
130BA:  MOVFF  FEC,03
130BE:  MOVF   FED,F
130C0:  MOVFF  FEF,8F5
130C4:  MOVFF  03,8F6
130C8:  MOVLB  0
130CA:  CALL   BFAE
130CE:  MOVFF  03,86D
130D2:  MOVFF  02,86C
130D6:  MOVFF  01,86B
130DA:  MOVFF  00,86A
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
130DE:  MOVLB  8
130E0:  CLRF   xF6
130E2:  MOVFF  72F,8F5
130E6:  MOVLB  0
130E8:  CALL   BFAE
130EC:  BCF    FD8.1
130EE:  MOVFF  86D,8F8
130F2:  MOVFF  86C,8F7
130F6:  MOVFF  86B,8F6
130FA:  MOVFF  86A,8F5
130FE:  MOVFF  03,8FC
13102:  MOVFF  02,8FB
13106:  MOVFF  01,8FA
1310A:  MOVFF  00,8F9
1310E:  CALL   C1BC
13112:  MOVFF  03,86D
13116:  MOVFF  02,86C
1311A:  MOVFF  01,86B
1311E:  MOVFF  00,86A
....................           
....................          fraction_of_day = (hour / 24); 
13122:  MOVFF  875,8DC
13126:  MOVFF  874,8DB
1312A:  MOVFF  873,8DA
1312E:  MOVFF  872,8D9
13132:  MOVLB  8
13134:  CLRF   xE0
13136:  CLRF   xDF
13138:  MOVLW  40
1313A:  MOVWF  xDE
1313C:  MOVLW  83
1313E:  MOVWF  xDD
13140:  MOVLB  0
13142:  CALL   BFE4
13146:  MOVFF  03,871
1314A:  MOVFF  02,870
1314E:  MOVFF  01,86F
13152:  MOVFF  00,86E
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
13156:  MOVFF  879,8DC
1315A:  MOVFF  878,8DB
1315E:  MOVFF  877,8DA
13162:  MOVFF  876,8D9
13166:  MOVLB  8
13168:  CLRF   xE0
1316A:  CLRF   xDF
1316C:  MOVLW  34
1316E:  MOVWF  xDE
13170:  MOVLW  89
13172:  MOVWF  xDD
13174:  MOVLB  0
13176:  CALL   BFE4
1317A:  BCF    FD8.1
1317C:  MOVFF  871,8F8
13180:  MOVFF  870,8F7
13184:  MOVFF  86F,8F6
13188:  MOVFF  86E,8F5
1318C:  MOVFF  03,8FC
13190:  MOVFF  02,8FB
13194:  MOVFF  01,8FA
13198:  MOVFF  00,8F9
1319C:  CALL   C1BC
131A0:  MOVFF  03,871
131A4:  MOVFF  02,870
131A8:  MOVFF  01,86F
131AC:  MOVFF  00,86E
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
131B0:  MOVFF  87D,8DC
131B4:  MOVFF  87C,8DB
131B8:  MOVFF  87B,8DA
131BC:  MOVFF  87A,8D9
131C0:  MOVLB  8
131C2:  CLRF   xE0
131C4:  MOVLW  C0
131C6:  MOVWF  xDF
131C8:  MOVLW  28
131CA:  MOVWF  xDE
131CC:  MOVLW  8F
131CE:  MOVWF  xDD
131D0:  MOVLB  0
131D2:  CALL   BFE4
131D6:  BCF    FD8.1
131D8:  MOVFF  871,8F8
131DC:  MOVFF  870,8F7
131E0:  MOVFF  86F,8F6
131E4:  MOVFF  86E,8F5
131E8:  MOVFF  03,8FC
131EC:  MOVFF  02,8FB
131F0:  MOVFF  01,8FA
131F4:  MOVFF  00,8F9
131F8:  CALL   C1BC
131FC:  MOVFF  03,871
13200:  MOVFF  02,870
13204:  MOVFF  01,86F
13208:  MOVFF  00,86E
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
1320C:  BCF    FD8.1
1320E:  MOVFF  86D,8F8
13212:  MOVFF  86C,8F7
13216:  MOVFF  86B,8F6
1321A:  MOVFF  86A,8F5
1321E:  MOVFF  871,8FC
13222:  MOVFF  870,8FB
13226:  MOVFF  86F,8FA
1322A:  MOVFF  86E,8F9
1322E:  CALL   C1BC
13232:  MOVFF  03,86D
13236:  MOVFF  02,86C
1323A:  MOVFF  01,86B
1323E:  MOVFF  00,86A
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
13242:  MOVFF  86D,8F4
13246:  MOVFF  86C,8F3
1324A:  MOVFF  86B,8F2
1324E:  MOVFF  86A,8F1
13252:  MOVFF  869,8F8
13256:  MOVFF  868,8F7
1325A:  MOVFF  867,8F6
1325E:  MOVFF  866,8F5
13262:  CALL   C142
13266:  BNC   1326A
13268:  BSF    4D.3
1326A:  MOVLB  7
....................       } 
....................    } 
1326C:  MOVLB  0
1326E:  GOTO   146F2 (RETURN)
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
*
13578:  BTFSS  4D.3
1357A:  BRA    13598
1357C:  MOVLW  FA
1357E:  MOVWF  FF6
13580:  MOVLW  0D
13582:  MOVWF  FF7
13584:  MOVLW  00
13586:  MOVWF  FF8
13588:  CLRF   1B
1358A:  BTFSC  FF2.7
1358C:  BSF    1B.7
1358E:  BCF    FF2.7
13590:  CALL   0E78
13594:  BTFSC  1B.7
13596:  BSF    FF2.7
13598:  GOTO   146FE (RETURN)
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0E8D8:  BCF    F67.5
0E8DA:  MOVLW  32
0E8DC:  MOVWF  F67
0E8DE:  MOVLW  40
0E8E0:  MOVWF  F68
....................     
....................    data = 0; 
0E8E2:  MOVLB  8
0E8E4:  CLRF   xB5
0E8E6:  CLRF   xB4
....................     
....................    DAC_MS_byte = 0; 
0E8E8:  CLRF   xB6
....................    DAC_LS_byte = 0; 
0E8EA:  CLRF   xB7
....................     
....................    data = setting & 0b0000111100000000; 
0E8EC:  CLRF   xB4
0E8EE:  MOVF   xB3,W
0E8F0:  ANDLW  0F
0E8F2:  MOVWF  xB5
....................    data = data >> 8; 
0E8F4:  MOVFF  8B5,8B4
0E8F8:  CLRF   xB5
....................    DAC_MS_byte = data; 
0E8FA:  MOVFF  8B4,8B6
....................     
....................    data = setting & 0b0000000011111111; 
0E8FE:  MOVFF  8B2,8B4
0E902:  CLRF   xB5
....................    DAC_LS_byte = data; 
0E904:  MOVFF  8B4,8B7
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0E908:  MOVLW  01
0E90A:  SUBWF  xB1,W
0E90C:  ADDLW  FC
0E90E:  BC    E93A
0E910:  ADDLW  04
0E912:  MOVLB  0
0E914:  GOTO   E958
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0E918:  MOVLW  30
0E91A:  MOVLB  8
0E91C:  IORWF  xB6,F
....................          break; 
0E91E:  BRA    E93A
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0E920:  MOVLW  70
0E922:  MOVLB  8
0E924:  IORWF  xB6,F
....................          break; 
0E926:  BRA    E93A
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0E928:  MOVLW  B0
0E92A:  MOVLB  8
0E92C:  IORWF  xB6,F
....................          break; 
0E92E:  BRA    E93A
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0E930:  MOVLW  F0
0E932:  MOVLB  8
0E934:  IORWF  xB6,F
....................          break; 
0E936:  BRA    E93A
0E938:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0E93A:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0E93C:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0E93E:  MOVF   F6A,W
0E940:  MOVFF  8B6,F6A
0E944:  RRCF   F68,W
0E946:  BNC   E944
....................    spi_write2(DAC_LS_byte); 
0E948:  MOVF   F6A,W
0E94A:  MOVFF  8B7,F6A
0E94E:  RRCF   F68,W
0E950:  BNC   E94E
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0E952:  BSF    F8C.3
0E954:  MOVLB  0
0E956:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0E980:  MOVLB  8
0E982:  CLRF   xB6
0E984:  CLRF   xB7
0E986:  CLRF   xB8
0E988:  CLRF   xB9
0E98A:  CLRF   xBA
0E98C:  CLRF   xBB
0E98E:  CLRF   xBC
0E990:  CLRF   xBD
0E992:  CLRF   xBE
0E994:  CLRF   xBF
0E996:  CLRF   xC0
0E998:  CLRF   xC1
0E99A:  CLRF   xC2
0E99C:  CLRF   xC3
0E99E:  CLRF   xC4
0E9A0:  CLRF   xC5
0E9A2:  CLRF   xC6
0E9A4:  CLRF   xC7
0E9A6:  CLRF   xC8
0E9A8:  CLRF   xC9
0E9AA:  CLRF   xCA
0E9AC:  CLRF   xCB
0E9AE:  CLRF   xCC
0E9B0:  CLRF   xCD
0E9B2:  CLRF   xCE
0E9B4:  CLRF   xCF
0E9B6:  CLRF   xD0
0E9B8:  CLRF   xD1
0E9BA:  CLRF   xD2
0E9BC:  CLRF   xD3
0E9BE:  CLRF   xD4
0E9C0:  CLRF   xD5
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0E9C2:  CLRF   xD6
0E9C4:  CLRF   xD7
0E9C6:  CLRF   xD8
0E9C8:  CLRF   xD9
0E9CA:  CLRF   xDA
0E9CC:  CLRF   xDB
0E9CE:  CLRF   xDC
0E9D0:  CLRF   xDD
0E9D2:  CLRF   xDE
0E9D4:  CLRF   xDF
0E9D6:  CLRF   xE0
0E9D8:  CLRF   xE1
0E9DA:  CLRF   xE2
0E9DC:  CLRF   xE3
0E9DE:  CLRF   xE4
0E9E0:  CLRF   xE5
0E9E2:  CLRF   xE6
0E9E4:  CLRF   xE7
0E9E6:  CLRF   xE8
0E9E8:  CLRF   xE9
0E9EA:  CLRF   xEA
0E9EC:  CLRF   xEB
0E9EE:  CLRF   xEC
0E9F0:  CLRF   xED
0E9F2:  CLRF   xEE
0E9F4:  CLRF   xEF
0E9F6:  CLRF   xF0
0E9F8:  CLRF   xF1
0E9FA:  CLRF   xF2
0E9FC:  CLRF   xF3
0E9FE:  CLRF   xF4
0EA00:  CLRF   xF5
....................     
....................    for (j=1; j<(scans+1); ++j) 
0EA02:  CLRF   xB5
0EA04:  MOVLW  01
0EA06:  MOVWF  xB4
0EA08:  MOVLW  01
0EA0A:  ADDWF  xB1,W
0EA0C:  MOVWF  01
0EA0E:  MOVLW  00
0EA10:  ADDWFC xB2,W
0EA12:  MOVWF  03
0EA14:  MOVF   xB5,W
0EA16:  SUBWF  03,W
0EA18:  BNC   EAFE
0EA1A:  BNZ   EA22
0EA1C:  MOVF   01,W
0EA1E:  SUBWF  xB4,W
0EA20:  BC    EAFE
....................    { 
....................       for (n=1; n<5; ++n) 
0EA22:  MOVLW  01
0EA24:  MOVWF  xB3
0EA26:  MOVF   xB3,W
0EA28:  SUBLW  04
0EA2A:  BNC   EAF6
....................       { 
....................          set_adc_channel(n,VSS); 
0EA2C:  RLCF   xB3,W
0EA2E:  MOVWF  00
0EA30:  RLCF   00,F
0EA32:  MOVLW  FC
0EA34:  ANDWF  00,F
0EA36:  MOVF   FC2,W
0EA38:  ANDLW  83
0EA3A:  IORWF  00,W
0EA3C:  MOVWF  FC2
0EA3E:  MOVLW  00
0EA40:  MOVWF  01
0EA42:  MOVF   FC1,W
0EA44:  ANDLW  F8
0EA46:  IORWF  01,W
0EA48:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0EA4A:  MOVF   xB3,W
0EA4C:  MULLW  04
0EA4E:  MOVF   FF3,W
0EA50:  CLRF   03
0EA52:  ADDLW  D6
0EA54:  MOVWF  FE9
0EA56:  MOVLW  08
0EA58:  ADDWFC 03,W
0EA5A:  MOVWF  FEA
0EA5C:  BSF    FC2.1
0EA5E:  BTFSC  FC2.1
0EA60:  BRA    EA5E
0EA62:  MOVFF  FC3,FEF
0EA66:  MOVFF  FC4,FEC
0EA6A:  CLRF   FEC
0EA6C:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0EA6E:  MOVF   xB3,W
0EA70:  MULLW  04
0EA72:  MOVF   FF3,W
0EA74:  CLRF   03
0EA76:  ADDLW  B6
0EA78:  MOVWF  01
0EA7A:  MOVLW  08
0EA7C:  ADDWFC 03,F
0EA7E:  MOVFF  01,8F6
0EA82:  MOVFF  03,8F7
0EA86:  MOVF   xB3,W
0EA88:  MULLW  04
0EA8A:  MOVF   FF3,W
0EA8C:  CLRF   03
0EA8E:  ADDLW  B6
0EA90:  MOVWF  FE9
0EA92:  MOVLW  08
0EA94:  ADDWFC 03,W
0EA96:  MOVWF  FEA
0EA98:  MOVFF  FEF,8F8
0EA9C:  MOVFF  FEC,8F9
0EAA0:  MOVFF  FEC,8FA
0EAA4:  MOVFF  FEC,8FB
0EAA8:  MOVF   xB3,W
0EAAA:  MULLW  04
0EAAC:  MOVF   FF3,W
0EAAE:  CLRF   03
0EAB0:  ADDLW  D6
0EAB2:  MOVWF  FE9
0EAB4:  MOVLW  08
0EAB6:  ADDWFC 03,W
0EAB8:  MOVWF  FEA
0EABA:  MOVFF  FEF,00
0EABE:  MOVFF  FEC,01
0EAC2:  MOVFF  FEC,02
0EAC6:  MOVFF  FEC,03
0EACA:  MOVF   xF8,W
0EACC:  ADDWF  00,F
0EACE:  MOVF   xF9,W
0EAD0:  ADDWFC 01,F
0EAD2:  MOVF   xFA,W
0EAD4:  ADDWFC 02,F
0EAD6:  MOVF   xFB,W
0EAD8:  ADDWFC 03,F
0EADA:  MOVFF  8F7,FEA
0EADE:  MOVFF  8F6,FE9
0EAE2:  MOVFF  00,FEF
0EAE6:  MOVFF  01,FEC
0EAEA:  MOVFF  02,FEC
0EAEE:  MOVFF  03,FEC
0EAF2:  INCF   xB3,F
0EAF4:  BRA    EA26
....................       } 
0EAF6:  INCF   xB4,F
0EAF8:  BTFSC  FD8.2
0EAFA:  INCF   xB5,F
0EAFC:  BRA    EA08
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0EAFE:  MOVLW  01
0EB00:  MOVWF  xB3
0EB02:  MOVF   xB3,W
0EB04:  SUBLW  04
0EB06:  BNC   EB78
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0EB08:  BCF    FD8.0
0EB0A:  RLCF   xB3,W
0EB0C:  CLRF   03
0EB0E:  ADDLW  A5
0EB10:  MOVWF  01
0EB12:  MOVLW  04
0EB14:  ADDWFC 03,F
0EB16:  MOVFF  01,8F6
0EB1A:  MOVFF  03,8F7
0EB1E:  MOVF   xB3,W
0EB20:  MULLW  04
0EB22:  MOVF   FF3,W
0EB24:  CLRF   03
0EB26:  ADDLW  B6
0EB28:  MOVWF  FE9
0EB2A:  MOVLW  08
0EB2C:  ADDWFC 03,W
0EB2E:  MOVWF  FEA
0EB30:  MOVFF  FEF,A25
0EB34:  MOVFF  FEC,A26
0EB38:  MOVFF  FEC,A27
0EB3C:  MOVFF  FEC,A28
0EB40:  BCF    FD8.1
0EB42:  CLRF   1B
0EB44:  BTFSC  FF2.7
0EB46:  BSF    1B.7
0EB48:  BCF    FF2.7
0EB4A:  MOVLB  A
0EB4C:  CLRF   x2C
0EB4E:  CLRF   x2B
0EB50:  MOVFF  8B2,A2A
0EB54:  MOVFF  8B1,A29
0EB58:  MOVLB  0
0EB5A:  CALL   1080
0EB5E:  BTFSC  1B.7
0EB60:  BSF    FF2.7
0EB62:  MOVFF  8F7,FEA
0EB66:  MOVFF  8F6,FE9
0EB6A:  MOVFF  00,FEF
0EB6E:  MOVFF  01,FEC
0EB72:  MOVLB  8
0EB74:  INCF   xB3,F
0EB76:  BRA    EB02
....................    } 
0EB78:  MOVLB  0
0EB7A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    //Handle updating variables for the valve timeout 
....................    /*if(valve_align_timeout != -1){ 
....................       fprintf(COM_A,"align_var: %Ld \r\n",valve_align_timeout); 
....................       if(valve_align_timeout >= 2){ 
....................          valve_align_timeout = -1; 
....................          reset_cpu(); 
....................       } 
....................       valve_align_timeout++; 
....................    }*/ 
....................    //Service watchdog 
....................    output_bit(PIN_J7,(!input(PIN_J7))); 
*
00E3E:  BTFSS  F88.7
00E40:  BRA    0E46
00E42:  BCF    F91.7
00E44:  BRA    0E48
00E46:  BSF    F91.7
....................     
....................    rtc_alarm = TRUE; 
00E48:  BSF    4D.0
....................    sleep_mode = FALSE; 
00E4A:  BCF    4D.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E4C:  BTFSS  4D.2
00E4E:  BRA    0E52
....................    { 
....................       ; 
00E50:  BRA    0E4C
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E52:  BSF    4D.2
....................    RTC_read_flags(); 
00E54:  RCALL  0E02
....................    ++nv_elapsed; 
00E56:  INCF   35,F
00E58:  BTFSC  FD8.2
00E5A:  INCF   36,F
.................... } 
....................  
00E5C:  BCF    FF2.1
00E5E:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00EA2:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00EA4:  BTFSC  4D.1
00EA6:  BRA    0EF8
....................    { 
....................       if (kbhit(COM_A)) 
00EA8:  BTFSS  F9E.5
00EAA:  BRA    0EF6
....................       { 
....................          c = getc(COM_A); 
00EAC:  RCALL  0E62
00EAE:  MOVFF  01,A10
....................          switch (c) 
00EB2:  MOVLB  A
00EB4:  MOVF   x10,W
00EB6:  XORLW  3F
00EB8:  MOVLB  0
00EBA:  BZ    0EC6
00EBC:  XORLW  2E
00EBE:  BZ    0EEA
00EC0:  XORLW  0A
00EC2:  BZ    0EF0
00EC4:  BRA    0EF6
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00EC6:  DECFSZ 4E,W
00EC8:  BRA    0EDA
00ECA:  MOVLW  02
00ECC:  MOVWF  FF6
00ECE:  MOVLW  0F
00ED0:  MOVWF  FF7
00ED2:  MOVLW  00
00ED4:  MOVWF  FF8
00ED6:  RCALL  0E78
00ED8:  BRA    0EE8
....................                else fprintf(COM_A, "@RDY\r\n"); 
00EDA:  MOVLW  0A
00EDC:  MOVWF  FF6
00EDE:  MOVLW  0F
00EE0:  MOVWF  FF7
00EE2:  MOVLW  00
00EE4:  MOVWF  FF8
00EE6:  RCALL  0E78
....................                break; 
00EE8:  BRA    0EF6
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EEA:  MOVLW  01
00EEC:  MOVWF  50
....................                break;          
00EEE:  BRA    0EF6
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EF0:  CLRF   32
00EF2:  MOVLW  01
00EF4:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00EF6:  BRA    0EFC
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00EF8:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00EFA:  BCF    F9E.5
....................    } 
00EFC:  BCF    F9E.5
00EFE:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0AE16:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0AE18:  MOVF   FAE,W
....................    busy_status = FALSE; 
0AE1A:  CLRF   4E
0AE1C:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
0299E:  MOVLW  01
029A0:  MOVWF  4E
....................    clear_interrupt(INT_RDA); 
029A2:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
029A4:  BSF    F9D.5
029A6:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00F12:  MOVLW  0B
00F14:  MOVWF  FD7
00F16:  MOVLW  DC
00F18:  MOVWF  FD6
....................    restart_wdt(); 
00F1A:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00F1C:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00F1E:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00F20:  CLRF   FCF
00F22:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00F24:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00F26:  MOVF   2F,W
00F28:  SUBLW  02
00F2A:  BNZ   0F32
00F2C:  MOVF   30,F
00F2E:  BNZ   0F32
00F30:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00F32:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00F34:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00F36:  BCF    FF2.2
00F38:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00F3C:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00F3E:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00F40:  MOVF   2F,W
00F42:  SUBLW  02
00F44:  BNZ   0F4C
00F46:  MOVF   30,F
00F48:  BNZ   0F4C
00F4A:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F4C:  BCF    F9E.0
00F4E:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
0B026:  MOVLB  8
0B028:  CLRF   x6B
0B02A:  CLRF   x6F
0B02C:  CLRF   x6E
0B02E:  CLRF   x6D
0B030:  CLRF   x6C
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
0B032:  MOVLW  01
0B034:  ADDWF  x6C,F
0B036:  BTFSC  FD8.0
0B038:  INCF   x6D,F
0B03A:  BTFSC  FD8.2
0B03C:  INCF   x6E,F
0B03E:  BTFSC  FD8.2
0B040:  INCF   x6F,F
0B042:  MOVF   x6F,F
0B044:  BNZ   B084
0B046:  MOVF   x6E,W
0B048:  SUBLW  04
0B04A:  BNC   B084
0B04C:  BNZ   B05C
0B04E:  MOVF   x6D,W
0B050:  SUBLW  93
0B052:  BNC   B084
0B054:  BNZ   B05C
0B056:  MOVF   x6C,W
0B058:  SUBLW  DF
0B05A:  BNC   B084
....................    { 
....................       if(kbhit(COM_A)) 
0B05C:  BTFSS  F9E.5
0B05E:  BRA    B07A
....................       { 
....................          c = fgetc(COM_A); 
0B060:  MOVLB  0
0B062:  CALL   0E62
0B066:  MOVFF  01,86B
....................          if (com_echo == TRUE) 
0B06A:  DECFSZ 4C,W
0B06C:  BRA    B076
....................          { 
....................             fputc(c, COM_A); 
0B06E:  MOVLB  8
0B070:  MOVF   x6B,W
0B072:  MOVLB  0
0B074:  RCALL  AE1E
....................          } 
....................          break; 
0B076:  MOVLB  8
0B078:  BRA    B084
....................       } 
....................  
....................       delay_us(10); 
0B07A:  MOVLW  35
0B07C:  MOVWF  00
0B07E:  DECFSZ 00,F
0B080:  BRA    B07E
0B082:  BRA    B032
....................    } 
....................  
....................    return(c); 
0B084:  MOVFF  86B,01
0B088:  MOVLB  0
0B08A:  GOTO   B09A (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AD90:  MOVLW  58
0AD92:  MOVLB  8
0AD94:  MOVWF  x64
0AD96:  CLRF   x68
0AD98:  CLRF   x67
0AD9A:  CLRF   x66
0AD9C:  CLRF   x65
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AD9E:  MOVLW  01
0ADA0:  ADDWF  x65,F
0ADA2:  BTFSC  FD8.0
0ADA4:  INCF   x66,F
0ADA6:  BTFSC  FD8.2
0ADA8:  INCF   x67,F
0ADAA:  BTFSC  FD8.2
0ADAC:  INCF   x68,F
0ADAE:  MOVF   x68,F
0ADB0:  BNZ   ADE0
0ADB2:  MOVF   x67,F
0ADB4:  BNZ   ADE0
0ADB6:  MOVF   x66,W
0ADB8:  SUBLW  C3
0ADBA:  BNC   ADE0
0ADBC:  BNZ   ADC4
0ADBE:  MOVF   x65,W
0ADC0:  SUBLW  4F
0ADC2:  BNC   ADE0
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0ADC4:  MOVLW  05
0ADC6:  MOVWF  00
0ADC8:  DECFSZ 00,F
0ADCA:  BRA    ADC8
....................  
....................       if(kbhit()) 
0ADCC:  BTFSS  F9E.5
0ADCE:  BRA    ADDE
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0ADD0:  MOVLB  0
0ADD2:  CALL   0E62
0ADD6:  MOVFF  01,864
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0ADDA:  MOVLB  8
0ADDC:  BRA    ADE0
....................       } 
0ADDE:  BRA    AD9E
....................    } 
....................  
....................    return(EscChar); 
0ADE0:  MOVFF  864,01
0ADE4:  MOVLB  0
0ADE6:  GOTO   14D82 (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0E536:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0E538:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0E53A:  BSF    F8F.3
....................    delay_ms(10); 
0E53C:  MOVLW  0A
0E53E:  MOVLB  A
0E540:  MOVWF  xA2
0E542:  MOVLB  0
0E544:  CALL   0588
0E548:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0E6CE:  MOVLB  8
0E6D0:  CLRF   xD2
0E6D2:  CLRF   xD1
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0E6D4:  MOVLB  F
0E6D6:  BTFSC  x21.1
0E6D8:  BRA    E6E6
....................       ++c; 
0E6DA:  MOVLB  8
0E6DC:  INCF   xD1,F
0E6DE:  BTFSC  FD8.2
0E6E0:  INCF   xD2,F
0E6E2:  BRA    E6D4
0E6E4:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0E6E6:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0E6E8:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0E6EA:  BCF    F8F.3
0E6EC:  MOVLB  0
0E6EE:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
....................    output_low(MD2_TXEN);      // Tx disable 
.................... } 
....................  
....................  
.................... void open_pipe() 
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
....................  
....................    while (charFromB != EOT) 
....................    { 
....................        if (kbhit(COM_A)) 
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
....................           if (com_echo == TRUE) 
....................           { 
....................              fputc(charFromA, COM_A); 
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
....................              if (CARRIAGE_RET == charFromA) 
....................              { 
....................                 multidrop_on(); 
....................                 for (index = 0 ; index < charCount; index++) 
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
....................                 } 
....................                 charCount = 0; 
....................                 multidrop_off(); 
....................              } 
....................           } 
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
....................              charCount = 0; 
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
....................           fputc(charFromB, COM_A);                  // send data via USART 
....................        } 
....................    } 
....................  
....................    multidrop_shdn(); 
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           putc(c); 
....................           putc(' '); 
....................           putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          putc(c); 
....................        } 
....................    } while(c != CARRIAGE_RET); 
....................    s[len]=0; 
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
02916:  MOVLW  2F
02918:  MOVWF  F92
....................    set_tris_b(0b00110111); 
0291A:  MOVLW  37
0291C:  MOVWF  F93
....................    set_tris_c(0b10010000); 
0291E:  MOVLW  90
02920:  MOVWF  F94
....................    set_tris_d(0b00100000); 
02922:  MOVLW  20
02924:  MOVWF  F95
....................    set_tris_e(0b01000000); 
02926:  MOVLW  40
02928:  MOVWF  F96
....................    set_tris_f(0b00000000); 
0292A:  MOVLW  00
0292C:  MOVWF  F97
....................    set_tris_g(0b11100100); 
0292E:  MOVLW  E4
02930:  MOVWF  F98
....................    set_tris_h(0b01000000); 
02932:  MOVLW  40
02934:  MOVWF  F99
....................    set_tris_j(0b00000000); 
02936:  MOVLW  00
02938:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
0293A:  BCF    F8E.3
....................    output_low(HB_IN1); 
0293C:  BCF    F8E.4
....................    output_low(HB_IN2); 
0293E:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
02940:  BCF    F91.3
....................    output_high(EEP_CS);        
02942:  BSF    F91.2
....................    output_high(RTC_CS); 
02944:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
02946:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
02948:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
0294A:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
0294C:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
0294E:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
02950:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
02952:  BCF    F8F.3
....................    delay_ms(20);   
02954:  MOVLW  14
02956:  MOVLB  A
02958:  MOVWF  xA2
0295A:  MOVLB  0
0295C:  CALL   0588
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
02960:  BCF    F8E.1
....................    output_low(VDET);     
02962:  BCF    F90.7
....................    bus_pwr_status=0; 
02964:  MOVLB  4
02966:  CLRF   xB6
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
02968:  BSF    F8C.2
....................    output_high(DAC_CS); 
0296A:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
0296C:  BCF    F8C.0
....................    output_low(HSW2); 
0296E:  BCF    F8C.1
....................    heater_stat=0; 
02970:  CLRF   xB5
02972:  MOVLB  0
02974:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
0AF54:  BSF    F91.1
....................    output_low(EEP_WP);        
0AF56:  BCF    F91.3
....................    output_high(EEP_CS);        
0AF58:  BSF    F91.2
....................    output_high(RTC_CS);  
0AF5A:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
0AF5C:  BCF    F8E.3
....................    output_low(HB_IN1);        
0AF5E:  BCF    F8E.4
....................    output_low(HB_IN2); 
0AF60:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
0AF62:  BCF    F8C.2
....................    output_low(DAC_CS); 
0AF64:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
0AF66:  BCF    F8C.0
....................    output_low(HSW2); 
0AF68:  BCF    F8C.1
....................    heater_stat=0; 
0AF6A:  MOVLB  4
0AF6C:  CLRF   xB5
....................    // Power switches 
....................    output_low(VMOT);         
0AF6E:  BCF    F8E.1
....................    output_low(VDET);  
0AF70:  BCF    F90.7
....................    bus_pwr_status=0; 
0AF72:  CLRF   xB6
....................    output_low(VENC1);         
0AF74:  BCF    F8E.6
....................    output_low(VENC2);         
0AF76:  BCF    F8E.7
....................    output_low(VHBRDG);  
0AF78:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
0AF7A:  MOVLW  72
0AF7C:  MOVWF  FF6
0AF7E:  MOVLW  0F
0AF80:  MOVWF  FF7
0AF82:  MOVLW  00
0AF84:  MOVWF  FF8
0AF86:  CLRF   1B
0AF88:  BTFSC  FF2.7
0AF8A:  BSF    1B.7
0AF8C:  BCF    FF2.7
0AF8E:  MOVLB  0
0AF90:  CALL   0E78
0AF94:  BTFSC  1B.7
0AF96:  BSF    FF2.7
....................    delay_ms(50); 
0AF98:  MOVLW  32
0AF9A:  MOVLB  A
0AF9C:  MOVWF  xA2
0AF9E:  MOVLB  0
0AFA0:  CALL   0588
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
0AFA4:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
0AFA6:  BSF    F91.6
....................    output_low(MD1_TXEN); 
0AFA8:  BCF    F91.5
....................    output_low(MD2_SHDN);    
0AFAA:  BCF    F8F.0
....................    output_low(MD2_REN); 
0AFAC:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
0AFAE:  BCF    F8F.3
....................  
....................    delay_ms(30); 
0AFB0:  MOVLW  1E
0AFB2:  MOVLB  A
0AFB4:  MOVWF  xA2
0AFB6:  MOVLB  0
0AFB8:  CALL   0588
0AFBC:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
05014:  MOVLB  8
05016:  CLRF   x68
05018:  MOVF   x68,W
0501A:  SUBLW  02
0501C:  BNC   5042
....................       FS_Status = f_mountdrv(); 
0501E:  MOVLB  0
05020:  RCALL  4830
05022:  MOVFF  01,724
....................       if (FS_Status) 
05026:  MOVLB  7
05028:  MOVF   x24,F
0502A:  BZ    5036
....................          { 
....................          display_file_result(FS_Status); 
0502C:  MOVFF  724,869
05030:  MOVLB  0
05032:  BRA    4DCE
....................          } 
05034:  BRA    503C
....................       else break; 
05036:  MOVLB  8
05038:  BRA    5042
0503A:  MOVLB  0
0503C:  MOVLB  8
0503E:  INCF   x68,F
05040:  BRA    5018
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
05042:  MOVLW  3E
05044:  MOVWF  xCC
05046:  CLRF   xCE
05048:  MOVFF  724,8CD
0504C:  MOVLB  0
0504E:  RCALL  4FAE
....................     
....................    return(FS_Status); 
05050:  MOVLB  7
05052:  MOVFF  724,01
05056:  MOVLB  0
05058:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
030DE:  MOVLW  01
030E0:  MOVLB  8
030E2:  MOVWF  x64
030E4:  MOVF   x64,W
030E6:  SUBLW  03
030E8:  BNC   3124
....................    { 
....................       output_bit(BOARD_LED, ON); 
030EA:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
030EC:  MOVF   2F,W
030EE:  SUBLW  02
030F0:  BNZ   30F8
030F2:  MOVF   30,F
030F4:  BNZ   30F8
030F6:  BSF    F90.6
....................       delay_ms(32); 
030F8:  MOVLW  20
030FA:  MOVLB  A
030FC:  MOVWF  xA2
030FE:  MOVLB  0
03100:  CALL   0588
....................       output_bit(BOARD_LED, OFF); 
03104:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
03106:  MOVF   2F,W
03108:  SUBLW  02
0310A:  BNZ   3112
0310C:  MOVF   30,F
0310E:  BNZ   3112
03110:  BCF    F90.6
....................       delay_ms(32); 
03112:  MOVLW  20
03114:  MOVLB  A
03116:  MOVWF  xA2
03118:  MOVLB  0
0311A:  CALL   0588
0311E:  MOVLB  8
03120:  INCF   x64,F
03122:  BRA    30E4
....................    } 
03124:  MOVLB  0
03126:  GOTO   14B82 (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
050D6:  MOVLB  8
050D8:  CLRF   xD1
050DA:  CLRF   xD0
050DC:  CLRF   xCF
050DE:  CLRF   xCE
....................    set_adc_channel(0,VSS); 
050E0:  MOVLW  00
050E2:  MOVWF  01
050E4:  MOVF   FC2,W
050E6:  ANDLW  83
050E8:  IORWF  01,W
050EA:  MOVWF  FC2
050EC:  MOVLW  00
050EE:  MOVWF  01
050F0:  MOVF   FC1,W
050F2:  ANDLW  F8
050F4:  IORWF  01,W
050F6:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
050F8:  MOVLW  01
050FA:  MOVWF  xCB
050FC:  MOVF   xCB,W
050FE:  SUBLW  32
05100:  BNC   5126
....................       reading=read_adc(); 
05102:  BSF    FC2.1
05104:  BTFSC  FC2.1
05106:  BRA    5104
05108:  MOVFF  FC3,8D2
0510C:  MOVFF  FC4,8D3
05110:  CLRF   xD4
05112:  CLRF   xD5
....................       delay_ms(5); 
05114:  MOVLW  05
05116:  MOVLB  A
05118:  MOVWF  xA2
0511A:  MOVLB  0
0511C:  CALL   0588
05120:  MOVLB  8
05122:  INCF   xCB,F
05124:  BRA    50FC
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
05126:  MOVLW  01
05128:  MOVWF  xCB
0512A:  MOVF   xCB,W
0512C:  SUBLW  64
0512E:  BNC   51DC
....................       reading=read_adc(); 
05130:  BSF    FC2.1
05132:  BTFSC  FC2.1
05134:  BRA    5132
05136:  MOVFF  FC3,8D2
0513A:  MOVFF  FC4,8D3
0513E:  CLRF   xD4
05140:  CLRF   xD5
....................       result=(((result*(i-1))+reading)/i); 
05142:  MOVLW  01
05144:  SUBWF  xCB,W
05146:  MOVWF  xD6
05148:  MOVFF  8D1,9D7
0514C:  MOVFF  8D0,9D6
05150:  MOVFF  8CF,9D5
05154:  MOVFF  8CE,9D4
05158:  MOVLB  9
0515A:  CLRF   xDB
0515C:  CLRF   xDA
0515E:  CLRF   xD9
05160:  MOVWF  xD8
05162:  MOVLB  0
05164:  CALL   47D4
05168:  MOVFF  03,8D9
0516C:  MOVFF  02,8D8
05170:  MOVFF  01,8D7
05174:  MOVFF  00,8D6
05178:  MOVLB  8
0517A:  MOVF   xD2,W
0517C:  ADDWF  xD6,F
0517E:  MOVF   xD3,W
05180:  ADDWFC xD7,F
05182:  MOVF   xD4,W
05184:  ADDWFC xD8,F
05186:  MOVF   xD5,W
05188:  ADDWFC xD9,F
0518A:  BCF    FD8.1
0518C:  CLRF   1B
0518E:  BTFSC  FF2.7
05190:  BSF    1B.7
05192:  BCF    FF2.7
05194:  MOVFF  8D9,A28
05198:  MOVFF  8D8,A27
0519C:  MOVFF  8D7,A26
051A0:  MOVFF  8D6,A25
051A4:  MOVLB  A
051A6:  CLRF   x2C
051A8:  CLRF   x2B
051AA:  CLRF   x2A
051AC:  MOVFF  8CB,A29
051B0:  MOVLB  0
051B2:  CALL   1080
051B6:  BTFSC  1B.7
051B8:  BSF    FF2.7
051BA:  MOVFF  03,8D1
051BE:  MOVFF  02,8D0
051C2:  MOVFF  01,8CF
051C6:  MOVFF  00,8CE
....................       delay_ms(5); 
051CA:  MOVLW  05
051CC:  MOVLB  A
051CE:  MOVWF  xA2
051D0:  MOVLB  0
051D2:  CALL   0588
051D6:  MOVLB  8
051D8:  INCF   xCB,F
051DA:  BRA    512A
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
051DC:  MOVFF  8D1,9D7
051E0:  MOVFF  8D0,9D6
051E4:  MOVFF  8CF,9D5
051E8:  MOVFF  8CE,9D4
051EC:  MOVLB  9
051EE:  CLRF   xDB
051F0:  CLRF   xDA
051F2:  CLRF   xD9
051F4:  MOVLW  64
051F6:  MOVWF  xD8
051F8:  MOVLB  0
051FA:  CALL   47D4
051FE:  MOVFF  03,8D9
05202:  MOVFF  02,8D8
05206:  MOVFF  01,8D7
0520A:  MOVFF  00,8D6
0520E:  BCF    FD8.1
05210:  CLRF   1B
05212:  BTFSC  FF2.7
05214:  BSF    1B.7
05216:  BCF    FF2.7
05218:  MOVFF  03,A28
0521C:  MOVFF  02,A27
05220:  MOVFF  01,A26
05224:  MOVFF  00,A25
05228:  MOVLB  A
0522A:  CLRF   x2C
0522C:  CLRF   x2B
0522E:  MOVLW  01
05230:  MOVWF  x2A
05232:  MOVLW  10
05234:  MOVWF  x29
05236:  MOVLB  0
05238:  CALL   1080
0523C:  BTFSC  1B.7
0523E:  BSF    FF2.7
05240:  MOVLW  56
05242:  MOVLB  8
05244:  ADDWF  00,W
05246:  MOVWF  xCC
05248:  MOVLW  00
0524A:  ADDWFC 01,W
0524C:  MOVWF  xCD
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
0524E:  MOVFF  8CC,01
05252:  MOVFF  8CD,02
05256:  MOVLB  0
05258:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
050C0:  MOVLW  02
050C2:  MOVWF  FEA
050C4:  MOVLW  99
050C6:  MOVWF  FE9
050C8:  CLRF   00
050CA:  CLRF   02
050CC:  MOVLW  1E
050CE:  MOVWF  01
050D0:  CALL   350A
050D4:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
0F212:  MOVLW  02
0F214:  MOVWF  FEA
0F216:  MOVLW  B7
0F218:  MOVWF  FE9
0F21A:  CLRF   00
0F21C:  CLRF   02
0F21E:  MOVLW  1E
0F220:  MOVWF  01
0F222:  CALL   350A
0F226:  GOTO   FABC (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
053F4:  RCALL  50C0
....................     
....................    v_supply = read_supply(); 
053F6:  RCALL  50D6
053F8:  MOVFF  02,8CA
053FC:  MOVFF  01,8C9
....................    RTC_read(); 
05400:  CALL   3328
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
05404:  MOVLW  02
05406:  MOVWF  1E
05408:  MOVLW  99
0540A:  MOVWF  1D
0540C:  MOVFF  72A,8CB
05410:  MOVLW  01
05412:  MOVLB  8
05414:  MOVWF  xCC
05416:  MOVLB  0
05418:  RCALL  525A
0541A:  MOVLW  2F
0541C:  MOVLB  8
0541E:  MOVWF  xDD
05420:  MOVLB  0
05422:  RCALL  5078
05424:  MOVFF  729,8CB
05428:  MOVLW  01
0542A:  MOVLB  8
0542C:  MOVWF  xCC
0542E:  MOVLB  0
05430:  RCALL  525A
05432:  MOVLW  2F
05434:  MOVLB  8
05436:  MOVWF  xDD
05438:  MOVLB  0
0543A:  RCALL  5078
0543C:  MOVFF  72B,8CB
05440:  MOVLW  01
05442:  MOVLB  8
05444:  MOVWF  xCC
05446:  MOVLB  0
05448:  RCALL  525A
0544A:  MOVLW  20
0544C:  MOVLB  8
0544E:  MOVWF  xDD
05450:  MOVLB  0
05452:  RCALL  5078
05454:  MOVFF  727,8CB
05458:  MOVLW  01
0545A:  MOVLB  8
0545C:  MOVWF  xCC
0545E:  MOVLB  0
05460:  RCALL  525A
05462:  MOVLW  3A
05464:  MOVLB  8
05466:  MOVWF  xDD
05468:  MOVLB  0
0546A:  RCALL  5078
0546C:  MOVFF  726,8CB
05470:  MOVLW  01
05472:  MOVLB  8
05474:  MOVWF  xCC
05476:  MOVLB  0
05478:  RCALL  525A
0547A:  MOVLW  3A
0547C:  MOVLB  8
0547E:  MOVWF  xDD
05480:  MOVLB  0
05482:  RCALL  5078
05484:  MOVFF  725,8CB
05488:  MOVLW  01
0548A:  MOVLB  8
0548C:  MOVWF  xCC
0548E:  MOVLB  0
05490:  RCALL  525A
05492:  MOVLW  2C
05494:  MOVLB  8
05496:  MOVWF  xDD
05498:  MOVLB  0
0549A:  RCALL  5078
0549C:  MOVLW  44
0549E:  MOVWF  FE9
054A0:  MOVLB  8
054A2:  CLRF   xCE
054A4:  CLRF   xCD
054A6:  MOVFF  8CA,8CC
054AA:  MOVFF  8C9,8CB
054AE:  MOVLW  02
054B0:  MOVWF  xCF
054B2:  MOVLB  0
054B4:  RCALL  52F4
054B6:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
0847A:  MOVLB  2
0847C:  MOVF   xDC,F
0847E:  BNZ   84FA
....................    { 
....................       strcopy(event_buffer,""); 
08480:  MOVLW  01
08482:  MOVWF  FEA
08484:  MOVLW  07
08486:  MOVWF  FE9
08488:  MOVLW  00
0848A:  MOVLB  0
0848C:  CALL   02CE
08490:  TBLRD*-
08492:  TBLRD*+
08494:  MOVF   FF5,W
08496:  MOVWF  FEE
08498:  IORLW  00
0849A:  BNZ   8492
....................       time_stamp(); 
0849C:  CALL   53F4
....................       strcat(event_buffer, time_stmp_str); 
084A0:  MOVLW  01
084A2:  MOVLB  8
084A4:  MOVWF  xD7
084A6:  MOVLW  07
084A8:  MOVWF  xD6
084AA:  MOVLW  02
084AC:  MOVWF  xD9
084AE:  MOVLW  99
084B0:  MOVWF  xD8
084B2:  MOVLB  0
084B4:  CALL   54B8
....................       strcat(event_buffer, event_str); 
084B8:  MOVLW  01
084BA:  MOVLB  8
084BC:  MOVWF  xD7
084BE:  MOVLW  07
084C0:  MOVWF  xD6
084C2:  MOVLW  01
084C4:  MOVWF  xD9
084C6:  MOVLW  A7
084C8:  MOVWF  xD8
084CA:  MOVLB  0
084CC:  CALL   54B8
....................       buffer_select = 1; 
084D0:  MOVLW  01
084D2:  MOVWF  x66
....................     
....................       heartbeat(FALSE); 
084D4:  MOVLB  8
084D6:  CLRF   xCB
084D8:  MOVLB  0
084DA:  CALL   555C
....................          append_data(file_ptr_events); 
084DE:  MOVLW  03
084E0:  MOVLB  8
084E2:  MOVWF  xCC
084E4:  MOVLW  15
084E6:  MOVWF  xCB
084E8:  MOVLB  0
084EA:  RCALL  8298
....................       heartbeat(TRUE); 
084EC:  MOVLW  01
084EE:  MOVLB  8
084F0:  MOVWF  xCB
084F2:  MOVLB  0
084F4:  CALL   555C
084F8:  MOVLB  2
....................    } 
084FA:  MOVLB  0
084FC:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
028CA:  BCF    F8B.2
028CC:  MOVLW  0C
028CE:  MOVWF  FBB
028D0:  CLRF   FBE
028D2:  CLRF   FBF
028D4:  MOVLW  01
028D6:  MOVWF  F9C
028D8:  MOVLW  F8
028DA:  MOVLB  F
028DC:  ANDWF  x2D,F
028DE:  MOVLW  00
028E0:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
028E2:  BCF    F8B.1
028E4:  MOVLW  0C
028E6:  MOVWF  x4E
028E8:  CLRF   x51
028EA:  CLRF   x52
028EC:  MOVLW  01
028EE:  MOVWF  x1B
028F0:  MOVLW  C7
028F2:  ANDWF  x2D,F
028F4:  MOVLW  00
028F6:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
028F8:  IORLW  05
028FA:  MOVWF  FCA
028FC:  MOVLW  7F
028FE:  MOVWF  FCB
02900:  MOVLB  0
02902:  GOTO   14B38 (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09CA2:  MOVLW  7C
09CA4:  MOVWF  FF6
09CA6:  MOVLW  0F
09CA8:  MOVWF  FF7
09CAA:  MOVLW  00
09CAC:  MOVWF  FF8
09CAE:  CLRF   1B
09CB0:  BTFSC  FF2.7
09CB2:  BSF    1B.7
09CB4:  BCF    FF2.7
09CB6:  MOVLW  05
09CB8:  MOVLB  A
09CBA:  MOVWF  x19
09CBC:  MOVLB  0
09CBE:  CALL   104E
09CC2:  BTFSC  1B.7
09CC4:  BSF    FF2.7
09CC6:  MOVLW  10
09CC8:  MOVWF  FE9
09CCA:  CLRF   1B
09CCC:  BTFSC  FF2.7
09CCE:  BSF    1B.7
09CD0:  BCF    FF2.7
09CD2:  MOVFF  797,A1A
09CD6:  MOVFF  796,A19
09CDA:  CALL   11D0
09CDE:  BTFSC  1B.7
09CE0:  BSF    FF2.7
09CE2:  MOVLW  2C
09CE4:  BTFSS  F9E.4
09CE6:  BRA    9CE4
09CE8:  MOVWF  FAD
09CEA:  MOVLW  10
09CEC:  MOVWF  FE9
09CEE:  CLRF   1B
09CF0:  BTFSC  FF2.7
09CF2:  BSF    1B.7
09CF4:  BCF    FF2.7
09CF6:  MOVFF  799,A1A
09CFA:  MOVFF  798,A19
09CFE:  CALL   11D0
09D02:  BTFSC  1B.7
09D04:  BSF    FF2.7
09D06:  MOVLW  0D
09D08:  BTFSS  F9E.4
09D0A:  BRA    9D08
09D0C:  MOVWF  FAD
09D0E:  MOVLW  0A
09D10:  BTFSS  F9E.4
09D12:  BRA    9D10
09D14:  MOVWF  FAD
09D16:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02CFA:  MOVLW  86
02CFC:  MOVLB  8
02CFE:  MOVWF  x72
02D00:  MOVLB  0
02D02:  RCALL  29A8
02D04:  MOVFF  02,743
02D08:  MOVFF  01,742
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02D0C:  MOVLW  8A
02D0E:  MOVLB  8
02D10:  MOVWF  x72
02D12:  MOVLB  0
02D14:  RCALL  29A8
02D16:  MOVFF  02,747
02D1A:  MOVFF  01,746
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02D1E:  MOVLW  8E
02D20:  MOVLB  8
02D22:  MOVWF  x72
02D24:  MOVLB  0
02D26:  RCALL  29A8
02D28:  MOVFF  02,74B
02D2C:  MOVFF  01,74A
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02D30:  MOVLW  92
02D32:  MOVLB  8
02D34:  MOVWF  x72
02D36:  MOVLB  0
02D38:  RCALL  29A8
02D3A:  MOVFF  02,74F
02D3E:  MOVFF  01,74E
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02D42:  MOVLW  96
02D44:  MOVLB  8
02D46:  MOVWF  x72
02D48:  MOVLB  0
02D4A:  RCALL  29A8
02D4C:  MOVFF  02,753
02D50:  MOVFF  01,752
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02D54:  MOVLW  9A
02D56:  MOVLB  8
02D58:  MOVWF  x72
02D5A:  MOVLB  0
02D5C:  RCALL  29A8
02D5E:  MOVFF  02,757
02D62:  MOVFF  01,756
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02D66:  MOVLW  9E
02D68:  MOVLB  8
02D6A:  MOVWF  x72
02D6C:  MOVLB  0
02D6E:  RCALL  29A8
02D70:  MOVFF  02,75B
02D74:  MOVFF  01,75A
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02D78:  MOVLW  A2
02D7A:  MOVLB  8
02D7C:  MOVWF  x72
02D7E:  MOVLB  0
02D80:  RCALL  29A8
02D82:  MOVFF  02,75F
02D86:  MOVFF  01,75E
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02D8A:  MOVLW  A6
02D8C:  MOVLB  8
02D8E:  MOVWF  x72
02D90:  MOVLB  0
02D92:  RCALL  29A8
02D94:  MOVFF  02,763
02D98:  MOVFF  01,762
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02D9C:  MOVLW  82
02D9E:  MOVLB  8
02DA0:  MOVWF  x72
02DA2:  MOVLB  0
02DA4:  RCALL  29A8
02DA6:  MOVFF  02,767
02DAA:  MOVFF  01,766
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02DAE:  MOVLW  7E
02DB0:  MOVLB  8
02DB2:  MOVWF  x72
02DB4:  MOVLB  0
02DB6:  RCALL  29A8
02DB8:  MOVFF  02,7C0
02DBC:  MOVFF  01,7BF
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02DC0:  MOVLW  AA
02DC2:  MOVLB  8
02DC4:  MOVWF  x72
02DC6:  MOVLB  0
02DC8:  RCALL  29A8
02DCA:  MOVFF  02,7C4
02DCE:  MOVFF  01,7C3
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02DD2:  MOVLW  7A
02DD4:  MOVLB  8
02DD6:  MOVWF  x72
02DD8:  MOVLB  0
02DDA:  RCALL  29A8
02DDC:  MOVFF  02,76B
02DE0:  MOVFF  01,76A
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02DE4:  MOVLW  76
02DE6:  MOVLB  8
02DE8:  MOVWF  x72
02DEA:  MOVLB  0
02DEC:  RCALL  29A8
02DEE:  MOVFF  02,76F
02DF2:  MOVFF  01,76E
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02DF6:  MOVLW  72
02DF8:  MOVLB  8
02DFA:  MOVWF  x72
02DFC:  MOVLB  0
02DFE:  RCALL  29A8
02E00:  MOVFF  02,773
02E04:  MOVFF  01,772
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02E08:  MOVLW  6E
02E0A:  MOVLB  8
02E0C:  MOVWF  x72
02E0E:  MOVLB  0
02E10:  RCALL  29A8
02E12:  MOVFF  02,797
02E16:  MOVFF  01,796
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02E1A:  MOVLW  AE
02E1C:  MOVLB  8
02E1E:  MOVWF  x72
02E20:  MOVLB  0
02E22:  RCALL  29A8
02E24:  MOVFF  02,777
02E28:  MOVFF  01,776
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02E2C:  MOVLW  B2
02E2E:  MOVLB  8
02E30:  MOVWF  x72
02E32:  MOVLB  0
02E34:  RCALL  29A8
02E36:  MOVFF  02,7B0
02E3A:  MOVFF  01,7AF
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02E3E:  MOVLW  B6
02E40:  MOVLB  8
02E42:  MOVWF  x72
02E44:  MOVLB  0
02E46:  RCALL  29A8
02E48:  MOVFF  02,7B4
02E4C:  MOVFF  01,7B3
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02E50:  MOVLW  BA
02E52:  MOVLB  8
02E54:  MOVWF  x72
02E56:  MOVLB  0
02E58:  RCALL  29A8
02E5A:  MOVFF  02,77B
02E5E:  MOVFF  01,77A
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02E62:  MOVLW  BE
02E64:  MOVLB  8
02E66:  MOVWF  x72
02E68:  MOVLB  0
02E6A:  RCALL  29A8
02E6C:  MOVFF  02,77F
02E70:  MOVFF  01,77E
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02E74:  MOVLW  C2
02E76:  MOVLB  8
02E78:  MOVWF  x72
02E7A:  MOVLB  0
02E7C:  RCALL  29A8
02E7E:  MOVFF  02,783
02E82:  MOVFF  01,782
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02E86:  MOVLW  88
02E88:  MOVLB  8
02E8A:  MOVWF  x72
02E8C:  MOVLB  0
02E8E:  RCALL  29A8
02E90:  MOVFF  02,745
02E94:  MOVFF  01,744
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02E98:  MOVLW  8C
02E9A:  MOVLB  8
02E9C:  MOVWF  x72
02E9E:  MOVLB  0
02EA0:  RCALL  29A8
02EA2:  MOVFF  02,749
02EA6:  MOVFF  01,748
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02EAA:  MOVLW  90
02EAC:  MOVLB  8
02EAE:  MOVWF  x72
02EB0:  MOVLB  0
02EB2:  RCALL  29A8
02EB4:  MOVFF  02,74D
02EB8:  MOVFF  01,74C
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02EBC:  MOVLW  94
02EBE:  MOVLB  8
02EC0:  MOVWF  x72
02EC2:  MOVLB  0
02EC4:  RCALL  29A8
02EC6:  MOVFF  02,751
02ECA:  MOVFF  01,750
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02ECE:  MOVLW  98
02ED0:  MOVLB  8
02ED2:  MOVWF  x72
02ED4:  MOVLB  0
02ED6:  RCALL  29A8
02ED8:  MOVFF  02,755
02EDC:  MOVFF  01,754
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02EE0:  MOVLW  9C
02EE2:  MOVLB  8
02EE4:  MOVWF  x72
02EE6:  MOVLB  0
02EE8:  RCALL  29A8
02EEA:  MOVFF  02,759
02EEE:  MOVFF  01,758
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02EF2:  MOVLW  A0
02EF4:  MOVLB  8
02EF6:  MOVWF  x72
02EF8:  MOVLB  0
02EFA:  RCALL  29A8
02EFC:  MOVFF  02,75D
02F00:  MOVFF  01,75C
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02F04:  MOVLW  A4
02F06:  MOVLB  8
02F08:  MOVWF  x72
02F0A:  MOVLB  0
02F0C:  RCALL  29A8
02F0E:  MOVFF  02,761
02F12:  MOVFF  01,760
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02F16:  MOVLW  A8
02F18:  MOVLB  8
02F1A:  MOVWF  x72
02F1C:  MOVLB  0
02F1E:  RCALL  29A8
02F20:  MOVFF  02,765
02F24:  MOVFF  01,764
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02F28:  MOVLW  84
02F2A:  MOVLB  8
02F2C:  MOVWF  x72
02F2E:  MOVLB  0
02F30:  RCALL  29A8
02F32:  MOVFF  02,769
02F36:  MOVFF  01,768
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02F3A:  MOVLW  80
02F3C:  MOVLB  8
02F3E:  MOVWF  x72
02F40:  MOVLB  0
02F42:  RCALL  29A8
02F44:  MOVFF  02,7C2
02F48:  MOVFF  01,7C1
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02F4C:  MOVLW  AC
02F4E:  MOVLB  8
02F50:  MOVWF  x72
02F52:  MOVLB  0
02F54:  RCALL  29A8
02F56:  MOVFF  02,7C6
02F5A:  MOVFF  01,7C5
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02F5E:  MOVLW  7C
02F60:  MOVLB  8
02F62:  MOVWF  x72
02F64:  MOVLB  0
02F66:  RCALL  29A8
02F68:  MOVFF  02,76D
02F6C:  MOVFF  01,76C
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02F70:  MOVLW  78
02F72:  MOVLB  8
02F74:  MOVWF  x72
02F76:  MOVLB  0
02F78:  RCALL  29A8
02F7A:  MOVFF  02,771
02F7E:  MOVFF  01,770
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02F82:  MOVLW  74
02F84:  MOVLB  8
02F86:  MOVWF  x72
02F88:  MOVLB  0
02F8A:  RCALL  29A8
02F8C:  MOVFF  02,775
02F90:  MOVFF  01,774
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
02F94:  MOVLW  70
02F96:  MOVLB  8
02F98:  MOVWF  x72
02F9A:  MOVLB  0
02F9C:  RCALL  29A8
02F9E:  MOVFF  02,799
02FA2:  MOVFF  01,798
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
02FA6:  MOVLW  B0
02FA8:  MOVLB  8
02FAA:  MOVWF  x72
02FAC:  MOVLB  0
02FAE:  RCALL  29A8
02FB0:  MOVFF  02,779
02FB4:  MOVFF  01,778
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
02FB8:  MOVLW  B4
02FBA:  MOVLB  8
02FBC:  MOVWF  x72
02FBE:  MOVLB  0
02FC0:  RCALL  29A8
02FC2:  MOVFF  02,7B2
02FC6:  MOVFF  01,7B1
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
02FCA:  MOVLW  B8
02FCC:  MOVLB  8
02FCE:  MOVWF  x72
02FD0:  MOVLB  0
02FD2:  RCALL  29A8
02FD4:  MOVFF  02,7B6
02FD8:  MOVFF  01,7B5
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
02FDC:  MOVLW  BC
02FDE:  MOVLB  8
02FE0:  MOVWF  x72
02FE2:  MOVLB  0
02FE4:  RCALL  29A8
02FE6:  MOVFF  02,77D
02FEA:  MOVFF  01,77C
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
02FEE:  MOVLW  C0
02FF0:  MOVLB  8
02FF2:  MOVWF  x72
02FF4:  MOVLB  0
02FF6:  RCALL  29A8
02FF8:  MOVFF  02,781
02FFC:  MOVFF  01,780
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
03000:  MOVLW  C4
03002:  MOVLB  8
03004:  MOVWF  x72
03006:  MOVLB  0
03008:  RCALL  29A8
0300A:  MOVFF  02,785
0300E:  MOVFF  01,784
....................     
....................    motor=0; 
03012:  MOVLB  7
03014:  CLRF   x40
....................    m_fixed=1; 
03016:  MOVLW  01
03018:  MOVWF  x41
....................    m_step_cnt[0]=0; 
0301A:  CLRF   xA5
0301C:  CLRF   xA4
0301E:  CLRF   xA3
03020:  CLRF   xA2
....................    m_step_cnt[1]=0; 
03022:  CLRF   xA9
03024:  CLRF   xA8
03026:  CLRF   xA7
03028:  CLRF   xA6
....................    e_cha_cnt[0]=0; 
0302A:  CLRF   xBC
0302C:  CLRF   xBB
....................    e_cha_cnt[1]=0;  
0302E:  CLRF   xBE
03030:  CLRF   xBD
....................    m_gb_cnt[0]=0; 
03032:  CLRF   x9B
03034:  CLRF   x9A
....................    m_gb_cnt[1]=0; 
03036:  CLRF   x9D
03038:  CLRF   x9C
....................    e_mode_rst[0]=0; 
0303A:  CLRF   x9F
0303C:  CLRF   x9E
....................    e_mode_rst[1]=0;    
0303E:  CLRF   xA1
03040:  CLRF   xA0
....................    e_port_dist[0]=0; 
03042:  CLRF   xB8
03044:  CLRF   xB7
....................    e_port_dist[1]=0; 
03046:  CLRF   xBA
03048:  CLRF   xB9
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
0304A:  MOVFF  777,8BA
0304E:  MOVFF  776,8B9
03052:  MOVFF  763,8BC
03056:  MOVFF  762,8BB
0305A:  MOVLB  0
0305C:  RCALL  2CB4
0305E:  BCF    FD8.0
03060:  MOVLB  8
03062:  RLCF   01,W
03064:  MOVLB  7
03066:  MOVWF  xAB
03068:  MOVLB  8
0306A:  RLCF   02,W
0306C:  MOVLB  7
0306E:  MOVWF  xAC
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
03070:  MOVFF  779,8BA
03074:  MOVFF  778,8B9
03078:  MOVFF  765,8BC
0307C:  MOVFF  764,8BB
03080:  MOVLB  0
03082:  RCALL  2CB4
03084:  BCF    FD8.0
03086:  MOVLB  8
03088:  RLCF   01,W
0308A:  MOVLB  7
0308C:  MOVWF  xAD
0308E:  MOVLB  8
03090:  RLCF   02,W
03092:  MOVLB  7
03094:  MOVWF  xAE
03096:  MOVLB  0
03098:  GOTO   14B76 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
....................    write16(ADDR_M1_MODE,FULL); 
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
....................    write16(ADDR_M1_POS_DIR,0); 
....................    write16(ADDR_M1_PWM_HLD,0); 
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
....................    write16(ADDR_E1_CPR,16); 
....................    write16(ADDR_E1_PPR,16); 
....................    write16(ADDR_E1_MODE,2); 
....................    write16(ADDR_E1_POS,0); 
....................    write16(ADDR_E1_PORT,0); 
....................    write16(ADDR_E1_TYPE,2); 
....................    write16(ADDR_M1_RUN,270); 
....................    write16(ADDR_M1_BKLSH,0); 
....................    write16(ADDR_M1_ERROR,0);   
....................    write16(ADDR_M1_SPR,38400); 
....................    write16(ADDR_M1_COMP,0); 
....................    write16(ADDR_M1_LIN_POS,0); 
....................    write16(ADDR_E1_INDEX,1); 
....................    write16(ADDR_M1_EVN_SO,0); 
....................    write16(ADDR_M1_ALIGN_OS,0); 
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
....................    write16(ADDR_M2_MODE,HALF); 
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
....................    write16(ADDR_M2_POS_DIR,0); 
....................    write16(ADDR_M2_PWM_HLD,0); 
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
....................    write16(ADDR_M2_GB_ERR,0); 
....................    write16(ADDR_E2_CPR,0); 
....................    write16(ADDR_E2_PPR,0);   
....................    write16(ADDR_E2_MODE,0); 
....................    write16(ADDR_E2_POS,0); 
....................    write16(ADDR_E2_PORT,0); 
....................    write16(ADDR_E2_TYPE,0); 
....................    write16(ADDR_M2_RUN,0); 
....................    write16(ADDR_M2_BKLSH,0); 
....................    write16(ADDR_M2_ERROR,0);   
....................    write16(ADDR_M2_SPR,0); 
....................    write16(ADDR_M2_COMP,0); 
....................    write16(ADDR_M2_LIN_POS,0);    
....................    write16(ADDR_E2_INDEX,0); 
....................    write16(ADDR_M2_EVN_SO,0); 
....................    write16(ADDR_M2_ALIGN_OS,0); 
....................     
....................    get_step_vars(); 
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
....................    write16(ADDR_M1_MODE,FULL); 
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
....................    write16(ADDR_M1_POS_DIR,1); 
....................    write16(ADDR_M1_PWM_HLD,51); 
....................    write16(ADDR_M1_PWM_DRV,511); 
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
....................    write16(ADDR_E1_CPR,24); 
....................    write16(ADDR_E1_PPR,48); 
....................    write16(ADDR_E1_MODE,2); 
....................    write16(ADDR_E1_POS,0); 
....................    write16(ADDR_E1_PORT,0); 
....................    write16(ADDR_E1_TYPE,2); 
....................    write16(ADDR_M1_RUN,34); 
....................    write16(ADDR_M1_BKLSH,0); 
....................    write16(ADDR_M1_ERROR,0);   
....................    write16(ADDR_M1_SPR,6400); 
....................    write16(ADDR_M1_COMP,0); 
....................    write16(ADDR_M1_LIN_POS,0); 
....................    write16(ADDR_E1_INDEX,1);    
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
....................    write16(ADDR_M2_MODE,HALF); 
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
....................    write16(ADDR_M2_POS_DIR,0); 
....................    write16(ADDR_M2_PWM_HLD,0); 
....................    write16(ADDR_M2_PWM_DRV,511); 
....................    write16(ADDR_M2_GB_ERR,0); 
....................    write16(ADDR_E2_CPR,0); 
....................    write16(ADDR_E2_PPR,0);   
....................    write16(ADDR_E2_MODE,0); 
....................    write16(ADDR_E2_POS,0); 
....................    write16(ADDR_E2_PORT,0); 
....................    write16(ADDR_E2_TYPE,0); 
....................    write16(ADDR_M2_RUN,0); 
....................    write16(ADDR_M2_BKLSH,0); 
....................    write16(ADDR_M2_ERROR,0);   
....................    write16(ADDR_M2_SPR,0); 
....................    write16(ADDR_M2_COMP,0); 
....................    write16(ADDR_M2_LIN_POS,0);   
....................    write16(ADDR_E2_INDEX,0);    
....................     
....................    get_step_vars(); 
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
....................    write16(ADDR_M1_MODE,FULL); 
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
....................    write16(ADDR_M1_POS_DIR,0); 
....................    write16(ADDR_M1_PWM_HLD,0); 
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
....................    write16(ADDR_E1_CPR,16); 
....................    write16(ADDR_E1_PPR,16); 
....................    write16(ADDR_E1_MODE,2); 
....................    write16(ADDR_E1_POS,0); 
....................    write16(ADDR_E1_PORT,0); 
....................    write16(ADDR_E1_TYPE,2); 
....................    write16(ADDR_M1_RUN,270); 
....................    write16(ADDR_M1_BKLSH,0); 
....................    write16(ADDR_M1_ERROR,0);   
....................    write16(ADDR_M1_SPR,38400); 
....................    write16(ADDR_M1_COMP,0); 
....................    write16(ADDR_M1_LIN_POS,0); 
....................    write16(ADDR_E1_INDEX,1); 
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
....................    write16(ADDR_M2_MODE,HALF); 
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
....................    write16(ADDR_M2_POS_DIR,0); 
....................    write16(ADDR_M2_PWM_HLD,0); 
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
....................    write16(ADDR_M2_GB_ERR,0); 
....................    write16(ADDR_E2_CPR,0); 
....................    write16(ADDR_E2_PPR,0);   
....................    write16(ADDR_E2_MODE,0); 
....................    write16(ADDR_E2_POS,0); 
....................    write16(ADDR_E2_PORT,0); 
....................    write16(ADDR_E2_TYPE,0); 
....................    write16(ADDR_M2_RUN,0); 
....................    write16(ADDR_M2_BKLSH,0); 
....................    write16(ADDR_M2_ERROR,0);   
....................    write16(ADDR_M2_SPR,0); 
....................    write16(ADDR_M2_COMP,0); 
....................    write16(ADDR_M2_LIN_POS,0);    
....................     
....................    get_step_vars(); 
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
....................    write16(ADDR_M1_MODE,FULL); 
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
....................    write16(ADDR_M1_POS_DIR,1); 
....................    write16(ADDR_M1_PWM_HLD,0); 
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
....................    write16(ADDR_E1_CPR,500); 
....................    write16(ADDR_E1_PPR,50); 
....................    write16(ADDR_E1_MODE,2); 
....................    write16(ADDR_E1_POS,0); 
....................    write16(ADDR_E1_PORT,0); 
....................    write16(ADDR_E1_TYPE,1); 
....................    write16(ADDR_M1_RUN,0); 
....................    write16(ADDR_M1_BKLSH,1300); 
....................    write16(ADDR_M1_ERROR,0);   
....................    write16(ADDR_M1_SPR,20000); 
....................    write16(ADDR_M1_COMP,0); 
....................    write16(ADDR_M1_LIN_POS,0); 
....................    write16(ADDR_E1_INDEX,0); 
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
....................    write16(ADDR_M2_MODE,HALF); 
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
....................    write16(ADDR_M2_POS_DIR,1); 
....................    write16(ADDR_M2_PWM_HLD,0); 
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
....................    write16(ADDR_M2_GB_ERR,0); 
....................    write16(ADDR_E2_CPR,0); 
....................    write16(ADDR_E2_PPR,0);   
....................    write16(ADDR_E2_MODE,0); 
....................    write16(ADDR_E2_POS,0); 
....................    write16(ADDR_E2_PORT,0); 
....................    write16(ADDR_E2_TYPE,0); 
....................    write16(ADDR_M2_RUN,0); 
....................    write16(ADDR_M2_BKLSH,0); 
....................    write16(ADDR_M2_ERROR,0);   
....................    write16(ADDR_M2_SPR,0); 
....................    write16(ADDR_M2_COMP,0); 
....................    write16(ADDR_M2_LIN_POS,0);    
....................    write16(ADDR_E2_INDEX,0); 
....................     
....................    get_step_vars(); 
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
02976:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
02978:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
0297A:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
0297C:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
0297E:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
02980:  BCF    F90.5
....................    set_pwm1_duty(0);    
02982:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
02984:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
02986:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
02988:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
0298A:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
0298C:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
0298E:  BCF    F8D.5
....................    set_pwm2_duty(0);  
02990:  MOVLB  F
02992:  CLRF   x4F
....................  
....................    output_low(VENC1); 
02994:  BCF    F8E.6
....................    output_low(VENC2);         
02996:  BCF    F8E.7
....................    output_low(VHBRDG); 
02998:  BCF    F8E.2
0299A:  MOVLB  0
0299C:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
01284:  BCF    FD8.0
01286:  MOVLB  7
01288:  RLCF   x40,W
0128A:  CLRF   03
0128C:  ADDLW  4E
0128E:  MOVWF  FE9
01290:  MOVLW  07
01292:  ADDWFC 03,W
01294:  MOVWF  FEA
01296:  MOVFF  FEC,A11
0129A:  MOVF   FED,F
0129C:  MOVFF  FEF,A10
012A0:  MOVLB  A
012A2:  MOVF   x10,F
012A4:  BTFSS  FD8.2
012A6:  BRA    142E
012A8:  MOVF   x11,F
012AA:  BTFSS  FD8.2
012AC:  BRA    142E
....................       if(m_way[motor]==POS) { 
012AE:  BCF    FD8.0
012B0:  MOVLB  7
012B2:  RLCF   x40,W
012B4:  CLRF   03
012B6:  ADDLW  86
012B8:  MOVWF  FE9
012BA:  MOVLW  07
012BC:  ADDWFC 03,W
012BE:  MOVWF  FEA
012C0:  MOVFF  FEC,A11
012C4:  MOVF   FED,F
012C6:  MOVFF  FEF,A10
012CA:  MOVLB  A
012CC:  MOVF   x10,F
012CE:  BNZ   1368
012D0:  MOVF   x11,F
012D2:  BNZ   1368
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
012D4:  BCF    FD8.0
012D6:  MOVLB  7
012D8:  RLCF   x40,W
012DA:  CLRF   03
012DC:  ADDLW  BF
012DE:  MOVWF  FE9
012E0:  MOVLW  07
012E2:  ADDWFC 03,W
012E4:  MOVWF  FEA
012E6:  MOVFF  FEC,A11
012EA:  MOVF   FED,F
012EC:  MOVFF  FEF,A10
012F0:  BCF    FD8.0
012F2:  RLCF   x40,W
012F4:  CLRF   03
012F6:  ADDLW  5E
012F8:  MOVWF  FE9
012FA:  MOVLW  07
012FC:  ADDWFC 03,W
012FE:  MOVWF  FEA
01300:  MOVFF  FEC,03
01304:  MOVF   FED,F
01306:  MOVFF  FEF,01
0130A:  MOVF   03,W
0130C:  MOVLB  A
0130E:  SUBWF  x11,W
01310:  BNC   1334
01312:  BNZ   131A
01314:  MOVF   01,W
01316:  SUBWF  x10,W
01318:  BNC   1334
0131A:  BCF    FD8.0
0131C:  MOVLB  7
0131E:  RLCF   x40,W
01320:  CLRF   03
01322:  ADDLW  BF
01324:  MOVWF  FE9
01326:  MOVLW  07
01328:  ADDWFC 03,W
0132A:  MOVWF  FEA
0132C:  CLRF   FEC
0132E:  MOVF   FED,F
01330:  CLRF   FEF
01332:  MOVLB  A
....................          e_pos[motor]++; 
01334:  BCF    FD8.0
01336:  MOVLB  7
01338:  RLCF   x40,W
0133A:  CLRF   03
0133C:  ADDLW  BF
0133E:  MOVWF  FE9
01340:  MOVLW  07
01342:  ADDWFC 03,W
01344:  MOVWF  FEA
01346:  MOVLW  01
01348:  ADDWF  FEE,F
0134A:  BNC   134E
0134C:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
0134E:  BCF    FD8.0
01350:  RLCF   x40,W
01352:  CLRF   03
01354:  ADDLW  9A
01356:  MOVWF  FE9
01358:  MOVLW  07
0135A:  ADDWFC 03,W
0135C:  MOVWF  FEA
0135E:  CLRF   FEC
01360:  MOVF   FED,F
01362:  CLRF   FEF
....................       } 
01364:  BRA    142C
01366:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
01368:  BCF    FD8.0
0136A:  MOVLB  7
0136C:  RLCF   x40,W
0136E:  CLRF   03
01370:  ADDLW  86
01372:  MOVWF  FE9
01374:  MOVLW  07
01376:  ADDWFC 03,W
01378:  MOVWF  FEA
0137A:  MOVFF  FEC,A11
0137E:  MOVF   FED,F
01380:  MOVFF  FEF,A10
01384:  MOVLB  A
01386:  DECFSZ x10,W
01388:  BRA    142E
0138A:  MOVF   x11,F
0138C:  BNZ   142E
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
0138E:  BCF    FD8.0
01390:  MOVLB  7
01392:  RLCF   x40,W
01394:  CLRF   03
01396:  ADDLW  BF
01398:  MOVWF  FE9
0139A:  MOVLW  07
0139C:  ADDWFC 03,W
0139E:  MOVWF  FEA
013A0:  MOVFF  FEC,A11
013A4:  MOVF   FED,F
013A6:  MOVFF  FEF,A10
013AA:  MOVLB  A
013AC:  MOVF   x10,F
013AE:  BNZ   13FA
013B0:  MOVF   x11,F
013B2:  BNZ   13FA
013B4:  BCF    FD8.0
013B6:  MOVLB  7
013B8:  RLCF   x40,W
013BA:  CLRF   03
013BC:  ADDLW  BF
013BE:  MOVWF  01
013C0:  MOVLW  07
013C2:  ADDWFC 03,F
013C4:  MOVLB  A
013C6:  MOVFF  03,A11
013CA:  BCF    FD8.0
013CC:  MOVLB  7
013CE:  RLCF   x40,W
013D0:  CLRF   03
013D2:  ADDLW  5E
013D4:  MOVWF  FE9
013D6:  MOVLW  07
013D8:  ADDWFC 03,W
013DA:  MOVWF  FEA
013DC:  MOVFF  FEC,03
013E0:  MOVF   FED,F
013E2:  MOVFF  FEF,A12
013E6:  MOVLB  A
013E8:  MOVFF  A11,FEA
013EC:  MOVFF  01,FE9
013F0:  MOVFF  03,FEC
013F4:  MOVF   FED,F
013F6:  MOVFF  A12,FEF
....................          e_pos[motor]--; 
013FA:  BCF    FD8.0
013FC:  MOVLB  7
013FE:  RLCF   x40,W
01400:  CLRF   03
01402:  ADDLW  BF
01404:  MOVWF  FE9
01406:  MOVLW  07
01408:  ADDWFC 03,W
0140A:  MOVWF  FEA
0140C:  MOVLW  FF
0140E:  ADDWF  FEF,F
01410:  BC    1416
01412:  MOVF   FEE,F
01414:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
01416:  BCF    FD8.0
01418:  RLCF   x40,W
0141A:  CLRF   03
0141C:  ADDLW  9A
0141E:  MOVWF  FE9
01420:  MOVLW  07
01422:  ADDWFC 03,W
01424:  MOVWF  FEA
01426:  CLRF   FEC
01428:  MOVF   FED,F
0142A:  CLRF   FEF
0142C:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
0142E:  BCF    FD8.0
01430:  MOVLB  7
01432:  RLCF   x40,W
01434:  CLRF   03
01436:  ADDLW  4E
01438:  MOVWF  FE9
0143A:  MOVLW  07
0143C:  ADDWFC 03,W
0143E:  MOVWF  FEA
01440:  MOVFF  FEC,A11
01444:  MOVF   FED,F
01446:  MOVFF  FEF,A10
0144A:  MOVLB  A
0144C:  DECFSZ x10,W
0144E:  BRA    15D6
01450:  MOVF   x11,F
01452:  BTFSS  FD8.2
01454:  BRA    15D6
....................       if(m_way[motor]==NEG) { 
01456:  BCF    FD8.0
01458:  MOVLB  7
0145A:  RLCF   x40,W
0145C:  CLRF   03
0145E:  ADDLW  86
01460:  MOVWF  FE9
01462:  MOVLW  07
01464:  ADDWFC 03,W
01466:  MOVWF  FEA
01468:  MOVFF  FEC,A11
0146C:  MOVF   FED,F
0146E:  MOVFF  FEF,A10
01472:  MOVLB  A
01474:  DECFSZ x10,W
01476:  BRA    1510
01478:  MOVF   x11,F
0147A:  BNZ   1510
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
0147C:  BCF    FD8.0
0147E:  MOVLB  7
01480:  RLCF   x40,W
01482:  CLRF   03
01484:  ADDLW  BF
01486:  MOVWF  FE9
01488:  MOVLW  07
0148A:  ADDWFC 03,W
0148C:  MOVWF  FEA
0148E:  MOVFF  FEC,A11
01492:  MOVF   FED,F
01494:  MOVFF  FEF,A10
01498:  BCF    FD8.0
0149A:  RLCF   x40,W
0149C:  CLRF   03
0149E:  ADDLW  5E
014A0:  MOVWF  FE9
014A2:  MOVLW  07
014A4:  ADDWFC 03,W
014A6:  MOVWF  FEA
014A8:  MOVFF  FEC,03
014AC:  MOVF   FED,F
014AE:  MOVFF  FEF,01
014B2:  MOVF   03,W
014B4:  MOVLB  A
014B6:  SUBWF  x11,W
014B8:  BNC   14DC
014BA:  BNZ   14C2
014BC:  MOVF   01,W
014BE:  SUBWF  x10,W
014C0:  BNC   14DC
014C2:  BCF    FD8.0
014C4:  MOVLB  7
014C6:  RLCF   x40,W
014C8:  CLRF   03
014CA:  ADDLW  BF
014CC:  MOVWF  FE9
014CE:  MOVLW  07
014D0:  ADDWFC 03,W
014D2:  MOVWF  FEA
014D4:  CLRF   FEC
014D6:  MOVF   FED,F
014D8:  CLRF   FEF
014DA:  MOVLB  A
....................          e_pos[motor]++; 
014DC:  BCF    FD8.0
014DE:  MOVLB  7
014E0:  RLCF   x40,W
014E2:  CLRF   03
014E4:  ADDLW  BF
014E6:  MOVWF  FE9
014E8:  MOVLW  07
014EA:  ADDWFC 03,W
014EC:  MOVWF  FEA
014EE:  MOVLW  01
014F0:  ADDWF  FEE,F
014F2:  BNC   14F6
014F4:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014F6:  BCF    FD8.0
014F8:  RLCF   x40,W
014FA:  CLRF   03
014FC:  ADDLW  9A
014FE:  MOVWF  FE9
01500:  MOVLW  07
01502:  ADDWFC 03,W
01504:  MOVWF  FEA
01506:  CLRF   FEC
01508:  MOVF   FED,F
0150A:  CLRF   FEF
....................       } 
0150C:  BRA    15D4
0150E:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
01510:  BCF    FD8.0
01512:  MOVLB  7
01514:  RLCF   x40,W
01516:  CLRF   03
01518:  ADDLW  86
0151A:  MOVWF  FE9
0151C:  MOVLW  07
0151E:  ADDWFC 03,W
01520:  MOVWF  FEA
01522:  MOVFF  FEC,A11
01526:  MOVF   FED,F
01528:  MOVFF  FEF,A10
0152C:  MOVLB  A
0152E:  MOVF   x10,F
01530:  BNZ   15D6
01532:  MOVF   x11,F
01534:  BNZ   15D6
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01536:  BCF    FD8.0
01538:  MOVLB  7
0153A:  RLCF   x40,W
0153C:  CLRF   03
0153E:  ADDLW  BF
01540:  MOVWF  FE9
01542:  MOVLW  07
01544:  ADDWFC 03,W
01546:  MOVWF  FEA
01548:  MOVFF  FEC,A11
0154C:  MOVF   FED,F
0154E:  MOVFF  FEF,A10
01552:  MOVLB  A
01554:  MOVF   x10,F
01556:  BNZ   15A2
01558:  MOVF   x11,F
0155A:  BNZ   15A2
0155C:  BCF    FD8.0
0155E:  MOVLB  7
01560:  RLCF   x40,W
01562:  CLRF   03
01564:  ADDLW  BF
01566:  MOVWF  01
01568:  MOVLW  07
0156A:  ADDWFC 03,F
0156C:  MOVLB  A
0156E:  MOVFF  03,A11
01572:  BCF    FD8.0
01574:  MOVLB  7
01576:  RLCF   x40,W
01578:  CLRF   03
0157A:  ADDLW  5E
0157C:  MOVWF  FE9
0157E:  MOVLW  07
01580:  ADDWFC 03,W
01582:  MOVWF  FEA
01584:  MOVFF  FEC,03
01588:  MOVF   FED,F
0158A:  MOVFF  FEF,A12
0158E:  MOVLB  A
01590:  MOVFF  A11,FEA
01594:  MOVFF  01,FE9
01598:  MOVFF  03,FEC
0159C:  MOVF   FED,F
0159E:  MOVFF  A12,FEF
....................          e_pos[motor]--; 
015A2:  BCF    FD8.0
015A4:  MOVLB  7
015A6:  RLCF   x40,W
015A8:  CLRF   03
015AA:  ADDLW  BF
015AC:  MOVWF  FE9
015AE:  MOVLW  07
015B0:  ADDWFC 03,W
015B2:  MOVWF  FEA
015B4:  MOVLW  FF
015B6:  ADDWF  FEF,F
015B8:  BC    15BE
015BA:  MOVF   FEE,F
015BC:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
015BE:  BCF    FD8.0
015C0:  RLCF   x40,W
015C2:  CLRF   03
015C4:  ADDLW  9A
015C6:  MOVWF  FE9
015C8:  MOVLW  07
015CA:  ADDWFC 03,W
015CC:  MOVWF  FEA
015CE:  CLRF   FEC
015D0:  MOVF   FED,F
015D2:  CLRF   FEF
015D4:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
015D6:  MOVF   1F,W
015D8:  SUBLW  04
015DA:  BTFSS  FD8.2
015DC:  BRA    1710
015DE:  MOVF   20,F
015E0:  BTFSS  FD8.2
015E2:  BRA    1710
015E4:  BCF    FD8.0
015E6:  MOVLB  7
015E8:  RLCF   x40,W
015EA:  CLRF   03
015EC:  ADDLW  6A
015EE:  MOVWF  FE9
015F0:  MOVLW  07
015F2:  ADDWFC 03,W
015F4:  MOVWF  FEA
015F6:  MOVFF  FEC,A11
015FA:  MOVF   FED,F
015FC:  MOVFF  FEF,A10
01600:  MOVLB  A
01602:  MOVF   x10,W
01604:  SUBLW  02
01606:  BTFSS  FD8.2
01608:  BRA    1710
0160A:  MOVF   x11,F
0160C:  BTFSS  FD8.2
0160E:  BRA    1710
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
01610:  MOVLW  01
01612:  MOVLB  7
01614:  ADDWF  x40,W
01616:  MOVLB  A
01618:  MOVWF  x10
0161A:  MOVLB  7
0161C:  MOVF   x40,W
0161E:  MULLW  04
01620:  MOVF   FF3,W
01622:  CLRF   03
01624:  ADDLW  A2
01626:  MOVWF  FE9
01628:  MOVLW  07
0162A:  ADDWFC 03,W
0162C:  MOVWF  FEA
0162E:  MOVFF  FEF,A11
01632:  MOVFF  FEC,A12
01636:  MOVFF  FEC,A13
0163A:  MOVFF  FEC,A14
0163E:  BCF    FD8.0
01640:  RLCF   x40,W
01642:  CLRF   03
01644:  ADDLW  BB
01646:  MOVWF  FE9
01648:  MOVLW  07
0164A:  ADDWFC 03,W
0164C:  MOVWF  FEA
0164E:  MOVFF  FEC,A16
01652:  MOVF   FED,F
01654:  MOVFF  FEF,A15
01658:  BCF    FD8.0
0165A:  RLCF   x40,W
0165C:  CLRF   03
0165E:  ADDLW  BF
01660:  MOVWF  FE9
01662:  MOVLW  07
01664:  ADDWFC 03,W
01666:  MOVWF  FEA
01668:  MOVFF  FEC,A18
0166C:  MOVF   FED,F
0166E:  MOVFF  FEF,A17
01672:  MOVLW  6D
01674:  BTFSS  F9E.4
01676:  BRA    1674
01678:  MOVWF  FAD
0167A:  MOVLW  3A
0167C:  BTFSS  F9E.4
0167E:  BRA    167C
01680:  MOVWF  FAD
01682:  MOVFF  A10,A19
01686:  MOVLW  1B
01688:  MOVLB  A
0168A:  MOVWF  x1A
0168C:  MOVLB  0
0168E:  RCALL  0FD0
01690:  MOVLW  2C
01692:  BTFSS  F9E.4
01694:  BRA    1692
01696:  MOVWF  FAD
01698:  MOVFF  7AA,A19
0169C:  MOVLW  1B
0169E:  MOVLB  A
016A0:  MOVWF  x1A
016A2:  MOVLB  0
016A4:  RCALL  0FD0
016A6:  MOVLW  93
016A8:  MOVWF  FF6
016AA:  MOVLW  0F
016AC:  MOVWF  FF7
016AE:  MOVLW  00
016B0:  MOVWF  FF8
016B2:  MOVLW  03
016B4:  MOVLB  A
016B6:  MOVWF  x19
016B8:  MOVLB  0
016BA:  RCALL  104E
016BC:  MOVLW  41
016BE:  MOVWF  FE9
016C0:  MOVFF  A14,A1C
016C4:  MOVFF  A13,A1B
016C8:  MOVFF  A12,A1A
016CC:  MOVFF  A11,A19
016D0:  RCALL  1114
016D2:  MOVLW  2C
016D4:  BTFSS  F9E.4
016D6:  BRA    16D4
016D8:  MOVWF  FAD
016DA:  MOVLW  10
016DC:  MOVWF  FE9
016DE:  MOVFF  A16,A1A
016E2:  MOVFF  A15,A19
016E6:  RCALL  11D0
016E8:  MOVLW  2C
016EA:  BTFSS  F9E.4
016EC:  BRA    16EA
016EE:  MOVWF  FAD
016F0:  MOVLW  10
016F2:  MOVWF  FE9
016F4:  MOVFF  A18,A1A
016F8:  MOVFF  A17,A19
016FC:  RCALL  11D0
016FE:  MOVLW  0D
01700:  BTFSS  F9E.4
01702:  BRA    1700
01704:  MOVWF  FAD
01706:  MOVLW  0A
01708:  BTFSS  F9E.4
0170A:  BRA    1708
0170C:  MOVWF  FAD
0170E:  MOVLB  A
....................    }    
01710:  MOVLB  0
01712:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A722:  MOVLB  7
0A724:  MOVF   x40,W
0A726:  XORLW  00
0A728:  MOVLB  0
0A72A:  BZ    A732
0A72C:  XORLW  01
0A72E:  BZ    A7C2
0A730:  BRA    A850
....................       case 0 : if (e_type[motor]==1) { 
0A732:  BCF    FD8.0
0A734:  MOVLB  7
0A736:  RLCF   x40,W
0A738:  CLRF   03
0A73A:  ADDLW  6A
0A73C:  MOVWF  FE9
0A73E:  MOVLW  07
0A740:  ADDWFC 03,W
0A742:  MOVWF  FEA
0A744:  MOVFF  FEC,8A6
0A748:  MOVF   FED,F
0A74A:  MOVFF  FEF,8A5
0A74E:  MOVLB  8
0A750:  DECFSZ xA5,W
0A752:  BRA    A772
0A754:  MOVF   xA6,F
0A756:  BNZ   A772
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A758:  CLRF   03
0A75A:  MOVLB  7
0A75C:  MOVF   x40,W
0A75E:  ADDLW  CB
0A760:  MOVWF  FE9
0A762:  MOVLW  07
0A764:  ADDWFC 03,W
0A766:  MOVWF  FEA
0A768:  MOVLW  00
0A76A:  BTFSC  F81.4
0A76C:  MOVLW  01
0A76E:  MOVWF  FEF
0A770:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A772:  BCF    FD8.0
0A774:  MOVLB  7
0A776:  RLCF   x40,W
0A778:  CLRF   03
0A77A:  ADDLW  6A
0A77C:  MOVWF  FE9
0A77E:  MOVLW  07
0A780:  ADDWFC 03,W
0A782:  MOVWF  FEA
0A784:  MOVFF  FEC,8A6
0A788:  MOVF   FED,F
0A78A:  MOVFF  FEF,8A5
0A78E:  MOVLB  8
0A790:  MOVF   xA5,W
0A792:  SUBLW  02
0A794:  BNZ   A7BE
0A796:  MOVF   xA6,F
0A798:  BNZ   A7BE
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A79A:  CLRF   03
0A79C:  MOVLB  7
0A79E:  MOVF   x40,W
0A7A0:  ADDLW  CB
0A7A2:  MOVWF  FE9
0A7A4:  MOVLW  07
0A7A6:  ADDWFC 03,W
0A7A8:  MOVWF  FEA
0A7AA:  MOVLW  00
0A7AC:  BTFSC  F81.4
0A7AE:  MOVLW  01
0A7B0:  MOVLB  8
0A7B2:  MOVWF  xA7
0A7B4:  MOVLW  00
0A7B6:  BTFSC  F81.1
0A7B8:  MOVLW  01
0A7BA:  ANDWF  xA7,W
0A7BC:  MOVWF  FEF
....................                } 
....................          break; 
0A7BE:  MOVLB  0
0A7C0:  BRA    A850
....................       case 1 : if (e_type[motor]==1) { 
0A7C2:  BCF    FD8.0
0A7C4:  MOVLB  7
0A7C6:  RLCF   x40,W
0A7C8:  CLRF   03
0A7CA:  ADDLW  6A
0A7CC:  MOVWF  FE9
0A7CE:  MOVLW  07
0A7D0:  ADDWFC 03,W
0A7D2:  MOVWF  FEA
0A7D4:  MOVFF  FEC,8A6
0A7D8:  MOVF   FED,F
0A7DA:  MOVFF  FEF,8A5
0A7DE:  MOVLB  8
0A7E0:  DECFSZ xA5,W
0A7E2:  BRA    A802
0A7E4:  MOVF   xA6,F
0A7E6:  BNZ   A802
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A7E8:  CLRF   03
0A7EA:  MOVLB  7
0A7EC:  MOVF   x40,W
0A7EE:  ADDLW  CB
0A7F0:  MOVWF  FE9
0A7F2:  MOVLW  07
0A7F4:  ADDWFC 03,W
0A7F6:  MOVWF  FEA
0A7F8:  MOVLW  00
0A7FA:  BTFSC  F81.5
0A7FC:  MOVLW  01
0A7FE:  MOVWF  FEF
0A800:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A802:  BCF    FD8.0
0A804:  MOVLB  7
0A806:  RLCF   x40,W
0A808:  CLRF   03
0A80A:  ADDLW  6A
0A80C:  MOVWF  FE9
0A80E:  MOVLW  07
0A810:  ADDWFC 03,W
0A812:  MOVWF  FEA
0A814:  MOVFF  FEC,8A6
0A818:  MOVF   FED,F
0A81A:  MOVFF  FEF,8A5
0A81E:  MOVLB  8
0A820:  MOVF   xA5,W
0A822:  SUBLW  02
0A824:  BNZ   A84E
0A826:  MOVF   xA6,F
0A828:  BNZ   A84E
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A82A:  CLRF   03
0A82C:  MOVLB  7
0A82E:  MOVF   x40,W
0A830:  ADDLW  CB
0A832:  MOVWF  FE9
0A834:  MOVLW  07
0A836:  ADDWFC 03,W
0A838:  MOVWF  FEA
0A83A:  MOVLW  00
0A83C:  BTFSC  F81.5
0A83E:  MOVLW  01
0A840:  MOVLB  8
0A842:  MOVWF  xA7
0A844:  MOVLW  00
0A846:  BTFSC  F81.2
0A848:  MOVLW  01
0A84A:  ANDWF  xA7,W
0A84C:  MOVWF  FEF
....................                } 
....................          break; 
0A84E:  MOVLB  0
....................    } 
0A850:  GOTO   A90A (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
01800:  MOVLB  7
01802:  MOVF   x40,W
01804:  XORLW  00
01806:  MOVLB  0
01808:  BZ    1810
0180A:  XORLW  01
0180C:  BZ    18A0
0180E:  BRA    192E
....................       case 0 : if (e_type[motor]==1) { 
01810:  BCF    FD8.0
01812:  MOVLB  7
01814:  RLCF   x40,W
01816:  CLRF   03
01818:  ADDLW  6A
0181A:  MOVWF  FE9
0181C:  MOVLW  07
0181E:  ADDWFC 03,W
01820:  MOVWF  FEA
01822:  MOVFF  FEC,A11
01826:  MOVF   FED,F
01828:  MOVFF  FEF,A10
0182C:  MOVLB  A
0182E:  DECFSZ x10,W
01830:  BRA    1850
01832:  MOVF   x11,F
01834:  BNZ   1850
....................                   e_ch_n[motor]=input(ENC1_IND); 
01836:  CLRF   03
01838:  MOVLB  7
0183A:  MOVF   x40,W
0183C:  ADDLW  CB
0183E:  MOVWF  FE9
01840:  MOVLW  07
01842:  ADDWFC 03,W
01844:  MOVWF  FEA
01846:  MOVLW  00
01848:  BTFSC  F81.4
0184A:  MOVLW  01
0184C:  MOVWF  FEF
0184E:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01850:  BCF    FD8.0
01852:  MOVLB  7
01854:  RLCF   x40,W
01856:  CLRF   03
01858:  ADDLW  6A
0185A:  MOVWF  FE9
0185C:  MOVLW  07
0185E:  ADDWFC 03,W
01860:  MOVWF  FEA
01862:  MOVFF  FEC,A11
01866:  MOVF   FED,F
01868:  MOVFF  FEF,A10
0186C:  MOVLB  A
0186E:  MOVF   x10,W
01870:  SUBLW  02
01872:  BNZ   189C
01874:  MOVF   x11,F
01876:  BNZ   189C
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
01878:  CLRF   03
0187A:  MOVLB  7
0187C:  MOVF   x40,W
0187E:  ADDLW  CB
01880:  MOVWF  FE9
01882:  MOVLW  07
01884:  ADDWFC 03,W
01886:  MOVWF  FEA
01888:  MOVLW  00
0188A:  BTFSC  F81.4
0188C:  MOVLW  01
0188E:  MOVLB  A
01890:  MOVWF  x12
01892:  MOVLW  00
01894:  BTFSC  F81.1
01896:  MOVLW  01
01898:  ANDWF  x12,W
0189A:  MOVWF  FEF
....................                } 
....................          break; 
0189C:  MOVLB  0
0189E:  BRA    192E
....................       case 1 : if (e_type[motor]==1) { 
018A0:  BCF    FD8.0
018A2:  MOVLB  7
018A4:  RLCF   x40,W
018A6:  CLRF   03
018A8:  ADDLW  6A
018AA:  MOVWF  FE9
018AC:  MOVLW  07
018AE:  ADDWFC 03,W
018B0:  MOVWF  FEA
018B2:  MOVFF  FEC,A11
018B6:  MOVF   FED,F
018B8:  MOVFF  FEF,A10
018BC:  MOVLB  A
018BE:  DECFSZ x10,W
018C0:  BRA    18E0
018C2:  MOVF   x11,F
018C4:  BNZ   18E0
....................                   e_ch_n[motor]=input(ENC2_IND); 
018C6:  CLRF   03
018C8:  MOVLB  7
018CA:  MOVF   x40,W
018CC:  ADDLW  CB
018CE:  MOVWF  FE9
018D0:  MOVLW  07
018D2:  ADDWFC 03,W
018D4:  MOVWF  FEA
018D6:  MOVLW  00
018D8:  BTFSC  F81.5
018DA:  MOVLW  01
018DC:  MOVWF  FEF
018DE:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
018E0:  BCF    FD8.0
018E2:  MOVLB  7
018E4:  RLCF   x40,W
018E6:  CLRF   03
018E8:  ADDLW  6A
018EA:  MOVWF  FE9
018EC:  MOVLW  07
018EE:  ADDWFC 03,W
018F0:  MOVWF  FEA
018F2:  MOVFF  FEC,A11
018F6:  MOVF   FED,F
018F8:  MOVFF  FEF,A10
018FC:  MOVLB  A
018FE:  MOVF   x10,W
01900:  SUBLW  02
01902:  BNZ   192C
01904:  MOVF   x11,F
01906:  BNZ   192C
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
01908:  CLRF   03
0190A:  MOVLB  7
0190C:  MOVF   x40,W
0190E:  ADDLW  CB
01910:  MOVWF  FE9
01912:  MOVLW  07
01914:  ADDWFC 03,W
01916:  MOVWF  FEA
01918:  MOVLW  00
0191A:  BTFSC  F81.5
0191C:  MOVLW  01
0191E:  MOVLB  A
01920:  MOVWF  x12
01922:  MOVLW  00
01924:  BTFSC  F81.2
01926:  MOVLW  01
01928:  ANDWF  x12,W
0192A:  MOVWF  FEF
....................                } 
....................          break; 
0192C:  MOVLB  0
....................    } 
0192E:  GOTO   1A7C (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
01714:  BCF    FD8.0
01716:  MOVLB  7
01718:  RLCF   x40,W
0171A:  CLRF   03
0171C:  ADDLW  BB
0171E:  MOVWF  FE9
01720:  MOVLW  07
01722:  ADDWFC 03,W
01724:  MOVWF  FEA
01726:  MOVLW  01
01728:  ADDWF  FEE,F
0172A:  BNC   172E
0172C:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
0172E:  MOVF   xAA,W
01730:  XORLW  00
01732:  MOVLB  0
01734:  BZ    1740
01736:  XORLW  01
01738:  BZ    1746
0173A:  XORLW  03
0173C:  BZ    1758
0173E:  BRA    1782
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
01740:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
01742:  BCF    FF0.0
....................          break; 
01744:  BRA    1782
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01746:  MOVLW  02
01748:  MOVLB  7
0174A:  MOVWF  xAA
....................                disable_interrupts(INT_EXT1_L2H); 
0174C:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
0174E:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
01750:  BSF    FF0.3
01752:  BCF    FF1.5
....................          break; 
01754:  MOVLB  0
01756:  BRA    1782
....................       case 2 : edge_mode=1; 
01758:  MOVLW  01
0175A:  MOVLB  7
0175C:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
0175E:  BCF    FD8.0
01760:  RLCF   x40,W
01762:  CLRF   03
01764:  ADDLW  BB
01766:  MOVWF  FE9
01768:  MOVLW  07
0176A:  ADDWFC 03,W
0176C:  MOVWF  FEA
0176E:  MOVLW  FF
01770:  ADDWF  FEF,F
01772:  BC    1778
01774:  MOVF   FEE,F
01776:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
01778:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
0177A:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
0177C:  BSF    FF0.3
0177E:  BSF    FF1.5
....................          break; 
01780:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
01782:  RCALL  1284
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
01784:  BCF    FF0.0
01786:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
0178A:  BCF    FD8.0
0178C:  MOVLB  7
0178E:  RLCF   x40,W
01790:  CLRF   03
01792:  ADDLW  BB
01794:  MOVWF  FE9
01796:  MOVLW  07
01798:  ADDWFC 03,W
0179A:  MOVWF  FEA
0179C:  MOVLW  01
0179E:  ADDWF  FEE,F
017A0:  BNC   17A4
017A2:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
017A4:  MOVF   xAA,W
017A6:  XORLW  00
017A8:  MOVLB  0
017AA:  BZ    17B6
017AC:  XORLW  01
017AE:  BZ    17BC
017B0:  XORLW  03
017B2:  BZ    17CE
017B4:  BRA    17F8
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
017B6:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
017B8:  BCF    FF0.1
....................          break; 
017BA:  BRA    17F8
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
017BC:  MOVLW  02
017BE:  MOVLB  7
017C0:  MOVWF  xAA
....................                disable_interrupts(INT_EXT2_L2H); 
017C2:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
017C4:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
017C6:  BSF    FF0.4
017C8:  BCF    FF1.4
....................          break; 
017CA:  MOVLB  0
017CC:  BRA    17F8
....................       case 2 : edge_mode=1; 
017CE:  MOVLW  01
017D0:  MOVLB  7
017D2:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
017D4:  BCF    FD8.0
017D6:  RLCF   x40,W
017D8:  CLRF   03
017DA:  ADDLW  BB
017DC:  MOVWF  FE9
017DE:  MOVLW  07
017E0:  ADDWFC 03,W
017E2:  MOVWF  FEA
017E4:  MOVLW  FF
017E6:  ADDWF  FEF,F
017E8:  BC    17EE
017EA:  MOVF   FEE,F
017EC:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017EE:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017F0:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017F2:  BSF    FF0.4
017F4:  BSF    FF1.4
....................          break; 
017F6:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017F8:  RCALL  1284
.................... } 
....................  
.................... // motor step timer interrupt 
017FA:  BCF    FF0.1
017FC:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
01932:  MOVLW  F9
01934:  MOVWF  FB3
01936:  MOVLW  C0
01938:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
0193A:  BCF    FD8.0
0193C:  MOVLB  7
0193E:  RLCF   x40,W
01940:  CLRF   03
01942:  ADDLW  8E
01944:  MOVWF  FE9
01946:  MOVLW  07
01948:  ADDWFC 03,W
0194A:  MOVWF  FEA
0194C:  MOVLW  01
0194E:  ADDWF  FEE,F
01950:  BNC   1954
01952:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
01954:  BCF    FD8.0
01956:  RLCF   x40,W
01958:  CLRF   03
0195A:  ADDLW  8E
0195C:  MOVWF  FE9
0195E:  MOVLW  07
01960:  ADDWFC 03,W
01962:  MOVWF  FEA
01964:  MOVFF  FEC,A11
01968:  MOVF   FED,F
0196A:  MOVFF  FEF,A10
0196E:  BCF    FD8.0
01970:  RLCF   x40,W
01972:  CLRF   03
01974:  ADDLW  4A
01976:  MOVWF  FE9
01978:  MOVLW  07
0197A:  ADDWFC 03,W
0197C:  MOVWF  FEA
0197E:  MOVFF  FEC,03
01982:  MOVF   FED,F
01984:  MOVFF  FEF,01
01988:  MOVF   03,W
0198A:  MOVLB  A
0198C:  SUBWF  x11,W
0198E:  BTFSS  FD8.0
01990:  BRA    1A7E
01992:  BNZ   199C
01994:  MOVF   01,W
01996:  SUBWF  x10,W
01998:  BTFSS  FD8.0
0199A:  BRA    1A7E
....................    { 
....................       m_step_cnt[motor]++; 
0199C:  MOVLB  7
0199E:  MOVF   x40,W
019A0:  MULLW  04
019A2:  MOVF   FF3,W
019A4:  CLRF   03
019A6:  ADDLW  A2
019A8:  MOVWF  FE9
019AA:  MOVLW  07
019AC:  ADDWFC 03,W
019AE:  MOVWF  FEA
019B0:  MOVLW  01
019B2:  ADDWF  FEE,F
019B4:  MOVLW  00
019B6:  ADDWFC FEE,F
019B8:  ADDWFC FEE,F
019BA:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
019BC:  BCF    FD8.0
019BE:  RLCF   x40,W
019C0:  CLRF   03
019C2:  ADDLW  9A
019C4:  MOVWF  FE9
019C6:  MOVLW  07
019C8:  ADDWFC 03,W
019CA:  MOVWF  FEA
019CC:  MOVLW  01
019CE:  ADDWF  FEE,F
019D0:  BNC   19D4
019D2:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
019D4:  BCF    FD8.0
019D6:  RLCF   x40,W
019D8:  CLRF   03
019DA:  ADDLW  8E
019DC:  MOVWF  FE9
019DE:  MOVLW  07
019E0:  ADDWFC 03,W
019E2:  MOVWF  FEA
019E4:  CLRF   FEC
019E6:  MOVF   FED,F
019E8:  CLRF   FEF
....................  
....................       if (motor==0) 
019EA:  MOVF   x40,F
019EC:  BNZ   19F2
....................       { 
....................          output_toggle(M1_CLOCK); 
019EE:  BTG    F90.4
....................       } 
019F0:  BRA    1A52
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019F2:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019F4:  BCF    FD8.0
019F6:  RLCF   x40,W
019F8:  CLRF   03
019FA:  ADDLW  86
019FC:  MOVWF  FE9
019FE:  MOVLW  07
01A00:  ADDWFC 03,W
01A02:  MOVWF  FEA
01A04:  MOVFF  FEC,A11
01A08:  MOVF   FED,F
01A0A:  MOVFF  FEF,A10
01A0E:  MOVLB  A
01A10:  MOVF   x10,F
01A12:  BNZ   1A38
01A14:  MOVF   x11,F
01A16:  BNZ   1A38
01A18:  BCF    FD8.0
01A1A:  MOVLB  7
01A1C:  RLCF   x40,W
01A1E:  CLRF   03
01A20:  ADDLW  B3
01A22:  MOVWF  FE9
01A24:  MOVLW  07
01A26:  ADDWFC 03,W
01A28:  MOVWF  FEA
01A2A:  MOVLW  FF
01A2C:  ADDWF  FEF,F
01A2E:  BC    1A34
01A30:  MOVF   FEE,F
01A32:  DECF   FED,F
01A34:  BRA    1A52
01A36:  MOVLB  A
....................          else m_lin_pos[motor]++;          
01A38:  BCF    FD8.0
01A3A:  MOVLB  7
01A3C:  RLCF   x40,W
01A3E:  CLRF   03
01A40:  ADDLW  B3
01A42:  MOVWF  FE9
01A44:  MOVLW  07
01A46:  ADDWFC 03,W
01A48:  MOVWF  FEA
01A4A:  MOVLW  01
01A4C:  ADDWF  FEE,F
01A4E:  BNC   1A52
01A50:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A52:  BCF    FD8.0
01A54:  RLCF   x40,W
01A56:  CLRF   03
01A58:  ADDLW  66
01A5A:  MOVWF  FE9
01A5C:  MOVLW  07
01A5E:  ADDWFC 03,W
01A60:  MOVWF  FEA
01A62:  MOVFF  FEC,A11
01A66:  MOVF   FED,F
01A68:  MOVFF  FEF,A10
01A6C:  MOVLB  A
01A6E:  MOVF   x10,W
01A70:  SUBLW  03
01A72:  BNZ   1A7E
01A74:  MOVF   x11,F
01A76:  BNZ   1A7E
01A78:  MOVLB  0
01A7A:  BRA    1800
01A7C:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A7E:  BCF    FA1.1
01A80:  BCF    FA1.1
01A82:  MOVLB  0
01A84:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
08984:  BCF    FD8.0
08986:  MOVLB  7
08988:  RLCF   x40,W
0898A:  CLRF   03
0898C:  ADDLW  4E
0898E:  MOVWF  FE9
08990:  MOVLW  07
08992:  ADDWFC 03,W
08994:  MOVWF  FEA
08996:  MOVFF  FEC,8B7
0899A:  MOVF   FED,F
0899C:  MOVFF  FEF,8B6
089A0:  MOVLB  8
089A2:  DECFSZ xB6,W
089A4:  BRA    89F4
089A6:  MOVF   xB7,F
089A8:  BNZ   89F4
089AA:  BCF    FD8.0
089AC:  MOVLB  7
089AE:  RLCF   x40,W
089B0:  CLRF   03
089B2:  ADDLW  86
089B4:  MOVWF  01
089B6:  MOVLW  07
089B8:  ADDWFC 03,F
089BA:  MOVFF  01,8B6
089BE:  MOVLB  8
089C0:  MOVFF  03,8B7
089C4:  BCF    FD8.0
089C6:  MOVLB  7
089C8:  RLCF   x40,W
089CA:  CLRF   03
089CC:  ADDLW  86
089CE:  MOVWF  FE9
089D0:  MOVLW  07
089D2:  ADDWFC 03,W
089D4:  MOVWF  FEA
089D6:  MOVF   FEF,F
089D8:  BNZ   89DE
089DA:  MOVF   FEC,F
089DC:  BZ    89E2
089DE:  MOVLW  00
089E0:  BRA    89E4
089E2:  MOVLW  01
089E4:  MOVLB  8
089E6:  MOVFF  8B7,FEA
089EA:  MOVFF  8B6,FE9
089EE:  CLRF   FEC
089F0:  MOVF   FED,F
089F2:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
089F4:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
089F6:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
089F8:  BCF    FD8.0
089FA:  MOVLB  7
089FC:  RLCF   x40,W
089FE:  CLRF   03
08A00:  ADDLW  42
08A02:  MOVWF  FE9
08A04:  MOVLW  07
08A06:  ADDWFC 03,W
08A08:  MOVWF  FEA
08A0A:  MOVF   FEF,F
08A0C:  BNZ   8A16
08A0E:  MOVF   FEC,F
08A10:  BNZ   8A16
08A12:  BCF    F90.2
08A14:  BRA    8A18
08A16:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
08A18:  BCF    FD8.0
08A1A:  RLCF   x40,W
08A1C:  CLRF   03
08A1E:  ADDLW  46
08A20:  MOVWF  FE9
08A22:  MOVLW  07
08A24:  ADDWFC 03,W
08A26:  MOVWF  FEA
08A28:  MOVF   FEF,F
08A2A:  BNZ   8A34
08A2C:  MOVF   FEC,F
08A2E:  BNZ   8A34
08A30:  BCF    F90.3
08A32:  BRA    8A36
08A34:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
08A36:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
08A38:  BCF    FD8.0
08A3A:  RLCF   x40,W
08A3C:  CLRF   03
08A3E:  ADDLW  86
08A40:  MOVWF  FE9
08A42:  MOVLW  07
08A44:  ADDWFC 03,W
08A46:  MOVWF  FEA
08A48:  MOVF   FEF,F
08A4A:  BNZ   8A54
08A4C:  MOVF   FEC,F
08A4E:  BNZ   8A54
08A50:  BCF    F90.5
08A52:  BRA    8A56
08A54:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
08A56:  BCF    FD8.0
08A58:  RLCF   x40,W
08A5A:  CLRF   03
08A5C:  ADDLW  56
08A5E:  MOVWF  FE9
08A60:  MOVLW  07
08A62:  ADDWFC 03,W
08A64:  MOVWF  FEA
08A66:  MOVFF  FEC,8B7
08A6A:  MOVF   FED,F
08A6C:  MOVFF  FEF,8B6
08A70:  MOVLB  8
08A72:  RRCF   xB7,F
08A74:  RRCF   xB6,F
08A76:  RRCF   xB7,F
08A78:  RRCF   xB6,F
08A7A:  RRCF   xB7,F
08A7C:  MOVFF  8B6,FBC
08A80:  RRCF   xB7,F
08A82:  RRCF   xB7,W
08A84:  ANDLW  30
08A86:  MOVWF  00
08A88:  MOVF   FBB,W
08A8A:  ANDLW  CF
08A8C:  IORWF  00,W
08A8E:  MOVWF  FBB
08A90:  MOVLB  0
08A92:  GOTO   8C1C (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08A96:  BCF    FD8.0
08A98:  MOVLB  7
08A9A:  RLCF   x40,W
08A9C:  CLRF   03
08A9E:  ADDLW  4E
08AA0:  MOVWF  FE9
08AA2:  MOVLW  07
08AA4:  ADDWFC 03,W
08AA6:  MOVWF  FEA
08AA8:  MOVFF  FEC,8B7
08AAC:  MOVF   FED,F
08AAE:  MOVFF  FEF,8B6
08AB2:  MOVLB  8
08AB4:  DECFSZ xB6,W
08AB6:  BRA    8B06
08AB8:  MOVF   xB7,F
08ABA:  BNZ   8B06
08ABC:  BCF    FD8.0
08ABE:  MOVLB  7
08AC0:  RLCF   x40,W
08AC2:  CLRF   03
08AC4:  ADDLW  86
08AC6:  MOVWF  01
08AC8:  MOVLW  07
08ACA:  ADDWFC 03,F
08ACC:  MOVFF  01,8B6
08AD0:  MOVLB  8
08AD2:  MOVFF  03,8B7
08AD6:  BCF    FD8.0
08AD8:  MOVLB  7
08ADA:  RLCF   x40,W
08ADC:  CLRF   03
08ADE:  ADDLW  86
08AE0:  MOVWF  FE9
08AE2:  MOVLW  07
08AE4:  ADDWFC 03,W
08AE6:  MOVWF  FEA
08AE8:  MOVF   FEF,F
08AEA:  BNZ   8AF0
08AEC:  MOVF   FEC,F
08AEE:  BZ    8AF4
08AF0:  MOVLW  00
08AF2:  BRA    8AF6
08AF4:  MOVLW  01
08AF6:  MOVLB  8
08AF8:  MOVFF  8B7,FEA
08AFC:  MOVFF  8B6,FE9
08B00:  CLRF   FEC
08B02:  MOVF   FED,F
08B04:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08B06:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08B08:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08B0A:  BCF    FD8.0
08B0C:  MOVLB  7
08B0E:  RLCF   x40,W
08B10:  CLRF   03
08B12:  ADDLW  42
08B14:  MOVWF  FE9
08B16:  MOVLW  07
08B18:  ADDWFC 03,W
08B1A:  MOVWF  FEA
08B1C:  MOVF   FEF,F
08B1E:  BNZ   8B28
08B20:  MOVF   FEC,F
08B22:  BNZ   8B28
08B24:  BCF    F8D.2
08B26:  BRA    8B2A
08B28:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08B2A:  BCF    FD8.0
08B2C:  RLCF   x40,W
08B2E:  CLRF   03
08B30:  ADDLW  46
08B32:  MOVWF  FE9
08B34:  MOVLW  07
08B36:  ADDWFC 03,W
08B38:  MOVWF  FEA
08B3A:  MOVF   FEF,F
08B3C:  BNZ   8B46
08B3E:  MOVF   FEC,F
08B40:  BNZ   8B46
08B42:  BCF    F8D.3
08B44:  BRA    8B48
08B46:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08B48:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08B4A:  BCF    FD8.0
08B4C:  RLCF   x40,W
08B4E:  CLRF   03
08B50:  ADDLW  86
08B52:  MOVWF  FE9
08B54:  MOVLW  07
08B56:  ADDWFC 03,W
08B58:  MOVWF  FEA
08B5A:  MOVF   FEF,F
08B5C:  BNZ   8B66
08B5E:  MOVF   FEC,F
08B60:  BNZ   8B66
08B62:  BCF    F8D.5
08B64:  BRA    8B68
08B66:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08B68:  BCF    FD8.0
08B6A:  RLCF   x40,W
08B6C:  CLRF   03
08B6E:  ADDLW  56
08B70:  MOVWF  FE9
08B72:  MOVLW  07
08B74:  ADDWFC 03,W
08B76:  MOVWF  FEA
08B78:  MOVFF  FEC,8B7
08B7C:  MOVF   FED,F
08B7E:  MOVFF  FEF,8B6
08B82:  MOVLB  8
08B84:  RRCF   xB7,F
08B86:  RRCF   xB6,F
08B88:  RRCF   xB7,F
08B8A:  RRCF   xB6,F
08B8C:  RRCF   xB7,F
08B8E:  MOVFF  8B6,F4F
08B92:  RRCF   xB7,F
08B94:  RRCF   xB7,W
08B96:  ANDLW  30
08B98:  MOVWF  00
08B9A:  MOVLB  F
08B9C:  MOVF   x4E,W
08B9E:  ANDLW  CF
08BA0:  IORWF  00,W
08BA2:  MOVWF  x4E
08BA4:  MOVLB  0
08BA6:  GOTO   8C1C (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
08970:  MOVLB  8
08972:  MOVF   xCA,F
08974:  BZ    897C
....................       output_bit(VENC1,ON); 
08976:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
08978:  BSF    F8E.7
....................    } 
0897A:  BRA    8980
....................    else {       
....................       output_bit(VENC1,OFF); 
0897C:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
0897E:  BCF    F8E.7
....................    } 
08980:  MOVLB  0
08982:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08D0A:  MOVLB  8
08D0C:  MOVF   xCB,F
08D0E:  BNZ   8D36
08D10:  MOVF   xCC,F
08D12:  BNZ   8D36
....................       edge_mode=0; 
08D14:  MOVLB  7
08D16:  CLRF   xAA
....................       switch (motor){ 
08D18:  MOVF   x40,W
08D1A:  XORLW  00
08D1C:  MOVLB  0
08D1E:  BZ    8D26
08D20:  XORLW  01
08D22:  BZ    8D2E
08D24:  BRA    8D34
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08D26:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08D28:  BSF    FF0.3
08D2A:  BCF    FF1.5
....................             break; 
08D2C:  BRA    8D34
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08D2E:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08D30:  BSF    FF0.4
08D32:  BCF    FF1.4
....................             break; 
08D34:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08D36:  DECFSZ xCB,W
08D38:  BRA    8D60
08D3A:  MOVF   xCC,F
08D3C:  BNZ   8D60
....................       edge_mode=0; 
08D3E:  MOVLB  7
08D40:  CLRF   xAA
....................       switch (motor){ 
08D42:  MOVF   x40,W
08D44:  XORLW  00
08D46:  MOVLB  0
08D48:  BZ    8D50
08D4A:  XORLW  01
08D4C:  BZ    8D58
08D4E:  BRA    8D5E
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08D50:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08D52:  BSF    FF0.3
08D54:  BSF    FF1.5
....................             break; 
08D56:  BRA    8D5E
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08D58:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08D5A:  BSF    FF0.4
08D5C:  BSF    FF1.4
....................             break; 
08D5E:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08D60:  MOVF   xCB,W
08D62:  SUBLW  02
08D64:  BNZ   8DB6
08D66:  MOVF   xCC,F
08D68:  BNZ   8DB6
08D6A:  BCF    FD8.0
08D6C:  MOVLB  7
08D6E:  RLCF   x40,W
08D70:  CLRF   03
08D72:  ADDLW  6A
08D74:  MOVWF  FE9
08D76:  MOVLW  07
08D78:  ADDWFC 03,W
08D7A:  MOVWF  FEA
08D7C:  MOVFF  FEC,8CE
08D80:  MOVF   FED,F
08D82:  MOVFF  FEF,8CD
08D86:  MOVLB  8
08D88:  MOVF   xCD,W
08D8A:  SUBLW  02
08D8C:  BNZ   8DB6
08D8E:  MOVF   xCE,F
08D90:  BNZ   8DB6
....................       edge_mode=1; 
08D92:  MOVLW  01
08D94:  MOVLB  7
08D96:  MOVWF  xAA
....................       switch (motor){ 
08D98:  MOVF   x40,W
08D9A:  XORLW  00
08D9C:  MOVLB  0
08D9E:  BZ    8DA6
08DA0:  XORLW  01
08DA2:  BZ    8DAE
08DA4:  BRA    8DB4
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08DA6:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08DA8:  BSF    FF0.3
08DAA:  BSF    FF1.5
....................             break; 
08DAC:  BRA    8DB4
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08DAE:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08DB0:  BSF    FF0.4
08DB2:  BSF    FF1.4
....................             break; 
08DB4:  MOVLB  8
....................       }  
....................    }     
08DB6:  MOVLB  0
08DB8:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08F20:  MOVLB  7
08F22:  MOVF   x40,W
08F24:  XORLW  00
08F26:  MOVLB  0
08F28:  BZ    8F30
08F2A:  XORLW  01
08F2C:  BZ    8F5A
08F2E:  BRA    8F82
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08F30:  BCF    FD8.0
08F32:  MOVLB  7
08F34:  RLCF   x40,W
08F36:  CLRF   03
08F38:  ADDLW  96
08F3A:  MOVWF  FE9
08F3C:  MOVLW  07
08F3E:  ADDWFC 03,W
08F40:  MOVWF  FEA
08F42:  MOVFF  FEC,8CE
08F46:  MOVF   FED,F
08F48:  MOVFF  FEF,8CD
08F4C:  MOVLW  6E
08F4E:  MOVLB  8
08F50:  MOVWF  xCC
08F52:  MOVLB  0
08F54:  CALL   4FAE
....................          break; 
08F58:  BRA    8F82
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08F5A:  BCF    FD8.0
08F5C:  MOVLB  7
08F5E:  RLCF   x40,W
08F60:  CLRF   03
08F62:  ADDLW  96
08F64:  MOVWF  FE9
08F66:  MOVLW  07
08F68:  ADDWFC 03,W
08F6A:  MOVWF  FEA
08F6C:  MOVFF  FEC,8CE
08F70:  MOVF   FED,F
08F72:  MOVFF  FEF,8CD
08F76:  MOVLW  70
08F78:  MOVLB  8
08F7A:  MOVWF  xCC
08F7C:  MOVLB  0
08F7E:  CALL   4FAE
....................          break;          
....................    } 
08F82:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08DBA:  MOVLB  8
08DBC:  MOVF   xCA,F
08DBE:  BNZ   8DDC
....................    { 
....................       switch (motor) 
08DC0:  MOVLB  7
08DC2:  MOVF   x40,W
08DC4:  XORLW  00
08DC6:  MOVLB  0
08DC8:  BZ    8DD0
08DCA:  XORLW  01
08DCC:  BZ    8DD6
08DCE:  BRA    8DDA
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08DD0:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08DD2:  BCF    FF0.3
....................             break; 
08DD4:  BRA    8DDA
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08DD6:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08DD8:  BCF    FF0.4
....................             break; 
08DDA:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08DDC:  DECFSZ xCA,W
08DDE:  BRA    8E44
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08DE0:  BCF    FD8.0
08DE2:  MOVLB  7
08DE4:  RLCF   x40,W
08DE6:  CLRF   03
08DE8:  ADDLW  6A
08DEA:  MOVWF  FE9
08DEC:  MOVLW  07
08DEE:  ADDWFC 03,W
08DF0:  MOVWF  FEA
08DF2:  MOVFF  FEC,8CC
08DF6:  MOVF   FED,F
08DF8:  MOVFF  FEF,8CB
08DFC:  MOVLB  8
08DFE:  DECFSZ xCB,W
08E00:  BRA    8E10
08E02:  MOVF   xCC,F
08E04:  BNZ   8E10
08E06:  CLRF   xCC
08E08:  CLRF   xCB
08E0A:  MOVLB  0
08E0C:  RCALL  8D0A
08E0E:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08E10:  BCF    FD8.0
08E12:  MOVLB  7
08E14:  RLCF   x40,W
08E16:  CLRF   03
08E18:  ADDLW  6A
08E1A:  MOVWF  FE9
08E1C:  MOVLW  07
08E1E:  ADDWFC 03,W
08E20:  MOVWF  FEA
08E22:  MOVFF  FEC,8CC
08E26:  MOVF   FED,F
08E28:  MOVFF  FEF,8CB
08E2C:  MOVLB  8
08E2E:  MOVF   xCB,W
08E30:  SUBLW  02
08E32:  BNZ   8E44
08E34:  MOVF   xCC,F
08E36:  BNZ   8E44
08E38:  CLRF   xCC
08E3A:  MOVLW  01
08E3C:  MOVWF  xCB
08E3E:  MOVLB  0
08E40:  RCALL  8D0A
08E42:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08E44:  MOVF   xCA,W
08E46:  SUBLW  02
08E48:  BNZ   8E7E
08E4A:  BCF    FD8.0
08E4C:  MOVLB  7
08E4E:  RLCF   x40,W
08E50:  CLRF   03
08E52:  ADDLW  6A
08E54:  MOVWF  FE9
08E56:  MOVLW  07
08E58:  ADDWFC 03,W
08E5A:  MOVWF  FEA
08E5C:  MOVFF  FEC,8CC
08E60:  MOVF   FED,F
08E62:  MOVFF  FEF,8CB
08E66:  MOVLB  8
08E68:  MOVF   xCB,W
08E6A:  SUBLW  02
08E6C:  BNZ   8E7E
08E6E:  MOVF   xCC,F
08E70:  BNZ   8E7E
....................    { 
....................       enable_enc_isr(2);   
08E72:  CLRF   xCC
08E74:  MOVLW  02
08E76:  MOVWF  xCB
08E78:  MOVLB  0
08E7A:  RCALL  8D0A
08E7C:  MOVLB  8
....................    } 
08E7E:  MOVLB  0
08E80:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08BAA:  BCF    FD8.0
08BAC:  MOVLB  7
08BAE:  RLCF   x40,W
08BB0:  CLRF   03
08BB2:  ADDLW  8E
08BB4:  MOVWF  FE9
08BB6:  MOVLW  07
08BB8:  ADDWFC 03,W
08BBA:  MOVWF  FEA
08BBC:  CLRF   FEC
08BBE:  MOVF   FED,F
08BC0:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08BC2:  BCF    FD8.0
08BC4:  RLCF   x40,W
08BC6:  CLRF   03
08BC8:  ADDLW  BB
08BCA:  MOVWF  FE9
08BCC:  MOVLW  07
08BCE:  ADDWFC 03,W
08BD0:  MOVWF  FEA
08BD2:  CLRF   FEC
08BD4:  MOVF   FED,F
08BD6:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08BD8:  BCF    FD8.0
08BDA:  RLCF   x40,W
08BDC:  CLRF   03
08BDE:  ADDLW  9A
08BE0:  MOVWF  FE9
08BE2:  MOVLW  07
08BE4:  ADDWFC 03,W
08BE6:  MOVWF  FEA
08BE8:  CLRF   FEC
08BEA:  MOVF   FED,F
08BEC:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08BEE:  BSF    F8E.1
....................    enc_pwr(ON); 
08BF0:  MOVLW  01
08BF2:  MOVLB  8
08BF4:  MOVWF  xCA
08BF6:  MOVLB  0
08BF8:  RCALL  8970
....................    delay_ms(100); 
08BFA:  MOVLW  64
08BFC:  MOVLB  A
08BFE:  MOVWF  xA2
08C00:  MOVLB  0
08C02:  CALL   0588
....................     
....................    switch (motor){ 
08C06:  MOVLB  7
08C08:  MOVF   x40,W
08C0A:  XORLW  00
08C0C:  MOVLB  0
08C0E:  BZ    8C16
08C10:  XORLW  01
08C12:  BZ    8C1A
08C14:  BRA    8C1C
....................       case 0 : motor_setup1(); 
08C16:  BRA    8984
....................          break; 
08C18:  BRA    8C1C
....................       case 1 : motor_setup2(); 
08C1A:  BRA    8A96
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08C1C:  BCF    FD8.0
08C1E:  MOVLB  7
08C20:  RLCF   x40,W
08C22:  CLRF   03
08C24:  ADDLW  8A
08C26:  MOVWF  FE9
08C28:  MOVLW  07
08C2A:  ADDWFC 03,W
08C2C:  MOVWF  FEA
08C2E:  MOVFF  FEC,8B7
08C32:  MOVF   FED,F
08C34:  MOVFF  FEF,8B6
08C38:  BCF    FD8.0
08C3A:  RLCF   x40,W
08C3C:  CLRF   03
08C3E:  ADDLW  86
08C40:  MOVWF  FE9
08C42:  MOVLW  07
08C44:  ADDWFC 03,W
08C46:  MOVWF  FEA
08C48:  MOVFF  FEC,03
08C4C:  MOVF   FED,F
08C4E:  MOVF   FEF,W
08C50:  MOVLB  8
08C52:  SUBWF  xB6,W
08C54:  BNZ   8C5C
08C56:  MOVF   03,W
08C58:  SUBWF  xB7,W
08C5A:  BZ    8D04
....................       m_way_rst[motor]=m_way[motor]; 
08C5C:  BCF    FD8.0
08C5E:  MOVLB  7
08C60:  RLCF   x40,W
08C62:  CLRF   03
08C64:  ADDLW  8A
08C66:  MOVWF  01
08C68:  MOVLW  07
08C6A:  ADDWFC 03,F
08C6C:  MOVLB  8
08C6E:  MOVFF  03,8B7
08C72:  BCF    FD8.0
08C74:  MOVLB  7
08C76:  RLCF   x40,W
08C78:  CLRF   03
08C7A:  ADDLW  86
08C7C:  MOVWF  FE9
08C7E:  MOVLW  07
08C80:  ADDWFC 03,W
08C82:  MOVWF  FEA
08C84:  MOVFF  FEC,03
08C88:  MOVF   FED,F
08C8A:  MOVFF  FEF,8B8
08C8E:  MOVLB  8
08C90:  MOVFF  8B7,FEA
08C94:  MOVFF  01,FE9
08C98:  MOVFF  03,FEC
08C9C:  MOVF   FED,F
08C9E:  MOVFF  8B8,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08CA2:  BCF    FD8.0
08CA4:  MOVLB  7
08CA6:  RLCF   x40,W
08CA8:  CLRF   03
08CAA:  ADDLW  9E
08CAC:  MOVWF  01
08CAE:  MOVLW  07
08CB0:  ADDWFC 03,F
08CB2:  MOVLB  8
08CB4:  MOVFF  03,8B7
08CB8:  BCF    FD8.0
08CBA:  MOVLB  7
08CBC:  RLCF   x40,W
08CBE:  CLRF   03
08CC0:  ADDLW  66
08CC2:  MOVWF  FE9
08CC4:  MOVLW  07
08CC6:  ADDWFC 03,W
08CC8:  MOVWF  FEA
08CCA:  MOVFF  FEC,03
08CCE:  MOVF   FED,F
08CD0:  MOVFF  FEF,8B8
08CD4:  MOVLB  8
08CD6:  MOVFF  8B7,FEA
08CDA:  MOVFF  01,FE9
08CDE:  MOVFF  03,FEC
08CE2:  MOVF   FED,F
08CE4:  MOVFF  8B8,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08CE8:  BCF    FD8.0
08CEA:  MOVLB  7
08CEC:  RLCF   x40,W
08CEE:  CLRF   03
08CF0:  ADDLW  66
08CF2:  MOVWF  FE9
08CF4:  MOVLW  07
08CF6:  ADDWFC 03,W
08CF8:  MOVWF  FEA
08CFA:  CLRF   FEC
08CFC:  MOVF   FED,F
08CFE:  MOVLW  05
08D00:  MOVWF  FEF
08D02:  MOVLB  8
....................    } 
08D04:  MOVLB  0
08D06:  GOTO   8E84 (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08E82:  BRA    8BAA
....................     
....................    m_comp[motor]=FALSE; 
08E84:  BCF    FD8.0
08E86:  MOVLB  7
08E88:  RLCF   x40,W
08E8A:  CLRF   03
08E8C:  ADDLW  AF
08E8E:  MOVWF  FE9
08E90:  MOVLW  07
08E92:  ADDWFC 03,W
08E94:  MOVWF  FEA
08E96:  CLRF   FEC
08E98:  MOVF   FED,F
08E9A:  CLRF   FEF
....................     
....................    switch (motor){ 
08E9C:  MOVF   x40,W
08E9E:  XORLW  00
08EA0:  MOVLB  0
08EA2:  BZ    8EAA
08EA4:  XORLW  01
08EA6:  BZ    8EBC
08EA8:  BRA    8ECC
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08EAA:  MOVLW  B2
08EAC:  MOVLB  8
08EAE:  MOVWF  xCC
08EB0:  CLRF   xCE
08EB2:  CLRF   xCD
08EB4:  MOVLB  0
08EB6:  CALL   4FAE
....................          break; 
08EBA:  BRA    8ECC
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08EBC:  MOVLW  B4
08EBE:  MOVLB  8
08EC0:  MOVWF  xCC
08EC2:  CLRF   xCE
08EC4:  CLRF   xCD
08EC6:  MOVLB  0
08EC8:  CALL   4FAE
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08ECC:  MOVLB  7
08ECE:  MOVF   x40,W
08ED0:  XORLW  00
08ED2:  MOVLB  0
08ED4:  BZ    8EDC
08ED6:  XORLW  01
08ED8:  BZ    8EE0
08EDA:  BRA    8EE2
....................       case 0 : output_bit(M1_ENABLE, ON); 
08EDC:  BSF    F90.1
....................          break; 
08EDE:  BRA    8EE2
....................       case 1 : output_bit(M2_ENABLE, ON); 
08EE0:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08EE2:  MOVLW  32
08EE4:  MOVLB  A
08EE6:  MOVWF  xA2
08EE8:  MOVLB  0
08EEA:  CALL   0588
....................     
....................    set_timer3(STEP_INTERVAL); 
08EEE:  MOVLW  F9
08EF0:  MOVWF  FB3
08EF2:  MOVLW  C0
08EF4:  MOVWF  FB2
....................    enc_isr(int_mode); 
08EF6:  MOVFF  8B5,8CA
08EFA:  RCALL  8DBA
....................    clear_interrupt(INT_TIMER3); 
08EFC:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08EFE:  BCF    FD8.0
08F00:  MOVLB  7
08F02:  RLCF   x40,W
08F04:  CLRF   03
08F06:  ADDLW  92
08F08:  MOVWF  FE9
08F0A:  MOVLW  07
08F0C:  ADDWFC 03,W
08F0E:  MOVWF  FEA
08F10:  CLRF   FEC
08F12:  MOVF   FED,F
08F14:  MOVLW  01
08F16:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08F18:  BSF    FA0.1
08F1A:  MOVLB  0
08F1C:  GOTO   A194 (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
085A6:  MOVFF  8B8,8C0
085AA:  MOVFF  8B7,8BF
085AE:  MOVFF  8B6,8BE
085B2:  MOVFF  8B5,8BD
....................    enc_res    = e_cpr[motor]; 
085B6:  BCF    FD8.0
085B8:  MOVLB  7
085BA:  RLCF   x40,W
085BC:  CLRF   03
085BE:  ADDLW  5E
085C0:  MOVWF  FE9
085C2:  MOVLW  07
085C4:  ADDWFC 03,W
085C6:  MOVWF  FEA
085C8:  MOVLB  8
085CA:  CLRF   xC4
085CC:  CLRF   xC3
085CE:  MOVFF  FEC,8C2
085D2:  MOVF   FED,F
085D4:  MOVFF  FEF,8C1
....................    ports      = e_ppr[motor]; 
085D8:  BCF    FD8.0
085DA:  MOVLB  7
085DC:  RLCF   x40,W
085DE:  CLRF   03
085E0:  ADDLW  62
085E2:  MOVWF  FE9
085E4:  MOVLW  07
085E6:  ADDWFC 03,W
085E8:  MOVWF  FEA
085EA:  MOVLB  8
085EC:  CLRF   xCC
085EE:  CLRF   xCB
085F0:  MOVFF  FEC,8CA
085F4:  MOVF   FED,F
085F6:  MOVFF  FEF,8C9
....................     
....................    enc_res = enc_res * 1000; 
085FA:  MOVFF  8C4,9D7
085FE:  MOVFF  8C3,9D6
08602:  MOVFF  8C2,9D5
08606:  MOVFF  8C1,9D4
0860A:  MOVLB  9
0860C:  CLRF   xDB
0860E:  CLRF   xDA
08610:  MOVLW  03
08612:  MOVWF  xD9
08614:  MOVLW  E8
08616:  MOVWF  xD8
08618:  MOVLB  0
0861A:  CALL   47D4
0861E:  MOVFF  03,8C4
08622:  MOVFF  02,8C3
08626:  MOVFF  01,8C2
0862A:  MOVFF  00,8C1
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
0862E:  BCF    FD8.1
08630:  CLRF   1B
08632:  BTFSC  FF2.7
08634:  BSF    1B.7
08636:  BCF    FF2.7
08638:  MOVFF  8C4,A28
0863C:  MOVFF  8C3,A27
08640:  MOVFF  8C2,A26
08644:  MOVFF  8C1,A25
08648:  MOVFF  8CC,A2C
0864C:  MOVFF  8CB,A2B
08650:  MOVFF  8CA,A2A
08654:  MOVFF  8C9,A29
08658:  CALL   1080
0865C:  BTFSC  1B.7
0865E:  BSF    FF2.7
08660:  MOVFF  03,8BC
08664:  MOVFF  02,8BB
08668:  MOVFF  01,8BA
0866C:  MOVFF  00,8B9
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
08670:  MOVFF  8B8,9D7
08674:  MOVFF  8B7,9D6
08678:  MOVFF  8B6,9D5
0867C:  MOVFF  8B5,9D4
08680:  MOVFF  8BC,9DB
08684:  MOVFF  8BB,9DA
08688:  MOVFF  8BA,9D9
0868C:  MOVFF  8B9,9D8
08690:  CALL   47D4
08694:  MOVLB  8
08696:  MOVF   xB9,W
08698:  SUBWF  00,W
0869A:  MOVWF  xBD
0869C:  MOVF   xBA,W
0869E:  SUBWFB 01,W
086A0:  MOVWF  xBE
086A2:  MOVF   xBB,W
086A4:  SUBWFB 02,W
086A6:  MOVWF  xBF
086A8:  MOVF   xBC,W
086AA:  SUBWFB 03,W
086AC:  MOVWF  xC0
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
086AE:  BCF    FD8.1
086B0:  CLRF   1B
086B2:  BTFSC  FF2.7
086B4:  BSF    1B.7
086B6:  BCF    FF2.7
086B8:  MOVFF  8C0,A28
086BC:  MOVFF  8BF,A27
086C0:  MOVFF  8BE,A26
086C4:  MOVFF  8BD,A25
086C8:  MOVLB  A
086CA:  CLRF   x2C
086CC:  CLRF   x2B
086CE:  MOVLW  03
086D0:  MOVWF  x2A
086D2:  MOVLW  E8
086D4:  MOVWF  x29
086D6:  MOVLB  0
086D8:  CALL   1080
086DC:  BTFSC  1B.7
086DE:  BSF    FF2.7
086E0:  MOVFF  03,8C8
086E4:  MOVFF  02,8C7
086E8:  MOVFF  01,8C6
086EC:  MOVFF  00,8C5
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
086F0:  MOVFF  8C8,9D7
086F4:  MOVFF  8C7,9D6
086F8:  MOVFF  8C6,9D5
086FC:  MOVFF  8C5,9D4
08700:  MOVLB  9
08702:  CLRF   xDB
08704:  CLRF   xDA
08706:  MOVLW  03
08708:  MOVWF  xD9
0870A:  MOVLW  E8
0870C:  MOVWF  xD8
0870E:  MOVLB  0
08710:  CALL   47D4
08714:  MOVFF  03,8C8
08718:  MOVFF  02,8C7
0871C:  MOVFF  01,8C6
08720:  MOVFF  00,8C5
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
08724:  MOVLB  8
08726:  MOVF   xC5,W
08728:  SUBWF  xBD,F
0872A:  MOVF   xC6,W
0872C:  SUBWFB xBE,F
0872E:  MOVF   xC7,W
08730:  SUBWFB xBF,F
08732:  MOVF   xC8,W
08734:  SUBWFB xC0,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
08736:  BCF    FD8.1
08738:  CLRF   1B
0873A:  BTFSC  FF2.7
0873C:  BSF    1B.7
0873E:  BCF    FF2.7
08740:  MOVFF  8C8,A28
08744:  MOVFF  8C7,A27
08748:  MOVFF  8C6,A26
0874C:  MOVFF  8C5,A25
08750:  MOVLB  A
08752:  CLRF   x2C
08754:  CLRF   x2B
08756:  MOVLW  03
08758:  MOVWF  x2A
0875A:  MOVLW  E8
0875C:  MOVWF  x29
0875E:  MOVLB  0
08760:  CALL   1080
08764:  BTFSC  1B.7
08766:  BSF    FF2.7
08768:  MOVFF  03,8C8
0876C:  MOVFF  02,8C7
08770:  MOVFF  01,8C6
08774:  MOVFF  00,8C5
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
08778:  MOVLB  8
0877A:  MOVF   xC0,F
0877C:  BNZ   8792
0877E:  MOVF   xBF,F
08780:  BNZ   8792
08782:  MOVF   xBE,W
08784:  SUBLW  00
08786:  BC    87A2
08788:  XORLW  FF
0878A:  BNZ   8792
0878C:  MOVF   xBD,W
0878E:  SUBLW  F3
08790:  BC    87A2
08792:  MOVLW  01
08794:  ADDWF  xC5,F
08796:  BTFSC  FD8.0
08798:  INCF   xC6,F
0879A:  BTFSC  FD8.2
0879C:  INCF   xC7,F
0879E:  BTFSC  FD8.2
087A0:  INCF   xC8,F
....................    return(enc_pos); 
087A2:  MOVFF  8C5,00
087A6:  MOVFF  8C6,01
087AA:  MOVFF  8C7,02
087AE:  MOVFF  8C8,03
087B2:  MOVLB  0
087B4:  GOTO   A11C (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
087B8:  BCF    FD8.0
087BA:  MOVLB  7
087BC:  RLCF   x40,W
087BE:  CLRF   03
087C0:  ADDLW  BF
087C2:  MOVWF  FE9
087C4:  MOVLW  07
087C6:  ADDWFC 03,W
087C8:  MOVWF  FEA
087CA:  MOVFF  FEC,03
087CE:  MOVF   FED,F
087D0:  MOVFF  FEF,01
087D4:  MOVF   03,W
087D6:  MOVLB  8
087D8:  SUBWF  xB8,W
087DA:  BNC   88A2
087DC:  BNZ   87E4
087DE:  MOVF   xB7,W
087E0:  SUBWF  01,W
087E2:  BC    88A2
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
087E4:  BCF    FD8.0
087E6:  MOVLB  7
087E8:  RLCF   x40,W
087EA:  CLRF   03
087EC:  ADDLW  BF
087EE:  MOVWF  FE9
087F0:  MOVLW  07
087F2:  ADDWFC 03,W
087F4:  MOVWF  FEA
087F6:  MOVFF  FEC,03
087FA:  MOVF   FED,F
087FC:  MOVF   FEF,W
087FE:  MOVLB  8
08800:  SUBWF  xB7,W
08802:  MOVWF  xB9
08804:  MOVF   03,W
08806:  SUBWFB xB8,W
08808:  MOVWF  xBA
....................       if (e_pos_r > (e_cpr[motor]/2)) 
0880A:  BCF    FD8.0
0880C:  MOVLB  7
0880E:  RLCF   x40,W
08810:  CLRF   03
08812:  ADDLW  5E
08814:  MOVWF  FE9
08816:  MOVLW  07
08818:  ADDWFC 03,W
0881A:  MOVWF  FEA
0881C:  MOVFF  FEC,8BC
08820:  MOVF   FED,F
08822:  MOVFF  FEF,8BB
08826:  BCF    FD8.0
08828:  MOVLB  8
0882A:  RRCF   xBC,W
0882C:  MOVWF  03
0882E:  RRCF   xBB,W
08830:  MOVWF  02
08832:  MOVWF  01
08834:  MOVF   03,W
08836:  SUBWF  xBA,W
08838:  BNC   8886
0883A:  BNZ   8842
0883C:  MOVF   xB9,W
0883E:  SUBWF  01,W
08840:  BC    8886
....................       { 
....................          m_way[motor] = NEG; 
08842:  BCF    FD8.0
08844:  MOVLB  7
08846:  RLCF   x40,W
08848:  CLRF   03
0884A:  ADDLW  86
0884C:  MOVWF  FE9
0884E:  MOVLW  07
08850:  ADDWFC 03,W
08852:  MOVWF  FEA
08854:  CLRF   FEC
08856:  MOVF   FED,F
08858:  MOVLW  01
0885A:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
0885C:  BCF    FD8.0
0885E:  RLCF   x40,W
08860:  CLRF   03
08862:  ADDLW  5E
08864:  MOVWF  FE9
08866:  MOVLW  07
08868:  ADDWFC 03,W
0886A:  MOVWF  FEA
0886C:  MOVFF  FEC,8BC
08870:  MOVF   FED,F
08872:  MOVFF  FEF,8BB
08876:  MOVLB  8
08878:  MOVF   xB9,W
0887A:  SUBWF  xBB,W
0887C:  MOVWF  xB9
0887E:  MOVF   xBA,W
08880:  SUBWFB xBC,W
08882:  MOVWF  xBA
....................       } 
08884:  BRA    88A0
....................       else 
....................       { 
....................          m_way[motor] = POS; 
08886:  BCF    FD8.0
08888:  MOVLB  7
0888A:  RLCF   x40,W
0888C:  CLRF   03
0888E:  ADDLW  86
08890:  MOVWF  FE9
08892:  MOVLW  07
08894:  ADDWFC 03,W
08896:  MOVWF  FEA
08898:  CLRF   FEC
0889A:  MOVF   FED,F
0889C:  CLRF   FEF
0889E:  MOVLB  8
....................       } 
....................    } 
088A0:  BRA    8962
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
088A2:  BCF    FD8.0
088A4:  MOVLB  7
088A6:  RLCF   x40,W
088A8:  CLRF   03
088AA:  ADDLW  BF
088AC:  MOVWF  FE9
088AE:  MOVLW  07
088B0:  ADDWFC 03,W
088B2:  MOVWF  FEA
088B4:  MOVFF  FEC,8BC
088B8:  MOVF   FED,F
088BA:  MOVFF  FEF,8BB
088BE:  MOVLB  8
088C0:  MOVF   xB7,W
088C2:  SUBWF  xBB,W
088C4:  MOVWF  xB9
088C6:  MOVF   xB8,W
088C8:  SUBWFB xBC,W
088CA:  MOVWF  xBA
....................       if (e_pos_r > (e_cpr[motor]/2)) 
088CC:  BCF    FD8.0
088CE:  MOVLB  7
088D0:  RLCF   x40,W
088D2:  CLRF   03
088D4:  ADDLW  5E
088D6:  MOVWF  FE9
088D8:  MOVLW  07
088DA:  ADDWFC 03,W
088DC:  MOVWF  FEA
088DE:  MOVFF  FEC,8BC
088E2:  MOVF   FED,F
088E4:  MOVFF  FEF,8BB
088E8:  BCF    FD8.0
088EA:  MOVLB  8
088EC:  RRCF   xBC,W
088EE:  MOVWF  03
088F0:  RRCF   xBB,W
088F2:  MOVWF  02
088F4:  MOVWF  01
088F6:  MOVF   03,W
088F8:  SUBWF  xBA,W
088FA:  BNC   8946
088FC:  BNZ   8904
088FE:  MOVF   xB9,W
08900:  SUBWF  01,W
08902:  BC    8946
....................       { 
....................          m_way[motor] = POS; 
08904:  BCF    FD8.0
08906:  MOVLB  7
08908:  RLCF   x40,W
0890A:  CLRF   03
0890C:  ADDLW  86
0890E:  MOVWF  FE9
08910:  MOVLW  07
08912:  ADDWFC 03,W
08914:  MOVWF  FEA
08916:  CLRF   FEC
08918:  MOVF   FED,F
0891A:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
0891C:  BCF    FD8.0
0891E:  RLCF   x40,W
08920:  CLRF   03
08922:  ADDLW  5E
08924:  MOVWF  FE9
08926:  MOVLW  07
08928:  ADDWFC 03,W
0892A:  MOVWF  FEA
0892C:  MOVFF  FEC,8BC
08930:  MOVF   FED,F
08932:  MOVFF  FEF,8BB
08936:  MOVLB  8
08938:  MOVF   xB9,W
0893A:  SUBWF  xBB,W
0893C:  MOVWF  xB9
0893E:  MOVF   xBA,W
08940:  SUBWFB xBC,W
08942:  MOVWF  xBA
....................       } 
08944:  BRA    8962
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
08946:  BCF    FD8.0
08948:  MOVLB  7
0894A:  RLCF   x40,W
0894C:  CLRF   03
0894E:  ADDLW  86
08950:  MOVWF  FE9
08952:  MOVLW  07
08954:  ADDWFC 03,W
08956:  MOVWF  FEA
08958:  CLRF   FEC
0895A:  MOVF   FED,F
0895C:  MOVLW  01
0895E:  MOVWF  FEF
08960:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
08962:  MOVFF  8B9,01
08966:  MOVFF  8BA,02
0896A:  MOVLB  0
0896C:  GOTO   A148 (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
09070:  BCF    FD8.0
09072:  MOVLB  7
09074:  RLCF   x40,W
09076:  CLRF   03
09078:  ADDLW  92
0907A:  MOVWF  FE9
0907C:  MOVLW  07
0907E:  ADDWFC 03,W
09080:  MOVWF  FEA
09082:  CLRF   FEC
09084:  MOVF   FED,F
09086:  CLRF   FEF
....................           
....................    switch (motor){ 
09088:  MOVF   x40,W
0908A:  XORLW  00
0908C:  MOVLB  0
0908E:  BZ    9096
09090:  XORLW  01
09092:  BZ    9100
09094:  BRA    916E
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
09096:  BCF    FD8.0
09098:  MOVLB  7
0909A:  RLCF   x40,W
0909C:  CLRF   03
0909E:  ADDLW  52
090A0:  MOVWF  FE9
090A2:  MOVLW  07
090A4:  ADDWFC 03,W
090A6:  MOVWF  FEA
090A8:  MOVFF  FEC,8CB
090AC:  MOVF   FED,F
090AE:  MOVFF  FEF,8CA
090B2:  MOVLB  8
090B4:  MOVF   xCA,F
090B6:  BNZ   90BC
090B8:  MOVF   xCB,F
090BA:  BZ    90FA
090BC:  BCF    FD8.0
090BE:  MOVLB  7
090C0:  RLCF   x40,W
090C2:  CLRF   03
090C4:  ADDLW  52
090C6:  MOVWF  FE9
090C8:  MOVLW  07
090CA:  ADDWFC 03,W
090CC:  MOVWF  FEA
090CE:  MOVFF  FEC,8CB
090D2:  MOVF   FED,F
090D4:  MOVFF  FEF,8CA
090D8:  MOVLB  8
090DA:  RRCF   xCB,F
090DC:  RRCF   xCA,F
090DE:  RRCF   xCB,F
090E0:  RRCF   xCA,F
090E2:  RRCF   xCB,F
090E4:  MOVFF  8CA,FBC
090E8:  RRCF   xCB,F
090EA:  RRCF   xCB,W
090EC:  ANDLW  30
090EE:  MOVWF  00
090F0:  MOVF   FBB,W
090F2:  ANDLW  CF
090F4:  IORWF  00,W
090F6:  MOVWF  FBB
090F8:  BRA    90FC
....................                else output_bit(M1_ENABLE, OFF); 
090FA:  BCF    F90.1
....................          break;   
090FC:  MOVLB  0
090FE:  BRA    916E
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
09100:  BCF    FD8.0
09102:  MOVLB  7
09104:  RLCF   x40,W
09106:  CLRF   03
09108:  ADDLW  52
0910A:  MOVWF  FE9
0910C:  MOVLW  07
0910E:  ADDWFC 03,W
09110:  MOVWF  FEA
09112:  MOVFF  FEC,8CB
09116:  MOVF   FED,F
09118:  MOVFF  FEF,8CA
0911C:  MOVLB  8
0911E:  MOVF   xCA,F
09120:  BNZ   9126
09122:  MOVF   xCB,F
09124:  BZ    9168
09126:  BCF    FD8.0
09128:  MOVLB  7
0912A:  RLCF   x40,W
0912C:  CLRF   03
0912E:  ADDLW  52
09130:  MOVWF  FE9
09132:  MOVLW  07
09134:  ADDWFC 03,W
09136:  MOVWF  FEA
09138:  MOVFF  FEC,8CB
0913C:  MOVF   FED,F
0913E:  MOVFF  FEF,8CA
09142:  MOVLB  8
09144:  RRCF   xCB,F
09146:  RRCF   xCA,F
09148:  RRCF   xCB,F
0914A:  RRCF   xCA,F
0914C:  RRCF   xCB,F
0914E:  MOVFF  8CA,F4F
09152:  RRCF   xCB,F
09154:  RRCF   xCB,W
09156:  ANDLW  30
09158:  MOVWF  00
0915A:  MOVLB  F
0915C:  MOVF   x4E,W
0915E:  ANDLW  CF
09160:  IORWF  00,W
09162:  MOVWF  x4E
09164:  BRA    916C
09166:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
09168:  BCF    F8D.1
0916A:  MOVLB  F
....................          break; 
0916C:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
0916E:  BCF    FA0.1
....................    enc_isr(OFF); 
09170:  MOVLB  8
09172:  CLRF   xCA
09174:  MOVLB  0
09176:  RCALL  8DBA
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
09178:  MOVLB  7
0917A:  MOVF   x52,F
0917C:  BNZ   918C
0917E:  MOVF   x53,F
09180:  BNZ   918C
09182:  MOVF   x54,F
09184:  BNZ   918C
09186:  MOVF   x55,F
09188:  BNZ   918C
....................    { 
....................       output_bit(VMOT,OFF); 
0918A:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
0918C:  MOVLB  8
0918E:  CLRF   xCA
09190:  MOVLB  0
09192:  CALL   8970
....................  
....................    if(success==TRUE) 
09196:  MOVLB  8
09198:  DECFSZ xC9,W
0919A:  BRA    9336
....................    { 
....................       m_error[motor]=FALSE; 
0919C:  BCF    FD8.0
0919E:  MOVLB  7
091A0:  RLCF   x40,W
091A2:  CLRF   03
091A4:  ADDLW  96
091A6:  MOVWF  FE9
091A8:  MOVLW  07
091AA:  ADDWFC 03,W
091AC:  MOVWF  FEA
091AE:  CLRF   FEC
091B0:  MOVF   FED,F
091B2:  CLRF   FEF
....................       wrt_m_error(); 
091B4:  MOVLB  0
091B6:  RCALL  8F20
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
091B8:  BCF    FD8.0
091BA:  MOVLB  7
091BC:  RLCF   x40,W
091BE:  CLRF   03
091C0:  ADDLW  66
091C2:  MOVWF  FE9
091C4:  MOVLW  07
091C6:  ADDWFC 03,W
091C8:  MOVWF  FEA
091CA:  MOVFF  FEC,8CB
091CE:  MOVF   FED,F
091D0:  MOVFF  FEF,8CA
091D4:  MOVLB  8
091D6:  MOVF   xCA,W
091D8:  SUBLW  03
091DA:  BNZ   9212
091DC:  MOVF   xCB,F
091DE:  BNZ   9212
....................       { 
....................          e_pos[motor] = 0; 
091E0:  BCF    FD8.0
091E2:  MOVLB  7
091E4:  RLCF   x40,W
091E6:  CLRF   03
091E8:  ADDLW  BF
091EA:  MOVWF  FE9
091EC:  MOVLW  07
091EE:  ADDWFC 03,W
091F0:  MOVWF  FEA
091F2:  CLRF   FEC
091F4:  MOVF   FED,F
091F6:  CLRF   FEF
....................          e_port[motor] = 1; 
091F8:  BCF    FD8.0
091FA:  RLCF   x40,W
091FC:  CLRF   03
091FE:  ADDLW  C3
09200:  MOVWF  FE9
09202:  MOVLW  07
09204:  ADDWFC 03,W
09206:  MOVWF  FEA
09208:  CLRF   FEC
0920A:  MOVF   FED,F
0920C:  MOVLW  01
0920E:  MOVWF  FEF
09210:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
09212:  BCF    FD8.0
09214:  MOVLB  7
09216:  RLCF   x40,W
09218:  CLRF   03
0921A:  ADDLW  66
0921C:  MOVWF  FE9
0921E:  MOVLW  07
09220:  ADDWFC 03,W
09222:  MOVWF  FEA
09224:  MOVFF  FEC,8CB
09228:  MOVF   FED,F
0922A:  MOVFF  FEF,8CA
0922E:  MOVLB  8
09230:  MOVF   xCA,W
09232:  SUBLW  02
09234:  BNZ   9280
09236:  MOVF   xCB,F
09238:  BNZ   9280
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
0923A:  BCF    FD8.0
0923C:  MOVLB  7
0923E:  RLCF   x40,W
09240:  CLRF   03
09242:  ADDLW  C3
09244:  MOVWF  01
09246:  MOVLW  07
09248:  ADDWFC 03,F
0924A:  MOVLB  8
0924C:  MOVFF  03,8CB
09250:  BCF    FD8.0
09252:  MOVLB  7
09254:  RLCF   x40,W
09256:  CLRF   03
09258:  ADDLW  C7
0925A:  MOVWF  FE9
0925C:  MOVLW  07
0925E:  ADDWFC 03,W
09260:  MOVWF  FEA
09262:  MOVFF  FEC,03
09266:  MOVF   FED,F
09268:  MOVFF  FEF,8CC
0926C:  MOVLB  8
0926E:  MOVFF  8CB,FEA
09272:  MOVFF  01,FE9
09276:  MOVFF  03,FEC
0927A:  MOVF   FED,F
0927C:  MOVFF  8CC,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
09280:  BCF    FD8.0
09282:  MOVLB  7
09284:  RLCF   x40,W
09286:  CLRF   03
09288:  ADDLW  66
0928A:  MOVWF  FE9
0928C:  MOVLW  07
0928E:  ADDWFC 03,W
09290:  MOVWF  FEA
09292:  MOVFF  FEC,8CB
09296:  MOVF   FED,F
09298:  MOVFF  FEF,8CA
0929C:  MOVLB  8
0929E:  MOVF   xCA,W
092A0:  SUBLW  02
092A2:  BNZ   92A8
092A4:  MOVF   xCB,F
092A6:  BZ    92D0
092A8:  BCF    FD8.0
092AA:  MOVLB  7
092AC:  RLCF   x40,W
092AE:  CLRF   03
092B0:  ADDLW  66
092B2:  MOVWF  FE9
092B4:  MOVLW  07
092B6:  ADDWFC 03,W
092B8:  MOVWF  FEA
092BA:  MOVFF  FEC,8CB
092BE:  MOVF   FED,F
092C0:  MOVFF  FEF,8CA
092C4:  MOVLB  8
092C6:  MOVF   xCA,W
092C8:  SUBLW  03
092CA:  BNZ   9334
092CC:  MOVF   xCB,F
092CE:  BNZ   9334
....................       { 
....................          switch(motor) 
092D0:  MOVLB  7
092D2:  MOVF   x40,W
092D4:  XORLW  00
092D6:  MOVLB  0
092D8:  BZ    92E0
092DA:  XORLW  01
092DC:  BZ    930A
092DE:  BRA    9332
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
092E0:  MOVLW  7E
092E2:  MOVLB  8
092E4:  MOVWF  xCC
092E6:  MOVFF  7C0,8CE
092EA:  MOVFF  7BF,8CD
092EE:  MOVLB  0
092F0:  CALL   4FAE
....................                      write16(ADDR_E1_PORT,e_port[0]); 
092F4:  MOVLW  AA
092F6:  MOVLB  8
092F8:  MOVWF  xCC
092FA:  MOVFF  7C4,8CE
092FE:  MOVFF  7C3,8CD
09302:  MOVLB  0
09304:  CALL   4FAE
....................                break; 
09308:  BRA    9332
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
0930A:  MOVLW  80
0930C:  MOVLB  8
0930E:  MOVWF  xCC
09310:  MOVFF  7C2,8CE
09314:  MOVFF  7C1,8CD
09318:  MOVLB  0
0931A:  CALL   4FAE
....................                      write16(ADDR_E2_PORT,e_port[1]); 
0931E:  MOVLW  AC
09320:  MOVLB  8
09322:  MOVWF  xCC
09324:  MOVFF  7C6,8CE
09328:  MOVFF  7C5,8CD
0932C:  MOVLB  0
0932E:  CALL   4FAE
....................                break;             
09332:  MOVLB  8
....................          } 
....................       } 
....................    } 
09334:  BRA    93DE
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
09336:  BCF    FD8.0
09338:  MOVLB  7
0933A:  RLCF   x40,W
0933C:  CLRF   03
0933E:  ADDLW  96
09340:  MOVWF  FE9
09342:  MOVLW  07
09344:  ADDWFC 03,W
09346:  MOVWF  FEA
09348:  CLRF   FEC
0934A:  MOVF   FED,F
0934C:  MOVLW  01
0934E:  MOVWF  FEF
....................       e_pos[motor] = 0; 
09350:  BCF    FD8.0
09352:  RLCF   x40,W
09354:  CLRF   03
09356:  ADDLW  BF
09358:  MOVWF  FE9
0935A:  MOVLW  07
0935C:  ADDWFC 03,W
0935E:  MOVWF  FEA
09360:  CLRF   FEC
09362:  MOVF   FED,F
09364:  CLRF   FEF
....................       e_port[motor] = 0; 
09366:  BCF    FD8.0
09368:  RLCF   x40,W
0936A:  CLRF   03
0936C:  ADDLW  C3
0936E:  MOVWF  FE9
09370:  MOVLW  07
09372:  ADDWFC 03,W
09374:  MOVWF  FEA
09376:  CLRF   FEC
09378:  MOVF   FED,F
0937A:  CLRF   FEF
....................       switch(motor) 
0937C:  MOVF   x40,W
0937E:  XORLW  00
09380:  MOVLB  0
09382:  BZ    938A
09384:  XORLW  01
09386:  BZ    93B4
09388:  BRA    93DC
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
0938A:  MOVLW  7E
0938C:  MOVLB  8
0938E:  MOVWF  xCC
09390:  MOVFF  7C0,8CE
09394:  MOVFF  7BF,8CD
09398:  MOVLB  0
0939A:  CALL   4FAE
....................                   write16(ADDR_E1_PORT,e_port[0]); 
0939E:  MOVLW  AA
093A0:  MOVLB  8
093A2:  MOVWF  xCC
093A4:  MOVFF  7C4,8CE
093A8:  MOVFF  7C3,8CD
093AC:  MOVLB  0
093AE:  CALL   4FAE
....................             break; 
093B2:  BRA    93DC
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
093B4:  MOVLW  80
093B6:  MOVLB  8
093B8:  MOVWF  xCC
093BA:  MOVFF  7C2,8CE
093BE:  MOVFF  7C1,8CD
093C2:  MOVLB  0
093C4:  CALL   4FAE
....................                   write16(ADDR_E2_PORT,e_port[1]); 
093C8:  MOVLW  AC
093CA:  MOVLB  8
093CC:  MOVWF  xCC
093CE:  MOVFF  7C6,8CE
093D2:  MOVFF  7C5,8CD
093D6:  MOVLB  0
093D8:  CALL   4FAE
....................             break;             
093DC:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
093DE:  BCF    FD8.0
093E0:  MOVLB  7
093E2:  RLCF   x40,W
093E4:  CLRF   03
093E6:  ADDLW  AF
093E8:  MOVWF  FE9
093EA:  MOVLW  07
093EC:  ADDWFC 03,W
093EE:  MOVWF  FEA
093F0:  CLRF   FEC
093F2:  MOVF   FED,F
093F4:  MOVLW  01
093F6:  MOVWF  FEF
....................     
....................    switch (motor) 
093F8:  MOVF   x40,W
093FA:  XORLW  00
093FC:  MOVLB  0
093FE:  BZ    9406
09400:  XORLW  01
09402:  BZ    942E
09404:  BRA    9454
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
09406:  MOVLW  B2
09408:  MOVLB  8
0940A:  MOVWF  xCC
0940C:  CLRF   xCE
0940E:  MOVLW  01
09410:  MOVWF  xCD
09412:  MOVLB  0
09414:  CALL   4FAE
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
09418:  MOVLW  B6
0941A:  MOVLB  8
0941C:  MOVWF  xCC
0941E:  MOVFF  7B4,8CE
09422:  MOVFF  7B3,8CD
09426:  MOVLB  0
09428:  CALL   4FAE
....................          break; 
0942C:  BRA    9454
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
0942E:  MOVLW  B4
09430:  MOVLB  8
09432:  MOVWF  xCC
09434:  CLRF   xCE
09436:  MOVLW  01
09438:  MOVWF  xCD
0943A:  MOVLB  0
0943C:  CALL   4FAE
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
09440:  MOVLW  B8
09442:  MOVLB  8
09444:  MOVWF  xCC
09446:  MOVFF  7B6,8CE
0944A:  MOVFF  7B5,8CD
0944E:  MOVLB  0
09450:  CALL   4FAE
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
09454:  MOVF   1F,W
09456:  SUBLW  04
09458:  BNZ   94FE
0945A:  MOVF   20,F
0945C:  BNZ   94FE
....................    { 
....................       if(motor==1) 
0945E:  MOVLB  7
09460:  DECFSZ x40,W
09462:  BRA    9500
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
09464:  BCF    FD8.0
09466:  RLCF   x40,W
09468:  CLRF   03
0946A:  ADDLW  AF
0946C:  MOVWF  FE9
0946E:  MOVLW  07
09470:  ADDWFC 03,W
09472:  MOVWF  FEA
09474:  MOVFF  FEC,8CB
09478:  MOVF   FED,F
0947A:  MOVFF  FEF,8CA
0947E:  BCF    FD8.0
09480:  RLCF   x40,W
09482:  CLRF   03
09484:  ADDLW  B3
09486:  MOVWF  FE9
09488:  MOVLW  07
0948A:  ADDWFC 03,W
0948C:  MOVWF  FEA
0948E:  MOVFF  FEC,8CD
09492:  MOVF   FED,F
09494:  MOVFF  FEF,8CC
09498:  MOVLW  88
0949A:  MOVWF  FF6
0949C:  MOVLW  1A
0949E:  MOVWF  FF7
094A0:  MOVLW  00
094A2:  MOVWF  FF8
094A4:  CLRF   1B
094A6:  BTFSC  FF2.7
094A8:  BSF    1B.7
094AA:  BCF    FF2.7
094AC:  MOVLW  05
094AE:  MOVLB  A
094B0:  MOVWF  x19
094B2:  MOVLB  0
094B4:  CALL   104E
094B8:  BTFSC  1B.7
094BA:  BSF    FF2.7
094BC:  MOVLW  10
094BE:  MOVWF  FE9
094C0:  CLRF   1B
094C2:  BTFSC  FF2.7
094C4:  BSF    1B.7
094C6:  BCF    FF2.7
094C8:  MOVFF  8CB,A1A
094CC:  MOVFF  8CA,A19
094D0:  CALL   11D0
094D4:  BTFSC  1B.7
094D6:  BSF    FF2.7
094D8:  MOVLW  2C
094DA:  BTFSS  F9E.4
094DC:  BRA    94DA
094DE:  MOVWF  FAD
094E0:  MOVLW  10
094E2:  MOVWF  FE9
094E4:  MOVFF  8CD,8CF
094E8:  MOVFF  8CC,8CE
094EC:  RCALL  8F84
094EE:  MOVLW  0D
094F0:  BTFSS  F9E.4
094F2:  BRA    94F0
094F4:  MOVWF  FAD
094F6:  MOVLW  0A
094F8:  BTFSS  F9E.4
094FA:  BRA    94F8
094FC:  MOVWF  FAD
094FE:  MOVLB  7
....................       } 
....................    } 
09500:  MOVLB  0
09502:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
09630:  BCF    FD8.0
09632:  MOVLB  7
09634:  RLCF   x40,W
09636:  CLRF   03
09638:  ADDLW  6A
0963A:  MOVWF  FE9
0963C:  MOVLW  07
0963E:  ADDWFC 03,W
09640:  MOVWF  FEA
09642:  MOVFF  FEC,8CA
09646:  MOVF   FED,F
09648:  MOVFF  FEF,8C9
0964C:  MOVLB  8
0964E:  DECFSZ xC9,W
09650:  BRA    9660
09652:  MOVF   xCA,F
09654:  BNZ   9660
09656:  MOVLW  01
09658:  MOVWF  xC9
0965A:  MOVLB  0
0965C:  RCALL  9070
0965E:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
09660:  BCF    FD8.0
09662:  MOVLB  7
09664:  RLCF   x40,W
09666:  CLRF   03
09668:  ADDLW  6A
0966A:  MOVWF  FE9
0966C:  MOVLW  07
0966E:  ADDWFC 03,W
09670:  MOVWF  FEA
09672:  MOVFF  FEC,8CA
09676:  MOVF   FED,F
09678:  MOVFF  FEF,8C9
0967C:  MOVLB  8
0967E:  MOVF   xC9,W
09680:  SUBLW  02
09682:  BTFSS  FD8.2
09684:  BRA    9C8E
09686:  MOVF   xCA,F
09688:  BTFSS  FD8.2
0968A:  BRA    9C8E
....................       if (e_mode[motor]==2){ 
0968C:  BCF    FD8.0
0968E:  MOVLB  7
09690:  RLCF   x40,W
09692:  CLRF   03
09694:  ADDLW  66
09696:  MOVWF  FE9
09698:  MOVLW  07
0969A:  ADDWFC 03,W
0969C:  MOVWF  FEA
0969E:  MOVFF  FEC,8CA
096A2:  MOVF   FED,F
096A4:  MOVFF  FEF,8C9
096A8:  MOVLB  8
096AA:  MOVF   xC9,W
096AC:  SUBLW  02
096AE:  BTFSS  FD8.2
096B0:  BRA    9C0A
096B2:  MOVF   xCA,F
096B4:  BTFSS  FD8.2
096B6:  BRA    9C0A
....................          if(nv_product==ECO || nv_product==WMS2){ 
096B8:  MOVF   2F,F
096BA:  BNZ   96C0
096BC:  MOVF   30,F
096BE:  BZ    96CE
096C0:  MOVF   2F,W
096C2:  SUBLW  03
096C4:  BTFSS  FD8.2
096C6:  BRA    9812
096C8:  MOVF   30,F
096CA:  BTFSS  FD8.2
096CC:  BRA    9812
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
096CE:  BCF    FD8.0
096D0:  MOVLB  7
096D2:  RLCF   x40,W
096D4:  CLRF   03
096D6:  ADDLW  AB
096D8:  MOVWF  FE9
096DA:  MOVLW  07
096DC:  ADDWFC 03,W
096DE:  MOVWF  FEA
096E0:  MOVFF  FEC,9D5
096E4:  MOVF   FED,F
096E6:  MOVFF  FEF,9D4
096EA:  MOVFF  FEA,8CC
096EE:  MOVFF  FE9,8CB
096F2:  MOVLB  9
096F4:  CLRF   xD7
096F6:  CLRF   xD6
096F8:  MOVFF  8BA,9DB
096FC:  MOVFF  8B9,9DA
09700:  MOVFF  8B8,9D9
09704:  MOVFF  8B7,9D8
09708:  MOVLB  0
0970A:  CALL   47D4
0970E:  MOVFF  8CC,FEA
09712:  MOVFF  8CB,FE9
09716:  MOVFF  03,8CC
0971A:  MOVFF  02,8CB
0971E:  MOVFF  01,8CA
09722:  MOVFF  00,8C9
09726:  BCF    FD8.0
09728:  MOVLB  7
0972A:  RLCF   x40,W
0972C:  CLRF   03
0972E:  ADDLW  AB
09730:  MOVWF  FE9
09732:  MOVLW  07
09734:  ADDWFC 03,W
09736:  MOVWF  FEA
09738:  MOVFF  FEC,8CE
0973C:  MOVF   FED,F
0973E:  MOVFF  FEF,8CD
09742:  BCF    FD8.0
09744:  MOVLB  8
09746:  RRCF   xCE,W
09748:  MOVWF  03
0974A:  RRCF   xCD,W
0974C:  MOVWF  02
0974E:  ADDWF  00,W
09750:  MOVWF  00
09752:  MOVF   03,W
09754:  ADDWFC 01,W
09756:  MOVWF  01
09758:  MOVLW  00
0975A:  ADDWFC xCB,W
0975C:  MOVWF  02
0975E:  MOVLW  00
09760:  ADDWFC xCC,W
09762:  MOVWF  xC4
09764:  MOVFF  02,8C3
09768:  MOVFF  01,8C2
0976C:  MOVFF  00,8C1
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
09770:  BCF    FD8.0
09772:  MOVLB  7
09774:  RLCF   x40,W
09776:  CLRF   03
09778:  ADDLW  AB
0977A:  MOVWF  FE9
0977C:  MOVLW  07
0977E:  ADDWFC 03,W
09780:  MOVWF  FEA
09782:  MOVFF  FEC,9D5
09786:  MOVF   FED,F
09788:  MOVFF  FEF,9D4
0978C:  MOVFF  FEA,8CC
09790:  MOVFF  FE9,8CB
09794:  MOVLB  9
09796:  CLRF   xD7
09798:  CLRF   xD6
0979A:  MOVFF  8BA,9DB
0979E:  MOVFF  8B9,9DA
097A2:  MOVFF  8B8,9D9
097A6:  MOVFF  8B7,9D8
097AA:  MOVLB  0
097AC:  CALL   47D4
097B0:  MOVFF  8CC,FEA
097B4:  MOVFF  8CB,FE9
097B8:  MOVFF  03,8CC
097BC:  MOVFF  02,8CB
097C0:  MOVFF  01,8CA
097C4:  MOVFF  00,8C9
097C8:  BCF    FD8.0
097CA:  MOVLB  7
097CC:  RLCF   x40,W
097CE:  CLRF   03
097D0:  ADDLW  AB
097D2:  MOVWF  FE9
097D4:  MOVLW  07
097D6:  ADDWFC 03,W
097D8:  MOVWF  FEA
097DA:  MOVFF  FEC,8CE
097DE:  MOVF   FED,F
097E0:  MOVFF  FEF,8CD
097E4:  BCF    FD8.0
097E6:  MOVLB  8
097E8:  RRCF   xCE,W
097EA:  MOVWF  03
097EC:  RRCF   xCD,W
097EE:  MOVWF  02
097F0:  SUBWF  00,W
097F2:  MOVWF  00
097F4:  MOVF   03,W
097F6:  SUBWFB 01,W
097F8:  MOVWF  01
097FA:  MOVLW  00
097FC:  SUBWFB xCB,W
097FE:  MOVWF  02
09800:  MOVLW  00
09802:  SUBWFB xCC,W
09804:  MOVWF  xC8
09806:  MOVFF  02,8C7
0980A:  MOVFF  01,8C6
0980E:  MOVFF  00,8C5
....................          } 
....................          if (nv_product==WMS4){ 
09812:  DECFSZ 2F,W
09814:  BRA    9A2C
09816:  MOVF   30,F
09818:  BTFSS  FD8.2
0981A:  BRA    9A2C
....................             if (end_even_port==FALSE){ 
0981C:  MOVLB  2
0981E:  MOVF   xDB,F
09820:  BNZ   9916
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
09822:  BCF    FD8.0
09824:  MOVLB  7
09826:  RLCF   x40,W
09828:  CLRF   03
0982A:  ADDLW  AB
0982C:  MOVWF  FE9
0982E:  MOVLW  07
09830:  ADDWFC 03,W
09832:  MOVWF  FEA
09834:  MOVFF  FEC,9EB
09838:  MOVF   FED,F
0983A:  MOVFF  FEF,9EA
0983E:  MOVFF  8BC,9ED
09842:  MOVFF  8BB,9EC
09846:  MOVLB  0
09848:  CALL   5C76
0984C:  MOVFF  02,8CA
09850:  MOVFF  01,8C9
09854:  BCF    FD8.0
09856:  MOVLB  7
09858:  RLCF   x40,W
0985A:  CLRF   03
0985C:  ADDLW  AB
0985E:  MOVWF  FE9
09860:  MOVLW  07
09862:  ADDWFC 03,W
09864:  MOVWF  FEA
09866:  MOVFF  FEC,8CC
0986A:  MOVF   FED,F
0986C:  MOVFF  FEF,8CB
09870:  BCF    FD8.0
09872:  MOVLB  8
09874:  RRCF   xCC,W
09876:  MOVWF  03
09878:  RRCF   xCB,W
0987A:  MOVWF  02
0987C:  ADDWF  01,W
0987E:  MOVWF  01
09880:  MOVF   xCA,W
09882:  ADDWFC 03,F
09884:  MOVFF  01,8C1
09888:  MOVFF  03,8C2
0988C:  CLRF   02
0988E:  CLRF   03
09890:  MOVFF  03,8C4
09894:  MOVFF  02,8C3
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
09898:  BCF    FD8.0
0989A:  MOVLB  7
0989C:  RLCF   x40,W
0989E:  CLRF   03
098A0:  ADDLW  AB
098A2:  MOVWF  FE9
098A4:  MOVLW  07
098A6:  ADDWFC 03,W
098A8:  MOVWF  FEA
098AA:  MOVFF  FEC,9EB
098AE:  MOVF   FED,F
098B0:  MOVFF  FEF,9EA
098B4:  MOVFF  8BC,9ED
098B8:  MOVFF  8BB,9EC
098BC:  MOVLB  0
098BE:  CALL   5C76
098C2:  MOVFF  02,8CA
098C6:  MOVFF  01,8C9
098CA:  BCF    FD8.0
098CC:  MOVLB  7
098CE:  RLCF   x40,W
098D0:  CLRF   03
098D2:  ADDLW  AB
098D4:  MOVWF  FE9
098D6:  MOVLW  07
098D8:  ADDWFC 03,W
098DA:  MOVWF  FEA
098DC:  MOVFF  FEC,8CC
098E0:  MOVF   FED,F
098E2:  MOVFF  FEF,8CB
098E6:  BCF    FD8.0
098E8:  MOVLB  8
098EA:  RRCF   xCC,W
098EC:  MOVWF  03
098EE:  RRCF   xCB,W
098F0:  MOVWF  02
098F2:  SUBWF  01,W
098F4:  MOVWF  00
098F6:  MOVF   03,W
098F8:  SUBWFB xCA,W
098FA:  MOVWF  03
098FC:  MOVF   00,W
098FE:  MOVFF  03,8C6
09902:  CLRF   02
09904:  CLRF   03
09906:  MOVFF  03,8C8
0990A:  MOVFF  02,8C7
0990E:  MOVFF  00,8C5
....................             } 
09912:  BRA    9A2C
09914:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
09916:  DECFSZ xDB,W
09918:  BRA    9A2E
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
0991A:  BCF    FD8.0
0991C:  MOVLB  7
0991E:  RLCF   x40,W
09920:  CLRF   03
09922:  ADDLW  AB
09924:  MOVWF  FE9
09926:  MOVLW  07
09928:  ADDWFC 03,W
0992A:  MOVWF  FEA
0992C:  MOVFF  FEC,9EB
09930:  MOVF   FED,F
09932:  MOVFF  FEF,9EA
09936:  MOVLW  01
09938:  MOVLB  8
0993A:  SUBWF  xBB,W
0993C:  MOVWF  00
0993E:  MOVLW  00
09940:  SUBWFB xBC,W
09942:  MOVWF  03
09944:  MOVFF  00,8CB
09948:  MOVWF  xCC
0994A:  MOVFF  FE8,9ED
0994E:  MOVFF  00,9EC
09952:  MOVLB  0
09954:  CALL   5C76
09958:  MOVFF  02,8CA
0995C:  MOVFF  01,8C9
09960:  BCF    FD8.0
09962:  MOVLB  7
09964:  RLCF   x40,W
09966:  CLRF   03
09968:  ADDLW  AB
0996A:  MOVWF  FE9
0996C:  MOVLW  07
0996E:  ADDWFC 03,W
09970:  MOVWF  FEA
09972:  MOVFF  FEC,8CC
09976:  MOVF   FED,F
09978:  MOVFF  FEF,8CB
0997C:  BCF    FD8.0
0997E:  MOVLB  8
09980:  RRCF   xCC,W
09982:  MOVWF  03
09984:  RRCF   xCB,W
09986:  MOVWF  02
09988:  ADDWF  01,W
0998A:  MOVWF  01
0998C:  MOVF   xCA,W
0998E:  ADDWFC 03,F
09990:  MOVFF  01,8C1
09994:  MOVFF  03,8C2
09998:  CLRF   02
0999A:  CLRF   03
0999C:  MOVFF  03,8C4
099A0:  MOVFF  02,8C3
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
099A4:  BCF    FD8.0
099A6:  MOVLB  7
099A8:  RLCF   x40,W
099AA:  CLRF   03
099AC:  ADDLW  AB
099AE:  MOVWF  FE9
099B0:  MOVLW  07
099B2:  ADDWFC 03,W
099B4:  MOVWF  FEA
099B6:  MOVFF  FEC,9EB
099BA:  MOVF   FED,F
099BC:  MOVFF  FEF,9EA
099C0:  MOVLW  01
099C2:  MOVLB  8
099C4:  SUBWF  xBB,W
099C6:  MOVWF  00
099C8:  MOVLW  00
099CA:  SUBWFB xBC,W
099CC:  MOVWF  03
099CE:  MOVFF  00,8CB
099D2:  MOVWF  xCC
099D4:  MOVFF  FE8,9ED
099D8:  MOVFF  00,9EC
099DC:  MOVLB  0
099DE:  CALL   5C76
099E2:  MOVFF  02,03
099E6:  MOVFF  01,8C5
099EA:  MOVFF  02,8C6
099EE:  CLRF   02
099F0:  CLRF   03
099F2:  MOVFF  03,8C8
099F6:  MOVFF  02,8C7
....................                m_pll = m_pll -(m_ppp[motor]/2); 
099FA:  BCF    FD8.0
099FC:  MOVLB  7
099FE:  RLCF   x40,W
09A00:  CLRF   03
09A02:  ADDLW  AB
09A04:  MOVWF  FE9
09A06:  MOVLW  07
09A08:  ADDWFC 03,W
09A0A:  MOVWF  FEA
09A0C:  MOVFF  FEC,8CA
09A10:  MOVF   FED,F
09A12:  MOVFF  FEF,8C9
09A16:  BCF    FD8.0
09A18:  MOVLB  8
09A1A:  RRCF   xCA,W
09A1C:  MOVWF  03
09A1E:  RRCF   xC9,W
09A20:  SUBWF  xC5,F
09A22:  MOVF   03,W
09A24:  SUBWFB xC6,F
09A26:  MOVLW  00
09A28:  SUBWFB xC7,F
09A2A:  SUBWFB xC8,F
09A2C:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
09A2E:  MOVLB  7
09A30:  MOVF   x40,W
09A32:  MULLW  04
09A34:  MOVF   FF3,W
09A36:  CLRF   03
09A38:  ADDLW  A2
09A3A:  MOVWF  FE9
09A3C:  MOVLW  07
09A3E:  ADDWFC 03,W
09A40:  MOVWF  FEA
09A42:  MOVFF  FEF,8C9
09A46:  MOVFF  FEC,8CA
09A4A:  MOVFF  FEC,8CB
09A4E:  MOVFF  FEC,8CC
09A52:  MOVLB  8
09A54:  BTFSC  xC4.7
09A56:  BRA    9AC6
09A58:  MOVF   xC4,W
09A5A:  SUBWF  xCC,W
09A5C:  BNC   9A76
09A5E:  BNZ   9AC6
09A60:  MOVF   xC3,W
09A62:  SUBWF  xCB,W
09A64:  BNC   9A76
09A66:  BNZ   9AC6
09A68:  MOVF   xC2,W
09A6A:  SUBWF  xCA,W
09A6C:  BNC   9A76
09A6E:  BNZ   9AC6
09A70:  MOVF   xC9,W
09A72:  SUBWF  xC1,W
09A74:  BNC   9AC6
09A76:  MOVLB  7
09A78:  MOVF   x40,W
09A7A:  MULLW  04
09A7C:  MOVF   FF3,W
09A7E:  CLRF   03
09A80:  ADDLW  A2
09A82:  MOVWF  FE9
09A84:  MOVLW  07
09A86:  ADDWFC 03,W
09A88:  MOVWF  FEA
09A8A:  MOVFF  FEF,8C9
09A8E:  MOVFF  FEC,8CA
09A92:  MOVFF  FEC,8CB
09A96:  MOVFF  FEC,8CC
09A9A:  MOVLB  8
09A9C:  BTFSC  xC8.7
09A9E:  BRA    9C0A
09AA0:  MOVF   xCC,W
09AA2:  SUBWF  xC8,W
09AA4:  BTFSS  FD8.0
09AA6:  BRA    9C0A
09AA8:  BNZ   9AC6
09AAA:  MOVF   xCB,W
09AAC:  SUBWF  xC7,W
09AAE:  BTFSS  FD8.0
09AB0:  BRA    9C0A
09AB2:  BNZ   9AC6
09AB4:  MOVF   xCA,W
09AB6:  SUBWF  xC6,W
09AB8:  BTFSS  FD8.0
09ABA:  BRA    9C0A
09ABC:  BNZ   9AC6
09ABE:  MOVF   xC5,W
09AC0:  SUBWF  xC9,W
09AC2:  BTFSC  FD8.0
09AC4:  BRA    9C0A
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09AC6:  MOVLW  01
09AC8:  MOVLB  7
09ACA:  ADDWF  x40,W
09ACC:  MOVLB  8
09ACE:  MOVWF  xC9
09AD0:  BCF    FD8.0
09AD2:  MOVLB  7
09AD4:  RLCF   x40,W
09AD6:  CLRF   03
09AD8:  ADDLW  AB
09ADA:  MOVWF  FE9
09ADC:  MOVLW  07
09ADE:  ADDWFC 03,W
09AE0:  MOVWF  FEA
09AE2:  MOVFF  FEC,8CB
09AE6:  MOVF   FED,F
09AE8:  MOVFF  FEF,8CA
09AEC:  MOVF   x40,W
09AEE:  MULLW  04
09AF0:  MOVF   FF3,W
09AF2:  CLRF   03
09AF4:  ADDLW  A2
09AF6:  MOVWF  FE9
09AF8:  MOVLW  07
09AFA:  ADDWFC 03,W
09AFC:  MOVWF  FEA
09AFE:  MOVFF  FEF,8CC
09B02:  MOVFF  FEC,8CD
09B06:  MOVFF  FEC,8CE
09B0A:  MOVFF  FEC,8CF
09B0E:  MOVLW  98
09B10:  MOVWF  FF6
09B12:  MOVLW  1A
09B14:  MOVWF  FF7
09B16:  MOVLW  00
09B18:  MOVWF  FF8
09B1A:  CLRF   1B
09B1C:  BTFSC  FF2.7
09B1E:  BSF    1B.7
09B20:  BCF    FF2.7
09B22:  MOVLW  05
09B24:  MOVLB  A
09B26:  MOVWF  x19
09B28:  MOVLB  0
09B2A:  CALL   104E
09B2E:  BTFSC  1B.7
09B30:  BSF    FF2.7
09B32:  CLRF   1B
09B34:  BTFSC  FF2.7
09B36:  BSF    1B.7
09B38:  BCF    FF2.7
09B3A:  MOVFF  8C9,A19
09B3E:  MOVLW  1B
09B40:  MOVLB  A
09B42:  MOVWF  x1A
09B44:  MOVLB  0
09B46:  CALL   0FD0
09B4A:  BTFSC  1B.7
09B4C:  BSF    FF2.7
09B4E:  MOVLW  2C
09B50:  BTFSS  F9E.4
09B52:  BRA    9B50
09B54:  MOVWF  FAD
09B56:  MOVLW  41
09B58:  MOVWF  FE9
09B5A:  MOVFF  8BA,8D3
09B5E:  MOVFF  8B9,8D2
09B62:  MOVFF  8B8,8D1
09B66:  MOVFF  8B7,8D0
09B6A:  RCALL  9504
09B6C:  MOVLW  2C
09B6E:  BTFSS  F9E.4
09B70:  BRA    9B6E
09B72:  MOVWF  FAD
09B74:  MOVLW  10
09B76:  MOVWF  FE9
09B78:  CLRF   1B
09B7A:  BTFSC  FF2.7
09B7C:  BSF    1B.7
09B7E:  BCF    FF2.7
09B80:  MOVFF  8CB,A1A
09B84:  MOVFF  8CA,A19
09B88:  CALL   11D0
09B8C:  BTFSC  1B.7
09B8E:  BSF    FF2.7
09B90:  MOVLW  2C
09B92:  BTFSS  F9E.4
09B94:  BRA    9B92
09B96:  MOVWF  FAD
09B98:  MOVLW  41
09B9A:  MOVWF  FE9
09B9C:  CLRF   1B
09B9E:  BTFSC  FF2.7
09BA0:  BSF    1B.7
09BA2:  BCF    FF2.7
09BA4:  MOVFF  8CF,A1C
09BA8:  MOVFF  8CE,A1B
09BAC:  MOVFF  8CD,A1A
09BB0:  MOVFF  8CC,A19
09BB4:  CALL   1114
09BB8:  BTFSC  1B.7
09BBA:  BSF    FF2.7
09BBC:  MOVLW  2C
09BBE:  BTFSS  F9E.4
09BC0:  BRA    9BBE
09BC2:  MOVWF  FAD
09BC4:  MOVLW  41
09BC6:  MOVWF  FE9
09BC8:  MOVFF  8C4,8D3
09BCC:  MOVFF  8C3,8D2
09BD0:  MOVFF  8C2,8D1
09BD4:  MOVFF  8C1,8D0
09BD8:  RCALL  9504
09BDA:  MOVLW  2C
09BDC:  BTFSS  F9E.4
09BDE:  BRA    9BDC
09BE0:  MOVWF  FAD
09BE2:  MOVLW  41
09BE4:  MOVWF  FE9
09BE6:  MOVFF  8C8,8D3
09BEA:  MOVFF  8C7,8D2
09BEE:  MOVFF  8C6,8D1
09BF2:  MOVFF  8C5,8D0
09BF6:  RCALL  9504
09BF8:  MOVLW  0D
09BFA:  BTFSS  F9E.4
09BFC:  BRA    9BFA
09BFE:  MOVWF  FAD
09C00:  MOVLW  0A
09C02:  BTFSS  F9E.4
09C04:  BRA    9C02
09C06:  MOVWF  FAD
09C08:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09C0A:  BCF    FD8.0
09C0C:  MOVLB  7
09C0E:  RLCF   x40,W
09C10:  CLRF   03
09C12:  ADDLW  9E
09C14:  MOVWF  01
09C16:  MOVLW  07
09C18:  ADDWFC 03,F
09C1A:  MOVLB  8
09C1C:  MOVFF  03,8CA
09C20:  BCF    FD8.0
09C22:  MOVLB  7
09C24:  RLCF   x40,W
09C26:  CLRF   03
09C28:  ADDLW  66
09C2A:  MOVWF  FE9
09C2C:  MOVLW  07
09C2E:  ADDWFC 03,W
09C30:  MOVWF  FEA
09C32:  MOVFF  FEC,03
09C36:  MOVF   FED,F
09C38:  MOVFF  FEF,8CB
09C3C:  MOVLB  8
09C3E:  MOVFF  8CA,FEA
09C42:  MOVFF  01,FE9
09C46:  MOVFF  03,FEC
09C4A:  MOVF   FED,F
09C4C:  MOVFF  8CB,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09C50:  BCF    FD8.0
09C52:  MOVLB  7
09C54:  RLCF   x40,W
09C56:  CLRF   03
09C58:  ADDLW  66
09C5A:  MOVWF  FE9
09C5C:  MOVLW  07
09C5E:  ADDWFC 03,W
09C60:  MOVWF  FEA
09C62:  CLRF   FEC
09C64:  MOVF   FED,F
09C66:  MOVLW  04
09C68:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09C6A:  MOVF   x40,W
09C6C:  MULLW  04
09C6E:  MOVF   FF3,W
09C70:  CLRF   03
09C72:  ADDLW  A2
09C74:  MOVWF  FE9
09C76:  MOVLW  07
09C78:  ADDWFC 03,W
09C7A:  MOVWF  FEA
09C7C:  MOVFF  FEF,8BD
09C80:  MOVFF  FEC,8BE
09C84:  MOVFF  FEC,8BF
09C88:  MOVFF  FEC,8C0
09C8C:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09C8E:  MOVFF  8BD,00
09C92:  MOVFF  8BE,01
09C96:  MOVFF  8BF,02
09C9A:  MOVFF  8C0,03
09C9E:  MOVLB  0
09CA0:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
084FE:  MOVLB  2
08500:  CLRF   xDB
....................    start_even_port = FALSE; 
08502:  CLRF   xDA
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
08504:  BCF    FD8.0
08506:  MOVLB  7
08508:  RLCF   x40,W
0850A:  CLRF   03
0850C:  ADDLW  C7
0850E:  MOVWF  FE9
08510:  MOVLW  07
08512:  ADDWFC 03,W
08514:  MOVWF  FEA
08516:  MOVFF  FEC,8B7
0851A:  MOVF   FED,F
0851C:  MOVFF  FEF,8B6
08520:  MOVLW  01
08522:  MOVLB  8
08524:  ANDWF  xB6,F
08526:  CLRF   xB7
08528:  MOVF   xB6,F
0852A:  BNZ   8538
0852C:  MOVF   xB7,F
0852E:  BNZ   8538
....................    { 
....................       end_even_port = TRUE; 
08530:  MOVLW  01
08532:  MOVLB  2
08534:  MOVWF  xDB
08536:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
08538:  BCF    FD8.0
0853A:  MOVLB  7
0853C:  RLCF   x40,W
0853E:  CLRF   03
08540:  ADDLW  C3
08542:  MOVWF  FE9
08544:  MOVLW  07
08546:  ADDWFC 03,W
08548:  MOVWF  FEA
0854A:  MOVFF  FEC,8B7
0854E:  MOVF   FED,F
08550:  MOVFF  FEF,8B6
08554:  MOVLW  01
08556:  MOVLB  8
08558:  ANDWF  xB6,F
0855A:  CLRF   xB7
0855C:  MOVF   xB6,F
0855E:  BNZ   856C
08560:  MOVF   xB7,F
08562:  BNZ   856C
....................    { 
....................       start_even_port = TRUE; 
08564:  MOVLW  01
08566:  MOVLB  2
08568:  MOVWF  xDA
0856A:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
0856C:  MOVLB  2
0856E:  MOVF   xDA,F
08570:  BNZ   8586
....................    { 
....................       evenOdd = 0; 
08572:  MOVLB  8
08574:  CLRF   xB5
....................       if (TRUE == end_even_port) 
08576:  MOVLB  2
08578:  DECFSZ xDB,W
0857A:  BRA    8584
....................       { 
....................          evenOdd = 1; 
0857C:  MOVLW  01
0857E:  MOVLB  8
08580:  MOVWF  xB5
08582:  MOVLB  2
....................       } 
....................    } 
08584:  BRA    859A
....................    else 
....................    { 
....................       evenOdd = 2; 
08586:  MOVLW  02
08588:  MOVLB  8
0858A:  MOVWF  xB5
....................       if (TRUE == end_even_port) 
0858C:  MOVLB  2
0858E:  DECFSZ xDB,W
08590:  BRA    859A
....................       { 
....................          evenOdd = 3; 
08592:  MOVLW  03
08594:  MOVLB  8
08596:  MOVWF  xB5
08598:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
0859A:  MOVLB  8
0859C:  MOVFF  8B5,01
085A0:  MOVLB  0
085A2:  GOTO   9FF0 (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09D18:  BCF    FD8.0
09D1A:  MOVLB  7
09D1C:  RLCF   x40,W
09D1E:  CLRF   03
09D20:  ADDLW  86
09D22:  MOVWF  FE9
09D24:  MOVLW  07
09D26:  ADDWFC 03,W
09D28:  MOVWF  FEA
09D2A:  CLRF   FEC
09D2C:  MOVF   FED,F
09D2E:  MOVFF  8A6,FEF
....................    m_step_cnt[motor] = 0; 
09D32:  MOVF   x40,W
09D34:  MULLW  04
09D36:  MOVF   FF3,W
09D38:  CLRF   03
09D3A:  ADDLW  A2
09D3C:  MOVWF  FE9
09D3E:  MOVLW  07
09D40:  ADDWFC 03,W
09D42:  MOVWF  FEA
09D44:  MOVF   FEE,F
09D46:  MOVF   FEE,F
09D48:  CLRF   FEC
09D4A:  MOVF   FED,F
09D4C:  CLRF   FEF
09D4E:  MOVF   FED,F
09D50:  CLRF   FEF
09D52:  MOVF   FED,F
09D54:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09D56:  BCF    FD8.0
09D58:  RLCF   x40,W
09D5A:  CLRF   03
09D5C:  ADDLW  6E
09D5E:  MOVWF  FE9
09D60:  MOVLW  07
09D62:  ADDWFC 03,W
09D64:  MOVWF  FEA
09D66:  MOVFF  FEC,8B3
09D6A:  MOVF   FED,F
09D6C:  MOVFF  FEF,8B2
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09D70:  BCF    FD8.0
09D72:  RLCF   x40,W
09D74:  CLRF   03
09D76:  ADDLW  76
09D78:  MOVWF  FE9
09D7A:  MOVLW  07
09D7C:  ADDWFC 03,W
09D7E:  MOVWF  FEA
09D80:  MOVFF  FEC,8BA
09D84:  MOVF   FED,F
09D86:  MOVFF  FEF,8B9
09D8A:  BCF    FD8.0
09D8C:  RLCF   x40,W
09D8E:  CLRF   03
09D90:  ADDLW  5E
09D92:  MOVWF  FE9
09D94:  MOVLW  07
09D96:  ADDWFC 03,W
09D98:  MOVWF  FEA
09D9A:  MOVFF  FEC,03
09D9E:  MOVF   FED,F
09DA0:  MOVFF  FEF,8BB
09DA4:  MOVFF  03,8B8
09DA8:  MOVFF  03,8BC
09DAC:  MOVLB  0
09DAE:  CALL   2CB4
09DB2:  MOVFF  02,8B1
09DB6:  MOVFF  01,8B0
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09DBA:  BCF    FD8.0
09DBC:  MOVLB  7
09DBE:  RLCF   x40,W
09DC0:  CLRF   03
09DC2:  ADDLW  66
09DC4:  MOVWF  FE9
09DC6:  MOVLW  07
09DC8:  ADDWFC 03,W
09DCA:  MOVWF  FEA
09DCC:  MOVFF  FEC,8B6
09DD0:  MOVF   FED,F
09DD2:  MOVFF  FEF,8B5
09DD6:  MOVLB  8
09DD8:  MOVF   xB5,W
09DDA:  SUBLW  02
09DDC:  BNZ   9E0C
09DDE:  MOVF   xB6,F
09DE0:  BNZ   9E0C
09DE2:  BCF    FD8.0
09DE4:  MOVLB  7
09DE6:  RLCF   x40,W
09DE8:  CLRF   03
09DEA:  ADDLW  C3
09DEC:  MOVWF  FE9
09DEE:  MOVLW  07
09DF0:  ADDWFC 03,W
09DF2:  MOVWF  FEA
09DF4:  MOVFF  FEC,8B6
09DF8:  MOVF   FED,F
09DFA:  MOVFF  FEF,8B5
09DFE:  MOVLB  8
09E00:  MOVF   xB5,F
09E02:  BNZ   9E0C
09E04:  MOVF   xB6,F
09E06:  BTFSC  FD8.2
09E08:  GOTO   A6AA
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09E0C:  BCF    FD8.0
09E0E:  MOVLB  7
09E10:  RLCF   x40,W
09E12:  CLRF   03
09E14:  ADDLW  66
09E16:  MOVWF  FE9
09E18:  MOVLW  07
09E1A:  ADDWFC 03,W
09E1C:  MOVWF  FEA
09E1E:  MOVFF  FEC,8B6
09E22:  MOVF   FED,F
09E24:  MOVFF  FEF,8B5
09E28:  MOVLB  8
09E2A:  MOVF   xB5,W
09E2C:  SUBLW  02
09E2E:  BTFSS  FD8.2
09E30:  BRA    A18A
09E32:  MOVF   xB6,F
09E34:  BTFSS  FD8.2
09E36:  BRA    A18A
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09E38:  BCF    FD8.0
09E3A:  MOVLB  7
09E3C:  RLCF   x40,W
09E3E:  CLRF   03
09E40:  ADDLW  C7
09E42:  MOVWF  FE9
09E44:  MOVLW  07
09E46:  ADDWFC 03,W
09E48:  MOVWF  FEA
09E4A:  MOVFF  8A7,FEF
09E4E:  MOVFF  8A8,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09E52:  DECFSZ 2F,W
09E54:  BRA    A106
09E56:  MOVF   30,F
09E58:  BTFSS  FD8.2
09E5A:  BRA    A106
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09E5C:  BCF    FD8.0
09E5E:  RLCF   x40,W
09E60:  CLRF   03
09E62:  ADDLW  C7
09E64:  MOVWF  FE9
09E66:  MOVLW  07
09E68:  ADDWFC 03,W
09E6A:  MOVWF  FEA
09E6C:  MOVFF  FEC,8B6
09E70:  MOVF   FED,F
09E72:  MOVFF  FEF,8B5
09E76:  BCF    FD8.0
09E78:  RLCF   x40,W
09E7A:  CLRF   03
09E7C:  ADDLW  C3
09E7E:  MOVWF  FE9
09E80:  MOVLW  07
09E82:  ADDWFC 03,W
09E84:  MOVWF  FEA
09E86:  MOVFF  FEC,03
09E8A:  MOVF   FED,F
09E8C:  MOVFF  FEF,01
09E90:  MOVF   03,W
09E92:  MOVLB  8
09E94:  SUBWF  xB6,W
09E96:  BNC   9F32
09E98:  BNZ   9EA0
09E9A:  MOVF   xB5,W
09E9C:  SUBWF  01,W
09E9E:  BC    9F32
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09EA0:  BCF    FD8.0
09EA2:  MOVLB  7
09EA4:  RLCF   x40,W
09EA6:  CLRF   03
09EA8:  ADDLW  B7
09EAA:  MOVWF  01
09EAC:  MOVLW  07
09EAE:  ADDWFC 03,F
09EB0:  MOVLB  8
09EB2:  MOVFF  03,8B6
09EB6:  BCF    FD8.0
09EB8:  MOVLB  7
09EBA:  RLCF   x40,W
09EBC:  CLRF   03
09EBE:  ADDLW  C7
09EC0:  MOVWF  FE9
09EC2:  MOVLW  07
09EC4:  ADDWFC 03,W
09EC6:  MOVWF  FEA
09EC8:  MOVFF  FEC,8B8
09ECC:  MOVF   FED,F
09ECE:  MOVFF  FEF,8B7
09ED2:  BCF    FD8.0
09ED4:  RLCF   x40,W
09ED6:  CLRF   03
09ED8:  ADDLW  C3
09EDA:  MOVWF  FE9
09EDC:  MOVLW  07
09EDE:  ADDWFC 03,W
09EE0:  MOVWF  FEA
09EE2:  MOVFF  FEC,03
09EE6:  MOVF   FED,F
09EE8:  MOVF   FEF,W
09EEA:  MOVLB  8
09EEC:  SUBWF  xB7,W
09EEE:  MOVWF  00
09EF0:  MOVF   03,W
09EF2:  SUBWFB xB8,W
09EF4:  MOVFF  8B6,FEA
09EF8:  MOVFF  01,FE9
09EFC:  MOVWF  FEC
09EFE:  MOVF   FED,F
09F00:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F04:  BCF    FD8.0
09F06:  MOVLB  7
09F08:  RLCF   x40,W
09F0A:  CLRF   03
09F0C:  ADDLW  B7
09F0E:  MOVWF  FE9
09F10:  MOVLW  07
09F12:  ADDWFC 03,W
09F14:  MOVWF  FEA
09F16:  MOVFF  FEC,8B6
09F1A:  MOVF   FED,F
09F1C:  MOVFF  FEF,8B5
09F20:  BCF    FD8.0
09F22:  MOVLB  8
09F24:  CLRF   xAA
09F26:  CLRF   xA9
09F28:  RRCF   xB6,W
09F2A:  MOVWF  xA8
09F2C:  RRCF   xB5,W
09F2E:  MOVWF  xA7
....................             } 
09F30:  BRA    9FEA
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09F32:  BCF    FD8.0
09F34:  MOVLB  7
09F36:  RLCF   x40,W
09F38:  CLRF   03
09F3A:  ADDLW  B7
09F3C:  MOVWF  01
09F3E:  MOVLW  07
09F40:  ADDWFC 03,F
09F42:  MOVFF  01,8B5
09F46:  MOVLB  8
09F48:  MOVFF  03,8B6
09F4C:  BCF    FD8.0
09F4E:  MOVLB  7
09F50:  RLCF   x40,W
09F52:  CLRF   03
09F54:  ADDLW  62
09F56:  MOVWF  FE9
09F58:  MOVLW  07
09F5A:  ADDWFC 03,W
09F5C:  MOVWF  FEA
09F5E:  MOVFF  FEC,8B8
09F62:  MOVF   FED,F
09F64:  MOVFF  FEF,8B7
09F68:  BCF    FD8.0
09F6A:  RLCF   x40,W
09F6C:  CLRF   03
09F6E:  ADDLW  C3
09F70:  MOVWF  FE9
09F72:  MOVLW  07
09F74:  ADDWFC 03,W
09F76:  MOVWF  FEA
09F78:  MOVFF  FEC,03
09F7C:  MOVF   FED,F
09F7E:  MOVF   FEF,W
09F80:  MOVLB  8
09F82:  SUBWF  xB7,F
09F84:  MOVF   03,W
09F86:  SUBWFB xB8,F
09F88:  BCF    FD8.0
09F8A:  MOVLB  7
09F8C:  RLCF   x40,W
09F8E:  CLRF   03
09F90:  ADDLW  C7
09F92:  MOVWF  FE9
09F94:  MOVLW  07
09F96:  ADDWFC 03,W
09F98:  MOVWF  FEA
09F9A:  MOVFF  FEC,03
09F9E:  MOVF   FED,F
09FA0:  MOVF   FEF,W
09FA2:  MOVLB  8
09FA4:  ADDWF  xB7,W
09FA6:  MOVWF  01
09FA8:  MOVF   xB8,W
09FAA:  ADDWFC 03,F
09FAC:  MOVFF  8B6,FEA
09FB0:  MOVFF  8B5,FE9
09FB4:  MOVFF  03,FEC
09FB8:  MOVF   FED,F
09FBA:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
09FBE:  BCF    FD8.0
09FC0:  MOVLB  7
09FC2:  RLCF   x40,W
09FC4:  CLRF   03
09FC6:  ADDLW  B7
09FC8:  MOVWF  FE9
09FCA:  MOVLW  07
09FCC:  ADDWFC 03,W
09FCE:  MOVWF  FEA
09FD0:  MOVFF  FEC,8B6
09FD4:  MOVF   FED,F
09FD6:  MOVFF  FEF,8B5
09FDA:  BCF    FD8.0
09FDC:  MOVLB  8
09FDE:  CLRF   xAA
09FE0:  CLRF   xA9
09FE2:  RRCF   xB6,W
09FE4:  MOVWF  xA8
09FE6:  RRCF   xB5,W
09FE8:  MOVWF  xA7
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
09FEA:  MOVLB  0
09FEC:  GOTO   84FE
09FF0:  MOVFF  01,8B4
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
09FF4:  BCF    FD8.0
09FF6:  MOVLB  7
09FF8:  RLCF   x40,W
09FFA:  CLRF   03
09FFC:  ADDLW  C7
09FFE:  MOVWF  FE9
0A000:  MOVLW  07
0A002:  ADDWFC 03,W
0A004:  MOVWF  FEA
0A006:  MOVFF  FEC,8B6
0A00A:  MOVF   FED,F
0A00C:  MOVFF  FEF,8B5
0A010:  MOVLB  8
0A012:  MOVF   xB5,W
0A014:  SUBLW  02
0A016:  BNZ   A046
0A018:  MOVF   xB6,F
0A01A:  BNZ   A046
0A01C:  BCF    FD8.0
0A01E:  MOVLB  7
0A020:  RLCF   x40,W
0A022:  CLRF   03
0A024:  ADDLW  C3
0A026:  MOVWF  FE9
0A028:  MOVLW  07
0A02A:  ADDWFC 03,W
0A02C:  MOVWF  FEA
0A02E:  MOVFF  FEC,8B6
0A032:  MOVF   FED,F
0A034:  MOVFF  FEF,8B5
0A038:  MOVLB  8
0A03A:  DECFSZ xB5,W
0A03C:  BRA    A046
0A03E:  MOVF   xB6,F
0A040:  BNZ   A046
....................             { 
....................                port_port=4; 
0A042:  MOVLW  04
0A044:  MOVWF  xB4
....................             } 
....................              
....................             switch(port_port){ 
0A046:  MOVF   xB4,W
0A048:  ADDLW  FB
0A04A:  BC    A102
0A04C:  ADDLW  05
0A04E:  MOVLB  0
0A050:  GOTO   A6F8
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
0A054:  BCF    FD8.0
0A056:  MOVLB  7
0A058:  RLCF   x40,W
0A05A:  CLRF   03
0A05C:  ADDLW  6E
0A05E:  MOVWF  FE9
0A060:  MOVLW  07
0A062:  ADDWFC 03,W
0A064:  MOVWF  FEA
0A066:  MOVFF  FEC,8B3
0A06A:  MOVF   FED,F
0A06C:  MOVFF  FEF,8B2
....................                   break; 
0A070:  MOVLB  8
0A072:  BRA    A102
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A074:  BCF    FD8.0
0A076:  MOVLB  7
0A078:  RLCF   x40,W
0A07A:  CLRF   03
0A07C:  ADDLW  7E
0A07E:  MOVWF  FE9
0A080:  MOVLW  07
0A082:  ADDWFC 03,W
0A084:  MOVWF  FEA
0A086:  MOVFF  FEC,03
0A08A:  MOVF   FED,F
0A08C:  MOVF   FEF,W
0A08E:  MOVLB  8
0A090:  ADDWF  xB0,W
0A092:  MOVWF  xB2
0A094:  MOVF   03,W
0A096:  ADDWFC xB1,W
0A098:  MOVWF  xB3
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A09A:  BRA    A102
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A09C:  BCF    FD8.0
0A09E:  MOVLB  7
0A0A0:  RLCF   x40,W
0A0A2:  CLRF   03
0A0A4:  ADDLW  6E
0A0A6:  MOVWF  FE9
0A0A8:  MOVLW  07
0A0AA:  ADDWFC 03,W
0A0AC:  MOVWF  FEA
0A0AE:  MOVFF  FEC,8B3
0A0B2:  MOVF   FED,F
0A0B4:  MOVFF  FEF,8B2
....................                         ++m_steps; 
0A0B8:  MOVLW  01
0A0BA:  MOVLB  8
0A0BC:  ADDWF  xA7,F
0A0BE:  BTFSC  FD8.0
0A0C0:  INCF   xA8,F
0A0C2:  BTFSC  FD8.2
0A0C4:  INCF   xA9,F
0A0C6:  BTFSC  FD8.2
0A0C8:  INCF   xAA,F
....................                   break; 
0A0CA:  BRA    A102
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A0CC:  BCF    FD8.0
0A0CE:  MOVLB  7
0A0D0:  RLCF   x40,W
0A0D2:  CLRF   03
0A0D4:  ADDLW  7E
0A0D6:  MOVWF  FE9
0A0D8:  MOVLW  07
0A0DA:  ADDWFC 03,W
0A0DC:  MOVWF  FEA
0A0DE:  MOVFF  FEC,03
0A0E2:  MOVF   FED,F
0A0E4:  MOVF   FEF,W
0A0E6:  MOVLB  8
0A0E8:  ADDWF  xB0,W
0A0EA:  MOVWF  xB2
0A0EC:  MOVF   03,W
0A0EE:  ADDWFC xB1,W
0A0F0:  MOVWF  xB3
....................  
....................                   break; 
0A0F2:  BRA    A102
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A0F4:  MOVFF  8B1,8B3
0A0F8:  MOVFF  8B0,8B2
....................                   break;     
0A0FC:  MOVLB  8
0A0FE:  BRA    A102
0A100:  MOVLB  8
....................             } 
....................          } 
0A102:  BRA    A12E
0A104:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A106:  MOVFF  8AA,8B8
0A10A:  MOVFF  8A9,8B7
0A10E:  MOVFF  8A8,8B6
0A112:  MOVFF  8A7,8B5
0A116:  MOVLB  0
0A118:  GOTO   85A6
0A11C:  MOVFF  03,8AA
0A120:  MOVFF  02,8A9
0A124:  MOVFF  01,8A8
0A128:  MOVFF  00,8A7
0A12C:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A12E:  DECFSZ xA5,W
0A130:  BRA    A158
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A132:  MOVFF  8A8,8B6
0A136:  MOVFF  8A7,8B5
0A13A:  MOVFF  8A8,8B8
0A13E:  MOVFF  8A7,8B7
0A142:  MOVLB  0
0A144:  GOTO   87B8
0A148:  MOVLB  8
0A14A:  CLRF   xAA
0A14C:  CLRF   xA9
0A14E:  MOVFF  02,8A8
0A152:  MOVFF  01,8A7
....................          } 
0A156:  BRA    A18A
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A158:  MOVF   2F,W
0A15A:  SUBLW  03
0A15C:  BNZ   A18A
0A15E:  MOVF   30,F
0A160:  BNZ   A18A
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A162:  BCF    FD8.0
0A164:  MOVLB  7
0A166:  RLCF   x40,W
0A168:  CLRF   03
0A16A:  ADDLW  BF
0A16C:  MOVWF  FE9
0A16E:  MOVLW  07
0A170:  ADDWFC 03,W
0A172:  MOVWF  FEA
0A174:  MOVFF  FEC,03
0A178:  MOVF   FED,F
0A17A:  MOVF   FEF,W
0A17C:  MOVLB  8
0A17E:  SUBWF  xA7,F
0A180:  MOVF   03,W
0A182:  SUBWFB xA8,F
0A184:  MOVLW  00
0A186:  SUBWFB xA9,F
0A188:  SUBWFB xAA,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A18A:  MOVFF  8AB,8B5
0A18E:  MOVLB  0
0A190:  GOTO   8E82
....................        
....................       //timeout could be set here!!! 
....................       while (m_running[motor]) 
0A194:  BCF    FD8.0
0A196:  MOVLB  7
0A198:  RLCF   x40,W
0A19A:  CLRF   03
0A19C:  ADDLW  92
0A19E:  MOVWF  FE9
0A1A0:  MOVLW  07
0A1A2:  ADDWFC 03,W
0A1A4:  MOVWF  FEA
0A1A6:  MOVF   FEF,F
0A1A8:  BNZ   A1B0
0A1AA:  MOVF   FEC,F
0A1AC:  BTFSC  FD8.2
0A1AE:  BRA    A6A6
....................       { 
....................          switch(e_mode[motor]) 
0A1B0:  BCF    FD8.0
0A1B2:  RLCF   x40,W
0A1B4:  CLRF   03
0A1B6:  ADDLW  66
0A1B8:  MOVWF  FE9
0A1BA:  MOVLW  07
0A1BC:  ADDWFC 03,W
0A1BE:  MOVWF  FEA
0A1C0:  MOVF   FEF,W
0A1C2:  MOVWF  00
0A1C4:  MOVF   FEE,F
0A1C6:  MOVF   FED,W
0A1C8:  MOVWF  03
0A1CA:  MOVF   03,W
0A1CC:  BNZ   A1D6
0A1CE:  MOVF   00,F
0A1D0:  MOVLB  0
0A1D2:  BZ    A224
0A1D4:  MOVLB  7
0A1D6:  MOVF   03,W
0A1D8:  BNZ   A1E4
0A1DA:  MOVLW  01
0A1DC:  SUBWF  00,W
0A1DE:  MOVLB  0
0A1E0:  BZ    A27A
0A1E2:  MOVLB  7
0A1E4:  MOVF   03,W
0A1E6:  BNZ   A1F2
0A1E8:  MOVLW  02
0A1EA:  SUBWF  00,W
0A1EC:  MOVLB  0
0A1EE:  BZ    A27A
0A1F0:  MOVLB  7
0A1F2:  MOVF   03,W
0A1F4:  BNZ   A202
0A1F6:  MOVLW  03
0A1F8:  SUBWF  00,W
0A1FA:  MOVLB  0
0A1FC:  BTFSC  FD8.2
0A1FE:  BRA    A348
0A200:  MOVLB  7
0A202:  MOVF   03,W
0A204:  BNZ   A212
0A206:  MOVLW  04
0A208:  SUBWF  00,W
0A20A:  MOVLB  0
0A20C:  BTFSC  FD8.2
0A20E:  BRA    A498
0A210:  MOVLB  7
0A212:  MOVF   03,W
0A214:  BNZ   A222
0A216:  MOVLW  05
0A218:  SUBWF  00,W
0A21A:  MOVLB  0
0A21C:  BTFSC  FD8.2
0A21E:  BRA    A5E8
0A220:  MOVLB  7
0A222:  BRA    A6A0
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A224:  MOVLB  7
0A226:  MOVF   x40,W
0A228:  MULLW  04
0A22A:  MOVF   FF3,W
0A22C:  CLRF   03
0A22E:  ADDLW  A2
0A230:  MOVWF  FE9
0A232:  MOVLW  07
0A234:  ADDWFC 03,W
0A236:  MOVWF  FEA
0A238:  MOVFF  FEF,8B5
0A23C:  MOVFF  FEC,8B6
0A240:  MOVFF  FEC,8B7
0A244:  MOVFF  FEC,8B8
0A248:  MOVLB  8
0A24A:  MOVF   xAA,W
0A24C:  SUBWF  xB8,W
0A24E:  BNC   A274
0A250:  BNZ   A268
0A252:  MOVF   xA9,W
0A254:  SUBWF  xB7,W
0A256:  BNC   A274
0A258:  BNZ   A268
0A25A:  MOVF   xA8,W
0A25C:  SUBWF  xB6,W
0A25E:  BNC   A274
0A260:  BNZ   A268
0A262:  MOVF   xA7,W
0A264:  SUBWF  xB5,W
0A266:  BNC   A274
....................                { 
....................                   terminate(1); 
0A268:  MOVLW  01
0A26A:  MOVWF  xC9
0A26C:  MOVLB  0
0A26E:  CALL   9070
0A272:  MOVLB  8
....................                } 
....................                break; 
0A274:  MOVLB  7
0A276:  BRA    A6A0
0A278:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A27A:  BCF    FD8.0
0A27C:  MOVLB  7
0A27E:  RLCF   x40,W
0A280:  CLRF   03
0A282:  ADDLW  9A
0A284:  MOVWF  FE9
0A286:  MOVLW  07
0A288:  ADDWFC 03,W
0A28A:  MOVWF  FEA
0A28C:  MOVFF  FEC,8B6
0A290:  MOVF   FED,F
0A292:  MOVFF  FEF,8B5
0A296:  BCF    FD8.0
0A298:  RLCF   x40,W
0A29A:  CLRF   03
0A29C:  ADDLW  5A
0A29E:  MOVWF  FE9
0A2A0:  MOVLW  07
0A2A2:  ADDWFC 03,W
0A2A4:  MOVWF  FEA
0A2A6:  MOVFF  FEC,03
0A2AA:  MOVF   FED,F
0A2AC:  MOVFF  FEF,01
0A2B0:  MOVF   03,W
0A2B2:  MOVLB  8
0A2B4:  SUBWF  xB6,W
0A2B6:  BNC   A2CA
0A2B8:  BNZ   A2C0
0A2BA:  MOVF   01,W
0A2BC:  SUBWF  xB5,W
0A2BE:  BNC   A2CA
....................                { 
....................                   terminate(0); 
0A2C0:  CLRF   xC9
0A2C2:  MOVLB  0
0A2C4:  CALL   9070
0A2C8:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A2CA:  BCF    FD8.0
0A2CC:  MOVLB  7
0A2CE:  RLCF   x40,W
0A2D0:  CLRF   03
0A2D2:  ADDLW  BB
0A2D4:  MOVWF  FE9
0A2D6:  MOVLW  07
0A2D8:  ADDWFC 03,W
0A2DA:  MOVWF  FEA
0A2DC:  MOVFF  FEC,8B6
0A2E0:  MOVF   FED,F
0A2E2:  MOVFF  FEF,8B5
0A2E6:  MOVLB  8
0A2E8:  MOVF   xAA,F
0A2EA:  BNZ   A342
0A2EC:  MOVF   xA9,F
0A2EE:  BNZ   A342
0A2F0:  MOVF   xA8,W
0A2F2:  SUBWF  xB6,W
0A2F4:  BNC   A342
0A2F6:  BNZ   A2FE
0A2F8:  MOVF   xA7,W
0A2FA:  SUBWF  xB5,W
0A2FC:  BNC   A342
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A2FE:  BCF    FD8.0
0A300:  MOVLB  7
0A302:  RLCF   x40,W
0A304:  CLRF   03
0A306:  ADDLW  B7
0A308:  MOVWF  FE9
0A30A:  MOVLW  07
0A30C:  ADDWFC 03,W
0A30E:  MOVWF  FEA
0A310:  MOVFF  FEC,8BC
0A314:  MOVF   FED,F
0A316:  MOVFF  FEF,8BB
0A31A:  MOVFF  8AA,8BA
0A31E:  MOVFF  8A9,8B9
0A322:  MOVFF  8A8,8B8
0A326:  MOVFF  8A7,8B7
0A32A:  MOVLB  0
0A32C:  CALL   9630
0A330:  MOVFF  03,8AF
0A334:  MOVFF  02,8AE
0A338:  MOVFF  01,8AD
0A33C:  MOVFF  00,8AC
0A340:  MOVLB  8
....................                } 
....................                break; 
0A342:  MOVLB  7
0A344:  BRA    A6A0
0A346:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A348:  BCF    FD8.0
0A34A:  MOVLB  7
0A34C:  RLCF   x40,W
0A34E:  CLRF   03
0A350:  ADDLW  BB
0A352:  MOVWF  FE9
0A354:  MOVLW  07
0A356:  ADDWFC 03,W
0A358:  MOVWF  FEA
0A35A:  MOVFF  FEC,8B6
0A35E:  MOVF   FED,F
0A360:  MOVFF  FEF,8B5
0A364:  MOVLB  8
0A366:  MOVF   xAA,F
0A368:  BNZ   A386
0A36A:  MOVF   xA9,F
0A36C:  BNZ   A386
0A36E:  MOVF   xA8,W
0A370:  SUBWF  xB6,W
0A372:  BNC   A386
0A374:  BNZ   A37C
0A376:  MOVF   xA7,W
0A378:  SUBWF  xB5,W
0A37A:  BNC   A386
....................                { 
....................                   terminate(0); 
0A37C:  CLRF   xC9
0A37E:  MOVLB  0
0A380:  CALL   9070
0A384:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A386:  BCF    FD8.0
0A388:  MOVLB  7
0A38A:  RLCF   x40,W
0A38C:  CLRF   03
0A38E:  ADDLW  7A
0A390:  MOVWF  FE9
0A392:  MOVLW  07
0A394:  ADDWFC 03,W
0A396:  MOVWF  FEA
0A398:  MOVFF  FEC,8B6
0A39C:  MOVF   FED,F
0A39E:  MOVFF  FEF,8B5
0A3A2:  MOVLB  8
0A3A4:  MOVF   xB5,F
0A3A6:  BNZ   A40C
0A3A8:  MOVF   xB6,F
0A3AA:  BNZ   A40C
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A3AC:  CLRF   03
0A3AE:  MOVLB  7
0A3B0:  MOVF   x40,W
0A3B2:  ADDLW  CB
0A3B4:  MOVWF  FE9
0A3B6:  MOVLW  07
0A3B8:  ADDWFC 03,W
0A3BA:  MOVWF  FEA
0A3BC:  MOVF   FEF,F
0A3BE:  BNZ   A40A
....................                   { 
....................                      wrt_m_error(); 
0A3C0:  MOVLB  0
0A3C2:  CALL   8F20
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A3C6:  BCF    FD8.0
0A3C8:  MOVLB  7
0A3CA:  RLCF   x40,W
0A3CC:  CLRF   03
0A3CE:  ADDLW  B7
0A3D0:  MOVWF  FE9
0A3D2:  MOVLW  07
0A3D4:  ADDWFC 03,W
0A3D6:  MOVWF  FEA
0A3D8:  MOVFF  FEC,8BC
0A3DC:  MOVF   FED,F
0A3DE:  MOVFF  FEF,8BB
0A3E2:  MOVFF  8AA,8BA
0A3E6:  MOVFF  8A9,8B9
0A3EA:  MOVFF  8A8,8B8
0A3EE:  MOVFF  8A7,8B7
0A3F2:  MOVLB  0
0A3F4:  CALL   9630
0A3F8:  MOVFF  03,8AF
0A3FC:  MOVFF  02,8AE
0A400:  MOVFF  01,8AD
0A404:  MOVFF  00,8AC
0A408:  MOVLB  7
0A40A:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A40C:  BCF    FD8.0
0A40E:  MOVLB  7
0A410:  RLCF   x40,W
0A412:  CLRF   03
0A414:  ADDLW  7A
0A416:  MOVWF  FE9
0A418:  MOVLW  07
0A41A:  ADDWFC 03,W
0A41C:  MOVWF  FEA
0A41E:  MOVFF  FEC,8B6
0A422:  MOVF   FED,F
0A424:  MOVFF  FEF,8B5
0A428:  MOVLB  8
0A42A:  DECFSZ xB5,W
0A42C:  BRA    A492
0A42E:  MOVF   xB6,F
0A430:  BNZ   A492
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A432:  CLRF   03
0A434:  MOVLB  7
0A436:  MOVF   x40,W
0A438:  ADDLW  CB
0A43A:  MOVWF  FE9
0A43C:  MOVLW  07
0A43E:  ADDWFC 03,W
0A440:  MOVWF  FEA
0A442:  DECFSZ FEF,W
0A444:  BRA    A490
....................                   { 
....................                      wrt_m_error(); 
0A446:  MOVLB  0
0A448:  CALL   8F20
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A44C:  BCF    FD8.0
0A44E:  MOVLB  7
0A450:  RLCF   x40,W
0A452:  CLRF   03
0A454:  ADDLW  B7
0A456:  MOVWF  FE9
0A458:  MOVLW  07
0A45A:  ADDWFC 03,W
0A45C:  MOVWF  FEA
0A45E:  MOVFF  FEC,8BC
0A462:  MOVF   FED,F
0A464:  MOVFF  FEF,8BB
0A468:  MOVFF  8AA,8BA
0A46C:  MOVFF  8A9,8B9
0A470:  MOVFF  8A8,8B8
0A474:  MOVFF  8A7,8B7
0A478:  MOVLB  0
0A47A:  CALL   9630
0A47E:  MOVFF  03,8AF
0A482:  MOVFF  02,8AE
0A486:  MOVFF  01,8AD
0A48A:  MOVFF  00,8AC
0A48E:  MOVLB  7
0A490:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A492:  MOVLB  7
0A494:  BRA    A6A0
0A496:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A498:  MOVLB  7
0A49A:  MOVF   x40,W
0A49C:  MULLW  04
0A49E:  MOVF   FF3,W
0A4A0:  CLRF   03
0A4A2:  ADDLW  A2
0A4A4:  MOVWF  FE9
0A4A6:  MOVLW  07
0A4A8:  ADDWFC 03,W
0A4AA:  MOVWF  FEA
0A4AC:  MOVFF  FEF,8B5
0A4B0:  MOVFF  FEC,8B6
0A4B4:  MOVFF  FEC,8B7
0A4B8:  MOVFF  FEC,8B8
0A4BC:  MOVLB  8
0A4BE:  MOVF   xAC,W
0A4C0:  SUBWF  xB5,F
0A4C2:  MOVF   xAD,W
0A4C4:  SUBWFB xB6,F
0A4C6:  MOVF   xAE,W
0A4C8:  SUBWFB xB7,F
0A4CA:  MOVF   xAF,W
0A4CC:  SUBWFB xB8,F
0A4CE:  BNZ   A4E6
0A4D0:  MOVF   xB7,F
0A4D2:  BNZ   A4E6
0A4D4:  MOVF   xB3,W
0A4D6:  SUBWF  xB6,W
0A4D8:  BTFSS  FD8.0
0A4DA:  BRA    A5E2
0A4DC:  BNZ   A4E6
0A4DE:  MOVF   xB2,W
0A4E0:  SUBWF  xB5,W
0A4E2:  BTFSS  FD8.0
0A4E4:  BRA    A5E2
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A4E6:  BCF    FD8.0
0A4E8:  MOVLB  7
0A4EA:  RLCF   x40,W
0A4EC:  CLRF   03
0A4EE:  ADDLW  66
0A4F0:  MOVWF  01
0A4F2:  MOVLW  07
0A4F4:  ADDWFC 03,F
0A4F6:  MOVLB  8
0A4F8:  MOVFF  03,8B6
0A4FC:  BCF    FD8.0
0A4FE:  MOVLB  7
0A500:  RLCF   x40,W
0A502:  CLRF   03
0A504:  ADDLW  9E
0A506:  MOVWF  FE9
0A508:  MOVLW  07
0A50A:  ADDWFC 03,W
0A50C:  MOVWF  FEA
0A50E:  MOVFF  FEC,03
0A512:  MOVF   FED,F
0A514:  MOVFF  FEF,8B7
0A518:  MOVLB  8
0A51A:  MOVFF  8B6,FEA
0A51E:  MOVFF  01,FE9
0A522:  MOVFF  03,FEC
0A526:  MOVF   FED,F
0A528:  MOVFF  8B7,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A52C:  MOVLB  7
0A52E:  MOVF   x40,W
0A530:  MULLW  04
0A532:  MOVF   FF3,W
0A534:  CLRF   03
0A536:  ADDLW  A2
0A538:  MOVWF  FE9
0A53A:  MOVLW  07
0A53C:  ADDWFC 03,W
0A53E:  MOVWF  FEA
0A540:  MOVFF  FEF,8B5
0A544:  MOVFF  FEC,8B6
0A548:  MOVFF  FEC,8B7
0A54C:  MOVFF  FEC,8B8
0A550:  MOVLW  B6
0A552:  MOVWF  FF6
0A554:  MOVLW  1A
0A556:  MOVWF  FF7
0A558:  MOVLW  00
0A55A:  MOVWF  FF8
0A55C:  CLRF   1B
0A55E:  BTFSC  FF2.7
0A560:  BSF    1B.7
0A562:  BCF    FF2.7
0A564:  MOVLW  0B
0A566:  MOVLB  A
0A568:  MOVWF  x19
0A56A:  MOVLB  0
0A56C:  CALL   104E
0A570:  BTFSC  1B.7
0A572:  BSF    FF2.7
0A574:  MOVLW  41
0A576:  MOVWF  FE9
0A578:  CLRF   1B
0A57A:  BTFSC  FF2.7
0A57C:  BSF    1B.7
0A57E:  BCF    FF2.7
0A580:  MOVFF  8B8,A1C
0A584:  MOVFF  8B7,A1B
0A588:  MOVFF  8B6,A1A
0A58C:  MOVFF  8B5,A19
0A590:  CALL   1114
0A594:  BTFSC  1B.7
0A596:  BSF    FF2.7
0A598:  MOVLW  2C
0A59A:  BTFSS  F9E.4
0A59C:  BRA    A59A
0A59E:  MOVWF  FAD
0A5A0:  MOVLW  41
0A5A2:  MOVWF  FE9
0A5A4:  CLRF   1B
0A5A6:  BTFSC  FF2.7
0A5A8:  BSF    1B.7
0A5AA:  BCF    FF2.7
0A5AC:  MOVFF  8AF,A1C
0A5B0:  MOVFF  8AE,A1B
0A5B4:  MOVFF  8AD,A1A
0A5B8:  MOVFF  8AC,A19
0A5BC:  CALL   1114
0A5C0:  BTFSC  1B.7
0A5C2:  BSF    FF2.7
0A5C4:  MOVLW  0D
0A5C6:  BTFSS  F9E.4
0A5C8:  BRA    A5C6
0A5CA:  MOVWF  FAD
0A5CC:  MOVLW  0A
0A5CE:  BTFSS  F9E.4
0A5D0:  BRA    A5CE
0A5D2:  MOVWF  FAD
....................                   terminate(1); 
0A5D4:  MOVLW  01
0A5D6:  MOVLB  8
0A5D8:  MOVWF  xC9
0A5DA:  MOVLB  0
0A5DC:  CALL   9070
0A5E0:  MOVLB  8
....................                } 
....................                break; 
0A5E2:  MOVLB  7
0A5E4:  BRA    A6A0
0A5E6:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A5E8:  MOVLB  7
0A5EA:  MOVF   x40,W
0A5EC:  MULLW  04
0A5EE:  MOVF   FF3,W
0A5F0:  CLRF   03
0A5F2:  ADDLW  A2
0A5F4:  MOVWF  FE9
0A5F6:  MOVLW  07
0A5F8:  ADDWFC 03,W
0A5FA:  MOVWF  FEA
0A5FC:  MOVFF  FEF,8B5
0A600:  MOVFF  FEC,8B6
0A604:  MOVFF  FEC,8B7
0A608:  MOVFF  FEC,8B8
0A60C:  BCF    FD8.0
0A60E:  RLCF   x40,W
0A610:  CLRF   03
0A612:  ADDLW  72
0A614:  MOVWF  FE9
0A616:  MOVLW  07
0A618:  ADDWFC 03,W
0A61A:  MOVWF  FEA
0A61C:  MOVFF  FEC,03
0A620:  MOVF   FED,F
0A622:  MOVFF  FEF,01
0A626:  MOVLB  8
0A628:  MOVF   xB8,F
0A62A:  BNZ   A63E
0A62C:  MOVF   xB7,F
0A62E:  BNZ   A63E
0A630:  MOVF   03,W
0A632:  SUBWF  xB6,W
0A634:  BNC   A69E
0A636:  BNZ   A63E
0A638:  MOVF   01,W
0A63A:  SUBWF  xB5,W
0A63C:  BNC   A69E
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A63E:  BCF    FD8.0
0A640:  MOVLB  7
0A642:  RLCF   x40,W
0A644:  CLRF   03
0A646:  ADDLW  66
0A648:  MOVWF  01
0A64A:  MOVLW  07
0A64C:  ADDWFC 03,F
0A64E:  MOVLB  8
0A650:  MOVFF  03,8B6
0A654:  BCF    FD8.0
0A656:  MOVLB  7
0A658:  RLCF   x40,W
0A65A:  CLRF   03
0A65C:  ADDLW  9E
0A65E:  MOVWF  FE9
0A660:  MOVLW  07
0A662:  ADDWFC 03,W
0A664:  MOVWF  FEA
0A666:  MOVFF  FEC,03
0A66A:  MOVF   FED,F
0A66C:  MOVFF  FEF,8B7
0A670:  MOVLB  8
0A672:  MOVFF  8B6,FEA
0A676:  MOVFF  01,FE9
0A67A:  MOVFF  03,FEC
0A67E:  MOVF   FED,F
0A680:  MOVFF  8B7,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A684:  BCF    FD8.0
0A686:  MOVLB  7
0A688:  RLCF   x40,W
0A68A:  CLRF   03
0A68C:  ADDLW  BB
0A68E:  MOVWF  FE9
0A690:  MOVLW  07
0A692:  ADDWFC 03,W
0A694:  MOVWF  FEA
0A696:  CLRF   FEC
0A698:  MOVF   FED,F
0A69A:  CLRF   FEF
0A69C:  MOVLB  8
....................                } 
....................                break; 
0A69E:  MOVLB  7
....................             } 
....................          } 
0A6A0:  MOVLB  0
0A6A2:  BRA    A194
0A6A4:  MOVLB  7
....................       } 
....................    } 
0A6A6:  BRA    A6C4
0A6A8:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A6AA:  BCF    FD8.0
0A6AC:  MOVLB  7
0A6AE:  RLCF   x40,W
0A6B0:  CLRF   03
0A6B2:  ADDLW  96
0A6B4:  MOVWF  FE9
0A6B6:  MOVLW  07
0A6B8:  ADDWFC 03,W
0A6BA:  MOVWF  FEA
0A6BC:  CLRF   FEC
0A6BE:  MOVF   FED,F
0A6C0:  MOVLW  01
0A6C2:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A6C4:  BCF    FD8.0
0A6C6:  RLCF   x40,W
0A6C8:  CLRF   03
0A6CA:  ADDLW  96
0A6CC:  MOVWF  FE9
0A6CE:  MOVLW  07
0A6D0:  ADDWFC 03,W
0A6D2:  MOVWF  FEA
0A6D4:  MOVFF  FEC,8B6
0A6D8:  MOVF   FED,F
0A6DA:  MOVFF  FEF,8B5
0A6DE:  MOVLB  8
0A6E0:  DECFSZ xB5,W
0A6E2:  BRA    A6F4
0A6E4:  MOVF   xB6,F
0A6E6:  BNZ   A6F4
....................       wrt_m_error(); 
0A6E8:  MOVLB  0
0A6EA:  CALL   8F20
....................       msg_mer(); 
0A6EE:  CALL   9CA2
0A6F2:  MOVLB  8
....................    } 
0A6F4:  MOVLB  0
0A6F6:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
....................    } 
....................    else if(arg==0) 
....................    { 
....................       m_lin_pos[motor]=0; 
....................       switch (motor){ 
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
....................             break; 
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
....................             break; 
....................       }  
....................       m_error[motor]=0; 
....................       wrt_m_error(); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
....................       switch(motor) 
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
....................             chanA = input(ENC1_PHA); 
....................             break; 
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
....................             chanA = input(ENC2_PHA); 
....................             break; 
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
....................       if (kbhit(COM_A)) 
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
....................          { 
....................             break; 
....................          } 
....................       } 
....................    } 
....................  
....................    delay_ms(100); 
....................    enc_pwr(OFF); 
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A854:  BCF    FD8.0
0A856:  MOVLB  7
0A858:  RLCF   x40,W
0A85A:  CLRF   03
0A85C:  ADDLW  66
0A85E:  MOVWF  FE9
0A860:  MOVLW  07
0A862:  ADDWFC 03,W
0A864:  MOVWF  FEA
0A866:  MOVFF  FEC,8A4
0A86A:  MOVF   FED,F
0A86C:  MOVFF  FEF,8A3
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A870:  BCF    FD8.0
0A872:  RLCF   x40,W
0A874:  CLRF   03
0A876:  ADDLW  76
0A878:  MOVWF  FE9
0A87A:  MOVLW  07
0A87C:  ADDWFC 03,W
0A87E:  MOVWF  FEA
0A880:  MOVFF  FEC,8BA
0A884:  MOVF   FED,F
0A886:  MOVFF  FEF,8B9
0A88A:  BCF    FD8.0
0A88C:  RLCF   x40,W
0A88E:  CLRF   03
0A890:  ADDLW  62
0A892:  MOVWF  FE9
0A894:  MOVLW  07
0A896:  ADDWFC 03,W
0A898:  MOVWF  FEA
0A89A:  MOVFF  FEC,03
0A89E:  MOVF   FED,F
0A8A0:  MOVFF  FEF,8BB
0A8A4:  MOVFF  03,8A8
0A8A8:  MOVFF  03,8BC
0A8AC:  MOVLB  0
0A8AE:  CALL   2CB4
0A8B2:  MOVFF  02,8A2
0A8B6:  MOVFF  01,8A1
....................    e_mode[motor] = 0;                          // motor steps 
0A8BA:  BCF    FD8.0
0A8BC:  MOVLB  7
0A8BE:  RLCF   x40,W
0A8C0:  CLRF   03
0A8C2:  ADDLW  66
0A8C4:  MOVWF  FE9
0A8C6:  MOVLW  07
0A8C8:  ADDWFC 03,W
0A8CA:  MOVWF  FEA
0A8CC:  CLRF   FEC
0A8CE:  MOVF   FED,F
0A8D0:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A8D2:  MOVLB  8
0A8D4:  CLRF   xA5
0A8D6:  MOVFF  8A0,8A6
0A8DA:  CLRF   xAA
0A8DC:  CLRF   xA9
0A8DE:  MOVFF  8A2,8A8
0A8E2:  MOVFF  8A1,8A7
0A8E6:  MOVLW  01
0A8E8:  MOVWF  xAB
0A8EA:  MOVLB  0
0A8EC:  CALL   9D18
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A8F0:  MOVLW  01
0A8F2:  MOVLB  8
0A8F4:  MOVWF  xCA
0A8F6:  MOVLB  0
0A8F8:  CALL   8970
....................    delay_ms(100); 
0A8FC:  MOVLW  64
0A8FE:  MOVLB  A
0A900:  MOVWF  xA2
0A902:  MOVLB  0
0A904:  CALL   0588
....................    poll_index(); 
0A908:  BRA    A722
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A90A:  BCF    FD8.0
0A90C:  MOVLB  7
0A90E:  RLCF   x40,W
0A910:  CLRF   03
0A912:  ADDLW  5E
0A914:  MOVWF  FE9
0A916:  MOVLW  07
0A918:  ADDWFC 03,W
0A91A:  MOVWF  FEA
0A91C:  MOVFF  FEC,8A6
0A920:  MOVF   FED,F
0A922:  MOVFF  FEF,8A5
0A926:  MOVLW  02
0A928:  MOVLB  8
0A92A:  ADDWF  xA5,W
0A92C:  MOVWF  xA1
0A92E:  MOVLW  00
0A930:  ADDWFC xA6,W
0A932:  MOVWF  xA2
....................    e_mode[motor] = 3; 
0A934:  BCF    FD8.0
0A936:  MOVLB  7
0A938:  RLCF   x40,W
0A93A:  CLRF   03
0A93C:  ADDLW  66
0A93E:  MOVWF  FE9
0A940:  MOVLW  07
0A942:  ADDWFC 03,W
0A944:  MOVWF  FEA
0A946:  CLRF   FEC
0A948:  MOVF   FED,F
0A94A:  MOVLW  03
0A94C:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A94E:  MOVLB  8
0A950:  CLRF   xA5
0A952:  MOVFF  8A0,8A6
0A956:  CLRF   xAA
0A958:  CLRF   xA9
0A95A:  MOVFF  8A2,8A8
0A95E:  MOVFF  8A1,8A7
0A962:  MOVLW  01
0A964:  MOVWF  xAB
0A966:  MOVLB  0
0A968:  CALL   9D18
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A96C:  MOVFF  783,8A2
0A970:  MOVFF  782,8A1
....................    e_mode[motor] = 0;                          // motor steps 
0A974:  BCF    FD8.0
0A976:  MOVLB  7
0A978:  RLCF   x40,W
0A97A:  CLRF   03
0A97C:  ADDLW  66
0A97E:  MOVWF  FE9
0A980:  MOVLW  07
0A982:  ADDWFC 03,W
0A984:  MOVWF  FEA
0A986:  CLRF   FEC
0A988:  MOVF   FED,F
0A98A:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0A98C:  MOVLB  8
0A98E:  CLRF   xA5
0A990:  MOVFF  8A0,8A6
0A994:  CLRF   xAA
0A996:  CLRF   xA9
0A998:  MOVFF  8A2,8A8
0A99C:  MOVFF  8A1,8A7
0A9A0:  MOVLW  01
0A9A2:  MOVWF  xAB
0A9A4:  MOVLB  0
0A9A6:  CALL   9D18
....................  
....................    e_pos[motor] = 0; 
0A9AA:  BCF    FD8.0
0A9AC:  MOVLB  7
0A9AE:  RLCF   x40,W
0A9B0:  CLRF   03
0A9B2:  ADDLW  BF
0A9B4:  MOVWF  FE9
0A9B6:  MOVLW  07
0A9B8:  ADDWFC 03,W
0A9BA:  MOVWF  FEA
0A9BC:  CLRF   FEC
0A9BE:  MOVF   FED,F
0A9C0:  CLRF   FEF
....................    e_port[motor] = 1; 
0A9C2:  BCF    FD8.0
0A9C4:  RLCF   x40,W
0A9C6:  CLRF   03
0A9C8:  ADDLW  C3
0A9CA:  MOVWF  FE9
0A9CC:  MOVLW  07
0A9CE:  ADDWFC 03,W
0A9D0:  MOVWF  FEA
0A9D2:  CLRF   FEC
0A9D4:  MOVF   FED,F
0A9D6:  MOVLW  01
0A9D8:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0A9DA:  BCF    FD8.0
0A9DC:  RLCF   x40,W
0A9DE:  CLRF   03
0A9E0:  ADDLW  66
0A9E2:  MOVWF  FE9
0A9E4:  MOVLW  07
0A9E6:  ADDWFC 03,W
0A9E8:  MOVWF  FEA
0A9EA:  MOVFF  8A4,FEC
0A9EE:  MOVF   FED,F
0A9F0:  MOVFF  8A3,FEF
0A9F4:  MOVLB  0
0A9F6:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
0A9F8:  MOVF   2F,W
0A9FA:  SUBLW  02
0A9FC:  BNZ   AA02
0A9FE:  MOVF   30,F
0AA00:  BZ    AA6A
....................    { 
....................       //setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_256); 
....................       //set up valve timeout variable 
....................       /*ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
....................       enable_interrupts(INT_EXT); 
....................  
....................       start_heartbeat(); 
....................  
....................       enable_interrupts(GLOBAL); 
....................       busy_set();*/ 
....................       valve_align_timeout = 0; 
0AA02:  CLRF   3A
0AA04:  CLRF   39
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0AA06:  MOVLW  DE
0AA08:  MOVWF  FF6
0AA0A:  MOVLW  1A
0AA0C:  MOVWF  FF7
0AA0E:  MOVLW  00
0AA10:  MOVWF  FF8
0AA12:  CLRF   1B
0AA14:  BTFSC  FF2.7
0AA16:  BSF    1B.7
0AA18:  BCF    FF2.7
0AA1A:  CALL   0E78
0AA1E:  BTFSC  1B.7
0AA20:  BSF    FF2.7
....................       motor=0; 
0AA22:  MOVLB  7
0AA24:  CLRF   x40
....................       align(0); 
0AA26:  MOVLB  8
0AA28:  CLRF   xA0
0AA2A:  MOVLB  0
0AA2C:  RCALL  A854
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0AA2E:  MOVLW  01
0AA30:  MOVLB  7
0AA32:  MOVWF  x40
....................       move_motor(0,0,22000,1); 
0AA34:  MOVLB  8
0AA36:  CLRF   xA5
0AA38:  CLRF   xA6
0AA3A:  CLRF   xAA
0AA3C:  CLRF   xA9
0AA3E:  MOVLW  55
0AA40:  MOVWF  xA8
0AA42:  MOVLW  F0
0AA44:  MOVWF  xA7
0AA46:  MOVLW  01
0AA48:  MOVWF  xAB
0AA4A:  MOVLB  0
0AA4C:  CALL   9D18
....................        
....................       m_lin_pos[1]=0; 
0AA50:  MOVLB  7
0AA52:  CLRF   xB6
0AA54:  CLRF   xB5
....................       write16(ADDR_M2_LIN_POS,0); 
0AA56:  MOVLW  B8
0AA58:  MOVLB  8
0AA5A:  MOVWF  xCC
0AA5C:  CLRF   xCE
0AA5E:  CLRF   xCD
0AA60:  MOVLB  0
0AA62:  CALL   4FAE
....................       valve_align_timeout = -1; 
0AA66:  SETF   3A
0AA68:  SETF   39
....................    } 
0AA6A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
112A6:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
112A8:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
112AA:  BCF    F8E.3
....................   delay_ms(20); 
112AC:  MOVLW  14
112AE:  MOVLB  A
112B0:  MOVWF  xA2
112B2:  MOVLB  0
112B4:  CALL   0588
....................   output_bit(VMOT,  OFF); 
112B8:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
112BA:  BCF    F8E.2
112BC:  GOTO   11312 (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
112C0:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
112C2:  BSF    F8E.1
....................   delay_ms(50); 
112C4:  MOVLW  32
112C6:  MOVLB  A
112C8:  MOVWF  xA2
112CA:  MOVLB  0
112CC:  CALL   0588
....................   output_bit(HB_IN1,ON);           
112D0:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
112D2:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
112D4:  BSF    F8E.3
112D6:  GOTO   11312 (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
112DA:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
112DC:  BSF    F8E.1
....................   delay_ms(50); 
112DE:  MOVLW  32
112E0:  MOVLB  A
112E2:  MOVWF  xA2
112E4:  MOVLB  0
112E6:  CALL   0588
....................   output_bit(HB_IN1,OFF);           
112EA:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
112EC:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
112EE:  BSF    F8E.3
112F0:  GOTO   11312 (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
112F4:  MOVLB  8
112F6:  MOVF   x93,W
112F8:  XORLW  00
112FA:  MOVLB  0
112FC:  BZ    11308
112FE:  XORLW  01
11300:  BZ    1130C
11302:  XORLW  03
11304:  BZ    11310
11306:  BRA    11312
....................       case 0:  HB_all_OFF(); 
11308:  BRA    112A6
....................          break; 
1130A:  BRA    11312
....................       case 1:  HB_m1_ON(); 
1130C:  BRA    112C0
....................          break; 
1130E:  BRA    11312
....................       case 2:  HB_m2_ON(); 
11310:  BRA    112DA
....................          break; 
....................    } 
11312:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
0B08E:  MOVLB  8
0B090:  CLRF   x68
0B092:  CLRF   x69
0B094:  CLRF   x6A
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
0B096:  MOVLB  0
0B098:  BRA    B026
0B09A:  MOVFF  01,869
....................       if (serChar) 
0B09E:  MOVLB  8
0B0A0:  MOVF   x69,F
0B0A2:  BZ    B0CC
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
0B0A4:  MOVF   x69,W
0B0A6:  SUBLW  24
0B0A8:  BNZ   B0B2
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
0B0AA:  MOVLW  02
0B0AC:  MOVWF  x6A
....................             break; 
0B0AE:  BRA    B0D8
....................          }else if (serChar == 'D'){ 
0B0B0:  BRA    B0CC
0B0B2:  MOVF   x69,W
0B0B4:  SUBLW  44
0B0B6:  BNZ   B0C8
....................             wakeup_char_is_D = 1; 
0B0B8:  MOVLW  01
0B0BA:  MOVLB  7
0B0BC:  MOVWF  xCD
....................             wakeUpReason = WAKE_UP_GOOD; 
0B0BE:  MOVLW  02
0B0C0:  MOVLB  8
0B0C2:  MOVWF  x6A
....................             break; 
0B0C4:  BRA    B0D8
....................          }else 
0B0C6:  BRA    B0CC
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
0B0C8:  MOVLW  01
0B0CA:  MOVWF  x6A
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
0B0CC:  INCF   x68,F
0B0CE:  MOVF   x68,W
0B0D0:  SUBLW  02
0B0D2:  BC    B0D6
....................       { 
....................          break; 
0B0D4:  BRA    B0D8
....................       } 
0B0D6:  BRA    B096
....................    } 
....................  
....................    return (wakeUpReason); 
0B0D8:  MOVFF  86A,01
0B0DC:  MOVLB  0
0B0DE:  GOTO   BBDA (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
0AFBE:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
0AFC0:  BSF    4D.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
0AFC2:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
0AFC4:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
0AFC6:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
0AFC8:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
0AFCA:  BSF    FF2.6
0AFCC:  GOTO   AFD8 (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
0AFD0:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
0AFD2:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
0AFD4:  BCF    4D.0
....................    set_usart_int(); 
0AFD6:  BRA    AFBE
....................    kill_wd(); 
0AFD8:  CALL   30D8
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
0AFDC:  BSF    FF2.4
....................    sleep();  
0AFDE:  MOVFF  FD3,00
0AFE2:  BCF    FD1.7
0AFE4:  BCF    FD3.7
0AFE6:  SLEEP 
0AFE8:  MOVFF  00,FD3
....................    delay_cycles(1); 
0AFEC:  NOP   
0AFEE:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
0BBC4:  MOVLB  8
0BBC6:  CLRF   x67
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
0BBC8:  MOVLB  0
0BBCA:  CALL   AFF0
....................  
....................    if (TRUE != rtc_alarm) 
0BBCE:  BTFSC  4D.0
0BBD0:  BRA    BC94
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
0BBD2:  CALL   AFF0
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
0BBD6:  GOTO   B08E
0BBDA:  MOVFF  01,867
....................       if (WAKE_UP_GOOD == serWakeupReason) 
0BBDE:  MOVLB  8
0BBE0:  MOVF   x67,W
0BBE2:  SUBLW  02
0BBE4:  BNZ   BC8A
....................       { 
....................          sleep_mode = FALSE; 
0BBE6:  BCF    4D.1
....................          start_heartbeat(); 
0BBE8:  MOVLB  0
0BBEA:  CALL   2906
....................          init_hardware(); 
0BBEE:  CALL   2916
....................          init_rtc();                      // This is the FAT RTC 
0BBF2:  CALL   34EC
....................          sd_status = init_sdcard(); 
0BBF6:  CALL   5014
0BBFA:  MOVFF  01,2DC
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
0BBFE:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
0BC00:  MOVLW  01
0BC02:  MOVWF  1E
0BC04:  MOVLW  A7
0BC06:  MOVWF  1D
0BC08:  MOVLW  14
0BC0A:  MOVWF  FF6
0BC0C:  MOVLW  1B
0BC0E:  MOVWF  FF7
0BC10:  MOVLW  00
0BC12:  MOVWF  FF8
0BC14:  CALL   5098
....................          record_event(); 
0BC18:  CALL   847A
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
0BC1C:  CLRF   32
0BC1E:  MOVLW  01
0BC20:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
0BC22:  MOVLW  02
0BC24:  MOVLB  8
0BC26:  MOVWF  xA2
0BC28:  MOVFF  31,8A3
0BC2C:  MOVLB  0
0BC2E:  CALL   33F6
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
0BC32:  MOVLB  7
0BC34:  MOVF   xCD,F
0BC36:  BZ    BC58
....................             file_list(file_ptr_rel_new); 
0BC38:  MOVLW  03
0BC3A:  MOVLB  8
0BC3C:  MOVWF  x69
0BC3E:  MOVLW  07
0BC40:  MOVWF  x68
0BC42:  MOVLB  0
0BC44:  BRA    B79E
....................             f_unlink(file_ptr_rel_new); 
0BC46:  MOVLW  03
0BC48:  MOVLB  8
0BC4A:  MOVWF  x69
0BC4C:  MOVLW  07
0BC4E:  MOVWF  x68
0BC50:  MOVLB  0
0BC52:  BRA    B91A
....................              
....................             wakeup_char_is_D = 0; 
0BC54:  MOVLB  7
0BC56:  CLRF   xCD
....................          } 
....................          if(sd_status>0) 
0BC58:  MOVLB  2
0BC5A:  MOVF   xDC,F
0BC5C:  BZ    BC66
....................          { 
....................             msg_card_fail(); 
0BC5E:  MOVLB  0
0BC60:  CALL   505A
0BC64:  MOVLB  2
....................          } 
....................  
....................          fprintf(COM_A, "@RST\r\n"); 
0BC66:  MOVLW  36
0BC68:  MOVWF  FF6
0BC6A:  MOVLW  1B
0BC6C:  MOVWF  FF7
0BC6E:  MOVLW  00
0BC70:  MOVWF  FF8
0BC72:  CLRF   1B
0BC74:  BTFSC  FF2.7
0BC76:  BSF    1B.7
0BC78:  BCF    FF2.7
0BC7A:  MOVLB  0
0BC7C:  CALL   0E78
0BC80:  BTFSC  1B.7
0BC82:  BSF    FF2.7
....................          reset_cpu(); 
0BC84:  RESET
....................       } 
0BC86:  BRA    BC94
0BC88:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
0BC8A:  DECFSZ x67,W
0BC8C:  BRA    BC96
....................          { 
....................             initilizeSleepState(); 
0BC8E:  MOVLB  0
0BC90:  CALL   AFD0
0BC94:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
0BC96:  MOVLW  00
0BC98:  BTFSC  4D.0
0BC9A:  MOVLW  01
0BC9C:  MOVWF  01
0BC9E:  MOVLB  0
0BCA0:  GOTO   BCAE (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
0BCA4:  CALL   AF54
....................    initilizeSleepState(); 
0BCA8:  CALL   AFD0
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
0BCAC:  BRA    BBC4
0BCAE:  DECFSZ 01,W
0BCB0:  BRA    BCB6
....................       { 
....................          rtc_alarm = FALSE; 
0BCB2:  BCF    4D.0
....................          break; 
0BCB4:  BRA    BCC0
....................       } 
....................  
....................       blip(); 
0BCB6:  CALL   AFF0
....................       blip(); 
0BCBA:  CALL   AFF0
0BCBE:  BRA    BCAC
....................    } 
0BCC0:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0AB66:  MOVF   FD0,W
0AB68:  ANDLW  0F
0AB6A:  BTFSS  FD0.4
0AB6C:  MOVLW  00
0AB6E:  BSF    FD0.0
0AB70:  BSF    FD0.1
0AB72:  BSF    FD0.4
0AB74:  BSF    FD8.3
0AB76:  BSF    FD8.4
0AB78:  ADDLW  F0
0AB7A:  BTFSC  FD8.0
0AB7C:  BRA    AD4C
0AB7E:  ADDLW  10
0AB80:  GOTO   AD50
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0AB84:  MOVLW  3E
0AB86:  MOVWF  FF6
0AB88:  MOVLW  1B
0AB8A:  MOVWF  FF7
0AB8C:  MOVLW  00
0AB8E:  MOVWF  FF8
0AB90:  CLRF   1B
0AB92:  BTFSC  FF2.7
0AB94:  BSF    1B.7
0AB96:  BCF    FF2.7
0AB98:  CALL   0E78
0AB9C:  BTFSC  1B.7
0AB9E:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0ABA0:  MOVLW  01
0ABA2:  MOVWF  1E
0ABA4:  MOVLW  A7
0ABA6:  MOVWF  1D
0ABA8:  MOVLW  46
0ABAA:  MOVWF  FF6
0ABAC:  MOVLW  1B
0ABAE:  MOVWF  FF7
0ABB0:  MOVLW  00
0ABB2:  MOVWF  FF8
0ABB4:  CALL   5098
....................          record_event(); 
0ABB8:  CALL   847A
....................          recovery(); 
0ABBC:  RCALL  A9F8
....................          break; 
0ABBE:  BRA    AD4C
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0ABC0:  MOVLW  64
0ABC2:  MOVWF  FF6
0ABC4:  MOVLW  1B
0ABC6:  MOVWF  FF7
0ABC8:  MOVLW  00
0ABCA:  MOVWF  FF8
0ABCC:  CLRF   1B
0ABCE:  BTFSC  FF2.7
0ABD0:  BSF    1B.7
0ABD2:  BCF    FF2.7
0ABD4:  CALL   0E78
0ABD8:  BTFSC  1B.7
0ABDA:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0ABDC:  MOVLW  01
0ABDE:  MOVWF  1E
0ABE0:  MOVLW  A7
0ABE2:  MOVWF  1D
0ABE4:  MOVLW  6C
0ABE6:  MOVWF  FF6
0ABE8:  MOVLW  1B
0ABEA:  MOVWF  FF7
0ABEC:  MOVLW  00
0ABEE:  MOVWF  FF8
0ABF0:  CALL   5098
....................          record_event(); 
0ABF4:  CALL   847A
....................          recovery(); 
0ABF8:  RCALL  A9F8
....................          break; 
0ABFA:  BRA    AD4C
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0ABFC:  MOVLW  8C
0ABFE:  MOVWF  FF6
0AC00:  MOVLW  1B
0AC02:  MOVWF  FF7
0AC04:  MOVLW  00
0AC06:  MOVWF  FF8
0AC08:  CLRF   1B
0AC0A:  BTFSC  FF2.7
0AC0C:  BSF    1B.7
0AC0E:  BCF    FF2.7
0AC10:  CALL   0E78
0AC14:  BTFSC  1B.7
0AC16:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0AC18:  MOVLW  01
0AC1A:  MOVWF  1E
0AC1C:  MOVLW  A7
0AC1E:  MOVWF  1D
0AC20:  MOVLW  94
0AC22:  MOVWF  FF6
0AC24:  MOVLW  1B
0AC26:  MOVWF  FF7
0AC28:  MOVLW  00
0AC2A:  MOVWF  FF8
0AC2C:  MOVLW  05
0AC2E:  MOVLB  8
0AC30:  MOVWF  xC9
0AC32:  MOVLB  0
0AC34:  RCALL  AA6C
0AC36:  MOVLW  10
0AC38:  MOVWF  FE9
0AC3A:  MOVFF  26,8D5
0AC3E:  MOVFF  25,8D4
0AC42:  RCALL  AA9E
0AC44:  MOVLW  9C
0AC46:  MOVWF  FF6
0AC48:  MOVLW  1B
0AC4A:  MOVWF  FF7
0AC4C:  MOVLW  00
0AC4E:  MOVWF  FF8
0AC50:  MOVLW  20
0AC52:  MOVLB  8
0AC54:  MOVWF  xC9
0AC56:  MOVLB  0
0AC58:  RCALL  AA6C
....................          record_event(); 
0AC5A:  CALL   847A
....................          break; 
0AC5E:  BRA    AD4C
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0AC60:  MOVLW  BE
0AC62:  MOVWF  FF6
0AC64:  MOVLW  1B
0AC66:  MOVWF  FF7
0AC68:  MOVLW  00
0AC6A:  MOVWF  FF8
0AC6C:  CLRF   1B
0AC6E:  BTFSC  FF2.7
0AC70:  BSF    1B.7
0AC72:  BCF    FF2.7
0AC74:  CALL   0E78
0AC78:  BTFSC  1B.7
0AC7A:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0AC7C:  MOVLW  01
0AC7E:  MOVWF  1E
0AC80:  MOVLW  A7
0AC82:  MOVWF  1D
0AC84:  MOVLW  C6
0AC86:  MOVWF  FF6
0AC88:  MOVLW  1B
0AC8A:  MOVWF  FF7
0AC8C:  MOVLW  00
0AC8E:  MOVWF  FF8
0AC90:  CALL   5098
....................          record_event(); 
0AC94:  CALL   847A
....................          break; 
0AC98:  BRA    AD4C
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0AC9A:  MOVLW  EA
0AC9C:  MOVWF  FF6
0AC9E:  MOVLW  1B
0ACA0:  MOVWF  FF7
0ACA2:  MOVLW  00
0ACA4:  MOVWF  FF8
0ACA6:  CLRF   1B
0ACA8:  BTFSC  FF2.7
0ACAA:  BSF    1B.7
0ACAC:  BCF    FF2.7
0ACAE:  CALL   0E78
0ACB2:  BTFSC  1B.7
0ACB4:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0ACB6:  MOVLW  01
0ACB8:  MOVWF  1E
0ACBA:  MOVLW  A7
0ACBC:  MOVWF  1D
0ACBE:  MOVLW  F2
0ACC0:  MOVWF  FF6
0ACC2:  MOVLW  1B
0ACC4:  MOVWF  FF7
0ACC6:  MOVLW  00
0ACC8:  MOVWF  FF8
0ACCA:  CALL   5098
....................          record_event(); 
0ACCE:  CALL   847A
....................          recovery(); 
0ACD2:  RCALL  A9F8
....................          break; 
0ACD4:  BRA    AD4C
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0ACD6:  MOVLW  0E
0ACD8:  MOVWF  FF6
0ACDA:  MOVLW  1C
0ACDC:  MOVWF  FF7
0ACDE:  MOVLW  00
0ACE0:  MOVWF  FF8
0ACE2:  CLRF   1B
0ACE4:  BTFSC  FF2.7
0ACE6:  BSF    1B.7
0ACE8:  BCF    FF2.7
0ACEA:  CALL   0E78
0ACEE:  BTFSC  1B.7
0ACF0:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0ACF2:  MOVLW  01
0ACF4:  MOVWF  1E
0ACF6:  MOVLW  A7
0ACF8:  MOVWF  1D
0ACFA:  MOVLW  16
0ACFC:  MOVWF  FF6
0ACFE:  MOVLW  1C
0AD00:  MOVWF  FF7
0AD02:  MOVLW  00
0AD04:  MOVWF  FF8
0AD06:  CALL   5098
....................          record_event(); 
0AD0A:  CALL   847A
....................          recovery(); 
0AD0E:  RCALL  A9F8
....................          break; 
0AD10:  BRA    AD4C
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0AD12:  MOVLW  38
0AD14:  MOVWF  FF6
0AD16:  MOVLW  1C
0AD18:  MOVWF  FF7
0AD1A:  MOVLW  00
0AD1C:  MOVWF  FF8
0AD1E:  CLRF   1B
0AD20:  BTFSC  FF2.7
0AD22:  BSF    1B.7
0AD24:  BCF    FF2.7
0AD26:  CALL   0E78
0AD2A:  BTFSC  1B.7
0AD2C:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0AD2E:  MOVLW  01
0AD30:  MOVWF  1E
0AD32:  MOVLW  A7
0AD34:  MOVWF  1D
0AD36:  MOVLW  40
0AD38:  MOVWF  FF6
0AD3A:  MOVLW  1C
0AD3C:  MOVWF  FF7
0AD3E:  MOVLW  00
0AD40:  MOVWF  FF8
0AD42:  CALL   5098
....................          record_event(); 
0AD46:  CALL   847A
....................          recovery(); 
0AD4A:  RCALL  A9F8
....................          break; 
....................       }         
....................    } 
0AD4C:  GOTO   14C1E (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02A96:  MOVLW  1E
02A98:  MOVLB  8
02A9A:  MOVWF  x72
02A9C:  MOVLB  0
02A9E:  RCALL  29A8
02AA0:  MOVFF  02,30
02AA4:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02AA8:  MOVLW  1C
02AAA:  MOVLB  8
02AAC:  MOVWF  x72
02AAE:  MOVLB  0
02AB0:  RCALL  29A8
02AB2:  MOVFF  02,20
02AB6:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02ABA:  MOVLW  16
02ABC:  MOVLB  8
02ABE:  MOVWF  x72
02AC0:  MOVLB  0
02AC2:  RCALL  29A8
02AC4:  MOVFF  02,22
02AC8:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02ACC:  MOVLW  14
02ACE:  MOVLB  8
02AD0:  MOVWF  x72
02AD2:  MOVLB  0
02AD4:  RCALL  29A8
02AD6:  MOVFF  02,24
02ADA:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02ADE:  MOVLB  8
02AE0:  CLRF   x72
02AE2:  MOVLB  0
02AE4:  RCALL  29A8
02AE6:  MOVFF  02,26
02AEA:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02AEE:  MOVLW  18
02AF0:  MOVLB  8
02AF2:  MOVWF  x72
02AF4:  MOVLB  0
02AF6:  RCALL  29A8
02AF8:  MOVFF  02,28
02AFC:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02B00:  MOVLW  02
02B02:  MOVLB  8
02B04:  MOVWF  x96
02B06:  MOVLB  0
02B08:  RCALL  2A02
02B0A:  CLRF   32
02B0C:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02B10:  MOVLW  28
02B12:  MOVLB  8
02B14:  MOVWF  x96
02B16:  MOVLB  0
02B18:  RCALL  2A02
02B1A:  CLRF   34
02B1C:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02B20:  MOVLW  12
02B22:  MOVLB  8
02B24:  MOVWF  x72
02B26:  MOVLB  0
02B28:  RCALL  29A8
02B2A:  MOVFF  02,36
02B2E:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02B32:  MOVLW  3A
02B34:  MOVLB  8
02B36:  MOVWF  x72
02B38:  MOVLB  0
02B3A:  RCALL  29A8
02B3C:  MOVFF  02,38
02B40:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02B44:  MOVLW  3C
02B46:  MOVLB  8
02B48:  MOVWF  x72
02B4A:  MOVLB  0
02B4C:  RCALL  29A8
02B4E:  MOVFF  02,3E
02B52:  MOVFF  01,3D
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02B56:  MOVLW  3E
02B58:  MOVLB  8
02B5A:  MOVWF  x72
02B5C:  MOVLB  0
02B5E:  RCALL  29A8
02B60:  MOVFF  02,40
02B64:  MOVFF  01,3F
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02B68:  MOVLW  40
02B6A:  MOVLB  8
02B6C:  MOVWF  x72
02B6E:  MOVLB  0
02B70:  RCALL  29A8
02B72:  MOVFF  02,42
02B76:  MOVFF  01,41
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02B7A:  MOVLW  42
02B7C:  MOVLB  8
02B7E:  MOVWF  x72
02B80:  MOVLB  0
02B82:  RCALL  29A8
02B84:  MOVFF  02,44
02B88:  MOVFF  01,43
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02B8C:  MOVLW  04
02B8E:  MOVLB  8
02B90:  MOVWF  x96
02B92:  MOVLB  0
02B94:  RCALL  2A02
02B96:  MOVFF  01,72D
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02B9A:  MOVLB  8
02B9C:  CLRF   x65
02B9E:  MOVLW  44
02BA0:  MOVWF  x64
02BA2:  MOVLB  0
02BA4:  RCALL  2A28
02BA6:  MOVFF  03,3F8
02BAA:  MOVFF  02,3F7
02BAE:  MOVFF  01,3F6
02BB2:  MOVFF  00,3F5
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02BB6:  MOVLB  8
02BB8:  CLRF   x65
02BBA:  MOVLW  48
02BBC:  MOVWF  x64
02BBE:  MOVLB  0
02BC0:  RCALL  2A28
02BC2:  MOVFF  03,3FC
02BC6:  MOVFF  02,3FB
02BCA:  MOVFF  01,3FA
02BCE:  MOVFF  00,3F9
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02BD2:  MOVLB  8
02BD4:  CLRF   x65
02BD6:  MOVLW  4C
02BD8:  MOVWF  x64
02BDA:  MOVLB  0
02BDC:  RCALL  2A28
02BDE:  MOVFF  03,400
02BE2:  MOVFF  02,3FF
02BE6:  MOVFF  01,3FE
02BEA:  MOVFF  00,3FD
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02BEE:  MOVLB  8
02BF0:  CLRF   x65
02BF2:  MOVLW  52
02BF4:  MOVWF  x64
02BF6:  MOVLB  0
02BF8:  RCALL  2A28
02BFA:  MOVFF  03,404
02BFE:  MOVFF  02,403
02C02:  MOVFF  01,402
02C06:  MOVFF  00,401
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02C0A:  MOVLB  8
02C0C:  CLRF   x65
02C0E:  MOVLW  56
02C10:  MOVWF  x64
02C12:  MOVLB  0
02C14:  RCALL  2A28
02C16:  MOVFF  03,408
02C1A:  MOVFF  02,407
02C1E:  MOVFF  01,406
02C22:  MOVFF  00,405
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02C26:  MOVLB  8
02C28:  CLRF   x65
02C2A:  MOVLW  5A
02C2C:  MOVWF  x64
02C2E:  MOVLB  0
02C30:  RCALL  2A28
02C32:  MOVFF  03,40C
02C36:  MOVFF  02,40B
02C3A:  MOVFF  01,40A
02C3E:  MOVFF  00,409
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02C42:  MOVLB  8
02C44:  CLRF   x65
02C46:  MOVLW  5E
02C48:  MOVWF  x64
02C4A:  MOVLB  0
02C4C:  RCALL  2A28
02C4E:  MOVFF  03,410
02C52:  MOVFF  02,40F
02C56:  MOVFF  01,40E
02C5A:  MOVFF  00,40D
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02C5E:  MOVLB  8
02C60:  CLRF   x65
02C62:  MOVLW  62
02C64:  MOVWF  x64
02C66:  MOVLB  0
02C68:  RCALL  2A28
02C6A:  MOVFF  03,414
02C6E:  MOVFF  02,413
02C72:  MOVFF  01,412
02C76:  MOVFF  00,411
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02C7A:  MOVLW  20
02C7C:  MOVLB  8
02C7E:  MOVWF  x72
02C80:  MOVLB  0
02C82:  RCALL  29A8
02C84:  MOVFF  02,2A
02C88:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02C8C:  MOVLW  22
02C8E:  MOVLB  8
02C90:  MOVWF  x72
02C92:  MOVLB  0
02C94:  RCALL  29A8
02C96:  MOVFF  02,2C
02C9A:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02C9E:  MOVLW  24
02CA0:  MOVLB  8
02CA2:  MOVWF  x72
02CA4:  MOVLB  0
02CA6:  RCALL  29A8
02CA8:  MOVFF  02,2E
02CAC:  MOVFF  01,2D
02CB0:  GOTO   14B72 (RETURN)
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
....................    write16(ADDR_SAMPLE,0); 
....................    write16(ADDR_INTERVAL,60); 
....................    write16(ADDR_SERIALNO,9999); 
....................    write16(ADDR_MAX_SAMPLES,3360); 
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
....................    write16(ADDR_MACRO_STEP, 0); 
....................    write16(ADDR_COM_ERR,3); 
....................     
....................    write8(ADDR_ALARM_YR,10);  
....................     
....................    write_float(ADDR_CAL_M1,1); 
....................    write_float(ADDR_CAL_C1,0); 
....................    write_float(ADDR_CAL_M2,1); 
....................    write_float(ADDR_CAL_C2,0); 
....................    write_float(ADDR_CAL_M3,1); 
....................    write_float(ADDR_CAL_C3,0); 
....................    write_float(ADDR_CAL_M4,1); 
....................    write_float(ADDR_CAL_C4,0);  
....................     
....................    write16(ADDR_D1_TEMP,20000); 
....................    write16(ADDR_D2_TEMP,20000); 
....................     
....................    write16(ADDR_MACRO_MODE,0); 
....................    write16(ADDR_VOLUME,22500);  
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
....................    else write16(ADDR_PORT,1); 
....................     
....................    write16(ADDR_DET_TYPE,1); 
....................     
....................    init_nv_vars(); 
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
0ECAE:  MOVLW  02
0ECB0:  MOVWF  FEA
0ECB2:  MOVLW  47
0ECB4:  MOVWF  FE9
0ECB6:  CLRF   00
0ECB8:  CLRF   02
0ECBA:  MOVLW  51
0ECBC:  MOVWF  01
0ECBE:  CALL   350A
0ECC2:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F22A:  MOVLW  03
0F22C:  MOVWF  FEA
0F22E:  MOVLW  25
0F230:  MOVWF  FE9
0F232:  CLRF   00
0F234:  CLRF   02
0F236:  MOVLW  14
0F238:  MOVWF  01
0F23A:  CALL   350A
0F23E:  GOTO   F25E (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
0FDCE:  MOVLB  8
0FDD0:  CLRF   xB2
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
0FDD2:  CLRF   FEA
0FDD4:  MOVLW  52
0FDD6:  MOVWF  FE9
0FDD8:  CLRF   00
0FDDA:  CLRF   02
0FDDC:  MOVLW  14
0FDDE:  MOVWF  01
0FDE0:  MOVLB  0
0FDE2:  CALL   350A
....................  
....................    for(n=0; n<20; n++) { 
0FDE6:  MOVLB  8
0FDE8:  CLRF   xB3
0FDEA:  MOVF   xB3,W
0FDEC:  SUBLW  13
0FDEE:  BNC   FE34
....................         c = data_buffer[string_pos];  
0FDF0:  CLRF   03
0FDF2:  MOVLB  2
0FDF4:  MOVF   x98,W
0FDF6:  ADDLW  67
0FDF8:  MOVWF  FE9
0FDFA:  MOVLW  00
0FDFC:  ADDWFC 03,W
0FDFE:  MOVWF  FEA
0FE00:  MOVFF  FEF,8B2
....................         ++string_pos; 
0FE04:  INCF   x98,F
....................         if (c == '\0') return(1); // found end 
0FE06:  MOVLB  8
0FE08:  MOVF   xB2,F
0FE0A:  BNZ   FE12
0FE0C:  MOVLW  01
0FE0E:  MOVWF  01
0FE10:  BRA    FE38
....................         if (c == ',')  return(0); // found seperator  
0FE12:  MOVF   xB2,W
0FE14:  SUBLW  2C
0FE16:  BNZ   FE1E
0FE18:  MOVLW  00
0FE1A:  MOVWF  01
0FE1C:  BRA    FE38
....................         sub_string[n] = c; 
0FE1E:  CLRF   03
0FE20:  MOVF   xB3,W
0FE22:  ADDLW  52
0FE24:  MOVWF  FE9
0FE26:  MOVLW  00
0FE28:  ADDWFC 03,W
0FE2A:  MOVWF  FEA
0FE2C:  MOVFF  8B2,FEF
0FE30:  INCF   xB3,F
0FE32:  BRA    FDEA
....................    } 
....................     
....................    return(2); // failed = bad string 
0FE34:  MOVLW  02
0FE36:  MOVWF  01
0FE38:  MOVLB  0
0FE3A:  GOTO   FF80 (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
0FE94:  MOVLW  64
0FE96:  MOVWF  FF6
0FE98:  MOVLW  1C
0FE9A:  MOVWF  FF7
0FE9C:  MOVLW  00
0FE9E:  MOVWF  FF8
0FEA0:  MOVLW  03
0FEA2:  MOVWF  FEA
0FEA4:  MOVLW  3D
0FEA6:  MOVWF  FE9
0FEA8:  CALL   BF74
0FEAC:  MOVF   01,W
0FEAE:  BZ    FEC2
0FEB0:  XORLW  01
0FEB2:  BZ    FEE2
0FEB4:  XORLW  03
0FEB6:  BZ    FF02
0FEB8:  XORLW  01
0FEBA:  BZ    FF22
0FEBC:  XORLW  07
0FEBE:  BZ    FF42
0FEC0:  BRA    FF60
....................       case "NO3" : NO3_array[read_i] = result; 
0FEC2:  BCF    FD8.0
0FEC4:  MOVLB  3
0FEC6:  RLCF   x4A,W
0FEC8:  CLRF   03
0FECA:  ADDLW  4B
0FECC:  MOVWF  FE9
0FECE:  MOVLW  03
0FED0:  ADDWFC 03,W
0FED2:  MOVWF  FEA
0FED4:  MOVFF  8B3,FEC
0FED8:  MOVF   FED,F
0FEDA:  MOVFF  8B2,FEF
....................          break; 
0FEDE:  MOVLB  0
0FEE0:  BRA    FF60
....................       case "NO2" : NO2_array[read_i] = result; 
0FEE2:  BCF    FD8.0
0FEE4:  MOVLB  3
0FEE6:  RLCF   x4A,W
0FEE8:  CLRF   03
0FEEA:  ADDLW  5D
0FEEC:  MOVWF  FE9
0FEEE:  MOVLW  03
0FEF0:  ADDWFC 03,W
0FEF2:  MOVWF  FEA
0FEF4:  MOVFF  8B3,FEC
0FEF8:  MOVF   FED,F
0FEFA:  MOVFF  8B2,FEF
....................          break;    
0FEFE:  MOVLB  0
0FF00:  BRA    FF60
....................       case "PO4" : PO4_array[read_i] = result; 
0FF02:  BCF    FD8.0
0FF04:  MOVLB  3
0FF06:  RLCF   x4A,W
0FF08:  CLRF   03
0FF0A:  ADDLW  6F
0FF0C:  MOVWF  FE9
0FF0E:  MOVLW  03
0FF10:  ADDWFC 03,W
0FF12:  MOVWF  FEA
0FF14:  MOVFF  8B3,FEC
0FF18:  MOVF   FED,F
0FF1A:  MOVFF  8B2,FEF
....................          break; 
0FF1E:  MOVLB  0
0FF20:  BRA    FF60
....................       case "NH4" : NH4_array[read_i] = result; 
0FF22:  BCF    FD8.0
0FF24:  MOVLB  3
0FF26:  RLCF   x4A,W
0FF28:  CLRF   03
0FF2A:  ADDLW  81
0FF2C:  MOVWF  FE9
0FF2E:  MOVLW  03
0FF30:  ADDWFC 03,W
0FF32:  MOVWF  FEA
0FF34:  MOVFF  8B3,FEC
0FF38:  MOVF   FED,F
0FF3A:  MOVFF  8B2,FEF
....................          break; 
0FF3E:  MOVLB  0
0FF40:  BRA    FF60
....................       case "SiO" : SiO_array[read_i] = result; 
0FF42:  BCF    FD8.0
0FF44:  MOVLB  3
0FF46:  RLCF   x4A,W
0FF48:  CLRF   03
0FF4A:  ADDLW  93
0FF4C:  MOVWF  FE9
0FF4E:  MOVLW  03
0FF50:  ADDWFC 03,W
0FF52:  MOVWF  FEA
0FF54:  MOVFF  8B3,FEC
0FF58:  MOVF   FED,F
0FF5A:  MOVFF  8B2,FEF
....................          break; 
0FF5E:  MOVLB  0
....................    } 
0FF60:  GOTO   FFD8 (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
0FF64:  MOVLB  8
0FF66:  CLRF   xAD
0FF68:  CLRF   xAC
0FF6A:  CLRF   xAF
0FF6C:  CLRF   xAE
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
0FF6E:  MOVLB  2
0FF70:  CLRF   x98
....................     
....................    for (n=0; n<11; ++n){ 
0FF72:  MOVLB  8
0FF74:  CLRF   xB0
0FF76:  MOVF   xB0,W
0FF78:  SUBLW  0A
0FF7A:  BNC   FFCC
....................       parsed = parse_string(); 
0FF7C:  MOVLB  0
0FF7E:  BRA    FDCE
0FF80:  MOVFF  01,8B1
....................       if (parsed == 2) return(0); 
0FF84:  MOVLB  8
0FF86:  MOVF   xB1,W
0FF88:  SUBLW  02
0FF8A:  BNZ   FF94
0FF8C:  MOVLW  00
0FF8E:  MOVWF  01
0FF90:  MOVWF  02
0FF92:  BRA    FFE2
....................       if (n==8) result = atol(sub_string); 
0FF94:  MOVF   xB0,W
0FF96:  SUBLW  08
0FF98:  BNZ   FFAE
0FF9A:  CLRF   xB3
0FF9C:  MOVLW  52
0FF9E:  MOVWF  xB2
0FFA0:  MOVLB  0
0FFA2:  RCALL  10000
0FFA4:  MOVFF  02,8AD
0FFA8:  MOVFF  01,8AC
0FFAC:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
0FFAE:  MOVF   xB0,W
0FFB0:  SUBLW  0A
0FFB2:  BNZ   FFC8
0FFB4:  CLRF   xB3
0FFB6:  MOVLW  52
0FFB8:  MOVWF  xB2
0FFBA:  MOVLB  0
0FFBC:  RCALL  10000
0FFBE:  MOVFF  02,8AF
0FFC2:  MOVFF  01,8AE
0FFC6:  MOVLB  8
0FFC8:  INCF   xB0,F
0FFCA:  BRA    FF76
....................    } 
....................    load_parsed_data(result); 
0FFCC:  MOVFF  8AD,8B3
0FFD0:  MOVFF  8AC,8B2
0FFD4:  MOVLB  0
0FFD6:  BRA    FE94
....................    return (temp); 
0FFD8:  MOVLB  8
0FFDA:  MOVFF  8AE,01
0FFDE:  MOVFF  8AF,02
0FFE2:  MOVLB  0
0FFE4:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0E3DE:  CLRF   FEA
0E3E0:  MOVLW  67
0E3E2:  MOVWF  FE9
0E3E4:  CLRF   00
0E3E6:  CLRF   02
0E3E8:  MOVLW  A0
0E3EA:  MOVWF  01
0E3EC:  CALL   350A
0E3F0:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F242:  MOVLW  03
0F244:  MOVWF  FEA
0F246:  MOVLW  3D
0F248:  MOVWF  FE9
0F24A:  MOVLW  00
0F24C:  CALL   02E4
0F250:  TBLRD*-
0F252:  TBLRD*+
0F254:  MOVF   FF5,W
0F256:  MOVWF  FEE
0F258:  IORLW  00
0F25A:  BNZ   F252
....................  
....................    clear_flag_str(); 
0F25C:  BRA    F22A
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F25E:  MOVLW  08
0F260:  MOVWF  1E
0F262:  MOVLW  CB
0F264:  MOVWF  1D
0F266:  MOVLW  10
0F268:  MOVWF  FE9
0F26A:  MOVFF  324,8D5
0F26E:  MOVFF  323,8D4
0F272:  CALL   AA9E
....................  
....................    if (macro_flag < 100) { 
0F276:  MOVLB  3
0F278:  MOVF   x24,F
0F27A:  BNZ   F294
0F27C:  MOVF   x23,W
0F27E:  SUBLW  63
0F280:  BNC   F294
....................       temp_str[3] = '\0'; 
0F282:  MOVLB  8
0F284:  CLRF   xCE
....................       temp_str[2] = temp_str[1]; 
0F286:  MOVFF  8CC,8CD
....................       temp_str[1] = temp_str[0]; 
0F28A:  MOVFF  8CB,8CC
....................       temp_str[0] = '0'; 
0F28E:  MOVLW  30
0F290:  MOVWF  xCB
0F292:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F294:  MOVLB  8
0F296:  MOVF   xCB,W
0F298:  XORLW  30
0F29A:  MOVLB  0
0F29C:  BZ    F2C0
0F29E:  XORLW  01
0F2A0:  BZ    F2E6
0F2A2:  XORLW  03
0F2A4:  BZ    F30C
0F2A6:  XORLW  01
0F2A8:  BZ    F332
0F2AA:  XORLW  07
0F2AC:  BZ    F358
0F2AE:  XORLW  01
0F2B0:  BZ    F37E
0F2B2:  XORLW  03
0F2B4:  BTFSC  FD8.2
0F2B6:  BRA    F3A4
0F2B8:  XORLW  01
0F2BA:  BTFSC  FD8.2
0F2BC:  BRA    F3CA
0F2BE:  BRA    F3F2
....................       case '0' : strcopy(chem,"NO3"); 
0F2C0:  MOVLW  03
0F2C2:  MOVWF  FEA
0F2C4:  MOVLW  3D
0F2C6:  MOVWF  FE9
0F2C8:  MOVLW  00
0F2CA:  CALL   02FC
0F2CE:  TBLRD*-
0F2D0:  TBLRD*+
0F2D2:  MOVF   FF5,W
0F2D4:  MOVWF  FEE
0F2D6:  IORLW  00
0F2D8:  BNZ   F2D0
....................                  wave_l=543; 
0F2DA:  MOVLW  02
0F2DC:  MOVLB  8
0F2DE:  MOVWF  xCA
0F2E0:  MOVLW  1F
0F2E2:  MOVWF  xC9
....................          break; 
0F2E4:  BRA    F416
....................       case '1' : strcopy(chem,"PO4"); 
0F2E6:  MOVLW  03
0F2E8:  MOVWF  FEA
0F2EA:  MOVLW  3D
0F2EC:  MOVWF  FE9
0F2EE:  MOVLW  00
0F2F0:  CALL   0314
0F2F4:  TBLRD*-
0F2F6:  TBLRD*+
0F2F8:  MOVF   FF5,W
0F2FA:  MOVWF  FEE
0F2FC:  IORLW  00
0F2FE:  BNZ   F2F6
....................                  wave_l=880;       
0F300:  MOVLW  03
0F302:  MOVLB  8
0F304:  MOVWF  xCA
0F306:  MOVLW  70
0F308:  MOVWF  xC9
....................          break; 
0F30A:  BRA    F416
....................       case '2' : strcopy(chem,"NH4"); 
0F30C:  MOVLW  03
0F30E:  MOVWF  FEA
0F310:  MOVLW  3D
0F312:  MOVWF  FE9
0F314:  MOVLW  00
0F316:  CALL   032C
0F31A:  TBLRD*-
0F31C:  TBLRD*+
0F31E:  MOVF   FF5,W
0F320:  MOVWF  FEE
0F322:  IORLW  00
0F324:  BNZ   F31C
....................                  wave_l=660;       
0F326:  MOVLW  02
0F328:  MOVLB  8
0F32A:  MOVWF  xCA
0F32C:  MOVLW  94
0F32E:  MOVWF  xC9
....................          break; 
0F330:  BRA    F416
....................       case '3' : strcopy(chem,"SiO"); 
0F332:  MOVLW  03
0F334:  MOVWF  FEA
0F336:  MOVLW  3D
0F338:  MOVWF  FE9
0F33A:  MOVLW  00
0F33C:  CALL   0344
0F340:  TBLRD*-
0F342:  TBLRD*+
0F344:  MOVF   FF5,W
0F346:  MOVWF  FEE
0F348:  IORLW  00
0F34A:  BNZ   F342
....................                  wave_l=810;       
0F34C:  MOVLW  03
0F34E:  MOVLB  8
0F350:  MOVWF  xCA
0F352:  MOVLW  2A
0F354:  MOVWF  xC9
....................          break; 
0F356:  BRA    F416
....................       case '4' : strcopy(chem,"Ure"); 
0F358:  MOVLW  03
0F35A:  MOVWF  FEA
0F35C:  MOVLW  3D
0F35E:  MOVWF  FE9
0F360:  MOVLW  00
0F362:  CALL   035C
0F366:  TBLRD*-
0F368:  TBLRD*+
0F36A:  MOVF   FF5,W
0F36C:  MOVWF  FEE
0F36E:  IORLW  00
0F370:  BNZ   F368
....................                  wave_l=525;       
0F372:  MOVLW  02
0F374:  MOVLB  8
0F376:  MOVWF  xCA
0F378:  MOVLW  0D
0F37A:  MOVWF  xC9
....................          break; 
0F37C:  BRA    F416
....................       case '5' : strcopy(chem,"NO2"); 
0F37E:  MOVLW  03
0F380:  MOVWF  FEA
0F382:  MOVLW  3D
0F384:  MOVWF  FE9
0F386:  MOVLW  00
0F388:  CALL   0374
0F38C:  TBLRD*-
0F38E:  TBLRD*+
0F390:  MOVF   FF5,W
0F392:  MOVWF  FEE
0F394:  IORLW  00
0F396:  BNZ   F38E
....................                  wave_l=543;       
0F398:  MOVLW  02
0F39A:  MOVLB  8
0F39C:  MOVWF  xCA
0F39E:  MOVLW  1F
0F3A0:  MOVWF  xC9
....................          break; 
0F3A2:  BRA    F416
....................       case '6' : strcopy(chem,"Fe_"); 
0F3A4:  MOVLW  03
0F3A6:  MOVWF  FEA
0F3A8:  MOVLW  3D
0F3AA:  MOVWF  FE9
0F3AC:  MOVLW  00
0F3AE:  CALL   038C
0F3B2:  TBLRD*-
0F3B4:  TBLRD*+
0F3B6:  MOVF   FF5,W
0F3B8:  MOVWF  FEE
0F3BA:  IORLW  00
0F3BC:  BNZ   F3B4
....................                  wave_l=543;       
0F3BE:  MOVLW  02
0F3C0:  MOVLB  8
0F3C2:  MOVWF  xCA
0F3C4:  MOVLW  1F
0F3C6:  MOVWF  xC9
....................          break; 
0F3C8:  BRA    F416
....................       case '7' : strcopy(chem,"Cl_"); 
0F3CA:  MOVLW  03
0F3CC:  MOVWF  FEA
0F3CE:  MOVLW  3D
0F3D0:  MOVWF  FE9
0F3D2:  MOVLW  00
0F3D4:  CALL   03A4
0F3D8:  TBLRD*-
0F3DA:  TBLRD*+
0F3DC:  MOVF   FF5,W
0F3DE:  MOVWF  FEE
0F3E0:  IORLW  00
0F3E2:  BNZ   F3DA
....................                  wave_l=560;       
0F3E4:  MOVLW  02
0F3E6:  MOVLB  8
0F3E8:  MOVWF  xCA
0F3EA:  MOVLW  30
0F3EC:  MOVWF  xC9
....................          break; 
0F3EE:  BRA    F416
0F3F0:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0F3F2:  MOVLW  03
0F3F4:  MOVWF  FEA
0F3F6:  MOVLW  3D
0F3F8:  MOVWF  FE9
0F3FA:  MOVLW  00
0F3FC:  CALL   02E4
0F400:  TBLRD*-
0F402:  TBLRD*+
0F404:  MOVF   FF5,W
0F406:  MOVWF  FEE
0F408:  IORLW  00
0F40A:  BNZ   F402
....................                  wave_l=999;       
0F40C:  MOVLW  03
0F40E:  MOVLB  8
0F410:  MOVWF  xCA
0F412:  MOVLW  E7
0F414:  MOVWF  xC9
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0F416:  MOVF   xCC,W
0F418:  XORLW  31
0F41A:  MOVLB  0
0F41C:  BZ    F43C
0F41E:  XORLW  03
0F420:  BZ    F458
0F422:  XORLW  01
0F424:  BZ    F474
0F426:  XORLW  07
0F428:  BZ    F490
0F42A:  XORLW  01
0F42C:  BZ    F4AC
0F42E:  XORLW  03
0F430:  BZ    F4C8
0F432:  XORLW  01
0F434:  BZ    F4E4
0F436:  XORLW  0F
0F438:  BZ    F500
0F43A:  BRA    F51C
....................       case '1' : strcopy(anal,"Smp"); 
0F43C:  MOVLW  03
0F43E:  MOVWF  FEA
0F440:  MOVLW  42
0F442:  MOVWF  FE9
0F444:  MOVLW  00
0F446:  CALL   03BC
0F44A:  TBLRD*-
0F44C:  TBLRD*+
0F44E:  MOVF   FF5,W
0F450:  MOVWF  FEE
0F452:  IORLW  00
0F454:  BNZ   F44C
....................          break; 
0F456:  BRA    F536
....................       case '2' : strcopy(anal,"Std"); 
0F458:  MOVLW  03
0F45A:  MOVWF  FEA
0F45C:  MOVLW  42
0F45E:  MOVWF  FE9
0F460:  MOVLW  00
0F462:  CALL   03D4
0F466:  TBLRD*-
0F468:  TBLRD*+
0F46A:  MOVF   FF5,W
0F46C:  MOVWF  FEE
0F46E:  IORLW  00
0F470:  BNZ   F468
....................          break; 
0F472:  BRA    F536
....................       case '3' : strcopy(anal,"Cmb"); 
0F474:  MOVLW  03
0F476:  MOVWF  FEA
0F478:  MOVLW  42
0F47A:  MOVWF  FE9
0F47C:  MOVLW  00
0F47E:  CALL   03EC
0F482:  TBLRD*-
0F484:  TBLRD*+
0F486:  MOVF   FF5,W
0F488:  MOVWF  FEE
0F48A:  IORLW  00
0F48C:  BNZ   F484
....................          break; 
0F48E:  BRA    F536
....................       case '4' : strcopy(anal,"Tst"); 
0F490:  MOVLW  03
0F492:  MOVWF  FEA
0F494:  MOVLW  42
0F496:  MOVWF  FE9
0F498:  MOVLW  00
0F49A:  CALL   0404
0F49E:  TBLRD*-
0F4A0:  TBLRD*+
0F4A2:  MOVF   FF5,W
0F4A4:  MOVWF  FEE
0F4A6:  IORLW  00
0F4A8:  BNZ   F4A0
....................          break; 
0F4AA:  BRA    F536
....................       case '5' : strcopy(anal,"Rbl"); 
0F4AC:  MOVLW  03
0F4AE:  MOVWF  FEA
0F4B0:  MOVLW  42
0F4B2:  MOVWF  FE9
0F4B4:  MOVLW  00
0F4B6:  CALL   041C
0F4BA:  TBLRD*-
0F4BC:  TBLRD*+
0F4BE:  MOVF   FF5,W
0F4C0:  MOVWF  FEE
0F4C2:  IORLW  00
0F4C4:  BNZ   F4BC
....................          break; 
0F4C6:  BRA    F536
....................       case '6' : strcopy(anal,"Cal"); 
0F4C8:  MOVLW  03
0F4CA:  MOVWF  FEA
0F4CC:  MOVLW  42
0F4CE:  MOVWF  FE9
0F4D0:  MOVLW  00
0F4D2:  CALL   0434
0F4D6:  TBLRD*-
0F4D8:  TBLRD*+
0F4DA:  MOVF   FF5,W
0F4DC:  MOVWF  FEE
0F4DE:  IORLW  00
0F4E0:  BNZ   F4D8
....................          break; 
0F4E2:  BRA    F536
....................       case '7' : strcopy(anal,"Fls"); 
0F4E4:  MOVLW  03
0F4E6:  MOVWF  FEA
0F4E8:  MOVLW  42
0F4EA:  MOVWF  FE9
0F4EC:  MOVLW  00
0F4EE:  CALL   044C
0F4F2:  TBLRD*-
0F4F4:  TBLRD*+
0F4F6:  MOVF   FF5,W
0F4F8:  MOVWF  FEE
0F4FA:  IORLW  00
0F4FC:  BNZ   F4F4
....................          break; 
0F4FE:  BRA    F536
....................       case '8' : strcopy(anal,"Utl"); 
0F500:  MOVLW  03
0F502:  MOVWF  FEA
0F504:  MOVLW  42
0F506:  MOVWF  FE9
0F508:  MOVLW  00
0F50A:  CALL   0464
0F50E:  TBLRD*-
0F510:  TBLRD*+
0F512:  MOVF   FF5,W
0F514:  MOVWF  FEE
0F516:  IORLW  00
0F518:  BNZ   F510
....................          break;     
0F51A:  BRA    F536
....................       default  : strcopy(anal,"XXX"); 
0F51C:  MOVLW  03
0F51E:  MOVWF  FEA
0F520:  MOVLW  42
0F522:  MOVWF  FE9
0F524:  MOVLW  00
0F526:  CALL   02E4
0F52A:  TBLRD*-
0F52C:  TBLRD*+
0F52E:  MOVF   FF5,W
0F530:  MOVWF  FEE
0F532:  IORLW  00
0F534:  BNZ   F52C
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0F536:  MOVLB  8
0F538:  MOVF   xCD,W
0F53A:  XORLW  31
0F53C:  MOVLB  0
0F53E:  BZ    F568
0F540:  XORLW  03
0F542:  BZ    F588
0F544:  XORLW  01
0F546:  BZ    F5AA
0F548:  XORLW  07
0F54A:  BZ    F5CC
0F54C:  XORLW  01
0F54E:  BZ    F5EE
0F550:  XORLW  03
0F552:  BZ    F610
0F554:  XORLW  01
0F556:  BTFSC  FD8.2
0F558:  BRA    F632
0F55A:  XORLW  0F
0F55C:  BTFSC  FD8.2
0F55E:  BRA    F654
0F560:  XORLW  01
0F562:  BTFSC  FD8.2
0F564:  BRA    F676
0F566:  BRA    F69A
....................       case '1' : strcopy(read_t,"I0s"); 
0F568:  MOVLW  03
0F56A:  MOVWF  FEA
0F56C:  MOVLW  46
0F56E:  MOVWF  FE9
0F570:  MOVLW  00
0F572:  CALL   047C
0F576:  TBLRD*-
0F578:  TBLRD*+
0F57A:  MOVF   FF5,W
0F57C:  MOVWF  FEE
0F57E:  IORLW  00
0F580:  BNZ   F578
....................                  read_i = 0; 
0F582:  MOVLB  3
0F584:  CLRF   x4A
....................          break; 
0F586:  BRA    F6B8
....................       case '2' : strcopy(read_t,"I1s"); 
0F588:  MOVLW  03
0F58A:  MOVWF  FEA
0F58C:  MOVLW  46
0F58E:  MOVWF  FE9
0F590:  MOVLW  00
0F592:  CALL   0494
0F596:  TBLRD*-
0F598:  TBLRD*+
0F59A:  MOVF   FF5,W
0F59C:  MOVWF  FEE
0F59E:  IORLW  00
0F5A0:  BNZ   F598
....................                  read_i = 1;       
0F5A2:  MOVLW  01
0F5A4:  MOVLB  3
0F5A6:  MOVWF  x4A
....................          break; 
0F5A8:  BRA    F6B8
....................       case '3' : strcopy(read_t,"I0t"); 
0F5AA:  MOVLW  03
0F5AC:  MOVWF  FEA
0F5AE:  MOVLW  46
0F5B0:  MOVWF  FE9
0F5B2:  MOVLW  00
0F5B4:  CALL   04AC
0F5B8:  TBLRD*-
0F5BA:  TBLRD*+
0F5BC:  MOVF   FF5,W
0F5BE:  MOVWF  FEE
0F5C0:  IORLW  00
0F5C2:  BNZ   F5BA
....................                  read_i = 2;       
0F5C4:  MOVLW  02
0F5C6:  MOVLB  3
0F5C8:  MOVWF  x4A
....................          break; 
0F5CA:  BRA    F6B8
....................       case '4' : strcopy(read_t,"I1t"); 
0F5CC:  MOVLW  03
0F5CE:  MOVWF  FEA
0F5D0:  MOVLW  46
0F5D2:  MOVWF  FE9
0F5D4:  MOVLW  00
0F5D6:  CALL   04C4
0F5DA:  TBLRD*-
0F5DC:  TBLRD*+
0F5DE:  MOVF   FF5,W
0F5E0:  MOVWF  FEE
0F5E2:  IORLW  00
0F5E4:  BNZ   F5DC
....................                  read_i = 3;       
0F5E6:  MOVLW  03
0F5E8:  MOVLB  3
0F5EA:  MOVWF  x4A
....................          break; 
0F5EC:  BRA    F6B8
....................       case '5' : strcopy(read_t,"I0r"); 
0F5EE:  MOVLW  03
0F5F0:  MOVWF  FEA
0F5F2:  MOVLW  46
0F5F4:  MOVWF  FE9
0F5F6:  MOVLW  00
0F5F8:  CALL   04DC
0F5FC:  TBLRD*-
0F5FE:  TBLRD*+
0F600:  MOVF   FF5,W
0F602:  MOVWF  FEE
0F604:  IORLW  00
0F606:  BNZ   F5FE
....................                  read_i = 4;       
0F608:  MOVLW  04
0F60A:  MOVLB  3
0F60C:  MOVWF  x4A
....................          break; 
0F60E:  BRA    F6B8
....................       case '6' : strcopy(read_t,"I1r"); 
0F610:  MOVLW  03
0F612:  MOVWF  FEA
0F614:  MOVLW  46
0F616:  MOVWF  FE9
0F618:  MOVLW  00
0F61A:  CALL   04F4
0F61E:  TBLRD*-
0F620:  TBLRD*+
0F622:  MOVF   FF5,W
0F624:  MOVWF  FEE
0F626:  IORLW  00
0F628:  BNZ   F620
....................                  read_i = 5;       
0F62A:  MOVLW  05
0F62C:  MOVLB  3
0F62E:  MOVWF  x4A
....................          break; 
0F630:  BRA    F6B8
....................       case '7' : strcopy(read_t,"I0u"); 
0F632:  MOVLW  03
0F634:  MOVWF  FEA
0F636:  MOVLW  46
0F638:  MOVWF  FE9
0F63A:  MOVLW  00
0F63C:  CALL   050C
0F640:  TBLRD*-
0F642:  TBLRD*+
0F644:  MOVF   FF5,W
0F646:  MOVWF  FEE
0F648:  IORLW  00
0F64A:  BNZ   F642
....................                  read_i = 6;       
0F64C:  MOVLW  06
0F64E:  MOVLB  3
0F650:  MOVWF  x4A
....................          break; 
0F652:  BRA    F6B8
....................       case '8' : strcopy(read_t,"I1u"); 
0F654:  MOVLW  03
0F656:  MOVWF  FEA
0F658:  MOVLW  46
0F65A:  MOVWF  FE9
0F65C:  MOVLW  00
0F65E:  CALL   0524
0F662:  TBLRD*-
0F664:  TBLRD*+
0F666:  MOVF   FF5,W
0F668:  MOVWF  FEE
0F66A:  IORLW  00
0F66C:  BNZ   F664
....................                  read_i = 7;       
0F66E:  MOVLW  07
0F670:  MOVLB  3
0F672:  MOVWF  x4A
....................          break; 
0F674:  BRA    F6B8
....................       case '9' : strcopy(read_t,"Chk"); 
0F676:  MOVLW  03
0F678:  MOVWF  FEA
0F67A:  MOVLW  46
0F67C:  MOVWF  FE9
0F67E:  MOVLW  00
0F680:  CALL   053C
0F684:  TBLRD*-
0F686:  TBLRD*+
0F688:  MOVF   FF5,W
0F68A:  MOVWF  FEE
0F68C:  IORLW  00
0F68E:  BNZ   F686
....................                  read_i = 8;       
0F690:  MOVLW  08
0F692:  MOVLB  3
0F694:  MOVWF  x4A
....................          break;        
0F696:  BRA    F6B8
0F698:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0F69A:  MOVLW  03
0F69C:  MOVWF  FEA
0F69E:  MOVLW  46
0F6A0:  MOVWF  FE9
0F6A2:  MOVLW  00
0F6A4:  CALL   0554
0F6A8:  TBLRD*-
0F6AA:  TBLRD*+
0F6AC:  MOVF   FF5,W
0F6AE:  MOVWF  FEE
0F6B0:  IORLW  00
0F6B2:  BNZ   F6AA
....................                  read_i = 0;       
0F6B4:  MOVLB  3
0F6B6:  CLRF   x4A
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0F6B8:  MOVLW  03
0F6BA:  MOVLB  8
0F6BC:  MOVWF  xD7
0F6BE:  MOVLW  25
0F6C0:  MOVWF  xD6
0F6C2:  MOVLW  03
0F6C4:  MOVWF  xD9
0F6C6:  MOVLW  3D
0F6C8:  MOVWF  xD8
0F6CA:  MOVLB  0
0F6CC:  CALL   54B8
....................    strcat(flag_str, (char *)","); 
0F6D0:  MOVLW  2C
0F6D2:  MOVLB  8
0F6D4:  MOVWF  xD2
0F6D6:  CLRF   xD3
0F6D8:  MOVLW  03
0F6DA:  MOVWF  xD7
0F6DC:  MOVLW  25
0F6DE:  MOVWF  xD6
0F6E0:  MOVLW  08
0F6E2:  MOVWF  xD9
0F6E4:  MOVLW  D2
0F6E6:  MOVWF  xD8
0F6E8:  MOVLB  0
0F6EA:  CALL   54B8
....................    strcat(flag_str, anal); 
0F6EE:  MOVLW  03
0F6F0:  MOVLB  8
0F6F2:  MOVWF  xD7
0F6F4:  MOVLW  25
0F6F6:  MOVWF  xD6
0F6F8:  MOVLW  03
0F6FA:  MOVWF  xD9
0F6FC:  MOVLW  42
0F6FE:  MOVWF  xD8
0F700:  MOVLB  0
0F702:  CALL   54B8
....................    strcat(flag_str, (char *)","); 
0F706:  MOVLW  2C
0F708:  MOVLB  8
0F70A:  MOVWF  xD2
0F70C:  CLRF   xD3
0F70E:  MOVLW  03
0F710:  MOVWF  xD7
0F712:  MOVLW  25
0F714:  MOVWF  xD6
0F716:  MOVLW  08
0F718:  MOVWF  xD9
0F71A:  MOVLW  D2
0F71C:  MOVWF  xD8
0F71E:  MOVLB  0
0F720:  CALL   54B8
....................    strcat(flag_str, read_t);   
0F724:  MOVLW  03
0F726:  MOVLB  8
0F728:  MOVWF  xD7
0F72A:  MOVLW  25
0F72C:  MOVWF  xD6
0F72E:  MOVLW  03
0F730:  MOVWF  xD9
0F732:  MOVLW  46
0F734:  MOVWF  xD8
0F736:  MOVLB  0
0F738:  CALL   54B8
....................     
....................    return wave_l; 
0F73C:  MOVLB  8
0F73E:  MOVFF  8C9,01
0F742:  MOVFF  8CA,02
0F746:  MOVLB  0
0F748:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0E6F0:  MOVF   47,W
0E6F2:  SUBLW  4B
0E6F4:  BTFSC  FD8.2
0E6F6:  MOVFF  48,2D6
....................    if (cmd=='L') detector_li = arg; 
0E6FA:  MOVF   47,W
0E6FC:  SUBLW  4C
0E6FE:  BNZ   E708
0E700:  MOVFF  49,2D8
0E704:  MOVFF  48,2D7
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0E708:  MOVF   1F,W
0E70A:  SUBLW  04
0E70C:  BNZ   E7D6
0E70E:  MOVF   20,F
0E710:  BNZ   E7D6
0E712:  MOVLW  7A
0E714:  MOVWF  FF6
0E716:  MOVLW  1C
0E718:  MOVWF  FF7
0E71A:  MOVLW  00
0E71C:  MOVWF  FF8
0E71E:  CLRF   1B
0E720:  BTFSC  FF2.7
0E722:  BSF    1B.7
0E724:  BCF    FF2.7
0E726:  MOVLW  06
0E728:  MOVLB  A
0E72A:  MOVWF  x19
0E72C:  MOVLB  0
0E72E:  CALL   104E
0E732:  BTFSC  1B.7
0E734:  BSF    FF2.7
0E736:  CLRF   1B
0E738:  BTFSC  FF2.7
0E73A:  BSF    1B.7
0E73C:  BCF    FF2.7
0E73E:  MOVFF  2D5,A19
0E742:  MOVLW  1B
0E744:  MOVLB  A
0E746:  MOVWF  x1A
0E748:  MOVLB  0
0E74A:  CALL   0FD0
0E74E:  BTFSC  1B.7
0E750:  BSF    FF2.7
0E752:  MOVLW  5D
0E754:  BTFSS  F9E.4
0E756:  BRA    E754
0E758:  MOVWF  FAD
0E75A:  MOVLW  5B
0E75C:  BTFSS  F9E.4
0E75E:  BRA    E75C
0E760:  MOVWF  FAD
0E762:  MOVF   47,W
0E764:  BTFSS  F9E.4
0E766:  BRA    E764
0E768:  MOVWF  FAD
0E76A:  MOVLW  86
0E76C:  MOVWF  FF6
0E76E:  MOVLW  1C
0E770:  MOVWF  FF7
0E772:  MOVLW  00
0E774:  MOVWF  FF8
0E776:  CLRF   1B
0E778:  BTFSC  FF2.7
0E77A:  BSF    1B.7
0E77C:  BCF    FF2.7
0E77E:  MOVLW  05
0E780:  MOVLB  A
0E782:  MOVWF  x19
0E784:  MOVLB  0
0E786:  CALL   104E
0E78A:  BTFSC  1B.7
0E78C:  BSF    FF2.7
0E78E:  MOVLW  41
0E790:  MOVWF  FE9
0E792:  CLRF   1B
0E794:  BTFSC  FF2.7
0E796:  BSF    1B.7
0E798:  BCF    FF2.7
0E79A:  MOVFF  4B,A1C
0E79E:  MOVFF  4A,A1B
0E7A2:  MOVFF  49,A1A
0E7A6:  MOVFF  48,A19
0E7AA:  CALL   1114
0E7AE:  BTFSC  1B.7
0E7B0:  BSF    FF2.7
0E7B2:  MOVLW  8E
0E7B4:  MOVWF  FF6
0E7B6:  MOVLW  1C
0E7B8:  MOVWF  FF7
0E7BA:  MOVLW  00
0E7BC:  MOVWF  FF8
0E7BE:  CLRF   1B
0E7C0:  BTFSC  FF2.7
0E7C2:  BSF    1B.7
0E7C4:  BCF    FF2.7
0E7C6:  MOVLW  03
0E7C8:  MOVLB  A
0E7CA:  MOVWF  x19
0E7CC:  MOVLB  0
0E7CE:  CALL   104E
0E7D2:  BTFSC  1B.7
0E7D4:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0E7D6:  RCALL  E536
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0E7D8:  MOVLW  2F
0E7DA:  BTFSS  FA4.4
0E7DC:  BRA    E7DA
0E7DE:  MOVLB  F
0E7E0:  MOVWF  x1C
0E7E2:  MOVFF  2D5,8D1
0E7E6:  MOVLW  1B
0E7E8:  MOVLB  8
0E7EA:  MOVWF  xD2
0E7EC:  MOVLB  0
0E7EE:  RCALL  E54A
0E7F0:  MOVF   47,W
0E7F2:  BTFSS  FA4.4
0E7F4:  BRA    E7F2
0E7F6:  MOVLB  F
0E7F8:  MOVWF  x1C
0E7FA:  MOVLW  41
0E7FC:  MOVWF  FE9
0E7FE:  MOVFF  4B,8D4
0E802:  MOVFF  4A,8D3
0E806:  MOVFF  49,8D2
0E80A:  MOVFF  48,8D1
0E80E:  MOVLB  0
0E810:  BRA    E5EE
0E812:  MOVLW  0D
0E814:  BTFSS  FA4.4
0E816:  BRA    E814
0E818:  MOVLB  F
0E81A:  MOVWF  x1C
0E81C:  MOVLW  0A
0E81E:  BTFSS  FA4.4
0E820:  BRA    E81E
0E822:  MOVWF  x1C
....................    multidrop_off(); 
0E824:  MOVLB  0
0E826:  RCALL  E6CE
0E828:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
0F826:  MOVLB  8
0F828:  CLRF   xCA
0F82A:  BCF    xCB.0
0F82C:  CLRF   xCC
0F82E:  CLRF   xD0
0F830:  CLRF   xCF
0F832:  CLRF   xCE
0F834:  CLRF   xCD
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
0F836:  MOVLW  02
0F838:  MOVWF  FEA
0F83A:  MOVLW  47
0F83C:  MOVWF  FE9
0F83E:  CLRF   00
0F840:  CLRF   02
0F842:  MOVLW  51
0F844:  MOVWF  01
0F846:  MOVLB  0
0F848:  CALL   350A
....................  
....................    det_cmd(); 
0F84C:  CALL   E6F0
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
0F850:  CALL   552A
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
0F854:  MOVLB  8
0F856:  MOVF   xCC,W
0F858:  SUBLW  02
0F85A:  BZ    F8EE
0F85C:  MOVF   xCC,W
0F85E:  SUBLW  03
0F860:  BZ    F8EE
0F862:  MOVF   xCA,W
0F864:  SUBLW  50
0F866:  BNC   F8EE
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
0F868:  BTFSS  FA4.5
0F86A:  BRA    F8A2
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
0F86C:  MOVLB  0
0F86E:  BRA    F80A
0F870:  MOVFF  01,8C9
....................  
....................          if(startCharacterRcvd) 
0F874:  MOVLB  8
0F876:  BTFSS  xCB.0
0F878:  BRA    F89A
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
0F87A:  MOVF   xCA,W
0F87C:  INCF   xCA,F
0F87E:  CLRF   03
0F880:  ADDLW  47
0F882:  MOVWF  FE9
0F884:  MOVLW  02
0F886:  ADDWFC 03,W
0F888:  MOVWF  FEA
0F88A:  MOVFF  8C9,FEF
....................             if (CARRIAGE_RET == c) 
0F88E:  MOVF   xC9,W
0F890:  SUBLW  0D
0F892:  BNZ   F898
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
0F894:  MOVLW  02
0F896:  MOVWF  xCC
....................             } 
....................          } 
0F898:  BRA    F8A2
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
0F89A:  MOVF   xC9,W
0F89C:  SUBLW  40
0F89E:  BNZ   F8A2
....................             { 
....................                startCharacterRcvd = TRUE; 
0F8A0:  BSF    xCB.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
0F8A2:  MOVLW  35
0F8A4:  MOVWF  00
0F8A6:  DECFSZ 00,F
0F8A8:  BRA    F8A6
....................       if (tenMicroSecDelayCounter++ > 500000) 
0F8AA:  MOVFF  8D0,8D4
0F8AE:  MOVFF  8CF,8D3
0F8B2:  MOVFF  8CE,8D2
0F8B6:  MOVFF  8CD,8D1
0F8BA:  MOVLW  01
0F8BC:  ADDWF  xCD,F
0F8BE:  BTFSC  FD8.0
0F8C0:  INCF   xCE,F
0F8C2:  BTFSC  FD8.2
0F8C4:  INCF   xCF,F
0F8C6:  BTFSC  FD8.2
0F8C8:  INCF   xD0,F
0F8CA:  MOVF   xD4,F
0F8CC:  BNZ   F8E8
0F8CE:  MOVF   xD3,W
0F8D0:  SUBLW  06
0F8D2:  BC    F8EC
0F8D4:  XORLW  FF
0F8D6:  BNZ   F8E8
0F8D8:  MOVF   xD2,W
0F8DA:  SUBLW  A0
0F8DC:  BC    F8EC
0F8DE:  XORLW  FF
0F8E0:  BNZ   F8E8
0F8E2:  MOVF   xD1,W
0F8E4:  SUBLW  20
0F8E6:  BC    F8EC
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
0F8E8:  MOVLW  03
0F8EA:  MOVWF  xCC
....................       } 
0F8EC:  BRA    F856
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
0F8EE:  MOVF   xCA,W
0F8F0:  SUBLW  50
0F8F2:  BC    F904
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
0F8F4:  MOVF   xCC,W
0F8F6:  SUBLW  03
0F8F8:  BZ    F904
0F8FA:  MOVF   xCC,W
0F8FC:  SUBLW  02
0F8FE:  BZ    F904
....................       { 
....................          rcvDataType = SOME_DATA; 
0F900:  MOVLW  01
0F902:  MOVWF  xCC
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
0F904:  MOVLB  0
0F906:  CALL   554A
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
0F90A:  MOVLB  8
0F90C:  MOVFF  8CC,01
0F910:  MOVLB  0
0F912:  GOTO   FB56 (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
0F93C:  MOVF   1F,F
0F93E:  BNZ   F95E
0F940:  MOVF   20,F
0F942:  BNZ   F95E
0F944:  MOVLB  8
0F946:  DECFSZ xCA,W
0F948:  BRA    F94C
0F94A:  BRA    F950
0F94C:  MOVLB  0
0F94E:  BRA    F95E
0F950:  CLRF   FEA
0F952:  MOVLW  67
0F954:  MOVWF  FE9
0F956:  MOVLB  0
0F958:  CALL   793C
0F95C:  BRA    F972
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
0F95E:  MOVF   20,F
0F960:  BNZ   F968
0F962:  MOVF   1F,W
0F964:  SUBLW  03
0F966:  BC    F972
0F968:  CLRF   FEA
0F96A:  MOVLW  67
0F96C:  MOVWF  FE9
0F96E:  CALL   793C
....................  
....................    if (store==TRUE && sd_status==0) { 
0F972:  MOVLB  8
0F974:  DECFSZ xC9,W
0F976:  BRA    F9D6
0F978:  MOVLB  2
0F97A:  MOVF   xDC,F
0F97C:  BTFSC  FD8.2
0F97E:  BRA    F984
0F980:  MOVLB  8
0F982:  BRA    F9D6
....................        
....................       buffer_select = 0; 
0F984:  MOVLB  0
0F986:  CLRF   x66
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0F988:  MOVLB  8
0F98A:  CLRF   xCB
0F98C:  MOVLB  0
0F98E:  CALL   555C
....................          append_data(file_ptr_raw_all); 
0F992:  MOVLW  02
0F994:  MOVLB  8
0F996:  MOVWF  xCC
0F998:  MOVLW  DD
0F99A:  MOVWF  xCB
0F99C:  MOVLB  0
0F99E:  CALL   8298
....................       heartbeat(TRUE); 
0F9A2:  MOVLW  01
0F9A4:  MOVLB  8
0F9A6:  MOVWF  xCB
0F9A8:  MOVLB  0
0F9AA:  CALL   555C
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0F9AE:  MOVLB  8
0F9B0:  CLRF   xCB
0F9B2:  MOVLB  0
0F9B4:  CALL   555C
....................          append_data(file_ptr_raw_new); 
0F9B8:  MOVLW  02
0F9BA:  MOVLB  8
0F9BC:  MOVWF  xCC
0F9BE:  MOVLW  EB
0F9C0:  MOVWF  xCB
0F9C2:  MOVLB  0
0F9C4:  CALL   8298
....................       heartbeat(TRUE); 
0F9C8:  MOVLW  01
0F9CA:  MOVLB  8
0F9CC:  MOVWF  xCB
0F9CE:  MOVLB  0
0F9D0:  CALL   555C
0F9D4:  MOVLB  8
....................    } 
0F9D6:  MOVLB  0
0F9D8:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
0F9E6:  CLRF   xC3
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
0F9DA:  MOVLW  0D
0F9DC:  MOVLB  8
0F9DE:  MOVWF  xAC
0F9E0:  MOVLW  0A
0F9E2:  MOVWF  xAD
0F9E4:  CLRF   xAE
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
0F9E8:  MOVLB  0
0F9EA:  CALL   ECAE
....................    clear_data_buffer(); 
0F9EE:  CALL   E3DE
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
0F9F2:  MOVLW  08
0F9F4:  MOVWF  FEA
0F9F6:  MOVLW  AF
0F9F8:  MOVWF  FE9
0F9FA:  CLRF   00
0F9FC:  CLRF   02
0F9FE:  MOVLW  14
0FA00:  MOVWF  01
0FA02:  CALL   350A
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
0FA06:  MOVLW  01
0FA08:  MOVWF  FEA
0FA0A:  MOVLW  A7
0FA0C:  MOVWF  FE9
0FA0E:  CLRF   00
0FA10:  CLRF   02
0FA12:  MOVLW  A0
0FA14:  MOVWF  01
0FA16:  CALL   350A
....................  
....................    time_stamp(); 
0FA1A:  CALL   53F4
....................    strcpy(data_buffer, time_stmp_str); 
0FA1E:  CLRF   FEA
0FA20:  MOVLW  67
0FA22:  MOVWF  FE9
0FA24:  MOVLW  02
0FA26:  MOVWF  FE2
0FA28:  MOVLW  99
0FA2A:  MOVWF  FE1
0FA2C:  MOVF   FE7,F
0FA2E:  MOVFF  FE6,FEE
0FA32:  BNZ   FA2C
....................    strcat(data_buffer, (char *)","); 
0FA34:  MOVLW  2C
0FA36:  MOVLB  8
0FA38:  MOVWF  xC7
0FA3A:  CLRF   xC8
0FA3C:  CLRF   xD7
0FA3E:  MOVLW  67
0FA40:  MOVWF  xD6
0FA42:  MOVLW  08
0FA44:  MOVWF  xD9
0FA46:  MOVLW  C7
0FA48:  MOVWF  xD8
0FA4A:  MOVLB  0
0FA4C:  CALL   54B8
....................  
....................    flag_mod=fmod(macro_flag,10); 
0FA50:  MOVFF  324,8F6
0FA54:  MOVFF  323,8F5
0FA58:  CALL   BFAE
0FA5C:  MOVFF  03,8CC
0FA60:  MOVFF  02,8CB
0FA64:  MOVFF  01,8CA
0FA68:  MOVFF  00,8C9
0FA6C:  MOVFF  03,8D0
0FA70:  MOVFF  02,8CF
0FA74:  MOVFF  01,8CE
0FA78:  MOVFF  00,8CD
0FA7C:  MOVLB  8
0FA7E:  CLRF   xD4
0FA80:  CLRF   xD3
0FA82:  MOVLW  20
0FA84:  MOVWF  xD2
0FA86:  MOVLW  82
0FA88:  MOVWF  xD1
0FA8A:  MOVLB  0
0FA8C:  GOTO   F0AA
0FA90:  MOVFF  03,8F4
0FA94:  MOVFF  02,8F3
0FA98:  MOVFF  01,8F2
0FA9C:  MOVFF  00,8F1
0FAA0:  CALL   ECC4
0FAA4:  MOVFF  01,8C6
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
0FAA8:  MOVLB  8
0FAAA:  DECFSZ xC6,W
0FAAC:  BRA    FAB0
0FAAE:  BRA    FAB6
0FAB0:  MOVF   xC6,W
0FAB2:  SUBLW  03
0FAB4:  BNZ   FAD6
....................    { 
....................       clear_proc_time_stmp_str(); 
0FAB6:  MOVLB  0
0FAB8:  GOTO   F212
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
0FABC:  MOVLW  02
0FABE:  MOVWF  FEA
0FAC0:  MOVLW  B7
0FAC2:  MOVWF  FE9
0FAC4:  MOVLW  02
0FAC6:  MOVWF  FE2
0FAC8:  MOVLW  99
0FACA:  MOVWF  FE1
0FACC:  MOVF   FE7,F
0FACE:  MOVFF  FE6,FEE
0FAD2:  BNZ   FACC
0FAD4:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
0FAD6:  MOVLB  0
0FAD8:  CALL   F242
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
0FADC:  MOVLB  8
0FADE:  CLRF   xCA
0FAE0:  MOVLW  67
0FAE2:  MOVWF  xC9
0FAE4:  MOVLB  0
0FAE6:  RCALL  F74A
0FAE8:  MOVFF  02,03
0FAEC:  MOVF   01,W
0FAEE:  XORLW  FF
0FAF0:  ADDLW  A1
0FAF2:  MOVLB  8
0FAF4:  MOVWF  xC9
0FAF6:  MOVLW  00
0FAF8:  SUBFWB 02,W
0FAFA:  MOVWF  xCA
0FAFC:  MOVLW  01
0FAFE:  SUBWF  xC9,F
0FB00:  MOVLW  00
0FB02:  SUBWFB xCA,F
0FB04:  CLRF   xCC
0FB06:  MOVLW  67
0FB08:  MOVWF  xCB
0FB0A:  MOVLW  03
0FB0C:  MOVWF  xCE
0FB0E:  MOVLW  25
0FB10:  MOVWF  xCD
0FB12:  MOVFF  8CA,8D0
0FB16:  MOVFF  8C9,8CF
0FB1A:  MOVLB  0
0FB1C:  RCALL  F786
....................    strcat(data_buffer, (char *)","); 
0FB1E:  MOVLW  2C
0FB20:  MOVLB  8
0FB22:  MOVWF  xC7
0FB24:  CLRF   xC8
0FB26:  CLRF   xD7
0FB28:  MOVLW  67
0FB2A:  MOVWF  xD6
0FB2C:  MOVLW  08
0FB2E:  MOVWF  xD9
0FB30:  MOVLW  C7
0FB32:  MOVWF  xD8
0FB34:  MOVLB  0
0FB36:  CALL   54B8
....................     
....................    cmd = 'S'; 
0FB3A:  MOVLW  53
0FB3C:  MOVWF  47
....................    arg = 1; 
0FB3E:  CLRF   4B
0FB40:  CLRF   4A
0FB42:  CLRF   49
0FB44:  MOVLW  01
0FB46:  MOVWF  48
....................  
....................    for(i = 0; i < 6; i++) 
0FB48:  MOVLB  8
0FB4A:  CLRF   xC4
0FB4C:  MOVF   xC4,W
0FB4E:  SUBLW  05
0FB50:  BNC   FB68
....................    { 
....................       rcvdData = get_slave_data(); 
0FB52:  MOVLB  0
0FB54:  BRA    F826
0FB56:  MOVFF  01,8C3
....................       if (DATA_COMPLETE == rcvdData) 
0FB5A:  MOVLB  8
0FB5C:  MOVF   xC3,W
0FB5E:  SUBLW  02
0FB60:  BNZ   FB64
....................       { 
....................          break; 
0FB62:  BRA    FB68
....................       } 
0FB64:  INCF   xC4,F
0FB66:  BRA    FB4C
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
0FB68:  CLRF   xCA
0FB6A:  MOVLW  67
0FB6C:  MOVWF  xC9
0FB6E:  MOVLB  0
0FB70:  RCALL  F74A
0FB72:  MOVFF  02,03
0FB76:  MOVF   01,W
0FB78:  XORLW  FF
0FB7A:  ADDLW  A1
0FB7C:  MOVLB  8
0FB7E:  MOVWF  xC9
0FB80:  MOVLW  00
0FB82:  SUBFWB 02,W
0FB84:  MOVWF  xCA
0FB86:  MOVLW  01
0FB88:  SUBWF  xC9,F
0FB8A:  MOVLW  00
0FB8C:  SUBWFB xCA,F
0FB8E:  CLRF   xCC
0FB90:  MOVLW  67
0FB92:  MOVWF  xCB
0FB94:  MOVLW  02
0FB96:  MOVWF  xCE
0FB98:  MOVLW  47
0FB9A:  MOVWF  xCD
0FB9C:  MOVFF  8CA,8D0
0FBA0:  MOVFF  8C9,8CF
0FBA4:  MOVLB  0
0FBA6:  RCALL  F786
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
0FBA8:  MOVLW  02
0FBAA:  MOVLB  8
0FBAC:  MOVWF  xCA
0FBAE:  MOVLW  47
0FBB0:  MOVWF  xC9
0FBB2:  MOVLB  0
0FBB4:  RCALL  F74A
0FBB6:  MOVFF  01,8C5
....................    if (rec_len > 0 && rec_len < 12) 
0FBBA:  MOVLB  8
0FBBC:  MOVF   xC5,F
0FBBE:  BZ    FBCC
0FBC0:  MOVF   xC5,W
0FBC2:  SUBLW  0B
0FBC4:  BNC   FBCC
....................    { 
....................       rcvdData = SHORT_DATA; 
0FBC6:  MOVLW  04
0FBC8:  MOVWF  xC3
....................    } 
0FBCA:  BRA    FBD6
....................    else 
....................    { 
....................       if (rec_len > 30) 
0FBCC:  MOVF   xC5,W
0FBCE:  SUBLW  1E
0FBD0:  BC    FBD6
....................       { 
....................          rcvdData = LONG_DATA; 
0FBD2:  MOVLW  05
0FBD4:  MOVWF  xC3
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
0FBD6:  MOVLW  02
0FBD8:  SUBWF  xC3,W
0FBDA:  ADDLW  FC
0FBDC:  BC    FC48
0FBDE:  ADDLW  04
0FBE0:  MOVLB  0
0FBE2:  GOTO   FDA6
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
0FBE6:  MOVLB  8
0FBE8:  BRA    FC48
0FBEA:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
0FBEC:  MOVLW  08
0FBEE:  MOVWF  1E
0FBF0:  MOVLW  AF
0FBF2:  MOVWF  1D
0FBF4:  MOVLW  92
0FBF6:  MOVWF  FF6
0FBF8:  MOVLW  1C
0FBFA:  MOVWF  FF7
0FBFC:  MOVLW  00
0FBFE:  MOVWF  FF8
0FC00:  CALL   5098
....................          break; 
0FC04:  MOVLB  8
0FC06:  BRA    FC48
0FC08:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
0FC0A:  MOVLW  08
0FC0C:  MOVWF  1E
0FC0E:  MOVLW  AF
0FC10:  MOVWF  1D
0FC12:  MOVLW  9C
0FC14:  MOVWF  FF6
0FC16:  MOVLW  1C
0FC18:  MOVWF  FF7
0FC1A:  MOVLW  00
0FC1C:  MOVWF  FF8
0FC1E:  CALL   5098
....................          break; 
0FC22:  MOVLB  8
0FC24:  BRA    FC48
0FC26:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
0FC28:  MOVLW  08
0FC2A:  MOVWF  1E
0FC2C:  MOVLW  AF
0FC2E:  MOVWF  1D
0FC30:  MOVLW  AC
0FC32:  MOVWF  FF6
0FC34:  MOVLW  1C
0FC36:  MOVWF  FF7
0FC38:  MOVLW  00
0FC3A:  MOVWF  FF8
0FC3C:  CALL   5098
....................          break; 
0FC40:  MOVLB  8
0FC42:  BRA    FC48
0FC44:  MOVLB  0
0FC46:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
0FC48:  CLRF   xCA
0FC4A:  MOVLW  67
0FC4C:  MOVWF  xC9
0FC4E:  MOVLB  0
0FC50:  RCALL  F74A
0FC52:  MOVFF  02,03
0FC56:  MOVF   01,W
0FC58:  XORLW  FF
0FC5A:  ADDLW  A1
0FC5C:  MOVLB  8
0FC5E:  MOVWF  xC9
0FC60:  MOVLW  00
0FC62:  SUBFWB 02,W
0FC64:  MOVWF  xCA
0FC66:  MOVLW  01
0FC68:  SUBWF  xC9,F
0FC6A:  MOVLW  00
0FC6C:  SUBWFB xCA,F
0FC6E:  CLRF   xCC
0FC70:  MOVLW  67
0FC72:  MOVWF  xCB
0FC74:  MOVLW  08
0FC76:  MOVWF  xCE
0FC78:  MOVLW  AF
0FC7A:  MOVWF  xCD
0FC7C:  MOVFF  8CA,8D0
0FC80:  MOVFF  8C9,8CF
0FC84:  MOVLB  0
0FC86:  RCALL  F786
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
0FC88:  MOVLB  8
0FC8A:  CLRF   xCA
0FC8C:  MOVLW  67
0FC8E:  MOVWF  xC9
0FC90:  MOVLB  0
0FC92:  RCALL  F74A
0FC94:  MOVFF  02,03
0FC98:  MOVF   01,W
0FC9A:  XORLW  FF
0FC9C:  ADDLW  A1
0FC9E:  MOVLB  8
0FCA0:  MOVWF  xC9
0FCA2:  MOVLW  00
0FCA4:  SUBFWB 02,W
0FCA6:  MOVWF  xCA
0FCA8:  MOVLW  01
0FCAA:  SUBWF  xC9,F
0FCAC:  MOVLW  00
0FCAE:  SUBWFB xCA,F
0FCB0:  CLRF   xCC
0FCB2:  MOVLW  67
0FCB4:  MOVWF  xCB
0FCB6:  MOVLW  08
0FCB8:  MOVWF  xCE
0FCBA:  MOVLW  AC
0FCBC:  MOVWF  xCD
0FCBE:  MOVFF  8CA,8D0
0FCC2:  MOVFF  8C9,8CF
0FCC6:  MOVLB  0
0FCC8:  RCALL  F786
....................  
....................    if(DATA_COMPLETE != rcvdData) 
0FCCA:  MOVLB  8
0FCCC:  MOVF   xC3,W
0FCCE:  SUBLW  02
0FCD0:  BZ    FD8A
....................    {    //housekeeping 
....................       time_stamp(); 
0FCD2:  MOVLB  0
0FCD4:  CALL   53F4
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
0FCD8:  MOVLW  01
0FCDA:  MOVWF  1E
0FCDC:  MOVLW  A7
0FCDE:  MOVWF  1D
0FCE0:  MOVLW  BC
0FCE2:  MOVWF  FF6
0FCE4:  MOVLW  1C
0FCE6:  MOVWF  FF7
0FCE8:  MOVLW  00
0FCEA:  MOVWF  FF8
0FCEC:  MOVLW  0A
0FCEE:  MOVLB  8
0FCF0:  MOVWF  xC9
0FCF2:  MOVLB  0
0FCF4:  CALL   AA6C
0FCF8:  MOVFF  1E,FEA
0FCFC:  MOVFF  1D,FE9
0FD00:  CLRF   FEF
0FD02:  MOVLW  08
0FD04:  MOVWF  FEA
0FD06:  MOVLW  AF
0FD08:  MOVWF  FE9
0FD0A:  RCALL  F916
0FD0C:  MOVLW  C8
0FD0E:  MOVWF  FF6
0FD10:  MOVLW  1C
0FD12:  MOVWF  FF7
0FD14:  MOVLW  00
0FD16:  MOVWF  FF8
0FD18:  MOVLW  06
0FD1A:  MOVLB  8
0FD1C:  MOVWF  xC9
0FD1E:  MOVLB  0
0FD20:  CALL   AA6C
0FD24:  MOVFF  8C5,8CB
0FD28:  MOVLW  1B
0FD2A:  MOVLB  8
0FD2C:  MOVWF  xCC
0FD2E:  MOVLB  0
0FD30:  CALL   525A
0FD34:  MOVLW  5D
0FD36:  MOVLB  8
0FD38:  MOVWF  xDD
0FD3A:  MOVLB  0
0FD3C:  CALL   5078
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
0FD40:  MOVLW  01
0FD42:  MOVLB  8
0FD44:  MOVWF  xCA
0FD46:  MOVLW  A7
0FD48:  MOVWF  xC9
0FD4A:  MOVLB  0
0FD4C:  RCALL  F74A
0FD4E:  MOVFF  02,03
0FD52:  MOVF   01,W
0FD54:  XORLW  FF
0FD56:  ADDLW  A1
0FD58:  MOVLB  8
0FD5A:  MOVWF  xC9
0FD5C:  MOVLW  00
0FD5E:  SUBFWB 02,W
0FD60:  MOVWF  xCA
0FD62:  MOVLW  01
0FD64:  SUBWF  xC9,F
0FD66:  MOVLW  00
0FD68:  SUBWFB xCA,F
0FD6A:  MOVLW  01
0FD6C:  MOVWF  xCC
0FD6E:  MOVLW  A7
0FD70:  MOVWF  xCB
0FD72:  CLRF   xCE
0FD74:  MOVLW  67
0FD76:  MOVWF  xCD
0FD78:  MOVFF  8CA,8D0
0FD7C:  MOVFF  8C9,8CF
0FD80:  MOVLB  0
0FD82:  RCALL  F786
....................       record_event(); 
0FD84:  CALL   847A
0FD88:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
0FD8A:  MOVFF  8AA,8C9
0FD8E:  MOVFF  8AB,8CA
0FD92:  MOVLB  0
0FD94:  RCALL  F93C
....................  
....................    return (rcvdData); 
0FD96:  CLRF   03
0FD98:  MOVLB  8
0FD9A:  MOVFF  8C3,01
0FD9E:  MOVFF  03,02
0FDA2:  MOVLB  0
0FDA4:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
1024E:  MOVLB  8
10250:  CLRF   xA2
10252:  MOVF   xA2,W
10254:  SUBLW  02
10256:  BTFSS  FD8.0
10258:  BRA    1036E
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
1025A:  MOVFF  8A0,8AA
1025E:  MOVFF  8A1,8AB
10262:  MOVLB  0
10264:  CALL   F9DA
10268:  MOVFF  02,03
1026C:  MOVF   01,W
1026E:  SUBLW  02
10270:  BNZ   1027E
10272:  MOVF   03,F
10274:  BNZ   1027E
....................       { 
....................          break; 
10276:  MOVLB  8
10278:  BRA    1036E
....................       } 
1027A:  BRA    1036A
1027C:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
1027E:  MOVLW  01
10280:  MOVLB  8
10282:  ADDWF  xA2,W
10284:  MOVWF  xA3
10286:  MOVLW  D2
10288:  MOVWF  FF6
1028A:  MOVLW  1C
1028C:  MOVWF  FF7
1028E:  MOVLW  00
10290:  MOVWF  FF8
10292:  CLRF   1B
10294:  BTFSC  FF2.7
10296:  BSF    1B.7
10298:  BCF    FF2.7
1029A:  MOVLW  05
1029C:  MOVLB  A
1029E:  MOVWF  x19
102A0:  MOVLB  0
102A2:  CALL   104E
102A6:  BTFSC  1B.7
102A8:  BSF    FF2.7
102AA:  CLRF   1B
102AC:  BTFSC  FF2.7
102AE:  BSF    1B.7
102B0:  BCF    FF2.7
102B2:  MOVFF  8A3,A19
102B6:  MOVLW  1B
102B8:  MOVLB  A
102BA:  MOVWF  x1A
102BC:  MOVLB  0
102BE:  CALL   0FD0
102C2:  BTFSC  1B.7
102C4:  BSF    FF2.7
102C6:  MOVLW  0D
102C8:  BTFSS  F9E.4
102CA:  BRA    102C8
102CC:  MOVWF  FAD
102CE:  MOVLW  0A
102D0:  BTFSS  F9E.4
102D2:  BRA    102D0
102D4:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
102D6:  BCF    F90.7
....................          delay_ms(1000); 
102D8:  MOVLW  04
102DA:  MOVLB  8
102DC:  MOVWF  xA3
102DE:  MOVLW  FA
102E0:  MOVLB  A
102E2:  MOVWF  xA2
102E4:  MOVLB  0
102E6:  CALL   0588
102EA:  MOVLB  8
102EC:  DECFSZ xA3,F
102EE:  BRA    102DE
....................          output_bit(VDET,ON); 
102F0:  BSF    F90.7
....................          delay_ms(1000); 
102F2:  MOVLW  04
102F4:  MOVWF  xA3
102F6:  MOVLW  FA
102F8:  MOVLB  A
102FA:  MOVWF  xA2
102FC:  MOVLB  0
102FE:  CALL   0588
10302:  MOVLB  8
10304:  DECFSZ xA3,F
10306:  BRA    102F6
....................          if (LightTargetFlag==0) 
10308:  MOVLB  2
1030A:  MOVF   xD9,F
1030C:  BNZ   10354
....................          { 
....................           cmd='K'; 
1030E:  MOVLW  4B
10310:  MOVWF  47
....................           arg=detector_ch; 
10312:  CLRF   4B
10314:  CLRF   4A
10316:  CLRF   49
10318:  MOVFF  2D6,48
....................           det_cmd(); 
1031C:  MOVLB  0
1031E:  CALL   E6F0
....................           delay_ms(1000); 
10322:  MOVLW  04
10324:  MOVLB  8
10326:  MOVWF  xA3
10328:  MOVLW  FA
1032A:  MOVLB  A
1032C:  MOVWF  xA2
1032E:  MOVLB  0
10330:  CALL   0588
10334:  MOVLB  8
10336:  DECFSZ xA3,F
10338:  BRA    10328
....................           cmd='L'; 
1033A:  MOVLW  4C
1033C:  MOVWF  47
....................           arg=detector_li; 
1033E:  CLRF   4B
10340:  CLRF   4A
10342:  MOVFF  2D8,49
10346:  MOVFF  2D7,48
....................           det_cmd(); 
1034A:  MOVLB  0
1034C:  CALL   E6F0
....................          }  
10350:  BRA    10368
10352:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
10354:  MOVLW  6C
10356:  MOVWF  47
....................           arg=1; 
10358:  CLRF   4B
1035A:  CLRF   4A
1035C:  CLRF   49
1035E:  MOVLW  01
10360:  MOVWF  48
....................           det_cmd(); 
10362:  MOVLB  0
10364:  CALL   E6F0
10368:  MOVLB  8
....................          }  
....................       } 
1036A:  INCF   xA2,F
1036C:  BRA    10252
....................    } 
....................  
....................    parse_data(); 
1036E:  MOVLB  0
10370:  RCALL  FF64
....................    data_available = TRUE; 
10372:  MOVLW  01
10374:  MOVLB  3
10376:  MOVWF  x3B
....................    macro_flag = 900; 
10378:  MOVLW  03
1037A:  MOVWF  x24
1037C:  MOVLW  84
1037E:  MOVWF  x23
....................  
....................    return; 
10380:  MOVLB  0
10382:  GOTO   106D4 (RETURN)
.................... } 
....................  
.................... int16 parse_temp() 
*
10A28:  MOVLB  8
10A2A:  CLRF   xAB
10A2C:  CLRF   xAA
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
10A2E:  MOVLB  0
10A30:  CALL   FF64
10A34:  MOVFF  02,8AB
10A38:  MOVFF  01,8AA
....................    return (temp); 
10A3C:  MOVLB  8
10A3E:  MOVFF  8AA,01
10A42:  MOVFF  8AB,02
10A46:  MOVLB  0
10A48:  GOTO   10B5A (RETURN)
.................... } 
....................  
.................... void det_temp() 
10A4C:  MOVLB  8
10A4E:  CLRF   xA7
10A50:  CLRF   xA6
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
10A52:  MOVLB  2
10A54:  MOVF   xD5,W
10A56:  XORLW  01
10A58:  MOVLB  0
10A5A:  BZ    10A62
10A5C:  XORLW  03
10A5E:  BZ    10A6C
10A60:  BRA    10A76
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
10A62:  MOVFF  42,8A9
10A66:  MOVFF  41,8A8
....................          break; 
10A6A:  BRA    10A82
....................       case 2 : target_temp = nv_d2_temp; 
10A6C:  MOVFF  44,8A9
10A70:  MOVFF  43,8A8
....................          break; 
10A74:  BRA    10A82
....................       default : target_temp = 20000; 
10A76:  MOVLW  4E
10A78:  MOVLB  8
10A7A:  MOVWF  xA9
10A7C:  MOVLW  20
10A7E:  MOVWF  xA8
....................          break; 
10A80:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
10A82:  MOVLB  8
10A84:  CLRF   xA5
10A86:  MOVLW  3C
10A88:  MOVWF  xA4
....................    n = 0; 
10A8A:  CLRF   xA3
10A8C:  CLRF   xA2
....................    store=FALSE; 
10A8E:  CLRF   xA0
....................    display=FALSE; 
10A90:  CLRF   xA1
....................  
....................    time_stamp(); 
10A92:  MOVLB  0
10A94:  CALL   53F4
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
10A98:  MOVLW  01
10A9A:  MOVWF  1E
10A9C:  MOVLW  A7
10A9E:  MOVWF  1D
10AA0:  MOVLW  DC
10AA2:  MOVWF  FF6
10AA4:  MOVLW  1C
10AA6:  MOVWF  FF7
10AA8:  MOVLW  00
10AAA:  MOVWF  FF8
10AAC:  MOVLW  16
10AAE:  MOVLB  8
10AB0:  MOVWF  xC9
10AB2:  MOVLB  0
10AB4:  CALL   AA6C
10AB8:  MOVLW  10
10ABA:  MOVWF  FE9
10ABC:  MOVFF  8A9,8D5
10AC0:  MOVFF  8A8,8D4
10AC4:  CALL   AA9E
10AC8:  MOVLW  F5
10ACA:  MOVWF  FF6
10ACC:  MOVLW  1C
10ACE:  MOVWF  FF7
10AD0:  MOVLW  00
10AD2:  MOVWF  FF8
10AD4:  MOVLW  09
10AD6:  MOVLB  8
10AD8:  MOVWF  xC9
10ADA:  MOVLB  0
10ADC:  CALL   AA6C
10AE0:  MOVLW  10
10AE2:  MOVWF  FE9
10AE4:  MOVFF  8A7,8D5
10AE8:  MOVFF  8A6,8D4
10AEC:  CALL   AA9E
10AF0:  MOVLW  01
10AF2:  MOVWF  FF6
10AF4:  MOVLW  1D
10AF6:  MOVWF  FF7
10AF8:  MOVLW  00
10AFA:  MOVWF  FF8
10AFC:  MOVLW  0B
10AFE:  MOVLB  8
10B00:  MOVWF  xC9
10B02:  MOVLB  0
10B04:  CALL   AA6C
10B08:  MOVLW  10
10B0A:  MOVWF  FE9
10B0C:  MOVFF  8A3,8D5
10B10:  MOVFF  8A2,8D4
10B14:  CALL   AA9E
10B18:  MOVLW  0F
10B1A:  MOVWF  FF6
10B1C:  MOVLW  1D
10B1E:  MOVWF  FF7
10B20:  MOVLW  00
10B22:  MOVWF  FF8
10B24:  MOVLW  03
10B26:  MOVLB  8
10B28:  MOVWF  xC9
10B2A:  MOVLB  0
10B2C:  CALL   AA6C
....................    record_event(); 
10B30:  CALL   847A
....................  
....................    for (n=1; n<t; ++n) 
10B34:  MOVLB  8
10B36:  CLRF   xA3
10B38:  MOVLW  01
10B3A:  MOVWF  xA2
10B3C:  MOVF   xA3,W
10B3E:  SUBWF  xA5,W
10B40:  BNC   10B9C
10B42:  BNZ   10B4A
10B44:  MOVF   xA4,W
10B46:  SUBWF  xA2,W
10B48:  BC    10B9C
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
10B4A:  MOVFF  8A0,8AA
10B4E:  MOVFF  8A1,8AB
10B52:  MOVLB  0
10B54:  CALL   F9DA
....................       current_temp=parse_temp(); 
10B58:  BRA    10A28
10B5A:  MOVFF  02,8A7
10B5E:  MOVFF  01,8A6
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
10B62:  MOVLB  8
10B64:  MOVF   xA9,W
10B66:  SUBWF  xA7,W
10B68:  BNC   10B72
10B6A:  BNZ   10B7A
10B6C:  MOVF   xA8,W
10B6E:  SUBWF  xA6,W
10B70:  BC    10B7A
10B72:  MOVF   xA6,F
10B74:  BNZ   10B7E
10B76:  MOVF   xA7,F
10B78:  BNZ   10B7E
10B7A:  BRA    10B9C
10B7C:  BRA    10B94
....................       else delay_ms(2500);                               // completes the 5.0 loop 
10B7E:  MOVLW  0A
10B80:  MOVWF  xAA
10B82:  MOVLW  FA
10B84:  MOVLB  A
10B86:  MOVWF  xA2
10B88:  MOVLB  0
10B8A:  CALL   0588
10B8E:  MOVLB  8
10B90:  DECFSZ xAA,F
10B92:  BRA    10B82
10B94:  INCF   xA2,F
10B96:  BTFSC  FD8.2
10B98:  INCF   xA3,F
10B9A:  BRA    10B3C
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
10B9C:  MOVLW  01
10B9E:  MOVWF  1E
10BA0:  MOVLW  A7
10BA2:  MOVWF  1D
10BA4:  MOVLW  14
10BA6:  MOVWF  FF6
10BA8:  MOVLW  1D
10BAA:  MOVWF  FF7
10BAC:  MOVLW  00
10BAE:  MOVWF  FF8
10BB0:  MOVLW  14
10BB2:  MOVWF  xC9
10BB4:  MOVLB  0
10BB6:  CALL   AA6C
10BBA:  MOVLW  10
10BBC:  MOVWF  FE9
10BBE:  MOVFF  8A9,8D5
10BC2:  MOVFF  8A8,8D4
10BC6:  CALL   AA9E
10BCA:  MOVLW  2B
10BCC:  MOVWF  FF6
10BCE:  MOVLW  1D
10BD0:  MOVWF  FF7
10BD2:  MOVLW  00
10BD4:  MOVWF  FF8
10BD6:  MOVLW  09
10BD8:  MOVLB  8
10BDA:  MOVWF  xC9
10BDC:  MOVLB  0
10BDE:  CALL   AA6C
10BE2:  MOVLW  10
10BE4:  MOVWF  FE9
10BE6:  MOVFF  8A7,8D5
10BEA:  MOVFF  8A6,8D4
10BEE:  CALL   AA9E
10BF2:  MOVLW  37
10BF4:  MOVWF  FF6
10BF6:  MOVLW  1D
10BF8:  MOVWF  FF7
10BFA:  MOVLW  00
10BFC:  MOVWF  FF8
10BFE:  MOVLW  0B
10C00:  MOVLB  8
10C02:  MOVWF  xC9
10C04:  MOVLB  0
10C06:  CALL   AA6C
10C0A:  MOVLW  10
10C0C:  MOVWF  FE9
10C0E:  MOVFF  8A3,8D5
10C12:  MOVFF  8A2,8D4
10C16:  CALL   AA9E
10C1A:  MOVLW  45
10C1C:  MOVWF  FF6
10C1E:  MOVLW  1D
10C20:  MOVWF  FF7
10C22:  MOVLW  00
10C24:  MOVWF  FF8
10C26:  MOVLW  03
10C28:  MOVLB  8
10C2A:  MOVWF  xC9
10C2C:  MOVLB  0
10C2E:  CALL   AA6C
....................    record_event();    
10C32:  CALL   847A
10C36:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
10700:  MOVLB  8
10702:  CLRF   xB3
10704:  CLRF   xB2
10706:  CLRF   xB1
10708:  CLRF   xB0
....................    set_adc_channel(1,VSS); 
1070A:  MOVLW  04
1070C:  MOVWF  01
1070E:  MOVF   FC2,W
10710:  ANDLW  83
10712:  IORWF  01,W
10714:  MOVWF  FC2
10716:  MOVLW  00
10718:  MOVWF  01
1071A:  MOVF   FC1,W
1071C:  ANDLW  F8
1071E:  IORWF  01,W
10720:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
10722:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
10724:  MOVLW  01
10726:  MOVWF  xAD
10728:  MOVF   xAD,W
1072A:  SUBLW  32
1072C:  BNC   10752
....................       reading=read_adc(); 
1072E:  BSF    FC2.1
10730:  BTFSC  FC2.1
10732:  BRA    10730
10734:  MOVFF  FC3,8B4
10738:  MOVFF  FC4,8B5
1073C:  CLRF   xB6
1073E:  CLRF   xB7
....................       delay_ms(5); 
10740:  MOVLW  05
10742:  MOVLB  A
10744:  MOVWF  xA2
10746:  MOVLB  0
10748:  CALL   0588
1074C:  MOVLB  8
1074E:  INCF   xAD,F
10750:  BRA    10728
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
10752:  MOVLW  01
10754:  MOVWF  xAD
10756:  MOVF   xAD,W
10758:  SUBLW  64
1075A:  BNC   10808
....................       reading=read_adc(); 
1075C:  BSF    FC2.1
1075E:  BTFSC  FC2.1
10760:  BRA    1075E
10762:  MOVFF  FC3,8B4
10766:  MOVFF  FC4,8B5
1076A:  CLRF   xB6
1076C:  CLRF   xB7
....................       result=(((result*(i-1))+reading)/i); 
1076E:  MOVLW  01
10770:  SUBWF  xAD,W
10772:  MOVWF  xB8
10774:  MOVFF  8B3,9D7
10778:  MOVFF  8B2,9D6
1077C:  MOVFF  8B1,9D5
10780:  MOVFF  8B0,9D4
10784:  MOVLB  9
10786:  CLRF   xDB
10788:  CLRF   xDA
1078A:  CLRF   xD9
1078C:  MOVWF  xD8
1078E:  MOVLB  0
10790:  CALL   47D4
10794:  MOVFF  03,8BB
10798:  MOVFF  02,8BA
1079C:  MOVFF  01,8B9
107A0:  MOVFF  00,8B8
107A4:  MOVLB  8
107A6:  MOVF   xB4,W
107A8:  ADDWF  xB8,F
107AA:  MOVF   xB5,W
107AC:  ADDWFC xB9,F
107AE:  MOVF   xB6,W
107B0:  ADDWFC xBA,F
107B2:  MOVF   xB7,W
107B4:  ADDWFC xBB,F
107B6:  BCF    FD8.1
107B8:  CLRF   1B
107BA:  BTFSC  FF2.7
107BC:  BSF    1B.7
107BE:  BCF    FF2.7
107C0:  MOVFF  8BB,A28
107C4:  MOVFF  8BA,A27
107C8:  MOVFF  8B9,A26
107CC:  MOVFF  8B8,A25
107D0:  MOVLB  A
107D2:  CLRF   x2C
107D4:  CLRF   x2B
107D6:  CLRF   x2A
107D8:  MOVFF  8AD,A29
107DC:  MOVLB  0
107DE:  CALL   1080
107E2:  BTFSC  1B.7
107E4:  BSF    FF2.7
107E6:  MOVFF  03,8B3
107EA:  MOVFF  02,8B2
107EE:  MOVFF  01,8B1
107F2:  MOVFF  00,8B0
....................       delay_ms(5); 
107F6:  MOVLW  05
107F8:  MOVLB  A
107FA:  MOVWF  xA2
107FC:  MOVLB  0
107FE:  CALL   0588
10802:  MOVLB  8
10804:  INCF   xAD,F
10806:  BRA    10756
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
10808:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
1080A:  MOVFF  8B3,9D7
1080E:  MOVFF  8B2,9D6
10812:  MOVFF  8B1,9D5
10816:  MOVFF  8B0,9D4
1081A:  MOVLB  9
1081C:  CLRF   xDB
1081E:  CLRF   xDA
10820:  MOVLW  10
10822:  MOVWF  xD9
10824:  MOVLW  25
10826:  MOVWF  xD8
10828:  MOVLB  0
1082A:  CALL   47D4
1082E:  MOVFF  03,8BB
10832:  MOVFF  02,8BA
10836:  MOVFF  01,8B9
1083A:  MOVFF  00,8B8
1083E:  BCF    FD8.1
10840:  CLRF   1B
10842:  BTFSC  FF2.7
10844:  BSF    1B.7
10846:  BCF    FF2.7
10848:  MOVFF  03,A28
1084C:  MOVFF  02,A27
10850:  MOVFF  01,A26
10854:  MOVFF  00,A25
10858:  MOVLB  A
1085A:  CLRF   x2C
1085C:  CLRF   x2B
1085E:  CLRF   x2A
10860:  MOVLW  64
10862:  MOVWF  x29
10864:  MOVLB  0
10866:  CALL   1080
1086A:  BTFSC  1B.7
1086C:  BSF    FF2.7
1086E:  MOVLW  21
10870:  MOVLB  8
10872:  SUBWF  00,W
10874:  MOVWF  xAE
10876:  MOVLW  50
10878:  SUBWFB 01,W
1087A:  MOVWF  xAF
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
1087C:  MOVFF  8AE,01
10880:  MOVFF  8AF,02
10884:  MOVLB  0
10886:  GOTO   108EC (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
10896:  CLRF   xA6
10898:  CLRF   xA5
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
1088A:  MOVLW  0D
1088C:  MOVLB  8
1088E:  MOVWF  xA2
10890:  MOVLW  0A
10892:  MOVWF  xA3
10894:  CLRF   xA4
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
1089A:  MOVLB  0
1089C:  CALL   ECAE
....................    clear_data_buffer(); 
108A0:  CALL   E3DE
....................  
....................    time_stamp(); 
108A4:  CALL   53F4
....................    strcpy(data_buffer, time_stmp_str); 
108A8:  CLRF   FEA
108AA:  MOVLW  67
108AC:  MOVWF  FE9
108AE:  MOVLW  02
108B0:  MOVWF  FE2
108B2:  MOVLW  99
108B4:  MOVWF  FE1
108B6:  MOVF   FE7,F
108B8:  MOVFF  FE6,FEE
108BC:  BNZ   108B6
....................    strcat(data_buffer, (char *)",Tmp,"); 
108BE:  MOVLW  2C
108C0:  MOVLB  8
108C2:  MOVWF  xA7
108C4:  MOVLW  54
108C6:  MOVWF  xA8
108C8:  MOVLW  6D
108CA:  MOVWF  xA9
108CC:  MOVLW  70
108CE:  MOVWF  xAA
108D0:  MOVLW  2C
108D2:  MOVWF  xAB
108D4:  CLRF   xAC
108D6:  CLRF   xD7
108D8:  MOVLW  67
108DA:  MOVWF  xD6
108DC:  MOVLW  08
108DE:  MOVWF  xD9
108E0:  MOVLW  A7
108E2:  MOVWF  xD8
108E4:  MOVLB  0
108E6:  CALL   54B8
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
108EA:  BRA    10700
108EC:  MOVFF  02,8A6
108F0:  MOVFF  01,8A5
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
108F4:  MOVLW  02
108F6:  MOVWF  1E
108F8:  MOVLW  47
108FA:  MOVWF  1D
108FC:  MOVLW  45
108FE:  MOVWF  FE9
10900:  MOVLB  8
10902:  CLRF   xCE
10904:  CLRF   xCD
10906:  MOVFF  8A6,8CC
1090A:  MOVFF  8A5,8CB
1090E:  MOVLW  03
10910:  MOVWF  xCF
10912:  MOVLB  0
10914:  CALL   52F4
....................  
....................    strcat(slave_reply, endofline); 
10918:  MOVLW  02
1091A:  MOVLB  8
1091C:  MOVWF  xD7
1091E:  MOVLW  47
10920:  MOVWF  xD6
10922:  MOVLW  08
10924:  MOVWF  xD9
10926:  MOVLW  A2
10928:  MOVWF  xD8
1092A:  MOVLB  0
1092C:  CALL   54B8
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
10930:  MOVLB  8
10932:  CLRF   xCA
10934:  MOVLW  67
10936:  MOVWF  xC9
10938:  MOVLB  0
1093A:  CALL   F74A
1093E:  MOVFF  02,03
10942:  MOVF   01,W
10944:  XORLW  FF
10946:  ADDLW  A1
10948:  MOVLB  8
1094A:  MOVWF  xAD
1094C:  MOVLW  00
1094E:  SUBFWB 02,W
10950:  MOVWF  xAE
10952:  MOVLW  01
10954:  SUBWF  xAD,F
10956:  MOVLW  00
10958:  SUBWFB xAE,F
1095A:  CLRF   xCC
1095C:  MOVLW  67
1095E:  MOVWF  xCB
10960:  MOVLW  02
10962:  MOVWF  xCE
10964:  MOVLW  47
10966:  MOVWF  xCD
10968:  MOVFF  8AE,8D0
1096C:  MOVFF  8AD,8CF
10970:  MOVLB  0
10972:  CALL   F786
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
10976:  MOVF   1F,F
10978:  BNZ   10998
1097A:  MOVF   20,F
1097C:  BNZ   10998
1097E:  MOVLB  8
10980:  DECFSZ xA1,W
10982:  BRA    10986
10984:  BRA    1098A
10986:  MOVLB  0
10988:  BRA    10998
1098A:  CLRF   FEA
1098C:  MOVLW  67
1098E:  MOVWF  FE9
10990:  MOVLB  0
10992:  CALL   793C
10996:  BRA    109AC
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
10998:  MOVF   20,F
1099A:  BNZ   109A2
1099C:  MOVF   1F,W
1099E:  SUBLW  03
109A0:  BC    109AC
109A2:  CLRF   FEA
109A4:  MOVLW  67
109A6:  MOVWF  FE9
109A8:  CALL   793C
....................  
....................    if (store == TRUE && sd_status==0) { 
109AC:  MOVLB  8
109AE:  DECFSZ xA0,W
109B0:  BRA    10A10
109B2:  MOVLB  2
109B4:  MOVF   xDC,F
109B6:  BTFSC  FD8.2
109B8:  BRA    109BE
109BA:  MOVLB  8
109BC:  BRA    10A10
....................       buffer_select = 0; 
109BE:  MOVLB  0
109C0:  CLRF   x66
....................       
....................       heartbeat(FALSE); 
109C2:  MOVLB  8
109C4:  CLRF   xCB
109C6:  MOVLB  0
109C8:  CALL   555C
....................          append_data(file_ptr_raw_all); 
109CC:  MOVLW  02
109CE:  MOVLB  8
109D0:  MOVWF  xCC
109D2:  MOVLW  DD
109D4:  MOVWF  xCB
109D6:  MOVLB  0
109D8:  CALL   8298
....................       heartbeat(TRUE); 
109DC:  MOVLW  01
109DE:  MOVLB  8
109E0:  MOVWF  xCB
109E2:  MOVLB  0
109E4:  CALL   555C
....................        
....................       heartbeat(FALSE); 
109E8:  MOVLB  8
109EA:  CLRF   xCB
109EC:  MOVLB  0
109EE:  CALL   555C
....................          append_data(file_ptr_raw_new); 
109F2:  MOVLW  02
109F4:  MOVLB  8
109F6:  MOVWF  xCC
109F8:  MOVLW  EB
109FA:  MOVWF  xCB
109FC:  MOVLB  0
109FE:  CALL   8298
....................       heartbeat(TRUE); 
10A02:  MOVLW  01
10A04:  MOVLB  8
10A06:  MOVWF  xCB
10A08:  MOVLB  0
10A0A:  CALL   555C
10A0E:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
10A10:  MOVLW  03
10A12:  MOVLB  3
10A14:  MOVWF  x24
10A16:  MOVLW  84
10A18:  MOVWF  x23
....................     
....................    return (temp); 
10A1A:  MOVLB  8
10A1C:  MOVFF  8A5,01
10A20:  MOVFF  8A6,02
10A24:  MOVLB  0
10A26:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
0E82A:  MOVLB  8
0E82C:  MOVF   xA3,W
0E82E:  ADDLW  FC
0E830:  BC    E86E
0E832:  ADDLW  04
0E834:  MOVLB  0
0E836:  GOTO   E878
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
0E83A:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
0E83C:  BCF    F8C.1
....................          break; 
0E83E:  MOVLB  8
0E840:  BRA    E86E
....................       case 1 :  
....................             output_bit(HSW1, ON); 
0E842:  BSF    F8C.0
....................          break; 
0E844:  MOVLB  8
0E846:  BRA    E86E
....................       case 2 :  
....................             output_bit(HSW2, ON); 
0E848:  BSF    F8C.1
....................          break;  
0E84A:  MOVLB  8
0E84C:  BRA    E86E
....................       case 3 :  
....................             output_bit(HSW1, ON); 
0E84E:  BSF    F8C.0
....................             delay_ms(500); 
0E850:  MOVLW  02
0E852:  MOVLB  8
0E854:  MOVWF  xA4
0E856:  MOVLW  FA
0E858:  MOVLB  A
0E85A:  MOVWF  xA2
0E85C:  MOVLB  0
0E85E:  CALL   0588
0E862:  MOVLB  8
0E864:  DECFSZ xA4,F
0E866:  BRA    E856
....................             output_bit(HSW2, ON); 
0E868:  BSF    F8C.1
....................          break;             
0E86A:  BRA    E86E
0E86C:  MOVLB  8
....................    } 
....................    heater_stat=set; 
0E86E:  MOVFF  8A3,4B5
0E872:  MOVLB  0
0E874:  GOTO   E8D6 (RETURN)
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0EB7C:  MOVLW  08
0EB7E:  MOVLB  8
0EB80:  MOVWF  xAA
0EB82:  CLRF   xA9
....................    LED_level_change=2048; 
0EB84:  MOVWF  xAC
0EB86:  CLRF   xAB
....................     
....................    for (i=0; i<12; i++){ 
0EB88:  CLRF   xA8
0EB8A:  MOVF   xA8,W
0EB8C:  SUBLW  0B
0EB8E:  BNC   EC06
....................       DAC_set(1,LED_level); 
0EB90:  MOVLW  01
0EB92:  MOVWF  xB1
0EB94:  MOVFF  8AA,8B3
0EB98:  MOVFF  8A9,8B2
0EB9C:  MOVLB  0
0EB9E:  RCALL  E8D8
....................       LED_level_change = LED_level_change/2; 
0EBA0:  BCF    FD8.0
0EBA2:  MOVLB  8
0EBA4:  RRCF   xAC,F
0EBA6:  RRCF   xAB,F
....................       ADC_average(200); 
0EBA8:  CLRF   xB2
0EBAA:  MOVLW  C8
0EBAC:  MOVWF  xB1
0EBAE:  MOVLB  0
0EBB0:  RCALL  E980
....................       output = ADC_val[2]; 
0EBB2:  MOVFF  4AA,8AE
0EBB6:  MOVFF  4A9,8AD
....................       temp = ADC_val[3]; 
0EBBA:  MOVFF  4AC,8B0
0EBBE:  MOVFF  4AB,8AF
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0EBC2:  MOVLB  8
0EBC4:  MOVF   xA7,W
0EBC6:  SUBWF  xAE,W
0EBC8:  BNC   EBDC
0EBCA:  BNZ   EBD2
0EBCC:  MOVF   xAD,W
0EBCE:  SUBWF  xA6,W
0EBD0:  BC    EBDC
....................          LED_level=LED_level-LED_level_change; 
0EBD2:  MOVF   xAB,W
0EBD4:  SUBWF  xA9,F
0EBD6:  MOVF   xAC,W
0EBD8:  SUBWFB xAA,F
....................       } 
0EBDA:  BRA    EC02
....................       else if(output<intensity){ 
0EBDC:  MOVF   xAE,W
0EBDE:  SUBWF  xA7,W
0EBE0:  BNC   EBF4
0EBE2:  BNZ   EBEA
0EBE4:  MOVF   xA6,W
0EBE6:  SUBWF  xAD,W
0EBE8:  BC    EBF4
....................          LED_level=LED_level+LED_level_change; 
0EBEA:  MOVF   xAB,W
0EBEC:  ADDWF  xA9,F
0EBEE:  MOVF   xAC,W
0EBF0:  ADDWFC xAA,F
....................       } 
0EBF2:  BRA    EC02
....................       else if(output==intensity) break; 
0EBF4:  MOVF   xA6,W
0EBF6:  SUBWF  xAD,W
0EBF8:  BNZ   EC02
0EBFA:  MOVF   xA7,W
0EBFC:  SUBWF  xAE,W
0EBFE:  BTFSC  FD8.2
0EC00:  BRA    EC06
0EC02:  INCF   xA8,F
0EC04:  BRA    EB8A
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0EC06:  MOVLW  01
0EC08:  MOVWF  xB1
0EC0A:  MOVFF  8AA,8B3
0EC0E:  MOVFF  8A9,8B2
0EC12:  MOVLB  0
0EC14:  RCALL  E8D8
0EC16:  GOTO   EC3A (RETURN)
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0EC1A:  MOVLW  01
0EC1C:  MOVLB  8
0EC1E:  MOVWF  xA5
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0EC20:  MOVF   xA3,F
0EC22:  BNZ   EC28
0EC24:  MOVF   xA4,F
0EC26:  BZ    EC3C
0EC28:  MOVF   xA4,W
0EC2A:  SUBLW  0F
0EC2C:  BNC   EC3C
0EC2E:  MOVFF  8A4,8A7
0EC32:  MOVFF  8A3,8A6
0EC36:  MOVLB  0
0EC38:  BRA    EB7C
0EC3A:  MOVLB  8
....................   if(intensity == 0) { 
0EC3C:  MOVF   xA3,F
0EC3E:  BNZ   EC62
0EC40:  MOVF   xA4,F
0EC42:  BNZ   EC62
....................       DAC_set(1, 0); 
0EC44:  MOVLW  01
0EC46:  MOVWF  xB1
0EC48:  CLRF   xB3
0EC4A:  CLRF   xB2
0EC4C:  MOVLB  0
0EC4E:  RCALL  E8D8
....................       DAC_set(2, 0); 
0EC50:  MOVLW  02
0EC52:  MOVLB  8
0EC54:  MOVWF  xB1
0EC56:  CLRF   xB3
0EC58:  CLRF   xB2
0EC5A:  MOVLB  0
0EC5C:  RCALL  E8D8
....................    } 
0EC5E:  BRA    EC66
0EC60:  MOVLB  8
....................    else valid=FALSE; 
0EC62:  CLRF   xA5
0EC64:  MOVLB  0
....................    return(valid); 
0EC66:  MOVLB  8
0EC68:  MOVFF  8A5,01
0EC6C:  MOVLB  0
0EC6E:  GOTO   ECAC (RETURN)
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
10386:  MOVLW  4A
10388:  MOVWF  FF6
1038A:  MOVLW  1D
1038C:  MOVWF  FF7
1038E:  MOVLW  00
10390:  MOVWF  FF8
10392:  MOVLW  03
10394:  MOVWF  FEA
10396:  MOVLW  3D
10398:  MOVWF  FE9
1039A:  CALL   BF74
1039E:  MOVF   01,W
103A0:  BZ    103B4
103A2:  XORLW  01
103A4:  BZ    103D4
103A6:  XORLW  03
103A8:  BZ    103F4
103AA:  XORLW  01
103AC:  BZ    10414
103AE:  XORLW  07
103B0:  BZ    10434
103B2:  BRA    10452
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
103B4:  BCF    FD8.0
103B6:  MOVLB  3
103B8:  RLCF   x4A,W
103BA:  CLRF   03
103BC:  ADDLW  4B
103BE:  MOVWF  FE9
103C0:  MOVLW  03
103C2:  ADDWFC 03,W
103C4:  MOVWF  FEA
103C6:  MOVFF  4A8,FEC
103CA:  MOVF   FED,F
103CC:  MOVFF  4A7,FEF
....................          break; 
103D0:  MOVLB  0
103D2:  BRA    10452
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
103D4:  BCF    FD8.0
103D6:  MOVLB  3
103D8:  RLCF   x4A,W
103DA:  CLRF   03
103DC:  ADDLW  5D
103DE:  MOVWF  FE9
103E0:  MOVLW  03
103E2:  ADDWFC 03,W
103E4:  MOVWF  FEA
103E6:  MOVFF  4A8,FEC
103EA:  MOVF   FED,F
103EC:  MOVFF  4A7,FEF
....................          break;    
103F0:  MOVLB  0
103F2:  BRA    10452
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
103F4:  BCF    FD8.0
103F6:  MOVLB  3
103F8:  RLCF   x4A,W
103FA:  CLRF   03
103FC:  ADDLW  6F
103FE:  MOVWF  FE9
10400:  MOVLW  03
10402:  ADDWFC 03,W
10404:  MOVWF  FEA
10406:  MOVFF  4A8,FEC
1040A:  MOVF   FED,F
1040C:  MOVFF  4A7,FEF
....................          break; 
10410:  MOVLB  0
10412:  BRA    10452
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
10414:  BCF    FD8.0
10416:  MOVLB  3
10418:  RLCF   x4A,W
1041A:  CLRF   03
1041C:  ADDLW  81
1041E:  MOVWF  FE9
10420:  MOVLW  03
10422:  ADDWFC 03,W
10424:  MOVWF  FEA
10426:  MOVFF  4A8,FEC
1042A:  MOVF   FED,F
1042C:  MOVFF  4A7,FEF
....................          break; 
10430:  MOVLB  0
10432:  BRA    10452
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
10434:  BCF    FD8.0
10436:  MOVLB  3
10438:  RLCF   x4A,W
1043A:  CLRF   03
1043C:  ADDLW  93
1043E:  MOVWF  FE9
10440:  MOVLW  03
10442:  ADDWFC 03,W
10444:  MOVWF  FEA
10446:  MOVFF  4A8,FEC
1044A:  MOVF   FED,F
1044C:  MOVFF  4A7,FEF
....................          break; 
10450:  MOVLB  0
....................    } 
10452:  GOTO   106A0 (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
10456:  MOVFF  8A1,8B2
1045A:  MOVFF  8A0,8B1
1045E:  CALL   E980
....................     
....................    v_supply = read_supply(); 
10462:  CALL   50D6
10466:  MOVFF  02,8A6
1046A:  MOVFF  01,8A5
....................        
....................    RTC_reset_HT(); 
1046E:  CALL   3496
....................    RTC_read(); 
10472:  CALL   3328
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
10476:  CALL   F242
1047A:  MOVFF  02,8A8
1047E:  MOVFF  01,8A7
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
10482:  MOVLB  8
10484:  DECFSZ xA4,W
10486:  BRA    104B0
10488:  MOVLW  10
1048A:  MOVWF  FE9
1048C:  CLRF   1B
1048E:  BTFSC  FF2.7
10490:  BSF    1B.7
10492:  BCF    FF2.7
10494:  MOVFF  4AA,A1A
10498:  MOVFF  4A9,A19
1049C:  MOVLB  0
1049E:  CALL   11D0
104A2:  BTFSC  1B.7
104A4:  BSF    FF2.7
104A6:  MOVLW  2C
104A8:  BTFSS  F9E.4
104AA:  BRA    104A8
104AC:  MOVWF  FAD
104AE:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
104B0:  CLRF   1E
104B2:  MOVLW  67
104B4:  MOVWF  1D
104B6:  MOVFF  72A,8CB
104BA:  MOVLW  01
104BC:  MOVWF  xCC
104BE:  MOVLB  0
104C0:  CALL   525A
104C4:  MOVLW  2F
104C6:  MOVLB  8
104C8:  MOVWF  xDD
104CA:  MOVLB  0
104CC:  CALL   5078
104D0:  MOVFF  729,8CB
104D4:  MOVLW  01
104D6:  MOVLB  8
104D8:  MOVWF  xCC
104DA:  MOVLB  0
104DC:  CALL   525A
104E0:  MOVLW  2F
104E2:  MOVLB  8
104E4:  MOVWF  xDD
104E6:  MOVLB  0
104E8:  CALL   5078
104EC:  MOVFF  72B,8CB
104F0:  MOVLW  01
104F2:  MOVLB  8
104F4:  MOVWF  xCC
104F6:  MOVLB  0
104F8:  CALL   525A
104FC:  MOVLW  20
104FE:  MOVLB  8
10500:  MOVWF  xDD
10502:  MOVLB  0
10504:  CALL   5078
10508:  MOVFF  727,8CB
1050C:  MOVLW  01
1050E:  MOVLB  8
10510:  MOVWF  xCC
10512:  MOVLB  0
10514:  CALL   525A
10518:  MOVLW  3A
1051A:  MOVLB  8
1051C:  MOVWF  xDD
1051E:  MOVLB  0
10520:  CALL   5078
10524:  MOVFF  726,8CB
10528:  MOVLW  01
1052A:  MOVLB  8
1052C:  MOVWF  xCC
1052E:  MOVLB  0
10530:  CALL   525A
10534:  MOVLW  3A
10536:  MOVLB  8
10538:  MOVWF  xDD
1053A:  MOVLB  0
1053C:  CALL   5078
10540:  MOVFF  725,8CB
10544:  MOVLW  01
10546:  MOVLB  8
10548:  MOVWF  xCC
1054A:  MOVLB  0
1054C:  CALL   525A
10550:  MOVLW  2C
10552:  MOVLB  8
10554:  MOVWF  xDD
10556:  MOVLB  0
10558:  CALL   5078
1055C:  MOVLW  04
1055E:  MOVWF  FE9
10560:  MOVLB  8
10562:  CLRF   xCE
10564:  CLRF   xCD
10566:  MOVFF  8A6,8CC
1056A:  MOVFF  8A5,8CB
1056E:  MOVLW  02
10570:  MOVWF  xCF
10572:  MOVLB  0
10574:  CALL   52F4
10578:  MOVLW  2C
1057A:  MOVLB  8
1057C:  MOVWF  xDD
1057E:  MOVLB  0
10580:  CALL   5078
10584:  MOVFF  1E,FEA
10588:  MOVFF  1D,FE9
1058C:  CLRF   FEF
1058E:  MOVLW  03
10590:  MOVWF  FEA
10592:  MOVLW  3D
10594:  MOVWF  FE9
10596:  CALL   F916
1059A:  MOVLW  2C
1059C:  MOVLB  8
1059E:  MOVWF  xDD
105A0:  MOVLB  0
105A2:  CALL   5078
105A6:  MOVFF  1E,FEA
105AA:  MOVFF  1D,FE9
105AE:  CLRF   FEF
105B0:  MOVLW  03
105B2:  MOVWF  FEA
105B4:  MOVLW  42
105B6:  MOVWF  FE9
105B8:  CALL   F916
105BC:  MOVLW  2C
105BE:  MOVLB  8
105C0:  MOVWF  xDD
105C2:  MOVLB  0
105C4:  CALL   5078
105C8:  MOVFF  1E,FEA
105CC:  MOVFF  1D,FE9
105D0:  CLRF   FEF
105D2:  MOVLW  03
105D4:  MOVWF  FEA
105D6:  MOVLW  46
105D8:  MOVWF  FE9
105DA:  CALL   F916
105DE:  MOVLW  2C
105E0:  MOVLB  8
105E2:  MOVWF  xDD
105E4:  MOVLB  0
105E6:  CALL   5078
105EA:  MOVLW  10
105EC:  MOVWF  FE9
105EE:  MOVFF  26,8D5
105F2:  MOVFF  25,8D4
105F6:  CALL   AA9E
105FA:  MOVLW  2C
105FC:  MOVLB  8
105FE:  MOVWF  xDD
10600:  MOVLB  0
10602:  CALL   5078
10606:  MOVLW  10
10608:  MOVWF  FE9
1060A:  MOVFF  8A8,8D5
1060E:  MOVFF  8A7,8D4
10612:  CALL   AA9E
10616:  MOVLW  2C
10618:  MOVLB  8
1061A:  MOVWF  xDD
1061C:  MOVLB  0
1061E:  CALL   5078
10622:  MOVFF  4B5,8CB
10626:  MOVLW  1B
10628:  MOVLB  8
1062A:  MOVWF  xCC
1062C:  MOVLB  0
1062E:  CALL   525A
10632:  MOVLW  2C
10634:  MOVLB  8
10636:  MOVWF  xDD
10638:  MOVLB  0
1063A:  CALL   5078
1063E:  MOVLW  10
10640:  MOVWF  FE9
10642:  MOVFF  4A8,8D5
10646:  MOVFF  4A7,8D4
1064A:  CALL   AA9E
1064E:  MOVLW  2C
10650:  MOVLB  8
10652:  MOVWF  xDD
10654:  MOVLB  0
10656:  CALL   5078
1065A:  MOVLW  10
1065C:  MOVWF  FE9
1065E:  MOVFF  4AE,8D5
10662:  MOVFF  4AD,8D4
10666:  CALL   AA9E
1066A:  MOVLW  2C
1066C:  MOVLB  8
1066E:  MOVWF  xDD
10670:  MOVLB  0
10672:  CALL   5078
10676:  MOVLW  10
10678:  MOVWF  FE9
1067A:  MOVFF  4AC,8D5
1067E:  MOVFF  4AB,8D4
10682:  CALL   AA9E
10686:  MOVLW  0D
10688:  MOVLB  8
1068A:  MOVWF  xDD
1068C:  MOVLB  0
1068E:  CALL   5078
10692:  MOVLW  0A
10694:  MOVLB  8
10696:  MOVWF  xDD
10698:  MOVLB  0
1069A:  CALL   5078
....................  
....................    load_scanned_data();  
1069E:  BRA    10386
....................  
....................    display_rec(store, display); 
106A0:  MOVFF  8A2,8C9
106A4:  MOVFF  8A3,8CA
106A8:  CALL   F93C
....................     
....................    data_available = TRUE; 
106AC:  MOVLW  01
106AE:  MOVLB  3
106B0:  MOVWF  x3B
....................    macro_flag = 900; 
106B2:  MOVLW  03
106B4:  MOVWF  x24
106B6:  MOVLW  84
106B8:  MOVWF  x23
106BA:  MOVLB  0
106BC:  GOTO   106FE (RETURN)
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
....................    channel=channel-20000; 
....................     
....................    for (i=0; i<9; i++){ 
....................       DAC_set(channel, setting); 
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
....................       setting = setting+500; 
....................    } 
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
....................     
....................    for (i=0; i<9; i++){ 
....................       LED_SAR(intensity); 
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
....................       intensity = intensity+500; 
....................    } 
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
0309C:  MOVLB  8
0309E:  CLRF   x94
030A0:  MOVF   x94,W
030A2:  SUBLW  20
030A4:  BNC   30BA
030A6:  CLRF   03
030A8:  MOVF   x94,W
030AA:  ADDLW  B7
030AC:  MOVWF  FE9
030AE:  MOVLW  04
030B0:  ADDWFC 03,W
030B2:  MOVWF  FEA
030B4:  CLRF   FEF
030B6:  INCF   x94,F
030B8:  BRA    30A0
030BA:  MOVLB  0
030BC:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
030BE:  MOVF   2F,W
030C0:  SUBLW  02
030C2:  BNZ   30CC
030C4:  MOVF   30,F
030C6:  BNZ   30CC
030C8:  MOVLW  00
030CA:  MOVWF  F99
....................    init_valve_status(); 
030CC:  RCALL  309C
....................    bus_pwr_status=0; 
030CE:  MOVLB  4
030D0:  CLRF   xB6
030D2:  MOVLB  0
030D4:  GOTO   14B7A (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
115BE:  MOVLW  7A
115C0:  MOVWF  FF6
115C2:  MOVLW  1D
115C4:  MOVWF  FF7
115C6:  MOVLW  00
115C8:  MOVWF  FF8
115CA:  CLRF   1B
115CC:  BTFSC  FF2.7
115CE:  BSF    1B.7
115D0:  BCF    FF2.7
115D2:  CALL   0E78
115D6:  BTFSC  1B.7
115D8:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
115DA:  MOVLW  01
115DC:  MOVLB  8
115DE:  MOVWF  x94
115E0:  MOVF   x94,W
115E2:  SUBLW  08
115E4:  BNC   1164E
115E6:  CLRF   03
115E8:  MOVF   x94,W
115EA:  ADDLW  B7
115EC:  MOVWF  FE9
115EE:  MOVLW  04
115F0:  ADDWFC 03,W
115F2:  MOVWF  FEA
115F4:  MOVFF  FEF,895
115F8:  CLRF   1B
115FA:  BTFSC  FF2.7
115FC:  BSF    1B.7
115FE:  BCF    FF2.7
11600:  MOVFF  894,A19
11604:  MOVLW  01
11606:  MOVLB  A
11608:  MOVWF  x1A
1160A:  MOVLB  0
1160C:  CALL   0FD0
11610:  BTFSC  1B.7
11612:  BSF    FF2.7
11614:  MOVLW  5B
11616:  BTFSS  F9E.4
11618:  BRA    11616
1161A:  MOVWF  FAD
1161C:  CLRF   1B
1161E:  BTFSC  FF2.7
11620:  BSF    1B.7
11622:  BCF    FF2.7
11624:  MOVFF  895,A19
11628:  MOVLW  1B
1162A:  MOVLB  A
1162C:  MOVWF  x1A
1162E:  MOVLB  0
11630:  CALL   0FD0
11634:  BTFSC  1B.7
11636:  BSF    FF2.7
11638:  MOVLW  5D
1163A:  BTFSS  F9E.4
1163C:  BRA    1163A
1163E:  MOVWF  FAD
11640:  MOVLW  20
11642:  BTFSS  F9E.4
11644:  BRA    11642
11646:  MOVWF  FAD
11648:  MOVLB  8
1164A:  INCF   x94,F
1164C:  BRA    115E0
....................    fprintf(COM_A, "\r\n"); 
1164E:  MOVLW  0D
11650:  BTFSS  F9E.4
11652:  BRA    11650
11654:  MOVWF  FAD
11656:  MOVLW  0A
11658:  BTFSS  F9E.4
1165A:  BRA    11658
1165C:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
1165E:  MOVLW  80
11660:  MOVWF  FF6
11662:  MOVLW  1D
11664:  MOVWF  FF7
11666:  MOVLW  00
11668:  MOVWF  FF8
1166A:  CLRF   1B
1166C:  BTFSC  FF2.7
1166E:  BSF    1B.7
11670:  BCF    FF2.7
11672:  MOVLB  0
11674:  CALL   0E78
11678:  BTFSC  1B.7
1167A:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
1167C:  MOVLW  09
1167E:  MOVLB  8
11680:  MOVWF  x94
11682:  MOVF   x94,W
11684:  SUBLW  10
11686:  BNC   116F0
11688:  CLRF   03
1168A:  MOVF   x94,W
1168C:  ADDLW  B7
1168E:  MOVWF  FE9
11690:  MOVLW  04
11692:  ADDWFC 03,W
11694:  MOVWF  FEA
11696:  MOVFF  FEF,895
1169A:  CLRF   1B
1169C:  BTFSC  FF2.7
1169E:  BSF    1B.7
116A0:  BCF    FF2.7
116A2:  MOVFF  894,A19
116A6:  MOVLW  01
116A8:  MOVLB  A
116AA:  MOVWF  x1A
116AC:  MOVLB  0
116AE:  CALL   0FD0
116B2:  BTFSC  1B.7
116B4:  BSF    FF2.7
116B6:  MOVLW  5B
116B8:  BTFSS  F9E.4
116BA:  BRA    116B8
116BC:  MOVWF  FAD
116BE:  CLRF   1B
116C0:  BTFSC  FF2.7
116C2:  BSF    1B.7
116C4:  BCF    FF2.7
116C6:  MOVFF  895,A19
116CA:  MOVLW  1B
116CC:  MOVLB  A
116CE:  MOVWF  x1A
116D0:  MOVLB  0
116D2:  CALL   0FD0
116D6:  BTFSC  1B.7
116D8:  BSF    FF2.7
116DA:  MOVLW  5D
116DC:  BTFSS  F9E.4
116DE:  BRA    116DC
116E0:  MOVWF  FAD
116E2:  MOVLW  20
116E4:  BTFSS  F9E.4
116E6:  BRA    116E4
116E8:  MOVWF  FAD
116EA:  MOVLB  8
116EC:  INCF   x94,F
116EE:  BRA    11682
....................    fprintf(COM_A, "\r\n"); 
116F0:  MOVLW  0D
116F2:  BTFSS  F9E.4
116F4:  BRA    116F2
116F6:  MOVWF  FAD
116F8:  MOVLW  0A
116FA:  BTFSS  F9E.4
116FC:  BRA    116FA
116FE:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
11700:  MOVLW  86
11702:  MOVWF  FF6
11704:  MOVLW  1D
11706:  MOVWF  FF7
11708:  MOVLW  00
1170A:  MOVWF  FF8
1170C:  CLRF   1B
1170E:  BTFSC  FF2.7
11710:  BSF    1B.7
11712:  BCF    FF2.7
11714:  MOVLB  0
11716:  CALL   0E78
1171A:  BTFSC  1B.7
1171C:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
1171E:  MOVLW  11
11720:  MOVLB  8
11722:  MOVWF  x94
11724:  MOVF   x94,W
11726:  SUBLW  18
11728:  BNC   11792
1172A:  CLRF   03
1172C:  MOVF   x94,W
1172E:  ADDLW  B7
11730:  MOVWF  FE9
11732:  MOVLW  04
11734:  ADDWFC 03,W
11736:  MOVWF  FEA
11738:  MOVFF  FEF,895
1173C:  CLRF   1B
1173E:  BTFSC  FF2.7
11740:  BSF    1B.7
11742:  BCF    FF2.7
11744:  MOVFF  894,A19
11748:  MOVLW  01
1174A:  MOVLB  A
1174C:  MOVWF  x1A
1174E:  MOVLB  0
11750:  CALL   0FD0
11754:  BTFSC  1B.7
11756:  BSF    FF2.7
11758:  MOVLW  5B
1175A:  BTFSS  F9E.4
1175C:  BRA    1175A
1175E:  MOVWF  FAD
11760:  CLRF   1B
11762:  BTFSC  FF2.7
11764:  BSF    1B.7
11766:  BCF    FF2.7
11768:  MOVFF  895,A19
1176C:  MOVLW  1B
1176E:  MOVLB  A
11770:  MOVWF  x1A
11772:  MOVLB  0
11774:  CALL   0FD0
11778:  BTFSC  1B.7
1177A:  BSF    FF2.7
1177C:  MOVLW  5D
1177E:  BTFSS  F9E.4
11780:  BRA    1177E
11782:  MOVWF  FAD
11784:  MOVLW  20
11786:  BTFSS  F9E.4
11788:  BRA    11786
1178A:  MOVWF  FAD
1178C:  MOVLB  8
1178E:  INCF   x94,F
11790:  BRA    11724
....................    fprintf(COM_A, "\r\n"); 
11792:  MOVLW  0D
11794:  BTFSS  F9E.4
11796:  BRA    11794
11798:  MOVWF  FAD
1179A:  MOVLW  0A
1179C:  BTFSS  F9E.4
1179E:  BRA    1179C
117A0:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
117A2:  MOVLW  8C
117A4:  MOVWF  FF6
117A6:  MOVLW  1D
117A8:  MOVWF  FF7
117AA:  MOVLW  00
117AC:  MOVWF  FF8
117AE:  CLRF   1B
117B0:  BTFSC  FF2.7
117B2:  BSF    1B.7
117B4:  BCF    FF2.7
117B6:  MOVLB  0
117B8:  CALL   0E78
117BC:  BTFSC  1B.7
117BE:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
117C0:  MOVLW  19
117C2:  MOVLB  8
117C4:  MOVWF  x94
117C6:  MOVF   x94,W
117C8:  SUBLW  20
117CA:  BNC   11834
117CC:  CLRF   03
117CE:  MOVF   x94,W
117D0:  ADDLW  B7
117D2:  MOVWF  FE9
117D4:  MOVLW  04
117D6:  ADDWFC 03,W
117D8:  MOVWF  FEA
117DA:  MOVFF  FEF,895
117DE:  CLRF   1B
117E0:  BTFSC  FF2.7
117E2:  BSF    1B.7
117E4:  BCF    FF2.7
117E6:  MOVFF  894,A19
117EA:  MOVLW  01
117EC:  MOVLB  A
117EE:  MOVWF  x1A
117F0:  MOVLB  0
117F2:  CALL   0FD0
117F6:  BTFSC  1B.7
117F8:  BSF    FF2.7
117FA:  MOVLW  5B
117FC:  BTFSS  F9E.4
117FE:  BRA    117FC
11800:  MOVWF  FAD
11802:  CLRF   1B
11804:  BTFSC  FF2.7
11806:  BSF    1B.7
11808:  BCF    FF2.7
1180A:  MOVFF  895,A19
1180E:  MOVLW  1B
11810:  MOVLB  A
11812:  MOVWF  x1A
11814:  MOVLB  0
11816:  CALL   0FD0
1181A:  BTFSC  1B.7
1181C:  BSF    FF2.7
1181E:  MOVLW  5D
11820:  BTFSS  F9E.4
11822:  BRA    11820
11824:  MOVWF  FAD
11826:  MOVLW  20
11828:  BTFSS  F9E.4
1182A:  BRA    11828
1182C:  MOVWF  FAD
1182E:  MOVLB  8
11830:  INCF   x94,F
11832:  BRA    117C6
....................    fprintf(COM_A, "\r\n");    
11834:  MOVLW  0D
11836:  BTFSS  F9E.4
11838:  BRA    11836
1183A:  MOVWF  FAD
1183C:  MOVLW  0A
1183E:  BTFSS  F9E.4
11840:  BRA    1183E
11842:  MOVWF  FAD
11844:  MOVLB  0
11846:  GOTO   11C2A (RETURN)
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
1150A:  MOVF   1F,W
1150C:  SUBLW  04
1150E:  BNZ   11578
11510:  MOVF   20,F
11512:  BNZ   11578
11514:  MOVLW  92
11516:  MOVWF  FF6
11518:  MOVLW  1D
1151A:  MOVWF  FF7
1151C:  MOVLW  00
1151E:  MOVWF  FF8
11520:  CLRF   1B
11522:  BTFSC  FF2.7
11524:  BSF    1B.7
11526:  BCF    FF2.7
11528:  MOVLW  0C
1152A:  MOVLB  A
1152C:  MOVWF  x19
1152E:  MOVLB  0
11530:  CALL   104E
11534:  BTFSC  1B.7
11536:  BSF    FF2.7
11538:  MOVLW  10
1153A:  MOVWF  FE9
1153C:  CLRF   1B
1153E:  BTFSC  FF2.7
11540:  BSF    1B.7
11542:  BCF    FF2.7
11544:  MOVFF  895,A1A
11548:  MOVFF  894,A19
1154C:  CALL   11D0
11550:  BTFSC  1B.7
11552:  BSF    FF2.7
11554:  MOVLW  A1
11556:  MOVWF  FF6
11558:  MOVLW  1D
1155A:  MOVWF  FF7
1155C:  MOVLW  00
1155E:  MOVWF  FF8
11560:  CLRF   1B
11562:  BTFSC  FF2.7
11564:  BSF    1B.7
11566:  BCF    FF2.7
11568:  MOVLW  03
1156A:  MOVLB  A
1156C:  MOVWF  x19
1156E:  MOVLB  0
11570:  CALL   104E
11574:  BTFSC  1B.7
11576:  BSF    FF2.7
....................  
....................    multidrop_on(); 
11578:  CALL   E536
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
1157C:  MOVLW  A6
1157E:  MOVWF  FF6
11580:  MOVLW  1D
11582:  MOVWF  FF7
11584:  MOVLW  00
11586:  MOVWF  FF8
11588:  MOVLW  03
1158A:  MOVLB  8
1158C:  MOVWF  x96
1158E:  MOVLB  0
11590:  RCALL  11314
11592:  MOVLW  10
11594:  MOVWF  FE9
11596:  MOVFF  895,897
1159A:  MOVFF  894,896
1159E:  BRA    11450
115A0:  MOVLW  0D
115A2:  BTFSS  FA4.4
115A4:  BRA    115A2
115A6:  MOVLB  F
115A8:  MOVWF  x1C
....................    multidrop_off(); 
115AA:  MOVLB  0
115AC:  CALL   E6CE
....................  
....................    delay_ms(100); 
115B0:  MOVLW  64
115B2:  MOVLB  A
115B4:  MOVWF  xA2
115B6:  MOVLB  0
115B8:  CALL   0588
115BC:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
11378:  MOVF   1F,W
1137A:  SUBLW  04
1137C:  BNZ   113E6
1137E:  MOVF   20,F
11380:  BNZ   113E6
11382:  MOVLW  AE
11384:  MOVWF  FF6
11386:  MOVLW  1D
11388:  MOVWF  FF7
1138A:  MOVLW  00
1138C:  MOVWF  FF8
1138E:  CLRF   1B
11390:  BTFSC  FF2.7
11392:  BSF    1B.7
11394:  BCF    FF2.7
11396:  MOVLW  0C
11398:  MOVLB  A
1139A:  MOVWF  x19
1139C:  MOVLB  0
1139E:  CALL   104E
113A2:  BTFSC  1B.7
113A4:  BSF    FF2.7
113A6:  CLRF   1B
113A8:  BTFSC  FF2.7
113AA:  BSF    1B.7
113AC:  BCF    FF2.7
113AE:  MOVFF  894,A19
113B2:  MOVLW  1B
113B4:  MOVLB  A
113B6:  MOVWF  x1A
113B8:  MOVLB  0
113BA:  CALL   0FD0
113BE:  BTFSC  1B.7
113C0:  BSF    FF2.7
113C2:  MOVLW  BC
113C4:  MOVWF  FF6
113C6:  MOVLW  1D
113C8:  MOVWF  FF7
113CA:  MOVLW  00
113CC:  MOVWF  FF8
113CE:  CLRF   1B
113D0:  BTFSC  FF2.7
113D2:  BSF    1B.7
113D4:  BCF    FF2.7
113D6:  MOVLW  03
113D8:  MOVLB  A
113DA:  MOVWF  x19
113DC:  MOVLB  0
113DE:  CALL   104E
113E2:  BTFSC  1B.7
113E4:  BSF    FF2.7
....................     
....................    multidrop_on(); 
113E6:  CALL   E536
....................       fprintf(COM_B, "/1c%u\r",chip); 
113EA:  MOVLW  C0
113EC:  MOVWF  FF6
113EE:  MOVLW  1D
113F0:  MOVWF  FF7
113F2:  MOVLW  00
113F4:  MOVWF  FF8
113F6:  MOVLW  03
113F8:  MOVLB  8
113FA:  MOVWF  x96
113FC:  MOVLB  0
113FE:  RCALL  11314
11400:  MOVFF  894,8D1
11404:  MOVLW  1B
11406:  MOVLB  8
11408:  MOVWF  xD2
1140A:  MOVLB  0
1140C:  CALL   E54A
11410:  MOVLW  0D
11412:  BTFSS  FA4.4
11414:  BRA    11412
11416:  MOVLB  F
11418:  MOVWF  x1C
....................    multidrop_off(); 
1141A:  MOVLB  0
1141C:  CALL   E6CE
....................    delay_ms(100); 
11420:  MOVLW  64
11422:  MOVLB  A
11424:  MOVWF  xA2
11426:  MOVLB  0
11428:  CALL   0588
....................  
....................    multidrop_on(); 
1142C:  CALL   E536
....................      fprintf(COM_B, "/1s256\r"); 
11430:  MOVLW  C8
11432:  MOVWF  FF6
11434:  MOVLW  1D
11436:  MOVWF  FF7
11438:  MOVLW  00
1143A:  MOVWF  FF8
1143C:  BRA    11348
....................    multidrop_off();  
1143E:  CALL   E6CE
....................    delay_ms(100); 
11442:  MOVLW  64
11444:  MOVLB  A
11446:  MOVWF  xA2
11448:  MOVLB  0
1144A:  CALL   0588
1144E:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
1184A:  MOVLB  8
1184C:  MOVF   x93,W
1184E:  ADDLW  DF
11850:  BTFSC  FD8.0
11852:  BRA    11C00
11854:  ADDLW  21
11856:  MOVLB  0
11858:  GOTO   11C30
....................       case 0 : sol_chip_cmd(1); 
1185C:  MOVLW  01
1185E:  MOVLB  8
11860:  MOVWF  x94
11862:  MOVLB  0
11864:  RCALL  11378
....................                sol_switch_cmd(0); 
11866:  MOVLB  8
11868:  CLRF   x95
1186A:  CLRF   x94
1186C:  MOVLB  0
1186E:  RCALL  1150A
....................                sol_chip_cmd(2); 
11870:  MOVLW  02
11872:  MOVLB  8
11874:  MOVWF  x94
11876:  MOVLB  0
11878:  RCALL  11378
....................                sol_switch_cmd(0); 
1187A:  MOVLB  8
1187C:  CLRF   x95
1187E:  CLRF   x94
11880:  MOVLB  0
11882:  RCALL  1150A
....................                sol_chip_cmd(3); 
11884:  MOVLW  03
11886:  MOVLB  8
11888:  MOVWF  x94
1188A:  MOVLB  0
1188C:  RCALL  11378
....................                sol_switch_cmd(0); 
1188E:  MOVLB  8
11890:  CLRF   x95
11892:  CLRF   x94
11894:  MOVLB  0
11896:  RCALL  1150A
....................                sol_chip_cmd(4); 
11898:  MOVLW  04
1189A:  MOVLB  8
1189C:  MOVWF  x94
1189E:  MOVLB  0
118A0:  RCALL  11378
....................                sol_switch_cmd(0); 
118A2:  MOVLB  8
118A4:  CLRF   x95
118A6:  CLRF   x94
118A8:  MOVLB  0
118AA:  RCALL  1150A
....................                init_valve_status(); 
118AC:  CALL   309C
....................          break; 
118B0:  MOVLB  8
118B2:  BRA    11C00
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
118B4:  MOVLW  01
118B6:  MOVLB  8
118B8:  MOVWF  x94
118BA:  MOVLB  0
118BC:  RCALL  11378
....................                sol_switch_cmd(1); 
118BE:  MOVLB  8
118C0:  CLRF   x95
118C2:  MOVLW  01
118C4:  MOVWF  x94
118C6:  MOVLB  0
118C8:  RCALL  1150A
....................          break;     
118CA:  MOVLB  8
118CC:  BRA    11C00
....................       case 2 : sol_chip_cmd(1); 
118CE:  MOVLW  01
118D0:  MOVLB  8
118D2:  MOVWF  x94
118D4:  MOVLB  0
118D6:  RCALL  11378
....................                sol_switch_cmd(2); 
118D8:  MOVLB  8
118DA:  CLRF   x95
118DC:  MOVLW  02
118DE:  MOVWF  x94
118E0:  MOVLB  0
118E2:  RCALL  1150A
....................          break;           
118E4:  MOVLB  8
118E6:  BRA    11C00
....................       case 3 : sol_chip_cmd(1); 
118E8:  MOVLW  01
118EA:  MOVLB  8
118EC:  MOVWF  x94
118EE:  MOVLB  0
118F0:  RCALL  11378
....................                sol_switch_cmd(4); 
118F2:  MOVLB  8
118F4:  CLRF   x95
118F6:  MOVLW  04
118F8:  MOVWF  x94
118FA:  MOVLB  0
118FC:  RCALL  1150A
....................          break;  
118FE:  MOVLB  8
11900:  BRA    11C00
....................       case 4 : sol_chip_cmd(1); 
11902:  MOVLW  01
11904:  MOVLB  8
11906:  MOVWF  x94
11908:  MOVLB  0
1190A:  RCALL  11378
....................                sol_switch_cmd(8); 
1190C:  MOVLB  8
1190E:  CLRF   x95
11910:  MOVLW  08
11912:  MOVWF  x94
11914:  MOVLB  0
11916:  RCALL  1150A
....................          break;  
11918:  MOVLB  8
1191A:  BRA    11C00
....................       case 5 : sol_chip_cmd(1); 
1191C:  MOVLW  01
1191E:  MOVLB  8
11920:  MOVWF  x94
11922:  MOVLB  0
11924:  RCALL  11378
....................                sol_switch_cmd(16); 
11926:  MOVLB  8
11928:  CLRF   x95
1192A:  MOVLW  10
1192C:  MOVWF  x94
1192E:  MOVLB  0
11930:  RCALL  1150A
....................          break;  
11932:  MOVLB  8
11934:  BRA    11C00
....................       case 6 : sol_chip_cmd(1); 
11936:  MOVLW  01
11938:  MOVLB  8
1193A:  MOVWF  x94
1193C:  MOVLB  0
1193E:  RCALL  11378
....................                sol_switch_cmd(32); 
11940:  MOVLB  8
11942:  CLRF   x95
11944:  MOVLW  20
11946:  MOVWF  x94
11948:  MOVLB  0
1194A:  RCALL  1150A
....................          break;  
1194C:  MOVLB  8
1194E:  BRA    11C00
....................       case 7 : sol_chip_cmd(1); 
11950:  MOVLW  01
11952:  MOVLB  8
11954:  MOVWF  x94
11956:  MOVLB  0
11958:  RCALL  11378
....................                sol_switch_cmd(64); 
1195A:  MOVLB  8
1195C:  CLRF   x95
1195E:  MOVLW  40
11960:  MOVWF  x94
11962:  MOVLB  0
11964:  RCALL  1150A
....................          break;  
11966:  MOVLB  8
11968:  BRA    11C00
....................       case 8 : sol_chip_cmd(1); 
1196A:  MOVLW  01
1196C:  MOVLB  8
1196E:  MOVWF  x94
11970:  MOVLB  0
11972:  RCALL  11378
....................                sol_switch_cmd(128); 
11974:  MOVLB  8
11976:  CLRF   x95
11978:  MOVLW  80
1197A:  MOVWF  x94
1197C:  MOVLB  0
1197E:  RCALL  1150A
....................          break;   
11980:  MOVLB  8
11982:  BRA    11C00
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
11984:  MOVLW  02
11986:  MOVLB  8
11988:  MOVWF  x94
1198A:  MOVLB  0
1198C:  RCALL  11378
....................                sol_switch_cmd(1); 
1198E:  MOVLB  8
11990:  CLRF   x95
11992:  MOVLW  01
11994:  MOVWF  x94
11996:  MOVLB  0
11998:  RCALL  1150A
....................          break;     
1199A:  MOVLB  8
1199C:  BRA    11C00
....................       case 10 : sol_chip_cmd(2); 
1199E:  MOVLW  02
119A0:  MOVLB  8
119A2:  MOVWF  x94
119A4:  MOVLB  0
119A6:  RCALL  11378
....................                sol_switch_cmd(2); 
119A8:  MOVLB  8
119AA:  CLRF   x95
119AC:  MOVLW  02
119AE:  MOVWF  x94
119B0:  MOVLB  0
119B2:  RCALL  1150A
....................          break;           
119B4:  MOVLB  8
119B6:  BRA    11C00
....................       case 11 : sol_chip_cmd(2); 
119B8:  MOVLW  02
119BA:  MOVLB  8
119BC:  MOVWF  x94
119BE:  MOVLB  0
119C0:  RCALL  11378
....................                sol_switch_cmd(4); 
119C2:  MOVLB  8
119C4:  CLRF   x95
119C6:  MOVLW  04
119C8:  MOVWF  x94
119CA:  MOVLB  0
119CC:  RCALL  1150A
....................          break;  
119CE:  MOVLB  8
119D0:  BRA    11C00
....................       case 12 : sol_chip_cmd(2); 
119D2:  MOVLW  02
119D4:  MOVLB  8
119D6:  MOVWF  x94
119D8:  MOVLB  0
119DA:  RCALL  11378
....................                sol_switch_cmd(8); 
119DC:  MOVLB  8
119DE:  CLRF   x95
119E0:  MOVLW  08
119E2:  MOVWF  x94
119E4:  MOVLB  0
119E6:  RCALL  1150A
....................          break;  
119E8:  MOVLB  8
119EA:  BRA    11C00
....................       case 13 : sol_chip_cmd(2); 
119EC:  MOVLW  02
119EE:  MOVLB  8
119F0:  MOVWF  x94
119F2:  MOVLB  0
119F4:  RCALL  11378
....................                sol_switch_cmd(16); 
119F6:  MOVLB  8
119F8:  CLRF   x95
119FA:  MOVLW  10
119FC:  MOVWF  x94
119FE:  MOVLB  0
11A00:  RCALL  1150A
....................          break;  
11A02:  MOVLB  8
11A04:  BRA    11C00
....................       case 14 : sol_chip_cmd(2); 
11A06:  MOVLW  02
11A08:  MOVLB  8
11A0A:  MOVWF  x94
11A0C:  MOVLB  0
11A0E:  RCALL  11378
....................                sol_switch_cmd(32); 
11A10:  MOVLB  8
11A12:  CLRF   x95
11A14:  MOVLW  20
11A16:  MOVWF  x94
11A18:  MOVLB  0
11A1A:  RCALL  1150A
....................          break;  
11A1C:  MOVLB  8
11A1E:  BRA    11C00
....................       case 15 : sol_chip_cmd(2); 
11A20:  MOVLW  02
11A22:  MOVLB  8
11A24:  MOVWF  x94
11A26:  MOVLB  0
11A28:  RCALL  11378
....................                sol_switch_cmd(64); 
11A2A:  MOVLB  8
11A2C:  CLRF   x95
11A2E:  MOVLW  40
11A30:  MOVWF  x94
11A32:  MOVLB  0
11A34:  RCALL  1150A
....................          break;  
11A36:  MOVLB  8
11A38:  BRA    11C00
....................       case 16 : sol_chip_cmd(2); 
11A3A:  MOVLW  02
11A3C:  MOVLB  8
11A3E:  MOVWF  x94
11A40:  MOVLB  0
11A42:  RCALL  11378
....................                sol_switch_cmd(128); 
11A44:  MOVLB  8
11A46:  CLRF   x95
11A48:  MOVLW  80
11A4A:  MOVWF  x94
11A4C:  MOVLB  0
11A4E:  RCALL  1150A
....................          break;   
11A50:  MOVLB  8
11A52:  BRA    11C00
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
11A54:  MOVLW  03
11A56:  MOVLB  8
11A58:  MOVWF  x94
11A5A:  MOVLB  0
11A5C:  RCALL  11378
....................                sol_switch_cmd(1); 
11A5E:  MOVLB  8
11A60:  CLRF   x95
11A62:  MOVLW  01
11A64:  MOVWF  x94
11A66:  MOVLB  0
11A68:  RCALL  1150A
....................          break;     
11A6A:  MOVLB  8
11A6C:  BRA    11C00
....................       case 18 : sol_chip_cmd(3); 
11A6E:  MOVLW  03
11A70:  MOVLB  8
11A72:  MOVWF  x94
11A74:  MOVLB  0
11A76:  RCALL  11378
....................                sol_switch_cmd(2); 
11A78:  MOVLB  8
11A7A:  CLRF   x95
11A7C:  MOVLW  02
11A7E:  MOVWF  x94
11A80:  MOVLB  0
11A82:  RCALL  1150A
....................          break;           
11A84:  MOVLB  8
11A86:  BRA    11C00
....................       case 19 : sol_chip_cmd(3); 
11A88:  MOVLW  03
11A8A:  MOVLB  8
11A8C:  MOVWF  x94
11A8E:  MOVLB  0
11A90:  RCALL  11378
....................                sol_switch_cmd(4); 
11A92:  MOVLB  8
11A94:  CLRF   x95
11A96:  MOVLW  04
11A98:  MOVWF  x94
11A9A:  MOVLB  0
11A9C:  RCALL  1150A
....................          break;  
11A9E:  MOVLB  8
11AA0:  BRA    11C00
....................       case 20 : sol_chip_cmd(3); 
11AA2:  MOVLW  03
11AA4:  MOVLB  8
11AA6:  MOVWF  x94
11AA8:  MOVLB  0
11AAA:  RCALL  11378
....................                sol_switch_cmd(8); 
11AAC:  MOVLB  8
11AAE:  CLRF   x95
11AB0:  MOVLW  08
11AB2:  MOVWF  x94
11AB4:  MOVLB  0
11AB6:  RCALL  1150A
....................          break;  
11AB8:  MOVLB  8
11ABA:  BRA    11C00
....................       case 21 : sol_chip_cmd(3); 
11ABC:  MOVLW  03
11ABE:  MOVLB  8
11AC0:  MOVWF  x94
11AC2:  MOVLB  0
11AC4:  RCALL  11378
....................                sol_switch_cmd(16); 
11AC6:  MOVLB  8
11AC8:  CLRF   x95
11ACA:  MOVLW  10
11ACC:  MOVWF  x94
11ACE:  MOVLB  0
11AD0:  RCALL  1150A
....................          break;  
11AD2:  MOVLB  8
11AD4:  BRA    11C00
....................       case 22 : sol_chip_cmd(3); 
11AD6:  MOVLW  03
11AD8:  MOVLB  8
11ADA:  MOVWF  x94
11ADC:  MOVLB  0
11ADE:  RCALL  11378
....................                sol_switch_cmd(32); 
11AE0:  MOVLB  8
11AE2:  CLRF   x95
11AE4:  MOVLW  20
11AE6:  MOVWF  x94
11AE8:  MOVLB  0
11AEA:  RCALL  1150A
....................          break;  
11AEC:  MOVLB  8
11AEE:  BRA    11C00
....................       case 23 : sol_chip_cmd(3); 
11AF0:  MOVLW  03
11AF2:  MOVLB  8
11AF4:  MOVWF  x94
11AF6:  MOVLB  0
11AF8:  RCALL  11378
....................                sol_switch_cmd(64); 
11AFA:  MOVLB  8
11AFC:  CLRF   x95
11AFE:  MOVLW  40
11B00:  MOVWF  x94
11B02:  MOVLB  0
11B04:  RCALL  1150A
....................          break;  
11B06:  MOVLB  8
11B08:  BRA    11C00
....................       case 24 : sol_chip_cmd(3); 
11B0A:  MOVLW  03
11B0C:  MOVLB  8
11B0E:  MOVWF  x94
11B10:  MOVLB  0
11B12:  RCALL  11378
....................                sol_switch_cmd(128); 
11B14:  MOVLB  8
11B16:  CLRF   x95
11B18:  MOVLW  80
11B1A:  MOVWF  x94
11B1C:  MOVLB  0
11B1E:  RCALL  1150A
....................          break;      
11B20:  MOVLB  8
11B22:  BRA    11C00
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
11B24:  MOVLW  04
11B26:  MOVLB  8
11B28:  MOVWF  x94
11B2A:  MOVLB  0
11B2C:  RCALL  11378
....................                sol_switch_cmd(1); 
11B2E:  MOVLB  8
11B30:  CLRF   x95
11B32:  MOVLW  01
11B34:  MOVWF  x94
11B36:  MOVLB  0
11B38:  RCALL  1150A
....................          break;     
11B3A:  MOVLB  8
11B3C:  BRA    11C00
....................       case 26 : sol_chip_cmd(4); 
11B3E:  MOVLW  04
11B40:  MOVLB  8
11B42:  MOVWF  x94
11B44:  MOVLB  0
11B46:  RCALL  11378
....................                sol_switch_cmd(2); 
11B48:  MOVLB  8
11B4A:  CLRF   x95
11B4C:  MOVLW  02
11B4E:  MOVWF  x94
11B50:  MOVLB  0
11B52:  RCALL  1150A
....................          break;           
11B54:  MOVLB  8
11B56:  BRA    11C00
....................       case 27 : sol_chip_cmd(4); 
11B58:  MOVLW  04
11B5A:  MOVLB  8
11B5C:  MOVWF  x94
11B5E:  MOVLB  0
11B60:  RCALL  11378
....................                sol_switch_cmd(4); 
11B62:  MOVLB  8
11B64:  CLRF   x95
11B66:  MOVLW  04
11B68:  MOVWF  x94
11B6A:  MOVLB  0
11B6C:  RCALL  1150A
....................          break;  
11B6E:  MOVLB  8
11B70:  BRA    11C00
....................       case 28 : sol_chip_cmd(4); 
11B72:  MOVLW  04
11B74:  MOVLB  8
11B76:  MOVWF  x94
11B78:  MOVLB  0
11B7A:  CALL   11378
....................                sol_switch_cmd(8); 
11B7E:  MOVLB  8
11B80:  CLRF   x95
11B82:  MOVLW  08
11B84:  MOVWF  x94
11B86:  MOVLB  0
11B88:  RCALL  1150A
....................          break;  
11B8A:  MOVLB  8
11B8C:  BRA    11C00
....................       case 29 : sol_chip_cmd(4); 
11B8E:  MOVLW  04
11B90:  MOVLB  8
11B92:  MOVWF  x94
11B94:  MOVLB  0
11B96:  CALL   11378
....................                sol_switch_cmd(16); 
11B9A:  MOVLB  8
11B9C:  CLRF   x95
11B9E:  MOVLW  10
11BA0:  MOVWF  x94
11BA2:  MOVLB  0
11BA4:  RCALL  1150A
....................          break;  
11BA6:  MOVLB  8
11BA8:  BRA    11C00
....................       case 30 : sol_chip_cmd(4); 
11BAA:  MOVLW  04
11BAC:  MOVLB  8
11BAE:  MOVWF  x94
11BB0:  MOVLB  0
11BB2:  CALL   11378
....................                sol_switch_cmd(32); 
11BB6:  MOVLB  8
11BB8:  CLRF   x95
11BBA:  MOVLW  20
11BBC:  MOVWF  x94
11BBE:  MOVLB  0
11BC0:  RCALL  1150A
....................          break;  
11BC2:  MOVLB  8
11BC4:  BRA    11C00
....................       case 31 : sol_chip_cmd(4); 
11BC6:  MOVLW  04
11BC8:  MOVLB  8
11BCA:  MOVWF  x94
11BCC:  MOVLB  0
11BCE:  CALL   11378
....................                sol_switch_cmd(64); 
11BD2:  MOVLB  8
11BD4:  CLRF   x95
11BD6:  MOVLW  40
11BD8:  MOVWF  x94
11BDA:  MOVLB  0
11BDC:  RCALL  1150A
....................          break;  
11BDE:  MOVLB  8
11BE0:  BRA    11C00
....................       case 32 : sol_chip_cmd(4); 
11BE2:  MOVLW  04
11BE4:  MOVLB  8
11BE6:  MOVWF  x94
11BE8:  MOVLB  0
11BEA:  CALL   11378
....................                sol_switch_cmd(128); 
11BEE:  MOVLB  8
11BF0:  CLRF   x95
11BF2:  MOVLW  80
11BF4:  MOVWF  x94
11BF6:  MOVLB  0
11BF8:  RCALL  1150A
....................          break; 
11BFA:  MOVLB  8
11BFC:  BRA    11C00
11BFE:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
11C00:  MOVF   x93,F
11C02:  BZ    11C1C
11C04:  MOVF   x93,W
11C06:  SUBLW  20
11C08:  BNC   11C1C
11C0A:  CLRF   03
11C0C:  MOVF   x93,W
11C0E:  ADDLW  B7
11C10:  MOVWF  FE9
11C12:  MOVLW  04
11C14:  ADDWFC 03,W
11C16:  MOVWF  FEA
11C18:  MOVLW  01
11C1A:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
11C1C:  MOVF   1F,W
11C1E:  SUBLW  04
11C20:  BNZ   11C2C
11C22:  MOVF   20,F
11C24:  BNZ   11C2C
11C26:  MOVLB  0
11C28:  BRA    115BE
11C2A:  MOVLB  8
11C2C:  MOVLB  0
11C2E:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
0BD02:  MOVLB  8
0BD04:  CLRF   x7B
0BD06:  MOVF   x7B,W
0BD08:  SUBLW  07
0BD0A:  BNC   BD26
0BD0C:  BCF    FD8.0
0BD0E:  RLCF   x7B,W
0BD10:  CLRF   03
0BD12:  ADDLW  4B
0BD14:  MOVWF  FE9
0BD16:  MOVLW  03
0BD18:  ADDWFC 03,W
0BD1A:  MOVWF  FEA
0BD1C:  CLRF   FEC
0BD1E:  MOVF   FED,F
0BD20:  CLRF   FEF
0BD22:  INCF   x7B,F
0BD24:  BRA    BD06
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
0BD26:  CLRF   x7B
0BD28:  MOVF   x7B,W
0BD2A:  SUBLW  07
0BD2C:  BNC   BD48
0BD2E:  BCF    FD8.0
0BD30:  RLCF   x7B,W
0BD32:  CLRF   03
0BD34:  ADDLW  5D
0BD36:  MOVWF  FE9
0BD38:  MOVLW  03
0BD3A:  ADDWFC 03,W
0BD3C:  MOVWF  FEA
0BD3E:  CLRF   FEC
0BD40:  MOVF   FED,F
0BD42:  CLRF   FEF
0BD44:  INCF   x7B,F
0BD46:  BRA    BD28
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
0BD48:  CLRF   x7B
0BD4A:  MOVF   x7B,W
0BD4C:  SUBLW  07
0BD4E:  BNC   BD6A
0BD50:  BCF    FD8.0
0BD52:  RLCF   x7B,W
0BD54:  CLRF   03
0BD56:  ADDLW  6F
0BD58:  MOVWF  FE9
0BD5A:  MOVLW  03
0BD5C:  ADDWFC 03,W
0BD5E:  MOVWF  FEA
0BD60:  CLRF   FEC
0BD62:  MOVF   FED,F
0BD64:  CLRF   FEF
0BD66:  INCF   x7B,F
0BD68:  BRA    BD4A
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
0BD6A:  CLRF   x7B
0BD6C:  MOVF   x7B,W
0BD6E:  SUBLW  07
0BD70:  BNC   BD8C
0BD72:  BCF    FD8.0
0BD74:  RLCF   x7B,W
0BD76:  CLRF   03
0BD78:  ADDLW  81
0BD7A:  MOVWF  FE9
0BD7C:  MOVLW  03
0BD7E:  ADDWFC 03,W
0BD80:  MOVWF  FEA
0BD82:  CLRF   FEC
0BD84:  MOVF   FED,F
0BD86:  CLRF   FEF
0BD88:  INCF   x7B,F
0BD8A:  BRA    BD6C
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
0BD8C:  CLRF   x7B
0BD8E:  MOVF   x7B,W
0BD90:  SUBLW  07
0BD92:  BNC   BDAE
0BD94:  BCF    FD8.0
0BD96:  RLCF   x7B,W
0BD98:  CLRF   03
0BD9A:  ADDLW  93
0BD9C:  MOVWF  FE9
0BD9E:  MOVLW  03
0BDA0:  ADDWFC 03,W
0BDA2:  MOVWF  FEA
0BDA4:  CLRF   FEC
0BDA6:  MOVF   FED,F
0BDA8:  CLRF   FEF
0BDAA:  INCF   x7B,F
0BDAC:  BRA    BD8E
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
0BDAE:  MOVLW  04
0BDB0:  MOVWF  FEA
0BDB2:  MOVLW  25
0BDB4:  MOVWF  FE9
0BDB6:  CLRF   00
0BDB8:  CLRF   02
0BDBA:  MOVLW  44
0BDBC:  MOVWF  01
0BDBE:  MOVLB  0
0BDC0:  CALL   350A
0BDC4:  GOTO   12936 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
0CC36:  MOVLB  8
0CC38:  CLRF   xA0
0CC3A:  MOVF   xA0,W
0CC3C:  SUBLW  03
0CC3E:  BNC   CC5E
0CC40:  MOVF   xA0,W
0CC42:  MULLW  04
0CC44:  MOVF   FF3,W
0CC46:  CLRF   03
0CC48:  ADDLW  A5
0CC4A:  MOVWF  FE9
0CC4C:  MOVLW  03
0CC4E:  ADDWFC 03,W
0CC50:  MOVWF  FEA
0CC52:  CLRF   FEF
0CC54:  CLRF   FEC
0CC56:  CLRF   FEC
0CC58:  CLRF   FEC
0CC5A:  INCF   xA0,F
0CC5C:  BRA    CC3A
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
0CC5E:  MOVLB  3
0CC60:  MOVF   x4B,F
0CC62:  BTFSS  FD8.2
0CC64:  BRA    CC6A
0CC66:  MOVF   x4C,F
0CC68:  BZ    CD04
0CC6A:  MOVF   x4D,F
0CC6C:  BNZ   CC72
0CC6E:  MOVF   x4E,F
0CC70:  BZ    CD04
....................       blank = NO3_array[0]; 
0CC72:  MOVFF  34C,8F6
0CC76:  MOVFF  34B,8F5
0CC7A:  MOVLB  0
0CC7C:  CALL   BFAE
0CC80:  MOVFF  03,8A4
0CC84:  MOVFF  02,8A3
0CC88:  MOVFF  01,8A2
0CC8C:  MOVFF  00,8A1
....................       react = NO3_array[1]; 
0CC90:  MOVFF  34E,8F6
0CC94:  MOVFF  34D,8F5
0CC98:  CALL   BFAE
0CC9C:  MOVFF  03,8A8
0CCA0:  MOVFF  02,8A7
0CCA4:  MOVFF  01,8A6
0CCA8:  MOVFF  00,8A5
....................       ratio = blank / react; 
0CCAC:  MOVFF  8A4,8DC
0CCB0:  MOVFF  8A3,8DB
0CCB4:  MOVFF  8A2,8DA
0CCB8:  MOVFF  8A1,8D9
0CCBC:  MOVFF  8A8,8E0
0CCC0:  MOVFF  8A7,8DF
0CCC4:  MOVFF  8A6,8DE
0CCC8:  MOVFF  8A5,8DD
0CCCC:  CALL   BFE4
0CCD0:  MOVFF  03,8AC
0CCD4:  MOVFF  02,8AB
0CCD8:  MOVFF  01,8AA
0CCDC:  MOVFF  00,8A9
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
0CCE0:  MOVFF  8AC,8B0
0CCE4:  MOVFF  8AB,8AF
0CCE8:  MOVFF  8AA,8AE
0CCEC:  MOVFF  8A9,8AD
0CCF0:  RCALL  C97A
0CCF2:  MOVFF  03,3A8
0CCF6:  MOVFF  02,3A7
0CCFA:  MOVFF  01,3A6
0CCFE:  MOVFF  00,3A5
0CD02:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
0CD04:  MOVF   x4F,F
0CD06:  BNZ   CD0C
0CD08:  MOVF   x50,F
0CD0A:  BZ    CDA6
0CD0C:  MOVF   x51,F
0CD0E:  BNZ   CD14
0CD10:  MOVF   x52,F
0CD12:  BZ    CDA6
....................       blank = NO3_array[2]; 
0CD14:  MOVFF  350,8F6
0CD18:  MOVFF  34F,8F5
0CD1C:  MOVLB  0
0CD1E:  CALL   BFAE
0CD22:  MOVFF  03,8A4
0CD26:  MOVFF  02,8A3
0CD2A:  MOVFF  01,8A2
0CD2E:  MOVFF  00,8A1
....................       react = NO3_array[3]; 
0CD32:  MOVFF  352,8F6
0CD36:  MOVFF  351,8F5
0CD3A:  CALL   BFAE
0CD3E:  MOVFF  03,8A8
0CD42:  MOVFF  02,8A7
0CD46:  MOVFF  01,8A6
0CD4A:  MOVFF  00,8A5
....................       ratio = blank / react;    
0CD4E:  MOVFF  8A4,8DC
0CD52:  MOVFF  8A3,8DB
0CD56:  MOVFF  8A2,8DA
0CD5A:  MOVFF  8A1,8D9
0CD5E:  MOVFF  8A8,8E0
0CD62:  MOVFF  8A7,8DF
0CD66:  MOVFF  8A6,8DE
0CD6A:  MOVFF  8A5,8DD
0CD6E:  CALL   BFE4
0CD72:  MOVFF  03,8AC
0CD76:  MOVFF  02,8AB
0CD7A:  MOVFF  01,8AA
0CD7E:  MOVFF  00,8A9
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
0CD82:  MOVFF  8AC,8B0
0CD86:  MOVFF  8AB,8AF
0CD8A:  MOVFF  8AA,8AE
0CD8E:  MOVFF  8A9,8AD
0CD92:  RCALL  C97A
0CD94:  MOVFF  03,3AC
0CD98:  MOVFF  02,3AB
0CD9C:  MOVFF  01,3AA
0CDA0:  MOVFF  00,3A9
0CDA4:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
0CDA6:  MOVF   x53,F
0CDA8:  BNZ   CDAE
0CDAA:  MOVF   x54,F
0CDAC:  BZ    CE48
0CDAE:  MOVF   x55,F
0CDB0:  BNZ   CDB6
0CDB2:  MOVF   x56,F
0CDB4:  BZ    CE48
....................       blank = NO3_array[4]; 
0CDB6:  MOVFF  354,8F6
0CDBA:  MOVFF  353,8F5
0CDBE:  MOVLB  0
0CDC0:  CALL   BFAE
0CDC4:  MOVFF  03,8A4
0CDC8:  MOVFF  02,8A3
0CDCC:  MOVFF  01,8A2
0CDD0:  MOVFF  00,8A1
....................       react = NO3_array[5]; 
0CDD4:  MOVFF  356,8F6
0CDD8:  MOVFF  355,8F5
0CDDC:  CALL   BFAE
0CDE0:  MOVFF  03,8A8
0CDE4:  MOVFF  02,8A7
0CDE8:  MOVFF  01,8A6
0CDEC:  MOVFF  00,8A5
....................       ratio = blank / react; 
0CDF0:  MOVFF  8A4,8DC
0CDF4:  MOVFF  8A3,8DB
0CDF8:  MOVFF  8A2,8DA
0CDFC:  MOVFF  8A1,8D9
0CE00:  MOVFF  8A8,8E0
0CE04:  MOVFF  8A7,8DF
0CE08:  MOVFF  8A6,8DE
0CE0C:  MOVFF  8A5,8DD
0CE10:  CALL   BFE4
0CE14:  MOVFF  03,8AC
0CE18:  MOVFF  02,8AB
0CE1C:  MOVFF  01,8AA
0CE20:  MOVFF  00,8A9
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
0CE24:  MOVFF  8AC,8B0
0CE28:  MOVFF  8AB,8AF
0CE2C:  MOVFF  8AA,8AE
0CE30:  MOVFF  8A9,8AD
0CE34:  RCALL  C97A
0CE36:  MOVFF  03,3B0
0CE3A:  MOVFF  02,3AF
0CE3E:  MOVFF  01,3AE
0CE42:  MOVFF  00,3AD
0CE46:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
0CE48:  MOVF   x57,F
0CE4A:  BNZ   CE50
0CE4C:  MOVF   x58,F
0CE4E:  BZ    CEEA
0CE50:  MOVF   x59,F
0CE52:  BNZ   CE58
0CE54:  MOVF   x5A,F
0CE56:  BZ    CEEA
....................       blank = NO3_array[6]; 
0CE58:  MOVFF  358,8F6
0CE5C:  MOVFF  357,8F5
0CE60:  MOVLB  0
0CE62:  CALL   BFAE
0CE66:  MOVFF  03,8A4
0CE6A:  MOVFF  02,8A3
0CE6E:  MOVFF  01,8A2
0CE72:  MOVFF  00,8A1
....................       react = NO3_array[7]; 
0CE76:  MOVFF  35A,8F6
0CE7A:  MOVFF  359,8F5
0CE7E:  CALL   BFAE
0CE82:  MOVFF  03,8A8
0CE86:  MOVFF  02,8A7
0CE8A:  MOVFF  01,8A6
0CE8E:  MOVFF  00,8A5
....................       ratio = blank / react; 
0CE92:  MOVFF  8A4,8DC
0CE96:  MOVFF  8A3,8DB
0CE9A:  MOVFF  8A2,8DA
0CE9E:  MOVFF  8A1,8D9
0CEA2:  MOVFF  8A8,8E0
0CEA6:  MOVFF  8A7,8DF
0CEAA:  MOVFF  8A6,8DE
0CEAE:  MOVFF  8A5,8DD
0CEB2:  CALL   BFE4
0CEB6:  MOVFF  03,8AC
0CEBA:  MOVFF  02,8AB
0CEBE:  MOVFF  01,8AA
0CEC2:  MOVFF  00,8A9
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
0CEC6:  MOVFF  8AC,8B0
0CECA:  MOVFF  8AB,8AF
0CECE:  MOVFF  8AA,8AE
0CED2:  MOVFF  8A9,8AD
0CED6:  RCALL  C97A
0CED8:  MOVFF  03,3B4
0CEDC:  MOVFF  02,3B3
0CEE0:  MOVFF  01,3B2
0CEE4:  MOVFF  00,3B1
0CEE8:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
0CEEA:  MOVLW  04
0CEEC:  MOVWF  1E
0CEEE:  MOVLW  25
0CEF0:  MOVWF  1D
0CEF2:  MOVLW  D0
0CEF4:  MOVWF  FF6
0CEF6:  MOVLW  1D
0CEF8:  MOVWF  FF7
0CEFA:  MOVLW  00
0CEFC:  MOVWF  FF8
0CEFE:  MOVLW  06
0CF00:  MOVLB  8
0CF02:  MOVWF  xC9
0CF04:  MOVLB  0
0CF06:  CALL   AA6C
0CF0A:  MOVLW  10
0CF0C:  MOVWF  FE9
0CF0E:  MOVFF  34C,8D5
0CF12:  MOVFF  34B,8D4
0CF16:  CALL   AA9E
0CF1A:  MOVLW  D9
0CF1C:  MOVWF  FF6
0CF1E:  MOVLW  1D
0CF20:  MOVWF  FF7
0CF22:  MOVLW  00
0CF24:  MOVWF  FF8
0CF26:  MOVLW  07
0CF28:  MOVLB  8
0CF2A:  MOVWF  xC9
0CF2C:  MOVLB  0
0CF2E:  CALL   AA6C
0CF32:  MOVLW  10
0CF34:  MOVWF  FE9
0CF36:  MOVFF  34E,8D5
0CF3A:  MOVFF  34D,8D4
0CF3E:  CALL   AA9E
0CF42:  MOVLW  E3
0CF44:  MOVWF  FF6
0CF46:  MOVLW  1D
0CF48:  MOVWF  FF7
0CF4A:  MOVLW  00
0CF4C:  MOVWF  FF8
0CF4E:  MOVLW  09
0CF50:  MOVLB  8
0CF52:  MOVWF  xC9
0CF54:  MOVLB  0
0CF56:  CALL   AA6C
0CF5A:  MOVLW  89
0CF5C:  MOVWF  FE9
0CF5E:  MOVFF  3A8,8B0
0CF62:  MOVFF  3A7,8AF
0CF66:  MOVFF  3A6,8AE
0CF6A:  MOVFF  3A5,8AD
0CF6E:  MOVLW  04
0CF70:  MOVLB  8
0CF72:  MOVWF  xB1
0CF74:  MOVLB  0
0CF76:  RCALL  CA28
0CF78:  MOVLW  F1
0CF7A:  MOVWF  FF6
0CF7C:  MOVLW  1D
0CF7E:  MOVWF  FF7
0CF80:  MOVLW  00
0CF82:  MOVWF  FF8
0CF84:  MOVLW  07
0CF86:  MOVLB  8
0CF88:  MOVWF  xC9
0CF8A:  MOVLB  0
0CF8C:  CALL   AA6C
0CF90:  MOVLW  10
0CF92:  MOVWF  FE9
0CF94:  MOVFF  350,8D5
0CF98:  MOVFF  34F,8D4
0CF9C:  CALL   AA9E
0CFA0:  MOVLW  FB
0CFA2:  MOVWF  FF6
0CFA4:  MOVLW  1D
0CFA6:  MOVWF  FF7
0CFA8:  MOVLW  00
0CFAA:  MOVWF  FF8
0CFAC:  MOVLW  07
0CFAE:  MOVLB  8
0CFB0:  MOVWF  xC9
0CFB2:  MOVLB  0
0CFB4:  CALL   AA6C
0CFB8:  MOVLW  10
0CFBA:  MOVWF  FE9
0CFBC:  MOVFF  352,8D5
0CFC0:  MOVFF  351,8D4
0CFC4:  CALL   AA9E
0CFC8:  MOVLW  05
0CFCA:  MOVWF  FF6
0CFCC:  MOVLW  1E
0CFCE:  MOVWF  FF7
0CFD0:  MOVLW  00
0CFD2:  MOVWF  FF8
0CFD4:  MOVLW  09
0CFD6:  MOVLB  8
0CFD8:  MOVWF  xC9
0CFDA:  MOVLB  0
0CFDC:  CALL   AA6C
0CFE0:  MOVLW  89
0CFE2:  MOVWF  FE9
0CFE4:  MOVFF  3AC,8B0
0CFE8:  MOVFF  3AB,8AF
0CFEC:  MOVFF  3AA,8AE
0CFF0:  MOVFF  3A9,8AD
0CFF4:  MOVLW  04
0CFF6:  MOVLB  8
0CFF8:  MOVWF  xB1
0CFFA:  MOVLB  0
0CFFC:  RCALL  CA28
0CFFE:  MOVLW  13
0D000:  MOVWF  FF6
0D002:  MOVLW  1E
0D004:  MOVWF  FF7
0D006:  MOVLW  00
0D008:  MOVWF  FF8
0D00A:  MOVLW  07
0D00C:  MOVLB  8
0D00E:  MOVWF  xC9
0D010:  MOVLB  0
0D012:  CALL   AA6C
0D016:  MOVLW  10
0D018:  MOVWF  FE9
0D01A:  MOVFF  354,8D5
0D01E:  MOVFF  353,8D4
0D022:  CALL   AA9E
0D026:  MOVLW  1D
0D028:  MOVWF  FF6
0D02A:  MOVLW  1E
0D02C:  MOVWF  FF7
0D02E:  MOVLW  00
0D030:  MOVWF  FF8
0D032:  MOVLW  07
0D034:  MOVLB  8
0D036:  MOVWF  xC9
0D038:  MOVLB  0
0D03A:  CALL   AA6C
0D03E:  MOVLW  10
0D040:  MOVWF  FE9
0D042:  MOVFF  356,8D5
0D046:  MOVFF  355,8D4
0D04A:  CALL   AA9E
0D04E:  MOVLW  27
0D050:  MOVWF  FF6
0D052:  MOVLW  1E
0D054:  MOVWF  FF7
0D056:  MOVLW  00
0D058:  MOVWF  FF8
0D05A:  MOVLW  09
0D05C:  MOVLB  8
0D05E:  MOVWF  xC9
0D060:  MOVLB  0
0D062:  CALL   AA6C
0D066:  MOVLW  89
0D068:  MOVWF  FE9
0D06A:  MOVFF  3B0,8B0
0D06E:  MOVFF  3AF,8AF
0D072:  MOVFF  3AE,8AE
0D076:  MOVFF  3AD,8AD
0D07A:  MOVLW  04
0D07C:  MOVLB  8
0D07E:  MOVWF  xB1
0D080:  MOVLB  0
0D082:  RCALL  CA28
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
0D084:  MOVF   1F,W
0D086:  SUBLW  02
0D088:  BNZ   D08E
0D08A:  MOVF   20,F
0D08C:  BZ    D0CE
0D08E:  MOVLW  36
0D090:  MOVWF  FF6
0D092:  MOVLW  1E
0D094:  MOVWF  FF7
0D096:  MOVLW  00
0D098:  MOVWF  FF8
0D09A:  CLRF   1B
0D09C:  BTFSC  FF2.7
0D09E:  BSF    1B.7
0D0A0:  BCF    FF2.7
0D0A2:  MOVLW  09
0D0A4:  MOVLB  A
0D0A6:  MOVWF  x19
0D0A8:  MOVLB  0
0D0AA:  CALL   104E
0D0AE:  BTFSC  1B.7
0D0B0:  BSF    FF2.7
0D0B2:  MOVLW  04
0D0B4:  MOVWF  FEA
0D0B6:  MOVLW  25
0D0B8:  MOVWF  FE9
0D0BA:  CALL   793C
0D0BE:  MOVLW  0D
0D0C0:  BTFSS  F9E.4
0D0C2:  BRA    D0C0
0D0C4:  MOVWF  FAD
0D0C6:  MOVLW  0A
0D0C8:  BTFSS  F9E.4
0D0CA:  BRA    D0C8
0D0CC:  MOVWF  FAD
0D0CE:  GOTO   E3DC (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
0D0D2:  MOVLB  8
0D0D4:  CLRF   xA0
0D0D6:  MOVF   xA0,W
0D0D8:  SUBLW  03
0D0DA:  BNC   D0FA
0D0DC:  MOVF   xA0,W
0D0DE:  MULLW  04
0D0E0:  MOVF   FF3,W
0D0E2:  CLRF   03
0D0E4:  ADDLW  B5
0D0E6:  MOVWF  FE9
0D0E8:  MOVLW  03
0D0EA:  ADDWFC 03,W
0D0EC:  MOVWF  FEA
0D0EE:  CLRF   FEF
0D0F0:  CLRF   FEC
0D0F2:  CLRF   FEC
0D0F4:  CLRF   FEC
0D0F6:  INCF   xA0,F
0D0F8:  BRA    D0D6
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
0D0FA:  MOVLB  3
0D0FC:  MOVF   x5D,F
0D0FE:  BTFSS  FD8.2
0D100:  BRA    D106
0D102:  MOVF   x5E,F
0D104:  BZ    D1A2
0D106:  MOVF   x5F,F
0D108:  BNZ   D10E
0D10A:  MOVF   x60,F
0D10C:  BZ    D1A2
....................       blank = NO2_array[0]; 
0D10E:  MOVFF  35E,8F6
0D112:  MOVFF  35D,8F5
0D116:  MOVLB  0
0D118:  CALL   BFAE
0D11C:  MOVFF  03,8A4
0D120:  MOVFF  02,8A3
0D124:  MOVFF  01,8A2
0D128:  MOVFF  00,8A1
....................       react = NO2_array[1]; 
0D12C:  MOVFF  360,8F6
0D130:  MOVFF  35F,8F5
0D134:  CALL   BFAE
0D138:  MOVFF  03,8A8
0D13C:  MOVFF  02,8A7
0D140:  MOVFF  01,8A6
0D144:  MOVFF  00,8A5
....................       ratio = blank / react; 
0D148:  MOVFF  8A4,8DC
0D14C:  MOVFF  8A3,8DB
0D150:  MOVFF  8A2,8DA
0D154:  MOVFF  8A1,8D9
0D158:  MOVFF  8A8,8E0
0D15C:  MOVFF  8A7,8DF
0D160:  MOVFF  8A6,8DE
0D164:  MOVFF  8A5,8DD
0D168:  CALL   BFE4
0D16C:  MOVFF  03,8AC
0D170:  MOVFF  02,8AB
0D174:  MOVFF  01,8AA
0D178:  MOVFF  00,8A9
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
0D17C:  MOVFF  8AC,8B0
0D180:  MOVFF  8AB,8AF
0D184:  MOVFF  8AA,8AE
0D188:  MOVFF  8A9,8AD
0D18C:  CALL   C97A
0D190:  MOVFF  03,3B8
0D194:  MOVFF  02,3B7
0D198:  MOVFF  01,3B6
0D19C:  MOVFF  00,3B5
0D1A0:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
0D1A2:  MOVF   x61,F
0D1A4:  BNZ   D1AA
0D1A6:  MOVF   x62,F
0D1A8:  BZ    D246
0D1AA:  MOVF   x63,F
0D1AC:  BNZ   D1B2
0D1AE:  MOVF   x64,F
0D1B0:  BZ    D246
....................       blank = NO2_array[2]; 
0D1B2:  MOVFF  362,8F6
0D1B6:  MOVFF  361,8F5
0D1BA:  MOVLB  0
0D1BC:  CALL   BFAE
0D1C0:  MOVFF  03,8A4
0D1C4:  MOVFF  02,8A3
0D1C8:  MOVFF  01,8A2
0D1CC:  MOVFF  00,8A1
....................       react = NO2_array[3]; 
0D1D0:  MOVFF  364,8F6
0D1D4:  MOVFF  363,8F5
0D1D8:  CALL   BFAE
0D1DC:  MOVFF  03,8A8
0D1E0:  MOVFF  02,8A7
0D1E4:  MOVFF  01,8A6
0D1E8:  MOVFF  00,8A5
....................       ratio = blank / react;    
0D1EC:  MOVFF  8A4,8DC
0D1F0:  MOVFF  8A3,8DB
0D1F4:  MOVFF  8A2,8DA
0D1F8:  MOVFF  8A1,8D9
0D1FC:  MOVFF  8A8,8E0
0D200:  MOVFF  8A7,8DF
0D204:  MOVFF  8A6,8DE
0D208:  MOVFF  8A5,8DD
0D20C:  CALL   BFE4
0D210:  MOVFF  03,8AC
0D214:  MOVFF  02,8AB
0D218:  MOVFF  01,8AA
0D21C:  MOVFF  00,8A9
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
0D220:  MOVFF  8AC,8B0
0D224:  MOVFF  8AB,8AF
0D228:  MOVFF  8AA,8AE
0D22C:  MOVFF  8A9,8AD
0D230:  CALL   C97A
0D234:  MOVFF  03,3BC
0D238:  MOVFF  02,3BB
0D23C:  MOVFF  01,3BA
0D240:  MOVFF  00,3B9
0D244:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
0D246:  MOVF   x65,F
0D248:  BNZ   D24E
0D24A:  MOVF   x66,F
0D24C:  BZ    D2EA
0D24E:  MOVF   x67,F
0D250:  BNZ   D256
0D252:  MOVF   x68,F
0D254:  BZ    D2EA
....................       blank = NO2_array[4]; 
0D256:  MOVFF  366,8F6
0D25A:  MOVFF  365,8F5
0D25E:  MOVLB  0
0D260:  CALL   BFAE
0D264:  MOVFF  03,8A4
0D268:  MOVFF  02,8A3
0D26C:  MOVFF  01,8A2
0D270:  MOVFF  00,8A1
....................       react = NO2_array[5]; 
0D274:  MOVFF  368,8F6
0D278:  MOVFF  367,8F5
0D27C:  CALL   BFAE
0D280:  MOVFF  03,8A8
0D284:  MOVFF  02,8A7
0D288:  MOVFF  01,8A6
0D28C:  MOVFF  00,8A5
....................       ratio = blank / react; 
0D290:  MOVFF  8A4,8DC
0D294:  MOVFF  8A3,8DB
0D298:  MOVFF  8A2,8DA
0D29C:  MOVFF  8A1,8D9
0D2A0:  MOVFF  8A8,8E0
0D2A4:  MOVFF  8A7,8DF
0D2A8:  MOVFF  8A6,8DE
0D2AC:  MOVFF  8A5,8DD
0D2B0:  CALL   BFE4
0D2B4:  MOVFF  03,8AC
0D2B8:  MOVFF  02,8AB
0D2BC:  MOVFF  01,8AA
0D2C0:  MOVFF  00,8A9
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
0D2C4:  MOVFF  8AC,8B0
0D2C8:  MOVFF  8AB,8AF
0D2CC:  MOVFF  8AA,8AE
0D2D0:  MOVFF  8A9,8AD
0D2D4:  CALL   C97A
0D2D8:  MOVFF  03,3C0
0D2DC:  MOVFF  02,3BF
0D2E0:  MOVFF  01,3BE
0D2E4:  MOVFF  00,3BD
0D2E8:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
0D2EA:  MOVF   x69,F
0D2EC:  BNZ   D2F2
0D2EE:  MOVF   x6A,F
0D2F0:  BZ    D38E
0D2F2:  MOVF   x6B,F
0D2F4:  BNZ   D2FA
0D2F6:  MOVF   x6C,F
0D2F8:  BZ    D38E
....................       blank = NO2_array[6]; 
0D2FA:  MOVFF  36A,8F6
0D2FE:  MOVFF  369,8F5
0D302:  MOVLB  0
0D304:  CALL   BFAE
0D308:  MOVFF  03,8A4
0D30C:  MOVFF  02,8A3
0D310:  MOVFF  01,8A2
0D314:  MOVFF  00,8A1
....................       react = NO2_array[7]; 
0D318:  MOVFF  36C,8F6
0D31C:  MOVFF  36B,8F5
0D320:  CALL   BFAE
0D324:  MOVFF  03,8A8
0D328:  MOVFF  02,8A7
0D32C:  MOVFF  01,8A6
0D330:  MOVFF  00,8A5
....................       ratio = blank / react; 
0D334:  MOVFF  8A4,8DC
0D338:  MOVFF  8A3,8DB
0D33C:  MOVFF  8A2,8DA
0D340:  MOVFF  8A1,8D9
0D344:  MOVFF  8A8,8E0
0D348:  MOVFF  8A7,8DF
0D34C:  MOVFF  8A6,8DE
0D350:  MOVFF  8A5,8DD
0D354:  CALL   BFE4
0D358:  MOVFF  03,8AC
0D35C:  MOVFF  02,8AB
0D360:  MOVFF  01,8AA
0D364:  MOVFF  00,8A9
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
0D368:  MOVFF  8AC,8B0
0D36C:  MOVFF  8AB,8AF
0D370:  MOVFF  8AA,8AE
0D374:  MOVFF  8A9,8AD
0D378:  CALL   C97A
0D37C:  MOVFF  03,3C4
0D380:  MOVFF  02,3C3
0D384:  MOVFF  01,3C2
0D388:  MOVFF  00,3C1
0D38C:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
0D38E:  MOVLW  04
0D390:  MOVWF  1E
0D392:  MOVLW  25
0D394:  MOVWF  1D
0D396:  MOVLW  44
0D398:  MOVWF  FF6
0D39A:  MOVLW  1E
0D39C:  MOVWF  FF7
0D39E:  MOVLW  00
0D3A0:  MOVWF  FF8
0D3A2:  MOVLW  06
0D3A4:  MOVLB  8
0D3A6:  MOVWF  xC9
0D3A8:  MOVLB  0
0D3AA:  CALL   AA6C
0D3AE:  MOVLW  10
0D3B0:  MOVWF  FE9
0D3B2:  MOVFF  35E,8D5
0D3B6:  MOVFF  35D,8D4
0D3BA:  CALL   AA9E
0D3BE:  MOVLW  4D
0D3C0:  MOVWF  FF6
0D3C2:  MOVLW  1E
0D3C4:  MOVWF  FF7
0D3C6:  MOVLW  00
0D3C8:  MOVWF  FF8
0D3CA:  MOVLW  07
0D3CC:  MOVLB  8
0D3CE:  MOVWF  xC9
0D3D0:  MOVLB  0
0D3D2:  CALL   AA6C
0D3D6:  MOVLW  10
0D3D8:  MOVWF  FE9
0D3DA:  MOVFF  360,8D5
0D3DE:  MOVFF  35F,8D4
0D3E2:  CALL   AA9E
0D3E6:  MOVLW  57
0D3E8:  MOVWF  FF6
0D3EA:  MOVLW  1E
0D3EC:  MOVWF  FF7
0D3EE:  MOVLW  00
0D3F0:  MOVWF  FF8
0D3F2:  MOVLW  09
0D3F4:  MOVLB  8
0D3F6:  MOVWF  xC9
0D3F8:  MOVLB  0
0D3FA:  CALL   AA6C
0D3FE:  MOVLW  89
0D400:  MOVWF  FE9
0D402:  MOVFF  3B8,8B0
0D406:  MOVFF  3B7,8AF
0D40A:  MOVFF  3B6,8AE
0D40E:  MOVFF  3B5,8AD
0D412:  MOVLW  04
0D414:  MOVLB  8
0D416:  MOVWF  xB1
0D418:  MOVLB  0
0D41A:  CALL   CA28
0D41E:  MOVLW  65
0D420:  MOVWF  FF6
0D422:  MOVLW  1E
0D424:  MOVWF  FF7
0D426:  MOVLW  00
0D428:  MOVWF  FF8
0D42A:  MOVLW  07
0D42C:  MOVLB  8
0D42E:  MOVWF  xC9
0D430:  MOVLB  0
0D432:  CALL   AA6C
0D436:  MOVLW  10
0D438:  MOVWF  FE9
0D43A:  MOVFF  362,8D5
0D43E:  MOVFF  361,8D4
0D442:  CALL   AA9E
0D446:  MOVLW  6F
0D448:  MOVWF  FF6
0D44A:  MOVLW  1E
0D44C:  MOVWF  FF7
0D44E:  MOVLW  00
0D450:  MOVWF  FF8
0D452:  MOVLW  07
0D454:  MOVLB  8
0D456:  MOVWF  xC9
0D458:  MOVLB  0
0D45A:  CALL   AA6C
0D45E:  MOVLW  10
0D460:  MOVWF  FE9
0D462:  MOVFF  364,8D5
0D466:  MOVFF  363,8D4
0D46A:  CALL   AA9E
0D46E:  MOVLW  79
0D470:  MOVWF  FF6
0D472:  MOVLW  1E
0D474:  MOVWF  FF7
0D476:  MOVLW  00
0D478:  MOVWF  FF8
0D47A:  MOVLW  09
0D47C:  MOVLB  8
0D47E:  MOVWF  xC9
0D480:  MOVLB  0
0D482:  CALL   AA6C
0D486:  MOVLW  89
0D488:  MOVWF  FE9
0D48A:  MOVFF  3BC,8B0
0D48E:  MOVFF  3BB,8AF
0D492:  MOVFF  3BA,8AE
0D496:  MOVFF  3B9,8AD
0D49A:  MOVLW  04
0D49C:  MOVLB  8
0D49E:  MOVWF  xB1
0D4A0:  MOVLB  0
0D4A2:  CALL   CA28
0D4A6:  MOVLW  87
0D4A8:  MOVWF  FF6
0D4AA:  MOVLW  1E
0D4AC:  MOVWF  FF7
0D4AE:  MOVLW  00
0D4B0:  MOVWF  FF8
0D4B2:  MOVLW  07
0D4B4:  MOVLB  8
0D4B6:  MOVWF  xC9
0D4B8:  MOVLB  0
0D4BA:  CALL   AA6C
0D4BE:  MOVLW  10
0D4C0:  MOVWF  FE9
0D4C2:  MOVFF  366,8D5
0D4C6:  MOVFF  365,8D4
0D4CA:  CALL   AA9E
0D4CE:  MOVLW  91
0D4D0:  MOVWF  FF6
0D4D2:  MOVLW  1E
0D4D4:  MOVWF  FF7
0D4D6:  MOVLW  00
0D4D8:  MOVWF  FF8
0D4DA:  MOVLW  07
0D4DC:  MOVLB  8
0D4DE:  MOVWF  xC9
0D4E0:  MOVLB  0
0D4E2:  CALL   AA6C
0D4E6:  MOVLW  10
0D4E8:  MOVWF  FE9
0D4EA:  MOVFF  368,8D5
0D4EE:  MOVFF  367,8D4
0D4F2:  CALL   AA9E
0D4F6:  MOVLW  9B
0D4F8:  MOVWF  FF6
0D4FA:  MOVLW  1E
0D4FC:  MOVWF  FF7
0D4FE:  MOVLW  00
0D500:  MOVWF  FF8
0D502:  MOVLW  09
0D504:  MOVLB  8
0D506:  MOVWF  xC9
0D508:  MOVLB  0
0D50A:  CALL   AA6C
0D50E:  MOVLW  89
0D510:  MOVWF  FE9
0D512:  MOVFF  3C0,8B0
0D516:  MOVFF  3BF,8AF
0D51A:  MOVFF  3BE,8AE
0D51E:  MOVFF  3BD,8AD
0D522:  MOVLW  04
0D524:  MOVLB  8
0D526:  MOVWF  xB1
0D528:  MOVLB  0
0D52A:  CALL   CA28
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
0D52E:  MOVF   1F,W
0D530:  SUBLW  02
0D532:  BNZ   D538
0D534:  MOVF   20,F
0D536:  BZ    D578
0D538:  MOVLW  AA
0D53A:  MOVWF  FF6
0D53C:  MOVLW  1E
0D53E:  MOVWF  FF7
0D540:  MOVLW  00
0D542:  MOVWF  FF8
0D544:  CLRF   1B
0D546:  BTFSC  FF2.7
0D548:  BSF    1B.7
0D54A:  BCF    FF2.7
0D54C:  MOVLW  09
0D54E:  MOVLB  A
0D550:  MOVWF  x19
0D552:  MOVLB  0
0D554:  CALL   104E
0D558:  BTFSC  1B.7
0D55A:  BSF    FF2.7
0D55C:  MOVLW  04
0D55E:  MOVWF  FEA
0D560:  MOVLW  25
0D562:  MOVWF  FE9
0D564:  CALL   793C
0D568:  MOVLW  0D
0D56A:  BTFSS  F9E.4
0D56C:  BRA    D56A
0D56E:  MOVWF  FAD
0D570:  MOVLW  0A
0D572:  BTFSS  F9E.4
0D574:  BRA    D572
0D576:  MOVWF  FAD
0D578:  GOTO   E3DC (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
0D57C:  MOVLB  8
0D57E:  CLRF   xA0
0D580:  MOVF   xA0,W
0D582:  SUBLW  03
0D584:  BNC   D5A4
0D586:  MOVF   xA0,W
0D588:  MULLW  04
0D58A:  MOVF   FF3,W
0D58C:  CLRF   03
0D58E:  ADDLW  C5
0D590:  MOVWF  FE9
0D592:  MOVLW  03
0D594:  ADDWFC 03,W
0D596:  MOVWF  FEA
0D598:  CLRF   FEF
0D59A:  CLRF   FEC
0D59C:  CLRF   FEC
0D59E:  CLRF   FEC
0D5A0:  INCF   xA0,F
0D5A2:  BRA    D580
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
0D5A4:  MOVLB  3
0D5A6:  MOVF   x6F,F
0D5A8:  BTFSS  FD8.2
0D5AA:  BRA    D5B0
0D5AC:  MOVF   x70,F
0D5AE:  BZ    D64C
0D5B0:  MOVF   x71,F
0D5B2:  BNZ   D5B8
0D5B4:  MOVF   x72,F
0D5B6:  BZ    D64C
....................       blank = PO4_array[0]; 
0D5B8:  MOVFF  370,8F6
0D5BC:  MOVFF  36F,8F5
0D5C0:  MOVLB  0
0D5C2:  CALL   BFAE
0D5C6:  MOVFF  03,8A4
0D5CA:  MOVFF  02,8A3
0D5CE:  MOVFF  01,8A2
0D5D2:  MOVFF  00,8A1
....................       react = PO4_array[1]; 
0D5D6:  MOVFF  372,8F6
0D5DA:  MOVFF  371,8F5
0D5DE:  CALL   BFAE
0D5E2:  MOVFF  03,8A8
0D5E6:  MOVFF  02,8A7
0D5EA:  MOVFF  01,8A6
0D5EE:  MOVFF  00,8A5
....................       ratio = blank / react; 
0D5F2:  MOVFF  8A4,8DC
0D5F6:  MOVFF  8A3,8DB
0D5FA:  MOVFF  8A2,8DA
0D5FE:  MOVFF  8A1,8D9
0D602:  MOVFF  8A8,8E0
0D606:  MOVFF  8A7,8DF
0D60A:  MOVFF  8A6,8DE
0D60E:  MOVFF  8A5,8DD
0D612:  CALL   BFE4
0D616:  MOVFF  03,8AC
0D61A:  MOVFF  02,8AB
0D61E:  MOVFF  01,8AA
0D622:  MOVFF  00,8A9
....................       PO4_abs_array[0] = log10(ratio); 
0D626:  MOVFF  8AC,8B0
0D62A:  MOVFF  8AB,8AF
0D62E:  MOVFF  8AA,8AE
0D632:  MOVFF  8A9,8AD
0D636:  CALL   C97A
0D63A:  MOVFF  03,3C8
0D63E:  MOVFF  02,3C7
0D642:  MOVFF  01,3C6
0D646:  MOVFF  00,3C5
0D64A:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
0D64C:  MOVF   x73,F
0D64E:  BNZ   D654
0D650:  MOVF   x74,F
0D652:  BZ    D6F0
0D654:  MOVF   x75,F
0D656:  BNZ   D65C
0D658:  MOVF   x76,F
0D65A:  BZ    D6F0
....................       blank = PO4_array[2]; 
0D65C:  MOVFF  374,8F6
0D660:  MOVFF  373,8F5
0D664:  MOVLB  0
0D666:  CALL   BFAE
0D66A:  MOVFF  03,8A4
0D66E:  MOVFF  02,8A3
0D672:  MOVFF  01,8A2
0D676:  MOVFF  00,8A1
....................       react = PO4_array[3]; 
0D67A:  MOVFF  376,8F6
0D67E:  MOVFF  375,8F5
0D682:  CALL   BFAE
0D686:  MOVFF  03,8A8
0D68A:  MOVFF  02,8A7
0D68E:  MOVFF  01,8A6
0D692:  MOVFF  00,8A5
....................       ratio = blank / react;    
0D696:  MOVFF  8A4,8DC
0D69A:  MOVFF  8A3,8DB
0D69E:  MOVFF  8A2,8DA
0D6A2:  MOVFF  8A1,8D9
0D6A6:  MOVFF  8A8,8E0
0D6AA:  MOVFF  8A7,8DF
0D6AE:  MOVFF  8A6,8DE
0D6B2:  MOVFF  8A5,8DD
0D6B6:  CALL   BFE4
0D6BA:  MOVFF  03,8AC
0D6BE:  MOVFF  02,8AB
0D6C2:  MOVFF  01,8AA
0D6C6:  MOVFF  00,8A9
....................       PO4_abs_array[1] = log10(ratio); 
0D6CA:  MOVFF  8AC,8B0
0D6CE:  MOVFF  8AB,8AF
0D6D2:  MOVFF  8AA,8AE
0D6D6:  MOVFF  8A9,8AD
0D6DA:  CALL   C97A
0D6DE:  MOVFF  03,3CC
0D6E2:  MOVFF  02,3CB
0D6E6:  MOVFF  01,3CA
0D6EA:  MOVFF  00,3C9
0D6EE:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
0D6F0:  MOVF   x77,F
0D6F2:  BNZ   D6F8
0D6F4:  MOVF   x78,F
0D6F6:  BZ    D794
0D6F8:  MOVF   x79,F
0D6FA:  BNZ   D700
0D6FC:  MOVF   x7A,F
0D6FE:  BZ    D794
....................       blank = PO4_array[4]; 
0D700:  MOVFF  378,8F6
0D704:  MOVFF  377,8F5
0D708:  MOVLB  0
0D70A:  CALL   BFAE
0D70E:  MOVFF  03,8A4
0D712:  MOVFF  02,8A3
0D716:  MOVFF  01,8A2
0D71A:  MOVFF  00,8A1
....................       react = PO4_array[5]; 
0D71E:  MOVFF  37A,8F6
0D722:  MOVFF  379,8F5
0D726:  CALL   BFAE
0D72A:  MOVFF  03,8A8
0D72E:  MOVFF  02,8A7
0D732:  MOVFF  01,8A6
0D736:  MOVFF  00,8A5
....................       ratio = blank / react; 
0D73A:  MOVFF  8A4,8DC
0D73E:  MOVFF  8A3,8DB
0D742:  MOVFF  8A2,8DA
0D746:  MOVFF  8A1,8D9
0D74A:  MOVFF  8A8,8E0
0D74E:  MOVFF  8A7,8DF
0D752:  MOVFF  8A6,8DE
0D756:  MOVFF  8A5,8DD
0D75A:  CALL   BFE4
0D75E:  MOVFF  03,8AC
0D762:  MOVFF  02,8AB
0D766:  MOVFF  01,8AA
0D76A:  MOVFF  00,8A9
....................       PO4_abs_array[2] = log10(ratio); 
0D76E:  MOVFF  8AC,8B0
0D772:  MOVFF  8AB,8AF
0D776:  MOVFF  8AA,8AE
0D77A:  MOVFF  8A9,8AD
0D77E:  CALL   C97A
0D782:  MOVFF  03,3D0
0D786:  MOVFF  02,3CF
0D78A:  MOVFF  01,3CE
0D78E:  MOVFF  00,3CD
0D792:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
0D794:  MOVF   x7B,F
0D796:  BNZ   D79C
0D798:  MOVF   x7C,F
0D79A:  BZ    D838
0D79C:  MOVF   x7D,F
0D79E:  BNZ   D7A4
0D7A0:  MOVF   x7E,F
0D7A2:  BZ    D838
....................       blank = PO4_array[6]; 
0D7A4:  MOVFF  37C,8F6
0D7A8:  MOVFF  37B,8F5
0D7AC:  MOVLB  0
0D7AE:  CALL   BFAE
0D7B2:  MOVFF  03,8A4
0D7B6:  MOVFF  02,8A3
0D7BA:  MOVFF  01,8A2
0D7BE:  MOVFF  00,8A1
....................       react = PO4_array[7]; 
0D7C2:  MOVFF  37E,8F6
0D7C6:  MOVFF  37D,8F5
0D7CA:  CALL   BFAE
0D7CE:  MOVFF  03,8A8
0D7D2:  MOVFF  02,8A7
0D7D6:  MOVFF  01,8A6
0D7DA:  MOVFF  00,8A5
....................       ratio = blank / react; 
0D7DE:  MOVFF  8A4,8DC
0D7E2:  MOVFF  8A3,8DB
0D7E6:  MOVFF  8A2,8DA
0D7EA:  MOVFF  8A1,8D9
0D7EE:  MOVFF  8A8,8E0
0D7F2:  MOVFF  8A7,8DF
0D7F6:  MOVFF  8A6,8DE
0D7FA:  MOVFF  8A5,8DD
0D7FE:  CALL   BFE4
0D802:  MOVFF  03,8AC
0D806:  MOVFF  02,8AB
0D80A:  MOVFF  01,8AA
0D80E:  MOVFF  00,8A9
....................       PO4_abs_array[3] = log10(ratio); 
0D812:  MOVFF  8AC,8B0
0D816:  MOVFF  8AB,8AF
0D81A:  MOVFF  8AA,8AE
0D81E:  MOVFF  8A9,8AD
0D822:  CALL   C97A
0D826:  MOVFF  03,3D4
0D82A:  MOVFF  02,3D3
0D82E:  MOVFF  01,3D2
0D832:  MOVFF  00,3D1
0D836:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
0D838:  MOVLW  04
0D83A:  MOVWF  1E
0D83C:  MOVLW  25
0D83E:  MOVWF  1D
0D840:  MOVLW  B8
0D842:  MOVWF  FF6
0D844:  MOVLW  1E
0D846:  MOVWF  FF7
0D848:  MOVLW  00
0D84A:  MOVWF  FF8
0D84C:  MOVLW  06
0D84E:  MOVLB  8
0D850:  MOVWF  xC9
0D852:  MOVLB  0
0D854:  CALL   AA6C
0D858:  MOVLW  10
0D85A:  MOVWF  FE9
0D85C:  MOVFF  370,8D5
0D860:  MOVFF  36F,8D4
0D864:  CALL   AA9E
0D868:  MOVLW  C1
0D86A:  MOVWF  FF6
0D86C:  MOVLW  1E
0D86E:  MOVWF  FF7
0D870:  MOVLW  00
0D872:  MOVWF  FF8
0D874:  MOVLW  07
0D876:  MOVLB  8
0D878:  MOVWF  xC9
0D87A:  MOVLB  0
0D87C:  CALL   AA6C
0D880:  MOVLW  10
0D882:  MOVWF  FE9
0D884:  MOVFF  372,8D5
0D888:  MOVFF  371,8D4
0D88C:  CALL   AA9E
0D890:  MOVLW  CB
0D892:  MOVWF  FF6
0D894:  MOVLW  1E
0D896:  MOVWF  FF7
0D898:  MOVLW  00
0D89A:  MOVWF  FF8
0D89C:  MOVLW  09
0D89E:  MOVLB  8
0D8A0:  MOVWF  xC9
0D8A2:  MOVLB  0
0D8A4:  CALL   AA6C
0D8A8:  MOVLW  89
0D8AA:  MOVWF  FE9
0D8AC:  MOVFF  3C8,8B0
0D8B0:  MOVFF  3C7,8AF
0D8B4:  MOVFF  3C6,8AE
0D8B8:  MOVFF  3C5,8AD
0D8BC:  MOVLW  04
0D8BE:  MOVLB  8
0D8C0:  MOVWF  xB1
0D8C2:  MOVLB  0
0D8C4:  CALL   CA28
0D8C8:  MOVLW  D9
0D8CA:  MOVWF  FF6
0D8CC:  MOVLW  1E
0D8CE:  MOVWF  FF7
0D8D0:  MOVLW  00
0D8D2:  MOVWF  FF8
0D8D4:  MOVLW  07
0D8D6:  MOVLB  8
0D8D8:  MOVWF  xC9
0D8DA:  MOVLB  0
0D8DC:  CALL   AA6C
0D8E0:  MOVLW  10
0D8E2:  MOVWF  FE9
0D8E4:  MOVFF  374,8D5
0D8E8:  MOVFF  373,8D4
0D8EC:  CALL   AA9E
0D8F0:  MOVLW  E3
0D8F2:  MOVWF  FF6
0D8F4:  MOVLW  1E
0D8F6:  MOVWF  FF7
0D8F8:  MOVLW  00
0D8FA:  MOVWF  FF8
0D8FC:  MOVLW  07
0D8FE:  MOVLB  8
0D900:  MOVWF  xC9
0D902:  MOVLB  0
0D904:  CALL   AA6C
0D908:  MOVLW  10
0D90A:  MOVWF  FE9
0D90C:  MOVFF  376,8D5
0D910:  MOVFF  375,8D4
0D914:  CALL   AA9E
0D918:  MOVLW  ED
0D91A:  MOVWF  FF6
0D91C:  MOVLW  1E
0D91E:  MOVWF  FF7
0D920:  MOVLW  00
0D922:  MOVWF  FF8
0D924:  MOVLW  09
0D926:  MOVLB  8
0D928:  MOVWF  xC9
0D92A:  MOVLB  0
0D92C:  CALL   AA6C
0D930:  MOVLW  89
0D932:  MOVWF  FE9
0D934:  MOVFF  3CC,8B0
0D938:  MOVFF  3CB,8AF
0D93C:  MOVFF  3CA,8AE
0D940:  MOVFF  3C9,8AD
0D944:  MOVLW  04
0D946:  MOVLB  8
0D948:  MOVWF  xB1
0D94A:  MOVLB  0
0D94C:  CALL   CA28
0D950:  MOVLW  FB
0D952:  MOVWF  FF6
0D954:  MOVLW  1E
0D956:  MOVWF  FF7
0D958:  MOVLW  00
0D95A:  MOVWF  FF8
0D95C:  MOVLW  07
0D95E:  MOVLB  8
0D960:  MOVWF  xC9
0D962:  MOVLB  0
0D964:  CALL   AA6C
0D968:  MOVLW  10
0D96A:  MOVWF  FE9
0D96C:  MOVFF  378,8D5
0D970:  MOVFF  377,8D4
0D974:  CALL   AA9E
0D978:  MOVLW  05
0D97A:  MOVWF  FF6
0D97C:  MOVLW  1F
0D97E:  MOVWF  FF7
0D980:  MOVLW  00
0D982:  MOVWF  FF8
0D984:  MOVLW  07
0D986:  MOVLB  8
0D988:  MOVWF  xC9
0D98A:  MOVLB  0
0D98C:  CALL   AA6C
0D990:  MOVLW  10
0D992:  MOVWF  FE9
0D994:  MOVFF  37A,8D5
0D998:  MOVFF  379,8D4
0D99C:  CALL   AA9E
0D9A0:  MOVLW  0F
0D9A2:  MOVWF  FF6
0D9A4:  MOVLW  1F
0D9A6:  MOVWF  FF7
0D9A8:  MOVLW  00
0D9AA:  MOVWF  FF8
0D9AC:  MOVLW  09
0D9AE:  MOVLB  8
0D9B0:  MOVWF  xC9
0D9B2:  MOVLB  0
0D9B4:  CALL   AA6C
0D9B8:  MOVLW  89
0D9BA:  MOVWF  FE9
0D9BC:  MOVFF  3D0,8B0
0D9C0:  MOVFF  3CF,8AF
0D9C4:  MOVFF  3CE,8AE
0D9C8:  MOVFF  3CD,8AD
0D9CC:  MOVLW  04
0D9CE:  MOVLB  8
0D9D0:  MOVWF  xB1
0D9D2:  MOVLB  0
0D9D4:  CALL   CA28
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
0D9D8:  MOVF   1F,W
0D9DA:  SUBLW  02
0D9DC:  BNZ   D9E2
0D9DE:  MOVF   20,F
0D9E0:  BZ    DA22
0D9E2:  MOVLW  1E
0D9E4:  MOVWF  FF6
0D9E6:  MOVLW  1F
0D9E8:  MOVWF  FF7
0D9EA:  MOVLW  00
0D9EC:  MOVWF  FF8
0D9EE:  CLRF   1B
0D9F0:  BTFSC  FF2.7
0D9F2:  BSF    1B.7
0D9F4:  BCF    FF2.7
0D9F6:  MOVLW  09
0D9F8:  MOVLB  A
0D9FA:  MOVWF  x19
0D9FC:  MOVLB  0
0D9FE:  CALL   104E
0DA02:  BTFSC  1B.7
0DA04:  BSF    FF2.7
0DA06:  MOVLW  04
0DA08:  MOVWF  FEA
0DA0A:  MOVLW  25
0DA0C:  MOVWF  FE9
0DA0E:  CALL   793C
0DA12:  MOVLW  0D
0DA14:  BTFSS  F9E.4
0DA16:  BRA    DA14
0DA18:  MOVWF  FAD
0DA1A:  MOVLW  0A
0DA1C:  BTFSS  F9E.4
0DA1E:  BRA    DA1C
0DA20:  MOVWF  FAD
0DA22:  GOTO   E3DC (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
0DA26:  MOVLB  8
0DA28:  CLRF   xA0
0DA2A:  MOVF   xA0,W
0DA2C:  SUBLW  03
0DA2E:  BNC   DA4E
0DA30:  MOVF   xA0,W
0DA32:  MULLW  04
0DA34:  MOVF   FF3,W
0DA36:  CLRF   03
0DA38:  ADDLW  D5
0DA3A:  MOVWF  FE9
0DA3C:  MOVLW  03
0DA3E:  ADDWFC 03,W
0DA40:  MOVWF  FEA
0DA42:  CLRF   FEF
0DA44:  CLRF   FEC
0DA46:  CLRF   FEC
0DA48:  CLRF   FEC
0DA4A:  INCF   xA0,F
0DA4C:  BRA    DA2A
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
0DA4E:  MOVLB  3
0DA50:  MOVF   x81,F
0DA52:  BTFSS  FD8.2
0DA54:  BRA    DA5A
0DA56:  MOVF   x82,F
0DA58:  BZ    DAF6
0DA5A:  MOVF   x83,F
0DA5C:  BNZ   DA62
0DA5E:  MOVF   x84,F
0DA60:  BZ    DAF6
....................       blank = NH4_array[0]; 
0DA62:  MOVFF  382,8F6
0DA66:  MOVFF  381,8F5
0DA6A:  MOVLB  0
0DA6C:  CALL   BFAE
0DA70:  MOVFF  03,8A4
0DA74:  MOVFF  02,8A3
0DA78:  MOVFF  01,8A2
0DA7C:  MOVFF  00,8A1
....................       react = NH4_array[1]; 
0DA80:  MOVFF  384,8F6
0DA84:  MOVFF  383,8F5
0DA88:  CALL   BFAE
0DA8C:  MOVFF  03,8A8
0DA90:  MOVFF  02,8A7
0DA94:  MOVFF  01,8A6
0DA98:  MOVFF  00,8A5
....................       ratio = blank / react; 
0DA9C:  MOVFF  8A4,8DC
0DAA0:  MOVFF  8A3,8DB
0DAA4:  MOVFF  8A2,8DA
0DAA8:  MOVFF  8A1,8D9
0DAAC:  MOVFF  8A8,8E0
0DAB0:  MOVFF  8A7,8DF
0DAB4:  MOVFF  8A6,8DE
0DAB8:  MOVFF  8A5,8DD
0DABC:  CALL   BFE4
0DAC0:  MOVFF  03,8AC
0DAC4:  MOVFF  02,8AB
0DAC8:  MOVFF  01,8AA
0DACC:  MOVFF  00,8A9
....................       NH4_abs_array[0] = log10(ratio); 
0DAD0:  MOVFF  8AC,8B0
0DAD4:  MOVFF  8AB,8AF
0DAD8:  MOVFF  8AA,8AE
0DADC:  MOVFF  8A9,8AD
0DAE0:  CALL   C97A
0DAE4:  MOVFF  03,3D8
0DAE8:  MOVFF  02,3D7
0DAEC:  MOVFF  01,3D6
0DAF0:  MOVFF  00,3D5
0DAF4:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
0DAF6:  MOVF   x85,F
0DAF8:  BNZ   DAFE
0DAFA:  MOVF   x86,F
0DAFC:  BZ    DB9A
0DAFE:  MOVF   x87,F
0DB00:  BNZ   DB06
0DB02:  MOVF   x88,F
0DB04:  BZ    DB9A
....................       blank = NH4_array[2]; 
0DB06:  MOVFF  386,8F6
0DB0A:  MOVFF  385,8F5
0DB0E:  MOVLB  0
0DB10:  CALL   BFAE
0DB14:  MOVFF  03,8A4
0DB18:  MOVFF  02,8A3
0DB1C:  MOVFF  01,8A2
0DB20:  MOVFF  00,8A1
....................       react = NH4_array[3]; 
0DB24:  MOVFF  388,8F6
0DB28:  MOVFF  387,8F5
0DB2C:  CALL   BFAE
0DB30:  MOVFF  03,8A8
0DB34:  MOVFF  02,8A7
0DB38:  MOVFF  01,8A6
0DB3C:  MOVFF  00,8A5
....................       ratio = blank / react;    
0DB40:  MOVFF  8A4,8DC
0DB44:  MOVFF  8A3,8DB
0DB48:  MOVFF  8A2,8DA
0DB4C:  MOVFF  8A1,8D9
0DB50:  MOVFF  8A8,8E0
0DB54:  MOVFF  8A7,8DF
0DB58:  MOVFF  8A6,8DE
0DB5C:  MOVFF  8A5,8DD
0DB60:  CALL   BFE4
0DB64:  MOVFF  03,8AC
0DB68:  MOVFF  02,8AB
0DB6C:  MOVFF  01,8AA
0DB70:  MOVFF  00,8A9
....................       NH4_abs_array[1] = log10(ratio); 
0DB74:  MOVFF  8AC,8B0
0DB78:  MOVFF  8AB,8AF
0DB7C:  MOVFF  8AA,8AE
0DB80:  MOVFF  8A9,8AD
0DB84:  CALL   C97A
0DB88:  MOVFF  03,3DC
0DB8C:  MOVFF  02,3DB
0DB90:  MOVFF  01,3DA
0DB94:  MOVFF  00,3D9
0DB98:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
0DB9A:  MOVF   x89,F
0DB9C:  BNZ   DBA2
0DB9E:  MOVF   x8A,F
0DBA0:  BZ    DC3E
0DBA2:  MOVF   x8B,F
0DBA4:  BNZ   DBAA
0DBA6:  MOVF   x8C,F
0DBA8:  BZ    DC3E
....................       blank = NH4_array[4]; 
0DBAA:  MOVFF  38A,8F6
0DBAE:  MOVFF  389,8F5
0DBB2:  MOVLB  0
0DBB4:  CALL   BFAE
0DBB8:  MOVFF  03,8A4
0DBBC:  MOVFF  02,8A3
0DBC0:  MOVFF  01,8A2
0DBC4:  MOVFF  00,8A1
....................       react = NH4_array[5]; 
0DBC8:  MOVFF  38C,8F6
0DBCC:  MOVFF  38B,8F5
0DBD0:  CALL   BFAE
0DBD4:  MOVFF  03,8A8
0DBD8:  MOVFF  02,8A7
0DBDC:  MOVFF  01,8A6
0DBE0:  MOVFF  00,8A5
....................       ratio = blank / react; 
0DBE4:  MOVFF  8A4,8DC
0DBE8:  MOVFF  8A3,8DB
0DBEC:  MOVFF  8A2,8DA
0DBF0:  MOVFF  8A1,8D9
0DBF4:  MOVFF  8A8,8E0
0DBF8:  MOVFF  8A7,8DF
0DBFC:  MOVFF  8A6,8DE
0DC00:  MOVFF  8A5,8DD
0DC04:  CALL   BFE4
0DC08:  MOVFF  03,8AC
0DC0C:  MOVFF  02,8AB
0DC10:  MOVFF  01,8AA
0DC14:  MOVFF  00,8A9
....................       NH4_abs_array[2] = log10(ratio); 
0DC18:  MOVFF  8AC,8B0
0DC1C:  MOVFF  8AB,8AF
0DC20:  MOVFF  8AA,8AE
0DC24:  MOVFF  8A9,8AD
0DC28:  CALL   C97A
0DC2C:  MOVFF  03,3E0
0DC30:  MOVFF  02,3DF
0DC34:  MOVFF  01,3DE
0DC38:  MOVFF  00,3DD
0DC3C:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
0DC3E:  MOVF   x8D,F
0DC40:  BNZ   DC46
0DC42:  MOVF   x8E,F
0DC44:  BZ    DCE2
0DC46:  MOVF   x8F,F
0DC48:  BNZ   DC4E
0DC4A:  MOVF   x90,F
0DC4C:  BZ    DCE2
....................       blank = NH4_array[6]; 
0DC4E:  MOVFF  38E,8F6
0DC52:  MOVFF  38D,8F5
0DC56:  MOVLB  0
0DC58:  CALL   BFAE
0DC5C:  MOVFF  03,8A4
0DC60:  MOVFF  02,8A3
0DC64:  MOVFF  01,8A2
0DC68:  MOVFF  00,8A1
....................       react = NH4_array[7]; 
0DC6C:  MOVFF  390,8F6
0DC70:  MOVFF  38F,8F5
0DC74:  CALL   BFAE
0DC78:  MOVFF  03,8A8
0DC7C:  MOVFF  02,8A7
0DC80:  MOVFF  01,8A6
0DC84:  MOVFF  00,8A5
....................       ratio = blank / react; 
0DC88:  MOVFF  8A4,8DC
0DC8C:  MOVFF  8A3,8DB
0DC90:  MOVFF  8A2,8DA
0DC94:  MOVFF  8A1,8D9
0DC98:  MOVFF  8A8,8E0
0DC9C:  MOVFF  8A7,8DF
0DCA0:  MOVFF  8A6,8DE
0DCA4:  MOVFF  8A5,8DD
0DCA8:  CALL   BFE4
0DCAC:  MOVFF  03,8AC
0DCB0:  MOVFF  02,8AB
0DCB4:  MOVFF  01,8AA
0DCB8:  MOVFF  00,8A9
....................       NH4_abs_array[3] = log10(ratio); 
0DCBC:  MOVFF  8AC,8B0
0DCC0:  MOVFF  8AB,8AF
0DCC4:  MOVFF  8AA,8AE
0DCC8:  MOVFF  8A9,8AD
0DCCC:  CALL   C97A
0DCD0:  MOVFF  03,3E4
0DCD4:  MOVFF  02,3E3
0DCD8:  MOVFF  01,3E2
0DCDC:  MOVFF  00,3E1
0DCE0:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
0DCE2:  MOVLW  04
0DCE4:  MOVWF  1E
0DCE6:  MOVLW  25
0DCE8:  MOVWF  1D
0DCEA:  MOVLW  2C
0DCEC:  MOVWF  FF6
0DCEE:  MOVLW  1F
0DCF0:  MOVWF  FF7
0DCF2:  MOVLW  00
0DCF4:  MOVWF  FF8
0DCF6:  MOVLW  06
0DCF8:  MOVLB  8
0DCFA:  MOVWF  xC9
0DCFC:  MOVLB  0
0DCFE:  CALL   AA6C
0DD02:  MOVLW  10
0DD04:  MOVWF  FE9
0DD06:  MOVFF  382,8D5
0DD0A:  MOVFF  381,8D4
0DD0E:  CALL   AA9E
0DD12:  MOVLW  35
0DD14:  MOVWF  FF6
0DD16:  MOVLW  1F
0DD18:  MOVWF  FF7
0DD1A:  MOVLW  00
0DD1C:  MOVWF  FF8
0DD1E:  MOVLW  07
0DD20:  MOVLB  8
0DD22:  MOVWF  xC9
0DD24:  MOVLB  0
0DD26:  CALL   AA6C
0DD2A:  MOVLW  10
0DD2C:  MOVWF  FE9
0DD2E:  MOVFF  384,8D5
0DD32:  MOVFF  383,8D4
0DD36:  CALL   AA9E
0DD3A:  MOVLW  3F
0DD3C:  MOVWF  FF6
0DD3E:  MOVLW  1F
0DD40:  MOVWF  FF7
0DD42:  MOVLW  00
0DD44:  MOVWF  FF8
0DD46:  MOVLW  09
0DD48:  MOVLB  8
0DD4A:  MOVWF  xC9
0DD4C:  MOVLB  0
0DD4E:  CALL   AA6C
0DD52:  MOVLW  89
0DD54:  MOVWF  FE9
0DD56:  MOVFF  3D8,8B0
0DD5A:  MOVFF  3D7,8AF
0DD5E:  MOVFF  3D6,8AE
0DD62:  MOVFF  3D5,8AD
0DD66:  MOVLW  04
0DD68:  MOVLB  8
0DD6A:  MOVWF  xB1
0DD6C:  MOVLB  0
0DD6E:  CALL   CA28
0DD72:  MOVLW  4D
0DD74:  MOVWF  FF6
0DD76:  MOVLW  1F
0DD78:  MOVWF  FF7
0DD7A:  MOVLW  00
0DD7C:  MOVWF  FF8
0DD7E:  MOVLW  07
0DD80:  MOVLB  8
0DD82:  MOVWF  xC9
0DD84:  MOVLB  0
0DD86:  CALL   AA6C
0DD8A:  MOVLW  10
0DD8C:  MOVWF  FE9
0DD8E:  MOVFF  386,8D5
0DD92:  MOVFF  385,8D4
0DD96:  CALL   AA9E
0DD9A:  MOVLW  57
0DD9C:  MOVWF  FF6
0DD9E:  MOVLW  1F
0DDA0:  MOVWF  FF7
0DDA2:  MOVLW  00
0DDA4:  MOVWF  FF8
0DDA6:  MOVLW  07
0DDA8:  MOVLB  8
0DDAA:  MOVWF  xC9
0DDAC:  MOVLB  0
0DDAE:  CALL   AA6C
0DDB2:  MOVLW  10
0DDB4:  MOVWF  FE9
0DDB6:  MOVFF  388,8D5
0DDBA:  MOVFF  387,8D4
0DDBE:  CALL   AA9E
0DDC2:  MOVLW  61
0DDC4:  MOVWF  FF6
0DDC6:  MOVLW  1F
0DDC8:  MOVWF  FF7
0DDCA:  MOVLW  00
0DDCC:  MOVWF  FF8
0DDCE:  MOVLW  09
0DDD0:  MOVLB  8
0DDD2:  MOVWF  xC9
0DDD4:  MOVLB  0
0DDD6:  CALL   AA6C
0DDDA:  MOVLW  89
0DDDC:  MOVWF  FE9
0DDDE:  MOVFF  3DC,8B0
0DDE2:  MOVFF  3DB,8AF
0DDE6:  MOVFF  3DA,8AE
0DDEA:  MOVFF  3D9,8AD
0DDEE:  MOVLW  04
0DDF0:  MOVLB  8
0DDF2:  MOVWF  xB1
0DDF4:  MOVLB  0
0DDF6:  CALL   CA28
0DDFA:  MOVLW  6F
0DDFC:  MOVWF  FF6
0DDFE:  MOVLW  1F
0DE00:  MOVWF  FF7
0DE02:  MOVLW  00
0DE04:  MOVWF  FF8
0DE06:  MOVLW  07
0DE08:  MOVLB  8
0DE0A:  MOVWF  xC9
0DE0C:  MOVLB  0
0DE0E:  CALL   AA6C
0DE12:  MOVLW  10
0DE14:  MOVWF  FE9
0DE16:  MOVFF  38A,8D5
0DE1A:  MOVFF  389,8D4
0DE1E:  CALL   AA9E
0DE22:  MOVLW  79
0DE24:  MOVWF  FF6
0DE26:  MOVLW  1F
0DE28:  MOVWF  FF7
0DE2A:  MOVLW  00
0DE2C:  MOVWF  FF8
0DE2E:  MOVLW  07
0DE30:  MOVLB  8
0DE32:  MOVWF  xC9
0DE34:  MOVLB  0
0DE36:  CALL   AA6C
0DE3A:  MOVLW  10
0DE3C:  MOVWF  FE9
0DE3E:  MOVFF  38C,8D5
0DE42:  MOVFF  38B,8D4
0DE46:  CALL   AA9E
0DE4A:  MOVLW  83
0DE4C:  MOVWF  FF6
0DE4E:  MOVLW  1F
0DE50:  MOVWF  FF7
0DE52:  MOVLW  00
0DE54:  MOVWF  FF8
0DE56:  MOVLW  09
0DE58:  MOVLB  8
0DE5A:  MOVWF  xC9
0DE5C:  MOVLB  0
0DE5E:  CALL   AA6C
0DE62:  MOVLW  89
0DE64:  MOVWF  FE9
0DE66:  MOVFF  3E0,8B0
0DE6A:  MOVFF  3DF,8AF
0DE6E:  MOVFF  3DE,8AE
0DE72:  MOVFF  3DD,8AD
0DE76:  MOVLW  04
0DE78:  MOVLB  8
0DE7A:  MOVWF  xB1
0DE7C:  MOVLB  0
0DE7E:  CALL   CA28
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
0DE82:  MOVF   1F,W
0DE84:  SUBLW  02
0DE86:  BNZ   DE8C
0DE88:  MOVF   20,F
0DE8A:  BZ    DECC
0DE8C:  MOVLW  92
0DE8E:  MOVWF  FF6
0DE90:  MOVLW  1F
0DE92:  MOVWF  FF7
0DE94:  MOVLW  00
0DE96:  MOVWF  FF8
0DE98:  CLRF   1B
0DE9A:  BTFSC  FF2.7
0DE9C:  BSF    1B.7
0DE9E:  BCF    FF2.7
0DEA0:  MOVLW  09
0DEA2:  MOVLB  A
0DEA4:  MOVWF  x19
0DEA6:  MOVLB  0
0DEA8:  CALL   104E
0DEAC:  BTFSC  1B.7
0DEAE:  BSF    FF2.7
0DEB0:  MOVLW  04
0DEB2:  MOVWF  FEA
0DEB4:  MOVLW  25
0DEB6:  MOVWF  FE9
0DEB8:  CALL   793C
0DEBC:  MOVLW  0D
0DEBE:  BTFSS  F9E.4
0DEC0:  BRA    DEBE
0DEC2:  MOVWF  FAD
0DEC4:  MOVLW  0A
0DEC6:  BTFSS  F9E.4
0DEC8:  BRA    DEC6
0DECA:  MOVWF  FAD
0DECC:  GOTO   E3DC (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
0DED0:  MOVLB  8
0DED2:  CLRF   xA0
0DED4:  MOVF   xA0,W
0DED6:  SUBLW  03
0DED8:  BNC   DEF8
0DEDA:  MOVF   xA0,W
0DEDC:  MULLW  04
0DEDE:  MOVF   FF3,W
0DEE0:  CLRF   03
0DEE2:  ADDLW  E5
0DEE4:  MOVWF  FE9
0DEE6:  MOVLW  03
0DEE8:  ADDWFC 03,W
0DEEA:  MOVWF  FEA
0DEEC:  CLRF   FEF
0DEEE:  CLRF   FEC
0DEF0:  CLRF   FEC
0DEF2:  CLRF   FEC
0DEF4:  INCF   xA0,F
0DEF6:  BRA    DED4
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
0DEF8:  MOVLB  3
0DEFA:  MOVF   x93,F
0DEFC:  BTFSS  FD8.2
0DEFE:  BRA    DF04
0DF00:  MOVF   x94,F
0DF02:  BZ    DFA0
0DF04:  MOVF   x95,F
0DF06:  BNZ   DF0C
0DF08:  MOVF   x96,F
0DF0A:  BZ    DFA0
....................       blank = SiO_array[0]; 
0DF0C:  MOVFF  394,8F6
0DF10:  MOVFF  393,8F5
0DF14:  MOVLB  0
0DF16:  CALL   BFAE
0DF1A:  MOVFF  03,8A4
0DF1E:  MOVFF  02,8A3
0DF22:  MOVFF  01,8A2
0DF26:  MOVFF  00,8A1
....................       react = SiO_array[1]; 
0DF2A:  MOVFF  396,8F6
0DF2E:  MOVFF  395,8F5
0DF32:  CALL   BFAE
0DF36:  MOVFF  03,8A8
0DF3A:  MOVFF  02,8A7
0DF3E:  MOVFF  01,8A6
0DF42:  MOVFF  00,8A5
....................       ratio = blank / react; 
0DF46:  MOVFF  8A4,8DC
0DF4A:  MOVFF  8A3,8DB
0DF4E:  MOVFF  8A2,8DA
0DF52:  MOVFF  8A1,8D9
0DF56:  MOVFF  8A8,8E0
0DF5A:  MOVFF  8A7,8DF
0DF5E:  MOVFF  8A6,8DE
0DF62:  MOVFF  8A5,8DD
0DF66:  CALL   BFE4
0DF6A:  MOVFF  03,8AC
0DF6E:  MOVFF  02,8AB
0DF72:  MOVFF  01,8AA
0DF76:  MOVFF  00,8A9
....................       SiO_abs_array[0] = log10(ratio); 
0DF7A:  MOVFF  8AC,8B0
0DF7E:  MOVFF  8AB,8AF
0DF82:  MOVFF  8AA,8AE
0DF86:  MOVFF  8A9,8AD
0DF8A:  CALL   C97A
0DF8E:  MOVFF  03,3E8
0DF92:  MOVFF  02,3E7
0DF96:  MOVFF  01,3E6
0DF9A:  MOVFF  00,3E5
0DF9E:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
0DFA0:  MOVF   x97,F
0DFA2:  BNZ   DFA8
0DFA4:  MOVF   x98,F
0DFA6:  BZ    E044
0DFA8:  MOVF   x99,F
0DFAA:  BNZ   DFB0
0DFAC:  MOVF   x9A,F
0DFAE:  BZ    E044
....................       blank = SiO_array[2]; 
0DFB0:  MOVFF  398,8F6
0DFB4:  MOVFF  397,8F5
0DFB8:  MOVLB  0
0DFBA:  CALL   BFAE
0DFBE:  MOVFF  03,8A4
0DFC2:  MOVFF  02,8A3
0DFC6:  MOVFF  01,8A2
0DFCA:  MOVFF  00,8A1
....................       react = SiO_array[3]; 
0DFCE:  MOVFF  39A,8F6
0DFD2:  MOVFF  399,8F5
0DFD6:  CALL   BFAE
0DFDA:  MOVFF  03,8A8
0DFDE:  MOVFF  02,8A7
0DFE2:  MOVFF  01,8A6
0DFE6:  MOVFF  00,8A5
....................       ratio = blank / react;    
0DFEA:  MOVFF  8A4,8DC
0DFEE:  MOVFF  8A3,8DB
0DFF2:  MOVFF  8A2,8DA
0DFF6:  MOVFF  8A1,8D9
0DFFA:  MOVFF  8A8,8E0
0DFFE:  MOVFF  8A7,8DF
0E002:  MOVFF  8A6,8DE
0E006:  MOVFF  8A5,8DD
0E00A:  CALL   BFE4
0E00E:  MOVFF  03,8AC
0E012:  MOVFF  02,8AB
0E016:  MOVFF  01,8AA
0E01A:  MOVFF  00,8A9
....................       SiO_abs_array[1] = log10(ratio); 
0E01E:  MOVFF  8AC,8B0
0E022:  MOVFF  8AB,8AF
0E026:  MOVFF  8AA,8AE
0E02A:  MOVFF  8A9,8AD
0E02E:  CALL   C97A
0E032:  MOVFF  03,3EC
0E036:  MOVFF  02,3EB
0E03A:  MOVFF  01,3EA
0E03E:  MOVFF  00,3E9
0E042:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
0E044:  MOVF   x9B,F
0E046:  BNZ   E04C
0E048:  MOVF   x9C,F
0E04A:  BZ    E0E8
0E04C:  MOVF   x9D,F
0E04E:  BNZ   E054
0E050:  MOVF   x9E,F
0E052:  BZ    E0E8
....................       blank = SiO_array[4]; 
0E054:  MOVFF  39C,8F6
0E058:  MOVFF  39B,8F5
0E05C:  MOVLB  0
0E05E:  CALL   BFAE
0E062:  MOVFF  03,8A4
0E066:  MOVFF  02,8A3
0E06A:  MOVFF  01,8A2
0E06E:  MOVFF  00,8A1
....................       react = SiO_array[5]; 
0E072:  MOVFF  39E,8F6
0E076:  MOVFF  39D,8F5
0E07A:  CALL   BFAE
0E07E:  MOVFF  03,8A8
0E082:  MOVFF  02,8A7
0E086:  MOVFF  01,8A6
0E08A:  MOVFF  00,8A5
....................       ratio = blank / react; 
0E08E:  MOVFF  8A4,8DC
0E092:  MOVFF  8A3,8DB
0E096:  MOVFF  8A2,8DA
0E09A:  MOVFF  8A1,8D9
0E09E:  MOVFF  8A8,8E0
0E0A2:  MOVFF  8A7,8DF
0E0A6:  MOVFF  8A6,8DE
0E0AA:  MOVFF  8A5,8DD
0E0AE:  CALL   BFE4
0E0B2:  MOVFF  03,8AC
0E0B6:  MOVFF  02,8AB
0E0BA:  MOVFF  01,8AA
0E0BE:  MOVFF  00,8A9
....................       SiO_abs_array[2] = log10(ratio); 
0E0C2:  MOVFF  8AC,8B0
0E0C6:  MOVFF  8AB,8AF
0E0CA:  MOVFF  8AA,8AE
0E0CE:  MOVFF  8A9,8AD
0E0D2:  CALL   C97A
0E0D6:  MOVFF  03,3F0
0E0DA:  MOVFF  02,3EF
0E0DE:  MOVFF  01,3EE
0E0E2:  MOVFF  00,3ED
0E0E6:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
0E0E8:  MOVF   x9F,F
0E0EA:  BNZ   E0F0
0E0EC:  MOVF   xA0,F
0E0EE:  BZ    E18C
0E0F0:  MOVF   xA1,F
0E0F2:  BNZ   E0F8
0E0F4:  MOVF   xA2,F
0E0F6:  BZ    E18C
....................       blank = SiO_array[6]; 
0E0F8:  MOVFF  3A0,8F6
0E0FC:  MOVFF  39F,8F5
0E100:  MOVLB  0
0E102:  CALL   BFAE
0E106:  MOVFF  03,8A4
0E10A:  MOVFF  02,8A3
0E10E:  MOVFF  01,8A2
0E112:  MOVFF  00,8A1
....................       react = SiO_array[7]; 
0E116:  MOVFF  3A2,8F6
0E11A:  MOVFF  3A1,8F5
0E11E:  CALL   BFAE
0E122:  MOVFF  03,8A8
0E126:  MOVFF  02,8A7
0E12A:  MOVFF  01,8A6
0E12E:  MOVFF  00,8A5
....................       ratio = blank / react; 
0E132:  MOVFF  8A4,8DC
0E136:  MOVFF  8A3,8DB
0E13A:  MOVFF  8A2,8DA
0E13E:  MOVFF  8A1,8D9
0E142:  MOVFF  8A8,8E0
0E146:  MOVFF  8A7,8DF
0E14A:  MOVFF  8A6,8DE
0E14E:  MOVFF  8A5,8DD
0E152:  CALL   BFE4
0E156:  MOVFF  03,8AC
0E15A:  MOVFF  02,8AB
0E15E:  MOVFF  01,8AA
0E162:  MOVFF  00,8A9
....................       SiO_abs_array[3] = log10(ratio); 
0E166:  MOVFF  8AC,8B0
0E16A:  MOVFF  8AB,8AF
0E16E:  MOVFF  8AA,8AE
0E172:  MOVFF  8A9,8AD
0E176:  CALL   C97A
0E17A:  MOVFF  03,3F4
0E17E:  MOVFF  02,3F3
0E182:  MOVFF  01,3F2
0E186:  MOVFF  00,3F1
0E18A:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
0E18C:  MOVLW  04
0E18E:  MOVWF  1E
0E190:  MOVLW  25
0E192:  MOVWF  1D
0E194:  MOVLW  A0
0E196:  MOVWF  FF6
0E198:  MOVLW  1F
0E19A:  MOVWF  FF7
0E19C:  MOVLW  00
0E19E:  MOVWF  FF8
0E1A0:  MOVLW  06
0E1A2:  MOVLB  8
0E1A4:  MOVWF  xC9
0E1A6:  MOVLB  0
0E1A8:  CALL   AA6C
0E1AC:  MOVLW  10
0E1AE:  MOVWF  FE9
0E1B0:  MOVFF  394,8D5
0E1B4:  MOVFF  393,8D4
0E1B8:  CALL   AA9E
0E1BC:  MOVLW  A9
0E1BE:  MOVWF  FF6
0E1C0:  MOVLW  1F
0E1C2:  MOVWF  FF7
0E1C4:  MOVLW  00
0E1C6:  MOVWF  FF8
0E1C8:  MOVLW  07
0E1CA:  MOVLB  8
0E1CC:  MOVWF  xC9
0E1CE:  MOVLB  0
0E1D0:  CALL   AA6C
0E1D4:  MOVLW  10
0E1D6:  MOVWF  FE9
0E1D8:  MOVFF  396,8D5
0E1DC:  MOVFF  395,8D4
0E1E0:  CALL   AA9E
0E1E4:  MOVLW  B3
0E1E6:  MOVWF  FF6
0E1E8:  MOVLW  1F
0E1EA:  MOVWF  FF7
0E1EC:  MOVLW  00
0E1EE:  MOVWF  FF8
0E1F0:  MOVLW  09
0E1F2:  MOVLB  8
0E1F4:  MOVWF  xC9
0E1F6:  MOVLB  0
0E1F8:  CALL   AA6C
0E1FC:  MOVLW  89
0E1FE:  MOVWF  FE9
0E200:  MOVFF  3E8,8B0
0E204:  MOVFF  3E7,8AF
0E208:  MOVFF  3E6,8AE
0E20C:  MOVFF  3E5,8AD
0E210:  MOVLW  04
0E212:  MOVLB  8
0E214:  MOVWF  xB1
0E216:  MOVLB  0
0E218:  CALL   CA28
0E21C:  MOVLW  C1
0E21E:  MOVWF  FF6
0E220:  MOVLW  1F
0E222:  MOVWF  FF7
0E224:  MOVLW  00
0E226:  MOVWF  FF8
0E228:  MOVLW  07
0E22A:  MOVLB  8
0E22C:  MOVWF  xC9
0E22E:  MOVLB  0
0E230:  CALL   AA6C
0E234:  MOVLW  10
0E236:  MOVWF  FE9
0E238:  MOVFF  398,8D5
0E23C:  MOVFF  397,8D4
0E240:  CALL   AA9E
0E244:  MOVLW  CB
0E246:  MOVWF  FF6
0E248:  MOVLW  1F
0E24A:  MOVWF  FF7
0E24C:  MOVLW  00
0E24E:  MOVWF  FF8
0E250:  MOVLW  07
0E252:  MOVLB  8
0E254:  MOVWF  xC9
0E256:  MOVLB  0
0E258:  CALL   AA6C
0E25C:  MOVLW  10
0E25E:  MOVWF  FE9
0E260:  MOVFF  39A,8D5
0E264:  MOVFF  399,8D4
0E268:  CALL   AA9E
0E26C:  MOVLW  D5
0E26E:  MOVWF  FF6
0E270:  MOVLW  1F
0E272:  MOVWF  FF7
0E274:  MOVLW  00
0E276:  MOVWF  FF8
0E278:  MOVLW  09
0E27A:  MOVLB  8
0E27C:  MOVWF  xC9
0E27E:  MOVLB  0
0E280:  CALL   AA6C
0E284:  MOVLW  89
0E286:  MOVWF  FE9
0E288:  MOVFF  3EC,8B0
0E28C:  MOVFF  3EB,8AF
0E290:  MOVFF  3EA,8AE
0E294:  MOVFF  3E9,8AD
0E298:  MOVLW  04
0E29A:  MOVLB  8
0E29C:  MOVWF  xB1
0E29E:  MOVLB  0
0E2A0:  CALL   CA28
0E2A4:  MOVLW  E3
0E2A6:  MOVWF  FF6
0E2A8:  MOVLW  1F
0E2AA:  MOVWF  FF7
0E2AC:  MOVLW  00
0E2AE:  MOVWF  FF8
0E2B0:  MOVLW  07
0E2B2:  MOVLB  8
0E2B4:  MOVWF  xC9
0E2B6:  MOVLB  0
0E2B8:  CALL   AA6C
0E2BC:  MOVLW  10
0E2BE:  MOVWF  FE9
0E2C0:  MOVFF  39C,8D5
0E2C4:  MOVFF  39B,8D4
0E2C8:  CALL   AA9E
0E2CC:  MOVLW  ED
0E2CE:  MOVWF  FF6
0E2D0:  MOVLW  1F
0E2D2:  MOVWF  FF7
0E2D4:  MOVLW  00
0E2D6:  MOVWF  FF8
0E2D8:  MOVLW  07
0E2DA:  MOVLB  8
0E2DC:  MOVWF  xC9
0E2DE:  MOVLB  0
0E2E0:  CALL   AA6C
0E2E4:  MOVLW  10
0E2E6:  MOVWF  FE9
0E2E8:  MOVFF  39E,8D5
0E2EC:  MOVFF  39D,8D4
0E2F0:  CALL   AA9E
0E2F4:  MOVLW  F7
0E2F6:  MOVWF  FF6
0E2F8:  MOVLW  1F
0E2FA:  MOVWF  FF7
0E2FC:  MOVLW  00
0E2FE:  MOVWF  FF8
0E300:  MOVLW  09
0E302:  MOVLB  8
0E304:  MOVWF  xC9
0E306:  MOVLB  0
0E308:  CALL   AA6C
0E30C:  MOVLW  89
0E30E:  MOVWF  FE9
0E310:  MOVFF  3F0,8B0
0E314:  MOVFF  3EF,8AF
0E318:  MOVFF  3EE,8AE
0E31C:  MOVFF  3ED,8AD
0E320:  MOVLW  04
0E322:  MOVLB  8
0E324:  MOVWF  xB1
0E326:  MOVLB  0
0E328:  CALL   CA28
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
0E32C:  MOVF   1F,W
0E32E:  SUBLW  02
0E330:  BNZ   E336
0E332:  MOVF   20,F
0E334:  BZ    E376
0E336:  MOVLW  06
0E338:  MOVWF  FF6
0E33A:  MOVLW  20
0E33C:  MOVWF  FF7
0E33E:  MOVLW  00
0E340:  MOVWF  FF8
0E342:  CLRF   1B
0E344:  BTFSC  FF2.7
0E346:  BSF    1B.7
0E348:  BCF    FF2.7
0E34A:  MOVLW  09
0E34C:  MOVLB  A
0E34E:  MOVWF  x19
0E350:  MOVLB  0
0E352:  CALL   104E
0E356:  BTFSC  1B.7
0E358:  BSF    FF2.7
0E35A:  MOVLW  04
0E35C:  MOVWF  FEA
0E35E:  MOVLW  25
0E360:  MOVWF  FE9
0E362:  CALL   793C
0E366:  MOVLW  0D
0E368:  BTFSS  F9E.4
0E36A:  BRA    E368
0E36C:  MOVWF  FAD
0E36E:  MOVLW  0A
0E370:  BTFSS  F9E.4
0E372:  BRA    E370
0E374:  MOVWF  FAD
0E376:  GOTO   E3DC (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
0E37A:  MOVLW  04
0E37C:  MOVWF  FEA
0E37E:  MOVLW  25
0E380:  MOVWF  FE9
0E382:  MOVLW  00
0E384:  CALL   056C
0E388:  TBLRD*-
0E38A:  TBLRD*+
0E38C:  MOVF   FF5,W
0E38E:  MOVWF  FEE
0E390:  IORLW  00
0E392:  BNZ   E38A
....................     
....................    switch (chem){ 
0E394:  MOVLW  14
0E396:  MOVWF  FF6
0E398:  MOVLW  20
0E39A:  MOVWF  FF7
0E39C:  MOVLW  00
0E39E:  MOVWF  FF8
0E3A0:  MOVLW  03
0E3A2:  MOVWF  FEA
0E3A4:  MOVLW  3D
0E3A6:  MOVWF  FE9
0E3A8:  CALL   BF74
0E3AC:  MOVF   01,W
0E3AE:  BZ    E3C2
0E3B0:  XORLW  01
0E3B2:  BZ    E3C8
0E3B4:  XORLW  03
0E3B6:  BZ    E3CE
0E3B8:  XORLW  01
0E3BA:  BZ    E3D4
0E3BC:  XORLW  07
0E3BE:  BZ    E3DA
0E3C0:  BRA    E3DC
....................       case "NO3" : calc_abs_NO3(); 
0E3C2:  GOTO   CC36
....................          break; 
0E3C6:  BRA    E3DC
....................       case "NO2" : calc_abs_NO2 (); 
0E3C8:  GOTO   D0D2
....................          break;    
0E3CC:  BRA    E3DC
....................       case "PO4" : calc_abs_PO4(); 
0E3CE:  GOTO   D57C
....................          break; 
0E3D2:  BRA    E3DC
....................       case "NH4" : calc_abs_NH4(); 
0E3D4:  GOTO   DA26
....................          break; 
0E3D8:  BRA    E3DC
....................       case "SiO" : calc_abs_SiO(); 
0E3DA:  BRA    DED0
....................          break; 
....................    } 
0E3DC:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
*
0E3F2:  RCALL  E3DE
....................     
....................    if (data_available == TRUE) { 
0E3F4:  MOVLB  3
0E3F6:  DECFSZ x3B,W
0E3F8:  BRA    E4FC
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
0E3FA:  MOVLB  8
0E3FC:  CLRF   xD7
0E3FE:  MOVLW  67
0E400:  MOVWF  xD6
0E402:  MOVLW  02
0E404:  MOVWF  xD9
0E406:  MOVLW  B7
0E408:  MOVWF  xD8
0E40A:  MOVLB  0
0E40C:  CALL   54B8
....................       strcat(data_buffer, comma); 
0E410:  MOVLB  8
0E412:  CLRF   xD7
0E414:  MOVLW  67
0E416:  MOVWF  xD6
0E418:  MOVLW  03
0E41A:  MOVWF  xD9
0E41C:  MOVLW  39
0E41E:  MOVWF  xD8
0E420:  MOVLB  0
0E422:  CALL   54B8
....................       strcat(data_buffer, chem); 
0E426:  MOVLB  8
0E428:  CLRF   xD7
0E42A:  MOVLW  67
0E42C:  MOVWF  xD6
0E42E:  MOVLW  03
0E430:  MOVWF  xD9
0E432:  MOVLW  3D
0E434:  MOVWF  xD8
0E436:  MOVLB  0
0E438:  CALL   54B8
....................       strcat(data_buffer, comma); 
0E43C:  MOVLB  8
0E43E:  CLRF   xD7
0E440:  MOVLW  67
0E442:  MOVWF  xD6
0E444:  MOVLW  03
0E446:  MOVWF  xD9
0E448:  MOVLW  39
0E44A:  MOVWF  xD8
0E44C:  MOVLB  0
0E44E:  CALL   54B8
....................       strcat(data_buffer, abs_str); 
0E452:  MOVLB  8
0E454:  CLRF   xD7
0E456:  MOVLW  67
0E458:  MOVWF  xD6
0E45A:  MOVLW  04
0E45C:  MOVWF  xD9
0E45E:  MOVLW  25
0E460:  MOVWF  xD8
0E462:  MOVLB  0
0E464:  CALL   54B8
....................       strcat(data_buffer, endofline); 
0E468:  MOVLB  8
0E46A:  CLRF   xD7
0E46C:  MOVLW  67
0E46E:  MOVWF  xD6
0E470:  MOVLW  07
0E472:  MOVWF  xD9
0E474:  MOVLW  CE
0E476:  MOVWF  xD8
0E478:  MOVLB  0
0E47A:  CALL   54B8
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
0E47E:  MOVF   1F,W
0E480:  SUBLW  04
0E482:  BNZ   E4A2
0E484:  MOVF   20,F
0E486:  BNZ   E4A2
0E488:  CLRF   FEA
0E48A:  MOVLW  67
0E48C:  MOVWF  FE9
0E48E:  CALL   793C
0E492:  MOVLW  0D
0E494:  BTFSS  F9E.4
0E496:  BRA    E494
0E498:  MOVWF  FAD
0E49A:  MOVLW  0A
0E49C:  BTFSS  F9E.4
0E49E:  BRA    E49C
0E4A0:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
0E4A2:  MOVLB  2
0E4A4:  MOVF   xDC,F
0E4A6:  BNZ   E4FA
....................        
....................          buffer_select = 0; 
0E4A8:  MOVLB  0
0E4AA:  CLRF   x66
....................           
....................          heartbeat(FALSE); 
0E4AC:  MOVLB  8
0E4AE:  CLRF   xCB
0E4B0:  MOVLB  0
0E4B2:  CALL   555C
....................             append_data(file_ptr_rel_all); 
0E4B6:  MOVLW  02
0E4B8:  MOVLB  8
0E4BA:  MOVWF  xCC
0E4BC:  MOVLW  F9
0E4BE:  MOVWF  xCB
0E4C0:  MOVLB  0
0E4C2:  CALL   8298
....................          heartbeat(TRUE);          
0E4C6:  MOVLW  01
0E4C8:  MOVLB  8
0E4CA:  MOVWF  xCB
0E4CC:  MOVLB  0
0E4CE:  CALL   555C
....................           
....................          heartbeat(FALSE); 
0E4D2:  MOVLB  8
0E4D4:  CLRF   xCB
0E4D6:  MOVLB  0
0E4D8:  CALL   555C
....................             append_data(file_ptr_rel_new);    
0E4DC:  MOVLW  03
0E4DE:  MOVLB  8
0E4E0:  MOVWF  xCC
0E4E2:  MOVLW  07
0E4E4:  MOVWF  xCB
0E4E6:  MOVLB  0
0E4E8:  CALL   8298
....................          heartbeat(TRUE); 
0E4EC:  MOVLW  01
0E4EE:  MOVLB  8
0E4F0:  MOVWF  xCB
0E4F2:  MOVLB  0
0E4F4:  CALL   555C
0E4F8:  MOVLB  2
0E4FA:  MOVLB  3
....................       } 
....................    } 
0E4FC:  MOVLB  0
0E4FE:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
12638:  MOVLW  2C
1263A:  MOVLB  8
1263C:  MOVWF  x7C
1263E:  CLRF   x7D
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
12640:  MOVLW  0D
12642:  MOVWF  x7E
12644:  MOVLW  0A
12646:  MOVWF  x7F
12648:  CLRF   x80
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
1264A:  MOVLB  0
1264C:  CALL   E3DE
....................    time_stamp(); 
12650:  CALL   53F4
....................    strcat(data_buffer, time_stmp_str); 
12654:  MOVLB  8
12656:  CLRF   xD7
12658:  MOVLW  67
1265A:  MOVWF  xD6
1265C:  MOVLW  02
1265E:  MOVWF  xD9
12660:  MOVLW  99
12662:  MOVWF  xD8
12664:  MOVLB  0
12666:  CALL   54B8
....................    strcat(data_buffer, comma); 
1266A:  MOVLB  8
1266C:  CLRF   xD7
1266E:  MOVLW  67
12670:  MOVWF  xD6
12672:  MOVLW  08
12674:  MOVWF  xD9
12676:  MOVLW  7C
12678:  MOVWF  xD8
1267A:  MOVLB  0
1267C:  CALL   54B8
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
12680:  MOVLW  08
12682:  MOVWF  1E
12684:  MOVLW  81
12686:  MOVWF  1D
12688:  MOVFF  87B,8CB
1268C:  MOVLW  1B
1268E:  MOVLB  8
12690:  MOVWF  xCC
12692:  MOVLB  0
12694:  CALL   525A
12698:  MOVLW  2C
1269A:  MOVLB  8
1269C:  MOVWF  xDD
1269E:  MOVLB  0
126A0:  CALL   5078
126A4:  MOVLW  10
126A6:  MOVWF  FE9
126A8:  MOVFF  2A,8D5
126AC:  MOVFF  29,8D4
126B0:  CALL   AA9E
126B4:  MOVLW  2C
126B6:  MOVLB  8
126B8:  MOVWF  xDD
126BA:  MOVLB  0
126BC:  CALL   5078
126C0:  MOVLW  10
126C2:  MOVWF  FE9
126C4:  MOVFF  24,8D5
126C8:  MOVFF  23,8D4
126CC:  CALL   AA9E
126D0:  MOVLW  2C
126D2:  MOVLB  8
126D4:  MOVWF  xDD
126D6:  MOVLB  0
126D8:  CALL   5078
126DC:  MOVLW  10
126DE:  MOVWF  FE9
126E0:  MOVFF  2C,8D5
126E4:  MOVFF  2B,8D4
126E8:  CALL   AA9E
126EC:  MOVLW  2C
126EE:  MOVLB  8
126F0:  MOVWF  xDD
126F2:  MOVLB  0
126F4:  CALL   5078
126F8:  MOVLW  10
126FA:  MOVWF  FE9
126FC:  MOVFF  2E,8D5
12700:  MOVFF  2D,8D4
12704:  CALL   AA9E
12708:  MOVLW  2C
1270A:  MOVLB  8
1270C:  MOVWF  xDD
1270E:  MOVLB  0
12710:  CALL   5078
12714:  MOVLW  10
12716:  MOVWF  FE9
12718:  MOVFF  22,8D5
1271C:  MOVFF  21,8D4
12720:  CALL   AA9E
12724:  MOVLW  2C
12726:  MOVLB  8
12728:  MOVWF  xDD
1272A:  MOVLB  0
1272C:  CALL   5078
12730:  MOVLW  10
12732:  MOVWF  FE9
12734:  MOVFF  7C8,8D5
12738:  MOVFF  7C7,8D4
1273C:  CALL   AA9E
12740:  MOVLW  2C
12742:  MOVLB  8
12744:  MOVWF  xDD
12746:  MOVLB  0
12748:  CALL   5078
1274C:  MOVLW  10
1274E:  MOVWF  FE9
12750:  MOVFF  7B6,8A0
12754:  MOVFF  7B5,89F
12758:  BRA    12536
....................    strcat(data_buffer, config_str); 
1275A:  MOVLB  8
1275C:  CLRF   xD7
1275E:  MOVLW  67
12760:  MOVWF  xD6
12762:  MOVLW  08
12764:  MOVWF  xD9
12766:  MOVLW  81
12768:  MOVWF  xD8
1276A:  MOVLB  0
1276C:  CALL   54B8
....................    strcat(data_buffer, endofline); 
12770:  MOVLB  8
12772:  CLRF   xD7
12774:  MOVLW  67
12776:  MOVWF  xD6
12778:  MOVLW  08
1277A:  MOVWF  xD9
1277C:  MOVLW  7E
1277E:  MOVWF  xD8
12780:  MOVLB  0
12782:  CALL   54B8
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
12786:  CLRF   FEA
12788:  MOVLW  67
1278A:  MOVWF  FE9
1278C:  CALL   793C
12790:  MOVLW  0D
12792:  BTFSS  F9E.4
12794:  BRA    12792
12796:  MOVWF  FAD
12798:  MOVLW  0A
1279A:  BTFSS  F9E.4
1279C:  BRA    1279A
1279E:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
127A0:  MOVLB  2
127A2:  MOVF   xDC,F
127A4:  BNZ   127F8
....................     
....................       buffer_select = 0; 
127A6:  MOVLB  0
127A8:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
127AA:  MOVLB  8
127AC:  CLRF   xCB
127AE:  MOVLB  0
127B0:  CALL   555C
....................          append_data(file_ptr_raw_all); 
127B4:  MOVLW  02
127B6:  MOVLB  8
127B8:  MOVWF  xCC
127BA:  MOVLW  DD
127BC:  MOVWF  xCB
127BE:  MOVLB  0
127C0:  CALL   8298
....................       heartbeat(TRUE);          
127C4:  MOVLW  01
127C6:  MOVLB  8
127C8:  MOVWF  xCB
127CA:  MOVLB  0
127CC:  CALL   555C
....................        
....................       heartbeat(FALSE); 
127D0:  MOVLB  8
127D2:  CLRF   xCB
127D4:  MOVLB  0
127D6:  CALL   555C
....................          append_data(file_ptr_raw_new);    
127DA:  MOVLW  02
127DC:  MOVLB  8
127DE:  MOVWF  xCC
127E0:  MOVLW  EB
127E2:  MOVWF  xCB
127E4:  MOVLB  0
127E6:  CALL   8298
....................       heartbeat(TRUE); 
127EA:  MOVLW  01
127EC:  MOVLB  8
127EE:  MOVWF  xCB
127F0:  MOVLB  0
127F2:  CALL   555C
127F6:  MOVLB  2
....................    } 
127F8:  MOVLB  0
127FA:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
127FC:  MOVLW  2C
127FE:  MOVLB  8
12800:  MOVWF  x7E
12802:  CLRF   x7F
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
12804:  MOVLW  0D
12806:  MOVWF  x80
12808:  MOVLW  0A
1280A:  MOVWF  x81
1280C:  CLRF   x82
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
1280E:  MOVLB  0
12810:  CALL   E3DE
....................    time_stamp(); 
12814:  CALL   53F4
....................    strcat(data_buffer, time_stmp_str); 
12818:  MOVLB  8
1281A:  CLRF   xD7
1281C:  MOVLW  67
1281E:  MOVWF  xD6
12820:  MOVLW  02
12822:  MOVWF  xD9
12824:  MOVLW  99
12826:  MOVWF  xD8
12828:  MOVLB  0
1282A:  CALL   54B8
....................    strcat(data_buffer, comma); 
1282E:  MOVLB  8
12830:  CLRF   xD7
12832:  MOVLW  67
12834:  MOVWF  xD6
12836:  MOVLW  08
12838:  MOVWF  xD9
1283A:  MOVLW  7E
1283C:  MOVWF  xD8
1283E:  MOVLB  0
12840:  CALL   54B8
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
12844:  MOVLW  08
12846:  MOVWF  1E
12848:  MOVLW  83
1284A:  MOVWF  1D
1284C:  MOVFF  87B,8CB
12850:  MOVLW  1B
12852:  MOVLB  8
12854:  MOVWF  xCC
12856:  MOVLB  0
12858:  CALL   525A
1285C:  MOVLW  2C
1285E:  MOVLB  8
12860:  MOVWF  xDD
12862:  MOVLB  0
12864:  CALL   5078
12868:  MOVLW  10
1286A:  MOVWF  FE9
1286C:  MOVFF  87D,8D5
12870:  MOVFF  87C,8D4
12874:  CALL   AA9E
....................    strcat(data_buffer, config_str); 
12878:  MOVLB  8
1287A:  CLRF   xD7
1287C:  MOVLW  67
1287E:  MOVWF  xD6
12880:  MOVLW  08
12882:  MOVWF  xD9
12884:  MOVLW  83
12886:  MOVWF  xD8
12888:  MOVLB  0
1288A:  CALL   54B8
....................    strcat(data_buffer, endofline); 
1288E:  MOVLB  8
12890:  CLRF   xD7
12892:  MOVLW  67
12894:  MOVWF  xD6
12896:  MOVLW  08
12898:  MOVWF  xD9
1289A:  MOVLW  80
1289C:  MOVWF  xD8
1289E:  MOVLB  0
128A0:  CALL   54B8
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
128A4:  MOVF   1F,W
128A6:  SUBLW  04
128A8:  BNZ   128C8
128AA:  MOVF   20,F
128AC:  BNZ   128C8
128AE:  CLRF   FEA
128B0:  MOVLW  67
128B2:  MOVWF  FE9
128B4:  CALL   793C
128B8:  MOVLW  0D
128BA:  BTFSS  F9E.4
128BC:  BRA    128BA
128BE:  MOVWF  FAD
128C0:  MOVLW  0A
128C2:  BTFSS  F9E.4
128C4:  BRA    128C2
128C6:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
128C8:  MOVLB  2
128CA:  MOVF   xDC,F
128CC:  BNZ   12920
....................     
....................       buffer_select = 0; 
128CE:  MOVLB  0
128D0:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
128D2:  MOVLB  8
128D4:  CLRF   xCB
128D6:  MOVLB  0
128D8:  CALL   555C
....................          append_data(file_ptr_raw_all); 
128DC:  MOVLW  02
128DE:  MOVLB  8
128E0:  MOVWF  xCC
128E2:  MOVLW  DD
128E4:  MOVWF  xCB
128E6:  MOVLB  0
128E8:  CALL   8298
....................       heartbeat(TRUE);          
128EC:  MOVLW  01
128EE:  MOVLB  8
128F0:  MOVWF  xCB
128F2:  MOVLB  0
128F4:  CALL   555C
....................        
....................       heartbeat(FALSE); 
128F8:  MOVLB  8
128FA:  CLRF   xCB
128FC:  MOVLB  0
128FE:  CALL   555C
....................          append_data(file_ptr_raw_new);    
12902:  MOVLW  02
12904:  MOVLB  8
12906:  MOVWF  xCC
12908:  MOVLW  EB
1290A:  MOVWF  xCB
1290C:  MOVLB  0
1290E:  CALL   8298
....................       heartbeat(TRUE); 
12912:  MOVLW  01
12914:  MOVLB  8
12916:  MOVWF  xCB
12918:  MOVLB  0
1291A:  CALL   555C
1291E:  MOVLB  2
....................    } 
12920:  MOVLB  0
12922:  GOTO   12ABC (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUvY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
10C70:  BSF    F90.7
....................    delay_ms(500); 
10C72:  MOVLW  02
10C74:  MOVLB  8
10C76:  MOVWF  xA0
10C78:  MOVLW  FA
10C7A:  MOVLB  A
10C7C:  MOVWF  xA2
10C7E:  MOVLB  0
10C80:  CALL   0588
10C84:  MOVLB  8
10C86:  DECFSZ xA0,F
10C88:  BRA    10C78
....................    bus_pwr_status=1; 
10C8A:  MOVLW  01
10C8C:  MOVLB  4
10C8E:  MOVWF  xB6
10C90:  MOVLB  0
10C92:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
*
0FFE6:  BCF    F90.7
....................    delay_ms(100); 
0FFE8:  MOVLW  64
0FFEA:  MOVLB  A
0FFEC:  MOVWF  xA2
0FFEE:  MOVLB  0
0FFF0:  CALL   0588
....................    bus_pwr_status=0; 
0FFF4:  MOVLB  4
0FFF6:  CLRF   xB6
0FFF8:  MOVLB  0
0FFFA:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
....................       string_arg[i] = 0; 
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
....................       if(com_echo == TRUE) 
....................       { 
....................          fputc(string_arg[i],COM_A); 
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
....................       { 
....................          break; 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
....................    macro_arg = 0; 
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
....................       number = fgetc(COM_A); 
....................       if (com_echo == TRUE) 
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................       } 
....................       if (number > 47 && number < 58) 
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
....................          macro_arg = macro_arg * 10;                    // increase significance 
....................          macro_arg = macro_arg + number;                // for each number 
....................       } 
....................       else if (number == CARRIAGE_RET) 
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
....................          else return(65535); 
....................       } 
....................       else 
....................       { 
....................          return(65535); 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
....................          break; 
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
....................          break;   
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
....................          break;   
....................    } 
....................    return(valid_macro); 
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
....................       if (com_echo == TRUE) fputc(e,COM_A); 
....................          valid_macro = check_macro(e, macro); 
....................       if (valid_macro == TRUE) { 
....................          return(e); 
....................       } 
....................       else return(0); 
....................    } while (valid_macro == TRUE); 
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
....................     
....................    ++addr; 
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
....................    write_ext_eeprom(addr, macro_cmd); 
....................     
....................    int i = 0; 
....................    addr = string_address[macro] + (count*50); 
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
....................       for(i = 0; i<50; i++) { 
....................          write_ext_eeprom(addr + i, string_arg[i]); 
....................          if(string_arg[i] == 0){ 
....................             break; 
....................          } 
....................       
....................       } 
....................    }else{ 
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
....................    } 
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
....................     
....................    write_macro_line(59, 0, 1, 0); 
....................    write_macro_line(59, 0, 2, 0); 
....................    write_macro_line(59, 0, 3, 0); 
....................    write_macro_line(59, 0, 4, 0); 
....................    write_macro_line(59, 0, 5, 0); 
....................    write_macro_line(59, 0, 6, 0); 
....................    write_macro_line(59, 0, 7, 0); 
....................    write_macro_line(59, 0, 8, 0); 
....................     
....................    write_macro_line(59, 0, 9, 0); 
....................    write_macro_line(59, 0, 10, 0); 
....................    write_macro_line(59, 0, 11, 0); 
....................    write_macro_line(59, 0, 12, 0); 
....................    write_macro_line(59, 0, 13, 0); 
....................    write_macro_line(59, 0, 14, 0); 
....................    write_macro_line(59, 0, 15, 0); 
....................    write_macro_line(59, 0, 16, 0); 
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
....................     
....................    heartbeat(FALSE); 
....................     
....................    while(mcc != CARRIAGE_RET){ 
....................       if (kbhit(COM_A)) { 
....................          mcc=fgetc(COM_A); 
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
....................       } 
....................    } 
....................     
....................    heartbeat(TRUE); 
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
....................     
....................    macro_cmd = get_cmd(macro); 
....................    if (macro_cmd == 35){  
....................       macro_comment();        // # = 35 
....................    }else if(macro_cmd == 112){// 112 is p 
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
....................       valid_macro = TRUE; 
....................    }else{ 
....................       if (macro_cmd != 0) { 
....................          macro_arg = get_arg(); 
....................          if (macro_arg != 65535) valid_macro = TRUE; 
....................          else return(macro_cmd); 
....................       }else return(macro_cmd); 
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
....................       return(macro_cmd); 
....................    } 
....................    return(macro_cmd); 
.................... } 
....................  
.................... void upload_macro(int8 macro) 
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
....................    valid_macro = TRUE; 
....................    macro_cmd = 1; 
....................     
....................    init_ext_eeprom(); 
....................     
....................    fprintf(COM_A, ":"); 
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
....................          count++; 
....................       } 
....................       if (macro_cmd != 35) ++line; 
....................       if (macro_cmd != 59) printf("\r\n:"); 
....................    }       
....................    if (macro_cmd == 0){ 
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
....................       fprintf(COM_A, "Please re-upload macro"); 
....................    } 
....................    fprintf(COM_A, "\r\n"); 
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
....................    ++addr; 
....................    macro_arg = read16_ext_eeprom(addr); 
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
....................     
....................    return(macro_cmd); 
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
111F2:  BCF    FD8.0
111F4:  MOVLB  8
111F6:  RLCF   x95,W
111F8:  CLRF   03
111FA:  ADDLW  D1
111FC:  MOVWF  FE9
111FE:  MOVLW  07
11200:  ADDWFC 03,W
11202:  MOVWF  FEA
11204:  MOVFF  FEC,89E
11208:  MOVF   FED,F
1120A:  MOVFF  FEF,89D
1120E:  MOVFF  897,9EB
11212:  MOVFF  896,9EA
11216:  MOVLB  9
11218:  CLRF   xED
1121A:  MOVLW  03
1121C:  MOVWF  xEC
1121E:  MOVLB  0
11220:  CALL   5C76
11224:  MOVF   01,W
11226:  MOVLB  8
11228:  ADDWF  x9D,W
1122A:  MOVWF  x98
1122C:  MOVF   02,W
1122E:  ADDWFC x9E,W
11230:  MOVWF  x99
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
11232:  MOVFF  899,8AA
11236:  MOVFF  898,8A9
1123A:  MOVLB  0
1123C:  CALL   BE02
11240:  MOVFF  01,89A
....................    ++addr; 
11244:  MOVLB  8
11246:  INCF   x98,F
11248:  BTFSC  FD8.2
1124A:  INCF   x99,F
....................    macro_arg = read16_ext_eeprom(addr); 
1124C:  MOVFF  899,8A1
11250:  MOVFF  898,8A0
11254:  MOVLB  0
11256:  CALL   BF18
1125A:  MOVFF  02,89C
1125E:  MOVFF  01,89B
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
11262:  MOVLB  8
11264:  MOVF   x9A,W
11266:  BTFSS  F9E.4
11268:  BRA    11266
1126A:  MOVWF  FAD
1126C:  MOVLW  10
1126E:  MOVWF  FE9
11270:  CLRF   1B
11272:  BTFSC  FF2.7
11274:  BSF    1B.7
11276:  BCF    FF2.7
11278:  MOVFF  89C,A1A
1127C:  MOVFF  89B,A19
11280:  MOVLB  0
11282:  CALL   11D0
11286:  BTFSC  1B.7
11288:  BSF    FF2.7
1128A:  MOVLW  0D
1128C:  BTFSS  F9E.4
1128E:  BRA    1128C
11290:  MOVWF  FAD
11292:  MOVLW  0A
11294:  BTFSS  F9E.4
11296:  BRA    11294
11298:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
1129A:  MOVLB  8
1129C:  MOVFF  89A,01
112A0:  MOVLB  0
112A2:  GOTO   11E6E (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
0BE5C:  BCF    FD8.0
0BE5E:  MOVLB  8
0BE60:  RLCF   x93,W
0BE62:  CLRF   03
0BE64:  ADDLW  FB
0BE66:  MOVWF  FE9
0BE68:  MOVLW  07
0BE6A:  ADDWFC 03,W
0BE6C:  MOVWF  FEA
0BE6E:  MOVFF  FEC,89C
0BE72:  MOVF   FED,F
0BE74:  MOVFF  FEF,89B
0BE78:  MOVFF  897,9EB
0BE7C:  MOVFF  896,9EA
0BE80:  MOVLB  9
0BE82:  CLRF   xED
0BE84:  MOVLW  32
0BE86:  MOVWF  xEC
0BE88:  MOVLB  0
0BE8A:  CALL   5C76
0BE8E:  MOVF   01,W
0BE90:  MOVLB  8
0BE92:  ADDWF  x9B,W
0BE94:  MOVWF  x98
0BE96:  MOVF   02,W
0BE98:  ADDWFC x9C,W
0BE9A:  MOVWF  x99
....................     
....................    int i = 0; 
0BE9C:  CLRF   x9A
....................    for(i = 0; i < 50; i++){ 
0BE9E:  CLRF   x9A
0BEA0:  MOVF   x9A,W
0BEA2:  SUBLW  31
0BEA4:  BNC   BEBA
....................       string_arg[i] = 0; 
0BEA6:  CLRF   03
0BEA8:  MOVF   x9A,W
0BEAA:  ADDLW  25
0BEAC:  MOVWF  FE9
0BEAE:  MOVLW  08
0BEB0:  ADDWFC 03,W
0BEB2:  MOVWF  FEA
0BEB4:  CLRF   FEF
0BEB6:  INCF   x9A,F
0BEB8:  BRA    BEA0
....................    }  
....................    for(i = 0; i < 50; i++){ 
0BEBA:  CLRF   x9A
0BEBC:  MOVF   x9A,W
0BEBE:  SUBLW  31
0BEC0:  BNC   BF12
....................       string_arg[i] = read_ext_eeprom(addr + i); 
0BEC2:  CLRF   03
0BEC4:  MOVF   x9A,W
0BEC6:  ADDLW  25
0BEC8:  MOVWF  01
0BECA:  MOVLW  08
0BECC:  ADDWFC 03,F
0BECE:  MOVFF  01,89B
0BED2:  MOVFF  03,89C
0BED6:  MOVF   x9A,W
0BED8:  ADDWF  x98,W
0BEDA:  MOVWF  x9D
0BEDC:  MOVLW  00
0BEDE:  ADDWFC x99,W
0BEE0:  MOVWF  x9E
0BEE2:  MOVWF  xAA
0BEE4:  MOVFF  89D,8A9
0BEE8:  MOVLB  0
0BEEA:  RCALL  BE02
0BEEC:  MOVFF  89C,FEA
0BEF0:  MOVFF  89B,FE9
0BEF4:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
0BEF8:  CLRF   03
0BEFA:  MOVLB  8
0BEFC:  MOVF   x9A,W
0BEFE:  ADDLW  25
0BF00:  MOVWF  FE9
0BF02:  MOVLW  08
0BF04:  ADDWFC 03,W
0BF06:  MOVWF  FEA
0BF08:  MOVF   FEF,F
0BF0A:  BNZ   BF0E
....................          break; 
0BF0C:  BRA    BF12
....................       } 
0BF0E:  INCF   x9A,F
0BF10:  BRA    BEBC
....................    }   
0BF12:  MOVLB  0
0BF14:  GOTO   11D22 (RETURN)
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
....................    macro_cmd = 1; 
....................     
....................    init_ext_eeprom(); 
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
....................       macro_cmd = read_macro_line(macro, line); 
....................       if(macro_cmd == 'p'){ 
....................          read_macro_line_string(macro,line,count); 
....................          count++; 
....................       } 
....................       ++line; 
....................    } 
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0E500:  MOVLB  8
0E502:  CLRF   xA3
0E504:  CLRF   xA2
0E506:  MOVF   xA3,W
0E508:  SUBWF  xA1,W
0E50A:  BNC   E532
0E50C:  BNZ   E514
0E50E:  MOVF   xA0,W
0E510:  SUBWF  xA2,W
0E512:  BC    E532
....................       delay_ms(1000); 
0E514:  MOVLW  04
0E516:  MOVWF  xA4
0E518:  MOVLW  FA
0E51A:  MOVLB  A
0E51C:  MOVWF  xA2
0E51E:  MOVLB  0
0E520:  CALL   0588
0E524:  MOVLB  8
0E526:  DECFSZ xA4,F
0E528:  BRA    E518
0E52A:  INCF   xA2,F
0E52C:  BTFSC  FD8.2
0E52E:  INCF   xA3,F
0E530:  BRA    E506
....................    }  
0E532:  MOVLB  0
0E534:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
10C38:  BCF    FD8.0
10C3A:  MOVLB  7
10C3C:  RLCF   x40,W
10C3E:  CLRF   03
10C40:  ADDLW  96
10C42:  MOVWF  FE9
10C44:  MOVLW  07
10C46:  ADDWFC 03,W
10C48:  MOVWF  FEA
10C4A:  MOVFF  FEC,8A2
10C4E:  MOVF   FED,F
10C50:  MOVFF  FEF,8A1
10C54:  MOVLB  8
10C56:  DECFSZ xA1,W
10C58:  BRA    10C64
10C5A:  MOVF   xA2,F
10C5C:  BNZ   10C64
....................    { 
....................       macro_status = 'e'; 
10C5E:  MOVLW  65
10C60:  MOVWF  xA0
....................    } 
10C62:  BRA    10C68
....................    else 
....................    { 
....................       macro_status = 'a'; 
10C64:  MOVLW  61
10C66:  MOVWF  xA0
....................    } 
....................    return(macro_status); 
10C68:  MOVFF  8A0,01
10C6C:  MOVLB  0
10C6E:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
106C0:  DECFSZ 45,W
106C2:  BRA    106D6
106C4:  MOVF   46,F
106C6:  BNZ   106D6
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
106C8:  MOVLW  01
106CA:  MOVLB  8
106CC:  MOVWF  xA0
106CE:  MOVWF  xA1
106D0:  MOVLB  0
106D2:  BRA    1024E
....................    } 
106D4:  BRA    106FE
....................    else if(nv_det_type==2 || nv_det_type==3) 
106D6:  MOVF   45,W
106D8:  SUBLW  02
106DA:  BNZ   106E0
106DC:  MOVF   46,F
106DE:  BZ    106EA
106E0:  MOVF   45,W
106E2:  SUBLW  03
106E4:  BNZ   106FE
106E6:  MOVF   46,F
106E8:  BNZ   106FE
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
106EA:  MOVLB  8
106EC:  CLRF   xA1
106EE:  MOVLW  C8
106F0:  MOVWF  xA0
106F2:  MOVLW  01
106F4:  MOVWF  xA2
106F6:  MOVWF  xA3
106F8:  CLRF   xA4
106FA:  MOVLB  0
106FC:  BRA    10456
....................    } 
106FE:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
0E8A0:  DECFSZ 45,W
0E8A2:  BRA    E8BC
0E8A4:  MOVF   46,F
0E8A6:  BNZ   E8BC
....................       cmd = macro_cmd; 
0E8A8:  MOVFF  8A0,47
....................       arg = macro_arg; 
0E8AC:  CLRF   4B
0E8AE:  CLRF   4A
0E8B0:  MOVFF  8A2,49
0E8B4:  MOVFF  8A1,48
....................       det_cmd(); 
0E8B8:  RCALL  E6F0
....................    } 
0E8BA:  BRA    E8D6
....................    else if(nv_det_type==2 || nv_det_type==3) { 
0E8BC:  MOVF   45,W
0E8BE:  SUBLW  02
0E8C0:  BNZ   E8C6
0E8C2:  MOVF   46,F
0E8C4:  BZ    E8D0
0E8C6:  MOVF   45,W
0E8C8:  SUBLW  03
0E8CA:  BNZ   E8D6
0E8CC:  MOVF   46,F
0E8CE:  BNZ   E8D6
....................       set_heaters(macro_arg); 
0E8D0:  MOVFF  8A1,8A3
0E8D4:  BRA    E82A
....................    } 
0E8D6:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
*
0EC72:  DECFSZ 45,W
0EC74:  BRA    EC8E
0EC76:  MOVF   46,F
0EC78:  BNZ   EC8E
....................       cmd = macro_cmd; 
0EC7A:  MOVFF  8A0,47
....................       arg = macro_arg; 
0EC7E:  CLRF   4B
0EC80:  CLRF   4A
0EC82:  MOVFF  8A2,49
0EC86:  MOVFF  8A1,48
....................       det_cmd(); 
0EC8A:  RCALL  E6F0
....................    } 
0EC8C:  BRA    ECAC
....................    else if(nv_det_type==2 || nv_det_type==3) { 
0EC8E:  MOVF   45,W
0EC90:  SUBLW  02
0EC92:  BNZ   EC98
0EC94:  MOVF   46,F
0EC96:  BZ    ECA2
0EC98:  MOVF   45,W
0EC9A:  SUBLW  03
0EC9C:  BNZ   ECAC
0EC9E:  MOVF   46,F
0ECA0:  BNZ   ECAC
....................       set_LED(macro_arg); 
0ECA2:  MOVFF  8A2,8A4
0ECA6:  MOVFF  8A1,8A3
0ECAA:  BRA    EC1A
....................    } 
0ECAC:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
10DF0:  MOVLW  65
10DF2:  MOVLB  8
10DF4:  MOVWF  x9F
....................     
....................    addr = macro_address[macro] + (line*3); 
10DF6:  BCF    FD8.0
10DF8:  RLCF   x95,W
10DFA:  CLRF   03
10DFC:  ADDLW  D1
10DFE:  MOVWF  FE9
10E00:  MOVLW  07
10E02:  ADDWFC 03,W
10E04:  MOVWF  FEA
10E06:  MOVFF  FEC,8A1
10E0A:  MOVF   FED,F
10E0C:  MOVFF  FEF,8A0
10E10:  MOVFF  897,9EB
10E14:  MOVFF  896,9EA
10E18:  MOVLB  9
10E1A:  CLRF   xED
10E1C:  MOVLW  03
10E1E:  MOVWF  xEC
10E20:  MOVLB  0
10E22:  CALL   5C76
10E26:  MOVF   01,W
10E28:  MOVLB  8
10E2A:  ADDWF  xA0,W
10E2C:  MOVWF  x9A
10E2E:  MOVF   02,W
10E30:  ADDWFC xA1,W
10E32:  MOVWF  x9B
....................  
....................    init_ext_eeprom(); 
10E34:  MOVLB  0
10E36:  CALL   BDC8
....................    macro_cmd = read_ext_eeprom(addr); 
10E3A:  MOVFF  89B,8AA
10E3E:  MOVFF  89A,8A9
10E42:  CALL   BE02
10E46:  MOVFF  01,89C
....................    ++addr; 
10E4A:  MOVLB  8
10E4C:  INCF   x9A,F
10E4E:  BTFSC  FD8.2
10E50:  INCF   x9B,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
10E52:  MOVFF  89B,8A1
10E56:  MOVFF  89A,8A0
10E5A:  MOVLB  0
10E5C:  CALL   BF18
10E60:  MOVFF  02,89E
10E64:  MOVFF  01,89D
....................    //} 
....................    heartbeat(TRUE); 
10E68:  MOVLW  01
10E6A:  MOVLB  8
10E6C:  MOVWF  xCB
10E6E:  MOVLB  0
10E70:  CALL   555C
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
10E74:  MOVF   2F,F
10E76:  BTFSS  FD8.2
10E78:  BRA    1112E
10E7A:  MOVF   30,F
10E7C:  BTFSS  FD8.2
10E7E:  BRA    1112E
....................       switch(macro_cmd) 
10E80:  MOVLW  2B
10E82:  MOVLB  8
10E84:  SUBWF  x9C,W
10E86:  ADDLW  B4
10E88:  BTFSC  FD8.0
10E8A:  BRA    11130
10E8C:  ADDLW  4C
10E8E:  MOVLB  0
10E90:  GOTO   1113A
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
10E94:  CALL   E37A
....................             store_rel_data(); 
10E98:  CALL   E3F2
....................             macro_status = 'a'; 
10E9C:  MOVLW  61
10E9E:  MOVLB  8
10EA0:  MOVWF  x9F
....................             break; 
10EA2:  BRA    11130
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
10EA4:  MOVLW  08
10EA6:  MOVWF  FEA
10EA8:  MOVLW  25
10EAA:  MOVWF  FE9
10EAC:  CALL   793C
10EB0:  MOVLW  0D
10EB2:  BTFSS  F9E.4
10EB4:  BRA    10EB2
10EB6:  MOVWF  FAD
10EB8:  MOVLW  0A
10EBA:  BTFSS  F9E.4
10EBC:  BRA    10EBA
10EBE:  MOVWF  FAD
....................             macro_status = 'a'; 
10EC0:  MOVLW  61
10EC2:  MOVLB  8
10EC4:  MOVWF  x9F
....................             break; 
10EC6:  BRA    11130
....................          case 'C' : 
....................             calc_abs_data(); 
10EC8:  CALL   E37A
....................             break; 
10ECC:  MOVLB  8
10ECE:  BRA    11130
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
10ED0:  MOVFF  89E,8A1
10ED4:  MOVFF  89D,8A0
10ED8:  CALL   E500
....................             macro_status = 'a'; 
10EDC:  MOVLW  61
10EDE:  MOVLB  8
10EE0:  MOVWF  x9F
....................             break; 
10EE2:  BRA    11130
....................          case 'F' : macro_flag = macro_arg; 
10EE4:  MOVFF  89E,324
10EE8:  MOVFF  89D,323
....................                     macro_status = 'a'; 
10EEC:  MOVLW  61
10EEE:  MOVLB  8
10EF0:  MOVWF  x9F
....................             break ; 
10EF2:  BRA    11130
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
10EF4:  MOVFF  89D,2D5
....................                     macro_status = 'a'; 
10EF8:  MOVLW  61
10EFA:  MOVLB  8
10EFC:  MOVWF  x9F
....................             break ; 
10EFE:  BRA    11130
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
10F00:  MOVFF  89C,8A0
10F04:  MOVFF  89E,8A2
10F08:  MOVFF  89D,8A1
10F0C:  CALL   E8A0
....................                     macro_status = 'a'; 
10F10:  MOVLW  61
10F12:  MOVLB  8
10F14:  MOVWF  x9F
....................             break; 
10F16:  BRA    11130
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
10F18:  MOVFF  89C,8A0
10F1C:  MOVFF  89E,8A2
10F20:  MOVFF  89D,8A1
10F24:  CALL   E8A0
....................                     macro_status = 'a'; 
10F28:  MOVLW  61
10F2A:  MOVLB  8
10F2C:  MOVWF  x9F
....................             break; 
10F2E:  BRA    11130
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
10F30:  MOVFF  89E,8BA
10F34:  MOVFF  89D,8B9
10F38:  MOVLB  8
10F3A:  CLRF   xBC
10F3C:  MOVLW  64
10F3E:  MOVWF  xBB
10F40:  MOVLB  0
10F42:  CALL   2CB4
10F46:  MOVFF  02,74D
10F4A:  MOVFF  01,74C
....................                     macro_status = 'a'; 
10F4E:  MOVLW  61
10F50:  MOVLB  8
10F52:  MOVWF  x9F
....................             break;    
10F54:  BRA    11130
....................          case 'l' : LightTargetFlag = 1; 
10F56:  MOVLW  01
10F58:  MOVLB  2
10F5A:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
10F5C:  MOVFF  89C,8A0
10F60:  MOVFF  89E,8A2
10F64:  MOVFF  89D,8A1
10F68:  MOVLB  0
10F6A:  CALL   EC72
....................                     delay_ms(10000); 
10F6E:  MOVLW  28
10F70:  MOVLB  8
10F72:  MOVWF  xA0
10F74:  MOVLW  FA
10F76:  MOVLB  A
10F78:  MOVWF  xA2
10F7A:  MOVLB  0
10F7C:  CALL   0588
10F80:  MOVLB  8
10F82:  DECFSZ xA0,F
10F84:  BRA    10F74
....................                     macro_status = 'a'; 
10F86:  MOVLW  61
10F88:  MOVWF  x9F
....................             break;        
10F8A:  BRA    11130
....................          case 'L' : LightTargetFlag = 0; 
10F8C:  MOVLB  2
10F8E:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
10F90:  MOVFF  89C,8A0
10F94:  MOVFF  89E,8A2
10F98:  MOVFF  89D,8A1
10F9C:  MOVLB  0
10F9E:  CALL   EC72
....................                     macro_status = 'a'; 
10FA2:  MOVLW  61
10FA4:  MOVLB  8
10FA6:  MOVWF  x9F
....................             break; 
10FA8:  BRA    11130
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
10FAA:  MOVFF  89C,47
....................                     arg = macro_arg; 
10FAE:  CLRF   4B
10FB0:  CLRF   4A
10FB2:  MOVFF  89E,49
10FB6:  MOVFF  89D,48
....................                     det_cmd(); 
10FBA:  CALL   E6F0
....................                     macro_status = 'a'; 
10FBE:  MOVLW  61
10FC0:  MOVLB  8
10FC2:  MOVWF  x9F
....................             break ; 
10FC4:  BRA    11130
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
10FC6:  MOVLB  8
10FC8:  DECFSZ x9D,W
10FCA:  BRA    10FD8
10FCC:  MOVF   x9E,F
10FCE:  BNZ   10FD8
10FD0:  MOVLB  0
10FD2:  CALL   106C0
10FD6:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
10FD8:  MOVF   x9D,W
10FDA:  SUBLW  02
10FDC:  BNZ   10FEE
10FDE:  MOVF   x9E,F
10FE0:  BNZ   10FEE
10FE2:  MOVLW  01
10FE4:  MOVWF  xA0
10FE6:  MOVWF  xA1
10FE8:  MOVLB  0
10FEA:  RCALL  1088A
10FEC:  MOVLB  8
....................                     macro_status = 'a'; 
10FEE:  MOVLW  61
10FF0:  MOVWF  x9F
....................             break ;  
10FF2:  BRA    11130
....................          case 'T' : det_temp(); 
10FF4:  RCALL  10A4C
....................                     macro_status = 'a'; 
10FF6:  MOVLW  61
10FF8:  MOVLB  8
10FFA:  MOVWF  x9F
....................             break; 
10FFC:  BRA    11130
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
10FFE:  MOVLW  01
11000:  MOVLB  7
11002:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
11004:  MOVLB  8
11006:  CLRF   xA5
11008:  CLRF   xA6
1100A:  CLRF   xAA
1100C:  CLRF   xA9
1100E:  MOVFF  89E,8A8
11012:  MOVFF  89D,8A7
11016:  MOVWF  xAB
11018:  MOVLB  0
1101A:  CALL   9D18
....................                     macro_status=step_err_status(); 
1101E:  RCALL  10C38
11020:  MOVFF  01,89F
....................             break; 
11024:  MOVLB  8
11026:  BRA    11130
....................          case '-' : motor=1; 
11028:  MOVLW  01
1102A:  MOVLB  7
1102C:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
1102E:  MOVLB  8
11030:  CLRF   xA5
11032:  MOVWF  xA6
11034:  CLRF   xAA
11036:  CLRF   xA9
11038:  MOVFF  89E,8A8
1103C:  MOVFF  89D,8A7
11040:  MOVWF  xAB
11042:  MOVLB  0
11044:  CALL   9D18
....................                     macro_status=step_err_status(); 
11048:  RCALL  10C38
1104A:  MOVFF  01,89F
....................             break; 
1104E:  MOVLB  8
11050:  BRA    11130
....................          case 'G' : motor=0; 
11052:  MOVLB  7
11054:  CLRF   x40
....................                     align(0); 
11056:  MOVLB  8
11058:  CLRF   xA0
1105A:  MOVLB  0
1105C:  CALL   A854
....................                     macro_status=step_err_status(); 
11060:  RCALL  10C38
11062:  MOVFF  01,89F
....................             break ;           
11066:  MOVLB  8
11068:  BRA    11130
....................          case 'P' : motor=0; 
1106A:  MOVLB  7
1106C:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
1106E:  MOVLW  01
11070:  MOVLB  8
11072:  MOVWF  xA5
11074:  CLRF   xA6
11076:  CLRF   xAA
11078:  CLRF   xA9
1107A:  MOVFF  89E,8A8
1107E:  MOVFF  89D,8A7
11082:  MOVWF  xAB
11084:  MOVLB  0
11086:  CALL   9D18
....................                     macro_status=step_err_status(); 
1108A:  RCALL  10C38
1108C:  MOVFF  01,89F
....................             break; 
11090:  MOVLB  8
11092:  BRA    11130
....................          case 'Q' : motor=0; 
11094:  MOVLB  7
11096:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
11098:  MOVLB  8
1109A:  CLRF   xA5
1109C:  CLRF   xA6
1109E:  CLRF   xAA
110A0:  CLRF   xA9
110A2:  MOVFF  89E,8A8
110A6:  MOVFF  89D,8A7
110AA:  MOVLW  01
110AC:  MOVWF  xAB
110AE:  MOVLB  0
110B0:  CALL   9D18
....................                     macro_status=step_err_status(); 
110B4:  RCALL  10C38
110B6:  MOVFF  01,89F
....................             break; 
110BA:  MOVLB  8
110BC:  BRA    11130
....................          case 'R' : motor=0; 
110BE:  MOVLB  7
110C0:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
110C2:  MOVLB  8
110C4:  CLRF   xA5
110C6:  MOVLW  01
110C8:  MOVWF  xA6
110CA:  CLRF   xAA
110CC:  CLRF   xA9
110CE:  MOVFF  89E,8A8
110D2:  MOVFF  89D,8A7
110D6:  MOVWF  xAB
110D8:  MOVLB  0
110DA:  CALL   9D18
....................                     macro_status=step_err_status(); 
110DE:  RCALL  10C38
110E0:  MOVFF  01,89F
....................             break; 
110E4:  MOVLB  8
110E6:  BRA    11130
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
110E8:  MOVLB  8
110EA:  DECFSZ x9D,W
110EC:  BRA    110FA
110EE:  MOVF   x9E,F
110F0:  BNZ   110FA
110F2:  MOVLB  0
110F4:  RCALL  10C70
110F6:  BRA    11108
110F8:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
110FA:  MOVF   x9D,F
110FC:  BNZ   1110A
110FE:  MOVF   x9E,F
11100:  BNZ   1110A
11102:  MOVLB  0
11104:  CALL   FFE6
11108:  MOVLB  8
....................                     macro_status = 'a'; 
1110A:  MOVLW  61
1110C:  MOVWF  x9F
....................             break; 
1110E:  BRA    11130
....................          case 'v': 
....................             arg = macro_arg; 
11110:  CLRF   4B
11112:  CLRF   4A
11114:  MOVFF  89E,49
11118:  MOVFF  89D,48
....................             command_v(); 
1111C:  RCALL  10C94
....................             macro_status = 'a'; 
1111E:  MOVLW  61
11120:  MOVLB  8
11122:  MOVWF  x9F
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
11124:  BRA    11130
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
11126:  MOVLW  66
11128:  MOVLB  8
1112A:  MOVWF  x9F
....................             break ; 
1112C:  BRA    11130
1112E:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
11130:  MOVFF  89F,01
11134:  MOVLB  0
11136:  GOTO   11E36 (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
11C92:  MOVLW  65
11C94:  MOVLB  8
11C96:  MOVWF  x85
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
11C98:  BCF    FD8.0
11C9A:  RLCF   x7B,W
11C9C:  CLRF   03
11C9E:  ADDLW  D1
11CA0:  MOVWF  FE9
11CA2:  MOVLW  07
11CA4:  ADDWFC 03,W
11CA6:  MOVWF  FEA
11CA8:  MOVFF  FEC,894
11CAC:  MOVF   FED,F
11CAE:  MOVFF  FEF,893
11CB2:  MOVFF  87D,03
11CB6:  MOVFF  87C,FE9
11CBA:  MOVFF  87D,FEA
11CBE:  MOVFF  FEC,9EB
11CC2:  MOVF   FED,F
11CC4:  MOVFF  FEF,9EA
11CC8:  MOVLB  9
11CCA:  CLRF   xED
11CCC:  MOVLW  03
11CCE:  MOVWF  xEC
11CD0:  MOVLB  0
11CD2:  CALL   5C76
11CD6:  MOVF   01,W
11CD8:  MOVLB  8
11CDA:  ADDWF  x93,W
11CDC:  MOVWF  x80
11CDE:  MOVF   02,W
11CE0:  ADDWFC x94,W
11CE2:  MOVWF  x81
....................  
....................    init_ext_eeprom(); 
11CE4:  MOVLB  0
11CE6:  CALL   BDC8
....................    macro_cmd = read_ext_eeprom(addr); 
11CEA:  MOVFF  881,8AA
11CEE:  MOVFF  880,8A9
11CF2:  CALL   BE02
11CF6:  MOVFF  01,882
....................    ++addr; 
11CFA:  MOVLB  8
11CFC:  INCF   x80,F
11CFE:  BTFSC  FD8.2
11D00:  INCF   x81,F
....................    if(macro_cmd == 'p'){ 
11D02:  MOVF   x82,W
11D04:  SUBLW  70
11D06:  BNZ   11D2C
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
11D08:  MOVFF  87B,893
11D0C:  MOVFF  87D,895
11D10:  MOVFF  87C,894
11D14:  MOVFF  858,897
11D18:  MOVFF  857,896
11D1C:  MOVLB  0
11D1E:  GOTO   BE5C
....................       count1++; 
11D22:  MOVLB  8
11D24:  INCF   x57,F
11D26:  BTFSC  FD8.2
11D28:  INCF   x58,F
....................    }else{ 
11D2A:  BRA    11D44
....................    macro_arg = read16_ext_eeprom(addr); 
11D2C:  MOVFF  881,8A1
11D30:  MOVFF  880,8A0
11D34:  MOVLB  0
11D36:  CALL   BF18
11D3A:  MOVFF  02,884
11D3E:  MOVFF  01,883
11D42:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
11D44:  MOVLW  01
11D46:  MOVWF  xCB
11D48:  MOVLB  0
11D4A:  CALL   555C
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
11D4E:  MOVF   2F,F
11D50:  BTFSS  FD8.2
11D52:  BRA    121B8
11D54:  MOVF   30,F
11D56:  BTFSS  FD8.2
11D58:  BRA    121B8
....................       switch(macro_cmd){ 
11D5A:  MOVLW  2B
11D5C:  MOVLB  8
11D5E:  SUBWF  x82,W
11D60:  ADDLW  B4
11D62:  BTFSC  FD8.0
11D64:  BRA    121B4
11D66:  ADDLW  4C
11D68:  MOVLB  0
11D6A:  GOTO   1247E
....................          case 'A' : 
....................             calc_abs_data(); 
11D6E:  CALL   E37A
....................             store_rel_data(); 
11D72:  CALL   E3F2
....................             macro_status = 'a'; 
11D76:  MOVLW  61
11D78:  MOVLB  8
11D7A:  MOVWF  x85
....................             break; 
11D7C:  BRA    121B4
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
11D7E:  MOVLW  08
11D80:  MOVWF  FEA
11D82:  MOVLW  25
11D84:  MOVWF  FE9
11D86:  CALL   793C
11D8A:  MOVLW  0D
11D8C:  BTFSS  F9E.4
11D8E:  BRA    11D8C
11D90:  MOVWF  FAD
11D92:  MOVLW  0A
11D94:  BTFSS  F9E.4
11D96:  BRA    11D94
11D98:  MOVWF  FAD
....................             macro_status = 'a'; 
11D9A:  MOVLW  61
11D9C:  MOVLB  8
11D9E:  MOVWF  x85
....................             break; 
11DA0:  BRA    121B4
....................          case 'C' : 
....................             calc_abs_data(); 
11DA2:  CALL   E37A
....................             break; 
11DA6:  MOVLB  8
11DA8:  BRA    121B4
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
11DAA:  MOVLB  8
11DAC:  CLRF   x89
11DAE:  CLRF   x88
11DB0:  CLRF   x87
11DB2:  CLRF   x86
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
11DB4:  MOVFF  87D,03
11DB8:  MOVFF  87C,FE9
11DBC:  MOVFF  87D,FEA
11DC0:  MOVLW  01
11DC2:  ADDWF  FEE,F
11DC4:  BNC   11DC8
11DC6:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
11DC8:  MOVFF  87C,FE9
11DCC:  MOVFF  87D,FEA
11DD0:  CLRF   x8D
11DD2:  CLRF   x8C
11DD4:  MOVFF  FEC,88B
11DD8:  MOVF   FED,F
11DDA:  MOVFF  FEF,88A
11DDE:  CLRF   x91
11DE0:  CLRF   x90
11DE2:  CLRF   x8F
11DE4:  CLRF   x8E
....................                    
....................                   while(count < macro_arg){ 
11DE6:  MOVF   x89,F
11DE8:  BTFSS  FD8.2
11DEA:  BRA    11F26
11DEC:  MOVF   x88,F
11DEE:  BTFSS  FD8.2
11DF0:  BRA    11F26
11DF2:  MOVF   x87,W
11DF4:  SUBWF  x84,W
11DF6:  BTFSS  FD8.0
11DF8:  BRA    11F26
11DFA:  BNZ   11E04
11DFC:  MOVF   x83,W
11DFE:  SUBWF  x86,W
11E00:  BTFSC  FD8.0
11E02:  BRA    11F26
....................                      char curr = 'A'; 
11E04:  MOVLW  41
11E06:  MOVWF  x92
....................                      while(curr != '%'){ 
11E08:  MOVF   x92,W
11E0A:  SUBLW  25
11E0C:  BZ    11E78
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
11E0E:  MOVFF  87D,03
11E12:  MOVFF  87C,FE9
11E16:  MOVFF  87D,FEA
11E1A:  MOVFF  FEC,897
11E1E:  MOVF   FED,F
11E20:  MOVFF  FEF,896
11E24:  MOVFF  87B,895
11E28:  MOVFF  87F,899
11E2C:  MOVFF  87E,898
11E30:  MOVLB  0
11E32:  GOTO   10DF0
....................                         (*line)++; 
11E36:  MOVFF  87D,03
11E3A:  MOVLB  8
11E3C:  MOVF   x7C,W
11E3E:  MOVWF  FE9
11E40:  MOVFF  03,FEA
11E44:  MOVLW  01
11E46:  ADDWF  FEE,F
11E48:  BNC   11E4C
11E4A:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
11E4C:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
11E4E:  MOVFF  87D,03
11E52:  MOVFF  87C,FE9
11E56:  MOVFF  87D,FEA
11E5A:  MOVFF  FEC,897
11E5E:  MOVF   FED,F
11E60:  MOVFF  FEF,896
11E64:  MOVFF  87B,895
11E68:  MOVLB  0
11E6A:  GOTO   111F2
11E6E:  MOVFF  01,892
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
11E72:  BSF    F91.5
11E74:  MOVLB  8
11E76:  BRA    11E08
....................                      } 
....................                      end_line = (*line); 
11E78:  MOVFF  87C,FE9
11E7C:  MOVFF  87D,FEA
11E80:  CLRF   x91
11E82:  CLRF   x90
11E84:  MOVFF  FEC,88F
11E88:  MOVF   FED,F
11E8A:  MOVFF  FEF,88E
....................                      count++; 
11E8E:  MOVLW  01
11E90:  ADDWF  x86,F
11E92:  BTFSC  FD8.0
11E94:  INCF   x87,F
11E96:  BTFSC  FD8.2
11E98:  INCF   x88,F
11E9A:  BTFSC  FD8.2
11E9C:  INCF   x89,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
11E9E:  MOVF   x86,W
11EA0:  SUBWF  x83,W
11EA2:  MOVWF  x93
11EA4:  MOVF   x87,W
11EA6:  SUBWFB x84,W
11EA8:  MOVWF  x94
11EAA:  MOVLW  00
11EAC:  SUBFWB x88,W
11EAE:  MOVWF  x95
11EB0:  MOVLW  00
11EB2:  SUBFWB x89,W
11EB4:  MOVWF  x96
11EB6:  MOVLW  80
11EB8:  MOVWF  FF6
11EBA:  MOVLW  21
11EBC:  MOVWF  FF7
11EBE:  MOVLW  00
11EC0:  MOVWF  FF8
11EC2:  CLRF   1B
11EC4:  BTFSC  FF2.7
11EC6:  BSF    1B.7
11EC8:  BCF    FF2.7
11ECA:  MOVLW  11
11ECC:  MOVLB  A
11ECE:  MOVWF  x19
11ED0:  MOVLB  0
11ED2:  CALL   104E
11ED6:  BTFSC  1B.7
11ED8:  BSF    FF2.7
11EDA:  MOVLW  41
11EDC:  MOVWF  FE9
11EDE:  CLRF   1B
11EE0:  BTFSC  FF2.7
11EE2:  BSF    1B.7
11EE4:  BCF    FF2.7
11EE6:  MOVFF  896,A1C
11EEA:  MOVFF  895,A1B
11EEE:  MOVFF  894,A1A
11EF2:  MOVFF  893,A19
11EF6:  CALL   1114
11EFA:  BTFSC  1B.7
11EFC:  BSF    FF2.7
11EFE:  MOVLW  0D
11F00:  BTFSS  F9E.4
11F02:  BRA    11F00
11F04:  MOVWF  FAD
11F06:  MOVLW  0A
11F08:  BTFSS  F9E.4
11F0A:  BRA    11F08
11F0C:  MOVWF  FAD
....................                      (*line) = start_line; 
11F0E:  MOVFF  87D,03
11F12:  MOVLB  8
11F14:  MOVFF  87C,FE9
11F18:  MOVFF  87D,FEA
11F1C:  MOVFF  88A,FEF
11F20:  MOVFF  88B,FEC
11F24:  BRA    11DE6
....................                   } 
....................                   (*line) = end_line + 1; 
11F26:  MOVFF  87C,FE9
11F2A:  MOVFF  87D,FEA
11F2E:  MOVLW  01
11F30:  ADDWF  x8E,W
11F32:  MOVWF  FEF
11F34:  MOVLW  00
11F36:  ADDWFC x8F,W
11F38:  MOVWF  FEC
....................                   macro_status = 'a'; 
11F3A:  MOVLW  61
11F3C:  MOVWF  x85
....................             break; 
11F3E:  BRA    121B4
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
11F40:  MOVFF  884,8A1
11F44:  MOVFF  883,8A0
11F48:  CALL   E500
....................                     macro_status = 'a'; 
11F4C:  MOVLW  61
11F4E:  MOVLB  8
11F50:  MOVWF  x85
....................             break; 
11F52:  BRA    121B4
....................          case 'F' : macro_flag = macro_arg; 
11F54:  MOVFF  884,324
11F58:  MOVFF  883,323
....................                     macro_status = 'a'; 
11F5C:  MOVLW  61
11F5E:  MOVLB  8
11F60:  MOVWF  x85
....................             break ; 
11F62:  BRA    121B4
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
11F64:  MOVFF  883,2D5
....................                     macro_status = 'a'; 
11F68:  MOVLW  61
11F6A:  MOVLB  8
11F6C:  MOVWF  x85
....................             break ; 
11F6E:  BRA    121B4
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
11F70:  MOVFF  882,8A0
11F74:  MOVFF  884,8A2
11F78:  MOVFF  883,8A1
11F7C:  CALL   E8A0
....................                     macro_status = 'a'; 
11F80:  MOVLW  61
11F82:  MOVLB  8
11F84:  MOVWF  x85
....................             break; 
11F86:  BRA    121B4
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
11F88:  MOVFF  882,8A0
11F8C:  MOVFF  884,8A2
11F90:  MOVFF  883,8A1
11F94:  CALL   E8A0
....................                     macro_status = 'a'; 
11F98:  MOVLW  61
11F9A:  MOVLB  8
11F9C:  MOVWF  x85
....................             break; 
11F9E:  BRA    121B4
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
11FA0:  MOVFF  884,8BA
11FA4:  MOVFF  883,8B9
11FA8:  MOVLB  8
11FAA:  CLRF   xBC
11FAC:  MOVLW  64
11FAE:  MOVWF  xBB
11FB0:  MOVLB  0
11FB2:  CALL   2CB4
11FB6:  MOVFF  02,74D
11FBA:  MOVFF  01,74C
....................                     macro_status = 'a'; 
11FBE:  MOVLW  61
11FC0:  MOVLB  8
11FC2:  MOVWF  x85
....................             break;    
11FC4:  BRA    121B4
....................          case 'l' : LightTargetFlag = 1; 
11FC6:  MOVLW  01
11FC8:  MOVLB  2
11FCA:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
11FCC:  MOVFF  882,8A0
11FD0:  MOVFF  884,8A2
11FD4:  MOVFF  883,8A1
11FD8:  MOVLB  0
11FDA:  CALL   EC72
....................                     delay_ms(10000); 
11FDE:  MOVLW  28
11FE0:  MOVLB  8
11FE2:  MOVWF  x93
11FE4:  MOVLW  FA
11FE6:  MOVLB  A
11FE8:  MOVWF  xA2
11FEA:  MOVLB  0
11FEC:  CALL   0588
11FF0:  MOVLB  8
11FF2:  DECFSZ x93,F
11FF4:  BRA    11FE4
....................                     macro_status = 'a'; 
11FF6:  MOVLW  61
11FF8:  MOVWF  x85
....................             break;        
11FFA:  BRA    121B4
....................          case 'L' : LightTargetFlag = 0; 
11FFC:  MOVLB  2
11FFE:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
12000:  MOVFF  882,8A0
12004:  MOVFF  884,8A2
12008:  MOVFF  883,8A1
1200C:  MOVLB  0
1200E:  CALL   EC72
....................                     macro_status = 'a'; 
12012:  MOVLW  61
12014:  MOVLB  8
12016:  MOVWF  x85
....................             break; 
12018:  BRA    121B4
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
1201A:  MOVFF  882,47
....................                     arg = macro_arg; 
1201E:  CLRF   4B
12020:  CLRF   4A
12022:  MOVFF  884,49
12026:  MOVFF  883,48
....................                     det_cmd(); 
1202A:  CALL   E6F0
....................                     macro_status = 'a'; 
1202E:  MOVLW  61
12030:  MOVLB  8
12032:  MOVWF  x85
....................             break ; 
12034:  BRA    121B4
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
12036:  MOVLB  8
12038:  DECFSZ x83,W
1203A:  BRA    12048
1203C:  MOVF   x84,F
1203E:  BNZ   12048
12040:  MOVLB  0
12042:  CALL   106C0
12046:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
12048:  MOVF   x83,W
1204A:  SUBLW  02
1204C:  BNZ   12060
1204E:  MOVF   x84,F
12050:  BNZ   12060
12052:  MOVLW  01
12054:  MOVWF  xA0
12056:  MOVWF  xA1
12058:  MOVLB  0
1205A:  CALL   1088A
1205E:  MOVLB  8
....................                     macro_status = 'a'; 
12060:  MOVLW  61
12062:  MOVWF  x85
....................             break ;  
12064:  BRA    121B4
....................          case 'T' : det_temp(); 
12066:  CALL   10A4C
....................                     macro_status = 'a'; 
1206A:  MOVLW  61
1206C:  MOVLB  8
1206E:  MOVWF  x85
....................             break; 
12070:  BRA    121B4
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
12072:  MOVLW  01
12074:  MOVLB  7
12076:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
12078:  MOVLB  8
1207A:  CLRF   xA5
1207C:  CLRF   xA6
1207E:  CLRF   xAA
12080:  CLRF   xA9
12082:  MOVFF  884,8A8
12086:  MOVFF  883,8A7
1208A:  MOVWF  xAB
1208C:  MOVLB  0
1208E:  CALL   9D18
....................                     macro_status=step_err_status(); 
12092:  CALL   10C38
12096:  MOVFF  01,885
....................             break; 
1209A:  MOVLB  8
1209C:  BRA    121B4
....................          case '-' : motor=1; 
1209E:  MOVLW  01
120A0:  MOVLB  7
120A2:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
120A4:  MOVLB  8
120A6:  CLRF   xA5
120A8:  MOVWF  xA6
120AA:  CLRF   xAA
120AC:  CLRF   xA9
120AE:  MOVFF  884,8A8
120B2:  MOVFF  883,8A7
120B6:  MOVWF  xAB
120B8:  MOVLB  0
120BA:  CALL   9D18
....................                     macro_status=step_err_status(); 
120BE:  CALL   10C38
120C2:  MOVFF  01,885
....................             break; 
120C6:  MOVLB  8
120C8:  BRA    121B4
....................          case 'G' : motor=0; 
120CA:  MOVLB  7
120CC:  CLRF   x40
....................                     align(0); 
120CE:  MOVLB  8
120D0:  CLRF   xA0
120D2:  MOVLB  0
120D4:  CALL   A854
....................                     macro_status=step_err_status(); 
120D8:  CALL   10C38
120DC:  MOVFF  01,885
....................             break ;           
120E0:  MOVLB  8
120E2:  BRA    121B4
....................          case 'P' : motor=0; 
120E4:  MOVLB  7
120E6:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
120E8:  MOVLW  01
120EA:  MOVLB  8
120EC:  MOVWF  xA5
120EE:  CLRF   xA6
120F0:  CLRF   xAA
120F2:  CLRF   xA9
120F4:  MOVFF  884,8A8
120F8:  MOVFF  883,8A7
120FC:  MOVWF  xAB
120FE:  MOVLB  0
12100:  CALL   9D18
....................                     macro_status=step_err_status(); 
12104:  CALL   10C38
12108:  MOVFF  01,885
....................             break; 
1210C:  MOVLB  8
1210E:  BRA    121B4
....................          case 'Q' : motor=0; 
12110:  MOVLB  7
12112:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
12114:  MOVLB  8
12116:  CLRF   xA5
12118:  CLRF   xA6
1211A:  CLRF   xAA
1211C:  CLRF   xA9
1211E:  MOVFF  884,8A8
12122:  MOVFF  883,8A7
12126:  MOVLW  01
12128:  MOVWF  xAB
1212A:  MOVLB  0
1212C:  CALL   9D18
....................                     macro_status=step_err_status(); 
12130:  CALL   10C38
12134:  MOVFF  01,885
....................             break; 
12138:  MOVLB  8
1213A:  BRA    121B4
....................          case 'R' : motor=0; 
1213C:  MOVLB  7
1213E:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
12140:  MOVLB  8
12142:  CLRF   xA5
12144:  MOVLW  01
12146:  MOVWF  xA6
12148:  CLRF   xAA
1214A:  CLRF   xA9
1214C:  MOVFF  884,8A8
12150:  MOVFF  883,8A7
12154:  MOVWF  xAB
12156:  MOVLB  0
12158:  CALL   9D18
....................                     macro_status=step_err_status(); 
1215C:  CALL   10C38
12160:  MOVFF  01,885
....................             break; 
12164:  MOVLB  8
12166:  BRA    121B4
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
12168:  MOVLB  8
1216A:  DECFSZ x83,W
1216C:  BRA    1217C
1216E:  MOVF   x84,F
12170:  BNZ   1217C
12172:  MOVLB  0
12174:  CALL   10C70
12178:  BRA    1218A
1217A:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
1217C:  MOVF   x83,F
1217E:  BNZ   1218C
12180:  MOVF   x84,F
12182:  BNZ   1218C
12184:  MOVLB  0
12186:  CALL   FFE6
1218A:  MOVLB  8
....................                     macro_status = 'a'; 
1218C:  MOVLW  61
1218E:  MOVWF  x85
....................             break; 
12190:  BRA    121B4
....................          case 'v':  
....................             arg = macro_arg; 
12192:  CLRF   4B
12194:  CLRF   4A
12196:  MOVFF  884,49
1219A:  MOVFF  883,48
....................             command_v(); 
1219E:  CALL   10C94
....................             macro_status = 'a'; 
121A2:  MOVLW  61
121A4:  MOVLB  8
121A6:  MOVWF  x85
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
121A8:  BRA    121B4
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
121AA:  MOVLW  66
121AC:  MOVLB  8
121AE:  MOVWF  x85
....................             break ; 
121B0:  BRA    121B4
121B2:  MOVLB  8
....................       } 
....................    } 
121B4:  BRA    12474
121B6:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
121B8:  DECFSZ 2F,W
121BA:  BRA    121C0
121BC:  MOVF   30,F
121BE:  BZ    121CE
121C0:  MOVF   2F,W
121C2:  SUBLW  03
121C4:  BTFSS  FD8.2
121C6:  BRA    1234C
121C8:  MOVF   30,F
121CA:  BTFSS  FD8.2
121CC:  BRA    1234C
....................       switch(macro_cmd){ 
121CE:  MOVLB  8
121D0:  MOVF   x82,W
121D2:  XORLW  2B
121D4:  MOVLB  0
121D6:  BZ    12204
121D8:  XORLW  06
121DA:  BZ    1222E
121DC:  XORLW  6F
121DE:  BZ    12258
121E0:  XORLW  05
121E2:  BZ    1226A
121E4:  XORLW  17
121E6:  BZ    12282
121E8:  XORLW  01
121EA:  BZ    122AC
121EC:  XORLW  03
121EE:  BZ    122D6
121F0:  XORLW  06
121F2:  BTFSC  FD8.2
121F4:  BRA    12300
121F6:  XORLW  0D
121F8:  BTFSC  FD8.2
121FA:  BRA    12316
121FC:  XORLW  62
121FE:  BTFSC  FD8.2
12200:  BRA    12342
12202:  BRA    1234A
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
12204:  MOVLW  01
12206:  MOVLB  7
12208:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
1220A:  MOVLB  8
1220C:  CLRF   xA5
1220E:  CLRF   xA6
12210:  CLRF   xAA
12212:  CLRF   xA9
12214:  MOVFF  884,8A8
12218:  MOVFF  883,8A7
1221C:  MOVWF  xAB
1221E:  MOVLB  0
12220:  CALL   9D18
....................                     macro_status=step_err_status(); 
12224:  CALL   10C38
12228:  MOVFF  01,885
....................             break; 
1222C:  BRA    1234A
....................          case '-' : motor=1; 
1222E:  MOVLW  01
12230:  MOVLB  7
12232:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
12234:  MOVLB  8
12236:  CLRF   xA5
12238:  MOVWF  xA6
1223A:  CLRF   xAA
1223C:  CLRF   xA9
1223E:  MOVFF  884,8A8
12242:  MOVFF  883,8A7
12246:  MOVWF  xAB
12248:  MOVLB  0
1224A:  CALL   9D18
....................                     macro_status=step_err_status(); 
1224E:  CALL   10C38
12252:  MOVFF  01,885
....................             break; 
12256:  BRA    1234A
....................          case 'B' : h_bridge(macro_arg); 
12258:  MOVFF  883,893
1225C:  CALL   112F4
....................                     macro_status = 'a'; 
12260:  MOVLW  61
12262:  MOVLB  8
12264:  MOVWF  x85
....................             break;             
12266:  MOVLB  0
12268:  BRA    1234A
....................          case 'G' : motor=0; 
1226A:  MOVLB  7
1226C:  CLRF   x40
....................                     align(0); 
1226E:  MOVLB  8
12270:  CLRF   xA0
12272:  MOVLB  0
12274:  CALL   A854
....................                     macro_status=step_err_status(); 
12278:  CALL   10C38
1227C:  MOVFF  01,885
....................             break ;           
12280:  BRA    1234A
....................          case 'P' : motor=0; 
12282:  MOVLB  7
12284:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1);   
12286:  MOVLB  8
12288:  CLRF   xA5
1228A:  CLRF   xA6
1228C:  CLRF   xAA
1228E:  CLRF   xA9
12290:  MOVFF  87F,8A8
12294:  MOVFF  87E,8A7
12298:  MOVLW  01
1229A:  MOVWF  xAB
1229C:  MOVLB  0
1229E:  CALL   9D18
....................                     macro_status=step_err_status(); 
122A2:  CALL   10C38
122A6:  MOVFF  01,885
....................             break; 
122AA:  BRA    1234A
....................          case 'Q' : motor=0; 
122AC:  MOVLB  7
122AE:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1); 
122B0:  MOVLB  8
122B2:  CLRF   xA5
122B4:  CLRF   xA6
122B6:  CLRF   xAA
122B8:  CLRF   xA9
122BA:  MOVFF  87F,8A8
122BE:  MOVFF  87E,8A7
122C2:  MOVLW  01
122C4:  MOVWF  xAB
122C6:  MOVLB  0
122C8:  CALL   9D18
....................                     macro_status=step_err_status(); 
122CC:  CALL   10C38
122D0:  MOVFF  01,885
....................             break; 
122D4:  BRA    1234A
....................          case 'R' : motor=0; 
122D6:  MOVLB  7
122D8:  CLRF   x40
....................                     move_motor(0,1,mmacro_var,1); 
122DA:  MOVLB  8
122DC:  CLRF   xA5
122DE:  MOVLW  01
122E0:  MOVWF  xA6
122E2:  CLRF   xAA
122E4:  CLRF   xA9
122E6:  MOVFF  87F,8A8
122EA:  MOVFF  87E,8A7
122EE:  MOVWF  xAB
122F0:  MOVLB  0
122F2:  CALL   9D18
....................                     macro_status=step_err_status(); 
122F6:  CALL   10C38
122FA:  MOVFF  01,885
....................             break; 
122FE:  BRA    1234A
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
12300:  MOVFF  884,8A1
12304:  MOVFF  883,8A0
12308:  CALL   E500
....................                     macro_status = 'a'; 
1230C:  MOVLW  61
1230E:  MOVLB  8
12310:  MOVWF  x85
....................             break; 
12312:  MOVLB  0
12314:  BRA    1234A
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
12316:  MOVLB  8
12318:  DECFSZ x83,W
1231A:  BRA    1232A
1231C:  MOVF   x84,F
1231E:  BNZ   1232A
12320:  MOVLB  0
12322:  CALL   10C70
12326:  BRA    12338
12328:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
1232A:  MOVF   x83,F
1232C:  BNZ   1233A
1232E:  MOVF   x84,F
12330:  BNZ   1233A
12332:  MOVLB  0
12334:  CALL   FFE6
12338:  MOVLB  8
....................                     macro_status = 'a'; 
1233A:  MOVLW  61
1233C:  MOVWF  x85
....................             break; 
1233E:  MOVLB  0
12340:  BRA    1234A
....................          case ';' : macro_status = 'f'; 
12342:  MOVLW  66
12344:  MOVLB  8
12346:  MOVWF  x85
....................             break;            
12348:  MOVLB  0
....................       } 
....................    } 
1234A:  BRA    12472
....................    else if (nv_product==AWS){ 
1234C:  MOVF   2F,W
1234E:  SUBLW  02
12350:  BTFSS  FD8.2
12352:  BRA    12472
12354:  MOVF   30,F
12356:  BTFSS  FD8.2
12358:  BRA    12472
....................       switch(macro_cmd){ 
1235A:  MOVLB  8
1235C:  MOVF   x82,W
1235E:  XORLW  2B
12360:  MOVLB  0
12362:  BZ    12388
12364:  XORLW  06
12366:  BZ    123B2
12368:  XORLW  6E
1236A:  BZ    123DC
1236C:  XORLW  07
1236E:  BZ    123EE
12370:  XORLW  14
12372:  BZ    12404
12374:  XORLW  01
12376:  BZ    12416
12378:  XORLW  02
1237A:  BZ    12428
1237C:  XORLW  0A
1237E:  BZ    1243E
12380:  XORLW  62
12382:  BTFSC  FD8.2
12384:  BRA    1246A
12386:  BRA    12472
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
12388:  MOVLW  01
1238A:  MOVLB  7
1238C:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
1238E:  MOVLB  8
12390:  CLRF   xA5
12392:  CLRF   xA6
12394:  CLRF   xAA
12396:  CLRF   xA9
12398:  MOVFF  884,8A8
1239C:  MOVFF  883,8A7
123A0:  MOVWF  xAB
123A2:  MOVLB  0
123A4:  CALL   9D18
....................                     macro_status=step_err_status(); 
123A8:  CALL   10C38
123AC:  MOVFF  01,885
....................             break; 
123B0:  BRA    12472
....................          case '-' : motor=1; 
123B2:  MOVLW  01
123B4:  MOVLB  7
123B6:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
123B8:  MOVLB  8
123BA:  CLRF   xA5
123BC:  MOVWF  xA6
123BE:  CLRF   xAA
123C0:  CLRF   xA9
123C2:  MOVFF  884,8A8
123C6:  MOVFF  883,8A7
123CA:  MOVWF  xAB
123CC:  MOVLB  0
123CE:  CALL   9D18
....................                     macro_status=step_err_status(); 
123D2:  CALL   10C38
123D6:  MOVFF  01,885
....................             break; 
123DA:  BRA    12472
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
123DC:  MOVFF  883,894
123E0:  CALL   11378
....................                     macro_status = 'a';  
123E4:  MOVLW  61
123E6:  MOVLB  8
123E8:  MOVWF  x85
....................             break;          
123EA:  MOVLB  0
123EC:  BRA    12472
....................          case 'D' : delay_sec(macro_arg); 
123EE:  MOVFF  884,8A1
123F2:  MOVFF  883,8A0
123F6:  CALL   E500
....................                     macro_status = 'a'; 
123FA:  MOVLW  61
123FC:  MOVLB  8
123FE:  MOVWF  x85
....................             break; 
12400:  MOVLB  0
12402:  BRA    12472
....................          case 'P' : sol_switch(mmacro_var); 
12404:  MOVFF  87E,893
12408:  CALL   1184A
....................                     macro_status = 'a'; 
1240C:  MOVLW  61
1240E:  MOVLB  8
12410:  MOVWF  x85
....................             break;              
12412:  MOVLB  0
12414:  BRA    12472
....................          case 'Q' : sol_switch(macro_arg); 
12416:  MOVFF  883,893
1241A:  CALL   1184A
....................                     macro_status = 'a'; 
1241E:  MOVLW  61
12420:  MOVLB  8
12422:  MOVWF  x85
....................             break;             
12424:  MOVLB  0
12426:  BRA    12472
....................          case 'S' : sol_switch_cmd(macro_arg); 
12428:  MOVFF  884,895
1242C:  MOVFF  883,894
12430:  CALL   1150A
....................                     macro_status = 'a'; 
12434:  MOVLW  61
12436:  MOVLB  8
12438:  MOVWF  x85
....................             break; 
1243A:  MOVLB  0
1243C:  BRA    12472
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
1243E:  MOVLB  8
12440:  DECFSZ x83,W
12442:  BRA    12452
12444:  MOVF   x84,F
12446:  BNZ   12452
12448:  MOVLB  0
1244A:  CALL   10C70
1244E:  BRA    12460
12450:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
12452:  MOVF   x83,F
12454:  BNZ   12462
12456:  MOVF   x84,F
12458:  BNZ   12462
1245A:  MOVLB  0
1245C:  CALL   FFE6
12460:  MOVLB  8
....................                     macro_status = 'a'; 
12462:  MOVLW  61
12464:  MOVWF  x85
....................             break;               
12466:  MOVLB  0
12468:  BRA    12472
....................          case ';' : macro_status = 'f'; 
1246A:  MOVLW  66
1246C:  MOVLB  8
1246E:  MOVWF  x85
....................             break;            
12470:  MOVLB  0
12472:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
12474:  MOVFF  885,01
12478:  MOVLB  0
1247A:  GOTO   12A58 (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
12926:  MOVLB  8
12928:  CLRF   x58
1292A:  CLRF   x57
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
1292C:  MOVLB  0
1292E:  CALL   50C0
....................    clear_data_arrays(); 
12932:  GOTO   BD02
....................     
....................    line = 0;  
12936:  MOVLB  8
12938:  CLRF   x79
1293A:  CLRF   x78
....................    macro_status = 'a'; 
1293C:  MOVLW  61
1293E:  MOVWF  x7A
....................    data_available = FALSE; 
12940:  MOVLB  3
12942:  CLRF   x3B
....................    macro_flag = 900; 
12944:  MOVLW  03
12946:  MOVWF  x24
12948:  MOVLW  84
1294A:  MOVWF  x23
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
1294C:  MOVLW  01
1294E:  MOVWF  1E
12950:  MOVLW  A7
12952:  MOVWF  1D
12954:  MOVLW  98
12956:  MOVWF  FF6
12958:  MOVLW  21
1295A:  MOVWF  FF7
1295C:  MOVLW  00
1295E:  MOVWF  FF8
12960:  MOVLW  07
12962:  MOVLB  8
12964:  MOVWF  xC9
12966:  MOVLB  0
12968:  CALL   AA6C
1296C:  MOVFF  875,8CB
12970:  MOVLW  1B
12972:  MOVLB  8
12974:  MOVWF  xCC
12976:  MOVLB  0
12978:  CALL   525A
1297C:  MOVLW  A1
1297E:  MOVWF  FF6
12980:  MOVLW  21
12982:  MOVWF  FF7
12984:  MOVLW  00
12986:  MOVWF  FF8
12988:  MOVLW  09
1298A:  MOVLB  8
1298C:  MOVWF  xC9
1298E:  MOVLB  0
12990:  CALL   AA6C
....................    record_event();    
12994:  CALL   847A
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
12998:  MOVLB  8
1299A:  MOVF   x79,W
1299C:  SUBLW  03
1299E:  BNC   12A70
129A0:  MOVF   x7A,W
129A2:  SUBLW  61
129A4:  BNZ   12A70
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
129A6:  MOVF   1F,W
129A8:  SUBLW  04
129AA:  BNZ   12A3E
129AC:  MOVF   20,F
129AE:  BNZ   12A3E
....................                                                macro_status, (line + 1)); 
129B0:  MOVLW  01
129B2:  ADDWF  x78,W
129B4:  MOVWF  x7B
129B6:  MOVLW  00
129B8:  ADDWFC x79,W
129BA:  MOVWF  x7C
129BC:  MOVLW  AC
129BE:  MOVWF  FF6
129C0:  MOVLW  21
129C2:  MOVWF  FF7
129C4:  MOVLW  00
129C6:  MOVWF  FF8
129C8:  CLRF   1B
129CA:  BTFSC  FF2.7
129CC:  BSF    1B.7
129CE:  BCF    FF2.7
129D0:  MOVLW  05
129D2:  MOVLB  A
129D4:  MOVWF  x19
129D6:  MOVLB  0
129D8:  CALL   104E
129DC:  BTFSC  1B.7
129DE:  BSF    FF2.7
129E0:  MOVLB  8
129E2:  MOVF   x7A,W
129E4:  BTFSS  F9E.4
129E6:  BRA    129E4
129E8:  MOVWF  FAD
129EA:  MOVLW  5D
129EC:  BTFSS  F9E.4
129EE:  BRA    129EC
129F0:  MOVWF  FAD
129F2:  MOVLW  5B
129F4:  BTFSS  F9E.4
129F6:  BRA    129F4
129F8:  MOVWF  FAD
129FA:  MOVLW  10
129FC:  MOVWF  FE9
129FE:  CLRF   1B
12A00:  BTFSC  FF2.7
12A02:  BSF    1B.7
12A04:  BCF    FF2.7
12A06:  MOVFF  87C,A1A
12A0A:  MOVFF  87B,A19
12A0E:  MOVLB  0
12A10:  CALL   11D0
12A14:  BTFSC  1B.7
12A16:  BSF    FF2.7
12A18:  MOVLW  B8
12A1A:  MOVWF  FF6
12A1C:  MOVLW  21
12A1E:  MOVWF  FF7
12A20:  MOVLW  00
12A22:  MOVWF  FF8
12A24:  CLRF   1B
12A26:  BTFSC  FF2.7
12A28:  BSF    1B.7
12A2A:  BCF    FF2.7
12A2C:  MOVLW  03
12A2E:  MOVLB  A
12A30:  MOVWF  x19
12A32:  MOVLB  0
12A34:  CALL   104E
12A38:  BTFSC  1B.7
12A3A:  BSF    FF2.7
12A3C:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
12A3E:  MOVFF  875,87B
12A42:  MOVLW  08
12A44:  MOVWF  x7D
12A46:  MOVLW  78
12A48:  MOVWF  x7C
12A4A:  MOVFF  877,87F
12A4E:  MOVFF  876,87E
12A52:  MOVLB  0
12A54:  GOTO   11C92
12A58:  MOVFF  01,87A
....................       ++line; 
12A5C:  MOVLB  8
12A5E:  INCF   x78,F
12A60:  BTFSC  FD8.2
12A62:  INCF   x79,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
12A64:  DECFSZ 50,W
12A66:  BRA    12A6E
....................          macro_status = 'g'; 
12A68:  MOVLW  67
12A6A:  MOVWF  x7A
....................          break;    
12A6C:  BRA    12A70
....................       } 
12A6E:  BRA    1299A
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
12A70:  MOVF   2F,W
12A72:  MOVWF  00
12A74:  MOVF   30,W
12A76:  MOVWF  03
12A78:  MOVF   03,W
12A7A:  BNZ   12A86
12A7C:  MOVLW  01
12A7E:  SUBWF  00,W
12A80:  MOVLB  0
12A82:  BZ    12AA4
12A84:  MOVLB  8
12A86:  MOVF   03,W
12A88:  BNZ   12A94
12A8A:  MOVLW  03
12A8C:  SUBWF  00,W
12A8E:  MOVLB  0
12A90:  BZ    12AA4
12A92:  MOVLB  8
12A94:  MOVF   03,W
12A96:  BNZ   12AA2
12A98:  MOVLW  02
12A9A:  SUBWF  00,W
12A9C:  MOVLB  0
12A9E:  BZ    12AAE
12AA0:  MOVLB  8
12AA2:  BRA    12ABE
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
12AA4:  MOVFF  875,87B
12AA8:  RCALL  12638
....................          break; 
12AAA:  MOVLB  8
12AAC:  BRA    12ABE
....................       case AWS : store_aws_data(macro,mmacro_var); 
12AAE:  MOVFF  875,87B
12AB2:  MOVFF  877,87D
12AB6:  MOVFF  876,87C
12ABA:  BRA    127FC
....................          break; 
12ABC:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
12ABE:  MOVLW  61
12AC0:  SUBWF  x7A,W
12AC2:  ADDLW  F9
12AC4:  BC    12BB0
12AC6:  ADDLW  07
12AC8:  MOVLB  0
12ACA:  GOTO   12C5C
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
12ACE:  MOVLW  BC
12AD0:  MOVWF  FF6
12AD2:  MOVLW  21
12AD4:  MOVWF  FF7
12AD6:  MOVLW  00
12AD8:  MOVWF  FF8
12ADA:  CLRF   1B
12ADC:  BTFSC  FF2.7
12ADE:  BSF    1B.7
12AE0:  BCF    FF2.7
12AE2:  CALL   0E78
12AE6:  BTFSC  1B.7
12AE8:  BSF    FF2.7
....................          break; 
12AEA:  MOVLB  8
12AEC:  BRA    12BB0
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
12AEE:  MOVLW  C4
12AF0:  MOVWF  FF6
12AF2:  MOVLW  21
12AF4:  MOVWF  FF7
12AF6:  MOVLW  00
12AF8:  MOVWF  FF8
12AFA:  CLRF   1B
12AFC:  BTFSC  FF2.7
12AFE:  BSF    1B.7
12B00:  BCF    FF2.7
12B02:  CALL   0E78
12B06:  BTFSC  1B.7
12B08:  BSF    FF2.7
....................          break; 
12B0A:  MOVLB  8
12B0C:  BRA    12BB0
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
12B0E:  MOVLW  CC
12B10:  MOVWF  FF6
12B12:  MOVLW  21
12B14:  MOVWF  FF7
12B16:  MOVLW  00
12B18:  MOVWF  FF8
12B1A:  CLRF   1B
12B1C:  BTFSC  FF2.7
12B1E:  BSF    1B.7
12B20:  BCF    FF2.7
12B22:  CALL   0E78
12B26:  BTFSC  1B.7
12B28:  BSF    FF2.7
....................          break; 
12B2A:  MOVLB  8
12B2C:  BRA    12BB0
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
12B2E:  MOVLW  D4
12B30:  MOVWF  FF6
12B32:  MOVLW  21
12B34:  MOVWF  FF7
12B36:  MOVLW  00
12B38:  MOVWF  FF8
12B3A:  CLRF   1B
12B3C:  BTFSC  FF2.7
12B3E:  BSF    1B.7
12B40:  BCF    FF2.7
12B42:  CALL   0E78
12B46:  BTFSC  1B.7
12B48:  BSF    FF2.7
....................          break; 
12B4A:  MOVLB  8
12B4C:  BRA    12BB0
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
12B4E:  MOVLW  DC
12B50:  MOVWF  FF6
12B52:  MOVLW  21
12B54:  MOVWF  FF7
12B56:  MOVLW  00
12B58:  MOVWF  FF8
12B5A:  CLRF   1B
12B5C:  BTFSC  FF2.7
12B5E:  BSF    1B.7
12B60:  BCF    FF2.7
12B62:  CALL   0E78
12B66:  BTFSC  1B.7
12B68:  BSF    FF2.7
....................          break;    
12B6A:  MOVLB  8
12B6C:  BRA    12BB0
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
12B6E:  MOVLW  E4
12B70:  MOVWF  FF6
12B72:  MOVLW  21
12B74:  MOVWF  FF7
12B76:  MOVLW  00
12B78:  MOVWF  FF8
12B7A:  CLRF   1B
12B7C:  BTFSC  FF2.7
12B7E:  BSF    1B.7
12B80:  BCF    FF2.7
12B82:  CALL   0E78
12B86:  BTFSC  1B.7
12B88:  BSF    FF2.7
....................          break;    
12B8A:  MOVLB  8
12B8C:  BRA    12BB0
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
12B8E:  MOVLW  EC
12B90:  MOVWF  FF6
12B92:  MOVLW  21
12B94:  MOVWF  FF7
12B96:  MOVLW  00
12B98:  MOVWF  FF8
12B9A:  CLRF   1B
12B9C:  BTFSC  FF2.7
12B9E:  BSF    1B.7
12BA0:  BCF    FF2.7
12BA2:  CALL   0E78
12BA6:  BTFSC  1B.7
12BA8:  BSF    FF2.7
....................          break;           
12BAA:  MOVLB  8
12BAC:  BRA    12BB0
12BAE:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
12BB0:  MOVLW  01
12BB2:  MOVWF  1E
12BB4:  MOVLW  A7
12BB6:  MOVWF  1D
12BB8:  MOVLW  F4
12BBA:  MOVWF  FF6
12BBC:  MOVLW  21
12BBE:  MOVWF  FF7
12BC0:  MOVLW  00
12BC2:  MOVWF  FF8
12BC4:  MOVLW  07
12BC6:  MOVWF  xC9
12BC8:  MOVLB  0
12BCA:  CALL   AA6C
12BCE:  MOVFF  875,8CB
12BD2:  MOVLW  1B
12BD4:  MOVLB  8
12BD6:  MOVWF  xCC
12BD8:  MOVLB  0
12BDA:  CALL   525A
12BDE:  MOVLW  FD
12BE0:  MOVWF  FF6
12BE2:  MOVLW  21
12BE4:  MOVWF  FF7
12BE6:  MOVLW  00
12BE8:  MOVWF  FF8
12BEA:  MOVLW  09
12BEC:  MOVLB  8
12BEE:  MOVWF  xC9
12BF0:  MOVLB  0
12BF2:  CALL   AA6C
12BF6:  MOVFF  87A,8DD
12BFA:  CALL   5078
12BFE:  MOVLW  08
12C00:  MOVWF  FF6
12C02:  MOVLW  22
12C04:  MOVWF  FF7
12C06:  MOVLW  00
12C08:  MOVWF  FF8
12C0A:  MOVLW  07
12C0C:  MOVLB  8
12C0E:  MOVWF  xC9
12C10:  MOVLB  0
12C12:  CALL   AA6C
12C16:  MOVLW  10
12C18:  MOVWF  FE9
12C1A:  MOVFF  879,8D5
12C1E:  MOVFF  878,8D4
12C22:  CALL   AA9E
12C26:  MOVLW  12
12C28:  MOVWF  FF6
12C2A:  MOVLW  22
12C2C:  MOVWF  FF7
12C2E:  MOVLW  00
12C30:  MOVWF  FF8
12C32:  MOVLW  03
12C34:  MOVLB  8
12C36:  MOVWF  xC9
12C38:  MOVLB  0
12C3A:  CALL   AA6C
....................    record_event(); 
12C3E:  CALL   847A
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
12C42:  MOVLB  8
12C44:  MOVF   x7A,W
12C46:  SUBLW  66
12C48:  BZ    12C58
12C4A:  MOVF   x7A,W
12C4C:  SUBLW  67
12C4E:  BZ    12C58
12C50:  MOVLB  0
12C52:  CALL   A9F8
12C56:  MOVLB  8
12C58:  MOVLB  0
12C5A:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
1366A:  MOVLW  01
1366C:  MOVLB  8
1366E:  MOVWF  x6C
....................    while (macro_batch == TRUE){ 
13670:  DECFSZ x6C,W
13672:  BRA    138F4
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
13674:  MOVFF  38,9EB
13678:  MOVFF  37,9EA
1367C:  MOVLB  9
1367E:  CLRF   xED
13680:  MOVLW  03
13682:  MOVWF  xEC
13684:  MOVLB  0
13686:  CALL   5C76
1368A:  MOVF   01,W
1368C:  MOVLB  7
1368E:  ADDWF  xD1,W
13690:  MOVLB  8
13692:  MOVWF  x67
13694:  MOVF   02,W
13696:  MOVLB  7
13698:  ADDWFC xD2,W
1369A:  MOVLB  8
1369C:  MOVWF  x68
....................       init_ext_eeprom(); 
1369E:  MOVLB  0
136A0:  CALL   BDC8
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
136A4:  MOVFF  868,8AA
136A8:  MOVFF  867,8A9
136AC:  CALL   BE02
136B0:  MOVFF  01,869
....................       ++addr; 
136B4:  MOVLB  8
136B6:  INCF   x67,F
136B8:  BTFSC  FD8.2
136BA:  INCF   x68,F
....................       macro_arg = read16_ext_eeprom(addr); 
136BC:  MOVFF  868,8A1
136C0:  MOVFF  867,8A0
136C4:  MOVLB  0
136C6:  CALL   BF18
136CA:  MOVFF  02,86B
136CE:  MOVFF  01,86A
....................       ++addr; 
136D2:  MOVLB  8
136D4:  INCF   x67,F
136D6:  BTFSC  FD8.2
136D8:  INCF   x68,F
....................       ++addr;      
136DA:  INCF   x67,F
136DC:  BTFSC  FD8.2
136DE:  INCF   x68,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
136E0:  MOVF   x69,W
136E2:  SUBLW  4D
136E4:  BTFSS  FD8.2
136E6:  BRA    1380E
136E8:  MOVF   x6A,F
136EA:  BNZ   136F2
136EC:  MOVF   x6B,F
136EE:  BTFSC  FD8.2
136F0:  BRA    1380E
....................          { 
....................          RTC_reset_HT(); 
136F2:  MOVLB  0
136F4:  CALL   3496
....................          RTC_read(); 
136F8:  CALL   3328
....................          RTC_display(); 
136FC:  RCALL  13272
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
136FE:  MOVLW  16
13700:  MOVWF  FF6
13702:  MOVLW  22
13704:  MOVWF  FF7
13706:  MOVLW  00
13708:  MOVWF  FF8
1370A:  CLRF   1B
1370C:  BTFSC  FF2.7
1370E:  BSF    1B.7
13710:  BCF    FF2.7
13712:  MOVLW  09
13714:  MOVLB  A
13716:  MOVWF  x19
13718:  MOVLB  0
1371A:  CALL   104E
1371E:  BTFSC  1B.7
13720:  BSF    FF2.7
13722:  MOVLB  8
13724:  MOVF   x69,W
13726:  BTFSS  F9E.4
13728:  BRA    13726
1372A:  MOVWF  FAD
1372C:  MOVLW  10
1372E:  MOVWF  FE9
13730:  CLRF   1B
13732:  BTFSC  FF2.7
13734:  BSF    1B.7
13736:  BCF    FF2.7
13738:  MOVFF  86B,A1A
1373C:  MOVFF  86A,A19
13740:  MOVLB  0
13742:  CALL   11D0
13746:  BTFSC  1B.7
13748:  BSF    FF2.7
1374A:  MOVLW  24
1374C:  MOVWF  FF6
1374E:  MOVLW  22
13750:  MOVWF  FF7
13752:  MOVLW  00
13754:  MOVWF  FF8
13756:  CLRF   1B
13758:  BTFSC  FF2.7
1375A:  BSF    1B.7
1375C:  BCF    FF2.7
1375E:  MOVLW  03
13760:  MOVLB  A
13762:  MOVWF  x19
13764:  MOVLB  0
13766:  CALL   104E
1376A:  BTFSC  1B.7
1376C:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
1376E:  MOVLW  01
13770:  ADDWF  21,W
13772:  MOVLB  8
13774:  MOVWF  x6D
13776:  MOVLW  00
13778:  ADDWFC 22,W
1377A:  MOVWF  x6E
1377C:  MOVLW  28
1377E:  MOVWF  FF6
13780:  MOVLW  22
13782:  MOVWF  FF7
13784:  MOVLW  00
13786:  MOVWF  FF8
13788:  CLRF   1B
1378A:  BTFSC  FF2.7
1378C:  BSF    1B.7
1378E:  BCF    FF2.7
13790:  MOVLW  07
13792:  MOVLB  A
13794:  MOVWF  x19
13796:  MOVLB  0
13798:  CALL   104E
1379C:  BTFSC  1B.7
1379E:  BSF    FF2.7
137A0:  MOVLW  09
137A2:  MOVWF  FE9
137A4:  CLRF   1B
137A6:  BTFSC  FF2.7
137A8:  BSF    1B.7
137AA:  BCF    FF2.7
137AC:  MOVFF  86E,A1A
137B0:  MOVFF  86D,A19
137B4:  CALL   11D0
137B8:  BTFSC  1B.7
137BA:  BSF    FF2.7
137BC:  MOVLW  34
137BE:  MOVWF  FF6
137C0:  MOVLW  22
137C2:  MOVWF  FF7
137C4:  MOVLW  00
137C6:  MOVWF  FF8
137C8:  CLRF   1B
137CA:  BTFSC  FF2.7
137CC:  BSF    1B.7
137CE:  BCF    FF2.7
137D0:  MOVLW  04
137D2:  MOVLB  A
137D4:  MOVWF  x19
137D6:  MOVLB  0
137D8:  CALL   104E
137DC:  BTFSC  1B.7
137DE:  BSF    FF2.7
137E0:  MOVLW  09
137E2:  MOVWF  FE9
137E4:  CLRF   1B
137E6:  BTFSC  FF2.7
137E8:  BSF    1B.7
137EA:  BCF    FF2.7
137EC:  MOVFF  28,A1A
137F0:  MOVFF  27,A19
137F4:  CALL   11D0
137F8:  BTFSC  1B.7
137FA:  BSF    FF2.7
137FC:  MOVLW  0D
137FE:  BTFSS  F9E.4
13800:  BRA    137FE
13802:  MOVWF  FAD
13804:  MOVLW  0A
13806:  BTFSS  F9E.4
13808:  BRA    13806
1380A:  MOVWF  FAD
1380C:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
1380E:  MOVF   28,W
13810:  SUBWF  22,W
13812:  BNC   13820
13814:  BNZ   1381C
13816:  MOVF   27,W
13818:  SUBWF  21,W
1381A:  BNC   13820
....................          {macro_cmd = 'Z';} 
1381C:  MOVLW  5A
1381E:  MOVWF  x69
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
13820:  MOVF   x69,W
13822:  XORLW  72
13824:  MOVLB  0
13826:  BZ    1383A
13828:  XORLW  57
1382A:  BZ    1385C
1382C:  XORLW  68
1382E:  BZ    13892
13830:  XORLW  17
13832:  BZ    138C8
13834:  XORLW  61
13836:  BZ    138D4
13838:  BRA    138DE
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
1383A:  INCF   37,F
1383C:  BTFSC  FD8.2
1383E:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
13840:  MOVLB  8
13842:  CLRF   x60
13844:  CLRF   x5F
13846:  MOVFF  38,85E
1384A:  MOVFF  37,85D
....................                master_macro_loop_count = macro_arg; 
1384E:  CLRF   x5C
13850:  CLRF   x5B
13852:  MOVFF  86B,85A
13856:  MOVFF  86A,859
....................             break; 
1385A:  BRA    138E8
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
1385C:  MOVLB  8
1385E:  MOVF   x5C,F
13860:  BNZ   13870
13862:  MOVF   x5B,F
13864:  BNZ   13870
13866:  MOVF   x5A,F
13868:  BNZ   13870
1386A:  MOVF   x59,W
1386C:  SUBLW  01
1386E:  BC    1388A
....................                   nv_macro_step = master_macro_loop_start; 
13870:  MOVFF  85E,38
13874:  MOVFF  85D,37
....................                   master_macro_loop_count--; 
13878:  MOVLW  FF
1387A:  ADDWF  x59,F
1387C:  BTFSS  FD8.0
1387E:  ADDWF  x5A,F
13880:  BTFSS  FD8.0
13882:  ADDWF  x5B,F
13884:  BTFSS  FD8.0
13886:  ADDWF  x5C,F
....................                }else{ 
13888:  BRA    13890
....................                   nv_macro_step++; 
1388A:  INCF   37,F
1388C:  BTFSC  FD8.2
1388E:  INCF   38,F
....................                } 
....................             break; 
13890:  BRA    138E8
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
13892:  MOVLB  8
13894:  MOVF   x6B,F
13896:  BNZ   138C6
13898:  MOVF   x6A,W
1389A:  SUBLW  14
1389C:  BNC   138C6
....................                   play_macro(macro_arg,0);     // casts to int8 
1389E:  MOVFF  86A,875
138A2:  CLRF   x77
138A4:  CLRF   x76
138A6:  MOVLB  0
138A8:  CALL   12926
....................                   delay_ms(100); 
138AC:  MOVLW  64
138AE:  MOVLB  A
138B0:  MOVWF  xA2
138B2:  MOVLB  0
138B4:  CALL   0588
....................                   ++nv_sample; 
138B8:  INCF   21,F
138BA:  BTFSC  FD8.2
138BC:  INCF   22,F
....................                   ++nv_macro_step; 
138BE:  INCF   37,F
138C0:  BTFSC  FD8.2
138C2:  INCF   38,F
138C4:  MOVLB  8
....................                } 
....................                break; 
138C6:  BRA    138E8
....................             case 'Z' : ++nv_macro_step; 
138C8:  INCF   37,F
138CA:  BTFSC  FD8.2
138CC:  INCF   38,F
....................                        macro_batch = FALSE; 
138CE:  MOVLB  8
138D0:  CLRF   x6C
....................                break; 
138D2:  BRA    138E8
....................             case ';' : nv_macro_step = 0; 
138D4:  CLRF   38
138D6:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
138D8:  MOVLB  8
138DA:  BRA    138E8
138DC:  MOVLB  0
....................             default  : cmd_err(); 
138DE:  RCALL  1364C
....................                        macro_cmd = 'e'; 
138E0:  MOVLW  65
138E2:  MOVLB  8
138E4:  MOVWF  x69
....................                        macro_batch = FALSE; 
138E6:  CLRF   x6C
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
138E8:  DECFSZ 50,W
138EA:  BRA    138F2
....................             macro_cmd = ';'; 
138EC:  MOVLW  3B
138EE:  MOVWF  x69
....................             break;         // 17 = CTRL-Q (quit) 
138F0:  BRA    138F4
....................          } 
138F2:  BRA    13670
....................    } 
....................    return (macro_cmd); 
138F4:  MOVFF  869,01
138F8:  MOVLB  0
138FA:  GOTO   139A6 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
13D34:  MOVLB  8
13D36:  MOVF   x6A,W
13D38:  XORLW  2B
13D3A:  MOVLB  0
13D3C:  BZ    13D6C
13D3E:  XORLW  06
13D40:  BZ    13D96
13D42:  XORLW  6F
13D44:  BZ    13DC0
13D46:  XORLW  05
13D48:  BZ    13DD2
13D4A:  XORLW  17
13D4C:  BZ    13DEA
13D4E:  XORLW  01
13D50:  BZ    13E1C
13D52:  XORLW  03
13D54:  BTFSC  FD8.2
13D56:  BRA    13E46
13D58:  XORLW  06
13D5A:  BTFSC  FD8.2
13D5C:  BRA    13E70
13D5E:  XORLW  0D
13D60:  BTFSC  FD8.2
13D62:  BRA    13E86
13D64:  XORLW  62
13D66:  BTFSC  FD8.2
13D68:  BRA    13EB2
13D6A:  BRA    13EBA
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
13D6C:  MOVLW  01
13D6E:  MOVLB  7
13D70:  MOVWF  x40
....................                  move_motor(0,0,macro_arg,1); 
13D72:  MOVLB  8
13D74:  CLRF   xA5
13D76:  CLRF   xA6
13D78:  CLRF   xAA
13D7A:  CLRF   xA9
13D7C:  MOVFF  86C,8A8
13D80:  MOVFF  86B,8A7
13D84:  MOVWF  xAB
13D86:  MOVLB  0
13D88:  CALL   9D18
....................                  macro_status=step_err_status(); 
13D8C:  CALL   10C38
13D90:  MOVFF  01,86D
....................          break; 
13D94:  BRA    13EBA
....................       case '-' : motor=1; 
13D96:  MOVLW  01
13D98:  MOVLB  7
13D9A:  MOVWF  x40
....................                  move_motor(0,1,macro_arg,1); 
13D9C:  MOVLB  8
13D9E:  CLRF   xA5
13DA0:  MOVWF  xA6
13DA2:  CLRF   xAA
13DA4:  CLRF   xA9
13DA6:  MOVFF  86C,8A8
13DAA:  MOVFF  86B,8A7
13DAE:  MOVWF  xAB
13DB0:  MOVLB  0
13DB2:  CALL   9D18
....................                  macro_status=step_err_status(); 
13DB6:  CALL   10C38
13DBA:  MOVFF  01,86D
....................          break; 
13DBE:  BRA    13EBA
....................       case 'B' : h_bridge(macro_arg); 
13DC0:  MOVFF  86B,893
13DC4:  CALL   112F4
....................                  macro_status = 'a'; 
13DC8:  MOVLW  61
13DCA:  MOVLB  8
13DCC:  MOVWF  x6D
....................          break; 
13DCE:  MOVLB  0
13DD0:  BRA    13EBA
....................       case 'G' : motor=0; 
13DD2:  MOVLB  7
13DD4:  CLRF   x40
....................                  align(0); 
13DD6:  MOVLB  8
13DD8:  CLRF   xA0
13DDA:  MOVLB  0
13DDC:  CALL   A854
....................                  macro_status=step_err_status(); 
13DE0:  CALL   10C38
13DE4:  MOVFF  01,86D
....................          break ;           
13DE8:  BRA    13EBA
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
13DEA:  MOVFF  86C,2E
13DEE:  MOVFF  86B,2D
....................                  motor=0; 
13DF2:  MOVLB  7
13DF4:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1);   
13DF6:  MOVLB  8
13DF8:  CLRF   xA5
13DFA:  CLRF   xA6
13DFC:  CLRF   xAA
13DFE:  CLRF   xA9
13E00:  MOVFF  86C,8A8
13E04:  MOVFF  86B,8A7
13E08:  MOVLW  01
13E0A:  MOVWF  xAB
13E0C:  MOVLB  0
13E0E:  CALL   9D18
....................                  macro_status=step_err_status(); 
13E12:  CALL   10C38
13E16:  MOVFF  01,86D
....................          break; 
13E1A:  BRA    13EBA
....................       case 'Q' : motor=0; 
13E1C:  MOVLB  7
13E1E:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1); 
13E20:  MOVLB  8
13E22:  CLRF   xA5
13E24:  CLRF   xA6
13E26:  CLRF   xAA
13E28:  CLRF   xA9
13E2A:  MOVFF  86C,8A8
13E2E:  MOVFF  86B,8A7
13E32:  MOVLW  01
13E34:  MOVWF  xAB
13E36:  MOVLB  0
13E38:  CALL   9D18
....................                  macro_status=step_err_status(); 
13E3C:  CALL   10C38
13E40:  MOVFF  01,86D
....................          break; 
13E44:  BRA    13EBA
....................       case 'R' : motor=0; 
13E46:  MOVLB  7
13E48:  CLRF   x40
....................                  move_motor(0,1,macro_arg,1); 
13E4A:  MOVLB  8
13E4C:  CLRF   xA5
13E4E:  MOVLW  01
13E50:  MOVWF  xA6
13E52:  CLRF   xAA
13E54:  CLRF   xA9
13E56:  MOVFF  86C,8A8
13E5A:  MOVFF  86B,8A7
13E5E:  MOVWF  xAB
13E60:  MOVLB  0
13E62:  CALL   9D18
....................                  macro_status=step_err_status(); 
13E66:  CALL   10C38
13E6A:  MOVFF  01,86D
....................          break; 
13E6E:  BRA    13EBA
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
13E70:  MOVFF  86C,8A1
13E74:  MOVFF  86B,8A0
13E78:  CALL   E500
....................                  macro_status = 'a'; 
13E7C:  MOVLW  61
13E7E:  MOVLB  8
13E80:  MOVWF  x6D
....................          break; 
13E82:  MOVLB  0
13E84:  BRA    13EBA
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
13E86:  MOVLB  8
13E88:  DECFSZ x6B,W
13E8A:  BRA    13E9A
13E8C:  MOVF   x6C,F
13E8E:  BNZ   13E9A
13E90:  MOVLB  0
13E92:  CALL   10C70
13E96:  BRA    13EA8
13E98:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
13E9A:  MOVF   x6B,F
13E9C:  BNZ   13EAA
13E9E:  MOVF   x6C,F
13EA0:  BNZ   13EAA
13EA2:  MOVLB  0
13EA4:  CALL   FFE6
13EA8:  MOVLB  8
....................                  macro_status = 'a'; 
13EAA:  MOVLW  61
13EAC:  MOVWF  x6D
....................          break;           
13EAE:  MOVLB  0
13EB0:  BRA    13EBA
....................       case ';' : macro_status = 'f'; 
13EB2:  MOVLW  66
13EB4:  MOVLB  8
13EB6:  MOVWF  x6D
....................          break;            
13EB8:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
13EBA:  MOVLB  8
13EBC:  MOVFF  86D,01
13EC0:  MOVLB  0
13EC2:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
13EC4:  MOVF   2E,F
13EC6:  BNZ   13ECE
13EC8:  MOVF   2D,W
13ECA:  SUBLW  01
13ECC:  BC    13EE0
13ECE:  MOVF   2E,F
13ED0:  BNZ   13EE0
13ED2:  MOVF   2D,W
13ED4:  SUBLW  30
13ED6:  BNC   13EE0
13ED8:  DECFSZ 2F,W
13EDA:  BRA    13EE0
13EDC:  MOVF   30,F
13EDE:  BZ    13EFE
13EE0:  MOVF   2E,F
13EE2:  BNZ   13EEA
13EE4:  MOVF   2D,W
13EE6:  SUBLW  01
13EE8:  BC    13F08
13EEA:  MOVF   2E,F
13EEC:  BNZ   13F08
13EEE:  MOVF   2D,W
13EF0:  SUBLW  32
13EF2:  BNC   13F08
13EF4:  MOVF   2F,W
13EF6:  SUBLW  03
13EF8:  BNZ   13F08
13EFA:  MOVF   30,F
13EFC:  BNZ   13F08
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
13EFE:  MOVLW  61
13F00:  MOVLB  8
13F02:  MOVWF  x69
....................    } 
13F04:  BRA    13F10
13F06:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
13F08:  MOVLW  65
13F0A:  MOVLB  8
13F0C:  MOVWF  x69
....................       goto end_macro;       
13F0E:  BRA    13FC0
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
13F10:  MOVLW  59
13F12:  MOVWF  x6A
13F14:  CLRF   x6C
13F16:  MOVLW  01
13F18:  MOVWF  x6B
13F1A:  MOVLB  0
13F1C:  RCALL  13D34
13F1E:  MOVFF  01,869
....................    if (macro_status != 'a') goto end_macro; 
13F22:  MOVLB  8
13F24:  MOVF   x69,W
13F26:  SUBLW  61
13F28:  BTFSS  FD8.2
13F2A:  BRA    13FC0
....................    macro_status = play_wms_macro_cmd('G',1); 
13F2C:  MOVLW  47
13F2E:  MOVWF  x6A
13F30:  CLRF   x6C
13F32:  MOVLW  01
13F34:  MOVWF  x6B
13F36:  MOVLB  0
13F38:  RCALL  13D34
13F3A:  MOVFF  01,869
....................    if (macro_status != 'a') goto end_macro; 
13F3E:  MOVLB  8
13F40:  MOVF   x69,W
13F42:  SUBLW  61
13F44:  BTFSS  FD8.2
13F46:  BRA    13FC0
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
13F48:  MOVLW  2D
13F4A:  MOVWF  x6A
13F4C:  MOVFF  2C,86C
13F50:  MOVFF  2B,86B
13F54:  MOVLB  0
13F56:  RCALL  13D34
13F58:  MOVFF  01,869
....................    if (macro_status != 'a') goto end_macro; 
13F5C:  MOVLB  8
13F5E:  MOVF   x69,W
13F60:  SUBLW  61
13F62:  BTFSS  FD8.2
13F64:  BRA    13FC0
....................    macro_status = play_wms_macro_cmd('P',port); 
13F66:  MOVLW  50
13F68:  MOVWF  x6A
13F6A:  MOVFF  868,86C
13F6E:  MOVFF  867,86B
13F72:  MOVLB  0
13F74:  RCALL  13D34
13F76:  MOVFF  01,869
....................    if (macro_status != 'a') goto end_macro;    
13F7A:  MOVLB  8
13F7C:  MOVF   x69,W
13F7E:  SUBLW  61
13F80:  BTFSS  FD8.2
13F82:  BRA    13FC0
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
13F84:  MOVLW  2B
13F86:  MOVWF  x6A
13F88:  MOVFF  2C,86C
13F8C:  MOVFF  2B,86B
13F90:  MOVLB  0
13F92:  RCALL  13D34
13F94:  MOVFF  01,869
....................    if (macro_status != 'a') goto end_macro; 
13F98:  MOVLB  8
13F9A:  MOVF   x69,W
13F9C:  SUBLW  61
13F9E:  BTFSS  FD8.2
13FA0:  BRA    13FC0
....................    macro_status = play_wms_macro_cmd('Y',0); 
13FA2:  MOVLW  59
13FA4:  MOVWF  x6A
13FA6:  CLRF   x6C
13FA8:  CLRF   x6B
13FAA:  MOVLB  0
13FAC:  RCALL  13D34
13FAE:  MOVFF  01,869
....................    if (macro_status != 'a') goto end_macro; 
13FB2:  MOVLB  8
13FB4:  MOVF   x69,W
13FB6:  SUBLW  61
13FB8:  BTFSS  FD8.2
13FBA:  BRA    13FC0
....................    macro_status='f';  
13FBC:  MOVLW  66
13FBE:  MOVWF  x69
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
13FC0:  CLRF   x7B
13FC2:  MOVLB  0
13FC4:  CALL   12638
....................    
....................    switch(macro_status){ 
13FC8:  MOVLW  61
13FCA:  MOVLB  8
13FCC:  SUBWF  x69,W
13FCE:  ADDLW  FA
13FD0:  BC    140A4
13FD2:  ADDLW  06
13FD4:  MOVLB  0
13FD6:  GOTO   140AA
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
13FDA:  MOVF   1F,F
13FDC:  BNZ   13FE2
13FDE:  MOVF   20,F
13FE0:  BZ    13FFE
13FE2:  MOVLW  40
13FE4:  MOVWF  FF6
13FE6:  MOVLW  22
13FE8:  MOVWF  FF7
13FEA:  MOVLW  00
13FEC:  MOVWF  FF8
13FEE:  CLRF   1B
13FF0:  BTFSC  FF2.7
13FF2:  BSF    1B.7
13FF4:  BCF    FF2.7
13FF6:  CALL   0E78
13FFA:  BTFSC  1B.7
13FFC:  BSF    FF2.7
....................          break; 
13FFE:  MOVLB  8
14000:  BRA    140A4
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
14002:  MOVLW  48
14004:  MOVWF  FF6
14006:  MOVLW  22
14008:  MOVWF  FF7
1400A:  MOVLW  00
1400C:  MOVWF  FF8
1400E:  CLRF   1B
14010:  BTFSC  FF2.7
14012:  BSF    1B.7
14014:  BCF    FF2.7
14016:  CALL   0E78
1401A:  BTFSC  1B.7
1401C:  BSF    FF2.7
....................          break; 
1401E:  MOVLB  8
14020:  BRA    140A4
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
14022:  MOVLW  50
14024:  MOVWF  FF6
14026:  MOVLW  22
14028:  MOVWF  FF7
1402A:  MOVLW  00
1402C:  MOVWF  FF8
1402E:  CLRF   1B
14030:  BTFSC  FF2.7
14032:  BSF    1B.7
14034:  BCF    FF2.7
14036:  CALL   0E78
1403A:  BTFSC  1B.7
1403C:  BSF    FF2.7
....................          break; 
1403E:  MOVLB  8
14040:  BRA    140A4
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
14042:  MOVLW  58
14044:  MOVWF  FF6
14046:  MOVLW  22
14048:  MOVWF  FF7
1404A:  MOVLW  00
1404C:  MOVWF  FF8
1404E:  CLRF   1B
14050:  BTFSC  FF2.7
14052:  BSF    1B.7
14054:  BCF    FF2.7
14056:  CALL   0E78
1405A:  BTFSC  1B.7
1405C:  BSF    FF2.7
....................          break; 
1405E:  MOVLB  8
14060:  BRA    140A4
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
14062:  MOVLW  60
14064:  MOVWF  FF6
14066:  MOVLW  22
14068:  MOVWF  FF7
1406A:  MOVLW  00
1406C:  MOVWF  FF8
1406E:  CLRF   1B
14070:  BTFSC  FF2.7
14072:  BSF    1B.7
14074:  BCF    FF2.7
14076:  CALL   0E78
1407A:  BTFSC  1B.7
1407C:  BSF    FF2.7
....................          break;    
1407E:  MOVLB  8
14080:  BRA    140A4
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
14082:  MOVLW  68
14084:  MOVWF  FF6
14086:  MOVLW  22
14088:  MOVWF  FF7
1408A:  MOVLW  00
1408C:  MOVWF  FF8
1408E:  CLRF   1B
14090:  BTFSC  FF2.7
14092:  BSF    1B.7
14094:  BCF    FF2.7
14096:  CALL   0E78
1409A:  BTFSC  1B.7
1409C:  BSF    FF2.7
....................          break;           
1409E:  MOVLB  8
140A0:  BRA    140A4
140A2:  MOVLB  8
....................    } 
140A4:  MOVLB  0
140A6:  GOTO   141D0 (RETURN)
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
13B3E:  MOVLB  8
13B40:  MOVF   x67,W
13B42:  BTFSC  FD8.2
13B44:  DECF   x68,F
13B46:  DECF   x67,F
....................    addr = macro_address[0] + (step*9); 
13B48:  MOVFF  868,9EB
13B4C:  MOVFF  867,9EA
13B50:  MOVLB  9
13B52:  CLRF   xED
13B54:  MOVLW  09
13B56:  MOVWF  xEC
13B58:  MOVLB  0
13B5A:  CALL   5C76
13B5E:  MOVF   01,W
13B60:  MOVLB  7
13B62:  ADDWF  xD1,W
13B64:  MOVLB  8
13B66:  MOVWF  x69
13B68:  MOVF   02,W
13B6A:  MOVLB  7
13B6C:  ADDWFC xD2,W
13B6E:  MOVLB  8
13B70:  MOVWF  x6A
....................     
....................    init_ext_eeprom(); 
13B72:  MOVLB  0
13B74:  CALL   BDC8
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
13B78:  MOVFF  86A,8AA
13B7C:  MOVFF  869,8A9
13B80:  CALL   BE02
13B84:  MOVFF  01,86B
....................    ++addr; 
13B88:  MOVLB  8
13B8A:  INCF   x69,F
13B8C:  BTFSC  FD8.2
13B8E:  INCF   x6A,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
13B90:  MOVFF  86A,8A1
13B94:  MOVFF  869,8A0
13B98:  MOVLB  0
13B9A:  CALL   BF18
13B9E:  MOVFF  02,86F
13BA2:  MOVFF  01,86E
....................    ++addr; 
13BA6:  MOVLB  8
13BA8:  INCF   x69,F
13BAA:  BTFSC  FD8.2
13BAC:  INCF   x6A,F
....................    ++addr; 
13BAE:  INCF   x69,F
13BB0:  BTFSC  FD8.2
13BB2:  INCF   x6A,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
13BB4:  MOVFF  86A,8AA
13BB8:  MOVFF  869,8A9
13BBC:  MOVLB  0
13BBE:  CALL   BE02
13BC2:  MOVFF  01,86C
....................    ++addr; 
13BC6:  MOVLB  8
13BC8:  INCF   x69,F
13BCA:  BTFSC  FD8.2
13BCC:  INCF   x6A,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
13BCE:  MOVFF  86A,8A1
13BD2:  MOVFF  869,8A0
13BD6:  MOVLB  0
13BD8:  CALL   BF18
13BDC:  MOVFF  02,871
13BE0:  MOVFF  01,870
....................    ++addr; 
13BE4:  MOVLB  8
13BE6:  INCF   x69,F
13BE8:  BTFSC  FD8.2
13BEA:  INCF   x6A,F
....................    ++addr; 
13BEC:  INCF   x69,F
13BEE:  BTFSC  FD8.2
13BF0:  INCF   x6A,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
13BF2:  MOVFF  86A,8AA
13BF6:  MOVFF  869,8A9
13BFA:  MOVLB  0
13BFC:  CALL   BE02
13C00:  MOVFF  01,86D
....................    ++addr; 
13C04:  MOVLB  8
13C06:  INCF   x69,F
13C08:  BTFSC  FD8.2
13C0A:  INCF   x6A,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
13C0C:  MOVFF  86A,8A1
13C10:  MOVFF  869,8A0
13C14:  MOVLB  0
13C16:  CALL   BF18
13C1A:  MOVFF  02,873
13C1E:  MOVFF  01,872
....................    ++addr; 
13C22:  MOVLB  8
13C24:  INCF   x69,F
13C26:  BTFSC  FD8.2
13C28:  INCF   x6A,F
....................    ++addr; 
13C2A:  INCF   x69,F
13C2C:  BTFSC  FD8.2
13C2E:  INCF   x6A,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
13C30:  MOVFF  86A,8AA
13C34:  MOVFF  869,8A9
13C38:  MOVLB  0
13C3A:  CALL   BE02
13C3E:  MOVFF  01,874
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
13C42:  MOVLB  8
13C44:  MOVF   x6B,W
13C46:  SUBLW  4A
13C48:  BTFSS  FD8.2
13C4A:  BRA    13D20
13C4C:  MOVF   x6C,W
13C4E:  SUBLW  50
13C50:  BNZ   13D20
13C52:  MOVF   x6D,W
13C54:  SUBLW  4D
13C56:  BNZ   13D20
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
13C58:  MOVF   x6B,W
13C5A:  BTFSS  F9E.4
13C5C:  BRA    13C5A
13C5E:  MOVWF  FAD
13C60:  MOVLW  10
13C62:  MOVWF  FE9
13C64:  CLRF   1B
13C66:  BTFSC  FF2.7
13C68:  BSF    1B.7
13C6A:  BCF    FF2.7
13C6C:  MOVFF  86F,A1A
13C70:  MOVFF  86E,A19
13C74:  MOVLB  0
13C76:  CALL   11D0
13C7A:  BTFSC  1B.7
13C7C:  BSF    FF2.7
13C7E:  MOVLW  2C
13C80:  BTFSS  F9E.4
13C82:  BRA    13C80
13C84:  MOVWF  FAD
13C86:  MOVLB  8
13C88:  MOVF   x6C,W
13C8A:  BTFSS  F9E.4
13C8C:  BRA    13C8A
13C8E:  MOVWF  FAD
13C90:  MOVLW  10
13C92:  MOVWF  FE9
13C94:  CLRF   1B
13C96:  BTFSC  FF2.7
13C98:  BSF    1B.7
13C9A:  BCF    FF2.7
13C9C:  MOVFF  871,A1A
13CA0:  MOVFF  870,A19
13CA4:  MOVLB  0
13CA6:  CALL   11D0
13CAA:  BTFSC  1B.7
13CAC:  BSF    FF2.7
13CAE:  MOVLW  2C
13CB0:  BTFSS  F9E.4
13CB2:  BRA    13CB0
13CB4:  MOVWF  FAD
13CB6:  MOVLB  8
13CB8:  MOVF   x6D,W
13CBA:  BTFSS  F9E.4
13CBC:  BRA    13CBA
13CBE:  MOVWF  FAD
13CC0:  MOVLW  10
13CC2:  MOVWF  FE9
13CC4:  CLRF   1B
13CC6:  BTFSC  FF2.7
13CC8:  BSF    1B.7
13CCA:  BCF    FF2.7
13CCC:  MOVFF  873,A1A
13CD0:  MOVFF  872,A19
13CD4:  MOVLB  0
13CD6:  CALL   11D0
13CDA:  BTFSC  1B.7
13CDC:  BSF    FF2.7
13CDE:  MOVLW  0D
13CE0:  BTFSS  F9E.4
13CE2:  BRA    13CE0
13CE4:  MOVWF  FAD
13CE6:  MOVLW  0A
13CE8:  BTFSS  F9E.4
13CEA:  BRA    13CE8
13CEC:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
13CEE:  MOVFF  86F,24
13CF2:  MOVFF  86E,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
13CF6:  MOVLB  8
13CF8:  MOVF   x72,F
13CFA:  BNZ   13D00
13CFC:  MOVF   x73,F
13CFE:  BZ    13D1E
13D00:  MOVF   x73,F
13D02:  BNZ   13D1E
13D04:  MOVF   x72,W
13D06:  SUBLW  10
13D08:  BNC   13D1E
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
13D0A:  MOVFF  872,875
13D0E:  MOVFF  871,877
13D12:  MOVFF  870,876
13D16:  MOVLB  0
13D18:  CALL   12926
13D1C:  MOVLB  8
....................       } 
....................    } 
13D1E:  BRA    13D2A
....................    else { 
....................       cmd_err(); 
13D20:  MOVLB  0
13D22:  RCALL  1364C
....................       macro_end = 59; 
13D24:  MOVLW  3B
13D26:  MOVLB  8
13D28:  MOVWF  x74
....................    } 
....................     
....................    return (macro_end); 
13D2A:  MOVFF  874,01
13D2E:  MOVLB  0
13D30:  GOTO   141BC (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
142BC:  MOVLB  8
142BE:  MOVF   x67,W
142C0:  BTFSC  FD8.2
142C2:  DECF   x68,F
142C4:  DECF   x67,F
....................    addr = macro_address[0] + (step*6); 
142C6:  MOVFF  868,9EB
142CA:  MOVFF  867,9EA
142CE:  MOVLB  9
142D0:  CLRF   xED
142D2:  MOVLW  06
142D4:  MOVWF  xEC
142D6:  MOVLB  0
142D8:  CALL   5C76
142DC:  MOVF   01,W
142DE:  MOVLB  7
142E0:  ADDWF  xD1,W
142E2:  MOVLB  8
142E4:  MOVWF  x69
142E6:  MOVF   02,W
142E8:  MOVLB  7
142EA:  ADDWFC xD2,W
142EC:  MOVLB  8
142EE:  MOVWF  x6A
....................     
....................    init_ext_eeprom(); 
142F0:  MOVLB  0
142F2:  CALL   BDC8
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
142F6:  MOVFF  86A,8AA
142FA:  MOVFF  869,8A9
142FE:  CALL   BE02
14302:  MOVFF  01,86B
....................    ++addr; 
14306:  MOVLB  8
14308:  INCF   x69,F
1430A:  BTFSC  FD8.2
1430C:  INCF   x6A,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
1430E:  MOVFF  86A,8A1
14312:  MOVFF  869,8A0
14316:  MOVLB  0
14318:  CALL   BF18
1431C:  MOVFF  02,86E
14320:  MOVFF  01,86D
....................    ++addr; 
14324:  MOVLB  8
14326:  INCF   x69,F
14328:  BTFSC  FD8.2
1432A:  INCF   x6A,F
....................    ++addr; 
1432C:  INCF   x69,F
1432E:  BTFSC  FD8.2
14330:  INCF   x6A,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
14332:  MOVFF  86A,8AA
14336:  MOVFF  869,8A9
1433A:  MOVLB  0
1433C:  CALL   BE02
14340:  MOVFF  01,86C
....................    ++addr; 
14344:  MOVLB  8
14346:  INCF   x69,F
14348:  BTFSC  FD8.2
1434A:  INCF   x6A,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
1434C:  MOVFF  86A,8A1
14350:  MOVFF  869,8A0
14354:  MOVLB  0
14356:  CALL   BF18
1435A:  MOVFF  02,870
1435E:  MOVFF  01,86F
....................    ++addr; 
14362:  MOVLB  8
14364:  INCF   x69,F
14366:  BTFSC  FD8.2
14368:  INCF   x6A,F
....................    ++addr; 
1436A:  INCF   x69,F
1436C:  BTFSC  FD8.2
1436E:  INCF   x6A,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
14370:  MOVFF  86A,8AA
14374:  MOVFF  869,8A9
14378:  MOVLB  0
1437A:  CALL   BE02
1437E:  MOVFF  01,871
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
14382:  MOVLB  8
14384:  MOVF   x6B,W
14386:  SUBLW  50
14388:  BNZ   1442C
1438A:  MOVF   x6C,W
1438C:  SUBLW  4D
1438E:  BNZ   1442C
....................        
....................       RTC_read(); 
14390:  MOVLB  0
14392:  CALL   3328
....................       RTC_display(); 
14396:  CALL   13272
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
1439A:  MOVLB  8
1439C:  MOVF   x6B,W
1439E:  BTFSS  F9E.4
143A0:  BRA    1439E
143A2:  MOVWF  FAD
143A4:  MOVLW  10
143A6:  MOVWF  FE9
143A8:  CLRF   1B
143AA:  BTFSC  FF2.7
143AC:  BSF    1B.7
143AE:  BCF    FF2.7
143B0:  MOVFF  86E,A1A
143B4:  MOVFF  86D,A19
143B8:  MOVLB  0
143BA:  CALL   11D0
143BE:  BTFSC  1B.7
143C0:  BSF    FF2.7
143C2:  MOVLW  2C
143C4:  BTFSS  F9E.4
143C6:  BRA    143C4
143C8:  MOVWF  FAD
143CA:  MOVLB  8
143CC:  MOVF   x6C,W
143CE:  BTFSS  F9E.4
143D0:  BRA    143CE
143D2:  MOVWF  FAD
143D4:  MOVLW  10
143D6:  MOVWF  FE9
143D8:  CLRF   1B
143DA:  BTFSC  FF2.7
143DC:  BSF    1B.7
143DE:  BCF    FF2.7
143E0:  MOVFF  870,A1A
143E4:  MOVFF  86F,A19
143E8:  MOVLB  0
143EA:  CALL   11D0
143EE:  BTFSC  1B.7
143F0:  BSF    FF2.7
143F2:  MOVLW  0D
143F4:  BTFSS  F9E.4
143F6:  BRA    143F4
143F8:  MOVWF  FAD
143FA:  MOVLW  0A
143FC:  BTFSS  F9E.4
143FE:  BRA    143FC
14400:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
14402:  MOVLB  8
14404:  MOVF   x6F,F
14406:  BNZ   1440C
14408:  MOVF   x70,F
1440A:  BZ    1442A
1440C:  MOVF   x70,F
1440E:  BNZ   1442A
14410:  MOVF   x6F,W
14412:  SUBLW  10
14414:  BNC   1442A
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
14416:  MOVFF  86F,875
1441A:  MOVFF  86E,877
1441E:  MOVFF  86D,876
14422:  MOVLB  0
14424:  CALL   12926
14428:  MOVLB  8
....................       } 
....................    } 
1442A:  BRA    14438
....................    else { 
....................       cmd_err(); 
1442C:  MOVLB  0
1442E:  CALL   1364C
....................       macro_end = 59; 
14432:  MOVLW  3B
14434:  MOVLB  8
14436:  MOVWF  x71
....................    } 
....................     
....................    return (macro_end); 
14438:  MOVFF  871,01
1443C:  MOVLB  0
1443E:  GOTO   14520 (RETURN)
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
1391C:  MOVF   24,W
1391E:  SUBWF  36,W
13920:  BTFSS  FD8.0
13922:  BRA    13B28
13924:  BNZ   1392E
13926:  MOVF   23,W
13928:  SUBWF  35,W
1392A:  BTFSS  FD8.0
1392C:  BRA    13B28
1392E:  MOVF   33,F
13930:  BTFSS  FD8.2
13932:  BRA    13B28
13934:  MOVF   34,F
13936:  BTFSS  FD8.2
13938:  BRA    13B28
....................       { 
....................          nv_elapsed = 0; 
1393A:  CLRF   36
1393C:  CLRF   35
....................  
....................          init_hardware(); 
1393E:  CALL   2916
....................          sd_status = init_sdcard(); 
13942:  CALL   5014
13946:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
1394A:  MOVLB  2
1394C:  MOVF   xDC,F
1394E:  BZ    13958
13950:  MOVLB  0
13952:  CALL   505A
13956:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
13958:  MOVLW  01
1395A:  MOVWF  1E
1395C:  MOVLW  A7
1395E:  MOVWF  1D
13960:  MOVLW  70
13962:  MOVWF  FF6
13964:  MOVLW  22
13966:  MOVWF  FF7
13968:  MOVLW  00
1396A:  MOVWF  FF8
1396C:  MOVLW  14
1396E:  MOVLB  8
13970:  MOVWF  xC9
13972:  MOVLB  0
13974:  CALL   AA6C
13978:  MOVLW  10
1397A:  MOVWF  FE9
1397C:  MOVFF  22,8D5
13980:  MOVFF  21,8D4
13984:  CALL   AA9E
13988:  MOVLW  87
1398A:  MOVWF  FF6
1398C:  MOVLW  22
1398E:  MOVWF  FF7
13990:  MOVLW  00
13992:  MOVWF  FF8
13994:  MOVLW  09
13996:  MOVLB  8
13998:  MOVWF  xC9
1399A:  MOVLB  0
1399C:  CALL   AA6C
....................          record_event();          
139A0:  CALL   847A
....................              
....................          macro_cmd = master_macro_eco(); 
139A4:  BRA    1366A
139A6:  MOVFF  01,866
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
139AA:  MOVLW  16
139AC:  MOVLB  8
139AE:  MOVWF  xCC
139B0:  MOVFF  22,8CE
139B4:  MOVFF  21,8CD
139B8:  MOVLB  0
139BA:  CALL   4FAE
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
139BE:  MOVLW  3A
139C0:  MOVLB  8
139C2:  MOVWF  xCC
139C4:  MOVFF  38,8CE
139C8:  MOVFF  37,8CD
139CC:  MOVLB  0
139CE:  CALL   4FAE
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
139D2:  DECFSZ 50,W
139D4:  BRA    139F8
....................          { 
....................             disable_interrupts (INT_EXT); 
139D6:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
139D8:  CLRF   32
139DA:  MOVLW  01
139DC:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
139DE:  MOVLW  02
139E0:  MOVLB  8
139E2:  MOVWF  xA2
139E4:  MOVFF  31,8A3
139E8:  MOVLB  0
139EA:  CALL   33F6
....................             busy_clear(); 
139EE:  CALL   AE16
....................             return (user_quit); 
139F2:  MOVFF  50,01
139F6:  BRA    13B3A
....................          } 
....................  
....................          motor_sleep_rdy(); 
139F8:  CALL   2976
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
139FC:  MOVLW  01
139FE:  MOVWF  1E
13A00:  MOVLW  A7
13A02:  MOVWF  1D
13A04:  MOVLW  92
13A06:  MOVWF  FF6
13A08:  MOVLW  22
13A0A:  MOVWF  FF7
13A0C:  MOVLW  00
13A0E:  MOVWF  FF8
13A10:  MOVLW  14
13A12:  MOVLB  8
13A14:  MOVWF  xC9
13A16:  MOVLB  0
13A18:  CALL   AA6C
13A1C:  MOVLW  10
13A1E:  MOVWF  FE9
13A20:  MOVFF  22,8D5
13A24:  MOVFF  21,8D4
13A28:  CALL   AA9E
13A2C:  MOVLW  A9
13A2E:  MOVWF  FF6
13A30:  MOVLW  22
13A32:  MOVWF  FF7
13A34:  MOVLW  00
13A36:  MOVWF  FF8
13A38:  MOVLW  0C
13A3A:  MOVLB  8
13A3C:  MOVWF  xC9
13A3E:  MOVLB  0
13A40:  CALL   AA6C
....................          record_event();  
13A44:  CALL   847A
....................           
....................          if (macro_cmd == 'e') 
13A48:  MOVLB  8
13A4A:  MOVF   x66,W
13A4C:  SUBLW  65
13A4E:  BNZ   13AA0
....................          { 
....................             disable_interrupts (INT_EXT); 
13A50:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
13A52:  MOVLW  01
13A54:  MOVWF  1E
13A56:  MOVLW  A7
13A58:  MOVWF  1D
13A5A:  MOVLW  B6
13A5C:  MOVWF  FF6
13A5E:  MOVLW  22
13A60:  MOVWF  FF7
13A62:  MOVLW  00
13A64:  MOVWF  FF8
13A66:  MOVLW  14
13A68:  MOVWF  xC9
13A6A:  MOVLB  0
13A6C:  CALL   AA6C
13A70:  MOVLW  10
13A72:  MOVWF  FE9
13A74:  MOVFF  22,8D5
13A78:  MOVFF  21,8D4
13A7C:  CALL   AA9E
13A80:  MOVLW  CD
13A82:  MOVWF  FF6
13A84:  MOVLW  22
13A86:  MOVWF  FF7
13A88:  MOVLW  00
13A8A:  MOVWF  FF8
13A8C:  MOVLW  09
13A8E:  MOVLB  8
13A90:  MOVWF  xC9
13A92:  MOVLB  0
13A94:  CALL   AA6C
....................             record_event();  
13A98:  CALL   847A
....................             cmd_err(); 
13A9C:  RCALL  1364C
13A9E:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
13AA0:  MOVF   28,W
13AA2:  SUBWF  22,W
13AA4:  BNC   13B2A
13AA6:  BNZ   13AAE
13AA8:  MOVF   27,W
13AAA:  SUBWF  21,W
13AAC:  BNC   13B2A
....................          { 
....................             disable_interrupts (INT_EXT); 
13AAE:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
13AB0:  MOVLW  01
13AB2:  MOVWF  1E
13AB4:  MOVLW  A7
13AB6:  MOVWF  1D
13AB8:  MOVLW  D8
13ABA:  MOVWF  FF6
13ABC:  MOVLW  22
13ABE:  MOVWF  FF7
13AC0:  MOVLW  00
13AC2:  MOVWF  FF8
13AC4:  MOVLW  14
13AC6:  MOVWF  xC9
13AC8:  MOVLB  0
13ACA:  CALL   AA6C
13ACE:  MOVLW  10
13AD0:  MOVWF  FE9
13AD2:  MOVFF  22,8D5
13AD6:  MOVFF  21,8D4
13ADA:  CALL   AA9E
13ADE:  MOVLW  EF
13AE0:  MOVWF  FF6
13AE2:  MOVLW  22
13AE4:  MOVWF  FF7
13AE6:  MOVLW  00
13AE8:  MOVWF  FF8
13AEA:  MOVLW  0F
13AEC:  MOVLB  8
13AEE:  MOVWF  xC9
13AF0:  MOVLB  0
13AF2:  CALL   AA6C
....................             record_event();   
13AF6:  CALL   847A
....................             msg_max(); 
13AFA:  RCALL  138FE
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
13AFC:  CLRF   34
13AFE:  MOVLW  01
13B00:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
13B02:  MOVLW  28
13B04:  MOVLB  8
13B06:  MOVWF  xA2
13B08:  MOVFF  33,8A3
13B0C:  MOVLB  0
13B0E:  CALL   33F6
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
13B12:  CLRF   32
13B14:  MOVLW  01
13B16:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
13B18:  MOVLW  02
13B1A:  MOVLB  8
13B1C:  MOVWF  xA2
13B1E:  MOVFF  31,8A3
13B22:  MOVLB  0
13B24:  CALL   33F6
13B28:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
13B2A:  MOVLB  0
13B2C:  CALL   BCA4
13B30:  BRA    1391C
....................    } 
....................     
....................    busy_clear(); 
13B32:  CALL   AE16
....................    return (user_quit); 
13B36:  MOVFF  50,01
13B3A:  GOTO   147FE (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
140D6:  MOVF   24,W
140D8:  SUBWF  36,W
140DA:  BTFSS  FD8.0
140DC:  BRA    142AA
140DE:  BNZ   140E8
140E0:  MOVF   23,W
140E2:  SUBWF  35,W
140E4:  BTFSS  FD8.0
140E6:  BRA    142AA
....................       { 
....................          nv_elapsed = 0; 
140E8:  CLRF   36
140EA:  CLRF   35
....................  
....................          init_hardware(); 
140EC:  CALL   2916
....................          sd_status = init_sdcard(); 
140F0:  CALL   5014
140F4:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
140F8:  MOVLB  2
140FA:  MOVF   xDC,F
140FC:  BZ    14106
140FE:  MOVLB  0
14100:  CALL   505A
14104:  MOVLB  2
....................  
....................          ++nv_sample; 
14106:  INCF   21,F
14108:  BTFSC  FD8.2
1410A:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
1410C:  MOVLW  40
1410E:  BTFSS  F9E.4
14110:  BRA    1410E
14112:  MOVWF  FAD
14114:  MOVLW  53
14116:  BTFSS  F9E.4
14118:  BRA    14116
1411A:  MOVWF  FAD
1411C:  MOVLW  09
1411E:  MOVWF  FE9
14120:  CLRF   1B
14122:  BTFSC  FF2.7
14124:  BSF    1B.7
14126:  BCF    FF2.7
14128:  MOVFF  22,A1A
1412C:  MOVFF  21,A19
14130:  MOVLB  0
14132:  CALL   11D0
14136:  BTFSC  1B.7
14138:  BSF    FF2.7
1413A:  MOVLW  0D
1413C:  BTFSS  F9E.4
1413E:  BRA    1413C
14140:  MOVWF  FAD
14142:  MOVLW  0A
14144:  BTFSS  F9E.4
14146:  BRA    14144
14148:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
1414A:  MOVLW  01
1414C:  MOVWF  1E
1414E:  MOVLW  A7
14150:  MOVWF  1D
14152:  MOVLW  00
14154:  MOVWF  FF6
14156:  MOVLW  23
14158:  MOVWF  FF7
1415A:  MOVLW  00
1415C:  MOVWF  FF8
1415E:  MOVLW  14
14160:  MOVLB  8
14162:  MOVWF  xC9
14164:  MOVLB  0
14166:  CALL   AA6C
1416A:  MOVLW  10
1416C:  MOVWF  FE9
1416E:  MOVFF  22,8D5
14172:  MOVFF  21,8D4
14176:  CALL   AA9E
1417A:  MOVLW  17
1417C:  MOVWF  FF6
1417E:  MOVLW  23
14180:  MOVWF  FF7
14182:  MOVLW  00
14184:  MOVWF  FF8
14186:  MOVLW  09
14188:  MOVLB  8
1418A:  MOVWF  xC9
1418C:  MOVLB  0
1418E:  CALL   AA6C
....................          record_event();   
14192:  CALL   847A
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
14196:  MOVLW  16
14198:  MOVLB  8
1419A:  MOVWF  xCC
1419C:  MOVFF  22,8CE
141A0:  MOVFF  21,8CD
141A4:  MOVLB  0
141A6:  CALL   4FAE
....................  
....................          if (nv_macro_mode==TRUE) 
141AA:  DECFSZ 29,W
141AC:  BRA    141C2
141AE:  MOVF   2A,F
141B0:  BNZ   141C2
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
141B2:  MOVFF  22,868
141B6:  MOVFF  21,867
141BA:  BRA    13B3E
141BC:  MOVFF  01,866
....................          } 
141C0:  BRA    14228
....................          else 
....................          { 
....................             time_stamp(); 
141C2:  CALL   53F4
....................             play_wms_hard_macro(nv_port); 
141C6:  MOVFF  2E,868
141CA:  MOVFF  2D,867
141CE:  BRA    13EC4
....................             ++nv_port; 
141D0:  INCF   2D,F
141D2:  BTFSC  FD8.2
141D4:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
141D6:  MOVF   2E,F
141D8:  BNZ   141E0
141DA:  MOVF   2D,W
141DC:  SUBLW  01
141DE:  BC    141F2
141E0:  MOVF   2E,F
141E2:  BNZ   141F2
141E4:  MOVF   2D,W
141E6:  SUBLW  30
141E8:  BNC   141F2
141EA:  DECFSZ 2F,W
141EC:  BRA    141F2
141EE:  MOVF   30,F
141F0:  BZ    14210
141F2:  MOVF   2E,F
141F4:  BNZ   141FC
141F6:  MOVF   2D,W
141F8:  SUBLW  01
141FA:  BC    14226
141FC:  MOVF   2E,F
141FE:  BNZ   14226
14200:  MOVF   2D,W
14202:  SUBLW  32
14204:  BNC   14226
14206:  MOVF   2F,W
14208:  SUBLW  03
1420A:  BNZ   14226
1420C:  MOVF   30,F
1420E:  BNZ   14226
....................             { 
....................                write16(ADDR_PORT, nv_port);             
14210:  MOVLW  24
14212:  MOVLB  8
14214:  MOVWF  xCC
14216:  MOVFF  2E,8CE
1421A:  MOVFF  2D,8CD
1421E:  MOVLB  0
14220:  CALL   4FAE
....................             } 
14224:  BRA    14228
....................             else disable_interrupts (INT_EXT); 
14226:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
14228:  DECFSZ 50,W
1422A:  BRA    1424E
....................          { 
....................             disable_interrupts (INT_EXT); 
1422C:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
1422E:  CLRF   32
14230:  MOVLW  01
14232:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
14234:  MOVLW  02
14236:  MOVLB  8
14238:  MOVWF  xA2
1423A:  MOVFF  31,8A3
1423E:  MOVLB  0
14240:  CALL   33F6
....................             busy_clear(); 
14244:  CALL   AE16
....................             return (user_quit); 
14248:  MOVFF  50,01
1424C:  BRA    142B8
....................          } 
....................           
....................          motor_sleep_rdy(); 
1424E:  CALL   2976
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
14252:  MOVLW  01
14254:  MOVWF  1E
14256:  MOVLW  A7
14258:  MOVWF  1D
1425A:  MOVLW  22
1425C:  MOVWF  FF6
1425E:  MOVLW  23
14260:  MOVWF  FF7
14262:  MOVLW  00
14264:  MOVWF  FF8
14266:  MOVLW  14
14268:  MOVLB  8
1426A:  MOVWF  xC9
1426C:  MOVLB  0
1426E:  CALL   AA6C
14272:  MOVLW  10
14274:  MOVWF  FE9
14276:  MOVFF  22,8D5
1427A:  MOVFF  21,8D4
1427E:  CALL   AA9E
14282:  MOVLW  39
14284:  MOVWF  FF6
14286:  MOVLW  23
14288:  MOVWF  FF7
1428A:  MOVLW  00
1428C:  MOVWF  FF8
1428E:  MOVLW  0C
14290:  MOVLB  8
14292:  MOVWF  xC9
14294:  MOVLB  0
14296:  CALL   AA6C
....................          record_event();  
1429A:  CALL   847A
....................           
....................          if (macro_end == ';') 
1429E:  MOVLB  8
142A0:  MOVF   x66,W
142A2:  SUBLW  3B
142A4:  BNZ   142A8
....................          { 
....................             disable_interrupts (INT_EXT); 
142A6:  BCF    FF2.4
142A8:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
142AA:  CALL   BCA4
142AE:  BRA    140D6
....................    } 
....................    busy_clear(); 
142B0:  CALL   AE16
....................    return (user_quit); 
142B4:  MOVFF  50,01
142B8:  GOTO   14806 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
14442:  MOVF   24,W
14444:  SUBWF  36,W
14446:  BTFSS  FD8.0
14448:  BRA    14602
1444A:  BNZ   14454
1444C:  MOVF   23,W
1444E:  SUBWF  35,W
14450:  BTFSS  FD8.0
14452:  BRA    14602
....................       { 
....................          nv_elapsed = 0; 
14454:  CLRF   36
14456:  CLRF   35
....................  
....................          init_hardware(); 
14458:  CALL   2916
....................          sd_status = init_sdcard(); 
1445C:  CALL   5014
14460:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
14464:  MOVLB  2
14466:  MOVF   xDC,F
14468:  BZ    14472
1446A:  MOVLB  0
1446C:  CALL   505A
14470:  MOVLB  2
....................  
....................          ++nv_sample; 
14472:  INCF   21,F
14474:  BTFSC  FD8.2
14476:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
14478:  MOVLW  40
1447A:  BTFSS  F9E.4
1447C:  BRA    1447A
1447E:  MOVWF  FAD
14480:  MOVLW  53
14482:  BTFSS  F9E.4
14484:  BRA    14482
14486:  MOVWF  FAD
14488:  MOVLW  09
1448A:  MOVWF  FE9
1448C:  CLRF   1B
1448E:  BTFSC  FF2.7
14490:  BSF    1B.7
14492:  BCF    FF2.7
14494:  MOVFF  22,A1A
14498:  MOVFF  21,A19
1449C:  MOVLB  0
1449E:  CALL   11D0
144A2:  BTFSC  1B.7
144A4:  BSF    FF2.7
144A6:  MOVLW  0D
144A8:  BTFSS  F9E.4
144AA:  BRA    144A8
144AC:  MOVWF  FAD
144AE:  MOVLW  0A
144B0:  BTFSS  F9E.4
144B2:  BRA    144B0
144B4:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
144B6:  MOVLW  01
144B8:  MOVWF  1E
144BA:  MOVLW  A7
144BC:  MOVWF  1D
144BE:  MOVLW  46
144C0:  MOVWF  FF6
144C2:  MOVLW  23
144C4:  MOVWF  FF7
144C6:  MOVLW  00
144C8:  MOVWF  FF8
144CA:  MOVLW  14
144CC:  MOVLB  8
144CE:  MOVWF  xC9
144D0:  MOVLB  0
144D2:  CALL   AA6C
144D6:  MOVLW  10
144D8:  MOVWF  FE9
144DA:  MOVFF  22,8D5
144DE:  MOVFF  21,8D4
144E2:  CALL   AA9E
144E6:  MOVLW  5D
144E8:  MOVWF  FF6
144EA:  MOVLW  23
144EC:  MOVWF  FF7
144EE:  MOVLW  00
144F0:  MOVWF  FF8
144F2:  MOVLW  09
144F4:  MOVLB  8
144F6:  MOVWF  xC9
144F8:  MOVLB  0
144FA:  CALL   AA6C
....................          record_event();   
144FE:  CALL   847A
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
14502:  MOVLW  16
14504:  MOVLB  8
14506:  MOVWF  xCC
14508:  MOVFF  22,8CE
1450C:  MOVFF  21,8CD
14510:  MOVLB  0
14512:  CALL   4FAE
....................  
....................          macro_end = master_macro_aws(nv_sample); 
14516:  MOVFF  22,868
1451A:  MOVFF  21,867
1451E:  BRA    142BC
14520:  MOVFF  01,866
....................           
....................          if (user_quit == TRUE) 
14524:  DECFSZ 50,W
14526:  BRA    1454A
....................          { 
....................             disable_interrupts (INT_EXT); 
14528:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
1452A:  CLRF   32
1452C:  MOVLW  01
1452E:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
14530:  MOVLW  02
14532:  MOVLB  8
14534:  MOVWF  xA2
14536:  MOVFF  31,8A3
1453A:  MOVLB  0
1453C:  CALL   33F6
....................             busy_clear(); 
14540:  CALL   AE16
....................             return (user_quit); 
14544:  MOVFF  50,01
14548:  BRA    14614
....................          } 
....................           
....................          motor_sleep_rdy(); 
1454A:  CALL   2976
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
1454E:  MOVLW  01
14550:  MOVWF  1E
14552:  MOVLW  A7
14554:  MOVWF  1D
14556:  MOVLW  68
14558:  MOVWF  FF6
1455A:  MOVLW  23
1455C:  MOVWF  FF7
1455E:  MOVLW  00
14560:  MOVWF  FF8
14562:  MOVLW  14
14564:  MOVLB  8
14566:  MOVWF  xC9
14568:  MOVLB  0
1456A:  CALL   AA6C
1456E:  MOVLW  10
14570:  MOVWF  FE9
14572:  MOVFF  22,8D5
14576:  MOVFF  21,8D4
1457A:  CALL   AA9E
1457E:  MOVLW  7F
14580:  MOVWF  FF6
14582:  MOVLW  23
14584:  MOVWF  FF7
14586:  MOVLW  00
14588:  MOVWF  FF8
1458A:  MOVLW  0C
1458C:  MOVLB  8
1458E:  MOVWF  xC9
14590:  MOVLB  0
14592:  CALL   AA6C
....................          record_event();  
14596:  CALL   847A
....................           
....................          if (macro_end == ';') 
1459A:  MOVLB  8
1459C:  MOVF   x66,W
1459E:  SUBLW  3B
145A0:  BNZ   145A4
....................          { 
....................             disable_interrupts (INT_EXT); 
145A2:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
145A4:  MOVF   28,W
145A6:  SUBWF  22,W
145A8:  BNC   14604
145AA:  BNZ   145B2
145AC:  MOVF   27,W
145AE:  SUBWF  21,W
145B0:  BNC   14604
....................          { 
....................             disable_interrupts (INT_EXT); 
145B2:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
145B4:  MOVLW  01
145B6:  MOVWF  1E
145B8:  MOVLW  A7
145BA:  MOVWF  1D
145BC:  MOVLW  8C
145BE:  MOVWF  FF6
145C0:  MOVLW  23
145C2:  MOVWF  FF7
145C4:  MOVLW  00
145C6:  MOVWF  FF8
145C8:  MOVLW  14
145CA:  MOVWF  xC9
145CC:  MOVLB  0
145CE:  CALL   AA6C
145D2:  MOVLW  10
145D4:  MOVWF  FE9
145D6:  MOVFF  22,8D5
145DA:  MOVFF  21,8D4
145DE:  CALL   AA9E
145E2:  MOVLW  A3
145E4:  MOVWF  FF6
145E6:  MOVLW  23
145E8:  MOVWF  FF7
145EA:  MOVLW  00
145EC:  MOVWF  FF8
145EE:  MOVLW  0F
145F0:  MOVLB  8
145F2:  MOVWF  xC9
145F4:  MOVLB  0
145F6:  CALL   AA6C
....................             record_event();   
145FA:  CALL   847A
....................             msg_max(); 
145FE:  CALL   138FE
14602:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
14604:  MOVLB  0
14606:  CALL   BCA4
1460A:  BRA    14442
....................    } 
....................    busy_clear(); 
1460C:  CALL   AE16
....................    return (user_quit); 
14610:  MOVFF  50,01
14614:  GOTO   1480E (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
14618:  CALL   299E
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
1461C:  MOVLW  01
1461E:  MOVWF  1E
14620:  MOVLW  A7
14622:  MOVWF  1D
14624:  MOVLW  B4
14626:  MOVWF  FF6
14628:  MOVLW  23
1462A:  MOVWF  FF7
1462C:  MOVLW  00
1462E:  MOVWF  FF8
14630:  CALL   5098
....................    record_event(); 
14634:  CALL   847A
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
14638:  MOVLW  01
1463A:  MOVWF  1E
1463C:  MOVLW  A7
1463E:  MOVWF  1D
14640:  MOVLW  CE
14642:  MOVWF  FF6
14644:  MOVLW  23
14646:  MOVWF  FF7
14648:  MOVLW  00
1464A:  MOVWF  FF8
1464C:  MOVLW  0C
1464E:  MOVLB  8
14650:  MOVWF  xC9
14652:  MOVLB  0
14654:  CALL   AA6C
14658:  MOVLW  10
1465A:  MOVWF  FE9
1465C:  MOVFF  26,8D5
14660:  MOVFF  25,8D4
14664:  CALL   AA9E
14668:  MOVLW  DD
1466A:  MOVWF  FF6
1466C:  MOVLW  23
1466E:  MOVWF  FF7
14670:  MOVLW  00
14672:  MOVWF  FF8
14674:  MOVLW  06
14676:  MOVLB  8
14678:  MOVWF  xC9
1467A:  MOVLB  0
1467C:  CALL   AA6C
14680:  MOVLW  10
14682:  MOVWF  FE9
14684:  MOVFF  24,8D5
14688:  MOVFF  23,8D4
1468C:  CALL   AA9E
14690:  MOVLW  E6
14692:  MOVWF  FF6
14694:  MOVLW  23
14696:  MOVWF  FF7
14698:  MOVLW  00
1469A:  MOVWF  FF8
1469C:  MOVLW  06
1469E:  MOVLB  8
146A0:  MOVWF  xC9
146A2:  MOVLB  0
146A4:  CALL   AA6C
146A8:  MOVLW  10
146AA:  MOVWF  FE9
146AC:  MOVFF  28,8D5
146B0:  MOVFF  27,8D4
146B4:  CALL   AA9E
146B8:  MOVLW  EF
146BA:  MOVWF  FF6
146BC:  MOVLW  23
146BE:  MOVWF  FF7
146C0:  MOVLW  00
146C2:  MOVWF  FF8
146C4:  MOVLW  03
146C6:  MOVLB  8
146C8:  MOVWF  xC9
146CA:  MOVLB  0
146CC:  CALL   AA6C
....................    record_event(); 
146D0:  CALL   847A
....................     
....................    user_quit = FALSE; 
146D4:  CLRF   50
....................     
....................    nv_cmd_mode = FALSE; 
146D6:  CLRF   32
146D8:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
146DA:  MOVLW  02
146DC:  MOVLB  8
146DE:  MOVWF  xA2
146E0:  MOVFF  31,8A3
146E4:  MOVLB  0
146E6:  CALL   33F6
....................  
....................    RTC_set_AFE(); 
146EA:  GOTO   12C8A
....................    // check if start is earlier than now 
....................    RTC_late(); 
146EE:  GOTO   12DB8
....................    // show clock 
....................    RTC_display(); 
146F2:  CALL   13272
....................    // show alarm 
....................    RTC_display_alarm(); 
146F6:  GOTO   133FC
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
146FA:  GOTO   13578
....................  
....................    if (alarm_passed == FALSE){ 
146FE:  BTFSC  4D.3
14700:  BRA    14702
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
14702:  MOVLW  00
14704:  BTFSC  4D.3
14706:  MOVLW  01
14708:  MOVLB  8
1470A:  MOVWF  x66
1470C:  MOVLW  01
1470E:  MOVWF  1E
14710:  MOVLW  A7
14712:  MOVWF  1D
14714:  MOVLW  F4
14716:  MOVWF  FF6
14718:  MOVLW  23
1471A:  MOVWF  FF7
1471C:  MOVLW  00
1471E:  MOVWF  FF8
14720:  MOVLW  14
14722:  MOVWF  xC9
14724:  MOVLB  0
14726:  CALL   AA6C
1472A:  MOVLW  10
1472C:  MOVWF  FE9
1472E:  MOVFF  22,8D5
14732:  MOVFF  21,8D4
14736:  CALL   AA9E
1473A:  MOVLW  0B
1473C:  MOVWF  FF6
1473E:  MOVLW  24
14740:  MOVWF  FF7
14742:  MOVLW  00
14744:  MOVWF  FF8
14746:  MOVLW  08
14748:  MOVLB  8
1474A:  MOVWF  xC9
1474C:  MOVLB  0
1474E:  CALL   AA6C
14752:  MOVFF  866,8CB
14756:  MOVLW  1B
14758:  MOVLB  8
1475A:  MOVWF  xCC
1475C:  MOVLB  0
1475E:  CALL   525A
14762:  MOVLW  15
14764:  MOVWF  FF6
14766:  MOVLW  24
14768:  MOVWF  FF7
1476A:  MOVLW  00
1476C:  MOVWF  FF8
1476E:  MOVLW  03
14770:  MOVLB  8
14772:  MOVWF  xC9
14774:  MOVLB  0
14776:  CALL   AA6C
....................    record_event();  
1477A:  CALL   847A
....................  
....................    while (TRUE == RTC_read_flags_running) 
1477E:  BTFSS  4D.2
14780:  BRA    14784
....................    { 
....................       ; 
14782:  BRA    1477E
....................    } 
....................    RTC_read_flags_running = TRUE; 
14784:  BSF    4D.2
14786:  CLRF   1B
14788:  BTFSC  FF2.7
1478A:  BSF    1B.7
1478C:  BCF    FF2.7
....................    RTC_read_flags(); 
1478E:  CALL   0E02
14792:  BTFSC  1B.7
14794:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
14796:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
14798:  CALL   2976
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
1479C:  BTFSC  4D.3
1479E:  BRA    147C0
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
147A0:  MOVLW  01
147A2:  MOVWF  1E
147A4:  MOVLW  A7
147A6:  MOVWF  1D
147A8:  MOVLW  1A
147AA:  MOVWF  FF6
147AC:  MOVLW  24
147AE:  MOVWF  FF7
147B0:  MOVLW  00
147B2:  MOVWF  FF8
147B4:  CALL   5098
....................       record_event(); 
147B8:  CALL   847A
....................       go_to_sleep(); 
147BC:  CALL   BCA4
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
147C0:  GOTO   1359C
....................    nv_elapsed = nv_interval; 
147C4:  MOVFF  24,36
147C8:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
147CC:  MOVFF  2F,00
147D0:  MOVF   30,W
147D2:  MOVWF  03
147D4:  BNZ   147DA
147D6:  MOVF   00,F
147D8:  BZ    147FA
147DA:  MOVF   03,W
147DC:  BNZ   147E4
147DE:  MOVLW  01
147E0:  SUBWF  00,W
147E2:  BZ    14804
147E4:  MOVF   03,W
147E6:  BNZ   147EE
147E8:  MOVLW  03
147EA:  SUBWF  00,W
147EC:  BZ    14804
147EE:  MOVF   03,W
147F0:  BNZ   147F8
147F2:  MOVLW  02
147F4:  SUBWF  00,W
147F6:  BZ    1480C
147F8:  BRA    14812
....................       case ECO: user_quit = auto_sample_eco(); 
147FA:  GOTO   1391C
147FE:  MOVFF  01,50
....................          break; 
14802:  BRA    14812
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
14804:  BRA    140D6
14806:  MOVFF  01,50
....................          break; 
1480A:  BRA    14812
....................       case AWS: user_quit = auto_sample_aws(); 
1480C:  BRA    14442
1480E:  MOVFF  01,50
....................          break;          
....................    } 
....................    return(user_quit); 
14812:  MOVFF  50,01
14816:  GOTO   14928 (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
....................       detector = arg; 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
....................       switch (detector){ 
....................          case 1 : nv_d1_temp = arg; 
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
....................             break; 
....................          case 2 : nv_d2_temp = arg; 
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
....................             break; 
....................          default : cmd_err(); 
....................             break; 
....................       } 
....................    } 
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
....................       nv_macro_mode = arg; 
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
....................       case ECO : commandAe(); 
....................          break; 
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
....................       nv_det_type = arg; 
....................       write16(ADDR_DET_TYPE, nv_det_type); 
....................    } 
....................    else if(arg==0) { 
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
....................       hb_cmd=arg; 
....................       h_bridge(hb_cmd); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
....................       case ECO : commandBe(); 
....................          break; 
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
....................                   break; 
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
....................                NO3_slope = get_float(); 
....................                fprintf(COM_A,"\r\n");   
....................                write_float(ADDR_CAL_M1,NO3_slope); 
....................          break; 
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
....................                NO3_inter = get_float(); 
....................                fprintf(COM_A,"\r\n");  
....................                write_float(ADDR_CAL_C1,NO3_inter); 
....................          break; 
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
....................                PO4_slope = get_float(); 
....................                fprintf(COM_A,"\r\n"); 
....................                write_float(ADDR_CAL_M2,PO4_slope); 
....................          break; 
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
....................                PO4_inter = get_float(); 
....................                fprintf(COM_A,"\r\n");  
....................                write_float(ADDR_CAL_C2,NO3_inter); 
....................          break; 
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
....................                NH4_slope = get_float(); 
....................                fprintf(COM_A,"\r\n");   
....................                write_float(ADDR_CAL_M3,NH4_slope); 
....................          break; 
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
....................                NH4_inter = get_float(); 
....................                fprintf(COM_A,"\r\n");  
....................                write_float(ADDR_CAL_C3,NH4_inter); 
....................          break; 
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
....................                SiO_slope = get_float(); 
....................                fprintf(COM_A,"\r\n");   
....................                write_float(ADDR_CAL_M4,SiO_slope); 
....................          break; 
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
....................                SiO_inter = get_float(); 
....................                fprintf(COM_A,"\r\n");  
....................                write_float(ADDR_CAL_C4,SiO_inter); 
....................          break;         
....................       default: cmd_arg(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
....................          port=arg; 
....................          play_wms_hard_macro(port);    
....................       } 
....................       else cmd_arg(); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
....................       chip=arg; 
....................       sol_chip_cmd(chip); 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
....................       case ECO : commandCe(); 
....................          break; 
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
....................          break; 
....................       case AWS : commandCa(); 
....................          break;          
....................    } 
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
....................       case 0 : file_list(file_ptr_raw_all); 
....................          break; 
....................       case 1 : file_list(file_ptr_raw_new); 
....................                f_unlink(file_ptr_raw_new); 
....................          break; 
....................       case 2 : file_list(file_ptr_rel_all); 
....................          break; 
....................       case 3 : file_list(file_ptr_rel_new); 
....................                f_unlink(file_ptr_rel_new); 
....................          break;  
....................       default : cmd_arg(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
....................       char result; 
....................       result = fgetc(COM_A); 
....................       if(result == 'Y'){ 
....................       f_unlink(file_ptr_raw_all); 
....................       printf("File deleted!\n\r"); 
....................       }else{ 
....................          printf("Operation canceled!\r\n"); 
....................       } 
....................          break; 
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
....................          result = fgetc(COM_A); 
....................          if(result == 'Y'){ 
....................             f_unlink(file_ptr_rel_all); 
....................             printf("File deleted!\n\r"); 
....................          }else{ 
....................             printf("Operation canceled!\r\n"); 
....................          } 
....................          break; 
....................       default : cmd_arg(); 
....................          break;          
....................    } 
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
....................       reset_nv_vars(); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
....................    { 
....................       busy_set(); 
....................  
....................       switch(arg) 
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
....................             align(0); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
....................             { 
....................                motor=0; 
....................                cal_disk(0); 
....................             } 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
....................             break; 
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
....................    } 
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
....................       v_supply = read_supply(); 
....................        
....................       RTC_reset_HT(); 
....................       RTC_read(); 
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
....................       RTC_display(); 
....................       if (RTCfmt == 0) 
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
....................       } 
....................       if (RTCfmt == 1)  
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
....................       }     
....................       RTC_read_alarm(); 
....................       RTC_display_alarm(); 
....................    } 
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
....................       v_supply = read_supply(); 
....................        
....................       RTC_reset_HT(); 
....................       RTC_read(); 
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
....................       RTC_display(); 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
....................        
....................       RTC_read_alarm(); 
....................       RTC_display_alarm(); 
....................    } 
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
....................       v_supply = read_supply(); 
....................        
....................       RTC_reset_HT(); 
....................       RTC_read(); 
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
....................       display_valve_status(); 
....................       RTC_display(); 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
....................        
....................       RTC_read_alarm(); 
....................       RTC_display_alarm(); 
....................    } 
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
....................       case ECO : commandHe(); 
....................          break; 
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
....................          break; 
....................       case AWS : commandHa(); 
....................          break;          
....................    } 
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
....................       nv_interval = arg; 
....................       write16(ADDR_INTERVAL, nv_interval); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
....................       nv_serial = arg; 
....................       write16(ADDR_SERIALNO, nv_serial); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
....................        
....................       if (arg > 0 && arg < 3){ 
....................          det_cmd(); 
....................       } 
....................       else cmd_arg(); 
....................        
....................    } 
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
....................       switch (nv_det_type){ 
....................          case 1 : det_cmd(); 
....................             break; 
....................          case 2 : DAC_set(1,arg); 
....................             break; 
....................          case 3 : set_LED(arg); 
....................             break; 
....................       } 
....................    } 
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
....................    else if(arg==30001)set_LED_test(); 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
....................       nv_volume = arg; 
....................       write16(ADDR_VOLUME, nv_volume); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
....................       case ECO : commandLe(); 
....................          break; 
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
1481A:  CALL   299E
....................     
....................    user_quit = FALSE; 
1481E:  CLRF   50
....................     
....................    if(arg > 0 && arg < 21) 
14820:  MOVF   48,F
14822:  BNZ   14830
14824:  MOVF   49,F
14826:  BNZ   14830
14828:  MOVF   4A,F
1482A:  BNZ   14830
1482C:  MOVF   4B,F
1482E:  BZ    148AC
14830:  MOVF   4B,F
14832:  BNZ   148AC
14834:  MOVF   4A,F
14836:  BNZ   148AC
14838:  MOVF   49,F
1483A:  BNZ   148AC
1483C:  MOVF   48,W
1483E:  SUBLW  14
14840:  BNC   148AC
....................    { 
....................       macro = arg; 
14842:  MOVFF  48,865
....................       switch(nv_product){ 
14846:  MOVFF  2F,00
1484A:  MOVF   30,W
1484C:  MOVWF  03
1484E:  BNZ   14854
14850:  MOVF   00,F
14852:  BZ    14874
14854:  MOVF   03,W
14856:  BNZ   1485E
14858:  MOVLW  01
1485A:  SUBWF  00,W
1485C:  BZ    14874
1485E:  MOVF   03,W
14860:  BNZ   14868
14862:  MOVLW  03
14864:  SUBWF  00,W
14866:  BZ    14874
14868:  MOVF   03,W
1486A:  BNZ   14872
1486C:  MOVLW  02
1486E:  SUBWF  00,W
14870:  BZ    1489A
14872:  BRA    148AA
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
14874:  MOVLW  01
14876:  MOVLB  7
14878:  ADDWF  xC3,W
1487A:  MOVLB  8
1487C:  MOVWF  x66
1487E:  MOVLW  00
14880:  MOVLB  7
14882:  ADDWFC xC4,W
14884:  MOVLB  8
14886:  MOVWF  x67
14888:  MOVFF  865,875
1488C:  MOVWF  x77
1488E:  MOVFF  866,876
14892:  MOVLB  0
14894:  CALL   12926
....................             break; 
14898:  BRA    148AA
....................          case AWS : play_macro(macro,nv_port); 
1489A:  MOVFF  865,875
1489E:  MOVFF  2E,877
148A2:  MOVFF  2D,876
148A6:  CALL   12926
....................             break; 
....................       } 
....................    }    
148AA:  BRA    14932
....................    else if (arg == 0) 
148AC:  MOVF   48,F
148AE:  BNZ   1492E
148B0:  MOVF   49,F
148B2:  BNZ   1492E
148B4:  MOVF   4A,F
148B6:  BNZ   1492E
148B8:  MOVF   4B,F
148BA:  BNZ   1492E
....................    { 
....................       //start watchdog at beginning of logging mode 
....................       //RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
148BC:  BCF    F91.0
....................       spi_write(0x89); 
148BE:  MOVF   FC9,W
148C0:  MOVLW  89
148C2:  MOVWF  FC9
148C4:  RRCF   FC7,W
148C6:  BNC   148C4
....................       spi_write(0b11111111); 
148C8:  MOVF   FC9,W
148CA:  SETF   FC9
148CC:  RRCF   FC7,W
148CE:  BNC   148CC
....................       spi_read(0x00); 
148D0:  MOVF   FC9,W
148D2:  CLRF   FC9
148D4:  RRCF   FC7,W
148D6:  BNC   148D4
....................       output_bit(RTC_CS, DISABLE); 
148D8:  BSF    F91.0
....................        
....................       MaxSamples=FALSE; 
148DA:  CLRF   34
148DC:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
148DE:  MOVLW  28
148E0:  MOVLB  8
148E2:  MOVWF  xA2
148E4:  MOVFF  33,8A3
148E8:  MOVLB  0
148EA:  CALL   33F6
....................       if (LoggingReentry != TRUE) 
148EE:  MOVLB  8
148F0:  DECFSZ x64,W
148F2:  BRA    148F6
148F4:  BRA    1490E
....................       { 
....................          nv_sample = 0; 
148F6:  CLRF   22
148F8:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
148FA:  MOVLW  16
148FC:  MOVWF  xCC
148FE:  MOVFF  22,8CE
14902:  MOVFF  21,8CD
14906:  MOVLB  0
14908:  CALL   4FAE
1490C:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
1490E:  CLRF   x64
....................       nv_macro_step = 0; 
14910:  CLRF   38
14912:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
14914:  MOVLW  3A
14916:  MOVWF  xCC
14918:  MOVFF  38,8CE
1491C:  MOVFF  37,8CD
14920:  MOVLB  0
14922:  CALL   4FAE
....................       user_quit = auto_sample_ready(); 
14926:  BRA    14618
14928:  MOVFF  01,50
....................    } 
1492C:  BRA    14932
....................    else cmd_arg(); 
1492E:  CALL   BCC2
....................     
....................    busy_clear(); 
14932:  CALL   AE16
14936:  GOTO   14DE6 (RETURN)
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
....................       nv_max_samples = arg; 
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
....................    } 
....................    else if(arg == 0) { 
....................       nv_sample = 0; 
....................       write16(ADDR_SAMPLE, nv_sample); 
....................       nv_macro_step = 0; 
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
....................    { 
....................       bus_on(); 
....................       open_pipe(); 
....................       bus_off(); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
....................       if(e_mode[motor]==2){     // if port mode then move 
....................          switch (nv_product){ 
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
....................                break;             
....................             case WMS4: command_move(0,0,1); 
....................                break; 
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
....................                break; 
....................          } 
....................       } 
....................       else cmd_err();                           // else error 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
....................       nv_port = arg; 
....................       write16(ADDR_PORT, nv_port); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
....................       case ECO : commandPe(); 
....................          break; 
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
....................          break; 
....................       case AWS : commandPa(); 
....................          break;          
....................    } 
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
....................     
....................       if(arg<33){ 
....................          valve=arg;    
....................          sol_switch(valve); 
....................       }  
....................       else cmd_arg(); 
....................    } 
....................    else cmd_err(); 
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
....................       nv_port = arg; 
....................       write16(ADDR_SAMPLE, nv_port); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
....................          break; 
....................       case AWS : commandQa(); 
....................          break;          
....................    } 
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
....................     
....................    nv_macro_step = 0; 
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
....................     
....................    user_quit = FALSE; 
....................     
....................    if (arg > 0 && arg < 3501){ 
....................       samples = arg; 
....................       user_quit = FALSE; 
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
....................          macro_cmd = master_macro_eco(); 
....................          if (macro_cmd == ';') break; 
....................       } 
....................    } 
....................     
....................    busy_clear(); 
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
....................       n=arg; 
....................       port=2; 
....................       for(i=0;i<n;++i){ 
....................          play_wms_hard_macro(port); 
....................          ++port; 
....................       } 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
....................     
....................    nv_macro_step = 0; 
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
....................     
....................    user_quit = FALSE; 
....................     
....................    if (arg > 0 && arg < 241){ 
....................       samples = arg; 
....................       user_quit = FALSE; 
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
....................          macro_cmd = master_macro_aws(count+1); 
....................          ++nv_sample;                     // increment sample number 
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
....................       } 
....................    } 
....................     
....................    busy_clear(); 
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
....................       case ECO : commandRe(); 
....................          break; 
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
....................          break; 
....................       case AWS : commandRa(); 
....................          break;          
....................    } 
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
....................     
....................    switch(arg){ 
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
....................       } 
....................       else if(nv_det_type==2 || nv_det_type==3) 
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
....................       } 
....................       break;                                                        //200 scans,don't store,display 
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
....................       break; 
....................    default: cmd_arg(); 
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
....................       nv_sample = arg; 
....................       write16(ADDR_SAMPLE, nv_sample); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
....................       setting = arg; 
....................       sol_switch_cmd(setting); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
....................       case ECO : commandSe(); 
....................          break; 
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
....................          break; 
....................       case AWS : commandSa(); 
....................          break;          
....................    } 
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
....................    fputc('>',COM_A); 
....................    RTCfmt=fgetc(COM_A); 
....................    if (com_echo == TRUE) 
....................       { 
....................       fputc(RTCfmt,COM_A); 
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
....................        write16(ADDR_RTCfmt, RTCfmt); 
....................       }  
....................    else cmd_arg(); 
....................     
....................    if(arg == 1) 
....................    { 
....................       RTC_Set(); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
....................       macro = arg; 
....................       upload_macro(macro);    
....................    }    
....................    else if (arg == 5525){ 
....................       write_blank_macros(); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
....................       macro = arg;  
....................       read_macro(macro); 
....................    }    
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
....................       //fprintf(COM_A,"1\r\n"); 
....................       RTC_alarm(); 
....................       //fprintf(COM_A,"2\r\n"); 
....................       RTC_late(); 
....................       //fprintf(COM_A,"3\r\n"); 
....................       RTC_alarm_status(); 
....................       //fprintf(COM_A,"4\r\n"); 
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
....................          break; 
....................       default: cmd_arg(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
....................     
....................    switch(arg){ 
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
....................                bus_pwr_status=0; 
....................          break; 
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
....................                bus_pwr_status=1; 
....................          break; 
....................       case 20: output_bit(VMOT,OFF); 
....................          break; 
....................       case 21: output_bit(VMOT,ON); 
....................          break; 
....................       case 30: output_bit(VENC1,OFF); 
....................          break; 
....................       case 31: output_bit(VENC1,ON); 
....................          break; 
....................       case 40: output_bit(VENC2,OFF); 
....................          break; 
....................       case 41: output_bit(VENC2,ON); 
....................          break; 
....................       case 50: output_bit(VHBRDG,OFF); 
....................          break; 
....................       case 51: output_bit(VHBRDG,ON); 
....................          break;          
....................       case 60: set_heaters(0); 
....................          break; 
....................       case 61: set_heaters(3); 
....................          break; 
....................       default : cmd_arg(); 
....................          break;          
....................    } 
....................     
....................    busy_clear(); 
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
*
0BCE0:  MOVF   48,F
0BCE2:  BNZ   BCFC
0BCE4:  MOVF   49,F
0BCE6:  BNZ   BCFC
0BCE8:  MOVF   4A,F
0BCEA:  BNZ   BCFC
0BCEC:  MOVF   4B,F
0BCEE:  BNZ   BCFC
....................       motor_sleep_rdy(); 
0BCF0:  CALL   2976
....................       shutdown(); 
0BCF4:  CALL   AF54
....................       go_to_sleep(); 
0BCF8:  RCALL  BCA4
....................    } 
0BCFA:  BRA    BCFE
....................    else cmd_arg(); 
0BCFC:  RCALL  BCC2
0BCFE:  GOTO   14DB4 (RETURN)
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
....................       m_bklsh[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_c(){ 
....................    if(arg == 0){ 
....................       output_bit(PIN_J7,0); 
....................    }else if(arg == 1){ 
....................       output_bit(PIN_J7,1); 
....................    }else{ 
....................       RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
....................       spi_write(0x89); 
....................       spi_write(arg); 
....................       output_bit(RTC_CS, DISABLE); 
....................    } 
.................... } 
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
....................       m_pos_dir[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
....................       e_cpr[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
....................       m_gb_err[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
....................       hold_pc=arg; 
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
....................       m_stp_int[motor] = (arg/100); 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
....................       m_run[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
....................       e_mode[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
....................       m_mode[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
....................       e_index[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
....................        evn_so[motor] = arg; 
....................        switch(motor){ 
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
....................       e_ppr[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
....................       switch (nv_product) { 
....................          case ECO : rst_step_vars_eco(); 
....................             break; 
....................          case WMS4 : rst_step_vars_wms4(); 
....................             break; 
....................          case AWS : rst_step_vars_aws(); 
....................             break;             
....................          case WMS2 : rst_step_vars_wms2(); 
....................             break; 
....................       } 
....................    }  
....................    else cmd_arg(); 
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
....................       m_spr[motor] = arg; 
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
....................       e_type[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... //currently used to test dio pins 
.................... void command_v(){ 
....................    if(arg == 00){ 
*
10C94:  MOVF   48,F
10C96:  BNZ   10CA8
10C98:  MOVF   49,F
10C9A:  BNZ   10CA8
10C9C:  MOVF   4A,F
10C9E:  BNZ   10CA8
10CA0:  MOVF   4B,F
10CA2:  BNZ   10CA8
....................       output_bit(PIN_D0,0); 
10CA4:  BCF    F8C.0
....................    }else if(arg == 01){ 
10CA6:  BRA    10DEE
10CA8:  DECFSZ 48,W
10CAA:  BRA    10CBC
10CAC:  MOVF   49,F
10CAE:  BNZ   10CBC
10CB0:  MOVF   4A,F
10CB2:  BNZ   10CBC
10CB4:  MOVF   4B,F
10CB6:  BNZ   10CBC
....................       output_bit(PIN_D0,1); 
10CB8:  BSF    F8C.0
....................    }else if(arg == 10){ 
10CBA:  BRA    10DEE
10CBC:  MOVF   48,W
10CBE:  SUBLW  0A
10CC0:  BNZ   10CD2
10CC2:  MOVF   49,F
10CC4:  BNZ   10CD2
10CC6:  MOVF   4A,F
10CC8:  BNZ   10CD2
10CCA:  MOVF   4B,F
10CCC:  BNZ   10CD2
....................       output_bit(PIN_D1,0); 
10CCE:  BCF    F8C.1
....................    }else if(arg == 11){ 
10CD0:  BRA    10DEE
10CD2:  MOVF   48,W
10CD4:  SUBLW  0B
10CD6:  BNZ   10CE8
10CD8:  MOVF   49,F
10CDA:  BNZ   10CE8
10CDC:  MOVF   4A,F
10CDE:  BNZ   10CE8
10CE0:  MOVF   4B,F
10CE2:  BNZ   10CE8
....................       output_bit(PIN_D1,1); 
10CE4:  BSF    F8C.1
....................    }else if(arg == 20){ 
10CE6:  BRA    10DEE
10CE8:  MOVF   48,W
10CEA:  SUBLW  14
10CEC:  BNZ   10CFE
10CEE:  MOVF   49,F
10CF0:  BNZ   10CFE
10CF2:  MOVF   4A,F
10CF4:  BNZ   10CFE
10CF6:  MOVF   4B,F
10CF8:  BNZ   10CFE
....................       output_bit(PIN_D2,0); 
10CFA:  BCF    F8C.2
....................    }else if(arg == 21){ 
10CFC:  BRA    10DEE
10CFE:  MOVF   48,W
10D00:  SUBLW  15
10D02:  BNZ   10D14
10D04:  MOVF   49,F
10D06:  BNZ   10D14
10D08:  MOVF   4A,F
10D0A:  BNZ   10D14
10D0C:  MOVF   4B,F
10D0E:  BNZ   10D14
....................       output_bit(PIN_D2,1); 
10D10:  BSF    F8C.2
....................    }else if(arg == 30){ 
10D12:  BRA    10DEE
10D14:  MOVF   48,W
10D16:  SUBLW  1E
10D18:  BNZ   10D2A
10D1A:  MOVF   49,F
10D1C:  BNZ   10D2A
10D1E:  MOVF   4A,F
10D20:  BNZ   10D2A
10D22:  MOVF   4B,F
10D24:  BNZ   10D2A
....................       output_bit(PIN_D3,0); 
10D26:  BCF    F8C.3
....................    }else if(arg == 31){ 
10D28:  BRA    10DEE
10D2A:  MOVF   48,W
10D2C:  SUBLW  1F
10D2E:  BNZ   10D40
10D30:  MOVF   49,F
10D32:  BNZ   10D40
10D34:  MOVF   4A,F
10D36:  BNZ   10D40
10D38:  MOVF   4B,F
10D3A:  BNZ   10D40
....................       output_bit(PIN_D3,1); 
10D3C:  BSF    F8C.3
....................    }else if(arg == 40){ 
10D3E:  BRA    10DEE
10D40:  MOVF   48,W
10D42:  SUBLW  28
10D44:  BNZ   10D56
10D46:  MOVF   49,F
10D48:  BNZ   10D56
10D4A:  MOVF   4A,F
10D4C:  BNZ   10D56
10D4E:  MOVF   4B,F
10D50:  BNZ   10D56
....................       output_bit(PIN_D4,0); 
10D52:  BCF    F8C.4
....................    }else if(arg == 41){ 
10D54:  BRA    10DEE
10D56:  MOVF   48,W
10D58:  SUBLW  29
10D5A:  BNZ   10D6C
10D5C:  MOVF   49,F
10D5E:  BNZ   10D6C
10D60:  MOVF   4A,F
10D62:  BNZ   10D6C
10D64:  MOVF   4B,F
10D66:  BNZ   10D6C
....................       output_bit(PIN_D4,1); 
10D68:  BSF    F8C.4
....................    }else if(arg == 50){ 
10D6A:  BRA    10DEE
10D6C:  MOVF   48,W
10D6E:  SUBLW  32
10D70:  BNZ   10D82
10D72:  MOVF   49,F
10D74:  BNZ   10D82
10D76:  MOVF   4A,F
10D78:  BNZ   10D82
10D7A:  MOVF   4B,F
10D7C:  BNZ   10D82
....................       output_bit(PIN_D5,0); 
10D7E:  BCF    F8C.5
....................    }else if(arg == 51){ 
10D80:  BRA    10DEE
10D82:  MOVF   48,W
10D84:  SUBLW  33
10D86:  BNZ   10D98
10D88:  MOVF   49,F
10D8A:  BNZ   10D98
10D8C:  MOVF   4A,F
10D8E:  BNZ   10D98
10D90:  MOVF   4B,F
10D92:  BNZ   10D98
....................       output_bit(PIN_D5,1); 
10D94:  BSF    F8C.5
....................    }else if(arg == 60){ 
10D96:  BRA    10DEE
10D98:  MOVF   48,W
10D9A:  SUBLW  3C
10D9C:  BNZ   10DAE
10D9E:  MOVF   49,F
10DA0:  BNZ   10DAE
10DA2:  MOVF   4A,F
10DA4:  BNZ   10DAE
10DA6:  MOVF   4B,F
10DA8:  BNZ   10DAE
....................       output_bit(PIN_D6,0); 
10DAA:  BCF    F8C.6
....................    }else if(arg == 61){ 
10DAC:  BRA    10DEE
10DAE:  MOVF   48,W
10DB0:  SUBLW  3D
10DB2:  BNZ   10DC4
10DB4:  MOVF   49,F
10DB6:  BNZ   10DC4
10DB8:  MOVF   4A,F
10DBA:  BNZ   10DC4
10DBC:  MOVF   4B,F
10DBE:  BNZ   10DC4
....................       output_bit(PIN_D6,1); 
10DC0:  BSF    F8C.6
....................    }else if(arg == 70){ 
10DC2:  BRA    10DEE
10DC4:  MOVF   48,W
10DC6:  SUBLW  46
10DC8:  BNZ   10DDA
10DCA:  MOVF   49,F
10DCC:  BNZ   10DDA
10DCE:  MOVF   4A,F
10DD0:  BNZ   10DDA
10DD2:  MOVF   4B,F
10DD4:  BNZ   10DDA
....................       output_bit(PIN_D7,0); 
10DD6:  BCF    F8C.7
....................    }else if(arg == 71){ 
10DD8:  BRA    10DEE
10DDA:  MOVF   48,W
10DDC:  SUBLW  47
10DDE:  BNZ   10DEE
10DE0:  MOVF   49,F
10DE2:  BNZ   10DEE
10DE4:  MOVF   4A,F
10DE6:  BNZ   10DEE
10DE8:  MOVF   4B,F
10DEA:  BNZ   10DEE
....................       output_bit(PIN_D7,1); 
10DEC:  BSF    F8C.7
....................    } 
10DEE:  RETURN 0
.................... } 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
....................       drive_pc=arg; 
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
....................        align_os[motor] = arg; 
....................        switch(motor){ 
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
....................       m_ctrl[motor] = arg; 
....................       switch(motor){ 
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
....................             break; 
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();    
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
....................       case 1: motor = 0; 
....................          break; 
....................       case 2: motor = 1; 
....................          break; 
....................       default : cmd_arg(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
....................       switch(arg){ 
....................          case 1 : e_pos[0] = 0; 
....................                   write16(ADDR_E1_POS, 0); 
....................             break; 
....................          case 2 : e_pos[1] = 0; 
....................                   write16(ADDR_E2_POS, 0); 
....................             break;             
....................       } 
....................    } 
....................    else cmd_arg();  
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
....................       step_us  =   m_stp_int[0]*100; 
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
....................       step_us  =   m_stp_int[1]*100; 
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
....................    } 
....................    else cmd_arg(); 
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
....................       case 5525 : nv_product = ECO; 
....................                   write16(ADDR_PRODUCT, ECO); 
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
....................                   record_event(); 
....................          break; 
....................       case 5526 : nv_product = WMS4; 
....................                   write16(ADDR_PRODUCT, WMS4); 
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
....................                   record_event();                   
....................          break;    
....................       case 5527 : nv_product = AWS; 
....................                   write16(ADDR_PRODUCT, AWS); 
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
....................                   record_event();                   
....................          break;   
....................       case 5528 : nv_product = WMS2; 
....................                   write16(ADDR_PRODUCT, WMS2); 
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
....................                   record_event();                   
....................          break;            
....................    } 
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
....................       case 0 : kill_wd(); 
....................          break; 
....................       case 1 : start_heartbeat(); 
....................          break; 
....................       case 2 : suspend_heartbeat(); 
....................          break; 
....................       default : cmd_arg(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
....................       case 0:     signon(); 
....................                   fprintf(COM_A, __DATE__); 
....................                   fprintf(COM_A, "\r\n"); 
....................                   fprintf(COM_A, __TIME__); 
....................                   fprintf(COM_A, "\r\n"); 
....................          break; 
....................       case 5525 : kill_wd(); 
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
....................                   load_program(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
....................       case 0 : cmd_set=0;  // user 
....................          break; 
....................       case 1 : cmd_set=1;  // full 
....................          break; 
....................    } 
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
....................     
....................    switch (cmd) 
....................    { 
....................       case '&': commandFW(); 
....................          break; 
....................       case '#': command_hash(); 
....................          break;          
....................       case '%': command_prod(); 
....................          break; 
....................       case '*': command_star(); 
....................          break;       
....................       // standard commands 
....................       case '/': command_addr(); 
....................          break; 
....................       case 'A': commandA(); 
....................          break; 
....................       case 'B': commandB(); 
....................          break; 
....................       case 'C': commandC(); 
....................          break; 
....................       case 'D': commandD(); 
....................          break; 
....................       case 'E': commandE(); 
....................          break;          
....................       case 'F': commandF(); 
....................          break;          
....................       case 'G': commandG(); 
....................          break; 
....................       case 'H': commandH(); 
....................          break; 
....................       case 'I': commandI(); 
....................          break;    
....................       case 'J': commandJ(); 
....................          break;      
....................       case 'K': commandK(); 
....................          break;    
....................       case 'L': commandL(); 
....................          break;             
....................       case 'M': commandM(FALSE); 
....................          break;   
....................       case 'N': commandN(); 
....................          break;          
....................       case 'O': commandO(); 
....................          break;    
....................       case 'P': commandP(); 
....................          break;  
....................       case 'Q': commandQ(); 
....................          break;              
....................       case 'R': commandR(); 
....................          break;    
....................       case 'S': commandS(); 
....................          break;  
....................       case 'T': commandT(); 
....................          break;            
....................       case 'U': commandU(); 
....................          break;           
....................       case 'V': commandV(); 
....................          break; 
....................       case 'W': commandW(); 
....................          break; 
....................       case 'X': commandX(); 
....................          break; 
....................       case 'Y': commandY(); 
....................          break;  
....................       case 'Z': commandZ(); 
....................          break;    
....................       // stepper 
....................       case '^': command_set(); 
....................          break;       
....................       case '+': if(m_fixed==1) motor=1; 
....................                 command_move(0,0,1); 
....................          break; 
....................       case '-': if(m_fixed==1) motor=1; 
....................                 command_move(0,1,1); 
....................          break; 
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
....................          break;     
....................       case 'b': command_b(); 
....................          break; 
....................       case 'c': command_c(); 
....................          break; 
....................       case 'd': command_d(); 
....................          break;          
....................       case 'e': command_e(); 
....................          break;       
....................       case 'f': command_f(); 
....................          break; 
....................       case 'g': command_g(); 
....................          break;          
....................       case 'h': command_h(); 
....................          break; 
....................       case 'i': command_i(); 
....................          break;   
....................       case 'j': command_j(); 
....................          break;           
....................       case 'k': command_k(); 
....................          break;          
....................       case 'l': step_var_list(); 
....................          break;          
....................       case 'm': command_m(); 
....................          break;    
....................       case 'n': command_n(); 
....................          break; 
....................       case 'o': command_o(); 
....................          break;    
....................       case 'p': command_p(); 
....................          break;   
....................       case 'q': command_q(); 
....................          break; 
....................       case 'r': command_r(); 
....................          break;    
....................       case 's': command_s(); 
....................          break;           
....................       case 't': command_t(); 
....................          break;          
....................       case 'u': command_u(); 
....................          break; 
....................       case 'v': command_v(); 
....................          break; 
....................       case 'w': command_w(); 
....................          break; 
....................       case 'x': command_x(); 
....................          break;    
....................       case 'y': command_y(); 
....................          break;  
....................       case 'z': command_z(); 
....................          break;           
....................    } 
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... #define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c" 
.................... #define BYTE_TO_BINARY(byte)  \ 
....................   (byte & 0x80 ? '1' : '0'), \ 
....................   (byte & 0x40 ? '1' : '0'), \ 
....................   (byte & 0x20 ? '1' : '0'), \ 
....................   (byte & 0x10 ? '1' : '0'), \ 
....................   (byte & 0x08 ? '1' : '0'), \ 
....................   (byte & 0x04 ? '1' : '0'), \ 
....................   (byte & 0x02 ? '1' : '0'), \ 
....................   (byte & 0x01 ? '1' : '0')  
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
....................    return(valid); 
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
....................    else fputs("@INV", COM_A); 
.................... } 
....................  
.................... void command_prompt(){ 
*
0AE26:  MOVLB  8
0AE28:  CLRF   x64
0AE2A:  CLRF   x65
....................    int8 i = 0; 
....................    char temp = 0; 
....................    char input_string[30]; 
....................    char blank_string[30]; 
....................    for(i = 0; i<30; i++){ 
0AE2C:  CLRF   x64
0AE2E:  MOVF   x64,W
0AE30:  SUBLW  1D
0AE32:  BNC   AE58
....................       input_string[i] = 0; 
0AE34:  CLRF   03
0AE36:  MOVF   x64,W
0AE38:  ADDLW  66
0AE3A:  MOVWF  FE9
0AE3C:  MOVLW  08
0AE3E:  ADDWFC 03,W
0AE40:  MOVWF  FEA
0AE42:  CLRF   FEF
....................       blank_string[i] = 0; 
0AE44:  CLRF   03
0AE46:  MOVF   x64,W
0AE48:  ADDLW  84
0AE4A:  MOVWF  FE9
0AE4C:  MOVLW  08
0AE4E:  ADDWFC 03,W
0AE50:  MOVWF  FEA
0AE52:  CLRF   FEF
0AE54:  INCF   x64,F
0AE56:  BRA    AE2E
....................    } 
....................    i = 0; 
0AE58:  CLRF   x64
....................     
....................    nv_cmd_mode = TRUE; 
0AE5A:  CLRF   32
0AE5C:  MOVLW  01
0AE5E:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
0AE60:  MOVLW  02
0AE62:  MOVWF  xA2
0AE64:  MOVFF  31,8A3
0AE68:  MOVLB  0
0AE6A:  CALL   33F6
....................     
....................    fputs("@CMD", COM_A); 
0AE6E:  MOVLW  F4
0AE70:  MOVWF  FF6
0AE72:  MOVLW  27
0AE74:  MOVWF  FF7
0AE76:  MOVLW  00
0AE78:  MOVWF  FF8
0AE7A:  BRA    ADEA
0AE7C:  MOVLW  0D
0AE7E:  BTFSS  F9E.4
0AE80:  BRA    AE7E
0AE82:  MOVWF  FAD
0AE84:  MOVLW  0A
0AE86:  BTFSS  F9E.4
0AE88:  BRA    AE86
0AE8A:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
0AE8C:  MOVLW  01
0AE8E:  MOVWF  1E
0AE90:  MOVLW  A7
0AE92:  MOVWF  1D
0AE94:  MOVLW  FA
0AE96:  MOVWF  FF6
0AE98:  MOVLW  27
0AE9A:  MOVWF  FF7
0AE9C:  MOVLW  00
0AE9E:  MOVWF  FF8
0AEA0:  CALL   5098
....................    record_event(); 
0AEA4:  CALL   847A
....................     
....................    busy_clear(); 
0AEA8:  RCALL  AE16
....................     
....................    cmd_set=0; // user 
0AEAA:  CLRF   51
....................     
....................    do { 
....................       fputc('>',COM_A); 
0AEAC:  MOVLW  3E
0AEAE:  RCALL  AE1E
....................        
....................       while(temp != CARRIAGE_RET){ 
0AEB0:  MOVLB  8
0AEB2:  MOVF   x65,W
0AEB4:  SUBLW  0D
0AEB6:  BZ    AF42
....................          temp = fgetc(COM_A); 
0AEB8:  MOVLB  0
0AEBA:  CALL   0E62
0AEBE:  MOVFF  01,865
....................          if(temp != 8){ 
0AEC2:  MOVLB  8
0AEC4:  MOVF   x65,W
0AEC6:  SUBLW  08
0AEC8:  BZ    AEEC
....................          if (com_echo == TRUE) 
0AECA:  DECFSZ 4C,W
0AECC:  BRA    AED6
....................          { 
....................             fputc(temp,COM_A); 
0AECE:  MOVF   x65,W
0AED0:  MOVLB  0
0AED2:  RCALL  AE1E
0AED4:  MOVLB  8
....................          } 
....................          input_string[i] = temp; 
0AED6:  CLRF   03
0AED8:  MOVF   x64,W
0AEDA:  ADDLW  66
0AEDC:  MOVWF  FE9
0AEDE:  MOVLW  08
0AEE0:  ADDWFC 03,W
0AEE2:  MOVWF  FEA
0AEE4:  MOVFF  865,FEF
....................          i++; 
0AEE8:  INCF   x64,F
....................          }else{ 
0AEEA:  BRA    AF40
....................             if(i != 0){ 
0AEEC:  MOVF   x64,F
0AEEE:  BZ    AF40
....................                input_string[i-1] = 0; 
0AEF0:  MOVLW  01
0AEF2:  SUBWF  x64,W
0AEF4:  CLRF   03
0AEF6:  ADDLW  66
0AEF8:  MOVWF  FE9
0AEFA:  MOVLW  08
0AEFC:  ADDWFC 03,W
0AEFE:  MOVWF  FEA
0AF00:  CLRF   FEF
....................                i--; 
0AF02:  DECF   x64,F
....................                fputc('\r',COM_A); 
0AF04:  MOVLW  0D
0AF06:  MOVLB  0
0AF08:  RCALL  AE1E
....................                fprintf(COM_A,"                                       "); 
0AF0A:  MOVLW  0C
0AF0C:  MOVWF  FF6
0AF0E:  MOVLW  28
0AF10:  MOVWF  FF7
0AF12:  MOVLW  00
0AF14:  MOVWF  FF8
0AF16:  CLRF   1B
0AF18:  BTFSC  FF2.7
0AF1A:  BSF    1B.7
0AF1C:  BCF    FF2.7
0AF1E:  CALL   0E78
0AF22:  BTFSC  1B.7
0AF24:  BSF    FF2.7
....................                fputc('\r',COM_A); 
0AF26:  MOVLW  0D
0AF28:  RCALL  AE1E
....................                fprintf(COM_A,">"); 
0AF2A:  MOVLW  3E
0AF2C:  BTFSS  F9E.4
0AF2E:  BRA    AF2C
0AF30:  MOVWF  FAD
....................                fprintf(COM_A,input_string); 
0AF32:  MOVLW  08
0AF34:  MOVWF  FEA
0AF36:  MOVLW  66
0AF38:  MOVWF  FE9
0AF3A:  CALL   793C
0AF3E:  MOVLB  8
....................                 
....................             } 
....................          } 
0AF40:  BRA    AEB2
....................       } 
....................        
....................        
....................           
....................       /*if(cmd != 8){ 
....................          temp_cmd = cmd; 
....................          if (com_echo == TRUE) 
....................          { 
....................             fputc(cmd,COM_A); 
....................          } 
....................          if (cmd == '?') msg_busy(); 
....................          else proc_cmd(); 
....................       }else{ 
....................          if(temp_cmd != 0){ 
....................             fprintf(COM_A,"\r\n>%c",temp_cmd); 
....................          } 
....................       } 
....................       //restart_wdt();*/ 
....................    } while(nv_cmd_mode == TRUE); 
0AF42:  DECFSZ 31,W
0AF44:  BRA    AF50
0AF46:  MOVF   32,F
0AF48:  BTFSS  FD8.2
0AF4A:  BRA    AF50
0AF4C:  MOVLB  0
0AF4E:  BRA    AEAC
0AF50:  MOVLB  0
0AF52:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void command_prompt2() 
.................... { 
....................    //disable_interrupts(INT_EXT); 
....................    char temp_cmd = 0; 
....................    nv_cmd_mode = TRUE; 
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
....................     
....................    fputs("@CMD", COM_A); 
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
....................    record_event(); 
....................     
....................    busy_clear(); 
....................     
....................    cmd_set=0; // user 
....................     
....................    do { 
....................       fputc('>',COM_A); 
....................       cmd=fgetc(COM_A); 
....................          temp_cmd = cmd; 
....................          if (com_echo == TRUE) 
....................          { 
....................             fputc(cmd,COM_A); 
....................          } 
....................          if (cmd == '?') msg_busy(); 
....................          else proc_cmd(); 
....................       //restart_wdt(); 
....................    } while(nv_cmd_mode == TRUE); 
.................... } 
....................  
....................  
.................... void main() 
*
1493A:  CLRF   FF8
1493C:  BCF    FD0.7
1493E:  BSF    07.7
14940:  MOVLW  70
14942:  MOVWF  FD3
14944:  MOVLW  40
14946:  MOVWF  F9B
14948:  CLRF   F64
1494A:  CLRF   1C
1494C:  BSF    F65.3
1494E:  MOVWF  FAF
14950:  MOVLW  03
14952:  MOVWF  FD4
14954:  MOVLW  A6
14956:  MOVWF  FAC
14958:  MOVLW  90
1495A:  MOVWF  FAB
1495C:  MOVLB  F
1495E:  BSF    x20.3
14960:  MOVLW  82
14962:  MOVWF  x1E
14964:  MOVLW  06
14966:  MOVWF  x1F
14968:  MOVLW  A6
1496A:  MOVWF  x21
1496C:  MOVLW  90
1496E:  MOVWF  x22
14970:  BSF    F65.3
14972:  MOVLW  40
14974:  MOVWF  FAF
14976:  MOVLW  03
14978:  MOVWF  FD4
1497A:  MOVLW  A6
1497C:  MOVWF  FAC
1497E:  MOVLW  90
14980:  MOVWF  FAB
14982:  CLRF   1E
14984:  CLRF   1D
14986:  SETF   3A
14988:  SETF   39
1498A:  SETF   3C
1498C:  SETF   3B
1498E:  CLRF   46
14990:  MOVLW  01
14992:  MOVWF  45
14994:  MOVWF  4C
14996:  BCF    4D.0
14998:  BCF    4D.1
1499A:  BCF    4D.2
1499C:  MOVLB  0
1499E:  CLRF   x66
149A0:  MOVLB  2
149A2:  MOVWF  xD9
149A4:  MOVLB  3
149A6:  CLRF   x3B
149A8:  MOVLB  4
149AA:  CLRF   xE7
149AC:  MOVWF  xED
149AE:  MOVLW  04
149B0:  MOVLB  7
149B2:  MOVWF  x13
149B4:  MOVLW  EE
149B6:  MOVWF  x12
149B8:  CLRF   xCD
149BA:  MOVLB  8
149BC:  CLRF   x58
149BE:  CLRF   x57
149C0:  CLRF   x5C
149C2:  CLRF   x5B
149C4:  CLRF   x5A
149C6:  CLRF   x59
149C8:  CLRF   x60
149CA:  CLRF   x5F
149CC:  CLRF   x5E
149CE:  CLRF   x5D
149D0:  MOVLW  00
149D2:  MOVLB  F
149D4:  MOVWF  x23
149D6:  MOVWF  x24
149D8:  MOVWF  x25
149DA:  BCF    FC1.3
149DC:  BCF    FC1.4
149DE:  BCF    FC1.5
149E0:  CLRF   x2E
149E2:  CLRF   x2F
149E4:  CLRF   x54
149E6:  BRA    14AA8
149E8:  DATA 44,02
149EA:  DATA DD,20
149EC:  DATA 64,72
149EE:  DATA 61,77
149F0:  DATA 5F,61
149F2:  DATA 6C,6C
149F4:  DATA 2E,63
149F6:  DATA 73,76
149F8:  DATA 00,20
149FA:  DATA 64,72
149FC:  DATA 61,77
149FE:  DATA 5F,6E
14A00:  DATA 65,77
14A02:  DATA 2E,63
14A04:  DATA 73,76
14A06:  DATA 00,20
14A08:  DATA 64,72
14A0A:  DATA 65,6C
14A0C:  DATA 5F,61
14A0E:  DATA 6C,6C
14A10:  DATA 2E,63
14A12:  DATA 73,76
14A14:  DATA 00,20
14A16:  DATA 64,72
14A18:  DATA 65,6C
14A1A:  DATA 5F,6E
14A1C:  DATA 65,77
14A1E:  DATA 2E,63
14A20:  DATA 73,76
14A22:  DATA 00,20
14A24:  DATA 65,76
14A26:  DATA 65,6E
14A28:  DATA 74,73
14A2A:  DATA 2E,74
14A2C:  DATA 78,74
14A2E:  DATA 00,02
14A30:  DATA 03,39
14A32:  DATA 2C,00
14A34:  DATA 02,04
14A36:  DATA D8,00
14A38:  DATA 00,10
14A3A:  DATA 07,14
14A3C:  DATA 46,41
14A3E:  DATA 54,31
14A40:  DATA 32,46
14A42:  DATA 41,54
14A44:  DATA 31,36
14A46:  DATA 46,41
14A48:  DATA 54,33
14A4A:  DATA 32,00
14A4C:  DATA 57,07
14A4E:  DATA CE,0D
14A50:  DATA 0A,00
14A52:  DATA 00,03
14A54:  DATA 00,0F
14A56:  DATA 00,1B
14A58:  DATA 00,27
14A5A:  DATA 00,33
14A5C:  DATA 00,3F
14A5E:  DATA 00,4B
14A60:  DATA 00,57
14A62:  DATA 00,63
14A64:  DATA 00,6F
14A66:  DATA 00,7B
14A68:  DATA 00,87
14A6A:  DATA 00,93
14A6C:  DATA 00,9F
14A6E:  DATA 00,AB
14A70:  DATA 00,B7
14A72:  DATA 00,C3
14A74:  DATA 48,B1
14A76:  DATA 70,D4
14A78:  DATA 98,F7
14A7A:  DATA C0,1A
14A7C:  DATA 00,CF
14A7E:  DATA 28,F2
14A80:  DATA 50,15
14A82:  DATA 78,38
14A84:  DATA A0,5B
14A86:  DATA C8,7E
14A88:  DATA F0,A1
14A8A:  DATA 18,C5
14A8C:  DATA 40,E8
14A8E:  DATA 68,0B
14A90:  DATA 90,2E
14A92:  DATA B8,51
14A94:  DATA E0,74
14A96:  DATA 08,98
14A98:  DATA 30,BB
14A9A:  DATA 58,DE
14A9C:  DATA 80,01
14A9E:  DATA A8,24
14AA0:  DATA D0,47
14AA2:  DATA F8,6A
14AA4:  DATA 20,8E
14AA6:  DATA 00,00
14AA8:  MOVLW  01
14AAA:  MOVWF  FF8
14AAC:  MOVLW  49
14AAE:  MOVWF  FF7
14AB0:  MOVLW  E8
14AB2:  MOVWF  FF6
14AB4:  TBLRD*+
14AB6:  MOVF   FF5,W
14AB8:  MOVWF  00
14ABA:  XORLW  00
14ABC:  BZ    14AE4
14ABE:  TBLRD*+
14AC0:  MOVF   FF5,W
14AC2:  MOVWF  01
14AC4:  BTFSC  FE8.7
14AC6:  BRA    14AD2
14AC8:  ANDLW  0F
14ACA:  MOVWF  FEA
14ACC:  TBLRD*+
14ACE:  MOVFF  FF5,FE9
14AD2:  BTFSC  01.6
14AD4:  TBLRD*+
14AD6:  BTFSS  01.6
14AD8:  TBLRD*+
14ADA:  MOVFF  FF5,FEE
14ADE:  DCFSNZ 00,F
14AE0:  BRA    14AB4
14AE2:  BRA    14AD6
14AE4:  CLRF   FF8
14AE6:  MOVLB  8
14AE8:  CLRF   x61
14AEA:  CLRF   x63
14AEC:  CLRF   x62
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
14AEE:  BCF    FF2.6
14AF0:  BCF    FF2.7
14AF2:  BTFSC  FF2.7
14AF4:  BRA    14AF0
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
14AF6:  BCF    FC6.5
14AF8:  MOVLW  21
14AFA:  MOVWF  FC6
14AFC:  MOVLW  40
14AFE:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
14B00:  BCF    F67.5
14B02:  MOVLW  21
14B04:  MOVWF  F67
14B06:  MOVLW  40
14B08:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
14B0A:  MOVLW  00
14B0C:  MOVLB  F
14B0E:  MOVWF  x23
14B10:  MOVWF  x24
14B12:  MOVLW  1F
14B14:  MOVWF  x25
14B16:  BCF    FC1.3
14B18:  BSF    FC1.4
14B1A:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
14B1C:  MOVF   FC0,W
14B1E:  ANDLW  C0
14B20:  IORLW  07
14B22:  MOVWF  FC0
14B24:  BSF    FC0.7
14B26:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
14B28:  MOVLW  87
14B2A:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
14B2C:  MOVLW  37
14B2E:  MOVWF  FCD
14B30:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
14B32:  MOVLB  0
14B34:  GOTO   28CA
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
14B38:  CLRF   FB0
14B3A:  MOVLW  07
14B3C:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
14B3E:  MOVLW  04
14B40:  MOVLB  F
14B42:  MOVWF  x2E
14B44:  MOVWF  x2F
14B46:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
14B48:  MOVLW  70
14B4A:  MOVWF  FD3
14B4C:  MOVLW  40
14B4E:  MOVWF  F9B
14B50:  CLRF   F64
....................     
....................    //setup_wdt(WDT_4S); 
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
14B52:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
14B54:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
14B56:  MOVLB  0
14B58:  CALL   2906
....................  
....................    enable_interrupts(GLOBAL); 
14B5C:  MOVLW  C0
14B5E:  IORWF  FF2,F
....................     
....................     
....................  
....................    init_hardware(); 
14B60:  CALL   2916
....................    motor_sleep_rdy(); 
14B64:  CALL   2976
....................  
....................    sleep_mode = FALSE;    
14B68:  BCF    4D.1
....................    busy_set(); 
14B6A:  CALL   299E
....................     
....................    init_nv_vars(); 
14B6E:  GOTO   2A96
....................    get_step_vars(); 
14B72:  GOTO   2CFA
....................    init_aws(); 
14B76:  GOTO   30BE
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
14B7A:  CALL   30D8
....................    blink(); 
14B7E:  GOTO   30DE
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
14B82:  GOTO   312A
....................     
....................    RTC_read(); 
14B86:  CALL   3328
....................    RTC_last_power(); 
14B8A:  GOTO   3426
....................    RTC_reset_HT();   
14B8E:  CALL   3496
....................    RTC_read(); 
14B92:  CALL   3328
14B96:  CLRF   1B
14B98:  BTFSC  FF2.7
14B9A:  BSF    1B.7
14B9C:  BCF    FF2.7
....................    RTC_read_flags(); 
14B9E:  CALL   0E02
14BA2:  BTFSC  1B.7
14BA4:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
14BA6:  MOVF   3F,F
14BA8:  BNZ   14BAE
14BAA:  MOVF   40,F
14BAC:  BZ    14BFE
14BAE:  MOVLW  4C
14BB0:  MOVWF  FF6
14BB2:  MOVLW  28
14BB4:  MOVWF  FF7
14BB6:  MOVLW  00
14BB8:  MOVWF  FF8
14BBA:  CLRF   1B
14BBC:  BTFSC  FF2.7
14BBE:  BSF    1B.7
14BC0:  BCF    FF2.7
14BC2:  MOVLW  04
14BC4:  MOVLB  A
14BC6:  MOVWF  x19
14BC8:  MOVLB  0
14BCA:  CALL   104E
14BCE:  BTFSC  1B.7
14BD0:  BSF    FF2.7
14BD2:  MOVLW  10
14BD4:  MOVWF  FE9
14BD6:  CLRF   1B
14BD8:  BTFSC  FF2.7
14BDA:  BSF    1B.7
14BDC:  BCF    FF2.7
14BDE:  MOVFF  40,A1A
14BE2:  MOVFF  3F,A19
14BE6:  CALL   11D0
14BEA:  BTFSC  1B.7
14BEC:  BSF    FF2.7
14BEE:  MOVLW  0D
14BF0:  BTFSS  F9E.4
14BF2:  BRA    14BF0
14BF4:  MOVWF  FAD
14BF6:  MOVLW  0A
14BF8:  BTFSS  F9E.4
14BFA:  BRA    14BF8
14BFC:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
14BFE:  CALL   34EC
....................    sd_status = init_sdcard(); 
14C02:  CALL   5014
14C06:  MOVFF  01,2DC
....................    if(sd_status>0) msg_card_fail(); 
14C0A:  MOVLB  2
14C0C:  MOVF   xDC,F
14C0E:  BZ    14C18
14C10:  MOVLB  0
14C12:  CALL   505A
14C16:  MOVLB  2
....................    
....................     
....................     
....................    reset_event(); 
14C18:  MOVLB  0
14C1A:  GOTO   AB66
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
14C1E:  MOVLB  7
14C20:  MOVF   x96,F
14C22:  BNZ   14C30
14C24:  MOVF   x97,F
14C26:  BNZ   14C30
14C28:  MOVF   x98,F
14C2A:  BNZ   14C30
14C2C:  MOVF   x99,F
14C2E:  BZ    14C38
14C30:  MOVLB  0
14C32:  CALL   9CA2
14C36:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
14C38:  MOVF   xAF,F
14C3A:  BNZ   14CBE
14C3C:  MOVF   xB0,F
14C3E:  BNZ   14CBE
....................       e_port[0]=0; 
14C40:  CLRF   xC4
14C42:  CLRF   xC3
....................       write16(ADDR_E1_PORT,0); 
14C44:  MOVLW  AA
14C46:  MOVLB  8
14C48:  MOVWF  xCC
14C4A:  CLRF   xCE
14C4C:  CLRF   xCD
14C4E:  MOVLB  0
14C50:  CALL   4FAE
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
14C54:  MOVLW  56
14C56:  MOVWF  FF6
14C58:  MOVLW  28
14C5A:  MOVWF  FF7
14C5C:  MOVLW  00
14C5E:  MOVWF  FF8
14C60:  CLRF   1B
14C62:  BTFSC  FF2.7
14C64:  BSF    1B.7
14C66:  BCF    FF2.7
14C68:  MOVLW  05
14C6A:  MOVLB  A
14C6C:  MOVWF  x19
14C6E:  MOVLB  0
14C70:  CALL   104E
14C74:  BTFSC  1B.7
14C76:  BSF    FF2.7
14C78:  MOVLW  10
14C7A:  MOVWF  FE9
14C7C:  CLRF   1B
14C7E:  BTFSC  FF2.7
14C80:  BSF    1B.7
14C82:  BCF    FF2.7
14C84:  MOVFF  7B0,A1A
14C88:  MOVFF  7AF,A19
14C8C:  CALL   11D0
14C90:  BTFSC  1B.7
14C92:  BSF    FF2.7
14C94:  MOVLW  2C
14C96:  BTFSS  F9E.4
14C98:  BRA    14C96
14C9A:  MOVWF  FAD
14C9C:  MOVLW  10
14C9E:  MOVWF  FE9
14CA0:  MOVFF  7C4,8CF
14CA4:  MOVFF  7C3,8CE
14CA8:  CALL   8F84
14CAC:  MOVLW  0D
14CAE:  BTFSS  F9E.4
14CB0:  BRA    14CAE
14CB2:  MOVWF  FAD
14CB4:  MOVLW  0A
14CB6:  BTFSS  F9E.4
14CB8:  BRA    14CB6
14CBA:  MOVWF  FAD
14CBC:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
14CBE:  MOVF   xB1,F
14CC0:  BNZ   14D44
14CC2:  MOVF   xB2,F
14CC4:  BNZ   14D44
....................       m_lin_pos[1]=-1; 
14CC6:  SETF   xB6
14CC8:  SETF   xB5
....................       write16(ADDR_M2_LIN_POS, -1); 
14CCA:  MOVLW  B8
14CCC:  MOVLB  8
14CCE:  MOVWF  xCC
14CD0:  SETF   xCE
14CD2:  SETF   xCD
14CD4:  MOVLB  0
14CD6:  CALL   4FAE
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
14CDA:  MOVLW  66
14CDC:  MOVWF  FF6
14CDE:  MOVLW  28
14CE0:  MOVWF  FF7
14CE2:  MOVLW  00
14CE4:  MOVWF  FF8
14CE6:  CLRF   1B
14CE8:  BTFSC  FF2.7
14CEA:  BSF    1B.7
14CEC:  BCF    FF2.7
14CEE:  MOVLW  05
14CF0:  MOVLB  A
14CF2:  MOVWF  x19
14CF4:  MOVLB  0
14CF6:  CALL   104E
14CFA:  BTFSC  1B.7
14CFC:  BSF    FF2.7
14CFE:  MOVLW  10
14D00:  MOVWF  FE9
14D02:  CLRF   1B
14D04:  BTFSC  FF2.7
14D06:  BSF    1B.7
14D08:  BCF    FF2.7
14D0A:  MOVFF  7B2,A1A
14D0E:  MOVFF  7B1,A19
14D12:  CALL   11D0
14D16:  BTFSC  1B.7
14D18:  BSF    FF2.7
14D1A:  MOVLW  2C
14D1C:  BTFSS  F9E.4
14D1E:  BRA    14D1C
14D20:  MOVWF  FAD
14D22:  MOVLW  10
14D24:  MOVWF  FE9
14D26:  MOVFF  7B6,8CF
14D2A:  MOVFF  7B5,8CE
14D2E:  CALL   8F84
14D32:  MOVLW  0D
14D34:  BTFSS  F9E.4
14D36:  BRA    14D34
14D38:  MOVWF  FAD
14D3A:  MOVLW  0A
14D3C:  BTFSS  F9E.4
14D3E:  BRA    14D3C
14D40:  MOVWF  FAD
14D42:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
14D44:  MOVF   31,F
14D46:  BNZ   14DEA
14D48:  MOVF   32,F
14D4A:  BNZ   14DEA
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
14D4C:  MOVLW  76
14D4E:  MOVWF  FF6
14D50:  MOVLW  28
14D52:  MOVWF  FF7
14D54:  MOVLW  00
14D56:  MOVWF  FF8
14D58:  CLRF   1B
14D5A:  BTFSC  FF2.7
14D5C:  BSF    1B.7
14D5E:  BCF    FF2.7
14D60:  MOVLB  0
14D62:  CALL   0E78
14D66:  BTFSC  1B.7
14D68:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
14D6A:  MOVLB  8
14D6C:  MOVF   x63,F
14D6E:  BNZ   14D9E
14D70:  MOVF   x62,W
14D72:  SUBLW  63
14D74:  BNC   14D9E
14D76:  MOVF   x61,W
14D78:  SUBLW  1B
14D7A:  BZ    14D9E
....................       { 
....................          EscNum=TestForEsc(); 
14D7C:  MOVLB  0
14D7E:  GOTO   AD90
14D82:  MOVFF  01,861
....................          if(EscNum == ESCAPE) command_prompt(); 
14D86:  MOVLB  8
14D88:  MOVF   x61,W
14D8A:  SUBLW  1B
14D8C:  BNZ   14D96
14D8E:  MOVLB  0
14D90:  CALL   AE26
14D94:  MOVLB  8
....................          EscCount++; 
14D96:  INCF   x62,F
14D98:  BTFSC  FD8.2
14D9A:  INCF   x63,F
14D9C:  BRA    14D6C
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
14D9E:  DECFSZ 33,W
14DA0:  BRA    14DB6
14DA2:  MOVF   34,F
14DA4:  BNZ   14DB6
....................       { 
....................          arg=0; 
14DA6:  CLRF   4B
14DA8:  CLRF   4A
14DAA:  CLRF   49
14DAC:  CLRF   48
....................          commandZ(); 
14DAE:  MOVLB  0
14DB0:  GOTO   BCE0
14DB4:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
14DB6:  MOVLW  AE
14DB8:  MOVWF  FF6
14DBA:  MOVLW  28
14DBC:  MOVWF  FF7
14DBE:  MOVLW  00
14DC0:  MOVWF  FF8
14DC2:  CLRF   1B
14DC4:  BTFSC  FF2.7
14DC6:  BSF    1B.7
14DC8:  BCF    FF2.7
14DCA:  MOVLB  0
14DCC:  CALL   0E78
14DD0:  BTFSC  1B.7
14DD2:  BSF    FF2.7
....................       arg = 0; 
14DD4:  CLRF   4B
14DD6:  CLRF   4A
14DD8:  CLRF   49
14DDA:  CLRF   48
....................       commandM(TRUE); 
14DDC:  MOVLW  01
14DDE:  MOVLB  8
14DE0:  MOVWF  x64
14DE2:  MOVLB  0
14DE4:  BRA    1481A
....................    } 
14DE6:  BRA    14DF0
14DE8:  MOVLB  7
....................    else 
....................    { 
....................       /*int8 RTC_buffer = 0; 
....................       unsigned int8 a0 = 0; 
....................       unsigned int8 a1 = 0; 
....................       unsigned int8 a2 = 0; 
....................       unsigned int8 a3 = 0; 
....................       unsigned int8 a4 = 0; 
....................       unsigned int8 a5 = 0; 
....................       unsigned int8 a6 = 0; 
....................       unsigned int8 a7 = 0; 
....................       unsigned int8 a8 = 0; 
....................       unsigned int8 a9 = 0; 
....................       unsigned int8 a10 = 0; 
....................       unsigned int8 a11 = 0; 
....................        
....................       RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
....................       spi_write(0x89); 
....................       spi_write(0b11000011); 
....................       output_bit(RTC_CS, DISABLE); 
....................        
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x00); 
....................       a0 = RTC_buffer; 
....................       fprintf(COM_A,"crap: %u\r\n",RTC_buffer); 
....................       a1 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg0: %u\r\n",a1); 
....................       a2 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg1: %u\r\n",a2); 
....................       a3 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg2: %u\r\n",a3); 
....................       a4 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg3: %u\r\n",a4); 
....................       a5 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg4: %u\r\n",a5); 
....................       a6 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg5: %u\r\n",a6); 
....................       a7 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg6: %u\r\n",a7); 
....................       a8 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg7: %u\r\n",a8); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg8: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg9: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regA: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regB: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regC: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regD: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regE: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regF: %u\r\n",a9); 
....................        
....................       output_bit(RTC_CS, DISABLE);*/ 
....................     
....................       command_prompt(); 
14DEA:  MOVLB  0
14DEC:  CALL   AE26
....................    } 
....................  
....................    reset_cpu(); 
14DF0:  RESET
.................... } 
....................  
14DF2:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 2878   PUT NOBROWNOUT BORV18 ZPBORM NOWDT WDT1024
   Word  3: 8BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
